[
    {
        "title": "Maximum Candies Allocated to K Children",
        "question_content": "You are given a 0-indexed integer array candies. Each element in the array denotes a pile of candies of size candies[i]. You can divide each pile into any number of sub piles, but you cannot merge two piles together.\nYou are also given an integer k. You should allocate piles of candies to k children such that each child gets the same number of candies. Each child can take at most one pile of candies and some piles of candies may go unused.\nReturn the maximum number of candies each child can get.\n&nbsp;\nExample 1:\n\nInput: candies = [5,8,6], k = 3\nOutput: 5\nExplanation: We can divide candies[1] into 2 piles of size 5 and 3, and candies[2] into 2 piles of size 5 and 1. We now have five piles of candies of sizes 5, 5, 3, 5, and 1. We can allocate the 3 piles of size 5 to 3 children. It can be proven that each child cannot receive more than 5 candies.\n\nExample 2:\n\nInput: candies = [2,5], k = 11\nOutput: 0\nExplanation: There are 11 children but only 7 candies in total, so it is impossible to ensure each child receives at least one candy. Thus, each child gets no candy and the answer is 0.\n\n&nbsp;\nConstraints:\n\n\t1 <= candies.length <= 105\n\t1 <= candies[i] <= 107\n\t1 <= k <= 1012",
        "solutions": [
            {
                "id": 1908888,
                "title": "java-c-python-binary-search-with-explanation",
                "content": "# **Intuition**\\nBinary search\\n<br>\\n\\n# **Explanation**\\nAssume we want give each child `m` candies, for each pile of `candies[i]`,\\nwe can divide out at most `candies[i] / m` sub piles with each pile `m` candies.\\n\\nWe can sum up all the sub piles we can divide out, then compare with the `k` children.\\n\\nIf `k > sum`, \\nwe don\\'t allocate to every child, \\nsince the pile of `m` candidies it too big,\\nso we assign `right = m - 1`.\\n\\nIf `k <= sum`, \\nwe are able to allocate to every child, \\nsince the pile of `m` candidies is small enough\\nso we assign `left = m`.\\n\\nWe repeatly do this until `left == right`, and that\\'s the maximum number of candies each child can get.\\n<br>\\n\\n# **Tips**\\nTip1.  `left < right` Vs `left <= right`\\n\\nCheck all my solution, I keep using `left < right`.\\nThe easy but important approach: \\nfollow and upvote my codes,\\ntry to do the same.\\nyou\\'ll find all binary search is similar,\\nnever bother thinking it anymore.\\n\\nTip2. `mid = (left + right + 1) / 2` Vs `mid = (left + right) / 2`\\n\\n`mid = (left + right) / 2` to find **first** element valid\\n`mid = (left + right + 1) / 2 `to find **last** element valid\\n<br>\\n\\n# **Complexity**\\nTime `O(nlog10000000)`\\nSpace `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    public int maximumCandies(int[] A, long k) {\\n        int left = 0, right = 10_000_000;\\n        while (left < right) {\\n            long sum = 0;\\n            int mid = (left + right + 1) / 2;\\n            for (int a : A) {\\n                sum += a / mid;\\n            }\\n            if (k > sum)\\n                right = mid - 1;\\n            else\\n                left = mid;\\n        }\\n        return left;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int maximumCandies(vector<int>& A, long long k) {\\n        int left = 0, right = 1e7;\\n        while (left < right) {\\n            long sum = 0, mid = (left + right + 1) / 2;\\n            for (int& a : A) {\\n                sum += a / mid;\\n            }\\n            if (k > sum)\\n                right = mid - 1;\\n            else\\n                left = mid;\\n        }\\n        return left;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def maximumCandies(self, A, k):\\n        left, right = 0, sum(A) / k\\n        while left < right:\\n            mid = (left + right + 1) / 2\\n            if k > sum(a / mid for a in A):\\n                right = mid - 1\\n            else:\\n                left = mid\\n        return left\\n```\\n<br>\\n\\n# More Good Binary Search Problems\\nHere are some similar binary search problems.\\nAlso find more explanations.\\nGood luck and have fun.\\n\\n- 2226. [Maximum Candies Allocated to K Children](https://leetcode.com/problems/maximum-candies-allocated-to-k-children/discuss/1908888/JavaC%2B%2BPython-Binary-Search-with-Explanation)\\n- 1802. [Maximum Value at a Given Index in a Bounded Array](https://leetcode.com/problems/maximum-value-at-a-given-index-in-a-bounded-array/discuss/1119801/Python-Binary-Search)\\n- 1539. [Kth Missing Positive Number](https://leetcode.com/problems/kth-missing-positive-number/discuss/779999/JavaC++Python-O(logN))\\n- 1482. [Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/discuss/686316/javacpython-binary-search)\\n- 1283. [Find the Smallest Divisor Given a Threshold](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/discuss/446376/javacpython-bianry-search)\\n- 1231. [Divide Chocolate](https://leetcode.com/problems/divide-chocolate/discuss/408503/Python-Binary-Search)\\n- 1011. [Capacity To Ship Packages In N Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/discuss/256729/javacpython-binary-search/)\\n- 875. [Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/discuss/152324/C++JavaPython-Binary-Search)\\n- 774. [Minimize Max Distance to Gas Station](https://leetcode.com/problems/minimize-max-distance-to-gas-station/discuss/113633/Easy-and-Concise-Solution-using-Binary-Search-C++JavaPython)\\n- 410. [Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/)\\n<br>\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int maximumCandies(int[] A, long k) {\\n        int left = 0, right = 10_000_000;\\n        while (left < right) {\\n            long sum = 0;\\n            int mid = (left + right + 1) / 2;\\n            for (int a : A) {\\n                sum += a / mid;\\n            }\\n            if (k > sum)\\n                right = mid - 1;\\n            else\\n                left = mid;\\n        }\\n        return left;\\n    }\\n```\n```cpp\\n    int maximumCandies(vector<int>& A, long long k) {\\n        int left = 0, right = 1e7;\\n        while (left < right) {\\n            long sum = 0, mid = (left + right + 1) / 2;\\n            for (int& a : A) {\\n                sum += a / mid;\\n            }\\n            if (k > sum)\\n                right = mid - 1;\\n            else\\n                left = mid;\\n        }\\n        return left;\\n    }\\n```\n```py\\n    def maximumCandies(self, A, k):\\n        left, right = 0, sum(A) / k\\n        while left < right:\\n            mid = (left + right + 1) / 2\\n            if k > sum(a / mid for a in A):\\n                right = mid - 1\\n            else:\\n                left = mid\\n        return left\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1908695,
                "title": "binary-search",
                "content": "Say we decide to allocate `m` candies. We can check if all `k` kids can get `m` candies in O(n).\\n\\nTherefore, we can binary-search for the maximum value `m`. The overall runtime complexity will be O(n * log m), where `m` is maximum number of candies in a single pile (10000000).\\n\\nThe fact that we can split piles could be confusing. But it simply means that we can distribute `m` candies to ` candies[i] / m` children from pile `i`.\\n\\n**C++**\\n```cpp    \\nint maximumCandies(vector<int>& candies, long long k) {\\n    int l = 0, r = 10000000;\\n    while(l < r) {\\n        long long m = (l + r + 1) / 2, cnt = 0;\\n        for (int i = 0; i < candies.size() && cnt < k; ++i)\\n            cnt += candies[i] / m;\\n        if (cnt >= k)\\n            l = m;\\n        else\\n            r = m - 1;\\n    }\\n    return l;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp    \\nint maximumCandies(vector<int>& candies, long long k) {\\n    int l = 0, r = 10000000;\\n    while(l < r) {\\n        long long m = (l + r + 1) / 2, cnt = 0;\\n        for (int i = 0; i < candies.size() && cnt < k; ++i)\\n            cnt += candies[i] / m;\\n        if (cnt >= k)\\n            l = m;\\n        else\\n            r = m - 1;\\n    }\\n    return l;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1908738,
                "title": "c-easy-solution-with-explanation",
                "content": "Lets see about the brute force solution.\\n\\nWe can check for candies=1,2 and so,on until we find an answer.\\n\\nCan\\'t we do something better,instead of linear search ?.\\n\\nYes, we can do **binary search.**\\n \\nIf we can divide the candies into piles containing x number of candies all the numbers below x,\\nwill also be satisfied.\\n\\nIn this question we have to find the maximum number of candies.\\n\\nLets see the lowest value is 1 and highest value as the maximum element in candies.\\n\\nNow we will find the mid, and we will check weather we can divide mid amount of candies into piles \\nsuch that they will be sufficient for k children.\\n\\nFinally we return the ans.\\n\\n```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    \\n    bool solve(vector<int>& v, ll mid, ll k){\\n        int n = v.size();\\n        ll cnt = 0;\\n        for(int i=0;i<n;i++){\\n            cnt += (v[i]/mid);\\n            if(cnt>=k) return true;\\n        }\\n        return false;\\n    }\\n    \\n    // v is the candies vector.\\n    int maximumCandies(vector<int>& v, long long k) {\\n        int n = v.size();\\n\\t\\tint mx = 0;\\n        for(int i=0;i<n;i++){\\n\\t\\t\\tmx = max(mx,v[i]);\\n        }\\n        \\n        ll low = 1, high = mx;\\n        ll ans = 0;\\n        while(low<=high){\\n            ll mid = low + (high-low)/2;\\n            if(solve(v,mid,k)){\\n                ans = mid;\\n                low = mid+1;\\n            }\\n            else{\\n                high = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Time Complexity= O(nlogp)   // p is the maximum candy.\\nSpace Complexity- O(1);**\\n\\n\\nUpvote if it helps!!\\nThank you!!\\n\\nMore binary search problems:\\n\\nhttps://leetcode.com/problems/capacity-to-ship-packages-within-d-days/\\nhttps://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/\\nhttps://leetcode.com/problems/find-the-duplicate-number/\\nhttps://leetcode.com/problems/minimum-size-subarray-sum/\\nhttps://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/\\nhttps://leetcode.com/problems/most-beautiful-item-for-each-query/\\nhttps://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/\\nhttps://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/\\nhttps://leetcode.com/problems/heaters/\\nhttps://leetcode.com/problems/minimum-absolute-sum-difference/\\nhttps://leetcode.com/problems/frequency-of-the-most-frequent-element/",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    \\n    bool solve(vector<int>& v, ll mid, ll k){\\n        int n = v.size();\\n        ll cnt = 0;\\n        for(int i=0;i<n;i++){\\n            cnt += (v[i]/mid);\\n            if(cnt>=k) return true;\\n        }\\n        return false;\\n    }\\n    \\n    // v is the candies vector.\\n    int maximumCandies(vector<int>& v, long long k) {\\n        int n = v.size();\\n\\t\\tint mx = 0;\\n        for(int i=0;i<n;i++){\\n\\t\\t\\tmx = max(mx,v[i]);\\n        }\\n        \\n        ll low = 1, high = mx;\\n        ll ans = 0;\\n        while(low<=high){\\n            ll mid = low + (high-low)/2;\\n            if(solve(v,mid,k)){\\n                ans = mid;\\n                low = mid+1;\\n            }\\n            else{\\n                high = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908797,
                "title": "binary-search-solution-with-explanation-java-o-n-log-max-candies",
                "content": "Simple Binary Search Solution | Java | O(n log(max(candies)))\\n\\n**Idea**:\\nBrute force :Start with 1 candy and see if we can allocate. If yes, then check for 2 candy. \\nOptimization: Instead of checking every candy at a time, why can\\'t we directly check for a number to see if we can allocate that many candy. This way we reduce our search space. Best way to do it is binary search.\\n\\n**Approach**:\\nFirst go through each pile and store the maximum of candy of that pile.\\nNow your seach space will be `[0 - max]`. Now, we will pick `mid` from that and check if we can allocate that many candies to k children. If yes, update `lo`, if not update `hi`.\\n0 is trickey number because you can always allocate that many candies. So, at the end I do a check one more time on lo to see if I can allocate that candies. otherwise return lo-1.\\n\\n**TimeComplexity**:\\n`O(n)` to check if you can allocate x candies to k people\\ncalling above function `log(max(candies))`.\\nSo, overall time complexity `O(n log(max(candies)))`\\n\\n**Upvote if it helps. Thanks :)**\\n\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        \\n        int max = 0;\\n        for(int candy : candies)\\n            max = Math.max(max, candy);\\n        int lo = 0, hi = max;\\n        \\n        while(lo < hi) {            \\n            int mid = lo + (hi-lo)/2;\\n            if(canAllocate(candies, k, mid)) {\\n                lo = mid+1;\\n            } else {\\n                hi = mid ;\\n            }\\n        }  \\n        return canAllocate(candies, k, lo) ? lo : lo-1;\\n    }\\n    \\n    public boolean canAllocate(int[] candies, long k, int allow) {\\n        if(allow == 0)\\n            return true;\\n        long total = 0;\\n        for(int candy : candies) {\\n            total += candy / allow;\\n            if(total >= k)\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        \\n        int max = 0;\\n        for(int candy : candies)\\n            max = Math.max(max, candy);\\n        int lo = 0, hi = max;\\n        \\n        while(lo < hi) {            \\n            int mid = lo + (hi-lo)/2;\\n            if(canAllocate(candies, k, mid)) {\\n                lo = mid+1;\\n            } else {\\n                hi = mid ;\\n            }\\n        }  \\n        return canAllocate(candies, k, lo) ? lo : lo-1;\\n    }\\n    \\n    public boolean canAllocate(int[] candies, long k, int allow) {\\n        if(allow == 0)\\n            return true;\\n        long total = 0;\\n        for(int candy : candies) {\\n            total += candy / allow;\\n            if(total >= k)\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908862,
                "title": "binary-search-intutive-intution-explanation",
                "content": "Intution : We Know we had  to distribute  maximum candies , whenever face Problem in which we  have   to distribute  and finding the maximum or minium, See the Time Complexity if Time Complexity isaround 10^4, and your answer require optimal ways then think of dp solution, if Time Complexity is around 10^5 either it can be done by  sorting with greedy or binary search on ans. Now with this it was clear it is binary search on ans problem. So Just checked how can I distribute \\n1. Search space can be 1 to sum(candies), Why\\n Becuase you have to give them at least one so low = 1.\\n 2. Just find the mid and check, if distributing mid candies it is possible to distribute if yes, then reduce your search space so that more optimal ans can be find.\\n\\n**Please UPVOTE Guys , If it helps, That motivates**\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& candies, long long k, long long mid) {\\n        long long split = 0;\\n        for(int i = 0; i < candies.size(); ++i) {\\n            split += candies[i]/mid;\\n        }   \\n        return split>=k;\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long sum = 0;\\n        for(int i = 0; i < candies.size(); ++i) {\\n            sum += candies[i];\\n        }\\n        \\n        long long start = 1, end = sum;\\n        long long ans = 0;\\n        \\n        while(start <= end) {\\n            long long mid = (start + end)/2;\\n            if(check(candies, k, mid)) {\\n                ans = mid;\\n                start = mid + 1;\\n            } else {\\n                end = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nTime Complexity : nlog(m}\\nSpace Complexity: O(1)",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool check(vector<int>& candies, long long k, long long mid) {\\n        long long split = 0;\\n        for(int i = 0; i < candies.size(); ++i) {\\n            split += candies[i]/mid;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1908775,
                "title": "100-faster-c-python-java-binary-search-with-logic",
                "content": "![image](https://assets.leetcode.com/users/images/82a7e416-2997-4676-929e-712206ab4b1a_1648961313.8131979.png)\\n\\n**Idea**\\n\\n* start can be taken as 1 , highest we can distribute equally is average.\\n\\n* Use Binary Search and try to distribute the candies equal to mid, if possible try to maximize it by moving on right, else if not possible try it by decreasing the value by moving on left\\n* **TC: O(NlogN) SC: O(1)**\\n\\n```\\ndef canSplit(candies, mid, k):\\n    split = 0\\n    for i in candies:\\n        split += i//mid\\n    if split >= k:\\n        return True\\n    else:\\n        return False\\n    \\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        end = sum(candies)//k\\n        start = 1\\n        ans = 0\\n        while start <= end:\\n            mid = (start + end)//2\\n            if canSplit(candies, mid, k):\\n                start = mid + 1\\n                ans = mid\\n            else:\\n                end = mid - 1\\n        return ans\\n        \\n```\\n\\n**C++**\\n\\n```\\nclass Solution {\\npublic:\\n    bool canSplit(vector<int>& candies, long long k, long long mid) {\\n        long long split = 0;\\n        for(int i = 0; i < candies.size(); ++i) {\\n            split += candies[i]/mid;\\n        }   \\n        if(split >= k)\\n            return true;\\n        else\\n            return false;\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long sum = 0;\\n        for(int i = 0; i < candies.size(); ++i) {\\n            sum += candies[i];\\n        }\\n        long long start = 1, end = sum/k;\\n        long long ans = 0;\\n        while(start <= end) {\\n            long long mid = (start + end)/2;\\n            if(canSplit(candies, k, mid)) {\\n                ans = mid;\\n                start = mid + 1;\\n            } else {\\n                end = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Java**\\n```\\nclass Solution {\\n    public boolean canSplit(int[] candies, long k, long mid) {\\n        long split = 0;\\n        for(int i = 0; i < candies.length; ++i) {\\n            split += candies[i]/mid;\\n        }   \\n        if(split >= k)\\n            return true;\\n        else\\n            return false;\\n    }\\n    \\n    public int maximumCandies(int[] candies, long k) {\\n        long sum = 0;\\n        for(int i = 0; i < candies.length; ++i) {\\n            sum += candies[i];\\n        }\\n        long start = 1, end = sum;\\n        long ans = 0;\\n        while(start <= end) {\\n            long mid = (start + end)/2;\\n            if(canSplit(candies, k, mid)) {\\n                ans = mid;\\n                start = mid + 1;\\n            } else {\\n                end = mid-1;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Binary Search"
                ],
                "code": "```\\ndef canSplit(candies, mid, k):\\n    split = 0\\n    for i in candies:\\n        split += i//mid\\n    if split >= k:\\n        return True\\n    else:\\n        return False\\n    \\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        end = sum(candies)//k\\n        start = 1\\n        ans = 0\\n        while start <= end:\\n            mid = (start + end)//2\\n            if canSplit(candies, mid, k):\\n                start = mid + 1\\n                ans = mid\\n            else:\\n                end = mid - 1\\n        return ans\\n        \\n```\n```\\nclass Solution {\\npublic:\\n    bool canSplit(vector<int>& candies, long long k, long long mid) {\\n        long long split = 0;\\n        for(int i = 0; i < candies.size(); ++i) {\\n            split += candies[i]/mid;\\n        }   \\n        if(split >= k)\\n            return true;\\n        else\\n            return false;\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long sum = 0;\\n        for(int i = 0; i < candies.size(); ++i) {\\n            sum += candies[i];\\n        }\\n        long long start = 1, end = sum/k;\\n        long long ans = 0;\\n        while(start <= end) {\\n            long long mid = (start + end)/2;\\n            if(canSplit(candies, k, mid)) {\\n                ans = mid;\\n                start = mid + 1;\\n            } else {\\n                end = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public boolean canSplit(int[] candies, long k, long mid) {\\n        long split = 0;\\n        for(int i = 0; i < candies.length; ++i) {\\n            split += candies[i]/mid;\\n        }   \\n        if(split >= k)\\n            return true;\\n        else\\n            return false;\\n    }\\n    \\n    public int maximumCandies(int[] candies, long k) {\\n        long sum = 0;\\n        for(int i = 0; i < candies.length; ++i) {\\n            sum += candies[i];\\n        }\\n        long start = 1, end = sum;\\n        long ans = 0;\\n        while(start <= end) {\\n            long mid = (start + end)/2;\\n            if(canSplit(candies, k, mid)) {\\n                ans = mid;\\n                start = mid + 1;\\n            } else {\\n                end = mid-1;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908707,
                "title": "binary-search-explained",
                "content": "**Explanation :**\\nBinary search between **[1, max(candies)]** to find the result.\\n**if we can allocate currCandy candies to k children. then update start, if not update end.**\\nSimilar Question : [https://leetcode.com/problems/koko-eating-bananas/]\\n**Time O(Nlog(MaxC))\\nSpace O(1)**\\n    \\n    \\n```\\nclass Solution {\\npublic:\\n    \\n    bool doit(int currCandy, vector<int>& candies, long long k) {\\n       \\n\\t\\t// c candies can be divided into (c/currCandy) number of piles of size currCandy.\\n        for (auto& c : candies)   k -= (c/currCandy);\\n        return k <= 0;\\n    }\\n    \\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        \\n        int start(1), end(INT_MIN);\\n        for (auto& candy : candies) end = max(end, candy);\\n        \\n        while (start <= end) {\\n            int currCandy = start+(end-start)/2;\\n\\t\\t\\t// If we can divide the candies into piles containing currCandy number of candies all the numbers below currCandy can be distributed too.\\n            if (doit(currCandy, candies, k))    start = currCandy+1;\\n            else    end = currCandy-1;\\n        }\\n        return end;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool doit(int currCandy, vector<int>& candies, long long k) {\\n       \\n\\t\\t// c candies can be divided into (c/currCandy) number of piles of size currCandy.\\n        for (auto& c : candies)   k -= (c/currCandy);\\n        return k <= 0;\\n    }\\n    \\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        \\n        int start(1), end(INT_MIN);\\n        for (auto& candy : candies) end = max(end, candy);\\n        \\n        while (start <= end) {\\n            int currCandy = start+(end-start)/2;\\n\\t\\t\\t// If we can divide the candies into piles containing currCandy number of candies all the numbers below currCandy can be distributed too.\\n            if (doit(currCandy, candies, k))    start = currCandy+1;\\n            else    end = currCandy-1;\\n        }\\n        return end;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266489,
                "title": "easy-to-understand-optimized-binary-search-approach-beginner-friendly-detail-explained",
                "content": "\\n# Approach\\n1. minimum size of candy can be 1,less than 1 can not be possible.\\n2. maximum size of candy can be maximum element of given candies array,greater than max element can not be possible.\\n3. we chose candy size by bianry search, so that we can choose in optimised time.\\n4. function func give information about that, candies array\\'s element can be divided into mid size.\\n5. In function func,\\'cnt\\' count the nummber of \\'mid\\' size candy can be divided from candies array elements.\\n6. when count of mid size candy greater than our need(k), then we return true, *i.e.*  our answer should be mid but greater than mid can be possible.\\n# Complexity\\n- Time complexity:$$O(N*logN)$$\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool func(vector<int>&pile,long long h,int mid)\\n    {\\n        long long cnt=0;\\n        for(int i=0;i<pile.size();i++)\\n        {\\n            cnt += pile[i]/mid ;\\n            if(cnt>h)\\n            return true;\\n        }\\n        return cnt>=h;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) \\n    {\\n        int s = 1,e = *max_element(candies.begin(),candies.end());\\n        int ans=0;\\n        while(s<=e)\\n        {\\n            int mid = s+ (e-s)/2;\\n            if(func(candies,k,mid))\\n            {\\n                ans = mid;\\n                s = mid+1;\\n            }\\n            else\\n            e = mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**If you feel this helpful then plz like and upvote this solution \\uD83D\\uDE0A\\nKEEP LEETCODING.............**\\n![upvote.png](https://assets.leetcode.com/users/images/2fccf5b3-2212-4efd-afe0-0a5ca0b80d68_1678151551.9504004.png)\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool func(vector<int>&pile,long long h,int mid)\\n    {\\n        long long cnt=0;\\n        for(int i=0;i<pile.size();i++)\\n        {\\n            cnt += pile[i]/mid ;\\n            if(cnt>h)\\n            return true;\\n        }\\n        return cnt>=h;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) \\n    {\\n        int s = 1,e = *max_element(candies.begin(),candies.end());\\n        int ans=0;\\n        while(s<=e)\\n        {\\n            int mid = s+ (e-s)/2;\\n            if(func(candies,k,mid))\\n            {\\n                ans = mid;\\n                s = mid+1;\\n            }\\n            else\\n            e = mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909217,
                "title": "c-solution-100-faster",
                "content": "\"\"\"\\n#define ll long long\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        ll left=1,right=*max_element(candies.begin(),candies.end());\\n        ll size=candies.size();\\n        ll maxi=0;\\n        while(left<=right){\\n            ll mid=left+(right-left)/2;\\n            ll temp=0;\\n            for(int i=0;i<size;i++){\\n                temp+=candies[i]/mid;\\n            }\\n            if(temp>=k){\\n                maxi=mid;\\n                left=mid+1;\\n            }else{\\n                right=mid-1;\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n\"\"\"\\n\\nPlease Upvote if you find it Helpful \\uD83D\\uDE42.",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "class Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        ll left=1,right=*max_element(candies.begin(),candies.end());\\n        ll size=candies.size();\\n        ll maxi=0;\\n        while(left<=right){\\n            ll mid=left+(right-left)/2;\\n            ll temp=0;\\n            for(int i=0;i<size;i++){\\n                temp+=candies[i]/mid;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1909039,
                "title": "c-binary-search-on-answer-explained-o-nlogn",
                "content": "**CONCEPT**\\n* In these type of question first we have to find search space which is the possible set of answers which this question can have. Like in this case minimum answer can be zero and maximum can be maximum of the candies not more than that. \\n* Simply apply binary search on this range [0,max] and if mid is possible answer than we will try to increase this answer by reducing our search space to [mid+1,max] else we will try to find answer in [0,mid].\\n* isPossible function tells whether is it possible to divide the candies or not. So it is implemented greedily. So i have count the maximum number of children i can distribute candies to and if it is greater than equal to k than it is possible to divide else not.\\n* Time:O(NlogN) and Space:O(1\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums, long long k, long long mid){\\n        long long cnt=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>=mid){\\n                cnt+=(nums[i]/mid);\\n            }\\n        }\\n        return cnt>=k;\\n    }\\n    \\n    \\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        sort(candies.begin(),candies.end());\\n        int n=candies.size();\\n        long long sum=0;\\n        int mx=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            sum+=candies[i];\\n            mx=max(mx,candies[i]);\\n            \\n        }\\n        \\n        long long l=1,r=mx;\\n        int res=0;\\n        while(l<=r){\\n            long long mid=l+(r-l)/2;\\n            if(isPossible(candies,k,mid)){\\n                l=mid+1;\\n            }else{\\n                r=mid-1;\\n            }\\n        }\\n        \\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums, long long k, long long mid){\\n        long long cnt=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>=mid){\\n                cnt+=(nums[i]/mid);\\n            }\\n        }\\n        return cnt>=k;\\n    }\\n    \\n    \\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        sort(candies.begin(),candies.end());\\n        int n=candies.size();\\n        long long sum=0;\\n        int mx=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            sum+=candies[i];\\n            mx=max(mx,candies[i]);\\n            \\n        }\\n        \\n        long long l=1,r=mx;\\n        int res=0;\\n        while(l<=r){\\n            long long mid=l+(r-l)/2;\\n            if(isPossible(candies,k,mid)){\\n                l=mid+1;\\n            }else{\\n                r=mid-1;\\n            }\\n        }\\n        \\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908820,
                "title": "c-binary-search",
                "content": "\\nSee my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. Binary Answer\\n\\nBinary search in range `L = 1, R = max(A)`.\\n\\nFor a given `M = (L + R) / 2`, we test if we can give `M` candies to each child, which can be done by traversing the array once, taking `O(N)` time. \\n\\nIf possible/valid, we make `L = M + 1`; otherwise, we make `R = M - 1`.\\n\\nIn the end, since we are looking for the greatest valid number, we return `R`.\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-287/problems/maximum-candies-allocated-to-k-children/\\n// Author: github.com/lzl124631x\\n// Time: O(Nlog(sum(A)))\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& A, long long k) {\\n        long L = 1, R = *max_element(begin(A), end(A)), N = A.size();\\n        auto valid = [&](long m) {\\n            long cnt = 0;\\n            for (int n : A) {\\n                cnt += n / m;\\n                if (cnt >= k) return true;\\n            }\\n            return false;\\n        };\\n        while (L <= R) {\\n            long M = L + (R - L) / 2;\\n            if (valid(M)) L = M + 1;\\n            else R = M - 1;\\n        }\\n        return R;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-287/problems/maximum-candies-allocated-to-k-children/\\n// Author: github.com/lzl124631x\\n// Time: O(Nlog(sum(A)))\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& A, long long k) {\\n        long L = 1, R = *max_element(begin(A), end(A)), N = A.size();\\n        auto valid = [&](long m) {\\n            long cnt = 0;\\n            for (int n : A) {\\n                cnt += n / m;\\n                if (cnt >= k) return true;\\n            }\\n            return false;\\n        };\\n        while (L <= R) {\\n            long M = L + (R - L) / 2;\\n            if (valid(M)) L = M + 1;\\n            else R = M - 1;\\n        }\\n        return R;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909387,
                "title": "c-accepted-solution-binary-search-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        \\n        long long sum=0;\\n        \\n        int n=candies.size();\\n        \\n        //calculate sum\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=(long long)candies[i];\\n        }\\n        \\n        \\n        // if sum<k then we are not able to give a single one candy\\n        if(sum<k) return 0;\\n        \\n        \\n        long long h=sum/k;  // max possible ans cant exceed sum/k\\n        long long l=1;      // min possible ans will be 1\\n        long long res=1;\\n        \\n        \\n        //next part is just binary search\\n        while(h>=l)\\n        {\\n            long long m=(h+l)/2;\\n            long long count=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                count+=candies[i]/m;\\n            }\\n            \\n            if(count>=k)\\n            {\\n                res=max(res,m);\\n                l=m+1;\\n            }\\n            else\\n            {\\n                h=m-1;\\n            }\\n        }\\n        return res;\\n        \\n        \\n    }\\n};\\n```\\n**upvote**",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        \\n        long long sum=0;\\n        \\n        int n=candies.size();\\n        \\n        //calculate sum\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=(long long)candies[i];\\n        }\\n        \\n        \\n        // if sum<k then we are not able to give a single one candy\\n        if(sum<k) return 0;\\n        \\n        \\n        long long h=sum/k;  // max possible ans cant exceed sum/k\\n        long long l=1;      // min possible ans will be 1\\n        long long res=1;\\n        \\n        \\n        //next part is just binary search\\n        while(h>=l)\\n        {\\n            long long m=(h+l)/2;\\n            long long count=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                count+=candies[i]/m;\\n            }\\n            \\n            if(count>=k)\\n            {\\n                res=max(res,m);\\n                l=m+1;\\n            }\\n            else\\n            {\\n                h=m-1;\\n            }\\n        }\\n        return res;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3361579,
                "title": "c-binary-search-simple-explanation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhat comes to my mind is to check what number of candies(search space) is satisfying children.\\nSo by this intuition we can find the search space. \\n\\nMinimum candy child can  get will be 1:\\nExample: [1,2,3,4] and k=5\\nTotal 5 children and all of them should have same amount of candies\\nso for example let candy=2 now check whether we can get 2 candies from all the piles or not\\n1st pile:- candies[0]=1 and we can\\'t get 2 candies -> count=0\\n2nd pile:- candies[1]=2 we can get 2 candies -> count=1\\n3rd pile:- candies[2]=3 we can get 2 candies -> count=2\\n4th pile:- candies[3]=4 we can get total pair of 2 candy -> count=4\\n\\nAt end we can only satisfy 4 children but we need to satisfy 5 children(k=5)\\nso minimum value child can get will be 1 candy.\\n\\nMaximum candy child can get will be maximum element in candies:\\nExample candies=[1,2,3,4] and k=1\\nHere we need to satisy 1 children and it should have maximum candy we can just allocate all candy to single children \\nso maximum value of candy child can get will be 4.\\n\\nWe got our search space here\\nstart=1 and end=max_element\\n\\nNow approach is to apply binary search and check whether particular number of candies satisfies all the children or not\\nExample: candies=[5,8,6], k = 3\\nsuppose we reached mid=5 now count the number of 5 candies from each pile:\\n```\\n bool isSatisfying(vector<int> candies,long long mid ,long long k){\\n        long long count=0;\\n\\n        for(auto x: candies){\\n            count=count+(x/mid);\\n        }\\n        if(count>=k) return true;\\n        return false;\\n    }\\n```\\nWe are dividing each piles with mid value and checking how many number of 5 candies we can get.\\nFor [5,8,6]->\\n    Each child gets 1 pile of total 5 candies\\n    5/5=1 -> For first child\\n    8/5=1 -> For second child\\n    6/5=1 -> For third child\\n\\nWe can distribute max 5 candies to 3 children\\nIf count is greater or equal to children then we can distribute equal candies to all children .\\n\\n# Complexity\\n- Time complexity:\\n $$O(n(log(end)))$$ where n=candies.size() and end=max_element\\n\\n- Space complexity\\n    $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isSatisfying(vector<int> candies,long long mid ,long long k){\\n        long long count=0;\\n\\n        for(auto x: candies){\\n            count=count+(x/mid);\\n        }\\n\\n        if(count>=k) return true;\\n        return false;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int start=1;\\n        int end=*max_element(candies.begin(),candies.end());\\n        int ans=0;\\n\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            if(isSatisfying(candies,mid,k)){\\n                //we need to maximize search space so storing answer and finding anther maxi\\n                ans=mid;\\n                start=mid+1;\\n            }\\n            else{\\n                end=mid-1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Binary Search"
                ],
                "code": "```\\n bool isSatisfying(vector<int> candies,long long mid ,long long k){\\n        long long count=0;\\n\\n        for(auto x: candies){\\n            count=count+(x/mid);\\n        }\\n        if(count>=k) return true;\\n        return false;\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    bool isSatisfying(vector<int> candies,long long mid ,long long k){\\n        long long count=0;\\n\\n        for(auto x: candies){\\n            count=count+(x/mid);\\n        }\\n\\n        if(count>=k) return true;\\n        return false;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int start=1;\\n        int end=*max_element(candies.begin(),candies.end());\\n        int ans=0;\\n\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            if(isSatisfying(candies,mid,k)){\\n                //we need to maximize search space so storing answer and finding anther maxi\\n                ans=mid;\\n                start=mid+1;\\n            }\\n            else{\\n                end=mid-1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909559,
                "title": "easy-tricky-binary-search-approach-explained-along-with-code",
                "content": "# This problem is a kind of Upper Bond problem of Binary search.\\nHere we just simply have to make an binary search call by setting the min and max variables which is the range in which we have to be get the correct answer. Since we can give as minimum as 0 candies to k children because there are not many candies for everyone so our min = 0. and the maximum candies which we can give is the maximum pile of candie which is available with us because there is no way we can distribute more candies than what we have available.\\nTo Calculate mid we will use this formula **mid = min + (max-min)/2** this will give us the exact possible value of mid everytime.\\nAnd then we need a condtion to verify if the current **mid** is a right input so for that we have a condition that the number of candie pile can be divided such that all the **k** childeren should get same number of candy so we will make a boolean function to check the exact same thing which we  discussed.\\n\\n\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int min = 1;\\n        int max = Integer.MIN_VALUE;\\n        for(int candie : candies){\\n            max = Math.max(candie,max);\\n        }\\n        \\n        int answer = 0;\\n        while(min <= max){\\n            int mid = min + (max - min)/2;\\n            if(checkIfTrue(candies,k,mid)){\\n                answer = mid;\\n                min = mid+1;\\n            }else{\\n                max = mid-1;\\n            }\\n        }\\n        return answer;\\n    }\\n    \\n    public boolean checkIfTrue(int[] candies,long k,int divid){\\n        long cnt = 0;\\n        for(int candie : candies){\\n            cnt += (long) Math.floor(candie/divid);\\n        }\\n        if(cnt >= k) return true;\\n        return false;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int min = 1;\\n        int max = Integer.MIN_VALUE;\\n        for(int candie : candies){\\n            max = Math.max(candie,max);\\n        }\\n        \\n        int answer = 0;\\n        while(min <= max){\\n            int mid = min + (max - min)/2;\\n            if(checkIfTrue(candies,k,mid)){\\n                answer = mid;\\n                min = mid+1;\\n            }else{\\n                max = mid-1;\\n            }\\n        }\\n        return answer;\\n    }\\n    \\n    public boolean checkIfTrue(int[] candies,long k,int divid){\\n        long cnt = 0;\\n        for(int candie : candies){\\n            cnt += (long) Math.floor(candie/divid);\\n        }\\n        if(cnt >= k) return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3182046,
                "title": "best-solution-in-c-binarysearch-on-answer",
                "content": "# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n**Please Upvote if u liked my Solution**\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    bool occurrences(int x,vector<int>& candies,long k){\\n        long ans=0;\\n        for(auto it:candies){\\n            ans+=it/x;\\n            if(ans>=k)\\n                return true;\\n        }\\n        return false;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int size=candies.size(),ans=-1;\\n        long sum=0;\\n        for(auto it:candies)\\n            sum+=it;\\n        if(sum<k)\\n            return 0;\\n        int ll=1,ul=sum/k,mid;\\n        while(ll<=ul){\\n            mid= (ll+ul) >> 1;\\n            if(occurrences(mid,candies,k)){\\n                ans=mid;\\n                ll=mid+1;\\n            }\\n            else\\n                ul=mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool occurrences(int x,vector<int>& candies,long k){\\n        long ans=0;\\n        for(auto it:candies){\\n            ans+=it/x;\\n            if(ans>=k)\\n                return true;\\n        }\\n        return false;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int size=candies.size(),ans=-1;\\n        long sum=0;\\n        for(auto it:candies)\\n            sum+=it;\\n        if(sum<k)\\n            return 0;\\n        int ll=1,ul=sum/k,mid;\\n        while(ll<=ul){\\n            mid= (ll+ul) >> 1;\\n            if(occurrences(mid,candies,k)){\\n                ans=mid;\\n                ll=mid+1;\\n            }\\n            else\\n                ul=mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2958952,
                "title": "concise-binary-search-c",
                "content": "```\\nclass Solution {\\n    bool good(int x, vector<int> &c, long long k) {\\n        long long cnt = 0;\\n        for(int i : c) cnt += i / x;\\n        return cnt < k ? false : true;\\n    }\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int s = 1, e = 1e9, ans = INT_MIN;\\n        while(s <= e) {\\n            int m = (s + e) / 2;\\n            if(good(m, candies, k)) ans = max(ans, m), s = m + 1;\\n            else e = m - 1;\\n        }\\n        return ans == INT_MIN ? 0 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    bool good(int x, vector<int> &c, long long k) {\\n        long long cnt = 0;\\n        for(int i : c) cnt += i / x;\\n        return cnt < k ? false : true;\\n    }\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int s = 1, e = 1e9, ans = INT_MIN;\\n        while(s <= e) {\\n            int m = (s + e) / 2;\\n            if(good(m, candies, k)) ans = max(ans, m), s = m + 1;\\n            else e = m - 1;\\n        }\\n        return ans == INT_MIN ? 0 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2434695,
                "title": "java-solution-using-binary-search",
                "content": "```\\nprivate boolean isPossible(int[] candies,int max,long k){\\n        long sum = 0;\\n        for(int i = 0; i<candies.length;i++){\\n            sum += (candies[i]/max);\\n        }\\n        if(sum>=k){\\n            return true;\\n        }\\n        return false;\\n    }\\n    public int maximumCandies(int[] candies, long k) {\\n        int s = 1;\\n        int e = 0;\\n        for(int i = 0; i< candies.length;i++){\\n            e = Math.max(e,candies[i]);                  // ans can\\'t be more than the height number in the array so take end, the max candie from array.\\n        }\\n        int ans = 0;\\n        while(s<=e){\\n            int mid = s+(e-s)/2;\\n            if(isPossible(candies,mid,k)){       // if posible to distribute candies with mid then store ans and increase start to mid + 1, Becoz we need maximum possible ans according to question.\\n                ans = mid;\\n                s = mid+1;\\n            }\\n            else{\\n                e = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nprivate boolean isPossible(int[] candies,int max,long k){\\n        long sum = 0;\\n        for(int i = 0; i<candies.length;i++){\\n            sum += (candies[i]/max);\\n        }\\n        if(sum>=k){\\n            return true;\\n        }\\n        return false;\\n    }\\n    public int maximumCandies(int[] candies, long k) {\\n        int s = 1;\\n        int e = 0;\\n        for(int i = 0; i< candies.length;i++){\\n            e = Math.max(e,candies[i]);                  // ans can\\'t be more than the height number in the array so take end, the max candie from array.\\n        }\\n        int ans = 0;\\n        while(s<=e){\\n            int mid = s+(e-s)/2;\\n            if(isPossible(candies,mid,k)){       // if posible to distribute candies with mid then store ans and increase start to mid + 1, Becoz we need maximum possible ans according to question.\\n                ans = mid;\\n                s = mid+1;\\n            }\\n            else{\\n                e = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1975986,
                "title": "python-easy-to-understand-50-faster",
                "content": "```\\nclass Solution:\\n    \"\"\"\\n    approach: \\n    the problem can be tackled using binary search \\n    max_candies that can be allocated to children = max(candies)\\n    min_candies that can be allocated to children = 1\\n    \\n    we will apply binary search on finding the optimal values of candies that can be\\n    distributed to children. \\n    \"\"\"\\n    def check_fulfilment(self, candies, elem, k):\\n        count = 0\\n        for candy in candies:\\n            count+= candy // elem\\n        if count >= k:\\n            return True\\n        return False\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        low = 1\\n        high = max(candies)\\n        if sum(candies) < k:\\n            return 0\\n        while low <= high:\\n            mid = (low+high) // 2\\n            # check if I can fulfil that order\\n            status = self.check_fulfilment(candies, mid, k)\\n            if status:\\n                low = mid+1\\n            else:         \\n                high = mid-1\\n        # low is the maximum number of candies that can be  distributed\\n        return high\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    \"\"\"\\n    approach: \\n    the problem can be tackled using binary search \\n    max_candies that can be allocated to children = max(candies)\\n    min_candies that can be allocated to children = 1\\n    \\n    we will apply binary search on finding the optimal values of candies that can be\\n    distributed to children. \\n    \"\"\"\\n    def check_fulfilment(self, candies, elem, k):\\n        count = 0\\n        for candy in candies:\\n            count+= candy // elem\\n        if count >= k:\\n            return True\\n        return False\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        low = 1\\n        high = max(candies)\\n        if sum(candies) < k:\\n            return 0\\n        while low <= high:\\n            mid = (low+high) // 2\\n            # check if I can fulfil that order\\n            status = self.check_fulfilment(candies, mid, k)\\n            if status:\\n                low = mid+1\\n            else:         \\n                high = mid-1\\n        # low is the maximum number of candies that can be  distributed\\n        return high\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1960155,
                "title": "c-discrete-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(long val,vector<int>&candies,long k){\\n        long sum = 0;\\n        for(auto it : candies){\\n            sum += (it/val);\\n        }\\n        return sum >= k;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long start = 1, end = 1e9;\\n        while(start < end){\\n            long mid = (start + end) / 2;\\n            if(!check(mid,candies,k)){\\n                end = mid;\\n            }\\n            else start = mid+1;\\n        }\\n        return start-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(long val,vector<int>&candies,long k){\\n        long sum = 0;\\n        for(auto it : candies){\\n            sum += (it/val);\\n        }\\n        return sum >= k;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long start = 1, end = 1e9;\\n        while(start < end){\\n            long mid = (start + end) / 2;\\n            if(!check(mid,candies,k)){\\n                end = mid;\\n            }\\n            else start = mid+1;\\n        }\\n        return start-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1912213,
                "title": "easy-to-understand-python-solution-binary-search",
                "content": "```\\nclass Solution:\\n    def maximumCandies(self, candies, k):\\n        n = len(candies)\\n        left = 1  # the least number of candy in each stack we can give to each student is one\\n        right = max(candies)  # the max number of candy in each stack that we can give to each student is the maximum number in the candies array\\n        ans = 0 # ans here is used to store the maximum amount in each stack that we can give to each children. \\n               # If we don\\'t have enough to distribute, we will return 0 at the end so we initialize it to be 0 now.\\n\\n        while left <= right:  # binary search\\n            numberOfPiles = 0\\n            mid = (left) + (right - left) // 2  # the number of candies we require to form a stack\\n\\n            for i in range(n):   # loop through the array to find the numbers of stack we can form\\n                numberOfPiles += candies[i] // mid   # we add to the numberOfPiles whenever we find that this current stack (candies[i]) can be split into mid (the number of candies we require to form a stack)\\n\\n            if numberOfPiles >= k: # if our number of piles is greater or equal than the students we have, so we have enough to distribute\\n                ans = max(ans, mid)   # we first store the max no. of candies in each stack that we can give to each student \\n                left = mid + 1      # we will try to increase the number of candies in each stack that we can give to each student\\n            else: \\n                right = mid - 1   # we will try to reduce the number of candies in each stack that we can give to each student\\n        return ans\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCandies(self, candies, k):\\n        n = len(candies)\\n        left = 1  # the least number of candy in each stack we can give to each student is one\\n        right = max(candies)  # the max number of candy in each stack that we can give to each student is the maximum number in the candies array\\n        ans = 0 # ans here is used to store the maximum amount in each stack that we can give to each children. \\n               # If we don\\'t have enough to distribute, we will return 0 at the end so we initialize it to be 0 now.\\n\\n        while left <= right:  # binary search\\n            numberOfPiles = 0\\n            mid = (left) + (right - left) // 2  # the number of candies we require to form a stack\\n\\n            for i in range(n):   # loop through the array to find the numbers of stack we can form\\n                numberOfPiles += candies[i] // mid   # we add to the numberOfPiles whenever we find that this current stack (candies[i]) can be split into mid (the number of candies we require to form a stack)\\n\\n            if numberOfPiles >= k: # if our number of piles is greater or equal than the students we have, so we have enough to distribute\\n                ans = max(ans, mid)   # we first store the max no. of candies in each stack that we can give to each student \\n                left = mid + 1      # we will try to increase the number of candies in each stack that we can give to each student\\n            else: \\n                right = mid - 1   # we will try to reduce the number of candies in each stack that we can give to each student\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911684,
                "title": "1-liner-python-ruby",
                "content": "Binary-search the smallest allocation `a` that\\'s too large, the answer is 1 lower. Ruby still excels at this, though Python improved now that it supports a `key`.\\n\\nRuby:\\n```\\ndef maximum_candies(candies, k)\\n  (1..10**8).bsearch { |a| candies.sum { |c| c / a } < k } - 1\\nend\\n```\\nPython:\\n\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        return bisect_left(range(1, 10**8), True, key=lambda a: sum(c // a for c in candies) < k)\\n",
                "solutionTags": [
                    "Python",
                    "Ruby",
                    "Binary Tree"
                ],
                "code": "```\\ndef maximum_candies(candies, k)\\n  (1..10**8).bsearch { |a| candies.sum { |c| c / a } < k } - 1\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1910012,
                "title": "c-o-n-solution-with-explanation-binary-search",
                "content": "**Code:**\\n**TC: O(N), SC: O(1)**\\n```\\nclass Solution {\\npublic:\\n    \\n    bool isPossible(vector<int>& candies, int mid, long long k)\\n    {\\n        //it contains piles of candies that tells whether we can distribute or not assign to children equally \\n        long count=0;\\n        for(auto it:candies)\\n        {\\n            count += it/mid;\\n        \\n            //whenever count is greater than or equal to k it tells we can distribute mid to k children and return true;\\n            if(count>=k) return true;\\n        }\\n        //when we can\\'t distribute mid piles to k children, we return false;\\n        return false;\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) \\n    {\\n        //initialize two pointers, 1 for minimum no. of candy, 1 for maximum no. of candy\\n        int min_candy = 1;\\n        int max_candy = *max_element(begin(candies), end(candies)); //we can also use for(auto it:candies) max_candy = max(max_candy, it)\\n        \\n        //use binary search for finding candies that can get by each child\\n        while(min_candy<=max_candy)\\n        {\\n            //find mid value\\n            long mid = (min_candy+max_candy)>>1;\\n            \\n            //if we can distribute mid piles of candies to k children successfully\\n            //we check for next greater candies\\n            if(isPossible(candies, mid, k))\\n            {\\n                min_candy = mid+1;\\n            }\\n            \\n            //if we can\\'t distribute mid piles of candies to k children\\n            //we check for lesser candies\\n            else\\n            {\\n                max_candy = mid-1;\\n                \\n            }\\n        }\\n        \\n        //return maxi_candies that can assign to each child\\n        return max_candy;\\n        \\n    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool isPossible(vector<int>& candies, int mid, long long k)\\n    {\\n        //it contains piles of candies that tells whether we can distribute or not assign to children equally \\n        long count=0;\\n        for(auto it:candies)\\n        {\\n            count += it/mid;\\n        \\n            //whenever count is greater than or equal to k it tells we can distribute mid to k children and return true;\\n            if(count>=k) return true;\\n        }\\n        //when we can\\'t distribute mid piles to k children, we return false;\\n        return false;\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) \\n    {\\n        //initialize two pointers, 1 for minimum no. of candy, 1 for maximum no. of candy\\n        int min_candy = 1;\\n        int max_candy = *max_element(begin(candies), end(candies)); //we can also use for(auto it:candies) max_candy = max(max_candy, it)\\n        \\n        //use binary search for finding candies that can get by each child\\n        while(min_candy<=max_candy)\\n        {\\n            //find mid value\\n            long mid = (min_candy+max_candy)>>1;\\n            \\n            //if we can distribute mid piles of candies to k children successfully\\n            //we check for next greater candies\\n            if(isPossible(candies, mid, k))\\n            {\\n                min_candy = mid+1;\\n            }\\n            \\n            //if we can\\'t distribute mid piles of candies to k children\\n            //we check for lesser candies\\n            else\\n            {\\n                max_candy = mid-1;\\n                \\n            }\\n        }\\n        \\n        //return maxi_candies that can assign to each child\\n        return max_candy;\\n        \\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909538,
                "title": "easy-understandable-java-accepted",
                "content": "```\\nclass Solution {\\n    public static int maximumCandies(int[] arr, long k) {\\n\\t\\tArrays.sort(arr);\\n\\t\\tint low = 1;\\n\\t\\tint right = arr[arr.length - 1];\\n\\t\\twhile (low <= right) {\\n\\t\\t\\tint mid = (right - low) / 2 + low;\\n\\t\\t\\tif (helper(arr, k, mid)) {\\n\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tright = mid - 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn right;\\n\\t}\\n\\n\\tpublic static boolean helper(int[] arr, long k, int mid) {\\n\\t\\tlong curr = 0;\\n\\t\\tfor (int i = arr.length - 1; i >= 0 && curr < k; i--) {\\n\\t\\t\\tcurr += arr[i] / mid;\\n\\t\\t}\\n\\t\\treturn curr >= k;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public static int maximumCandies(int[] arr, long k) {\\n\\t\\tArrays.sort(arr);\\n\\t\\tint low = 1;\\n\\t\\tint right = arr[arr.length - 1];\\n\\t\\twhile (low <= right) {\\n\\t\\t\\tint mid = (right - low) / 2 + low;\\n\\t\\t\\tif (helper(arr, k, mid)) {\\n\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tright = mid - 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn right;\\n\\t}\\n\\n\\tpublic static boolean helper(int[] arr, long k, int mid) {\\n\\t\\tlong curr = 0;\\n\\t\\tfor (int i = arr.length - 1; i >= 0 && curr < k; i--) {\\n\\t\\t\\tcurr += arr[i] / mid;\\n\\t\\t}\\n\\t\\treturn curr >= k;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909171,
                "title": "intuition-behind-binary-search-on-answers",
                "content": "<br>\\n\\n`When there are multiple answers that are valid but we need to find the maximum possible valid answer or minimum possible valid answer then we can use binary search on answers.`\\n\\n**How does it work ?**\\n\\nin this problem we know that minimum number of candies that we can allocate is 0 and maximum is max(candies), so in all such problems we need to find the **minimum possible answer** and **maximum possible answer** and binary search between them to find **maximum / minimum valid answer** in logarithmic time.\\n\\nAnd binary search on answers can be used only in those problems in which **we can validate whether the current answer in valid or not**. In this problem we can do that by checking if we can allocate x number of candies among k children by dividing some piles, so we can do binary search here.\\n\\n<br>\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        \\n        int left = 1, ans = 0;\\n        int right = *max_element(candies.begin(), candies.end());\\n        \\n        while(left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if(canAllocate(candies, k, mid)) {\\n                left = mid + 1;\\n                ans = mid;\\n            }\\n            else {\\n                right = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n\\nprivate:\\n    bool canAllocate(vector<int>& candies, long long k, int candy) {\\n        \\n        long long total = 0;\\n        \\n        for(int c: candies) {\\n            total += c / candy;\\n            if(total >= k) return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```\\n<br>\\n\\n**Time complexity: O(n) * log(max(candies))\\nSpace complexity: O(1)**\\n\\n<br>",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        \\n        int left = 1, ans = 0;\\n        int right = *max_element(candies.begin(), candies.end());\\n        \\n        while(left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if(canAllocate(candies, k, mid)) {\\n                left = mid + 1;\\n                ans = mid;\\n            }\\n            else {\\n                right = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n\\nprivate:\\n    bool canAllocate(vector<int>& candies, long long k, int candy) {\\n        \\n        long long total = 0;\\n        \\n        for(int c: candies) {\\n            total += c / candy;\\n            if(total >= k) return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909087,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long l=1,h=0;\\n        for(int& t:candies)\\n            h+=t;\\n        int ans=0;\\n        while(l<=h)\\n        {\\n            long long mid=l+(h-l)/2;\\n            long long val=0;\\n            for(auto t:candies)\\n                val+=(t/mid);\\n            if(val>=k)\\n            {\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else h=mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long l=1,h=0;\\n        for(int& t:candies)\\n            h+=t;\\n        int ans=0;\\n        while(l<=h)\\n        {\\n            long long mid=l+(h-l)/2;\\n            long long val=0;\\n            for(auto t:candies)\\n                val+=(t/mid);\\n            if(val>=k)\\n            {\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else h=mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908890,
                "title": "javascript-2226-maximum-candies-allocated-to-k-children",
                "content": "\\n**Weekly Contest 287**\\n\\n- Q1 answer\\n  - https://leetcode.com/problems/minimum-number-of-operations-to-convert-time/discuss/1908839/JavaScript-2224.-Minimum-Number-of-Operations-to-Convert-Time\\n- Q2 answer\\n  - https://leetcode.com/problems/find-players-with-zero-or-one-losses/discuss/1908871/JavaScript-2225.-Find-Players-With-Zero-or-One-Losses\\n- Q3 answer\\n  - https://leetcode.com/problems/maximum-candies-allocated-to-k-children/discuss/1908890/JavaScript-2226.-Maximum-Candies-Allocated-to-K-Children\\n  - **below**\\n    - Similar to some other DP problems, but this is greedy\\n    - **Less code** solution\\n    - **More code - with comments** solution\\n\\n---\\n\\nHope it is simple to understand.\\n\\n---\\n\\n**Less code** solution\\n\\n```\\nvar maximumCandies = function (candies, k) {\\n    function ok(min_candy) {\\n        let count = 0;\\n        for (let candy of candies) count += Math.floor(candy / min_candy);\\n        return count >= k;\\n    }\\n\\n    let l = 0,\\n        h = Math.max(...candies);\\n\\n    while (l <= h) {\\n        let m = l + Math.trunc((h - l) / 2);\\n        if (ok(m)) l = m + 1;\\n        else h = m - 1;\\n    }\\n    return h;\\n};\\n```\\n\\n---\\n\\n**More code - with comments** solution\\n\\n```\\nvar maximumCandies = function (cand, k) {\\n    function is_good_number_of_candies(cmin) {\\n        let count = 0;\\n        for (let c of cand) {\\n            count += Math.trunc(c / cmin); // how many mins (cmin) can we give from this pile (c)\\n        }\\n        return count >= k;\\n    }\\n\\n    let sum = cand.reduce((sum, x) => sum + x, 0);\\n    if (sum < k) return 0; // not enough, to give at least 1 candy\\n\\n    let lo = 1; // 1 is possible\\n    let hi = cand.reduce((max, x) => Math.max(max, x), -Infinity); // max possible\\n\\n    // since # of candies are too large, try binary search\\n    while (lo <= hi) {\\n        let mid = lo + Math.trunc((hi - lo) / 2);\\n        if (is_good_number_of_candies(mid)) {\\n            lo = mid + 1; // mid is good (##), try next one\\n        } else {\\n            hi = mid - 1;\\n        }\\n    }\\n    return lo - 1; // last good was mid, 1 below lo (## above)\\n};\\n```\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maximumCandies = function (candies, k) {\\n    function ok(min_candy) {\\n        let count = 0;\\n        for (let candy of candies) count += Math.floor(candy / min_candy);\\n        return count >= k;\\n    }\\n\\n    let l = 0,\\n        h = Math.max(...candies);\\n\\n    while (l <= h) {\\n        let m = l + Math.trunc((h - l) / 2);\\n        if (ok(m)) l = m + 1;\\n        else h = m - 1;\\n    }\\n    return h;\\n};\\n```\n```\\nvar maximumCandies = function (cand, k) {\\n    function is_good_number_of_candies(cmin) {\\n        let count = 0;\\n        for (let c of cand) {\\n            count += Math.trunc(c / cmin); // how many mins (cmin) can we give from this pile (c)\\n        }\\n        return count >= k;\\n    }\\n\\n    let sum = cand.reduce((sum, x) => sum + x, 0);\\n    if (sum < k) return 0; // not enough, to give at least 1 candy\\n\\n    let lo = 1; // 1 is possible\\n    let hi = cand.reduce((max, x) => Math.max(max, x), -Infinity); // max possible\\n\\n    // since # of candies are too large, try binary search\\n    while (lo <= hi) {\\n        let mid = lo + Math.trunc((hi - lo) / 2);\\n        if (is_good_number_of_candies(mid)) {\\n            lo = mid + 1; // mid is good (##), try next one\\n        } else {\\n            hi = mid - 1;\\n        }\\n    }\\n    return lo - 1; // last good was mid, 1 below lo (## above)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1908756,
                "title": "c-binary-search-fastest",
                "content": "```\\nclass Solution {\\npublic:\\n    long long solve(vector<int>& c , long long mid){\\n        int n = c.size();\\n        long long cnt = 0;\\n        for(int i = n-1 ; i >= 0 ; i--){\\n            cnt += (c[i]/mid);\\n        }\\n        return cnt;\\n    }\\n    int maximumCandies(vector<int>& c, long long k) {\\n        long long sol = 0;\\n        int n = c.size();\\n        int low = 1;\\n        int high = *max_element(c.begin(),c.end());\\n        while(low <= high){\\n            long long mid = (high+low)/2;\\n            cout<<mid<<\" \";\\n            if(solve(c,mid) >= k){\\n                sol = mid;\\n                low = mid+1;\\n            }\\n            else{\\n                high = mid-1;\\n            }\\n        }\\n        \\n        return sol;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long solve(vector<int>& c , long long mid){\\n        int n = c.size();\\n        long long cnt = 0;\\n        for(int i = n-1 ; i >= 0 ; i--){\\n            cnt += (c[i]/mid);\\n        }\\n        return cnt;\\n    }\\n    int maximumCandies(vector<int>& c, long long k) {\\n        long long sol = 0;\\n        int n = c.size();\\n        int low = 1;\\n        int high = *max_element(c.begin(),c.end());\\n        while(low <= high){\\n            long long mid = (high+low)/2;\\n            cout<<mid<<\" \";\\n            if(solve(c,mid) >= k){\\n                sol = mid;\\n                low = mid+1;\\n            }\\n            else{\\n                high = mid-1;\\n            }\\n        }\\n        \\n        return sol;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3925584,
                "title": "c-binary-search",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& arr, long long k) {\\n          long long int result = 0 ;\\n          long long int low  = 1;\\n          auto it = max_element(arr.begin() , arr.end());\\n          long long int high = (long long int)(*it);\\n          int n = arr.size();\\n          while(low <= high){\\n              long long int mid = low + (high - low)/2;\\n              long long int count = 0;\\n              for(int i = 0 ; i < n ; i++){\\n                  count += ((long long int)arr[i] / mid);\\n                  if(count >= k)break;\\n              }\\n              if(count >= k){\\n                   result = mid;\\n                   low = mid + 1;\\n               }else{\\n                   high = mid - 1;\\n              }\\n          }\\n          return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& arr, long long k) {\\n          long long int result = 0 ;\\n          long long int low  = 1;\\n          auto it = max_element(arr.begin() , arr.end());\\n          long long int high = (long long int)(*it);\\n          int n = arr.size();\\n          while(low <= high){\\n              long long int mid = low + (high - low)/2;\\n              long long int count = 0;\\n              for(int i = 0 ; i < n ; i++){\\n                  count += ((long long int)arr[i] / mid);\\n                  if(count >= k)break;\\n              }\\n              if(count >= k){\\n                   result = mid;\\n                   low = mid + 1;\\n               }else{\\n                   high = mid - 1;\\n              }\\n          }\\n          return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3601419,
                "title": "binary-search-c-with-explanation",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere i apply **Binary Search Algorithm** to find out Maximum Number of candies.\\n\\nMaximum Number of Candies Always Belong to range **[1 , Maximum of array]** , number of Maximum Candies can be any Element from this sorted array that satisfy the given condition-\\n**[1,2,3,4,5,6,7,8,9...........Maximum of given array]**\\n\\nFirst  = 1 \\nLast   = Maximum\\n\\nFind Index That Satisfy the Given Condition(allocate piles of candies to k children such that each child gets the same number of candies) ?\\n\\n**Note:-Here I also apply the same approach, have a look at these problems and try to solve with the same approach.**\\n\\n**Problem:-** https://leetcode.com/problems/koko-eating-bananas/description/\\n**Solution:-** https://leetcode.com/problems/koko-eating-bananas/solutions/3601174/binary-search-c-with-explanation/\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:O(N*Log(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int> arr,long long k,int n)\\n    {\\n        long long count = 0;\\n        for(int i = 0;i<arr.size();i++)\\n        count+=(arr[i]/n);\\n        \\n        if(count>=k)\\n        return true;\\n\\n        return false;\\n    }\\n    int maximumCandies(vector<int>& arr, long long k) {\\n        \\n           int n = arr.size(),ans = 0;\\n           int first = 1,last = INT_MIN;\\n\\n           for(int i = 0;i<n;i++)\\n           last = max(last,arr[i])+1;\\n        \\n           while(first<last)\\n           {\\n               int mid = (first+last)/2;\\n\\n               if(check(arr,k,mid))\\n               {\\n                   first = mid+1;\\n                   ans = max(ans,mid);\\n               }\\n               else\\n               last = mid;\\n           }\\n           \\n           return ans;\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/4d957791-93e7-424e-a2ba-a546017c5145_1685983637.253224.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int> arr,long long k,int n)\\n    {\\n        long long count = 0;\\n        for(int i = 0;i<arr.size();i++)\\n        count+=(arr[i]/n);\\n        \\n        if(count>=k)\\n        return true;\\n\\n        return false;\\n    }\\n    int maximumCandies(vector<int>& arr, long long k) {\\n        \\n           int n = arr.size(),ans = 0;\\n           int first = 1,last = INT_MIN;\\n\\n           for(int i = 0;i<n;i++)\\n           last = max(last,arr[i])+1;\\n        \\n           while(first<last)\\n           {\\n               int mid = (first+last)/2;\\n\\n               if(check(arr,k,mid))\\n               {\\n                   first = mid+1;\\n                   ans = max(ans,mid);\\n               }\\n               else\\n               last = mid;\\n           }\\n           \\n           return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3365306,
                "title": "using-binary-search-on-answer-explanation",
                "content": "instead of applying binary search directly on array we will apply binary search on the range of the answer.\\n\\nlow = 1 because there can be minimum 1 candy in the array\\nhigh = maximum in the array because that is the maaximum amount of candies that can be present in the pile\\n\\n\\nnow we want to validate each mid that we will get \\n# Code\\n```\\nclass Solution {\\n    public int maximumCandies (int[] candies, long k) {\\n        int max = 0;\\n        for (int i : candies) {\\n            max = (max > i) ? max : i;\\n        }\\n        int start = 1, end = max, mid = 0, res = 0;\\n        while (start <= end) {\\n            mid = start + (end - start) / 2;\\n            if (isValid(candies, k, mid)) {\\n                res = mid;\\n                start = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        return res;\\n    }\\n    private boolean isValid(int[] candies, long k, int mid) {\\n        long totalPiles = 0;\\n        for (int i : candies) {\\n            int toAdd = i / mid;\\n            totalPiles += toAdd;\\n        }\\n        return totalPiles >= k;\\n    }\\n\\n}\\n```\\nyou can check out my github repository where i am uploading famous interview questions topic wise with solutions.\\nlink-- https://github.com/Abhaydutt2003/DataStructureAndAlgoPractice \\nkindly upvote if you like my solution. you can ask doubts below.\\n",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies (int[] candies, long k) {\\n        int max = 0;\\n        for (int i : candies) {\\n            max = (max > i) ? max : i;\\n        }\\n        int start = 1, end = max, mid = 0, res = 0;\\n        while (start <= end) {\\n            mid = start + (end - start) / 2;\\n            if (isValid(candies, k, mid)) {\\n                res = mid;\\n                start = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        return res;\\n    }\\n    private boolean isValid(int[] candies, long k, int mid) {\\n        long totalPiles = 0;\\n        for (int i : candies) {\\n            int toAdd = i / mid;\\n            totalPiles += toAdd;\\n        }\\n        return totalPiles >= k;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272035,
                "title": "c-binary-search-on-search-space-easy-solution",
                "content": "**Time Complexity : O(n*logm)** , where m is the maximum number of candies in the single pile.\\n```\\nclass Solution {\\nprivate:\\n    bool isValid(vector<int>& candies, long long k, int max_candies){\\n        long long child_cnt = 0;\\n        \\n        for(auto candies: candies)\\n            child_cnt += candies/max_candies;\\n        \\n        return child_cnt >= k;\\n    }\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int start = 1;\\n        int end = *max_element(candies.begin(), candies.end());\\n        int res = 0;\\n\\t\\t\\n        while(start <= end){\\n            int mid = start+(end-start)/2;\\n            if(isValid(candies, k, mid)){\\n                res = mid;\\n                start = mid+1;\\n            }\\n            else\\n                end = mid-1;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\nUpvote if this helps.\\nThanks!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool isValid(vector<int>& candies, long long k, int max_candies){\\n        long long child_cnt = 0;\\n        \\n        for(auto candies: candies)\\n            child_cnt += candies/max_candies;\\n        \\n        return child_cnt >= k;\\n    }\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int start = 1;\\n        int end = *max_element(candies.begin(), candies.end());\\n        int res = 0;\\n\\t\\t\\n        while(start <= end){\\n            int mid = start+(end-start)/2;\\n            if(isValid(candies, k, mid)){\\n                res = mid;\\n                start = mid+1;\\n            }\\n            else\\n                end = mid-1;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269073,
                "title": "easy-java-code-beats-99",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst find the range of candies to be distributed then,\\nUse Binary Search to find the maximum number of candies distributed.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(nlogn)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        \\n        long sum = 0;\\n        for(int i = 0 ; i < candies.length; i++){\\n            sum+= candies[i];\\n        }\\n        int left = 1;\\n        int right = (int)(sum/k);\\n        // System.out.println(sum+\" \"+right);\\n        \\n        while(left <= right){\\n            int mid = (right - left) / 2 + left;\\n            long count = 0;\\n            \\n            for(int i = 0 ; i < candies.length; i++){\\n                count+= candies[i]/mid;\\n            }\\n            if(count >= k){\\n                left = mid+1;\\n            }\\n            else{\\n                right = mid-1;\\n            }\\n        }\\n        return right;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        \\n        long sum = 0;\\n        for(int i = 0 ; i < candies.length; i++){\\n            sum+= candies[i];\\n        }\\n        int left = 1;\\n        int right = (int)(sum/k);\\n        // System.out.println(sum+\" \"+right);\\n        \\n        while(left <= right){\\n            int mid = (right - left) / 2 + left;\\n            long count = 0;\\n            \\n            for(int i = 0 ; i < candies.length; i++){\\n                count+= candies[i]/mid;\\n            }\\n            if(count >= k){\\n                left = mid+1;\\n            }\\n            else{\\n                right = mid-1;\\n            }\\n        }\\n        return right;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3157693,
                "title": "java-sol-easy-binary-search-simple",
                "content": "# Code\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int low = 1;\\n        int high = Arrays.stream(candies).max().getAsInt();\\n        int ans = 0;\\n        while (low<=high) {\\n            int mid = low + (high-low)/2;\\n            long currAns = 0;\\n            for (int i : candies) {\\n                currAns += i/mid;\\n            }\\n            if (currAns >= k) {\\n                low = mid+1;\\n                ans = Math.max(ans, mid);\\n            }\\n            else {\\n                high = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int low = 1;\\n        int high = Arrays.stream(candies).max().getAsInt();\\n        int ans = 0;\\n        while (low<=high) {\\n            int mid = low + (high-low)/2;\\n            long currAns = 0;\\n            for (int i : candies) {\\n                currAns += i/mid;\\n            }\\n            if (currAns >= k) {\\n                low = mid+1;\\n                ans = Math.max(ans, mid);\\n            }\\n            else {\\n                high = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911441,
                "title": "binary-search-method",
                "content": "class Solution {\\npublic:\\n    bool allocation(vector<int>& candies,long long k,long long mid){\\n        if(mid==0) return true;\\n        \\n        long long q=0;\\n        long long count=0;\\n         for(int i=0;i<candies.size();i++){\\n            int q=candies[i]/mid;\\n            count+=q;\\n            if(count>=k){\\n               return true;\\n              }\\n        }\\n        \\n        return false;\\n        \\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        \\n        int ans=0;\\n        for(int i=0;i<candies.size();i++){\\n          ans=max(ans,candies[i]);\\n        }  \\n        long long low=0,high=ans;\\n        while(low<high){\\n            long long mid=(low+high)/2;\\n            \\n            if(allocation(candies,k,mid)){\\n                low=mid+1;\\n            }else{\\n                high=mid;\\n            }\\n        }\\n       \\n       return allocation(candies,k,low)?low:low-1;\\n        \\n       \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool allocation(vector<int>& candies,long long k,long long mid){\\n        if(mid==0) return true;\\n        \\n        long long q=0;\\n        long long count=0;\\n         for(int i=0;i<candies.size();i++){\\n            int q=candies[i]/mid;\\n            count+=q;\\n            if(count>=k){\\n               return true;\\n              }",
                "codeTag": "Java"
            },
            {
                "id": 1911109,
                "title": "c-simple-binary-search-solution-o-n-log-max-candies",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& arr,int mid, long long k){\\n        long long count = 0;\\n        for(int i : arr){\\n            count += (i/mid);\\n        }\\n        \\n        return (count >= k);\\n    }\\n    \\n    int maximumCandies(vector<int>& arr, long long k) {\\n        int lo = 1, hi = *max_element(arr.begin(),arr.end()),ans = 0;        \\n        while(lo <= hi){\\n            int mid = lo + (hi - lo)/2;\\n            if(check(arr,mid,k)){\\n                ans = mid;\\n                lo = mid + 1;\\n            }else{\\n                hi = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& arr,int mid, long long k){\\n        long long count = 0;\\n        for(int i : arr){\\n            count += (i/mid);\\n        }\\n        \\n        return (count >= k);\\n    }\\n    \\n    int maximumCandies(vector<int>& arr, long long k) {\\n        int lo = 1, hi = *max_element(arr.begin(),arr.end()),ans = 0;        \\n        while(lo <= hi){\\n            int mid = lo + (hi - lo)/2;\\n            if(check(arr,mid,k)){\\n                ans = mid;\\n                lo = mid + 1;\\n            }else{\\n                hi = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909817,
                "title": "c-binary-search",
                "content": "```\\n  bool is_possible(vector<int>& candies, int mid, long long k)\\n    {\\n        long long count = 0;\\n        \\n        for(int i = 0; i < candies.size(); i++)\\n        {\\n            count += candies[i] / mid;\\n        }\\n        \\n        if(count >= k)\\n            return true;\\n        \\n        return false;\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        \\n        int n = candies.size();\\n        \\n        int low = 1;\\n        \\n        int high = *max_element(candies.begin(), candies.end());\\n        \\n        int ans = 0;\\n        \\n        while(low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            \\n            if(is_possible(candies, mid, k))\\n            {\\n                ans = mid;\\n                \\n                low = mid + 1;\\n            }\\n            else\\n            {\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    \\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n  bool is_possible(vector<int>& candies, int mid, long long k)\\n    {\\n        long long count = 0;\\n        \\n        for(int i = 0; i < candies.size(); i++)\\n        {\\n            count += candies[i] / mid;\\n        }\\n        \\n        if(count >= k)\\n            return true;\\n        \\n        return false;\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        \\n        int n = candies.size();\\n        \\n        int low = 1;\\n        \\n        int high = *max_element(candies.begin(), candies.end());\\n        \\n        int ans = 0;\\n        \\n        while(low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            \\n            if(is_possible(candies, mid, k))\\n            {\\n                ans = mid;\\n                \\n                low = mid + 1;\\n            }\\n            else\\n            {\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1909667,
                "title": "c-binary-search-solution",
                "content": "**Please Upvote If It Helps**\\n```\\nclass Solution {\\npublic:\\n    bool valid(int mid,vector<int>& candies,long long k)\\n    {\\n        // it will containg the count that will tell we can assign or not assign candies to children \\n        long sum = 0;\\n        for(auto it : candies)\\n        {\\n            sum += (it/mid);\\n            \\n            // if any time our sum is reches to k childrens it means we can assign so return true\\n            if(sum>=k)\\n                return true;\\n        }\\n        return false;\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) \\n    {\\n        // initializing two pointers onr for min one for max\\n        // our answer lies between both of them it is final\\n        long left  = 1;\\n        long right = *max_element(begin(candies), end(candies));\\n        \\n        // applyting the binary search for searching that element\\n        while(left<=right)\\n        {\\n            // deriving mid value\\n            long mid = left+(right-left)/2;\\n            \\n            // if we can assign mid candies to k childrens successfully \\n            // then can check for next bigger value\\n            if(valid(mid,candies,k))\\n            {\\n                left = mid+1;\\n            }\\n            \\n            // if we can not assign mid candies to k childrens successfully\\n            // then can check for lesser value\\n            else\\n            {\\n                right = mid-1;\\n            }\\n        }\\n        return right;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool valid(int mid,vector<int>& candies,long long k)\\n    {\\n        // it will containg the count that will tell we can assign or not assign candies to children \\n        long sum = 0;\\n        for(auto it : candies)\\n        {\\n            sum += (it/mid);\\n            \\n            // if any time our sum is reches to k childrens it means we can assign so return true\\n            if(sum>=k)\\n                return true;\\n        }\\n        return false;\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) \\n    {\\n        // initializing two pointers onr for min one for max\\n        // our answer lies between both of them it is final\\n        long left  = 1;\\n        long right = *max_element(begin(candies), end(candies));\\n        \\n        // applyting the binary search for searching that element\\n        while(left<=right)\\n        {\\n            // deriving mid value\\n            long mid = left+(right-left)/2;\\n            \\n            // if we can assign mid candies to k childrens successfully \\n            // then can check for next bigger value\\n            if(valid(mid,candies,k))\\n            {\\n                left = mid+1;\\n            }\\n            \\n            // if we can not assign mid candies to k childrens successfully\\n            // then can check for lesser value\\n            else\\n            {\\n                right = mid-1;\\n            }\\n        }\\n        return right;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909092,
                "title": "java-binary-search-easy-to-understand",
                "content": "**Here I am discussing my approach to this problem**\\n**Approach:**\\n1. First calculate **total number** of candies. Let it be `sum`.\\n2. If `sum < k`, **return 0** we have **more children than candies**.\\n3. If `sum = k`, **return 1** as we have** as many children as candies**.\\n4. Else, perform **binary search** on **number of candies** in the range where `low = 1`, and `high = max of candies`.\\n5. Check for `mid`, if we can distribute mid number of candies to each children, then we can move `low to mid + 1`, else move` high to mid - 1.`\\n6. Store the **last satisfied mid value in `ans`**.\\n7. Return `ans`.\\n\\n**Source Code:**\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        long sum = 0;\\n        long max = 0;\\n        \\n        for(int v : candies) {\\n            sum += v;\\n            max = Math.max(v, max);\\n        }\\n        \\n        if(sum < k)\\n            return 0;\\n        \\n        if(sum == k)\\n            return 1;\\n        \\n        long x = 1, y = max, ans = 1;\\n        \\n        while(x <= y) {\\n            long mid = (x + y) >> 1;\\n            long cur = 0;\\n            \\n            for(int v : candies) {\\n                cur += v / mid;\\n            }\\n            \\n            if(cur>= k) {\\n                ans = mid;\\n                x = mid + 1;\\n            }\\n            else\\n                y = mid - 1;\\n        }\\n        \\n        return (int) (ans);\\n        \\n    }\\n}\\n```\\n\\n**Complexity Analysis:**\\n```\\nTime Complexity: O(n * log(max)) // n = number of candy piles, max = max value of candy pile\\nSpace Complexity : O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        long sum = 0;\\n        long max = 0;\\n        \\n        for(int v : candies) {\\n            sum += v;\\n            max = Math.max(v, max);\\n        }\\n        \\n        if(sum < k)\\n            return 0;\\n        \\n        if(sum == k)\\n            return 1;\\n        \\n        long x = 1, y = max, ans = 1;\\n        \\n        while(x <= y) {\\n            long mid = (x + y) >> 1;\\n            long cur = 0;\\n            \\n            for(int v : candies) {\\n                cur += v / mid;\\n            }\\n            \\n            if(cur>= k) {\\n                ans = mid;\\n                x = mid + 1;\\n            }\\n            else\\n                y = mid - 1;\\n        }\\n        \\n        return (int) (ans);\\n        \\n    }\\n}\\n```\n```\\nTime Complexity: O(n * log(max)) // n = number of candy piles, max = max value of candy pile\\nSpace Complexity : O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909052,
                "title": "c-binary-search-easy-explaination-code",
                "content": "```\\n\\nclass Solution\\n{\\npublic:\\n    long long int maxPiles(vector<int> candies, long long int k)\\n    {\\n        long long int l = 1; // We can select an minimum 1 element\\n        long long int h = 0;\\n        for (auto i : candies)\\n        {\\n            h += i;\\n        }\\n        if (k > h)\\n        {\\n            return 0;\\n        }\\n        h /= k; // at most selection\\n                //  this ans for storing mid value\\n        int ans = 0;\\n        while (l <= h)\\n        {\\n            long long mid = (l + h) / 2;\\n            long long int count = 0;\\n            for (auto i : candies)\\n            {\\n                int tt = (i / mid);\\n                count += tt;\\n            }\\n            if (count >= k)\\n            {\\n                ans = mid; // updating mid\\n                l = mid + 1;\\n            }\\n            else\\n            {\\n                h = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int maximumCandies(vector<int> &candies, long long k)\\n    {\\n        return maxPiles(candies, k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n\\nclass Solution\\n{\\npublic:\\n    long long int maxPiles(vector<int> candies, long long int k)\\n    {\\n        long long int l = 1; // We can select an minimum 1 element\\n        long long int h = 0;\\n        for (auto i : candies)\\n        {\\n            h += i;\\n        }\\n        if (k > h)\\n        {\\n            return 0;\\n        }\\n        h /= k; // at most selection\\n                //  this ans for storing mid value\\n        int ans = 0;\\n        while (l <= h)\\n        {\\n            long long mid = (l + h) / 2;\\n            long long int count = 0;\\n            for (auto i : candies)\\n            {\\n                int tt = (i / mid);\\n                count += tt;\\n            }\\n            if (count >= k)\\n            {\\n                ans = mid; // updating mid\\n                l = mid + 1;\\n            }\\n            else\\n            {\\n                h = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int maximumCandies(vector<int> &candies, long long k)\\n    {\\n        return maxPiles(candies, k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908784,
                "title": "cpp-binary-search-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    //checks if each children can get C candies\\n    bool isPossible(vector<int>& candies, long long C, long long k) {\\n        long long cnt = 0;\\n        for(auto c : candies) {\\n            cnt += (long long)(c/C);\\n        }\\n        \\n        return cnt >= k;\\n    }\\n    \\n    //Binary Search on ans(no. of candies each can get)\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long sum = 0;\\n        for(auto c : candies) sum += (long long)c;\\n        \\n        long long end = sum / k + 1;\\n        long long beg = 0;\\n        while(beg + 1 < end) {\\n            long long mid = (beg + end) / 2;\\n            if(isGood(candies, mid, k)) beg = mid;\\n            else end = mid;\\n        }\\n        \\n        return (int)beg;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    //checks if each children can get C candies\\n    bool isPossible(vector<int>& candies, long long C, long long k) {\\n        long long cnt = 0;\\n        for(auto c : candies) {\\n            cnt += (long long)(c/C);\\n        }\\n        \\n        return cnt >= k;\\n    }\\n    \\n    //Binary Search on ans(no. of candies each can get)\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long sum = 0;\\n        for(auto c : candies) sum += (long long)c;\\n        \\n        long long end = sum / k + 1;\\n        long long beg = 0;\\n        while(beg + 1 < end) {\\n            long long mid = (beg + end) / 2;\\n            if(isGood(candies, mid, k)) beg = mid;\\n            else end = mid;\\n        }\\n        \\n        return (int)beg;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908729,
                "title": "python-solution-with-binary-search-explained",
                "content": "```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        # The lower bound is 1 and higher bound is maximum value from candies. \\n        lo, hi = 1, max(candies)\\n        # This higher bound is not generally possible except for cases like candies = [5,5,5,5] & k = 4\\n        res = 0 # Current maximum result\\n        if sum(candies) < k: # If true then we cannot give even 1 candy to each child thus return 0\\n            return 0\\n        \\n        def cal_num_of_piles(pile_size): # Criterion function\\n            count = 0\\n            for c in candies:\\n                count += c // pile_size\\n            return count >= k\\n        \\n        while lo <= hi: # Binary Search Algorithm \\n            mid = (lo + hi + 1) // 2 # Expected answer\\n            if cal_num_of_piles(mid): # Check if mid is a possible answer.\\n                res = mid # Update the current maximum answer\\n                lo = mid + 1 # Check ahead of mid\\n            else:\\n                hi = mid - 1 # Check below mid\\n        return res\\n```\\n\\n**Concept of Binary Search on Answer:**\\nThe best way to explain Binary Search the Answer is that we use binary search to guess the answer to the problem. By guessing we mean that we will get several \\u201CYES\\u201D or \\u201CNO\\u201D feedback or maybe \\u201Ctoo high\\u201D, \\u201Ctoo low\\u201D, or \\u201Cexactly\\u201D responses. Since we need the maximum answer Binary Search tries to converge on the largest possible answer till the possibility exists.\\n\\n**Binary Search on Answer has 3 basic requirements:**\\n1. The problem must have multiple possible answers. **[Range of possible solutions]**\\n2. The problem must be an optimization problem. **[Minimizing/Maximizing the result]**\\n3. We must develope a function/criterion to determine when to update left and right pointers. **[Criterion to update pointers]**\\n\\n**Observations:**\\n`For candies = [5,8,6] & k = 3` we have many possible answers: 1, 2, 3, 4, 5 all seem to work fine but we return 5 as it is the largest.\\n1. Thus we have a range of solutions and we are asked to maximize the final result. **Requirement 1 and 2 are fulfilled**.\\n2. One might feel that the possible answers must be smaller than the smallest value of an array. Eg: `for candies = [5,6,8] & k = 3` then the answer is 5. For say `candies = [7,9,13] & k = 4` the possible answers are 6, 5...2, 1. However this is not always correct. For Eg: `candies = [1,2,3,4,10] & k = 5` the possible answers are 1, 2, 3. Here we can neglect the 0th and 1st piles to get a better answer. This is because we are told that we may let some piles of candies go unused.\\n3. **Developing the criterion:** Since we only need to check if a given value can be possibly divided k times with the given candies array. Hence we get an easy update function. \\n\\t```\\n\\tdef cal_num_of_piles(pile_size):\\n\\t\\tcount = 0 # Number of divisions with current pile_size\\n\\t\\tfor c in candies:\\n\\t\\t\\tcount += c // pile_size # Add how many piles can be generated with ith candies with given pile_size\\n\\t\\treturn count >= k\\n\\t```\\n***So all three requirements are now fulfilled.***\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        # The lower bound is 1 and higher bound is maximum value from candies. \\n        lo, hi = 1, max(candies)\\n        # This higher bound is not generally possible except for cases like candies = [5,5,5,5] & k = 4\\n        res = 0 # Current maximum result\\n        if sum(candies) < k: # If true then we cannot give even 1 candy to each child thus return 0\\n            return 0\\n        \\n        def cal_num_of_piles(pile_size): # Criterion function\\n            count = 0\\n            for c in candies:\\n                count += c // pile_size\\n            return count >= k\\n        \\n        while lo <= hi: # Binary Search Algorithm \\n            mid = (lo + hi + 1) // 2 # Expected answer\\n            if cal_num_of_piles(mid): # Check if mid is a possible answer.\\n                res = mid # Update the current maximum answer\\n                lo = mid + 1 # Check ahead of mid\\n            else:\\n                hi = mid - 1 # Check below mid\\n        return res\\n```\n```\\n\\tdef cal_num_of_piles(pile_size):\\n\\t\\tcount = 0 # Number of divisions with current pile_size\\n\\t\\tfor c in candies:\\n\\t\\t\\tcount += c // pile_size # Add how many piles can be generated with ith candies with given pile_size\\n\\t\\treturn count >= k\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 3822063,
                "title": "beats-100-binary-search-easy-approach",
                "content": "# Complexity\\n- Time complexity : $$O(NlogN + NlogM)$$ M = Range i.e. high-low = totSum/k-1\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int n = candies.size();\\n        sort(begin(candies),end(candies));\\n\\n        long long totSum = accumulate(begin(candies),end(candies),0ll);\\n        if(totSum < k) return 0;\\n\\n        long long low=1 , high=totSum/k; // can also take some bigger value like 1e8\\n        while(low <= high) {\\n            long long mid = low + (high-low)/2;\\n\\n            if(isPossible(mid,candies,k)) low = mid+1;\\n            else high = mid-1;\\n        }\\n        return high;\\n    }\\n\\n    bool isPossible(long long mid, vector<int> &candies, long long k) {\\n        int n = candies.size();\\n        long long cnt = 0;\\n        for(int i=0 ; i<n ; i++) {\\n            cnt += 1ll*(candies[i]/mid);\\n        }\\n        return cnt>=k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int n = candies.size();\\n        sort(begin(candies),end(candies));\\n\\n        long long totSum = accumulate(begin(candies),end(candies),0ll);\\n        if(totSum < k) return 0;\\n\\n        long long low=1 , high=totSum/k; // can also take some bigger value like 1e8\\n        while(low <= high) {\\n            long long mid = low + (high-low)/2;\\n\\n            if(isPossible(mid,candies,k)) low = mid+1;\\n            else high = mid-1;\\n        }\\n        return high;\\n    }\\n\\n    bool isPossible(long long mid, vector<int> &candies, long long k) {\\n        int n = candies.size();\\n        long long cnt = 0;\\n        for(int i=0 ; i<n ; i++) {\\n            cnt += 1ll*(candies[i]/mid);\\n        }\\n        return cnt>=k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3273752,
                "title": "beats-99-easy-binary-search",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int n=candies.size();\\n        long long sum=0;\\n        for(auto i:candies)sum+=i;\\n        int mn=*min_element(candies.begin(),candies.end());\\n        long long s=mn/((k+n-1)/n);\\n        long long e=sum/k;\\n        long long m;\\n        while(s<=e){\\n            m=(s+e)/2;\\n            long long ct=0;\\n            if(m==0){\\n                ct=LONG_MAX;\\n            }else{\\n            for(auto i:candies){\\n                ct+=(i/m);\\n            }\\n            }\\n            if(ct<k){\\n                e=m-1;\\n            }else{\\n                s=m+1;\\n            }\\n        }\\n        return e;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int n=candies.size();\\n        long long sum=0;\\n        for(auto i:candies)sum+=i;\\n        int mn=*min_element(candies.begin(),candies.end());\\n        long long s=mn/((k+n-1)/n);\\n        long long e=sum/k;\\n        long long m;\\n        while(s<=e){\\n            m=(s+e)/2;\\n            long long ct=0;\\n            if(m==0){\\n                ct=LONG_MAX;\\n            }else{\\n            for(auto i:candies){\\n                ct+=(i/m);\\n            }\\n            }\\n            if(ct<k){\\n                e=m-1;\\n            }else{\\n                s=m+1;\\n            }\\n        }\\n        return e;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268223,
                "title": "range-bs-runtime-174-ms-beats-98-32-must-see",
                "content": "# Code\\n```\\n//for fast io\\nstatic int fast_io = []() \\n{ \\n    std::ios::sync_with_stdio(false); \\n    cin.tie(nullptr); \\n    cout.tie(nullptr); \\n    return 0; \\n}();\\n\\n#ifdef LOCAL\\n    freopen(\"input.txt\", \"r\" , stdin);\\n    freopen(\"output.txt\", \"w\", stdout);\\n#endif\\n//actual code\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) \\n    {\\n        long long int maxele = *max_element(candies.begin(),candies.end());\\n        long long int start = 0;\\n        long long int end   = maxele;\\n        long long int ans = 0;\\n\\n        while(start <= end)\\n        {\\n            long long int mid = (start + ((end-start)/2));\\n\\n            //we will try to allocate the piles to every children \\n            //having exactly mid candies\\n\\n            if(fun(candies,mid,k) == true)\\n            {\\n                if(mid > ans) ans = mid;\\n                start = mid+1;\\n            }\\n            else \\n            {\\n                end = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    bool fun(vector<int>&arr,long long int &mid,long long int &k)\\n    {\\n        if(mid == 0) return true;\\n\\n        long long int count = 0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            long long int temp = (arr[i]/mid);\\n            count = count + temp;\\n        }\\n        if(count >= k) return true;\\n\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\n//for fast io\\nstatic int fast_io = []() \\n{ \\n    std::ios::sync_with_stdio(false); \\n    cin.tie(nullptr); \\n    cout.tie(nullptr); \\n    return 0; \\n}();\\n\\n#ifdef LOCAL\\n    freopen(\"input.txt\", \"r\" , stdin);\\n    freopen(\"output.txt\", \"w\", stdout);\\n#endif\\n//actual code\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) \\n    {\\n        long long int maxele = *max_element(candies.begin(),candies.end());\\n        long long int start = 0;\\n        long long int end   = maxele;\\n        long long int ans = 0;\\n\\n        while(start <= end)\\n        {\\n            long long int mid = (start + ((end-start)/2));\\n\\n            //we will try to allocate the piles to every children \\n            //having exactly mid candies\\n\\n            if(fun(candies,mid,k) == true)\\n            {\\n                if(mid > ans) ans = mid;\\n                start = mid+1;\\n            }\\n            else \\n            {\\n                end = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    bool fun(vector<int>&arr,long long int &mid,long long int &k)\\n    {\\n        if(mid == 0) return true;\\n\\n        long long int count = 0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            long long int temp = (arr[i]/mid);\\n            count = count + temp;\\n        }\\n        if(count >= k) return true;\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2962740,
                "title": "c-binary-search-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool solve(vector<int>& candies, long long k, int mid) {\\n        long long n = candies.size(), candy = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            candy = candy + candies[i]/mid;\\n        }\\n\\n        if(candy >= k) \\n            return true;\\n\\n        else return false;\\n        \\n    }\\n\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long n = candies.size(), max = INT_MIN;\\n        long long sum = 0;\\n\\n        for(int i = 0; i < n; i++) {\\n            sum = candies[i] + sum;         //calculating sum of all candies\\n            if(candies[i] > max) {          //calculating minimum pile of candy\\n                max = candies[i];\\n            }\\n        }\\n\\n        if(sum < k) {\\n            return 0;       // bcoz no. children is more than total candy\\n        }\\n\\n        long long start = 1, end = max, ans = 0;\\n        long long mid = start + (end - start)/2;\\n\\n        while(start <= end) {\\n            int mid = start + (end - start)/2;\\n\\n            if(solve(candies, k, mid)) {\\n                start = mid + 1;\\n                ans = mid;\\n            }\\n\\n            else {\\n                end = mid - 1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n# Complexity\\n- Time complexity: O(n log m)\\n\\n- Space complexity: O(1)",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(vector<int>& candies, long long k, int mid) {\\n        long long n = candies.size(), candy = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            candy = candy + candies[i]/mid;\\n        }\\n\\n        if(candy >= k) \\n            return true;\\n\\n        else return false;\\n        \\n    }\\n\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long n = candies.size(), max = INT_MIN;\\n        long long sum = 0;\\n\\n        for(int i = 0; i < n; i++) {\\n            sum = candies[i] + sum;         //calculating sum of all candies\\n            if(candies[i] > max) {          //calculating minimum pile of candy\\n                max = candies[i];\\n            }\\n        }\\n\\n        if(sum < k) {\\n            return 0;       // bcoz no. children is more than total candy\\n        }\\n\\n        long long start = 1, end = max, ans = 0;\\n        long long mid = start + (end - start)/2;\\n\\n        while(start <= end) {\\n            int mid = start + (end - start)/2;\\n\\n            if(solve(candies, k, mid)) {\\n                start = mid + 1;\\n                ans = mid;\\n            }\\n\\n            else {\\n                end = mid - 1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2836560,
                "title": "simple-c-solution-using-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int n;\\n    bool good(int x , long long k , vector<int> &arr ){\\n        long long ct = 0;\\n        for(int i=0 ; i<n ; i++){\\n            ct += (arr[i]/x);\\n        }\\n        return (ct>=k);\\n    }\\n    int maximumCandies(vector<int>& arr, long long k) {\\n        int low = 1;\\n        int high = 1e9+1;\\n        n = arr.size();\\n        int ans = 0;\\n        \\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n            \\n            if(good(mid , k , arr)){\\n                ans = mid;\\n                low = mid+1;\\n            }\\n            else{\\n                high = mid-1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n// [4,7,5]\\n// 4\\n\\n// op -> 3\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    bool good(int x , long long k , vector<int> &arr ){\\n        long long ct = 0;\\n        for(int i=0 ; i<n ; i++){\\n            ct += (arr[i]/x);\\n        }\\n        return (ct>=k);\\n    }\\n    int maximumCandies(vector<int>& arr, long long k) {\\n        int low = 1;\\n        int high = 1e9+1;\\n        n = arr.size();\\n        int ans = 0;\\n        \\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n            \\n            if(good(mid , k , arr)){\\n                ans = mid;\\n                low = mid+1;\\n            }\\n            else{\\n                high = mid-1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n// [4,7,5]\\n// 4\\n\\n// op -> 3\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2565461,
                "title": "99-faster-python-solution",
                "content": "![image](https://assets.leetcode.com/users/images/8f3fb19a-40a0-4acf-9475-84ea66780864_1662967246.5710497.png)\\n\\n```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        if sum(candies)<k:return 0\\n        else:\\n            low=0 \\n            high=max(candies)\\n            while low<high:\\n                mid=math.ceil((low+high)/2)\\n                if sum(c//mid for c in candies)>=k: low=mid\\n                else: high=mid-1\\n            return low\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        if sum(candies)<k:return 0\\n        else:\\n            low=0 \\n            high=max(candies)\\n            while low<high:\\n                mid=math.ceil((low+high)/2)\\n                if sum(c//mid for c in candies)>=k: low=mid\\n                else: high=mid-1\\n            return low\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2503906,
                "title": "binary-search-ac-code-explained-with-comments",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    \\n    bool isValid(vector<int> &candies, long long k, long long mid){\\n\\n        long long total = 0;\\n        \\n        for(int i=0;i<candies.size();i++){ \\n            \\n           //Here we are maintaining the count of candies that we are distributing. \\n           total += candies[i]/mid;\\n            \\n        }\\n        \\n        //Checking if the total number of candies that can be distirbuted\\n        //for the pile of value \\'mid\\' is less than or equal to total no. of children.\\n        //If the above condition is false then we cannot divide the candies into piler of size mid\\n        return (total>=k);\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        //We will do the binary search for all the elements \\n        // from \\'1\\' to the largest value in the candies.\\n        int low = 1;\\n        int high = INT_MIN;\\n        \\n        for(int i=0;i<candies.size();i++){\\n            high = max(high, candies[i]);\\n        }\\n        \\n        int ans = 0;\\n        \\n        while(low<=high){\\n            long long mid = (low+high)/2;\\n            \\n            //Checking if the middle element can be a valid pile.\\n            //If the function returns true than we will move to the left side to\\n            //check if even a larger answer is possible.\\n            if(isValid(candies, k, mid)){\\n                ans = mid;\\n                low = mid+1;\\n            }else{\\n                //If the function returns false then we will move to the left half\\n                //to find the possible valid pile value.\\n                high = mid-1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool isValid(vector<int> &candies, long long k, long long mid){\\n\\n        long long total = 0;\\n        \\n        for(int i=0;i<candies.size();i++){ \\n            \\n           //Here we are maintaining the count of candies that we are distributing. \\n           total += candies[i]/mid;\\n            \\n        }\\n        \\n        //Checking if the total number of candies that can be distirbuted\\n        //for the pile of value \\'mid\\' is less than or equal to total no. of children.\\n        //If the above condition is false then we cannot divide the candies into piler of size mid\\n        return (total>=k);\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        //We will do the binary search for all the elements \\n        // from \\'1\\' to the largest value in the candies.\\n        int low = 1;\\n        int high = INT_MIN;\\n        \\n        for(int i=0;i<candies.size();i++){\\n            high = max(high, candies[i]);\\n        }\\n        \\n        int ans = 0;\\n        \\n        while(low<=high){\\n            long long mid = (low+high)/2;\\n            \\n            //Checking if the middle element can be a valid pile.\\n            //If the function returns true than we will move to the left side to\\n            //check if even a larger answer is possible.\\n            if(isValid(candies, k, mid)){\\n                ans = mid;\\n                low = mid+1;\\n            }else{\\n                //If the function returns false then we will move to the left half\\n                //to find the possible valid pile value.\\n                high = mid-1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2442477,
                "title": "c-efficient-sol-with-explanation-complexity",
                "content": "***Explanation :***\\nAccording to question we have to find the maximum size of each pile that we can get to satisfy k children.\\nWe do this using ***Binary Search : (why?)***\\n***Binary Search can be used on following type of problems :***\\n***1. Maximization problems\\n2. Minimization problems***\\nWe binary search for the maximum size of the pile . \\n***Range of binary search :*** \\n***lo=1***, (cannot be 0 sized pile) ***hi=maximum elemnt in candies array.***\\nFor every mid value , we check if it is possible to make k or more piles of size ***mid***\\n***If yes*** , we move ***lo= mid+1***, to get maximum possible size of pile .\\n***If no*** , then we move ***hi= mid-1*** , to decrease size of pile .\\n\\n***Complexity Analysis :\\nTC : O(n log x ) ( x--> maximum elment in candies array)\\nSC : O(1)***\\n\\n**UPVOTE IF YOU LIKE** \\u2705\\uD83D\\uDE0A\\n```\\nclass Solution {\\npublic:\\n    bool isPossible_to_divide(vector<int>&candies,long long size,long long k){\\n        long long ans=0;\\n        for(int i=0;i<candies.size();i++){\\n            ans+=(candies[i]/size);\\n        }\\n        return ans>=k;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long lo=1,hi=*max_element(candies.begin(),candies.end()),mid,ans=0;\\n        while(lo<=hi){\\n            mid=lo+(hi-lo)/2;\\n            if(isPossible_to_divide(candies, mid, k)){\\n                ans=mid;\\n                lo=mid+1;\\n            }\\n            else hi=mid-1;\\n        }\\n        return  ans;\\n    }\\n};\\n// Any other queries are welcomed as well.\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible_to_divide(vector<int>&candies,long long size,long long k){\\n        long long ans=0;\\n        for(int i=0;i<candies.size();i++){\\n            ans+=(candies[i]/size);\\n        }\\n        return ans>=k;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long lo=1,hi=*max_element(candies.begin(),candies.end()),mid,ans=0;\\n        while(lo<=hi){\\n            mid=lo+(hi-lo)/2;\\n            if(isPossible_to_divide(candies, mid, k)){\\n                ans=mid;\\n                lo=mid+1;\\n            }\\n            else hi=mid-1;\\n        }\\n        return  ans;\\n    }\\n};\\n// Any other queries are welcomed as well.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2402075,
                "title": "c-binary-search-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& c, long long k) {\\n        int left = 1, right = *max_element(c.begin(), c.end());\\n        int ans = 0;\\n        while(left <= right){\\n            int Cand = (left + right) >> 1;\\n            long long sum = 0;\\n            for(auto it: c){\\n                sum += it / Cand;\\n                if(sum >= k) break;\\n            }\\n            if(sum >= k){\\n                ans = Cand;\\n                left = Cand + 1;\\n            }\\n            else{\\n                right = Cand-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& c, long long k) {\\n        int left = 1, right = *max_element(c.begin(), c.end());\\n        int ans = 0;\\n        while(left <= right){\\n            int Cand = (left + right) >> 1;\\n            long long sum = 0;\\n            for(auto it: c){\\n                sum += it / Cand;\\n                if(sum >= k) break;\\n            }\\n            if(sum >= k){\\n                ans = Cand;\\n                left = Cand + 1;\\n            }\\n            else{\\n                right = Cand-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2276939,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& c,long long k,int mid)\\n    {\\n        if(!mid)\\n            return 1;\\n      long long x=0;    \\n        for(int i=0;i<c.size();i++)\\n        {\\n            x+=(c[i]/mid);\\n        }\\n        return x>=k;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int low=0,ans=0;\\n       int high=*max_element(candies.begin(),candies.end());\\n        while(low<=high)\\n        {\\n           int mid=(high+low)>>1;\\n            if(solve(candies,k,mid))\\n            {\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else\\n            {\\n                high=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& c,long long k,int mid)\\n    {\\n        if(!mid)\\n            return 1;\\n      long long x=0;    \\n        for(int i=0;i<c.size();i++)\\n        {\\n            x+=(c[i]/mid);\\n        }\\n        return x>=k;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int low=0,ans=0;\\n       int high=*max_element(candies.begin(),candies.end());\\n        while(low<=high)\\n        {\\n           int mid=(high+low)>>1;\\n            if(solve(candies,k,mid))\\n            {\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else\\n            {\\n                high=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2158323,
                "title": "binary-search-approach-with-detailed-explained-in-comments",
                "content": "### Please Upvote if you like this\\n\\n#### Time Complexity: Log(mx)  * O(N)\\n#### Log(mx) for binary search and O(N) for iterating through the candies array.\\n\\n#### Space Complexity: O(1) because we did use constant extra space.\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n//         get the sum and mx of all candies\\n        long long sum = 0;\\n        int mx = INT_MIN;\\n//         Iterate the loop to get the sum of all values and maximum among then\\n        for(int &i: candies){\\n            sum += i;\\n            mx = max(i, mx);\\n        }\\n        \\n//         if sum < k then return 0 because it will never fulfill the k children requirements:\\n//         \"each child gets the same number of candies\" it impossible to distribute atleast 1 candy to all so return 0\\n        \\n        if(sum < k) return 0;\\n        \\n//         start pointers for binary search\\n        int start = 1, end = mx;\\n        int ans = 0;\\n        \\n        \\n        while(start <= end){\\n            \\n            int mid = start + (end-start)/2;\\n            long long cand = 0;\\n            \\n//             take floor all values or simply write (i/mid) because it won\\'t let candies to merged\\n            for(int &i: candies){\\n                cand += floor(i/mid);\\n            }\\n            \\n//             cand >= k means that no. of mid candies can be distributed among all children. If cand >= k update the answer and search for more bigger value.\\n            if(cand >= k){\\n                ans = mid;\\n                start = mid + 1;\\n            }\\n//             if it doesn\\'t satisfy the condition then search for lower value.\\n            else{\\n                end = mid-1;\\n            }\\n        }\\n        // return the possible answer if it is otherwise return 0 as default value of ans.\\n        return ans;\\n    }\\n};\\n```\\n### Please Upvote if you like this",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n//         get the sum and mx of all candies\\n        long long sum = 0;\\n        int mx = INT_MIN;\\n//         Iterate the loop to get the sum of all values and maximum among then\\n        for(int &i: candies){\\n            sum += i;\\n            mx = max(i, mx);\\n        }\\n        \\n//         if sum < k then return 0 because it will never fulfill the k children requirements:\\n//         \"each child gets the same number of candies\" it impossible to distribute atleast 1 candy to all so return 0\\n        \\n        if(sum < k) return 0;\\n        \\n//         start pointers for binary search\\n        int start = 1, end = mx;\\n        int ans = 0;\\n        \\n        \\n        while(start <= end){\\n            \\n            int mid = start + (end-start)/2;\\n            long long cand = 0;\\n            \\n//             take floor all values or simply write (i/mid) because it won\\'t let candies to merged\\n            for(int &i: candies){\\n                cand += floor(i/mid);\\n            }\\n            \\n//             cand >= k means that no. of mid candies can be distributed among all children. If cand >= k update the answer and search for more bigger value.\\n            if(cand >= k){\\n                ans = mid;\\n                start = mid + 1;\\n            }\\n//             if it doesn\\'t satisfy the condition then search for lower value.\\n            else{\\n                end = mid-1;\\n            }\\n        }\\n        // return the possible answer if it is otherwise return 0 as default value of ans.\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017213,
                "title": "c-binary-search-by-value",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        // corner case\\n        long long sum = 0;\\n        for(auto c : candies){\\n            sum += c;\\n        }\\n        if(sum < k){\\n            return 0;\\n        }\\n        // binary search\\n        long long start = 1, end = *max_element(candies.begin(), candies.end());\\n        while(start < end){\\n            long long mid = start + (end - start + 1) / 2; // since we want to get the upper bound of the answers(maximum)\\n            long long count = numKidsAllocatedWithGivenCandyNum(candies, mid);\\n            if(count < k){\\n                // the number is too large, mid cannot be the answer\\n                end = mid - 1; \\n            }\\n            else{\\n                // the number is too small, but could be the answer\\n                start = mid;\\n            }\\n        }\\n        \\n        return start;\\n    }\\n    \\n    long long numKidsAllocatedWithGivenCandyNum(vector<int>& candies, int val){\\n        long long count = 0;\\n        for(auto candy : candies){\\n            count += candy / val;\\n        }\\n        return count;\\n    }\\n \\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        // corner case\\n        long long sum = 0;\\n        for(auto c : candies){\\n            sum += c;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2008765,
                "title": "python-binary-search",
                "content": "\\n    def maximumCandies(self, candies, k):\\n        def dfs(c):\\n            count = 0\\n            \\n            for candy in candies:\\n                count += candy//c\\n                \\n            if count >= k:\\n                return True\\n            \\n            return False\\n            \\n        low, high = 1, max(candies)\\n        \\n        while low<=high:\\n            mid = (low+high)//2\\n            \\n            if dfs(mid):\\n                low = mid + 1\\n            else:\\n                high = mid - 1\\n                \\n        return high\\n",
                "solutionTags": [],
                "code": "\\n    def maximumCandies(self, candies, k):\\n        def dfs(c):\\n            count = 0\\n            \\n            for candy in candies:\\n                count += candy//c\\n                \\n            if count >= k:\\n                return True\\n            \\n            return False\\n            \\n        low, high = 1, max(candies)\\n        \\n        while low<=high:\\n            mid = (low+high)//2\\n            \\n            if dfs(mid):\\n                low = mid + 1\\n            else:\\n                high = mid - 1\\n                \\n        return high\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1988406,
                "title": "python-binary-search-99",
                "content": "\\n\\n\\n```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        \\n        total_candies = sum(candies)\\n        max_candies = total_candies//k\\n        \\n        if max_candies<=1:\\n            return max_candies\\n        \\n\\n        i, j = 2, max_candies\\n        \\n        \\n        while i<=j:\\n            candy = (i+j)//2\\n            \\n            n_pile = sum([each//candy for each in candies])\\n            \\n            if n_pile>=k: \\n                i = candy+1\\n            else: \\n                j = candy-1\\n                \\n            \\n                \\n        return candy if n_pile >= k else candy-1\\n            \\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        \\n        total_candies = sum(candies)\\n        max_candies = total_candies//k\\n        \\n        if max_candies<=1:\\n            return max_candies\\n        \\n\\n        i, j = 2, max_candies\\n        \\n        \\n        while i<=j:\\n            candy = (i+j)//2\\n            \\n            n_pile = sum([each//candy for each in candies])\\n            \\n            if n_pile>=k: \\n                i = candy+1\\n            else: \\n                j = candy-1\\n                \\n            \\n                \\n        return candy if n_pile >= k else candy-1\\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1985777,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int n=candies.length;\\n        long sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=candies[i];\\n        }\\n        if(sum<k)return 0;\\n        if(sum==k)return 1;\\n        long ans=sum/k;\\n       // System.out.println(ans);\\n        if(ans==1)return (int)ans;\\n        long l=0;\\n        long mid=0;\\n        long h=ans;\\n\\t\\t//binary search\\n        while(l<=h){\\n            mid=l+(h-l)/2;\\n              long c=0;\\n            for(int j=0;j<n;j++){\\n                c+=(long)candies[j]/mid;\\n            }\\n            if(c>=k){\\n                ans=mid;\\n               // System.out.println(ans);\\n                l=mid+1;\\n            }\\n            else{\\n                h=mid-1;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n}",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "class Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int n=candies.length;\\n        long sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=candies[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1976270,
                "title": "java-beats-100-00-memory-speed-0ms-april-2022",
                "content": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int max = Integer.MIN_VALUE;\\n        long sum = 0;\\n        \\n        for (int num: candies) {\\n            max = Math.max(max, num);\\n            sum += num;\\n        }\\n        \\n        if (sum < k) {\\n            return 0;\\n        }\\n        \\n        int left = 1, right = max;\\n        \\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            \\n            if (canBeDistributed(mid, candies, k)) {\\n                if (!canBeDistributed(mid + 1, candies, k)) {\\n                    return mid;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n    \\n    public boolean canBeDistributed(int num, int[] candies, long k) {\\n        for (int i = 0; i < candies.length && k > 0; ++ i) {\\n            k -= candies[i] / num;\\n        }\\n        \\n        return k <= 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int max = Integer.MIN_VALUE;\\n        long sum = 0;\\n        \\n        for (int num: candies) {\\n            max = Math.max(max, num);\\n            sum += num;\\n        }\\n        \\n        if (sum < k) {\\n            return 0;\\n        }\\n        \\n        int left = 1, right = max;\\n        \\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            \\n            if (canBeDistributed(mid, candies, k)) {\\n                if (!canBeDistributed(mid + 1, candies, k)) {\\n                    return mid;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n    \\n    public boolean canBeDistributed(int num, int[] candies, long k) {\\n        for (int i = 0; i < candies.length && k > 0; ++ i) {\\n            k -= candies[i] / num;\\n        }\\n        \\n        return k <= 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1931345,
                "title": "kotlin-binary-search-solution",
                "content": "```\\nclass Solution {\\n    fun maximumCandies(candies: IntArray, k: Long): Int {\\n        var (min, max, sum) = Triple(1, Integer.MIN_VALUE, 0L)\\n        candies.forEach { sum += it.also { if (it > max) max = it } }\\n        if (sum < k) return 0\\n\\n        var result = min\\n        while (max > min) {\\n            if (canEachChildGetCCandies(result, candies, k)) min = result\\n            else max = result -1\\n            result = (min + max + 1) / 2\\n        }\\n        return result\\n    }\\n\\n    fun canEachChildGetCCandies(c: Int, candies: IntArray, k: Long) =\\n        candies.fold(0L) { sum, it -> sum + it / c } >= k\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    fun maximumCandies(candies: IntArray, k: Long): Int {\\n        var (min, max, sum) = Triple(1, Integer.MIN_VALUE, 0L)\\n        candies.forEach { sum += it.also { if (it > max) max = it } }\\n        if (sum < k) return 0\\n\\n        var result = min\\n        while (max > min) {\\n            if (canEachChildGetCCandies(result, candies, k)) min = result\\n            else max = result -1\\n            result = (min + max + 1) / 2\\n        }\\n        return result\\n    }\\n\\n    fun canEachChildGetCCandies(c: Int, candies: IntArray, k: Long) =\\n        candies.fold(0L) { sum, it -> sum + it / c } >= k\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1929691,
                "title": "2-python-solutions-binary-search",
                "content": "### ***Solution 1: Time O(nlog n) / Memory O(1)***\\n```\\nclass Solution:\\n    def maximumCandies(self, C: List[int], k: int) -> int:\\n        lo=0 ; hi=sum(C)//k\\n        while lo<hi:\\n            mid=(lo+hi)//2+1\\n            if sum(c//mid for c in C)>=k: lo=mid\\n            else: hi=mid-1\\n        return lo\\n```\\n-----------------\\n### ***Solution 2: One-Line Version   -->  Time O(nlog n) / Memory O(1)***\\n```\\nclass Solution:\\n    def maximumCandies(self, C: List[int], k: int) -> int:\\n        return bisect_left(range(1,sum(C)//k+1), True, key=lambda x:sum(c//x for c in C)<k)\\n```\\n-------------------\\n***----- Taha Choura -----***\\n*taha.choura@outlook.com*",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCandies(self, C: List[int], k: int) -> int:\\n        lo=0 ; hi=sum(C)//k\\n        while lo<hi:\\n            mid=(lo+hi)//2+1\\n            if sum(c//mid for c in C)>=k: lo=mid\\n            else: hi=mid-1\\n        return lo\\n```\n```\\nclass Solution:\\n    def maximumCandies(self, C: List[int], k: int) -> int:\\n        return bisect_left(range(1,sum(C)//k+1), True, key=lambda x:sum(c//x for c in C)<k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1927152,
                "title": "c-easy-to-understand-with-simple-binary-search",
                "content": "Expalnation  : \\nstep 1 : find minimum and maximum values of candies you can give to each child that gives you the range of minimum and maximum candies minimum is always 0.\\nstep 2: check for one by one each candies per child on range of minimum and maximum what maximum satisfy your condition but linearly you may get TLE so think of Binary search.\\n\\n\\t    // Binary search on minimum and maximum possible values and \\n\\t   //\\tcheck according to mid value it is possible to allocate mid candies to each child\\n\\t  //  if yess then increase low to mid because we want a maximum candies per child\\n...\\n\\n\\nint maximumCandies(vector<int>& candies, long long k) {\\n        long long sum = 0;\\n        for(long long i=0;i<candies.size();i++)\\n            sum += candies[i];\\n        if(sum < k)\\n            return 0;\\n        if(sum==k)\\n            return 1;\\n        long long low = 0;\\n        long long high = sum/k+1;\\n        \\n        long long ans=0;\\n\\t\\t// Binary search on minimum and maximum possible values and \\n\\t\\t//check according to mid value it is possible to allocate mid candies to each child\\n\\t\\t//if yess then increase low to mid because we want a maximum candies per child\\n       while(low < high)\\n       {\\n           int mid = low + (high - low)/2;\\n           if(mid == 0) return 0;\\n           long long count=0;\\n           for(int j=0;j<candies.size();j++)\\n            {\\n               long long pile = candies[j];\\n                count +=  (pile/mid);\\n            }\\n           if(count>=k)\\n           {\\n               if(mid>ans)\\n                   ans = mid;\\n               low = mid+1;\\n           }\\n           else\\n               high = mid;\\n           \\n       }\\n        return ans==0 ? 0 : ans;\\n    }\\n\\t\\n...",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "Expalnation  : \\nstep 1 : find minimum and maximum values of candies you can give to each child that gives you the range of minimum and maximum candies minimum is always 0.\\nstep 2: check for one by one each candies per child on range of minimum and maximum what maximum satisfy your condition but linearly you may get TLE so think of Binary search.\\n\\n\\t    // Binary search on minimum and maximum possible values and \\n\\t   //\\tcheck according to mid value it is possible to allocate mid candies to each child\\n\\t  //  if yess then increase low to mid because we want a maximum candies per child\\n...\\n\\n\\nint maximumCandies(vector<int>& candies, long long k) {\\n        long long sum = 0;\\n        for(long long i=0;i<candies.size();i++)\\n            sum += candies[i];\\n        if(sum < k)\\n            return 0;\\n        if(sum==k)\\n            return 1;\\n        long long low = 0;\\n        long long high = sum/k+1;\\n        \\n        long long ans=0;\\n\\t\\t// Binary search on minimum and maximum possible values and \\n\\t\\t//check according to mid value it is possible to allocate mid candies to each child\\n\\t\\t//if yess then increase low to mid because we want a maximum candies per child\\n       while(low < high)\\n       {\\n           int mid = low + (high - low)/2;\\n           if(mid == 0) return 0;\\n           long long count=0;\\n           for(int j=0;j<candies.size();j++)\\n            {\\n               long long pile = candies[j];\\n                count +=  (pile/mid);\\n            }\\n           if(count>=k)\\n           {\\n               if(mid>ans)\\n                   ans = mid;\\n               low = mid+1;\\n           }\\n           else\\n               high = mid;\\n           \\n       }\\n        return ans==0 ? 0 : ans;\\n    }\\n\\t\\n...",
                "codeTag": "Unknown"
            },
            {
                "id": 1923331,
                "title": "a-few-solutions",
                "content": "Use binary search to find the maximal `k` candy \"chunks\" we can `take` from each `A[i]`<sup>th</sup> pile of candies to satisfy threshold `T` children.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun maximumCandies(A: IntArray, T: Long): Int {\\n        var i = 0\\n        var j = A.max()!!\\n        while (i < j) {\\n            var k = (i + j + 1) / 2\\n            var take = A.map{ it.toLong() / k }.sum()\\n            if (T <= take)\\n                i = k\\n            else\\n                j = k - 1\\n        }\\n        return i\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet maximumCandies = (A, T) => {\\n    let i = 0,\\n        j = Math.max(...A);\\n    while (i < j) {\\n        let k = Math.floor((i + j + 1) / 2);\\n        let take = _.sum(A.map(x => Math.floor(x / k)));\\n        if (T <= take)\\n            i = k;\\n        else\\n            j = k - 1;\\n    }\\n    return i;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def maximumCandies(self, A: List[int], T: int) -> int:\\n        i = 0\\n        j = max(A)\\n        while i < j:\\n            k = (i + j + 1) // 2\\n            take = sum(x // k for x in A)\\n            if T <= take:\\n                i = k\\n            else:\\n                j = k - 1\\n        return i\\n```\\n\\n*Rust*\\n```\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn maximum_candies(A: VI, T: i64) -> i32 {\\n        let mut i = 0;\\n        let mut j = *A.iter().max().unwrap();\\n        while i < j {\\n            let k = (i + j + 1) / 2;\\n            let take: i64 = A.iter().map(|x| *x as i64 / k as i64).sum();\\n            if T <= take {\\n                i = k;\\n            } else {\\n                j = k - 1;\\n            }\\n        }\\n        return i;\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using LL = long long;\\n    int maximumCandies(VI& A, LL T) {\\n        LL i = 0,\\n           j = *max_element(A.begin(), A.end());\\n        while (i < j) {\\n            auto k = (i + j + 1LL) / 2;\\n            auto take = accumulate(A.begin(), A.end(), 0LL, [=](auto t, auto x) { return t + x / k; });\\n            if (T <= take)\\n                i = k;\\n            else\\n                j = k - 1;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun maximumCandies(A: IntArray, T: Long): Int {\\n        var i = 0\\n        var j = A.max()!!\\n        while (i < j) {\\n            var k = (i + j + 1) / 2\\n            var take = A.map{ it.toLong() / k }.sum()\\n            if (T <= take)\\n                i = k\\n            else\\n                j = k - 1\\n        }\\n        return i\\n    }\\n}\\n```\n```\\nlet maximumCandies = (A, T) => {\\n    let i = 0,\\n        j = Math.max(...A);\\n    while (i < j) {\\n        let k = Math.floor((i + j + 1) / 2);\\n        let take = _.sum(A.map(x => Math.floor(x / k)));\\n        if (T <= take)\\n            i = k;\\n        else\\n            j = k - 1;\\n    }\\n    return i;\\n};\\n```\n```\\nclass Solution:\\n    def maximumCandies(self, A: List[int], T: int) -> int:\\n        i = 0\\n        j = max(A)\\n        while i < j:\\n            k = (i + j + 1) // 2\\n            take = sum(x // k for x in A)\\n            if T <= take:\\n                i = k\\n            else:\\n                j = k - 1\\n        return i\\n```\n```\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn maximum_candies(A: VI, T: i64) -> i32 {\\n        let mut i = 0;\\n        let mut j = *A.iter().max().unwrap();\\n        while i < j {\\n            let k = (i + j + 1) / 2;\\n            let take: i64 = A.iter().map(|x| *x as i64 / k as i64).sum();\\n            if T <= take {\\n                i = k;\\n            } else {\\n                j = k - 1;\\n            }\\n        }\\n        return i;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using LL = long long;\\n    int maximumCandies(VI& A, LL T) {\\n        LL i = 0,\\n           j = *max_element(A.begin(), A.end());\\n        while (i < j) {\\n            auto k = (i + j + 1LL) / 2;\\n            auto take = accumulate(A.begin(), A.end(), 0LL, [=](auto t, auto x) { return t + x / k; });\\n            if (T <= take)\\n                i = k;\\n            else\\n                j = k - 1;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1917758,
                "title": "binary-search-pattern-problem-nlog-max-candy",
                "content": "1. Its the common pattern for the binary search and in this case we need to find the maximum candies that can be allocated to K students where each of them get equal amount of candies.\\n2. So we can give 0 candies in minimum or we can give max(candies) to the students\\n3. Thus our search space will be 0 to max(candies)\\n4. Apply our binary search concept.\\n5. Find the middle and check if middle amount of candies can be distributed to k students, if yes, we need to find maximum, so we think there is more optimal answer to the right of our search space that will maximize our result, so update low = middle + 1 and store result = middle.\\n6. If we are not able to distribute middle amount of candies to k number of students, then any candies to the right of middle is also of no use, we need to explore the left part and move right = middle - 1;\\n7. Finally return our result.\\n\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        if (candies == null || candies.length == 0) {\\n            return 0;\\n        }\\n        int low = 0;\\n        int high = findMax(candies);\\n        return binarySearch(candies, k, low, high);\\n    }\\n    \\n    public int binarySearch(int [] candies, long k, int low, int high) {\\n        int result = -1;\\n        while (low <= high) {\\n            int middle = low + (high - low) / 2;\\n            if (isPossibleToDivide(candies, middle, k)) {\\n                result = middle;\\n                low = middle + 1;\\n            }\\n            else {\\n                high = middle - 1;\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    public boolean isPossibleToDivide(int [] candies, int inHand, long k) {\\n        if (inHand == 0) {\\n            return true;\\n        }\\n        long total = 0;\\n        for (int num : candies) {\\n            total += (num) / inHand;\\n            if (total >= k) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public int findMax(int [] candies) {\\n        int max = 0;\\n        for (int num : candies) {\\n            if (max < num) {\\n                max = num;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        if (candies == null || candies.length == 0) {\\n            return 0;\\n        }\\n        int low = 0;\\n        int high = findMax(candies);\\n        return binarySearch(candies, k, low, high);\\n    }\\n    \\n    public int binarySearch(int [] candies, long k, int low, int high) {\\n        int result = -1;\\n        while (low <= high) {\\n            int middle = low + (high - low) / 2;\\n            if (isPossibleToDivide(candies, middle, k)) {\\n                result = middle;\\n                low = middle + 1;\\n            }\\n            else {\\n                high = middle - 1;\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    public boolean isPossibleToDivide(int [] candies, int inHand, long k) {\\n        if (inHand == 0) {\\n            return true;\\n        }\\n        long total = 0;\\n        for (int num : candies) {\\n            total += (num) / inHand;\\n            if (total >= k) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public int findMax(int [] candies) {\\n        int max = 0;\\n        for (int num : candies) {\\n            if (max < num) {\\n                max = num;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910615,
                "title": "cpp-easy-solution-binary-search",
                "content": "## **APPROACH**\\n* First check out how many number of maximum candies we can give to children if there were no constraints\\n* That would be dividing the sum in k children.\\n* So now we know our answer for number of candies we can give each child range from 1 to sum/k  and ( 0 in case of not enough candies)\\n* So find r which is sum/k and l which is 1\\n* And do binary search\\n* in this binary search we need to check that for a pile , how many parts we can create of mid number of candies.\\n* Then add all the parts we got of mid size.\\n* and if this number is more than k , it means , we can possibly give even more candies to each child , so decrease the search space and look for more number of candies that whether it could be a possible ans or not. \\n\\n\\n## **CODE**\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    \\n    bool isValid(vector<int>& candies, ll temp,ll k)\\n    {\\n        ll val=0;\\n        for(auto x:candies)\\n        {\\n            val+=(x/temp);\\n        }\\n        \\n        return val>=k;\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        \\n        // binary search \\n        // find range\\n        \\n        ll sum=0;\\n        for(auto x:candies)\\n        {\\n            sum+=x;\\n        }\\n        \\n        ll l=1,r=sum/k;\\n        \\n        if(r==0)\\n            return 0;\\n        \\n        // now do BS\\n        int ans=0;\\n        while(l<=r)\\n        {\\n            ll mid=l+(r-l)/2;\\n            \\n            bool check=isValid(candies,mid,k);\\n            \\n            if(check)\\n            {\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else\\n            {\\n                r=mid-1;\\n            }\\n                \\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n\\n```\\n\\n### **TIME-COMPLEXITY** :\\nO(nlogm)  where m can be 10^12 in worst case.\\n### **SPACE-COMPLEXITY**:\\nO(1)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    \\n    bool isValid(vector<int>& candies, ll temp,ll k)\\n    {\\n        ll val=0;\\n        for(auto x:candies)\\n        {\\n            val+=(x/temp);\\n        }\\n        \\n        return val>=k;\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        \\n        // binary search \\n        // find range\\n        \\n        ll sum=0;\\n        for(auto x:candies)\\n        {\\n            sum+=x;\\n        }\\n        \\n        ll l=1,r=sum/k;\\n        \\n        if(r==0)\\n            return 0;\\n        \\n        // now do BS\\n        int ans=0;\\n        while(l<=r)\\n        {\\n            ll mid=l+(r-l)/2;\\n            \\n            bool check=isValid(candies,mid,k);\\n            \\n            if(check)\\n            {\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else\\n            {\\n                r=mid-1;\\n            }\\n                \\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910250,
                "title": "binary-search-c",
                "content": "\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    long long calculate(vector<int> & candies, int num){\\n        long long ans = 0;\\n        for(int i=0;i<candies.size();i++){\\n            ans+=candies[i]/num;\\n        }\\n        return ans;\\n    }\\n    \\n    \\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int low = 1;\\n        int ans = 0;\\n        int high = 10000005;\\n        while(low<=high){\\n            int mid = low+(high-low)/2;\\n            long long curr = calculate(candies,mid);\\n            if(curr>=k){\\n                low = mid+1;\\n                ans = mid;\\n            }\\n            else\\n                high = mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long calculate(vector<int> & candies, int num){\\n        long long ans = 0;\\n        for(int i=0;i<candies.size();i++){\\n            ans+=candies[i]/num;\\n        }\\n        return ans;\\n    }\\n    \\n    \\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int low = 1;\\n        int ans = 0;\\n        int high = 10000005;\\n        while(low<=high){\\n            int mid = low+(high-low)/2;\\n            long long curr = calculate(candies,mid);\\n            if(curr>=k){\\n                low = mid+1;\\n                ans = mid;\\n            }\\n            else\\n                high = mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910232,
                "title": "c-solution-binary-search-faster-that-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long right = *max_element(candies.begin(), candies.end());\\n        long long left = 0;\\n        while(right > left){\\n            long long mid = (right + left + 1)/2;\\n            long long sum = 0;\\n            for(int i = 0;i < candies.size(); i++){\\n                sum += candies[i]/mid;\\n            }\\n            if (sum < k){\\n                right = mid - 1;\\n            }else if (sum >= k){\\n                left = mid;\\n            }\\n        }\\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long right = *max_element(candies.begin(), candies.end());\\n        long long left = 0;\\n        while(right > left){\\n            long long mid = (right + left + 1)/2;\\n            long long sum = 0;\\n            for(int i = 0;i < candies.size(); i++){\\n                sum += candies[i]/mid;\\n            }\\n            if (sum < k){\\n                right = mid - 1;\\n            }else if (sum >= k){\\n                left = mid;\\n            }\\n        }\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909852,
                "title": "java-o-nlogn-solution",
                "content": "\\n\\n        \\n        long sum=0;\\n        for(int i:candies)\\n            sum+=i;\\n        long low=0,high=sum;\\n        long ans=0;\\n        while(low<=high)\\n        {\\n            long mid=low+(high-low)/2;\\n            if(mid==0)\\n            {\\n                low=mid+1;\\n                continue;\\n            }\\n            long tmp=0;\\n            for(int i=0;i<candies.length;i++)\\n            {\\n                tmp+=candies[i]/mid;\\n            }\\n            if(tmp>=k)\\n            {\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else\\n                high=mid-1;\\n        }\\n        return (int)ans;\\n    \\n\\t",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "\\n\\n        \\n        long sum=0;\\n        for(int i:candies)\\n            sum+=i;\\n        long low=0,high=sum;\\n        long ans=0;\\n        while(low<=high)\\n        {\\n            long mid=low+(high-low)/2;\\n            if(mid==0)\\n            {\\n                low=mid+1;\\n                continue;\\n            }\\n            long tmp=0;\\n            for(int i=0;i<candies.length;i++)\\n            {\\n                tmp+=candies[i]/mid;\\n            }\\n            if(tmp>=k)\\n            {\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else\\n                high=mid-1;\\n        }\\n        return (int)ans;\\n    \\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1909799,
                "title": "left-right-1-2-vs-left-right-2",
                "content": "This post mainly focus on `(left+right+1)/2` and `(left+right)/2`.\\n\\n`mid = (left + right) / 2` to find *first* element valid\\n`mid = (left + right + 1) / 2` to find *last* element valid\\n\\nE.g. `[0, 1, 1, 1, 1]`\\n`mid = (left + right) / 2` would give index 1\\n`mid = (left + right + 1) / 2` would give index 5\\n\\nFor `mid = (left + right + 1) / 2`:\\n1. if `sum == k`, since we are going to find the last valid one, then move `left` till the very left: `left = mid`;\\n2. when go out of while loop, it\\'s getting to the first element NOT valid, so `right` need to decrement by one: `right = mid - 1`. So it would be:\\n\\n```\\nif (sum >= k) left = mid\\nelse right = mid -1\\n```\\nIf one wonders it\\'s `sum >= k` or `sum > k`, just take a moment think about if you want to first or last same element\\n\\nUsually we write `mid = (left + right) / 2` in\\n```\\nif (num[mid] < target) left = mid + 1\\nelse right = mid\\n```\\n\\nBtw, if using a helper `sum` function, be sure to return a `long` type not `int` otherwise you will hit error\\n\\nOriginal answer:\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        // binary search\\n        int left = 0, right = 10000000;\\n        \\n        while (left < right) {\\n            int mid = (left + right + 1) / 2;\\n\\n            // equal: go to the rightmost of these same numbers\\n            if (sum(candies, mid) >= k) \\n                left = mid;\\n            else \\n                right = mid - 1;\\n        }\\n        \\n        return left;\\n    }\\n    \\n    private long sum(int[] candies, int mid) {\\n        long count = 0;\\n        for (int c : candies) {\\n            count += c / mid;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nif (sum >= k) left = mid\\nelse right = mid -1\\n```\n```\\nif (num[mid] < target) left = mid + 1\\nelse right = mid\\n```\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        // binary search\\n        int left = 0, right = 10000000;\\n        \\n        while (left < right) {\\n            int mid = (left + right + 1) / 2;\\n\\n            // equal: go to the rightmost of these same numbers\\n            if (sum(candies, mid) >= k) \\n                left = mid;\\n            else \\n                right = mid - 1;\\n        }\\n        \\n        return left;\\n    }\\n    \\n    private long sum(int[] candies, int mid) {\\n        long count = 0;\\n        for (int c : candies) {\\n            count += c / mid;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909786,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Time Complexity : O(N * log(max. element in array))***\\n* ***Space Complexity : O(1)***\\n\\n```\\n    bool is_possible(vector<int>& candies, int mid, long long k)\\n    {\\n        long long count = 0;\\n        \\n        for(int i = 0; i < candies.size(); i++)\\n        {\\n            count += candies[i] / mid;\\n        }\\n        \\n        if(count >= k)\\n            return true;\\n        \\n        return false;\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        \\n        int n = candies.size();\\n        \\n        int low = 1;\\n        \\n        int high = *max_element(candies.begin(), candies.end());\\n        \\n        int ans = 0;\\n        \\n        while(low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            \\n            if(is_possible(candies, mid, k))\\n            {\\n                ans = mid;\\n                \\n                low = mid + 1;\\n            }\\n            else\\n            {\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\n    bool is_possible(vector<int>& candies, int mid, long long k)\\n    {\\n        long long count = 0;\\n        \\n        for(int i = 0; i < candies.size(); i++)\\n        {\\n            count += candies[i] / mid;\\n        }\\n        \\n        if(count >= k)\\n            return true;\\n        \\n        return false;\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        \\n        int n = candies.size();\\n        \\n        int low = 1;\\n        \\n        int high = *max_element(candies.begin(), candies.end());\\n        \\n        int ans = 0;\\n        \\n        while(low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            \\n            if(is_possible(candies, mid, k))\\n            {\\n                ans = mid;\\n                \\n                low = mid + 1;\\n            }\\n            else\\n            {\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1909572,
                "title": "python3-binary-search",
                "content": "```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        if sum(candies) < k:\\n            return 0\\n        \\n        low,high = 0,sum(candies)\\n        while low < high:\\n            mid = low + (high - low)//2 + 1\\n            if sum(i//mid for i in candies) >= k:\\n                low = mid\\n            else:\\n                high = mid-1\\n                \\n        return low\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        if sum(candies) < k:\\n            return 0\\n        \\n        low,high = 0,sum(candies)\\n        while low < high:\\n            mid = low + (high - low)//2 + 1\\n            if sum(i//mid for i in candies) >= k:\\n                low = mid\\n            else:\\n                high = mid-1\\n                \\n        return low\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909404,
                "title": "c-binary-search-easy-to-understand",
                "content": "```\\nint maximumCandies(vector<int>& c, long long k) \\n    {\\n        // I got the intuition because it was following the pattern of breaking down the question into two parts, I had to check if a number was feasible to keep and also no way of obviously finding it anyway else. Check Koko Eating bananas and similar pattern questions\\n        \\n        int left = 1 ;\\n        int right = 1e9;\\n        int res = INT_MIN;\\n        \\n        int n = c.size();\\n        long long sum = 0;\\n        \\n        \\n        while(left <= right)\\n        {\\n            int mid = left + (right-left)/2;\\n            \\n            if(isfeasible(c,k,mid))\\n            {\\n                res = max(res,mid);\\n                left = mid+1;\\n            }\\n            \\n            else\\n            {\\n                right = mid - 1;\\n            }\\n        }\\n        \\n        return res == INT_MIN? 0 : res; // if we didn\\'t find any feasible value and the result is the initial one we had\\n    }\\n    \\n    bool isfeasible(vector<int> &c, long long k, int candy)\\n    {\\n        // checking feasibility\\n        long long count = 0;\\n        for(int i=0;i<c.size();i++)\\n        {\\n            count+= c[i]/candy; // counting number of children that can have piles with \\'candy\\' number of candies\\n        }\\n        \\n        if(count>=k)\\n            return true;\\n        else\\n            return false;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nint maximumCandies(vector<int>& c, long long k) \\n    {\\n        // I got the intuition because it was following the pattern of breaking down the question into two parts, I had to check if a number was feasible to keep and also no way of obviously finding it anyway else. Check Koko Eating bananas and similar pattern questions\\n        \\n        int left = 1 ;\\n        int right = 1e9;\\n        int res = INT_MIN;\\n        \\n        int n = c.size();\\n        long long sum = 0;\\n        \\n        \\n        while(left <= right)\\n        {\\n            int mid = left + (right-left)/2;\\n            \\n            if(isfeasible(c,k,mid))\\n            {\\n                res = max(res,mid);\\n                left = mid+1;\\n            }\\n            \\n            else\\n            {\\n                right = mid - 1;\\n            }\\n        }\\n        \\n        return res == INT_MIN? 0 : res; // if we didn\\'t find any feasible value and the result is the initial one we had\\n    }\\n    \\n    bool isfeasible(vector<int> &c, long long k, int candy)\\n    {\\n        // checking feasibility\\n        long long count = 0;\\n        for(int i=0;i<c.size();i++)\\n        {\\n            count+= c[i]/candy; // counting number of children that can have piles with \\'candy\\' number of candies\\n        }\\n        \\n        if(count>=k)\\n            return true;\\n        else\\n            return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1909394,
                "title": "java-c-greedy-binary-search-explained-easy-to-understand",
                "content": "Idea: .Minimun and maximum candies that can be given to a child form a monotonically increasing function.\\n    .Thus to find the maximum candies to a single child, binary search can be applied in the above mentioned search space\\n\\t\\nC++\\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& cd, long long k) {\\n        long long l = 0, r = 1E7;\\n        long long ans = 0;\\n        while (l <= r) {\\n            //each child getting m candies\\n            auto m = l + (r-l) / 2;\\n            //number of children Getting Candies\\n            auto cgc = 0LL;\\n            if(m != 0l)\\n            {\\n                for (auto x : cd) {\\n                    cgc += x / m;\\n                }\\n            }\\n            if (cgc >= k) {\\n                ans = m;\\n                l = m+1;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nJava\\n```\\nclass Solution {\\n    public int maximumCandies(int[] cd, long k) {\\n        long l = 0, r = 10000000;\\n        long ans = 0;\\n        while (l <= r) {\\n            //each child getting m candies\\n            var m = l + (r-l) / 2;\\n            //number of children Getting Candies\\n            var cgc = 0l;\\n            if(m != 0l)\\n            {\\n                for (var x : cd) {\\n                    cgc += x / m;\\n                }\\n            }\\n            if (cgc >= k) {\\n                ans = m;\\n                l = m+1;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n}\\n```\\nAny corrections, suggestions or optimizations to code are welcomed. :)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& cd, long long k) {\\n        long long l = 0, r = 1E7;\\n        long long ans = 0;\\n        while (l <= r) {\\n            //each child getting m candies\\n            auto m = l + (r-l) / 2;\\n            //number of children Getting Candies\\n            auto cgc = 0LL;\\n            if(m != 0l)\\n            {\\n                for (auto x : cd) {\\n                    cgc += x / m;\\n                }\\n            }\\n            if (cgc >= k) {\\n                ans = m;\\n                l = m+1;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int maximumCandies(int[] cd, long k) {\\n        long l = 0, r = 10000000;\\n        long ans = 0;\\n        while (l <= r) {\\n            //each child getting m candies\\n            var m = l + (r-l) / 2;\\n            //number of children Getting Candies\\n            var cgc = 0l;\\n            if(m != 0l)\\n            {\\n                for (var x : cd) {\\n                    cgc += x / m;\\n                }\\n            }\\n            if (cgc >= k) {\\n                ans = m;\\n                l = m+1;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909330,
                "title": "c-binary-search-on-asnwer",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long \\n    \\n    bool isPossible(vector<int>& candies, ll k , ll mid ){\\n        ll children = 0 ;\\n        for(auto &x : candies) children += x / mid ;\\n        return children >= k ;\\n        \\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        ll totalCandies = accumulate(begin(candies),end(candies),0LL) ;\\n        ll lo = 1 , hi = totalCandies/k ;\\n        \\n        int ans = -1 ;\\n        while(lo <= hi){\\n            ll mid = lo + (hi-lo)/2LL ;\\n            if(isPossible(candies,k,mid)){\\n               ans = mid ;\\n               lo = mid + 1 ;\\n            }\\n            else hi = mid - 1 ;\\n        }\\n        return ans==-1 ? 0 : ans  ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long \\n    \\n    bool isPossible(vector<int>& candies, ll k , ll mid ){\\n        ll children = 0 ;\\n        for(auto &x : candies) children += x / mid ;\\n        return children >= k ;\\n        \\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        ll totalCandies = accumulate(begin(candies),end(candies),0LL) ;\\n        ll lo = 1 , hi = totalCandies/k ;\\n        \\n        int ans = -1 ;\\n        while(lo <= hi){\\n            ll mid = lo + (hi-lo)/2LL ;\\n            if(isPossible(candies,k,mid)){\\n               ans = mid ;\\n               lo = mid + 1 ;\\n            }\\n            else hi = mid - 1 ;\\n        }\\n        return ans==-1 ? 0 : ans  ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909268,
                "title": "binary-search-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int ans = 0;\\n        int l = 0,h = INT_MAX,m;\\n        while(l <= h) {\\n            m = l + (h -l )/2;\\n            if(isPossible(candies, m, k)) {\\n                ans = max(ans, m);\\n                l = m + 1;\\n            } else {\\n                h = m - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    bool isPossible(vector<int>& candies, int amount, long long k) {\\n        long long sum = 0;\\n        long long int cnt = 0;\\n        for(int candie : candies) {\\n            if(candie >= amount && amount != 0) cnt += candie/amount;\\n        }\\n        return cnt >= k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int ans = 0;\\n        int l = 0,h = INT_MAX,m;\\n        while(l <= h) {\\n            m = l + (h -l )/2;\\n            if(isPossible(candies, m, k)) {\\n                ans = max(ans, m);\\n                l = m + 1;\\n            } else {\\n                h = m - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    bool isPossible(vector<int>& candies, int amount, long long k) {\\n        long long sum = 0;\\n        long long int cnt = 0;\\n        for(int candie : candies) {\\n            if(candie >= amount && amount != 0) cnt += candie/amount;\\n        }\\n        return cnt >= k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909224,
                "title": "c-binary-search",
                "content": "\\ttypedef long long ll;\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint help(ll mid,vector<int>&nums,ll k){\\n\\t\\t\\tll res = 0;\\n\\t\\t\\tfor(int i=0;i<nums.size();i++) res+=(nums[i]/mid);\\n\\t\\t\\treturn res>=k;\\n\\t\\t}\\n\\n\\t\\tint maximumCandies(vector<int>& candies, long long k) {\\n\\t\\t\\tll i = 1, j = 1e9;\\n\\t\\t\\twhile(i<=j){\\n\\t\\t\\t\\tll mid = (i+j)/2;\\n\\t\\t\\t\\tif(help(mid,candies,k)) i = mid+1;\\n\\t\\t\\t\\telse j = mid-1;\\n\\t\\t\\t}\\n\\t\\t\\treturn i-1;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint help(ll mid,vector<int>&nums,ll k){\\n\\t\\t\\tll res = 0;\\n\\t\\t\\tfor(int i=0;i<nums.size();i++) res+=(nums[i]/mid);\\n\\t\\t\\treturn res>=k;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1909207,
                "title": "java-efficient-binary-search-approach-explained",
                "content": "**Find total candies**\\n\\tif `total < k,` then we cannot give candy to all child, so `return 0`.\\n\\tif `total == k`, then each child can get only `1 candy`.\\n\\nOtherwise,\\n\\tUse binary search to find possible candies.\\n\\tHere, `high = total / k` as this is maximum we can assign to each child.\\n\\tFor each mid, find **how many piles can be created** `(candy / mid)`. If numbers of piles i.e. `sum >= k` then we can assign atleast `mid` candies.\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        long total = 0;\\n        for (int candy : candies) {\\n            total += candy;\\n        }\\n        if (total < k) {\\n            return 0;\\n        }\\n        if (total == k) {\\n            return 1;\\n        }\\n        long low = 1;\\n        long high = total / k;\\n        int ans = 0;\\n        while (low <= high) {\\n            long mid = (low + high) / 2;\\n            long sum = 0;\\n            for (int candy: candies) {\\n                sum += (candy / mid);\\n            }\\n            if (sum >= k) {\\n                ans = (int) mid;\\n                low = mid + 1;\\n            } else {\\n                high = mid -1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        long total = 0;\\n        for (int candy : candies) {\\n            total += candy;\\n        }\\n        if (total < k) {\\n            return 0;\\n        }\\n        if (total == k) {\\n            return 1;\\n        }\\n        long low = 1;\\n        long high = total / k;\\n        int ans = 0;\\n        while (low <= high) {\\n            long mid = (low + high) / 2;\\n            long sum = 0;\\n            for (int candy: candies) {\\n                sum += (candy / mid);\\n            }\\n            if (sum >= k) {\\n                ans = (int) mid;\\n                low = mid + 1;\\n            } else {\\n                high = mid -1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909168,
                "title": "binary-search-similar-approach-as-book-allocation-problem-in-cpp",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& can, long long k) {\\n        int l=1,h=*max_element(can.begin(),can.end());  //here l initialised by 1 for the case when h=1\\n        int ans=0;\\n        while(l<=h)\\n        {\\n            int mid=l+(h-l)/2;\\n            long long cnt=0;\\n            if(mid==0)\\n                break;\\n            for(int i=0;i<can.size();i++)\\n            {\\n                cnt+=1ll*can[i]/mid;\\n            }\\n            if(cnt>=k)\\n            {\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else\\n                h=mid-1;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    int maximumCandies(vector<int>& can, long long k) {\\n        int l=1,h=*max_element(can.begin(),can.end());  //here l initialised by 1 for the case when h=1\\n        int ans=0;\\n        while(l<=h)\\n        {\\n            int mid=l+(h-l)/2;\\n            long long cnt=0;\\n            if(mid==0)\\n                break;\\n            for(int i=0;i<can.size();i++)\\n            {\\n                cnt+=1ll*can[i]/mid;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1909006,
                "title": "c-binary-search-faster-than-100",
                "content": "~~~\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& nums, long long k) {\\n        int n=nums.size();\\n        int mx=0;\\n        for(int i=0;i<nums.size();i++){\\n            mx=max(mx,nums[i]);\\n        }\\n        if(k==1)return mx;\\n        long long l=0,h=mx;\\n        long long ans=0;\\n        while(l<=h){\\n            long long mid=l+(h-l)/2;\\n            if(solve(nums,mid,k)){\\n                ans=mid;\\n                l=mid+1;\\n            }else{\\n                h=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int solve(vector<int> nums,long long val,long long k){\\n        if(val==0)return true;\\n        long long c=0;\\n        for(int i=0;i<nums.size();i++){\\n            c+=nums[i]/val;\\n        }\\n        if(c>=k)return true;\\n        return false;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maximumCandies(vector<int>& nums, long long k) {\\n        int n=nums.size();\\n        int mx=0;\\n        for(int i=0;i<nums.size();i++){\\n            mx=max(mx,nums[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1908944,
                "title": "binary-search-time-o-nlogn-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(long long mid,long long k, vector<int>&candies)\\n    {\\n        long long temp=0;\\n        for(int i=0;i<candies.size();i++)\\n        {\\n            temp+=candies[i]/mid;\\n            if(temp>=k)\\n                return true;\\n        }\\n        return false;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long sum=0;\\n        int ans=0;\\n        for(int i=0;i<candies.size();i++)\\n        {\\n            sum+=candies[i];\\n        }\\n        long long l=1,h=sum;\\n        while(l<=h)\\n        {\\n            long long mid=l+(h-l)/2;\\n            \\n            if(check(mid,k,candies))\\n            {\\n                ans=(int)mid;\\n                l=mid+1;\\n            }\\n            else\\n            {\\n                h=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Like it? Please Upvote ;-)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(long long mid,long long k, vector<int>&candies)\\n    {\\n        long long temp=0;\\n        for(int i=0;i<candies.size();i++)\\n        {\\n            temp+=candies[i]/mid;\\n            if(temp>=k)\\n                return true;\\n        }\\n        return false;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long sum=0;\\n        int ans=0;\\n        for(int i=0;i<candies.size();i++)\\n        {\\n            sum+=candies[i];\\n        }\\n        long long l=1,h=sum;\\n        while(l<=h)\\n        {\\n            long long mid=l+(h-l)/2;\\n            \\n            if(check(mid,k,candies))\\n            {\\n                ans=(int)mid;\\n                l=mid+1;\\n            }\\n            else\\n            {\\n                h=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908896,
                "title": "c-binary-search-clean-and-concise",
                "content": "```\\n#define ll long long \\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        \\n        \\n        ll sum=0;\\n        for(auto i:candies)\\n            sum+=i;\\n        if(sum<k)\\n            return 0;\\n        ll low=1;\\n        ll high=1e15;\\n        ll ans=0;\\n        while(low<=high)\\n        {\\n            ll mid=(low+high)/2;\\n           ll st=0;\\n            for(auto i:candies)\\n            {\\n                if(mid!=0)\\n                st+=(i/mid);\\n            }\\n            if(st>=k)\\n            {\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else\\n            {\\n                high=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Pls upvote the solution if you found helpful, it means a lot.\\nAlso comment down your doubts.\\nHappy Coding : )**\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n#define ll long long \\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        \\n        \\n        ll sum=0;\\n        for(auto i:candies)\\n            sum+=i;\\n        if(sum<k)\\n            return 0;\\n        ll low=1;\\n        ll high=1e15;\\n        ll ans=0;\\n        while(low<=high)\\n        {\\n            ll mid=(low+high)/2;\\n           ll st=0;\\n            for(auto i:candies)\\n            {\\n                if(mid!=0)\\n                st+=(i/mid);\\n            }\\n            if(st>=k)\\n            {\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else\\n            {\\n                high=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908845,
                "title": "easy-python-binary-search",
                "content": "```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        l, r = 1, max(candies)\\n        while l <= r:\\n            m = (l + r)//2\\n            if self.countPile(candies, m) >= k:\\n                if self.countPile(candies, m + 1) < k: return m\\n                l = m + 1\\n            else:\\n                r = m - 1\\n        return 0\\n                \\n    def countPile(self, candies, pileSize):\\n        return sum(candy//pileSize for candy in candies)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        l, r = 1, max(candies)\\n        while l <= r:\\n            m = (l + r)//2\\n            if self.countPile(candies, m) >= k:\\n                if self.countPile(candies, m + 1) < k: return m\\n                l = m + 1\\n            else:\\n                r = m - 1\\n        return 0\\n                \\n    def countPile(self, candies, pileSize):\\n        return sum(candy//pileSize for candy in candies)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908844,
                "title": "java-simple-binarysearch-tc-o-n-log-max",
                "content": "Solution:\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int max = Integer.MIN_VALUE;\\n        long sum = 0;\\n        \\n        for (int num: candies) {\\n            max = Math.max(max, num);\\n            sum += num;\\n        }\\n        \\n        if (sum < k) {\\n            return 0;\\n        }\\n        \\n        int left = 1, right = max;\\n        \\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            \\n            if (canBeDistributed(mid, candies, k)) {\\n                if (!canBeDistributed(mid + 1, candies, k)) {\\n                    return mid;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n    \\n    public boolean canBeDistributed(int num, int[] candies, long k) {\\n        for (int i = 0; i < candies.length && k > 0; ++ i) {\\n            k -= candies[i] / num;\\n        }\\n        \\n        return k <= 0;\\n    }\\n}\\n```\\n\\n**TimeComplexity:** O(N * log(Max)) where N is the number of candies.",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int max = Integer.MIN_VALUE;\\n        long sum = 0;\\n        \\n        for (int num: candies) {\\n            max = Math.max(max, num);\\n            sum += num;\\n        }\\n        \\n        if (sum < k) {\\n            return 0;\\n        }\\n        \\n        int left = 1, right = max;\\n        \\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            \\n            if (canBeDistributed(mid, candies, k)) {\\n                if (!canBeDistributed(mid + 1, candies, k)) {\\n                    return mid;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n    \\n    public boolean canBeDistributed(int num, int[] candies, long k) {\\n        for (int i = 0; i < candies.length && k > 0; ++ i) {\\n            k -= candies[i] / num;\\n        }\\n        \\n        return k <= 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908830,
                "title": "c-easy-binary-search",
                "content": "Approach:\\n* Firstly we will take given range and apply binary search.\\n* low will be 1 as min 1 candy shoud be given and high is upper limit of candy group in given constraint i.e 10^7.\\n* Firstly we will calculate mid and check if candy pile of k forms k groups or not if it is forming more than or equal to k groups then  we can take it as a possible answer and take low=mid+1 because we have to find max answer and there might exist any number more than mid that may satisfy given condition. if groups of mid are less than k then we have to search in left part fo high=mid-1.\\n    \\nComplexity:\\n* \\tTime: O(n log (10^7)) we are using binary search from 1 to 10^7 so log (10^7) and at each step we have to traverse array so it is multiplied by n.\\n* \\tSpace: O(1)\\n```\\t\\nclass Solution {\\npublic:\\n    using ll=long long;\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        ll low=1,high=10000001;\\n        int answer=0;\\n        while(low<=high){\\n            ll mid=(low+high)/2;\\n            ll groups=getGroups(candies,mid);\\n            if(groups>=k){\\n\\t\\t\\t\\t//probable any might be mid.\\n                answer=mid;\\n                low=mid+1;\\n            }else{\\n                high=mid-1;\\n            }\\n        }\\n        return answer;\\n    }\\n    ll getGroups(vector<int> &candies,ll mid){\\n        ll groups=0;\\n        for(auto can:candies){\\n            groups+=(can/mid);\\n        }\\n        return groups;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\t\\nclass Solution {\\npublic:\\n    using ll=long long;\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        ll low=1,high=10000001;\\n        int answer=0;\\n        while(low<=high){\\n            ll mid=(low+high)/2;\\n            ll groups=getGroups(candies,mid);\\n            if(groups>=k){\\n\\t\\t\\t\\t//probable any might be mid.\\n                answer=mid;\\n                low=mid+1;\\n            }else{\\n                high=mid-1;\\n            }\\n        }\\n        return answer;\\n    }\\n    ll getGroups(vector<int> &candies,ll mid){\\n        ll groups=0;\\n        for(auto can:candies){\\n            groups+=(can/mid);\\n        }\\n        return groups;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908821,
                "title": "c-binary-search-concise",
                "content": "```\\nclass Solution{\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long sum = 0, n = candies.size();\\n        for(int i =0;i<n;i++){\\n            sum+= candies[i];\\n        }\\n        if(k>sum) return 0;\\n        long long lower = 1;\\n        long long upper = sum/k;\\n        \\n        long long ans = 0;\\n        \\n        while(lower<=upper){ \\n             long long mid = lower + (upper-lower)/2;\\n             long long count = 0;\\n             for(int i =0;i<n;i++){\\n                count+= candies[i]/mid;\\n             }\\n             if(count>=k){\\n                ans = max(ans,mid);\\n                lower = mid+1;\\n             }\\n             else{\\n                upper = mid-1;\\n             }\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution{\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long sum = 0, n = candies.size();\\n        for(int i =0;i<n;i++){\\n            sum+= candies[i];\\n        }\\n        if(k>sum) return 0;\\n        long long lower = 1;\\n        long long upper = sum/k;\\n        \\n        long long ans = 0;\\n        \\n        while(lower<=upper){ \\n             long long mid = lower + (upper-lower)/2;\\n             long long count = 0;\\n             for(int i =0;i<n;i++){\\n                count+= candies[i]/mid;\\n             }\\n             if(count>=k){\\n                ans = max(ans,mid);\\n                lower = mid+1;\\n             }\\n             else{\\n                upper = mid-1;\\n             }\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908813,
                "title": "binary-search-same-as-koko-eating-bananas-python3",
                "content": "This problem is the very similar to the [Koko Eating bananas](https://leetcode.com/problems/koko-eating-bananas/). In fact, the only thing that changes in the condition and boundaries.\\n\\n\\n```\\ndef maximumCandies(self, candies: List[int], k: int) -> int:\\n        \\n        def can_take(target):\\n            count = 0\\n            for candy in candies:\\n                if candy >= target:\\n                    count += (candy // target) # Find out how many children this pile can feed :) \\n            return count >= k   # Make sure that we have enough to feed all the children\\n        \\n        l, r = 1, max(candies)\\n        res = 0\\n        while l <= r:\\n            m = (l + r) // 2\\n            if can_take(m):\\n                res = m\\n                l = m + 1\\n            else:\\n                r = m - 1\\n        return res\\n  ```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\ndef maximumCandies(self, candies: List[int], k: int) -> int:\\n        \\n        def can_take(target):\\n            count = 0\\n            for candy in candies:\\n                if candy >= target:\\n                    count += (candy // target) # Find out how many children this pile can feed :) \\n            return count >= k   # Make sure that we have enough to feed all the children\\n        \\n        l, r = 1, max(candies)\\n        res = 0\\n        while l <= r:\\n            m = (l + r) // 2\\n            if can_take(m):\\n                res = m\\n                l = m + 1\\n            else:\\n                r = m - 1\\n        return res\\n  ```",
                "codeTag": "Python3"
            },
            {
                "id": 1908805,
                "title": "python-java-binary-search",
                "content": "\\tclass Solution:\\n\\t\\tdef maximumCandies(self, candies: List[int], k: int) -> int:\\n\\t\\t\\tl = 1\\n\\t\\t\\tr = sum(candies)\\n\\t\\t\\tif r < k:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\tdef allocate(m):\\n\\t\\t\\t\\tcnt = 0\\n\\t\\t\\t\\tfor candy in candies:\\n\\t\\t\\t\\t\\tcnt += candy // m\\n\\t\\t\\t\\treturn cnt\\n\\t\\t\\twhile l + 1 < r:\\n\\t\\t\\t\\tm = (l + r) // 2\\n\\t\\t\\t\\tif allocate(m) < k:\\n\\t\\t\\t\\t\\tr = m - 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tl = m\\n\\t\\t\\tif allocate(r) >= k:\\n\\t\\t\\t\\treturn r\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn l\\n\\n\\n\\tclass Solution {\\n\\t\\tpublic int maximumCandies(int[] candies, long k) {\\n\\t\\t\\tlong l = 1;\\n\\t\\t\\tlong r = 0;\\n\\t\\t\\tfor (int candy: candies) {\\n\\t\\t\\t\\tr += candy;\\n\\t\\t\\t}\\n\\t\\t\\tif (r < k) {\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\twhile (l + 1 < r) {\\n\\t\\t\\t\\tlong m = (r - l) / 2 + l;\\n\\t\\t\\t\\tif (allocate(candies, m) < k) {\\n\\t\\t\\t\\t\\tr = m - 1;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tl = m;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (allocate(candies, r) >= k) {\\n\\t\\t\\t\\treturn (int)r;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn (int)l;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tprivate long allocate(int[] candies, long m) {\\n\\t\\t\\tlong cnt = 0;\\n\\t\\t\\tfor (int candy: candies) {\\n\\t\\t\\t\\tcnt += candy / m;\\n\\t\\t\\t}\\n\\t\\t\\treturn cnt;\\n\\t\\t} \\n\\t}",
                "solutionTags": [],
                "code": "class Solution:\\n\\t\\tdef maximumCandies(self, candies: List[int], k: int) -> int:\\n\\t\\t\\tl = 1\\n\\t\\t\\tr = sum(candies)\\n\\t\\t\\tif r < k:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\tdef allocate(m):\\n\\t\\t\\t\\tcnt = 0\\n\\t\\t\\t\\tfor candy in candies:\\n\\t\\t\\t\\t\\tcnt += candy // m\\n\\t\\t\\t\\treturn cnt\\n\\t\\t\\twhile l + 1 < r:\\n\\t\\t\\t\\tm = (l + r) // 2\\n\\t\\t\\t\\tif allocate(m) < k:\\n\\t\\t\\t\\t\\tr = m - 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tl = m\\n\\t\\t\\tif allocate(r) >= k:\\n\\t\\t\\t\\treturn r\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn l\\n\\n\\n\\tclass Solution {\\n\\t\\tpublic int maximumCandies(int[] candies, long k) {\\n\\t\\t\\tlong l = 1;\\n\\t\\t\\tlong r = 0;\\n\\t\\t\\tfor (int candy: candies) {\\n\\t\\t\\t\\tr += candy;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1908799,
                "title": "python-binary-search-solution-and-explanation",
                "content": "**\\uD83D\\uDC46Please UPVOTE it if you find my soulutions are useful \\uD83D\\uDC46 Feel free to ask any question**\\n# [Python] \\uD83C\\uDF1F Binary Search Solution and Explanation \\uD83D\\uDC95\\n## 1\\uFE0F\\u20E3 Main Idea:\\nWe can greedy test every potential target from 1~ total//k.\\nSo we use binary Search to find our maximum target.\\n* canDivide: Simply use res += candy // target. To check whether a candy pile could split into how many piles to fit the target.\\n\\n## Complexity Analysis\\n* Time: O(NlogN)\\n* Space: O(1)\\n\\n## Code\\n\\n**Python**\\n```python\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        total = sum(candies)\\n        if total < k:\\n            return 0\\n        \\n        # We can test our current target is valid\\n        def canDivide(target):\\n            res = 0\\n            for candy in candies:\\n                res += candy // target\\n            return res >= k\\n        \\n        # Greedy high would be total // k\\n        low, high = 1, total // k\\n        res = 0\\n        # Binary Search\\n        while low <= high:\\n            target = low + (high - low) // 2\\n            if canDivide(target):\\n                res = target\\n                low = target + 1\\n            else:\\n                high = target - 1\\n        return res\\n```\\n* See more 2022 Daily Challenge Solution : [GitHub](https://github.com/gcobs0834/2022-Daily-LeetCoding-Challenge-python3-)",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        total = sum(candies)\\n        if total < k:\\n            return 0\\n        \\n        # We can test our current target is valid\\n        def canDivide(target):\\n            res = 0\\n            for candy in candies:\\n                res += candy // target\\n            return res >= k\\n        \\n        # Greedy high would be total // k\\n        low, high = 1, total // k\\n        res = 0\\n        # Binary Search\\n        while low <= high:\\n            target = low + (high - low) // 2\\n            if canDivide(target):\\n                res = target\\n                low = target + 1\\n            else:\\n                high = target - 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908787,
                "title": "c-binary-search-o-nlogn-intiution-comments",
                "content": "intiution : our search space(no of candies we can allocate) will be 1  to max number in array . if we can allocate a particular number of candy then search for next higher number else search number lower than that particular number.\\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int maxCand = INT_MIN;\\n        long long s = 0;\\n        for(int i = 0;i < candies.size();i++){\\n            if(candies[i] > maxCand)\\n                maxCand = candies[i];\\n            s += candies[i];\\n        }\\n\\t\\t// if total number of candies are less than the no of children then we can never allocate same number of candies to children hence return 0\\n        if(k > s)\\n            return 0;\\n        int l = 1;\\n        int h = maxCand;\\n        while(l <= h){\\n            int mid = l + (h - l) / 2;\\n            long long sum = 0;\\n            for(int i =a 0;i < candies.size();i++){\\n\\t\\t\\t// mid means the number that we check if we can allocate that number of candy to children.\\n\\t\\t\\t// [ 5 8 6] and if mid = 2 then we can get 2 piles of 2 candies from 5 and 2 piles from 8 and 3 piles from 6.\\n                sum += candies[i] / mid;\\n            }\\n\\t\\t\\t// if total no of piles of mid number candy is >= k then we can allocate mid number candy to children hence check for next higher possible number.\\n            if(sum >= k)\\n                l = mid + 1;\\n\\t\\t\\t\\t// else check for lower number than mid.\\n            else\\n                h = mid - 1;\\n        }\\n\\t\\t// at end h points to a maximum number that we can allocate to children.\\n        return h;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int maxCand = INT_MIN;\\n        long long s = 0;\\n        for(int i = 0;i < candies.size();i++){\\n            if(candies[i] > maxCand)\\n                maxCand = candies[i];\\n            s += candies[i];\\n        }\\n\\t\\t// if total number of candies are less than the no of children then we can never allocate same number of candies to children hence return 0\\n        if(k > s)\\n            return 0;\\n        int l = 1;\\n        int h = maxCand;\\n        while(l <= h){\\n            int mid = l + (h - l) / 2;\\n            long long sum = 0;\\n            for(int i =a 0;i < candies.size();i++){\\n\\t\\t\\t// mid means the number that we check if we can allocate that number of candy to children.\\n\\t\\t\\t// [ 5 8 6] and if mid = 2 then we can get 2 piles of 2 candies from 5 and 2 piles from 8 and 3 piles from 6.\\n                sum += candies[i] / mid;\\n            }\\n\\t\\t\\t// if total no of piles of mid number candy is >= k then we can allocate mid number candy to children hence check for next higher possible number.\\n            if(sum >= k)\\n                l = mid + 1;\\n\\t\\t\\t\\t// else check for lower number than mid.\\n            else\\n                h = mid - 1;\\n        }\\n\\t\\t// at end h points to a maximum number that we can allocate to children.\\n        return h;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908745,
                "title": "binary-search-clean-java-solution",
                "content": "```\\nclass Solution {\\n    \\n    public boolean valid(int mid, int candies[], long k){\\n      \\n        long c=0;\\n        \\n        for(int i=0;i<candies.length;i++){\\n            int val=candies[i];\\n            c+=val/mid;\\n            if(c>=k){\\n                \\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n        \\n    }\\n    \\n    public int maximumCandies(int[] candies, long k) {\\n        int max=Integer.MIN_VALUE;\\n        \\n        for(int i=0;i<candies.length;i++){\\n            max=Math.max(candies[i],max);\\n        }\\n        \\n        int low=1;\\n        int high=max;\\n        \\n        int ans=0;\\n        \\n        while(low<=high){\\n            int mid= low +(high-low) / 2;\\n            \\n            if(valid(mid,candies,k)){\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            \\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public boolean valid(int mid, int candies[], long k){\\n      \\n        long c=0;\\n        \\n        for(int i=0;i<candies.length;i++){\\n            int val=candies[i];\\n            c+=val/mid;\\n            if(c>=k){\\n                \\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n        \\n    }\\n    \\n    public int maximumCandies(int[] candies, long k) {\\n        int max=Integer.MIN_VALUE;\\n        \\n        for(int i=0;i<candies.length;i++){\\n            max=Math.max(candies[i],max);\\n        }\\n        \\n        int low=1;\\n        int high=max;\\n        \\n        int ans=0;\\n        \\n        while(low<=high){\\n            int mid= low +(high-low) / 2;\\n            \\n            if(valid(mid,candies,k)){\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            \\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908742,
                "title": "python-binary-search",
                "content": "\\n\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n\\t\\n        n = len(candies)\\n        \\n        if k > sum(candies):\\n            return 0\\n        \\n        def check(m):\\n            cnt = 0\\n            for c in candies:\\n                cnt += c//m\\n            \\n            if cnt >= k:\\n                return True\\n            else:\\n                return False\\n        \\n        l = 1\\n        r = max(candies)\\n        \\n        while l < r:\\n            m = l + (r-l+1)//2\\n            \\n            if check(m):\\n                l = m\\n            else:\\n                r = m - 1\\n        \\n        return l\\n        \\n",
                "solutionTags": [],
                "code": "\\n\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n\\t\\n        n = len(candies)\\n        \\n        if k > sum(candies):\\n            return 0\\n        \\n        def check(m):\\n            cnt = 0\\n            for c in candies:\\n                cnt += c//m\\n            \\n            if cnt >= k:\\n                return True\\n            else:\\n                return False\\n        \\n        l = 1\\n        r = max(candies)\\n        \\n        while l < r:\\n            m = l + (r-l+1)//2\\n            \\n            if check(m):\\n                l = m\\n            else:\\n                r = m - 1\\n        \\n        return l\\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 1908739,
                "title": "easy-concept-using-binary-search",
                "content": "\\nSimply do binary search, \\'guess\\' the max number of candies each child can get\\nsearching range: left = 0, right = (sum(candies)//k)+1\\nin each guess, we go through the whole candies array and check whether this guess is valid\\n\\ntime complexity: O(logS)*O(N), where S is the span of searching range\\nspace complexity: O(1)\\n\\n```\\nfrom typing import List\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        def is_valid(x):\\n            if x == 0: return True\\n            cnt = 0\\n            for p in candies:\\n                if p >= x:              # we can divide pile into any number of sub-piles\\n                    cnt += p//x\\n                if cnt >= k:\\n                    return True\\n            return False\\n        \\n        l, r = 0, (sum(candies)//k)+1\\n        while l < r:\\n            m = (l+r+1)//2\\n            if is_valid(m):             # everyone can get m candies, but could get more: try bigger m\\n                l = m\\n            else:\\n                r = m-1\\n\\n        return l\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```\\nfrom typing import List\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        def is_valid(x):\\n            if x == 0: return True\\n            cnt = 0\\n            for p in candies:\\n                if p >= x:              # we can divide pile into any number of sub-piles\\n                    cnt += p//x\\n                if cnt >= k:\\n                    return True\\n            return False\\n        \\n        l, r = 0, (sum(candies)//k)+1\\n        while l < r:\\n            m = (l+r+1)//2\\n            if is_valid(m):             # everyone can get m candies, but could get more: try bigger m\\n                l = m\\n            else:\\n                r = m-1\\n\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908704,
                "title": "binary-search-c-o-nlogk",
                "content": "```\\n// use binary search to get optimum valuse\\n// O(n)\\n\\nclass Solution {\\npublic:\\n    bool check( long long mid, vector<int> &candies, long long k){\\n        long long cnt=0;\\n        for(auto c : candies){\\n            cnt += 1ll*c/mid;\\n        }\\n        return cnt >= k;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long lo=0, hi = 1e12+1;  // check for highest possible (although it will be max(candies))\\n        while(lo < hi){\\n            long long mid = lo+(hi-lo+1)/2;  \\n            if(mid == 0)\\n                return 0;\\n            if(check(mid, candies, k))\\n                lo = mid;\\n            else\\n                hi = mid-1;\\n        }\\n        return hi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\n// use binary search to get optimum valuse\\n// O(n)\\n\\nclass Solution {\\npublic:\\n    bool check( long long mid, vector<int> &candies, long long k){\\n        long long cnt=0;\\n        for(auto c : candies){\\n            cnt += 1ll*c/mid;\\n        }\\n        return cnt >= k;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long lo=0, hi = 1e12+1;  // check for highest possible (although it will be max(candies))\\n        while(lo < hi){\\n            long long mid = lo+(hi-lo+1)/2;  \\n            if(mid == 0)\\n                return 0;\\n            if(check(mid, candies, k))\\n                lo = mid;\\n            else\\n                hi = mid-1;\\n        }\\n        return hi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908700,
                "title": "easy-to-understand-with-detailed-explanation-and-java-code-binary-search",
                "content": "***Please upvote if you find this helpful :)***\\n\\nA typical binary search implemetation. \\n\\nWe need to find the maximum candies every child can get. We take a lower and an upper bound and try to find if the current candy count can be given to every child or not. In case it can be given, then we try to find the same thing for a higher candy count and hence update our low to mid+1. In case, the current count is not valid, then we decrease the count to high = mid-1\\n\\nEdge case - If the sum of candies is less than no of students then the candies can\\'t be distributed and the ans will be 0.\\n\\n```\\nclass Solution {\\n    \\n    private boolean isValid(int[] candies, long k, int target){\\n        long ans = 0;\\n        for(int candy: candies){\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0ans += (long)(candy/target);\\n        }\\n        return (ans>=k);\\n    }\\n    public int maximumCandies(int[] candies, long k) {\\n        int low = 0;\\n        int high = 10000000;\\n        int ans = 0;\\n        long sum = 0;\\n        for(int candy: candies){\\n            sum += candy;\\n        }\\n        if(sum<k){\\n            return 0;\\n        }\\n        while(low<=high){\\n            int mid = (low+high)/2;\\n            if(isValid(candies,k,mid)){\\n                ans = mid;\\n                low = mid+1;\\n            }else{\\n                high = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    private boolean isValid(int[] candies, long k, int target){\\n        long ans = 0;\\n        for(int candy: candies){\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0ans += (long)(candy/target);\\n        }\\n        return (ans>=k);\\n    }\\n    public int maximumCandies(int[] candies, long k) {\\n        int low = 0;\\n        int high = 10000000;\\n        int ans = 0;\\n        long sum = 0;\\n        for(int candy: candies){\\n            sum += candy;\\n        }\\n        if(sum<k){\\n            return 0;\\n        }\\n        while(low<=high){\\n            int mid = (low+high)/2;\\n            if(isValid(candies,k,mid)){\\n                ans = mid;\\n                low = mid+1;\\n            }else{\\n                high = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908698,
                "title": "c-binary-search-on-search-space-o-n-log-m-time-o-1-space",
                "content": "\\n**Binary search on Search space**\\nWe can atleast give 1 candy  and atmost max(candies) to each child. So, we binary search between 1 to max(candies).\\n\\n**How do we check, if we can give X candies to K children?**\\nIf we divide candy heaps into K or more sub heapes of size X. So, we try to divide each candy heap and see how many candy sub heaps of size X we can form. Sum of all X candy heaps in the array >= K children. Then we can say, we can divide X candies to K children.\\n\\n**Time complexity:** O(n log m), where n = size of array & m = max element in array\\n**Space complexity:** O(1)\\n\\n```\\n\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& candies, long long k, int val) {\\n        long long count = 0;\\n        for(int candy: candies) {\\n            count += candy / val;\\n        }\\n        \\n        return count >= k;\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int left = 1;\\n        int right = INT_MIN;\\n        long long sum = 0;\\n        for(int candy: candies) { \\n            right = max(right, candy);\\n            sum += candy;\\n        }\\n        \\n        if(sum < k) { return 0; }\\n        \\n        long long result = 0;\\n        while(left <= right) {\\n            long long mid = left + (right - left) / 2;\\n            if(isPossible(candies, k, mid)) {\\n                result = mid;\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& candies, long long k, int val) {\\n        long long count = 0;\\n        for(int candy: candies) {\\n            count += candy / val;\\n        }\\n        \\n        return count >= k;\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int left = 1;\\n        int right = INT_MIN;\\n        long long sum = 0;\\n        for(int candy: candies) { \\n            right = max(right, candy);\\n            sum += candy;\\n        }\\n        \\n        if(sum < k) { return 0; }\\n        \\n        long long result = 0;\\n        while(left <= right) {\\n            long long mid = left + (right - left) / 2;\\n            if(isPossible(candies, k, mid)) {\\n                result = mid;\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4052744,
                "title": "c-solution-using-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nbinary search approach similar to koko eating bananas\\n\\n# Complexity\\n- Time complexity:\\n- O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool noOfCandies(vector<int> candies,int n,long long candiesPerChild,long long totalNoOfKids){\\n        long long noOfKidsWithCandies=0;\\n        for(int i=0;i<n;i++){\\n            noOfKidsWithCandies+=candies[i]/candiesPerChild;\\n            if(noOfKidsWithCandies>=totalNoOfKids){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int n=candies.size();\\n        long long low=1;\\n        long long high=0;\\n        for(int i=0;i<n;i++){\\n            high+=candies[i];\\n        }\\n        if(k>high){\\n            return 0;\\n        }\\n        while(low<=high){\\n            long long mid=low+(high-low)/2;\\n            if(noOfCandies(candies,n,mid,k)){\\n                low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        return high;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool noOfCandies(vector<int> candies,int n,long long candiesPerChild,long long totalNoOfKids){\\n        long long noOfKidsWithCandies=0;\\n        for(int i=0;i<n;i++){\\n            noOfKidsWithCandies+=candies[i]/candiesPerChild;\\n            if(noOfKidsWithCandies>=totalNoOfKids){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int n=candies.size();\\n        long long low=1;\\n        long long high=0;\\n        for(int i=0;i<n;i++){\\n            high+=candies[i];\\n        }\\n        if(k>high){\\n            return 0;\\n        }\\n        while(low<=high){\\n            long long mid=low+(high-low)/2;\\n            if(noOfCandies(candies,n,mid,k)){\\n                low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        return high;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4024376,
                "title": "exactly-the-same-as-koko-eat-banana",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int max = Integer.MIN_VALUE;\\n        for (int candy : candies) max = Math.max(max, candy);\\n        int l = 0, r = max;\\n        while (l < r) {\\n            System.out.println(l + \" \" + r);\\n            int mid = r - (r - l ) / 2; // mid as unit\\n            if (canDivide(candies, k, mid)) {\\n                l = mid;\\n            } else {\\n                r = mid - 1;\\n            }\\n        }\\n        return l;\\n\\n    }\\n\\n    private boolean canDivide(int[] candies, long k, int unit) {\\n        if (unit == 0) return true; // This is different from koko question\\n        long cnt = 0;\\n        for (int candy : candies) {\\n            cnt += (long) candy / unit;\\n        }\\n\\n        return cnt >= k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int max = Integer.MIN_VALUE;\\n        for (int candy : candies) max = Math.max(max, candy);\\n        int l = 0, r = max;\\n        while (l < r) {\\n            System.out.println(l + \" \" + r);\\n            int mid = r - (r - l ) / 2; // mid as unit\\n            if (canDivide(candies, k, mid)) {\\n                l = mid;\\n            } else {\\n                r = mid - 1;\\n            }\\n        }\\n        return l;\\n\\n    }\\n\\n    private boolean canDivide(int[] candies, long k, int unit) {\\n        if (unit == 0) return true; // This is different from koko question\\n        long cnt = 0;\\n        for (int candy : candies) {\\n            cnt += (long) candy / unit;\\n        }\\n\\n        return cnt >= k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023068,
                "title": "c-binary-search-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long x=*max_element(candies.begin(),candies.end());\\n        long long low=1,high=x;\\n        long long ans=0;\\n        while(low<=high){\\n            long long mid=(low+high)/2;\\n            long long cnt=0;\\n            for(int i=0;i<candies.size();i++){\\n                cnt=cnt+candies[i]/mid;\\n            }\\n            if(cnt>=k){\\n                ans=max(ans,mid);\\n                low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long x=*max_element(candies.begin(),candies.end());\\n        long long low=1,high=x;\\n        long long ans=0;\\n        while(low<=high){\\n            long long mid=(low+high)/2;\\n            long long cnt=0;\\n            for(int i=0;i<candies.size();i++){\\n                cnt=cnt+candies[i]/mid;\\n            }\\n            if(cnt>=k){\\n                ans=max(ans,mid);\\n                low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988243,
                "title": "9-o-n-solution-using-binary-search",
                "content": "# Intuition\\nbecause equal no. of candies have to be distributed among k children, so we will have to check the feasibility of the number of candies that can be distributed.\\n\\nex: for cadies [ 5, 6, 8] and k = 3,\\nwe have to distriburte among k = 3 children, so we will find the largest number that can be extracted from any of the indexes k (3) times.\\nIt can be in different indexes or the same indexes.\\nfor the above example, it can be sub-divided into\\n[5, [5, 1], [5, 3]], so we can have 5 as the largest number of candies that can be distributed.\\n\\nif we had candies: [2, 20], k = 3;\\nhere we simply have to divide 20 into 3 equal numbers\\n[2, [6, 6, 6, 2]]\\nin the above we have 6 as an answer.\\n\\ntry solving problem number : 875\\n# Approach\\nfor every feasible number T from 1 -> totalSumOfCandies / n candies, we will check for each of them if its feasible or not to divide the array on that number T.\\nwe will use BS for this\\n\\n\\n# Complexity\\n- Time complexity:\\nN*O(N)\\n- Space complexity:\\nO(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n\\t\\t\\tint n = candies.size();\\n\\n\\t\\t\\tlong long totalCandies = accumulate(begin(candies),end(candies),0ll);\\n\\n\\t\\t\\tif(totalCandies < k)\\treturn 0;\\n\\n\\t\\t\\tlong long s = 1, e = totalCandies/k;\\n\\t\\t\\tlong long mid = -1;\\n\\n\\t\\t\\twhile(s <= e) {\\n\\t\\t\\t\\tmid = s + (e-s)/2;\\n\\n\\t\\t\\t\\tlong int cnt = 0;\\n\\t\\t\\t\\tfor(int i = 0; i < n; i++) {\\n\\t\\t\\t\\t\\tif(candies[i] >= mid)\\n\\t\\t\\t\\t\\t\\tcnt += 1ll*(candies[i]/mid);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif(cnt >= k)\\ts = mid+1;\\n\\t\\t\\t\\telse\\t\\t\\te = mid-1;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn e;\\n\\t\\t}\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n\\t\\t\\tint n = candies.size();\\n\\n\\t\\t\\tlong long totalCandies = accumulate(begin(candies),end(candies),0ll);\\n\\n\\t\\t\\tif(totalCandies < k)\\treturn 0;\\n\\n\\t\\t\\tlong long s = 1, e = totalCandies/k;\\n\\t\\t\\tlong long mid = -1;\\n\\n\\t\\t\\twhile(s <= e) {\\n\\t\\t\\t\\tmid = s + (e-s)/2;\\n\\n\\t\\t\\t\\tlong int cnt = 0;\\n\\t\\t\\t\\tfor(int i = 0; i < n; i++) {\\n\\t\\t\\t\\t\\tif(candies[i] >= mid)\\n\\t\\t\\t\\t\\t\\tcnt += 1ll*(candies[i]/mid);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif(cnt >= k)\\ts = mid+1;\\n\\t\\t\\t\\telse\\t\\t\\te = mid-1;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn e;\\n\\t\\t}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963858,
                "title": "simple-python-solution",
                "content": "# Intuition\\nThis is similar to minimizing the result but now we have to find the maximum that satisfies some condition. If you remember firstBadVersion problem, you know we didn\\'t stop until we found the result, the only difference is minimum lies on the left side of our inputs, and maximum on the right side. \\n\\n# Approach\\nBinary Search and narrow down till we have our result.\\n\\n# Code\\n```\\ndef success(number, candies, children):    \\n    count = 0\\n    for candy in candies:\\n        if number > 0:\\n            count += math.floor(candy/number)\\n        \\n        if count >= children:\\n            return True\\n    \\n    return False\\n\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        if sum(candies) < k:\\n            return 0\\n\\n        left = 1\\n        right = max(set(candies))\\n\\n        result = 0\\n        while left <= right:\\n            mid  = (left + right)//2\\n            if success(mid, candies, k):\\n                result = mid\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n\\n        return result\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef success(number, candies, children):    \\n    count = 0\\n    for candy in candies:\\n        if number > 0:\\n            count += math.floor(candy/number)\\n        \\n        if count >= children:\\n            return True\\n    \\n    return False\\n\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        if sum(candies) < k:\\n            return 0\\n\\n        left = 1\\n        right = max(set(candies))\\n\\n        result = 0\\n        while left <= right:\\n            mid  = (left + right)//2\\n            if success(mid, candies, k):\\n                result = mid\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n\\n        return result\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947592,
                "title": "c-solution-faster-than-95",
                "content": "# Intuition\\nImplementation of Book Allocation problem using Binary Search\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool isPossible(vector<int> arr, long long k, int mid) {\\n        long long int children = 0;\\n        for (int i : arr) {\\n            children += i / mid;\\n            if (children >= k) return true;\\n        }\\n        return false;\\n    }\\n\\n\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long int start = 1;\\n        long long int end = *max_element(candies.begin(), candies.end());;\\n        long long int mid = start + (end - start) / 2;\\n        long long int ans = 0;\\n\\n        while(start <= end) {\\n            if(isPossible(candies, k, mid)) {\\n                ans = mid;\\n                start = mid + 1;\\n            }\\n            else end = mid - 1;\\n            mid = start + (end - start) / 2;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\n# Approach\\nI\\'ll try to explain using a testcase and dry run:\\n\\n### Input:\\ncandies = [5, 8, 6]\\nk = 3\\n\\n\\n\\n### Dry Run:\\n\\n1. Initialize start as 1, end as the maximum element in candies, which is 8, and mid as (1 + 8) / 2 = 4. ans is initialized as 0.\\n\\n\\n2. Enter the binary search loop:\\n- Check if it\\'s possible to distribute candies with mid = 4 among 3 children using isPossible().\\n    - Initialize children as 0.\\n    - Loop through each pile of candies:\\n        - For the first pile of 5 candies, children += 5 / 4, which is 1.\\n        - For the second pile of 8 candies, children += 8 / 4, which is 3.\\n        - For the third pile of 6 candies, children += 6 / 4, which is 4.\\n    - Check if children (4) is greater than or equal to k (3). It\\'s true.\\n    - Set ans to 4 and update start to mid + 1, which is 5.\\n    - Update mid to (5 + 8) / 2 = 6.\\n\\n\\n3. Loop again:\\n- Check if it\\'s possible to distribute candies with mid = 6 among 3 children using isPossible().\\n    - Initialize children as 0.\\n    - Loop through each pile of candies:\\n        - For the first pile of 5 candies, children += 5 / 6, which is 0.\\n        - For the second pile of 8 candies, children += 8 / 6, which is 1.\\n        - For the third pile of 6 candies, children += 6 / 6, which is 1.\\n    - Check if children (1) is greater than or equal to k (3). It\\'s false.\\n    - Update end to mid - 1, which is 5.\\n    - Update mid to (5 + 5) / 2 = 5.\\n\\n\\n4. Loop again:\\n- Check if it\\'s possible to distribute candies with mid = 5 among 3 children using isPossible().\\n    - Initialize children as 0.\\n    - Loop through each pile of candies:\\n        - For the first pile of 5 candies, children += 5 / 5, which is 1.\\n        - For the second pile of 8 candies, children += 8 / 5, which is 2.\\n        - For the third pile of 6 candies, children += 6 / 5, which is 3.\\n    - Check if children (3) is greater than or equal to k (3). It\\'s true.\\n    - Set ans to 5 and update start to mid + 1, which is 6.\\n    - Update mid to (6 + 5) / 2 = 5.\\n\\n5. Since start is not less than or equal to end, the loop ends.\\n\\n\\n### Output:\\nThe function returns ans, which is 5. This means each child can receive at most 5 candies.\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n * log(max_element))\\n\\n- Space complexity: O(1)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool isPossible(vector<int> arr, long long k, int mid) {\\n        long long int children = 0;\\n        for (int i : arr) {\\n            children += i / mid;\\n            if (children >= k) return true;\\n        }\\n        return false;\\n    }\\n\\n\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long int start = 1;\\n        long long int end = *max_element(candies.begin(), candies.end());;\\n        long long int mid = start + (end - start) / 2;\\n        long long int ans = 0;\\n\\n        while(start <= end) {\\n            if(isPossible(candies, k, mid)) {\\n                ans = mid;\\n                start = mid + 1;\\n            }\\n            else end = mid - 1;\\n            mid = start + (end - start) / 2;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3936994,
                "title": "c-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n     public int MaximumCandies(int[] candies, long k)\\n    {\\n        long left = 1;\\n        long right = 0;\\n\\n        long sum = 0;\\n        foreach (var candy in candies)\\n        {\\n            sum += candy;\\n        }\\n\\n        right = sum / k;\\n        var answer = 0;\\n        \\n        while (left <= right)\\n        {\\n            var mid = left + (right - left) / 2;\\n            var count = CalculateCandies(mid, candies);\\n            \\n            if (count < k)\\n            {\\n                right = mid - 1;\\n            }\\n            else\\n            {\\n                answer = (int)mid;\\n                left = mid + 1;\\n            }\\n        }\\n\\n        return answer;\\n    }\\n\\n    long CalculateCandies(long mid, int[] candies)\\n    {\\n        long count = 0;\\n        \\n        foreach (var candy in candies)\\n        {\\n            if (candy >= mid)\\n            {\\n                count += candy / mid;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n     public int MaximumCandies(int[] candies, long k)\\n    {\\n        long left = 1;\\n        long right = 0;\\n\\n        long sum = 0;\\n        foreach (var candy in candies)\\n        {\\n            sum += candy;\\n        }\\n\\n        right = sum / k;\\n        var answer = 0;\\n        \\n        while (left <= right)\\n        {\\n            var mid = left + (right - left) / 2;\\n            var count = CalculateCandies(mid, candies);\\n            \\n            if (count < k)\\n            {\\n                right = mid - 1;\\n            }\\n            else\\n            {\\n                answer = (int)mid;\\n                left = mid + 1;\\n            }\\n        }\\n\\n        return answer;\\n    }\\n\\n    long CalculateCandies(long mid, int[] candies)\\n    {\\n        long count = 0;\\n        \\n        foreach (var candy in candies)\\n        {\\n            if (candy >= mid)\\n            {\\n                count += candy / mid;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3931339,
                "title": "easy-binary-search-solution",
                "content": "Using Binary search optimized approach\\n\\n```\\nclass Solution {\\npublic:\\n    bool func(long long n,vector<int>& arr,long long k)\\n    {\\n        long long res=0;\\n        for(int i=0;i<arr.size();i++)\\n            res+=(long long)arr[i]/n;\\n        return res>=k;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long l=1,n=candies.size();\\n        long long h=1;\\n        for(int i=0;i<n;i++)\\n            h=max(h,(long long)candies[i]);\\n        long long ans=0;\\n        while(l<=h)\\n        {\\n            long long mid=(l+h)/2;\\n            if(func(mid,candies,k))\\n            {\\n                ans=max(ans,mid);\\n                l=mid+1;\\n            }\\n            else\\n                h=mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool func(long long n,vector<int>& arr,long long k)\\n    {\\n        long long res=0;\\n        for(int i=0;i<arr.size();i++)\\n            res+=(long long)arr[i]/n;\\n        return res>=k;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long l=1,n=candies.size();\\n        long long h=1;\\n        for(int i=0;i<n;i++)\\n            h=max(h,(long long)candies[i]);\\n        long long ans=0;\\n        while(l<=h)\\n        {\\n            long long mid=(l+h)/2;\\n            if(func(mid,candies,k))\\n            {\\n                ans=max(ans,mid);\\n                l=mid+1;\\n            }\\n            else\\n                h=mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3927055,
                "title": "easy-java-solution-for-beginners",
                "content": "# Code\\n```\\nclass Solution {\\n    public int maximumCandies(int[] nums, long k) {\\n        int n=nums.length;\\n        int max=0;\\n        for(int x:nums){\\n            max=Math.max(x,max);\\n        }\\n        int st=1;\\n        int end=max;\\n        int ans=0;\\n        while(st<=end){\\n            int mid=(st+end)/2;\\n            if(solve(nums,mid)>=k){\\n                ans=Math.max(ans,mid);\\n                st=mid+1;\\n            }\\n            else{\\n                end=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    public double solve(int[] nums,int t){\\n        double count=0;\\n        if(t==0) return 0;\\n        for(int x:nums){\\n            count+=x/t;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] nums, long k) {\\n        int n=nums.length;\\n        int max=0;\\n        for(int x:nums){\\n            max=Math.max(x,max);\\n        }\\n        int st=1;\\n        int end=max;\\n        int ans=0;\\n        while(st<=end){\\n            int mid=(st+end)/2;\\n            if(solve(nums,mid)>=k){\\n                ans=Math.max(ans,mid);\\n                st=mid+1;\\n            }\\n            else{\\n                end=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    public double solve(int[] nums,int t){\\n        double count=0;\\n        if(t==0) return 0;\\n        for(int x:nums){\\n            count+=x/t;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924412,
                "title": "go-binary-search-100-runtime-90-memory",
                "content": "```\\nfunc maximumCandies(candies []int, k int64) int {\\n    sum := 0\\n    for _, c := range candies {\\n        sum+=c\\n    }\\n    if k > int64(sum) {\\n        return 0\\n    }\\n\\n    l, r, res := 1, sum/int(k), 0\\n\\n    for l <= r {\\n        m := (l+r)/2\\n        numOfCandies := 0\\n        \\n        for _, c := range candies {\\n            numOfCandies += (c / m)\\n        }\\n        if int64(numOfCandies) < k {\\n            r = m - 1\\n        } else {\\n            res = m\\n            l = m + 1\\n        }\\n    }\\n\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maximumCandies(candies []int, k int64) int {\\n    sum := 0\\n    for _, c := range candies {\\n        sum+=c\\n    }\\n    if k > int64(sum) {\\n        return 0\\n    }\\n\\n    l, r, res := 1, sum/int(k), 0\\n\\n    for l <= r {\\n        m := (l+r)/2\\n        numOfCandies := 0\\n        \\n        for _, c := range candies {\\n            numOfCandies += (c / m)\\n        }\\n        if int64(numOfCandies) < k {\\n            r = m - 1\\n        } else {\\n            res = m\\n            l = m + 1\\n        }\\n    }\\n\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3902866,
                "title": "c-binary-search",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(\\\\log{max(candies)})$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        sort(candies.begin(), candies.end());\\n        int lo = 1, hi = 0, mid, res = 0, n = candies.size();\\n        hi = candies.back();\\n        while (lo <= hi) {\\n            mid = (lo + hi) / 2;\\n            long long tmp = k;\\n            for (int i = n - 1; i >= 0; -- i) {\\n                tmp -= 1LL * candies[i] / mid;\\n                if (tmp <= 0) break;\\n            }\\n            if (tmp <= 0) {\\n                res = mid;\\n                lo = mid + 1;\\n            } else hi = mid - 1;\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Please upvote if u like the solution :)**",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        sort(candies.begin(), candies.end());\\n        int lo = 1, hi = 0, mid, res = 0, n = candies.size();\\n        hi = candies.back();\\n        while (lo <= hi) {\\n            mid = (lo + hi) / 2;\\n            long long tmp = k;\\n            for (int i = n - 1; i >= 0; -- i) {\\n                tmp -= 1LL * candies[i] / mid;\\n                if (tmp <= 0) break;\\n            }\\n            if (tmp <= 0) {\\n                res = mid;\\n                lo = mid + 1;\\n            } else hi = mid - 1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3901111,
                "title": "binary-search-on-solution-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe number of piles, given the number of candies per child, can be calculated in linear time and is monotonic. So we can binary search on the solution space.\\n\\n# Complexity\\n- Time complexity: $$O(N*log(k))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn maximum_candies(candies: Vec<i32>, k: i64) -> i32 {\\n        let count_piles = |n| {\\n            candies.iter().map(|&c| (c / n) as i64).sum::<i64>()\\n        };\\n\\n        let mut lo = 0;\\n        let mut hi = *candies.iter().max().unwrap();\\n        while lo < hi {\\n            let mid = lo + (hi - lo + 1) / 2;\\n            if count_piles(mid) >= k { lo = mid }\\n            else { hi = mid - 1 }\\n        }\\n        lo\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn maximum_candies(candies: Vec<i32>, k: i64) -> i32 {\\n        let count_piles = |n| {\\n            candies.iter().map(|&c| (c / n) as i64).sum::<i64>()\\n        };\\n\\n        let mut lo = 0;\\n        let mut hi = *candies.iter().max().unwrap();\\n        while lo < hi {\\n            let mid = lo + (hi - lo + 1) / 2;\\n            if count_piles(mid) >= k { lo = mid }\\n            else { hi = mid - 1 }\\n        }\\n        lo\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3900497,
                "title": "c-solution-binary-search",
                "content": "\\n# Complexity\\n- Time complexity:\\n$$O(nlong(n))$$\\n- Space complexity:\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int high = INT_MIN;\\n        for(auto it : candies){\\n            high = max(high,it);\\n        }\\n        int low =1;\\n        while(low <= high){\\n            long long candiesget=0;\\n            int mid = (low+high)/2;\\n            for(auto it : candies){\\n                candiesget += (it)/mid;\\n\\n            }\\n            if(candiesget >= k){\\n                low = mid+1;\\n            }else{\\n                high = mid-1;\\n            }\\n        }\\n        return high;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int high = INT_MIN;\\n        for(auto it : candies){\\n            high = max(high,it);\\n        }\\n        int low =1;\\n        while(low <= high){\\n            long long candiesget=0;\\n            int mid = (low+high)/2;\\n            for(auto it : candies){\\n                candiesget += (it)/mid;\\n\\n            }\\n            if(candiesget >= k){\\n                low = mid+1;\\n            }else{\\n                high = mid-1;\\n            }\\n        }\\n        return high;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3893424,
                "title": "easy-solution-5-lines",
                "content": "# Complexity\\n- Time complexity:\\nO(log n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        l, r = 0, max(candies)\\n        while l <= r:\\n            m = (l+r)//2\\n            l, r = (m+1, r) if not m or sum(candy // m for candy in candies) >= k else (l, m-1)\\n        return r\\n```\\n\\nPlease let me know if any improvements can be made.\\n\\nThanks",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        l, r = 0, max(candies)\\n        while l <= r:\\n            m = (l+r)//2\\n            l, r = (m+1, r) if not m or sum(candy // m for candy in candies) >= k else (l, m-1)\\n        return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3891171,
                "title": "best-approach-v-easy-to-understand-beats-90",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBinary Search\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool morePossible(vector<int>& candies, long long k, int amount){\\n        long long count = 0;\\n        for(int i = 0; i<candies.size(); i++){\\n            count += (candies[i]/amount);\\n        }\\n        if(count >= k)return true;\\n\\n        return false;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int right = *max_element(candies.begin(), candies.end());\\n        int left = 1;\\n        int res = 0;\\n       \\n        while(left <= right){\\n            int mid = (left +right)/2;\\n            if(morePossible(candies, k, mid)){\\n                res = mid;\\n                left = mid+1;\\n            }else{\\n                right = mid-1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool morePossible(vector<int>& candies, long long k, int amount){\\n        long long count = 0;\\n        for(int i = 0; i<candies.size(); i++){\\n            count += (candies[i]/amount);\\n        }\\n        if(count >= k)return true;\\n\\n        return false;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int right = *max_element(candies.begin(), candies.end());\\n        int left = 1;\\n        int res = 0;\\n       \\n        while(left <= right){\\n            int mid = (left +right)/2;\\n            if(morePossible(candies, k, mid)){\\n                res = mid;\\n                left = mid+1;\\n            }else{\\n                right = mid-1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3890228,
                "title": "kotlin-solution",
                "content": "# Binary search\\n```\\nclass Solution {\\n    fun maximumCandies(candies: IntArray, k: Long): Int {\\n        var left = 0\\n        var right = 10_000_000\\n\\n        while (left < right) {\\n            val m = (left + right + 1) / 2\\n            var childWithCandies: Long = 0\\n\\n            candies.forEach {\\n                childWithCandies += it / m\\n            }\\n\\n            if (childWithCandies >= k) left = m\\n            else right = m - 1\\n        }\\n\\n        return left\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun maximumCandies(candies: IntArray, k: Long): Int {\\n        var left = 0\\n        var right = 10_000_000\\n\\n        while (left < right) {\\n            val m = (left + right + 1) / 2\\n            var childWithCandies: Long = 0\\n\\n            candies.forEach {\\n                childWithCandies += it / m\\n            }\\n\\n            if (childWithCandies >= k) left = m\\n            else right = m - 1\\n        }\\n\\n        return left\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887281,
                "title": "java-solution-binary-search-on-answer-beats-95",
                "content": "\\n\\n\\n# Complexity\\n- Time complexity: O(N*logM) M is range of max element.. \\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n       int low =1;\\n       int high = findMax(candies); \\n       while(low <= high){\\n           int mid = low + (high-low)/2;\\n           if(isValid(candies,mid,k)){\\n               low = mid+1;\\n           }else {\\n               high = mid-1;\\n           }\\n       }\\n       return high;\\n    }\\n    public int findMax(int [] candies){\\n        int max = 0;\\n        for(int i:candies){\\n            max = Math.max(max,i);\\n        }\\n        return max;\\n    }\\n\\n    public boolean isValid(int [] candies, int mid,long k){\\n        long piles = 0;\\n        for(int i: candies){\\n            int add = i/mid;\\n            piles += add;\\n        }\\n        return piles >=k;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n       int low =1;\\n       int high = findMax(candies); \\n       while(low <= high){\\n           int mid = low + (high-low)/2;\\n           if(isValid(candies,mid,k)){\\n               low = mid+1;\\n           }else {\\n               high = mid-1;\\n           }\\n       }\\n       return high;\\n    }\\n    public int findMax(int [] candies){\\n        int max = 0;\\n        for(int i:candies){\\n            max = Math.max(max,i);\\n        }\\n        return max;\\n    }\\n\\n    public boolean isValid(int [] candies, int mid,long k){\\n        long piles = 0;\\n        for(int i: candies){\\n            int add = i/mid;\\n            piles += add;\\n        }\\n        return piles >=k;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3880468,
                "title": "simple-binary-search-beginers",
                "content": "# Intuition\\nThe very simple binary search with simple and easy checker function \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFirst just put a binary search on the possible values of the answer in the vector simple and easy approch \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(  log(n) )\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checker(int target,long long int k ,vector <int > & candies)\\n    {\\n        for(int i=0;i<candies.size();i++)\\n        {\\n            k-=candies[i]/target;\\n        }\\n        if(k>0) return false;\\n        else return true;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long int low=1,mid,high=*max_element(candies.begin(),candies.end());\\n        int ans=0;\\n        while(low<=high)\\n        {\\n            mid=low+(high-low)/2;\\n            if(checker(mid,k,candies))\\n            {\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else high=mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Hash Function"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checker(int target,long long int k ,vector <int > & candies)\\n    {\\n        for(int i=0;i<candies.size();i++)\\n        {\\n            k-=candies[i]/target;\\n        }\\n        if(k>0) return false;\\n        else return true;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long int low=1,mid,high=*max_element(candies.begin(),candies.end());\\n        int ans=0;\\n        while(low<=high)\\n        {\\n            mid=low+(high-low)/2;\\n            if(checker(mid,k,candies))\\n            {\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else high=mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879864,
                "title": "easy-c-sol",
                "content": "# Intuition\\njust use binary search to find mid and check that mid is possible or not..\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int>&candies,int mid,long long k)\\n    {\\n        long long cnt=0;\\n        for(int i=0;i<candies.size();i++)\\n        {\\n            cnt+=(candies[i]/mid);\\n        }\\n        return cnt>=k;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n         int high=*max_element(candies.begin(),candies.end());\\n         int low=1;\\n         int ans=0;\\n         while(low<=high)\\n         {\\n              int mid=(low+high)/2;\\n              if(check(candies,mid,k))\\n              {\\n                  ans=max(ans,mid);\\n                  low=mid+1;\\n              }\\n              else high=mid-1;\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>&candies,int mid,long long k)\\n    {\\n        long long cnt=0;\\n        for(int i=0;i<candies.size();i++)\\n        {\\n            cnt+=(candies[i]/mid);\\n        }\\n        return cnt>=k;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n         int high=*max_element(candies.begin(),candies.end());\\n         int low=1;\\n         int ans=0;\\n         while(low<=high)\\n         {\\n              int mid=(low+high)/2;\\n              if(check(candies,mid,k))\\n              {\\n                  ans=max(ans,mid);\\n                  low=mid+1;\\n              }\\n              else high=mid-1;\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3872085,
                "title": "detailed-thought-process-start-with-linear-search-and-convert-your-thought-to-binary-search-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBinary search: \\nHere this is the problem of maximisation over sorted search space.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# **First think of searching maximum candy linearly :**\\n\\nWhat will be sorted search space for this problem:\\n    Here candies = {5,8,6}; k = 3\\n   here total candies = (5+8+6) = 19 and these 19 candies we have to distribute on k children.\\n\\nso one just intuitive way comes to our mind that just devide 19 by 3 i.e 19/3 = 6 candy.  so distribute 6 candy to each children 6*3 = 18 candy will be distributed. so here one possible ans could be 6,\\nsay ans = 6, now check if this ans is valid or not\\n\\nhere we are distributing 6 candy to each children, then one thing we have to make sure that each of the piles must contains candy greater than or equal to 6 candy then only we will be able to distribute 6 candy to each children. as in problem statement it is clearly mentioned that you can\\'t merge two piles of candies.  but we can distribute two children from one pile. but candy from two pile can\\'t be distributed to single child.\\n\\nHere candies[0] = 5 < ans =6, so here it is not possible to distribute 6 candy to each children.\\nas to distribute 6 candy, we have to 2 extra candy to pile candies[1] = 8, so if we are using these 2 extra candy in candies[0] = 5 to distribute 6, then it is a king of merging candy from two piles that is conflicting the problem statement. so this is not possible.\\n\\n\\nNow lets reduce the amount of candy from 6 to 5, say ans = 5, lets check if we can distribute , so clearly we can see that each of the piles has greater than or equal to 5 candy. so this is our feasible ans.\\n\\nso we will not go below 5 as we need maximum candy to distribute.\\n\\n# Binary Search thought:\\n\\nSo above idea to search the maximum candy linearley. \\n\\nbut here search space is sorted we can apply binary search on the search space low = 1 and high = 10^7 or (sum of all candy)/ k\\n\\nhere low = 1 as we can distribute 1 candy for sure as 1<=candies[i]<= 10^7\\nand high = (sum of all candy)/ k or we can take directly 10^7 as it is the max possible value of candy in a pile. any thing greater than 10^7 is not possible. \\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int min = 0; int max = 0;\\n        long sum = 0;\\n        for(int candy : candies){\\n            sum += candy;\\n        }\\n\\n        if(sum < k) return 0;\\n        long s = 1;\\n        long e = (long)1e7;//sum/k;\\n        long ans = s;\\n        while(s <= e){\\n            long mid = s + (e-s)/2;\\n            if(canDistribute(candies,mid, k)){\\n                ans = mid;\\n                s = mid + 1;\\n            } else {\\n                e = mid -1;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n\\n\\n    private boolean canDistribute(int [] candies, long mid, long k){\\n        long count = 0;\\n        for(int candy : candies){\\n           count += candy/mid;\\n        }\\n        return count >= k;\\n    }\\n}\\n```\\n# Complexity\\n- Time complexity: O(nlog(Max{candies[i]})) as a for loop is running at starting to find the sum. \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int min = 0; int max = 0;\\n        long sum = 0;\\n        for(int candy : candies){\\n            sum += candy;\\n        }\\n\\n        if(sum < k) return 0;\\n        long s = 1;\\n        long e = (long)1e7;//sum/k;\\n        long ans = s;\\n        while(s <= e){\\n            long mid = s + (e-s)/2;\\n            if(canDistribute(candies,mid, k)){\\n                ans = mid;\\n                s = mid + 1;\\n            } else {\\n                e = mid -1;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n\\n\\n    private boolean canDistribute(int [] candies, long mid, long k){\\n        long count = 0;\\n        for(int candy : candies){\\n           count += candy/mid;\\n        }\\n        return count >= k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862887,
                "title": "binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long findNumberOfPeople(vector<int>& candies, long long mid) {\\n        long long total = 0;\\n        for(int i=0; i<candies.size(); i++) {\\n            total += candies[i] / mid;\\n        }\\n        return total;\\n    }\\n\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        if(accumulate(candies.begin(),candies.end(),0ll)<k)\\n        return 0;\\n        long long s = 1;\\n        long long h = *max_element(candies.begin(), candies.end());\\n        while (s < h) {\\n            long long m = s + (h - s + 1) / 2;\\n            if (findNumberOfPeople(candies, m) >= k) {\\n                s = m;\\n            }\\n            else {\\n                h = m - 1;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long findNumberOfPeople(vector<int>& candies, long long mid) {\\n        long long total = 0;\\n        for(int i=0; i<candies.size(); i++) {\\n            total += candies[i] / mid;\\n        }\\n        return total;\\n    }\\n\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        if(accumulate(candies.begin(),candies.end(),0ll)<k)\\n        return 0;\\n        long long s = 1;\\n        long long h = *max_element(candies.begin(), candies.end());\\n        while (s < h) {\\n            long long m = s + (h - s + 1) / 2;\\n            if (findNumberOfPeople(candies, m) >= k) {\\n                s = m;\\n            }\\n            else {\\n                h = m - 1;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849983,
                "title": "binary-search-13-ms-beats-99-7-runtime-98-77-memory",
                "content": "# Complexity\\n- Time complexity:\\nO(k * log(sum(candies)/k))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n  public int maximumCandies(int[] candies, long k) {\\n    long countCandies = 0;\\n    for (int i = 0; i < candies.length; i++) {\\n      countCandies += candies[i];\\n    }\\n\\n    long left = 1, right = countCandies / k;\\n    long maxCandies = 0;\\n    while (left <= right) {\\n      long mid = left + (right - left) / 2;\\n      long countAlloted = 0;\\n      for (int i = 0; i < candies.length; i++) {\\n        countAlloted += candies[i] / mid;\\n        if (countAlloted >= k) {\\n          break;\\n        }\\n      }\\n\\n      if (countAlloted >= k) {\\n        maxCandies = mid;\\n        left = mid + 1;\\n        continue;\\n      }\\n\\n      right = mid - 1;\\n    }\\n\\n    return (int) maxCandies;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n  public int maximumCandies(int[] candies, long k) {\\n    long countCandies = 0;\\n    for (int i = 0; i < candies.length; i++) {\\n      countCandies += candies[i];\\n    }\\n\\n    long left = 1, right = countCandies / k;\\n    long maxCandies = 0;\\n    while (left <= right) {\\n      long mid = left + (right - left) / 2;\\n      long countAlloted = 0;\\n      for (int i = 0; i < candies.length; i++) {\\n        countAlloted += candies[i] / mid;\\n        if (countAlloted >= k) {\\n          break;\\n        }\\n      }\\n\\n      if (countAlloted >= k) {\\n        maxCandies = mid;\\n        left = mid + 1;\\n        continue;\\n      }\\n\\n      right = mid - 1;\\n    }\\n\\n    return (int) maxCandies;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3848305,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    bool isPossible(vector<int>&candies,long long k,long long mid){\\n        long long count = 0;\\n        long long sum = 0;\\n        for(auto i:candies)\\n            count += i/mid;\\n        return count >= k;\\n    }\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int low = 1;\\n        long long high = 0;\\n        for(auto i:candies)\\n            high += i;\\n        long long ans = 0;\\n        long long mid = 0;\\n        if(high < k)\\n            return 0;\\n        while(low <= high){\\n            mid = low + (high - low)/2;\\n            if(isPossible(candies,k,mid)){\\n                ans = mid;\\n                low = mid + 1;\\n            }\\n            else\\n                high = mid - 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    bool isPossible(vector<int>&candies,long long k,long long mid){\\n        long long count = 0;\\n        long long sum = 0;\\n        for(auto i:candies)\\n            count += i/mid;\\n        return count >= k;\\n    }\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int low = 1;\\n        long long high = 0;\\n        for(auto i:candies)\\n            high += i;\\n        long long ans = 0;\\n        long long mid = 0;\\n        if(high < k)\\n            return 0;\\n        while(low <= high){\\n            mid = low + (high - low)/2;\\n            if(isPossible(candies,k,mid)){\\n                ans = mid;\\n                low = mid + 1;\\n            }\\n            else\\n                high = mid - 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3829075,
                "title": "faster-than-100-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n*log(right))\\n\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        if sum(candies)<k : \\n            return 0 \\n        \\n        def helper (val): \\n            crr = 0 \\n            for ele in candies : \\n                crr += (ele//val)\\n            if crr >= k : \\n                return True \\n            return False \\n        \\n        left =1\\n        right = sum(candies)//k \\n\\n        while left < right : \\n            mid = left + (right-left)//2\\n            if helper(mid): \\n                left = mid + 1 \\n            else : \\n                right = mid \\n        return left if helper(left) else left-1 \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        if sum(candies)<k : \\n            return 0 \\n        \\n        def helper (val): \\n            crr = 0 \\n            for ele in candies : \\n                crr += (ele//val)\\n            if crr >= k : \\n                return True \\n            return False \\n        \\n        left =1\\n        right = sum(candies)//k \\n\\n        while left < right : \\n            mid = left + (right-left)//2\\n            if helper(mid): \\n                left = mid + 1 \\n            else : \\n                right = mid \\n        return left if helper(left) else left-1 \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3824964,
                "title": "python-binary-search-solution",
                "content": "# Intuition \\nBinary Search, where the max amount is the number of available candies we have. We want to maximize this so we update our result.\\n# Approach\\nThe only addition to binary search is to consider when a valid amount is foundm updating the max when an amount can be satisfied using integer division.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n log(m)), where m = sum(candies), the number of candies we can distribute, and n is the length of candies. \\n\\n- Space complexity:\\nO(1), we are only storing integer variables.\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        if sum(candies) < k:\\n            return 0\\n        res = 0\\n        def can(amt, kids):\\n            for val in candies:\\n                if val >= amt:\\n                    kids -= (val // amt)\\n                    if kids <= 0:\\n                        return True\\n            return kids <= 0\\n        l, r = 1, sum(candies)\\n        while l <= r:\\n            m = (l + r) // 2\\n            if can(m, k):\\n                res = m\\n                l = m + 1\\n            else:\\n                r = m - 1\\n        return res\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        if sum(candies) < k:\\n            return 0\\n        res = 0\\n        def can(amt, kids):\\n            for val in candies:\\n                if val >= amt:\\n                    kids -= (val // amt)\\n                    if kids <= 0:\\n                        return True\\n            return kids <= 0\\n        l, r = 1, sum(candies)\\n        while l <= r:\\n            m = (l + r) // 2\\n            if can(m, k):\\n                res = m\\n                l = m + 1\\n            else:\\n                r = m - 1\\n        return res\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821954,
                "title": "o-nlogn-solution-c-java-solution",
                "content": "\\n# Code\\n**Java**\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int n=candies.length;\\n        int l=1,r=Integer.MIN_VALUE;\\n        for(int i=0;i<n;i++) r=Math.max(r,candies[i]);\\n        // System.out.println(r);\\n        int ans=0;\\n        while(l<=r){\\n            int mid=l+(r-l)/2;\\n            if(bs(candies,mid,k)){\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else r=mid-1;\\n        }\\n        return ans;\\n    }\\n    public boolean bs(int[] candies, int candy,long k){\\n        long total=0;\\n        for(int c:candies){\\n            total+=(c/candy);\\n        }\\n        return k<=total;\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(std::vector<int>& candies, long long k) {\\n        int n = candies.size();\\n        int l = 1, r = INT_MIN;\\n        for (int i = 0; i < n; i++) {\\n            r = std::max(r, candies[i]);\\n        }\\n\\n        int ans = 0;\\n        while (l <= r) {\\n            int mid = l + (r - l) / 2;\\n            if (bs(candies, mid, k)) {\\n                ans = mid;\\n                l = mid + 1;\\n            } else {\\n                r = mid - 1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    bool bs(std::vector<int>& candies, int candy, long long k) {\\n        long long total = 0;\\n        for (int c : candies) {\\n            total += (c / candy);\\n        }\\n        return k <= total;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int n=candies.length;\\n        int l=1,r=Integer.MIN_VALUE;\\n        for(int i=0;i<n;i++) r=Math.max(r,candies[i]);\\n        // System.out.println(r);\\n        int ans=0;\\n        while(l<=r){\\n            int mid=l+(r-l)/2;\\n            if(bs(candies,mid,k)){\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else r=mid-1;\\n        }\\n        return ans;\\n    }\\n    public boolean bs(int[] candies, int candy,long k){\\n        long total=0;\\n        for(int c:candies){\\n            total+=(c/candy);\\n        }\\n        return k<=total;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(std::vector<int>& candies, long long k) {\\n        int n = candies.size();\\n        int l = 1, r = INT_MIN;\\n        for (int i = 0; i < n; i++) {\\n            r = std::max(r, candies[i]);\\n        }\\n\\n        int ans = 0;\\n        while (l <= r) {\\n            int mid = l + (r - l) / 2;\\n            if (bs(candies, mid, k)) {\\n                ans = mid;\\n                l = mid + 1;\\n            } else {\\n                r = mid - 1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    bool bs(std::vector<int>& candies, int candy, long long k) {\\n        long long total = 0;\\n        for (int c : candies) {\\n            total += (c / candy);\\n        }\\n        return k <= total;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3820911,
                "title": "java-general-approach-to-handle-these-king-of-question-binary-search",
                "content": "\\tIn This question we know that we will have at least 1 candy in pile and maximum it can 10^7 and each pile can be divded  and we have to find our answer in that range \\n\\t\\n\\tNow there can be cases such that 1 pile is so big that it itself generate the answer from itself and here we check it through our valid \"MOSTLY THIS PART CHANGES IN THIS TYPE OF QUESTION\" .\\n\\tand there is simpy shifting left pointer to maximize the result ; \\n\\t\\n\\t\\n```\\nclass Solution {\\n    boolean valid(int[] arr, long k , int mid ){\\n        long piles = 0; \\n        for(int i = 0 ; i< arr.length ; ++i){\\n            piles += arr[i]/mid;\\n            if(piles >= k) return true;\\n        }\\n        return false;\\n                \\n        \\n    };\\n    public int maximumCandies(int[] candies, long k) {\\n        int l = 1 ,r = 10000000 ; \\n        \\n        int ans = 0; \\n        \\n        while( l <= r ){\\n            int mid = l + (r - l )/2;\\n            \\n            if(valid(candies,k,mid)){\\n                ans = mid; \\n                l = mid + 1; \\n            }\\n            else{\\n                r = mid -1; \\n            }\\n        }\\n        return ans ; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Array",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    boolean valid(int[] arr, long k , int mid ){\\n        long piles = 0; \\n        for(int i = 0 ; i< arr.length ; ++i){\\n            piles += arr[i]/mid;\\n            if(piles >= k) return true;\\n        }\\n        return false;\\n                \\n        \\n    };\\n    public int maximumCandies(int[] candies, long k) {\\n        int l = 1 ,r = 10000000 ; \\n        \\n        int ans = 0; \\n        \\n        while( l <= r ){\\n            int mid = l + (r - l )/2;\\n            \\n            if(valid(candies,k,mid)){\\n                ans = mid; \\n                l = mid + 1; \\n            }\\n            else{\\n                r = mid -1; \\n            }\\n        }\\n        return ans ; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3820402,
                "title": "simple-binary-search",
                "content": "# Intuition\\ncheck how much we can give\\n\\n# Approach\\nBinary Search\\n\\n# Complexity**Bold**\\n- Time complexity:\\nnlog(1e7)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& candies, long long k,long long mid)\\n    {\\n        long long t=0;\\n        int n=candies.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            t+=(long long)candies[i]/mid;\\n        }\\n        return t>=k;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long low=1,high=1e7;\\n        long long ans=0;\\n        while(low<=high)\\n        {\\n            long long mid=(low+high)/2;\\n            if(check(candies,k,mid))\\n            {\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else high=mid-1;\\n        }\\n        return int(ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& candies, long long k,long long mid)\\n    {\\n        long long t=0;\\n        int n=candies.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            t+=(long long)candies[i]/mid;\\n        }\\n        return t>=k;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long low=1,high=1e7;\\n        long long ans=0;\\n        while(low<=high)\\n        {\\n            long long mid=(low+high)/2;\\n            if(check(candies,k,mid))\\n            {\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else high=mid-1;\\n        }\\n        return int(ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819137,
                "title": "easy-c-solution",
                "content": "class Solution {\\npublic:\\n    \\n    bool check(vector<int> &candies, long long k, int mid){\\n        long long numofPiles = 0;\\n        for(int it:candies){\\n            numofPiles += it/mid;\\n        }\\n        return numofPiles >= k;\\n    }\\n    int maximumCandies(vector<int> &candies, long long k) {\\n        int l=1, r=1e7, ans = 0;\\n        while(l<=r){\\n            int mid = (l+r)/2;\\n            if(check(candies, k, mid) == true){\\n                ans = mid;\\n                l = mid+1;\\n            }\\n            else{\\n                r = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    bool check(vector<int> &candies, long long k, int mid){\\n        long long numofPiles = 0;\\n        for(int it:candies){\\n            numofPiles += it/mid;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3810289,
                "title": "similar-to-book-allocations",
                "content": "# Intuition\\nWe have to find how much we can divide so that it is distributed equally.\\n**Naive**\\n- we can start looking form 1 to infinity and once it fails we know previous one is the correct distribution eg:- the max distribution we can do.\\nNow we can optimize it for binary search\\n\\n\\n\\n\\n# Approach\\n**Binary search**\\n- we can find the range how can we distribute as in question (there can be piles that will be unused) therefore as we dont have to include every pile then **MAX pile is the upper bound**\\n- Lower bound will be 1 as we can distribute 1 to each kid\\n\\nSo as we are looking for MAX ,where distribution is doable then we have to look into the right half (upper bound) and vice versa.\\n\\n# Complexity\\n- Time complexity:\\nO(log(max-1+1).N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        long low=1,high= getMaxPile(candies);\\n\\n        while(low<=high)\\n        {\\n            long mid=low+(high-low)/2;\\n\\n            if(canDivide(candies,k,mid))\\n            {\\n                low=mid+1;      \\n            }\\n            else\\n            {\\n                high=mid-1;\\n            }\\n        }\\n        return (int)high;\\n    }\\n\\n    public boolean canDivide(int[] candies, long k, long amount)\\n    {\\n        long count=0;\\n\\n        for(int candy : candies)\\n        {\\n            count+=(candy/amount);\\n        } \\n      //  System.out.println((k<=amount));\\n        return count>=k;  \\n    }\\n\\n    public long getMaxPile(int[] candies)\\n    {\\n        long max=candies[0];\\n\\n        for(int candy : candies)\\n        {\\n            if(candy>max)\\n            {\\n                max=candy;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        long low=1,high= getMaxPile(candies);\\n\\n        while(low<=high)\\n        {\\n            long mid=low+(high-low)/2;\\n\\n            if(canDivide(candies,k,mid))\\n            {\\n                low=mid+1;      \\n            }\\n            else\\n            {\\n                high=mid-1;\\n            }\\n        }\\n        return (int)high;\\n    }\\n\\n    public boolean canDivide(int[] candies, long k, long amount)\\n    {\\n        long count=0;\\n\\n        for(int candy : candies)\\n        {\\n            count+=(candy/amount);\\n        } \\n      //  System.out.println((k<=amount));\\n        return count>=k;  \\n    }\\n\\n    public long getMaxPile(int[] candies)\\n    {\\n        long max=candies[0];\\n\\n        for(int candy : candies)\\n        {\\n            if(candy>max)\\n            {\\n                max=candy;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3807049,
                "title": "bs",
                "content": "**time: `O(KlogN)`; space: `O(1)`**\\n```\\nint maximumCandies(vector<int>& c, long long K)\\n{\\n\\tint l{}, h{10000001};\\n\\tfor( ; l+1<h; )\\n\\t{\\n\\t\\tint m = (l+h)/2;\\n\\t\\t(accumulate(begin(c), end(c), 0ll, [&](auto s, auto & c){ return s+1ll*c/m; })>=K ? l : h) = m;\\n\\t}\\n\\treturn l;\\n}\\n```\\n**Similar problems:**\\n[875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/discuss/2053517/bs?currentPage=1&orderBy=most_relevant&query=android)\\n[1891. Cutting Ribbons](https://leetcode.com/problems/cutting-ribbons/discuss/2963593/bs)\\n[2064. Minimized Maximum of Products Distributed to Any Store](https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/discuss/2127417/binary-search)\\n[1760. Minimum Limit of Balls in a Bag](https://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/discuss/1676227/binary-search)\\n[1300. Sum of Mutated Array Closest to Target](https://leetcode.com/problems/sum-of-mutated-array-closest-to-target/discuss/2969866/bs)\\n[1552. Magnetic Force Between Two Balls](https://leetcode.com/problems/magnetic-force-between-two-balls/discuss/3251398/ok)\\n[2517. Maximum Tastiness of Candy Basket](https://leetcode.com/problems/maximum-tastiness-of-candy-basket/discuss/3251393/ok)\\n[1482. Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/discuss/3253585/bs)\\n[1231. Divide Chocolate](https://leetcode.com/problems/divide-chocolate/discuss/3254564/bs)\\n[2226. Maximum Candies Allocated to K Children](https://leetcode.com/problems/maximum-candies-allocated-to-k-children/discuss/3807049/bs)\\n[2187. Minimum Time to Complete Trips](https://leetcode.com/problems/minimum-time-to-complete-trips/discuss/3808940/bs)\\n[2594. Minimum Time to Repair Cars](https://leetcode.com/problems/minimum-time-to-repair-cars/discuss/3945204/range-bs)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint maximumCandies(vector<int>& c, long long K)\\n{\\n\\tint l{}, h{10000001};\\n\\tfor( ; l+1<h; )\\n\\t{\\n\\t\\tint m = (l+h)/2;\\n\\t\\t(accumulate(begin(c), end(c), 0ll, [&](auto s, auto & c){ return s+1ll*c/m; })>=K ? l : h) = m;\\n\\t}\\n\\treturn l;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3805686,
                "title": "python-bs",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        \\n        def ispossible(n):\\n            if n==0:\\n                return True\\n            count = 0\\n            for e in candies:\\n                if e < n:\\n                    continue\\n                elif e == n:\\n                    count+=1\\n                else:\\n                    count+=e//n\\n            return count >= k\\n\\n        l = 0\\n        u = 10000000\\n        while l<=u:\\n            mid = (l+u)//2\\n            if ispossible(mid):\\n                l = mid+1\\n            else:\\n                u = mid-1\\n\\n        return l-1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        \\n        def ispossible(n):\\n            if n==0:\\n                return True\\n            count = 0\\n            for e in candies:\\n                if e < n:\\n                    continue\\n                elif e == n:\\n                    count+=1\\n                else:\\n                    count+=e//n\\n            return count >= k\\n\\n        l = 0\\n        u = 10000000\\n        while l<=u:\\n            mid = (l+u)//2\\n            if ispossible(mid):\\n                l = mid+1\\n            else:\\n                u = mid-1\\n\\n        return l-1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797209,
                "title": "easy-c-solution-using-bs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& A, long long k) {\\n        int left = 0, right = * max_element ( A.begin() , A.end());\\n        while (left < right) {\\n            long sum = 0, mid = (left + right + 1) / 2;\\n            for (int& a : A) {\\n                sum += a / mid;\\n            }\\n            if (k > sum)\\n                right = mid - 1;\\n            else\\n                left = mid;\\n        }\\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& A, long long k) {\\n        int left = 0, right = * max_element ( A.begin() , A.end());\\n        while (left < right) {\\n            long sum = 0, mid = (left + right + 1) / 2;\\n            for (int& a : A) {\\n                sum += a / mid;\\n            }\\n            if (k > sum)\\n                right = mid - 1;\\n            else\\n                left = mid;\\n        }\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3759528,
                "title": "easy-to-understand-clean-code-commented-binary-search-in-the-possible-answer",
                "content": "# Approach\\nLet\\'s say you can give maximum `X` candies. How do you find if it\\'s true or not?\\nTry to spit the piles keeping at least `X` candies on that and calculate how many piles you can build. If the number of piles is greater than number of kids then answer is true otherwise false.\\n\\nNow try to find a suitable `X` using binary search.\\n\\n# Complexity\\n- Time complexity:\\n`O(n log N)`\\n\\n- Space complexity:\\n`O(1)` - No extra space\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long min_possible = 1;\\n        long long max_possible = *max_element(candies.begin(), candies.end());\\n        long long ans = 0;\\n\\n        // Find the number of pile you can build keeping at least\\n        // `value` candies in it */\\n        auto check = [&] (int value) {\\n            long long piles = 0;\\n            for (const auto &candy : candies) {\\n                piles += (candy / value);\\n            }\\n\\n            return piles >= k;\\n        };\\n\\n        // find a suitalbe answer using binary search\\n        while (min_possible <= max_possible) {\\n            long long trial = (min_possible + max_possible) / 2;\\n            if (check(trial)) {\\n                ans = max(ans, trial);\\n                min_possible = trial + 1;\\n            } else {\\n                max_possible = trial - 1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long min_possible = 1;\\n        long long max_possible = *max_element(candies.begin(), candies.end());\\n        long long ans = 0;\\n\\n        // Find the number of pile you can build keeping at least\\n        // `value` candies in it */\\n        auto check = [&] (int value) {\\n            long long piles = 0;\\n            for (const auto &candy : candies) {\\n                piles += (candy / value);\\n            }\\n\\n            return piles >= k;\\n        };\\n\\n        // find a suitalbe answer using binary search\\n        while (min_possible <= max_possible) {\\n            long long trial = (min_possible + max_possible) / 2;\\n            if (check(trial)) {\\n                ans = max(ans, trial);\\n                min_possible = trial + 1;\\n            } else {\\n                max_possible = trial - 1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3759367,
                "title": "maximum-candies-allocated-to-k-children",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCandies(self, a: List[int], k: int) -> int:\\n        ##Method 1\\n        def chq(a,v,k):\\n            c=0\\n            for i in a:\\n                c+=i//v\\n            return c>=k\\n            mx=float(\"-inf\")\\n        ans=0\\n        l=1\\n        h=max(a)\\n        while l<=h:\\n            m=(l+h)//2\\n            if chq(a,m,k):\\n                ans=m\\n                l=m+1\\n            else:\\n                h=m-1\\n        return(ans)\\n        ### Method 2 (Brute Force)\\n            # d={}\\n            # for i in range(len(a)):\\n            #     n=a[i]\\n            #     if n<v:\\n            #         if n in d:\\n            #             d[n]+=1\\n            #         else:\\n            #             d[n]=1\\n            #         continue\\n            #     while n:\\n            #         if n==0:\\n            #             break\\n            #         elif n<v:\\n            #             if n not in d:\\n            #                 d[n]=1\\n            #             else:\\n            #                 d[n]+=1\\n            #             break\\n            #         else:\\n            #             if v not in d:\\n            #                 d[v]=1\\n            #             else:\\n            #                 d[v]+=1\\n            #             n-=v\\n            # mx=float(\"-inf\")\\n            # for i in d:\\n            #     if d[i]>=k:\\n            #         mx=max(mx,i)\\n            # return mx\\n        # print(chq(a,8,k))\\n        \\n        # for i in range(1,max(a)+1):\\n        #     if chq(a,i,k)!=float(\"-inf\"):\\n        #         mx=max(mx,i)\\n        # if mx==float(\"-inf\"):return 0\\n        # return mx\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCandies(self, a: List[int], k: int) -> int:\\n        ##Method 1\\n        def chq(a,v,k):\\n            c=0\\n            for i in a:\\n                c+=i//v\\n            return c>=k\\n            mx=float(\"-inf\")\\n        ans=0\\n        l=1\\n        h=max(a)\\n        while l<=h:\\n            m=(l+h)//2\\n            if chq(a,m,k):\\n                ans=m\\n                l=m+1\\n            else:\\n                h=m-1\\n        return(ans)\\n        ### Method 2 (Brute Force)\\n            # d={}\\n            # for i in range(len(a)):\\n            #     n=a[i]\\n            #     if n<v:\\n            #         if n in d:\\n            #             d[n]+=1\\n            #         else:\\n            #             d[n]=1\\n            #         continue\\n            #     while n:\\n            #         if n==0:\\n            #             break\\n            #         elif n<v:\\n            #             if n not in d:\\n            #                 d[n]=1\\n            #             else:\\n            #                 d[n]+=1\\n            #             break\\n            #         else:\\n            #             if v not in d:\\n            #                 d[v]=1\\n            #             else:\\n            #                 d[v]+=1\\n            #             n-=v\\n            # mx=float(\"-inf\")\\n            # for i in d:\\n            #     if d[i]>=k:\\n            #         mx=max(mx,i)\\n            # return mx\\n        # print(chq(a,8,k))\\n        \\n        # for i in range(1,max(a)+1):\\n        #     if chq(a,i,k)!=float(\"-inf\"):\\n        #         mx=max(mx,i)\\n        # if mx==float(\"-inf\"):return 0\\n        # return mx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3757149,
                "title": "binary-search-with-intuition",
                "content": "# Code\\n```\\nclass Solution {\\n    // Intuition: Doing binary search as possible range of ans is available\\n    // TC: O(logr * candies.length)\\n    // SC: O(1)\\n    public int maximumCandies(int[] candies, long totalChildren) {\\n        long l = 1;\\n        long r = candies[0];\\n        for(int c:candies){\\n            r+=c;\\n        }\\n        if(r<totalChildren){\\n            return 0;\\n        }\\n        long ans = 0;\\n        long mid = 0;\\n        // TC: O(logr)\\n        while(l<=r){\\n            mid = (l+r)/2;\\n            // TC: O(candies.length)\\n            if(canDistributeEqually(candies,totalChildren,mid)){\\n                ans = mid;\\n                l = mid+1;\\n            }else{\\n                r = mid-1;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n\\n    private boolean canDistributeEqually(int[] candies, long totalChildren, long eachMustHave){\\n        long count = 0;\\n        for(int c:candies){\\n            count+= c/eachMustHave;\\n        }\\n        return count>=totalChildren;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    // Intuition: Doing binary search as possible range of ans is available\\n    // TC: O(logr * candies.length)\\n    // SC: O(1)\\n    public int maximumCandies(int[] candies, long totalChildren) {\\n        long l = 1;\\n        long r = candies[0];\\n        for(int c:candies){\\n            r+=c;\\n        }\\n        if(r<totalChildren){\\n            return 0;\\n        }\\n        long ans = 0;\\n        long mid = 0;\\n        // TC: O(logr)\\n        while(l<=r){\\n            mid = (l+r)/2;\\n            // TC: O(candies.length)\\n            if(canDistributeEqually(candies,totalChildren,mid)){\\n                ans = mid;\\n                l = mid+1;\\n            }else{\\n                r = mid-1;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n\\n    private boolean canDistributeEqually(int[] candies, long totalChildren, long eachMustHave){\\n        long count = 0;\\n        for(int c:candies){\\n            count+= c/eachMustHave;\\n        }\\n        return count>=totalChildren;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710929,
                "title": "easy-to-understand-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe first notice that the maximum amount of candies in a pile can range from 0 to the max of candies, max(candies). We binary search over this range, utilizing a helper function to check if the chosen number for every pile is okay to allocate with. If we are successful in choosing the number for the maximum of this pile, we can find the max of this key value with our previous maximum. If we are not successful, then we decrease the size of our pile and binary search to the left. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        candies.sort()\\n        \\n        maximumNumCandies = 0\\n        \\n        #each child can take at most one pile of candies (some may go unused)\\n        #allocate piles of candies to k children such that each child gets the same number of candies\\n\\n        def canAllocatePiles(value):\\n            if value == 0:\\n                return True\\n            allocatedPiles = 0\\n            for pile in candies:\\n                allocatedPiles += (pile // value)\\n            return allocatedPiles >= k\\n\\n\\n        #the lower bound of candies a child can receive is 0. an upper bound is max(candies)\\n        lower, upper = 0, max(candies)\\n        #binary search through\\n        \\n        while lower <= upper:\\n            middle = (lower + upper) // 2\\n            \\n            if canAllocatePiles(middle):\\n                maximumNumCandies = max(maximumNumCandies, middle)\\n                lower = middle + 1\\n            else:\\n                upper = middle - 1\\n        \\n\\n        return maximumNumCandies\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        candies.sort()\\n        \\n        maximumNumCandies = 0\\n        \\n        #each child can take at most one pile of candies (some may go unused)\\n        #allocate piles of candies to k children such that each child gets the same number of candies\\n\\n        def canAllocatePiles(value):\\n            if value == 0:\\n                return True\\n            allocatedPiles = 0\\n            for pile in candies:\\n                allocatedPiles += (pile // value)\\n            return allocatedPiles >= k\\n\\n\\n        #the lower bound of candies a child can receive is 0. an upper bound is max(candies)\\n        lower, upper = 0, max(candies)\\n        #binary search through\\n        \\n        while lower <= upper:\\n            middle = (lower + upper) // 2\\n            \\n            if canAllocatePiles(middle):\\n                maximumNumCandies = max(maximumNumCandies, middle)\\n                lower = middle + 1\\n            else:\\n                upper = middle - 1\\n        \\n\\n        return maximumNumCandies\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3704735,
                "title": "c-easy-solution-striver-approach-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& candies, int mid, long long k){\\n        long long cntOfsplit = 0;\\n        for(int i = 0; i < candies.size(); i++){\\n            cntOfsplit += candies[i]/mid;\\n        }\\n        return cntOfsplit >= k;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int low = 1;\\n        int high = *max_element(candies.begin(), candies.end());\\n        while(low <= high){\\n            int mid = low+ (high- low)/2;\\n            if(isPossible(candies, mid, k)){\\n                low = mid + 1;\\n            }\\n            else{\\n                high = mid - 1;\\n            }\\n        }\\n        return high;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& candies, int mid, long long k){\\n        long long cntOfsplit = 0;\\n        for(int i = 0; i < candies.size(); i++){\\n            cntOfsplit += candies[i]/mid;\\n        }\\n        return cntOfsplit >= k;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int low = 1;\\n        int high = *max_element(candies.begin(), candies.end());\\n        while(low <= high){\\n            int mid = low+ (high- low)/2;\\n            if(isPossible(candies, mid, k)){\\n                low = mid + 1;\\n            }\\n            else{\\n                high = mid - 1;\\n            }\\n        }\\n        return high;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703155,
                "title": "binary-search-intuition-explained-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nClearly answer will be in between 0 and the max element of the vector.\\nWhen k is too high, answer have to b 0\\nWhen k is very low, (e.g. = 1) answer have to be maximum element\\n\\nSo Binary Search\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimply apply Binary search from with  l =0 and h = max_element. And for every mid element we will calculate in how many kids we can distribue the canides or subpiles. For that we just have to do $candies[i]/mid$. SO,,,,,,,,\\n\\n# Edge Case\\nJust keep in mind that we have low as 0. And when we will divide by mid, in cases mid can be 0 too. So, make a seprate case of that.\\n\\n# Complexity\\n- Time complexity:$O(nlogm)$ \\n- $n$ = Length of candies vector\\n- $m$ = max element of vector\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$O(1)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) \\n    {\\n        int i =0;\\n        long long j = *max_element(candies.begin(),candies.end());\\n        int ans=0;\\n        while(i<=j)\\n        {\\n            long long mid = i + (j-i)/2;\\n            long long temp=0;\\n            if(mid==0) temp=k;\\n            else\\n            {\\n                for(int a=0;a<candies.size();a++)\\n                {\\n                    temp = temp + floor((double)candies[a]/(double)mid);\\n                }\\n            }   \\n            if(temp>=k)\\n            {\\n                ans=mid;\\n                i=mid+1;\\n            }\\n            else\\n            {\\n                j=mid-1;\\n            }\\n        }    \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) \\n    {\\n        int i =0;\\n        long long j = *max_element(candies.begin(),candies.end());\\n        int ans=0;\\n        while(i<=j)\\n        {\\n            long long mid = i + (j-i)/2;\\n            long long temp=0;\\n            if(mid==0) temp=k;\\n            else\\n            {\\n                for(int a=0;a<candies.size();a++)\\n                {\\n                    temp = temp + floor((double)candies[a]/(double)mid);\\n                }\\n            }   \\n            if(temp>=k)\\n            {\\n                ans=mid;\\n                i=mid+1;\\n            }\\n            else\\n            {\\n                j=mid-1;\\n            }\\n        }    \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683524,
                "title": "swift-binary-search-solution-space",
                "content": "# Intuition\\n Define a solution space to perform a binary search to find the max # of candies per pile\\n \\n # Approach\\n Define a solution space of possible values.\\n The minimum pile count has to be 1 since a pile cannot contain 0 candies.\\n The maximum pile count is `max(candies)` since piles cannot be merged.\\n Use a binary search to find the max pile count that satisfies `checkPiles`.\\n \\n # Complexity\\n - Time complexity:\\n O(n log n) where `n` is `candies.count`.\\n O(n)(find max) * O(log n)(binary search) * O(n)(checkPiles)\\n \\n - Space complexity:\\n O(1) only a few integers are stored.\\n \\n This problem is similar to to [875. Koko eating bananas](https://leetcode.com/problems/koko-eating-bananas/)\\n\\n```\\nclass Solution {\\n\\n    func checkPiles(_ candies: [Int], _ k: Int, _ size: Int) -> Bool {\\n        var piles = 0\\n        for c in candies {\\n            piles += c / size\\n        }\\n\\n        return piles >= k\\n    }\\n\\n    func maximumCandies(_ candies: [Int], _ k: Int) -> Int {\\n        // Define the solution space\\n        var l = 1, r = Int.min, sum = 0 \\n        for c in candies {\\n            r = max(r, c)\\n            sum += c\\n        }\\n\\n        // The sum of all the piles has to be at least greater than the number of kids.\\n        guard sum >= k else { return 0 }\\n\\n        while l <= r {\\n            let mid = (l + r) / 2\\n            if checkPiles(candies, k, mid) {\\n                // Max number of candies satisfies the condition.\\n                // Try a bigger pile.\\n                l = mid + 1\\n            } else {\\n                // Num of candies per pile did not satisfy the condition.\\n                // Try a smaller pile.\\n                r = mid - 1\\n            }\\n        }\\n\\n        return r\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n\\n    func checkPiles(_ candies: [Int], _ k: Int, _ size: Int) -> Bool {\\n        var piles = 0\\n        for c in candies {\\n            piles += c / size\\n        }\\n\\n        return piles >= k\\n    }\\n\\n    func maximumCandies(_ candies: [Int], _ k: Int) -> Int {\\n        // Define the solution space\\n        var l = 1, r = Int.min, sum = 0 \\n        for c in candies {\\n            r = max(r, c)\\n            sum += c\\n        }\\n\\n        // The sum of all the piles has to be at least greater than the number of kids.\\n        guard sum >= k else { return 0 }\\n\\n        while l <= r {\\n            let mid = (l + r) / 2\\n            if checkPiles(candies, k, mid) {\\n                // Max number of candies satisfies the condition.\\n                // Try a bigger pile.\\n                l = mid + 1\\n            } else {\\n                // Num of candies per pile did not satisfy the condition.\\n                // Try a smaller pile.\\n                r = mid - 1\\n            }\\n        }\\n\\n        return r\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3639923,
                "title": "java-solution-binary-search-implementation",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int max = Integer.MIN_VALUE;\\n        long sum = 0;\\n        for(int p : candies){\\n            sum += p;\\n            max = Math.max(p, max);\\n        }\\n\\n        if(sum < k){\\n            return 0;\\n        }\\n        int lo = 1;\\n        int hi = max;\\n        int ans = -1;\\n        while(lo <= hi){\\n            long value = 0;\\n            int mid = lo + (hi - lo)/2;\\n            for(int i = 0;i<candies.length;i++){\\n                value += (candies[i]/mid);\\n            }\\n            if(value < k){\\n                \\n                hi = mid - 1;\\n            }\\n            else{\\n                ans = mid;\\n                lo = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int max = Integer.MIN_VALUE;\\n        long sum = 0;\\n        for(int p : candies){\\n            sum += p;\\n            max = Math.max(p, max);\\n        }\\n\\n        if(sum < k){\\n            return 0;\\n        }\\n        int lo = 1;\\n        int hi = max;\\n        int ans = -1;\\n        while(lo <= hi){\\n            long value = 0;\\n            int mid = lo + (hi - lo)/2;\\n            for(int i = 0;i<candies.length;i++){\\n                value += (candies[i]/mid);\\n            }\\n            if(value < k){\\n                \\n                hi = mid - 1;\\n            }\\n            else{\\n                ans = mid;\\n                lo = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630709,
                "title": "java-beats-92-very-easy-solution",
                "content": "# Complexity\\n- Time complexity: O(nlog(k))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int start=1,end=Integer.MIN_VALUE,ansv=0;\\n        for(int i:candies){\\n            end=Math.max(end,i);\\n        }\\n        while(start<=end){\\n            long sum=0;\\n            int mid=start+((end-start)>>1);\\n            for(int i:candies){\\n                sum+=i/mid;\\n            }\\n            if(sum>=k){\\n                    ansv=mid;\\n                    start=mid+1;\\n            }\\n            else\\n            end=mid-1;\\n        }\\n        return ansv;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int start=1,end=Integer.MIN_VALUE,ansv=0;\\n        for(int i:candies){\\n            end=Math.max(end,i);\\n        }\\n        while(start<=end){\\n            long sum=0;\\n            int mid=start+((end-start)>>1);\\n            for(int i:candies){\\n                sum+=i/mid;\\n            }\\n            if(sum>=k){\\n                    ansv=mid;\\n                    start=mid+1;\\n            }\\n            else\\n            end=mid-1;\\n        }\\n        return ansv;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3612438,
                "title": "c-easy-to-understand-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool flag(vector<int>&v,long long int mid,int n,long long int k){\\n    long long int kk=0;\\n    for(int i=0;i<n;i++){\\n        kk=kk+(v[i]/mid);\\n        if(kk>=k)return 1;\\n    }\\n    \\n    return 0;\\n\\n}\\n    int maximumCandies(vector<int>&candies, long long k) {\\n        int n=candies.size();\\n       long long int b=0;\\n       long long int a=1;\\n       int mx=0;\\n       for(int i=0;i<n;i++){\\n           mx=max(mx,candies[i]);\\n       }\\n       long long int ans=0;\\n       b=mx;\\n       while(a<=b){\\n           long long int mid=a+(b-a)/2;\\n           if(flag(candies,mid,n,k)){\\n               ans=mid;\\n               a=mid+1;\\n           }\\n           else{\\n               b=mid-1;\\n           }\\n\\n       }\\n       return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool flag(vector<int>&v,long long int mid,int n,long long int k){\\n    long long int kk=0;\\n    for(int i=0;i<n;i++){\\n        kk=kk+(v[i]/mid);\\n        if(kk>=k)return 1;\\n    }\\n    \\n    return 0;\\n\\n}\\n    int maximumCandies(vector<int>&candies, long long k) {\\n        int n=candies.size();\\n       long long int b=0;\\n       long long int a=1;\\n       int mx=0;\\n       for(int i=0;i<n;i++){\\n           mx=max(mx,candies[i]);\\n       }\\n       long long int ans=0;\\n       b=mx;\\n       while(a<=b){\\n           long long int mid=a+(b-a)/2;\\n           if(flag(candies,mid,n,k)){\\n               ans=mid;\\n               a=mid+1;\\n           }\\n           else{\\n               b=mid-1;\\n           }\\n\\n       }\\n       return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3611752,
                "title": "detailed-explanation-intuition-ranged-binary-search-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- We a given search space in which our answer occurs minimum answer can be 1  maximum answer can be maximum of array.\\n- Suppose a number 5 satisfies so all numbers less than 5 will also satisfy the problem we have to search for elements greater than 5, same is the case if 5 doesnot satisfy we have to search answers less then 5.\\n- All this indicate the use of **Binary Search**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Apply Binary Search\\n- If any element satisfy update the answer.\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        \\n        long l=1L,h=(long)-1e8,ans=0L;\\n        for(int i:candies)\\n            h = Math.max(h,i);\\n\\n        while(l<=h){\\n            long m = (h-l)/2+l;\\n            if(isPossible(candies,k,m)){\\n                ans = m;\\n                l=m+1;\\n            }else{\\n                h=m-1;\\n            }\\n        }\\n\\n        return (int)ans;\\n\\n        \\n    }\\n\\n    public boolean isPossible(int[] candies, long k,long m){\\n\\n        long c = 0L;\\n        for(int i:candies){\\n            if(i<m)\\n                continue;\\n\\n            c += (long)i/m;\\n            if(c>=k)\\n                return true;\\n        }\\n\\n        return c>=k;\\n\\n    }\\n}\\n```\\n\\n\\n**IF YOU LIKE IT PLS UPVOTE**\\n\\n\\n- thanks\\n",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        \\n        long l=1L,h=(long)-1e8,ans=0L;\\n        for(int i:candies)\\n            h = Math.max(h,i);\\n\\n        while(l<=h){\\n            long m = (h-l)/2+l;\\n            if(isPossible(candies,k,m)){\\n                ans = m;\\n                l=m+1;\\n            }else{\\n                h=m-1;\\n            }\\n        }\\n\\n        return (int)ans;\\n\\n        \\n    }\\n\\n    public boolean isPossible(int[] candies, long k,long m){\\n\\n        long c = 0L;\\n        for(int i:candies){\\n            if(i<m)\\n                continue;\\n\\n            c += (long)i/m;\\n            if(c>=k)\\n                return true;\\n        }\\n\\n        return c>=k;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3610302,
                "title": "easy-c-sol",
                "content": "# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        ll n=candies.size();\\n        ll sum=0;\\n        for(auto i:candies)sum+=i;\\n        if(sum<k)return 0;\\n        ll low=1;\\n        ll high=sum;\\n        ll ans=1;\\n        while(low<=high){\\n            ll mid=(low+high)/2;\\n            ll temp=0;\\n            for(int i=0;i<n;i++){\\n                temp+=floor(candies[i]*1.0/mid);\\n            }\\n            if(temp>=k){\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        ll n=candies.size();\\n        ll sum=0;\\n        for(auto i:candies)sum+=i;\\n        if(sum<k)return 0;\\n        ll low=1;\\n        ll high=sum;\\n        ll ans=1;\\n        while(low<=high){\\n            ll mid=(low+high)/2;\\n            ll temp=0;\\n            for(int i=0;i<n;i++){\\n                temp+=floor(candies[i]*1.0/mid);\\n            }\\n            if(temp>=k){\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581078,
                "title": "candies-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long int\\nclass Solution {\\npublic:\\n\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        ll n= candies.size();\\n        ll lo=1,hi=1e15,ans=0;\\n        while(lo<=hi){\\n            ll mid= (lo+hi)/2;\\n            ll totalkitnipilesbnsktihjismecandiesho=0;\\n            for(auto itr:candies){\\n                totalkitnipilesbnsktihjismecandiesho+=(itr/mid);\\n            }\\n            if(totalkitnipilesbnsktihjismecandiesho>=k){\\n                ans=mid;\\n                lo=mid+1;\\n            }\\n            else{\\n                hi=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        ll n= candies.size();\\n        ll lo=1,hi=1e15,ans=0;\\n        while(lo<=hi){\\n            ll mid= (lo+hi)/2;\\n            ll totalkitnipilesbnsktihjismecandiesho=0;\\n            for(auto itr:candies){\\n                totalkitnipilesbnsktihjismecandiesho+=(itr/mid);\\n            }\\n            if(totalkitnipilesbnsktihjismecandiesho>=k){\\n                ans=mid;\\n                lo=mid+1;\\n            }\\n            else{\\n                hi=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581042,
                "title": "java-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        long lo = 1, hi = Integer.MAX_VALUE;\\n        long ans=0;\\n        while(lo <= hi){\\n            long mid = (lo+hi)/2;\\n            long maxCandies=0;\\n            for(int i:candies){\\n                maxCandies += i/mid;\\n            }\\n            if(maxCandies >= k){\\n                ans = mid;\\n                lo = mid+1;\\n            } else{\\n                hi = mid-1;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        long lo = 1, hi = Integer.MAX_VALUE;\\n        long ans=0;\\n        while(lo <= hi){\\n            long mid = (lo+hi)/2;\\n            long maxCandies=0;\\n            for(int i:candies){\\n                maxCandies += i/mid;\\n            }\\n            if(maxCandies >= k){\\n                ans = mid;\\n                lo = mid+1;\\n            } else{\\n                hi = mid-1;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568094,
                "title": "possible-and-impossible-bound",
                "content": "# Approach\\nLet l be the lower bound of return value and r be the upper bound of lowest impossible value.\\nWhen l and r differ by 1, then l is what we want.\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int: \\n        l = 0 #True\\n        r = sum(candies) // k + 1 #False\\n\\n        while r - l > 1:\\n            m = (l + r) // 2\\n\\n            if sum(x // m for x in candies) >= k:\\n                l = m\\n            else:\\n                r = m\\n        \\n        return l\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int: \\n        l = 0 #True\\n        r = sum(candies) // k + 1 #False\\n\\n        while r - l > 1:\\n            m = (l + r) // 2\\n\\n            if sum(x // m for x in candies) >= k:\\n                l = m\\n            else:\\n                r = m\\n        \\n        return l\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3567696,
                "title": "easy-approach-to-solve-solution-using-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic: \\n    long long satisfiedchildren(int candiesperperson,vector<int>& candies ){\\n        long long  ans=0;\\n        int n=candies.size();\\n        for(int i=0; i<n; i++){\\n            ans += (candies[i]/candiesperperson);\\n\\n        }\\n        return ans;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int max_ele=INT_MIN;\\n        long long sum=0 , n=candies.size();\\n        for(int i=0; i<n; i++){\\n            max_ele= max(max_ele,candies[i]);\\n            sum+=candies[i];\\n        }\\n        if(sum<k) return 0;\\n\\n        int s=1, e=max_ele;\\n        int ans;\\n        while(s<=e)\\n        {\\n            int candiesperperson = s + (e-s)/2;\\n            long long sc = satisfiedchildren(candiesperperson, candies);\\n            if(sc>=k){\\n                ans=candiesperperson;\\n                s=candiesperperson+1;\\n            }\\n            else{\\n                e=candiesperperson-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    long long satisfiedchildren(int candiesperperson,vector<int>& candies ){\\n        long long  ans=0;\\n        int n=candies.size();\\n        for(int i=0; i<n; i++){\\n            ans += (candies[i]/candiesperperson);\\n\\n        }\\n        return ans;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int max_ele=INT_MIN;\\n        long long sum=0 , n=candies.size();\\n        for(int i=0; i<n; i++){\\n            max_ele= max(max_ele,candies[i]);\\n            sum+=candies[i];\\n        }\\n        if(sum<k) return 0;\\n\\n        int s=1, e=max_ele;\\n        int ans;\\n        while(s<=e)\\n        {\\n            int candiesperperson = s + (e-s)/2;\\n            long long sc = satisfiedchildren(candiesperperson, candies);\\n            if(sc>=k){\\n                ans=candiesperperson;\\n                s=candiesperperson+1;\\n            }\\n            else{\\n                e=candiesperperson-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3517862,
                "title": "rust-solution-using-binary-search",
                "content": "# Code\\n```\\nimpl Solution {\\n  pub fn maximum_candies(candies: Vec<i32>, k: i64) -> i32 {\\n    let k = k as usize;\\n    let mut count = 0;\\n    let candies = candies.into_iter().map(|v| {\\n      count += v as usize;\\n      v as usize\\n    }).collect::<Vec<usize>>();\\n    if count < k {\\n      return 0\\n    }\\n\\n    let mut left = 0;\\n    let mut right = 10usize.pow(15);\\n    while left + 1 < right {\\n      let mid = (left+right)/2;\\n      let mut temp = 0;\\n      for &v in &candies {\\n        temp += v / mid;\\n      }\\n\\n      if temp < k {\\n        right = mid;\\n      } else {\\n        left = mid;\\n      }\\n    }\\n    left as i32\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Binary Search"
                ],
                "code": "```\\nimpl Solution {\\n  pub fn maximum_candies(candies: Vec<i32>, k: i64) -> i32 {\\n    let k = k as usize;\\n    let mut count = 0;\\n    let candies = candies.into_iter().map(|v| {\\n      count += v as usize;\\n      v as usize\\n    }).collect::<Vec<usize>>();\\n    if count < k {\\n      return 0\\n    }\\n\\n    let mut left = 0;\\n    let mut right = 10usize.pow(15);\\n    while left + 1 < right {\\n      let mid = (left+right)/2;\\n      let mut temp = 0;\\n      for &v in &candies {\\n        temp += v / mid;\\n      }\\n\\n      if temp < k {\\n        right = mid;\\n      } else {\\n        left = mid;\\n      }\\n    }\\n    left as i32\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3495761,
                "title": "easy-to-understand-javascript-solution-binary-search",
                "content": "```\\nvar maximumCandies = function(candies, k) {\\n    const sum = candies.reduce((total, candy) => total + candy);\\n    let min = 1;\\n    let max = Math.floor(sum / k) + 1;\\n    const isEnough = (count) => {\\n        const children = candies.reduce((result, candy) => {\\n            return result - Math.floor(candy / count);\\n        }, k);\\n\\n        return children <= 0;\\n    };\\n\\n    while (min < max) {\\n        const mid = Math.floor((min + max) / 2);\\n\\n        isEnough(mid) ? min = mid + 1 : max = mid;\\n    }\\n    return min - 1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maximumCandies = function(candies, k) {\\n    const sum = candies.reduce((total, candy) => total + candy);\\n    let min = 1;\\n    let max = Math.floor(sum / k) + 1;\\n    const isEnough = (count) => {\\n        const children = candies.reduce((result, candy) => {\\n            return result - Math.floor(candy / count);\\n        }, k);\\n\\n        return children <= 0;\\n    };\\n\\n    while (min < max) {\\n        const mid = Math.floor((min + max) / 2);\\n\\n        isEnough(mid) ? min = mid + 1 : max = mid;\\n    }\\n    return min - 1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3462275,
                "title": "python-binary-search-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        ans,low, high = 0,1, max(candies)\\n\\n        while low<=high:\\n            mid=(low+high)//2\\n            i=0\\n            c=0\\n            while i < len(candies):\\n                c+=candies[i]//mid \\n# integer division to to get number of children consuming mid from each pile \\n                i+=1\\n            if c>=k: \\n# if more than k children can consume candies from piles, it is possible that k children can receive more candies instead\\n                ans=mid\\n                low = mid + 1\\n            else:\\n                high = mid-1\\n        return ans\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        ans,low, high = 0,1, max(candies)\\n\\n        while low<=high:\\n            mid=(low+high)//2\\n            i=0\\n            c=0\\n            while i < len(candies):\\n                c+=candies[i]//mid \\n# integer division to to get number of children consuming mid from each pile \\n                i+=1\\n            if c>=k: \\n# if more than k children can consume candies from piles, it is possible that k children can receive more candies instead\\n                ans=mid\\n                low = mid + 1\\n            else:\\n                high = mid-1\\n        return ans\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3387141,
                "title": "java-easy-solution-aasheesh-111th-day",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int start = 0, end = 0 , ans = 0;\\n        for(int can:candies)    end = Math.max(end , can);\\n        \\n        while(start <= end){\\n            int mid = start + (end - start) /2;\\n            boolean flag = check(candies, k , mid);\\n            if(flag)    end = mid - 1;\\n            else{\\n                ans = mid;\\n                start = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private boolean check(int[] candies, long k, int mid) {\\n        if(mid == 0)    return false;\\n        long sum = 0;\\n        for(int can: candies){\\n            int num = can/mid;\\n            sum +=num;\\n        }\\n        if(sum >= k)   return false;\\n        return true;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int start = 0, end = 0 , ans = 0;\\n        for(int can:candies)    end = Math.max(end , can);\\n        \\n        while(start <= end){\\n            int mid = start + (end - start) /2;\\n            boolean flag = check(candies, k , mid);\\n            if(flag)    end = mid - 1;\\n            else{\\n                ans = mid;\\n                start = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private boolean check(int[] candies, long k, int mid) {\\n        if(mid == 0)    return false;\\n        long sum = 0;\\n        for(int can: candies){\\n            int num = can/mid;\\n            sum +=num;\\n        }\\n        if(sum >= k)   return false;\\n        return true;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3385996,
                "title": "simple-c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long total =0;\\n        for(auto x:candies){\\n            total += x;\\n        }\\n\\n        if(total < k ){\\n            return 0;\\n        }\\n\\n        if(total == k){\\n            return 1;\\n        }\\n\\n        long long l = 1, r = total;\\n        long long ans = 0;\\n        while(l <= r){\\n            long long mid = (l+r)/2;\\n            long long piles = 0;\\n            for(auto x:candies){\\n                piles += x / mid;\\n            }\\n\\n            if(piles >= k){\\n                ans = max(ans, mid);\\n                l = mid+1;\\n            }\\n            else{\\n                r = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long total =0;\\n        for(auto x:candies){\\n            total += x;\\n        }\\n\\n        if(total < k ){\\n            return 0;\\n        }\\n\\n        if(total == k){\\n            return 1;\\n        }\\n\\n        long long l = 1, r = total;\\n        long long ans = 0;\\n        while(l <= r){\\n            long long mid = (l+r)/2;\\n            long long piles = 0;\\n            for(auto x:candies){\\n                piles += x / mid;\\n            }\\n\\n            if(piles >= k){\\n                ans = max(ans, mid);\\n                l = mid+1;\\n            }\\n            else{\\n                r = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3384561,
                "title": "easy-to-understand-solution-using-binary-search-in-c",
                "content": "# Approach\\n  => Try to distrubute with large value of chocolates\\n  => Inside binary search, try to see if the chocolates can be distributed among n no. of childrens.\\n  => If it can be distributed then set your  start = mid + 1 and answer = mid value\\n  => Otherwise set end = mid - 1 \\n\\n# Complexity\\n- Time complexity:\\nO(NLogN)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaximumCandies(int[] candies, long k) {\\n        int ans = 0;\\n        int start = 1;\\n        int end =  (int) 1e9;\\n        while(start <= end){\\n            int mid = start + (end - start)/2;\\n            long count = 0;\\n            for(int i=0;i<candies.Length;i++){\\n                if(candies[i] >= mid){\\n                    count +=  candies[i] / mid;\\n                }\\n            }\\n            if(count < k){\\n                end = mid -1;\\n            }\\n            else{\\n                ans = mid;\\n                start = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Binary Search"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaximumCandies(int[] candies, long k) {\\n        int ans = 0;\\n        int start = 1;\\n        int end =  (int) 1e9;\\n        while(start <= end){\\n            int mid = start + (end - start)/2;\\n            long count = 0;\\n            for(int i=0;i<candies.Length;i++){\\n                if(candies[i] >= mid){\\n                    count +=  candies[i] / mid;\\n                }\\n            }\\n            if(count < k){\\n                end = mid -1;\\n            }\\n            else{\\n                ans = mid;\\n                start = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3384435,
                "title": "c-binary-search-o-nlog-max-nums-i",
                "content": "```\\nclass Solution {\\npublic:\\n    bool ispossible(vector<int>&nums,long long num,long long k){\\n        \\n        long long students=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            if(nums[i]<num){\\n                continue;\\n            }\\n            else{\\n                int x=nums[i]/num;\\n                students=students+x;\\n                if(students>=k){\\n                    return true;\\n                }\\n            }\\n        }\\n        if(students<k){\\n            return false;\\n        }\\n        return true;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        \\n        long long start=1;\\n        int maxi=-1e9;\\n        int n=candies.size();\\n        for(int i=0;i<n;i++){\\n            maxi=max(maxi,candies[i]);\\n        }\\n        long long end=maxi;\\n        long long ans=0;\\n        while(start<=end){\\n            \\n            long long mid=(start+end)/2;\\n            if(ispossible(candies,mid,k)){\\n                ans=mid;\\n                start=mid+1;\\n            }\\n            else{\\n                end=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "class Solution {\\npublic:\\n    bool ispossible(vector<int>&nums,long long num,long long k){\\n        \\n        long long students=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            if(nums[i]<num){\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3383004,
                "title": "c-easy-solution-binary-search-for-beginner",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& c, long long k) {\\n        long long int sum=0;\\n        for(auto x:c) sum+=x;\\n        if(sum<k) return 0; // if total candies is less than the sum then we can not allote atleast one to everyone , So ans is 0\\n        \\n       long long int s=1;\\n        long long int e=sum/k;   //this is the max candies that a child can get,\\n        long long int ans;\\n        while(s<=e){\\n            long long int mid=s+(e-s)/2;\\n            if(isPossible(mid,k,c)){         //this function will tell us, is it possible to allot mid no. of candies to allot a child\\n                ans=mid;\\n                s=mid+1;\\n            }\\n            else{\\n                e=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    private: bool isPossible(long long int mid,long long int k,vector<int>&c){\\n        for(auto x:c){\\n            k-=(x/mid);\\n        }\\n        return k<=0?true:false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& c, long long k) {\\n        long long int sum=0;\\n        for(auto x:c) sum+=x;\\n        if(sum<k) return 0; // if total candies is less than the sum then we can not allote atleast one to everyone , So ans is 0\\n        \\n       long long int s=1;\\n        long long int e=sum/k;   //this is the max candies that a child can get,\\n        long long int ans;\\n        while(s<=e){\\n            long long int mid=s+(e-s)/2;\\n            if(isPossible(mid,k,c)){         //this function will tell us, is it possible to allot mid no. of candies to allot a child\\n                ans=mid;\\n                s=mid+1;\\n            }\\n            else{\\n                e=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    private: bool isPossible(long long int mid,long long int k,vector<int>&c){\\n        for(auto x:c){\\n            k-=(x/mid);\\n        }\\n        return k<=0?true:false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1688215,
                "content": [
                    {
                        "username": "topswe",
                        "content": "   Hint: very similar to 875. Koko Eating Bananas. binary search the solution space. left = 0, right = max(candies)\n  Given a fixed number of candies each child can get, is easy to check if it is possible to allocate k piles. If possible, set left = mid. Otherwise set right = mid-1.\n\n  O(nlog(max(candies))) time : O(1) space"
                    },
                    {
                        "username": "c0D3M",
                        "content": "I dont want to add my approach as masters already did.\\nBut i wanted to give the link of my post in case anyone wanted to practice more problems like these.\\nhttps://leetcode.com/discuss/study-guide/1529866/solving-kth-kind-of-problems"
                    },
                    {
                        "username": "rnikh",
                        "content": "Similar Question: 2064. Minimized Maximum of Products Distributed to Any Store "
                    },
                    {
                        "username": "mohiwalla",
                        "content": "> Each child can take at most one pile of candies\\n\\n>Return the maximum number of candies each child can get.\\n\\nDo these two statements match?"
                    }
                ]
            },
            {
                "id": 1570836,
                "content": [
                    {
                        "username": "topswe",
                        "content": "   Hint: very similar to 875. Koko Eating Bananas. binary search the solution space. left = 0, right = max(candies)\n  Given a fixed number of candies each child can get, is easy to check if it is possible to allocate k piles. If possible, set left = mid. Otherwise set right = mid-1.\n\n  O(nlog(max(candies))) time : O(1) space"
                    },
                    {
                        "username": "c0D3M",
                        "content": "I dont want to add my approach as masters already did.\\nBut i wanted to give the link of my post in case anyone wanted to practice more problems like these.\\nhttps://leetcode.com/discuss/study-guide/1529866/solving-kth-kind-of-problems"
                    },
                    {
                        "username": "rnikh",
                        "content": "Similar Question: 2064. Minimized Maximum of Products Distributed to Any Store "
                    },
                    {
                        "username": "mohiwalla",
                        "content": "> Each child can take at most one pile of candies\\n\\n>Return the maximum number of candies each child can get.\\n\\nDo these two statements match?"
                    }
                ]
            },
            {
                "id": 1926229,
                "content": [
                    {
                        "username": "topswe",
                        "content": "   Hint: very similar to 875. Koko Eating Bananas. binary search the solution space. left = 0, right = max(candies)\n  Given a fixed number of candies each child can get, is easy to check if it is possible to allocate k piles. If possible, set left = mid. Otherwise set right = mid-1.\n\n  O(nlog(max(candies))) time : O(1) space"
                    },
                    {
                        "username": "c0D3M",
                        "content": "I dont want to add my approach as masters already did.\\nBut i wanted to give the link of my post in case anyone wanted to practice more problems like these.\\nhttps://leetcode.com/discuss/study-guide/1529866/solving-kth-kind-of-problems"
                    },
                    {
                        "username": "rnikh",
                        "content": "Similar Question: 2064. Minimized Maximum of Products Distributed to Any Store "
                    },
                    {
                        "username": "mohiwalla",
                        "content": "> Each child can take at most one pile of candies\\n\\n>Return the maximum number of candies each child can get.\\n\\nDo these two statements match?"
                    }
                ]
            },
            {
                "id": 2006201,
                "content": [
                    {
                        "username": "topswe",
                        "content": "   Hint: very similar to 875. Koko Eating Bananas. binary search the solution space. left = 0, right = max(candies)\n  Given a fixed number of candies each child can get, is easy to check if it is possible to allocate k piles. If possible, set left = mid. Otherwise set right = mid-1.\n\n  O(nlog(max(candies))) time : O(1) space"
                    },
                    {
                        "username": "c0D3M",
                        "content": "I dont want to add my approach as masters already did.\\nBut i wanted to give the link of my post in case anyone wanted to practice more problems like these.\\nhttps://leetcode.com/discuss/study-guide/1529866/solving-kth-kind-of-problems"
                    },
                    {
                        "username": "rnikh",
                        "content": "Similar Question: 2064. Minimized Maximum of Products Distributed to Any Store "
                    },
                    {
                        "username": "mohiwalla",
                        "content": "> Each child can take at most one pile of candies\\n\\n>Return the maximum number of candies each child can get.\\n\\nDo these two statements match?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Count Number of Texts",
        "question_content": "<p>Alice is texting Bob using her phone. The <strong>mapping</strong> of digits to letters is shown in the figure below.</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/15/1200px-telephone-keypad2svg.png\" style=\"width: 200px; height: 162px;\" />\n<p>In order to <strong>add</strong> a letter, Alice has to <strong>press</strong> the key of the corresponding digit <code>i</code> times, where <code>i</code> is the position of the letter in the key.</p>\n\n<ul>\n\t<li>For example, to add the letter <code>&#39;s&#39;</code>, Alice has to press <code>&#39;7&#39;</code> four times. Similarly, to add the letter <code>&#39;k&#39;</code>, Alice has to press <code>&#39;5&#39;</code> twice.</li>\n\t<li>Note that the digits <code>&#39;0&#39;</code> and <code>&#39;1&#39;</code> do not map to any letters, so Alice <strong>does not</strong> use them.</li>\n</ul>\n\n<p>However, due to an error in transmission, Bob did not receive Alice&#39;s text message but received a <strong>string of pressed keys</strong> instead.</p>\n\n<ul>\n\t<li>For example, when Alice sent the message <code>&quot;bob&quot;</code>, Bob received the string <code>&quot;2266622&quot;</code>.</li>\n</ul>\n\n<p>Given a string <code>pressedKeys</code> representing the string received by Bob, return <em>the <strong>total number of possible text messages</strong> Alice could have sent</em>.</p>\n\n<p>Since the answer may be very large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> pressedKeys = &quot;22233&quot;\n<strong>Output:</strong> 8\n<strong>Explanation:</strong>\nThe possible text messages Alice could have sent are:\n&quot;aaadd&quot;, &quot;abdd&quot;, &quot;badd&quot;, &quot;cdd&quot;, &quot;aaae&quot;, &quot;abe&quot;, &quot;bae&quot;, and &quot;ce&quot;.\nSince there are 8 possible messages, we return 8.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> pressedKeys = &quot;222222222222222222222222222222222222&quot;\n<strong>Output:</strong> 82876089\n<strong>Explanation:</strong>\nThere are 2082876103 possible text messages Alice could have sent.\nSince we need to return the answer modulo 10<sup>9</sup> + 7, we return 2082876103 % (10<sup>9</sup> + 7) = 82876089.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= pressedKeys.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>pressedKeys</code> only consists of digits from <code>&#39;2&#39;</code> - <code>&#39;9&#39;</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 2017753,
                "title": "simple-o-n-single-pass-solution",
                "content": "For every number other than 7 and 9, we can consider at most 3 **consecutive** digits whereas for 7 and 9 we can consider atmost 4 **consecutive** digits.\\n\\nLogic:\\n- Make an empty dp array.\\n- Iterate through every key pressed in pressedKeys and for every **i** we can add dp[i-1],dp[i-2],dp[i-3] to dp[i] and if pressedKeys[i] is either 7 or 9 then we can add dp[i-4] also.\\n- <img src=\"https://assets.leetcode.com/users/images/9a4f16ea-9965-4fa6-91a4-b2e3e5629139_1651982047.43855.jpeg\" width=450 height=400 align=center>\\n\\nCode:\\n```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        MOD=pow(10,9)+7\\n        dp=[0]*(len(pressedKeys)+1)\\n        dp[0]=1\\n        for i in range(1,len(pressedKeys)+1):\\n            dp[i]=dp[i-1]%MOD\\n            if(i-2>=0 and pressedKeys[i-1]==pressedKeys[i-2]):\\n                dp[i]=(dp[i]+dp[i-2])%MOD\\n                if(i-3>=0 and pressedKeys[i-1]==pressedKeys[i-3]):\\n                    dp[i]=(dp[i]+dp[i-3])%MOD\\n                    if(pressedKeys[i-1] in \"79\" and i-4>=0 and pressedKeys[i-1]==pressedKeys[i-4]):\\n                        dp[i]=(dp[i]+dp[i-4])%MOD\\n        return dp[-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        MOD=pow(10,9)+7\\n        dp=[0]*(len(pressedKeys)+1)\\n        dp[0]=1\\n        for i in range(1,len(pressedKeys)+1):\\n            dp[i]=dp[i-1]%MOD\\n            if(i-2>=0 and pressedKeys[i-1]==pressedKeys[i-2]):\\n                dp[i]=(dp[i]+dp[i-2])%MOD\\n                if(i-3>=0 and pressedKeys[i-1]==pressedKeys[i-3]):\\n                    dp[i]=(dp[i]+dp[i-3])%MOD\\n                    if(pressedKeys[i-1] in \"79\" and i-4>=0 and pressedKeys[i-1]==pressedKeys[i-4]):\\n                        dp[i]=(dp[i]+dp[i-4])%MOD\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017810,
                "title": "python-o-n-dp-easy-to-understand-with-explanation",
                "content": "**Observation and intuition**\\n\"return the total number of possible text messages Alice could have sent\" means that this is a counting-number-of-ways problem, which is a signal of trying dynamic programming.\\n\\nLet\\'s have some simple observations trying to get some intuition about the recurrence relations:\\n1. if S = \"2\", then we only have one option: (2)\\n2. if S = \"23\", then we only have one option: (2)(3)\\n3. if S = \"22\", then we have two options: (2)(2), (22)\\n4. if S = \"223\", then we have two options: (2)(2)(3), (22)(3)\\n5. if S = \"222\", then we have four options: (2)(2)(2), (22)(2), (2)(22), (222)\\n\\nNote that ***more options emerge because we can combine the same letters together***, this is the main fact that we should utilize to break down this problem.\\n\\n\\n**Explanation:**\\nWhen we traverse the string S and we are at the index i, there are 3 (or 4 for \"7\" and \"9\") cases to be considered for the letter at index i:\\n1. consider that letter separately, so combination[i] = combination[i - 1]\\n2. if the two last letters stopping at index i are the same, we have an option to combine them, then combination[i] += combination[i - 2]\\n3. if the three last letters stopping at index i are the same, we have an option to combine them, then combination[i] += combination[i - 3]\\n4. if the four last letters (for \"7\" and \"9\") stopping at index i are the same, we have an option to combine them, then combination[i] += combination[i - 4]\\n\\nTake \"2222\" as an example and we are at the last \"2\":\\ncase 1: \"222(2)\", combination[\"2222\"] = combination[\"222\"]\\ncase 2: \"22(22)\", combination[\"2222\"] += combination[\"22\"]\\ncase 3: \"2(222)\", combination[\"2222\"] += combination[\"2\"]\\n\\n```\\nclass Solution:\\n    def countTexts(self, S: str) -> int:\\n        \\n        mod = 10 ** 9 + 7\\n        \\n        dp = [0] * (len(S) + 1)\\n        dp[0] = 1\\n        for i in range(1, len(S) + 1):\\n            dp[i] = dp[i - 1]\\n            if i - 2 >= 0 and S[i-1] == S[i-2]:\\n                dp[i] += dp[i - 2]\\n            if i - 3 >= 0 and S[i-1] == S[i-2] and S[i-1] == S[i-3]:\\n                dp[i] += dp[i - 3]\\n                \\n            if S[i-1] in {\"7\", \"9\"}:\\n                if i - 4 >= 0 and S[i-1] == S[i-2] and S[i-1] == S[i-3] and S[i-1] == S[i-4]:\\n                    dp[i] += dp[i - 4]\\n            dp[i] %= mod\\n            \\n        return dp[-1] % mod",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution:\\n    def countTexts(self, S: str) -> int:\\n        \\n        mod = 10 ** 9 + 7\\n        \\n        dp = [0] * (len(S) + 1)\\n        dp[0] = 1\\n        for i in range(1, len(S) + 1):\\n            dp[i] = dp[i - 1]\\n            if i - 2 >= 0 and S[i-1] == S[i-2]:\\n                dp[i] += dp[i - 2]\\n            if i - 3 >= 0 and S[i-1] == S[i-2] and S[i-1] == S[i-3]:\\n                dp[i] += dp[i - 3]\\n                \\n            if S[i-1] in {\"7\", \"9\"}",
                "codeTag": "Java"
            },
            {
                "id": 2017714,
                "title": "o-n-o-1",
                "content": "We use tabulation `dp` to store the number of possible messages for `i` characters.\\n\\nFor `i + 1`-th character, the number of messages is `dp[i + 1] = dp[i]`, plus:\\n- `dp[i - 1]` if `key[i + 1] == key[i]`\\n- `dp[i - 2]` if `key[i + 1] == key[i - 1]`\\n- `dp[i - 3]` if `key[i + 1] == key[i - 2]`\\n- `dp[i - 4]` if `key[i + 1] == key[i - 3]` and `key[i + 1]` is either 7 or 9.\\n\\nNote that we only need to store the tabulation for 4 previous positions. We can use a circular array to achieve O(1) memory complexity.\\n\\n**C++**\\n```cpp\\nint countTexts(string k) {\\n    int dp[5] = {1, 1, 1, 1, 1}, n = k.size();\\n    for (int i = n - 1; i >= 0; --i) {\\n        dp[i % 5] = 0;\\n        int max_j = min(n, i + (k[i] == \\'7\\' || k[i] == \\'9\\' ? 4 : 3));\\n        for (int j = i; j < max_j && k[i] == k[j]; ++j)\\n            dp[i % 5] = (dp[i % 5] + dp[(j + 1) % 5]) % 1000000007;\\n    }\\n    return dp[0];\\n} \\n```",
                "solutionTags": [],
                "code": "```cpp\\nint countTexts(string k) {\\n    int dp[5] = {1, 1, 1, 1, 1}, n = k.size();\\n    for (int i = n - 1; i >= 0; --i) {\\n        dp[i % 5] = 0;\\n        int max_j = min(n, i + (k[i] == \\'7\\' || k[i] == \\'9\\' ? 4 : 3));\\n        for (int j = i; j < max_j && k[i] == k[j]; ++j)\\n            dp[i % 5] = (dp[i % 5] + dp[(j + 1) % 5]) % 1000000007;\\n    }\\n    return dp[0];\\n} \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2019208,
                "title": "java-from-recursion-to-memoization-to-tabulation-easy-solution",
                "content": "Recursion -->>\\n\\n```\\nclass Solution {\\n    int mod = (1000000007);\\n\\n    public int countTexts(String pressedKeys) {\\n        int[] key = new int[] { 0, 0, 3, 3, 3, 3, 3, 4, 3, 4 };\\n        int n = pressedKeys.length();\\n        return solve(0,pressedKeys,key);\\n    }\\n\\n    public int solve(int ind, String s, int[] key) {\\n        if (ind == s.length()) {\\n            return 1;\\n        }\\n        int count = 0;\\n        int num = s.charAt(ind) - \\'0\\';\\n        int rep = key[num];\\n        for (int i = 0; i < rep && ind + i < s.length() && s.charAt(ind) == s.charAt(ind + i); i++) {\\n            count += solve(ind + 1 + i, s, key);\\n            count %= mod;\\n        }\\n        return  count;\\n    }\\n}\\n```\\n\\nMemoization(Top-Down)-->>\\n\\n```\\nclass Solution {\\n    int mod = (1000000007);\\n    public int countTexts(String pressedKeys) {\\n         int[] key = new int[] {0,0,3,3,3,3,3,4,3,4};\\n         int n = pressedKeys.length();\\n         int[] dp = new int[n];\\n        Arrays.fill(dp,-1);\\n         return solve(0,pressedKeys,key,dp);\\n    }\\n    public int solve(int ind , String s ,int[] key,int[]dp){\\n        if(ind==s.length()){\\n            return 1;\\n        }\\n        if(dp[ind]!=-1) return dp[ind];\\n        int count = 0;\\n        int num = s.charAt(ind)-\\'0\\';\\n        int rep = key[num];\\n        for(int i =0;i<rep && ind+i<s.length() && s.charAt(ind)==s.charAt(ind+i);i++){\\n            count += solve(ind+1+i,s,key,dp);\\n            count %= mod;\\n        }\\n        return dp[ind] = count;\\n    }\\n}\\n```\\n\\nTabulation(Bottom up)-->>\\n```\\nclass Solution {\\n    int mod = (1000000007);\\n\\n    public int countTexts(String pressedKeys) {\\n        int[] key = new int[] { 0, 0, 3, 3, 3, 3, 3, 4, 3, 4 };\\n        int n = pressedKeys.length();\\n        int[] dp = new int[n + 1];\\n        dp[n] = 1;\\n\\n        for (int ind = n - 1; ind >= 0; ind--) {\\n            int count = 0;\\n            int num = pressedKeys.charAt(ind) - \\'0\\';\\n            int rep = key[num];\\n            for (int i = 0; i < rep && ind + i < pressedKeys.length() && pressedKeys.charAt(ind) == pressedKeys.charAt(ind + i); i++) {\\n                count += dp[ind+i+1];\\n                count %= mod;\\n            }\\n             dp[ind] = count;\\n        }\\n        return dp[0];\\n    }\\n}\\n```\\n\\nDo Upvote if you find these solution Helpful.",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int mod = (1000000007);\\n\\n    public int countTexts(String pressedKeys) {\\n        int[] key = new int[] { 0, 0, 3, 3, 3, 3, 3, 4, 3, 4 };\\n        int n = pressedKeys.length();\\n        return solve(0,pressedKeys,key);\\n    }\\n\\n    public int solve(int ind, String s, int[] key) {\\n        if (ind == s.length()) {\\n            return 1;\\n        }\\n        int count = 0;\\n        int num = s.charAt(ind) - \\'0\\';\\n        int rep = key[num];\\n        for (int i = 0; i < rep && ind + i < s.length() && s.charAt(ind) == s.charAt(ind + i); i++) {\\n            count += solve(ind + 1 + i, s, key);\\n            count %= mod;\\n        }\\n        return  count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int mod = (1000000007);\\n    public int countTexts(String pressedKeys) {\\n         int[] key = new int[] {0,0,3,3,3,3,3,4,3,4};\\n         int n = pressedKeys.length();\\n         int[] dp = new int[n];\\n        Arrays.fill(dp,-1);\\n         return solve(0,pressedKeys,key,dp);\\n    }\\n    public int solve(int ind , String s ,int[] key,int[]dp){\\n        if(ind==s.length()){\\n            return 1;\\n        }\\n        if(dp[ind]!=-1) return dp[ind];\\n        int count = 0;\\n        int num = s.charAt(ind)-\\'0\\';\\n        int rep = key[num];\\n        for(int i =0;i<rep && ind+i<s.length() && s.charAt(ind)==s.charAt(ind+i);i++){\\n            count += solve(ind+1+i,s,key,dp);\\n            count %= mod;\\n        }\\n        return dp[ind] = count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int mod = (1000000007);\\n\\n    public int countTexts(String pressedKeys) {\\n        int[] key = new int[] { 0, 0, 3, 3, 3, 3, 3, 4, 3, 4 };\\n        int n = pressedKeys.length();\\n        int[] dp = new int[n + 1];\\n        dp[n] = 1;\\n\\n        for (int ind = n - 1; ind >= 0; ind--) {\\n            int count = 0;\\n            int num = pressedKeys.charAt(ind) - \\'0\\';\\n            int rep = key[num];\\n            for (int i = 0; i < rep && ind + i < pressedKeys.length() && pressedKeys.charAt(ind) == pressedKeys.charAt(ind + i); i++) {\\n                count += dp[ind+i+1];\\n                count %= mod;\\n            }\\n             dp[ind] = count;\\n        }\\n        return dp[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2109592,
                "title": "very-detailed-recursive-tree-diagram-with-decent-intuition-c-memorized-code",
                "content": "# Count Number of Texts\\n\\n***Intuition***\\n* As we know in feature phones, numbers (2, 3, 4, 5, 6, 8) have maximum 3 characters while (7 and 9) have 4 characters.\\n* So if we encountered same key press again in input then we have 2 choices either we can take it as single key press (take 1st letter of that pressed number) and move on or we can say that  a previously pressed number tapped again (if a same key pressed again then we take the next letter which is embedded to that number key).\\n***Example***\\n\\t* Let\\'s say we have input \"22223\"\\n       * if we consider every number was pressed once then the output word would be \"aaaad\".\\n       * if we consider that 2 was pressed twice at same time then the output word would be \"baac\".\\n       * if we say 2 pressed thrice then, we\\'ll get \"cab\" as the output\\n       * (**note**) This time we can\\'t take four 2s at same time because we know, we can only get a letter from number key 2 when it gets pressed once (a), twice(b) & thrice(c). Therefore the 4th keypress (2) considered as first tap & the keypress gives \\'a\\'.\\n  * **Please refer to the below recursive tree diagram for better understanding.**\\n<br>\\n![image](https://assets.leetcode.com/users/images/54f19f39-f2f0-463c-bec7-148f134327c0_1654338912.543673.png)\\n\\n***Please Upvote if you like the post*** \\u2B06\\uFE0F\\n\\n**Recursion [TLE]**\\n\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int solve(string &str, int idx) {\\n        if(idx == str.length()) return 1;\\n        int maxKeyPress = (str[idx] == \\'7\\' || str[idx] == \\'9\\') ? 4 : 3;\\n        long long currIndex = idx, pressFrequency = 1, ans = 0;\\n        while(pressFrequency <= maxKeyPress && str[currIndex] == str[idx]) {\\n            ++currIndex;\\n            ++pressFrequency;\\n            ans += solve(str, currIndex) % mod;\\n        }\\n        return ans%mod;\\n    }\\n    int countTexts(string pressedKeys) {\\n        return solve(pressedKeys, 0) % mod;\\n    }\\n};\\n```\\n\\n**Recursion + Memoization [#ACCEPTED]**\\n*TC : O(N) & SC: O(N), where N is input string length*\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[100005];\\n    int mod = 1e9+7;\\n    int solve(string &str, int idx) {\\n        if(idx == str.length()) return 1;\\n        if(dp[idx] != -1) return dp[idx];\\n        int maxKeyPress = (str[idx] == \\'7\\' || str[idx] == \\'9\\') ? 4 : 3;\\n        long long currIndex = idx, pressFrequency = 1, ans = 0;\\n        while(pressFrequency <= maxKeyPress && str[currIndex] == str[idx]) {\\n            ++currIndex;\\n            ++pressFrequency;\\n            ans += solve(str, currIndex) % mod;\\n        }\\n        return dp[idx] = ans%mod;\\n    }\\n    int countTexts(string pressedKeys) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(pressedKeys, 0) % mod;\\n    }\\n};\\n```\\n\\nThanks to [@aman-Raj](https://leetcode.com/aman-raj/) & [@anishakd](https://leetcode.com/anishakd/) for helping in recursive tree diagram \\u2764\\uFE0F.",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int solve(string &str, int idx) {\\n        if(idx == str.length()) return 1;\\n        int maxKeyPress = (str[idx] == \\'7\\' || str[idx] == \\'9\\') ? 4 : 3;\\n        long long currIndex = idx, pressFrequency = 1, ans = 0;\\n        while(pressFrequency <= maxKeyPress && str[currIndex] == str[idx]) {\\n            ++currIndex;\\n            ++pressFrequency;\\n            ans += solve(str, currIndex) % mod;\\n        }\\n        return ans%mod;\\n    }\\n    int countTexts(string pressedKeys) {\\n        return solve(pressedKeys, 0) % mod;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int dp[100005];\\n    int mod = 1e9+7;\\n    int solve(string &str, int idx) {\\n        if(idx == str.length()) return 1;\\n        if(dp[idx] != -1) return dp[idx];\\n        int maxKeyPress = (str[idx] == \\'7\\' || str[idx] == \\'9\\') ? 4 : 3;\\n        long long currIndex = idx, pressFrequency = 1, ans = 0;\\n        while(pressFrequency <= maxKeyPress && str[currIndex] == str[idx]) {\\n            ++currIndex;\\n            ++pressFrequency;\\n            ans += solve(str, currIndex) % mod;\\n        }\\n        return dp[idx] = ans%mod;\\n    }\\n    int countTexts(string pressedKeys) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(pressedKeys, 0) % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018336,
                "title": "python-dp-with-diagrams-for-beginners",
                "content": "I have created some diagrams to help learners better understand how the dp works.\\nWe create ```dp = [1] + [0] * len(pressedKeys)``` for dp[0] to become a \"base case\". \\nAt each continuous number, we append the appropriate letter to reach the \"required length\".\\nTake string \"222233\" as an example:\\n![image](https://assets.leetcode.com/users/images/67828b61-eb60-44cd-bbec-438a1f223934_1651988165.4311492.png)\\n\\n\\n\\nSame concept applies when moving to next different number:\\n![image](https://assets.leetcode.com/users/images/50a25151-b975-4404-83a9-4b6da3f8cba8_1652146323.6530101.png)\\n\\n\\n```\\nclass Solution(object):\\n    def countTexts(self, pressedKeys):\\n        \"\"\"\\n        :type pressedKeys: str\\n        :rtype: int\\n        \"\"\"\\n        dp = [1] + [0]*len(pressedKeys)\\n        mod = 10**9 + 7\\n        for i, n in enumerate(pressedKeys):\\n            dp[i+1] = dp[i]\\n            # check if is continous\\n            if i >= 1 and pressedKeys[i-1] == n:\\n                dp[i+1] += dp[i-1]\\n                dp[i+1] %= mod\\n                if i >= 2 and pressedKeys[i-2] == n:\\n                    dp[i+1] += dp[i-2]\\n                    dp[i+1] %= mod\\n                    # Special case for \\'7\\' and \\'9\\' that can have 4 characters combination\\n                    if i >= 3 and pressedKeys[i-3] == n and (n == \"7\" or n == \"9\"):\\n                        dp[i+1] += dp[i-3]\\n                        dp[i+1] %= mod\\n        return dp[-1]\\n```\\nCode can be further optimized.\\nInspired from https://leetcode.com/problems/count-number-of-texts/discuss/2017760/JavaPython-3-Time-O(n)-space-O(1)-1-pass-DP-codes .\\n\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```dp = [1] + [0] * len(pressedKeys)```\n```\\nclass Solution(object):\\n    def countTexts(self, pressedKeys):\\n        \"\"\"\\n        :type pressedKeys: str\\n        :rtype: int\\n        \"\"\"\\n        dp = [1] + [0]*len(pressedKeys)\\n        mod = 10**9 + 7\\n        for i, n in enumerate(pressedKeys):\\n            dp[i+1] = dp[i]\\n            # check if is continous\\n            if i >= 1 and pressedKeys[i-1] == n:\\n                dp[i+1] += dp[i-1]\\n                dp[i+1] %= mod\\n                if i >= 2 and pressedKeys[i-2] == n:\\n                    dp[i+1] += dp[i-2]\\n                    dp[i+1] %= mod\\n                    # Special case for \\'7\\' and \\'9\\' that can have 4 characters combination\\n                    if i >= 3 and pressedKeys[i-3] == n and (n == \"7\" or n == \"9\"):\\n                        dp[i+1] += dp[i-3]\\n                        dp[i+1] %= mod\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017760,
                "title": "java-python-3-1-pass-o-n-o-1-dp-codes-w-explanation-analysis-and-similar-problem",
                "content": "A Similar problem: \\n[91. Decode Ways](https://leetcode.com/problems/decode-ways/description/)\\n\\n----\\n\\n1. If the digit at index `i` was pressed just `1` times, then the corresponding solution is same as that of the subproblem of `i - 1`; e.g.,\\n\\n *   7   7   7  (7)\\n\\n2. If the digit at index `i` was acutally pressed `2` times, then the corresponding solution is same as that of the subproblem of `i - 2`; e.g.,\\n\\n*   7   7  (7   7)\\n\\n3.  If the digit at index `i` was acutally pressed `3` times, then the corresponding solution is same as that of the subproblem of `i - 3`; e.g.,\\n\\n *   7  (7   7   7)\\n\\n4.  If the digit at index `i` is `7` or `9` and was acutally pressed `4` times, then the corresponding solution is same as that of the subproblem of `i - 4`; e.g.,\\n\\n *  (7   7   7   7)\\n\\nCombine the above 4 cases, we can use `dp[i]` to indicate the solution of `pressedKeys.substring(0, i)`, and the general DP transition function is as follows:\\n```text\\ndp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3] + dp[i - 4]\\n```\\n\\n----\\n\\n```java\\n    private static final int MOD = 1_000_000_007;\\n    public int countTexts(String pressedKeys) {\\n        int n = pressedKeys.length();\\n        int[] dp = new int[n + 1];\\n        dp[0] = 1;\\n        for (int i = 1; i <= n; ++i) {\\n            char c = pressedKeys.charAt(i - 1);\\n            dp[i] = dp[i - 1];\\n            if (i >= 2) {\\n                if (c == pressedKeys.charAt(i - 2)) {\\n                    dp[i] = (dp[i] + dp[i - 2]) % MOD; \\n                    if (i >= 3 && c == pressedKeys.charAt(i - 3)) {\\n                        dp[i] = (dp[i] + dp[i - 3]) % MOD;\\n                        if ((c == \\'7\\' || c == \\'9\\') && i >= 4 && c == pressedKeys.charAt(i - 4)) {\\n                            dp[i] = (dp[i] + dp[i - 4]) % MOD;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n```\\n```python\\n    def countTexts(self, p: str) -> int:\\n        dp = [1] + [0] * len(p)\\n        for i, c in enumerate(p, 1):\\n            dp[i] = dp[i - 1]\\n            if i >= 2:    \\n                if c == p[i - 2]:\\n                    dp[i] += dp[i - 2]\\n                    if i >= 3 and c == p[i - 3]:\\n                        dp[i] += dp[i - 3]\\n                        if c in (\\'7\\', \\'9\\') and i >= 4 and c == p[i - 4]:\\n                            dp[i] += dp[i - 4]\\n            dp[i] %= 10 ** 9 + 7        \\n        return dp[len(p)]\\n```\\n**Analysis:**\\nTime & space: `O(n)`, where `n = pressedKeys.length()`.\\n\\n----\\n\\nAfter space optimization:\\n\\n```java\\n    private static final int MOD = 1_000_000_007;\\n    public int countTexts(String pressedKeys) {\\n        int n = pressedKeys.length();\\n        int[] dp = new int[5];\\n        dp[0] = 1;\\n        for (int i = 1; i <= n; ++i) {\\n            char c = pressedKeys.charAt(i - 1);\\n            int idx = i % 5;\\n            dp[idx] = dp[(i - 1) % 5];\\n            if (i >= 2) {\\n                if (c == pressedKeys.charAt(i - 2)) {\\n                    dp[idx] = (dp[idx] + dp[(i - 2) % 5]) % MOD; \\n                    if (i >= 3 && c == pressedKeys.charAt(i - 3)) {\\n                        dp[idx] = (dp[idx] + dp[(i - 3) % 5]) % MOD;\\n                        if ((c == \\'7\\' || c == \\'9\\') && i >= 4 && c == pressedKeys.charAt(i - 4)) {\\n                            dp[idx] = (dp[idx] + dp[(i - 4) % 5]) % MOD;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n % 5];\\n    }\\n```\\n```python\\n    def countTexts(self, pressedKeys: str) -> int:\\n        dp = [1] + [0] * 4\\n        for i, c in enumerate(pressedKeys, 1):\\n            dp[i % 5] = dp[(i - 1) % 5]\\n            if i >= 2:    \\n                if c == pressedKeys[i - 2]:\\n                    dp[i % 5] += dp[(i - 2) % 5]\\n                    if i >= 3 and c == pressedKeys[i - 3]:\\n                        dp[i % 5] += dp[(i - 3) % 5]\\n                        if c in (\\'7\\', \\'9\\') and i >= 4 and c == pressedKeys[i - 4]:\\n                            dp[i % 5] += dp[(i - 4) % 5]\\n            dp[i % 5] %= 10 ** 9 + 7        \\n        return dp[len(pressedKeys) % 5]\\n```\\n\\nSimplify the above codes further:\\n\\n```java\\n    private static final int MOD = 1_000_000_007;\\n    public int countTexts(String pressedKeys) {\\n        int n = pressedKeys.length();\\n        int[] dp = new int[5];\\n        dp[0] = 1;\\n        for (int i = 1; i <= n; ++i) {\\n            char c = pressedKeys.charAt(i - 1);\\n            int idx = i % 5, lowBound = Math.max(0, i - (c == \\'7\\' || c == \\'9\\' ? 4 : 3));\\n            dp[idx] = dp[(i - 1) % 5];\\n            for (int j = i - 2; j >= lowBound && c == pressedKeys.charAt(j); --j) {\\n                dp[idx] = (dp[idx] + dp[j % 5]) % MOD; \\n            }\\n        }\\n        return dp[n % 5];\\n    }\\n```\\n```python\\n    def countTexts(self, pressedKeys: str) -> int:\\n        dp = [1] + [0] * 4\\n        for i, c in enumerate(pressedKeys, 1):\\n            dp[i % 5] = dp[(i - 1) % 5]\\n            for j in range(i - 2, max(-1, i - 4 - (c in \\'79\\')), -1):\\n                if c == pressedKeys[j]:\\n                    dp[i % 5] += dp[j % 5]\\n                else:\\n                    break    \\n            dp[i % 5] %= 10 ** 9 + 7        \\n        return dp[len(pressedKeys) % 5]\\n```\\n**Analysis:**\\nTime: `O(n)`, space: `O(1)`, where `n = pressedKeys.length()`.",
                "solutionTags": [],
                "code": "```text\\ndp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3] + dp[i - 4]\\n```\n```java\\n    private static final int MOD = 1_000_000_007;\\n    public int countTexts(String pressedKeys) {\\n        int n = pressedKeys.length();\\n        int[] dp = new int[n + 1];\\n        dp[0] = 1;\\n        for (int i = 1; i <= n; ++i) {\\n            char c = pressedKeys.charAt(i - 1);\\n            dp[i] = dp[i - 1];\\n            if (i >= 2) {\\n                if (c == pressedKeys.charAt(i - 2)) {\\n                    dp[i] = (dp[i] + dp[i - 2]) % MOD; \\n                    if (i >= 3 && c == pressedKeys.charAt(i - 3)) {\\n                        dp[i] = (dp[i] + dp[i - 3]) % MOD;\\n                        if ((c == \\'7\\' || c == \\'9\\') && i >= 4 && c == pressedKeys.charAt(i - 4)) {\\n                            dp[i] = (dp[i] + dp[i - 4]) % MOD;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n```\n```python\\n    def countTexts(self, p: str) -> int:\\n        dp = [1] + [0] * len(p)\\n        for i, c in enumerate(p, 1):\\n            dp[i] = dp[i - 1]\\n            if i >= 2:    \\n                if c == p[i - 2]:\\n                    dp[i] += dp[i - 2]\\n                    if i >= 3 and c == p[i - 3]:\\n                        dp[i] += dp[i - 3]\\n                        if c in (\\'7\\', \\'9\\') and i >= 4 and c == p[i - 4]:\\n                            dp[i] += dp[i - 4]\\n            dp[i] %= 10 ** 9 + 7        \\n        return dp[len(p)]\\n```\n```java\\n    private static final int MOD = 1_000_000_007;\\n    public int countTexts(String pressedKeys) {\\n        int n = pressedKeys.length();\\n        int[] dp = new int[5];\\n        dp[0] = 1;\\n        for (int i = 1; i <= n; ++i) {\\n            char c = pressedKeys.charAt(i - 1);\\n            int idx = i % 5;\\n            dp[idx] = dp[(i - 1) % 5];\\n            if (i >= 2) {\\n                if (c == pressedKeys.charAt(i - 2)) {\\n                    dp[idx] = (dp[idx] + dp[(i - 2) % 5]) % MOD; \\n                    if (i >= 3 && c == pressedKeys.charAt(i - 3)) {\\n                        dp[idx] = (dp[idx] + dp[(i - 3) % 5]) % MOD;\\n                        if ((c == \\'7\\' || c == \\'9\\') && i >= 4 && c == pressedKeys.charAt(i - 4)) {\\n                            dp[idx] = (dp[idx] + dp[(i - 4) % 5]) % MOD;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n % 5];\\n    }\\n```\n```python\\n    def countTexts(self, pressedKeys: str) -> int:\\n        dp = [1] + [0] * 4\\n        for i, c in enumerate(pressedKeys, 1):\\n            dp[i % 5] = dp[(i - 1) % 5]\\n            if i >= 2:    \\n                if c == pressedKeys[i - 2]:\\n                    dp[i % 5] += dp[(i - 2) % 5]\\n                    if i >= 3 and c == pressedKeys[i - 3]:\\n                        dp[i % 5] += dp[(i - 3) % 5]\\n                        if c in (\\'7\\', \\'9\\') and i >= 4 and c == pressedKeys[i - 4]:\\n                            dp[i % 5] += dp[(i - 4) % 5]\\n            dp[i % 5] %= 10 ** 9 + 7        \\n        return dp[len(pressedKeys) % 5]\\n```\n```java\\n    private static final int MOD = 1_000_000_007;\\n    public int countTexts(String pressedKeys) {\\n        int n = pressedKeys.length();\\n        int[] dp = new int[5];\\n        dp[0] = 1;\\n        for (int i = 1; i <= n; ++i) {\\n            char c = pressedKeys.charAt(i - 1);\\n            int idx = i % 5, lowBound = Math.max(0, i - (c == \\'7\\' || c == \\'9\\' ? 4 : 3));\\n            dp[idx] = dp[(i - 1) % 5];\\n            for (int j = i - 2; j >= lowBound && c == pressedKeys.charAt(j); --j) {\\n                dp[idx] = (dp[idx] + dp[j % 5]) % MOD; \\n            }\\n        }\\n        return dp[n % 5];\\n    }\\n```\n```python\\n    def countTexts(self, pressedKeys: str) -> int:\\n        dp = [1] + [0] * 4\\n        for i, c in enumerate(pressedKeys, 1):\\n            dp[i % 5] = dp[(i - 1) % 5]\\n            for j in range(i - 2, max(-1, i - 4 - (c in \\'79\\')), -1):\\n                if c == pressedKeys[j]:\\n                    dp[i % 5] += dp[j % 5]\\n                else:\\n                    break    \\n            dp[i % 5] %= 10 ** 9 + 7        \\n        return dp[len(pressedKeys) % 5]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2017755,
                "title": "simple-memoization-technique-o-n",
                "content": "**Intuition:** If the pressedString is \"222\", there can 3 different keys pressed: \\'a\\'(\"2\"), \\'b\\'(\"22\") or \\'c\\'(\"222\"). So for every repeated keys, there can be multiple combinations of texts. We store the max repeatations of a particular key in keys array, and then try all recursive paths to get the count of several combinations of keys that can be formed starting from a particular index. As we try all recursive paths, so there has to be many repeated calculations, which can be mitigated by memoisation.\\n\\n```\\nCode:\\nclass Solution {\\npublic:\\n    static const int mod = 1e9+7;\\n    int dp[100001];\\n    static constexpr int keys[10] = {0,0,3,3,3,3,3,4,3,4};  // key \\'1\\' and \\'0\\' not to be used\\n    int countTexts(string pressedKeys) {\\n        memset(dp, -1, sizeof(dp));\\n        return getCounts(pressedKeys, 0);\\n    }\\n    \\n    int getCounts(string &pressed, int idx) {\\n        if(idx == pressed.length())\\n            return 1;\\n        if(dp[idx] != -1)\\n            return dp[idx];\\n        int digit = pressed[idx]-\\'0\\'; long counts = 0;\\n        for(int i = 0; i < keys[digit] && idx+i < pressed.length() && pressed[idx] == pressed[idx+i]; i++) {\\n            counts += getCounts(pressed, idx+i+1);\\n            counts %= mod;\\n        }\\n        return dp[idx] = counts;\\n    }\\n};\\n```\\nKindly upvote if helpful to keep me motivated ^-^. Also comment down for any doubts.\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nCode:\\nclass Solution {\\npublic:\\n    static const int mod = 1e9+7;\\n    int dp[100001];\\n    static constexpr int keys[10] = {0,0,3,3,3,3,3,4,3,4};  // key \\'1\\' and \\'0\\' not to be used\\n    int countTexts(string pressedKeys) {\\n        memset(dp, -1, sizeof(dp));\\n        return getCounts(pressedKeys, 0);\\n    }\\n    \\n    int getCounts(string &pressed, int idx) {\\n        if(idx == pressed.length())\\n            return 1;\\n        if(dp[idx] != -1)\\n            return dp[idx];\\n        int digit = pressed[idx]-\\'0\\'; long counts = 0;\\n        for(int i = 0; i < keys[digit] && idx+i < pressed.length() && pressed[idx] == pressed[idx+i]; i++) {\\n            counts += getCounts(pressed, idx+i+1);\\n            counts %= mod;\\n        }\\n        return dp[idx] = counts;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017730,
                "title": "cpp-short-and-simple-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int func(string &s,int i,int n,vector<int> &dp){\\n        if(i>=n)return 1;\\n        if(dp[i]!=-1)return dp[i];\\n        int ans=0;\\n        if(i+1<n && s[i]==s[i+1]){\\n            ans+=func(s,i+2,n,dp);\\n            ans=ans%mod;\\n            if(i+2<n && s[i]==s[i+2]){\\n                ans+=func(s,i+3,n,dp);\\n                ans=ans%mod;\\n                if(i+3<n && s[i]==s[i+3] && (s[i]==\\'9\\' || s[i]==\\'7\\'))ans+=func(s,i+4,n,dp);\\n                ans=ans%mod;\\n            }\\n        }\\n        ans+=func(s,i+1,n,dp);\\n        ans=ans%mod;\\n        return dp[i]=ans;\\n    }\\n    int countTexts(string s) {\\n        int n=s.length();\\n        vector<int> dp(n+1,-1);\\n        return func(s,0,n,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int func(string &s,int i,int n,vector<int> &dp){\\n        if(i>=n)return 1;\\n        if(dp[i]!=-1)return dp[i];\\n        int ans=0;\\n        if(i+1<n && s[i]==s[i+1]){\\n            ans+=func(s,i+2,n,dp);\\n            ans=ans%mod;\\n            if(i+2<n && s[i]==s[i+2]){\\n                ans+=func(s,i+3,n,dp);\\n                ans=ans%mod;\\n                if(i+3<n && s[i]==s[i+3] && (s[i]==\\'9\\' || s[i]==\\'7\\'))ans+=func(s,i+4,n,dp);\\n                ans=ans%mod;\\n            }\\n        }\\n        ans+=func(s,i+1,n,dp);\\n        ans=ans%mod;\\n        return dp[i]=ans;\\n    }\\n    int countTexts(string s) {\\n        int n=s.length();\\n        vector<int> dp(n+1,-1);\\n        return func(s,0,n,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018250,
                "title": "c-solution-dp-bottom-up-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int countTexts(string s) {\\n        int n = s.size();\\n        int mod = 1e9 + 7;\\n        vector<int> dp(n + 1);\\n        dp[0] = 1;\\n        for (int i = 0; i < n; i++)\\n        {\\n            dp[i + 1] = dp[i];\\n            if (i > 0 and s[i] == s[i - 1])\\n            {\\n                dp[i + 1] = (dp[i + 1] + dp[i - 1]) % mod;\\n                if (i > 1 and s[i] == s[i - 2])\\n                {\\n                    dp[i + 1] = (dp[i + 1] + dp[i - 2]) % mod;\\n                    if (i > 2 and s[i] == s[i - 3] and (s[i] == \\'7\\' or s[i] == \\'9\\'))\\n                        dp[i + 1] = (dp[i + 1] + dp[i - 3]) % mod;\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countTexts(string s) {\\n        int n = s.size();\\n        int mod = 1e9 + 7;\\n        vector<int> dp(n + 1);\\n        dp[0] = 1;\\n        for (int i = 0; i < n; i++)\\n        {\\n            dp[i + 1] = dp[i];\\n            if (i > 0 and s[i] == s[i - 1])\\n            {\\n                dp[i + 1] = (dp[i + 1] + dp[i - 1]) % mod;\\n                if (i > 1 and s[i] == s[i - 2])\\n                {\\n                    dp[i + 1] = (dp[i + 1] + dp[i - 2]) % mod;\\n                    if (i > 2 and s[i] == s[i - 3] and (s[i] == \\'7\\' or s[i] == \\'9\\'))\\n                        dp[i + 1] = (dp[i + 1] + dp[i - 3]) % mod;\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2021877,
                "title": "c-dp-solution-o-n",
                "content": "Runtime: 32 ms, faster than 100.00% of C++ online submissions for Count Number of Texts.\\nMemory Usage: 19.3 MB, less than 40.00% of C++ online submissions for Count Number of Texts.\\n\\n\\n```\\nWe can calculate the letter combination count of each digit type for different length using DP.\\n\\nLetter combinations for digit 2,3,4,5,6,8 is same for length  1 to N as they all have 3 letters in their button\\n\\nBase case combinations: Length 1 to 3\\n\\nLength 1 => [2] => \\'a\\' => 1\\nLength 2 => [2,2] => \\'aa\\', \\'b\\' => 2\\nLength 3 =>  [2,2,2] => \\'aaa\\', \\'ab\\', \\'ba\\', \\'c\\' => 4\\n\\nNow for Length > 3 we can get combination count from previous length combinations\\nLength 4 => [2,2,2,2] => \\'aaaa\\', \\'aab\\', \\'aba\\', \\'ac\\' , \\'baa\\' , \\'bb\\', \\'ca\\'  => 7\\n\\nLet first letter as \\'a\\', which has length 1 => [2]\\nThen total letter combination of length 4 with first letter \\'a\\' is DP[4-1] = DP[3] =>  \\'aaaa\\', \\'aab\\', \\'aba\\', \\'ac\\' => 4\\n\\nLet first letter as \\'b\\', which has length 2 => [2,2]\\nThen total letter combination of length 4 with first letter \\'b\\' is DP[4-2] = DP[2] =>  \\'baa\\' , \\'bb\\' => 2\\n\\nLet first letter as \\'c\\', which has length 3 => [2,2,2]\\nThen total letter combination of length 4 with first letter \\'c\\' is DP[4-3] = DP[1] =>  \\'ca\\' => 1\\n\\nSo, total letter combination of Length 4 => DP[4-1] + DP[4-2] + DP[4-3] = 4 + 2 + 1 = 7 \\n\\nDP equation: DP[N] => DP[N-1] + DP[N-2] + DP[N-3]\\n\\nLetter combinations for digit 7 and 9 is same for length  0 to N as they all have 4 letters in their button\\n\\nBase case combinations: Length 1 to 4\\n\\nLength 1 => [7] => \\'p\\' => 1\\nLength 2 => [7,7] => \\'pp\\' or \\'q\\' => 2\\nLength 3 =>  [7,7,7] => \\'ppp\\', \\'pq\\', \\'qp\\', \\'r\\' => 4\\nLength 4 => [7,7,7,7] => \\'pppp\\', \\'ppq\\', \\'pqp\\', \\'pr\\', \\'qq\\', \\'qpp\\', \\'rp\\', \\'s\\' => 8\\n\\nSimilary as above, DP equation: DP[N] => DP[N-1] + DP[N-2] + DP[N-3] + DP[N-4]\\n\\nFirst we get the max frequency of each digit and their frequency chunks.\\nThen we generate letter combinations for 0 to max frequency of each digit in DP\\nThen we multiply the DP[X] of frequency chunks X of each digit as their letter combinations are independent.\\n```\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int countTexts(string pressed) {\\n        \\n        int MOD = 1000000007;\\n        int pl = pressed.length();\\n        \\n        // base case combinations for 2-9 digits of length 0 to 4\\n        vector<vector<int>>preDP = {{0,1,2,4},{0,1,2,4,8}};\\n            \\n        // store max freq of each digit and freq chunks\\n        int maxFreq[10] = {};\\n        vector<int>freq[10];\\n        \\n        int curr = -1;\\n        int count = 0;\\n        \\n        for(int i=0;i<pl;i++)\\n        {\\n            if(pressed[i]-\\'0\\' == curr)\\n            {\\n                count++;\\n                maxFreq[curr] = max(maxFreq[curr],count);\\n                freq[curr].back()++;\\n            }\\n            else\\n            {\\n                curr = pressed[i]-\\'0\\';\\n                count = 1;\\n                maxFreq[curr] = max(maxFreq[curr],count);\\n                freq[curr].push_back(count);\\n            }\\n        }\\n        \\n        vector<long long>dp(pl+1);\\n        unsigned long long totalCount = 1L;\\n        int type;\\n        for(int i=0;i<10;i++)\\n        {\\n            if(maxFreq[i]==0)continue;\\n            \\n            // get digit type\\n            type = (i==7 || i==9) ? 1 : 0;\\n            \\n            // store the base case combinations for length 0 to 4\\n            for(int j=0;j<=maxFreq[i] && j<=3+type;j++)\\n                dp[j] = preDP[type][j];\\n            \\n            // store combinations for length 5 to max freq of current digit \\n            for(int j=4+type;j<=maxFreq[i];j++)\\n                dp[j] = (dp[j-1]  + dp[j-2] + dp[j-3] + (type ? dp[j-4] : 0) + MOD)%MOD;\\n            \\n            // get the digit freq chunk multiplications as they are independent\\n            for(int j=0;j<freq[i].size();j++)\\n                totalCount = (totalCount%MOD * dp[freq[i][j]]%MOD) %MOD ;  \\n        }\\n        \\n        return (int)totalCount;\\n    }\\n};\\n```\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Combinatorics"
                ],
                "code": "```\\nWe can calculate the letter combination count of each digit type for different length using DP.\\n\\nLetter combinations for digit 2,3,4,5,6,8 is same for length  1 to N as they all have 3 letters in their button\\n\\nBase case combinations: Length 1 to 3\\n\\nLength 1 => [2] => \\'a\\' => 1\\nLength 2 => [2,2] => \\'aa\\', \\'b\\' => 2\\nLength 3 =>  [2,2,2] => \\'aaa\\', \\'ab\\', \\'ba\\', \\'c\\' => 4\\n\\nNow for Length > 3 we can get combination count from previous length combinations\\nLength 4 => [2,2,2,2] => \\'aaaa\\', \\'aab\\', \\'aba\\', \\'ac\\' , \\'baa\\' , \\'bb\\', \\'ca\\'  => 7\\n\\nLet first letter as \\'a\\', which has length 1 => [2]\\nThen total letter combination of length 4 with first letter \\'a\\' is DP[4-1] = DP[3] =>  \\'aaaa\\', \\'aab\\', \\'aba\\', \\'ac\\' => 4\\n\\nLet first letter as \\'b\\', which has length 2 => [2,2]\\nThen total letter combination of length 4 with first letter \\'b\\' is DP[4-2] = DP[2] =>  \\'baa\\' , \\'bb\\' => 2\\n\\nLet first letter as \\'c\\', which has length 3 => [2,2,2]\\nThen total letter combination of length 4 with first letter \\'c\\' is DP[4-3] = DP[1] =>  \\'ca\\' => 1\\n\\nSo, total letter combination of Length 4 => DP[4-1] + DP[4-2] + DP[4-3] = 4 + 2 + 1 = 7 \\n\\nDP equation: DP[N] => DP[N-1] + DP[N-2] + DP[N-3]\\n\\nLetter combinations for digit 7 and 9 is same for length  0 to N as they all have 4 letters in their button\\n\\nBase case combinations: Length 1 to 4\\n\\nLength 1 => [7] => \\'p\\' => 1\\nLength 2 => [7,7] => \\'pp\\' or \\'q\\' => 2\\nLength 3 =>  [7,7,7] => \\'ppp\\', \\'pq\\', \\'qp\\', \\'r\\' => 4\\nLength 4 => [7,7,7,7] => \\'pppp\\', \\'ppq\\', \\'pqp\\', \\'pr\\', \\'qq\\', \\'qpp\\', \\'rp\\', \\'s\\' => 8\\n\\nSimilary as above, DP equation: DP[N] => DP[N-1] + DP[N-2] + DP[N-3] + DP[N-4]\\n\\nFirst we get the max frequency of each digit and their frequency chunks.\\nThen we generate letter combinations for 0 to max frequency of each digit in DP\\nThen we multiply the DP[X] of frequency chunks X of each digit as their letter combinations are independent.\\n```\n```\\nclass Solution {\\npublic:\\n    int countTexts(string pressed) {\\n        \\n        int MOD = 1000000007;\\n        int pl = pressed.length();\\n        \\n        // base case combinations for 2-9 digits of length 0 to 4\\n        vector<vector<int>>preDP = {{0,1,2,4},{0,1,2,4,8}};\\n            \\n        // store max freq of each digit and freq chunks\\n        int maxFreq[10] = {};\\n        vector<int>freq[10];\\n        \\n        int curr = -1;\\n        int count = 0;\\n        \\n        for(int i=0;i<pl;i++)\\n        {\\n            if(pressed[i]-\\'0\\' == curr)\\n            {\\n                count++;\\n                maxFreq[curr] = max(maxFreq[curr],count);\\n                freq[curr].back()++;\\n            }\\n            else\\n            {\\n                curr = pressed[i]-\\'0\\';\\n                count = 1;\\n                maxFreq[curr] = max(maxFreq[curr],count);\\n                freq[curr].push_back(count);\\n            }\\n        }\\n        \\n        vector<long long>dp(pl+1);\\n        unsigned long long totalCount = 1L;\\n        int type;\\n        for(int i=0;i<10;i++)\\n        {\\n            if(maxFreq[i]==0)continue;\\n            \\n            // get digit type\\n            type = (i==7 || i==9) ? 1 : 0;\\n            \\n            // store the base case combinations for length 0 to 4\\n            for(int j=0;j<=maxFreq[i] && j<=3+type;j++)\\n                dp[j] = preDP[type][j];\\n            \\n            // store combinations for length 5 to max freq of current digit \\n            for(int j=4+type;j<=maxFreq[i];j++)\\n                dp[j] = (dp[j-1]  + dp[j-2] + dp[j-3] + (type ? dp[j-4] : 0) + MOD)%MOD;\\n            \\n            // get the digit freq chunk multiplications as they are independent\\n            for(int j=0;j<freq[i].size();j++)\\n                totalCount = (totalCount%MOD * dp[freq[i][j]]%MOD) %MOD ;  \\n        }\\n        \\n        return (int)totalCount;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2021692,
                "title": "c-dp-o-n-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int M=1e9+7;\\n    int countTexts(string s) {\\n        int n=s.size();\\n        vector<long long> dp(n+1);\\n        dp[0]=1;\\n        for(int i=1;i<=n;i++){\\n            //firstly if character is same or different then copy last value.\\n            dp[i]=dp[i-1];\\n            //if last two characters are same then also last that value.\\n            if((i-2)>=0 && s[i-1]==s[i-2])\\n                dp[i]=(dp[i]+dp[i-2])%M;\\n            else\\n                continue;\\n            //if last 3 characters are same then also add that value.\\n            if((i-3)>=0 && s[i-1]==s[i-3])\\n                dp[i]=(dp[i]+dp[i-3])%M;\\n            else\\n                continue;\\n            //if we have 7 or 9 as characters we have to also check for 4th character.\\n            if((s[i-1]==\\'7\\' || s[i-1]==\\'9\\') && (i-4)>=0 && s[i-1]==s[i-4])\\n                dp[i]=(dp[i]+dp[i-4])%M;\\n        }\\n        return dp[n]%M;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int M=1e9+7;\\n    int countTexts(string s) {\\n        int n=s.size();\\n        vector<long long> dp(n+1);\\n        dp[0]=1;\\n        for(int i=1;i<=n;i++){\\n            //firstly if character is same or different then copy last value.\\n            dp[i]=dp[i-1];\\n            //if last two characters are same then also last that value.\\n            if((i-2)>=0 && s[i-1]==s[i-2])\\n                dp[i]=(dp[i]+dp[i-2])%M;\\n            else\\n                continue;\\n            //if last 3 characters are same then also add that value.\\n            if((i-3)>=0 && s[i-1]==s[i-3])\\n                dp[i]=(dp[i]+dp[i-3])%M;\\n            else\\n                continue;\\n            //if we have 7 or 9 as characters we have to also check for 4th character.\\n            if((s[i-1]==\\'7\\' || s[i-1]==\\'9\\') && (i-4)>=0 && s[i-1]==s[i-4])\\n                dp[i]=(dp[i]+dp[i-4])%M;\\n        }\\n        return dp[n]%M;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2019195,
                "title": "easy-memoization-o-n-time-c-with-explanation-with-comments",
                "content": "The simplest way to cache sub problems is to break this problem to :\\ntotal ways=No of ways to have one alphabet * number of ways of rest of the string.\\nWe dont have length of rest of the remaining string constant...like 6+rest, 66+rest\\' map to \\'m\\'+rest  and \\'n\\'+rest\\' respectively.\\nSo we iterate  ```No of ways to to have one alphabet```  and add  ``` number of ways of rest of the string```   in each iteration.\\n```\\nclass Solution {\\npublic:\\n    const int M=1000000007;\\n    vector<int>dp;\\n    int count(string &s,int i)\\n    {\\n        if(i==s.size())return 1;\\n        if(dp[i]!=-1)return dp[i];\\n        int no=3;//number of characters in the button\\n        if(s[i]==\\'7\\'||s[i]==\\'9\\')no=4;\\n        int ans=0,len=0;\\n        for(int j=i;j<i+no&&j<s.size();j++) //looping over possible alphabets out of the consecutively same  button press.\\n        {\\n            if(s[j]==s[i])ans=(ans+count(s,j+1))%M;//adding number of ways to have the rest of the string\\n                else break;\\n        }\\n        return dp[i]=ans;\\n        \\n    }\\n    int countTexts(string s) {\\n        dp.resize(s.size(),-1);\\n        return count(s,0);\\n    }\\n};\\n```\\nPlease upvote if you find the solution helping.",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```No of ways to to have one alphabet```\n``` number of ways of rest of the string```\n```\\nclass Solution {\\npublic:\\n    const int M=1000000007;\\n    vector<int>dp;\\n    int count(string &s,int i)\\n    {\\n        if(i==s.size())return 1;\\n        if(dp[i]!=-1)return dp[i];\\n        int no=3;//number of characters in the button\\n        if(s[i]==\\'7\\'||s[i]==\\'9\\')no=4;\\n        int ans=0,len=0;\\n        for(int j=i;j<i+no&&j<s.size();j++) //looping over possible alphabets out of the consecutively same  button press.\\n        {\\n            if(s[j]==s[i])ans=(ans+count(s,j+1))%M;//adding number of ways to have the rest of the string\\n                else break;\\n        }\\n        return dp[i]=ans;\\n        \\n    }\\n    int countTexts(string s) {\\n        dp.resize(s.size(),-1);\\n        return count(s,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018536,
                "title": "c-for-everyone-who-are-scared-of-dp-like-me",
                "content": "* So I experimented with `2`, `22`, `222` and realised that for `2222` the answer is the sum of previous 3 and this goes on.\\n* Now after doing this I was stuck thinking all the numbers have 3 letters but for `7` and `9`, the story is different since they have 4 letters.\\n* So I experimented **again** with `9`, `99`, `999`, `9999` and realised that for `99999` the answer is the sum of previous 4 and this goes on.\\n* And Boom **AC**.\\n\\n`//Experiment part`\\nWhy we do `dp[n] = dp[n-1] + dp[n-2] + dp[n-3]` ?\\nBecause we have 3 options,\\nLets take example of `22222`.\\n\\n`22222` = `2|2222` + `22|222` + `222|22`.\\nBasically we select the first (1-3) numbers and rest are already calculated.\\n**Note:** we can\\'t have a combination like this `2222|2` since four 2\\'s don\\'t make any combination(in case of 2 but in case of 7 and 9 its does and therefore the summation goes till `dp[n-4]` there).\\n\\n```\\nconst int mod = 1e9 + 7;\\nconst int mxx = 1e5 + 1;\\n#define ll long long\\nclass Solution {\\npublic:\\n    vector<int> a, b;\\n    \\n    Solution()\\n    {\\n        a.resize(mxx, 0);\\n        a[1] = 1;\\n        a[2] = 2;\\n        a[3] = 4;\\n        \\n        for(int i=4; i<=1e5; i++)\\n        {\\n            a[i] = ((a[i-1] + a[i-2]) % mod + a[i-3]) % mod;\\n        }\\n        \\n        b.resize(mxx, 0);\\n        b[1] = 1;\\n        b[2] = 2;\\n        b[3] = 4;\\n        b[4] = 8;\\n        \\n        for(int i=5; i<=1e5; i++)\\n        {\\n            b[i] = ((((b[i-1] + b[i-2]) % mod + b[i-3]) % mod) + b[i-4]) % mod;\\n        }\\n    }\\n    \\n    int countTexts(string s) {\\n        int n = s.size();\\n        int ans = 1;\\n        \\n        int cnt = 1;\\n        int i = 0;\\n        while(i+1 < n)\\n        {\\n            while(i+1 < n && s[i] == s[i+1]) \\n            {\\n                cnt++;\\n                i++;\\n            }\\n            // cout << a[cnt] << \" \";\\n            if(s[i] != \\'7\\' && s[i] != \\'9\\')\\n                ans = ((ll)ans * (ll)a[cnt]) % mod;\\n            else\\n                ans = ((ll)ans * (ll)b[cnt]) % mod;\\n            \\n            cnt = 1;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nActually the `experimented` part is something which is really hard for me explain. Do some experiment on your own and maybe it will click.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nconst int mod = 1e9 + 7;\\nconst int mxx = 1e5 + 1;\\n#define ll long long\\nclass Solution {\\npublic:\\n    vector<int> a, b;\\n    \\n    Solution()\\n    {\\n        a.resize(mxx, 0);\\n        a[1] = 1;\\n        a[2] = 2;\\n        a[3] = 4;\\n        \\n        for(int i=4; i<=1e5; i++)\\n        {\\n            a[i] = ((a[i-1] + a[i-2]) % mod + a[i-3]) % mod;\\n        }\\n        \\n        b.resize(mxx, 0);\\n        b[1] = 1;\\n        b[2] = 2;\\n        b[3] = 4;\\n        b[4] = 8;\\n        \\n        for(int i=5; i<=1e5; i++)\\n        {\\n            b[i] = ((((b[i-1] + b[i-2]) % mod + b[i-3]) % mod) + b[i-4]) % mod;\\n        }\\n    }\\n    \\n    int countTexts(string s) {\\n        int n = s.size();\\n        int ans = 1;\\n        \\n        int cnt = 1;\\n        int i = 0;\\n        while(i+1 < n)\\n        {\\n            while(i+1 < n && s[i] == s[i+1]) \\n            {\\n                cnt++;\\n                i++;\\n            }\\n            // cout << a[cnt] << \" \";\\n            if(s[i] != \\'7\\' && s[i] != \\'9\\')\\n                ans = ((ll)ans * (ll)a[cnt]) % mod;\\n            else\\n                ans = ((ll)ans * (ll)b[cnt]) % mod;\\n            \\n            cnt = 1;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2017834,
                "title": "python3-group-by-group",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/9aa0edb0815f3e0a75a47808e1690ca424f169e5) for solutions of weekly 292. \\n\\n```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        MOD = 1_000_000_007 \\n        \\n        @cache \\n        def fn(n, k): \\n            \"\"\"Return number of possible text of n repeated k times.\"\"\"\\n            if n < 0: return 0\\n            if n == 0: return 1\\n            ans = 0\\n            for x in range(1, k+1): ans = (ans + fn(n-x, k)) % MOD\\n            return ans \\n        \\n        ans = 1\\n        for key, grp in groupby(pressedKeys): \\n            if key in \"79\": k = 4\\n            else: k = 3\\n            ans = (ans * fn(len(list(grp)), k)) % MOD \\n        return ans \\n```\\n\\nAdded a shorter implementation \\n```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        dp = [0] * (len(pressedKeys)+1)\\n        dp[0] = 1\\n        for i, ch in enumerate(pressedKeys):\\n            dp[i+1] = dp[i]\\n            if i and pressedKeys[i-1] == ch: \\n                dp[i+1] += dp[i-1]\\n                if i >= 2 and pressedKeys[i-2] == ch: \\n                    dp[i+1] += dp[i-2]\\n                    if i >= 3 and pressedKeys[i-3] == ch and ch in \"79\": dp[i+1] += dp[i-3]\\n            dp[i+1] %= 1_000_000_007\\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        MOD = 1_000_000_007 \\n        \\n        @cache \\n        def fn(n, k): \\n            \"\"\"Return number of possible text of n repeated k times.\"\"\"\\n            if n < 0: return 0\\n            if n == 0: return 1\\n            ans = 0\\n            for x in range(1, k+1): ans = (ans + fn(n-x, k)) % MOD\\n            return ans \\n        \\n        ans = 1\\n        for key, grp in groupby(pressedKeys): \\n            if key in \"79\": k = 4\\n            else: k = 3\\n            ans = (ans * fn(len(list(grp)), k)) % MOD \\n        return ans \\n```\n```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        dp = [0] * (len(pressedKeys)+1)\\n        dp[0] = 1\\n        for i, ch in enumerate(pressedKeys):\\n            dp[i+1] = dp[i]\\n            if i and pressedKeys[i-1] == ch: \\n                dp[i+1] += dp[i-1]\\n                if i >= 2 and pressedKeys[i-2] == ch: \\n                    dp[i+1] += dp[i-2]\\n                    if i >= 3 and pressedKeys[i-3] == ch and ch in \"79\": dp[i+1] += dp[i-3]\\n            dp[i+1] %= 1_000_000_007\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018347,
                "title": "python-top-down-dp-time-o-4-n-easy-understanding",
                "content": "The result is solely impacted by the following four digits at index i.\\nNote that using MOD everywhere can save you a lot of time!\\n\\nTime: O(4*n)\\n\\n``` py\\nclass Solution:\\n    def countTexts(self, A: str) -> int:\\n        mp = set([\"2\", \"22\", \"222\",\\n                  \"3\", \"33\", \"333\",\\n                  \\'4\\', \\'44\\', \\'444\\',\\n                  \\'5\\', \\'55\\', \\'555\\',\\n                  \\'6\\', \\'66\\', \\'666\\',\\n                  \\'7\\', \\'77\\', \\'777\\', \\'7777\\', \\n                  \\'8\\', \\'88\\', \\'888\\', \\n                  \\'9\\', \\'99\\', \\'999\\', \\'9999\\'])\\n        MOD = 10**9+7\\n        \\n        @cache\\n        def dp(i):\\n            if i>=len(A): return 1\\n            ans = 0\\n            if i+1<=len(A) and A[i:i+1] in mp: ans += dp(i+1)%MOD\\n            if i+2<=len(A) and A[i:i+2] in mp: ans += dp(i+2)%MOD\\n            if i+3<=len(A) and A[i:i+3] in mp: ans += dp(i+3)%MOD\\n            if i+4<=len(A) and A[i:i+4] in mp: ans += dp(i+4)%MOD\\n            return ans%MOD\\n        \\n        return dp(0)%MOD\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "``` py\\nclass Solution:\\n    def countTexts(self, A: str) -> int:\\n        mp = set([\"2\", \"22\", \"222\",\\n                  \"3\", \"33\", \"333\",\\n                  \\'4\\', \\'44\\', \\'444\\',\\n                  \\'5\\', \\'55\\', \\'555\\',\\n                  \\'6\\', \\'66\\', \\'666\\',\\n                  \\'7\\', \\'77\\', \\'777\\', \\'7777\\', \\n                  \\'8\\', \\'88\\', \\'888\\', \\n                  \\'9\\', \\'99\\', \\'999\\', \\'9999\\'])\\n        MOD = 10**9+7\\n        \\n        @cache\\n        def dp(i):\\n            if i>=len(A): return 1\\n            ans = 0\\n            if i+1<=len(A) and A[i:i+1] in mp: ans += dp(i+1)%MOD\\n            if i+2<=len(A) and A[i:i+2] in mp: ans += dp(i+2)%MOD\\n            if i+3<=len(A) and A[i:i+3] in mp: ans += dp(i+3)%MOD\\n            if i+4<=len(A) and A[i:i+4] in mp: ans += dp(i+4)%MOD\\n            return ans%MOD\\n        \\n        return dp(0)%MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3786290,
                "title": "recursion-memoization-c-with-explanation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**If a substring contains the same characters (\\'22...\\', \\'9999......\\', \\'5555......\\',..............) How many text are possible by this substring**................................\\uD83E\\uDD14\\n\\n**Think about the above statement and try to write the code...........**\\n\\nhere the approach is simple that we are counting the possible text for a substring that has the same characters and multiplying all the results to get all the possible text.\\n\\n\\n```\\nFor example:- p = \\'222544\\'\\nsubstring with same characters = \\'222\\', \\'5\\', \\'44\\'\\n\\'222\\' Possible texts:- \\'a\\', \\'ba\\', \\'ab\\', \\'c\\'(4)\\n\\'5\\' Possible texts:- \\'j\\'(1)\\n\\'44\\' Possible texts:- \\'gg\\',\\'h\\'(2)\\n\\nNumber of all possible texts = 4 * 1 * 2 = 8\\n```\\n**Note:-**\\nHere you can see that after enumerating the possible text for a substring I removed all the entries from dp as the previous entry of the same character became invalid so I did that.\\n\\n```\\nFor example:- p = \\'222322\\'\\nHere we can see that \\'2\\' appears in two substrings:-\\n          str1 = \\'222\\' and str2 = \\'22\\'\\n\\nWhen enumerating possible text for str-2, all previous entries\\nstr-1 became invalid so we need to remove them.\\n```\\n# Complexity\\n- Time complexity:O(N*log(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    map<pair<int,char>,int> dp;\\n    int mod = 1e9+7;\\n    long long solve(char c,long long n,long long i)\\n    {\\n        if(i>n) return 0;\\n        if(i>=n-1) return 1;\\n        if(dp.find({i,c})!=dp.end()) return dp[{i,c}];\\n        long long c1 = solve(c,n,i+1);\\n        long long c2 = solve(c,n,i+2);\\n        long long c3 = solve(c,n,i+3);\\n        long long c4 = solve(c,n,i+4);\\n\\n        if(c==\\'7\\' || c==\\'9\\')\\n        return dp[{i,c}] = (c1+c2+c3+c4)%mod;\\n        \\n        return dp[{i,c}] = (c1+c2+c3)%mod;\\n    }\\n    int countTexts(string p) {\\n       long long count = 1,ans = 1;\\n       for(int i = 1;i<p.size();i++)\\n       {\\n           if(p[i]==p[i-1]) count++;\\n           if(p[i]!=p[i-1] || i==p.size()-1)\\n           {\\n               int x = solve(p[i-1],count,0)%mod;\\n               dp.clear();\\n               ans  = ((ans%mod)*(x%mod))%mod;\\n               count = 1;\\n           }\\n       }\\n       return ans%mod;\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/347a58e4-fc48-4a72-a4dc-b53ecd812bfa_1689747372.1231217.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nFor example:- p = \\'222544\\'\\nsubstring with same characters = \\'222\\', \\'5\\', \\'44\\'\\n\\'222\\' Possible texts:- \\'a\\', \\'ba\\', \\'ab\\', \\'c\\'(4)\\n\\'5\\' Possible texts:- \\'j\\'(1)\\n\\'44\\' Possible texts:- \\'gg\\',\\'h\\'(2)\\n\\nNumber of all possible texts = 4 * 1 * 2 = 8\\n```\n```\\nFor example:- p = \\'222322\\'\\nHere we can see that \\'2\\' appears in two substrings:-\\n          str1 = \\'222\\' and str2 = \\'22\\'\\n\\nWhen enumerating possible text for str-2, all previous entries\\nstr-1 became invalid so we need to remove them.\\n```\n```\\nclass Solution {\\npublic:\\n    map<pair<int,char>,int> dp;\\n    int mod = 1e9+7;\\n    long long solve(char c,long long n,long long i)\\n    {\\n        if(i>n) return 0;\\n        if(i>=n-1) return 1;\\n        if(dp.find({i,c})!=dp.end()) return dp[{i,c}];\\n        long long c1 = solve(c,n,i+1);\\n        long long c2 = solve(c,n,i+2);\\n        long long c3 = solve(c,n,i+3);\\n        long long c4 = solve(c,n,i+4);\\n\\n        if(c==\\'7\\' || c==\\'9\\')\\n        return dp[{i,c}] = (c1+c2+c3+c4)%mod;\\n        \\n        return dp[{i,c}] = (c1+c2+c3)%mod;\\n    }\\n    int countTexts(string p) {\\n       long long count = 1,ans = 1;\\n       for(int i = 1;i<p.size();i++)\\n       {\\n           if(p[i]==p[i-1]) count++;\\n           if(p[i]!=p[i-1] || i==p.size()-1)\\n           {\\n               int x = solve(p[i-1],count,0)%mod;\\n               dp.clear();\\n               ans  = ((ans%mod)*(x%mod))%mod;\\n               count = 1;\\n           }\\n       }\\n       return ans%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2024229,
                "title": "c-o-n-solution-with-explanation",
                "content": "At any point you have couple of things to do and that is you can choose current character \\n\\n1. As a single character so the answer will be what was at i-1 index because you\\'re adding current character as single character \\n\\n2. Taking current character with last so i-2 will be the added to the answer\\n3. Taking till i-2 character so i-3 will be added to answer\\n4. In case of 7, 9 Taking i-3 character so i-4 will be added to the answer\\n\\nHere is an example to that\\n\\nsuppose we have 222\\n\\nfor i = 0 we can only get \\na\\n\\nfor i = 1 we can get\\naa b\\n\\nfor i = 2 we can get\\n\\n(First taking current character as single)\\naa-a (2-2-2)\\nb-a (22-2)\\n\\n(Taking current with last)\\na-b (2-22)\\n\\nTaking till i-2\\nc (222)\\n\\nIn the solution we\\'ll first calculate the combinations\\n\\n\\n```\\n#define mod 1000000007\\n#define ll long long int\\nclass Solution {\\npublic:\\n    int countTexts(string s) {\\n        \\n        int n = s.size();\\n        \\n        if(n<3){\\n            return n;\\n        }\\n        \\n        ll ans = 1;\\n        vector<ll> dp1(n+1,0);\\n        vector<ll> dp2(n+1,0);\\n        \\n        dp1[0] = 1;\\n        dp1[1] = 1;\\n        dp1[2] = 2;\\n        \\n        dp2[0] = 1;\\n        dp2[1] = 1;\\n        dp2[2] = 2;\\n        dp2[3] = 4;\\n        \\n        for(int i = 3 ; i <= n ; i++)    \\n            dp1[i] = (dp1[i-1] + dp1[i-2] + dp1[i-3])%mod;\\n        \\n        for(int i = 4 ; i <= n ; i++)    //for 7 & 9\\n            dp2[i] = (dp2[i-1] + dp2[i-2] + dp2[i-3] + dp2[i-4])%mod;\\n        \\n        int i = 0;\\n        \\n        int start = -1;\\n        \\n        while(i<n-1){\\n            \\n            while(i<n-1 && s[i]==s[i+1])//finding the length same consecutive characters\\n                i++;\\n            \\n            int len = i-start;\\n            \\n            if(s[i]==\\'7\\' || s[i]==\\'9\\')\\n                ans = (ans*dp2[len])%mod; //multiplying because for 2 different consecutive characters we can\\'t add for ex if at first place we have 2 options and for place two also 2 option then if we combine we\\'ll have 4 options in total for better understanding see example 1 of the question\\n            else\\n                ans = (ans*dp1[len])%mod;\\n            \\n            start = i;\\n            \\n            i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define mod 1000000007\\n#define ll long long int\\nclass Solution {\\npublic:\\n    int countTexts(string s) {\\n        \\n        int n = s.size();\\n        \\n        if(n<3){\\n            return n;\\n        }\\n        \\n        ll ans = 1;\\n        vector<ll> dp1(n+1,0);\\n        vector<ll> dp2(n+1,0);\\n        \\n        dp1[0] = 1;\\n        dp1[1] = 1;\\n        dp1[2] = 2;\\n        \\n        dp2[0] = 1;\\n        dp2[1] = 1;\\n        dp2[2] = 2;\\n        dp2[3] = 4;\\n        \\n        for(int i = 3 ; i <= n ; i++)    \\n            dp1[i] = (dp1[i-1] + dp1[i-2] + dp1[i-3])%mod;\\n        \\n        for(int i = 4 ; i <= n ; i++)    //for 7 & 9\\n            dp2[i] = (dp2[i-1] + dp2[i-2] + dp2[i-3] + dp2[i-4])%mod;\\n        \\n        int i = 0;\\n        \\n        int start = -1;\\n        \\n        while(i<n-1){\\n            \\n            while(i<n-1 && s[i]==s[i+1])//finding the length same consecutive characters\\n                i++;\\n            \\n            int len = i-start;\\n            \\n            if(s[i]==\\'7\\' || s[i]==\\'9\\')\\n                ans = (ans*dp2[len])%mod; //multiplying because for 2 different consecutive characters we can\\'t add for ex if at first place we have 2 options and for place two also 2 option then if we combine we\\'ll have 4 options in total for better understanding see example 1 of the question\\n            else\\n                ans = (ans*dp1[len])%mod;\\n            \\n            start = i;\\n            \\n            i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2374298,
                "title": "python-sliding-window-o-1-space",
                "content": "```\\nfrom collections import deque\\n\\n\\nclass Solution:\\n    \\n    def countTexts(self, pressed_keys: str) -> int:\\n        \\n        key_letters = {\\n            \"2\": 3,\\n            \"3\": 3,\\n            \"4\": 3,\\n            \"5\": 3,\\n            \"6\": 3,\\n            \"7\": 4,\\n            \"8\": 3,\\n            \"9\": 4,\\n        }\\n        \\n        ans = 1\\n        current_count = 1\\n        prev_key = \"\" \\n        previous = deque([]) \\n        \\n        for pressed_key in pressed_keys:\\n            \\n            if pressed_key != prev_key:\\n                ans = (ans * current_count) % (10**9 + 7)\\n                previous = deque([1])\\n                current_count = 1 \\n                prev_key = pressed_key\\n            \\n            current_count = sum(previous) \\n            \\n            if len(previous) == key_letters[pressed_key]:\\n                previous.popleft()\\n                \\n            previous.append(current_count)\\n             \\n        ans = (ans * current_count) % (10**9 + 7)\\n        \\n        return ans\\n    \\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque\\n\\n\\nclass Solution:\\n    \\n    def countTexts(self, pressed_keys: str) -> int:\\n        \\n        key_letters = {\\n            \"2\": 3,\\n            \"3\": 3,\\n            \"4\": 3,\\n            \"5\": 3,\\n            \"6\": 3,\\n            \"7\": 4,\\n            \"8\": 3,\\n            \"9\": 4,\\n        }\\n        \\n        ans = 1\\n        current_count = 1\\n        prev_key = \"\" \\n        previous = deque([]) \\n        \\n        for pressed_key in pressed_keys:\\n            \\n            if pressed_key != prev_key:\\n                ans = (ans * current_count) % (10**9 + 7)\\n                previous = deque([1])\\n                current_count = 1 \\n                prev_key = pressed_key\\n            \\n            current_count = sum(previous) \\n            \\n            if len(previous) == key_letters[pressed_key]:\\n                previous.popleft()\\n                \\n            previous.append(current_count)\\n             \\n        ans = (ans * current_count) % (10**9 + 7)\\n        \\n        return ans\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2126835,
                "title": "javascript-solution-dp",
                "content": "```\\nvar countTexts = function(pressedKeys) {\\n    const MOD = 1e9 + 7;\\n    const n = pressedKeys.length;\\n    const dp = new Array(n + 1).fill(0);\\n    \\n    dp[0] = 1;\\n    \\n    let lastChar = \"\";\\n    let repeatCount = 0;\\n    \\n    for (let i = 1; i <= n; ++i) {\\n        const currChar = pressedKeys[i - 1];\\n        \\n        if (currChar != lastChar) repeatCount = 0;\\n        \\n        lastChar = currChar;\\n        repeatCount += 1;\\n        \\n        dp[i] = (dp[i] + dp[i - 1]) % MOD;\\n        \\n        if (i >= 2 && repeatCount >= 2) dp[i] = (dp[i] + dp[i - 2]) % MOD;\\n        if (i >= 3 && repeatCount >= 3) dp[i] = (dp[i] + dp[i - 3]) % MOD;\\n        if ((currChar == \"7\"  || currChar == \"9\") && i >= 4 && repeatCount >= 4) dp[i] = (dp[i] + dp[i - 4]) % MOD;\\n     }\\n    \\n    return dp[n];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar countTexts = function(pressedKeys) {\\n    const MOD = 1e9 + 7;\\n    const n = pressedKeys.length;\\n    const dp = new Array(n + 1).fill(0);\\n    \\n    dp[0] = 1;\\n    \\n    let lastChar = \"\";\\n    let repeatCount = 0;\\n    \\n    for (let i = 1; i <= n; ++i) {\\n        const currChar = pressedKeys[i - 1];\\n        \\n        if (currChar != lastChar) repeatCount = 0;\\n        \\n        lastChar = currChar;\\n        repeatCount += 1;\\n        \\n        dp[i] = (dp[i] + dp[i - 1]) % MOD;\\n        \\n        if (i >= 2 && repeatCount >= 2) dp[i] = (dp[i] + dp[i - 2]) % MOD;\\n        if (i >= 3 && repeatCount >= 3) dp[i] = (dp[i] + dp[i - 3]) % MOD;\\n        if ((currChar == \"7\"  || currChar == \"9\") && i >= 4 && repeatCount >= 4) dp[i] = (dp[i] + dp[i - 4]) % MOD;\\n     }\\n    \\n    return dp[n];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2020148,
                "title": "10-line-dp-python-o-n-o-1-beat-100-100-a-easy-bottom-up",
                "content": "```\\nclass Solution(object):\\n    def countTexts(self, keys):\\n        dic = {\\'2\\': 3, \\'3\\': 3, \\'4\\':3, \\'5\\':3, \\'6\\':3, \\'7\\':4, \\'8\\': 3, \\'9\\':4 } # dictionary!\\n        \\n        # e.g  dp means all possibilities ending now. 4 status totaly dp2 means we quickly press same num for 2 times. (33)-->e\\n        dp1, dp2, dp3, dp4 = 1, 0, 0, 0   # assuming we passed first key, dp1 is 1\\n\\t\\t\\n        for i in range(1, len(keys)):\\n            if keys[i] == keys[i-1]: # if same with before, this is how we inherit\\n                dp1, dp2, dp3, dp4 = (dp1 + dp2 + dp3 + dp4) % (10**9+7), dp1, dp2, 0 if dic[keys[i]] == 3 else dp3\\n            else: # and when not same, this is how we inherit\\n                dp1, dp2, dp3, dp4 = (dp1 + dp2 + dp3 + dp4) % (10**9+7), 0, 0, 0\\n\\t\\t\\t\\t\\n        return (dp1 + dp2 + dp3 + dp4) % (10**9+7)\\n\\t\\t\\n\\t\\t\\nActually the status is pretty clear. There are 3-4 status when ending at each index among the keys, and status transfer is also clear to see. \\n```\\n\\n\\n\\n\\n```\\n#Also here\\'s top-down dp ( = dfs + memo). Same time complexity, O(N) space. \\nclass Solution:\\n    def countTexts(self, keys: str) -> int:\\n        \\n        dic = {\\'2\\': 3, \\'3\\': 3, \\'4\\':3, \\'5\\':3, \\'6\\':3, \\'7\\':4, \\'8\\': 3, \\'9\\':4 }\\n\\n        @lru_cache(None)\\n        def dp(i, acc):\\n            if i == 0:\\n                if acc == 1:\\n                    return 1\\n                return 0\\n\\n            if acc == 1:\\n                return sum([ dp(i-1, k) for k in range(1, dic[keys[i-1]] +1) ]) % (10**9+7)\\n            \\n            if keys[i] == keys[i-1]:\\n                return dp(i-1, acc-1)\\n            \\n            return 0\\n        \\n        return sum([ dp(len(keys)-1, k) for k in range(1, dic[keys[-1]]+1) ]) % (10**9+7)\\n    ```\\n\\t\\n\\n\\t",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def countTexts(self, keys):\\n        dic = {\\'2\\': 3, \\'3\\': 3, \\'4\\':3, \\'5\\':3, \\'6\\':3, \\'7\\':4, \\'8\\': 3, \\'9\\':4 } # dictionary!\\n        \\n        # e.g  dp means all possibilities ending now. 4 status totaly dp2 means we quickly press same num for 2 times. (33)-->e\\n        dp1, dp2, dp3, dp4 = 1, 0, 0, 0   # assuming we passed first key, dp1 is 1\\n\\t\\t\\n        for i in range(1, len(keys)):\\n            if keys[i] == keys[i-1]: # if same with before, this is how we inherit\\n                dp1, dp2, dp3, dp4 = (dp1 + dp2 + dp3 + dp4) % (10**9+7), dp1, dp2, 0 if dic[keys[i]] == 3 else dp3\\n            else: # and when not same, this is how we inherit\\n                dp1, dp2, dp3, dp4 = (dp1 + dp2 + dp3 + dp4) % (10**9+7), 0, 0, 0\\n\\t\\t\\t\\t\\n        return (dp1 + dp2 + dp3 + dp4) % (10**9+7)\\n\\t\\t\\n\\t\\t\\nActually the status is pretty clear. There are 3-4 status when ending at each index among the keys, and status transfer is also clear to see. \\n```\n```\\n#Also here\\'s top-down dp ( = dfs + memo). Same time complexity, O(N) space. \\nclass Solution:\\n    def countTexts(self, keys: str) -> int:\\n        \\n        dic = {\\'2\\': 3, \\'3\\': 3, \\'4\\':3, \\'5\\':3, \\'6\\':3, \\'7\\':4, \\'8\\': 3, \\'9\\':4 }\\n\\n        @lru_cache(None)\\n        def dp(i, acc):\\n            if i == 0:\\n                if acc == 1:\\n                    return 1\\n                return 0\\n\\n            if acc == 1:\\n                return sum([ dp(i-1, k) for k in range(1, dic[keys[i-1]] +1) ]) % (10**9+7)\\n            \\n            if keys[i] == keys[i-1]:\\n                return dp(i-1, acc-1)\\n            \\n            return 0\\n        \\n        return sum([ dp(len(keys)-1, k) for k in range(1, dic[keys[-1]]+1) ]) % (10**9+7)\\n    ```",
                "codeTag": "Java"
            },
            {
                "id": 2019026,
                "title": "javascript-coin-change-dp-113ms",
                "content": "```\\nconst mod = 1e9 + 7;\\nconst cal = (c) => c == \\'7\\' || c == \\'9\\' ? 4 : 3\\n\\nconst countTexts = (s) => {\\n    let n = s.length;\\n    let dp = Array(n + 1).fill(0);\\n    dp[0] = 1;\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 1; j <= cal(s[i]); j++) {\\n            let len = i - j + 1;\\n            if (len < 0 || s[i] != s[len]) break;\\n            dp[i + 1] += dp[i + 1 - j];\\n        }\\n        dp[i + 1] %= mod;\\n    }\\n    return dp[n];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nconst mod = 1e9 + 7;\\nconst cal = (c) => c == \\'7\\' || c == \\'9\\' ? 4 : 3\\n\\nconst countTexts = (s) => {\\n    let n = s.length;\\n    let dp = Array(n + 1).fill(0);\\n    dp[0] = 1;\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 1; j <= cal(s[i]); j++) {\\n            let len = i - j + 1;\\n            if (len < 0 || s[i] != s[len]) break;\\n            dp[i + 1] += dp[i + 1 - j];\\n        }\\n        dp[i + 1] %= mod;\\n    }\\n    return dp[n];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2018146,
                "title": "c-top-down-recursive-and-memoization-solution",
                "content": "```\\nclass Solution \\n{\\n    public:\\n    int dp[100001][5];\\n    long long d=1000000007;\\n    int get(int n,int k)\\n    {\\n        if(n<0) return 0; // not valid\\n        if(n==0) return 1; // valid\\n        if(dp[n][k]!=-1) return dp[n][k];\\n\\n        long long result=0;\\n        for(int i=1;i<=k;i++) result=(result+get(n-i,k))%d; // i pressed counts are used\\n        dp[n][k]=result;\\n        return result;\\n    }\\n    int countTexts(string pressedKeys) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        long long result=1,a[10],n=pressedKeys.length(),c=1;\\n\\n        for(int i=0;i<10;i++) a[i]=3; // a[i] is the number of available alphabets for a given digit i\\n        a[7]=4;\\n        a[9]=4;\\n        pressedKeys+=\"0\"; // add a never-appeared digit at the end to make the below code concise\\n        \\n        for(int i=1;i<n+1;i++)\\n        {\\n            if(pressedKeys[i]==pressedKeys[i-1]) c++; // same digits\\n            else result=(result*get(c,a[pressedKeys[i-1]-\\'0\\']))%d, c=1; // find a different digit, so process the previous same digits\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public:\\n    int dp[100001][5];\\n    long long d=1000000007;\\n    int get(int n,int k)\\n    {\\n        if(n<0) return 0; // not valid\\n        if(n==0) return 1; // valid\\n        if(dp[n][k]!=-1) return dp[n][k];\\n\\n        long long result=0;\\n        for(int i=1;i<=k;i++) result=(result+get(n-i,k))%d; // i pressed counts are used\\n        dp[n][k]=result;\\n        return result;\\n    }\\n    int countTexts(string pressedKeys) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        long long result=1,a[10],n=pressedKeys.length(),c=1;\\n\\n        for(int i=0;i<10;i++) a[i]=3; // a[i] is the number of available alphabets for a given digit i\\n        a[7]=4;\\n        a[9]=4;\\n        pressedKeys+=\"0\"; // add a never-appeared digit at the end to make the below code concise\\n        \\n        for(int i=1;i<n+1;i++)\\n        {\\n            if(pressedKeys[i]==pressedKeys[i-1]) c++; // same digits\\n            else result=(result*get(c,a[pressedKeys[i-1]-\\'0\\']))%d, c=1; // find a different digit, so process the previous same digits\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2731706,
                "title": "c-easy-recursion-dp",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int dp[100005];\\n    int mod = 1e9+7;\\n    int solve(string &str, int idx) {\\n        if(idx == str.length()) return 1;\\n        if(dp[idx] != -1) return dp[idx];\\n        int maxKeyPress = (str[idx] == \\'7\\' || str[idx] == \\'9\\') ? 4 : 3;\\n        long long currIndex = idx, pressFrequency = 1, ans = 0;\\n        while(pressFrequency <= maxKeyPress && str[currIndex] == str[idx]) {\\n            ++currIndex;\\n            ++pressFrequency;\\n            ans += solve(str, currIndex) % mod;\\n        }\\n        return dp[idx] = ans%mod;\\n    }\\n    int countTexts(string pressedKeys) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(pressedKeys, 0) % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int dp[100005];\\n    int mod = 1e9+7;\\n    int solve(string &str, int idx) {\\n        if(idx == str.length()) return 1;\\n        if(dp[idx] != -1) return dp[idx];\\n        int maxKeyPress = (str[idx] == \\'7\\' || str[idx] == \\'9\\') ? 4 : 3;\\n        long long currIndex = idx, pressFrequency = 1, ans = 0;\\n        while(pressFrequency <= maxKeyPress && str[currIndex] == str[idx]) {\\n            ++currIndex;\\n            ++pressFrequency;\\n            ans += solve(str, currIndex) % mod;\\n        }\\n        return dp[idx] = ans%mod;\\n    }\\n    int countTexts(string pressedKeys) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(pressedKeys, 0) % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524389,
                "title": "easy-to-understand-solution-using-combinations-and-dp",
                "content": "The approach is like, first of all we will find the number of texts possible for each substring containing same numbers. Then finally multiply all the values possible number of texts for each substring to  get total number of texts possible  for entire string. \\nHope you Like it!\\n\\n\\n```\\n\\nint countTexts(string s) {\\n        \\n        int n = s.size();\\n        int md  = 1e9+7;\\n        \\n        vector<long long> dp(n,0);\\n        dp[0]=1;\\n        int cnt = 1;\\n        \\n        long long ans = 1;\\n        \\n        for(int i=1;i<n;i++){\\n            \\n            if(s[i]==s[i-1]){\\n                cnt++;\\n                if(s[i] == \\'7\\' || s[i] == \\'9\\'){\\n                    if(cnt<=4){\\n                        dp[i] = 1;\\n                    }\\n                    \\n                        int k = min( cnt-1,4);\\n                        \\n                        while(k){\\n                            dp[i]+= dp[i-k];\\n                            dp[i] %= md;\\n                            k--;\\n                        }\\n                    \\n                }else {\\n                    \\n                       if(cnt<=3){\\n                        dp[i] = 1;}\\n                    \\n                        int k = min( cnt-1,3);\\n                        \\n                        while(k){\\n                            dp[i]+= dp[i-k];\\n                         dp[i] %= md;\\n\\n                            k--;\\n                        }\\n                }\\n            }else {\\n                //reseting the count for new substring with different values.\\n                cnt = 1;\\n                dp[i] = 1;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// adding answer to previous substring.\\n                ans = (ans*dp[i-1])%md;\\n                \\n            }\\n\\t}\\n\\n\\tans = (ans*dp[n-1])%md;\\n\\n\\treturn (int) ans;\\n}\\n\\n```",
                "solutionTags": [
                    "Combinatorics"
                ],
                "code": "```\\n\\nint countTexts(string s) {\\n        \\n        int n = s.size();\\n        int md  = 1e9+7;\\n        \\n        vector<long long> dp(n,0);\\n        dp[0]=1;\\n        int cnt = 1;\\n        \\n        long long ans = 1;\\n        \\n        for(int i=1;i<n;i++){\\n            \\n            if(s[i]==s[i-1]){\\n                cnt++;\\n                if(s[i] == \\'7\\' || s[i] == \\'9\\'){\\n                    if(cnt<=4){\\n                        dp[i] = 1;\\n                    }\\n                    \\n                        int k = min( cnt-1,4);\\n                        \\n                        while(k){\\n                            dp[i]+= dp[i-k];\\n                            dp[i] %= md;\\n                            k--;\\n                        }\\n                    \\n                }else {\\n                    \\n                       if(cnt<=3){\\n                        dp[i] = 1;}\\n                    \\n                        int k = min( cnt-1,3);\\n                        \\n                        while(k){\\n                            dp[i]+= dp[i-k];\\n                         dp[i] %= md;\\n\\n                            k--;\\n                        }\\n                }\\n            }else {\\n                //reseting the count for new substring with different values.\\n                cnt = 1;\\n                dp[i] = 1;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// adding answer to previous substring.\\n                ans = (ans*dp[i-1])%md;\\n                \\n            }\\n\\t}\\n\\n\\tans = (ans*dp[n-1])%md;\\n\\n\\treturn (int) ans;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2405125,
                "title": "c-linear-time-constant-space-solution",
                "content": "## Simple Inputs\\n\\n#### Example 1.1: \"23578\"\\n\\nQ: What if we don\\'t have repetitions in the input string?\\n\\nA: Our fingers just press each key once to produce the message.\\n\\n> The answer is 1\\n\\n#### Example 1.2: \"235782783578\"\\n\\nQ: What if we do have some same digit appear across the input string?\\n\\nA: As long as they are not back-to-back grouping with their own kinds,\\nour fingers still need to press each key once and move around for another.\\n\\n> The answer is still 1\\n\\n#### Short Summary\\n\\nIn examples 1.x, things are simple. \\nWe can safely assume \\n\\n> finger movement **must** occur between **all** adjacent keys\\n\\nand hence one-and-only-one message can be incurred from each of these input strings.\\n\\n## Fancy Inputs\\n\\nAs the problem suggest, we may have same digit in some groups of contiguous substring.\\n\\nWe somehow still want the observation in examples 1.x to happen here.\\nExcept that this time, we can only do \\n\\n> finger movement **may** occur between **some** adjacent keys\\n\\nConsidering this, we may want to cut `\"22233\"` into `\"222\"` and `\"33\"`.\\n\\n**Q: How exactly is `count(\"22233\")` and `count(\"222\")` and `count(\"33\")` are related?**\\n\\n#### Example 2: \"22233\"\\n\\nSince our finger shall jump between `2` and `3` at some point,\\nLet\\'s say we press `222` and form `ba`.\\n**Then we must break the continuity and switch keys** (from `2` to `3`).\\nNext, pressing `33` can give a `e`.\\nThe final message `bae` is then formed by concatenating the pre-chosen segments.\\n\\nMore precisely, \\neach of the possible outcome from `222` can be paired with an outcome from `33` \\nfor producing a possible message.\\n\\nThus, the Product Rule (from Discrete Maths) applies.\\n\\n```\\ncount(\"22233\")   =   count(\"222\")   \\xD7   count(\"33\")\\n```\\n\\n## Extract Subroutine\\n\\nWe can imagine how the product expands, when more **contiguous substrings of same character** present.\\n\\nSay we extract out a subroutine for solving contiguous substrings of this kind, \\n\\n```c++\\nint countSameTexts(char& cc, int& count);\\n```\\n\\nthen we can formulate our solver progam as below. \\n\\n```c++\\nclass Solution {\\npublic:\\n    long modulo = 1000000007;\\n    int countSameTexts(char& cc, int& count);\\n    int countTexts(string pressedKeys) {\\n        long res = 1;\\n        int count = 0;\\n        char current = pressedKeys[0];\\n        for (char& c: pressedKeys)\\n            /* Accumulate count for contiguous substrings of same character */\\n            if (current == c)\\n                count++;\\n            /* Update `res` by Product Rule and `modulo` during key-switch */\\n            else {\\n                res = (res * countSameTexts(current, count)) % modulo;\\n                current = c;\\n                count = 1; // Reset count\\n            }\\n        /* Update `res` one final time */\\n        return (res * countSameTexts(current, count)) % modulo;\\n    }\\n};\\n```\\n\\n## Construct Subroutine By Dynamic Programming\\n\\n### Case 1: 7, 9\\n\\n#### Arbitrary length n\\nFrom the given repetition rule, a string with length `n` can be formed by one of the following.\\n- character formed by subtring of length `1` + chracters from remaining substrings of length `(n - 1)`\\n- character formed by subtring of length `2` + chracters from remaining substrings of length `(n - 2)`\\n- character formed by subtring of length `3` + chracters from remaining substrings of length `(n - 3)`\\n- character formed by subtring of length `4` + chracters from remaining substrings of length `(n - 4)`\\n\\nSub-optimal property is obviously preserved, \\nsince any length of substring from the original string always contains the same character.\\n\\nThe above events are disjoint and exhaustive.\\nThus, the Sum Rule (from Discrete Maths) applies.\\n\\n```\\nCount_79(n)   =   Count_79(n - 1)   +   Count_79(n - 2)   +   Count_79(n - 3)   +   Count_79(n - 4)\\n```\\n\\n#### Base Case of length 1, 2, 3, 4\\n\\nFor `n = 1`, obviously `Count_79(2) = 1`.\\n\\nFor `n = 2`, we have `7, 7` or `77`. so `Count_79(2) = 2`.\\n\\nFor `n = 3`, we have `7, 7, 7` or `7, 77` or `77, 7` or `777`. so `Count_79(3) = 4`.\\n\\nFor `n = 4`, the count will involve\\n- 1 permutation involving `7`\\n- 3 permutation involving `7` and `77`\\n- 2 permutation involving `7` and `777`\\n- 1 permutation involving `77` and `77`\\n- 1 permutation involving `7777`\\nHence, `Count_79(4) = 8`.\\n\\n#### Complete Formula \\n\\nFrom base case and recursion, we can obtain the complete formula ... (1)\\n\\n```\\nCount_79(1)   =   1\\nCount_79(2)   =   2\\nCount_79(3)   =   4\\nCount_79(4)   =   8\\nCount_79(n)   =   Count_79(n - 1)   +   Count_79(n - 2)   +   Count_79(n - 3)   +   Count_79(n - 4)\\n```\\n\\n### Case 2: 2, 3, 4, 5, 6, 8\\n\\n#### Complete Formula \\n\\nFollow a similar analysis as above, we can have the below formula ... (2)\\n\\n(Can you deduce the details?)\\n\\n```\\nCount_234568(1)   =   1\\nCount_234568(2)   =   2\\nCount_234568(3)   =   4\\nCount_234568(n)   =   Count_234568(n - 1)   +   Count_234568(n - 2)   +   Count_234568(n - 3)\\n```\\n\\n### Code\\n\\nThe code can easily be written, with bottom-up DP.\\n\\n```c++\\nint Solution::countSameTexts(char& cc, int& count) {\\n    // Count for 7, 9\\n    if (cc == \\'7\\' || cc == \\'9\\') {\\n        if (count <= 4)\\n            return 1 << (count - 1);\\n        long a = 1 << 0;\\n        long b = 1 << 1;\\n        long c = 1 << 2;\\n        long d = 1 << 3;\\n        for (int i = 4; i < count; i++) {\\n            long new_a = b;\\n            long new_b = c;\\n            long new_c = d;\\n            long new_d = (a + b + c + d) % modulo;\\n            a = new_a;\\n            b = new_b;\\n            c = new_c;\\n            d = new_d;\\n        }\\n        return d;\\n    }\\n    // Count for 2, 3, 4, 5, 6, 8\\n    else {        \\n        if (count <= 3)\\n            return 1 << (count - 1);\\n        long a = 1 << 0;\\n        long b = 1 << 1;\\n        long c = 1 << 2;\\n        for (int i = 3; i < count; i++) {\\n            long new_a = b;\\n            long new_b = c;\\n            long new_c = (a + b + c) % modulo;\\n            a = new_a;\\n            b = new_b;\\n            c = new_c;\\n        }\\n        return c;\\n    }\\n}\\n```\\n\\n## Possible Optimization\\n\\nFormula in (1) and (2) can easily be speed-up to logarithmic cost, by (binary) exponetiation of matrix.\\nI invite readers to develop a fancy (or somewhat standard) program with this approach :)\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Counting"
                ],
                "code": "```\\ncount(\"22233\")   =   count(\"222\")   \\xD7   count(\"33\")\\n```\n```c++\\nint countSameTexts(char& cc, int& count);\\n```\n```c++\\nclass Solution {\\npublic:\\n    long modulo = 1000000007;\\n    int countSameTexts(char& cc, int& count);\\n    int countTexts(string pressedKeys) {\\n        long res = 1;\\n        int count = 0;\\n        char current = pressedKeys[0];\\n        for (char& c: pressedKeys)\\n            /* Accumulate count for contiguous substrings of same character */\\n            if (current == c)\\n                count++;\\n            /* Update `res` by Product Rule and `modulo` during key-switch */\\n            else {\\n                res = (res * countSameTexts(current, count)) % modulo;\\n                current = c;\\n                count = 1; // Reset count\\n            }\\n        /* Update `res` one final time */\\n        return (res * countSameTexts(current, count)) % modulo;\\n    }\\n};\\n```\n```\\nCount_79(n)   =   Count_79(n - 1)   +   Count_79(n - 2)   +   Count_79(n - 3)   +   Count_79(n - 4)\\n```\n```\\nCount_79(1)   =   1\\nCount_79(2)   =   2\\nCount_79(3)   =   4\\nCount_79(4)   =   8\\nCount_79(n)   =   Count_79(n - 1)   +   Count_79(n - 2)   +   Count_79(n - 3)   +   Count_79(n - 4)\\n```\n```\\nCount_234568(1)   =   1\\nCount_234568(2)   =   2\\nCount_234568(3)   =   4\\nCount_234568(n)   =   Count_234568(n - 1)   +   Count_234568(n - 2)   +   Count_234568(n - 3)\\n```\n```c++\\nint Solution::countSameTexts(char& cc, int& count) {\\n    // Count for 7, 9\\n    if (cc == \\'7\\' || cc == \\'9\\') {\\n        if (count <= 4)\\n            return 1 << (count - 1);\\n        long a = 1 << 0;\\n        long b = 1 << 1;\\n        long c = 1 << 2;\\n        long d = 1 << 3;\\n        for (int i = 4; i < count; i++) {\\n            long new_a = b;\\n            long new_b = c;\\n            long new_c = d;\\n            long new_d = (a + b + c + d) % modulo;\\n            a = new_a;\\n            b = new_b;\\n            c = new_c;\\n            d = new_d;\\n        }\\n        return d;\\n    }\\n    // Count for 2, 3, 4, 5, 6, 8\\n    else {        \\n        if (count <= 3)\\n            return 1 << (count - 1);\\n        long a = 1 << 0;\\n        long b = 1 << 1;\\n        long c = 1 << 2;\\n        for (int i = 3; i < count; i++) {\\n            long new_a = b;\\n            long new_b = c;\\n            long new_c = (a + b + c) % modulo;\\n            a = new_a;\\n            b = new_b;\\n            c = new_c;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2340071,
                "title": "c-dp-memorization-very-simple-code",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    int mod=1000000007;\\n    int countTexts(string pressedKeys) {\\n        vector<int> dp(pressedKeys.size(),-1);\\n        return fun(dp,pressedKeys,0);\\n    }\\n    long fun(vector<int>& dp,string& s,int i)\\n    {\\n        if(i>=s.length())\\n            return 1;\\n        \\n        if(dp[i]!=-1)\\n            return dp[i];\\n        \\n        int n=temp(s[i])-1;\\n        long t=fun(dp,s,i+1)%mod;\\n        for(int j=i+1;j<s.length();j++)\\n        {\\n            if(s[j]==s[i] && n)\\n            {\\n                n--;\\n                t+=fun(dp,s,j+1)%mod;\\n            }\\n            else\\n                break;\\n        }\\n        return dp[i]=t%mod;\\n    }\\n    int temp(char c)\\n    {\\n        if(c==\\'7\\'|| c==\\'9\\')\\n            return 4;\\n        return 3;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1000000007;\\n    int countTexts(string pressedKeys) {\\n        vector<int> dp(pressedKeys.size(),-1);\\n        return fun(dp,pressedKeys,0);\\n    }\\n    long fun(vector<int>& dp,string& s,int i)\\n    {\\n        if(i>=s.length())\\n            return 1;\\n        \\n        if(dp[i]!=-1)\\n            return dp[i];\\n        \\n        int n=temp(s[i])-1;\\n        long t=fun(dp,s,i+1)%mod;\\n        for(int j=i+1;j<s.length();j++)\\n        {\\n            if(s[j]==s[i] && n)\\n            {\\n                n--;\\n                t+=fun(dp,s,j+1)%mod;\\n            }\\n            else\\n                break;\\n        }\\n        return dp[i]=t%mod;\\n    }\\n    int temp(char c)\\n    {\\n        if(c==\\'7\\'|| c==\\'9\\')\\n            return 4;\\n        return 3;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2166287,
                "title": "java-simple-solution",
                "content": "```\\nimport java.util.*;\\nclass Solution {\\n    \\n    int mod=(int)Math.pow(10,9)+7;\\n   // String[] keypad={\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n    int ans=0;\\n    public int countTexts(String pressedKeys) {\\n        \\n        int len=pressedKeys.length();\\n       int[] dp=new int[len+1];\\n        \\n        dp[0]=1;\\n        System.out.print(dp[0]+\" \");\\n        for(int i=1;i<len+1;i++){\\n            \\n            char ch=pressedKeys.charAt(i-1);\\n          \\n         \\n            \\n             dp[i]=(dp[i]%mod+dp[i-1]%mod)%mod;\\n            if(i-2>=0 && pressedKeys.charAt(i-2)==ch ){\\n                \\n                 dp[i]=(dp[i]%mod+dp[i-2]%mod)%mod;\\n                \\n                if(i-3>=0 &&  pressedKeys.charAt(i-3)==ch ){\\n                    \\n                    \\n                        dp[i]=(dp[i]%mod+dp[i-3]%mod)%mod;\\n                    \\n                    if((i-4>=0 && pressedKeys.charAt(i-4)==ch)&& (ch==\\'7\\' || ch==\\'9\\')  ){\\n                        dp[i]=(dp[i]%mod+dp[i-4]%mod)%mod;\\n                    }\\n                }\\n                \\n                \\n            }\\n            \\n            \\n           // System.out.print(dp[i]+\" \");\\n        }\\n         \\n        return dp[len];\\n    }\\n}\\n             \\n                   \\n```\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nimport java.util.*;\\nclass Solution {\\n    \\n    int mod=(int)Math.pow(10,9)+7;\\n   // String[] keypad={\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n    int ans=0;\\n    public int countTexts(String pressedKeys) {\\n        \\n        int len=pressedKeys.length();\\n       int[] dp=new int[len+1];\\n        \\n        dp[0]=1;\\n        System.out.print(dp[0]+\" \");\\n        for(int i=1;i<len+1;i++){\\n            \\n            char ch=pressedKeys.charAt(i-1);\\n          \\n         \\n            \\n             dp[i]=(dp[i]%mod+dp[i-1]%mod)%mod;\\n            if(i-2>=0 && pressedKeys.charAt(i-2)==ch ){\\n                \\n                 dp[i]=(dp[i]%mod+dp[i-2]%mod)%mod;\\n                \\n                if(i-3>=0 &&  pressedKeys.charAt(i-3)==ch ){\\n                    \\n                    \\n                        dp[i]=(dp[i]%mod+dp[i-3]%mod)%mod;\\n                    \\n                    if((i-4>=0 && pressedKeys.charAt(i-4)==ch)&& (ch==\\'7\\' || ch==\\'9\\')  ){\\n                        dp[i]=(dp[i]%mod+dp[i-4]%mod)%mod;\\n                    }\\n                }\\n                \\n                \\n            }\\n            \\n            \\n           // System.out.print(dp[i]+\" \");\\n        }\\n         \\n        return dp[len];\\n    }\\n}\\n             \\n                   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2164807,
                "title": "python-lru-cache",
                "content": "```\\nclass Solution:\\n    def countTexts(self, x: str) -> int:\\n        l=len(x)\\n        @lru_cache(None)\\n        def f(i):\\n            if i==l:return 1\\n            ans=0\\n            for j in range(i,i+(4 if x[i] in \\'97\\' else 3)):\\n                    if j<l and x[j]==x[i]:\\n                        ans+=f(j+1)\\n                    else:\\n                        break\\n            return ans%(10**9+7)\\n        return f(0)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countTexts(self, x: str) -> int:\\n        l=len(x)\\n        @lru_cache(None)\\n        def f(i):\\n            if i==l:return 1\\n            ans=0\\n            for j in range(i,i+(4 if x[i] in \\'97\\' else 3)):\\n                    if j<l and x[j]==x[i]:\\n                        ans+=f(j+1)\\n                    else:\\n                        break\\n            return ans%(10**9+7)\\n        return f(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2033223,
                "title": "python-simple",
                "content": "Should be mostly self explanatory. \\n\\nLoop through the numbers, and when the number is the same as the last number, just keep a running total of one, two, three, and four in a row. (Of course four in a row only exists for 7 or 9). \\n\\nWhen we have a new number, we sum up one, two, three, and four, and multiply that by our answer (ans) to keep a running total in ans. And at this point one = 1, all others are reset to 0.\\n\\nSee the code below:\\n\\n```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        M = 10 ** 9 + 7\\n        ans = one = 1\\n        two = three = four = 0\\n        last = \\'\\'\\n        for x in pressedKeys:\\n            if x == last:\\n                one, two, three, four = one + two + three + four, one, two, three\\n                if x not in \\'79\\':\\n                    four = 0\\n            else:\\n                ans = ans * (one + two + three + four) % M\\n                one = 1\\n                two = three = four = 0\\n            last = x\\n        return ans * (one + two + three + four) % M\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        M = 10 ** 9 + 7\\n        ans = one = 1\\n        two = three = four = 0\\n        last = \\'\\'\\n        for x in pressedKeys:\\n            if x == last:\\n                one, two, three, four = one + two + three + four, one, two, three\\n                if x not in \\'79\\':\\n                    four = 0\\n            else:\\n                ans = ans * (one + two + three + four) % M\\n                one = 1\\n                two = three = four = 0\\n            last = x\\n        return ans * (one + two + three + four) % M\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2029686,
                "title": "c-dynamic-programming-solution",
                "content": "Key idea: total possible number of answer with a digit `d` at the position `i` = \\n(total possible number of answer ends  at the position `i-1` + interpret the last digit as one character if 1 consecutive digits) + \\n(total possible number of answer ends  at the position `i-2` + interpret the last two digits as one character if 2 consecutive digits) + \\n(total possible number of answer ends  at the position `i-3` + interpret the last three digits as one character if 3 consecutive digits) + \\n(total possible number of answer ends  at the position `i-4` + interpret the last four digits as one character if 4 consecutive digits) + \\n\\nOne character is composed of at most 4 digits, so we only have to look up at most 4 entries to fill in each entry of the memorization table.\\n\\n```\\nint keys[10] = {0, 0, 3, 3, 3, 3, 3, 4, 3, 4};\\nconst int mod = 1e9 + 7;\\n\\nclass Solution {\\npublic:\\n    int countTexts(string pressedKeys) {\\n        int n= pressedKeys.size();\\n        if (n == 0) return 0;\\n        int dp[n+1];\\n        memset(dp, 0, sizeof(dp));\\n        dp[0] = 1;\\n        \\n        for (int i = 1; i <= n; ++i) {\\n            char c = pressedKeys[i-1];\\n            for (int j = 0; j < keys[c-\\'0\\']; ++j) {\\n                if (i-j <= 0 || pressedKeys[i-j-1] != c) {break;}\\n                dp[i] = (dp[i] + dp[i-j-1]) % mod;\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```\\nSpace complexity: O(n)\\ntime complexity: O(n)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint keys[10] = {0, 0, 3, 3, 3, 3, 3, 4, 3, 4};\\nconst int mod = 1e9 + 7;\\n\\nclass Solution {\\npublic:\\n    int countTexts(string pressedKeys) {\\n        int n= pressedKeys.size();\\n        if (n == 0) return 0;\\n        int dp[n+1];\\n        memset(dp, 0, sizeof(dp));\\n        dp[0] = 1;\\n        \\n        for (int i = 1; i <= n; ++i) {\\n            char c = pressedKeys[i-1];\\n            for (int j = 0; j < keys[c-\\'0\\']; ++j) {\\n                if (i-j <= 0 || pressedKeys[i-j-1] != c) {break;}\\n                dp[i] = (dp[i] + dp[i-j-1]) % mod;\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2019598,
                "title": "memoization-to-tablulation-c",
                "content": "```\\nclass Solution {\\npublic:   \\n    int m=1e9+7;\\n    vector<int> arr={0,0,3,3,3,3,3,4,3,4}; \\n    int dp[100003];\\n    int solve(string &s,int i){\\n        if(i==s.length()) return 1;\\n        if(dp[i]!=-1) return dp[i];\\n        long long ans=0;\\n        int j=0; \\n        ans=(ans%m+solve(s,i+1)%m)%m; \\n        for(j=i+1;j<s.length()&&j<i+arr[s[i]-\\'0\\'];j++){ \\n            if(s[j]!=s[j-1]) break;\\n            ans=(ans%m+solve(s,j+1)%m)%m;\\n        } \\n        return dp[i]=ans;\\n    }\\n    int countTexts(string s) {  \\n        memset(dp,-1,sizeof dp);\\n      return solve(s,0);\\n    }\\n};\\n``` \\n**CONVERTING IT TO TABULATION (credit-striver)** \\nfollowing steps involve in coverting memoization into tabulation\\n1.Declare same size storage and intialise base case.\\n2.Observe changing paremeter (i)  i->0,1,2,3,4,5 \\n3.write down the loop of changing parameter in reverse order.\\n4.Copy the recusion. \\n\\n```\\nclass Solution {\\npublic:    \\n    //tabulation\\n    int m=1e9+7;\\n    vector<int> arr={0,0,3,3,3,3,3,4,3,4}; \\n    int countTexts(string s) {  \\n      vector<int> dp(s.length()+1);\\n      dp[s.length()]=1; //step1\\n      for(int i=s.length()-1;i>=0;i--){ //step 2 and 3 \\n\\t  //step 4\\n        long long ans=0;\\n        int j=0; \\n        ans=(ans%m+dp[i+1]%m)%m; \\n        for(j=i+1;j<s.length()&&j<i+arr[s[i]-\\'0\\'];j++){ \\n            if(s[j]!=s[j-1]) break;\\n            ans=(ans%m+dp[j+1]%m)%m;\\n        } \\n        dp[i]=ans;\\n      }\\n      return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:   \\n    int m=1e9+7;\\n    vector<int> arr={0,0,3,3,3,3,3,4,3,4}; \\n    int dp[100003];\\n    int solve(string &s,int i){\\n        if(i==s.length()) return 1;\\n        if(dp[i]!=-1) return dp[i];\\n        long long ans=0;\\n        int j=0; \\n        ans=(ans%m+solve(s,i+1)%m)%m; \\n        for(j=i+1;j<s.length()&&j<i+arr[s[i]-\\'0\\'];j++){ \\n            if(s[j]!=s[j-1]) break;\\n            ans=(ans%m+solve(s,j+1)%m)%m;\\n        } \\n        return dp[i]=ans;\\n    }\\n    int countTexts(string s) {  \\n        memset(dp,-1,sizeof dp);\\n      return solve(s,0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:    \\n    //tabulation\\n    int m=1e9+7;\\n    vector<int> arr={0,0,3,3,3,3,3,4,3,4}; \\n    int countTexts(string s) {  \\n      vector<int> dp(s.length()+1);\\n      dp[s.length()]=1; //step1\\n      for(int i=s.length()-1;i>=0;i--){ //step 2 and 3 \\n\\t  //step 4\\n        long long ans=0;\\n        int j=0; \\n        ans=(ans%m+dp[i+1]%m)%m; \\n        for(j=i+1;j<s.length()&&j<i+arr[s[i]-\\'0\\'];j++){ \\n            if(s[j]!=s[j-1]) break;\\n            ans=(ans%m+dp[j+1]%m)%m;\\n        } \\n        dp[i]=ans;\\n      }\\n      return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018609,
                "title": "python-recursion-memoization",
                "content": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        keysMap={\"2\":3,\"3\":3,\"4\":3,\"5\":3,\"6\":3,\"7\":4,\"8\":3,\"9\":4}\\n        seen={}\\n        @lru_cache(10)\\n        def find_(ind):\\n            if ind>=len(pressedKeys):\\n                return 1\\n            ans=0\\n            for i in range(keysMap[pressedKeys[ind]]):\\n                if ind+i >= len(pressedKeys) or pressedKeys[ind+i]!=pressedKeys[ind]:\\n                    break\\n                ans+=find_(ind+i+1)\\n            return ans\\n        return find_(0)%1000000007\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        keysMap={\"2\":3,\"3\":3,\"4\":3,\"5\":3,\"6\":3,\"7\":4,\"8\":3,\"9\":4}\\n        seen={}\\n        @lru_cache(10)\\n        def find_(ind):\\n            if ind>=len(pressedKeys):\\n                return 1\\n            ans=0\\n            for i in range(keysMap[pressedKeys[ind]]):\\n                if ind+i >= len(pressedKeys) or pressedKeys[ind+i]!=pressedKeys[ind]:\\n                    break\\n                ans+=find_(ind+i+1)\\n            return ans\\n        return find_(0)%1000000007\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018479,
                "title": "java-memo-explained-o-n",
                "content": "```\\nclass Solution {\\n    public int countTexts(String pressedKeys) {\\n        int[] memo=new int[pressedKeys.length()];\\n        \\n        return dfs(pressedKeys,memo,0);\\n    }\\n    \\n    public int dfs(String pk,int[] memo,int index){\\n        if(index==pk.length())  //if end of string is reached that is one permutation\\n            return 1;\\n        \\n        if(memo[index]!=0)      //if countof permutations for that index is already calculated\\n            return memo[index];\\n        \\n        int count=0;\\n        for(int i=0;i<4;i++){   //max we need to go four index forward\\n            //for only button 7 and 9 we have 4 charcters\\n            if(pk.charAt(index)!=\\'7\\' && pk.charAt(index)!=\\'9\\' && i==3)  \\n                break;\\n            \\n            if(index+i>=pk.length())    //if end index goes out of bounds\\n                break;\\n              \\n            if(i!=0){  \\n                //if adjacent characters are not same\\n                if(pk.charAt(index+i)!=pk.charAt(index+i-1))    \\n                    break;\\n            }\\n            \\n            count+=dfs(pk,memo,index+i+1);  //recursive call for remaining string\\n            count%=1000000007;\\n                \\n        }\\n        \\n        memo[index]=count;  //store the calculated value for this index\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int countTexts(String pressedKeys) {\\n        int[] memo=new int[pressedKeys.length()];\\n        \\n        return dfs(pressedKeys,memo,0);\\n    }\\n    \\n    public int dfs(String pk,int[] memo,int index){\\n        if(index==pk.length())  //if end of string is reached that is one permutation\\n            return 1;\\n        \\n        if(memo[index]!=0)      //if countof permutations for that index is already calculated\\n            return memo[index];\\n        \\n        int count=0;\\n        for(int i=0;i<4;i++){   //max we need to go four index forward\\n            //for only button 7 and 9 we have 4 charcters\\n            if(pk.charAt(index)!=\\'7\\' && pk.charAt(index)!=\\'9\\' && i==3)  \\n                break;\\n            \\n            if(index+i>=pk.length())    //if end index goes out of bounds\\n                break;\\n              \\n            if(i!=0){  \\n                //if adjacent characters are not same\\n                if(pk.charAt(index+i)!=pk.charAt(index+i-1))    \\n                    break;\\n            }\\n            \\n            count+=dfs(pk,memo,index+i+1);  //recursive call for remaining string\\n            count%=1000000007;\\n                \\n        }\\n        \\n        memo[index]=count;  //store the calculated value for this index\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017949,
                "title": "python-single-pass-dp-o-n-time-o-1-space",
                "content": "**Building our Intuition:**\\nLet us imagine pressedKeys is \"2222\".\\n\\nThe only way to interpret \"2\" is:\\n[\"a\"]\\n\\nThere are two ways we interpret \"22\":\\n[\"aa\", \"b\"]\\n\\nFour ways we interpret \"222\":\\n[\"aaa\", \"ba\", \"ab\", \"c\"]\\n\\n7 ways we interpret \"2222\":\\n[\"aaaa\", \"baa\", \"aba\", \"ca\", \"aab\", \"bb\", \"ac\"]\\n\\nIn each state we can see that to get the ways a digit is interpretting as ending with \"a\", we need to combine all digits that ended previously with \"a\", \"b\", & \"c\". Then to get the ways the str can be interpretted as ending with \"b\", it would be the number of strings that ended with \"b\" in our previous digit. Similarly for \"c\" we need to get the number of ways the previous str ended with \"b\".\\n\\n**So how do we calculate one state from another?**\\nSo for the digit \"2\" in every subsequent digit of \"2\" to get the new combinations we just check how many previous digits ended with \"a\", \"b\", & \"c\". Same idea goes for every other digit except for \"7\" and \"9\" in which case there are 4 transitions, so we need to account and check for one more digit.\\n\\nWhen we see a new digit, i.e. if after seeing \"222\" we then encounter a \"3\", then we reset our states to be all 0, and make our first state to be the combination of all the previous state endings. Meaning if we had \"222\" then the possible combinations we have is [\"aaa\", \"ba\", \"ab\", \"c\"], however whenever we encounter a \"3\", then they all must end with \"d\", and as such we now get [\"aaad\", \"bad\", \"abd\", \"cd\"]. Which then is repersented as [4, 0, 0], meaning we have 4 digits that end with \"d\", and 0 digits that end \"e\" & \"f\".\\n\\n\\n```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        if not pressedKeys:\\n            return 0\\n        \\n        MOD = 10 ** 9 + 7\\n        chars_in_digit = {\\'2\\': 3, \\'3\\': 3, \\'4\\': 3, \\'5\\': 3, \\'6\\': 3, \\'7\\': 4, \\'8\\': 3, \\'9\\': 4}\\n        \\n        prev_states = [1]\\n        prev_digit = None\\n        \\n        for digit in pressedKeys:\\n            total = sum(prev_states) % MOD\\n            \\n            if digit != prev_digit:\\n                prev_states = [total] + [0] * (chars_in_digit[digit] - 1)\\n            else:\\n                prev_states = [total] + prev_states[:chars_in_digit[digit] - 1]\\n                \\n            prev_digit = digit\\n        \\n        return sum(prev_states) % MOD\\n```\\n\\n**TC: O(N)** -> Since all new list creations and tallying of states in each char has an upperbound of 4\\n**SC: O(1)** -> Since prev_states has a max length of 4, and other variables are constant",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        if not pressedKeys:\\n            return 0\\n        \\n        MOD = 10 ** 9 + 7\\n        chars_in_digit = {\\'2\\': 3, \\'3\\': 3, \\'4\\': 3, \\'5\\': 3, \\'6\\': 3, \\'7\\': 4, \\'8\\': 3, \\'9\\': 4}\\n        \\n        prev_states = [1]\\n        prev_digit = None\\n        \\n        for digit in pressedKeys:\\n            total = sum(prev_states) % MOD\\n            \\n            if digit != prev_digit:\\n                prev_states = [total] + [0] * (chars_in_digit[digit] - 1)\\n            else:\\n                prev_states = [total] + prev_states[:chars_in_digit[digit] - 1]\\n                \\n            prev_digit = digit\\n        \\n        return sum(prev_states) % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3774780,
                "title": "my-dp-memoization-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n    just have special cycles for index+1,index+2 and index+3 elements.\\nIf they are equal like 222 or 7777 then we can take this in cosideration.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int size = 1e5+10;\\n    int dp[100000];\\n    int solve(int ind, string &str, vector<string>& nummap){\\n        \\n        if(str[ind] == \\'0\\' || str[ind]==\\'1\\') return 0;\\n        if(ind == str.size()) return 1;\\n\\n        if(dp[ind] != -1) return dp[ind];\\n\\n        long long int ans = 0;\\n\\n        if(ind<str.size()-1 && str[ind+1]==str[ind]){\\n            ans += solve(ind+2,str,nummap)%mod;\\n        }\\n\\n        if(ind<str.size()-2 && (str[ind]==str[ind+1] && str[ind+1]==str[ind+2])){\\n            ans += solve(ind+3,str,nummap)%mod;\\n        }\\n\\n        if(ind<str.size()-3 && (str[ind]==\\'7\\' || str[ind]==\\'9\\') &&( str[ind+1]==str[ind] && str[ind+2]==str[ind]  && str[ind+3]==str[ind])){\\n            ans += solve(ind+4,str,nummap)%mod;\\n        }\\n\\n        ans += solve(ind+1,str,nummap)%mod;\\n\\n        return dp[ind] = ans%mod;\\n\\n    }\\n\\n    int countTexts(string pressedKeys) {\\n        \\n        vector<string> nummap {\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,pressedKeys,nummap)%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int size = 1e5+10;\\n    int dp[100000];\\n    int solve(int ind, string &str, vector<string>& nummap){\\n        \\n        if(str[ind] == \\'0\\' || str[ind]==\\'1\\') return 0;\\n        if(ind == str.size()) return 1;\\n\\n        if(dp[ind] != -1) return dp[ind];\\n\\n        long long int ans = 0;\\n\\n        if(ind<str.size()-1 && str[ind+1]==str[ind]){\\n            ans += solve(ind+2,str,nummap)%mod;\\n        }\\n\\n        if(ind<str.size()-2 && (str[ind]==str[ind+1] && str[ind+1]==str[ind+2])){\\n            ans += solve(ind+3,str,nummap)%mod;\\n        }\\n\\n        if(ind<str.size()-3 && (str[ind]==\\'7\\' || str[ind]==\\'9\\') &&( str[ind+1]==str[ind] && str[ind+2]==str[ind]  && str[ind+3]==str[ind])){\\n            ans += solve(ind+4,str,nummap)%mod;\\n        }\\n\\n        ans += solve(ind+1,str,nummap)%mod;\\n\\n        return dp[ind] = ans%mod;\\n\\n    }\\n\\n    int countTexts(string pressedKeys) {\\n        \\n        vector<string> nummap {\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,pressedKeys,nummap)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2677775,
                "title": "dp-based-simple-c-solution-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod=1000000007;\\n    int count(string &ss,int s,vector<int>&dp,map<char,int>&m)\\n    {\\n        if(s>=ss.length())\\n        {\\n            return 1;\\n        }\\n        if(dp[s]!=-1)\\n            return dp[s];\\n        int ans=0;\\n        char ch=ss[s];\\n        int k=m[ch];\\n        int j=s;\\n        while(j<ss.length() and j-s<k and ss[j]==ss[s])\\n        {\\n            ans=(ans%mod+count(ss,j+1,dp,m)%mod)%mod;\\n            j++;\\n        }\\n        dp[s]=ans;\\n        return ans;\\n    }\\n    int countTexts(string s) {\\n        int n=s.length();\\n        vector<int>dp(n+1,-1);\\n        map<char,int>m;\\n        m[\\'2\\']=3;\\n        m[\\'3\\']=3;\\n        m[\\'4\\']=3;\\n        m[\\'5\\']=3;\\n        m[\\'6\\']=3;\\n        m[\\'7\\']=4;\\n        m[\\'8\\']=3;\\n        m[\\'9\\']=4;\\n        \\n        return count(s,0,dp,m);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1000000007;\\n    int count(string &ss,int s,vector<int>&dp,map<char,int>&m)\\n    {\\n        if(s>=ss.length())\\n        {\\n            return 1;\\n        }\\n        if(dp[s]!=-1)\\n            return dp[s];\\n        int ans=0;\\n        char ch=ss[s];\\n        int k=m[ch];\\n        int j=s;\\n        while(j<ss.length() and j-s<k and ss[j]==ss[s])\\n        {\\n            ans=(ans%mod+count(ss,j+1,dp,m)%mod)%mod;\\n            j++;\\n        }\\n        dp[s]=ans;\\n        return ans;\\n    }\\n    int countTexts(string s) {\\n        int n=s.length();\\n        vector<int>dp(n+1,-1);\\n        map<char,int>m;\\n        m[\\'2\\']=3;\\n        m[\\'3\\']=3;\\n        m[\\'4\\']=3;\\n        m[\\'5\\']=3;\\n        m[\\'6\\']=3;\\n        m[\\'7\\']=4;\\n        m[\\'8\\']=3;\\n        m[\\'9\\']=4;\\n        \\n        return count(s,0,dp,m);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2557916,
                "title": "c-easy-approach-dp-hahmap",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    map<pair<int,int>,int>mp;\\n    void create_map(){\\n        mp[{0,1}]=mp[{1,1}]=1;\\n        mp[{0,2}]=mp[{1,2}]=2;\\n        mp[{0,3}]=mp[{1,3}]=4;\\n        mp[{0,4}]=7;\\n        mp[{1,4}]=8;\\n    }    \\n    unsigned int getval(int num,int count){\\n        //base case\\n        if(mp.count({num,count}))\\n            return mp[{num,count}];\\n        \\n        return mp[{num,count}]=(\\n                getval(num,count-1)%mod +\\n                getval(num,count-2)%mod +\\n                getval(num,count-3)%mod +\\n                (num==1 ? getval(num,count-4) : 0)%mod\\n            )%mod;\\n    }\\n    int countTexts(string str) {\\n        create_map();\\n        str.push_back(\\'#\\');\\n        int n= str.size();\\n        long long  ans=1;\\n        int count=1;\\n        for(int i=0;i<n-1;i++){\\n            if(str[i]==str[i+1])\\n                count++;\\n            else{\\n                int num=str[i]-\\'0\\';\\n                long long  curr = getval(num==7 || num==9,count)%mod;\\n                count=1;\\n                ans=(ans *curr)%mod;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    map<pair<int,int>,int>mp;\\n    void create_map(){\\n        mp[{0,1}]=mp[{1,1}]=1;\\n        mp[{0,2}]=mp[{1,2}]=2;\\n        mp[{0,3}]=mp[{1,3}]=4;\\n        mp[{0,4}]=7;\\n        mp[{1,4}]=8;\\n    }    \\n    unsigned int getval(int num,int count){\\n        //base case\\n        if(mp.count({num,count}))\\n            return mp[{num,count}];\\n        \\n        return mp[{num,count}]=(\\n                getval(num,count-1)%mod +\\n                getval(num,count-2)%mod +\\n                getval(num,count-3)%mod +\\n                (num==1 ? getval(num,count-4) : 0)%mod\\n            )%mod;\\n    }\\n    int countTexts(string str) {\\n        create_map();\\n        str.push_back(\\'#\\');\\n        int n= str.size();\\n        long long  ans=1;\\n        int count=1;\\n        for(int i=0;i<n-1;i++){\\n            if(str[i]==str[i+1])\\n                count++;\\n            else{\\n                int num=str[i]-\\'0\\';\\n                long long  curr = getval(num==7 || num==9,count)%mod;\\n                count=1;\\n                ans=(ans *curr)%mod;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2515500,
                "title": "c-intutive",
                "content": "\\n\\n\\nclass Solution {\\npublic:\\n   \\n    int countTexts(string pK) \\n    {\\n        int mod = 1e9+7;\\n        \\n        vector<int> dp(pK.length()+1,1);\\n        \\n        \\n        for(int idx=pK.length()-1;idx>=0;idx--){\\n            dp[idx] = dp[idx+1]%mod;\\n        if(idx<pK.length()-1 and pK[idx+1]==pK[idx])\\n        {\\n        dp[idx]=(dp[idx]+dp[idx+2])%mod;\\n        if(idx<pK.length()-2 and pK[idx+1]==pK[idx+2]) dp[idx]=(dp[idx]+dp[idx+3])%mod;\\n        else continue;\\n        if(idx<pK.length()-3 and pK[idx+2]==pK[idx+3] and (pK[idx]==\\'7\\'||pK[idx]==\\'9\\'))                             {dp[idx]=(dp[idx]+dp[idx+4])%mod;}\\n        }\\n        }\\n         \\n        return dp[0]%mod;\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n   \\n    int countTexts(string pK) \\n    {\\n        int mod = 1e9+7;\\n        \\n        vector<int> dp(pK.length()+1,1);\\n        \\n        \\n        for(int idx=pK.length()-1;idx>=0;idx--){\\n            dp[idx] = dp[idx+1]%mod;\\n        if(idx<pK.length()-1 and pK[idx+1]==pK[idx])\\n        {\\n        dp[idx]=(dp[idx]+dp[idx+2])%mod;\\n        if(idx<pK.length()-2 and pK[idx+1]==pK[idx+2]) dp[idx]=(dp[idx]+dp[idx+3])%mod;\\n        else continue;\\n        if(idx<pK.length()-3 and pK[idx+2]==pK[idx+3] and (pK[idx]==\\'7\\'||pK[idx]==\\'9\\'))                             {dp[idx]=(dp[idx]+dp[idx+4])%mod;}",
                "codeTag": "Java"
            },
            {
                "id": 2457241,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countTexts(string pressedKeys) {\\n        std::vector<long> dp(pressedKeys.size(), 0);\\n        dp[0] = 1;\\n        for (int i = 1; i < pressedKeys.size(); ++i) {\\n            char ch = pressedKeys[i];\\n            int max_num = (ch == \\'7\\' || ch == \\'9\\') ? 4 : 3;\\n\\n            for (int j = 0; j < max_num; ++j) {\\n                if (i - j < 0 || pressedKeys[i - j] != ch) break;\\n                dp[i] += (i - j - 1 < 0) ? 1 : dp[i - j - 1];\\n            }\\n\\n            dp[i] %= modulo_;\\n        }\\n        \\n        return dp.back();\\n    }\\nprivate:\\n    int modulo_ = 1000000007;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countTexts(string pressedKeys) {\\n        std::vector<long> dp(pressedKeys.size(), 0);\\n        dp[0] = 1;\\n        for (int i = 1; i < pressedKeys.size(); ++i) {\\n            char ch = pressedKeys[i];\\n            int max_num = (ch == \\'7\\' || ch == \\'9\\') ? 4 : 3;\\n\\n            for (int j = 0; j < max_num; ++j) {\\n                if (i - j < 0 || pressedKeys[i - j] != ch) break;\\n                dp[i] += (i - j - 1 < 0) ? 1 : dp[i - j - 1];\\n            }\\n\\n            dp[i] %= modulo_;\\n        }\\n        \\n        return dp.back();\\n    }\\nprivate:\\n    int modulo_ = 1000000007;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260337,
                "title": "c-dp-solution-clean-and-easy-to-understand",
                "content": "class Solution {\\npublic:\\n\\n    int mod = 1e9+7;\\n \\n    int countTexts(string s) {\\n\\t\\n        int n = s.length();\\n        vector<int> dp(n+1,0);\\n        \\n        dp[0] = 1;\\n        int ans = 0;\\n        \\n        for(int i = 1; i < n+1; i++){\\n            \\n            dp[i] = (dp[i] + dp[i-1]) % mod;\\n            \\n            \\n            if(i > 1 && s[i-1] == s[i-2])\\n                dp[i] =(dp[i] + dp[i-2]) % mod;\\n            \\n            \\n            if(i > 2 && s[i-1] == s[i-2] && s[i-2] == s[i-3])\\n                dp[i] =(dp[i] + dp[i-3]) % mod;\\n            \\n            \\n            if(s[i-1] == \\'7\\' || s[i-1] == \\'9\\')\\n                if(i > 3 && s[i-1] == s[i-2] && s[i-1] == s[i-3] && s[i-1] == s[i-4])\\n                    dp[i] =(dp[i] + dp[i-4]) % mod;\\n            \\n        }\\n        \\n        return dp[n];\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int mod = 1e9+7;\\n \\n    int countTexts(string s) {\\n\\t\\n        int n = s.length();\\n        vector<int> dp(n+1,0);\\n        \\n        dp[0] = 1;\\n        int ans = 0;\\n        \\n        for(int i = 1; i < n+1; i++){\\n            \\n            dp[i] = (dp[i] + dp[i-1]) % mod;\\n            \\n            \\n            if(i > 1 && s[i-1] == s[i-2])\\n                dp[i] =(dp[i] + dp[i-2]) % mod;\\n            \\n            \\n            if(i > 2 && s[i-1] == s[i-2] && s[i-2] == s[i-3])\\n                dp[i] =(dp[i] + dp[i-3]) % mod;\\n            \\n            \\n            if(s[i-1] == \\'7\\' || s[i-1] == \\'9\\')\\n                if(i > 3 && s[i-1] == s[i-2] && s[i-1] == s[i-3] && s[i-1] == s[i-4])\\n                    dp[i] =(dp[i] + dp[i-4]) % mod;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2136393,
                "title": "c-easy-to-understand-simple-dp-recursion-memoization",
                "content": "```\\n#define ll long long int\\nll mod=1e9+7;\\nclass Solution {\\npublic:\\n    int solve(string &s,int i,int n,vector<int> &dp)\\n    {\\n        if(i>=n)\\n        {\\n            return 1;\\n        }\\n        if(dp[i]!=-1)\\n        {\\n            return dp[i];\\n        }\\n        ll ans=0;\\n        if(i+1<n&&s[i]==s[i+1])\\n        {\\n            ans+=solve(s,i+2,n,dp)%mod;\\n            if(i+2<n&&s[i]==s[i+2])\\n            {\\n                ans+=solve(s,i+3,n,dp)%mod;\\n                if(i+3<n&&s[i]==s[i+3]&&(s[i]==\\'9\\'||s[i]==\\'7\\'))\\n                {\\n                    ans+=solve(s,i+4,n,dp)%mod;\\n                }\\n            }\\n        }\\n        ans=(ans%mod+solve(s,i+1,n,dp)%mod)%mod;\\n        return dp[i]=ans%mod;\\n    }\\n    int countTexts(string s) {\\n        int n=s.size();\\n        vector<int> dp(n+1,-1);\\n        return solve(s,0,n,dp);\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\n#define ll long long int\\nll mod=1e9+7;\\nclass Solution {\\npublic:\\n    int solve(string &s,int i,int n,vector<int> &dp)\\n    {\\n        if(i>=n)\\n        {\\n            return 1;\\n        }\\n        if(dp[i]!=-1)\\n        {\\n            return dp[i];\\n        }\\n        ll ans=0;\\n        if(i+1<n&&s[i]==s[i+1])\\n        {\\n            ans+=solve(s,i+2,n,dp)%mod;\\n            if(i+2<n&&s[i]==s[i+2])\\n            {\\n                ans+=solve(s,i+3,n,dp)%mod;\\n                if(i+3<n&&s[i]==s[i+3]&&(s[i]==\\'9\\'||s[i]==\\'7\\'))\\n                {\\n                    ans+=solve(s,i+4,n,dp)%mod;\\n                }\\n            }\\n        }\\n        ans=(ans%mod+solve(s,i+1,n,dp)%mod)%mod;\\n        return dp[i]=ans%mod;\\n    }\\n    int countTexts(string s) {\\n        int n=s.size();\\n        vector<int> dp(n+1,-1);\\n        return solve(s,0,n,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2135621,
                "title": "c-simple-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int countTexts(string &s) \\n    {\\n        int n=s.size();\\n        int dp[n];\\n        dp[0]=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            dp[i]=dp[i-1];\\n            if(s[i]==s[i-1])\\n                dp[i]=i>1?(dp[i]+dp[i-2]):(dp[i]+1);\\n            dp[i]%=mod;\\n            if(i>1 && s[i]==s[i-1] && s[i]==s[i-2])\\n                dp[i]=i>2?(dp[i]+dp[i-3]):(dp[i]+1);\\n            dp[i]%=mod;\\n            if(i>2 && (s[i]==\\'7\\' || s[i]==\\'9\\') && s[i]==s[i-1] && s[i]==s[i-2] && s[i]==s[i-3])\\n                dp[i]=i>3?(dp[i]+dp[i-4]):(dp[i]+1);\\n            dp[i]%=mod;\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int countTexts(string &s) \\n    {\\n        int n=s.size();\\n        int dp[n];\\n        dp[0]=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            dp[i]=dp[i-1];\\n            if(s[i]==s[i-1])\\n                dp[i]=i>1?(dp[i]+dp[i-2]):(dp[i]+1);\\n            dp[i]%=mod;\\n            if(i>1 && s[i]==s[i-1] && s[i]==s[i-2])\\n                dp[i]=i>2?(dp[i]+dp[i-3]):(dp[i]+1);\\n            dp[i]%=mod;\\n            if(i>2 && (s[i]==\\'7\\' || s[i]==\\'9\\') && s[i]==s[i-1] && s[i]==s[i-2] && s[i]==s[i-3])\\n                dp[i]=i>3?(dp[i]+dp[i-4]):(dp[i]+1);\\n            dp[i]%=mod;\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2119602,
                "title": "dp-python-3-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def countTexts(self, s: str) -> int:\\n        mod = 1000000007\\n        def rec2(n):\\n            if n==1:\\n                return 1\\n            if n==2:\\n                return 2\\n            if n==3:\\n                return 4\\n            if n==4:\\n                return 8\\n            dp = [0]*(n+1)\\n            dp[1]=1\\n            dp[2]=2\\n            dp[3] = 4\\n            dp[4] = 8\\n            for i in range(5,n+1):\\n                dp[i] = dp[i-1]+dp[i-2]+dp[i-3]+dp[i-4]\\n\\n            return dp[-1]\\n            \\n\\n        def rec(n):\\n            \\n            if n==1:\\n                return 1\\n            if n==2:\\n                return 2\\n            if n==3:\\n                return 4\\n            dp = [0]*(n+1)\\n            dp[1]=1\\n            dp[2]=2\\n            dp[3] = 4\\n            for i in range(4,n+1):\\n                dp[i] = dp[i-1]+dp[i-2]+dp[i-3]\\n\\n            return dp[-1]\\n        ans = 1\\n        cnt = 1\\n        for i in range(1,len(s)):\\n            if s[i]!=s[i-1]:\\n                if s[i-1] not in[\\'7\\',\\'9\\']:\\n                    ans*=(rec(cnt)%mod)\\n                else:\\n                    ans*=rec2(cnt)%mod\\n                cnt = 1\\n            else:\\n                cnt+=1\\n        ans = ans*rec(cnt) if s[-1] not in[\\'7\\',\\'9\\'] else ans*rec2(cnt)\\n        return ans%mod\\n\\t```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def countTexts(self, s: str) -> int:\\n        mod = 1000000007\\n        def rec2(n):\\n            if n==1:\\n                return 1\\n            if n==2:\\n                return 2\\n            if n==3:\\n                return 4\\n            if n==4:\\n                return 8\\n            dp = [0]*(n+1)\\n            dp[1]=1\\n            dp[2]=2\\n            dp[3] = 4\\n            dp[4] = 8\\n            for i in range(5,n+1):\\n                dp[i] = dp[i-1]+dp[i-2]+dp[i-3]+dp[i-4]\\n\\n            return dp[-1]\\n            \\n\\n        def rec(n):\\n            \\n            if n==1:\\n                return 1\\n            if n==2:\\n                return 2\\n            if n==3:\\n                return 4\\n            dp = [0]*(n+1)\\n            dp[1]=1\\n            dp[2]=2\\n            dp[3] = 4\\n            for i in range(4,n+1):\\n                dp[i] = dp[i-1]+dp[i-2]+dp[i-3]\\n\\n            return dp[-1]\\n        ans = 1\\n        cnt = 1\\n        for i in range(1,len(s)):\\n            if s[i]!=s[i-1]:\\n                if s[i-1] not in[\\'7\\',\\'9\\']:\\n                    ans*=(rec(cnt)%mod)\\n                else:\\n                    ans*=rec2(cnt)%mod\\n                cnt = 1\\n            else:\\n                cnt+=1\\n        ans = ans*rec(cnt) if s[-1] not in[\\'7\\',\\'9\\'] else ans*rec2(cnt)\\n        return ans%mod\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2109394,
                "title": "c-top-down-dp-recursion-with-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int helper(string& s,int idx,vector<int>& dp){\\n        if(idx==s.size()){\\n            return 1;\\n        }\\n        if(dp[idx]!=-1){\\n            return dp[idx];\\n        }\\n        int n=s.size();\\n        int res=0;\\n        res+=helper(s,idx+1,dp);\\n        if(idx+1<n and s[idx+1]==s[idx]){\\n            res+=helper(s,idx+2,dp);\\n            res%=mod;\\n        }\\n        if(idx+2<n and s[idx+1]==s[idx] and s[idx+2]==s[idx]){\\n            res+=helper(s,idx+3,dp);\\n            res%=mod;\\n        }\\n        if((s[idx]==\\'7\\' or s[idx]==\\'9\\') and idx+3<n and s[idx+1]==s[idx] and s[idx+2]==s[idx] and s[idx+3]==s[idx]){\\n            res+=helper(s,idx+4,dp);\\n            res%=mod;\\n        }\\n        return dp[idx]=res;\\n    }\\n    int countTexts(string s) {\\n        vector<int> dp(s.size(),-1);\\n        return helper(s,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int helper(string& s,int idx,vector<int>& dp){\\n        if(idx==s.size()){\\n            return 1;\\n        }\\n        if(dp[idx]!=-1){\\n            return dp[idx];\\n        }\\n        int n=s.size();\\n        int res=0;\\n        res+=helper(s,idx+1,dp);\\n        if(idx+1<n and s[idx+1]==s[idx]){\\n            res+=helper(s,idx+2,dp);\\n            res%=mod;\\n        }\\n        if(idx+2<n and s[idx+1]==s[idx] and s[idx+2]==s[idx]){\\n            res+=helper(s,idx+3,dp);\\n            res%=mod;\\n        }\\n        if((s[idx]==\\'7\\' or s[idx]==\\'9\\') and idx+3<n and s[idx+1]==s[idx] and s[idx+2]==s[idx] and s[idx+3]==s[idx]){\\n            res+=helper(s,idx+4,dp);\\n            res%=mod;\\n        }\\n        return dp[idx]=res;\\n    }\\n    int countTexts(string s) {\\n        vector<int> dp(s.size(),-1);\\n        return helper(s,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2080203,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8 The ART of Dynamic Programming:](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master)\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n\\nPreprocess the input to find the length of each `run` of same consecutive characters, then recursively \"consume\" each `run`.  This recursive \"consuming\" of characters is similar to [91. Decode Ways](https://leetcode.com/problems/decode-ways/discuss/117143/The-ART-of-Dynamic-Programming).\\n\\n---\\n\\n**Note:** if this `run` concept doesn\\'t make sense, look at the supplemental solutions at the very bottom (they are verbosely how I started to solve this problem).\\n\\nWe can recursively consider \"consuming\":\\n\\na. one same consecutive character: `s[i]`\\nb. two same consecutive characters: `s[i], s[i + 1]`\\nc. three same consecutive characters: `s[i], s[i + 1], s[i + 2]`\\nd. four same consecutive characters: `s[i], s[i + 1], s[i + 2], s[i + 3]` \\uD83D\\uDC48 (this use case is only applicable for characters `\\'7\\'` and `\\'9\\'`)\\n\\n---\\n\\n**Kotlin Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\n    fun countTexts(s: String): Int {\\n        var N = s.length\\n        var run = IntArray(N) { 1 }\\n        for (i in N - 2 downTo(0))\\n            if (s[i] == s[i + 1])\\n                run[i] = Math.min(1 + run[i + 1], if (s[i] == \\'7\\' || s[i] == \\'9\\') 4 else 3)\\n        fun go(i: Int = 0): Int {\\n            if (i == N)\\n                return 1\\n            var cnt = 0\\n            for (k in 1..run[i])\\n                if (i + k <= N)\\n                    cnt += go(i + k)\\n            return cnt\\n        }\\n        return go()\\n    }\\n}\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\n    fun countTexts(s: String, m: MutableMap<Int, Int> = mutableMapOf<Int, Int>()): Int {\\n        var N = s.length\\n        var run = IntArray(N) { 1 }\\n        for (i in N - 2 downTo(0))\\n            if (s[i] == s[i + 1])\\n                run[i] = Math.min(1 + run[i + 1], if (s[i] == \\'7\\' || s[i] == \\'9\\') 4 else 3)\\n        fun go(i: Int = 0): Int {\\n            if (i == N)\\n                return 1\\n            if (!m.contains(i)) {\\n                var cnt = 0\\n                for (k in 1..run[i])\\n                    if (i + k <= N)\\n                        cnt = (cnt + go(i + k)) % (1e9 + 7).toInt()\\n                m[i] = cnt\\n            }\\n            return m[i]!!\\n        }\\n        return go()\\n    }\\n}\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\n    fun countTexts(s: String, m: MutableMap<Int, Int> = mutableMapOf<Int, Int>()): Int {\\n        var N = s.length\\n        var run = IntArray(N) { 1 }\\n        for (i in N - 2 downTo(0))\\n            if (s[i] == s[i + 1])\\n                run[i] = Math.min(1 + run[i + 1], if (s[i] == \\'7\\' || s[i] == \\'9\\') 4 else 3)\\n        var dp = IntArray(N + 1) { 0 }\\n        dp[N] = 1\\n        for (i in N - 1 downTo 0)\\n            for (k in 1..run[i])\\n                if (i + k <= N)\\n                    dp[i] = (dp[i] + dp[i + k]) % (1e9 + 7).toInt()\\n        return dp[0]\\n    }\\n}\\n```\\n\\n---\\n\\n**Javascript Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nlet countTexts = s => {\\n    let N = s.length;\\n    let run = Array(N).fill(1);\\n    for (let i = N - 1; 0 <= i; --i)\\n        if (s[i] == s[i + 1])\\n            run[i] = Math.min(1 + run[i + 1], s[i] == \\'7\\' || s[i] == \\'9\\' ? 4 : 3);\\n    let go = (i = 0, cnt = 0) => {\\n        if (i == N)\\n            return 1;\\n        for (let k = 1; k <= run[i]; ++k)\\n            if (i + k <= N)\\n                cnt += go(i + k);\\n        return cnt;\\n    };\\n    return go();\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nlet countTexts = (s, m = new Map()) => {\\n    let N = s.length;\\n    let run = Array(N).fill(1);\\n    for (let i = N - 1; 0 <= i; --i)\\n        if (s[i] == s[i + 1])\\n            run[i] = Math.min(1 + run[i + 1], s[i] == \\'7\\' || s[i] == \\'9\\' ? 4 : 3);\\n    let go = (i = 0, cnt = 0) => {\\n        if (i == N)\\n            return 1;\\n        if (!m.has(i)) {\\n            for (let k = 1; k <= run[i]; ++k)\\n                if (i + k <= N)\\n                    cnt = (cnt + go(i + k)) % Number(1e9 + 7);\\n            m.set(i, cnt);\\n        }\\n        return m.get(i);\\n    };\\n    return go();\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nlet countTexts = (s, m = new Map()) => {\\n    let N = s.length;\\n    let run = Array(N).fill(1);\\n    for (let i = N - 1; 0 <= i; --i)\\n        if (s[i] == s[i + 1])\\n            run[i] = Math.min(1 + run[i + 1], s[i] == \\'7\\' || s[i] == \\'9\\' ? 4 : 3);\\n    let dp = Array(N + 1).fill(0);\\n    dp[N] = 1;\\n    for (let i = N - 1; 0 <= i; --i)\\n        for (let k = 1; k <= run[i]; ++k)\\n            if (i + k <= N)\\n                dp[i] = (dp[i] + dp[i + k]) % Number(1e9 + 7);\\n    return dp[0];\\n};\\n```\\n\\n---\\n\\n**Python3 Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution:\\n    def countTexts(self, s: str) -> int:\\n        N = len(s)\\n        run = [1] * N\\n        for i in range(N - 2, -1, -1):\\n            if s[i] == s[i + 1]:\\n                run[i] = min(1 + run[i + 1], 4 if s[i] == \\'7\\' or s[i] == \\'9\\' else 3)\\n        def go(i = 0, cnt = 0):\\n            if i == N:\\n                return 1\\n            for k in range(1, run[i] + 1):\\n                if i + k <= N:\\n                    cnt = (cnt + go(i + k)) % int(1e9 + 7)\\n            return cnt\\n        return go()\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution:\\n    def countTexts(self, s: str) -> int:\\n        N = len(s)\\n        run = [1] * N\\n        for i in range(N - 2, -1, -1):\\n            if s[i] == s[i + 1]:\\n                run[i] = min(1 + run[i + 1], 4 if s[i] == \\'7\\' or s[i] == \\'9\\' else 3)\\n        @cache\\n        def go(i = 0, cnt = 0):\\n            if i == N:\\n                return 1\\n            for k in range(1, run[i] + 1):\\n                if i + k <= N:\\n                    cnt = (cnt + go(i + k)) % int(1e9 + 7)\\n            return cnt\\n        return go()\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution:\\n    def countTexts(self, s: str) -> int:\\n        N = len(s)\\n        run = [1] * N\\n        for i in range(N - 2, -1, -1):\\n            if s[i] == s[i + 1]:\\n                run[i] = min(1 + run[i + 1], 4 if s[i] == \\'7\\' or s[i] == \\'9\\' else 3)\\n        dp = [0] * (N + 1)\\n        dp[N] = 1\\n        for i in range(N - 1, -1, -1):\\n            for k in range(1, run[i] + 1):\\n                if i + k <= N:\\n                    dp[i] = (dp[i] + dp[i + k]) % int(1e9 + 7)\\n        return dp[0]\\n```\\n\\n---\\n\\n**C++ Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int)>;\\n    int countTexts(string s) {\\n        int N = s.size();\\n        VI run(N, 1);\\n        for (auto i{ N - 2 }; 0 <= i; --i)\\n            if (s[i] == s[i + 1])\\n                run[i] = min(1 + run[i + 1], s[i] == \\'7\\' || s[i] == \\'9\\' ? 4 : 3);\\n        fun go = [&](auto i) {\\n            if (i == N)\\n                return 1;\\n            auto cnt = 0;\\n            for (auto k{ 1 }; k <= run[i]; ++k)\\n                if (i + k <= N)\\n                    cnt = (cnt + go(i + k)) % int(1e9 + 7);\\n            return cnt;\\n        };\\n        return go(0);\\n    }\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int)>;\\n    using Map = unordered_map<int, int>;\\n    int countTexts(string s, Map m = {}) {\\n        int N = s.size();\\n        VI run(N, 1);\\n        for (auto i{ N - 2 }; 0 <= i; --i)\\n            if (s[i] == s[i + 1])\\n                run[i] = min(1 + run[i + 1], s[i] == \\'7\\' || s[i] == \\'9\\' ? 4 : 3);\\n        fun go = [&](auto i) {\\n            if (i == N)\\n                return 1;\\n            if (m.find(i) == m.end()) {\\n                auto cnt = 0;\\n                for (auto k{ 1 }; k <= run[i]; ++k)\\n                    if (i + k <= N)\\n                        cnt = (cnt + go(i + k)) % int(1e9 + 7);\\n                m[i] = cnt;\\n            }\\n            return m[i];\\n        };\\n        return go(0);\\n    }\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int)>;\\n    using Map = unordered_map<int, int>;\\n    int countTexts(string s, Map m = {}) {\\n        int N = s.size();\\n        VI run(N, 1);\\n        for (auto i{ N - 2 }; 0 <= i; --i)\\n            if (s[i] == s[i + 1])\\n                run[i] = min(1 + run[i + 1], s[i] == \\'7\\' || s[i] == \\'9\\' ? 4 : 3);\\n        VI dp(N + 1, 0);\\n        dp[N] = 1;\\n        for (auto i{ N - 1 }; 0 <= i; --i)\\n            for (auto k{ 1 }; k <= run[i]; ++k)\\n                if (i + k <= N)\\n                    dp[i] = (dp[i] + dp[i + k]) % int(1e9 + 7);\\n        return dp[0];\\n    }\\n};\\n```\\n\\n---\\n\\n**Supplemental Solutions:** the reason for the `run` preprocessing in the solutions above is because it simplifies this redundant and verbose code...\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nlet countTexts = s => {\\n    let N = s.length;\\n    let go = (i = 0) => {\\n        if (i == N)\\n            return 1;\\n        let a = go(i + 1),\\n            b = i + 1 < N && s[i] == s[i + 1] ? go(i + 2) : 0,\\n            c = i + 2 < N && s[i] == s[i + 1] && s[i + 1] == s[i + 2] ? go(i + 3) : 0,\\n            d = i + 3 < N && s[i] == s[i + 1] && s[i + 1] == s[i + 2] && s[i + 2] == s[i + 3] && (s[i] == \\'7\\' || s[i] == \\'9\\') ? go(i + 4) : 0;\\n        return (a + b + c + d) % Number(1e9 + 7);\\n    };\\n    return go();\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nlet countTexts = (s, m = new Map()) => {\\n    let N = s.length;\\n    let go = (i = 0) => {\\n        if (i == N)\\n            return 1;\\n        if (!m.has(i)) {\\n            let a = go(i + 1),\\n                b = i + 1 < N && s[i] == s[i + 1] ? go(i + 2) : 0,\\n                c = i + 2 < N && s[i] == s[i + 1] && s[i + 1] == s[i + 2] ? go(i + 3) : 0,\\n                d = i + 3 < N && s[i] == s[i + 1] && s[i + 1] == s[i + 2] && s[i + 2] == s[i + 3] && (s[i] == \\'7\\' || s[i] == \\'9\\') ? go(i + 4) : 0;\\n            m.set(i, (a + b + c + d) % Number(1e9 + 7));\\n        }\\n        return m.get(i);\\n    };\\n    return go();\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nlet countTexts = s => {\\n    let N = s.length;\\n    let dp = Array(N + 1).fill(0);\\n    dp[N] = 1;\\n    for (let i = N - 1; 0 <= i; --i) {\\n        let a = dp[i + 1],\\n            b = i + 1 < N && s[i] == s[i + 1] ? dp[i + 2] : 0,\\n            c = i + 2 < N && s[i] == s[i + 1] && s[i + 1] == s[i + 2] ? dp[i + 3] : 0,\\n            d = i + 3 < N && s[i] == s[i + 1] && s[i + 1] == s[i + 2] && s[i + 2] == s[i + 3] && (s[i] == \\'7\\' || s[i] == \\'9\\') ? dp[i + 4] : 0;\\n        dp[i] = (a + b + c + d) % Number(1e9 + 7);\\n    }\\n    return dp[0];\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun countTexts(s: String): Int {\\n        var N = s.length\\n        var run = IntArray(N) { 1 }\\n        for (i in N - 2 downTo(0))\\n            if (s[i] == s[i + 1])\\n                run[i] = Math.min(1 + run[i + 1], if (s[i] == \\'7\\' || s[i] == \\'9\\') 4 else 3)\\n        fun go(i: Int = 0): Int {\\n            if (i == N)\\n                return 1\\n            var cnt = 0\\n            for (k in 1..run[i])\\n                if (i + k <= N)\\n                    cnt += go(i + k)\\n            return cnt\\n        }\\n        return go()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun countTexts(s: String, m: MutableMap<Int, Int> = mutableMapOf<Int, Int>()): Int {\\n        var N = s.length\\n        var run = IntArray(N) { 1 }\\n        for (i in N - 2 downTo(0))\\n            if (s[i] == s[i + 1])\\n                run[i] = Math.min(1 + run[i + 1], if (s[i] == \\'7\\' || s[i] == \\'9\\') 4 else 3)\\n        fun go(i: Int = 0): Int {\\n            if (i == N)\\n                return 1\\n            if (!m.contains(i)) {\\n                var cnt = 0\\n                for (k in 1..run[i])\\n                    if (i + k <= N)\\n                        cnt = (cnt + go(i + k)) % (1e9 + 7).toInt()\\n                m[i] = cnt\\n            }\\n            return m[i]!!\\n        }\\n        return go()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun countTexts(s: String, m: MutableMap<Int, Int> = mutableMapOf<Int, Int>()): Int {\\n        var N = s.length\\n        var run = IntArray(N) { 1 }\\n        for (i in N - 2 downTo(0))\\n            if (s[i] == s[i + 1])\\n                run[i] = Math.min(1 + run[i + 1], if (s[i] == \\'7\\' || s[i] == \\'9\\') 4 else 3)\\n        var dp = IntArray(N + 1) { 0 }\\n        dp[N] = 1\\n        for (i in N - 1 downTo 0)\\n            for (k in 1..run[i])\\n                if (i + k <= N)\\n                    dp[i] = (dp[i] + dp[i + k]) % (1e9 + 7).toInt()\\n        return dp[0]\\n    }\\n}\\n```\n```\\nlet countTexts = s => {\\n    let N = s.length;\\n    let run = Array(N).fill(1);\\n    for (let i = N - 1; 0 <= i; --i)\\n        if (s[i] == s[i + 1])\\n            run[i] = Math.min(1 + run[i + 1], s[i] == \\'7\\' || s[i] == \\'9\\' ? 4 : 3);\\n    let go = (i = 0, cnt = 0) => {\\n        if (i == N)\\n            return 1;\\n        for (let k = 1; k <= run[i]; ++k)\\n            if (i + k <= N)\\n                cnt += go(i + k);\\n        return cnt;\\n    };\\n    return go();\\n};\\n```\n```\\nlet countTexts = (s, m = new Map()) => {\\n    let N = s.length;\\n    let run = Array(N).fill(1);\\n    for (let i = N - 1; 0 <= i; --i)\\n        if (s[i] == s[i + 1])\\n            run[i] = Math.min(1 + run[i + 1], s[i] == \\'7\\' || s[i] == \\'9\\' ? 4 : 3);\\n    let go = (i = 0, cnt = 0) => {\\n        if (i == N)\\n            return 1;\\n        if (!m.has(i)) {\\n            for (let k = 1; k <= run[i]; ++k)\\n                if (i + k <= N)\\n                    cnt = (cnt + go(i + k)) % Number(1e9 + 7);\\n            m.set(i, cnt);\\n        }\\n        return m.get(i);\\n    };\\n    return go();\\n};\\n```\n```\\nlet countTexts = (s, m = new Map()) => {\\n    let N = s.length;\\n    let run = Array(N).fill(1);\\n    for (let i = N - 1; 0 <= i; --i)\\n        if (s[i] == s[i + 1])\\n            run[i] = Math.min(1 + run[i + 1], s[i] == \\'7\\' || s[i] == \\'9\\' ? 4 : 3);\\n    let dp = Array(N + 1).fill(0);\\n    dp[N] = 1;\\n    for (let i = N - 1; 0 <= i; --i)\\n        for (let k = 1; k <= run[i]; ++k)\\n            if (i + k <= N)\\n                dp[i] = (dp[i] + dp[i + k]) % Number(1e9 + 7);\\n    return dp[0];\\n};\\n```\n```\\nclass Solution:\\n    def countTexts(self, s: str) -> int:\\n        N = len(s)\\n        run = [1] * N\\n        for i in range(N - 2, -1, -1):\\n            if s[i] == s[i + 1]:\\n                run[i] = min(1 + run[i + 1], 4 if s[i] == \\'7\\' or s[i] == \\'9\\' else 3)\\n        def go(i = 0, cnt = 0):\\n            if i == N:\\n                return 1\\n            for k in range(1, run[i] + 1):\\n                if i + k <= N:\\n                    cnt = (cnt + go(i + k)) % int(1e9 + 7)\\n            return cnt\\n        return go()\\n```\n```\\nclass Solution:\\n    def countTexts(self, s: str) -> int:\\n        N = len(s)\\n        run = [1] * N\\n        for i in range(N - 2, -1, -1):\\n            if s[i] == s[i + 1]:\\n                run[i] = min(1 + run[i + 1], 4 if s[i] == \\'7\\' or s[i] == \\'9\\' else 3)\\n        @cache\\n        def go(i = 0, cnt = 0):\\n            if i == N:\\n                return 1\\n            for k in range(1, run[i] + 1):\\n                if i + k <= N:\\n                    cnt = (cnt + go(i + k)) % int(1e9 + 7)\\n            return cnt\\n        return go()\\n```\n```\\nclass Solution:\\n    def countTexts(self, s: str) -> int:\\n        N = len(s)\\n        run = [1] * N\\n        for i in range(N - 2, -1, -1):\\n            if s[i] == s[i + 1]:\\n                run[i] = min(1 + run[i + 1], 4 if s[i] == \\'7\\' or s[i] == \\'9\\' else 3)\\n        dp = [0] * (N + 1)\\n        dp[N] = 1\\n        for i in range(N - 1, -1, -1):\\n            for k in range(1, run[i] + 1):\\n                if i + k <= N:\\n                    dp[i] = (dp[i] + dp[i + k]) % int(1e9 + 7)\\n        return dp[0]\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int)>;\\n    int countTexts(string s) {\\n        int N = s.size();\\n        VI run(N, 1);\\n        for (auto i{ N - 2 }; 0 <= i; --i)\\n            if (s[i] == s[i + 1])\\n                run[i] = min(1 + run[i + 1], s[i] == \\'7\\' || s[i] == \\'9\\' ? 4 : 3);\\n        fun go = [&](auto i) {\\n            if (i == N)\\n                return 1;\\n            auto cnt = 0;\\n            for (auto k{ 1 }; k <= run[i]; ++k)\\n                if (i + k <= N)\\n                    cnt = (cnt + go(i + k)) % int(1e9 + 7);\\n            return cnt;\\n        };\\n        return go(0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int)>;\\n    using Map = unordered_map<int, int>;\\n    int countTexts(string s, Map m = {}) {\\n        int N = s.size();\\n        VI run(N, 1);\\n        for (auto i{ N - 2 }; 0 <= i; --i)\\n            if (s[i] == s[i + 1])\\n                run[i] = min(1 + run[i + 1], s[i] == \\'7\\' || s[i] == \\'9\\' ? 4 : 3);\\n        fun go = [&](auto i) {\\n            if (i == N)\\n                return 1;\\n            if (m.find(i) == m.end()) {\\n                auto cnt = 0;\\n                for (auto k{ 1 }; k <= run[i]; ++k)\\n                    if (i + k <= N)\\n                        cnt = (cnt + go(i + k)) % int(1e9 + 7);\\n                m[i] = cnt;\\n            }\\n            return m[i];\\n        };\\n        return go(0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int)>;\\n    using Map = unordered_map<int, int>;\\n    int countTexts(string s, Map m = {}) {\\n        int N = s.size();\\n        VI run(N, 1);\\n        for (auto i{ N - 2 }; 0 <= i; --i)\\n            if (s[i] == s[i + 1])\\n                run[i] = min(1 + run[i + 1], s[i] == \\'7\\' || s[i] == \\'9\\' ? 4 : 3);\\n        VI dp(N + 1, 0);\\n        dp[N] = 1;\\n        for (auto i{ N - 1 }; 0 <= i; --i)\\n            for (auto k{ 1 }; k <= run[i]; ++k)\\n                if (i + k <= N)\\n                    dp[i] = (dp[i] + dp[i + k]) % int(1e9 + 7);\\n        return dp[0];\\n    }\\n};\\n```\n```\\nlet countTexts = s => {\\n    let N = s.length;\\n    let go = (i = 0) => {\\n        if (i == N)\\n            return 1;\\n        let a = go(i + 1),\\n            b = i + 1 < N && s[i] == s[i + 1] ? go(i + 2) : 0,\\n            c = i + 2 < N && s[i] == s[i + 1] && s[i + 1] == s[i + 2] ? go(i + 3) : 0,\\n            d = i + 3 < N && s[i] == s[i + 1] && s[i + 1] == s[i + 2] && s[i + 2] == s[i + 3] && (s[i] == \\'7\\' || s[i] == \\'9\\') ? go(i + 4) : 0;\\n        return (a + b + c + d) % Number(1e9 + 7);\\n    };\\n    return go();\\n};\\n```\n```\\nlet countTexts = (s, m = new Map()) => {\\n    let N = s.length;\\n    let go = (i = 0) => {\\n        if (i == N)\\n            return 1;\\n        if (!m.has(i)) {\\n            let a = go(i + 1),\\n                b = i + 1 < N && s[i] == s[i + 1] ? go(i + 2) : 0,\\n                c = i + 2 < N && s[i] == s[i + 1] && s[i + 1] == s[i + 2] ? go(i + 3) : 0,\\n                d = i + 3 < N && s[i] == s[i + 1] && s[i + 1] == s[i + 2] && s[i + 2] == s[i + 3] && (s[i] == \\'7\\' || s[i] == \\'9\\') ? go(i + 4) : 0;\\n            m.set(i, (a + b + c + d) % Number(1e9 + 7));\\n        }\\n        return m.get(i);\\n    };\\n    return go();\\n};\\n```\n```\\nlet countTexts = s => {\\n    let N = s.length;\\n    let dp = Array(N + 1).fill(0);\\n    dp[N] = 1;\\n    for (let i = N - 1; 0 <= i; --i) {\\n        let a = dp[i + 1],\\n            b = i + 1 < N && s[i] == s[i + 1] ? dp[i + 2] : 0,\\n            c = i + 2 < N && s[i] == s[i + 1] && s[i + 1] == s[i + 2] ? dp[i + 3] : 0,\\n            d = i + 3 < N && s[i] == s[i + 1] && s[i + 1] == s[i + 2] && s[i + 2] == s[i + 3] && (s[i] == \\'7\\' || s[i] == \\'9\\') ? dp[i + 4] : 0;\\n        dp[i] = (a + b + c + d) % Number(1e9 + 7);\\n    }\\n    return dp[0];\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2037505,
                "title": "c-dp-solution",
                "content": "\\'\\'\\'\\n\\n    int countTexts(string pressedKeys) {\\n        int n = pressedKeys.length();\\n        vector<long long> dp(n+1);\\n        dp[0]=1;\\n        int cnt;\\n        for(int i=0;i<pressedKeys.size();i++)\\n        {\\n            int j=i;\\n            if(pressedKeys[i]==\\'7\\' || pressedKeys[i]==\\'9\\')\\n            {\\n                cnt=4;\\n            }\\n            else\\n            {\\n                cnt=3;\\n            }\\n            while(j>=0 && cnt>0 && pressedKeys[j]==pressedKeys[i])\\n            {\\n                dp[i+1] = (dp[i+1] + dp[j])%1000000007;\\n                j--;\\n                cnt--;\\n            }\\n        }\\n        \\n        return dp[n];    \\n    }\\n\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "\\'\\'\\'\\n\\n    int countTexts(string pressedKeys) {\\n        int n = pressedKeys.length();\\n        vector<long long> dp(n+1);\\n        dp[0]=1;\\n        int cnt;\\n        for(int i=0;i<pressedKeys.size();i++)\\n        {\\n            int j=i;\\n            if(pressedKeys[i]==\\'7\\' || pressedKeys[i]==\\'9\\')\\n            {\\n                cnt=4;\\n            }\\n            else\\n            {\\n                cnt=3;\\n            }\\n            while(j>=0 && cnt>0 && pressedKeys[j]==pressedKeys[i])\\n            {\\n                dp[i+1] = (dp[i+1] + dp[j])%1000000007;\\n                j--;\\n                cnt--;\\n            }\\n        }\\n        \\n        return dp[n];    \\n    }\\n\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 2037028,
                "title": "go-dp",
                "content": "```\\nfunc countTexts(pressedKeys string) int {\\n    pressedKeysLen := len(pressedKeys)\\n    dp := make([]int, pressedKeysLen + 1)\\n    dp[0] = 1\\n    dp[1] = 1\\n    modulo := int(1e9+7)\\n    for i := 1; i < pressedKeysLen; i++ {\\n        dp[i + 1] = dp[i]\\n        if i >= 1 && pressedKeys[i] == pressedKeys[i - 1] {\\n            dp[i + 1] = dp[i] + dp[i - 1]\\n            if i >= 2 && pressedKeys[i] == pressedKeys[i - 2] {\\n                dp[i + 1] = dp[i] + dp[i - 1] + dp[i - 2]\\n                if i >= 3 && (string(pressedKeys[i]) == \"7\" || string(pressedKeys[i]) == \"9\") {\\n                    if pressedKeys[i] == pressedKeys[i - 3] {\\n                        dp[i + 1] = dp[i] + dp[i - 1] + dp[i - 2] + dp[i - 3]\\n                    }\\n                }\\n            }\\n        }\\n        dp[i + 1] %= modulo\\n    }\\n    return dp[pressedKeysLen] \\n}",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```\\nfunc countTexts(pressedKeys string) int {\\n    pressedKeysLen := len(pressedKeys)\\n    dp := make([]int, pressedKeysLen + 1)\\n    dp[0] = 1\\n    dp[1] = 1\\n    modulo := int(1e9+7)\\n    for i := 1; i < pressedKeysLen; i++ {\\n        dp[i + 1] = dp[i]\\n        if i >= 1 && pressedKeys[i] == pressedKeys[i - 1] {\\n            dp[i + 1] = dp[i] + dp[i - 1]\\n            if i >= 2 && pressedKeys[i] == pressedKeys[i - 2] {\\n                dp[i + 1] = dp[i] + dp[i - 1] + dp[i - 2]\\n                if i >= 3 && (string(pressedKeys[i]) == \"7\" || string(pressedKeys[i]) == \"9\") {\\n                    if pressedKeys[i] == pressedKeys[i - 3] {\\n                        dp[i + 1] = dp[i] + dp[i - 1] + dp[i - 2] + dp[i - 3]\\n                    }\\n                }\\n            }\\n        }\\n        dp[i + 1] %= modulo\\n    }\\n    return dp[pressedKeysLen] \\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2033632,
                "title": "easy-understanding-code-in-python-with-16-lines",
                "content": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        MOD = 10 ** 9 + 7\\n        dp = [1] + [0] * len(pressedKeys)\\n        prev, c = None, 0\\n        for i, key in enumerate(pressedKeys):\\n            if key == prev:\\n                digits = 4 if prev in \\'79\\' else 3\\n                start = i + 1 - min(digits, c + 1) # c + 1 because in 22233 case, when we look at the last 3, we need to look at the combinations at last \\'2\\' and first \\'3\\' so look back c + 1\\n                dp[i+1] = sum(dp[start : i + 1]) % MOD  # i + 1 because we have a table of len + 1. and we are filling at i + 1 index.\\n                c += 1\\n            else:\\n                dp[i+1] = dp[i] % MOD\\n                c = 1\\n            prev = key\\n        return dp[-1] % MOD\\n```\\nFirst post, hope you enjoy it.\\n\\n\\n\\n\\nI would also like to share a ugly but efficient code with a very simple idea(beats 97.71%):\\n```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        MOD = 10 ** 9 + 7\\n        chr3 = []\\n        chr4 = []\\n        prev = pressedKeys[0]\\n        c = 1\\n        \\n        for key in pressedKeys[1:]:\\n            if key == prev:\\n                c += 1\\n            else:\\n                if prev in {\\'7\\', \\'9\\'}:\\n                    chr4.append(c)\\n                else:\\n                    chr3.append(c)\\n                c = 1\\n            prev = key\\n        if prev in {\\'7\\', \\'9\\'}:\\n            chr4.append(c)\\n        else:\\n            chr3.append(c)\\n        \\n        def getCounts(num, digits):\\n            dp = [1] + [0] * num\\n            for i in range(1, num + 1):\\n                start = i - digits\\n                dp[i] = sum(dp[start if start >=0 else 0 : i])%MOD\\n            return dp\\n        \\n        res = 1\\n        if chr3:\\n            max_counts3 = max(chr3)\\n            dp_3digs = getCounts(max_counts3, 3)\\n            for count in chr3:\\n                res *= dp_3digs[count]%MOD\\n        if chr4:\\n            max_counts4 = max(chr4)\\n            dp_4digs = getCounts(max_counts4, 4)\\n            for count in chr4:\\n                res *= dp_4digs[count]%MOD\\n        MOD = 10**9+7\\n        return res%MOD\\n```\\nThe code looks long, but the main idea is simple.\\nIf we have 22222223333444, we find it\\'s seven \\'2\\', four \\'3\\', three \\'4\\'.\\nWe simply return the combinations with 7 repeating numbers x 4 repeating numbers x 3 repeating numbers, without considering what\\'s the number.\\nThen construct a dp table with the longest repeating int size, which is 7 here.\\nwe return dp[7] * dp[3] * dp[4] and only generate a dp table of size 7!\\n\\nIf we have 7 or 9, simply construct another dp table and others remains the same.\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        MOD = 10 ** 9 + 7\\n        dp = [1] + [0] * len(pressedKeys)\\n        prev, c = None, 0\\n        for i, key in enumerate(pressedKeys):\\n            if key == prev:\\n                digits = 4 if prev in \\'79\\' else 3\\n                start = i + 1 - min(digits, c + 1) # c + 1 because in 22233 case, when we look at the last 3, we need to look at the combinations at last \\'2\\' and first \\'3\\' so look back c + 1\\n                dp[i+1] = sum(dp[start : i + 1]) % MOD  # i + 1 because we have a table of len + 1. and we are filling at i + 1 index.\\n                c += 1\\n            else:\\n                dp[i+1] = dp[i] % MOD\\n                c = 1\\n            prev = key\\n        return dp[-1] % MOD\\n```\n```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        MOD = 10 ** 9 + 7\\n        chr3 = []\\n        chr4 = []\\n        prev = pressedKeys[0]\\n        c = 1\\n        \\n        for key in pressedKeys[1:]:\\n            if key == prev:\\n                c += 1\\n            else:\\n                if prev in {\\'7\\', \\'9\\'}:\\n                    chr4.append(c)\\n                else:\\n                    chr3.append(c)\\n                c = 1\\n            prev = key\\n        if prev in {\\'7\\', \\'9\\'}:\\n            chr4.append(c)\\n        else:\\n            chr3.append(c)\\n        \\n        def getCounts(num, digits):\\n            dp = [1] + [0] * num\\n            for i in range(1, num + 1):\\n                start = i - digits\\n                dp[i] = sum(dp[start if start >=0 else 0 : i])%MOD\\n            return dp\\n        \\n        res = 1\\n        if chr3:\\n            max_counts3 = max(chr3)\\n            dp_3digs = getCounts(max_counts3, 3)\\n            for count in chr3:\\n                res *= dp_3digs[count]%MOD\\n        if chr4:\\n            max_counts4 = max(chr4)\\n            dp_4digs = getCounts(max_counts4, 4)\\n            for count in chr4:\\n                res *= dp_4digs[count]%MOD\\n        MOD = 10**9+7\\n        return res%MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2031394,
                "title": "java-dp-simple",
                "content": "```\\n\\tpublic int countTexts(String pk) {\\n        long[] _3digits = new long[]{1, 2, 4, 7};\\n        long[] _4digits = new long[]{1, 2, 4, 8};\\n        int n = pk.length();\\n        char ch = pk.charAt(0);\\n        int count = 1;\\n        long res = 1;\\n        long[] toAdd = (ch == \\'7\\' || ch == \\'9\\')? _4digits : _3digits;\\n        List<Long> freq = Arrays.stream(toAdd).boxed().collect(Collectors.toList());\\n        int modulo = 1000000007;\\n        \\n        for(int i=1; i<n; i++) {\\n            if (pk.charAt(i) == ch) {\\n                count++;\\n                if (count > 4) {\\n                    long newCount = (freq.get(count - 2) + freq.get(count - 3) + freq.get(count - 4)) % modulo;\\n                    newCount = (ch == \\'7\\' || ch == \\'9\\')? (newCount + freq.get(count - 5))%modulo : newCount;\\n                    freq.add(newCount);\\n                }\\n            }else{\\n                res = (res * freq.get(count - 1)) % modulo;\\n                \\n                ch = pk.charAt(i);\\n                toAdd = (ch == \\'7\\' || ch == \\'9\\')? _4digits : _3digits;\\n                freq = Arrays.stream(toAdd).boxed().collect(Collectors.toList());\\n                count = 1;\\n            }\\n        }\\n        \\n        res = (res * freq.get(count - 1)) % modulo;\\n        return (int) res;\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\tpublic int countTexts(String pk) {\\n        long[] _3digits = new long[]{1, 2, 4, 7};\\n        long[] _4digits = new long[]{1, 2, 4, 8};\\n        int n = pk.length();\\n        char ch = pk.charAt(0);\\n        int count = 1;\\n        long res = 1;\\n        long[] toAdd = (ch == \\'7\\' || ch == \\'9\\')? _4digits : _3digits;\\n        List<Long> freq = Arrays.stream(toAdd).boxed().collect(Collectors.toList());\\n        int modulo = 1000000007;\\n        \\n        for(int i=1; i<n; i++) {\\n            if (pk.charAt(i) == ch) {\\n                count++;\\n                if (count > 4) {\\n                    long newCount = (freq.get(count - 2) + freq.get(count - 3) + freq.get(count - 4)) % modulo;\\n                    newCount = (ch == \\'7\\' || ch == \\'9\\')? (newCount + freq.get(count - 5))%modulo : newCount;\\n                    freq.add(newCount);\\n                }\\n            }else{\\n                res = (res * freq.get(count - 1)) % modulo;\\n                \\n                ch = pk.charAt(i);\\n                toAdd = (ch == \\'7\\' || ch == \\'9\\')? _4digits : _3digits;\\n                freq = Arrays.stream(toAdd).boxed().collect(Collectors.toList());\\n                count = 1;\\n            }\\n        }\\n        \\n        res = (res * freq.get(count - 1)) % modulo;\\n        return (int) res;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2026751,
                "title": "java-tabulation",
                "content": "```\\nclass Solution {\\n    public static int[] press = {0, 0, 3, 3, 3, 3, 3, 4, 3, 4};\\n    int mod = 1000000007;\\n    public int countTexts(String pressedKeys) {\\n        int[] dp = new int[pressedKeys.length()];\\n        dp[0] = 1;\\n        int freq = 1;\\n        \\n        for(int i=1;i<pressedKeys.length();i++){\\n            char ch = pressedKeys.charAt(i);\\n            if(i==0 || ch!=pressedKeys.charAt(i-1)){\\n                freq = 1;\\n            } else {\\n                freq++;\\n            }\\n            \\n            for(int j=1;j<=Math.min(freq, press[ch-\\'0\\']);j++){\\n                dp[i] += ( (i - j == -1) ? 1 : dp[i - j] );\\n                dp[i] %= mod;\\n            }\\n        }\\n        \\n        return dp[dp.length-1];\\n    }\\n}\\n```\\n\\n# Notes :- \\n\\n1. freq denotes the possible amount of times a key can be pressed. For instance, in the message \"222\", the third \\'2\\' can either be pressed once to type \\'a\\', or twice to type \\'b\\' or thrice simultaneously to type \\'c\\'. \\n2. Math.min(freq, press[ch-\\'0\\']) is necessary. For instance, in the message \"2222\", there is no mapping for all 2\\'s being pressed simultaneously. The 4rth 2 was either pressed once to type \\'a\\', or twice alongwith 3rd \\'2\\' to type \\'b\\' or thrice alongwith 2nd and 3rd \\'2\\' to type \\'c\\'. The \\'min\\' part will ensure that the simultaneous presses of a digit doesn\\'t exceed the allowed maximum simultaneous press for that digit.\\n3. The ( i - j == -1) part only makes sense if first 2 digits are the same, just to escape from \"Array Out Of Bounds Exception\".\\n\\n* Time Complexity :- O(4*N) => O(N)\\n* Space Complexity :- O(N)\\n\\nHope you found the solution and the notes insightful !",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public static int[] press = {0, 0, 3, 3, 3, 3, 3, 4, 3, 4};\\n    int mod = 1000000007;\\n    public int countTexts(String pressedKeys) {\\n        int[] dp = new int[pressedKeys.length()];\\n        dp[0] = 1;\\n        int freq = 1;\\n        \\n        for(int i=1;i<pressedKeys.length();i++){\\n            char ch = pressedKeys.charAt(i);\\n            if(i==0 || ch!=pressedKeys.charAt(i-1)){\\n                freq = 1;\\n            } else {\\n                freq++;\\n            }\\n            \\n            for(int j=1;j<=Math.min(freq, press[ch-\\'0\\']);j++){\\n                dp[i] += ( (i - j == -1) ? 1 : dp[i - j] );\\n                dp[i] %= mod;\\n            }\\n        }\\n        \\n        return dp[dp.length-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2022776,
                "title": "java-dp",
                "content": "```\\nclass Solution {\\n    Long[][] mem = null;\\n    public int countTexts(String p) {\\n        mem = new Long[p.length()+1][10];\\n        Stack<int[]> arr = new Stack();\\n        for(int i=0; i<p.length(); i++) {\\n            if (arr.size() == 0 || arr.peek()[0] != (p.charAt(i)-\\'0\\')) {\\n                arr.push(new int[]{p.charAt(i)-\\'0\\', 1});\\n            } else {\\n                arr.peek()[1]++;\\n            }\\n        }\\n        \\n        ArrayList<int[]> list = new ArrayList(arr);\\n        long prod = 1;\\n        for(int[] x: list) {\\n            prod *= dp(x[1], x[0])%1000000007;\\n            prod = prod % 1000000007;\\n        }\\n        return (int)(prod%1000000007);\\n    }\\n    \\n    long dp(int c, int l) {\\n        int[] let = new int[]{0,0,3,3,3,3,3,4,3,4};\\n        if (c <= 0) return 1;\\n        if (mem[c][l] != null) return mem[c][l];\\n        long ans = 0;\\n        for(int i=1; i<=let[l]; i++) {\\n            if (c >=i) ans += dp(c-i, l)%1000000007;\\n            ans = ans%1000000007;\\n        }\\n        mem[c][l] = ans;\\n        return ans;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    Long[][] mem = null;\\n    public int countTexts(String p) {\\n        mem = new Long[p.length()+1][10];\\n        Stack<int[]> arr = new Stack();\\n        for(int i=0; i<p.length(); i++) {\\n            if (arr.size() == 0 || arr.peek()[0] != (p.charAt(i)-\\'0\\')) {\\n                arr.push(new int[]{p.charAt(i)-\\'0\\', 1});\\n            } else {\\n                arr.peek()[1]++;\\n            }\\n        }\\n        \\n        ArrayList<int[]> list = new ArrayList(arr);\\n        long prod = 1;\\n        for(int[] x: list) {\\n            prod *= dp(x[1], x[0])%1000000007;\\n            prod = prod % 1000000007;\\n        }\\n        return (int)(prod%1000000007);\\n    }\\n    \\n    long dp(int c, int l) {\\n        int[] let = new int[]{0,0,3,3,3,3,3,4,3,4};\\n        if (c <= 0) return 1;\\n        if (mem[c][l] != null) return mem[c][l];\\n        long ans = 0;\\n        for(int i=1; i<=let[l]; i++) {\\n            if (c >=i) ans += dp(c-i, l)%1000000007;\\n            ans = ans%1000000007;\\n        }\\n        mem[c][l] = ans;\\n        return ans;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2021727,
                "title": "java-dp",
                "content": "```\\nclass Solution {\\n    private static final int MOD = 1_000_000_007;\\n    \\n    public int countTexts(String passedKeys) {\\n        int[] dp = new int[passedKeys.length()+1];\\n        dp[0] = 1;\\n        \\n        for(int i=1; i<=passedKeys.length(); i++){\\n            char c = passedKeys.charAt(i-1);\\n            \\n            dp[i] += dp[i-1];\\n            if(i >= 2 && passedKeys.charAt(i-1) == passedKeys.charAt(i-2)){\\n                dp[i] = (dp[i] + dp[i-2])%MOD;\\n            }\\n            \\n            if(i >= 3 && passedKeys.charAt(i-1) == passedKeys.charAt(i-2) && passedKeys.charAt(i-2) == passedKeys.charAt(i-3)){\\n                dp[i] = (dp[i] + dp[i-3])%MOD;\\n            }\\n            \\n            if(c == \\'7\\' || c == \\'9\\'){\\n                if(i >= 4 && passedKeys.charAt(i-1) == passedKeys.charAt(i-2) && passedKeys.charAt(i-2) == passedKeys.charAt(i-3)\\n                         && passedKeys.charAt(i-3) == passedKeys.charAt(i-4)\\n                  ){\\n                    dp[i] = (dp[i] + dp[i-4])%MOD;\\n                }   \\n            }\\n        }\\n        \\n        return (int)(dp[passedKeys.length()]%MOD);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private static final int MOD = 1_000_000_007;\\n    \\n    public int countTexts(String passedKeys) {\\n        int[] dp = new int[passedKeys.length()+1];\\n        dp[0] = 1;\\n        \\n        for(int i=1; i<=passedKeys.length(); i++){\\n            char c = passedKeys.charAt(i-1);\\n            \\n            dp[i] += dp[i-1];\\n            if(i >= 2 && passedKeys.charAt(i-1) == passedKeys.charAt(i-2)){\\n                dp[i] = (dp[i] + dp[i-2])%MOD;\\n            }\\n            \\n            if(i >= 3 && passedKeys.charAt(i-1) == passedKeys.charAt(i-2) && passedKeys.charAt(i-2) == passedKeys.charAt(i-3)){\\n                dp[i] = (dp[i] + dp[i-3])%MOD;\\n            }\\n            \\n            if(c == \\'7\\' || c == \\'9\\'){\\n                if(i >= 4 && passedKeys.charAt(i-1) == passedKeys.charAt(i-2) && passedKeys.charAt(i-2) == passedKeys.charAt(i-3)\\n                         && passedKeys.charAt(i-3) == passedKeys.charAt(i-4)\\n                  ){\\n                    dp[i] = (dp[i] + dp[i-4])%MOD;\\n                }   \\n            }\\n        }\\n        \\n        return (int)(dp[passedKeys.length()]%MOD);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2019838,
                "title": "python-dfs-with-memoization-groupby-o-n-easy-to-read",
                "content": "```\\nfrom functools import lru_cache\\nfrom itertools import groupby\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        d = [0, 0, 3, 3, 3, 3, 3, 4, 3, 4]\\n        M = 10**9+7\\n        @lru_cache(None)\\n        def dfs(i, k):\\n            if i == 0: return 1\\n            if i < 0: return 0\\n            res = 0\\n            for j in range(1,k+1):\\n                res = (res + dfs(i-j, k))%M\\n            return res\\n        groups = [(int(k),len(list(v))) for k, v in groupby(pressedKeys)]\\n        res = 1\\n        for k, l in groups:\\n            res = (res*dfs(l, d[k]))%M\\n        return res",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nfrom functools import lru_cache\\nfrom itertools import groupby\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        d = [0, 0, 3, 3, 3, 3, 3, 4, 3, 4]\\n        M = 10**9+7\\n        @lru_cache(None)\\n        def dfs(i, k):\\n            if i == 0: return 1\\n            if i < 0: return 0\\n            res = 0\\n            for j in range(1,k+1):\\n                res = (res + dfs(i-j, k))%M\\n            return res\\n        groups = [(int(k),len(list(v))) for k, v in groupby(pressedKeys)]\\n        res = 1\\n        for k, l in groups:\\n            res = (res*dfs(l, d[k]))%M\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2019618,
                "title": "python-3-dp-bottom-up",
                "content": "Take 22223 for an example. \\n\\n2: `a`\\n2+2: 1st `a` plus another `a` gives `aa`, and connecting two 2s gives `b`. Total number of interpretations doubled.\\n22+2: `aa` and `b` from previous index appending another `a` gives `aaa` and `ba`; connecting the last 2 with the 2nd gives `ab`; and connecting all 3 2s gives `c`. Total number of interpretations doubled.\\n222+2: since `maximum connectable` 2s == 3, the additional interpretations it brings are:\\n\\t\\tinterpreations for 2 + 222 (`c`)\\n\\t\\tinterpretations for 22 + 22 (`b`)\\n\\t\\tinterpretations for 222 + 2 (`a`)\\n2222+3: 3 is a different digit to 2, it does not change the number of interpretations.\\n\\nFor digits 7 and 9, `maximum connectable` == 4.\\n\\nState transition:\\n```\\nif digit[i] != digit[i-1]:\\n\\tdp[i] = dp[i - 1]\\nelse:\\n\\tif connected <= max_connectable:\\n\\t\\tdp[i] = dp[i - 1] * 2\\n\\telse:\\n\\t\\tdp[i] += dp[i - j] for j in range(1 to max_connectable inclusively)\\n```\\n\\n```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        n = len(pressedKeys)\\n        mod = 1_000_000_007\\n        \\n        dp = [0] * n\\n        dp[0] = 1\\n        cnt = 1\\n        \\n        for i in range(1, n):\\n            if pressedKeys[i] != pressedKeys[i - 1]:\\n                dp[i] = dp[i - 1]\\n                cnt = 1\\n            else:\\n                cnt += 1\\n                if pressedKeys[i] != \\'7\\' and pressedKeys[i] != \\'9\\':\\n                    if cnt <= 3:\\n                        dp[i] = dp[i - 1] * 2 % mod\\n                    else:\\n                        dp[i] = (dp[i - 1] + dp[i - 2] + dp[i - 3]) % mod\\n                else:\\n                    if cnt <= 4:\\n                        dp[i] = dp[i - 1] * 2 % mod\\n                    else:\\n                        dp[i] = (dp[i - 1] + dp[i - 2] + dp[i - 3] + dp[i - 4]) % mod\\n        return dp[-1]\\n```\\n\\nA prefix sum can provide minor acceleration.\\n\\n```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        n = len(pressedKeys)\\n        mod = 1_000_000_007\\n        \\n        dp = [0] * n\\n        dp[0] = 1\\n        cnt = 1\\n        _sum = 1\\n        \\n        for i in range(1, n):\\n            if pressedKeys[i] != pressedKeys[i - 1]:\\n                dp[i] = dp[i - 1]\\n                cnt = 1\\n                _sum = dp[i]\\n            else:\\n                cnt += 1\\n                if pressedKeys[i] != \\'7\\' and pressedKeys[i] != \\'9\\':\\n                    if cnt <= 3:\\n                        dp[i] = dp[i - 1] * 2 % mod\\n                        _sum += dp[i]\\n                    else:\\n                        dp[i] = _sum % mod\\n                        _sum = _sum + dp[i] - dp[i - 3]\\n                else:\\n                    if cnt <= 4:\\n                        dp[i] = dp[i - 1] * 2 % mod\\n                        if cnt < 4:\\n                            _sum += dp[i]\\n                        else:\\n                            _sum = _sum + dp[i] - dp[i - 3]\\n                    else:\\n                        dp[i] = (_sum + dp[i - 4]) % mod\\n                        _sum = _sum + dp[i] - dp[i - 3]\\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nif digit[i] != digit[i-1]:\\n\\tdp[i] = dp[i - 1]\\nelse:\\n\\tif connected <= max_connectable:\\n\\t\\tdp[i] = dp[i - 1] * 2\\n\\telse:\\n\\t\\tdp[i] += dp[i - j] for j in range(1 to max_connectable inclusively)\\n```\n```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        n = len(pressedKeys)\\n        mod = 1_000_000_007\\n        \\n        dp = [0] * n\\n        dp[0] = 1\\n        cnt = 1\\n        \\n        for i in range(1, n):\\n            if pressedKeys[i] != pressedKeys[i - 1]:\\n                dp[i] = dp[i - 1]\\n                cnt = 1\\n            else:\\n                cnt += 1\\n                if pressedKeys[i] != \\'7\\' and pressedKeys[i] != \\'9\\':\\n                    if cnt <= 3:\\n                        dp[i] = dp[i - 1] * 2 % mod\\n                    else:\\n                        dp[i] = (dp[i - 1] + dp[i - 2] + dp[i - 3]) % mod\\n                else:\\n                    if cnt <= 4:\\n                        dp[i] = dp[i - 1] * 2 % mod\\n                    else:\\n                        dp[i] = (dp[i - 1] + dp[i - 2] + dp[i - 3] + dp[i - 4]) % mod\\n        return dp[-1]\\n```\n```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        n = len(pressedKeys)\\n        mod = 1_000_000_007\\n        \\n        dp = [0] * n\\n        dp[0] = 1\\n        cnt = 1\\n        _sum = 1\\n        \\n        for i in range(1, n):\\n            if pressedKeys[i] != pressedKeys[i - 1]:\\n                dp[i] = dp[i - 1]\\n                cnt = 1\\n                _sum = dp[i]\\n            else:\\n                cnt += 1\\n                if pressedKeys[i] != \\'7\\' and pressedKeys[i] != \\'9\\':\\n                    if cnt <= 3:\\n                        dp[i] = dp[i - 1] * 2 % mod\\n                        _sum += dp[i]\\n                    else:\\n                        dp[i] = _sum % mod\\n                        _sum = _sum + dp[i] - dp[i - 3]\\n                else:\\n                    if cnt <= 4:\\n                        dp[i] = dp[i - 1] * 2 % mod\\n                        if cnt < 4:\\n                            _sum += dp[i]\\n                        else:\\n                            _sum = _sum + dp[i] - dp[i - 3]\\n                    else:\\n                        dp[i] = (_sum + dp[i - 4]) % mod\\n                        _sum = _sum + dp[i] - dp[i - 3]\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2019523,
                "title": "dynamic-programming-memoization-java",
                "content": "```\\nclass Solution {\\n    int mod=1000000007;\\n    HashMap<Integer,Integer>map;\\n    public int countTexts(String pressedKeys) {\\n        HashSet<String>set=new HashSet<>();\\n        set.add(\"2\");\\n        set.add(\"22\");\\n        set.add(\"222\");\\n        set.add(\"3\");\\n        set.add(\"33\");\\n        set.add(\"333\");\\n        set.add(\"4\");\\n        set.add(\"44\");\\n        set.add(\"444\");\\n        \\n        set.add(\"5\");\\n        set.add(\"55\");\\n        set.add(\"555\");\\n        set.add(\"6\");\\n        set.add(\"66\");\\n        set.add(\"666\");\\n        set.add(\"7\");\\n        set.add(\"77\");\\n        set.add(\"7777\");\\n        set.add(\"777\");\\n        set.add(\"8\");\\n        set.add(\"88\");\\n        set.add(\"888\");\\n        set.add(\"9\");\\n        set.add(\"99\");\\n        set.add(\"9999\");\\n        set.add(\"999\");\\n        \\n        map=new HashMap<>();\\n        return solver(pressedKeys,set,pressedKeys.length(),0);\\n        \\n    }\\n    \\n    public int solver(String str, HashSet<String>set, int n,int i){\\n        \\n        \\n        if(i==n){\\n            map.put(n,1);\\n            return 1;\\n        }\\n        if(map.containsKey(i)){\\n            return map.get(i);\\n        }\\n        int ans=0;\\n        \\n        for(int j=i+1;j<=n;j++){\\n            String pre=str.substring(i,j);\\n         //   String ros=j==n?\"\":str.substring(j);\\n            if(set.contains(pre)){\\n                if(map.containsKey(j)){\\n                    ans+=map.get(j);\\n                }else{\\n                    ans+=solver(str,set,n,j);\\n                }\\n                \\n                ans%=mod;\\n            }else{\\n                break;\\n            }\\n        }\\n        \\n        map.put(i,ans);\\n        return ans;\\n    }\\n}```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int mod=1000000007;\\n    HashMap<Integer,Integer>map;\\n    public int countTexts(String pressedKeys) {\\n        HashSet<String>set=new HashSet<>();\\n        set.add(\"2\");\\n        set.add(\"22\");\\n        set.add(\"222\");\\n        set.add(\"3\");\\n        set.add(\"33\");\\n        set.add(\"333\");\\n        set.add(\"4\");\\n        set.add(\"44\");\\n        set.add(\"444\");\\n        \\n        set.add(\"5\");\\n        set.add(\"55\");\\n        set.add(\"555\");\\n        set.add(\"6\");\\n        set.add(\"66\");\\n        set.add(\"666\");\\n        set.add(\"7\");\\n        set.add(\"77\");\\n        set.add(\"7777\");\\n        set.add(\"777\");\\n        set.add(\"8\");\\n        set.add(\"88\");\\n        set.add(\"888\");\\n        set.add(\"9\");\\n        set.add(\"99\");\\n        set.add(\"9999\");\\n        set.add(\"999\");\\n        \\n        map=new HashMap<>();\\n        return solver(pressedKeys,set,pressedKeys.length(),0);\\n        \\n    }\\n    \\n    public int solver(String str, HashSet<String>set, int n,int i){\\n        \\n        \\n        if(i==n){\\n            map.put(n,1);\\n            return 1;\\n        }\\n        if(map.containsKey(i)){\\n            return map.get(i);\\n        }\\n        int ans=0;\\n        \\n        for(int j=i+1;j<=n;j++){\\n            String pre=str.substring(i,j);\\n         //   String ros=j==n?\"\":str.substring(j);\\n            if(set.contains(pre)){\\n                if(map.containsKey(j)){\\n                    ans+=map.get(j);\\n                }else{\\n                    ans+=solver(str,set,n,j);\\n                }\\n                \\n                ans%=mod;\\n            }else{\\n                break;\\n            }\\n        }\\n        \\n        map.put(i,ans);\\n        return ans;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 2019257,
                "title": "easy-solution-dp-dynamic-prorgramming-c-explanation-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int countTexts(string s) {\\n        int n=s.length();\\n        int mod=int(1e9)+7;\\n        vector<int>dp(n,0);\\n        unordered_set<string>um;\\n        for(int i=2;i<=9;i++){\\n            string temp=to_string(i);\\n            string cur=temp;\\n            um.insert(cur);\\n            cur+=temp;\\n            um.insert(cur);\\n            cur+=temp;\\n            um.insert(cur);\\n        }\\n        um.insert(\"7777\");\\n        um.insert(\"9999\");\\n        \\n        dp[0]=1;\\n        if(n==1) return dp[0];\\n        string cur=s.substr(0,2);\\n        dp[1]=1;\\n        if(um.find(cur)!=um.end()) dp[1]++;\\n        if(n==2) return dp[1];\\n        cur=s.substr(0,3);            \\n        if(um.find(cur)!=um.end()) dp[2]++;\\n        cur=s.substr(1,2);\\n        if(um.find(cur)!=um.end()) dp[2]+=dp[0];\\n        dp[2]+=dp[1];\\n\\n        for(int i=3;i<n;i++){\\n            dp[i]=dp[i-1]%mod;\\n            string cur1=s.substr(i-2,3);\\n            if(um.find(cur1)!=um.end()) dp[i]=(dp[i-3]%mod+dp[i]%mod)%mod;\\n            cur1=s.substr(i-1,2);\\n            if(um.find(cur1)!=um.end()) dp[i]=(dp[i-2]%mod+dp[i]%mod)%mod;\\n            if(s[i]==\\'7\\' || s[i]==\\'9\\'){\\n                cur1=s.substr(i-3,4);\\n                if(um.find(cur1)!=um.end()){\\n                    if(i==3) dp[i]++;\\n                    else dp[i]=(dp[i-4]%mod+dp[i]%mod)%mod;\\n                } \\n            }\\n        }\\n        \\n        return dp[n-1]%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countTexts(string s) {\\n        int n=s.length();\\n        int mod=int(1e9)+7;\\n        vector<int>dp(n,0);\\n        unordered_set<string>um;\\n        for(int i=2;i<=9;i++){\\n            string temp=to_string(i);\\n            string cur=temp;\\n            um.insert(cur);\\n            cur+=temp;\\n            um.insert(cur);\\n            cur+=temp;\\n            um.insert(cur);\\n        }\\n        um.insert(\"7777\");\\n        um.insert(\"9999\");\\n        \\n        dp[0]=1;\\n        if(n==1) return dp[0];\\n        string cur=s.substr(0,2);\\n        dp[1]=1;\\n        if(um.find(cur)!=um.end()) dp[1]++;\\n        if(n==2) return dp[1];\\n        cur=s.substr(0,3);            \\n        if(um.find(cur)!=um.end()) dp[2]++;\\n        cur=s.substr(1,2);\\n        if(um.find(cur)!=um.end()) dp[2]+=dp[0];\\n        dp[2]+=dp[1];\\n\\n        for(int i=3;i<n;i++){\\n            dp[i]=dp[i-1]%mod;\\n            string cur1=s.substr(i-2,3);\\n            if(um.find(cur1)!=um.end()) dp[i]=(dp[i-3]%mod+dp[i]%mod)%mod;\\n            cur1=s.substr(i-1,2);\\n            if(um.find(cur1)!=um.end()) dp[i]=(dp[i-2]%mod+dp[i]%mod)%mod;\\n            if(s[i]==\\'7\\' || s[i]==\\'9\\'){\\n                cur1=s.substr(i-3,4);\\n                if(um.find(cur1)!=um.end()){\\n                    if(i==3) dp[i]++;\\n                    else dp[i]=(dp[i-4]%mod+dp[i]%mod)%mod;\\n                } \\n            }\\n        }\\n        \\n        return dp[n-1]%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2019221,
                "title": "easy-to-understand-important-concept-involved",
                "content": "Take a test case like [1,1,1,1,1,1], here we have 6 (1) . Now think properly of what we have to do :\\n\\n[1,1,1,1,1,1]-->[a,a,a,a,a] , [a,b,a,a], [a,b,b] etc;\\n\\nIf we closely look its just like :\\n\\n6=1+1+1+1+1+1  => a+a+a+a+a+a\\n6=1+2+1+1 =>a+b+a+a\\n6=1+3+1=>a+c+a\\n\\n6=1+4 NOT VALID || We can only go upto 3 as given in ques (3presses);\\n\\nDoesn\\'t this look similar to COIN-CHANGE Problem , But HERE IS A CATCH , here we have to compute all the PERMUTATIONS unlike COIN CHANGE where we calculated unique PERMUTATION.\\n\\nYou can take help from here regarding Permutation Thing : https://leetcode.com/problems/combination-sum-iv/discuss/1986766/did-u-missed-this-concept-permutations-vs-unique-permutations\\n\\nSolution is as Follows:\\n\\nclass Solution { \\npublic:\\n    \\n    int COINCHANGE(int sum,int k){\\n        int mod=1e9+7;\\n        vector<int>coin={1,2,3};\\n        if(k==7 || k==9){   //since we can press 4 times there\\n            coin.push_back(4);\\n        }\\n        int n=coin.size();\\n        vector<vector<int>>dp(n+1,vector<int>(sum+1,0));\\n        \\n        for(int i=0;i<=sum;i++){\\n            dp[0][i]=0;\\n        }\\n        for(int i=0;i<=n;i++){\\n            dp[i][0]=1;\\n        }\\n        \\n        for(int k=1;k<=sum;k++){\\n            for(int i=1;i<=n;i++){\\n                if(k-coin[i-1]>=0){\\n                    dp[i][k]=(dp[i-1][k]%mod+dp[n][k-coin[i-1]]%mod)%mod;\\n                }\\n                else{\\n                    dp[i][k]=dp[i-1][k]%mod;\\n                }\\n            }\\n        }\\n        return dp[n][sum];\\n    }\\n    int countTexts(string s) {\\n        \\n        int cnt=0;\\n        long long ans=1;\\n        int mod=1e9+7;\\n        s+=\\'$\\';\\n        for(int i=1;i<s.size();i++){\\n            if(s[i]==s[i-1]){\\n                cnt++;\\n            }\\n            else{\\n                int k=s[i-1]-\\'0\\';\\n                ans=((ans%mod)*1LL*(COINCHANGE(cnt+1,k))%mod)%mod;  //Multiplication is done to have all the combinations\\n                ans=ans%mod;\\n                cnt=0;\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n };\\n \\n If it is still unclear, please let me know how can I help.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution { \\npublic:\\n    \\n    int COINCHANGE(int sum,int k){\\n        int mod=1e9+7;\\n        vector<int>coin={1,2,3}",
                "codeTag": "Java"
            },
            {
                "id": 2019187,
                "title": "solution-t-o-n-s-o-1-explain-with-schematic",
                "content": "![image](https://assets.leetcode.com/users/images/f6c8d425-39ab-404f-8de8-3090d74572ea_1652003566.5879638.png)\\ndp[] is the possibilities of text combination.\\nfrom the example, you can understand that \\ndp[i+1]+=dp[i]; // it always can be a letter alone and do not forget the dp[-1] should set to 1\\n- dp[i-1],dp[i-2] //if it can combine with the former pressed\\n- dp[i-3] //if this number is 7 or 9 \\n\\nthe Mod operation should be executed whenever it is added, cause the number will be very large at late stage. \\nP.S\\uFF1AIf the number is less than MOD, it will not be affected.\\n\\n```\\n\\tprivate static final int MOD = 1_000_000_007;\\n    public int countTexts(String pressedKeys) {\\n        //the last we need is i-4, so 5 is enough.\\n        int[] textPossibility = new int[5]; \\n        char[] chars = pressedKeys.toCharArray();\\n        int n = pressedKeys.length();\\n        textPossibility[0]=1;\\n        for(int i=0;i<n;i++){\\n            char c = pressedKeys.charAt(i);\\n            int index = (i+1)%5;\\n            //suppose the letter is the 1 time pressed\\n            textPossibility[index] = textPossibility[i%5]; \\n            if(i>0 && c==pressedKeys.charAt(i-1)){\\n                textPossibility[index]+= textPossibility[(i-1)%5];\\n                textPossibility[index] %= MOD;\\n                if(i>1 && c==pressedKeys.charAt(i-2)){\\n                    textPossibility[index]+= textPossibility[(i-2)%5];\\n                    textPossibility[index] %= MOD;\\n                    if((c==\\'7\\'||c==\\'9\\') && i>2 && c==pressedKeys.charAt(i-3)){\\n                        textPossibility[index]+= textPossibility[(i-3)%5];\\n                        textPossibility[index] %= MOD;\\n                    }\\n                }\\n            }\\n        }\\n        return textPossibility[n%5];\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\tprivate static final int MOD = 1_000_000_007;\\n    public int countTexts(String pressedKeys) {\\n        //the last we need is i-4, so 5 is enough.\\n        int[] textPossibility = new int[5]; \\n        char[] chars = pressedKeys.toCharArray();\\n        int n = pressedKeys.length();\\n        textPossibility[0]=1;\\n        for(int i=0;i<n;i++){\\n            char c = pressedKeys.charAt(i);\\n            int index = (i+1)%5;\\n            //suppose the letter is the 1 time pressed\\n            textPossibility[index] = textPossibility[i%5]; \\n            if(i>0 && c==pressedKeys.charAt(i-1)){\\n                textPossibility[index]+= textPossibility[(i-1)%5];\\n                textPossibility[index] %= MOD;\\n                if(i>1 && c==pressedKeys.charAt(i-2)){\\n                    textPossibility[index]+= textPossibility[(i-2)%5];\\n                    textPossibility[index] %= MOD;\\n                    if((c==\\'7\\'||c==\\'9\\') && i>2 && c==pressedKeys.charAt(i-3)){\\n                        textPossibility[index]+= textPossibility[(i-3)%5];\\n                        textPossibility[index] %= MOD;\\n                    }\\n                }\\n            }\\n        }\\n        return textPossibility[n%5];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2018770,
                "title": "easy-dp-solution-java",
                "content": "```\\n    public int countTexts(String s) {\\n        int n =s.length();\\n        long dp [] =new long[n+1];\\n        dp[0]=1;\\n        int mod = 1000000007;\\n        for(int i=1;i<=n;i++)\\n        {\\n            char ch = s.charAt(i-1);\\n        \\n               dp[i]= (dp[i] + dp[i-1]) % mod;     \\n                   \\n                if((i-2)>=0 && s.charAt(i-2)==ch) dp[i] = (dp[i] + dp[i-2]) % mod;\\n                else continue;\\n                \\n                if((i-3)>=0 && s.charAt(i-3)==ch) dp[i]= ( dp[i]+dp[i-3] )  % mod;\\n                else continue; \\n                \\n                if( (ch==\\'7\\' || ch==\\'9\\') && (i-4)>=0 && s.charAt(i-4)==ch) dp[i] = (dp[i]+dp[i-4] )  % mod;     \\n            \\n        }\\n        \\n        return (int)(dp[n] % mod);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int countTexts(String s) {\\n        int n =s.length();\\n        long dp [] =new long[n+1];\\n        dp[0]=1;\\n        int mod = 1000000007;\\n        for(int i=1;i<=n;i++)\\n        {\\n            char ch = s.charAt(i-1);\\n        \\n               dp[i]= (dp[i] + dp[i-1]) % mod;     \\n                   \\n                if((i-2)>=0 && s.charAt(i-2)==ch) dp[i] = (dp[i] + dp[i-2]) % mod;\\n                else continue;\\n                \\n                if((i-3)>=0 && s.charAt(i-3)==ch) dp[i]= ( dp[i]+dp[i-3] )  % mod;\\n                else continue; \\n                \\n                if( (ch==\\'7\\' || ch==\\'9\\') && (i-4)>=0 && s.charAt(i-4)==ch) dp[i] = (dp[i]+dp[i-4] )  % mod;     \\n            \\n        }\\n        \\n        return (int)(dp[n] % mod);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2018522,
                "title": "java-memoziation-based-solution",
                "content": "```\\nclass Solution {\\n    Integer[] cache;\\n    int mod = (int)Math.pow(10,9) + 7;\\n    public int countTexts(String pressedKeys) {\\n        cache = new Integer[pressedKeys.length()];\\n        return helper(pressedKeys, 0);\\n    }\\n    \\n    int helper(String cur, int pos) {\\n        if (pos >= cur.length()) {\\n            return 1;\\n        }\\n        \\n        if (cache[pos] != null) {\\n            return cache[pos];\\n        }\\n        int count = 0;\\n        for (int i = pos; i < cur.length() && i < pos + 4; i++) {\\n            if (cur.charAt(i) == cur.charAt(pos)) {\\n                count++;\\n            } else {\\n                break;\\n            }\\n        }\\n        \\n        if (cur.charAt(pos) == \\'7\\' || cur.charAt(pos) == \\'9\\') {\\n    \\n            count = count > 4 ? 4 : count;\\n        } else {\\n            count = count > 3 ? 3 : count;\\n        }\\n        \\n        int res = 0;\\n        \\n\\n        for (int i = pos; i < cur.length() && i < pos + count; i++) {\\n            res += helper(cur, i+1);\\n            res = res % mod;\\n        }\\n        return cache[pos] = res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Integer[] cache;\\n    int mod = (int)Math.pow(10,9) + 7;\\n    public int countTexts(String pressedKeys) {\\n        cache = new Integer[pressedKeys.length()];\\n        return helper(pressedKeys, 0);\\n    }\\n    \\n    int helper(String cur, int pos) {\\n        if (pos >= cur.length()) {\\n            return 1;\\n        }\\n        \\n        if (cache[pos] != null) {\\n            return cache[pos];\\n        }\\n        int count = 0;\\n        for (int i = pos; i < cur.length() && i < pos + 4; i++) {\\n            if (cur.charAt(i) == cur.charAt(pos)) {\\n                count++;\\n            } else {\\n                break;\\n            }\\n        }\\n        \\n        if (cur.charAt(pos) == \\'7\\' || cur.charAt(pos) == \\'9\\') {\\n    \\n            count = count > 4 ? 4 : count;\\n        } else {\\n            count = count > 3 ? 3 : count;\\n        }\\n        \\n        int res = 0;\\n        \\n\\n        for (int i = pos; i < cur.length() && i < pos + count; i++) {\\n            res += helper(cur, i+1);\\n            res = res % mod;\\n        }\\n        return cache[pos] = res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018437,
                "title": "dp-tabulation-observation",
                "content": "**PLEASE UPVOTE IF U FIND MY SOLUTION HELPFUL**\\n\\n```\\n#define ll long long\\nclass Solution \\n{\\n    const int M=1e9+7;\\npublic:\\n    int countTexts(string pK) \\n    {\\n        vector<pair<char,int>>v;\\n        int len=pK.length();\\n        \\n        int maxx=0;\\n        bool has_7OR9=0;//optimisation\\n        for(int i=0;i<len;)\\n        {\\n            char ch=pK[i];\\n            int c=0;\\n            while(i<len&&pK[i]==ch)\\n            {\\n                c++;\\n                i++;\\n            }\\n            maxx=max(maxx,c);\\n            if(ch==\\'7\\'||ch==\\'9\\')\\n                has_7OR9=1;\\n            v.push_back({ch,c});\\n        }\\n        \\n        \\n        maxx=max(4,maxx);\\n        vector<ll>dp1(maxx+1,0);//storing characters other than 7 and 9\\n        vector<ll>dp2(maxx+1,0);//storing characters 7 and 9\\n        dp1[1]=1,dp1[2]=2,dp1[3]=4;\\n        dp2[1]=1,dp2[2]=2,dp2[3]=4,dp2[4]=8;\\n        \\n        for(int i=4;i<=maxx;i++)\\n        {\\n            dp1[i]=(dp1[i-1]+dp1[i-2]+dp1[i-3])%M;\\n        }\\n        \\n        //not necessary but okie \\n        if(has_7OR9)\\n        {\\n           for(int i=5;i<=maxx;i++)\\n        {\\n            dp2[i]=(dp2[i-1]%M+dp2[i-2]%M+dp2[i-3]%M+dp2[i-4]%M)%M;\\n        }  \\n        }\\n       \\n        ll res=1;\\n        for(auto [ch,c]:v)\\n        {\\n        if(ch==\\'7\\'||ch==\\'9\\')\\n        {\\n              res=(res*(dp2[c])%M)%M;\\n        }\\n        else\\n        {\\n              res=(res*(dp1[c])%M)%M;\\n        }\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n#define ll long long\\nclass Solution \\n{\\n    const int M=1e9+7;\\npublic:\\n    int countTexts(string pK) \\n    {\\n        vector<pair<char,int>>v;\\n        int len=pK.length();\\n        \\n        int maxx=0;\\n        bool has_7OR9=0;//optimisation\\n        for(int i=0;i<len;)\\n        {\\n            char ch=pK[i];\\n            int c=0;\\n            while(i<len&&pK[i]==ch)\\n            {\\n                c++;\\n                i++;\\n            }\\n            maxx=max(maxx,c);\\n            if(ch==\\'7\\'||ch==\\'9\\')\\n                has_7OR9=1;\\n            v.push_back({ch,c});\\n        }\\n        \\n        \\n        maxx=max(4,maxx);\\n        vector<ll>dp1(maxx+1,0);//storing characters other than 7 and 9\\n        vector<ll>dp2(maxx+1,0);//storing characters 7 and 9\\n        dp1[1]=1,dp1[2]=2,dp1[3]=4;\\n        dp2[1]=1,dp2[2]=2,dp2[3]=4,dp2[4]=8;\\n        \\n        for(int i=4;i<=maxx;i++)\\n        {\\n            dp1[i]=(dp1[i-1]+dp1[i-2]+dp1[i-3])%M;\\n        }\\n        \\n        //not necessary but okie \\n        if(has_7OR9)\\n        {\\n           for(int i=5;i<=maxx;i++)\\n        {\\n            dp2[i]=(dp2[i-1]%M+dp2[i-2]%M+dp2[i-3]%M+dp2[i-4]%M)%M;\\n        }  \\n        }\\n       \\n        ll res=1;\\n        for(auto [ch,c]:v)\\n        {\\n        if(ch==\\'7\\'||ch==\\'9\\')\\n        {\\n              res=(res*(dp2[c])%M)%M;\\n        }\\n        else\\n        {\\n              res=(res*(dp1[c])%M)%M;\\n        }\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018404,
                "title": "simple-dp-solution-java-34ms-beats-100",
                "content": "We count consecutive repeating digits. For n repeating digits we count the number of ways to convert them into characters using DP.\\nFor digits 7 and 9 there are 4 characters corresponding to them. Their ways of converting n digits is as follows:\\nways[1]=1\\nways[2]=2\\nways[3]=4\\nways[4]=8\\n.\\n.\\n.\\nways[n]=ways[n-1]+ways[n-2]+ways[n-3]+ways[n-4]\\nFor digits other than 7 or 9, there are 3 characters corresponding to them. There ways of converting n repetitive digits is:\\nways[1]=1\\nways[2]=2\\nways[3]=4\\n.\\n.\\n.\\nways[n]=ways[n-1]+ways[n-2]+ways[n-3]\\nThe above formulas can be found out by taking some examples.\\n\\n```\\nclass Solution {\\n    public int countTexts(String pressedKeys) {\\n        int count=1;\\n        long total=1;\\n        for(int i=1;i<pressedKeys.length();i++)\\n        {\\n            if(pressedKeys.charAt(i)!=pressedKeys.charAt(i-1))\\n            {\\n                if(pressedKeys.charAt(i-1)==\\'7\\'||pressedKeys.charAt(i-1)==\\'9\\')\\n                    total=(total*count7or9(count))%1000000007;\\n                else\\n                    total=(total*countOthers(count)%1000000007);\\n                count=1;\\n            }\\n            else\\n                count++;\\n        }\\n        if(pressedKeys.charAt(pressedKeys.length()-1)==\\'7\\'||pressedKeys.charAt(pressedKeys.length()-1)==\\'9\\')\\n            total=(total*count7or9(count))%1000000007;\\n        else\\n            total=(total*countOthers(count)%1000000007);\\n        return (int)total;\\n    }\\n    public long count7or9(int count)\\n    {\\n        long[] ways=new long[count+1];\\n        if(count==1)\\n            return 1;\\n        else if(count==2)\\n            return 2;\\n        else if(count==3)\\n            return 4;\\n        else if(count==4)\\n            return 8;\\n        ways[1]=1;\\n        ways[2]=2;\\n        ways[3]=4;\\n        ways[4]=8;\\n        for(int i=5;i<=count;i++)\\n        {\\n            ways[i]=(ways[i-1]+ways[i-2]+ways[i-3]+ways[i-4])%1000000007;\\n        }\\n        return ways[count];\\n    }\\n    public long countOthers(int count)\\n    {\\n        long[] ways=new long[count+1];\\n        if(count==1)\\n            return 1;\\n        else if(count==2)\\n            return 2;\\n        else if(count==3)\\n            return 4;\\n        ways[1]=1;\\n        ways[2]=2;\\n        ways[3]=4;\\n        for(int i=4;i<=count;i++)\\n        {\\n            ways[i]=(ways[i-1]+ways[i-2]+ways[i-3])%1000000007;\\n        }\\n        return ways[count];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int countTexts(String pressedKeys) {\\n        int count=1;\\n        long total=1;\\n        for(int i=1;i<pressedKeys.length();i++)\\n        {\\n            if(pressedKeys.charAt(i)!=pressedKeys.charAt(i-1))\\n            {\\n                if(pressedKeys.charAt(i-1)==\\'7\\'||pressedKeys.charAt(i-1)==\\'9\\')\\n                    total=(total*count7or9(count))%1000000007;\\n                else\\n                    total=(total*countOthers(count)%1000000007);\\n                count=1;\\n            }\\n            else\\n                count++;\\n        }\\n        if(pressedKeys.charAt(pressedKeys.length()-1)==\\'7\\'||pressedKeys.charAt(pressedKeys.length()-1)==\\'9\\')\\n            total=(total*count7or9(count))%1000000007;\\n        else\\n            total=(total*countOthers(count)%1000000007);\\n        return (int)total;\\n    }\\n    public long count7or9(int count)\\n    {\\n        long[] ways=new long[count+1];\\n        if(count==1)\\n            return 1;\\n        else if(count==2)\\n            return 2;\\n        else if(count==3)\\n            return 4;\\n        else if(count==4)\\n            return 8;\\n        ways[1]=1;\\n        ways[2]=2;\\n        ways[3]=4;\\n        ways[4]=8;\\n        for(int i=5;i<=count;i++)\\n        {\\n            ways[i]=(ways[i-1]+ways[i-2]+ways[i-3]+ways[i-4])%1000000007;\\n        }\\n        return ways[count];\\n    }\\n    public long countOthers(int count)\\n    {\\n        long[] ways=new long[count+1];\\n        if(count==1)\\n            return 1;\\n        else if(count==2)\\n            return 2;\\n        else if(count==3)\\n            return 4;\\n        ways[1]=1;\\n        ways[2]=2;\\n        ways[3]=4;\\n        for(int i=4;i<=count;i++)\\n        {\\n            ways[i]=(ways[i-1]+ways[i-2]+ways[i-3])%1000000007;\\n        }\\n        return ways[count];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018217,
                "title": "java-o-n-time-o-1-space-with-comments-image-explanation-circular-array",
                "content": "```\\nclass Solution {\\n    static int mod = 1000000007;\\n    public int countTexts(String pK) {\\n        int n = pK.length();\\n        int[] dp = new int[5];\\n        // 1 represents number is present previously, unique digit.\\n        Arrays.fill(dp,1);\\n        for(int i=n-1;i>=0;i--){\\n            dp[i%5] = 0;\\n            // Range till which dp needs to filled, i.e., \\n\\t\\t\\t// For every i we can add dp[i-1],dp[i-2],dp[i-3] to dp[i] and if pK[i] is either 7 or 9 then we can add dp[i-4] also. \\t\\t\\n\\t\\t\\tint max;\\n            if(pK.charAt(i)==\\'7\\' || pK.charAt(i)==\\'9\\') max = i+4;\\n            else max = i+3;\\n\\t\\t\\t// If max goes beyond length then iterate till n. \\n            if(max>n) max=n;\\n            for(int j =i;j<max && pK.charAt(i)==pK.charAt(j);j++){\\n\\t\\t\\t // Since array is circular for dp[i], dp[i-1],dp[i-2],dp[i-3] will be dp[i+2],dp[i+3],dp[i+4], hence j+1 while adding.\\n                dp[i%5] = (dp[i%5] + dp[(j+1)%5])%mod;\\n            }\\n        }\\n        return dp[0];\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/895ac456-577d-40fc-bcc1-35b83aa8f813_1651985770.7568316.png)\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static int mod = 1000000007;\\n    public int countTexts(String pK) {\\n        int n = pK.length();\\n        int[] dp = new int[5];\\n        // 1 represents number is present previously, unique digit.\\n        Arrays.fill(dp,1);\\n        for(int i=n-1;i>=0;i--){\\n            dp[i%5] = 0;\\n            // Range till which dp needs to filled, i.e., \\n\\t\\t\\t// For every i we can add dp[i-1],dp[i-2],dp[i-3] to dp[i] and if pK[i] is either 7 or 9 then we can add dp[i-4] also. \\t\\t\\n\\t\\t\\tint max;\\n            if(pK.charAt(i)==\\'7\\' || pK.charAt(i)==\\'9\\') max = i+4;\\n            else max = i+3;\\n\\t\\t\\t// If max goes beyond length then iterate till n. \\n            if(max>n) max=n;\\n            for(int j =i;j<max && pK.charAt(i)==pK.charAt(j);j++){\\n\\t\\t\\t // Since array is circular for dp[i], dp[i-1],dp[i-2],dp[i-3] will be dp[i+2],dp[i+3],dp[i+4], hence j+1 while adding.\\n                dp[i%5] = (dp[i%5] + dp[(j+1)%5])%mod;\\n            }\\n        }\\n        return dp[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018212,
                "title": "python-top-down-dp",
                "content": "\\tclass Solution:\\n\\t\\tdef countTexts(self, pressedKeys: str) -> int:\\n\\t\\t\\tmod = 10 ** 9 + 7\\n\\t\\t\\t@cache\\n\\t\\t\\tdef dfs(i):\\n\\t\\t\\t\\tif i == 0:\\n\\t\\t\\t\\t\\treturn 1\\n\\t\\t\\t\\tcnt = dfs(i - 1)\\n\\t\\t\\t\\tif i >= 2 and pressedKeys[i - 1] == pressedKeys[i - 2]:\\n\\t\\t\\t\\t\\tcnt += dfs(i - 2)\\n\\t\\t\\t\\tif i >= 3 and pressedKeys[i - 3:i] == pressedKeys[i - 3] * 3:\\n\\t\\t\\t\\t\\tcnt += dfs(i - 3)\\n\\t\\t\\t\\tif pressedKeys[i - 1] == \"7\" or pressedKeys[i - 1] == \"9\":\\n\\t\\t\\t\\t\\tif i >= 4 and pressedKeys[i - 4:i] == pressedKeys[i - 4] * 4:\\n\\t\\t\\t\\t\\t\\tcnt += dfs(i - 4)\\n\\t\\t\\t\\treturn cnt % mod\\n\\t\\t\\treturn dfs(len(pressedKeys)) % mod",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef countTexts(self, pressedKeys: str) -> int:\\n\\t\\t\\tmod = 10 ** 9 + 7\\n\\t\\t\\t@cache\\n\\t\\t\\tdef dfs(i):\\n\\t\\t\\t\\tif i == 0:\\n\\t\\t\\t\\t\\treturn 1\\n\\t\\t\\t\\tcnt = dfs(i - 1)\\n\\t\\t\\t\\tif i >= 2 and pressedKeys[i - 1] == pressedKeys[i - 2]:\\n\\t\\t\\t\\t\\tcnt += dfs(i - 2)\\n\\t\\t\\t\\tif i >= 3 and pressedKeys[i - 3:i] == pressedKeys[i - 3] * 3:\\n\\t\\t\\t\\t\\tcnt += dfs(i - 3)\\n\\t\\t\\t\\tif pressedKeys[i - 1] == \"7\" or pressedKeys[i - 1] == \"9\":\\n\\t\\t\\t\\t\\tif i >= 4 and pressedKeys[i - 4:i] == pressedKeys[i - 4] * 4:\\n\\t\\t\\t\\t\\t\\tcnt += dfs(i - 4)\\n\\t\\t\\t\\treturn cnt % mod\\n\\t\\t\\treturn dfs(len(pressedKeys)) % mod",
                "codeTag": "Java"
            },
            {
                "id": 2018036,
                "title": "o-n-with-detail-explanation-for-dp",
                "content": "\\n\\n![image](https://assets.leetcode.com/users/images/a30713df-3f1e-4b26-96c5-8c5194e5d738_1651983880.0719159.png)\\n\\n\\n**only digit 7 and 9 has 4 consecutive press \\nwhich we need to characters from i-3 , i-2, i-1 and i\\nrest will be maximum 3 index characters from i-2,i-1 and i**\\n\\n\\n\\n```\\nlong M=(long)(1e9)+7;\\n    String[] PAD=new String[]{\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n    public int countTexts(String s) {        \\n        int n=s.length();\\n        long[] res = new long[n];\\n        res[0]=1;        \\n        \\n        for(int i=1;i<n;i++){\\n             res[i]=res[i-1];             \\n             res[i]%=M;\\n            \\n             if(i-1>=0 && s.charAt(i-1)==s.charAt(i)){\\n                 res[i]+=i-2<0?1:res[i-2];            \\n                 res[i]%=M;\\n             }\\n                        \\n             if(i-2>=0 && s.charAt(i-2)==s.charAt(i-1) && s.charAt(i-1)==s.charAt(i)){\\n                 res[i]+=i-3<0?1:res[i-3];                   \\n                 res[i]%=M;\\n             }            \\n            \\n            if(i-3>=0 && (s.charAt(i)==\\'7\\'||s.charAt(i)==\\'9\\') && s.charAt(i-3)==s.charAt(i-2) &&s.charAt(i-2)==s.charAt(i-1) && s.charAt(i-1)==s.charAt(i)){\\n                res[i]+=i-4<0?1:res[i-4];\\n                res[i]%=M;\\n            }            \\n        }        \\n        return (int)res[n-1];\\n        \\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\nlong M=(long)(1e9)+7;\\n    String[] PAD=new String[]{\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n    public int countTexts(String s) {        \\n        int n=s.length();\\n        long[] res = new long[n];\\n        res[0]=1;        \\n        \\n        for(int i=1;i<n;i++){\\n             res[i]=res[i-1];             \\n             res[i]%=M;\\n            \\n             if(i-1>=0 && s.charAt(i-1)==s.charAt(i)){\\n                 res[i]+=i-2<0?1:res[i-2];            \\n                 res[i]%=M;\\n             }\\n                        \\n             if(i-2>=0 && s.charAt(i-2)==s.charAt(i-1) && s.charAt(i-1)==s.charAt(i)){\\n                 res[i]+=i-3<0?1:res[i-3];                   \\n                 res[i]%=M;\\n             }            \\n            \\n            if(i-3>=0 && (s.charAt(i)==\\'7\\'||s.charAt(i)==\\'9\\') && s.charAt(i-3)==s.charAt(i-2) &&s.charAt(i-2)==s.charAt(i-1) && s.charAt(i-1)==s.charAt(i)){\\n                res[i]+=i-4<0?1:res[i-4];\\n                res[i]%=M;\\n            }            \\n        }        \\n        return (int)res[n-1];\\n        \\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2018024,
                "title": "c-recursive-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    #define LL long long\\n    const LL MOD = 1000000000 + 7;\\n    \\n    LL dp[100001][5];\\n    \\n    LL ans_me(int ix, int jump) {\\n        if (ix == 0) return 1;\\n        LL &ret = dp[ix][jump];\\n        if (ret != -1) return ret;\\n        ret = 0;\\n        for (int i = 1; i <= jump; i++) {\\n            if (ix - i >= 0) {\\n                ret = (ret + ans_me(ix - i, jump)) % MOD;\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n    \\n    int map_to_dig[10];\\n    \\n    int countTexts(string pressedKeys) {\\n        memset(dp, -1, sizeof dp);\\n        for (int i = 2; i < 10; i++) map_to_dig[i] = 3;\\n        map_to_dig[7] = map_to_dig[9] = 4;\\n        LL res = 1;\\n        for (int i = 0; i < pressedKeys.size(); i++) {\\n            int ix = i;\\n            while(ix < pressedKeys.size() && pressedKeys[i] == pressedKeys[ix]) {\\n                ix++;\\n            }\\n            int typ = map_to_dig[ pressedKeys[i] - \\'0\\' ];\\n            res = (res * ans_me(ix - i, typ)) % MOD;\\n            i = ix - 1;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    #define LL long long\\n    const LL MOD = 1000000000 + 7;\\n    \\n    LL dp[100001][5];\\n    \\n    LL ans_me(int ix, int jump) {\\n        if (ix == 0) return 1;\\n        LL &ret = dp[ix][jump];\\n        if (ret != -1) return ret;\\n        ret = 0;\\n        for (int i = 1; i <= jump; i++) {\\n            if (ix - i >= 0) {\\n                ret = (ret + ans_me(ix - i, jump)) % MOD;\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n    \\n    int map_to_dig[10];\\n    \\n    int countTexts(string pressedKeys) {\\n        memset(dp, -1, sizeof dp);\\n        for (int i = 2; i < 10; i++) map_to_dig[i] = 3;\\n        map_to_dig[7] = map_to_dig[9] = 4;\\n        LL res = 1;\\n        for (int i = 0; i < pressedKeys.size(); i++) {\\n            int ix = i;\\n            while(ix < pressedKeys.size() && pressedKeys[i] == pressedKeys[ix]) {\\n                ix++;\\n            }\\n            int typ = map_to_dig[ pressedKeys[i] - \\'0\\' ];\\n            res = (res * ans_me(ix - i, typ)) % MOD;\\n            i = ix - 1;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017980,
                "title": "easy-java-dp-solution-similar-to-decode-ways-memoization",
                "content": "Consider taking a hashmap to store the characters corresponding to number of keypresses. Say if we press 3 twice, we store e in the hashmap as 33 => \\'e\\'.  Now we have put all the possible characters in the hashmap. \\n\\nWe now solve the problem like we did in [Decode Ways I](https://leetcode.com/problems/decode-ways/) and maintain the count, before storing the count in the DP make sure to take mod of the answer by 10^9 + 7.\\n\\n```\\nclass Solution {\\n    \\n        int mod = (int)1e9 + 7;\\n    public int countTexts(String keys, int idx, HashMap<Integer, Character> map, int[] dp) {\\n        \\n        \\n        if(idx >= keys.length()) {\\n            return 1;\\n        }   \\n        \\n        if(dp[idx] != -1) {\\n            return dp[idx];\\n        }\\n        \\n        int count = 0;\\n        char ch = keys.charAt(idx);\\n        \\n        if(ch != \\'0\\' || ch != \\'1\\') {\\n            count = (count + countTexts(keys, idx + 1, map, dp)) % mod;\\n        }\\n        \\n        if(idx < keys.length() - 1) {\\n            int num = (ch - \\'0\\') * 10 + (keys.charAt(idx + 1) - \\'0\\');\\n            if(map.containsKey(num)) {\\n                count = (count + countTexts(keys, idx + 2, map, dp)) % mod;\\n            }\\n        }\\n        \\n        if(idx < keys.length() - 2) {\\n            int num = (ch - \\'0\\') * 100 + (keys.charAt(idx + 1) - \\'0\\') * 10 + (keys.charAt(idx + 2) - \\'0\\');\\n            if(map.containsKey(num)) {\\n                count = (count + countTexts(keys, idx + 3, map, dp)) % mod;\\n            }\\n        }\\n        \\n        if(idx < keys.length() - 3) {\\n            int num = (ch - \\'0\\') * 1000 + (keys.charAt(idx + 1) - \\'0\\') * 100 + (keys.charAt(idx + 2) - \\'0\\') * 10 + (keys.charAt(idx + 3) - \\'0\\');\\n            if(map.containsKey(num)) {\\n                count = (count + countTexts(keys, idx + 4, map, dp)) % mod;\\n            }\\n        }\\n        \\n        return dp[idx] = count % mod;\\n    }\\n    \\n    public int countTexts(String pressedKeys) {\\n        \\n        HashMap<Integer, Character> map = new HashMap<>();\\n        map.put(2, \\'a\\');\\n        map.put(22, \\'b\\');\\n        map.put(222, \\'c\\');\\n        map.put(3, \\'d\\');\\n        map.put(33, \\'e\\');\\n        map.put(333, \\'f\\');\\n        map.put(4, \\'g\\');\\n        map.put(44, \\'h\\');\\n        map.put(444, \\'i\\');\\n        map.put(5, \\'j\\');\\n        map.put(55, \\'k\\');\\n        map.put(555, \\'l\\');\\n        map.put(6, \\'m\\');\\n        map.put(66, \\'n\\');\\n        map.put(666, \\'o\\');\\n        map.put(7, \\'p\\');\\n        map.put(77, \\'q\\');\\n        map.put(777, \\'r\\');\\n        map.put(7777, \\'s\\');\\n        map.put(8, \\'t\\');\\n        map.put(88, \\'u\\');\\n        map.put(888, \\'v\\');\\n        map.put(9, \\'w\\');\\n        map.put(99, \\'x\\');\\n        map.put(999, \\'y\\');\\n        map.put(9999, \\'z\\');\\n        \\n        int[] dp = new int[pressedKeys.length() + 1];\\n        Arrays.fill(dp, -1);\\n        return countTexts(pressedKeys, 0, map, dp);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    \\n        int mod = (int)1e9 + 7;\\n    public int countTexts(String keys, int idx, HashMap<Integer, Character> map, int[] dp) {\\n        \\n        \\n        if(idx >= keys.length()) {\\n            return 1;\\n        }   \\n        \\n        if(dp[idx] != -1) {\\n            return dp[idx];\\n        }\\n        \\n        int count = 0;\\n        char ch = keys.charAt(idx);\\n        \\n        if(ch != \\'0\\' || ch != \\'1\\') {\\n            count = (count + countTexts(keys, idx + 1, map, dp)) % mod;\\n        }\\n        \\n        if(idx < keys.length() - 1) {\\n            int num = (ch - \\'0\\') * 10 + (keys.charAt(idx + 1) - \\'0\\');\\n            if(map.containsKey(num)) {\\n                count = (count + countTexts(keys, idx + 2, map, dp)) % mod;\\n            }\\n        }\\n        \\n        if(idx < keys.length() - 2) {\\n            int num = (ch - \\'0\\') * 100 + (keys.charAt(idx + 1) - \\'0\\') * 10 + (keys.charAt(idx + 2) - \\'0\\');\\n            if(map.containsKey(num)) {\\n                count = (count + countTexts(keys, idx + 3, map, dp)) % mod;\\n            }\\n        }\\n        \\n        if(idx < keys.length() - 3) {\\n            int num = (ch - \\'0\\') * 1000 + (keys.charAt(idx + 1) - \\'0\\') * 100 + (keys.charAt(idx + 2) - \\'0\\') * 10 + (keys.charAt(idx + 3) - \\'0\\');\\n            if(map.containsKey(num)) {\\n                count = (count + countTexts(keys, idx + 4, map, dp)) % mod;\\n            }\\n        }\\n        \\n        return dp[idx] = count % mod;\\n    }\\n    \\n    public int countTexts(String pressedKeys) {\\n        \\n        HashMap<Integer, Character> map = new HashMap<>();\\n        map.put(2, \\'a\\');\\n        map.put(22, \\'b\\');\\n        map.put(222, \\'c\\');\\n        map.put(3, \\'d\\');\\n        map.put(33, \\'e\\');\\n        map.put(333, \\'f\\');\\n        map.put(4, \\'g\\');\\n        map.put(44, \\'h\\');\\n        map.put(444, \\'i\\');\\n        map.put(5, \\'j\\');\\n        map.put(55, \\'k\\');\\n        map.put(555, \\'l\\');\\n        map.put(6, \\'m\\');\\n        map.put(66, \\'n\\');\\n        map.put(666, \\'o\\');\\n        map.put(7, \\'p\\');\\n        map.put(77, \\'q\\');\\n        map.put(777, \\'r\\');\\n        map.put(7777, \\'s\\');\\n        map.put(8, \\'t\\');\\n        map.put(88, \\'u\\');\\n        map.put(888, \\'v\\');\\n        map.put(9, \\'w\\');\\n        map.put(99, \\'x\\');\\n        map.put(999, \\'y\\');\\n        map.put(9999, \\'z\\');\\n        \\n        int[] dp = new int[pressedKeys.length() + 1];\\n        Arrays.fill(dp, -1);\\n        return countTexts(pressedKeys, 0, map, dp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017961,
                "title": "memo-dp-easy-to-understand",
                "content": "intution->we have to count how much combinations are possible from a number\\neg abc->2,22,222\\nif (2222)->not valid;break\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    \\n    int mod = 1000000007;\\n    map<int,int> index;\\n    vector<string>mp{\"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n    map<int,int> dp;\\n    int solve(string &s, int i){\\n        if (i>=s.size()){\\n            return 1;\\n        }\\n        if (dp.find(i)!=dp.end()){\\n            return dp[i];\\n        }\\n        int ways= 0;\\n        int sz = index[s[i]-\\'0\\'];\\n        int count = 0;\\n        for (int j =i; j<s.size(); j++){\\n            count++;\\n            if (s[i]==s[j] && count<=sz){\\n                ways+=solve(s,j+1);\\n            }\\n            else{\\n                break;\\n            }\\n            \\n            ways%=mod;\\n        }\\n         return dp[i] = ways%mod;\\n        \\n    }\\n    int countTexts(string s) {\\n        int count = 0;\\n        for (auto it:mp){\\n            string temp = it;\\n            count++;\\n            for (int i =0; i<temp.size(); i++){\\n                index[count] = temp.size();\\n            }\\n        }\\n        \\n        return solve(s,0);\\n        \\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    int mod = 1000000007;\\n    map<int,int> index;\\n    vector<string>mp{\"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n    map<int,int> dp;\\n    int solve(string &s, int i){\\n        if (i>=s.size()){\\n            return 1;\\n        }\\n        if (dp.find(i)!=dp.end()){\\n            return dp[i];\\n        }\\n        int ways= 0;\\n        int sz = index[s[i]-\\'0\\'];\\n        int count = 0;\\n        for (int j =i; j<s.size(); j++){\\n            count++;\\n            if (s[i]==s[j] && count<=sz){\\n                ways+=solve(s,j+1);\\n            }\\n            else{\\n                break;\\n            }\\n            \\n            ways%=mod;\\n        }\\n         return dp[i] = ways%mod;\\n        \\n    }\\n    int countTexts(string s) {\\n        int count = 0;\\n        for (auto it:mp){\\n            string temp = it;\\n            count++;\\n            for (int i =0; i<temp.size(); i++){\\n                index[count] = temp.size();\\n            }\\n        }\\n        \\n        return solve(s,0);\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017930,
                "title": "c-recursive-o-n-solution",
                "content": "```\\nclass Solution {\\n    \\n    #define ll long long \\n    int mod = 1000000007 ;\\n    \\n    int go( string &A , int i , ll t[] )\\n    {\\n        int N = A.size();\\n        if(t[i] != -1 ) return t[i] ;\\n        \\n        ll res = go( A , i+1 , t )%mod ;  // default case \\n        \\n        if( i+1 < N && A[i+1] == A[i] )\\n            res += go( A , i+2 , t );  // two consecutive can be grouped \\n        \\n        res %= mod ;\\n        \\n        if( i+2 < N && A[i+1] == A[i] && A[i+2] == A[i] )\\n            res += go( A , i+3 , t ); // three consecutive can be grouped \\n        \\n        res %= mod ;\\n        \\n        if( A[i] == \\'7\\' || A[i] == \\'9\\' ) // special cases \\n        {\\n            if( i+3 < N && A[i+1] == A[i] && A[i+2] == A[i] && A[i+3] == A[i] )\\n                res += go( A , i+4 , t ); // 4 consecutive can be grouped \\n        }\\n        \\n        return t[i] = res%mod ;\\n    }\\n    \\npublic:\\n    int countTexts(string A ) {\\n        \\n        int N = A.size();\\n        ll t[N+1];\\n        memset( t , -1 , sizeof t );\\n        t[N] = 1 ;\\n        \\n        return go( A , 0 , t )%mod ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    \\n    #define ll long long \\n    int mod = 1000000007 ;\\n    \\n    int go( string &A , int i , ll t[] )\\n    {\\n        int N = A.size();\\n        if(t[i] != -1 ) return t[i] ;\\n        \\n        ll res = go( A , i+1 , t )%mod ;  // default case \\n        \\n        if( i+1 < N && A[i+1] == A[i] )\\n            res += go( A , i+2 , t );  // two consecutive can be grouped \\n        \\n        res %= mod ;\\n        \\n        if( i+2 < N && A[i+1] == A[i] && A[i+2] == A[i] )\\n            res += go( A , i+3 , t ); // three consecutive can be grouped \\n        \\n        res %= mod ;\\n        \\n        if( A[i] == \\'7\\' || A[i] == \\'9\\' ) // special cases \\n        {\\n            if( i+3 < N && A[i+1] == A[i] && A[i+2] == A[i] && A[i+3] == A[i] )\\n                res += go( A , i+4 , t ); // 4 consecutive can be grouped \\n        }\\n        \\n        return t[i] = res%mod ;\\n    }\\n    \\npublic:\\n    int countTexts(string A ) {\\n        \\n        int N = A.size();\\n        ll t[N+1];\\n        memset( t , -1 , sizeof t );\\n        t[N] = 1 ;\\n        \\n        return go( A , 0 , t )%mod ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017868,
                "title": "updated-can-someone-please-explain-how-to-make-it-memory-efficient",
                "content": "update: found my mistake , i missed an &  with the string due to which it was copied again and again with every recursion \\uD83E\\uDD72. \\n```\\nclass Solution {\\npublic:\\n    int dp(int i,string pk,vector<int> &lim,vector<int> &v)\\n    {if(i==pk.size()){return 1;}\\n     if(v[i]!=-1){return v[i];}\\n        int ways=0,cnt=0;\\n        for(int j=i;j<pk.size();j++)\\n        {cnt++;\\n            \\n            ways=(ways+dp(j+1,pk,lim,v))%1000000007;\\n            if(pk[j]!=pk[j+1]||cnt>=lim[pk[j]-\\'0\\']){break;}\\n        }\\n     return v[i]=ways;\\n    }\\n    int countTexts(string pressedKeys) {\\n        vector<int> lim(10,3);lim[7]++;lim[9]++;\\n        vector<int> v(pressedKeys.size(),-1);\\n        return dp(0,pressedKeys,lim,v);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp(int i,string pk,vector<int> &lim,vector<int> &v)\\n    {if(i==pk.size()){return 1;}\\n     if(v[i]!=-1){return v[i];}\\n        int ways=0,cnt=0;\\n        for(int j=i;j<pk.size();j++)\\n        {cnt++;\\n            \\n            ways=(ways+dp(j+1,pk,lim,v))%1000000007;\\n            if(pk[j]!=pk[j+1]||cnt>=lim[pk[j]-\\'0\\']){break;}\\n        }\\n     return v[i]=ways;\\n    }\\n    int countTexts(string pressedKeys) {\\n        vector<int> lim(10,3);lim[7]++;lim[9]++;\\n        vector<int> v(pressedKeys.size(),-1);\\n        return dp(0,pressedKeys,lim,v);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017769,
                "title": "java-count-dp-bottom-up",
                "content": "1, count the numbers in the given string, \\npressedKeys 22235555\\ncompressed  3 of 2s ; 1 of 3s, 4 of 5s\\n\\n2, calculate 2 dp arrays for the number with 3 possible letters and 4 possible letters till the maximum \\ndp3[m] is the possible ways of keys for m same numbers (which has 3 letters on the button)\\ndp4[m] is the possible ways of keys for m same numbers (which has 4 letters on the button)\\n\\ndp3: 0,1,2,4,7,...\\ndp4: 1,1,2,4,8,...\\n\\n3, multiply the possibilitis to get the result.\\n\\n\\n```\\nclass Solution {\\n    private int MOD = 1000000007;\\n    public int countTexts(String pressedKeys) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        int maxLen = 0;\\n        char prevCh = \\'a\\';\\n        int curLen = 0;\\n        for(int i=0;i<pressedKeys.length();i++){\\n            if(pressedKeys.charAt(i) == prevCh){\\n                curLen++;\\n                maxLen = Math.max(maxLen,curLen);\\n            }else{\\n                if(curLen >0){\\n                    list.add(Arrays.asList(curLen,prevCh-\\'0\\'));\\n                }\\n                curLen = 1;\\n                prevCh = pressedKeys.charAt(i);\\n            }\\n        }\\n        list.add(Arrays.asList(curLen,prevCh-\\'0\\'));\\n        \\n       // System.out.println(list);        \\n        \\n        long[] dp3 = new long[Math.max(maxLen+1,5)];\\n        long[] dp4 = new long[Math.max(maxLen+1,5)];             \\n        \\n        dp3[1] = 1;\\n        dp3[2] = 2;\\n        dp3[3] = 4;\\n        \\n        dp4[0] = 1;\\n        dp4[1] = 1;\\n        dp4[2] = 2;\\n        dp4[3] = 4;\\n\\n        for(int i=4;i<dp3.length;i++){            \\n            dp3[i] = ((long)dp3[i-1]+dp3[i-2]+dp3[i-3])%MOD;\\n            dp4[i] = ((long)dp4[i-1]+dp4[i-2]+dp4[i-3]+dp4[i-4])%MOD;\\n        }\\n        \\n        //System.out.println(Arrays.toString(dp3));\\n        //System.out.println(Arrays.toString(dp4));\\n        \\n        long ret = 1;\\n        for(List<Integer> num:list){\\n            long nextVal = 1;\\n            if(num.get(1)==7 || num.get(1)==9){\\n                nextVal = dp4[num.get(0)];\\n            }else            {\\n                nextVal = dp3[num.get(0)];\\n            }\\n            ret =  (ret*nextVal)%MOD;\\n        }\\n        \\n        return (int)ret;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int MOD = 1000000007;\\n    public int countTexts(String pressedKeys) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        int maxLen = 0;\\n        char prevCh = \\'a\\';\\n        int curLen = 0;\\n        for(int i=0;i<pressedKeys.length();i++){\\n            if(pressedKeys.charAt(i) == prevCh){\\n                curLen++;\\n                maxLen = Math.max(maxLen,curLen);\\n            }else{\\n                if(curLen >0){\\n                    list.add(Arrays.asList(curLen,prevCh-\\'0\\'));\\n                }\\n                curLen = 1;\\n                prevCh = pressedKeys.charAt(i);\\n            }\\n        }\\n        list.add(Arrays.asList(curLen,prevCh-\\'0\\'));\\n        \\n       // System.out.println(list);        \\n        \\n        long[] dp3 = new long[Math.max(maxLen+1,5)];\\n        long[] dp4 = new long[Math.max(maxLen+1,5)];             \\n        \\n        dp3[1] = 1;\\n        dp3[2] = 2;\\n        dp3[3] = 4;\\n        \\n        dp4[0] = 1;\\n        dp4[1] = 1;\\n        dp4[2] = 2;\\n        dp4[3] = 4;\\n\\n        for(int i=4;i<dp3.length;i++){            \\n            dp3[i] = ((long)dp3[i-1]+dp3[i-2]+dp3[i-3])%MOD;\\n            dp4[i] = ((long)dp4[i-1]+dp4[i-2]+dp4[i-3]+dp4[i-4])%MOD;\\n        }\\n        \\n        //System.out.println(Arrays.toString(dp3));\\n        //System.out.println(Arrays.toString(dp4));\\n        \\n        long ret = 1;\\n        for(List<Integer> num:list){\\n            long nextVal = 1;\\n            if(num.get(1)==7 || num.get(1)==9){\\n                nextVal = dp4[num.get(0)];\\n            }else            {\\n                nextVal = dp3[num.get(0)];\\n            }\\n            ret =  (ret*nextVal)%MOD;\\n        }\\n        \\n        return (int)ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017767,
                "title": "java-dp",
                "content": "```\\nclass Solution {\\n    public int countTexts(String pressedKeys) {\\n        int n=pressedKeys.length();\\n        \\n        long [] dp = new long[n+1];\\n        dp[0]=1;\\n        dp[1]=1;\\n        \\n        for(int i=1;i<n;i++){\\n            char ch=pressedKeys.charAt(i);\\n            int j=i;\\n            if(ch!=\\'7\\' && ch!=\\'9\\'){\\n                while(j>0 && j>=i-2 && pressedKeys.charAt(j-1)==ch){\\n                    dp[i+1] += dp[j]%1000000007;\\n                    j--;\\n                }\\n                if(j!=i-3){\\n                    dp[i+1]+=dp[j]%1000000007;\\n                }\\n            }else{\\n                while(j>0 && j>=i-3 && pressedKeys.charAt(j-1)==ch){\\n                    dp[i+1] += dp[j]%1000000007;\\n                    j--;\\n                }\\n                if(j!=i-4){\\n                    dp[i+1]+=dp[j]%1000000007;\\n                }\\n            }\\n        }\\n        return (int) (dp[n]%1000000007);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int countTexts(String pressedKeys) {\\n        int n=pressedKeys.length();\\n        \\n        long [] dp = new long[n+1];\\n        dp[0]=1;\\n        dp[1]=1;\\n        \\n        for(int i=1;i<n;i++){\\n            char ch=pressedKeys.charAt(i);\\n            int j=i;\\n            if(ch!=\\'7\\' && ch!=\\'9\\'){\\n                while(j>0 && j>=i-2 && pressedKeys.charAt(j-1)==ch){\\n                    dp[i+1] += dp[j]%1000000007;\\n                    j--;\\n                }\\n                if(j!=i-3){\\n                    dp[i+1]+=dp[j]%1000000007;\\n                }\\n            }else{\\n                while(j>0 && j>=i-3 && pressedKeys.charAt(j-1)==ch){\\n                    dp[i+1] += dp[j]%1000000007;\\n                    j--;\\n                }\\n                if(j!=i-4){\\n                    dp[i+1]+=dp[j]%1000000007;\\n                }\\n            }\\n        }\\n        return (int) (dp[n]%1000000007);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017766,
                "title": "c-dp-o-n-solution",
                "content": "```\\nlong long mod=1000000007;\\n    \\n    long long ans[100001];\\n    \\n    long long solve(string &s,int i)\\n    {\\n        if(i==s.size())\\n        {\\n            return 1;\\n        }\\n        \\n        if(ans[i]!=-1)\\n        {\\n            return ans[i];\\n        }\\n        \\n        long long cnt=0;\\n        \\n        if(s[i]==\\'9\\'||s[i]==\\'7\\')\\n        {\\n            char c=s[i];\\n            \\n            for(int j=i;j<i+4;j++)\\n            {\\n                if(s[j]==c)\\n                {\\n                    cnt=(cnt+solve(s,j+1))%mod;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            char c=s[i];\\n            \\n            for(int j=i;j<i+3;j++)\\n            {\\n                if(s[j]==c)\\n                {\\n                    cnt=(cnt+solve(s,j+1))%mod;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n        }\\n        ans[i]=cnt%mod;\\n        return ans[i];\\n    }\\n    int countTexts(string pressedKeys) \\n    {\\n        memset(ans,-1,sizeof(ans));\\n        \\n        long long fans=solve(pressedKeys,0);\\n        return fans;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\nlong long mod=1000000007;\\n    \\n    long long ans[100001];\\n    \\n    long long solve(string &s,int i)\\n    {\\n        if(i==s.size())\\n        {\\n            return 1;\\n        }\\n        \\n        if(ans[i]!=-1)\\n        {\\n            return ans[i];\\n        }\\n        \\n        long long cnt=0;\\n        \\n        if(s[i]==\\'9\\'||s[i]==\\'7\\')\\n        {\\n            char c=s[i];\\n            \\n            for(int j=i;j<i+4;j++)\\n            {\\n                if(s[j]==c)\\n                {\\n                    cnt=(cnt+solve(s,j+1))%mod;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            char c=s[i];\\n            \\n            for(int j=i;j<i+3;j++)\\n            {\\n                if(s[j]==c)\\n                {\\n                    cnt=(cnt+solve(s,j+1))%mod;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n        }\\n        ans[i]=cnt%mod;\\n        return ans[i];\\n    }\\n    int countTexts(string pressedKeys) \\n    {\\n        memset(ans,-1,sizeof(ans));\\n        \\n        long long fans=solve(pressedKeys,0);\\n        return fans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 4084399,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string>v={\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\\n                    \"tuv\",\"wxyz\"};\\n    vector<int>dp;\\n    const int mod=1e9+7;\\n    int countTexts(string s) {\\n        dp.resize(s.length(),-1);\\n        return fun(s,0);\\n    }\\n    int fun(string &s,int idx)\\n    {\\n        if(idx==s.length())\\n        {\\n            return 1;\\n        }\\n        if(dp[idx]!=-1)\\n        {\\n            return dp[idx];\\n        }\\n        // cout<<idx<<endl;\\n        int num=s[idx]-\\'0\\';\\n        int count=0;\\n        for(int i=0;i<v[num].length();i++)\\n        {\\n            if((idx+i)<s.length() and s[idx]==s[idx+i])\\n            {\\n                count+=fun(s,idx+i+1);\\n                count=count%mod;\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        return dp[idx]=count%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string>v={\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\\n                    \"tuv\",\"wxyz\"};\\n    vector<int>dp;\\n    const int mod=1e9+7;\\n    int countTexts(string s) {\\n        dp.resize(s.length(),-1);\\n        return fun(s,0);\\n    }\\n    int fun(string &s,int idx)\\n    {\\n        if(idx==s.length())\\n        {\\n            return 1;\\n        }\\n        if(dp[idx]!=-1)\\n        {\\n            return dp[idx];\\n        }\\n        // cout<<idx<<endl;\\n        int num=s[idx]-\\'0\\';\\n        int count=0;\\n        for(int i=0;i<v[num].length();i++)\\n        {\\n            if((idx+i)<s.length() and s[idx]==s[idx+i])\\n            {\\n                count+=fun(s,idx+i+1);\\n                count=count%mod;\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        return dp[idx]=count%mod;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4067699,
                "title": "c-beats-93-using-combination-sum-iv",
                "content": "![Sighhhhhhhhhhhh 2023-09-20 at 17.39.06.png](https://assets.leetcode.com/users/images/785614dc-1c1f-4df9-815a-15654ac45cba_1695199155.8621168.png)\\n\\nThis problem can use the same algorithm from [377. Combination Sum IV](https://leetcode.com/problems/combination-sum-iv/).\\n\\nEg if there is a string of three 4s, \"444\"\\nThen we need to know how many ways she could have pressed them\\neg (1,1,1) or (1,2) or (2,1) or (3)\\nThis is Combination Sum IV.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static const int MOD = 1e9 + 7;\\n\\n    // September 20 2023\\n    int countTexts(const string& pressedKeys) {\\n        unsigned long long total = 1;\\n        for (int i = 0; i < pressedKeys.length(); i++) {\\n            char c = pressedKeys[i];\\n            int j = i + 1;\\n            while (j < pressedKeys.length() && c == pressedKeys[j]) j++;\\n            int numLetters = (c == \\'7\\' || c == \\'9\\') ? 4 : 3;\\n            total *= (combinationSum4(numLetters, j - i) % MOD);\\n            total %= MOD;\\n            i = j - 1;\\n        }\\n        return total;\\n    }\\nprivate:\\n    // numLetters = 4 for 7 or 9, 3 otherwise\\n    unsigned long long combinationSum4(const int numLetters, const int target) {\\n        unsigned long long dp[target + 1];\\n        memset(dp, 0, sizeof(dp));\\n        dp[target] = 1;\\n        for (int i = target - 1; i >= 0; i--) {\\n            for (int j = 1; j <= numLetters; j++) { // can press 1,2,3, or 4 times\\n                if (j + i <= target) {\\n                    dp[i] += dp[j + i] % MOD;\\n                }\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static const int MOD = 1e9 + 7;\\n\\n    // September 20 2023\\n    int countTexts(const string& pressedKeys) {\\n        unsigned long long total = 1;\\n        for (int i = 0; i < pressedKeys.length(); i++) {\\n            char c = pressedKeys[i];\\n            int j = i + 1;\\n            while (j < pressedKeys.length() && c == pressedKeys[j]) j++;\\n            int numLetters = (c == \\'7\\' || c == \\'9\\') ? 4 : 3;\\n            total *= (combinationSum4(numLetters, j - i) % MOD);\\n            total %= MOD;\\n            i = j - 1;\\n        }\\n        return total;\\n    }\\nprivate:\\n    // numLetters = 4 for 7 or 9, 3 otherwise\\n    unsigned long long combinationSum4(const int numLetters, const int target) {\\n        unsigned long long dp[target + 1];\\n        memset(dp, 0, sizeof(dp));\\n        dp[target] = 1;\\n        for (int i = target - 1; i >= 0; i--) {\\n            for (int j = 1; j <= numLetters; j++) { // can press 1,2,3, or 4 times\\n                if (j + i <= target) {\\n                    dp[i] += dp[j + i] % MOD;\\n                }\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4067382,
                "title": "ruby-solution-inspired-by-owen1605",
                "content": "# Intuition\\nAll credits to https://leetcode.com/problems/count-number-of-texts/solutions/2018336/python-dp-with-diagrams-for-beginners/\\nRewrite in Ruby to help ruby devs read the code easier\\n\\n\\n# Code\\n```\\n# @param {String} pressed_keys\\n# @return {Integer}\\ndef count_texts(pressed_keys) # \"22233\"\\n    dp = [1] + Array.new(pressed_keys.size, 0) # [1, 0, 0, 0, 0, 0]\\n\\n    pressed_keys.chars.each_with_index do |key, i|\\n        dp[i + 1] = dp[i]\\n\\n        # index 0 [1, 1, 0, 0, 0, 0]\\n        # index 1 [1, 1, 1, 0, 0, 0]\\n        # index 2 [1, 1, 2, 2, 0, 0]\\n        # 3   [1, 1, 2, 4, 4, 0]\\n        # 4   [1, 1, 2, 4, 4, 4]\\n\\n        # check if the current number is the same as previous one, eg: 22 \\n        if i >= 1 && pressed_keys[i - 1] == key\\n            dp[i + 1] += dp[i -1]\\n\\n            if i >= 2 && pressed_keys[i - 2] == key\\n                dp[i + 1] += dp[i - 2]\\n\\n                # 7 and 9 can have 4 possible letters\\n                if i >= 3 && pressed_keys[i-3] == key && [\"9\", \"7\"].include?(key)\\n                    dp[i+1] += dp[i-3]\\n                end\\n            end    \\n        end\\n\\n        dp[i+1] %= 10**9 + 7    \\n    end\\n\\n    dp[-1]\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {String} pressed_keys\\n# @return {Integer}\\ndef count_texts(pressed_keys) # \"22233\"\\n    dp = [1] + Array.new(pressed_keys.size, 0) # [1, 0, 0, 0, 0, 0]\\n\\n    pressed_keys.chars.each_with_index do |key, i|\\n        dp[i + 1] = dp[i]\\n\\n        # index 0 [1, 1, 0, 0, 0, 0]\\n        # index 1 [1, 1, 1, 0, 0, 0]\\n        # index 2 [1, 1, 2, 2, 0, 0]\\n        # 3   [1, 1, 2, 4, 4, 0]\\n        # 4   [1, 1, 2, 4, 4, 4]\\n\\n        # check if the current number is the same as previous one, eg: 22 \\n        if i >= 1 && pressed_keys[i - 1] == key\\n            dp[i + 1] += dp[i -1]\\n\\n            if i >= 2 && pressed_keys[i - 2] == key\\n                dp[i + 1] += dp[i - 2]\\n\\n                # 7 and 9 can have 4 possible letters\\n                if i >= 3 && pressed_keys[i-3] == key && [\"9\", \"7\"].include?(key)\\n                    dp[i+1] += dp[i-3]\\n                end\\n            end    \\n        end\\n\\n        dp[i+1] %= 10**9 + 7    \\n    end\\n\\n    dp[-1]\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4046080,
                "title": "python-dp-o-n-o-1-memory-100-runtime-91-4",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing \"dp[e] = dp[e-1] << 1\" and optimizing space complexity.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n**O(n)**\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**O(1)**\\n# Code\\n```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        dp = [1,0,0,0,0]\\n        mod = 10**9 + 7\\n        count = 1\\n        for i in range(1,len(pressedKeys)):\\n            e = i%5\\n            if pressedKeys[i] != pressedKeys[i-1]:\\n                dp[e] = dp[e-1] % mod\\n                count = 1\\n            else:\\n                count += 1\\n                if count <= 3 and pressedKeys[i] in \"234568\" or count <= 4 and pressedKeys[i] in \"79\":\\n                    dp[e] = (dp[e-1] <<1 ) % mod\\n                else:\\n                    dp[e] = (dp[e-1] + dp[e-2] + dp[e-3]) % mod\\n                    if pressedKeys[i] in \"79\":\\n                        dp[e] = (dp[e] + dp[e-4]) % mod\\n        \\n        return dp[(len(pressedKeys)-1) % 5]\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        dp = [1,0,0,0,0]\\n        mod = 10**9 + 7\\n        count = 1\\n        for i in range(1,len(pressedKeys)):\\n            e = i%5\\n            if pressedKeys[i] != pressedKeys[i-1]:\\n                dp[e] = dp[e-1] % mod\\n                count = 1\\n            else:\\n                count += 1\\n                if count <= 3 and pressedKeys[i] in \"234568\" or count <= 4 and pressedKeys[i] in \"79\":\\n                    dp[e] = (dp[e-1] <<1 ) % mod\\n                else:\\n                    dp[e] = (dp[e-1] + dp[e-2] + dp[e-3]) % mod\\n                    if pressedKeys[i] in \"79\":\\n                        dp[e] = (dp[e] + dp[e-4]) % mod\\n        \\n        return dp[(len(pressedKeys)-1) % 5]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984152,
                "title": "python-2-liner",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n`F(a,b)` function recursively counts number of alternatives when you pressed a number that includes `b` character `a` times. \\n`K` list holds number of characters in every number from 2 to 9. \\nWe return multiplication of number of alternatives for every number group in `P` string with using `groupby`. \\n\\n# Code\\n```\\nclass Solution:\\n    def countTexts(self, P, m = 10**9+7, K = [0,0,3,3,3,3,3,4,3,4], c = cache):\\n        F = c(lambda a,b:1 if a<2 else sum(F(a-i,b) for i in range(1,min(a+1,b+1))) % m)\\n        return prod(F(len(list(v)),K[int(k)]) for k,v in groupby(P)) % m\\n```\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countTexts(self, P, m = 10**9+7, K = [0,0,3,3,3,3,3,4,3,4], c = cache):\\n        F = c(lambda a,b:1 if a<2 else sum(F(a-i,b) for i in range(1,min(a+1,b+1))) % m)\\n        return prod(F(len(list(v)),K[int(k)]) for k,v in groupby(P)) % m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3951663,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int countTexts(string s) \\n    {\\n        int ct;\\n        ct=1;\\n\\n        long long ans;\\n        ans=1;\\n\\n        vector<long long> count1(s.size()+3);\\n        count1[1]=1;\\n        count1[2]=2;\\n        count1[3]=4;\\n\\n        vector<long long> count2(s.size()+4);\\n        count2[1]=1;\\n        count2[2]=2;\\n        count2[3]=4;\\n        count2[4]=8;\\n\\n        for(int i=4;i<=s.size();i++)\\n        {\\n            count1[i]=count1[i-1]+count1[i-2]+count1[i-3];\\n            count1[i]%=1000000007;\\n        }\\n\\n        for(int i=5;i<=s.size();i++)\\n        {\\n            count2[i]=count2[i-1]+count2[i-2]+count2[i-3]+count2[i-4];\\n            count2[i]%=1000000007;\\n        }\\n\\n        for(int i=0;i<s.size()-1;i++)\\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                ct++;\\n            }\\n\\n            else\\n            {\\n                if(s[i]==\\'7\\' || s[i]==\\'9\\')\\n                {\\n                    ans*=count2[ct];\\n                }\\n\\n                else\\n                {\\n                    ans*=count1[ct];\\n                }\\n\\n                ans%=1000000007;\\n                ct=1;\\n            }\\n        }\\n\\n        if(s[s.size()-1]==\\'7\\' || s[s.size()-1]==\\'9\\')\\n        {\\n            ans*=count2[ct];\\n        }\\n\\n        else\\n        {\\n            ans*=count1[ct];\\n        }\\n\\n        ans%=1000000007;\\n        return ans;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int countTexts(string s) \\n    {\\n        int ct;\\n        ct=1;\\n\\n        long long ans;\\n        ans=1;\\n\\n        vector<long long> count1(s.size()+3);\\n        count1[1]=1;\\n        count1[2]=2;\\n        count1[3]=4;\\n\\n        vector<long long> count2(s.size()+4);\\n        count2[1]=1;\\n        count2[2]=2;\\n        count2[3]=4;\\n        count2[4]=8;\\n\\n        for(int i=4;i<=s.size();i++)\\n        {\\n            count1[i]=count1[i-1]+count1[i-2]+count1[i-3];\\n            count1[i]%=1000000007;\\n        }\\n\\n        for(int i=5;i<=s.size();i++)\\n        {\\n            count2[i]=count2[i-1]+count2[i-2]+count2[i-3]+count2[i-4];\\n            count2[i]%=1000000007;\\n        }\\n\\n        for(int i=0;i<s.size()-1;i++)\\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                ct++;\\n            }\\n\\n            else\\n            {\\n                if(s[i]==\\'7\\' || s[i]==\\'9\\')\\n                {\\n                    ans*=count2[ct];\\n                }\\n\\n                else\\n                {\\n                    ans*=count1[ct];\\n                }\\n\\n                ans%=1000000007;\\n                ct=1;\\n            }\\n        }\\n\\n        if(s[s.size()-1]==\\'7\\' || s[s.size()-1]==\\'9\\')\\n        {\\n            ans*=count2[ct];\\n        }\\n\\n        else\\n        {\\n            ans*=count1[ct];\\n        }\\n\\n        ans%=1000000007;\\n        return ans;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3949119,
                "title": "iterative-dynamic-programming-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n  int countTexts(string s) {\\n    int n = s.size();\\n    vector<int> dp(n + 1);\\n    dp[0] = 1;\\n    const int mod = 1000000007;\\n    for(int i = 0; i < n; i++)  {\\n      if(s[i] == \\'7\\' || s[i] == \\'9\\')  {\\n        for(int j = 1; j < 5; j++)  {\\n          if(i + j <= n && s[i] == s[i + j - 1])  {\\n            (dp[i + j] += dp[i]) %= mod;\\n          } else  {\\n            break;\\n          }\\n        }\\n      } else  {\\n        for(int j = 1; j < 4; j++)  {\\n          if(i + j <= n && s[i] == s[i + j - 1])  {\\n            (dp[i + j] += dp[i]) %= mod;\\n          } else  {\\n            break;\\n          }\\n        }\\n      }\\n    }\\n    return dp[n];\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int countTexts(string s) {\\n    int n = s.size();\\n    vector<int> dp(n + 1);\\n    dp[0] = 1;\\n    const int mod = 1000000007;\\n    for(int i = 0; i < n; i++)  {\\n      if(s[i] == \\'7\\' || s[i] == \\'9\\')  {\\n        for(int j = 1; j < 5; j++)  {\\n          if(i + j <= n && s[i] == s[i + j - 1])  {\\n            (dp[i + j] += dp[i]) %= mod;\\n          } else  {\\n            break;\\n          }\\n        }\\n      } else  {\\n        for(int j = 1; j < 4; j++)  {\\n          if(i + j <= n && s[i] == s[i + j - 1])  {\\n            (dp[i + j] += dp[i]) %= mod;\\n          } else  {\\n            break;\\n          }\\n        }\\n      }\\n    }\\n    return dp[n];\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941922,
                "title": "c-dp-more-readable-class",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countTexts(string pressedKeys) {\\n        _keys = pressedKeys;\\n        for (int i = 0; i < (int) _keys.size(); i ++) {\\n            countTextsInternal(i);\\n        }\\n        return _result.back() % maxVal;\\n    }\\nprivate:\\n    const int maxVal = 1000000007;\\n    const int maxDeq = 4;\\n    deque<int> _result;\\n    int _deqStartIndex {0};\\n    string _keys;\\n\\n    void countTextsInternal(const int index) {\\n        const int startIndex = _keys.size() - index - 1; // string\\'s start index\\n        const int maxSeq = maxSequence(_keys[startIndex]);\\n        int seq = 1;\\n\\n        for (int i = 1; i < maxSeq && (index - i >= 0); i ++) {\\n            if (_keys[i + startIndex] == _keys[startIndex]) {\\n                seq ++;\\n            } else {\\n                break;\\n            }\\n        }\\n\\n        int count = 0; \\n        if (index == 0) {\\n            count = 1;\\n        } else if (seq == 1) {\\n            count = getPrevResult(index - 1);\\n        } else {\\n            for (int i = 0; i < seq; i ++) {\\n                count += getPrevResult(index - i - 1);\\n                if (count > maxVal) {\\n                    count -= maxVal;\\n                }\\n            }\\n        }\\n\\n        setCurrentResult(count);\\n    }\\n\\n    void setCurrentResult(int value) {\\n        _result.push_back(value);\\n        if (_result.size() > maxDeq) {\\n            _result.pop_front();\\n            _deqStartIndex++;\\n        }\\n    }\\n\\n    int getPrevResult(int index) {\\n        if (index < 0) {\\n            return 1; // it\\'s the case itself\\n        }\\n        return _result[index - _deqStartIndex];\\n    }\\n\\n    int maxSequence(char c) {\\n\\n        switch (c) {\\n            case \\'8\\' :\\n            case \\'6\\' :\\n            case \\'5\\' :\\n            case \\'4\\' :\\n            case \\'3\\' :\\n            case \\'2\\' : return 3;\\n            case \\'9\\' :\\n            case \\'7\\' : return 4;\\n        }\\n        printf(\"Unrecognised digit [%c] (%d)\\\\n\", c, c);\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countTexts(string pressedKeys) {\\n        _keys = pressedKeys;\\n        for (int i = 0; i < (int) _keys.size(); i ++) {\\n            countTextsInternal(i);\\n        }\\n        return _result.back() % maxVal;\\n    }\\nprivate:\\n    const int maxVal = 1000000007;\\n    const int maxDeq = 4;\\n    deque<int> _result;\\n    int _deqStartIndex {0};\\n    string _keys;\\n\\n    void countTextsInternal(const int index) {\\n        const int startIndex = _keys.size() - index - 1; // string\\'s start index\\n        const int maxSeq = maxSequence(_keys[startIndex]);\\n        int seq = 1;\\n\\n        for (int i = 1; i < maxSeq && (index - i >= 0); i ++) {\\n            if (_keys[i + startIndex] == _keys[startIndex]) {\\n                seq ++;\\n            } else {\\n                break;\\n            }\\n        }\\n\\n        int count = 0; \\n        if (index == 0) {\\n            count = 1;\\n        } else if (seq == 1) {\\n            count = getPrevResult(index - 1);\\n        } else {\\n            for (int i = 0; i < seq; i ++) {\\n                count += getPrevResult(index - i - 1);\\n                if (count > maxVal) {\\n                    count -= maxVal;\\n                }\\n            }\\n        }\\n\\n        setCurrentResult(count);\\n    }\\n\\n    void setCurrentResult(int value) {\\n        _result.push_back(value);\\n        if (_result.size() > maxDeq) {\\n            _result.pop_front();\\n            _deqStartIndex++;\\n        }\\n    }\\n\\n    int getPrevResult(int index) {\\n        if (index < 0) {\\n            return 1; // it\\'s the case itself\\n        }\\n        return _result[index - _deqStartIndex];\\n    }\\n\\n    int maxSequence(char c) {\\n\\n        switch (c) {\\n            case \\'8\\' :\\n            case \\'6\\' :\\n            case \\'5\\' :\\n            case \\'4\\' :\\n            case \\'3\\' :\\n            case \\'2\\' : return 3;\\n            case \\'9\\' :\\n            case \\'7\\' : return 4;\\n        }\\n        printf(\"Unrecognised digit [%c] (%d)\\\\n\", c, c);\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3873773,
                "title": "python-dp",
                "content": "# Intuition\\n- We cant count the ways using permutations and combinations if you think about it, we will need the ones that come next\\n- Hence recursion and DP\\n- Choose Each possibility and add it up\\n\\n# Approach\\n- Count possibilities using recursion\\n\\n# Complexity\\n- Time complexity:\\n- O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        @cache\\n        def solve(index):\\n            if index >= len(pressedKeys):\\n                return 1\\n            else:\\n                i = index\\n                total = 0\\n                counter = 0\\n                while i<len(pressedKeys) and pressedKeys[i] == pressedKeys[index] and ((counter < 3 and pressedKeys[index] !=\\'7\\' and pressedKeys[index] !=\\'9\\') or (counter < 4 and (pressedKeys[index] ==\\'7\\' or pressedKeys[index] ==\\'9\\'))) :\\n                    total+=solve(i+1)\\n                    counter+=1\\n                    i+=1\\n                return total%((10**9)+7)\\n        return solve(0)\\n        # return 2\\n                \\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        @cache\\n        def solve(index):\\n            if index >= len(pressedKeys):\\n                return 1\\n            else:\\n                i = index\\n                total = 0\\n                counter = 0\\n                while i<len(pressedKeys) and pressedKeys[i] == pressedKeys[index] and ((counter < 3 and pressedKeys[index] !=\\'7\\' and pressedKeys[index] !=\\'9\\') or (counter < 4 and (pressedKeys[index] ==\\'7\\' or pressedKeys[index] ==\\'9\\'))) :\\n                    total+=solve(i+1)\\n                    counter+=1\\n                    i+=1\\n                return total%((10**9)+7)\\n        return solve(0)\\n        # return 2\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3864462,
                "title": "python-easy-to-read-and-understand-dp",
                "content": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        n = len(pressedKeys)\\n        t = [0]*(n+1)\\n        t[0] = 1\\n        \\n        for i in range(1, n+1):\\n            t[i] = t[i-1]\\n            if i-2 >= 0 and pressedKeys[i-1] == pressedKeys[i-2]:\\n                t[i] += t[i-2]\\n            if i-3 >= 0 and pressedKeys[i-1] == pressedKeys[i-2] == pressedKeys[i-3]:\\n                t[i] += t[i-3]\\n            if pressedKeys[i-1] == \\'7\\' or pressedKeys[i-1] == \\'9\\':\\n                if i-4 >= 0 and pressedKeys[i-1] == pressedKeys[i-2] == pressedKeys[i-3] == pressedKeys[i-4]:\\n                    t[i] += t[i-4]\\n        \\n        return t[n]%(10**9 + 7)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        n = len(pressedKeys)\\n        t = [0]*(n+1)\\n        t[0] = 1\\n        \\n        for i in range(1, n+1):\\n            t[i] = t[i-1]\\n            if i-2 >= 0 and pressedKeys[i-1] == pressedKeys[i-2]:\\n                t[i] += t[i-2]\\n            if i-3 >= 0 and pressedKeys[i-1] == pressedKeys[i-2] == pressedKeys[i-3]:\\n                t[i] += t[i-3]\\n            if pressedKeys[i-1] == \\'7\\' or pressedKeys[i-1] == \\'9\\':\\n                if i-4 >= 0 and pressedKeys[i-1] == pressedKeys[i-2] == pressedKeys[i-3] == pressedKeys[i-4]:\\n                    t[i] += t[i-4]\\n        \\n        return t[n]%(10**9 + 7)",
                "codeTag": "Java"
            },
            {
                "id": 3863369,
                "title": "best-dp-question-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int mod = 1e9 + 7;\\n    int f(int ind,string &s,vector<int>&dp){\\n        if(ind == s.size())return 1;\\n\\n        if(dp[ind]!=-1)return dp[ind]%mod;\\n\\n\\n        int ans1 = 0;\\n        int ans2 = 0;\\n        int ans3 = 0;\\n        int ans4 = 0;\\n        ans1 = f(ind+1,s,dp);\\n        if(ind+1<s.size() && s[ind] == s[ind+1]){\\n            ans2+=f(ind+2,s,dp);\\n        }\\n        if(ind+2<s.size() && s[ind] == s[ind+1] && s[ind+1] == s[ind+2]){\\n            ans3+=f(ind+3,s,dp);\\n        }\\n        if(ind+3<s.size() && s[ind] == s[ind+1] && s[ind+1] == s[ind+2] && s[ind+2] == s[ind+3] \\n         && (s[ind] == \\'7\\' || s[ind] == \\'9\\'))ans4+=f(ind+4,s,dp);\\n\\n        return dp[ind] = (((ans1+ans2)%mod+ans3)%mod + ans4)%mod;\\n    }\\npublic:\\n    int countTexts(string pressedKeys) {\\n        int n = pressedKeys.size();\\n        vector<int> dp(n,-1);\\n        return f(0,pressedKeys,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int mod = 1e9 + 7;\\n    int f(int ind,string &s,vector<int>&dp){\\n        if(ind == s.size())return 1;\\n\\n        if(dp[ind]!=-1)return dp[ind]%mod;\\n\\n\\n        int ans1 = 0;\\n        int ans2 = 0;\\n        int ans3 = 0;\\n        int ans4 = 0;\\n        ans1 = f(ind+1,s,dp);\\n        if(ind+1<s.size() && s[ind] == s[ind+1]){\\n            ans2+=f(ind+2,s,dp);\\n        }\\n        if(ind+2<s.size() && s[ind] == s[ind+1] && s[ind+1] == s[ind+2]){\\n            ans3+=f(ind+3,s,dp);\\n        }\\n        if(ind+3<s.size() && s[ind] == s[ind+1] && s[ind+1] == s[ind+2] && s[ind+2] == s[ind+3] \\n         && (s[ind] == \\'7\\' || s[ind] == \\'9\\'))ans4+=f(ind+4,s,dp);\\n\\n        return dp[ind] = (((ans1+ans2)%mod+ans3)%mod + ans4)%mod;\\n    }\\npublic:\\n    int countTexts(string pressedKeys) {\\n        int n = pressedKeys.size();\\n        vector<int> dp(n,-1);\\n        return f(0,pressedKeys,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3861489,
                "title": "tabulation-java-bottom-up-explanation-in-comments-line-wise",
                "content": "COMMENTED PRECISELY\\n\\n# Code TABULATION (BOTTOM UP )\\n```\\nclass Solution {\\n    int mod = (1000000007);\\n    public int countTexts(String pressedKeys) {\\n\\n        int [] key = new int[] { 0 , 0 , 3 , 3 , 3 , 3 , 3  , 4 , 3 , 4 }; //number of alphabets available at any pressed digit \\n\\n        int n = pressedKeys.length();\\n\\n        int [] dp = new int [n+1];  // n + 1 bcz dp[n] = 1 is set to be one to include \"\" case which returns 1 possible message is sent .. \\n        //forming condition for memoization\\n\\n        dp[n] = 1; // note n index is the not the part of string ..\\n        //string has length n , means n-1 is the last index of string \\n\\n\\n        for(int ind = n - 1 ; ind >= 0 ; ind--){\\n\\n            int count = 0 ;\\n            int num = pressedKeys.charAt(ind) - \\'0\\'; // retreiving the number pressed from the inout string \\n\\n            int rep =  key[num]; // getting the number of alphabets \\n            //that are stored along the digit at the phone dial pad \\n\\n            for(int i = 0 ; i < rep && ind + i < pressedKeys.length() && pressedKeys.charAt(ind) == pressedKeys.charAt(ind + i ) ; i++){\\n             // the for loop condition \\n             // preesedKeys.charAt(ind) == pressedKeys.charAt(ind + i) and i = 0 for the start ..so compares itself to itself only  in 1st iteration \\n\\n             \\n\\n                count += dp[ind + i + 1];\\n                count %= mod;\\n\\n                // for eg  n = 7  and \"3334444\"\\n                //dp[] of size 7+1 is initialized\\n\\n                // dp[7] = 1 \\n                // dp[6] = dp[7] = 1\\n\\n                // dp[5] = dp[6] + dp[7] = 1 + 1 = 2\\n                //dp[4] = dp[7] + dp[6] + dp[5] = 1 + 1 + 2 = 4 \\n            }\\n\\n            dp[ind] = count;\\n        }\\n         return dp[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int mod = (1000000007);\\n    public int countTexts(String pressedKeys) {\\n\\n        int [] key = new int[] { 0 , 0 , 3 , 3 , 3 , 3 , 3  , 4 , 3 , 4 }; //number of alphabets available at any pressed digit \\n\\n        int n = pressedKeys.length();\\n\\n        int [] dp = new int [n+1];  // n + 1 bcz dp[n] = 1 is set to be one to include \"\" case which returns 1 possible message is sent .. \\n        //forming condition for memoization\\n\\n        dp[n] = 1; // note n index is the not the part of string ..\\n        //string has length n , means n-1 is the last index of string \\n\\n\\n        for(int ind = n - 1 ; ind >= 0 ; ind--){\\n\\n            int count = 0 ;\\n            int num = pressedKeys.charAt(ind) - \\'0\\'; // retreiving the number pressed from the inout string \\n\\n            int rep =  key[num]; // getting the number of alphabets \\n            //that are stored along the digit at the phone dial pad \\n\\n            for(int i = 0 ; i < rep && ind + i < pressedKeys.length() && pressedKeys.charAt(ind) == pressedKeys.charAt(ind + i ) ; i++){\\n             // the for loop condition \\n             // preesedKeys.charAt(ind) == pressedKeys.charAt(ind + i) and i = 0 for the start ..so compares itself to itself only  in 1st iteration \\n\\n             \\n\\n                count += dp[ind + i + 1];\\n                count %= mod;\\n\\n                // for eg  n = 7  and \"3334444\"\\n                //dp[] of size 7+1 is initialized\\n\\n                // dp[7] = 1 \\n                // dp[6] = dp[7] = 1\\n\\n                // dp[5] = dp[6] + dp[7] = 1 + 1 = 2\\n                //dp[4] = dp[7] + dp[6] + dp[5] = 1 + 1 + 2 = 4 \\n            }\\n\\n            dp[ind] = count;\\n        }\\n         return dp[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3857665,
                "title": "used-brute-force-and-memoized-it-but-gives-mle-can-help-me-to-optimize-it-please",
                "content": "```\\nclass Solution:\\n    def isValidKey(self, key, mp):\\n        length = len(key)\\n        stk = []\\n        stk.append(key[0])\\n        for i in key[1:]:\\n            if(stk[-1] == i):\\n                continue\\n            else:\\n                stk.append(i)\\n        if(len(stk) > 1):\\n            return False\\n        key = stk[0]\\n        if(length > mp[key]):\\n            return False\\n        return True\\n    \\n    def helper(self, pressedKeys, mp, dp):\\n        if( not pressedKeys):\\n            return 1\\n        if pressedKeys in dp:\\n            return dp[pressedKeys]\\n        res = 0\\n        for i in range(0, len(pressedKeys)):\\n            ch = pressedKeys[:i+1]\\n            if(self.isValidKey(ch, mp)):\\n                res += self.helper(pressedKeys[i+1:], mp, dp) % 1000000007\\n            else:\\n                break\\n        dp[pressedKeys] = res % 1000000007\\n        return dp[pressedKeys]\\n    \\n    def countTexts(self, pressedKeys: str) -> int:\\n        mp = {\\'2\\' : 3,\\n             \\'3\\' : 3, \\n             \\'4\\' : 3, \\n             \\'5\\' : 3, \\n             \\'6\\' : 3, \\n             \\'7\\' : 4,\\n             \\'8\\' : 3,\\n             \\'9\\' : 4}\\n        dp = {}\\n        return self.helper(pressedKeys, mp, dp) % 1000000007\\n                \\n        \\n        \\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def isValidKey(self, key, mp):\\n        length = len(key)\\n        stk = []\\n        stk.append(key[0])\\n        for i in key[1:]:\\n            if(stk[-1] == i):\\n                continue\\n            else:\\n                stk.append(i)\\n        if(len(stk) > 1):\\n            return False\\n        key = stk[0]\\n        if(length > mp[key]):\\n            return False\\n        return True\\n    \\n    def helper(self, pressedKeys, mp, dp):\\n        if( not pressedKeys):\\n            return 1\\n        if pressedKeys in dp:\\n            return dp[pressedKeys]\\n        res = 0\\n        for i in range(0, len(pressedKeys)):\\n            ch = pressedKeys[:i+1]\\n            if(self.isValidKey(ch, mp)):\\n                res += self.helper(pressedKeys[i+1:], mp, dp) % 1000000007\\n            else:\\n                break\\n        dp[pressedKeys] = res % 1000000007\\n        return dp[pressedKeys]\\n    \\n    def countTexts(self, pressedKeys: str) -> int:\\n        mp = {\\'2\\' : 3,\\n             \\'3\\' : 3, \\n             \\'4\\' : 3, \\n             \\'5\\' : 3, \\n             \\'6\\' : 3, \\n             \\'7\\' : 4,\\n             \\'8\\' : 3,\\n             \\'9\\' : 4}",
                "codeTag": "Java"
            },
            {
                "id": 3857007,
                "title": "dp-faster-than-99-22-optimized-solution",
                "content": "![Screenshot 2023-08-02 100332.png](https://assets.leetcode.com/users/images/2b3c8307-b6f2-47f7-9001-08cf5692b6c7_1691049413.8140266.png)\\n\\n# Intuition\\nIf continuous occurence for 2,3,4,5,6,8 is till 3 we can use $$dp[i] = dp[i-1]<<1 $$ and same for 7,9 until continuous occurence of 4. Using a variable while iterating to keep count of same numbers occuring together.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countTexts(self, k: str) -> int:\\n        n = len(k)\\n        dp = [0 for _ in range(n)]\\n        dp[0] = 1\\n        mod = 10 ** 9 + 7\\n        count = 1\\n        for i in range(1, n):\\n            if k[i-1]!=k[i]:\\n                dp[i] = dp[i-1]\\n                count = 1\\n            else:\\n                count+=1\\n                if count <=3 and k[i] in \"234568\" or  count <= 4 and k[i] in \"79\":\\n                    dp[i] = (dp[i-1]<<1)%mod\\n                else:\\n                    dp[i] = (dp[i-1] + dp[i-2] + dp[i-3])%mod\\n                    if k[i] in \"79\":\\n                        dp[i] = (dp[i] + dp[i-4])%mod\\n        return dp[-1]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countTexts(self, k: str) -> int:\\n        n = len(k)\\n        dp = [0 for _ in range(n)]\\n        dp[0] = 1\\n        mod = 10 ** 9 + 7\\n        count = 1\\n        for i in range(1, n):\\n            if k[i-1]!=k[i]:\\n                dp[i] = dp[i-1]\\n                count = 1\\n            else:\\n                count+=1\\n                if count <=3 and k[i] in \"234568\" or  count <= 4 and k[i] in \"79\":\\n                    dp[i] = (dp[i-1]<<1)%mod\\n                else:\\n                    dp[i] = (dp[i-1] + dp[i-2] + dp[i-3])%mod\\n                    if k[i] in \"79\":\\n                        dp[i] = (dp[i] + dp[i-4])%mod\\n        return dp[-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3856389,
                "title": "c-dp",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int countTexts(string s) {\\n        int n = s.size();\\n        vector<long long> dp(n+1);\\n        dp[0] = 1;\\n        for(int i=1;i<=n;i++)\\n        {\\n            dp[i] = dp[i-1];\\n            if(i-2>=0 && s[i-1]==s[i-2])\\n            dp[i]+=dp[i-2];\\n            if(i-3>=0 && s[i-1]==s[i-2] && s[i-1]==s[i-3])\\n            dp[i]+=dp[i-3];\\n            if((s[i-1]==\\'7\\' || s[i-1]==\\'9\\') && i-4>=0 && s[i-1]==s[i-2] && s[i-1]==s[i-3] && s[i-1]==s[i-4])\\n            dp[i]+=dp[i-4];\\n            dp[i]%=mod;\\n        }\\n        return dp[n]%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int countTexts(string s) {\\n        int n = s.size();\\n        vector<long long> dp(n+1);\\n        dp[0] = 1;\\n        for(int i=1;i<=n;i++)\\n        {\\n            dp[i] = dp[i-1];\\n            if(i-2>=0 && s[i-1]==s[i-2])\\n            dp[i]+=dp[i-2];\\n            if(i-3>=0 && s[i-1]==s[i-2] && s[i-1]==s[i-3])\\n            dp[i]+=dp[i-3];\\n            if((s[i-1]==\\'7\\' || s[i-1]==\\'9\\') && i-4>=0 && s[i-1]==s[i-2] && s[i-1]==s[i-3] && s[i-1]==s[i-4])\\n            dp[i]+=dp[i-4];\\n            dp[i]%=mod;\\n        }\\n        return dp[n]%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3829619,
                "title": "o-n-1d-dp-top-down-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    vector<long long> dp;\\n    long long solve(string& pressedKeys,int i){\\n        if(i==pressedKeys.size()) return 1;\\n        if(dp[i]!=-1) return dp[i];\\n        long long totalWays=0;\\n        int j=i;\\n        while(j<pressedKeys.size() && pressedKeys[i]==pressedKeys[j]){\\n            if(j-i==3 && (pressedKeys[i]!=\\'7\\' && pressedKeys[i]!=\\'9\\')){\\n                break;\\n            }else if(j-i==4) break;\\n            totalWays+=solve(pressedKeys,j+1);\\n            totalWays%=mod;\\n            j++;\\n        }\\n        return dp[i]=totalWays%mod;\\n    }\\n    int countTexts(string pressedKeys) {\\n        dp.resize(pressedKeys.size(),-1);\\n        return solve(pressedKeys,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    vector<long long> dp;\\n    long long solve(string& pressedKeys,int i){\\n        if(i==pressedKeys.size()) return 1;\\n        if(dp[i]!=-1) return dp[i];\\n        long long totalWays=0;\\n        int j=i;\\n        while(j<pressedKeys.size() && pressedKeys[i]==pressedKeys[j]){\\n            if(j-i==3 && (pressedKeys[i]!=\\'7\\' && pressedKeys[i]!=\\'9\\')){\\n                break;\\n            }else if(j-i==4) break;\\n            totalWays+=solve(pressedKeys,j+1);\\n            totalWays%=mod;\\n            j++;\\n        }\\n        return dp[i]=totalWays%mod;\\n    }\\n    int countTexts(string pressedKeys) {\\n        dp.resize(pressedKeys.size(),-1);\\n        return solve(pressedKeys,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821220,
                "title": "python-single-pass-o-n-solution-with-o-1-space",
                "content": "```\\nclass Solution:\\n    # Time: O(N), Space: O(1)\\n    def countTexts(self, pressedKeys: str) -> int:\\n        \\n        # we can identify the groups of similar digits and then for each group we find the number of ways and finally multiply\\n        # the ways of each group together to find the answer\\n        # Example: 22233\\n        # in this example there are two groups 222 and 33\\n        # 222 can be split in 4 ways => 2 2 2, 22 2, 2 22, 222\\n        # 33 can be split in 2 ways => 3 3, 33 \\n        # so total ways are 4*2 = 8\\n        \\n        # Example 2: 2222\\n        # there is only one group\\n        # ways = 2 2 2 2, 22 2 2, 222 2, 2 2 22, 2 22 2, 2 222, 22 22\\n        # not that 2222 is not valid in this case as 2 can only be pressed max 3 times so we cannot take more than 3 2\\'s\\n        # as one unit\\n        \\n        # now we try to find the pattern here\\n        # for single 2 there is 1 way\\n        # for two 2\\'s there are 1*2=2 ways => 2 2, 22\\n        # for three 2\\'s there are 2*2=4 ways\\n        # for four ways there are 4*2-1=7 ways\\n        # for each next length the number of ways are increasing by a factor of 2\\n        # but for lengths larger than 3 it is not increasing by a factor of 2 as at max we can take 3 digits as one unit\\n        # so for each length larger than 3 we subtract the ways at cur_length - 3 from current length ways\\n        \\n        # Look at the below example \\n        # the combinations for the lengths from 1 to 14\\n        # length = 1,2,3,4,5 ,6 ,7 ,8 ,9  ,10 ,11 ,12 ,13  ,14\\n        # ways   = 1,2,4,7,13,24,44,81,149,274,504,927,1705,3136\\n        # now we can find some pattern in this series\\n        # we keep the first 3 elements in an array as we know the combinations for 3 digits. so for 3 \\n        # letter digits we store 1,2,4,7 and for 4 letter digits we store 1,2,4,8,15 \\n        # now to calculate the combinations for all lengths above 4 we use the formula ways[i-1]*2-ways[i-3]\\n        # as for 3 letter digits we cannot use more than 3 digits as one unit so we need to subtract the\\n        # combinations we had at length i-3\\n        # we do the same for four length digits but for four length digits we subtract i-4\\n        \\n        # to save the space we do not need to store every length in an array of length N, as each length is \\n        # depenedent on last 4 lengths only so we can use an array of length 4 to optimize space to O(1)\\n        \\n        \\n        three_letter_digits = set([\\'2\\',\\'3\\',\\'4\\',\\'5\\',\\'6\\',\\'8\\'])\\n        four_letter_digits = set([\\'7\\',\\'9\\'])\\n        \\n        three_letters_dp, four_letters_dp = [1,2,4,7], [1,2,4,8,15]\\n        cur_group_length = 1\\n        total_combinations = prev_group_combinations = 1\\n        \\n        for i in range(1, len(pressedKeys)):\\n            char = pressedKeys[i]\\n            if char != pressedKeys[i-1]:\\n                # new group started so we reset all variables\\n                total_combinations *= prev_group_combinations\\n                cur_group_length = 1\\n                prev_group_combinations = 1\\n                three_letters_dp, four_letters_dp = [1,2,4,7], [1,2,4,8,15]\\n            else:\\n                cur_group_length += 1\\n                index = (cur_group_length-1)%4 if char in three_letter_digits else (cur_group_length-1)%5\\n                if char in three_letter_digits and cur_group_length > 4:\\n                    last_length_combs = max(three_letters_dp)\\n                    three_letters_dp[index] = last_length_combs*2 - three_letters_dp[index]\\n                elif char in four_letter_digits and cur_group_length > 5:\\n                    last_length_combs = max(four_letters_dp)\\n                    four_letters_dp[index] = last_length_combs*2 - four_letters_dp[index]\\n                \\n                prev_group_combinations = three_letters_dp[index] if char in three_letter_digits else four_letters_dp[index]\\n        \\n        total_combinations *= prev_group_combinations\\n        \\n        return total_combinations % (pow(10,9) + 7)\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # Time: O(N), Space: O(1)\\n    def countTexts(self, pressedKeys: str) -> int:\\n        \\n        # we can identify the groups of similar digits and then for each group we find the number of ways and finally multiply\\n        # the ways of each group together to find the answer\\n        # Example: 22233\\n        # in this example there are two groups 222 and 33\\n        # 222 can be split in 4 ways => 2 2 2, 22 2, 2 22, 222\\n        # 33 can be split in 2 ways => 3 3, 33 \\n        # so total ways are 4*2 = 8\\n        \\n        # Example 2: 2222\\n        # there is only one group\\n        # ways = 2 2 2 2, 22 2 2, 222 2, 2 2 22, 2 22 2, 2 222, 22 22\\n        # not that 2222 is not valid in this case as 2 can only be pressed max 3 times so we cannot take more than 3 2\\'s\\n        # as one unit\\n        \\n        # now we try to find the pattern here\\n        # for single 2 there is 1 way\\n        # for two 2\\'s there are 1*2=2 ways => 2 2, 22\\n        # for three 2\\'s there are 2*2=4 ways\\n        # for four ways there are 4*2-1=7 ways\\n        # for each next length the number of ways are increasing by a factor of 2\\n        # but for lengths larger than 3 it is not increasing by a factor of 2 as at max we can take 3 digits as one unit\\n        # so for each length larger than 3 we subtract the ways at cur_length - 3 from current length ways\\n        \\n        # Look at the below example \\n        # the combinations for the lengths from 1 to 14\\n        # length = 1,2,3,4,5 ,6 ,7 ,8 ,9  ,10 ,11 ,12 ,13  ,14\\n        # ways   = 1,2,4,7,13,24,44,81,149,274,504,927,1705,3136\\n        # now we can find some pattern in this series\\n        # we keep the first 3 elements in an array as we know the combinations for 3 digits. so for 3 \\n        # letter digits we store 1,2,4,7 and for 4 letter digits we store 1,2,4,8,15 \\n        # now to calculate the combinations for all lengths above 4 we use the formula ways[i-1]*2-ways[i-3]\\n        # as for 3 letter digits we cannot use more than 3 digits as one unit so we need to subtract the\\n        # combinations we had at length i-3\\n        # we do the same for four length digits but for four length digits we subtract i-4\\n        \\n        # to save the space we do not need to store every length in an array of length N, as each length is \\n        # depenedent on last 4 lengths only so we can use an array of length 4 to optimize space to O(1)\\n        \\n        \\n        three_letter_digits = set([\\'2\\',\\'3\\',\\'4\\',\\'5\\',\\'6\\',\\'8\\'])\\n        four_letter_digits = set([\\'7\\',\\'9\\'])\\n        \\n        three_letters_dp, four_letters_dp = [1,2,4,7], [1,2,4,8,15]\\n        cur_group_length = 1\\n        total_combinations = prev_group_combinations = 1\\n        \\n        for i in range(1, len(pressedKeys)):\\n            char = pressedKeys[i]\\n            if char != pressedKeys[i-1]:\\n                # new group started so we reset all variables\\n                total_combinations *= prev_group_combinations\\n                cur_group_length = 1\\n                prev_group_combinations = 1\\n                three_letters_dp, four_letters_dp = [1,2,4,7], [1,2,4,8,15]\\n            else:\\n                cur_group_length += 1\\n                index = (cur_group_length-1)%4 if char in three_letter_digits else (cur_group_length-1)%5\\n                if char in three_letter_digits and cur_group_length > 4:\\n                    last_length_combs = max(three_letters_dp)\\n                    three_letters_dp[index] = last_length_combs*2 - three_letters_dp[index]\\n                elif char in four_letter_digits and cur_group_length > 5:\\n                    last_length_combs = max(four_letters_dp)\\n                    four_letters_dp[index] = last_length_combs*2 - four_letters_dp[index]\\n                \\n                prev_group_combinations = three_letters_dp[index] if char in three_letter_digits else four_letters_dp[index]\\n        \\n        total_combinations *= prev_group_combinations\\n        \\n        return total_combinations % (pow(10,9) + 7)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3807863,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> dp3;\\n    vector<int> dp4;\\n    long long mod;\\n    vector<int> available;\\n    long long getCount(int available, int n, vector<int> &dp) {\\n        if (dp[n]) return dp[n];\\n        long long answer = 0; \\n        for (int i = 1; i <= available; ++i) {\\n            if (n - i >= 0)answer += getCount(available, n - i, dp);\\n        }\\n        answer %= mod;\\n        dp[n] = answer;\\n        return answer;\\n    }\\n    int countTexts(string pressedKeys) {\\n        \\n        long long answer = 1;\\n        int size = std::max(int(pressedKeys.size() + 1),10);\\n        dp3.resize(size, 0);\\n        dp4.resize(size, 0);\\n        mod = 1E9 + 7;\\n        available = {0, 0, 3, 3, 3, 3, 3, 4, 3, 4};\\n\\n        dp3[0] = dp4[0] = 1;\\n        dp3[1] = dp4[1] = 1;\\n        dp3[2] = dp4[2] = 2;\\n        dp3[3] = dp4[3] = 4;\\n        dp3[4] = 7;\\n        dp4[4] = 8;\\n\\n        char ch = pressedKeys[0];\\n        int count = 0;\\n        for (char x : pressedKeys) {\\n            if (x == ch) ++count;\\n            else {\\n                int number = ch - \\'0\\';\\n                if (number == 7 || number == 9) answer *= getCount(available[number], count, dp4);\\n                else answer *= getCount(available[number], count, dp3);\\n                answer %= mod;\\n                count = 1;\\n                ch = x;\\n            }\\n        }\\n        int number = ch - \\'0\\';\\n        if (number == 7 || number == 9) answer *= getCount(available[number], count, dp4);\\n        else answer *= getCount(available[number], count, dp3);\\n        answer %= mod;\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> dp3;\\n    vector<int> dp4;\\n    long long mod;\\n    vector<int> available;\\n    long long getCount(int available, int n, vector<int> &dp) {\\n        if (dp[n]) return dp[n];\\n        long long answer = 0; \\n        for (int i = 1; i <= available; ++i) {\\n            if (n - i >= 0)answer += getCount(available, n - i, dp);\\n        }\\n        answer %= mod;\\n        dp[n] = answer;\\n        return answer;\\n    }\\n    int countTexts(string pressedKeys) {\\n        \\n        long long answer = 1;\\n        int size = std::max(int(pressedKeys.size() + 1),10);\\n        dp3.resize(size, 0);\\n        dp4.resize(size, 0);\\n        mod = 1E9 + 7;\\n        available = {0, 0, 3, 3, 3, 3, 3, 4, 3, 4};\\n\\n        dp3[0] = dp4[0] = 1;\\n        dp3[1] = dp4[1] = 1;\\n        dp3[2] = dp4[2] = 2;\\n        dp3[3] = dp4[3] = 4;\\n        dp3[4] = 7;\\n        dp4[4] = 8;\\n\\n        char ch = pressedKeys[0];\\n        int count = 0;\\n        for (char x : pressedKeys) {\\n            if (x == ch) ++count;\\n            else {\\n                int number = ch - \\'0\\';\\n                if (number == 7 || number == 9) answer *= getCount(available[number], count, dp4);\\n                else answer *= getCount(available[number], count, dp3);\\n                answer %= mod;\\n                count = 1;\\n                ch = x;\\n            }\\n        }\\n        int number = ch - \\'0\\';\\n        if (number == 7 || number == 9) answer *= getCount(available[number], count, dp4);\\n        else answer *= getCount(available[number], count, dp3);\\n        answer %= mod;\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3793062,
                "title": "recursive-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int func(string &s, int i, int n, vector<int> &dp){\\n        if(i>=n) return 1;\\n        if(dp[i]!=-1) return dp[i];\\n        int ans=0;\\n        if(i+1<n && s[i]==s[i+1]){\\n            ans+=func(s,i+2,n,dp);\\n            ans=ans%mod;\\n            if(i+2<n && s[i]==s[i+2]){\\n                ans+=func(s,i+3,n,dp);\\n                ans=ans%mod;\\n                if(i+3<n && s[i]==s[i+3] && (s[i]==\\'9\\' || s[i]==\\'7\\')){\\n                    ans+=func(s,i+4,n,dp);\\n                    ans=ans%mod;\\n                }\\n            }\\n        }\\n        ans+=func(s,i+1,n,dp);\\n        ans=ans%mod;\\n        return dp[i]=ans;\\n    }\\n    int countTexts(string s) {\\n        int n=s.size();\\n        vector<int> dp(n+1,-1);\\n        return func(s,0,n,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int func(string &s, int i, int n, vector<int> &dp){\\n        if(i>=n) return 1;\\n        if(dp[i]!=-1) return dp[i];\\n        int ans=0;\\n        if(i+1<n && s[i]==s[i+1]){\\n            ans+=func(s,i+2,n,dp);\\n            ans=ans%mod;\\n            if(i+2<n && s[i]==s[i+2]){\\n                ans+=func(s,i+3,n,dp);\\n                ans=ans%mod;\\n                if(i+3<n && s[i]==s[i+3] && (s[i]==\\'9\\' || s[i]==\\'7\\')){\\n                    ans+=func(s,i+4,n,dp);\\n                    ans=ans%mod;\\n                }\\n            }\\n        }\\n        ans+=func(s,i+1,n,dp);\\n        ans=ans%mod;\\n        return dp[i]=ans;\\n    }\\n    int countTexts(string s) {\\n        int n=s.size();\\n        vector<int> dp(n+1,-1);\\n        return func(s,0,n,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3780208,
                "title": "c-o-n-faster-than-100-solutions-simple-dp-single-pass-solution-7ms",
                "content": "```\\nint val[10] = {0, 0, 3, 3, 3, 3, 3, 4, 3, 4};\\nvector<long long> th((int)1e5+1), f((int)1e5+2);\\nint mod = 1e9+7;\\nconst int fast = [](){\\n    th[0] = 1;\\n    th[1] = 1;\\n    th[2] = 2;\\n    \\n    f[0] = 1;\\n    f[1] = 1;\\n    f[2] = 2;\\n    f[3] = 4;\\n    \\n    for(int i=3;i<th.size();i++)\\n    {\\n        th[i] = (th[i-1]+th[i-2]+th[i-3])%mod;\\n        f[i+1] = (f[i] + f[i-1]+f[i-2]+f[i-3])%mod;\\n    }\\n    \\n    ios_base::sync_with_stdio(false);\\n    cin.tie(NULL);\\n    \\n    return 0;\\n}();\\nclass Solution {\\npublic:\\n    int countTexts(string pressedKeys) {\\n        int ans = 1;\\n        \\n        for(int i=0;i<pressedKeys.length();i++)\\n        {\\n            int j = i+1;\\n            for(;j<pressedKeys.size();j++)\\n            {\\n                if(pressedKeys[j]!=pressedKeys[i])break;\\n            }\\n            \\n            ans = (1LL*ans*((val[pressedKeys[i]-\\'0\\']==3)?th[j-i]:f[j-i]))%mod;\\n            i = j-1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n\\n\\tWe first stored the number of alphabets on that are possible for each each number, e.g. 3 characters (a,b,c) are possible using 2 and 4 characters (p,q,r,s) are possible using number 7.\\n\\t\\n\\tThen I make the arrays th (for numbers which can produce 3 characters) and f (for 4 characters).\\n\\nThese arrays store the number of ways to make a string if there are contiguous numbers which are same.\\n\\nFor e.g. if 2 comes 5 times conitnuosly, and we know two can make 3 characters:\\n\\twe simply use th[5].\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint val[10] = {0, 0, 3, 3, 3, 3, 3, 4, 3, 4};\\nvector<long long> th((int)1e5+1), f((int)1e5+2);\\nint mod = 1e9+7;\\nconst int fast = [](){\\n    th[0] = 1;\\n    th[1] = 1;\\n    th[2] = 2;\\n    \\n    f[0] = 1;\\n    f[1] = 1;\\n    f[2] = 2;\\n    f[3] = 4;\\n    \\n    for(int i=3;i<th.size();i++)\\n    {\\n        th[i] = (th[i-1]+th[i-2]+th[i-3])%mod;\\n        f[i+1] = (f[i] + f[i-1]+f[i-2]+f[i-3])%mod;\\n    }\\n    \\n    ios_base::sync_with_stdio(false);\\n    cin.tie(NULL);\\n    \\n    return 0;\\n}();\\nclass Solution {\\npublic:\\n    int countTexts(string pressedKeys) {\\n        int ans = 1;\\n        \\n        for(int i=0;i<pressedKeys.length();i++)\\n        {\\n            int j = i+1;\\n            for(;j<pressedKeys.size();j++)\\n            {\\n                if(pressedKeys[j]!=pressedKeys[i])break;\\n            }\\n            \\n            ans = (1LL*ans*((val[pressedKeys[i]-\\'0\\']==3)?th[j-i]:f[j-i]))%mod;\\n            i = j-1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3770330,
                "title": "cpp-2-dp-approaches-recursion-with-memoization-memoization-o-4-n-solution",
                "content": "* ### Recursion With Memoization Approach\\n```\\nclass Solution {\\npublic:\\n    int mod = (int)(1e9+7);\\n    int solve(int i,string &s, vector<int> &dp){\\n        int n = s.size();\\n        if(i>=n) return 1;\\n        if(dp[i]!=-1) return dp[i];\\n        int tot = (s[i]==\\'7\\'||s[i]==\\'9\\')?4:3;\\n        int take=0;\\n        for(int k=0;k<tot;k++){\\n            if(i+k<n and s[i+k]==s[i]) take = (take%mod + solve(i+k+1,s,dp)%mod)%mod;\\n            else break;\\n        }\\n        \\n        return dp[i] = take%mod;\\n    }\\n    int countTexts(string pressedKeys) {\\n        vector<int> dp(pressedKeys.size()+1,-1);\\n        return solve(0,pressedKeys,dp);\\n    }\\n};\\n```\\n* ### Tabulation Approach\\n```\\nclass Solution {\\npublic:\\n    int mod = (int)(1e9+7);\\n    int countTexts(string s) {\\n        int n = s.size();\\n        vector<int> dp(s.size()+1,0);\\n        dp[n]=1;\\n        \\n        for(int i=n-1;i>=0;i--){\\n            int tot = (s[i]==\\'7\\'||s[i]==\\'9\\')?4:3;\\n            int take=0;\\n            for(int k=0;k<tot;k++){\\n                if(i+k<n and s[i+k]==s[i]) take = (take%mod + dp[i+k+1]%mod)%mod;\\n                else break;\\n            }\\n\\n            dp[i] = take%mod;\\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = (int)(1e9+7);\\n    int solve(int i,string &s, vector<int> &dp){\\n        int n = s.size();\\n        if(i>=n) return 1;\\n        if(dp[i]!=-1) return dp[i];\\n        int tot = (s[i]==\\'7\\'||s[i]==\\'9\\')?4:3;\\n        int take=0;\\n        for(int k=0;k<tot;k++){\\n            if(i+k<n and s[i+k]==s[i]) take = (take%mod + solve(i+k+1,s,dp)%mod)%mod;\\n            else break;\\n        }\\n        \\n        return dp[i] = take%mod;\\n    }\\n    int countTexts(string pressedKeys) {\\n        vector<int> dp(pressedKeys.size()+1,-1);\\n        return solve(0,pressedKeys,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int mod = (int)(1e9+7);\\n    int countTexts(string s) {\\n        int n = s.size();\\n        vector<int> dp(s.size()+1,0);\\n        dp[n]=1;\\n        \\n        for(int i=n-1;i>=0;i--){\\n            int tot = (s[i]==\\'7\\'||s[i]==\\'9\\')?4:3;\\n            int take=0;\\n            for(int k=0;k<tot;k++){\\n                if(i+k<n and s[i+k]==s[i]) take = (take%mod + dp[i+k+1]%mod)%mod;\\n                else break;\\n            }\\n\\n            dp[i] = take%mod;\\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3756626,
                "title": "java-dp-31ms-beats-91",
                "content": "# Approach\\n1. Use an  int[] values to store the values/count of texts that can be formed backwords. values[n -1] = 1;\\n2. Look at each number: \\n    - key 4 can form 3 sequences: pressed once, twice, three times\\n    - key 9 can form 4 sequences: pressed once, twice, three, four times.\\n3. Create a simple mapping for max number of presses for each number: 3 -> 2, 9 > 3 means that digit 3 can take up at most 2 other chars at its right (current, next and next so an offset of 2) \\n4. Let\\'s look at the exmple 333 : values[0,0,1] (values[n-1] = 1 as last digit can form just 1 single number:itself)\\n    - i = 1: 33: \\n    - we can have one sequence of 1 press (d), thus the word is dd\\n    - we can have one sequence of 2 presses: (e) thus the word is e\\n    so values is [0,2,1]\\n    - i = 0: 333\\n    - if we press 3 once, then we form the text/word count given by values[1] = 2\\n    - if we press two times we form the text/word count given by values[2] = 1  \\n    - if we press it 3 times, we form the text f, thus just 1 word\\n    - total = 2+1+1 = 4;            \\n5. Starting from index i = n-2 to 0\\n    - loop with j from current index and stop when j reaches the max number of allowed keys for that number OR > n\\n    - sum up the indices/values represented by values[i+j+1] for each loop of j,\\n    - set values[i] = that sum.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private static final int[] maxKeys = {0,0,2,2,2,2,2,3,2,3};\\n    public int countTexts(String pressedKeys) {\\n        char[] chars = pressedKeys.toCharArray();\\n        int[] values = new int[chars.length];\\n        values[chars.length - 1] = 1;\\n        int sum;\\n        int digit, j;\\n        for (int i = chars.length - 2; i >= 0; i--) {\\n            sum = 0;\\n            j = 0;\\n            digit = chars[i] - \\'0\\';\\n            for (; j <= maxKeys[digit] && i + j < chars.length && chars[i] == chars[i + j]; j++) {\\n                sum = (sum + (i + j + 1 > chars.length - 1 ? 1 : values[i + j + 1])) % 1_000_000_007;\\n            }\\n            values[i] = sum;\\n        }\\n        return values[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private static final int[] maxKeys = {0,0,2,2,2,2,2,3,2,3};\\n    public int countTexts(String pressedKeys) {\\n        char[] chars = pressedKeys.toCharArray();\\n        int[] values = new int[chars.length];\\n        values[chars.length - 1] = 1;\\n        int sum;\\n        int digit, j;\\n        for (int i = chars.length - 2; i >= 0; i--) {\\n            sum = 0;\\n            j = 0;\\n            digit = chars[i] - \\'0\\';\\n            for (; j <= maxKeys[digit] && i + j < chars.length && chars[i] == chars[i + j]; j++) {\\n                sum = (sum + (i + j + 1 > chars.length - 1 ? 1 : values[i + j + 1])) % 1_000_000_007;\\n            }\\n            values[i] = sum;\\n        }\\n        return values[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3709203,
                "title": "simple-dp-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int dp[100000];\\n    int solve(int index,string &str){\\n        if(index>=str.size())\\n            return 1;\\n        \\n        if(dp[index]!=-1)\\n            return dp[index];\\n        int ans=0;\\n        if(str[index]==\\'9\\'||str[index]==\\'7\\'){\\n            for(int i=index;i<str.size()&&i<index+4;i++){\\n                if(str[i]!=str[index])\\n                    break;\\n                else\\n                    ans=(ans%mod+solve(i+1,str)%mod)%mod;\\n            }\\n        }\\n        \\n        else{\\n            \\n             for(int i=index;i<str.size()&&i<index+3;i++){\\n                if(str[i]!=str[index])\\n                    break;\\n                else\\n                    ans=(ans%mod+solve(i+1,str)%mod)%mod;\\n            }\\n        }\\n        \\n        \\n        return dp[index]=ans;\\n            \\n        }\\n    \\n    int countTexts(string pressedKeys) {\\n        memset(dp,-1,sizeof(dp));\\n        \\n        return solve(0,pressedKeys);\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int dp[100000];\\n    int solve(int index,string &str){\\n        if(index>=str.size())\\n            return 1;\\n        \\n        if(dp[index]!=-1)\\n            return dp[index];\\n        int ans=0;\\n        if(str[index]==\\'9\\'||str[index]==\\'7\\'){\\n            for(int i=index;i<str.size()&&i<index+4;i++){\\n                if(str[i]!=str[index])\\n                    break;\\n                else\\n                    ans=(ans%mod+solve(i+1,str)%mod)%mod;\\n            }\\n        }\\n        \\n        else{\\n            \\n             for(int i=index;i<str.size()&&i<index+3;i++){\\n                if(str[i]!=str[index])\\n                    break;\\n                else\\n                    ans=(ans%mod+solve(i+1,str)%mod)%mod;\\n            }\\n        }\\n        \\n        \\n        return dp[index]=ans;\\n            \\n        }\\n    \\n    int countTexts(string pressedKeys) {\\n        memset(dp,-1,sizeof(dp));\\n        \\n        return solve(0,pressedKeys);\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696036,
                "title": "easy-accepted-c-recursive-and-memoized-solution-similar-to-phone-keypad-problem",
                "content": "# Intuition\\nRecursion and Memoization\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    \\n    int solve(string &s,int idx,vector<string> &phone,vector<int> &dp){\\n        if(idx==s.length()){\\n            return 1;\\n        }\\n        if(dp[idx]!=-1){\\n            return dp[idx];\\n        }\\n        string mapped=phone[s[idx]-\\'0\\'];\\n        int len=mapped.length();\\n\\n        int instance=0;\\n\\n        int index=idx;\\n\\n        while(index<s.length() && s[index]==s[idx]){\\n            instance++;\\n            if(instance==len){\\n                break;\\n            }\\n            index++;\\n        }\\n\\n        int mini=min(instance,len);\\n\\n        int ans=0;\\n\\n        for(int i=1;i<=mini && i+idx<=s.length();i++){\\n            ans+=solve(s,idx+i,phone,dp)%mod;\\n            ans=ans%mod;\\n        }\\n\\n        return dp[idx]=ans%mod;\\n\\n    }\\n\\n    int countTexts(string pressedKeys) {\\n        vector<string> phone={\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        int n=pressedKeys.length();\\n        vector<int> dp(n+1,-1);\\n        return solve(pressedKeys,0,phone,dp)%mod;\\n    }\\n};\\n\\n// \"2 2 2 3 3 \" \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    \\n    int solve(string &s,int idx,vector<string> &phone,vector<int> &dp){\\n        if(idx==s.length()){\\n            return 1;\\n        }\\n        if(dp[idx]!=-1){\\n            return dp[idx];\\n        }\\n        string mapped=phone[s[idx]-\\'0\\'];\\n        int len=mapped.length();\\n\\n        int instance=0;\\n\\n        int index=idx;\\n\\n        while(index<s.length() && s[index]==s[idx]){\\n            instance++;\\n            if(instance==len){\\n                break;\\n            }\\n            index++;\\n        }\\n\\n        int mini=min(instance,len);\\n\\n        int ans=0;\\n\\n        for(int i=1;i<=mini && i+idx<=s.length();i++){\\n            ans+=solve(s,idx+i,phone,dp)%mod;\\n            ans=ans%mod;\\n        }\\n\\n        return dp[idx]=ans%mod;\\n\\n    }\\n\\n    int countTexts(string pressedKeys) {\\n        vector<string> phone={\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        int n=pressedKeys.length();\\n        vector<int> dp(n+1,-1);\\n        return solve(pressedKeys,0,phone,dp)%mod;\\n    }\\n};\\n\\n// \"2 2 2 3 3 \" \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3676641,
                "title": "c-solution-using-dp-easy-to-understand",
                "content": "\\n```\\npublic class Solution {\\n    public int CountTexts(string s) {\\n        int mod = ((int)1e9) + 7;\\n        int[] dp = new int[s.Length + 1];\\n        Array.Fill(dp,-1);\\n        int solve(int idx){\\n            if(idx >= s.Length) return 1;\\n            if(dp[idx] != -1) return dp[idx];\\n            int options = (s[idx] == \\'7\\' || s[idx] == \\'9\\') ? 4 : 3;\\n            \\n            int right = idx;\\n            while(right < s.Length && (right - idx) < options && s[right] == s[idx])\\n                right++;\\n\\n            long res = 0;\\n            for (int j = idx + 1; j <= right; j++) res += (solve(j) % mod);\\n            return dp[idx] = ((int)(res % mod));\\n        }\\n        return solve(0) % mod;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic class Solution {\\n    public int CountTexts(string s) {\\n        int mod = ((int)1e9) + 7;\\n        int[] dp = new int[s.Length + 1];\\n        Array.Fill(dp,-1);\\n        int solve(int idx){\\n            if(idx >= s.Length) return 1;\\n            if(dp[idx] != -1) return dp[idx];\\n            int options = (s[idx] == \\'7\\' || s[idx] == \\'9\\') ? 4 : 3;\\n            \\n            int right = idx;\\n            while(right < s.Length && (right - idx) < options && s[right] == s[idx])\\n                right++;\\n\\n            long res = 0;\\n            for (int j = idx + 1; j <= right; j++) res += (solve(j) % mod);\\n            return dp[idx] = ((int)(res % mod));\\n        }\\n        return solve(0) % mod;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3671545,
                "title": "pyhton3-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        dp = [0]*len(pressedKeys)\\n        spes = set({\\'7\\', \\'9\\'})\\n        dp[0] = 1\\n\\n        mod = 10**9+7\\n\\n        cnt = 1\\n        for i in range(1 , len(pressedKeys)):\\n    \\n            if pressedKeys[i] not in spes:\\n                if pressedKeys[i]== pressedKeys[i-1]:\\n                    if cnt < 3:\\n                        dp[i]= 2*dp[i-1]\\n                        cnt+=1\\n                    else:\\n                        dp[i]= dp[i-1] + dp[i-2] + dp[i-3]\\n                \\n                else:\\n                    dp[i] = dp[i-1]\\n                    cnt = 1\\n            \\n            else:\\n                if pressedKeys[i-1] == pressedKeys[i]:\\n                    if cnt<4:\\n                        dp[i] = dp[i-1]*2\\n                        cnt += 1\\n                    else:\\n                        dp[i]= dp[i-1] + dp[i-2] + dp[i-3] + dp[i-4]\\n                \\n                else:\\n                    dp[i] = dp[i-1]\\n                    cnt = 1\\n            \\n            \\n            dp[i] = dp[i]%mod\\n    \\n    \\n        return(dp[-1])\\n        \\n        \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        dp = [0]*len(pressedKeys)\\n        spes = set({\\'7\\', \\'9\\'})\\n        dp[0] = 1\\n\\n        mod = 10**9+7\\n\\n        cnt = 1\\n        for i in range(1 , len(pressedKeys)):\\n    \\n            if pressedKeys[i] not in spes:\\n                if pressedKeys[i]== pressedKeys[i-1]:\\n                    if cnt < 3:\\n                        dp[i]= 2*dp[i-1]\\n                        cnt+=1\\n                    else:\\n                        dp[i]= dp[i-1] + dp[i-2] + dp[i-3]\\n                \\n                else:\\n                    dp[i] = dp[i-1]\\n                    cnt = 1\\n            \\n            else:\\n                if pressedKeys[i-1] == pressedKeys[i]:\\n                    if cnt<4:\\n                        dp[i] = dp[i-1]*2\\n                        cnt += 1\\n                    else:\\n                        dp[i]= dp[i-1] + dp[i-2] + dp[i-3] + dp[i-4]\\n                \\n                else:\\n                    dp[i] = dp[i-1]\\n                    cnt = 1\\n            \\n            \\n            dp[i] = dp[i]%mod\\n    \\n    \\n        return(dp[-1])\\n        \\n        \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3657619,
                "title": "simple-memoization",
                "content": "```\\nclass Solution {\\nint solve(int index, string &s){\\n    if(index==s.size()) return 1;\\n    int count=0;\\n    int limit=3;\\n    if(dp[index]!=-1) return dp[index];\\n    if(s[index]-\\'0\\'==7 || s[index]-\\'0\\'==9) limit++;\\n\\t\\n    for(int i=index;i<s.size() && i-index+1<=limit;i++){ // (i-index+1) sets the limit for the length of the consecutive same letters\\n        if(s[i]==s[index]){\\n            count=(count+solve(i+1,s))%mod;\\n        }\\n        else break;\\n    }\\n    return dp[index]= count%mod;\\n}\\n    \\n    \\npublic:\\n    vector<int> dp;\\n    int mod=1e9+7;\\n    int countTexts(string s) {\\n        dp.resize(s.size()+1,-1);\\n        return solve(0,s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nint solve(int index, string &s){\\n    if(index==s.size()) return 1;\\n    int count=0;\\n    int limit=3;\\n    if(dp[index]!=-1) return dp[index];\\n    if(s[index]-\\'0\\'==7 || s[index]-\\'0\\'==9) limit++;\\n\\t\\n    for(int i=index;i<s.size() && i-index+1<=limit;i++){ // (i-index+1) sets the limit for the length of the consecutive same letters\\n        if(s[i]==s[index]){\\n            count=(count+solve(i+1,s))%mod;\\n        }\\n        else break;\\n    }\\n    return dp[index]= count%mod;\\n}\\n    \\n    \\npublic:\\n    vector<int> dp;\\n    int mod=1e9+7;\\n    int countTexts(string s) {\\n        dp.resize(s.size()+1,-1);\\n        return solve(0,s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3599494,
                "title": "dp-solutions",
                "content": "\\n\\n# Code\\n```\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    /* Top Down */\\n    /* int solve(int ind, string &s, vector<int> &dp) {\\n        if(ind == s.size()) return 1;\\n\\n        if(dp[ind] != -1) return dp[ind];\\n\\n        int maxPress = (s[ind] == \\'7\\' or s[ind] == \\'9\\') ? 4 : 3;\\n        int pressed = 1, count = 0, curr = ind;\\n        while(pressed <= maxPress and s[curr] == s[ind]) {\\n            pressed++;\\n            curr++;\\n            count = (count + solve(curr, s, dp)) % mod;\\n        }\\n\\n        return dp[ind] = count % mod;\\n    }\\n\\n    int countTexts(string pressedKeys) {\\n        int n = pressedKeys.size();\\n        vector<int> dp(n + 1, -1);\\n        return solve(0, pressedKeys, dp) % mod;\\n    } */\\n\\n    /* Bottom Up */\\n    int countTexts(string pressedKeys) {\\n        int n = pressedKeys.size();\\n        vector<int> dp(n + 1);\\n        dp[n] = 1;\\n        for(int i = n - 1; i >= 0; i--) {\\n            int maxPress = pressedKeys[i] == \\'7\\' or pressedKeys[i] == \\'9\\' ? 4 : 3;\\n            int pressed = 1, curr = i, count = 0;\\n\\n            while(pressed <= maxPress and pressedKeys[curr] == pressedKeys[i]) {\\n                pressed++;\\n                curr++;\\n                count = (count + dp[curr]) % mod;\\n            }\\n\\n            dp[i] = count % mod;\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    /* Top Down */\\n    /* int solve(int ind, string &s, vector<int> &dp) {\\n        if(ind == s.size()) return 1;\\n\\n        if(dp[ind] != -1) return dp[ind];\\n\\n        int maxPress = (s[ind] == \\'7\\' or s[ind] == \\'9\\') ? 4 : 3;\\n        int pressed = 1, count = 0, curr = ind;\\n        while(pressed <= maxPress and s[curr] == s[ind]) {\\n            pressed++;\\n            curr++;\\n            count = (count + solve(curr, s, dp)) % mod;\\n        }\\n\\n        return dp[ind] = count % mod;\\n    }\\n\\n    int countTexts(string pressedKeys) {\\n        int n = pressedKeys.size();\\n        vector<int> dp(n + 1, -1);\\n        return solve(0, pressedKeys, dp) % mod;\\n    } */\\n\\n    /* Bottom Up */\\n    int countTexts(string pressedKeys) {\\n        int n = pressedKeys.size();\\n        vector<int> dp(n + 1);\\n        dp[n] = 1;\\n        for(int i = n - 1; i >= 0; i--) {\\n            int maxPress = pressedKeys[i] == \\'7\\' or pressedKeys[i] == \\'9\\' ? 4 : 3;\\n            int pressed = 1, curr = i, count = 0;\\n\\n            while(pressed <= maxPress and pressedKeys[curr] == pressedKeys[i]) {\\n                pressed++;\\n                curr++;\\n                count = (count + dp[curr]) % mod;\\n            }\\n\\n            dp[i] = count % mod;\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3555360,
                "title": "c-recursion-memoization-tabulation-bottom-up-dp",
                "content": "we are finding every pattern possible like for example when \\na person pressed 333\\n\\nthen the total number of patters we can take ot perceive this is,\\n\\n3,3,3\\n3,33\\n33,3\\n333\\n\\nthat is 4.\\n\\nthis is what is carried out for each char in our string.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int ans(int ind,string s,vector<int> &keys,vector<int>&dp){\\n        if(ind==s.length())return 1;\\n        if(dp[ind]!=-1)return dp[ind];\\n        int count=0;\\n        int num=s[ind]-\\'0\\';\\n        int res=keys[num];\\n\\n        for(int i=0;i<res && ind+i<s.length() && s[ind+i]==s[ind];i++){\\n            count+=ans(ind+1+i,s,keys,dp);\\n            count%=mod;\\n        }\\n        return dp[ind]=count;\\n    }\\n    int countTexts(string pressedKeys) {\\n        vector<int> keys={0,0,3,3,3,3,3,4,3,4};\\n        \\n        int n=pressedKeys.size();\\n        vector<int> dp(n+1,0);\\n        string s=pressedKeys;\\n        dp[n]=1;\\n        for(int ind=n-1;ind>=0;ind--){\\n            int count=0;\\n            int num=s[ind]-\\'0\\';\\n            int res=keys[num];\\n\\n            for(int i=0;i<res && ind+i<s.length() && s[ind+i]==s[ind];i++){\\n                count+=dp[ind+1+i];\\n                count%=mod;\\n            }\\n                dp[ind]=count;\\n            }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int ans(int ind,string s,vector<int> &keys,vector<int>&dp){\\n        if(ind==s.length())return 1;\\n        if(dp[ind]!=-1)return dp[ind];\\n        int count=0;\\n        int num=s[ind]-\\'0\\';\\n        int res=keys[num];\\n\\n        for(int i=0;i<res && ind+i<s.length() && s[ind+i]==s[ind];i++){\\n            count+=ans(ind+1+i,s,keys,dp);\\n            count%=mod;\\n        }\\n        return dp[ind]=count;\\n    }\\n    int countTexts(string pressedKeys) {\\n        vector<int> keys={0,0,3,3,3,3,3,4,3,4};\\n        \\n        int n=pressedKeys.size();\\n        vector<int> dp(n+1,0);\\n        string s=pressedKeys;\\n        dp[n]=1;\\n        for(int ind=n-1;ind>=0;ind--){\\n            int count=0;\\n            int num=s[ind]-\\'0\\';\\n            int res=keys[num];\\n\\n            for(int i=0;i<res && ind+i<s.length() && s[ind+i]==s[ind];i++){\\n                count+=dp[ind+1+i];\\n                count%=mod;\\n            }\\n                dp[ind]=count;\\n            }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3552473,
                "title": "simple-dart-solution",
                "content": "\\n# Approach\\nMy first solution used recursion, but no matter how I did it I would always get a stack overflow error due to too much reucrsion so I made this solution using tabulation.\\n\\n# Code\\n```\\nclass Solution {\\n  int mod = 1000000007;\\n\\n  int countTexts(String pressedKeys) {\\n    List<int> key = [0, 0, 3, 3, 3, 3, 3, 4, 3, 4];\\n    int n = pressedKeys.length;\\n    List<int> dp = List<int>.filled(n + 1, 0);\\n    dp[n] = 1;\\n\\n    for (int ind = n - 1; ind >= 0; ind--) {\\n      int count = 0;\\n      int num = pressedKeys.codeUnitAt(ind) - \\'0\\'.codeUnitAt(0);\\n      int rep = key[num];\\n      for (int i = 0; i < rep && ind + i < pressedKeys.length && pressedKeys[ind] == pressedKeys[ind + i]; i++) {\\n        count += dp[ind + i + 1];\\n        count %= mod;\\n      }\\n      dp[ind] = count;\\n    }\\n    return dp[0];\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int mod = 1000000007;\\n\\n  int countTexts(String pressedKeys) {\\n    List<int> key = [0, 0, 3, 3, 3, 3, 3, 4, 3, 4];\\n    int n = pressedKeys.length;\\n    List<int> dp = List<int>.filled(n + 1, 0);\\n    dp[n] = 1;\\n\\n    for (int ind = n - 1; ind >= 0; ind--) {\\n      int count = 0;\\n      int num = pressedKeys.codeUnitAt(ind) - \\'0\\'.codeUnitAt(0);\\n      int rep = key[num];\\n      for (int i = 0; i < rep && ind + i < pressedKeys.length && pressedKeys[ind] == pressedKeys[ind + i]; i++) {\\n        count += dp[ind + i + 1];\\n        count %= mod;\\n      }\\n      dp[ind] = count;\\n    }\\n    return dp[0];\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520900,
                "title": "dp-memoization-java-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    long mod = (long)1e9+7;\\n    long[] dp = new long[100001];\\n    public long helper(String s,int idx,long[] dp){\\n        if(idx>=s.length()) return 1;\\n        if(dp[idx]!=-1) return dp[idx];\\n        long ans = 0;\\n            ans += (helper(s,idx+1,dp)%mod);\\n            if(idx+1<s.length() && s.charAt(idx)==s.charAt(idx+1)) ans += (helper(s,idx+2,dp)%mod);\\n            if(idx+2<s.length() && s.charAt(idx)==s.charAt(idx+1) && s.charAt(idx+2)==s.charAt(idx+1)) ans += (helper(s,idx+3,dp)%mod);\\n            if(s.charAt(idx)==\\'7\\' || s.charAt(idx)==\\'9\\'){\\n    if(idx+3<s.length() && s.charAt(idx)==s.charAt(idx+1) && s.charAt(idx+2)==s.charAt(idx+1) && s.charAt(idx+2)==s.charAt(idx+3)) ans += (helper(s,idx+4,dp)%mod);\\n            }\\n        ans %= mod;\\n        return dp[idx]=ans;\\n    }\\n    public int countTexts(String pressedKeys) {\\n        Arrays.fill(dp,-1);\\n        return (int)helper(pressedKeys,0,dp);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "String",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    long mod = (long)1e9+7;\\n    long[] dp = new long[100001];\\n    public long helper(String s,int idx,long[] dp){\\n        if(idx>=s.length()) return 1;\\n        if(dp[idx]!=-1) return dp[idx];\\n        long ans = 0;\\n            ans += (helper(s,idx+1,dp)%mod);\\n            if(idx+1<s.length() && s.charAt(idx)==s.charAt(idx+1)) ans += (helper(s,idx+2,dp)%mod);\\n            if(idx+2<s.length() && s.charAt(idx)==s.charAt(idx+1) && s.charAt(idx+2)==s.charAt(idx+1)) ans += (helper(s,idx+3,dp)%mod);\\n            if(s.charAt(idx)==\\'7\\' || s.charAt(idx)==\\'9\\'){\\n    if(idx+3<s.length() && s.charAt(idx)==s.charAt(idx+1) && s.charAt(idx+2)==s.charAt(idx+1) && s.charAt(idx+2)==s.charAt(idx+3)) ans += (helper(s,idx+4,dp)%mod);\\n            }\\n        ans %= mod;\\n        return dp[idx]=ans;\\n    }\\n    public int countTexts(String pressedKeys) {\\n        Arrays.fill(dp,-1);\\n        return (int)helper(pressedKeys,0,dp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436420,
                "title": "o-n-solution-beats-100-time",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def countTexts(self, pressedKeys):\\n        \"\"\"\\n        :type pressedKeys: str\\n        :rtype: int\\n        \"\"\"\\n        frequency_map = self.get_frequency_map(pressedKeys)\\n        tribo_max, quadro_max = self.get_max_tribo_an_quadro(frequency_map)\\n        tribos = self.get_all_tribos(tribo_max+1)\\n        quadros = self.get_all_quadros(quadro_max+1)\\n        combinations = self.get_all_combinations(tribos, quadros, frequency_map)\\n        return combinations\\n    \\n    def get_frequency_map(self, pressedKeys):\\n        frequency_map = []\\n        index = 0\\n        while index < len(pressedKeys):\\n            curr_char = pressedKeys[index]\\n            curr_count = 0\\n            while index < len(pressedKeys) and pressedKeys[index] == curr_char:\\n                curr_count+=1\\n                index+=1\\n            frequency_map.append([ord(curr_char)-ord(\\'0\\'), curr_count])\\n        \\n        return frequency_map\\n    \\n    def get_max_tribo_an_quadro(self, frequency_map):\\n        tribo_max = 3\\n        quadro_max = 4\\n        for key, freq in frequency_map:\\n            if key in [2,3,4,5,6,8]:\\n                tribo_max = max(tribo_max, freq)\\n            else:\\n               quadro_max = max(quadro_max, freq)\\n        return tribo_max, quadro_max\\n    \\n    def get_all_tribos(self, n):\\n        tribos = [0]*n\\n        tribos[0]=1\\n        tribos[1]=1\\n        tribos[2]=2\\n        for index in range(3, n):\\n            tribos[index] = self.add_all([tribos[index - 1],tribos[index - 2],tribos[index - 3]])\\n        return tribos\\n    \\n    def get_all_quadros(self, n):\\n        quadros=[0]*n\\n        quadros[0]=1\\n        quadros[1]=1\\n        quadros[2]=2\\n        quadros[3]=4\\n        for index in range(4, n):\\n            quadros[index] = self.add_all([quadros[index - 1],quadros[index - 2],quadros[index - 3],quadros[index - 4]])\\n        return quadros\\n    \\n    def get_all_combinations(self, tribos, quadros, frequency_map):\\n        combinations = 1\\n        for key, freq in frequency_map:\\n            if key in [2,3,4,5,6,8]:\\n                count = tribos[freq]\\n            else:\\n                count = quadros[freq]\\n            combinations = (combinations * count)%(1000000007)\\n        return combinations\\n\\n    \\n    def add_all(self, numbers):\\n        result = 0\\n        for num in numbers:\\n            result = (result + num)%(1000000007)\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def countTexts(self, pressedKeys):\\n        \"\"\"\\n        :type pressedKeys: str\\n        :rtype: int\\n        \"\"\"\\n        frequency_map = self.get_frequency_map(pressedKeys)\\n        tribo_max, quadro_max = self.get_max_tribo_an_quadro(frequency_map)\\n        tribos = self.get_all_tribos(tribo_max+1)\\n        quadros = self.get_all_quadros(quadro_max+1)\\n        combinations = self.get_all_combinations(tribos, quadros, frequency_map)\\n        return combinations\\n    \\n    def get_frequency_map(self, pressedKeys):\\n        frequency_map = []\\n        index = 0\\n        while index < len(pressedKeys):\\n            curr_char = pressedKeys[index]\\n            curr_count = 0\\n            while index < len(pressedKeys) and pressedKeys[index] == curr_char:\\n                curr_count+=1\\n                index+=1\\n            frequency_map.append([ord(curr_char)-ord(\\'0\\'), curr_count])\\n        \\n        return frequency_map\\n    \\n    def get_max_tribo_an_quadro(self, frequency_map):\\n        tribo_max = 3\\n        quadro_max = 4\\n        for key, freq in frequency_map:\\n            if key in [2,3,4,5,6,8]:\\n                tribo_max = max(tribo_max, freq)\\n            else:\\n               quadro_max = max(quadro_max, freq)\\n        return tribo_max, quadro_max\\n    \\n    def get_all_tribos(self, n):\\n        tribos = [0]*n\\n        tribos[0]=1\\n        tribos[1]=1\\n        tribos[2]=2\\n        for index in range(3, n):\\n            tribos[index] = self.add_all([tribos[index - 1],tribos[index - 2],tribos[index - 3]])\\n        return tribos\\n    \\n    def get_all_quadros(self, n):\\n        quadros=[0]*n\\n        quadros[0]=1\\n        quadros[1]=1\\n        quadros[2]=2\\n        quadros[3]=4\\n        for index in range(4, n):\\n            quadros[index] = self.add_all([quadros[index - 1],quadros[index - 2],quadros[index - 3],quadros[index - 4]])\\n        return quadros\\n    \\n    def get_all_combinations(self, tribos, quadros, frequency_map):\\n        combinations = 1\\n        for key, freq in frequency_map:\\n            if key in [2,3,4,5,6,8]:\\n                count = tribos[freq]\\n            else:\\n                count = quadros[freq]\\n            combinations = (combinations * count)%(1000000007)\\n        return combinations\\n\\n    \\n    def add_all(self, numbers):\\n        result = 0\\n        for num in numbers:\\n            result = (result + num)%(1000000007)\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395306,
                "title": "python-easy-dp",
                "content": "\\n```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        mod, i, res = 10**9 + 7, 0, 1\\n        def solveDp(n: int, x: int):\\n            nonlocal mod\\n            dp = [0 for _ in range(n + 1)]\\n            dp[0] = 1\\n            for i in range(1, n + 1):\\n                for j in range(x):\\n                    if i - j - 1 >= 0:\\n                        dp[i] = (dp[i] + dp[i - j - 1])%mod\\n            return dp[-1]\\n        mp = {\\'2\\': 3, \\'3\\':3, \\'4\\': 3, \\'5\\': 3, \\'6\\': 3, \\'7\\': 4, \\'8\\': 3, \\'9\\': 4}\\n        while i < len(pressedKeys):\\n            j = i + 1\\n            while j < len(pressedKeys) and pressedKeys[i] == pressedKeys[j]: j+=1\\n            res = (res * (solveDp(j - i, mp[pressedKeys[i]])))%mod\\n            i = j\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        mod, i, res = 10**9 + 7, 0, 1\\n        def solveDp(n: int, x: int):\\n            nonlocal mod\\n            dp = [0 for _ in range(n + 1)]\\n            dp[0] = 1\\n            for i in range(1, n + 1):\\n                for j in range(x):\\n                    if i - j - 1 >= 0:\\n                        dp[i] = (dp[i] + dp[i - j - 1])%mod\\n            return dp[-1]\\n        mp = {\\'2\\': 3, \\'3\\':3, \\'4\\': 3, \\'5\\': 3, \\'6\\': 3, \\'7\\': 4, \\'8\\': 3, \\'9\\': 4}\\n        while i < len(pressedKeys):\\n            j = i + 1\\n            while j < len(pressedKeys) and pressedKeys[i] == pressedKeys[j]: j+=1\\n            res = (res * (solveDp(j - i, mp[pressedKeys[i]])))%mod\\n            i = j\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3389029,
                "title": "simple-memoization-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int>dp;\\n    long long mod = 1e9+7;\\n    int f(string &s,int ind,int n){\\n\\n        if(ind==n){\\n            return 1;\\n        }\\n\\n        if(ind>n) return 0;\\n\\n        if(dp[ind]!=-1) return dp[ind]%mod;\\n\\n        if(s[ind]==\\'7\\' or s[ind]==\\'9\\'){\\n            long long ans = 0;\\n            for(int i = ind;i<ind+4;i++){\\n                if(s[ind]==s[i]){\\n                    ans = ans + f(s,i+1,n);\\n                    ans = ans % mod;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            return dp[ind] = ans%mod;\\n        }\\n\\n        else{\\n            long long ans = 0;\\n            for(int i = ind;i<ind+3;i++){\\n                if(s[ind]==s[i]){\\n                    ans = ans + f(s,i+1,n);\\n                    ans = ans % mod;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            return dp[ind] = ans%mod;\\n        }\\n\\n    }\\n\\n    int countTexts(string s) {\\n        dp.resize(s.size()+1,-1);\\n        return f(s,0,s.size())%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>dp;\\n    long long mod = 1e9+7;\\n    int f(string &s,int ind,int n){\\n\\n        if(ind==n){\\n            return 1;\\n        }\\n\\n        if(ind>n) return 0;\\n\\n        if(dp[ind]!=-1) return dp[ind]%mod;\\n\\n        if(s[ind]==\\'7\\' or s[ind]==\\'9\\'){\\n            long long ans = 0;\\n            for(int i = ind;i<ind+4;i++){\\n                if(s[ind]==s[i]){\\n                    ans = ans + f(s,i+1,n);\\n                    ans = ans % mod;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            return dp[ind] = ans%mod;\\n        }\\n\\n        else{\\n            long long ans = 0;\\n            for(int i = ind;i<ind+3;i++){\\n                if(s[ind]==s[i]){\\n                    ans = ans + f(s,i+1,n);\\n                    ans = ans % mod;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            return dp[ind] = ans%mod;\\n        }\\n\\n    }\\n\\n    int countTexts(string s) {\\n        dp.resize(s.size()+1,-1);\\n        return f(s,0,s.size())%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3385783,
                "title": "python-dp",
                "content": "```\\nimport math\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        DP = [0] * (len(pressedKeys)+1)\\n        DP[0] = 1\\n        for i in range(1, len(DP)):\\n            DP[i] = DP[i-1]\\n            if i > 1 and pressedKeys[i-1] == pressedKeys[i-2]:\\n                DP[i] += DP[i-2]\\n                DP[i] %= (10**9 + 7)\\n                if i > 2 and pressedKeys[i-1] == pressedKeys[i-3]:\\n                    DP[i] += DP[i-3]                     \\n                    DP[i] %= (10**9 + 7)     \\n                    if i > 3 and pressedKeys[i-1] in [\\'7\\', \\'9\\'] and pressedKeys[i-1] == pressedKeys[i-4]:\\n                        DP[i] += DP[i-4]\\n                        DP[i] %= (10**9 + 7)\\n        return DP[-1]\\n\\n\"\"\"\\n# Memoization and combinatorics\\n\\nimport math\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        d = {\\'2\\':3,\\'3\\':3,\\'4\\':3,\\'5\\':3,\\'6\\':3,\\'7\\':4,\\'8\\':3,\\'9\\':4}\\n    \\n        cache = dict()\\n        def cache_count(v, i):\\n            if i < 0:\\n                return 0\\n            if i == 0:\\n                return 1\\n\\n            if (v, i) in cache:\\n                return cache[(v, i)]\\n            \\n            cache[(v, i)] = sum(cache_count(v, i-j) for j in range(1, v+1))\\n            return cache[(v, i)]\\n\\n        t = 1\\n\\n        c = pressedKeys[0]\\n        l = 1\\n        for k in pressedKeys[1:]:\\n            if k == c:\\n                l += 1\\n            else:     \\n                t *= cache_count(d[c],l)\\n                t %= (10**9 + 7)\\n                l = 1\\n                c = k\\n        t *= cache_count(d[c],l)\\n        t %= (10**9 + 7)\\n        return t\\n\"\"\"\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        DP = [0] * (len(pressedKeys)+1)\\n        DP[0] = 1\\n        for i in range(1, len(DP)):\\n            DP[i] = DP[i-1]\\n            if i > 1 and pressedKeys[i-1] == pressedKeys[i-2]:\\n                DP[i] += DP[i-2]\\n                DP[i] %= (10**9 + 7)\\n                if i > 2 and pressedKeys[i-1] == pressedKeys[i-3]:\\n                    DP[i] += DP[i-3]                     \\n                    DP[i] %= (10**9 + 7)     \\n                    if i > 3 and pressedKeys[i-1] in [\\'7\\', \\'9\\'] and pressedKeys[i-1] == pressedKeys[i-4]:\\n                        DP[i] += DP[i-4]\\n                        DP[i] %= (10**9 + 7)\\n        return DP[-1]\\n\\n\"\"\"\\n# Memoization and combinatorics\\n\\nimport math\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        d = {\\'2\\':3,\\'3\\':3,\\'4\\':3,\\'5\\':3,\\'6\\':3,\\'7\\':4,\\'8\\':3,\\'9\\':4}\\n    \\n        cache = dict()\\n        def cache_count(v, i):\\n            if i < 0:\\n                return 0\\n            if i == 0:\\n                return 1\\n\\n            if (v, i) in cache:\\n                return cache[(v, i)]\\n            \\n            cache[(v, i)] = sum(cache_count(v, i-j) for j in range(1, v+1))\\n            return cache[(v, i)]\\n\\n        t = 1\\n\\n        c = pressedKeys[0]\\n        l = 1\\n        for k in pressedKeys[1:]:\\n            if k == c:\\n                l += 1\\n            else:     \\n                t *= cache_count(d[c],l)\\n                t %= (10**9 + 7)\\n                l = 1\\n                c = k\\n        t *= cache_count(d[c],l)\\n        t %= (10**9 + 7)\\n        return t\\n\"\"\"\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3374672,
                "title": "pam-parar",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} pressedKeys\\n * @return {number}\\n */\\nfunction countTexts (pressedKeys) {\\n   const strLength = pressedKeys.length;\\n   const bigInt = 10 ** 9 + 7;\\n   const fibonacci = new Array(strLength + 1).fill(0);\\n   fibonacci[0] = 1;\\n   \\n   let last = 0;\\n   let count = 0;\\n   \\n   for (let i = 1; i <= strLength; ++i) {\\n      const currient = pressedKeys[i - 1];\\n      \\n      if (currient !== last) count = 0;\\n      \\n      last = currient;\\n      count += 1;\\n      \\n      fibonacci[i] = (fibonacci[i] + fibonacci[i - 1]) % bigInt;\\n      \\n      if (i >= 2 && count >= 2) fibonacci[i] = (fibonacci[i] + fibonacci[i - 2]) % bigInt;\\n      if (i >= 3 && count >= 3) fibonacci[i] = (fibonacci[i] + fibonacci[i - 3]) % bigInt;\\n      if ((currient == \"7\"  || currient == \"9\") && i >= 4 && count >= 4) \\n      fibonacci[i] = (fibonacci[i] + fibonacci[i - 4]) % bigInt;\\n   }\\n\\n   return fibonacci[strLength];\\n   \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} pressedKeys\\n * @return {number}\\n */\\nfunction countTexts (pressedKeys) {\\n   const strLength = pressedKeys.length;\\n   const bigInt = 10 ** 9 + 7;\\n   const fibonacci = new Array(strLength + 1).fill(0);\\n   fibonacci[0] = 1;\\n   \\n   let last = 0;\\n   let count = 0;\\n   \\n   for (let i = 1; i <= strLength; ++i) {\\n      const currient = pressedKeys[i - 1];\\n      \\n      if (currient !== last) count = 0;\\n      \\n      last = currient;\\n      count += 1;\\n      \\n      fibonacci[i] = (fibonacci[i] + fibonacci[i - 1]) % bigInt;\\n      \\n      if (i >= 2 && count >= 2) fibonacci[i] = (fibonacci[i] + fibonacci[i - 2]) % bigInt;\\n      if (i >= 3 && count >= 3) fibonacci[i] = (fibonacci[i] + fibonacci[i - 3]) % bigInt;\\n      if ((currient == \"7\"  || currient == \"9\") && i >= 4 && count >= 4) \\n      fibonacci[i] = (fibonacci[i] + fibonacci[i - 4]) % bigInt;\\n   }\\n\\n   return fibonacci[strLength];\\n   \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3373550,
                "title": "a-brute-weird-solution-c-memoization",
                "content": "```\\nclass Solution\\n{\\n    const int M = 1e9 + 7;\\n    long long help(string &s, int cur, map<string, char> &mp, vector<int> &dp)\\n    {\\n        if (cur >= s.length()) return 1;\\n\\n        long long one = 0, two = 0, three = 0, four = 0;\\n\\n        if (dp[cur] != -1) return dp[cur];\\n\\n        if (cur < s.length())\\n        {\\n            string temp;\\n            temp.push_back(s[cur]);\\n            if (mp.find(temp) != mp.end())\\n            {\\n                one = help(s, cur + 1, mp, dp) % M;\\n            }\\n        }\\n        if (cur + 1 < s.length())\\n        {\\n            string temp;\\n            temp.push_back(s[cur]);\\n            temp.push_back(s[cur + 1]);\\n\\n            if (mp.find(temp) != mp.end())\\n            {\\n                two = help(s, cur + 2, mp, dp) % M;\\n            }\\n        }\\n        if (cur + 2 < s.length())\\n        {\\n            string temp;\\n            temp.push_back(s[cur]);\\n            temp.push_back(s[cur + 1]);\\n            temp.push_back(s[cur + 2]);\\n\\n            if (mp.find(temp) != mp.end())\\n            {\\n                three = help(s, cur + 3, mp, dp) % M;\\n            }\\n        }\\n        if (cur + 3 < s.length())\\n        {\\n            string temp;\\n            temp.push_back(s[cur]);\\n            temp.push_back(s[cur + 1]);\\n            temp.push_back(s[cur + 2]);\\n            temp.push_back(s[cur + 3]);\\n\\n            if (mp.find(temp) != mp.end())\\n            {\\n                four = help(s, cur + 4, mp, dp) % M;\\n            }\\n        }\\n        return dp[cur] = (one + two + three + four) % M;\\n    }\\n\\n    public:\\n        int countTexts(string s)\\n        {\\n            map<string, char> mp;\\n            mp[\"2\"] = \\'a\\';\\n            mp[\"22\"] = \\'b\\';\\n            mp[\"222\"] = \\'c\\';\\n            mp[\"3\"] = \\'d\\';\\n            mp[\"33\"] = \\'e\\';\\n            mp[\"333\"] = \\'f\\';\\n            mp[\"4\"] = \\'g\\';\\n            mp[\"44\"] = \\'h\\';\\n            mp[\"444\"] = \\'i\\';\\n            mp[\"5\"] = \\'j\\';\\n            mp[\"55\"] = \\'k\\';\\n            mp[\"555\"] = \\'l\\';\\n            mp[\"6\"] = \\'m\\';\\n            mp[\"66\"] = \\'n\\';\\n            mp[\"666\"] = \\'o\\';\\n            mp[\"7\"] = \\'p\\';\\n            mp[\"77\"] = \\'q\\';\\n            mp[\"777\"] = \\'r\\';\\n            mp[\"7777\"] = \\'s\\';\\n            mp[\"8\"] = \\'t\\';\\n            mp[\"88\"] = \\'u\\';\\n            mp[\"888\"] = \\'v\\';\\n            mp[\"9\"] = \\'w\\';\\n            mp[\"99\"] = \\'x\\';\\n            mp[\"999\"] = \\'y\\';\\n            mp[\"9999\"] = \\'z\\';\\n\\n            int n = s.length();\\n            vector<int> dp(n, -1);\\n            return help(s, 0, mp, dp);\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution\\n{\\n    const int M = 1e9 + 7;\\n    long long help(string &s, int cur, map<string, char> &mp, vector<int> &dp)\\n    {\\n        if (cur >= s.length()) return 1;\\n\\n        long long one = 0, two = 0, three = 0, four = 0;\\n\\n        if (dp[cur] != -1) return dp[cur];\\n\\n        if (cur < s.length())\\n        {\\n            string temp;\\n            temp.push_back(s[cur]);\\n            if (mp.find(temp) != mp.end())\\n            {\\n                one = help(s, cur + 1, mp, dp) % M;\\n            }\\n        }\\n        if (cur + 1 < s.length())\\n        {\\n            string temp;\\n            temp.push_back(s[cur]);\\n            temp.push_back(s[cur + 1]);\\n\\n            if (mp.find(temp) != mp.end())\\n            {\\n                two = help(s, cur + 2, mp, dp) % M;\\n            }\\n        }\\n        if (cur + 2 < s.length())\\n        {\\n            string temp;\\n            temp.push_back(s[cur]);\\n            temp.push_back(s[cur + 1]);\\n            temp.push_back(s[cur + 2]);\\n\\n            if (mp.find(temp) != mp.end())\\n            {\\n                three = help(s, cur + 3, mp, dp) % M;\\n            }\\n        }\\n        if (cur + 3 < s.length())\\n        {\\n            string temp;\\n            temp.push_back(s[cur]);\\n            temp.push_back(s[cur + 1]);\\n            temp.push_back(s[cur + 2]);\\n            temp.push_back(s[cur + 3]);\\n\\n            if (mp.find(temp) != mp.end())\\n            {\\n                four = help(s, cur + 4, mp, dp) % M;\\n            }\\n        }\\n        return dp[cur] = (one + two + three + four) % M;\\n    }\\n\\n    public:\\n        int countTexts(string s)\\n        {\\n            map<string, char> mp;\\n            mp[\"2\"] = \\'a\\';\\n            mp[\"22\"] = \\'b\\';\\n            mp[\"222\"] = \\'c\\';\\n            mp[\"3\"] = \\'d\\';\\n            mp[\"33\"] = \\'e\\';\\n            mp[\"333\"] = \\'f\\';\\n            mp[\"4\"] = \\'g\\';\\n            mp[\"44\"] = \\'h\\';\\n            mp[\"444\"] = \\'i\\';\\n            mp[\"5\"] = \\'j\\';\\n            mp[\"55\"] = \\'k\\';\\n            mp[\"555\"] = \\'l\\';\\n            mp[\"6\"] = \\'m\\';\\n            mp[\"66\"] = \\'n\\';\\n            mp[\"666\"] = \\'o\\';\\n            mp[\"7\"] = \\'p\\';\\n            mp[\"77\"] = \\'q\\';\\n            mp[\"777\"] = \\'r\\';\\n            mp[\"7777\"] = \\'s\\';\\n            mp[\"8\"] = \\'t\\';\\n            mp[\"88\"] = \\'u\\';\\n            mp[\"888\"] = \\'v\\';\\n            mp[\"9\"] = \\'w\\';\\n            mp[\"99\"] = \\'x\\';\\n            mp[\"999\"] = \\'y\\';\\n            mp[\"9999\"] = \\'z\\';\\n\\n            int n = s.length();\\n            vector<int> dp(n, -1);\\n            return help(s, 0, mp, dp);\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345505,
                "title": "c-golang-dp",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\n    const int mod = 1e9 + 7; \\npublic:\\n    int countTexts(string pressedKeys) {\\n        int j, n = pressedKeys.size();\\n        vector<int> DP(n, 1);\\n        long long ans = 1;\\n        for(int i = 0; i < n; i = j) {\\n            for(j = i + 1; j < n && pressedKeys[j] == pressedKeys[i]; j++) {\\n                if(j - i == 1) {\\n                    DP[j] = 2; continue;\\n                } else if(j - i == 2) {\\n                    DP[j] = 4; continue;\\n                }\\n                DP[j] = ((DP[j - 1] + DP[j - 2]) % mod + DP[j - 3]) % mod;\\n                if(pressedKeys[i] == \\'7\\' || pressedKeys[i] == \\'9\\') {\\n                    if(j - i == 3) {\\n                        DP[j] = 8; continue;\\n                    }\\n                    DP[j] = (DP[j] + DP[j - 4]) % mod;\\n                }\\n            }\\n            ans = (ans * DP[j - 1]) % mod;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nconst mod int = 1e9 + 7\\nfunc countTexts(pressedKeys string) int {\\n    var j, n int = 1, len(pressedKeys)\\n    DP := make([]int, n)\\n    var ans int = 1\\n    for i := 0; i < n; i = j {\\n        DP[i] = 1\\n        for j = i + 1; j < n && pressedKeys[j] == pressedKeys[i]; j++ {\\n            if j - i == 1 {\\n                DP[j] = 2\\n                continue\\n            } else if j - i == 2 {\\n                DP[j] = 4 \\n                continue\\n            }\\n            DP[j] = ((DP[j - 1] + DP[j - 2]) % mod + DP[j - 3]) % mod\\n            if pressedKeys[i] == \\'7\\' || pressedKeys[i] == \\'9\\' {\\n                if j - i == 3 {\\n                    DP[j] = 8\\n                    continue\\n                }\\n                DP[j] = (DP[j] + DP[j - 4]) % mod\\n            }\\n        }\\n        ans = (ans * DP[j - 1]) % mod\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "Math",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\n// C++\\nclass Solution {\\n    const int mod = 1e9 + 7; \\npublic:\\n    int countTexts(string pressedKeys) {\\n        int j, n = pressedKeys.size();\\n        vector<int> DP(n, 1);\\n        long long ans = 1;\\n        for(int i = 0; i < n; i = j) {\\n            for(j = i + 1; j < n && pressedKeys[j] == pressedKeys[i]; j++) {\\n                if(j - i == 1) {\\n                    DP[j] = 2; continue;\\n                } else if(j - i == 2) {\\n                    DP[j] = 4; continue;\\n                }\\n                DP[j] = ((DP[j - 1] + DP[j - 2]) % mod + DP[j - 3]) % mod;\\n                if(pressedKeys[i] == \\'7\\' || pressedKeys[i] == \\'9\\') {\\n                    if(j - i == 3) {\\n                        DP[j] = 8; continue;\\n                    }\\n                    DP[j] = (DP[j] + DP[j - 4]) % mod;\\n                }\\n            }\\n            ans = (ans * DP[j - 1]) % mod;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nconst mod int = 1e9 + 7\\nfunc countTexts(pressedKeys string) int {\\n    var j, n int = 1, len(pressedKeys)\\n    DP := make([]int, n)\\n    var ans int = 1\\n    for i := 0; i < n; i = j {\\n        DP[i] = 1\\n        for j = i + 1; j < n && pressedKeys[j] == pressedKeys[i]; j++ {\\n            if j - i == 1 {\\n                DP[j] = 2\\n                continue\\n            } else if j - i == 2 {\\n                DP[j] = 4 \\n                continue\\n            }\\n            DP[j] = ((DP[j - 1] + DP[j - 2]) % mod + DP[j - 3]) % mod\\n            if pressedKeys[i] == \\'7\\' || pressedKeys[i] == \\'9\\' {\\n                if j - i == 3 {\\n                    DP[j] = 8\\n                    continue\\n                }\\n                DP[j] = (DP[j] + DP[j - 4]) % mod\\n            }\\n        }\\n        ans = (ans * DP[j - 1]) % mod\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3333515,
                "title": "easy-dp-approach-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)+extra stack space\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int solve(string &s,int index,vector<int> &dp)\\n    {\\n        if(index>=s.length()){\\n            return 1;\\n        }\\n        if(dp[index]!=-1){\\n            return dp[index];\\n        }\\n        long long ans=0;\\n        //case 1\\n        ans=ans+solve(s,index+1,dp);\\n\\n        //case 2\\n        if(index+1<s.length()){\\n            if(s[index]==s[index+1]){\\n                ans=ans+solve(s,index+2,dp);\\n            }\\n        }\\n\\n        //case 3\\n        if(index+2<s.length()){\\n            if((s[index]==s[index+1])&&(s[index]==s[index+2])){\\n                ans=ans+solve(s,index+3,dp);\\n            }\\n        }\\n\\n        //case 4\\n        if(index+3<s.length() &&(s[index]==\\'7\\' || s[index]==\\'9\\')){\\n            if((s[index]==s[index+1])&&(s[index]==s[index+2])&&(s[index]==s[index+3])){\\n                ans=ans+solve(s,index+4,dp);\\n            }\\n        }\\n        return dp[index]=ans%mod;\\n    }\\n    int countTexts(string s) \\n    {\\n        int n=s.length();\\n        vector<int> dp(n+1,-1);\\n        return solve(s,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int solve(string &s,int index,vector<int> &dp)\\n    {\\n        if(index>=s.length()){\\n            return 1;\\n        }\\n        if(dp[index]!=-1){\\n            return dp[index];\\n        }\\n        long long ans=0;\\n        //case 1\\n        ans=ans+solve(s,index+1,dp);\\n\\n        //case 2\\n        if(index+1<s.length()){\\n            if(s[index]==s[index+1]){\\n                ans=ans+solve(s,index+2,dp);\\n            }\\n        }\\n\\n        //case 3\\n        if(index+2<s.length()){\\n            if((s[index]==s[index+1])&&(s[index]==s[index+2])){\\n                ans=ans+solve(s,index+3,dp);\\n            }\\n        }\\n\\n        //case 4\\n        if(index+3<s.length() &&(s[index]==\\'7\\' || s[index]==\\'9\\')){\\n            if((s[index]==s[index+1])&&(s[index]==s[index+2])&&(s[index]==s[index+3])){\\n                ans=ans+solve(s,index+4,dp);\\n            }\\n        }\\n        return dp[index]=ans%mod;\\n    }\\n    int countTexts(string s) \\n    {\\n        int n=s.length();\\n        vector<int> dp(n+1,-1);\\n        return solve(s,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268843,
                "title": "c-easy-solution-using-dp-and-memoization",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //using dp and memoization\\n    //partition and not partition variation\\n    //TC=O(N)\\n    //SC=O(N)+O(stack space)\\n    int mod=1e9+7;\\n    int find(int i,int c,string& s,vector<vector<int>>& dp,int n){\\n        if(i==n){\\n            return 1;\\n        }\\n        if(dp[i][c]!=-1){\\n            return dp[i][c]%mod;\\n        }\\n        int ways=0;\\n        if((s[i]==\\'9\\'||s[i]==\\'7\\') && c+1<=4){\\n            ways=(ways+find(i+1,0,s,dp,n))%mod;\\n        }\\n        if(s[i]!=\\'9\\' && s[i]!=\\'7\\' && c+1<=3){\\n            ways=(ways+find(i+1,0,s,dp,n))%mod;\\n        }\\n        if(i+1<n && (s[i]==\\'9\\'||s[i]==\\'7\\') && c+1<=4 && s[i]==s[i+1]){\\n            ways=(ways+find(i+1,c+1,s,dp,n))%mod;\\n        }\\n        if(i+1<n && s[i]!=\\'9\\' && s[i]!=\\'7\\' && c+1<=3 && s[i]==s[i+1]){\\n            ways=(ways+find(i+1,c+1,s,dp,n))%mod;\\n        }\\n        return dp[i][c]=ways%mod;\\n    }\\n    int countTexts(string pressedKeys) {\\n        int n=pressedKeys.size();\\n        vector<vector<int>> dp(n,vector<int>(6,-1));\\n        return find(0,0,pressedKeys,dp,n);\\n    }\\n};\\n```\\n# AUTHOR: JAYESH BADGUJAR\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //using dp and memoization\\n    //partition and not partition variation\\n    //TC=O(N)\\n    //SC=O(N)+O(stack space)\\n    int mod=1e9+7;\\n    int find(int i,int c,string& s,vector<vector<int>>& dp,int n){\\n        if(i==n){\\n            return 1;\\n        }\\n        if(dp[i][c]!=-1){\\n            return dp[i][c]%mod;\\n        }\\n        int ways=0;\\n        if((s[i]==\\'9\\'||s[i]==\\'7\\') && c+1<=4){\\n            ways=(ways+find(i+1,0,s,dp,n))%mod;\\n        }\\n        if(s[i]!=\\'9\\' && s[i]!=\\'7\\' && c+1<=3){\\n            ways=(ways+find(i+1,0,s,dp,n))%mod;\\n        }\\n        if(i+1<n && (s[i]==\\'9\\'||s[i]==\\'7\\') && c+1<=4 && s[i]==s[i+1]){\\n            ways=(ways+find(i+1,c+1,s,dp,n))%mod;\\n        }\\n        if(i+1<n && s[i]!=\\'9\\' && s[i]!=\\'7\\' && c+1<=3 && s[i]==s[i+1]){\\n            ways=(ways+find(i+1,c+1,s,dp,n))%mod;\\n        }\\n        return dp[i][c]=ways%mod;\\n    }\\n    int countTexts(string pressedKeys) {\\n        int n=pressedKeys.size();\\n        vector<vector<int>> dp(n,vector<int>(6,-1));\\n        return find(0,0,pressedKeys,dp,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3262905,
                "title": "recursion-memoization-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int mod=1e9+7;\\n    int dp[100005][5];\\n    int f(int count, int maxGrouping)\\n    {\\n        if(count==0) return 1;\\n        if(count<0) return 0;\\n        if(dp[count][maxGrouping]!=-1) return dp[count][maxGrouping];\\n        int ans=0;\\n        for(int x=1; x<=min(count,maxGrouping); x++)\\n        {\\n            ans=(ans%mod+f(count-x,maxGrouping)%mod)%mod;\\n        }\\n        return dp[count][maxGrouping]=ans%mod;\\n    }\\n    int countTexts(string pressedKeys) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        map<int,int> m;\\n        int ans=1;\\n        m[2]=3; m[3]=3; m[4]=3; m[5]=3; m[6]=3; m[7]=4; m[8]=3; m[9]=4;\\n        int n=pressedKeys.size();\\n        for(int x=0; x<n; x++)\\n        {\\n            int i=x+1;\\n            int count=1;\\n            while(i<n && pressedKeys[x]==pressedKeys[i])\\n            {\\n                i++; count++;\\n            }\\n            ans=((long long)ans%mod*f(count,m[pressedKeys[x]-48])%mod)%mod;\\n            x=i-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int mod=1e9+7;\\n    int dp[100005][5];\\n    int f(int count, int maxGrouping)\\n    {\\n        if(count==0) return 1;\\n        if(count<0) return 0;\\n        if(dp[count][maxGrouping]!=-1) return dp[count][maxGrouping];\\n        int ans=0;\\n        for(int x=1; x<=min(count,maxGrouping); x++)\\n        {\\n            ans=(ans%mod+f(count-x,maxGrouping)%mod)%mod;\\n        }\\n        return dp[count][maxGrouping]=ans%mod;\\n    }\\n    int countTexts(string pressedKeys) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        map<int,int> m;\\n        int ans=1;\\n        m[2]=3; m[3]=3; m[4]=3; m[5]=3; m[6]=3; m[7]=4; m[8]=3; m[9]=4;\\n        int n=pressedKeys.size();\\n        for(int x=0; x<n; x++)\\n        {\\n            int i=x+1;\\n            int count=1;\\n            while(i<n && pressedKeys[x]==pressedKeys[i])\\n            {\\n                i++; count++;\\n            }\\n            ans=((long long)ans%mod*f(count,m[pressedKeys[x]-48])%mod)%mod;\\n            x=i-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3210334,
                "title": "c-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    const unsigned int M = pow(10,9)+7; \\n    void dpf(string& pressedKeys, int curr, vector<int>& dp){\\n        char t = pressedKeys[curr];\\n        int num;\\n        if(t==\\'7\\'|| t==\\'9\\') num = 4;\\n        else num=3; \\n        for(int i = curr; i<dp.size() && i-curr<num && pressedKeys[i]==t; i++){\\n            if(i+1<dp.size()) dp[curr] = (dp[curr]+dp[i+1])%M; \\n            else dp[curr] = (dp[curr]+1)%M; \\n        }\\n    }\\n    int countTexts(string pressedKeys) {\\n        //dp   \\n        int len = pressedKeys.length(); \\n        vector<int> dp(len, 0);\\n        dp[len-1] = 1; \\n        for(int i = len-2; i >=0; i--)\\n            dpf(pressedKeys, i, dp); \\n        return dp[0]; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const unsigned int M = pow(10,9)+7; \\n    void dpf(string& pressedKeys, int curr, vector<int>& dp){\\n        char t = pressedKeys[curr];\\n        int num;\\n        if(t==\\'7\\'|| t==\\'9\\') num = 4;\\n        else num=3; \\n        for(int i = curr; i<dp.size() && i-curr<num && pressedKeys[i]==t; i++){\\n            if(i+1<dp.size()) dp[curr] = (dp[curr]+dp[i+1])%M; \\n            else dp[curr] = (dp[curr]+1)%M; \\n        }\\n    }\\n    int countTexts(string pressedKeys) {\\n        //dp   \\n        int len = pressedKeys.length(); \\n        vector<int> dp(len, 0);\\n        dp[len-1] = 1; \\n        for(int i = len-2; i >=0; i--)\\n            dpf(pressedKeys, i, dp); \\n        return dp[0]; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3173333,
                "title": "bottom-up-dp-python-o-n-image-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWith each new press is a potential double, triple, quad grouping (aka potential letter) that could be appended. \\n\\nLook back at the previous DP solution ***before that grouping (or letter) was considered*** and add to current DP[i].\\n![image.png](https://assets.leetcode.com/users/images/a8eb9f79-7d9e-4f10-88f4-be58d63eb63f_1676143680.0307488.png)\\n\\nie. \\n   7777\\n\\n   When adding that i=3 char 7, we open the possibility to append the following (4) letters to the path:\\n   - Adding P (+7) to series: DP[i-1] \\n   - Adding Q (+77) to series: DP[i-2]\\n   - Adding R (+777) to series: DP[i-3]\\n   - Adding S (+7777) to series: DP[i-4]\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBuilding up the solution (tabulation), we\\'ll consider any potential letters formed when adding the latest button press.\\n\\nThe subproblem we\\'ll choose is this:\\n\\n> DP[i] = number of pathways up to AND including the i-th button press\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) - run through array once\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) - storing DP state \\n# Code\\n```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n\\n\\n        s = pressedKeys\\n\\n        n = len(pressedKeys)\\n        \\n        DP = [0] * (n+1)\\n        if n ==1 :\\n            return 1\\n\\n        DP[0] = 1\\n        offset = 1 # offset b/c DP[i] refers to s[i-1]\\n        for i in range(1,len(DP)):\\n            # single unique character press\\n            DP[i] = DP[i-1]\\n                    \\n            # char double press\\n            if s[i-offset] == s[i-offset-1]:\\n                DP[i] += DP[i-2]\\n                DP[i] = (DP[i] % (10**9 + 7))\\n            # triple press\\n            if i> 2 and s[i-offset]== s[i-offset-1] and s[i-offset-1] == s[i-offset-2]:\\n                DP[i] += DP[i-3]\\n                DP[i] = (DP[i] % (10**9 + 7))\\n            # quad press of the button\\n            if i>3 and (s[i-offset] == \"7\" or s[i-offset]==\"9\") and s[i-offset]== s[i-offset-1] and s[i-offset-1] == s[i-offset-2] and s[i-offset-2] == s[i-offset-3]:\\n                DP[i] += DP[i-4] \\n                DP[i] = (DP[i] % (10**9 + 7))\\n\\n        print(DP)\\n\\n        return DP[n] % (10**9 + 7)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n\\n\\n        s = pressedKeys\\n\\n        n = len(pressedKeys)\\n        \\n        DP = [0] * (n+1)\\n        if n ==1 :\\n            return 1\\n\\n        DP[0] = 1\\n        offset = 1 # offset b/c DP[i] refers to s[i-1]\\n        for i in range(1,len(DP)):\\n            # single unique character press\\n            DP[i] = DP[i-1]\\n                    \\n            # char double press\\n            if s[i-offset] == s[i-offset-1]:\\n                DP[i] += DP[i-2]\\n                DP[i] = (DP[i] % (10**9 + 7))\\n            # triple press\\n            if i> 2 and s[i-offset]== s[i-offset-1] and s[i-offset-1] == s[i-offset-2]:\\n                DP[i] += DP[i-3]\\n                DP[i] = (DP[i] % (10**9 + 7))\\n            # quad press of the button\\n            if i>3 and (s[i-offset] == \"7\" or s[i-offset]==\"9\") and s[i-offset]== s[i-offset-1] and s[i-offset-1] == s[i-offset-2] and s[i-offset-2] == s[i-offset-3]:\\n                DP[i] += DP[i-4] \\n                DP[i] = (DP[i] % (10**9 + 7))\\n\\n        print(DP)\\n\\n        return DP[n] % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141053,
                "title": "tribonacci-and-quad-fibonacci-python-solution",
                "content": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        res = 1\\n        \\n        @cache\\n        def dp3(i):\\n            prev_1, prev_2, curr = 0, 0, 1\\n            \\n            for _ in range(i):\\n                prev_1, prev_2, curr = prev_2, curr, curr+prev_1+prev_2\\n                \\n            return curr\\n        \\n        @cache\\n        def dp4(i):\\n            prev_1, prev_2, prev_3, curr = 0, 0, 0, 1\\n            \\n            for _ in range(i):\\n                prev_1, prev_2, prev_3, curr = prev_2, prev_3, curr, prev_1 + prev_2 + prev_3 + curr\\n                \\n            return curr\\n                \\n        for k,v in groupby(pressedKeys):\\n            if k == \\'7\\' or k == \\'9\\': \\n                res *= dp4(sum(1 for _ in v))\\n            else:\\n                res *= dp3(sum(1 for _ in v))\\n            \\n        return res%(1000000007)        \\n ```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        res = 1\\n        \\n        @cache\\n        def dp3(i):\\n            prev_1, prev_2, curr = 0, 0, 1\\n            \\n            for _ in range(i):\\n                prev_1, prev_2, curr = prev_2, curr, curr+prev_1+prev_2\\n                \\n            return curr\\n        \\n        @cache\\n        def dp4(i):\\n            prev_1, prev_2, prev_3, curr = 0, 0, 0, 1\\n            \\n            for _ in range(i):\\n                prev_1, prev_2, prev_3, curr = prev_2, prev_3, curr, prev_1 + prev_2 + prev_3 + curr\\n                \\n            return curr\\n                \\n        for k,v in groupby(pressedKeys):\\n            if k == \\'7\\' or k == \\'9\\': \\n                res *= dp4(sum(1 for _ in v))\\n            else:\\n                res *= dp3(sum(1 for _ in v))\\n            \\n        return res%(1000000007)        \\n ```",
                "codeTag": "Java"
            },
            {
                "id": 3130372,
                "title": "based-on-climbing-stairs-dp-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n   long  climbingStairs3(int n){\\n       if(n == 0) return 0;\\n       if(n == 1) return 1;\\n       if(n == 2) return 2;\\n       if(n == 3) return 4;\\n       long  dp[n];\\n       dp[0] = 1;\\n       dp[1] = 2;\\n       dp[2] = 4;\\n       for(int i=3; i<n; i++){\\n           dp[i] = (dp[i-1] % 1000000007) + (dp[i-2] % 1000000007) + (dp[i-3] % 1000000007);\\n       }\\n       return dp[n-1] % 1000000007;\\n   }\\n   long  climbingStairs4(int n){\\n       if(n==0) return 0;\\n       if(n == 1) return 1;\\n       if(n == 2) return 2;\\n       if(n == 3) return 4;\\n       if(n == 4) return 8;\\n       long  dp[n];\\n       dp[0] = 1;\\n       dp[1] = 2;\\n       dp[2] = 4;\\n       dp[3] = 8;\\n       for(int i=4; i<n; i++){\\n           dp[i] = (dp[i-1] % 1000000007)  + (dp[i-2] % 1000000007) + (dp[i-3] % 1000000007) + (dp[i-4] % 1000000007 );\\n       }\\n       return dp[n-1] % 1000000007;\\n   }\\n    int countTexts(string pressedKeys) {\\n        if(pressedKeys.size() == 0) return 0;\\n        if(pressedKeys.size() == 1) return 1;\\n        unordered_map<char, vector<int>> m;\\n        int counter = 0;\\n        int prev = pressedKeys[0];\\n        for(int i=0; i<pressedKeys.size(); i++){\\n            while(pressedKeys[i] == prev){\\n                counter++;\\n                i++;\\n            }\\n            m[prev].push_back(counter);\\n            prev = pressedKeys[i];\\n            counter = 0;\\n            i--;\\n        }\\n        \\n        long  ans = 1;\\n\\n        for(int i=0; i<pressedKeys.size(); i++){\\n            if(m[pressedKeys[i]].size() > 0){\\n                for(int j=0; j<m[pressedKeys[i]].size(); j++){\\n                if(pressedKeys[i] == \\'9\\' || pressedKeys[i] == \\'7\\')\\n                ans = ans*climbingStairs4(m[pressedKeys[i]][j]);\\n                else\\n                 ans = ans*climbingStairs3(m[pressedKeys[i]][j]);\\n                 ans = ans%1000000007;\\n            }\\n                \\n                m.erase(pressedKeys[i]);\\n            }\\n        }\\n        /*for(int i=0; i<pressedKeys.size(); i++){\\n            if(map[pressedKeys[i]] > 0){\\n                if(pressedKeys[i] == \\'9\\' || pressedKeys[i] == \\'7\\')\\n                ans = ans*climbingStairs4(map[pressedKeys[i]]);\\n                else\\n                 ans = ans*climbingStairs3(map[pressedKeys[i]]);\\n                ans = ans%1000000007;\\n                map[pressedKeys[i]] = 0;\\n            }\\n        }*/\\n        return ans % 1000000007;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n   long  climbingStairs3(int n){\\n       if(n == 0) return 0;\\n       if(n == 1) return 1;\\n       if(n == 2) return 2;\\n       if(n == 3) return 4;\\n       long  dp[n];\\n       dp[0] = 1;\\n       dp[1] = 2;\\n       dp[2] = 4;\\n       for(int i=3; i<n; i++){\\n           dp[i] = (dp[i-1] % 1000000007) + (dp[i-2] % 1000000007) + (dp[i-3] % 1000000007);\\n       }\\n       return dp[n-1] % 1000000007;\\n   }\\n   long  climbingStairs4(int n){\\n       if(n==0) return 0;\\n       if(n == 1) return 1;\\n       if(n == 2) return 2;\\n       if(n == 3) return 4;\\n       if(n == 4) return 8;\\n       long  dp[n];\\n       dp[0] = 1;\\n       dp[1] = 2;\\n       dp[2] = 4;\\n       dp[3] = 8;\\n       for(int i=4; i<n; i++){\\n           dp[i] = (dp[i-1] % 1000000007)  + (dp[i-2] % 1000000007) + (dp[i-3] % 1000000007) + (dp[i-4] % 1000000007 );\\n       }\\n       return dp[n-1] % 1000000007;\\n   }\\n    int countTexts(string pressedKeys) {\\n        if(pressedKeys.size() == 0) return 0;\\n        if(pressedKeys.size() == 1) return 1;\\n        unordered_map<char, vector<int>> m;\\n        int counter = 0;\\n        int prev = pressedKeys[0];\\n        for(int i=0; i<pressedKeys.size(); i++){\\n            while(pressedKeys[i] == prev){\\n                counter++;\\n                i++;\\n            }\\n            m[prev].push_back(counter);\\n            prev = pressedKeys[i];\\n            counter = 0;\\n            i--;\\n        }\\n        \\n        long  ans = 1;\\n\\n        for(int i=0; i<pressedKeys.size(); i++){\\n            if(m[pressedKeys[i]].size() > 0){\\n                for(int j=0; j<m[pressedKeys[i]].size(); j++){\\n                if(pressedKeys[i] == \\'9\\' || pressedKeys[i] == \\'7\\')\\n                ans = ans*climbingStairs4(m[pressedKeys[i]][j]);\\n                else\\n                 ans = ans*climbingStairs3(m[pressedKeys[i]][j]);\\n                 ans = ans%1000000007;\\n            }\\n                \\n                m.erase(pressedKeys[i]);\\n            }\\n        }\\n        /*for(int i=0; i<pressedKeys.size(); i++){\\n            if(map[pressedKeys[i]] > 0){\\n                if(pressedKeys[i] == \\'9\\' || pressedKeys[i] == \\'7\\')\\n                ans = ans*climbingStairs4(map[pressedKeys[i]]);\\n                else\\n                 ans = ans*climbingStairs3(map[pressedKeys[i]]);\\n                ans = ans%1000000007;\\n                map[pressedKeys[i]] = 0;\\n            }\\n        }*/\\n        return ans % 1000000007;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3126727,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countTexts(string pressedKeys) {\\n        int n=pressedKeys.size();\\n        int mod=1e9+7;\\n        vector<int>dp(n+1);\\n        dp[0]=1;\\n        for (int i=1;i<=n;i++)\\n        {\\n            char ch=pressedKeys[i-1];\\n            dp[i]=dp[i-1];\\n            if (i>=2 && pressedKeys[i-2]==ch)\\n            dp[i]=(dp[i-2]+dp[i])%mod;\\n            else continue;\\n            if (i>=3 && pressedKeys[i-3]==ch)\\n            dp[i]=(dp[i]+dp[i-3])%mod;\\n            else continue;\\n            if (ch==\\'7\\' || ch==\\'9\\')\\n            {\\n                if (i>=4 && ch==pressedKeys[i-4]) dp[i]=(dp[i]+dp[i-4])%mod;\\n            }\\n        }\\n        return (dp[n])%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countTexts(string pressedKeys) {\\n        int n=pressedKeys.size();\\n        int mod=1e9+7;\\n        vector<int>dp(n+1);\\n        dp[0]=1;\\n        for (int i=1;i<=n;i++)\\n        {\\n            char ch=pressedKeys[i-1];\\n            dp[i]=dp[i-1];\\n            if (i>=2 && pressedKeys[i-2]==ch)\\n            dp[i]=(dp[i-2]+dp[i])%mod;\\n            else continue;\\n            if (i>=3 && pressedKeys[i-3]==ch)\\n            dp[i]=(dp[i]+dp[i-3])%mod;\\n            else continue;\\n            if (ch==\\'7\\' || ch==\\'9\\')\\n            {\\n                if (i>=4 && ch==pressedKeys[i-4]) dp[i]=(dp[i]+dp[i-4])%mod;\\n            }\\n        }\\n        return (dp[n])%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056386,
                "title": "python-dynamic-programming",
                "content": "\\tclass Solution(object):\\n\\t\\tdef countTexts(self, pressedKeys):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type pressedKeys: str\\n\\t\\t\\t:rtype: int\\n\\t\\t\\t\"\"\"\\n\\n\\t\\t\\tL = len(pressedKeys)\\n\\n\\t\\t\\ti, j = 0, 0\\n\\t\\t\\tCount = []\\n\\t\\t\\tMax_len = 0\\n\\t\\t\\twhile j < L and i < L:\\n\\t\\t\\t\\twhile j < L and pressedKeys[i] == pressedKeys[j]:\\n\\t\\t\\t\\t\\tj += 1\\n\\t\\t\\t\\tCount.append( [pressedKeys[i],j-i])\\n\\t\\t\\t\\tMax_len = max(Max_len, j-i)\\n\\t\\t\\t\\ti = j\\n\\n\\t\\t\\tN = Max_len\\n\\t\\t\\tf = [1 for i in range(N+1)]\\n\\t\\t\\tg = [1 for i in range(N+1)]\\n\\n\\t\\t\\tif N >=2: \\n\\t\\t\\t\\tf[2], g[2] = 2, 2 \\n\\t\\t\\tif N >= 3:\\n\\t\\t\\t\\tg[3] = 4\\n\\n\\t\\t\\tfor i in range(3, N+1):\\n\\t\\t\\t\\tf[i] =  (f[i-1] + f[i-2] + f[i-3])% (10**9 + 7)\\n\\n\\t\\t\\tfor i in range(4, N+1):\\n\\t\\t\\t\\tg[i] =  (g[i-1] + g[i-2] + g[i-3] + g[i-4]) % (10**9 + 7) \\n\\n\\n\\t\\t\\tres = 1\\n\\t\\t\\tfor x in Count:\\n\\t\\t\\t\\tif int(x[0]) == 7 or int(x[0]) == 9:\\n\\t\\t\\t\\t\\tres *= g[x[1]]\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tres *= f[x[1]]\\n\\n\\t\\t\\treturn res % (10**9 + 7)\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "\\tclass Solution(object):\\n\\t\\tdef countTexts(self, pressedKeys):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type pressedKeys: str\\n\\t\\t\\t:rtype: int\\n\\t\\t\\t\"\"\"\\n\\n\\t\\t\\tL = len(pressedKeys)\\n\\n\\t\\t\\ti, j = 0, 0\\n\\t\\t\\tCount = []\\n\\t\\t\\tMax_len = 0\\n\\t\\t\\twhile j < L and i < L:\\n\\t\\t\\t\\twhile j < L and pressedKeys[i] == pressedKeys[j]:\\n\\t\\t\\t\\t\\tj += 1\\n\\t\\t\\t\\tCount.append( [pressedKeys[i],j-i])\\n\\t\\t\\t\\tMax_len = max(Max_len, j-i)\\n\\t\\t\\t\\ti = j\\n\\n\\t\\t\\tN = Max_len\\n\\t\\t\\tf = [1 for i in range(N+1)]\\n\\t\\t\\tg = [1 for i in range(N+1)]\\n\\n\\t\\t\\tif N >=2: \\n\\t\\t\\t\\tf[2], g[2] = 2, 2 \\n\\t\\t\\tif N >= 3:\\n\\t\\t\\t\\tg[3] = 4\\n\\n\\t\\t\\tfor i in range(3, N+1):\\n\\t\\t\\t\\tf[i] =  (f[i-1] + f[i-2] + f[i-3])% (10**9 + 7)\\n\\n\\t\\t\\tfor i in range(4, N+1):\\n\\t\\t\\t\\tg[i] =  (g[i-1] + g[i-2] + g[i-3] + g[i-4]) % (10**9 + 7) \\n\\n\\n\\t\\t\\tres = 1\\n\\t\\t\\tfor x in Count:\\n\\t\\t\\t\\tif int(x[0]) == 7 or int(x[0]) == 9:\\n\\t\\t\\t\\t\\tres *= g[x[1]]\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tres *= f[x[1]]\\n\\n\\t\\t\\treturn res % (10**9 + 7)\\n",
                "codeTag": "Java"
            },
            {
                "id": 3054007,
                "title": "c",
                "content": "```\\nint countTexts(char * pressedKeys){\\n    int mod = 1e9 + 7 ;\\n    int n = strlen(pressedKeys) ;\\n    long long * dp = malloc((n+1) * sizeof(long long)) ;\\n    dp[n] = 1;\\n    bool* hash = calloc(100000, sizeof(bool)) ;\\n    int trip[] = {2, 3, 4, 5, 6, 8};\\n    int four[] = {7, 9} ;\\n    for(int i = 0; i < 6; i++){\\n        int d = trip[i] ;\\n        int val = 0;\\n        for(int j = 0; j < 3; j++){\\n            val = val * 10 + d;\\n            hash[val] = true ;\\n        }\\n    }\\n    \\n    for(int i = 0; i < 2; i++){\\n        int d = four[i] ;\\n        int val = 0;\\n        for(int j = 0; j < 4; j++){\\n            val = val * 10 + d;\\n            hash[val] = true ;\\n        }\\n    }\\n\\n    dp[n] = 1;\\n    dp[n-1] = 1;\\n    pressedKeys[n] = \\'0\\' ;\\n    for(int i = n-2 ; i >= 0 ; i--){\\n        int val = pressedKeys[i] - \\'0\\' ;\\n        dp[i] = 0;\\n        int k = 1 ;\\n        while( hash[val] ){\\n            dp[i] = (dp[i] + dp[i+k]) % mod;\\n            val = val* 10 + pressedKeys[i+k] - \\'0\\' ;\\n            k++;  \\n        }\\n    }\\n    pressedKeys[n] = \\'\\\\0\\' ;  //rollback\\n    int ans =  dp[0];\\n    free(hash) ;\\n    free(dp) ;\\n    return ans;\\n }\\n```",
                "solutionTags": [],
                "code": "```\\nint countTexts(char * pressedKeys){\\n    int mod = 1e9 + 7 ;\\n    int n = strlen(pressedKeys) ;\\n    long long * dp = malloc((n+1) * sizeof(long long)) ;\\n    dp[n] = 1;\\n    bool* hash = calloc(100000, sizeof(bool)) ;\\n    int trip[] = {2, 3, 4, 5, 6, 8};\\n    int four[] = {7, 9} ;\\n    for(int i = 0; i < 6; i++){\\n        int d = trip[i] ;\\n        int val = 0;\\n        for(int j = 0; j < 3; j++){\\n            val = val * 10 + d;\\n            hash[val] = true ;\\n        }\\n    }\\n    \\n    for(int i = 0; i < 2; i++){\\n        int d = four[i] ;\\n        int val = 0;\\n        for(int j = 0; j < 4; j++){\\n            val = val * 10 + d;\\n            hash[val] = true ;\\n        }\\n    }\\n\\n    dp[n] = 1;\\n    dp[n-1] = 1;\\n    pressedKeys[n] = \\'0\\' ;\\n    for(int i = n-2 ; i >= 0 ; i--){\\n        int val = pressedKeys[i] - \\'0\\' ;\\n        dp[i] = 0;\\n        int k = 1 ;\\n        while( hash[val] ){\\n            dp[i] = (dp[i] + dp[i+k]) % mod;\\n            val = val* 10 + pressedKeys[i+k] - \\'0\\' ;\\n            k++;  \\n        }\\n    }\\n    pressedKeys[n] = \\'\\\\0\\' ;  //rollback\\n    int ans =  dp[0];\\n    free(hash) ;\\n    free(dp) ;\\n    return ans;\\n }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2974724,
                "title": "python3-java-top-down-dp",
                "content": "Intuition is we can combine upto limit character together where limit is 4 for digit -> (7,9) and 3 for other digits and check for each combination , if string is 222, then you possible combination will be \\n(2,2,2) -> a,a,a\\n(2,22)  -> a,b\\n(22,2)  -> b,a\\n(222)  ->  c\\n```\\nPython3\\n\\nclass Solution:\\n    def countTexts(self, A: str) -> int:\\n        mod = 1_00_00_00_007\\n        n = len(A)\\n        dp = [-1 for i in range(n)]\\n        def dfs(ind):\\n            if ind == n:\\n                return 1\\n            if dp[ind] != -1:\\n                return dp[ind]\\n            limit = 4 if A[ind] == \\'7\\' or A[ind] == \\'9\\' else 3\\n            val = 0\\n            for i in range(1,limit + 1):\\n                if ind + i <= n and A[ind + i - 1] == A[ind]:\\n                    val = val % mod + dfs(ind + i) % mod\\n                else:\\n                    break\\n            dp[ind] = val\\n            return dp[ind]\\n        return dfs(0) % mod\\n```\\n```\\nJava\\n\\nclass Solution {\\n    int dfs(int ind,int n,int[] dp,char[] A,int mod){\\n        if (ind == n){\\n            return 1;\\n        }\\n        if(dp[ind] != -1){\\n            return dp[ind];\\n        }\\n        int limit = A[ind] == \\'7\\' || A[ind] ==\\'9\\' ? 4 : 3;\\n        int val = 0;\\n        for(int i = 1 ; i <= limit ; i++){\\n            if(ind + i <= n && A[ind + i - 1] == A[ind]){\\n                val = val % mod + dfs(ind + i,n,dp,A,mod) % mod;\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        return dp[ind] = val;\\n    }\\n    public int countTexts(String A) {\\n        char[] arr = A.toCharArray();\\n        int n = arr.length;\\n        int[] dp = new int[n];\\n        Arrays.fill(dp,-1);\\n        int mod = 1_00_00_00_007;\\n        return dfs(0,n,dp,arr,mod) % mod;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nPython3\\n\\nclass Solution:\\n    def countTexts(self, A: str) -> int:\\n        mod = 1_00_00_00_007\\n        n = len(A)\\n        dp = [-1 for i in range(n)]\\n        def dfs(ind):\\n            if ind == n:\\n                return 1\\n            if dp[ind] != -1:\\n                return dp[ind]\\n            limit = 4 if A[ind] == \\'7\\' or A[ind] == \\'9\\' else 3\\n            val = 0\\n            for i in range(1,limit + 1):\\n                if ind + i <= n and A[ind + i - 1] == A[ind]:\\n                    val = val % mod + dfs(ind + i) % mod\\n                else:\\n                    break\\n            dp[ind] = val\\n            return dp[ind]\\n        return dfs(0) % mod\\n```\n```\\nJava\\n\\nclass Solution {\\n    int dfs(int ind,int n,int[] dp,char[] A,int mod){\\n        if (ind == n){\\n            return 1;\\n        }\\n        if(dp[ind] != -1){\\n            return dp[ind];\\n        }\\n        int limit = A[ind] == \\'7\\' || A[ind] ==\\'9\\' ? 4 : 3;\\n        int val = 0;\\n        for(int i = 1 ; i <= limit ; i++){\\n            if(ind + i <= n && A[ind + i - 1] == A[ind]){\\n                val = val % mod + dfs(ind + i,n,dp,A,mod) % mod;\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        return dp[ind] = val;\\n    }\\n    public int countTexts(String A) {\\n        char[] arr = A.toCharArray();\\n        int n = arr.length;\\n        int[] dp = new int[n];\\n        Arrays.fill(dp,-1);\\n        int mod = 1_00_00_00_007;\\n        return dfs(0,n,dp,arr,mod) % mod;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2912092,
                "title": "java-dynamic-programming-top-down-dp-recursion-memization-faster",
                "content": "```\\nclass Solution {\\n\\n    int MOD = 1000000007;\\n    String key;\\n    Integer[] dp;\\n    int[] count;\\n\\t\\n    private int solve(int i) {\\n\\t\\n        if(i >= key.length())\\n            return 1;\\n        \\n        if(dp[i] != null) \\n            return dp[i];\\n       \\n        char first = key.charAt(i);\\n        int res = 0, cnt = 1, mxCnt = count[first - \\'0\\'], j = i;\\n        \\n        while(i < key.length() && key.charAt(i) == first && cnt <= mxCnt) {\\n            res = (((res%MOD) + (solve(i+1)%MOD)) % MOD);\\n            i++; cnt++;\\n        }\\n\\t\\t\\n        return dp[j] = res;\\n    }\\n\\t\\n    public int countTexts(String pressedKeys) {\\n\\t\\n        this.key = pressedKeys;\\n        this.count = new int[]{0,0,3,3,3,3,3,4,3,4};\\n        this.dp = new Integer[pressedKeys.length()+1];\\n        return solve(0);\\n\\t\\t\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n\\n    int MOD = 1000000007;\\n    String key;\\n    Integer[] dp;\\n    int[] count;\\n\\t\\n    private int solve(int i) {\\n\\t\\n        if(i >= key.length())\\n            return 1;\\n        \\n        if(dp[i] != null) \\n            return dp[i];\\n       \\n        char first = key.charAt(i);\\n        int res = 0, cnt = 1, mxCnt = count[first - \\'0\\'], j = i;\\n        \\n        while(i < key.length() && key.charAt(i) == first && cnt <= mxCnt) {\\n            res = (((res%MOD) + (solve(i+1)%MOD)) % MOD);\\n            i++; cnt++;\\n        }\\n\\t\\t\\n        return dp[j] = res;\\n    }\\n\\t\\n    public int countTexts(String pressedKeys) {\\n\\t\\n        this.key = pressedKeys;\\n        this.count = new int[]{0,0,3,3,3,3,3,4,3,4};\\n        this.dp = new Integer[pressedKeys.length()+1];\\n        return solve(0);\\n\\t\\t\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2877811,
                "title": "easy-and-clean-2-approaches-from-recursion-to-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int mod = (int)(Math.pow(10,9)+7);\\n    public int countTexts(String pressedKeys) {\\n        //Way 1 Recursion\\n        int [] dp = new int[pressedKeys.length()];\\n        Arrays.fill(dp, -1);\\n        return GetCT(pressedKeys, 0, dp);\\n        //Way 2\\n        int [] dp = new int[pressedKeys.length()+1];\\n        dp[0] = 1;\\n        for(int i = 1; i <= pressedKeys.length();i++)\\n        {\\n            dp[i] = dp[i-1] % mod;\\n            if(i > 1 && pressedKeys.charAt(i-1) == pressedKeys.charAt(i-2))\\n            {\\n                dp[i] = (dp[i] + dp[i-2] % mod)%mod;\\n                if(i > 2 && pressedKeys.charAt(i-1) == pressedKeys.charAt(i-3))\\n                {\\n                    dp[i] = (dp[i] + dp[i-3] % mod)%mod;\\n                    if(i > 3  && (pressedKeys.charAt(i-1) == \\'7\\' \\n                     || pressedKeys.charAt(i-1) == \\'9\\') \\n                    && pressedKeys.charAt(i-1) == pressedKeys.charAt(i-4))\\n                        dp[i] = (dp[i] + dp[i-4] % mod)%mod;\\n                }\\n            }\\n        }\\n        return dp[pressedKeys.length()];\\n    }\\n\\n    public int GetCT(String s, int idx, int [] dp)\\n    {\\n        if(idx == s.length())\\n        return 1;\\n\\n        if(dp[idx] != -1)\\n        return dp[idx];\\n\\n        int maxPKeys = (s.charAt(idx) == \\'7\\' || s.charAt(idx) == \\'9\\') ? 4 : 3;\\n        int ans = 0;\\n        int pressedKey = 1;\\n        int curIdx = idx;\\n        while(curIdx < s.length() && pressedKey <= maxPKeys && \\n        s.charAt(curIdx) == s.charAt(idx))\\n        {\\n            curIdx++;\\n            pressedKey++;\\n            ans = (ans + GetCT(s, curIdx, dp)%mod)%mod;\\n        }\\n        return dp[idx] = ans%mod;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int mod = (int)(Math.pow(10,9)+7);\\n    public int countTexts(String pressedKeys) {\\n        //Way 1 Recursion\\n        int [] dp = new int[pressedKeys.length()];\\n        Arrays.fill(dp, -1);\\n        return GetCT(pressedKeys, 0, dp);\\n        //Way 2\\n        int [] dp = new int[pressedKeys.length()+1];\\n        dp[0] = 1;\\n        for(int i = 1; i <= pressedKeys.length();i++)\\n        {\\n            dp[i] = dp[i-1] % mod;\\n            if(i > 1 && pressedKeys.charAt(i-1) == pressedKeys.charAt(i-2))\\n            {\\n                dp[i] = (dp[i] + dp[i-2] % mod)%mod;\\n                if(i > 2 && pressedKeys.charAt(i-1) == pressedKeys.charAt(i-3))\\n                {\\n                    dp[i] = (dp[i] + dp[i-3] % mod)%mod;\\n                    if(i > 3  && (pressedKeys.charAt(i-1) == \\'7\\' \\n                     || pressedKeys.charAt(i-1) == \\'9\\') \\n                    && pressedKeys.charAt(i-1) == pressedKeys.charAt(i-4))\\n                        dp[i] = (dp[i] + dp[i-4] % mod)%mod;\\n                }\\n            }\\n        }\\n        return dp[pressedKeys.length()];\\n    }\\n\\n    public int GetCT(String s, int idx, int [] dp)\\n    {\\n        if(idx == s.length())\\n        return 1;\\n\\n        if(dp[idx] != -1)\\n        return dp[idx];\\n\\n        int maxPKeys = (s.charAt(idx) == \\'7\\' || s.charAt(idx) == \\'9\\') ? 4 : 3;\\n        int ans = 0;\\n        int pressedKey = 1;\\n        int curIdx = idx;\\n        while(curIdx < s.length() && pressedKey <= maxPKeys && \\n        s.charAt(curIdx) == s.charAt(idx))\\n        {\\n            curIdx++;\\n            pressedKey++;\\n            ans = (ans + GetCT(s, curIdx, dp)%mod)%mod;\\n        }\\n        return dp[idx] = ans%mod;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2877317,
                "title": "easy-python-recursion-memoization-top-down-approach",
                "content": "**leetcode 2266 : Count Number of Texts\\nEasy Understanding\\nDp Recursion with Memoization\\nTop down Approach**\\n```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        dic = {\\n            \\'2\\': \\'abc\\',\\n            \\'3\\': \\'def\\',\\n            \\'4\\': \\'gfi\\',\\n            \\'5\\': \\'jkl\\',\\n            \\'6\\': \\'mno\\',\\n            \\'7\\': \\'pqrs\\',\\n            \\'8\\': \\'tuv\\',\\n            \\'9\\': \\'wxyz\\',\\n        }\\n        s = pressedKeys\\n        mod = (10**9)+7\\n        \\n        def f(i):\\n            if i == len(s):\\n                return 1\\n            ## optimization \\n            ## if i already found in dp \\n            ## then return dp[i] \\n            if i in dp:\\n                return dp[i]\\n            total = 0\\n            ## current index in s is i \\n            ## so current digit is s[i]\\n            ## letters of that digit is dic[s[i]]\\n\\n            for j in range(len(dic[s[i]])):\\n                k = i + j + 1\\n                ## k is the position where next iteration will be called\\n                ## k must be next position of i, k==i+1\\n                if k > len(s) or s[k-1] != s[i] :\\n                    break\\n                ## optimization \\n                if k in dp:\\n                    total += dp[k]\\n                else:\\n                    total += f(k)\\n            ## keep a copy of the result of i in dp\\n            dp[i] = total % mod\\n            return dp[i]\\n        dp = {}\\n        return f(0)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        dic = {\\n            \\'2\\': \\'abc\\',\\n            \\'3\\': \\'def\\',\\n            \\'4\\': \\'gfi\\',\\n            \\'5\\': \\'jkl\\',\\n            \\'6\\': \\'mno\\',\\n            \\'7\\': \\'pqrs\\',\\n            \\'8\\': \\'tuv\\',\\n            \\'9\\': \\'wxyz\\',\\n        }\\n        s = pressedKeys\\n        mod = (10**9)+7\\n        \\n        def f(i):\\n            if i == len(s):\\n                return 1\\n            ## optimization \\n            ## if i already found in dp \\n            ## then return dp[i] \\n            if i in dp:\\n                return dp[i]\\n            total = 0\\n            ## current index in s is i \\n            ## so current digit is s[i]\\n            ## letters of that digit is dic[s[i]]\\n\\n            for j in range(len(dic[s[i]])):\\n                k = i + j + 1\\n                ## k is the position where next iteration will be called\\n                ## k must be next position of i, k==i+1\\n                if k > len(s) or s[k-1] != s[i] :\\n                    break\\n                ## optimization \\n                if k in dp:\\n                    total += dp[k]\\n                else:\\n                    total += f(k)\\n            ## keep a copy of the result of i in dp\\n            dp[i] = total % mod\\n            return dp[i]\\n        dp = {}\\n        return f(0)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2869579,
                "title": "c-dp-memoization-recursion-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    int mod=1e9+7;\\n    long solve(string &s,int idx)\\n    {\\n        if(idx>=s.size())\\n            return 1;\\n        if(dp[idx]!=-1)\\n            return dp[idx];\\n        int maxpress=(s[idx]==\\'7\\'||s[idx]==\\'9\\')?4:3;\\n        int curr_idx=idx,press=1;\\n        long ans=0;\\n        while(press<=maxpress&&s[curr_idx]==s[idx])\\n        {\\n            press++;\\n            curr_idx++;\\n            ans+=(solve(s,curr_idx))%mod;\\n        }\\n        return dp[idx]=ans%mod;\\n    }\\n    int countTexts(string pressedKeys) \\n    {\\n        int n=pressedKeys.size();\\n        dp.resize(n+1,-1);\\n        return solve(pressedKeys,0);\\n        \\n        \\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> dp;\\n    int mod=1e9+7;\\n    long solve(string &s,int idx)\\n    {\\n        if(idx>=s.size())\\n            return 1;\\n        if(dp[idx]!=-1)\\n            return dp[idx];\\n        int maxpress=(s[idx]==\\'7\\'||s[idx]==\\'9\\')?4:3;\\n        int curr_idx=idx,press=1;\\n        long ans=0;\\n        while(press<=maxpress&&s[curr_idx]==s[idx])\\n        {\\n            press++;\\n            curr_idx++;\\n            ans+=(solve(s,curr_idx))%mod;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2841733,
                "title": "python3-dp",
                "content": "class Solution:\\n\\n    def countTexts(self, pressedKeys: str) -> int:\\n        N = len(pressedKeys) + 1\\n        MOD = 10**9+7\\n        dp = [0]*N\\n        dp[0] = 1\\n    \\n        for i in range(1,N):\\n            currChar = pressedKeys[i-1]\\n            dp[i] = dp[i-1]\\n            if i>=2 and currChar ==  pressedKeys[i-2]:\\n                dp[i] = (dp[i]+dp[i-2])%MOD\\n            else:\\n                continue\\n            if i>=3 and currChar ==  pressedKeys[i-3]:\\n                dp[i] = (dp[i]+dp[i-3])%MOD\\n            else:\\n                continue\\n            \\n            if i>=4 and currChar in \"79\" and currChar ==  pressedKeys[i-4]:\\n                dp[i] = (dp[i]+dp[i-4])%MOD\\n                \\n        return dp[-1]",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def countTexts(self, pressedKeys: str) -> int:\\n        N = len(pressedKeys) + 1\\n        MOD = 10**9+7\\n        dp = [0]*N\\n        dp[0] = 1\\n    \\n        for i in range(1,N):\\n            currChar = pressedKeys[i-1]\\n            dp[i] = dp[i-1]\\n            if i>=2 and currChar ==  pressedKeys[i-2]:\\n                dp[i] = (dp[i]+dp[i-2])%MOD\\n            else:\\n                continue\\n            if i>=3 and currChar ==  pressedKeys[i-3]:\\n                dp[i] = (dp[i]+dp[i-3])%MOD\\n            else:\\n                continue\\n            \\n            if i>=4 and currChar in \"79\" and currChar ==  pressedKeys[i-4]:\\n                dp[i] = (dp[i]+dp[i-4])%MOD\\n                \\n        return dp[-1]",
                "codeTag": "Java"
            },
            {
                "id": 2840945,
                "title": "python-cached-recursive-dp-approach",
                "content": "```python\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        \\n        # dp(n, lmt): possibilities pressing a number of lmt charaters n times\\n        @cache\\n        def dp(n, lmt):\\n            if n == 0:\\n                return 1\\n            ans = 0\\n            for i in range(max(0, n - lmt), n):\\n                ans += dp(i, lmt)\\n            return ans % int(1e9 + 7)\\n        \\n        i, j = 0, 0\\n        s = pressedKeys + \"-\"\\n        ans = 1\\n        while j < len(s) - 1:\\n            j += 1\\n            if s[j] != s[i]:\\n                ans *= dp(j - i, 4 if s[i] == \\'7\\' or s[i] == \\'9\\' else 3)\\n                ans %= int(1e9 + 7)\\n                i = j\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```python\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        \\n        # dp(n, lmt): possibilities pressing a number of lmt charaters n times\\n        @cache\\n        def dp(n, lmt):\\n            if n == 0:\\n                return 1\\n            ans = 0\\n            for i in range(max(0, n - lmt), n):\\n                ans += dp(i, lmt)\\n            return ans % int(1e9 + 7)\\n        \\n        i, j = 0, 0\\n        s = pressedKeys + \"-\"\\n        ans = 1\\n        while j < len(s) - 1:\\n            j += 1\\n            if s[j] != s[i]:\\n                ans *= dp(j - i, 4 if s[i] == \\'7\\' or s[i] == \\'9\\' else 3)\\n                ans %= int(1e9 + 7)\\n                i = j\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831929,
                "title": "java-top-down-dp-memoization",
                "content": "class Solution {\\n\\n    int res=0;\\n    int mod = 1000000007;\\n    Map<Integer,Integer> mp=new HashMap<Integer,Integer>();\\n    Map<Integer,Integer> cache=new HashMap<Integer,Integer>();\\n    \\n    public int recur(String keys,int index){\\n        if(index==keys.length()){\\n            return 1;\\n        }\\n        if(cache.containsKey(index)){\\n            return cache.get(index);\\n        }\\n        char x = keys.charAt(index);\\n        int mappingSize = mp.get(x-\\'0\\');\\n        int i=index;\\n        int sum=0;\\n        while(i<keys.length() && keys.charAt(i)==x && i-index<mappingSize){\\n            int count=0;\\n            count=recur(keys,i+1);\\n            sum=(sum+count)%mod;\\n            i++;\\n        }\\n        \\n        cache.put(index,sum);\\n        return sum;\\n        \\n    }\\n    public int countTexts(String pressedKeys) {\\n        mp.put(2,3);\\n        mp.put(3,3);\\n        mp.put(4,3);\\n        mp.put(5,3);\\n        mp.put(6,3);\\n        mp.put(7,4);\\n        mp.put(8,3);\\n        mp.put(9,4);\\n        return recur(pressedKeys,0);  \\n    }\\n}",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "class Solution {\\n\\n    int res=0;\\n    int mod = 1000000007;\\n    Map<Integer,Integer> mp=new HashMap<Integer,Integer>();\\n    Map<Integer,Integer> cache=new HashMap<Integer,Integer>();\\n    \\n    public int recur(String keys,int index){\\n        if(index==keys.length()){\\n            return 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2828735,
                "title": "video-walkthrough-python-easy-five-line-solution",
                "content": "[Click Here For Video Walkthrough](https://youtu.be/n82BgEqSCkg)\\n```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        count, char,lastFour = 0, -1, [1,1,1,1]\\n        for key in pressedKeys:\\n            count, char =  min(count * int(char == key) + 1, 3 + int(char==\\'7\\' or char==\\'9\\')), key\\n            lastFour = [sum(lastFour[:count]) % (10 ** 9 + 7)] + lastFour[:-1]\\n        return lastFour[0] % (10 ** 9 + 7)\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        count, char,lastFour = 0, -1, [1,1,1,1]\\n        for key in pressedKeys:\\n            count, char =  min(count * int(char == key) + 1, 3 + int(char==\\'7\\' or char==\\'9\\')), key\\n            lastFour = [sum(lastFour[:count]) % (10 ** 9 + 7)] + lastFour[:-1]\\n        return lastFour[0] % (10 ** 9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2827628,
                "title": "simple-easy-to-understand-solution-c-hashing-dp-o-n-o-n",
                "content": "\\'\\'\\'\\n unordered_map< int , int >mp1 , mp2 ;\\n    \\n   int solve( pair< int  , char  >p )\\n    {\\n           int a = p.first ;\\n           char b = p.second ;\\n       \\n           int mod = pow( 10 , 9 ) + 7 ;\\n       \\n           int arr[a+1] ;\\n       \\n       \\n          if( b == \\'7\\' || b == \\'9\\' )\\n          {\\n              if( mp1.find(a) != mp1.end() )  return mp1[a] ;\\n              \\n              if( a  <= 2  )  return a ;\\n              if( a == 3 )  return 4 ;\\n              if( a == 4 )  return 8 ;\\n              \\n              arr[1] = 1 ;\\n              arr[2] = 2 ;\\n              arr[3] = 4 ;\\n              arr[4] = 8 ;\\n              \\n              for( int i = 5 ; i <= a ; i++ )\\n              {\\n                  arr[i] = ( (arr[i-1] + arr[i-2])%mod  + (arr[i-3] + arr[i-4] )%mod )%mod ;\\n              }\\n              \\n              mp1[a] = arr[a] ;\\n              \\n          }\\n          else{\\n              \\n             if( mp2.find(a) != mp2.end() )  return mp2[a] ;\\n              \\n              if( a  <= 2  )  return a ;\\n              if( a == 3 )  return 4 ;\\n             \\n              \\n              arr[1] = 1 ;\\n              arr[2] = 2 ;\\n              arr[3] = 4 ;\\n             \\n              \\n              for( int i = 4 ; i <= a ; i++ )\\n              {\\n                  arr[i] = ( (arr[i-1] + arr[i-2])%mod  +  arr[i-3] )%mod ;\\n              }\\n              \\n              mp2[a] = arr[a] ; \\n          }\\n       \\n          return arr[a] ;\\n    }\\n    int countTexts(string pk ) {\\n        \\n         if( pk == \"\")\\n        {\\n            return 0 ;\\n        }\\n        \\n        \\n        vector< pair<int , char >>mp ;\\n       \\n        string temp = \"\" ;\\n        \\n        int n = pk.size()  ;\\n        \\n            temp += pk[0] ;\\n                \\n            \\n        \\n        for( int i = 1 ; i < n ; i++ )\\n        {\\n            \\n            \\n            if( pk[i] == pk[i-1] )\\n            {\\n                temp += pk[i] ;\\n            }\\n            else{\\n                \\n                mp.push_back({ temp.size() , temp[0] }) ;\\n                // cout<<temp.size()<<\" \"<<temp[0]<<endl ;\\n                temp = pk[i] ;\\n            }\\n        }\\n        \\n        if( !temp.empty())\\n        {\\n            mp.push_back({ temp.size() , temp[0] }) ;\\n        }\\n        \\n        long long int ans = 1 ;\\n        \\n        int mod = pow( 10 , 9 ) + 7 ;\\n        \\n        for( int i = 0 ; i < mp.size() ; i++ )\\n        {\\n            ans = (ans*solve(mp[i]))%mod ;\\n        }\\n        \\n        return ans%mod ;\\n    }\\n\\t\\'\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n unordered_map< int , int >mp1 , mp2 ;\\n    \\n   int solve( pair< int  , char  >p )\\n    {\\n           int a = p.first ;\\n           char b = p.second ;\\n       \\n           int mod = pow( 10 , 9 ) + 7 ;\\n       \\n           int arr[a+1] ;\\n       \\n       \\n          if( b == \\'7\\' || b == \\'9\\' )\\n          {\\n              if( mp1.find(a) != mp1.end() )  return mp1[a] ;\\n              \\n              if( a  <= 2  )  return a ;\\n              if( a == 3 )  return 4 ;\\n              if( a == 4 )  return 8 ;\\n              \\n              arr[1] = 1 ;\\n              arr[2] = 2 ;\\n              arr[3] = 4 ;\\n              arr[4] = 8 ;\\n              \\n              for( int i = 5 ; i <= a ; i++ )\\n              {\\n                  arr[i] = ( (arr[i-1] + arr[i-2])%mod  + (arr[i-3] + arr[i-4] )%mod )%mod ;\\n              }\\n              \\n              mp1[a] = arr[a] ;\\n              \\n          }\\n          else{\\n              \\n             if( mp2.find(a) != mp2.end() )  return mp2[a] ;\\n              \\n              if( a  <= 2  )  return a ;\\n              if( a == 3 )  return 4 ;\\n             \\n              \\n              arr[1] = 1 ;\\n              arr[2] = 2 ;\\n              arr[3] = 4 ;\\n             \\n              \\n              for( int i = 4 ; i <= a ; i++ )\\n              {\\n                  arr[i] = ( (arr[i-1] + arr[i-2])%mod  +  arr[i-3] )%mod ;\\n              }\\n              \\n              mp2[a] = arr[a] ; \\n          }\\n       \\n          return arr[a] ;\\n    }\\n    int countTexts(string pk ) {\\n        \\n         if( pk == \"\")\\n        {\\n            return 0 ;\\n        }\\n        \\n        \\n        vector< pair<int , char >>mp ;\\n       \\n        string temp = \"\" ;\\n        \\n        int n = pk.size()  ;\\n        \\n            temp += pk[0] ;\\n                \\n            \\n        \\n        for( int i = 1 ; i < n ; i++ )\\n        {\\n            \\n            \\n            if( pk[i] == pk[i-1] )\\n            {\\n                temp += pk[i] ;\\n            }\\n            else{\\n                \\n                mp.push_back({ temp.size() , temp[0] }) ;\\n                // cout<<temp.size()<<\" \"<<temp[0]<<endl ;\\n                temp = pk[i] ;\\n            }\\n        }\\n        \\n        if( !temp.empty())\\n        {\\n            mp.push_back({ temp.size() , temp[0] }) ;\\n        }\\n        \\n        long long int ans = 1 ;\\n        \\n        int mod = pow( 10 , 9 ) + 7 ;\\n        \\n        for( int i = 0 ; i < mp.size() ; i++ )\\n        {\\n            ans = (ans*solve(mp[i]))%mod ;\\n        }\\n        \\n        return ans%mod ;\\n    }\\n\\t\\'\\'\\'\\'",
                "codeTag": "C++"
            },
            {
                "id": 2819325,
                "title": "faster-than-97-96-solution-without-dp",
                "content": "```\\n    int modNum = 1e9 + 7;\\n\\n\\tint countTexts(string pressedKeys)\\n\\t{\\n\\t\\tlong long sum = 1;\\n\\t\\tint lenSame = 1;\\n\\t\\tfor (int i = 1; i < pressedKeys.length(); i++)\\n\\t\\t{\\n\\t\\t\\tif (pressedKeys[i] == pressedKeys[i - 1])\\n\\t\\t\\t{\\n\\t\\t\\t\\tlenSame++;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tsum *= multiThem(pressedKeys[i - 1], lenSame) ;\\n\\t\\t\\t\\tsum %= modNum;\\n\\t\\t\\t\\tlenSame = 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tsum *= multiThem(pressedKeys[pressedKeys.length() - 1], lenSame);\\n\\t\\tsum %= modNum;\\n\\t\\treturn sum;\\n\\t}\\n\\n\\tint multiThem(char key, int len)\\n\\t{\\n\\t\\tint sum = 1;\\n\\t\\tif (len == 2)\\n\\t\\t\\tsum *= 2;\\n\\t\\telse if (len == 3)\\n\\t\\t\\tsum *= 4;\\n\\t\\telse if (len > 3)\\n\\t\\t\\tsum *= sumPossiblity(key, len);\\n\\n\\t\\treturn sum;\\n\\t}\\n\\n\\tint sumPossiblity(char key, int len)\\n\\t{\\n\\t\\tint *index = new int[len + 1];\\n\\t\\tindex[0] = 1;\\n\\t\\tindex[1] = 1;\\n\\t\\tindex[2] = 2;\\n\\t\\tindex[3] = 4;\\n\\t\\tfor (int i = 4; i <= len; i++)\\n\\t\\t{\\n\\t\\t\\tlong long x = index[i - 1];\\n\\t\\t\\tx += index[i - 2];\\n\\t\\t\\tx += index[i - 3];\\n\\t\\t\\t\\n\\t\\t\\tif (key == \\'7\\' || key == \\'9\\')\\n\\t\\t\\t{\\n\\t\\t\\t\\tx += index[i - 4];\\n\\t\\t\\t}\\n\\t\\t\\tx %= modNum;\\n\\t\\t\\tindex[i] = x;\\n\\t\\t}\\n\\n\\t\\tint sum = index[len];\\n\\t\\tdelete[] index;\\n\\t\\treturn sum;\\n\\t}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int modNum = 1e9 + 7;\\n\\n\\tint countTexts(string pressedKeys)\\n\\t{\\n\\t\\tlong long sum = 1;\\n\\t\\tint lenSame = 1;\\n\\t\\tfor (int i = 1; i < pressedKeys.length(); i++)\\n\\t\\t{\\n\\t\\t\\tif (pressedKeys[i] == pressedKeys[i - 1])\\n\\t\\t\\t{\\n\\t\\t\\t\\tlenSame++;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tsum *= multiThem(pressedKeys[i - 1], lenSame) ;\\n\\t\\t\\t\\tsum %= modNum;\\n\\t\\t\\t\\tlenSame = 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tsum *= multiThem(pressedKeys[pressedKeys.length() - 1], lenSame);\\n\\t\\tsum %= modNum;\\n\\t\\treturn sum;\\n\\t}\\n\\n\\tint multiThem(char key, int len)\\n\\t{\\n\\t\\tint sum = 1;\\n\\t\\tif (len == 2)\\n\\t\\t\\tsum *= 2;\\n\\t\\telse if (len == 3)\\n\\t\\t\\tsum *= 4;\\n\\t\\telse if (len > 3)\\n\\t\\t\\tsum *= sumPossiblity(key, len);\\n\\n\\t\\treturn sum;\\n\\t}\\n\\n\\tint sumPossiblity(char key, int len)\\n\\t{\\n\\t\\tint *index = new int[len + 1];\\n\\t\\tindex[0] = 1;\\n\\t\\tindex[1] = 1;\\n\\t\\tindex[2] = 2;\\n\\t\\tindex[3] = 4;\\n\\t\\tfor (int i = 4; i <= len; i++)\\n\\t\\t{\\n\\t\\t\\tlong long x = index[i - 1];\\n\\t\\t\\tx += index[i - 2];\\n\\t\\t\\tx += index[i - 3];\\n\\t\\t\\t\\n\\t\\t\\tif (key == \\'7\\' || key == \\'9\\')\\n\\t\\t\\t{\\n\\t\\t\\t\\tx += index[i - 4];\\n\\t\\t\\t}\\n\\t\\t\\tx %= modNum;\\n\\t\\t\\tindex[i] = x;\\n\\t\\t}\\n\\n\\t\\tint sum = index[len];\\n\\t\\tdelete[] index;\\n\\t\\treturn sum;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2797745,
                "title": "python-simple-dynamic-programming",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countTexts(self, pressedKeys):\\n        n = len(pressedKeys)\\n\\n        dp = [0]*(n+1)\\n\\n        dp[0], dp[1] = 1, 1\\n\\n        for i in range(2,n+1):\\n            dp[i] += dp[i-1]\\n\\n            if i > 1 and pressedKeys[i-1] == pressedKeys[i-2]:\\n                dp[i] += dp[i-2]\\n\\n            if i > 2 and pressedKeys[i-1] == pressedKeys[i-2] == pressedKeys[i-3]:\\n                dp[i] += dp[i-3]\\n\\n            if pressedKeys[i-1] == \"7\" or pressedKeys[i-1] == \"9\":\\n                if i > 3 and pressedKeys[i-1] == pressedKeys[i-2] == pressedKeys[i-3] == pressedKeys[i-4]:\\n                    dp[i] += dp[i-4]\\n\\n        return dp[-1]%(10**9+7)\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys):\\n        n = len(pressedKeys)\\n\\n        dp = [0]*(n+1)\\n\\n        dp[0], dp[1] = 1, 1\\n\\n        for i in range(2,n+1):\\n            dp[i] += dp[i-1]\\n\\n            if i > 1 and pressedKeys[i-1] == pressedKeys[i-2]:\\n                dp[i] += dp[i-2]\\n\\n            if i > 2 and pressedKeys[i-1] == pressedKeys[i-2] == pressedKeys[i-3]:\\n                dp[i] += dp[i-3]\\n\\n            if pressedKeys[i-1] == \"7\" or pressedKeys[i-1] == \"9\":\\n                if i > 3 and pressedKeys[i-1] == pressedKeys[i-2] == pressedKeys[i-3] == pressedKeys[i-4]:\\n                    dp[i] += dp[i-4]\\n\\n        return dp[-1]%(10**9+7)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792224,
                "title": "java-easy-to-understand-code",
                "content": "```\\nchar[] arr;\\nint brr[], dp[], mod = 1_000_000_007;\\n\\npublic int countTexts(String pressedKeys){\\n\\tarr = pressedKeys.toCharArray();\\n\\tdp = new int[arr.length + 1];\\n\\tbrr = new int[] { 0, 0, 3, 3, 3, 3, 3, 4, 3, 4 };\\n\\tdp[0] = 1;\\n\\tfor(int i = 1; i <= arr.length; i++){\\n\\n\\t\\tint freq = brr[arr[i - 1] - \\'0\\'], count = 0;\\n\\t\\tfor (int j = 0; i - j - 1 >= 0 && j < freq && arr[i - 1] == arr[i - j - 1]; j++) {\\n\\t\\t\\tcount = (count % mod + dp[i - j - 1] % mod) % mod;\\n\\t\\t}\\n\\t\\tdp[i] = count;\\n\\t}\\n\\treturn dp[arr.length];\\n}",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nchar[] arr;\\nint brr[], dp[], mod = 1_000_000_007;\\n\\npublic int countTexts(String pressedKeys){\\n\\tarr = pressedKeys.toCharArray();\\n\\tdp = new int[arr.length + 1];\\n\\tbrr = new int[] { 0, 0, 3, 3, 3, 3, 3, 4, 3, 4 };\\n\\tdp[0] = 1;\\n\\tfor(int i = 1; i <= arr.length; i++){\\n\\n\\t\\tint freq = brr[arr[i - 1] - \\'0\\'], count = 0;\\n\\t\\tfor (int j = 0; i - j - 1 >= 0 && j < freq && arr[i - 1] == arr[i - j - 1]; j++) {\\n\\t\\t\\tcount = (count % mod + dp[i - j - 1] % mod) % mod;\\n\\t\\t}\\n\\t\\tdp[i] = count;\\n\\t}\\n\\treturn dp[arr.length];\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2737477,
                "title": "c-o-n-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int countTexts(string pressedKeys) {\\n        pressedKeys += \\'*\\';\\n        long long res = 1, mod = 1e9+7;\\n        vector<int> vNumChar = {1,0,3,3,3,3,3,4,3,4};\\n        char pre = \\'0\\';\\n        int len = 0;\\n        for(auto c:pressedKeys){\\n            if(c != pre){\\n                res = count(len, vNumChar[pre-\\'0\\']) % mod * res % mod;\\n                pre = c;\\n                len = 1;\\n            }\\n            else{\\n                len++;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    int count(int n, int numChar){\\n        const long long mod = 1e9+7;\\n        vector<long long> dp(n+1, 0);\\n        dp[0] = 1;\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<=numChar;j++){\\n                if(i+1-j >= 0) dp[i+1] += dp[i+1-j];\\n            }\\n            dp[i+1] %= mod;\\n        }\\n        return dp.back();\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int countTexts(string pressedKeys) {\\n        pressedKeys += \\'*\\';\\n        long long res = 1, mod = 1e9+7;\\n        vector<int> vNumChar = {1,0,3,3,3,3,3,4,3,4}",
                "codeTag": "Java"
            },
            {
                "id": 2717929,
                "title": "c-concise-intuitive-easy-to-understand-dynamic-programming-solution-o-n",
                "content": "My personal struggle has always been, my brain looping in cataclysms of understanding \\'# of ways\\', so I often get the tansition from one state to another wrong.\\nI do things like initialising dp tables with 1 or adding 1 while transitioning which is clearly wrong. \\n\\nFor example in for input 2223 transitioning from \"222\"-> \"2223\" will not resullt in increase in the # of ways.\\nAlso it is important to understand the base condition dp[0] = 1;\\nBasically dp[n] denotes the number of ways of decoding the test of length n, the number of ways of decoding an empty message is 1.\\n\\n```\\nint countTexts(string pk) {\\n        int n = pk.size(), m = 1e9 + 7, k;\\n        vector<int> dp(n + 1, 0);\\n        dp[0] = 1;\\n        for (int i = 0; i < n; i++) {\\n            k = (pk[i] == \\'7\\' || pk[i] == \\'9\\') ? 4 : 3;\\n            for (int j = 0; j < k && i - j >= 0 && pk[i] == pk[i - j]; j++) \\n                dp[i + 1] = (dp[i + 1] + dp[i - j]) % m;\\n        }\\n        return dp[n];\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nint countTexts(string pk) {\\n        int n = pk.size(), m = 1e9 + 7, k;\\n        vector<int> dp(n + 1, 0);\\n        dp[0] = 1;\\n        for (int i = 0; i < n; i++) {\\n            k = (pk[i] == \\'7\\' || pk[i] == \\'9\\') ? 4 : 3;\\n            for (int j = 0; j < k && i - j >= 0 && pk[i] == pk[i - j]; j++) \\n                dp[i + 1] = (dp[i + 1] + dp[i - j]) % m;\\n        }\\n        return dp[n];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2692639,
                "title": "java-o-n-memoization-easy-intiution-faster",
                "content": "\\tpublic int mod = 1000000007;\\n    public int[] dp;\\n   \\n    public int countTexts(String s) {\\n        int n = s.length();\\n        dp = new int[n+1];\\n        dp[n]=1;\\n        for(int index=n-1; index>=0; index--){\\n            char ch = s.charAt(index);\\n            int keylen=(ch==\\'7\\' || ch==\\'9\\')?4:3;\\n            for(int i=1; i<=keylen; i++){\\n                if(index+i > n) break;\\n                if(ch!=s.charAt(index+i-1)) break;\\n\\n                dp[index] += dp[index+i];\\n                dp[index] = dp[index]%mod;\\n            }\\n        }\\n        return dp[0];\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "\\tpublic int mod = 1000000007;\\n    public int[] dp;\\n   \\n    public int countTexts(String s) {\\n        int n = s.length();\\n        dp = new int[n+1];\\n        dp[n]=1;\\n        for(int index=n-1; index>=0; index--){\\n            char ch = s.charAt(index);\\n            int keylen=(ch==\\'7\\' || ch==\\'9\\')?4:3;\\n            for(int i=1; i<=keylen; i++){\\n                if(index+i > n) break;\\n                if(ch!=s.charAt(index+i-1)) break;\\n\\n                dp[index] += dp[index+i];\\n                dp[index] = dp[index]%mod;\\n            }\\n        }\\n        return dp[0];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2679674,
                "title": "python-short-solution",
                "content": "```\\ndef countTexts(self, strs: str) -> int:\\n\\tmod = 10**9+7\\n\\t\\n\\t@lru_cache(None)\\n\\tdef dfs(x, k):\\n\\t\\tif x==0:\\n\\t\\t\\treturn 1\\n\\t\\treturn sum(dfs(x-i, k) for i in range(1, min(x, k)+1))%mod\\n\\n\\td = {str(c):3 for c in range(2, 10)}\\n\\td[\\'7\\'], d[\\'9\\'] = 4, 4\\n\\treturn reduce(mul, [dfs(len(list(g)), d[k]) for k, g in groupby(strs)])%mod    \\n```",
                "solutionTags": [],
                "code": "```\\ndef countTexts(self, strs: str) -> int:\\n\\tmod = 10**9+7\\n\\t\\n\\t@lru_cache(None)\\n\\tdef dfs(x, k):\\n\\t\\tif x==0:\\n\\t\\t\\treturn 1\\n\\t\\treturn sum(dfs(x-i, k) for i in range(1, min(x, k)+1))%mod\\n\\n\\td = {str(c):3 for c in range(2, 10)}\\n\\td[\\'7\\'], d[\\'9\\'] = 4, 4\\n\\treturn reduce(mul, [dfs(len(list(g)), d[k]) for k, g in groupby(strs)])%mod    \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2672218,
                "title": "python-easiest-memoization",
                "content": "```\\nclass Solution(object):\\n    def countTexts(self, pressed):\\n        def dfs(i,s):\\n            if i in dp:\\n                return dp[i]\\n            if i>=len(s):\\n                return 1\\n            count = 0\\n            n = 3\\n            if s[i] == \\'7\\' or s[i] == \\'9\\':\\n                n = 4\\n            # number of times we can press the buttons \\n            for k in range(1, n+1):\\n                if i+k<=len(s):\\n                    count+= dfs(i+k,s)\\n            dp[i] = count\\n            return dp[i]\\n        ans = 1\\n        i= 0\\n        j = 0\\n        while j<len(pressed):\\n            while j<len(pressed) and pressed[i] == pressed[j]:\\n                j+=1\\n            s = pressed[i:j]\\n            dp = {}\\n            ans *= dfs(0,s)\\n            i = j\\n        return ans%(10**9+7)\\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution(object):\\n    def countTexts(self, pressed):\\n        def dfs(i,s):\\n            if i in dp:\\n                return dp[i]\\n            if i>=len(s):\\n                return 1\\n            count = 0\\n            n = 3\\n            if s[i] == \\'7\\' or s[i] == \\'9\\':\\n                n = 4\\n            # number of times we can press the buttons \\n            for k in range(1, n+1):\\n                if i+k<=len(s):\\n                    count+= dfs(i+k,s)\\n            dp[i] = count\\n            return dp[i]\\n        ans = 1\\n        i= 0\\n        j = 0\\n        while j<len(pressed):\\n            while j<len(pressed) and pressed[i] == pressed[j]:\\n                j+=1\\n            s = pressed[i:j]\\n            dp = {}\\n            ans *= dfs(0,s)\\n            i = j\\n        return ans%(10**9+7)\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2664936,
                "title": "c-easy-recursive-and-memoized-code-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    int MOD = 1e9 + 7;\\n    int countTexts(string keys) {\\n        dp.resize(keys.size(), -1);\\n        \\n        return recurse(keys, 0);\\n    }\\n    int recurse(string &keys, int ind){\\n        if(ind >= keys.size()){\\n            return 1;\\n        }\\n        if(dp[ind] != -1){\\n            return dp[ind] % MOD;\\n        }\\n        \\n        long long ans = 0;\\n        \\n        //take one char at a time\\n        ans += recurse(keys, ind + 1);\\n            \\n        if(ind + 1 < keys.size() and keys[ind] == keys[ind + 1]){\\n            //take two char at a time if they\\'re identical\\n            ans += recurse(keys, ind + 2);\\n\\n            if(ind + 2 < keys.size() and keys[ind] == keys[ind + 2]){\\n                //take three char at a time if they\\'re identical\\n                ans += recurse(keys, ind + 3);\\n                \\n                //take four char at a time if they\\'re identical and they\\'re either 7 or 9\\n                if(ind + 3 < keys.size() and keys[ind] == keys[ind + 3] and \\n                  (keys[ind + 3] == \\'7\\' or keys[ind + 3] == \\'9\\')){\\n                    \\n                    ans += recurse(keys, ind + 4);\\n                }\\n            }\\n        }\\n        return dp[ind] = ans % MOD;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    int MOD = 1e9 + 7;\\n    int countTexts(string keys) {\\n        dp.resize(keys.size(), -1);\\n        \\n        return recurse(keys, 0);\\n    }\\n    int recurse(string &keys, int ind){\\n        if(ind >= keys.size()){\\n            return 1;\\n        }\\n        if(dp[ind] != -1){\\n            return dp[ind] % MOD;\\n        }\\n        \\n        long long ans = 0;\\n        \\n        //take one char at a time\\n        ans += recurse(keys, ind + 1);\\n            \\n        if(ind + 1 < keys.size() and keys[ind] == keys[ind + 1]){\\n            //take two char at a time if they\\'re identical\\n            ans += recurse(keys, ind + 2);\\n\\n            if(ind + 2 < keys.size() and keys[ind] == keys[ind + 2]){\\n                //take three char at a time if they\\'re identical\\n                ans += recurse(keys, ind + 3);\\n                \\n                //take four char at a time if they\\'re identical and they\\'re either 7 or 9\\n                if(ind + 3 < keys.size() and keys[ind] == keys[ind + 3] and \\n                  (keys[ind + 3] == \\'7\\' or keys[ind + 3] == \\'9\\')){\\n                    \\n                    ans += recurse(keys, ind + 4);\\n                }\\n            }\\n        }\\n        return dp[ind] = ans % MOD;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2661593,
                "title": "python-using-groupby",
                "content": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        MOD = 10 ** 9 + 7\\n        \\n        @cache\\n        def dfs(cur: int, options: int) -> int:\\n            if cur < 0:\\n                return 0\\n            if cur == 0:\\n                return 1\\n            \\n            res = 0\\n            for ind in range(1, options + 1):\\n                res += dfs(cur - ind, options)\\n            return res % MOD\\n        \\n        res = 1\\n        \\n        for key, curgroup in groupby(pressedKeys):\\n            options = 4 if key in \"79\" else 3\\n            res *= dfs(len(list(curgroup)), options)\\n            res %= MOD\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        MOD = 10 ** 9 + 7\\n        \\n        @cache\\n        def dfs(cur: int, options: int) -> int:\\n            if cur < 0:\\n                return 0\\n            if cur == 0:\\n                return 1\\n            \\n            res = 0\\n            for ind in range(1, options + 1):\\n                res += dfs(cur - ind, options)\\n            return res % MOD\\n        \\n        res = 1\\n        \\n        for key, curgroup in groupby(pressedKeys):\\n            options = 4 if key in \"79\" else 3\\n            res *= dfs(len(list(curgroup)), options)\\n            res %= MOD\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2654278,
                "title": "python-solution-dynamic-programming-faster-than-96-time-o-n-space-o-n",
                "content": "\\tclass Solution:\\n\\t\\tdef countTexts(self, pressedKeys: str) -> int:\\n\\t\\t\\tpressedKeys_len = len(pressedKeys)\\n\\t\\t\\tif pressedKeys_len == 0: \\n\\t\\t\\t\\treturn 0 \\n\\t\\t\\telif pressedKeys_len == 1: \\n\\t\\t\\t\\treturn 1 \\n\\t\\t\\tif \\'0\\' in pressedKeys or \\'1\\' in pressedKeys: \\n\\t\\t\\t\\treturn False\\n\\t\\t\\tqueue = list()\\n\\t\\t\\tcontinue_count = 1\\n\\t\\t\\tprev_num_of_text = pressedKeys[0]\\n\\t\\t\\ti = 1\\n\\t\\t\\tmax_continue_count = 1\\n\\t\\t\\twhile i<pressedKeys_len:\\n\\t\\t\\t\\tcurr_num_of_text = pressedKeys[i]\\n\\t\\t\\t\\tif curr_num_of_text == prev_num_of_text: \\n\\t\\t\\t\\t\\tcontinue_count += 1                \\n\\t\\t\\t\\telif curr_num_of_text != prev_num_of_text: \\n\\t\\t\\t\\t\\tqueue.append([prev_num_of_text, continue_count])\\n\\t\\t\\t\\t\\tif max_continue_count<continue_count: \\n\\t\\t\\t\\t\\t\\tmax_continue_count = continue_count\\n\\t\\t\\t\\t\\tcontinue_count = 1\\n\\t\\t\\t\\tprev_num_of_text = curr_num_of_text\\n\\t\\t\\t\\ti += 1 \\n\\t\\t\\tqueue.append((prev_num_of_text, continue_count))\\n\\t\\t\\tif max_continue_count<continue_count: \\n\\t\\t\\t\\tmax_continue_count = continue_count\\n\\t\\t\\t# print(queue)\\n\\t\\t\\tdp3 = [0 for _ in range(1+max_continue_count)]\\n\\t\\t\\tdp3[1] = 1 \\n\\t\\t\\tfor i in range(2, 1+max_continue_count): \\n\\t\\t\\t\\tif i==2:\\n\\t\\t\\t\\t\\tdp3[i] = (dp3[i-1] + 1) % (10**9 + 7)\\n\\t\\t\\t\\telif i==3: \\n\\t\\t\\t\\t\\tdp3[i] = (dp3[i-1] + dp3[i-2] + 1) % (10**9 + 7)\\n\\t\\t\\t\\telif i>=4: \\n\\t\\t\\t\\t\\tdp3[i] = (dp3[i-1] + dp3[i-2] + dp3[i-3]) % (10**9 + 7)  \\n\\n\\t\\t\\tdp4 = [0 for _ in range(1+max_continue_count)]         \\n\\t\\t\\tdp4[1] = 1         \\n\\t\\t\\tfor i in range(2, 1+max_continue_count): \\n\\t\\t\\t\\tif i==2:\\n\\t\\t\\t\\t\\tdp4[i] = (dp4[i-1] + 1) % (10**9 + 7)\\n\\t\\t\\t\\telif i==3: \\n\\t\\t\\t\\t\\tdp4[i] = (dp4[i-1] + dp4[i-2] + 1) % (10**9 + 7)\\n\\t\\t\\t\\telif i==4: \\n\\t\\t\\t\\t\\tdp4[i] = (dp4[i-1] + dp4[i-2] + dp4[i-3] + 1) % (10**9 + 7)                \\n\\t\\t\\t\\telif i>=5: \\n\\t\\t\\t\\t\\tdp4[i] = (dp4[i-1] + dp4[i-2] + dp4[i-3] + dp4[i-4]) % (10**9 + 7)                  \\n\\t\\t\\tres = 1 \\n\\t\\t\\titems_num = len(queue)\\n\\t\\t\\tfor i in range(items_num): \\n\\t\\t\\t\\tcurr_item = queue[i]\\n\\t\\t\\t\\tdigit_num, curr_continue_num_count = curr_item \\n\\t\\t\\t\\t# print(curr_item, digit_num, curr_continue_num_count)\\n\\t\\t\\t\\tif digit_num in \\'234568\\': \\n\\t\\t\\t\\t\\tres *= dp3[curr_continue_num_count] % (10**9 + 7) \\n\\t\\t\\t\\telif digit_num in \\'79\\':  \\n\\t\\t\\t\\t\\tres *= dp4[curr_continue_num_count] % (10**9 + 7) \\n\\t\\t\\treturn res % (10**9 + 7)",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef countTexts(self, pressedKeys: str) -> int:\\n\\t\\t\\tpressedKeys_len = len(pressedKeys)\\n\\t\\t\\tif pressedKeys_len == 0: \\n\\t\\t\\t\\treturn 0 \\n\\t\\t\\telif pressedKeys_len == 1: \\n\\t\\t\\t\\treturn 1 \\n\\t\\t\\tif \\'0\\' in pressedKeys or \\'1\\' in pressedKeys: \\n\\t\\t\\t\\treturn False\\n\\t\\t\\tqueue = list()\\n\\t\\t\\tcontinue_count = 1\\n\\t\\t\\tprev_num_of_text = pressedKeys[0]\\n\\t\\t\\ti = 1\\n\\t\\t\\tmax_continue_count = 1\\n\\t\\t\\twhile i<pressedKeys_len:\\n\\t\\t\\t\\tcurr_num_of_text = pressedKeys[i]\\n\\t\\t\\t\\tif curr_num_of_text == prev_num_of_text: \\n\\t\\t\\t\\t\\tcontinue_count += 1                \\n\\t\\t\\t\\telif curr_num_of_text != prev_num_of_text: \\n\\t\\t\\t\\t\\tqueue.append([prev_num_of_text, continue_count])\\n\\t\\t\\t\\t\\tif max_continue_count<continue_count: \\n\\t\\t\\t\\t\\t\\tmax_continue_count = continue_count\\n\\t\\t\\t\\t\\tcontinue_count = 1\\n\\t\\t\\t\\tprev_num_of_text = curr_num_of_text\\n\\t\\t\\t\\ti += 1 \\n\\t\\t\\tqueue.append((prev_num_of_text, continue_count))\\n\\t\\t\\tif max_continue_count<continue_count: \\n\\t\\t\\t\\tmax_continue_count = continue_count\\n\\t\\t\\t# print(queue)\\n\\t\\t\\tdp3 = [0 for _ in range(1+max_continue_count)]\\n\\t\\t\\tdp3[1] = 1 \\n\\t\\t\\tfor i in range(2, 1+max_continue_count): \\n\\t\\t\\t\\tif i==2:\\n\\t\\t\\t\\t\\tdp3[i] = (dp3[i-1] + 1) % (10**9 + 7)\\n\\t\\t\\t\\telif i==3: \\n\\t\\t\\t\\t\\tdp3[i] = (dp3[i-1] + dp3[i-2] + 1) % (10**9 + 7)\\n\\t\\t\\t\\telif i>=4: \\n\\t\\t\\t\\t\\tdp3[i] = (dp3[i-1] + dp3[i-2] + dp3[i-3]) % (10**9 + 7)  \\n\\n\\t\\t\\tdp4 = [0 for _ in range(1+max_continue_count)]         \\n\\t\\t\\tdp4[1] = 1         \\n\\t\\t\\tfor i in range(2, 1+max_continue_count): \\n\\t\\t\\t\\tif i==2:\\n\\t\\t\\t\\t\\tdp4[i] = (dp4[i-1] + 1) % (10**9 + 7)\\n\\t\\t\\t\\telif i==3: \\n\\t\\t\\t\\t\\tdp4[i] = (dp4[i-1] + dp4[i-2] + 1) % (10**9 + 7)\\n\\t\\t\\t\\telif i==4: \\n\\t\\t\\t\\t\\tdp4[i] = (dp4[i-1] + dp4[i-2] + dp4[i-3] + 1) % (10**9 + 7)                \\n\\t\\t\\t\\telif i>=5: \\n\\t\\t\\t\\t\\tdp4[i] = (dp4[i-1] + dp4[i-2] + dp4[i-3] + dp4[i-4]) % (10**9 + 7)                  \\n\\t\\t\\tres = 1 \\n\\t\\t\\titems_num = len(queue)\\n\\t\\t\\tfor i in range(items_num): \\n\\t\\t\\t\\tcurr_item = queue[i]\\n\\t\\t\\t\\tdigit_num, curr_continue_num_count = curr_item \\n\\t\\t\\t\\t# print(curr_item, digit_num, curr_continue_num_count)\\n\\t\\t\\t\\tif digit_num in \\'234568\\': \\n\\t\\t\\t\\t\\tres *= dp3[curr_continue_num_count] % (10**9 + 7) \\n\\t\\t\\t\\telif digit_num in \\'79\\':  \\n\\t\\t\\t\\t\\tres *= dp4[curr_continue_num_count] % (10**9 + 7) \\n\\t\\t\\treturn res % (10**9 + 7)",
                "codeTag": "Java"
            },
            {
                "id": 2651611,
                "title": "c-dp-single-pass",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSingle pass using dynamic programming similar to decode ways question\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countTexts(string pressedKeys) {\\n        \\n        int n = pressedKeys.length();\\n        // int* dp = new int[n];\\n        vector<long> dp(n);\\n        \\n        dp[0] = 1;\\n        int mod  = pow(10, 9) + 7;\\n\\n        for(int i=1; i<n; i++){\\n            dp[i] = dp[i-1];\\n            char ch = pressedKeys.at(i);\\n\\n            if((i>=1) && ch == pressedKeys.at(i-1)) dp[i]= i>=2 ?(dp[i] + dp[i-2]) % mod: dp[i] + 1;\\n            else continue;\\n\\n            if((i>=2) && ch == pressedKeys.at(i-2)) dp[i]= i>=3 ? (dp[i] + dp[i-3]) % mod: dp[i] + 1;\\n            else continue;\\n\\n            if((i>=3) && (ch == \\'7\\' || ch == \\'9\\') && ch == pressedKeys.at(i-3)) \\n            dp[i]= i>=4 ? (dp[i] + dp[i-4]) % mod : dp[i] + 1;\\n        }\\n       \\n        return (int)dp[n-1] % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countTexts(string pressedKeys) {\\n        \\n        int n = pressedKeys.length();\\n        // int* dp = new int[n];\\n        vector<long> dp(n);\\n        \\n        dp[0] = 1;\\n        int mod  = pow(10, 9) + 7;\\n\\n        for(int i=1; i<n; i++){\\n            dp[i] = dp[i-1];\\n            char ch = pressedKeys.at(i);\\n\\n            if((i>=1) && ch == pressedKeys.at(i-1)) dp[i]= i>=2 ?(dp[i] + dp[i-2]) % mod: dp[i] + 1;\\n            else continue;\\n\\n            if((i>=2) && ch == pressedKeys.at(i-2)) dp[i]= i>=3 ? (dp[i] + dp[i-3]) % mod: dp[i] + 1;\\n            else continue;\\n\\n            if((i>=3) && (ch == \\'7\\' || ch == \\'9\\') && ch == pressedKeys.at(i-3)) \\n            dp[i]= i>=4 ? (dp[i] + dp[i-4]) % mod : dp[i] + 1;\\n        }\\n       \\n        return (int)dp[n-1] % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2650844,
                "title": "python-easy-to-understand-solution-with-memoization",
                "content": "```python\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        d = {\\n            \\'2\\': \\'abc\\',\\n            \\'3\\': \\'def\\',\\n            \\'4\\': \\'gfi\\',\\n            \\'5\\': \\'jkl\\',\\n            \\'6\\': \\'mno\\',\\n            \\'7\\': \\'pqrs\\',\\n            \\'8\\': \\'tuv\\',\\n            \\'9\\': \\'wxyz\\',\\n        }\\n\\n        @cache\\n        def dfs(i):\\n            if i == len(pressedKeys):\\n                return 1\\n \\n            total = 0\\n    \\n            for j in range(len(d[pressedKeys[i]])):\\n                k = i + j + 1 \\n\\n                if k > len(pressedKeys) or pressedKeys[i] != pressedKeys[k - 1]:\\n                    break\\n\\n                total += dfs(k)\\n\\n            return total % (10**9 + 7)\\n\\n        return dfs(0) \\n```",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```python\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        d = {\\n            \\'2\\': \\'abc\\',\\n            \\'3\\': \\'def\\',\\n            \\'4\\': \\'gfi\\',\\n            \\'5\\': \\'jkl\\',\\n            \\'6\\': \\'mno\\',\\n            \\'7\\': \\'pqrs\\',\\n            \\'8\\': \\'tuv\\',\\n            \\'9\\': \\'wxyz\\',\\n        }\\n\\n        @cache\\n        def dfs(i):\\n            if i == len(pressedKeys):\\n                return 1\\n \\n            total = 0\\n    \\n            for j in range(len(d[pressedKeys[i]])):\\n                k = i + j + 1 \\n\\n                if k > len(pressedKeys) or pressedKeys[i] != pressedKeys[k - 1]:\\n                    break\\n\\n                total += dfs(k)\\n\\n            return total % (10**9 + 7)\\n\\n        return dfs(0) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649367,
                "title": "java-recursion",
                "content": "\\tclass Solution {\\n    int mod=(int)1e9+7;\\n    public int countTexts(String pk) {\\n        HashMap<String,Character>hm=new HashMap<>();\\n        \\n        hm.put(\"2\", \\'a\\'); hm.put(\"22\",\\'b\\'); hm.put(\"222\",\\'c\\');\\n        hm.put(\"3\",\\'d\\'); hm.put(\"33\",\\'e\\'); hm.put(\"333\",\\'f\\');\\n        hm.put(\"4\",\\'g\\'); hm.put(\"44\",\\'h\\'); hm.put(\"444\",\\'i\\');\\n        hm.put(\"5\",\\'j\\'); hm.put(\"55\",\\'k\\'); hm.put(\"555\",\\'l\\');\\n        hm.put(\"6\",\\'m\\'); hm.put(\"66\",\\'n\\'); hm.put(\"666\",\\'o\\');\\n        hm.put(\"7\",\\'p\\'); hm.put(\"77\",\\'q\\'); hm.put(\"777\",\\'r\\'); hm.put(\"7777\",\\'s\\');\\n        hm.put(\"8\",\\'t\\'); hm.put(\"88\",\\'u\\'); hm.put(\"888\",\\'v\\');\\n        hm.put(\"9\",\\'w\\'); hm.put(\"99\",\\'x\\'); hm.put(\"999\",\\'y\\');\\n        hm.put(\"9999\",\\'z\\');\\n        int []dp=new int[pk.length()+1]; Arrays.fill(dp,-1);\\n        return call(0, pk, hm,dp);\\n    }\\n    \\n    public int call(int i, String s, HashMap<String, Character>hm, int[]dp)\\n    {\\n        if(i==s.length()) return 1;\\n        if(dp[i]!=-1) return dp[i];\\n        int ans=0;\\n        for(int j=i+1;j<=s.length()&&j<=i+4 ;j++)\\n        {\\n            if(hm.containsKey(s.substring(i,j)))\\n            {\\n                ans=(ans+call(j, s, hm,dp)%mod)%mod;\\n            }\\n        }\\n        return dp[i]=ans%mod;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    int mod=(int)1e9+7;\\n    public int countTexts(String pk) {\\n        HashMap<String,Character>hm=new HashMap<>();\\n        \\n        hm.put(\"2\", \\'a\\'); hm.put(\"22\",\\'b\\'); hm.put(\"222\",\\'c\\');\\n        hm.put(\"3\",\\'d\\'); hm.put(\"33\",\\'e\\'); hm.put(\"333\",\\'f\\');\\n        hm.put(\"4\",\\'g\\'); hm.put(\"44\",\\'h\\'); hm.put(\"444\",\\'i\\');\\n        hm.put(\"5\",\\'j\\'); hm.put(\"55\",\\'k\\'); hm.put(\"555\",\\'l\\');\\n        hm.put(\"6\",\\'m\\'); hm.put(\"66\",\\'n\\'); hm.put(\"666\",\\'o\\');\\n        hm.put(\"7\",\\'p\\'); hm.put(\"77\",\\'q\\'); hm.put(\"777\",\\'r\\'); hm.put(\"7777\",\\'s\\');\\n        hm.put(\"8\",\\'t\\'); hm.put(\"88\",\\'u\\'); hm.put(\"888\",\\'v\\');\\n        hm.put(\"9\",\\'w\\'); hm.put(\"99\",\\'x\\'); hm.put(\"999\",\\'y\\');\\n        hm.put(\"9999\",\\'z\\');\\n        int []dp=new int[pk.length()+1]; Arrays.fill(dp,-1);\\n        return call(0, pk, hm,dp);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2648290,
                "title": "java-clean-dp-solution-for-both-topdown-and-bottom-up-beat-88",
                "content": "1. top-down + memorization (beat 18%)\\n2. bottom-up (beat 88%)\\n```\\nclass Solution {\\n    int[] dp, count;\\n    int mod = 100_000_000_7;\\n    public int countTextsTD(String pressedKeys) {\\n        //need store max length of repeat number that can form a char.    \\n        if(pressedKeys == null || pressedKeys.isEmpty()) return 0;\\n        int n = pressedKeys.length();\\n        count = new int[] {0,0,3,3,3,3,3,4,3,4};\\n        dp = new int[n];        \\n        Arrays.fill(dp, -1);\\n        return dp(pressedKeys, 0, n);\\n    }\\n    //calculated reversely, start from [idx...n] can form how many \\n    private int dp(String s, int idx, int n) {\\n        if(idx == n) return 1;\\n        if(dp[idx] != -1) return dp[idx];\\n        \\n        int res = 0;\\n        char c = s.charAt(idx);\\n        int len = count[c-\\'0\\'];\\n        \\n        for(int i = 0; i < len && idx + i < n && s.charAt(idx + i) == s.charAt(idx); i++) {\\n            // i start with 0, will consider number idx do not combine with previous char.\\n            // i > 1 means, it can be combined with previous number to form a char.\\n            res += dp(s, idx + i + 1, n);\\n            res %= mod;\\n        }\\n        return dp[idx] = res;    \\n    }\\n    \\n    public int countTexts(String s) {\\n        int n = s.length();\\n        int[] dp = new int[n + 1];\\n        dp[0] = 1;\\n        for(int i = 1; i <= n; i++) {\\n            dp[i] = dp[i-1] % mod;\\n            if(i > 1 && s.charAt(i-1) == s.charAt(i-2)) {\\n                dp[i] += dp[i-2];\\n                dp[i] %= mod;\\n                if(i > 2 && s.charAt(i-1) == s.charAt(i-3)) {\\n                    dp[i] += dp[i-3];\\n                    dp[i] %= mod;\\n                    if(i > 3 && (s.charAt(i-1) == \\'7\\' || s.charAt(i-1) == \\'9\\') && s.charAt(i-1) == s.charAt(i-4)) {\\n                        dp[i] += dp[i-4];\\n                        dp[i] %= mod;\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int[] dp, count;\\n    int mod = 100_000_000_7;\\n    public int countTextsTD(String pressedKeys) {\\n        //need store max length of repeat number that can form a char.    \\n        if(pressedKeys == null || pressedKeys.isEmpty()) return 0;\\n        int n = pressedKeys.length();\\n        count = new int[] {0,0,3,3,3,3,3,4,3,4};\\n        dp = new int[n];        \\n        Arrays.fill(dp, -1);\\n        return dp(pressedKeys, 0, n);\\n    }\\n    //calculated reversely, start from [idx...n] can form how many \\n    private int dp(String s, int idx, int n) {\\n        if(idx == n) return 1;\\n        if(dp[idx] != -1) return dp[idx];\\n        \\n        int res = 0;\\n        char c = s.charAt(idx);\\n        int len = count[c-\\'0\\'];\\n        \\n        for(int i = 0; i < len && idx + i < n && s.charAt(idx + i) == s.charAt(idx); i++) {\\n            // i start with 0, will consider number idx do not combine with previous char.\\n            // i > 1 means, it can be combined with previous number to form a char.\\n            res += dp(s, idx + i + 1, n);\\n            res %= mod;\\n        }\\n        return dp[idx] = res;    \\n    }\\n    \\n    public int countTexts(String s) {\\n        int n = s.length();\\n        int[] dp = new int[n + 1];\\n        dp[0] = 1;\\n        for(int i = 1; i <= n; i++) {\\n            dp[i] = dp[i-1] % mod;\\n            if(i > 1 && s.charAt(i-1) == s.charAt(i-2)) {\\n                dp[i] += dp[i-2];\\n                dp[i] %= mod;\\n                if(i > 2 && s.charAt(i-1) == s.charAt(i-3)) {\\n                    dp[i] += dp[i-3];\\n                    dp[i] %= mod;\\n                    if(i > 3 && (s.charAt(i-1) == \\'7\\' || s.charAt(i-1) == \\'9\\') && s.charAt(i-1) == s.charAt(i-4)) {\\n                        dp[i] += dp[i-4];\\n                        dp[i] %= mod;\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647673,
                "title": "dp-linear",
                "content": "class Solution {\\npublic:\\n    \\n    vector <int> sf;\\n    int mod = 1e9+7;\\n    \\n    int dp[100009];\\n    \\n    int rec(int i,int n,string& s){\\n        \\n        if(i>n)return 0;\\n        if(i==n)return 1;\\n        \\n        if(dp[i]!=-1)return dp[i];\\n        \\n        int ans=0;\\n        \\n        bool flag = (s[i]==\\'2\\') || (s[i]==\\'3\\') || (s[i]==\\'4\\') || (s[i]==\\'5\\') || (s[i]==\\'6\\') || (s[i]==\\'8\\');\\n        \\n        if(flag){\\n            int x = sf[i];\\n            for(int j=1;j<=min(x,3);j++){\\n                ans += rec(i+j,n,s);\\n                ans %= mod;\\n            }\\n        }\\n        \\n        else{\\n                int x = sf[i];\\n            for(int j=1;j<=min(x,4);j++){\\n                ans += rec(i+j,n,s);\\n                ans %= mod;\\n            }  \\n        }\\n        return dp[i]=ans; \\n    }\\n    \\n    int countTexts(string s) {\\n        int n = s.size();\\n        sf = vector <int> (n,0);\\n        sf[n-1]=1;\\n        for(int i=n-2;i>=0;i--){\\n            if(s[i]==s[i+1])sf[i]=sf[i+1]+1;\\n            else sf[i]=1;\\n        }\\n        memset(dp,-1,sizeof(dp));\\n       int ans = rec(0,n,s);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    vector <int> sf;\\n    int mod = 1e9+7;\\n    \\n    int dp[100009];\\n    \\n    int rec(int i,int n,string& s){\\n        \\n        if(i>n)return 0;\\n        if(i==n)return 1;\\n        \\n        if(dp[i]!=-1)return dp[i];\\n        \\n        int ans=0;\\n        \\n        bool flag = (s[i]==\\'2\\') || (s[i]==\\'3\\') || (s[i]==\\'4\\') || (s[i]==\\'5\\') || (s[i]==\\'6\\') || (s[i]==\\'8\\');\\n        \\n        if(flag){\\n            int x = sf[i];\\n            for(int j=1;j<=min(x,3);j++){\\n                ans += rec(i+j,n,s);\\n                ans %= mod;\\n            }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1576725,
                "content": [
                    {
                        "username": "snady",
                        "content": "the descrpition says \"Since the answer may be very large, return it modulo 10^9 + 7.\"\\nfellow python users might think to just return the answer % 10^9 + 7 at the end but this produces an incorrect result, the count should be modded at each iteration... \\n\\nI think the wording of the problem could be improved, unless I\\'m the only one who made this error \\uD83D\\uDE05"
                    },
                    {
                        "username": "joyparikh",
                        "content": "It is a well known result that (a+b)%c = (a%c + b%c)%c. So if you took mod only at the end, or you took mod at intermediate steps and then at the end should give the same result"
                    },
                    {
                        "username": "VehicleOfPuzzle",
                        "content": "I\\'m not sure what solution approach you\\'d be using such that modulo at the end would be an incorrect result. It may lead to very large intermediate calculations but the end result should be the same."
                    },
                    {
                        "username": "lolipop_",
                        "content": "When I run one of the testcases containing a large number of 3s as one of my trial test case, it works. But the same testcase fails when I submit the solution"
                    }
                ]
            },
            {
                "id": 1829036,
                "content": [
                    {
                        "username": "snady",
                        "content": "the descrpition says \"Since the answer may be very large, return it modulo 10^9 + 7.\"\\nfellow python users might think to just return the answer % 10^9 + 7 at the end but this produces an incorrect result, the count should be modded at each iteration... \\n\\nI think the wording of the problem could be improved, unless I\\'m the only one who made this error \\uD83D\\uDE05"
                    },
                    {
                        "username": "joyparikh",
                        "content": "It is a well known result that (a+b)%c = (a%c + b%c)%c. So if you took mod only at the end, or you took mod at intermediate steps and then at the end should give the same result"
                    },
                    {
                        "username": "VehicleOfPuzzle",
                        "content": "I\\'m not sure what solution approach you\\'d be using such that modulo at the end would be an incorrect result. It may lead to very large intermediate calculations but the end result should be the same."
                    },
                    {
                        "username": "lolipop_",
                        "content": "When I run one of the testcases containing a large number of 3s as one of my trial test case, it works. But the same testcase fails when I submit the solution"
                    }
                ]
            }
        ]
    },
    {
        "title": "Steps to Make Array Non-decreasing",
        "question_content": "<p>You are given a <strong>0-indexed</strong> integer array <code>nums</code>. In one step, <strong>remove</strong> all elements <code>nums[i]</code> where <code>nums[i - 1] &gt; nums[i]</code> for all <code>0 &lt; i &lt; nums.length</code>.</p>\n\n<p>Return <em>the number of steps performed until </em><code>nums</code><em> becomes a <strong>non-decreasing</strong> array</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [5,3,4,4,7,3,6,11,8,5,11]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The following are the steps performed:\n- Step 1: [5,<strong><u>3</u></strong>,4,4,7,<u><strong>3</strong></u>,6,11,<u><strong>8</strong></u>,<u><strong>5</strong></u>,11] becomes [5,4,4,7,6,11,11]\n- Step 2: [5,<u><strong>4</strong></u>,4,7,<u><strong>6</strong></u>,11,11] becomes [5,4,7,11,11]\n- Step 3: [5,<u><strong>4</strong></u>,7,11,11] becomes [5,7,11,11]\n[5,7,11,11] is a non-decreasing array. Therefore, we return 3.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [4,5,7,7,13]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> nums is already a non-decreasing array. Therefore, we return 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 2085864,
                "title": "java-c-python-stack-dp-explanation-poem",
                "content": "# **Intuition**\\nIterating the input `A` backward,\\nthen for each `A[i]`, find how many round it can eat on its right.\\n<br>\\n\\n# **Explanation**\\n`dp[i]` means the number of element `A[i]` can eat on its right.\\nMore precisely, the number of rounds for an element `A[i]`,\\nto completely eat whatever it can eat on the right of `A[i]`,\\nif it is possible.\\n\\nIterative input array `A` reversely,\\nIf `A[i]` is bigger the last element `A[j]` of stack,\\nthis means `A[i]` can eat that element,\\nThen update `dp[i]` to be max of `dp[i] + 1` and `dp[j]`.\\n<br>\\n# **Example**\\nTake example of `[10, 1, 2, 9, 1, 2, 3, 4]`\\n10 can eat 1,2 in 2 rounds\\n9 can eat 1,2,3,4 in 4 rounds\\n\\n\"max(++dp[i], dp[stack[j--]]);\"\\nIn this example\\n`dp[i] = 2`,\\n`++dp[i] = 3`\\n`dp[stack[j--] = 4`\\nfinally we got the max rounds `4`.\\n<br>\\n\\n# **Poem**\\nTo understand this process better with a famous Chinese poem:\\n\\n\\u957F\\u6C5F\\u540E\\u6D6A\\u63A8\\u524D\\u6D6A\\uFF0C\\n\\u524D\\u6D6A\\u6B7B\\u5728\\u6C99\\u6EE9\\u4E0A\\u3002\\n\\u540E\\u6D6A\\u7EE7\\u7EED\\u5F80\\u524D\\u63A8\\uFF0C\\n\\u8FD8\\u662F\\u6B7B\\u5728\\u6C99\\u6EE9\\u4E0A\\u3002\\n\\nThe back waves push the front waves,\\nthe front waves die on the beach.\\nThe back waves continue to push forward,\\nstill die on the beach.\\n<br>\\n\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(n)`\\n<br>\\n\\n**Java**\\nUse int array to simulate stack.\\n```java\\n    public int totalSteps(int[] A) {\\n        int n = A.length, res = 0, j = -1;\\n        int dp[] = new int[n], stack[] = new int[n];\\n        for (int i = n - 1; i >= 0; --i) {\\n            while (j >= 0 && A[i] > A[stack[j]]) {\\n                dp[i] = Math.max(++dp[i], dp[stack[j--]]);\\n                res = Math.max(res, dp[i]);\\n            }\\n            stack[++j] = i;\\n        }\\n        return res;\\n    }\\n```\\n**C++**\\n```cpp\\n    int totalSteps(vector<int>& A) {\\n        int n = A.size(), res = 0;\\n        vector<int> stack, dp(n);\\n        for (int i = n - 1; i >= 0; --i) {\\n            while (!stack.empty() && A[i] > A[stack.back()]) {\\n                dp[i] = max(++dp[i], dp[stack.back()]);\\n                stack.pop_back();\\n                res = max(res, dp[i]);\\n            }\\n            stack.push_back(i);\\n        }\\n        return res;\\n    }\\n```\\n**C++**\\nUse int array to simulate stack.\\n```cpp\\n    int totalSteps(vector<int>& A) {\\n        int n = A.size(), res = 0, j = -1;\\n        vector<int> stack(n), dp(n);\\n        for (int i = n - 1; i >= 0; --i) {\\n            while (j >= 0 && A[i] > A[stack[j]]) {\\n                dp[i] = max(++dp[i], dp[stack[j--]]);\\n                res = max(res, dp[i]);\\n            }\\n            stack[++j] = i;\\n        }\\n        return res;\\n    }\\n```\\n**Python**\\n```py\\n    def totalSteps(self, A: List[int]) -> int:\\n        n = len(A)\\n        dp = [0] * n\\n        stack = []\\n        for i in range(n-1, -1, -1):\\n            while stack and A[i] > A[stack[-1]]:\\n                dp[i] = max(dp[i] + 1, dp[stack.pop()])\\n            stack.append(i)\\n        return max(dp)\\n```\\n<br>\\n\\n\\n# **Solution 2: Iterating Forward**\\nWe can solve it by iterating it forward.\\nFor each `A[i]`, we need to find how many round it takes to eat `A[i]`.\\nThis is how I resovled it firstly.\\n\\nTime `O(n)`\\nSpace `O(n)`\\n\\n\\n**Python**\\n```py\\n    def totalSteps(self, A: List[int]) -> int:\\n        dp = [0] * len(A)\\n        stack = []\\n        for i, a in enumerate(A):\\n            cur = 0\\n            while stack and a >= A[stack[-1]]:\\n                cur = max(cur, dp[stack.pop()])\\n            if stack:\\n                dp[i] = cur + 1\\n            stack.append(i)\\n        return max(dp)\\n```\\n<br>\\n\\n\\n# More Good Stack Problems\\nHere are some problems that impressed me.\\nGood luck and have fun.\\n\\n- 2289. [Steps to Make Array Non-decreasing](https://leetcode.com/problems/steps-to-make-array-non-decreasing/discuss/2085864/)\\n- 2281. [Sum of Total Strength of Wizards](https://leetcode.com/problems/sum-of-total-strength-of-wizards/discuss/2061985/python-solution-on/1405190)\\n- 1776. [Car Fleet II](https://leetcode.com/problems/car-fleet-ii/discuss/1085987/javacpython-on-stack-solution/)\\n- 1673. [Find the Most Competitive Subsequence](https://leetcode.com/problems/find-the-most-competitive-subsequence/discuss/952786/javacpython-one-pass-stack-solution/776191 )\\n- 1671. [Minimum Number of Removals to Make Mountain Array](https://leetcode.com/problems/minimum-number-of-removals-to-make-mountain-array/discuss/952136/Python-LIS-O(nlogn))\\n- 1475. [Final Prices With a Special Discount in a Shop](https://leetcode.com/problems/final-prices-with-a-special-discount-in-a-shop/discuss/685390/javacpython-stack-one-pass/809992)\\n- 1425. [Constrained Subsequence Sum](https://leetcode.com/problems/constrained-subsequence-sum/discuss/597751/JavaC++Python-O(N)-Decreasing-Deque)\\n- 1130. [Minimum Cost Tree From Leaf Values](https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/339959/One-Pass-O(N)-Time-and-Space)\\n- 907. [Sum of Subarray Minimums](https://leetcode.com/problems/sum-of-subarray-minimums/discuss/170750/C++JavaPython-Stack-Solution)\\n- 901. [Online Stock Span](https://leetcode.com/problems/online-stock-span/discuss/168311/C++JavaPython-O(1))\\n- 856. [Score of Parentheses](https://leetcode.com/problems/score-of-parentheses/discuss/141777/C++JavaPython-O(1)-Space)\\n- 503. [Next Greater Element II](https://leetcode.com/problems/next-greater-element-ii/discuss/98270/JavaC++Python-Loop-Twice)\\n- 496. Next Greater Element I\\n- 84. Largest Rectangle in Histogram\\n- 42. Trapping Rain Water\\n<br>\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int totalSteps(int[] A) {\\n        int n = A.length, res = 0, j = -1;\\n        int dp[] = new int[n], stack[] = new int[n];\\n        for (int i = n - 1; i >= 0; --i) {\\n            while (j >= 0 && A[i] > A[stack[j]]) {\\n                dp[i] = Math.max(++dp[i], dp[stack[j--]]);\\n                res = Math.max(res, dp[i]);\\n            }\\n            stack[++j] = i;\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int totalSteps(vector<int>& A) {\\n        int n = A.size(), res = 0;\\n        vector<int> stack, dp(n);\\n        for (int i = n - 1; i >= 0; --i) {\\n            while (!stack.empty() && A[i] > A[stack.back()]) {\\n                dp[i] = max(++dp[i], dp[stack.back()]);\\n                stack.pop_back();\\n                res = max(res, dp[i]);\\n            }\\n            stack.push_back(i);\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int totalSteps(vector<int>& A) {\\n        int n = A.size(), res = 0, j = -1;\\n        vector<int> stack(n), dp(n);\\n        for (int i = n - 1; i >= 0; --i) {\\n            while (j >= 0 && A[i] > A[stack[j]]) {\\n                dp[i] = max(++dp[i], dp[stack[j--]]);\\n                res = max(res, dp[i]);\\n            }\\n            stack[++j] = i;\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def totalSteps(self, A: List[int]) -> int:\\n        n = len(A)\\n        dp = [0] * n\\n        stack = []\\n        for i in range(n-1, -1, -1):\\n            while stack and A[i] > A[stack[-1]]:\\n                dp[i] = max(dp[i] + 1, dp[stack.pop()])\\n            stack.append(i)\\n        return max(dp)\\n```\n```py\\n    def totalSteps(self, A: List[int]) -> int:\\n        dp = [0] * len(A)\\n        stack = []\\n        for i, a in enumerate(A):\\n            cur = 0\\n            while stack and a >= A[stack[-1]]:\\n                cur = max(cur, dp[stack.pop()])\\n            if stack:\\n                dp[i] = cur + 1\\n            stack.append(i)\\n        return max(dp)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2085967,
                "title": "python-explanation-with-pictures-stack",
                "content": "Let\\'s start with an example, I use blocks of different height to represent the values:\\n- The 1st number is always here since there is no larger number on its left.\\n- The 2nd number will be removed \\'by\\' the first number in the first step.\\n- The 3rd number will be removed \\'by\\' the second number in the first step.\\n- The 4th number will be removed \\'by\\' the 2nd number, **after** the first step when the 3rd block is removed. Thus the step for the 4th number is `step_for_the_3rd_number + 1 = 2`.\\n\\n\\n![image](https://assets.leetcode.com/users/images/0d9d8d5e-2115-46c4-98c0-fb0d3bac3d12_1653798218.5610669.png)\\n\\nTherefore, for a number `A[i]`, assume the first larger number on its left is `A[lft]`. `A[i]` can only be removed **after** all the numbers within `(lft, i)` are removed, and its step equals the largest step within `(lft, i)` plus 1.\\n\\nThus we can maintain a monotonic decreasing stack, and traverse the array from left to right. For each newly added number `A[i]`, (recall the example at the begining) we need to:\\n>remove the top number from stack that is no larger than `A[i]`, and record the maximum step number from these popped numbers. \\n>\\nUntil we find the first number that is larger than `A[i]`, meaning `A[i]` will be removed \\'by\\' this number in some step, and this step number equals the maximum step number we removed plus 1.\\n\\n- In the picture below, for the number in cyan, we popped the number to be removed in step `2` and step `3`, thus the cyan number will be removed in step `3 + 1`.\\n\\n![image](https://assets.leetcode.com/users/images/b900917d-5720-4a68-8b43-0f70c2210a6e_1653798222.1953542.png)\\n\\n- If we removed every number from stack, meaning the current number `A[i]` is the largest number so far and it will never be removed, thus its step number is `0`. \\n\\n![image](https://assets.leetcode.com/users/images/dd9cc664-2cb6-414f-b8ed-18fe219fae9e_1653798225.6963656.png)\\n\\n\\n\\n\\nThe final walkthrough, the numbers in the stack after each step are colored in dark:\\n\\n![image](https://assets.leetcode.com/users/images/a08cd076-8ca7-4059-a3f1-fc130745676c_1653798229.5009136.png)\\n\\n\\n**python**\\n```\\ndef totalSteps(self, A: List[int]) -> int:    \\n        st = [[A[0], 0]]\\n        ans = 0\\n        \\n        for a in A[1:]:\\n            t = 0\\n            while st and st[-1][0] <= a:\\n                t = max(t, st[-1][1])\\n                st.pop()\\n            if st: \\n                t += 1\\n            else:\\n                t = 0\\n            ans = max(ans, t)\\n            st.append([a, t])\\n            \\n        return ans\\n```\\n\\nYou might notice \\n\\n",
                "solutionTags": [],
                "code": "```\\ndef totalSteps(self, A: List[int]) -> int:    \\n        st = [[A[0], 0]]\\n        ans = 0\\n        \\n        for a in A[1:]:\\n            t = 0\\n            while st and st[-1][0] <= a:\\n                t = max(t, st[-1][1])\\n                st.pop()\\n            if st: \\n                t += 1\\n            else:\\n                t = 0\\n            ans = max(ans, t)\\n            st.append([a, t])\\n            \\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2085653,
                "title": "python3-stack",
                "content": "Consider the list in reversed direction. We record each element and the number of remove operations needed to execute after this element. When we push a new element, compare it with the top element. If it is larger, then we need to perform a remove operation.\\nCode:\\n```\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        ans = 0\\n        nums.reverse()\\n        lst = [[nums[0], 0]]\\n        for i in range(1, len(nums)):\\n            cnt = 0\\n            while lst and lst[-1][0] < nums[i]:\\n                cnt = max(cnt + 1, lst[-1][1])\\n                lst.pop()\\n            lst.append([nums[i], cnt])\\n            ans = max(ans, cnt)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        ans = 0\\n        nums.reverse()\\n        lst = [[nums[0], 0]]\\n        for i in range(1, len(nums)):\\n            cnt = 0\\n            while lst and lst[-1][0] < nums[i]:\\n                cnt = max(cnt + 1, lst[-1][1])\\n                lst.pop()\\n            lst.append([nums[i], cnt])\\n            ans = max(ans, cnt)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2115834,
                "title": "monostack-with-counter",
                "content": "I think that it\\'s a very challenging problem. We need to use two techniques - monostrack and DP - to solve it.\\n\\nThe idea is to go right to left, and build a decreasing strack. When we remove elements from the stack, we count how many elements we removed in `cnt`. Then, we store that count along with the element on the stack. That way, for each element in the stack, we know how many operations are needed to remove all smaller elements after it.\\n\\nIn the example below, we pop 4 smaller elements from the stack before inserting `nums[7]`. We store `nums[7]` in the stack along with the number of popped elements (`4`).\\n\\nNow, the important part. Before inserting `nums[4]`, we pop `nums[5]`, `nums[6]`, and also `nums[7]`. The counter for `nums[7]` is 4 (elements popped for `nums[7]`). So, we need to 4 operations to remove elements `[5..11]`:\\n- `nums[7]` removes `[8, 9]` in two operations, while `nums[4]` removes `[5, 6]`.\\n- `nums[4]` removes `nums[7]` and `nums[7]` removes `[10]` in one operation.\\n- `nums[4]` removes `[11]`.\\n\\nFinally, `nums[4]` removes `nums[12]`  and `nums[13]`, and the total number of operations is 6. Following this logic, we see that the number of operations for `nums[0]` is 7.\\n\\n![image](https://assets.leetcode.com/users/images/323054ae-6c89-480e-8f62-fee3fb84810c_1654498119.7348688.png)\\n\\n**C++**\\n```cpp\\nint totalSteps(vector<int>& nums) {\\n    vector<array<int, 2>> st;\\n    for (int i = nums.size() - 1; i >= 0; --i) {\\n        int cnt = 0;\\n        while (!st.empty() && st.back()[1] < nums[i]) {\\n            cnt = max(cnt + 1, st.back()[0]);\\n            st.pop_back();\\n        }\\n        st.push_back({cnt, nums[i]});\\n    }\\n    return (*max_element(begin(st), end(st)))[0];\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint totalSteps(vector<int>& nums) {\\n    vector<array<int, 2>> st;\\n    for (int i = nums.size() - 1; i >= 0; --i) {\\n        int cnt = 0;\\n        while (!st.empty() && st.back()[1] < nums[i]) {\\n            cnt = max(cnt + 1, st.back()[0]);\\n            st.pop_back();\\n        }\\n        st.push_back({cnt, nums[i]});\\n    }\\n    return (*max_element(begin(st), end(st)))[0];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2086003,
                "title": "no-dp-no-stack-directly-simulate-o-n-log-n",
                "content": "I saw many solutions using stack and dp, which is probably a better solution than mine.\\nHowever, I\\'d like to share an easier solution which requires much less thinking.\\n\\nNotice that the number of deletions is bounded by N. Even if it takes N rounds to reach the end, the total amount of deletions cannot be worse than O(N). \\n\\nLet us use an ordered map to track the relative ordering of the numbers. The key is their original index, and the value is their original value.\\n\\nTo initialize the map, we can populate it with (index, element) key-value pairs. At the same time, we keep track of which indices we need to delete in the first round in an array called `del`.\\n\\nThen, we loop until there is nothing left to delete.\\nIn a single round of deletions, we can remove all the elements in `del`. This will change the \"next\" element of ONLY the one before it in the relative ordering. So, we then consider all the elements whose \"next\" value has changed, and we add new deletions as necessary. \\n\\nAgain, the total amount of deletions is fixed, so no matter how many rounds there are, the complexity will be at worst O(N log N). The ordered map lets us find the \"next\" and \"previous\" elements in log N time, and helps us maintain the relative ordering while we simulate the deletions.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    using pi = pair<int, int>;\\n    int totalSteps(vector<int>& nums) {\\n        int N = nums.size();\\n        map<int, int> mp;\\n        vector<pi> del;    // stores pairs of (previous id, toDelete id)\\n        for (int i = 0; i < N; ++i) {\\n            mp[i] = nums[i];\\n            if (i+1 < N && nums[i] > nums[i+1])\\n                del.emplace_back(i, i+1);\\n        }\\n\\n        int ans = 0;  // number of rounds\\n        while (!del.empty()) {\\n            ++ans;\\n            vector<pi> nxt;  // pairs to delete in the next round\\n            for (auto [i,j] : del) mp.erase(j);   // first, get rid of the required deletions\\n            for (auto [i,j] : del) {\\n                auto it = mp.find(i);\\n                if ( it == end(mp) || next(it) == end(mp) )   // if it\\'s not in the map anymore,\\n                    continue;                   // OR if it\\'s the last element, skip it\\n                auto itn = next(it);            // now compare against next element in the ordering\\n                if (it->second > itn->second)   \\n                    nxt.emplace_back(it->first, itn->first);  // add the (current id, toDelete id)\\n            }\\n            swap(nxt, del);  // nxt is the new del\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    using pi = pair<int, int>;\\n    int totalSteps(vector<int>& nums) {\\n        int N = nums.size();\\n        map<int, int> mp;\\n        vector<pi> del;    // stores pairs of (previous id, toDelete id)\\n        for (int i = 0; i < N; ++i) {\\n            mp[i] = nums[i];\\n            if (i+1 < N && nums[i] > nums[i+1])\\n                del.emplace_back(i, i+1);\\n        }\\n\\n        int ans = 0;  // number of rounds\\n        while (!del.empty()) {\\n            ++ans;\\n            vector<pi> nxt;  // pairs to delete in the next round\\n            for (auto [i,j] : del) mp.erase(j);   // first, get rid of the required deletions\\n            for (auto [i,j] : del) {\\n                auto it = mp.find(i);\\n                if ( it == end(mp) || next(it) == end(mp) )   // if it\\'s not in the map anymore,\\n                    continue;                   // OR if it\\'s the last element, skip it\\n                auto itn = next(it);            // now compare against next element in the ordering\\n                if (it->second > itn->second)   \\n                    nxt.emplace_back(it->first, itn->first);  // add the (current id, toDelete id)\\n            }\\n            swap(nxt, del);  // nxt is the new del\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2090668,
                "title": "explained-solution-for-mere-mortals-100-faster",
                "content": "FIrst rephrase the problem.\\nBig eats small.\\nWhat is maximum number of right elements an element can eat.\\nTake a example [15,14,13]\\nIt seems 15 can eat 2 elements, but 14 will eat 13 while 15 is eating 14.\\nHence answer is 1\\nTake another example [16,15,13,14]\\nWhile 16 is eating 15, 15 will eat 13 and 14 will be left to be eaten by 16.\\nHence answer is 2.\\nTake another example [16,4,5,6,13,12]\\nWhile 16 will eat 4,5 and 6, 13 would have already eaten 12, hence answer is 4.\\n\\nWe maintain a stack which stores elements in decreasing order from back.\\nWHY? Because if some biggger number comes, it will eat smaller ones and we will do some calculations there.\\nWHAT calculations? If current element is bigger than top of stack, what does it mean?\\nIt can eat it, so what will be answer? Max of number of elements already eaten by current element + 1 and max elements that top of stack can eat if current element doesn\\'t eat it.\\n\\nRead that element lots of times, it\\'s hard to understand.\\n```                maxEat[i] = max(maxEat[i]+1, maxEat[s.top()]);```\\nHere I was struggling to understand\\nIf bigger element has already eaten 3 elements and now is going to eat\\nsmaller element which has already eaten 4 elements\\nWhy answer won\\'t be 3+4?\\nBecause everyone is eating simultaneuosly, while bigger was eating other 3 elements\\nsmaller was eating other three too, then what\\'s left now for bigger element is only smaller element, not the elements smaller than smaller element.\\n\\nBelow is my code:\\n\\n```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        vector<int> maxEat(nums.size()); \\n        stack<int> st;\\n        int steps = 0; \\n        for(int i = nums.size()-1 ; i>=0 ; i--){\\n            while(!st.empty() && nums[i] > nums[s.top()]){\\n                maxEat[i] = max(maxEat[i]+1, maxEat[s.top()]);\\n\\t\\t\\t\\tst.pop();\\n            }\\n            st.push(i);\\n            steps = max(steps, maxEat[i]);\\n        }\\n        return steps;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```                maxEat[i] = max(maxEat[i]+1, maxEat[s.top()]);```",
                "codeTag": "Unknown"
            },
            {
                "id": 2290383,
                "title": "detailed-intuitive-explanation",
                "content": "Don\\'t think of any algo or data structure at first, let\\'s build the solution from scratch \\uD83D\\uDE0E\\n\\nlet\\'s see few test cases\\n\\n[10, 4, 5, 6]\\n\\nlet\\'s go from left to right\\nas 10 > 4 so in round 1, 4 will be removed,\\n10>5, remove 5 in round 2\\n10>6, remove 6 in round 3\\n\\nSo using just above test case while going left to right you can observe 1 thing\\n   1) As 10 was greater than 4,5,6 so it will remove everyone who is lesser than 10 to it\\'s right\\n   \\n\\uD835\\uDDDC\\uD835\\uDE00 \\uD835\\uDDEE\\uD835\\uDDEF\\uD835\\uDDFC\\uD835\\uDE03\\uD835\\uDDF2 \\uD835\\uDDFC\\uD835\\uDDEF\\uD835\\uDE00\\uD835\\uDDF2\\uD835\\uDDFF\\uD835\\uDE03\\uD835\\uDDEE\\uD835\\uDE01\\uD835\\uDDF6\\uD835\\uDDFC\\uD835\\uDDFB \\uD835\\uDE03\\uD835\\uDDEE\\uD835\\uDDF9\\uD835\\uDDF6\\uD835\\uDDF1 \\uD835\\uDDF3\\uD835\\uDDFC\\uD835\\uDDFF \\uD835\\uDDEE\\uD835\\uDDF9\\uD835\\uDDF9 \\uD835\\uDE01\\uD835\\uDDF2\\uD835\\uDE00\\uD835\\uDE01 \\uD835\\uDDF0\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDDF2\\uD835\\uDE00 ?\\n\\n let\\'s see 1 more test case\\n\\n[10, 4, 5, 6, 3, 4]\\n\\nAs per our initial observation, 10 is greater than all 5 elements so it should remove all 5 and thus our answer should be 5 (\\uD835\\uDDF6\\uD835\\uDE00 \\uD835\\uDDF6\\uD835\\uDE01 \\uD835\\uDE01\\uD835\\uDDFF\\uD835\\uDE02\\uD835\\uDDF2 ??)\\n\\nremember the condition -> \\uD835\\uDDF6\\uD835\\uDDF3(\\uD835\\uDDFB\\uD835\\uDE02\\uD835\\uDDFA\\uD835\\uDE00[\\uD835\\uDDF6-\\uD835\\uDFED] > \\uD835\\uDDFB\\uD835\\uDE02\\uD835\\uDDFA\\uD835\\uDE00[\\uD835\\uDDF6]) \\uD835\\uDDFF\\uD835\\uDDF2\\uD835\\uDDFA\\uD835\\uDDFC\\uD835\\uDE03\\uD835\\uDDF2 \\uD835\\uDDFB\\uD835\\uDE02\\uD835\\uDDFA\\uD835\\uDE00[\\uD835\\uDDF6]\\n\\nSee the 4th element (6) as 6 > 3 & 6 > 4,\\nso 6 would remove both 3 & 4 in 2 rounds, 10 should remove 4,5,6 in 3 rounds so total 3 rounds are required\\n\\nNow what can we conclude from above test case ??\\n   1) Instead of going from l to r, we would go r to l (else we would get higher no. of rounds)\\n\\n[10, 4, 5, 6, 3, 4]\\n\\nlets start from rightmost element , we encounter 3,4 then 6\\nWhen we get 6 which is greater than 3,4 & will remove them thus 3,4 should be removed(popped) which also tells us to use \\n\\uD835\\uDE00\\uD835\\uDE01\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF8 \\uD835\\uDDF1\\uD835\\uDDEE\\uD835\\uDE01\\uD835\\uDDEE \\uD835\\uDE00\\uD835\\uDE01\\uD835\\uDDFF\\uD835\\uDE02\\uD835\\uDDF0\\uD835\\uDE01\\uD835\\uDE02\\uD835\\uDDFF\\uD835\\uDDF2\\n\\nSo what all we got till now\\n\\t 1) Start from right\\n\\t 2) Use stack\\n\\t 3) For every nums[i] count all the elements less than it & remove these elements\\n\\t 4) Finally push nums[i]\\n\\nHere comes an \\uD835\\uDDF2\\uD835\\uDDF1\\uD835\\uDDF4\\uD835\\uDDF2 \\uD835\\uDDF0\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDDF2\\uD83D\\uDE0E\\n\\nnums[]                              = [10, 6, 4, 5, 8]\\n\\ngoing r to l\\n6 removes 4,5 in 2 rounds (mark this point) \\u26A0\\nnow, 10 will remove 6 & 8, so it\\'s should take 2 rounds right ???\\n\\nsee below array configuration till we reach 6 (r to l)\\n\\nnums[]                              = [10, 6, 4, 5, 8]\\ncountRemovedByNum[i] =  [ -, 2, 0, 0, 0]\\n\\nwhen you are at 10 (it removes 6 in 1st round while 6 removed 4,5 in 2 round, so overall we took 2 rounds to remove [6,4,5] so in 3rd round 8 will be removed) (i know it\\'s a bit confusing \\uD83D\\uDE05 but read it few times)\\n\\nSo in above test case when 10 removed 6 (r to l in stack) total rounds for 10 should be 2 not 1 (2 because 6 removed 4,5 in 2 rounds), so when 10 removes 8 we do round + 1 i.e. 2+1 = 3 (our answer)\\n\\nFinally using above test case we improvise our previous observations as\\n\\t1) Start from right\\n\\t 2) Use stack (insert pair<int, int> of num[i], cnt of rounds )\\n\\t 3) For every nums[i] count all the elements less than it & remove these elements\\n\\t 4) Finally push nums[i]\\n\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        \\n        stack<pair<int, int>> stk;\\n        \\n        int cnt = 0;\\n        int res = 0;\\n        \\n        for(int i = nums.size() - 1;i >= 0;i--) {\\n        \\n            cnt = 0;\\n            \\n            while(!stk.empty() && nums[i] > stk.top().first) {\\n                cnt = max(cnt+1, stk.top().second);\\n                stk.pop();\\n            }\\n            res = max(res, cnt);\\n            stk.push({nums[i], cnt});\\n            \\n        }\\n        return res;\\n    }\\n};\\n\\nps-> do upvote if you like the explanation & plss ignore typos (if any)\\n",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        \\n        stack<pair<int, int>> stk;\\n        \\n        int cnt = 0;\\n        int res = 0;\\n        \\n        for(int i = nums.size() - 1;i >= 0;i--) {\\n        \\n            cnt = 0;\\n            \\n            while(!stk.empty() && nums[i] > stk.top().first) {\\n                cnt = max(cnt+1, stk.top().second);\\n                stk.pop();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2085764,
                "title": "c-easy-o-n-with-monotonic-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) \\n    {\\n        int n=nums.size(),i,ans=0,cnt,prev;\\n        stack <pair<int,int>> st;\\n        st.push({nums[n-1],0});\\n        for(i=n-2;i>=0;i--)\\n        {\\n            cnt=0;\\n            while(!st.empty() && nums[i]>st.top().first)\\n            {\\n                cnt=max(cnt+1,st.top().second);\\n                st.pop();\\n            }\\n            ans=max(ans,cnt);\\n            st.push({nums[i],cnt});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) \\n    {\\n        int n=nums.size(),i,ans=0,cnt,prev;\\n        stack <pair<int,int>> st;\\n        st.push({nums[n-1],0});\\n        for(i=n-2;i>=0;i--)\\n        {\\n            cnt=0;\\n            while(!st.empty() && nums[i]>st.top().first)\\n            {\\n                cnt=max(cnt+1,st.top().second);\\n                st.pop();\\n            }\\n            ans=max(ans,cnt);\\n            st.push({nums[i],cnt});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085808,
                "title": "java-mono-stack-o-n",
                "content": "traverse from back. If number in stack less than current number, count into removal steps. If removal steps in stack great than current count, that difference need be added to current count as that stack number already removal by current number before it removal rest of other numbers.\\n```\\n    public int totalSteps(int[] nums) {\\n        int ans = 0;\\n        Stack<int[]> stack = new Stack<int[]>();\\n        for(int i = nums.length-1; i >= 0; i--) {\\n            if(stack.isEmpty() || stack.peek()[0] >= nums[i]) {\\n                stack.push(new int[]{nums[i], 0});\\n            }else{\\n                int count = 0;\\n                while(!stack.isEmpty() && stack.peek()[0] < nums[i]) {\\n                    count++;\\n                    int[] item = stack.pop();\\n                    if(count < item[1]) count += (item[1] - count);\\n                }\\n                stack.push(new int[]{nums[i], count});\\n                ans = Math.max(ans, count);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int totalSteps(int[] nums) {\\n        int ans = 0;\\n        Stack<int[]> stack = new Stack<int[]>();\\n        for(int i = nums.length-1; i >= 0; i--) {\\n            if(stack.isEmpty() || stack.peek()[0] >= nums[i]) {\\n                stack.push(new int[]{nums[i], 0});\\n            }else{\\n                int count = 0;\\n                while(!stack.isEmpty() && stack.peek()[0] < nums[i]) {\\n                    count++;\\n                    int[] item = stack.pop();\\n                    if(count < item[1]) count += (item[1] - count);\\n                }\\n                stack.push(new int[]{nums[i], count});\\n                ans = Math.max(ans, count);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2086026,
                "title": "o-n-simulation-no-stack-with-commented-python-code",
                "content": "We literally just simulate the process of numbers \"eating\" smaller numbers to the right. \\nWe maintain a list of numbers that are still active(still eating)\\nEvery time a number eats the number to its right, it jumps to that index. So if index 5 eats index 6, this number jumps to index 6.\\n\\nThe difficult part to get is that what if the number at index 6 is at say index 8 ? We jump index 5 to index 8, ie index[index[6]]\\nthis makes sure that index 5 doesnt re-eat the numbers that 6 ate, and also index 5 can continue eating from where index 6 left off.\\n\\nThe time complexity is O(n) as every number gets eaten only once\\n\\nlmk if this explanation is not clear, i will re-write it\\n\\n```\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        \\n        # length of the array\\n        n = len(nums)\\n        \\n        # current index of each element in the simulation\\n        index = [i for i in range(n)]\\n        \\n        # number of elements swallowed by the number at index i\\n        count = [0 for i in range(n)]\\n        \\n        # list of all actively swallowing indices\\n        active = [i for i in reversed(range(n))]\\n        \\n        while(len(active) > 0):\\n            new_active = []\\n            for i in active:\\n                num = nums[i]\\n                cur_index = index[i]\\n                \\n                # either this index has reached the end of the array or has encountered a larger element\\n                if cur_index == n - 1 or nums[cur_index + 1] >= num:\\n                    continue\\n                \\n                # this element has just swallowed, it\\'s still active\\n                new_active.append(i)\\n                \\n                # IMPORTANT\\n                # jump this numbers index to the index of who he just swallowed\\n                index[i] = index[cur_index + 1]\\n                count[i] += 1\\n                \\n            # update the list of active indices\\n            active = new_active\\n        \\n        # return the max number of swallows\\n        return max(count)\\n```",
                "solutionTags": [
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        \\n        # length of the array\\n        n = len(nums)\\n        \\n        # current index of each element in the simulation\\n        index = [i for i in range(n)]\\n        \\n        # number of elements swallowed by the number at index i\\n        count = [0 for i in range(n)]\\n        \\n        # list of all actively swallowing indices\\n        active = [i for i in reversed(range(n))]\\n        \\n        while(len(active) > 0):\\n            new_active = []\\n            for i in active:\\n                num = nums[i]\\n                cur_index = index[i]\\n                \\n                # either this index has reached the end of the array or has encountered a larger element\\n                if cur_index == n - 1 or nums[cur_index + 1] >= num:\\n                    continue\\n                \\n                # this element has just swallowed, it\\'s still active\\n                new_active.append(i)\\n                \\n                # IMPORTANT\\n                # jump this numbers index to the index of who he just swallowed\\n                index[i] = index[cur_index + 1]\\n                count[i] += 1\\n                \\n            # update the list of active indices\\n            active = new_active\\n        \\n        # return the max number of swallows\\n        return max(count)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2424650,
                "title": "best-solution-explain-in-c-dry-run",
                "content": "lets take example as \\n[ 14 , 2 , 6 , 8 , 10 , 15 , 4 , 9 , 10 , 6 , 10 , 10 , 12 , 9 , 1 ] \\n\\nnow lets see a intution first  \\n\\na = 14             ans = 0 [  already decreasing ]\\n\\na =  14 , 2       ans = 1   [ remove 2] \\n\\na = 14 , 2 , 6   ans = 2  [ remove 2 , 6] \\n\\na = 14 , 2 , 6 , 8   ans = 3  [ remove  2 , 6 , 8 ] \\n\\na = 14 , 2 , 6 , 8 , 10  ans = 4 [ remove 2 , 6 , 8 , 10 ] \\n\\na = 14 , 2, 6 , 8 , 10 , 15   ans = 4  [ remove 2 , 6 , 8 , 10 ]   => 14 15    [ non - decreasing ] \\n\\na = 14 , 2 , 6 , 8 , 10 , 15 , 4   ans = 4    \\n\\nnow here we can see that we can parallely kill 4 in our first step  of killing 2  \\n\\nbasically , \\n\\n![image](https://assets.leetcode.com/users/images/a94601dc-0223-44bd-8e21-7a12ee9bfaab_1660480151.7467067.png)\\n\\nso clearly our ans = 4 in this case as well \\n\\nlets continue \\n\\na = 14, 2 ,6 , 8 , 10 , 15 , 4  , 9   ans = 4  \\nas 4 , 9  will be removed along with 2 , 6 and then 8 , 10  will be removed  \\n\\na = 14 , 2 , 6 , 8 , 10 , 15 , 4 , 9 , 10    ans =  4 \\nas 4 ,9 , 10 will be simulatenously removed along with 2 , 6 , 8  and then  10  will be removed  \\n\\nnow  lets add upto 3 more values \\n\\n\\na =  14 , 2 , 6, 8 , 10 , 15 , 4 , 9 , 10 , 6 , 10 , 10 , 10 \\n\\n![image](https://assets.leetcode.com/users/images/372ca49b-2a0d-4158-b298-7d6ab0bba9da_1660480403.3717368.png)\\n\\nnow here simulatenosuly 2  , 4 , 6 will be removed and then we can see that \\nbefore 15 we have to remove 3 more elements and after 15 we have to removed 5 more elements \\n\\n\\nso hopefully the intution is build  -> basically we will see like this whenever we find at index i \\nsuch that a[i - 1 ] > a[i]  we start deleting it parallely and we find the region where max deletion happens and that becomes our ans \\n\\n\\nnow so we can see that we need to know the next greater element here and as well as we have to know the result from the previous situation \\n\\nso we introduce dp in our ans now  \\n\\nwe create a dp table and at each state we store the answer for the remaning values to the right \\n\\n![image](https://assets.leetcode.com/users/images/78019bbc-eccb-487b-816b-994f0a673fde_1660480824.4858902.png)\\n\\nnow lets start our iteration one by one  \\n\\n\\nhere  number of elements (n ) = 15 \\n\\nso we start  our loop from behind and maintain a stack to find the next greater element [you should be aware about next greater element , otherwise you wont get a feel of what is happening next ] \\n\\n\\n![image](https://assets.leetcode.com/users/images/81c15022-175e-4c1c-8e07-28d05de31fa3_1660481004.4170446.png)\\nhere is our solution  which we will dry run now  \\n\\n\\n# i = 14 \\nstack  =  [  14 ] \\n\\n\\n\\n\\ndp table \\n\\n![image](https://assets.leetcode.com/users/images/680de1d3-d462-418a-a65f-d83a9c6d013d_1660481104.849981.png)\\n\\n\\n\\n\\n# i = 13  \\n\\n9 > 1  so we will enter into our condition  \\n\\ns.top = 14 \\n\\nhere we basically want to delete our next element and compare it with the ans for that element \\n\\n\\nso  dp[13] = max( dp[13] + 1 , dp[ 14] ) ;\\n\\nand we removed 14 from stack and push 13  now \\n\\nstack =  [ 13] \\n\\ndp table \\n![image](https://assets.leetcode.com/users/images/d6fb2dbb-9cc1-4187-bc59-e61943955fa2_1660481220.6860945.png)\\n\\n \\n# i = 12   \\nnow 12 > 9    \\nso we again move into the condition \\nand same we compare our ans for the element at top and our ans with our index + 1  for deleting the top element \\n\\nso dp[12] = max(dp[12] + 1 , dp[13]  \\n\\nnow at dp[13] = 1 \\nand dp[12] + 1  = 1 \\nso dp[12]  = 1  \\nand remove  13 \\n\\ndp table \\n![image](https://assets.leetcode.com/users/images/baf28c6b-d21d-487c-b54d-5268f4a30cf0_1660481355.0549781.png)\\n\\n# i = 11 \\n\\n10 < 12 \\nso push it  \\n\\nstack =  [ 11 , 12 ] \\n\\n\\n# i = 10  \\n10 ! > 10 \\n\\nso push it  \\n\\n\\nstack =   [10 , 11 , 12 ] \\n\\n\\n# i =  9 \\n\\n9 < 10 \\npush it  \\n\\nstack = [ 9 , 10 , 11 , 12 ] \\n\\n# i = 8 \\n \\n10 > 6 \\n\\nwe enter into the conditon st.top = 9 \\n\\ndp[8] = max(dp[8] + 1 , dp[9]) \\n\\ndp[8] = 1 \\n\\nremove  9  from the stack and push 8 \\n\\nstack  = [ 8 , 10 , 11 , 12]  \\n\\ndp table \\n\\n![image](https://assets.leetcode.com/users/images/2f91aa0b-edf8-402a-b4ab-6f37c15323d1_1660481819.2037504.png)\\n\\n\\n# i = 7 \\n\\n9 < 10 \\n\\npush 7  \\n\\nstack = [ 7 , 8  , 10 , 11 , 12 ] \\n\\n# i = 6   \\n\\n4 < 9 \\n\\npush 6 \\n\\nstack =  [ 6 , 7 , 8 , 10 , 11 , 12 ] \\n\\ndp table \\n\\n![image](https://assets.leetcode.com/users/images/44be38f2-6f15-49f0-8c28-4f1b03a89f99_1660481964.5189054.png)\\n\\n\\n# i = 5 [very important part now ]\\n\\nnow  15 > 4  \\n\\ncondition is ok  \\n\\ndp[5]  = max(dp[5] + 1 , dp[6]) \\n\\ndp[5] = 1  \\n\\nremove 6 \\n\\nstack = [ 7 ,  8 , 10 , 11 , 12] \\ndp table  \\n\\n\\n![image](https://assets.leetcode.com/users/images/c897ecf8-4b0f-4999-9377-cc566d2bd4c4_1660482012.5437205.png)\\n\\n\\n\\n\\n15 > 9  \\n\\ncondition ok  \\n\\ndp[5] = max(dp[5] + 1 , dp[7]) \\n\\ndp[5] = max( 2 , 0) \\n\\ndp[5] = 2 \\n\\n\\nremove 7  from stack  \\n\\n\\nstack =  [ 8 , 10 , 11 , 12 ] \\n\\ndp table  \\n\\n![image](https://assets.leetcode.com/users/images/c4aaf549-59e0-4f79-a5c4-cb28f8b5abda_1660482116.5252256.png)\\n\\n\\n15 > 10  \\nconditon ok again  \\n\\ndp[5] = max(dp[5] + 1 , dp[8]);\\n\\ndp[5]  = max ( 3 , 1 ) \\n\\ndp[5] = 3  \\n\\nremove 8 from stack \\n\\nstack = [10 , 11 , 12 ] \\n\\ndp table \\n![image](https://assets.leetcode.com/users/images/61eb09c0-17f8-4556-8801-fe496228c22e_1660482228.8710887.png)\\n\\n15 > 10   \\n\\nconditon ok again  \\n\\ndp[5] = max(dp[5] + 1 , dp[10]) ; =  max( 4 , 1 ) = 4 \\n\\n\\nremove 10  from stack \\n\\nstack =  [ 11,  12 ] \\n\\ndp table  \\n\\n![image](https://assets.leetcode.com/users/images/89d17b1c-4cb1-4e9e-b552-17546898ebb3_1660482560.42895.png)\\n\\n\\n15 > 10  \\n\\nconditon ok \\n\\ndp[5] = max(dp[5] + 1 , dp[11]) =  max( 5, 1 )  = 5 \\n\\ndp[5] = 5  \\n\\nremove 11 from stack  \\nstack =  [12 ]  \\ndp table \\n![image](https://assets.leetcode.com/users/images/b9529cd8-7285-47df-a6f9-81b28d057ade_1660482620.131915.png)\\n\\n\\n15  > 12   \\ncondition ok  \\n\\ndp[5] = max(dp[5] + 1 , dp[12]) =  6  \\n\\ndp[5] = 6 \\n\\nremove 12 from stack    and add 5   \\n\\nstack =  [5] \\n\\ndp table  \\n![image](https://assets.leetcode.com/users/images/6e25146d-32a8-4375-97e5-cf029cc56027_1660482711.8644836.png)\\n\\n\\n# i = 4  \\n\\n10 < 15  \\n\\npush  into stack  \\nstack = [4  , 5 ] \\n\\n# i = 3 \\n8 < 10 \\n\\npush into stack  = [ 3 , 4 , 5]  \\n\\n\\n# i = 2 \\n\\n6 < 8 \\npush into stack    =  [ 2 , 3 , 4 , 5 ] \\n\\n# i = 1  \\n\\n2 < 6  \\npush into stack  =  [ 1 , 2 , 3 , 4 , 5 ] \\n\\n\\n# i = 0     \\n\\n14 >  2 \\nconditon ok  \\ndp[0] = max(dp[0] + 1 , dp[1] ) \\n\\npop 1 from stack   stack =  [  2,  3 , 4 , 5 ]  \\n\\nsimilary 14 > 6 , 14 > 8 , 14 > 10  \\n\\nwill give dp[0] =  1 + 1 + 1 +1   = 4 \\n\\nand finally our solution ends at 15  \\nand loop breaks  \\n\\n\\nfinal dp  table  : \\n\\n![image](https://assets.leetcode.com/users/images/2dfec10e-9041-4d88-bb0c-022e635a3ccb_1660482933.3569784.png)\\n\\n\\nour ans = max of dp  table = 6   which is our ans  \\n\\n\\nverification : \\n\\n![image](https://assets.leetcode.com/users/images/3812492e-b1eb-42b6-a083-c1dd7983d378_1660483204.8307915.png)\\n\\n\\n\\nhence this solution is done now  !   \\n\\n\\nthis took a lot of efffort if you find it useful please share your thoughts   \\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Stack",
                    "Queue"
                ],
                "code": "lets take example as \\n[ 14 , 2 , 6 , 8 , 10 , 15 , 4 , 9 , 10 , 6 , 10 , 10 , 12 , 9 , 1 ] \\n\\nnow lets see a intution first  \\n\\na = 14             ans = 0 [  already decreasing ]\\n\\na =  14 , 2       ans = 1   [ remove 2] \\n\\na = 14 , 2 , 6   ans = 2  [ remove 2 , 6] \\n\\na = 14 , 2 , 6 , 8   ans = 3  [ remove  2 , 6 , 8 ] \\n\\na = 14 , 2 , 6 , 8 , 10  ans = 4 [ remove 2 , 6 , 8 , 10 ] \\n\\na = 14 , 2, 6 , 8 , 10 , 15   ans = 4  [ remove 2 , 6 , 8 , 10 ]   => 14 15    [ non - decreasing ] \\n\\na = 14 , 2 , 6 , 8 , 10 , 15 , 4   ans = 4    \\n\\nnow here we can see that we can parallely kill 4 in our first step  of killing 2  \\n\\nbasically , \\n\\n![image](https://assets.leetcode.com/users/images/a94601dc-0223-44bd-8e21-7a12ee9bfaab_1660480151.7467067.png)\\n\\nso clearly our ans = 4 in this case as well \\n\\nlets continue \\n\\na = 14, 2 ,6 , 8 , 10 , 15 , 4  , 9   ans = 4  \\nas 4 , 9  will be removed along with 2 , 6 and then 8 , 10  will be removed  \\n\\na = 14 , 2 , 6 , 8 , 10 , 15 , 4 , 9 , 10    ans =  4 \\nas 4 ,9 , 10 will be simulatenously removed along with 2 , 6 , 8  and then  10  will be removed  \\n\\nnow  lets add upto 3 more values \\n\\n\\na =  14 , 2 , 6, 8 , 10 , 15 , 4 , 9 , 10 , 6 , 10 , 10 , 10 \\n\\n![image](https://assets.leetcode.com/users/images/372ca49b-2a0d-4158-b298-7d6ab0bba9da_1660480403.3717368.png)\\n\\nnow here simulatenosuly 2  , 4 , 6 will be removed and then we can see that \\nbefore 15 we have to remove 3 more elements and after 15 we have to removed 5 more elements \\n\\n\\nso hopefully the intution is build  -> basically we will see like this whenever we find at index i \\nsuch that a[i - 1 ] > a[i]  we start deleting it parallely and we find the region where max deletion happens and that becomes our ans \\n\\n\\nnow so we can see that we need to know the next greater element here and as well as we have to know the result from the previous situation \\n\\nso we introduce dp in our ans now  \\n\\nwe create a dp table and at each state we store the answer for the remaning values to the right \\n\\n![image](https://assets.leetcode.com/users/images/78019bbc-eccb-487b-816b-994f0a673fde_1660480824.4858902.png)\\n\\nnow lets start our iteration one by one  \\n\\n\\nhere  number of elements (n ) = 15 \\n\\nso we start  our loop from behind and maintain a stack to find the next greater element [you should be aware about next greater element , otherwise you wont get a feel of what is happening next ] \\n\\n\\n![image](https://assets.leetcode.com/users/images/81c15022-175e-4c1c-8e07-28d05de31fa3_1660481004.4170446.png)\\nhere is our solution  which we will dry run now  \\n\\n\\n# i = 14 \\nstack  =  [  14 ] \\n\\n\\n\\n\\ndp table \\n\\n![image](https://assets.leetcode.com/users/images/680de1d3-d462-418a-a65f-d83a9c6d013d_1660481104.849981.png)\\n\\n\\n\\n\\n# i = 13  \\n\\n9 > 1  so we will enter into our condition  \\n\\ns.top = 14 \\n\\nhere we basically want to delete our next element and compare it with the ans for that element \\n\\n\\nso  dp[13] = max( dp[13] + 1 , dp[ 14] ) ;\\n\\nand we removed 14 from stack and push 13  now \\n\\nstack =  [ 13] \\n\\ndp table \\n![image](https://assets.leetcode.com/users/images/d6fb2dbb-9cc1-4187-bc59-e61943955fa2_1660481220.6860945.png)\\n\\n \\n# i = 12   \\nnow 12 > 9    \\nso we again move into the condition \\nand same we compare our ans for the element at top and our ans with our index + 1  for deleting the top element \\n\\nso dp[12] = max(dp[12] + 1 , dp[13]  \\n\\nnow at dp[13] = 1 \\nand dp[12] + 1  = 1 \\nso dp[12]  = 1  \\nand remove  13 \\n\\ndp table \\n![image](https://assets.leetcode.com/users/images/baf28c6b-d21d-487c-b54d-5268f4a30cf0_1660481355.0549781.png)\\n\\n# i = 11 \\n\\n10 < 12 \\nso push it  \\n\\nstack =  [ 11 , 12 ] \\n\\n\\n# i = 10  \\n10 ! > 10 \\n\\nso push it  \\n\\n\\nstack =   [10 , 11 , 12 ] \\n\\n\\n# i =  9 \\n\\n9 < 10 \\npush it  \\n\\nstack = [ 9 , 10 , 11 , 12 ] \\n\\n# i = 8 \\n \\n10 > 6 \\n\\nwe enter into the conditon st.top = 9 \\n\\ndp[8] = max(dp[8] + 1 , dp[9]) \\n\\ndp[8] = 1 \\n\\nremove  9  from the stack and push 8 \\n\\nstack  = [ 8 , 10 , 11 , 12]  \\n\\ndp table \\n\\n![image](https://assets.leetcode.com/users/images/2f91aa0b-edf8-402a-b4ab-6f37c15323d1_1660481819.2037504.png)\\n\\n\\n# i = 7 \\n\\n9 < 10 \\n\\npush 7  \\n\\nstack = [ 7 , 8  , 10 , 11 , 12 ] \\n\\n# i = 6   \\n\\n4 < 9 \\n\\npush 6 \\n\\nstack =  [ 6 , 7 , 8 , 10 , 11 , 12 ] \\n\\ndp table \\n\\n![image](https://assets.leetcode.com/users/images/44be38f2-6f15-49f0-8c28-4f1b03a89f99_1660481964.5189054.png)\\n\\n\\n# i = 5 [very important part now ]\\n\\nnow  15 > 4  \\n\\ncondition is ok  \\n\\ndp[5]  = max(dp[5] + 1 , dp[6]) \\n\\ndp[5] = 1  \\n\\nremove 6 \\n\\nstack = [ 7 ,  8 , 10 , 11 , 12] \\ndp table  \\n\\n\\n![image](https://assets.leetcode.com/users/images/c897ecf8-4b0f-4999-9377-cc566d2bd4c4_1660482012.5437205.png)\\n\\n\\n\\n\\n15 > 9  \\n\\ncondition ok  \\n\\ndp[5] = max(dp[5] + 1 , dp[7]) \\n\\ndp[5] = max( 2 , 0) \\n\\ndp[5] = 2 \\n\\n\\nremove 7  from stack  \\n\\n\\nstack =  [ 8 , 10 , 11 , 12 ] \\n\\ndp table  \\n\\n![image](https://assets.leetcode.com/users/images/c4aaf549-59e0-4f79-a5c4-cb28f8b5abda_1660482116.5252256.png)\\n\\n\\n15 > 10  \\nconditon ok again  \\n\\ndp[5] = max(dp[5] + 1 , dp[8]);\\n\\ndp[5]  = max ( 3 , 1 ) \\n\\ndp[5] = 3  \\n\\nremove 8 from stack \\n\\nstack = [10 , 11 , 12 ] \\n\\ndp table \\n![image](https://assets.leetcode.com/users/images/61eb09c0-17f8-4556-8801-fe496228c22e_1660482228.8710887.png)\\n\\n15 > 10   \\n\\nconditon ok again  \\n\\ndp[5] = max(dp[5] + 1 , dp[10]) ; =  max( 4 , 1 ) = 4 \\n\\n\\nremove 10  from stack \\n\\nstack =  [ 11,  12 ] \\n\\ndp table  \\n\\n![image](https://assets.leetcode.com/users/images/89d17b1c-4cb1-4e9e-b552-17546898ebb3_1660482560.42895.png)\\n\\n\\n15 > 10  \\n\\nconditon ok \\n\\ndp[5] = max(dp[5] + 1 , dp[11]) =  max( 5, 1 )  = 5 \\n\\ndp[5] = 5  \\n\\nremove 11 from stack  \\nstack =  [12 ]  \\ndp table \\n![image](https://assets.leetcode.com/users/images/b9529cd8-7285-47df-a6f9-81b28d057ade_1660482620.131915.png)\\n\\n\\n15  > 12   \\ncondition ok  \\n\\ndp[5] = max(dp[5] + 1 , dp[12]) =  6  \\n\\ndp[5] = 6 \\n\\nremove 12 from stack    and add 5   \\n\\nstack =  [5] \\n\\ndp table  \\n![image](https://assets.leetcode.com/users/images/6e25146d-32a8-4375-97e5-cf029cc56027_1660482711.8644836.png)\\n\\n\\n# i = 4  \\n\\n10 < 15  \\n\\npush  into stack  \\nstack = [4  , 5 ] \\n\\n# i = 3 \\n8 < 10 \\n\\npush into stack  = [ 3 , 4 , 5]  \\n\\n\\n# i = 2 \\n\\n6 < 8 \\npush into stack    =  [ 2 , 3 , 4 , 5 ] \\n\\n# i = 1  \\n\\n2 < 6  \\npush into stack  =  [ 1 , 2 , 3 , 4 , 5 ] \\n\\n\\n# i = 0     \\n\\n14 >  2 \\nconditon ok  \\ndp[0] = max(dp[0] + 1 , dp[1] ) \\n\\npop 1 from stack   stack =  [  2,  3 , 4 , 5 ]  \\n\\nsimilary 14 > 6 , 14 > 8 , 14 > 10  \\n\\nwill give dp[0] =  1 + 1 + 1 +1   = 4 \\n\\nand finally our solution ends at 15  \\nand loop breaks  \\n\\n\\nfinal dp  table  : \\n\\n![image](https://assets.leetcode.com/users/images/2dfec10e-9041-4d88-bb0c-022e635a3ccb_1660482933.3569784.png)\\n\\n\\nour ans = max of dp  table = 6   which is our ans  \\n\\n\\nverification : \\n\\n![image](https://assets.leetcode.com/users/images/3812492e-b1eb-42b6-a083-c1dd7983d378_1660483204.8307915.png)\\n\\n\\n\\nhence this solution is done now  !   \\n\\n\\nthis took a lot of efffort if you find it useful please share your thoughts   \\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2085666,
                "title": "python3-increasing-stack",
                "content": "Reverse scan from right to left, maintain an increasing stack.\\nFor i<j and nums[i]>nums[j], the number of rounds for nums[i] to remove nums[j] is:\\n    1. If nums[j] takes 3 rounds to remove all smaller numbers on its right, then it will also take nums[i] same 3 rounds to remove nums[j], not 1 round. \\n    2. If nums[j] has nothing to remove on its right side, then nums[i] will take at least 1 round to remove nums[j].\\n\\n```\\n    def totalSteps(self, nums: List[int]) -> int:\\n        res,stack = 0, []\\n        for i in range(len(nums)-1,-1,-1):\\n            cur = 0\\n            while stack and nums[stack[-1][0]]<nums[i]:\\n                _,v = stack.pop()\\n                cur=max(cur+1,v)\\n            res = max(res,cur)\\n            stack.append([i,cur])\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n    def totalSteps(self, nums: List[int]) -> int:\\n        res,stack = 0, []\\n        for i in range(len(nums)-1,-1,-1):\\n            cur = 0\\n            while stack and nums[stack[-1][0]]<nums[i]:\\n                _,v = stack.pop()\\n                cur=max(cur+1,v)\\n            res = max(res,cur)\\n            stack.append([i,cur])\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2086927,
                "title": "java-o-n-easy-understanding-just-simulate-by-double-linked-list",
                "content": "the key point of this question is that we can find the numbers need remove in next round from the previous round. The reason is that the numbers need remove in next round must be adjacent to some deleted number in current round.For example, [ 5, 2, 3, 4,], the first round we delete 2, the second round we delete 3, and 2 and 3 must be adjacent.\\nso we just need to do two things:\\n1.scan the numbers which need to delete in first step.\\n2.we delete the numbers.\\n3.then we check each deleted number\\'s next number whether it\\'s satisfied to delete in the next round.\\n3.repeat 2 and 3 until we can\\'t find new numbers to delete.\\nNoticing that we don\\'t scan the whole array so the complexity is NOT o(n2).   \\nThe tricky part is if we use array to store numbers, we can\\'t visit previous number of 3 by one step after we delete 2...So vey naturally\\uFF0C we can use linkedList to solve this problem.\\nSince we visit evey number which need delete only twice, so the whole time complexity is O(n)\\n```\\nclass Solution {\\n    class LinkedNode {\\n        LinkedNode pre, next;\\n        int val;\\n        boolean isDel;\\n        LinkedNode(int v){\\n            val = v;\\n        }\\n        void del() {\\n            if (this.pre != null)\\n                this.pre.next = this.next;\\n            if (this.next != null)\\n                this.next.pre = this.pre;\\n            this.isDel = true;\\n        }\\n        void add(LinkedNode node) {\\n            node.next = this.next;\\n            node.pre = this;\\n            if (this.next != null)\\n                this.next.pre = node;\\n            this.next = node;\\n        }\\n    }\\n    \\n    public int totalSteps(int[] nums) {\\n        int ans = 0;\\n        LinkedNode head = new LinkedNode(-1);\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            head.add(new LinkedNode(nums[i]));\\n        }\\n        List<LinkedNode> delList = new ArrayList<>();\\n        LinkedNode tmp = head.next, pre = head; \\n        while (tmp != null) {\\n            if (pre.val > tmp.val) {\\n                delList.add(tmp);\\n            }\\n            pre = tmp;\\n            tmp = tmp.next;\\n        }\\n        while (!delList.isEmpty()) {\\n            delList = remove(delList);\\n            ans++;\\n        }\\n        return ans;\\n    }\\n    \\n    List<LinkedNode> remove(List<LinkedNode> del) {\\n        for (LinkedNode node : del) {\\n            node.del();\\n        }\\n        List<LinkedNode> nextDel = new ArrayList<>();\\n        for (LinkedNode node : del) {\\n            if (node.next != null && !node.next.isDel && node.next.val < node.next.pre.val) {\\n                nextDel.add(node.next);\\n            }\\n        }\\n        return nextDel;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class LinkedNode {\\n        LinkedNode pre, next;\\n        int val;\\n        boolean isDel;\\n        LinkedNode(int v){\\n            val = v;\\n        }\\n        void del() {\\n            if (this.pre != null)\\n                this.pre.next = this.next;\\n            if (this.next != null)\\n                this.next.pre = this.pre;\\n            this.isDel = true;\\n        }\\n        void add(LinkedNode node) {\\n            node.next = this.next;\\n            node.pre = this;\\n            if (this.next != null)\\n                this.next.pre = node;\\n            this.next = node;\\n        }\\n    }\\n    \\n    public int totalSteps(int[] nums) {\\n        int ans = 0;\\n        LinkedNode head = new LinkedNode(-1);\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            head.add(new LinkedNode(nums[i]));\\n        }\\n        List<LinkedNode> delList = new ArrayList<>();\\n        LinkedNode tmp = head.next, pre = head; \\n        while (tmp != null) {\\n            if (pre.val > tmp.val) {\\n                delList.add(tmp);\\n            }\\n            pre = tmp;\\n            tmp = tmp.next;\\n        }\\n        while (!delList.isEmpty()) {\\n            delList = remove(delList);\\n            ans++;\\n        }\\n        return ans;\\n    }\\n    \\n    List<LinkedNode> remove(List<LinkedNode> del) {\\n        for (LinkedNode node : del) {\\n            node.del();\\n        }\\n        List<LinkedNode> nextDel = new ArrayList<>();\\n        for (LinkedNode node : del) {\\n            if (node.next != null && !node.next.isDel && node.next.val < node.next.pre.val) {\\n                nextDel.add(node.next);\\n            }\\n        }\\n        return nextDel;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2086010,
                "title": "c-100-efficient",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        vector<int> a(nums.size()); \\n        stack<int> s;\\n        int steps = 0; \\n        for(int i = nums.size()-1;i>=0;i--){\\n            while(!s.empty() && nums[i]>nums[s.top()]){\\n                a[i] = max(a[i]+1, a[s.top()]); s.pop();\\n            }\\n            s.push(i);\\n            steps = max(steps, a[i]);\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        vector<int> a(nums.size()); \\n        stack<int> s;\\n        int steps = 0; \\n        for(int i = nums.size()-1;i>=0;i--){\\n            while(!s.empty() && nums[i]>nums[s.top()]){\\n                a[i] = max(a[i]+1, a[s.top()]); s.pop();\\n            }\\n            s.push(i);\\n            steps = max(steps, a[i]);\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085731,
                "title": "simple-stack-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        stack<pair<int, int>> s;\\n        s.push({0, -1});\\n        int ans = -1, n = nums.size();\\n        \\n        for(int i = 1; i < n; i++) {\\n            int curr = 1;\\n            \\n            while(s.size()) {\\n                if(nums[i] >= nums[s.top().first]) {\\n                    curr = max(curr, s.top().second + 1);\\n                    s.pop();\\n                }\\n                else break;\\n            }\\n            \\n            if(!s.size()) curr = -1;\\n            ans = max(ans, curr);\\n            s.push({i, curr});\\n        }\\n        \\n        return ans < 0 ? 0: ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        stack<pair<int, int>> s;\\n        s.push({0, -1});\\n        int ans = -1, n = nums.size();\\n        \\n        for(int i = 1; i < n; i++) {\\n            int curr = 1;\\n            \\n            while(s.size()) {\\n                if(nums[i] >= nums[s.top().first]) {\\n                    curr = max(curr, s.top().second + 1);\\n                    s.pop();\\n                }\\n                else break;\\n            }\\n            \\n            if(!s.size()) curr = -1;\\n            ans = max(ans, curr);\\n            s.push({i, curr});\\n        }\\n        \\n        return ans < 0 ? 0: ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2091886,
                "title": "easy-python-monotonic-stack",
                "content": "For every number ```num[i]``` in the array, we have to remove every number ```num[j]```, such that ```num[i] > num[j] and i < j```.  So the answer is simply the maximum number of steps we need to perform in the array, where one step is removal of one number after ```num[i]``` \\n\\nFor ```[5,3,6,2]```, we can see that \\nfor 5, we have to remove ```3``` => 1 step. \\nFor 6 we have to remove ```2``` => 1 step\\nSo the answer is 1\\n\\nNow, if we consider ```[10,1,2,3,4,5,6,1,2,3]```,\\nfor 10, we have to remove ```1, 2, 3, 4, 5, 6``` => 6 steps\\nand for 6, we have to remove ```1, 2, 3``` => 3 steps\\nSo the answer is 6\\n\\nWe maintain a monotonic stack which stores the numbers and the step number for the particular number.\\n```\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        st = []\\n        ans = 0\\n        for i in nums:\\n            t = 0\\n            while st and st[-1][0] <= i:\\n                t = max(t, st.pop()[1])\\n            x = 0 \\n            if st: \\n                x = t+1 \\n            st.append([i, x])\\n            ans = max(ans, x)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Monotonic Stack"
                ],
                "code": "```num[i]```\n```num[j]```\n```num[i] > num[j] and i < j```\n```num[i]```\n```[5,3,6,2]```\n```3```\n```2```\n```[10,1,2,3,4,5,6,1,2,3]```\n```1, 2, 3, 4, 5, 6```\n```1, 2, 3```\n```\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        st = []\\n        ans = 0\\n        for i in nums:\\n            t = 0\\n            while st and st[-1][0] <= i:\\n                t = max(t, st.pop()[1])\\n            x = 0 \\n            if st: \\n                x = t+1 \\n            st.append([i, x])\\n            ans = max(ans, x)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085833,
                "title": "java-monotonic-stack-o-n",
                "content": "The second parameter of the stack element represents how many steps to make array non-decreasing\\n\\n\\tpublic int totalSteps(int[] nums) {\\n        LinkedList<int[]> stack = new LinkedList<>();\\n        int max = 0;\\n        for(int num : nums) {\\n            int score = 0;\\n            while(stack.size() > 0 && stack.getLast()[0] <= num) {\\n                score = Math.max(score, stack.removeLast()[1]);\\n            }\\n            stack.add(new int[]{num, stack.size() == 0 ? 0 : score+1});\\n            max = Math.max(max, stack.getLast()[1]);\\n        }\\n        return max;\\n    }",
                "solutionTags": [
                    "Java",
                    "Monotonic Stack"
                ],
                "code": "The second parameter of the stack element represents how many steps to make array non-decreasing\\n\\n\\tpublic int totalSteps(int[] nums) {\\n        LinkedList<int[]> stack = new LinkedList<>();\\n        int max = 0;\\n        for(int num : nums) {\\n            int score = 0;\\n            while(stack.size() > 0 && stack.getLast()[0] <= num) {\\n                score = Math.max(score, stack.removeLast()[1]);\\n            }\\n            stack.add(new int[]{num, stack.size() == 0 ? 0 : score+1});\\n            max = Math.max(max, stack.getLast()[1]);\\n        }\\n        return max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2086077,
                "title": "c-bfs-accepted-solution",
                "content": "I was not able to get it AC during the contest but continued with my BFS approach and finally made it. \\nFirst of all I created 3 vectors. \\n* dist[i] : gives me the number of elements that needs to be removed for ith element\\n* index[i] : gives me the index of element that needs to removed for the ith element\\n* vis[i] : used for checking if ith element is removed or not.\\n\\nWe will be pushing a pair of index {i,j} inside the queue where nums[i] > nums[j]. \\nWe will be starting from backwards (think intuitively). \\nInitially each index[i] = i+1 , since it will only forward us to the next index. \\n\\n```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int n = nums.size(); \\n        int ans = 0 ;\\n        vector<int>dist(n,0); \\n        vector<int>index(n,0);\\n        for(int i = 0 ; i < n ; i++){\\n            index[i] = i+1 ;\\n        }\\n        \\n        vector<int>vis(n,0); \\n        queue<pair<int,int>>q; \\n        for(int i = n-1 ; i > 0 ; i--){\\n            if(nums[i-1] > nums[i]){\\n                q.push({i-1,i});\\n            }\\n        }\\n        \\n        while(!q.empty()){\\n            auto f = q.front(); \\n            q.pop();\\n            \\n            int x = f.first  ; \\n            int y = f.second ; \\n            \\n            if(y == n){\\n                continue ;\\n            }\\n            if(vis[x]){\\n                continue ; \\n            }\\n\\t\\t\\t\\n\\t\\t\\t//index[y] gives us the next element that needs to be deleted.\\n            if(nums[x] > nums[y] && index[y] > y){\\n                vis[y] = 1 ;\\n                dist[f.first] += 1 ; \\n                index[f.first] = index[y];\\n                q.push({f.first,index[y]}); \\n            }\\n        }\\n        \\n        for(int i = 0 ; i < n ; i++) ans = max(ans , dist[i]);\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int n = nums.size(); \\n        int ans = 0 ;\\n        vector<int>dist(n,0); \\n        vector<int>index(n,0);\\n        for(int i = 0 ; i < n ; i++){\\n            index[i] = i+1 ;\\n        }\\n        \\n        vector<int>vis(n,0); \\n        queue<pair<int,int>>q; \\n        for(int i = n-1 ; i > 0 ; i--){\\n            if(nums[i-1] > nums[i]){\\n                q.push({i-1,i});\\n            }\\n        }\\n        \\n        while(!q.empty()){\\n            auto f = q.front(); \\n            q.pop();\\n            \\n            int x = f.first  ; \\n            int y = f.second ; \\n            \\n            if(y == n){\\n                continue ;\\n            }\\n            if(vis[x]){\\n                continue ; \\n            }\\n\\t\\t\\t\\n\\t\\t\\t//index[y] gives us the next element that needs to be deleted.\\n            if(nums[x] > nums[y] && index[y] > y){\\n                vis[y] = 1 ;\\n                dist[f.first] += 1 ; \\n                index[f.first] = index[y];\\n                q.push({f.first,index[y]}); \\n            }\\n        }\\n        \\n        for(int i = 0 ; i < n ; i++) ans = max(ans , dist[i]);\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2097856,
                "title": "c-2-approaches-single-monotonic-stack-or-monotonic-stack-with-dp-example-explained",
                "content": "Intuition :\\nAn element will eat all its smaller elements till next greater element unless it is itself get eated by some element on its left. Example-\\n[7 **[14 4]** 14 **[13 2 6]** 13]\\n13 can eat 2 and 6 but will only be able to eat 2 as it will be eaten by 14\\n[7 |**[14 4]**| **[14 [13 2]] 6 |** 13]\\nlater 14 will eat 6\\n[7 14 **[14 6]** 13]\\n[7 14 **[14 13]**]\\n\\n1. Using monotonic  stack and traversing from end (n-1 to 0)\\n\\n```\\nint totalSteps(vector<int>& nums) {\\n\\t\\tint n=nums.size();\\n        stack<pair<int,int>> st;\\n        int count=0;\\n        int ans=0;\\n        for(int i=n-1;i>=0;i--){\\n            while(st.size()&&nums[i]>nums[st.top().first]){\\n                count=max(count+1,st.top().second);\\n                st.pop();\\n            }\\n            st.push({i,count});\\n            ans=max(ans,count);\\n            count=0;\\n        }\\n        return ans;\\n\\t}\\n```\\n2. Using dynamic programming (dp array->eat[]) with motonic  stack\\n```\\nint totalSteps(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> eat(n);\\n        stack<int> st;\\n        int count=0;\\n        int ans=0;\\n        for(int i=n-1;i>=0;i--){\\n            // cout<<\"i=\"<<i<<\"---\";\\n            while(st.size()&&nums[i]>nums[st.top()]){\\n                //cout<<count<<\",\"<<eat[st.top()]<<\"; \";\\n                count=max(count+1,eat[st.top()]);\\n                st.pop();\\n            }\\n            eat[i]=count;\\n            st.push(i);\\n            ans=max(ans,count);\\n            count=0;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Monotonic Stack"
                ],
                "code": "```\\nint totalSteps(vector<int>& nums) {\\n\\t\\tint n=nums.size();\\n        stack<pair<int,int>> st;\\n        int count=0;\\n        int ans=0;\\n        for(int i=n-1;i>=0;i--){\\n            while(st.size()&&nums[i]>nums[st.top().first]){\\n                count=max(count+1,st.top().second);\\n                st.pop();\\n            }\\n            st.push({i,count});\\n            ans=max(ans,count);\\n            count=0;\\n        }\\n        return ans;\\n\\t}\\n```\n```\\nint totalSteps(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> eat(n);\\n        stack<int> st;\\n        int count=0;\\n        int ans=0;\\n        for(int i=n-1;i>=0;i--){\\n            // cout<<\"i=\"<<i<<\"---\";\\n            while(st.size()&&nums[i]>nums[st.top()]){\\n                //cout<<count<<\",\"<<eat[st.top()]<<\"; \";\\n                count=max(count+1,eat[st.top()]);\\n                st.pop();\\n            }\\n            eat[i]=count;\\n            st.push(i);\\n            ans=max(ans,count);\\n            count=0;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2087720,
                "title": "super-clean-explanation-of-pro-coders-approaches-examples-include",
                "content": "Consider the given testcase:\\n[5,3,4,4,7,3,6,11,8,5,11]\\nAs per qns we can\\'t delete the first element (In one step, remove all elements nums[i] where nums[i - 1] > nums[i] for all 0 < i < nums.length.)\\nso \\'5\\' is inevitable,\\nnow we have to remove elements less than 5 untill we meet other element right to \\'5\\' greater than \\'5\\'.\\nwe end up at  \\'7\\' so far we delete \"3\" nums.\\nuntill \\'11\\'  we delete \"2\" nums.\\nuntill next \\'11\\'  we delete \"2\" nums.\\nso answer would be max deletions taken place Therefore, ans=3\\n********************* BUT WAIT ******************\\nif we consider :\\n[14,1,2,3,4,5,6,1,2,3,4]\\nwe would get ans=10(Which is WRONG!!!)\\nBecause,\\nwe could delete nums 1 2 3 4 5 6 wrt \\'14\\' and other 1 2 3 4 nums wrt \\'6\\'\\nThen answer would be 6 actually.\\nSO WHAT TO DO !!!\\nlets see,\\nif we iterate the array from end which is right to left.\\nnow lets do the same but in other way\\nlets take a stack contains elements of form [nums[i],deletions_it_can_do]\\nso when we iterate it from right we find 4 we append [4,0] to stack\\nnext we find \\'3\\' which is smaller than \\'4\\' we continue \\n...\\nwe\\'ll reach \\'6\\' there are 4 nums right to it so we append [6,4]\\neach time ans would be max(ans,stack[i][1])\\nsimillarly we reach \\'14\\' we append [14,5]\\nso ans=5!!\\n(With this we predict the deletions we should make at max as we would have done 10 before wrt 14 but now we know that 6 helps us with few(4) parallel deletions so ans=5.)\\n(See code explanation below for complete explanation.)\\n\\n\\n**CODE:**\\n```\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        ans = 0\\n        nums.reverse()\\n        lst = [[nums[0], 0]]\\n        for i in range(1, len(nums)):\\n            cnt = 0\\n            while lst and lst[-1][0] < nums[i]:\\n                cnt = max(cnt + 1, lst[-1][1])\\n                print(lst)\\n                lst.pop()\\n            lst.append([nums[i], cnt])\\n            ans = max(ans, cnt)\\n        return ans\\n```\\n**STACK STATUS AT EACH ELEMENT:**\\n\\n4\\ninitial [[4, 0]]\\n3\\ninitial [[4, 0]]\\n2\\ninitial [[4, 0], [3, 0]]\\n1\\ninitial [[4, 0], [3, 0], [2, 0]]\\n6\\ninitial [[4, 0], [3, 0], [2, 0], [1, 0]]\\n[[4, 0], [3, 0], [2, 0], [1, 0]]\\n[[4, 0], [3, 0], [2, 0]]\\n[[4, 0], [3, 0]]\\n[[4, 0]]\\n5\\ninitial [[6, 4]]\\n4\\ninitial [[6, 4], [5, 0]]\\n3\\ninitial [[6, 4], [5, 0], [4, 0]]\\n2\\ninitial [[6, 4], [5, 0], [4, 0], [3, 0]]\\n14\\ninitial [[6, 4], [5, 0], [4, 0], [3, 0], [2, 0]]\\n[[6, 4], [5, 0], [4, 0], [3, 0], [2, 0]]\\n[[6, 4], [5, 0], [4, 0], [3, 0]]\\n[[6, 4], [5, 0], [4, 0]]\\n[[6, 4], [5, 0]]\\n[[6, 4]]\\nFinal stack [[14, 5]]\\n\\n\\n**CODE EXPLANATION:(DRY RUN)**\\nNow we are aware of the approach,code but how does it work.Let\\'s see.\\nWe initailly we have a stack containing  first ele of nums \\'4\\' and deletions \\'0\\' after reversing array.\\nAs we go on we find that the condition of the while loop is False untill we find a number greater than cur num.\\nAt 6;\\nThe while loop condition in True.\\nthat is 6>1 \\nStack Status: [[4, 0], [3, 0], [2, 0], [1, 0]]\\n`cnt = max(cnt + 1, lst[-1][1]`)\\nHere we see cnt =0 and `lst[-1][1]` intially\\nbut cnt is updated to cnt+1 in max function \\nit gets updated to 4 and stack gets empty and loop breaks \\nwe append `[[6, 4]]` to stack \\nNOTE: stack contains final non-decreaing array.\\nfor each iterations of for loop we update ans \\n`ans = max(ans, cnt)`\\nAt 11;\\nStack status : [[6, 4], [5, 0], [4, 0], [3, 0], [2, 0]]\\nnow we repeat same process we get [[14, 5]]\\nwe get 5 deletions cause `cnt = max(cnt + 1, lst[-1][1])`\\nHere is the catch its not added up its maximized \\nThats why we use stacks to get O(n) complexity.\\nHence we get desired answer!!\\nThank You if u read whole thing !!!\\nPlease Comment your insghts !!\\n(I couldn\\'t go through this again please ignore typos if any )\\n",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        ans = 0\\n        nums.reverse()\\n        lst = [[nums[0], 0]]\\n        for i in range(1, len(nums)):\\n            cnt = 0\\n            while lst and lst[-1][0] < nums[i]:\\n                cnt = max(cnt + 1, lst[-1][1])\\n                print(lst)\\n                lst.pop()\\n            lst.append([nums[i], cnt])\\n            ans = max(ans, cnt)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2086693,
                "title": "vedio-explanation-with-intuition",
                "content": "[Video Link](https://www.youtube.com/watch?v=XirZ8GtWxWA)",
                "solutionTags": [
                    "Stack"
                ],
                "code": "[Video Link](https://www.youtube.com/watch?v=XirZ8GtWxWA)",
                "codeTag": "Unknown"
            },
            {
                "id": 2127138,
                "title": "c-easy-code-explaination",
                "content": "\\n\\t\\tint totalSteps(vector<int>& A) {\\n\\t\\t\\t\\tint n = A.size(), steps = 0;\\n\\t\\t\\t\\tvector<int> dp(n);\\n\\t\\t\\t\\tstack<int> stack;\\n        \\n        for (int i=n-1 ; i>=0 ; i--) {\\n            while(!stack.empty() && A[i] > A[stack.top()]) {\\n                dp[i] = max(++dp[i], dp[stack.top()]);\\n                stack.pop();\\n                steps = max(steps, dp[i]);\\n            }\\n            stack.push(i);\\n        }\\n        \\n        return steps;\\n    }",
                "solutionTags": [],
                "code": "\\n\\t\\tint totalSteps(vector<int>& A) {\\n\\t\\t\\t\\tint n = A.size(), steps = 0;\\n\\t\\t\\t\\tvector<int> dp(n);\\n\\t\\t\\t\\tstack<int> stack;\\n        \\n        for (int i=n-1 ; i>=0 ; i--) {\\n            while(!stack.empty() && A[i] > A[stack.top()]) {\\n                dp[i] = max(++dp[i], dp[stack.top()]);\\n                stack.pop();\\n                steps = max(steps, dp[i]);\\n            }\\n            stack.push(i);\\n        }\\n        \\n        return steps;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2110632,
                "title": "c-solution-using-monotonic-stack-optimal-solution",
                "content": "```\\n/*  Approach -> using monotonic stack\\n    Time Complexity  -> O(n)\\n    Space Complexity -> O(n)    */\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        stack<pair<int,int>> st;\\n        int n=nums.size();\\n        int ans=0;\\n        \\n        st.push({nums[n-1],0});\\n        \\n        for(int i=n-2;i>=0;i--){\\n            int cnt=0;\\n            while(!st.empty() && nums[i]>st.top().first) {\\n                cnt=max(cnt+1,st.top().second);\\n                st.pop();\\n            }\\n            ans=max(ans,cnt);\\n            st.push({nums[i],cnt});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\n/*  Approach -> using monotonic stack\\n    Time Complexity  -> O(n)\\n    Space Complexity -> O(n)    */\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        stack<pair<int,int>> st;\\n        int n=nums.size();\\n        int ans=0;\\n        \\n        st.push({nums[n-1],0});\\n        \\n        for(int i=n-2;i>=0;i--){\\n            int cnt=0;\\n            while(!st.empty() && nums[i]>st.top().first) {\\n                cnt=max(cnt+1,st.top().second);\\n                st.pop();\\n            }\\n            ans=max(ans,cnt);\\n            st.push({nums[i],cnt});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2100060,
                "title": "easy-python-linked-list-simulation-solution",
                "content": "**Walkthrough**\\nThis is def not as elegant as the DP solution. But personally I find it easier to understand and a little bit more intuitive. What it is is recognizing the fact that linked list can help us for this problem because we keep deleting adjacent elements. \\n\\nThere are mostly 3 steps:\\n1. Convert the array list to a singly linked list\\n2. Get all peaks, where a peak is defined as any point in nums such that nums[i] > nums[i+1].\\n3. This is the simulation step. We keep deleting adjacent numbers to the peaks as long as they are smaller than the peaks, until no such peak exist any more. \\n\\n\\tNote that here we traverse backwards and that\\'s because in situation like [6,5,4] it can actually be deleted in one iteration if we traverse backwards. But if we traverse forward, 6 would delete 5 and 5 hasn\\'t had to chance to delete 4 yet, therefore yielding incorrect result. \\n\\n**Code**\\n```\\nclass Node:\\n    def __init__(self, val):\\n        self.val = val\\n        self.next = None\\n\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        head = Node(-1)\\n        curr = head\\n        \\n        # 1. Convert the list to a singly linked list\\n        for num in nums:\\n            curr.next = Node(num)\\n            curr = curr.next\\n            \\n        # 2. Get all the peaks, where a peak is defined if nums[i] > nums[i+1]\\n        curr = head\\n        peaks = []\\n        \\n        while curr.next:\\n            if curr.val > curr.next.val:\\n                peaks.append(curr)\\n            curr = curr.next\\n        \\n        # 3. Simulation. Keep getting rid of the peaks until there\\'s no more. \\n        steps = 0\\n        while peaks:  \\n            nextPeaks = []\\n            \\n            for node in reversed(peaks):\\n                if node.next and node.val > node.next.val:\\n                    node.next = node.next.next\\n                    nextPeaks.append(node)\\n            \\n            if not nextPeaks:\\n                return steps\\n            \\n            peaks = list(reversed(nextPeaks))\\n            steps += 1\\n        return steps\\n```\\t\\t\\n\\n**Time/Space Complexity**\\n\\n* Time: O(N), as each number can at be deleted once at most \\n* Space: O(N), we use linear space to convert the array list to a linked list\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Simulation"
                ],
                "code": "```\\nclass Node:\\n    def __init__(self, val):\\n        self.val = val\\n        self.next = None\\n\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        head = Node(-1)\\n        curr = head\\n        \\n        # 1. Convert the list to a singly linked list\\n        for num in nums:\\n            curr.next = Node(num)\\n            curr = curr.next\\n            \\n        # 2. Get all the peaks, where a peak is defined if nums[i] > nums[i+1]\\n        curr = head\\n        peaks = []\\n        \\n        while curr.next:\\n            if curr.val > curr.next.val:\\n                peaks.append(curr)\\n            curr = curr.next\\n        \\n        # 3. Simulation. Keep getting rid of the peaks until there\\'s no more. \\n        steps = 0\\n        while peaks:  \\n            nextPeaks = []\\n            \\n            for node in reversed(peaks):\\n                if node.next and node.val > node.next.val:\\n                    node.next = node.next.next\\n                    nextPeaks.append(node)\\n            \\n            if not nextPeaks:\\n                return steps\\n            \\n            peaks = list(reversed(nextPeaks))\\n            steps += 1\\n        return steps\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2087738,
                "title": "java-clean-code-with-comments",
                "content": "```\\n** Note: - This is the brute force solution hacing TC = O(n2) that gives TLE.\\n\\n    public int totalSteps(int[] nums) {\\n        int ts = 0;\\n\\n        List<Integer> nl = Arrays.stream(nums).boxed().collect(Collectors.toList());\\n        List<Integer> ul = new ArrayList<>();\\n        int prev = -1;\\n        while (true) {\\n            boolean changed = false;\\n            for (int num : nl) {\\n                if (prev == -1) prev = num;\\n                else if (num >= prev) ul.add(num);\\n                else {\\n                    changed = true;\\n                }\\n            }\\n            System.out.println(Arrays.toString(ul.toArray()));\\n            nl.clear();\\n            nl.addAll(ul);\\n            ul.clear();\\n            if (changed) ts++;\\n            if (!changed) break;\\n        }\\n\\n        return ts;\\n    }\\n\\n** Optimised Solution:- \\nTC = O(nk) where k is contant factor\\n\\nAlgorithm :-\\n- The Idea is to calculate distance between the closest left strictly greater element for every index i\\n- Return maximum of distance (As distance refers to numbers of steps needed to remove that element )\\n\\n\\n    public int totalSteps(int[] nums) {\\n        int ans = 0;\\n        Stack<int[]> stk = new Stack<>();\\n\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            if (stk.isEmpty() || stk.peek()[0] >= nums[i]) {\\n                stk.push(new int[]{nums[i], 0});\\n            } else {\\n                int count = 0;\\n                while (!stk.isEmpty() && stk.peek()[0] < nums[i]) {\\n                    count++;\\n                    int[] item = stk.pop();\\n                    if (item[1] > count) count = item[1];\\n                }\\n                stk.push(new int[]{nums[i], count});\\n                ans = Math.max(ans, count);\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n** Note: - This is the brute force solution hacing TC = O(n2) that gives TLE.\\n\\n    public int totalSteps(int[] nums) {\\n        int ts = 0;\\n\\n        List<Integer> nl = Arrays.stream(nums).boxed().collect(Collectors.toList());\\n        List<Integer> ul = new ArrayList<>();\\n        int prev = -1;\\n        while (true) {\\n            boolean changed = false;\\n            for (int num : nl) {\\n                if (prev == -1) prev = num;\\n                else if (num >= prev) ul.add(num);\\n                else {\\n                    changed = true;\\n                }\\n            }\\n            System.out.println(Arrays.toString(ul.toArray()));\\n            nl.clear();\\n            nl.addAll(ul);\\n            ul.clear();\\n            if (changed) ts++;\\n            if (!changed) break;\\n        }\\n\\n        return ts;\\n    }\\n\\n** Optimised Solution:- \\nTC = O(nk) where k is contant factor\\n\\nAlgorithm :-\\n- The Idea is to calculate distance between the closest left strictly greater element for every index i\\n- Return maximum of distance (As distance refers to numbers of steps needed to remove that element )\\n\\n\\n    public int totalSteps(int[] nums) {\\n        int ans = 0;\\n        Stack<int[]> stk = new Stack<>();\\n\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            if (stk.isEmpty() || stk.peek()[0] >= nums[i]) {\\n                stk.push(new int[]{nums[i], 0});\\n            } else {\\n                int count = 0;\\n                while (!stk.isEmpty() && stk.peek()[0] < nums[i]) {\\n                    count++;\\n                    int[] item = stk.pop();\\n                    if (item[1] > count) count = item[1];\\n                }\\n                stk.push(new int[]{nums[i], count});\\n                ans = Math.max(ans, count);\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2086750,
                "title": "java-monostack-9-2-ac-wow",
                "content": "oh wow, this question currently has a 9.2% passed rate and only 356 users got an AC during this contest. \\n\\nI feel like monostack questions tend to be a bit more unintuitive, but once we get the intuition, it is quite simple!\\n\\nIf we maintain a monostack and scan the array from right to left, pop element off when `nums[i] > nums[stack.peek()]`, then inituitively speaking, there are two possibilities for the count for `num[i]`: \\n1. Inherit the count from whatever it popped (maybe +1?)\\n\\n2. add 1 to its current count\\n\\nWhen we think a little deeper, we find that we are not supposed to +1 for case 1 because both numbers get deleted at the same time.  \\nAlso, we are supposed to take the maximum of both cases.\\n\\nSolved all 4 Qs on my own this time but didn\\'t participate in contest, so :( \\n\\n\\n\\n```Java\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        int ans = 0;\\n        int[] dp = new int[nums.length];\\n        for (int i = nums.length - 1; i >= 0; i--){\\n            int cur = 0;\\n            while(!stack.isEmpty() && nums[i] > nums[stack.peek()]){\\n                cur = Math.max(cur + 1, dp[stack.pop()]);\\n            }\\n            stack.push(i);\\n            dp[i] = cur;\\n            ans = Math.max(cur, ans);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Monotonic Stack"
                ],
                "code": "```Java\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        int ans = 0;\\n        int[] dp = new int[nums.length];\\n        for (int i = nums.length - 1; i >= 0; i--){\\n            int cur = 0;\\n            while(!stack.isEmpty() && nums[i] > nums[stack.peek()]){\\n                cur = Math.max(cur + 1, dp[stack.pop()]);\\n            }\\n            stack.push(i);\\n            dp[i] = cur;\\n            ans = Math.max(cur, ans);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3881965,
                "title": "monotonic-stack-very-easy-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse a **monotonic increasing stack** to count the number of steps. The approach is very simple, just count a **continuous number of operations** to build up the **stack in increasing order**.\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int totalSteps(vector<int>& arr) {\\n\\n      int n = arr.size();\\n      stack<pair<int,int>> st;\\n      int ans = -1;\\n       for(int i = n-1;i>=0;i--)\\n       {\\n           int cnt = 0;\\n           while(!st.empty() && st.top().first < arr[i])\\n           {\\n               cnt = max(cnt+1,st.top().second);\\n               st.pop();   \\n           }\\n           ans = max(ans,cnt);\\n           st.push({arr[i],cnt});\\n       }\\n\\n       return ans;\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/e3fbe3dc-a29d-4917-985a-96953bfb5397_1691502089.0189996.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int totalSteps(vector<int>& arr) {\\n\\n      int n = arr.size();\\n      stack<pair<int,int>> st;\\n      int ans = -1;\\n       for(int i = n-1;i>=0;i--)\\n       {\\n           int cnt = 0;\\n           while(!st.empty() && st.top().first < arr[i])\\n           {\\n               cnt = max(cnt+1,st.top().second);\\n               st.pop();   \\n           }\\n           ans = max(ans,cnt);\\n           st.push({arr[i],cnt});\\n       }\\n\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422708,
                "title": "python-using-a-stack",
                "content": "First, let\\'s take a look at an example.\\n\\n\\tnums = [5,3,4,4]\\n\\t\\n\\t- Step 1: [5,3,4,4] becomes [5,4,4]\\n\\t- Step 2: [5,4,4] becomes [5,4]\\n\\t- Step 3: [5,4] becomes [5]\\n\\t\\n\\tHere, we have to perform three steps to make the array non-decreasing (increasing).\\n\\t\\n\\tNow, ofcourse it is not a good idea to keep looping again and again until we are sure that array is now non-decreasing.\\n\\t\\n\\tSo, how can we quickly figure out, what is the number of steps required for this array to become non-decreasing.\\n\\t\\n\\tIt seems like we are simply counting how many smaller elements on right are there.\\n\\t\\n\\tBUT THERE IS A CATCH THAT I WILL DISCUSS IN LATER PART.\\n\\t\\n\\tFor example, for \"5\" at index = 0, we have to remove \"3\", \"4\" and \"4\". So there are \"3\" elements we have to remove for this \"5\".\\n\\n\\tSo, the steps = 3.\\n\\t\\n\\tIt also makes sense since in one step, we can only remove one element such that it is smaller than previous. So here,\\n\\t\\n\\tIn one step, we first remove \"3\". Then in second step, we remove \"4\" And finally, we remove the other \"4\".\\n\\n\\t\\nRemember I said there is a catch in the above approach.\\n\\nBased on the above approach, it makes sense to simply loop from left to right and see how many smaller elements are there on right of an element, right? But will it give us the right output?\\n\\n\\tTake this example ->  [5,3,4,3]\\n\\t\\n\\tAs per our logic, we will remove all the smaller elements on right of \"5\" and so it takes 3 steps.\\n\\t\\n\\tBut just think about it. Before \"5\" removes the last \"3\", won\\'t \"4\" already remove it?\\n\\t\\n\\tThe problem statement says in one step, all those elements will be removed that have a greater element on their left.\\n\\t\\n\\tAnd so, in Step 1, we will remove the \"3\" on right of \"5\" and also the \"3\" on right of \"4\", leaving us with [5,4]\\n\\t\\n\\tAnd in Step 2, we will remove the \"4\" and so output is 2 steps.\\n\\t\\nAnd that\\'s the whole idea of using the stack and looping from right to left. Such that, before we reach \"5\", we have already calculated how many elements \"4\" will remove and that will represent how many steps it would take.\\n\\nFinally, to summarize the solution, let\\'s take an example.\\n\\n\\tnums  = [7,14,4,14,13,2,6,13]\\n\\t\\n\\t\\n\\tWe loop from right to left.\\n\\t\\n\\tFirst, we have \"13\". We removed 0 elements. Stack = [(13,0)]\\n\\t\\n\\tNext, we have \"6\". Again, 0 elements removed since we don\\'t have smaller element on top of stack.\\n\\tAnd same story with \"2\".\\n\\t\\n\\tStack = [(13,0), (6,0), (2,0)]\\n\\t\\n\\tNext up, we have \"13\". Here, we see that stack has two smaller elements on top. \\n\\tSo, before pushing \"13\" we have to remove these two elements.\\n\\t\\n\\tSince for \"6\" and \"2\", the count of \"0\", it means we haven\\'t yet performed any step at all.\\n\\t\\n\\tSo, we perform our first step only when we reach \"13\". We will remove \"2\" first. \\n\\tstepCount += 1\\n\\t\\n\\tThen we will remove \"6\".\\n\\tstepCount += 1\\n\\t\\n\\tHence, for \"13\", we removed \"2\" elements and that took \"2\" steps. \\n\\t\\n\\tStack = [(13,0), (13,2)]\\n\\t\\n\\tNext, we have \"14\". Here, we see that top of stack has \"13\" and we are already at step 2 at this point since \"13\" removed \"2\" elements.\\n\\t\\n\\tSo, when \"14\" removed the topmost \"13\", it makes sense that it did that in at least the step 2 (or above).\\n\\t\\n\\tThat\\'s the reason why in the code we did stepCount = max(stepCount + 1, stack[-1][1])\\n\\t\\n\\tBecause if we had just done stepCount += 1, then for \"14\", \\n\\tit would\\'ve meant that one element removed and hence only one step performed.\\n\\tAnd we would\\'ve lost the actual steps performed so far, which is \"2\".\\n\\t\\n\\tSo, the idea is to keep track of maximum steps performed at any point we remove any element.\\n\\tBecause it makes sense that if we removed some elements already and \"x\" steps have been taken,\\n\\tthen if we remove another, then it is either the \"x\"th step itself or the \"x + 1\"th step.\\n\\t\\n\\tSo, at this point, we remove (13,2) from stack and right now, stepCount = 2\\n\\t\\n\\tThen we remove the next \"13\" and this one took another step. So stepCount = 3\\n\\t\\n\\tHence, Stack = [(14,3)] and so far, steps = 3\\n\\t\\n\\tSimilarly, we keep going and eventually, we will find that the maximum value for steps will be \"3\".\\n\\t\\nHence, nums  = [7,14,4,14,13,2,6,13] is converted to a non-decreasing array in 3 steps.\\n\\t\\n\\t\\n```\\ndef totalSteps(self, nums: List[int]) -> int:\\n        # Length of the input list\\n        n = len(nums)\\n        \\n        # Steps\\n        steps = 0\\n        \\n        # Stack\\n        stack = []\\n        \\n        # Loop in reverse\\n        for i in range(n - 1, -1, -1):\\n            # How many elements were removed for this particular element to push to stack\\n            # That represents the number of steps performed\\n            stepCount = 0\\n            \\n            # Remove all the elements on top of stack that are smaller\\n            while stack and stack[-1][0] < nums[i]:\\n                # We want to keep track of what is the maximum stepCount so far\\n                # That\\'s why, we want the maximum value here\\n                stepCount = max(stepCount + 1, stack[-1][1])\\n                stack.pop()\\n                \\n            # Push the current element to stack along with the step count\\n            stack.append([nums[i], stepCount])\\n            \\n            # Update the steps performed\\n            steps = max(steps, stepCount)\\n        \\n        return steps\\n```\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\ndef totalSteps(self, nums: List[int]) -> int:\\n        # Length of the input list\\n        n = len(nums)\\n        \\n        # Steps\\n        steps = 0\\n        \\n        # Stack\\n        stack = []\\n        \\n        # Loop in reverse\\n        for i in range(n - 1, -1, -1):\\n            # How many elements were removed for this particular element to push to stack\\n            # That represents the number of steps performed\\n            stepCount = 0\\n            \\n            # Remove all the elements on top of stack that are smaller\\n            while stack and stack[-1][0] < nums[i]:\\n                # We want to keep track of what is the maximum stepCount so far\\n                # That\\'s why, we want the maximum value here\\n                stepCount = max(stepCount + 1, stack[-1][1])\\n                stack.pop()\\n                \\n            # Push the current element to stack along with the step count\\n            stack.append([nums[i], stepCount])\\n            \\n            # Update the steps performed\\n            steps = max(steps, stepCount)\\n        \\n        return steps\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2896423,
                "title": "python3-easiest-solution-beats-90",
                "content": "# Code\\n```\\nclass Solution:\\n    def totalSteps(self, A: List[int]) -> int:      \\n        st = [[A[0], 0]]\\n        ans = 0\\n        \\n        for a in A[1:]:\\n            t = 0\\n            while st and st[-1][0] <= a:\\n                t = max(t, st[-1][1])\\n                st.pop()\\n            if st: \\n                t += 1\\n            else:\\n                t = 0\\n            ans = max(ans, t)\\n            st.append([a, t])\\n            \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def totalSteps(self, A: List[int]) -> int:      \\n        st = [[A[0], 0]]\\n        ans = 0\\n        \\n        for a in A[1:]:\\n            t = 0\\n            while st and st[-1][0] <= a:\\n                t = max(t, st[-1][1])\\n                st.pop()\\n            if st: \\n                t += 1\\n            else:\\n                t = 0\\n            ans = max(ans, t)\\n            st.append([a, t])\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2735172,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& A) {\\n        int n = A.size(), res = 0;\\n        vector<int> stack, dp(n);\\n        for (int i = n - 1; i >= 0; --i) {\\n            while (!stack.empty() && A[i] > A[stack.back()]) {\\n                dp[i] = max(++dp[i], dp[stack.back()]);\\n                stack.pop_back();\\n                res = max(res, dp[i]);\\n            }\\n            stack.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& A) {\\n        int n = A.size(), res = 0;\\n        vector<int> stack, dp(n);\\n        for (int i = n - 1; i >= 0; --i) {\\n            while (!stack.empty() && A[i] > A[stack.back()]) {\\n                dp[i] = max(++dp[i], dp[stack.back()]);\\n                stack.pop_back();\\n                res = max(res, dp[i]);\\n            }\\n            stack.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2298418,
                "title": "java-solution-o-n-time-o-n-space",
                "content": "```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        Stack st = new Stack<Integer>();\\n        st.push(0);\\n        int steps=0;\\n        int step_arr[] = new int[nums.length]; \\n        for(int i=1;i<nums.length;i++){\\n            int max_steps = 0;\\n            while(!st.empty() && nums[i]>=nums[(Integer)st.peek()]){\\n                max_steps=Math.max(max_steps,step_arr[(Integer)st.peek()]);\\n                st.pop();\\n            }\\n            if(!st.empty() && nums[i]<nums[(Integer)st.peek()]){\\n                    step_arr[i]=1+max_steps;\\n            }\\n            steps = Math.max(steps,step_arr[i]);\\n            st.push(i);\\n        }\\n        return steps;\\n    }\\n}\\n\\n/*\\n1. The stack helps us to figure out for each element, which is the first strictly greater element present to the left of it.\\n2. It is because of this element that the current element will be removed.\\n3. Once that is figured out we need to figure how many steps have passed when both these elements become adjacent to each other. In order to figure that out, whenever we perform the popping operation on stack we maintain a variable to record the max. steps that have passed in order for all intermedate elements to get removed,so that the current element and the strictly greater element have become adjacent. \\n4. The number of steps reqd. for this element to get removed would be one greater than the max. of all the intermediate elements\\' steps.\\n5. Maintain all the steps in an array called `step_arr`. Max of all the steps would be the answer.\\n6. Do comment or upvote if you stumble upon this discussion_thread. \\n\\n*/\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        Stack st = new Stack<Integer>();\\n        st.push(0);\\n        int steps=0;\\n        int step_arr[] = new int[nums.length]; \\n        for(int i=1;i<nums.length;i++){\\n            int max_steps = 0;\\n            while(!st.empty() && nums[i]>=nums[(Integer)st.peek()]){\\n                max_steps=Math.max(max_steps,step_arr[(Integer)st.peek()]);\\n                st.pop();\\n            }\\n            if(!st.empty() && nums[i]<nums[(Integer)st.peek()]){\\n                    step_arr[i]=1+max_steps;\\n            }\\n            steps = Math.max(steps,step_arr[i]);\\n            st.push(i);\\n        }\\n        return steps;\\n    }\\n}\\n\\n/*\\n1. The stack helps us to figure out for each element, which is the first strictly greater element present to the left of it.\\n2. It is because of this element that the current element will be removed.\\n3. Once that is figured out we need to figure how many steps have passed when both these elements become adjacent to each other. In order to figure that out, whenever we perform the popping operation on stack we maintain a variable to record the max. steps that have passed in order for all intermedate elements to get removed,so that the current element and the strictly greater element have become adjacent. \\n4. The number of steps reqd. for this element to get removed would be one greater than the max. of all the intermediate elements\\' steps.\\n5. Maintain all the steps in an array called `step_arr`. Max of all the steps would be the answer.\\n6. Do comment or upvote if you stumble upon this discussion_thread. \\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2100584,
                "title": "sollution-in-o-n-time-complexoty",
                "content": "/*\\n\\n1. Suppose the (ith) element takes count[i] stpes to get removed from the array , the minimum value of count[i] is 0; which means that there is no gretar element \\n   on its left.\\n\\n2. The element will get removed from the array if there is greater element than that element on left.\\n\\n3. The element will be removed by its greater element present on its left.\\n\\n4. suppose the element A[i] , has A[j] element which is greater than A[i];\\n\\n5. The rounds taken by element A[i] to get removed from the array is maximum number of rounds taken by element from [ (j+1 , i-1) ] + 1  \\n\\n*/\\n\\nclass Solution {\\npublic:\\n    int solve(vector<int>& v , int n)\\n    {\\n        stack<pair<int,int>> st;\\n        int ans = 0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(st.size() == 0)\\n            {\\n                st.push({v[i] , 0});\\n            }\\n            else\\n            {\\n                int curr_ans = 0;\\n                \\n                while(st.size() > 0 && st.top().first <= v[i])\\n                {\\n                    curr_ans = max(curr_ans , st.top().second);\\n                    st.pop();\\n                }\\n                \\n                if(st.size() == 0) curr_ans = 0;\\n                else curr_ans = curr_ans + 1;\\n                \\n                ans = max(ans , curr_ans);\\n                \\n                st.push({v[i] , curr_ans});\\n            }\\n        }\\n        return ans;\\n    }\\n    int totalSteps(vector<int>& nums) \\n    {\\n        int ans = solve(nums , nums.size());\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    int solve(vector<int>& v , int n)\\n    {\\n        stack<pair<int,int>> st;\\n        int ans = 0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(st.size() == 0)\\n            {\\n                st.push({v[i] , 0}",
                "codeTag": "Java"
            },
            {
                "id": 2100083,
                "title": "javascript-solution-stack-dp",
                "content": "```\\nvar totalSteps = function(nums) {\\n\\tlet stack = [],\\n\\t\\tdp = new Array(nums.length).fill(0),\\n\\t\\tmax = 0\\n\\n\\tfor (let i = nums.length - 1; i >= 0; i--) {\\n\\t\\twhile (stack.length > 0 && nums[i] > nums[stack[stack.length - 1]]) {\\n\\t\\t\\tdp[i] = Math.max(++dp[i], dp[stack.pop()])\\n\\t\\t\\tmax = Math.max(dp[i], max)\\n\\t\\t}\\n\\t\\tstack.push(i)\\n\\t}\\n\\treturn max\\n};\\n```\\nComplement Lee\\'s solution in javascript",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar totalSteps = function(nums) {\\n\\tlet stack = [],\\n\\t\\tdp = new Array(nums.length).fill(0),\\n\\t\\tmax = 0\\n\\n\\tfor (let i = nums.length - 1; i >= 0; i--) {\\n\\t\\twhile (stack.length > 0 && nums[i] > nums[stack[stack.length - 1]]) {\\n\\t\\t\\tdp[i] = Math.max(++dp[i], dp[stack.pop()])\\n\\t\\t\\tmax = Math.max(dp[i], max)\\n\\t\\t}\\n\\t\\tstack.push(i)\\n\\t}\\n\\treturn max\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2098159,
                "title": "python-stack-non-increasing-stack-no-dp-record-steps-before-removing-elements",
                "content": "I know, the highest upvoted solution uses DP. However, the DP solution is not intuitive to me, as DP[i] is not the steps to remove element at index i, but the steps to remove all  smaller elements behind element i in the non-incresing stack. It is hard to come up with such definition of DP. \\n\\nMy solution follows a simple intuition. When a new element is about to be appended to the stack, if it leads to existing elments right before element i in the stack being removed, record the steps to remove elements right before element i in the stack ; Update the steps when a new element is about to be appended to the non-increasing stack, choose the max. \\n\\n```Python\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        res, stack = 0, list()\\n        stack.append([nums[-1],0])\\n        for i in range(len(nums)-2, -1,-1):              \\n            cnt = 0\\n            while stack and nums[i] > stack[-1][0]:\\n                val, step = stack.pop()\\n                cnt = max(cnt, step)\\n                cnt += 1\\n            res = max(res, cnt)\\n            if stack: \\n                stack[-1][1]  = max(cnt, stack[-1][1])\\n            stack.append([nums[i],0])\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```Python\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        res, stack = 0, list()\\n        stack.append([nums[-1],0])\\n        for i in range(len(nums)-2, -1,-1):              \\n            cnt = 0\\n            while stack and nums[i] > stack[-1][0]:\\n                val, step = stack.pop()\\n                cnt = max(cnt, step)\\n                cnt += 1\\n            res = max(res, cnt)\\n            if stack: \\n                stack[-1][1]  = max(cnt, stack[-1][1])\\n            stack.append([nums[i],0])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2090753,
                "title": "c-monotonic-stack-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        //monotonic stack\\n        int n = nums.size();\\n        int ans = 0;\\n        int cnt = 0;\\n        stack<pair<int, int>> st;\\n        st.push({nums[n-1], 0});\\n        for(int i= n-2; i>=0; i--){\\n            cnt = 0;\\n            while(!st.empty() && nums[i]>st.top().first){\\n                cnt = max(cnt+1, st.top().second);\\n                st.pop();\\n            }\\n            \\n            ans = max(ans, cnt);\\n            st.push({nums[i], cnt});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        //monotonic stack\\n        int n = nums.size();\\n        int ans = 0;\\n        int cnt = 0;\\n        stack<pair<int, int>> st;\\n        st.push({nums[n-1], 0});\\n        for(int i= n-2; i>=0; i--){\\n            cnt = 0;\\n            while(!st.empty() && nums[i]>st.top().first){\\n                cnt = max(cnt+1, st.top().second);\\n                st.pop();\\n            }\\n            \\n            ans = max(ans, cnt);\\n            st.push({nums[i], cnt});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2088220,
                "title": "python-monotonic-stack-o-n-100",
                "content": "```\\n\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        nums.reverse()\\n        monostack=[[0,0]]\\n        #monotonicstack [lastIndex, numberOfDeletion]\\n        res=0\\n        print(nums)\\n        for index in range(1,len(nums)):\\n            #Deletion count for cur index is 0.\\n            cnt=0\\n            #keep deleting value if incoming value is greater than current top of stack\\n            while monostack and nums[monostack[-1][0]]<nums[index]:\\n                num,delcnt=monostack.pop()\\n                #ensure you carry forward your deletion from previous streak\\n                cnt=max(cnt+1,delcnt)\\n                res=max(res,cnt)\\n            monostack.append([index,cnt])\\n        return res\\n\\t``",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        nums.reverse()\\n        monostack=[[0,0]]\\n        #monotonicstack [lastIndex, numberOfDeletion]\\n        res=0\\n        print(nums)\\n        for index in range(1,len(nums)):\\n            #Deletion count for cur index is 0.\\n            cnt=0\\n            #keep deleting value if incoming value is greater than current top of stack\\n            while monostack and nums[monostack[-1][0]]<nums[index]:\\n                num,delcnt=monostack.pop()\\n                #ensure you carry forward your deletion from previous streak\\n                cnt=max(cnt+1,delcnt)\\n                res=max(res,cnt)\\n            monostack.append([index,cnt])\\n        return res\\n\\t``",
                "codeTag": "Java"
            },
            {
                "id": 2087410,
                "title": "java-100-stack",
                "content": "```\\nclass Solution {\\n    \\n    \\n    \\n    public int totalSteps(int[] nums) {\\n        \\n        int n = nums.length;\\n        int ans = 0;\\n        \\n        Stack<Pair<Integer,Integer>> st = new Stack();\\n        \\n        st.push(new Pair(nums[n-1],0));\\n        \\n        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            int count = 0;\\n            \\n            while(!st.isEmpty() && nums[i] > st.peek().getKey())\\n            {\\n                count = Math.max(count+1 , st.peek().getValue() );\\n                st.pop();\\n            }\\n            \\n            ans = Math.max(ans , count);\\n            st.push(new Pair(nums[i],count));\\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    \\n    \\n    \\n    public int totalSteps(int[] nums) {\\n        \\n        int n = nums.length;\\n        int ans = 0;\\n        \\n        Stack<Pair<Integer,Integer>> st = new Stack();\\n        \\n        st.push(new Pair(nums[n-1],0));\\n        \\n        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            int count = 0;\\n            \\n            while(!st.isEmpty() && nums[i] > st.peek().getKey())\\n            {\\n                count = Math.max(count+1 , st.peek().getValue() );\\n                st.pop();\\n            }\\n            \\n            ans = Math.max(ans , count);\\n            st.push(new Pair(nums[i],count));\\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2086826,
                "title": "c-easy-to-understand-monotonic-stack-approach-with-explanation",
                "content": "**We need to form a non-decreasing sequence. so, we need to remove all the values which makes our sequence decreasing in nature. Thus we use monotonic stack to find the count of numbers after a particular index which are needed to be removed to make the sequence non-decreasing. And we need to find the maximum of all of those counts because the number of steps to be stimulated to get the required ans would be obtained by doing the removal procedure for that many number of times.**\\n```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int n=nums.size();\\n        stack<pair<int,int> > st;\\n        st.push({nums[n-1],0});\\n        int res=0;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            int count=0;\\n            while(!st.empty()&&st.top().first<nums[i])\\n            {\\n                count=max(count+1,st.top().second);\\n                st.pop();\\n            }\\n            res=max(res,count);\\n            st.push({nums[i],count});\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int n=nums.size();\\n        stack<pair<int,int> > st;\\n        st.push({nums[n-1],0});\\n        int res=0;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            int count=0;\\n            while(!st.empty()&&st.top().first<nums[i])\\n            {\\n                count=max(count+1,st.top().second);\\n                st.pop();\\n            }\\n            res=max(res,count);\\n            st.push({nums[i],count});\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085918,
                "title": "c-easy-stack",
                "content": "class Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        vector<int>v(n);\\n        stack<int>st;\\n        int ans=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            while(!st.empty() && nums[i]>nums[st.top()])\\n            {\\n                v[i]=max(v[i]+1,v[st.top()]);\\n                st.pop();\\n            }\\n            st.push(i);\\n            ans=max(ans,v[i]);\\n        }\\n        //for(auto it:a)\\n            //cout<<it<<\" \";\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        vector<int>v(n);\\n        stack<int>st;\\n        int ans=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            while(!st.empty() && nums[i]>nums[st.top()])\\n            {\\n                v[i]=max(v[i]+1,v[st.top()]);\\n                st.pop();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2085763,
                "title": "c-monotonic-stack-segment-tree-explained",
                "content": "For each index i , we will first find the index having value greater than the current value of nums[i]. We will remove current element with this index but for that we have to remove the elements in between them, so for that we can create a segment tree and take maximum of all the values between those index.\\n\\nMax value+1 will be the step at which we can remove this element and we will update the segment tree accordingly.\\n\\n```\\nclass Solution\\n{\\npublic:\\n    const int N = 1e5 + 5;\\n    struct tree\\n    {\\n        int t[400020];\\n        // Dont use build tree better use point update\\n\\n        void update(int v, int tl, int tr, int pos, int val)\\n        {\\n            if (tl == tr)\\n            {\\n                t[v] = val;\\n                return;\\n            }\\n            int mid = (tl + tr) / 2;\\n            if (pos <= mid)\\n                update(2 * v, tl, mid, pos, val);\\n            else\\n                update(2 * v + 1, mid + 1, tr, pos, val);\\n            t[v] = max(t[2 * v], t[2 * v + 1]);\\n        }\\n\\n        int query(int v, int tl, int tr, int l, int r)\\n        {\\n            if (tr < l || tl > r)\\n                return 0;\\n            if (l <= tl && tr <= r)\\n                return t[v];\\n            int mid = (tl + tr) / 2;\\n            return max(query(2 * v, tl, mid, l, r), query(2 * v + 1, mid + 1, tr, l, r));\\n        }\\n        void clr(int n)\\n        {\\n            for (int i = 0; i < 4 * n + 5; i++)\\n                t[i] = 0;\\n        }\\n    };\\n    int totalSteps(vector<int> &nums)\\n    {\\n        tree seg;\\n\\n        int n = nums.size();\\n        seg.clr(n + 1);\\n        int dp[n];\\n        memset(dp, 0, sizeof(dp));\\n        stack<int> stk;\\n        stk.push(0);\\n        seg.update(1, 0, n, 0, 0);\\n        int ans = 0;\\n        for (int i = 1; i < n; i++)\\n        {\\n            while (stk.size() && nums[stk.top()] <= nums[i])\\n                stk.pop();\\n            if (stk.size())\\n            {\\n                int mn = seg.query(1, 0, n, stk.top() + 1, i);\\n                dp[i] = mn + 1;\\n                seg.update(1, 0, n, i, dp[i]);\\n            }\\n            stk.push(i);\\n            ans = max(ans, dp[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Tree",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    const int N = 1e5 + 5;\\n    struct tree\\n    {\\n        int t[400020];\\n        // Dont use build tree better use point update\\n\\n        void update(int v, int tl, int tr, int pos, int val)\\n        {\\n            if (tl == tr)\\n            {\\n                t[v] = val;\\n                return;\\n            }\\n            int mid = (tl + tr) / 2;\\n            if (pos <= mid)\\n                update(2 * v, tl, mid, pos, val);\\n            else\\n                update(2 * v + 1, mid + 1, tr, pos, val);\\n            t[v] = max(t[2 * v], t[2 * v + 1]);\\n        }\\n\\n        int query(int v, int tl, int tr, int l, int r)\\n        {\\n            if (tr < l || tl > r)\\n                return 0;\\n            if (l <= tl && tr <= r)\\n                return t[v];\\n            int mid = (tl + tr) / 2;\\n            return max(query(2 * v, tl, mid, l, r), query(2 * v + 1, mid + 1, tr, l, r));\\n        }\\n        void clr(int n)\\n        {\\n            for (int i = 0; i < 4 * n + 5; i++)\\n                t[i] = 0;\\n        }\\n    };\\n    int totalSteps(vector<int> &nums)\\n    {\\n        tree seg;\\n\\n        int n = nums.size();\\n        seg.clr(n + 1);\\n        int dp[n];\\n        memset(dp, 0, sizeof(dp));\\n        stack<int> stk;\\n        stk.push(0);\\n        seg.update(1, 0, n, 0, 0);\\n        int ans = 0;\\n        for (int i = 1; i < n; i++)\\n        {\\n            while (stk.size() && nums[stk.top()] <= nums[i])\\n                stk.pop();\\n            if (stk.size())\\n            {\\n                int mn = seg.query(1, 0, n, stk.top() + 1, i);\\n                dp[i] = mn + 1;\\n                seg.update(1, 0, n, i, dp[i]);\\n            }\\n            stk.push(i);\\n            ans = max(ans, dp[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677450,
                "title": "stack-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        stack<pair<int,int>>st;\\n        int n=nums.size();\\n        int ans=0;\\n        st.push({nums[n-1],0});\\n       for(int i=n-2;i>=0;i--){\\n            int cnt=0;\\n            while(!st.empty() && st.top().first<nums[i]){\\n                \\n                cnt=max(cnt+1,st.top().second);\\n                st.pop();\\n            }\\n            ans=max(cnt,ans);\\n            st.push({nums[i],cnt});\\n       } \\n\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        stack<pair<int,int>>st;\\n        int n=nums.size();\\n        int ans=0;\\n        st.push({nums[n-1],0});\\n       for(int i=n-2;i>=0;i--){\\n            int cnt=0;\\n            while(!st.empty() && st.top().first<nums[i]){\\n                \\n                cnt=max(cnt+1,st.top().second);\\n                st.pop();\\n            }\\n            ans=max(cnt,ans);\\n            st.push({nums[i],cnt});\\n       } \\n\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511494,
                "title": "efficient-algorithm-for-making-an-array-non-decreasing-with-step-by-step-visualization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem asks us to find the minimum number of steps required to make the input array non-decreasing. One way to approach this problem is to keep track of the elements in the array that need to be removed in order to make it non-decreasing.\\n\\nTo make the given array non-decreasing, we need to remove the elements that violate the non-decreasing condition. The idea is to make the smallest possible modifications to the array to make it non-decreasing. Therefore, we can choose to remove the elements that are smaller than the previous element and make them equal to the previous element. This way, we only need to modify the array elements that violate the non-decreasing condition. We can count the number of modifications made to the array to make it non-decreasing, which gives us the number of steps required to solve the problem.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo implement the above intuition, we can iterate over the input array and check if the current element is smaller than the previous element. If it is smaller, we remove the current element and make it equal to the previous element. We also update the steps count by the difference between the previous element and the current element. At the end of the loop, we would have made all necessary modifications to the array to make it non-decreasing. The steps count gives us the number of modifications made to the array to achieve this condition. We return this count as the final result.\\n\\n\\nWe can use a stack to keep track of the elements in the array that need to be removed. We iterate through the input array and for each element, we check if it is greater than or equal to the top element of the stack. If it is, we pop elements from the stack until we find an element that is greater than the current element or until the stack is empty. We then update a variable temp with the maximum value of the second element of the tuples in the stack. If the stack is not empty, we increment temp by 1. Otherwise, we set temp to 0. We then update a variable steps with the maximum value of steps and temp. Finally, we append a tuple containing the current element and temp to the stack.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity: The time complexity of our approach is O(n), where n is the length of the input array. We are iterating over the input array only once, and the time taken to modify an element is constant. Therefore, the overall time complexity of our approach is linear.\\n\\nTime complexity: O(n)\\n\\nThe time complexity of this solution is linear because we iterate through the input array once and for each element, we perform a constant number of operations.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity: The space complexity of our approach is O(1), as we are not using any extra data structures to store the intermediate results. We are modifying the input array in-place, so there is no extra space used apart from the input array itself. Therefore, the space complexity of our approach is constant.\\n\\n\\nSpace complexity: O(n)\\n\\nThe space complexity of this solution is linear because we use a stack to keep track of the elements in the array that need to be removed.\\n\\n\\n![download.png](https://assets.leetcode.com/users/images/94e3429f-e8b7-4f5f-b761-ed907c2a835b_1683789403.5844448.png)\\n\\n\\n\\n\\n\\n# Code\\n```C++ []\\n\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        stack<pair<int, int>> stack;\\n        stack.push({nums[0], 0});\\n        int steps = 0;\\n        for (int i = 1; i < nums.size(); i++) {\\n            int temp = 0;\\n            while (!stack.empty() && stack.top().first <= nums[i]) {\\n                temp = max(temp, stack.top().second);\\n                stack.pop();\\n            }\\n            if (!stack.empty()) {\\n                temp += 1;\\n            } else {\\n                temp = 0;\\n            }\\n            steps = max(steps, temp);\\n            stack.push({nums[i], temp});\\n        }\\n        return steps;\\n    }\\n};\\n\\n```\\n```python []\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        stack = [[nums[0], 0]]\\n        steps = 0\\n        for num in nums[1:]:\\n            temp = 0\\n            while stack and stack[-1][0] <= num:\\n                temp = max(temp, stack[-1][1])\\n                stack.pop()\\n            if stack:\\n                temp += 1\\n            else:\\n                temp = 0\\n            steps = max(steps, temp)\\n            stack.append([num, temp])\\n        return steps\\n\\n```\\n```java []\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        Stack<int[]> stack = new Stack<>();\\n        stack.push(new int[]{nums[0], 0});\\n        int steps = 0;\\n        for (int i = 1; i < nums.length; i++) {\\n            int temp = 0;\\n            while (!stack.isEmpty() && stack.peek()[0] <= nums[i]) {\\n                temp = Math.max(temp, stack.peek()[1]);\\n                stack.pop();\\n            }\\n            if (!stack.isEmpty()) {\\n                temp += 1;\\n            } else {\\n                temp = 0;\\n            }\\n            steps = Math.max(steps, temp);\\n            stack.push(new int[]{nums[i], temp});\\n        }\\n        return steps;\\n    }\\n}\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```C++ []\\n\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        stack<pair<int, int>> stack;\\n        stack.push({nums[0], 0});\\n        int steps = 0;\\n        for (int i = 1; i < nums.size(); i++) {\\n            int temp = 0;\\n            while (!stack.empty() && stack.top().first <= nums[i]) {\\n                temp = max(temp, stack.top().second);\\n                stack.pop();\\n            }\\n            if (!stack.empty()) {\\n                temp += 1;\\n            } else {\\n                temp = 0;\\n            }\\n            steps = max(steps, temp);\\n            stack.push({nums[i], temp});\\n        }\\n        return steps;\\n    }\\n};\\n\\n```\n```python []\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        stack = [[nums[0], 0]]\\n        steps = 0\\n        for num in nums[1:]:\\n            temp = 0\\n            while stack and stack[-1][0] <= num:\\n                temp = max(temp, stack[-1][1])\\n                stack.pop()\\n            if stack:\\n                temp += 1\\n            else:\\n                temp = 0\\n            steps = max(steps, temp)\\n            stack.append([num, temp])\\n        return steps\\n\\n```\n```java []\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        Stack<int[]> stack = new Stack<>();\\n        stack.push(new int[]{nums[0], 0});\\n        int steps = 0;\\n        for (int i = 1; i < nums.length; i++) {\\n            int temp = 0;\\n            while (!stack.isEmpty() && stack.peek()[0] <= nums[i]) {\\n                temp = Math.max(temp, stack.peek()[1]);\\n                stack.pop();\\n            }\\n            if (!stack.isEmpty()) {\\n                temp += 1;\\n            } else {\\n                temp = 0;\\n            }\\n            steps = Math.max(steps, temp);\\n            stack.push(new int[]{nums[i], temp});\\n        }\\n        return steps;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3246670,
                "title": "c-solution-o-n",
                "content": "# Complexity\\n- Time complexity:\\n   O(n)\\n\\n- Space complexity:\\n  O(n) --- (using stack)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n         int n = nums.size();\\n         int result = 0;\\n         stack<pair<int , int>> st;\\n         st.push({nums[n-1] , 0});\\n         for(int i = n - 2 ; i>=0 ; i--){\\n             int count = 0;\\n             while(st.size() && st.top().first < nums[i]){\\n                 int node = st.top().first;\\n                 int ways = st.top().second;\\n\\n                 st.pop();\\n\\n                 if(ways <= count)count++;\\n                 else count = ways;\\n             }\\n            //  result = max(result , count);\\n             st.push({nums[i] , count});\\n         }\\n         while(st.size()){\\n             result = max(result , st.top().second);\\n             st.pop();\\n         }\\n         return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n         int n = nums.size();\\n         int result = 0;\\n         stack<pair<int , int>> st;\\n         st.push({nums[n-1] , 0});\\n         for(int i = n - 2 ; i>=0 ; i--){\\n             int count = 0;\\n             while(st.size() && st.top().first < nums[i]){\\n                 int node = st.top().first;\\n                 int ways = st.top().second;\\n\\n                 st.pop();\\n\\n                 if(ways <= count)count++;\\n                 else count = ways;\\n             }\\n            //  result = max(result , count);\\n             st.push({nums[i] , count});\\n         }\\n         while(st.size()){\\n             result = max(result , st.top().second);\\n             st.pop();\\n         }\\n         return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3140147,
                "title": "stack-with-intuition-and-intuition-explanation",
                "content": "# Intuition\\nSince the current element will be removed when there is an element greater than it, we should process from backward to the front. Since the stack can help you determine where the nearest element that is greater than the current element (739. Daily Temperatures) is on the left or right side, we should use the stack!\\n\\nThe key to this concept is to know in which round(s) the following element will be removed for each element. Then find the maximum of those rounds.\\n\\n# Approach\\nTo find the round(s) that will be removed from each element, the first step is to determine the nearest element on the left side that is greater than it and find the difference between the indexes. For example, in 5 3 2 1, you can see that 3, 2, and 1 will be removed at the first round since each of them on the left has the greater element and the difference between the indexes is \"1.\"\\n\\nIf we apply the same approach to Example 5 (3, 4, 4, 7), we can see that the maximum round is 3 because the element at index 3 is 3 units away from the first index (3-0 = 3).\\n\\nThis approach seems nice, but the only problem here is that sometimes the leftmost greater element may come closer than it should be in some rounds! For example, in 7 14 4 14 13 2 6 13, the most left element that is greater than the last element is 14, which is on the third index, and the difference index between them is 4, but in the first round, the index numbers 2, 4, and 5 are removed, so it now becomes [7, 14, 14, 6, 13], and the difference between the index of the last element and its most left greatest element is now 2, (4-2 = 2), indicating that it is closer than it should be. So this approach will fail, but we should figure out how many rounds the left element can survive.\\n\\nSo we should record some data, which is what round(s) their left-side element will be removed, and now when we want to remove some elements, we will use this record to determine what round the left-side element can survive to determine the current element. To explain in words is cumbersome, so please look at the code.\\n\\n# Complexity\\n- Time complexity:\\n$$\\u0398(n)$$\\n\\n- Space complexity:\\n$$\\u0398(n)$$\\n\\n# Code\\n```\\n#include<iostream>\\n#include<vector>\\n#include<stack>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        const int N = (int)nums.size();\\n        if(N == 1) return 0;\\n\\n        int maxround = 0;\\n        // stack will keep the index of the element.\\n        stack<int> stack{};\\n        vector<int> records(N);\\n\\n        for(int i = N-1; i >= 0;--i){\\n            while(!stack.empty() && nums[stack.top()] < nums[i]){\\n                // Since it found the most left element that is greather than the current element\\n                // The current round is the maximum round(s) record that the currently removed element knows + 1.\\n                int current = records[stack.top()] + 1;\\n                maxround = max(maxround,current);\\n                stack.pop();\\n                // So we inform the maximum round that this element can survive to the next element after that.\\xA0\\n                // When it is removed, it will know what the maximum is by determining the maximum record that we saved.\\n                if(!stack.empty()) \\n                    records[stack.top()] = max(records[stack.top()],current);\\n            }\\n            stack.push(i);\\n        }\\n\\n        return maxround;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include<iostream>\\n#include<vector>\\n#include<stack>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        const int N = (int)nums.size();\\n        if(N == 1) return 0;\\n\\n        int maxround = 0;\\n        // stack will keep the index of the element.\\n        stack<int> stack{};\\n        vector<int> records(N);\\n\\n        for(int i = N-1; i >= 0;--i){\\n            while(!stack.empty() && nums[stack.top()] < nums[i]){\\n                // Since it found the most left element that is greather than the current element\\n                // The current round is the maximum round(s) record that the currently removed element knows + 1.\\n                int current = records[stack.top()] + 1;\\n                maxround = max(maxround,current);\\n                stack.pop();\\n                // So we inform the maximum round that this element can survive to the next element after that.\\xA0\\n                // When it is removed, it will know what the maximum is by determining the maximum record that we saved.\\n                if(!stack.empty()) \\n                    records[stack.top()] = max(records[stack.top()],current);\\n            }\\n            stack.push(i);\\n        }\\n\\n        return maxround;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2697579,
                "title": "java-solution-explanation",
                "content": "```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        int n = nums.length;\\n        //Stack of pairs consists of nums value and count\\n        Stack<Pair<Integer,Integer>> stack = new Stack();\\n        \\n        //Push the last element of nums in to stack\\n        stack.push(new Pair<>(nums[n-1],0));\\n        \\n        int ans = 0;\\n        \\n        //traverse from right left of nums\\n        for(int i = n-2;i>=0;i--){\\n            \\n            int count = 0;\\n            \\n            while(!stack.isEmpty() && nums[i]>stack.peek().getKey()){\\n                \\n//Count determines max how many times the condition nums[i-1]>nums[i] is encountured\\n                count = Math.max(count+1,stack.peek().getValue());\\n                \\n    //After that remove the top pair from the stack\\n                stack.pop();\\n            }\\n            \\n            //The maximum steps depends on the maximum count in each step\\n            //So, make sure to calculate maximum of count\\'s\\n            ans  = Math.max(ans,count);\\n            \\n            //Add next element of the nums in to stack with present count\\n            stack.push(new Pair(nums[i],count));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        int n = nums.length;\\n        //Stack of pairs consists of nums value and count\\n        Stack<Pair<Integer,Integer>> stack = new Stack();\\n        \\n        //Push the last element of nums in to stack\\n        stack.push(new Pair<>(nums[n-1],0));\\n        \\n        int ans = 0;\\n        \\n        //traverse from right left of nums\\n        for(int i = n-2;i>=0;i--){\\n            \\n            int count = 0;\\n            \\n            while(!stack.isEmpty() && nums[i]>stack.peek().getKey()){\\n                \\n//Count determines max how many times the condition nums[i-1]>nums[i] is encountured\\n                count = Math.max(count+1,stack.peek().getValue());\\n                \\n    //After that remove the top pair from the stack\\n                stack.pop();\\n            }\\n            \\n            //The maximum steps depends on the maximum count in each step\\n            //So, make sure to calculate maximum of count\\'s\\n            ans  = Math.max(ans,count);\\n            \\n            //Add next element of the nums in to stack with present count\\n            stack.push(new Pair(nums[i],count));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2571209,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\nint totalSteps(vector& nums) {\\nint n=nums.size(); //Taking the size of the array\\nstack<pair<int,int>>st; //making a stack of pair type to hold the key value pair\\n//in key placeholder I will store the element and in value placeholder I will hold the number of rounds.\\nint ans=0;\\nst.push({nums[n-1],0}); //storing the first element from right\\nfor(int i=n-2;i>=0;i--) //start to iterate from the second last element\\n{\\nint count=0;\\nwhile(!st.empty() and nums[i]>st.top().first) //if the element pushed at the top of the stack is greater than the element which was previously at the top then we will remove the previous element and increase the count against the number of elements which is popped out\\n{\\ncount=max(count+1,st.top().second);\\nst.pop();\\n\\n        }\\n        \\n        ans=max(ans,count);\\n        st.push({nums[i],count});  //else simply push the element\\n    }\\n    return ans;\\n}\\n};\\n``",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\nint totalSteps(vector& nums) {\\nint n=nums.size(); //Taking the size of the array\\nstack<pair<int,int>>st; //making a stack of pair type to hold the key value pair\\n//in key placeholder I will store the element and in value placeholder I will hold the number of rounds.\\nint ans=0;\\nst.push({nums[n-1],0}",
                "codeTag": "Java"
            },
            {
                "id": 2516529,
                "title": "java-stack-time-o-n-space-o-n",
                "content": "```Java\\nclass Solution {\\n/*\\n\\t[6,4,3,2,5,14,15,2,11,5,13,15]\\n\\t 6,        14,15,          15 \\n\\n\\t the process of delete 4,3,2,5\\n\\t stack: []\\n\\t detele 4\\n\\t stack: [4, 1]   // [value, deleteCount]\\n\\t delete 3\\n\\t stack: [4, 1], [3, 1]\\n\\t delete 2\\n\\t stack: [4, 1], [3, 1], [2, 1]\\n\\t detele 5, \\n\\t 5 is greater or equal to 2, pop [2, 1], max = Math(max, 1 + 1) = 2;\\n\\t 5 is greater or equal to 3, pop [3, 1], max = Math(max, 1 + 1) = 2;\\n\\t 5 is greater or equal to 3, pop [4, 1], max = Math(max, 1 + 1) = 2;\\n\\t push [5, 2]\\n\\t stack: [5, 2]\\n\\n\\t the process of delete 2, 11, 5, 13\\n\\t delete 2\\n\\t stack: [2, 1]\\n\\t detete 11\\n\\t stack: [11, 2]\\n\\t delete 5\\n\\t stack:[11, 2], [5, 1]\\n\\t delete 13\\n\\t stack:[13, 3]\\n*/\\n\\n\\tpublic int totalSteps(int[] nums) {\\n\\t\\tint res = 0;\\n\\t\\tint n = nums.length;\\n\\n\\t\\tStack<int[]> stack = new Stack<>(); // int[]{value, deleteCount}\\n\\t\\tint maxValue = nums[0];\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tif (nums[i] >= maxValue) {\\n\\t\\t\\t\\tmaxValue = nums[i];\\n\\t\\t\\t\\tstack = new Stack<>();\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tint max = 1;\\n\\t\\t\\twhile (!stack.empty() && stack.peek()[0] <= nums[i]) {\\n\\t\\t\\t\\tmax = Math.max(max, 1 + stack.pop()[1]);\\n\\t\\t\\t}\\n\\t\\t\\tres = Math.max(res, max);\\n\\t\\t\\tstack.push(new int[]{nums[i], max});\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```Java\\nclass Solution {\\n/*\\n\\t[6,4,3,2,5,14,15,2,11,5,13,15]\\n\\t 6,        14,15,          15 \\n\\n\\t the process of delete 4,3,2,5\\n\\t stack: []\\n\\t detele 4\\n\\t stack: [4, 1]   // [value, deleteCount]\\n\\t delete 3\\n\\t stack: [4, 1], [3, 1]\\n\\t delete 2\\n\\t stack: [4, 1], [3, 1], [2, 1]\\n\\t detele 5, \\n\\t 5 is greater or equal to 2, pop [2, 1], max = Math(max, 1 + 1) = 2;\\n\\t 5 is greater or equal to 3, pop [3, 1], max = Math(max, 1 + 1) = 2;\\n\\t 5 is greater or equal to 3, pop [4, 1], max = Math(max, 1 + 1) = 2;\\n\\t push [5, 2]\\n\\t stack: [5, 2]\\n\\n\\t the process of delete 2, 11, 5, 13\\n\\t delete 2\\n\\t stack: [2, 1]\\n\\t detete 11\\n\\t stack: [11, 2]\\n\\t delete 5\\n\\t stack:[11, 2], [5, 1]\\n\\t delete 13\\n\\t stack:[13, 3]\\n*/\\n\\n\\tpublic int totalSteps(int[] nums) {\\n\\t\\tint res = 0;\\n\\t\\tint n = nums.length;\\n\\n\\t\\tStack<int[]> stack = new Stack<>(); // int[]{value, deleteCount}\\n\\t\\tint maxValue = nums[0];\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tif (nums[i] >= maxValue) {\\n\\t\\t\\t\\tmaxValue = nums[i];\\n\\t\\t\\t\\tstack = new Stack<>();\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tint max = 1;\\n\\t\\t\\twhile (!stack.empty() && stack.peek()[0] <= nums[i]) {\\n\\t\\t\\t\\tmax = Math.max(max, 1 + stack.pop()[1]);\\n\\t\\t\\t}\\n\\t\\t\\tres = Math.max(res, max);\\n\\t\\t\\tstack.push(new int[]{nums[i], max});\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2328058,
                "title": "c-easy-solution-using-stack",
                "content": "**Please Upvote**\\n```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int ans=0;\\n        \\n        stack<pair<int,int>>s;\\n        \\n        for(int i=nums.size()-1;i>=0;i--){\\n            if(s.empty())s.push({nums[i],0});\\n            \\n            else{\\n                int a=0;\\n                while(!s.empty() && s.top().first<nums[i]){\\n                    a=max(a+1,s.top().second);\\n                    s.pop();\\n                }\\n                s.push({nums[i],a});\\n                ans=max(ans,a);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int ans=0;\\n        \\n        stack<pair<int,int>>s;\\n        \\n        for(int i=nums.size()-1;i>=0;i--){\\n            if(s.empty())s.push({nums[i],0}",
                "codeTag": "Java"
            },
            {
                "id": 2232808,
                "title": "c-stack-o-n-easy-code-for-beginners",
                "content": "```\\nint totalSteps(vector<int>& nums) {\\n        int n = nums.size();\\n        stack<pair<int, int> > stk;\\n        int ans = 0;\\n        //first: number itself\\n        //second: the step in which it will get deleted\\n        //first element will never get deleted so its second param is 0\\n        stk.push({nums[0], 0});\\n        for (int i = 1; i < n; i++) {\\n            int mx = 0;\\n            while (!stk.empty() && stk.top().first <= nums[i]) {\\n                mx = max(mx, stk.top().second);\\n                stk.pop();\\n            }\\n            if (stk.empty()) {\\n                stk.push({nums[i], 0});\\n                continue;\\n            } else {\\n                stk.push({nums[i], mx + 1});\\n            }\\n            ans = max(ans, mx + 1);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nint totalSteps(vector<int>& nums) {\\n        int n = nums.size();\\n        stack<pair<int, int> > stk;\\n        int ans = 0;\\n        //first: number itself\\n        //second: the step in which it will get deleted\\n        //first element will never get deleted so its second param is 0\\n        stk.push({nums[0], 0});\\n        for (int i = 1; i < n; i++) {\\n            int mx = 0;\\n            while (!stk.empty() && stk.top().first <= nums[i]) {\\n                mx = max(mx, stk.top().second);\\n                stk.pop();\\n            }\\n            if (stk.empty()) {\\n                stk.push({nums[i], 0});\\n                continue;\\n            } else {\\n                stk.push({nums[i], mx + 1});\\n            }\\n            ans = max(ans, mx + 1);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2202868,
                "title": "c-stack-pair-great-question",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        stack<pair<int, int>> st;\\n        st.push({nums[0], 0});\\n        int n = nums.size();\\n        int ans = 0;\\n        \\n        for(int i = 1; i < n; i++) {\\n            int cnt = 0;\\n            while(!st.empty() && st.top().first <= nums[i]) {\\n                cnt = max(cnt, st.top().second); // max of steps to remove (=)smaller elements before nums[i]\\n                st.pop();\\n            }\\n            \\n            if(st.empty()) { // no smaller element before nums[i], or nums[i] is largest element encountered so far\\n                cnt = 0;\\n            } else {\\n                cnt = cnt + 1; // there is a larger element somewhere before nums[i]\\n            }\\n            ans = max(ans, cnt);\\n            st.push({nums[i], cnt});\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        stack<pair<int, int>> st;\\n        st.push({nums[0], 0});\\n        int n = nums.size();\\n        int ans = 0;\\n        \\n        for(int i = 1; i < n; i++) {\\n            int cnt = 0;\\n            while(!st.empty() && st.top().first <= nums[i]) {\\n                cnt = max(cnt, st.top().second); // max of steps to remove (=)smaller elements before nums[i]\\n                st.pop();\\n            }\\n            \\n            if(st.empty()) { // no smaller element before nums[i], or nums[i] is largest element encountered so far\\n                cnt = 0;\\n            } else {\\n                cnt = cnt + 1; // there is a larger element somewhere before nums[i]\\n            }\\n            ans = max(ans, cnt);\\n            st.push({nums[i], cnt});\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2114786,
                "title": "python-simple-stack-solution",
                "content": "\\n    def totalSteps(self, nums):\\n        n = len(nums)\\n        \\n        dp, stack = [0]*n, []\\n        \\n        for i in range(n-1, -1, -1):\\n            while stack and nums[i] > nums[stack[-1]]:\\n                dp[i] = max(dp[i] + 1, dp[stack.pop()])\\n            stack.append(i)\\n            \\n        return max(dp)",
                "solutionTags": [],
                "code": "\\n    def totalSteps(self, nums):\\n        n = len(nums)\\n        \\n        dp, stack = [0]*n, []\\n        \\n        for i in range(n-1, -1, -1):\\n            while stack and nums[i] > nums[stack[-1]]:\\n                dp[i] = max(dp[i] + 1, dp[stack.pop()])\\n            stack.append(i)\\n            \\n        return max(dp)",
                "codeTag": "Python3"
            },
            {
                "id": 2113732,
                "title": "c-dp-stacks",
                "content": "The bruteforce approach would be to create a buffer array and push all the elements in it that satisfies the criteria to not be deleted, i.e. ```A[i-1] <= A[i]```\\nAnd after one traversal, swap the buffer array with the original array.\\nThese steps would be repeated until all elements in the array are in non-decreasing order.\\nBut this approach would throw TLE for ```n > 10^4```\\n\\nOptimal approach.\\nFor every element ```i```, we can find the number of consecutive elements less than it on the right side and save it in ```dp[i]```.\\nThen we can get the max steps as the max of all the ```dp[i]```.\\n\\n**Time Complexity:** ```O(n)```\\n\\n**Code:**\\n```\\n    int totalSteps(vector<int>& A) {\\n        int n = A.size(), steps = 0;\\n        vector<int> dp(n);\\n        stack<int> stack;\\n        \\n        for (int i=n-1 ; i>=0 ; i--) {\\n            while(!stack.empty() && A[i] > A[stack.top()]) {\\n                dp[i] = max(++dp[i], dp[stack.top()]);\\n                stack.pop();\\n                steps = max(steps, dp[i]);\\n            }\\n            stack.push(i);\\n        }\\n        \\n        return steps;\\n    }\\n```",
                "solutionTags": [],
                "code": "```A[i-1] <= A[i]```\n```n > 10^4```\n```i```\n```dp[i]```\n```dp[i]```\n```O(n)```\n```\\n    int totalSteps(vector<int>& A) {\\n        int n = A.size(), steps = 0;\\n        vector<int> dp(n);\\n        stack<int> stack;\\n        \\n        for (int i=n-1 ; i>=0 ; i--) {\\n            while(!stack.empty() && A[i] > A[stack.top()]) {\\n                dp[i] = max(++dp[i], dp[stack.top()]);\\n                stack.pop();\\n                steps = max(steps, dp[i]);\\n            }\\n            stack.push(i);\\n        }\\n        \\n        return steps;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2105211,
                "title": "c-element-which-finishes-last-monostack",
                "content": "* Solution Inspired By [Lee\\'s Post](https://leetcode.com/problems/steps-to-make-array-non-decreasing/discuss/2085864/JavaC%2B%2BPython-Stack-%2B-DP-%2B-Explanation-%2B-Poem)\\n* Element Which is greater than its immediate right element will eliminate the right element. (`ith` element gets deleted when `(i-1)th` element is greater).\\n* So , for all the indices `i` , where `nums[i-1]` `> nums[i]` , we have to find the index which will Keep on terminating the elements on its right for longer duration.\\n* For example, Consider the array [**2**,1,3,**4**,3,3,**5**,4,4,4], In This array Elements 2 , 4 and 5 (in Bold) are bigger than their just next right element. (i-1 > i)\\n* Each Element will simultaneously terminate elements on their immediate right, so that means, **2** will terminate -> 1 (in total 1 step) || **4** will terminate 3,3 (in total 2 steps-> in first steps 1st 3 get terminated and then in second steps 2nd 3 gets terminated) || **5** will terminate 4,4,4(in total 3 steps) , so the When all the elements simultaneously start terminating ,  the element which finishes last will yeild our steps (answer) . Here , answer will be 3 steps. \\n* Maintain a dp array and Start from the back of the array and Maintain elements  in decreasing order in stack , when a bigger elements is encountered , do calculations as mentioned below. dp[i] states the number of elements which the `ith` element can terminate to its right.\\n\\n```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n\\t   // i-1 terminates i\\n        stack<int> st ;\\n        vector<int> dp(nums.size(),0) ;\\n        int steps = 0 ;\\n        \\n        for(int i = nums.size() - 1 ; i >= 0 ; --i ){\\n            while(st.size() and nums[i] > nums[st.top()]){\\n                dp[i] = max(dp[i] + 1 , dp[st.top()]) ;\\n                st.pop() ;\\n            }\\n            steps = max(steps,dp[i]) ; //Elements which finishes last with max number of steps taken\\n            st.push(i) ;\\n        }\\n        \\n        return steps ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n\\t   // i-1 terminates i\\n        stack<int> st ;\\n        vector<int> dp(nums.size(),0) ;\\n        int steps = 0 ;\\n        \\n        for(int i = nums.size() - 1 ; i >= 0 ; --i ){\\n            while(st.size() and nums[i] > nums[st.top()]){\\n                dp[i] = max(dp[i] + 1 , dp[st.top()]) ;\\n                st.pop() ;\\n            }\\n            steps = max(steps,dp[i]) ; //Elements which finishes last with max number of steps taken\\n            st.push(i) ;\\n        }\\n        \\n        return steps ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2102500,
                "title": "simple-stack-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        reverse(nums.begin(), nums.end());\\n        vector<array<int, 2>> stk;\\n        int ans{0};\\n        for (int i : nums) {\\n            array<int, 2> p{i, 0};\\n            while(!stk.empty() && stk.back()[0] < p[0]) {\\n                p[1] = max(p[1] + 1, stk.back()[1]);\\n                stk.pop_back();\\n            }\\n            ans = max(ans, p[1]);\\n            stk.push_back(p);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        reverse(nums.begin(), nums.end());\\n        vector<array<int, 2>> stk;\\n        int ans{0};\\n        for (int i : nums) {\\n            array<int, 2> p{i, 0};\\n            while(!stk.empty() && stk.back()[0] < p[0]) {\\n                p[1] = max(p[1] + 1, stk.back()[1]);\\n                stk.pop_back();\\n            }\\n            ans = max(ans, p[1]);\\n            stk.push_back(p);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2100010,
                "title": "java-mono-stack",
                "content": "```\\npublic int totalSteps(int[] nums) {\\n\\t// mono-stack of peaks: [ peak value, length of non-decreasing streak leading to peak ]\\n\\tLinkedList<int[]> stack= new LinkedList<>();\\n\\tint ans= 0;\\n\\tfor(int i=1, streak= 0; i<nums.length; i++){\\n\\t\\tif(nums[i]<nums[i-1]){\\n\\t\\t\\tstack.addLast(new int[]{nums[i-1], streak});\\n\\t\\t\\tstreak= 1;\\n\\t\\t}else{\\n\\t\\t\\twhile(!stack.isEmpty() && nums[i]>=stack.peekLast()[0])\\n\\t\\t\\t\\tstreak= Math.max(streak, stack.removeLast()[1]);\\n\\t\\t\\tstreak= stack.isEmpty() ? 0 : streak+1;\\n\\t\\t}\\n\\t\\tans= Math.max(ans, streak);\\n\\t}\\n\\treturn ans;\\n}",
                "solutionTags": [],
                "code": "```\\npublic int totalSteps(int[] nums) {\\n\\t// mono-stack of peaks: [ peak value, length of non-decreasing streak leading to peak ]\\n\\tLinkedList<int[]> stack= new LinkedList<>();\\n\\tint ans= 0;\\n\\tfor(int i=1, streak= 0; i<nums.length; i++){\\n\\t\\tif(nums[i]<nums[i-1]){\\n\\t\\t\\tstack.addLast(new int[]{nums[i-1], streak});\\n\\t\\t\\tstreak= 1;\\n\\t\\t}else{\\n\\t\\t\\twhile(!stack.isEmpty() && nums[i]>=stack.peekLast()[0])\\n\\t\\t\\t\\tstreak= Math.max(streak, stack.removeLast()[1]);\\n\\t\\t\\tstreak= stack.isEmpty() ? 0 : streak+1;\\n\\t\\t}\\n\\t\\tans= Math.max(ans, streak);\\n\\t}\\n\\treturn ans;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2094970,
                "title": "c-doubly-linked-list-bfs-solution-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        \\n        list<int> ls; //doubly linked list\\n        \\n        for (auto n : nums) ls.push_back(n);\\n        \\n        \\n        auto it = ls.begin();\\n        int prev = *it;\\n        \\n        it++;\\n        \\n        queue<list<int>::iterator> q;\\n        \\n        \\n        for (; it!=ls.end(); it++){\\n            \\n            if (prev > *it){\\n                //it needs to be removed\\n                q.push(it); //push the element to be removed in the queue\\n                *it = -*it; //mark this elemtn is in the queue\\n            }\\n            \\n            prev = abs(*it);\\n        }\\n        \\n        \\n        \\n        if (q.size() == 0) return 0;\\n        \\n        int steps = 0;\\n        \\n        while(q.size()>0){\\n            \\n            int size = q.size();\\n            \\n            steps++;\\n            \\n            while(size > 0){\\n                \\n                \\n                auto it = q.front();\\n                q.pop();\\n                \\n                auto pit = --it;\\n                \\n                it++;\\n                \\n                auto nit = ++it;\\n                \\n                it--;\\n                \\n                if (it != ls.begin() && nit != ls.end()){\\n                    \\n                    if (abs(*pit) > abs(*nit) && *nit > 0) {\\n                        \\n                        //nit needs to be removed in next round\\n                        \\n                        q.push(nit);\\n                        *nit = -*nit;\\n                    }\\n                }\\n                \\n                ls.erase(it);\\n                \\n                size--;\\n            }\\n        }\\n        \\n        return steps;\\n        \\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        \\n        list<int> ls; //doubly linked list\\n        \\n        for (auto n : nums) ls.push_back(n);\\n        \\n        \\n        auto it = ls.begin();\\n        int prev = *it;\\n        \\n        it++;\\n        \\n        queue<list<int>::iterator> q;\\n        \\n        \\n        for (; it!=ls.end(); it++){\\n            \\n            if (prev > *it){\\n                //it needs to be removed\\n                q.push(it); //push the element to be removed in the queue\\n                *it = -*it; //mark this elemtn is in the queue\\n            }\\n            \\n            prev = abs(*it);\\n        }\\n        \\n        \\n        \\n        if (q.size() == 0) return 0;\\n        \\n        int steps = 0;\\n        \\n        while(q.size()>0){\\n            \\n            int size = q.size();\\n            \\n            steps++;\\n            \\n            while(size > 0){\\n                \\n                \\n                auto it = q.front();\\n                q.pop();\\n                \\n                auto pit = --it;\\n                \\n                it++;\\n                \\n                auto nit = ++it;\\n                \\n                it--;\\n                \\n                if (it != ls.begin() && nit != ls.end()){\\n                    \\n                    if (abs(*pit) > abs(*nit) && *nit > 0) {\\n                        \\n                        //nit needs to be removed in next round\\n                        \\n                        q.push(nit);\\n                        *nit = -*nit;\\n                    }\\n                }\\n                \\n                ls.erase(it);\\n                \\n                size--;\\n            }\\n        }\\n        \\n        return steps;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2091919,
                "title": "c-o-n-solution-using-linked-list-by-simulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        list<int> inds;\\n        vector<int> tbdelete;\\n        vector<int> deleted(nums.size(), 0);\\n        vector<list<int>::iterator> its;\\n        for(int i = 0; i < nums.size(); i++) {\\n            inds.push_back(i);\\n            its.push_back(prev(inds.end()));\\n            if(i && nums[i] < nums[i-1]) tbdelete.push_back(i);\\n        }\\n        \\n        int res = 0;\\n        while(!tbdelete.empty()) {\\n            vector<int> nexttb;\\n            for(int i = tbdelete.size() - 1; i >= 0; i--) {\\n                if(deleted[tbdelete[i]]) continue;\\n                auto p = its[tbdelete[i]];\\n                auto nextp = next(p);\\n                bool ends = nextp == inds.end();\\n                while(p != inds.begin() && nums[*prev(p)] > nums[*p]) {\\n                    auto pre = prev(p);\\n                    deleted[*p] = 1;\\n                    inds.erase(p);\\n                    p = pre;                    \\n                }\\n                if(!ends && nextp != inds.begin() && nums[*nextp] < nums[*prev(nextp)]) {\\n                    nexttb.push_back(*nextp);\\n                }\\n            }\\n            tbdelete.swap(nexttb);\\n            reverse(tbdelete.begin(), tbdelete.end());\\n            res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        list<int> inds;\\n        vector<int> tbdelete;\\n        vector<int> deleted(nums.size(), 0);\\n        vector<list<int>::iterator> its;\\n        for(int i = 0; i < nums.size(); i++) {\\n            inds.push_back(i);\\n            its.push_back(prev(inds.end()));\\n            if(i && nums[i] < nums[i-1]) tbdelete.push_back(i);\\n        }\\n        \\n        int res = 0;\\n        while(!tbdelete.empty()) {\\n            vector<int> nexttb;\\n            for(int i = tbdelete.size() - 1; i >= 0; i--) {\\n                if(deleted[tbdelete[i]]) continue;\\n                auto p = its[tbdelete[i]];\\n                auto nextp = next(p);\\n                bool ends = nextp == inds.end();\\n                while(p != inds.begin() && nums[*prev(p)] > nums[*p]) {\\n                    auto pre = prev(p);\\n                    deleted[*p] = 1;\\n                    inds.erase(p);\\n                    p = pre;                    \\n                }\\n                if(!ends && nextp != inds.begin() && nums[*nextp] < nums[*prev(nextp)]) {\\n                    nexttb.push_back(*nextp);\\n                }\\n            }\\n            tbdelete.swap(nexttb);\\n            reverse(tbdelete.begin(), tbdelete.end());\\n            res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2089253,
                "title": "c-monotonic-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        stack<pair<int,int>>st;\\n        int ans=0;\\n        for(int i=nums.size()-1;i>=0;--i){\\n            int c=0;\\n            while(!st.empty() && st.top().first<nums[i]){\\n                c=max(c+1,st.top().second);\\n                st.pop();\\n            }\\n            st.push({nums[i],c});\\n            ans=max(ans,c);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        stack<pair<int,int>>st;\\n        int ans=0;\\n        for(int i=nums.size()-1;i>=0;--i){\\n            int c=0;\\n            while(!st.empty() && st.top().first<nums[i]){\\n                c=max(c+1,st.top().second);\\n                st.pop();\\n            }\\n            st.push({nums[i],c});\\n            ans=max(ans,c);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2088583,
                "title": "python-stack-with-thought-process-when-being-asked-during-interviews",
                "content": "### Stack\\nThe number `nums[i]` can be removed only if there is a number `nums[j]` such that `j < i and nums[j] > nums[i]`. So we can maintian a decreasing monotonic stack to get the closet greater number if there is. \\n\\nWith this stack, we can know by which number `nums[j]`, `nums[i]` can be removed. But we need to know what\\'s the order for `nums[i]` to remove. In order to remove `nums[i]`, all of elements between `nums[j:i + 1]` have to be removed first.\\n\\nThen we can remove `nums[i]` in the next round, so the number of round we can remove `nums[i]` equals to `max(round of nums[j: i+1]) + 1`, which can be calculated when the middle element is popped out from the stack.\\n\\nNote, if there is no number left in stack after popup, the current one is largest and no need to remove.\\n\\n```python\\ndef totalSteps(self, nums: List[int]) -> int:\\n\\tstack = []\\n\\trounds = [0] * len(nums)\\n\\tfor i, num in enumerate(nums):\\n\\t\\tr = 0\\n\\t\\twhile stack and nums[stack[-1]] <= num:\\n\\t\\t\\tindex = stack.pop()\\n\\t\\t\\tr = max(r, rounds[index])\\n\\t\\tif stack:\\n\\t\\t\\trounds[i] = r + 1\\n\\t\\tstack.append(i)     \\n\\treturn max(rounds)    \\n```\\n\\n*Time Complexity*= **O(N)**\\n*Space Complexity*= **O(N)**",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```python\\ndef totalSteps(self, nums: List[int]) -> int:\\n\\tstack = []\\n\\trounds = [0] * len(nums)\\n\\tfor i, num in enumerate(nums):\\n\\t\\tr = 0\\n\\t\\twhile stack and nums[stack[-1]] <= num:\\n\\t\\t\\tindex = stack.pop()\\n\\t\\t\\tr = max(r, rounds[index])\\n\\t\\tif stack:\\n\\t\\t\\trounds[i] = r + 1\\n\\t\\tstack.append(i)     \\n\\treturn max(rounds)    \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2088235,
                "title": "stack-dp-time-o-n-space-o-n",
                "content": "\\n\\nint totalSteps(vector<int>& nums) {\\n        \\n        stack<pair<int,int>>st;\\n        \\n        \\n       int n=nums.size();\\n        \\n       \\n        \\n        vector<int>dp(n+1,0);\\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n            while(!st.empty() && nums[i]>st.top().first)\\n            {\\n                dp[i]=max(dp[i]+1,st.top().second);\\n                st.pop();\\n            }\\n            \\n            \\n            st.push({nums[i],dp[i]});\\n        }\\n    \\n        int ans=0;\\n        \\n        for(int i=0;i<n;i++){ ans=max(ans,dp[i]);}\\n        \\n        return ans;\\n        \\n    }",
                "solutionTags": [
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "\\n\\nint totalSteps(vector<int>& nums) {\\n        \\n        stack<pair<int,int>>st;\\n        \\n        \\n       int n=nums.size();\\n        \\n       \\n        \\n        vector<int>dp(n+1,0);\\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n            while(!st.empty() && nums[i]>st.top().first)\\n            {\\n                dp[i]=max(dp[i]+1,st.top().second);\\n                st.pop();\\n            }\\n            \\n            \\n            st.push({nums[i],dp[i]});\\n        }\\n    \\n        int ans=0;\\n        \\n        for(int i=0;i<n;i++){ ans=max(ans,dp[i]);}\\n        \\n        return ans;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2086690,
                "title": "java-o-n-monotonic-stack",
                "content": "rounds[i] is the deletion round for nums[i], and nums[i] will be deleted if there is a nums[j] >= nums[i] and j < i. Starting from begining of array, we push element into decreasing monotonic stack.  \\n1. if new element can be added to stack directly without any popup, which means it is less than left neighbor in nums array ( top of stack ), and can be deleted in 1 round.\\n2. if new element is not on the bottom of stack ( which means there is still at least one element bigger than it, and it still need to be deleted), and need to popup several elements before we can add this new element, then it will take the maximum round of the popup element + 1 to delete it.\\n3. If new element is on the bottom of stack, then it is the highest value up to current index, and it will not be deleted ( round = 0 )\\nAfter all items be added to stack, find the maximum rounds[i] as the result.\\n```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        int n = nums.length, rounds[] = new int[n];\\n        Stack<Integer> stack = new Stack<>();\\n        for (int i = 0; i < n; i++) {\\n            int deleteRound = 1;\\n            while (!stack.isEmpty() && nums[i] >= nums[stack.peek()]) {\\n                deleteRound = Math.max(deleteRound, rounds[stack.pop()] + 1);\\n            }\\n            rounds[i] = stack.isEmpty() ? 0 : deleteRound;\\n            stack.push(i);\\n        }\\n        int result = 0;\\n        for (int i : rounds) {\\n            result = Math.max(result, i);\\n        }   \\n        return result;\\n    }\\n}",
                "solutionTags": [
                    "Monotonic Stack"
                ],
                "code": "class Solution {\\n    public int totalSteps(int[] nums) {\\n        int n = nums.length, rounds[] = new int[n];\\n        Stack<Integer> stack = new Stack<>();\\n        for (int i = 0; i < n; i++) {\\n            int deleteRound = 1;\\n            while (!stack.isEmpty() && nums[i] >= nums[stack.peek()]) {\\n                deleteRound = Math.max(deleteRound, rounds[stack.pop()] + 1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2086296,
                "title": "python-two-o-n-simulation-approach-1-union-find-2-double-ended-queue",
                "content": "# Simulation\\n\\nTo simulate this question, the goal is: we need some techniques that can find the removed points in next round without traversal whole array. Here are two ways to do it.\\n\\n## Union Find\\nIn union function, If we always point to the left/right side, we can easily find the leftmost/rightmost idx in a group. That means, \\n- in node deletion, we can do **union(leftmost idx in previous group, leftmost idx in current group)**\\n- to find nxt round removed candidates, check **(current unioned group, nxt group)**. To find the nxt group, we need to find the rightmost idx in current group and add it by 1 then we can go to the next group;\\n\\n```python\\nclass UF:\\n    def __init__(self, n):\\n        self.n = n\\n        self.parents1 = [i for i in range(n)] # to left\\n        self.parents2 = [i for i in range(n)] # to right\\n\\n        \\n    def find1(self, idx): \\n\\t    # find group root from parents1\\n        if self.parents1[idx] != idx:\\n            self.parents1[idx] = self.find1(self.parents1[idx])\\n        return self.parents1[idx]\\n    \\n    def find2(self, idx):\\n\\t    # find group root from parents2\\n        if self.parents2[idx] != idx:\\n            self.parents2[idx] = self.find2(self.parents2[idx])\\n        return self.parents2[idx]\\n    \\n    def union(self, idx1, idx2):\\n\\t    # in parents1, always point to the leftside\\n        p11 = self.find1(self.parents1[idx1])\\n        p12 = self.find1(self.parents1[idx2])\\n        self.parents1[p12] = p11\\n        \\n\\t\\t# in parents2, always point to the rightside\\n        p21 = self.find2(self.parents2[idx1])\\n        p22 = self.find2(self.parents2[idx2])\\n        self.parents2[p21] = p22\\n    \\n\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        nums = [-float(\\'inf\\')] + nums + [float(\\'inf\\')]\\n        n = len(nums)\\n        uf = UF(n)\\n        candidates = set()\\n        for i in range(1, n - 1):\\n            if nums[i] > nums[i + 1]:\\n                candidates.add(i + 1)\\n        \\n        res = 0\\n        while candidates:\\n            # print(candidates)\\n            res += 1\\n            for idx in candidates:\\n\\t\\t\\t    # to find the previous group, we need to find the leftmost idx in current group, then decrease it by 1\\n                lidx = uf.find1(idx)\\n                lidx = uf.find1(lidx - 1)\\n                uf.union(lidx, idx)\\n            \\n            nxt = set()\\n            for idx in candidates:\\n\\t\\t\\t    # to find the nxt group, we need to find the rightmost idx in current group, then add it by 1\\n                lidx = uf.find1(idx)\\n                ridx = uf.find2(idx)\\n                ridx = uf.find1(ridx + 1)\\n\\n                if nums[lidx] > nums[ridx]:\\n                    nxt.add(ridx)\\n            candidates = nxt\\n        \\n        \\n        return res\\n```\\n\\n\\n## Double Ended Queue\\n\\nIt\\'s similiar to the UF solution, we know the next round candidates will appear in the two sides of the current removed nodes.\\n\\n\\n```python\\nclass Node:\\n    def __init__(self, val, idx):\\n        self.pre = None\\n        self.nxt = None\\n        self.val = val\\n        self.idx = idx\\n\\n\\nclass Dequeue:\\n    def __init__(self, nums):\\n        self.nums = [-float(\\'inf\\')] + nums + [float(\\'inf\\')]\\n        self.first = Node(-float(\\'inf\\'), -1)\\n        self.last = Node(float(\\'inf\\'), len(nums))\\n        self.n = len(self.nums)\\n        self.idx2node = {}\\n        self.candidates = set()\\n        self.alive = set([i for i in range(self.n)])\\n\\n        cur = self.first\\n        for idx, x in enumerate(self.nums):\\n            node = Node(x, idx)\\n            self.idx2node[idx] = node\\n            self.connect(cur, node)\\n            if cur.val > node.val:\\n                self.candidates.add(idx)\\n            cur = node\\n        self.connect(cur, self.last)\\n        self.step = 0\\n        \\n        \\n    def remove(self, cur):\\n        lnode = cur.pre\\n        rnode = cur.nxt\\n        self.connect(lnode, rnode)\\n        self.alive -= {cur.idx}\\n        \\n    def connect(self, node1, node2):\\n        node1.nxt = node2\\n        node2.pre = node1\\n        \\n    def simulate(self):\\n        candidates = self.candidates\\n        while candidates:\\n            self.step += 1\\n            nxt = set()\\n            for idx in candidates:\\n                node = self.idx2node[idx]\\n                lidx = node.pre.idx\\n                self.remove(node)\\n                # need to check whether the left-node can merge with its right side in next round\\n                nxt.add(lidx)\\n                \\n            candidates = set()\\n            for idx in nxt:\\n                if idx not in self.alive:\\n                    # pass if the node has already removed from deque\\n                    continue\\n                node = self.idx2node[idx]\\n                ridx = node.nxt.idx\\n                if self.nums[idx] > self.nums[ridx]:\\n                    candidates.add(ridx)\\n\\n        return self.step\\n\\n\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        dequeue = Dequeue(nums)\\n        return dequeue.simulate()\\n        \\n        \\n            \\n```\\n",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```python\\nclass UF:\\n    def __init__(self, n):\\n        self.n = n\\n        self.parents1 = [i for i in range(n)] # to left\\n        self.parents2 = [i for i in range(n)] # to right\\n\\n        \\n    def find1(self, idx): \\n\\t    # find group root from parents1\\n        if self.parents1[idx] != idx:\\n            self.parents1[idx] = self.find1(self.parents1[idx])\\n        return self.parents1[idx]\\n    \\n    def find2(self, idx):\\n\\t    # find group root from parents2\\n        if self.parents2[idx] != idx:\\n            self.parents2[idx] = self.find2(self.parents2[idx])\\n        return self.parents2[idx]\\n    \\n    def union(self, idx1, idx2):\\n\\t    # in parents1, always point to the leftside\\n        p11 = self.find1(self.parents1[idx1])\\n        p12 = self.find1(self.parents1[idx2])\\n        self.parents1[p12] = p11\\n        \\n\\t\\t# in parents2, always point to the rightside\\n        p21 = self.find2(self.parents2[idx1])\\n        p22 = self.find2(self.parents2[idx2])\\n        self.parents2[p21] = p22\\n    \\n\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        nums = [-float(\\'inf\\')] + nums + [float(\\'inf\\')]\\n        n = len(nums)\\n        uf = UF(n)\\n        candidates = set()\\n        for i in range(1, n - 1):\\n            if nums[i] > nums[i + 1]:\\n                candidates.add(i + 1)\\n        \\n        res = 0\\n        while candidates:\\n            # print(candidates)\\n            res += 1\\n            for idx in candidates:\\n\\t\\t\\t    # to find the previous group, we need to find the leftmost idx in current group, then decrease it by 1\\n                lidx = uf.find1(idx)\\n                lidx = uf.find1(lidx - 1)\\n                uf.union(lidx, idx)\\n            \\n            nxt = set()\\n            for idx in candidates:\\n\\t\\t\\t    # to find the nxt group, we need to find the rightmost idx in current group, then add it by 1\\n                lidx = uf.find1(idx)\\n                ridx = uf.find2(idx)\\n                ridx = uf.find1(ridx + 1)\\n\\n                if nums[lidx] > nums[ridx]:\\n                    nxt.add(ridx)\\n            candidates = nxt\\n        \\n        \\n        return res\\n```\n```python\\nclass Node:\\n    def __init__(self, val, idx):\\n        self.pre = None\\n        self.nxt = None\\n        self.val = val\\n        self.idx = idx\\n\\n\\nclass Dequeue:\\n    def __init__(self, nums):\\n        self.nums = [-float(\\'inf\\')] + nums + [float(\\'inf\\')]\\n        self.first = Node(-float(\\'inf\\'), -1)\\n        self.last = Node(float(\\'inf\\'), len(nums))\\n        self.n = len(self.nums)\\n        self.idx2node = {}\\n        self.candidates = set()\\n        self.alive = set([i for i in range(self.n)])\\n\\n        cur = self.first\\n        for idx, x in enumerate(self.nums):\\n            node = Node(x, idx)\\n            self.idx2node[idx] = node\\n            self.connect(cur, node)\\n            if cur.val > node.val:\\n                self.candidates.add(idx)\\n            cur = node\\n        self.connect(cur, self.last)\\n        self.step = 0\\n        \\n        \\n    def remove(self, cur):\\n        lnode = cur.pre\\n        rnode = cur.nxt\\n        self.connect(lnode, rnode)\\n        self.alive -= {cur.idx}\\n        \\n    def connect(self, node1, node2):\\n        node1.nxt = node2\\n        node2.pre = node1\\n        \\n    def simulate(self):\\n        candidates = self.candidates\\n        while candidates:\\n            self.step += 1\\n            nxt = set()\\n            for idx in candidates:\\n                node = self.idx2node[idx]\\n                lidx = node.pre.idx\\n                self.remove(node)\\n                # need to check whether the left-node can merge with its right side in next round\\n                nxt.add(lidx)\\n                \\n            candidates = set()\\n            for idx in nxt:\\n                if idx not in self.alive:\\n                    # pass if the node has already removed from deque\\n                    continue\\n                node = self.idx2node[idx]\\n                ridx = node.nxt.idx\\n                if self.nums[idx] > self.nums[ridx]:\\n                    candidates.add(ridx)\\n\\n        return self.step\\n\\n\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        dequeue = Dequeue(nums)\\n        return dequeue.simulate()\\n        \\n        \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2086225,
                "title": "python-dedicated-to-all-the-leetcoders-who-tried-to-honestly-remove-items-step-by-step-like-i-did",
                "content": "![image](https://assets.leetcode.com/users/images/187ee552-b739-4376-b75a-15f5779ac3d8_1653802529.355901.jpeg)\\n\\n\\tclass Solution:\\n\\t\\tdef totalSteps(self, nums: List[int]) -> int:   \\n\\t\\t\\tstack = [[nums[0], 0]]\\n\\t\\t\\tres, i, l = 0, 1, len(nums)\\n\\n\\t\\t\\twhile i < l:\\n\\t\\t\\t\\tel, cur = nums[i], 0\\n\\n\\t\\t\\t\\twhile stack and stack[-1][0] <= el:\\n\\t\\t\\t\\t\\tcur = max(cur, stack[-1][1])\\n\\t\\t\\t\\t\\tstack.pop()\\n\\n\\t\\t\\t\\tif stack: \\n\\t\\t\\t\\t\\tcur += 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tcur = 0\\n\\n\\t\\t\\t\\tres = max(res, cur)\\n\\t\\t\\t\\tstack.append([el, cur])\\n\\n\\t\\t\\t\\ti += 1\\n\\n\\t\\t\\treturn res\\n\\t\\t\\t\\n\\t\\t\\t\\nJust take a look at my first version to see that your attempts weren\\'t so bad. I used damn BISECT to search for an index in a list consisting of indexes of items to be deleted\\uD83D\\uDE25\\n\\n\\tclass Solution:\\n\\t\\tdef totalSteps(self, nums: List[int]) -> int:\\n\\t\\t\\tl = len(nums)\\n\\t\\t\\tcounter =  0\\n\\n\\t\\t\\tdef checker(l):\\n\\t\\t\\t\\tdels = []\\n\\t\\t\\t\\ti = 1\\n\\t\\t\\t\\twhile i < l:\\n\\t\\t\\t\\t\\tif nums[i] < nums[i - 1]:\\n\\t\\t\\t\\t\\t\\tdels.append(i)\\n\\t\\t\\t\\t\\ti += 1\\n\\t\\t\\t\\treturn dels\\n\\n\\t\\t\\twhile True:\\n\\t\\t\\t\\tdels = checker(l)\\n\\t\\t\\t\\tif dels:\\n\\t\\t\\t\\t\\tcounter += 1\\n\\t\\t\\t\\t\\tll = len(dels)\\n\\t\\t\\t\\t\\tnew_nums = []\\n\\t\\t\\t\\t\\tprev_ind = 0\\n\\t\\t\\t\\t\\tfor i, el in enumerate(nums):\\n\\t\\t\\t\\t\\t\\tind = bisect_left(dels, i, prev_ind)\\n\\t\\t\\t\\t\\t\\tprev_ind = ind\\n\\t\\t\\t\\t\\t\\tif ind == ll:\\n\\t\\t\\t\\t\\t\\t\\tnew_nums.extend(nums[i:])\\n\\t\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\t\\tif dels[ind] != i:\\n\\t\\t\\t\\t\\t\\t\\tnew_nums.append(el)\\n\\t\\t\\t\\t\\tnums = new_nums\\n\\t\\t\\t\\t\\tl -= ll\\n\\t\\t\\t\\t\\tchecker(l)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn counter",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/187ee552-b739-4376-b75a-15f5779ac3d8_1653802529.355901.jpeg)\\n\\n\\tclass Solution:\\n\\t\\tdef totalSteps(self, nums: List[int]) -> int:   \\n\\t\\t\\tstack = [[nums[0], 0]]\\n\\t\\t\\tres, i, l = 0, 1, len(nums)\\n\\n\\t\\t\\twhile i < l:\\n\\t\\t\\t\\tel, cur = nums[i], 0\\n\\n\\t\\t\\t\\twhile stack and stack[-1][0] <= el:\\n\\t\\t\\t\\t\\tcur = max(cur, stack[-1][1])\\n\\t\\t\\t\\t\\tstack.pop()\\n\\n\\t\\t\\t\\tif stack: \\n\\t\\t\\t\\t\\tcur += 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tcur = 0\\n\\n\\t\\t\\t\\tres = max(res, cur)\\n\\t\\t\\t\\tstack.append([el, cur])\\n\\n\\t\\t\\t\\ti += 1\\n\\n\\t\\t\\treturn res\\n\\t\\t\\t\\n\\t\\t\\t\\nJust take a look at my first version to see that your attempts weren\\'t so bad. I used damn BISECT to search for an index in a list consisting of indexes of items to be deleted\\uD83D\\uDE25\\n\\n\\tclass Solution:\\n\\t\\tdef totalSteps(self, nums: List[int]) -> int:\\n\\t\\t\\tl = len(nums)\\n\\t\\t\\tcounter =  0\\n\\n\\t\\t\\tdef checker(l):\\n\\t\\t\\t\\tdels = []\\n\\t\\t\\t\\ti = 1\\n\\t\\t\\t\\twhile i < l:\\n\\t\\t\\t\\t\\tif nums[i] < nums[i - 1]:\\n\\t\\t\\t\\t\\t\\tdels.append(i)\\n\\t\\t\\t\\t\\ti += 1\\n\\t\\t\\t\\treturn dels\\n\\n\\t\\t\\twhile True:\\n\\t\\t\\t\\tdels = checker(l)\\n\\t\\t\\t\\tif dels:\\n\\t\\t\\t\\t\\tcounter += 1\\n\\t\\t\\t\\t\\tll = len(dels)\\n\\t\\t\\t\\t\\tnew_nums = []\\n\\t\\t\\t\\t\\tprev_ind = 0\\n\\t\\t\\t\\t\\tfor i, el in enumerate(nums):\\n\\t\\t\\t\\t\\t\\tind = bisect_left(dels, i, prev_ind)\\n\\t\\t\\t\\t\\t\\tprev_ind = ind\\n\\t\\t\\t\\t\\t\\tif ind == ll:\\n\\t\\t\\t\\t\\t\\t\\tnew_nums.extend(nums[i:])\\n\\t\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\t\\tif dels[ind] != i:\\n\\t\\t\\t\\t\\t\\t\\tnew_nums.append(el)\\n\\t\\t\\t\\t\\tnums = new_nums\\n\\t\\t\\t\\t\\tl -= ll\\n\\t\\t\\t\\t\\tchecker(l)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn counter",
                "codeTag": "Java"
            },
            {
                "id": 2086199,
                "title": "c-monotonic-stack-dp-memoization-solution-with-explanation-o-n-time-o-n-space",
                "content": "```\\nclass Solution {\\npublic:\\n    //INTUITION: For every element, we check on its right that how many elements can be dissolved using it. Maximum number of such elements found is our answer.\\n    \\n    //ALGO: We use a monotonic stack to check for such a decreasing sequence from right to left, because an element can only dissolve elements on their right smaller than itself.\\n    //And we keep storing the no. of elements possible to be dissolved for every index in a dp array\\n    //For this algo, we have to traverse from the right end to starting of the array.\\n    int totalSteps(vector<int>& nums) {\\n        stack<int> st;\\n        int ans = 0;\\n        vector<int> dp(nums.size(),0);\\n        for(int i = nums.size()-1; i>=0; --i)\\n        {\\n            while(!st.empty() && nums[i]>nums[st.top()])//will run till we have a increasing sequence from right to left (or decreasing sequence from left to right starting from index i) \\n            {\\n                ++dp[i]; //because there\\'s one element to its right side for sure that it can dissolve/eliminate\\n                dp[i] = max(dp[i], dp[st.top()]); //now we also have to check whether there is another smaller number on the right side of nums[i] that can dissolve/eliminate even more no. of elements than nums[i] itself\\n                st.pop(); \\n                ans = max(ans,dp[i]);\\n            }\\n            st.push(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //INTUITION: For every element, we check on its right that how many elements can be dissolved using it. Maximum number of such elements found is our answer.\\n    \\n    //ALGO: We use a monotonic stack to check for such a decreasing sequence from right to left, because an element can only dissolve elements on their right smaller than itself.\\n    //And we keep storing the no. of elements possible to be dissolved for every index in a dp array\\n    //For this algo, we have to traverse from the right end to starting of the array.\\n    int totalSteps(vector<int>& nums) {\\n        stack<int> st;\\n        int ans = 0;\\n        vector<int> dp(nums.size(),0);\\n        for(int i = nums.size()-1; i>=0; --i)\\n        {\\n            while(!st.empty() && nums[i]>nums[st.top()])//will run till we have a increasing sequence from right to left (or decreasing sequence from left to right starting from index i) \\n            {\\n                ++dp[i]; //because there\\'s one element to its right side for sure that it can dissolve/eliminate\\n                dp[i] = max(dp[i], dp[st.top()]); //now we also have to check whether there is another smaller number on the right side of nums[i] that can dissolve/eliminate even more no. of elements than nums[i] itself\\n                st.pop(); \\n                ans = max(ans,dp[i]);\\n            }\\n            st.push(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2086171,
                "title": "javascript-monotonic-stack-dp-156ms",
                "content": "```\\nconst totalSteps = (a) => MonotonicStack(a);\\n\\nconst MonotonicStack = (a) => {\\n    let n = a.length, st = [], dp = Array(n).fill(0), res = 0;\\n    for (let i = n - 1; ~i; i--) {\\n        while (st.length && a[i] > a[st[st.length - 1]]) {\\n            let last = st.pop();\\n            dp[i] = Math.max(dp[i] + 1, dp[last]);\\n        }\\n        st.push(i);\\n        res = Math.max(res, dp[i]);\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Monotonic Stack"
                ],
                "code": "```\\nconst totalSteps = (a) => MonotonicStack(a);\\n\\nconst MonotonicStack = (a) => {\\n    let n = a.length, st = [], dp = Array(n).fill(0), res = 0;\\n    for (let i = n - 1; ~i; i--) {\\n        while (st.length && a[i] > a[st[st.length - 1]]) {\\n            let last = st.pop();\\n            dp[i] = Math.max(dp[i] + 1, dp[last]);\\n        }\\n        st.push(i);\\n        res = Math.max(res, dp[i]);\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2086156,
                "title": "c-10-lines-stack-o-n-time-space",
                "content": "```\\npublic class Solution \\n{\\n    public int TotalSteps(int[] nums) \\n    {\\n        Stack<int> stack = new();\\n        int[] ans = new int[nums.Length];\\n        \\n        for (int i = 0; i < nums.Length; ++i) \\n        {\\n            int res = 0;\\n            while (stack.Any() && nums[stack.Peek()] <= nums[i]) res = Math.Max(ans[stack.Pop()], res);\\n            \\n            if (stack.Any()) ans[i] = res + 1;\\n            \\n            stack.Push(i);\\n        }\\n        return ans.Max();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public int TotalSteps(int[] nums) \\n    {\\n        Stack<int> stack = new();\\n        int[] ans = new int[nums.Length];\\n        \\n        for (int i = 0; i < nums.Length; ++i) \\n        {\\n            int res = 0;\\n            while (stack.Any() && nums[stack.Peek()] <= nums[i]) res = Math.Max(ans[stack.Pop()], res);\\n            \\n            if (stack.Any()) ans[i] = res + 1;\\n            \\n            stack.Push(i);\\n        }\\n        return ans.Max();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2086007,
                "title": "how-to-resolve-time-limit-exceeded",
                "content": "Straightforward idea without using stack. Anyway to optimize or do we have to go reverse order and use stack?\\nThanks.\\n```\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        memo=[0]*len(nums)\\n        curr=nums[0]\\n        k=0\\n        for i in range(1,len(nums)):\\n            if nums[i]>=curr:\\n                curr=nums[i]\\n                k=i\\n                continue\\n\\n            if nums[i]<nums[i-1]:\\n                memo[i]=1\\n                continue\\n            j=i-2\\n            while j>=k:\\n                if nums[i]<nums[j]:\\n                    memo[i]=1+max(memo[j+1:i])\\n                    # print(memo)\\n                    break\\n                else:\\n                    j-=1                    \\n        return max(memo)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        memo=[0]*len(nums)\\n        curr=nums[0]\\n        k=0\\n        for i in range(1,len(nums)):\\n            if nums[i]>=curr:\\n                curr=nums[i]\\n                k=i\\n                continue\\n\\n            if nums[i]<nums[i-1]:\\n                memo[i]=1\\n                continue\\n            j=i-2\\n            while j>=k:\\n                if nums[i]<nums[j]:\\n                    memo[i]=1+max(memo[j+1:i])\\n                    # print(memo)\\n                    break\\n                else:\\n                    j-=1                    \\n        return max(memo)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085941,
                "title": "c-solution-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) \\n    {\\n        int answer=0;\\n        stack<pair<int,int>> st;\\n        st.push({nums[nums.size()-1],0});\\n        \\n        for(int i=nums.size()-2;i>=0;i--)\\n        {\\n            int count=0;\\n            while(!st.empty() && st.top().first<nums[i]) //if current element is greater  then the top of the stack(st.top().first) keep removing the top() element and simultaneously keep updating count\\n            {\\n                count=max(st.top().second,count+1);\\n                st.pop();\\n            }\\n            answer=max(answer,count);\\n            st.push({nums[i],count}); // push the new element in the stack\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) \\n    {\\n        int answer=0;\\n        stack<pair<int,int>> st;\\n        st.push({nums[nums.size()-1],0});\\n        \\n        for(int i=nums.size()-2;i>=0;i--)\\n        {\\n            int count=0;\\n            while(!st.empty() && st.top().first<nums[i]) //if current element is greater  then the top of the stack(st.top().first) keep removing the top() element and simultaneously keep updating count\\n            {\\n                count=max(st.top().second,count+1);\\n                st.pop();\\n            }\\n            answer=max(answer,count);\\n            st.push({nums[i],count}); // push the new element in the stack\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085912,
                "title": "12-lines-c-monotonic-stack",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint totalSteps(vector<int>& nums) {\\n\\t\\t\\tstack<int> st;\\n\\t\\t\\tvector<int> dp(nums.size(), 0);\\n\\t\\t\\tfor (int i = nums.size() - 1; i >= 0; i--) {\\n\\t\\t\\t\\twhile (!st.empty() && nums[st.top()] < nums[i]) {\\n\\t\\t\\t\\t\\tdp[i] = max(++dp[i], dp[st.top()]);\\n\\t\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tst.push(i);\\n\\t\\t\\t}\\n\\t\\t\\treturn *max_element(dp.begin(), dp.end());\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint totalSteps(vector<int>& nums) {\\n\\t\\t\\tstack<int> st;\\n\\t\\t\\tvector<int> dp(nums.size(), 0);\\n\\t\\t\\tfor (int i = nums.size() - 1; i >= 0; i--) {\\n\\t\\t\\t\\twhile (!st.empty() && nums[st.top()] < nums[i]) {\\n\\t\\t\\t\\t\\tdp[i] = max(++dp[i], dp[st.top()]);\\n\\t\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2085785,
                "title": "c-o-n-using-dp-stack",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        vector<int> dp(nums.size());\\n        stack<int> s;\\n        int r;\\n        for(int i = nums.size()-1;i>=0;i--){\\n            while(!s.empty() && nums[i]>nums[s.top()]){\\n                dp[i] = max(dp[i]+1, dp[s.top()]); s.pop();\\n            }\\n            s.push(i);\\n            r = max(r, dp[i]);\\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        vector<int> dp(nums.size());\\n        stack<int> s;\\n        int r;\\n        for(int i = nums.size()-1;i>=0;i--){\\n            while(!s.empty() && nums[i]>nums[s.top()]){\\n                dp[i] = max(dp[i]+1, dp[s.top()]); s.pop();\\n            }\\n            s.push(i);\\n            r = max(r, dp[i]);\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085698,
                "title": "accepted-after-3-tries-the-code-seems-easy-though",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int n = nums.size(), ret = 0;\\n        vector<int> dp(n);\\n        stack<int> s;\\n        for(int i=n-1; i>=0; i--) {\\n            while(not s.empty() and nums[s.top()] < nums[i]) {\\n                ++dp[i];\\n                dp[i] = max(dp[i], dp[s.top()]);\\n                s.pop();\\n            }\\n            ret = max(ret, dp[i]);\\n            s.push(i);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int n = nums.size(), ret = 0;\\n        vector<int> dp(n);\\n        stack<int> s;\\n        for(int i=n-1; i>=0; i--) {\\n            while(not s.empty() and nums[s.top()] < nums[i]) {\\n                ++dp[i];\\n                dp[i] = max(dp[i], dp[s.top()]);\\n                s.pop();\\n            }\\n            ret = max(ret, dp[i]);\\n            s.push(i);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085662,
                "title": "c-stack-o-n-short-code-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& a) {\\n        int n = a.size();\\n        int ret = 0;\\n\\t\\t// Which round will the position i be removed, set a big value to represent never be removed.\\n        vector<int>f(n, n+n);\\n\\t\\t// Position stack.\\n        stack<int>st;\\n        st.push(0);\\n        for(int i = 1;i<n;i++){\\n            int ans = 1;\\n\\t\\t\\t// Find the previous position which value is bigger than current value, the round will be the max round of positions in the middle + 1.\\n            while((!st.empty())&&a[st.top()]<=a[i]){\\n                ans=max(ans, f[st.top()]+1);\\n                st.pop();\\n            }\\n            if(ans<n+n){\\n                ret=max(ret, ans);\\n            }\\n            f[i] = ans;\\n            st.push(i);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& a) {\\n        int n = a.size();\\n        int ret = 0;\\n\\t\\t// Which round will the position i be removed, set a big value to represent never be removed.\\n        vector<int>f(n, n+n);\\n\\t\\t// Position stack.\\n        stack<int>st;\\n        st.push(0);\\n        for(int i = 1;i<n;i++){\\n            int ans = 1;\\n\\t\\t\\t// Find the previous position which value is bigger than current value, the round will be the max round of positions in the middle + 1.\\n            while((!st.empty())&&a[st.top()]<=a[i]){\\n                ans=max(ans, f[st.top()]+1);\\n                st.pop();\\n            }\\n            if(ans<n+n){\\n                ret=max(ret, ans);\\n            }\\n            f[i] = ans;\\n            st.push(i);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4050943,
                "title": "monotonic-pair-stack-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(2n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        stack<pair<int,int>>s;\\n        int maxo=0;\\n        \\n        for(int i=nums.size()-1;i>=0;i--){\\n            int count=0;\\n            if(!s.empty() && s.top().first<nums[i]){\\n                \\n                while(!s.empty() && s.top().first<nums[i]){\\n                    count++;\\n                    count=max(count,s.top().second);\\n                    s.pop();\\n                }\\n                \\n               \\n            }\\n            maxo=max(count,maxo);\\n            s.push({nums[i],count});\\n            \\n            \\n        }\\n        \\n\\n        return maxo;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        stack<pair<int,int>>s;\\n        int maxo=0;\\n        \\n        for(int i=nums.size()-1;i>=0;i--){\\n            int count=0;\\n            if(!s.empty() && s.top().first<nums[i]){\\n                \\n                while(!s.empty() && s.top().first<nums[i]){\\n                    count++;\\n                    count=max(count,s.top().second);\\n                    s.pop();\\n                }\\n                \\n               \\n            }\\n            maxo=max(count,maxo);\\n            s.push({nums[i],count});\\n            \\n            \\n        }\\n        \\n\\n        return maxo;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3999410,
                "title": "simulation-on-list-of-deques-just-careful-implementation",
                "content": "# Intuition\\nlist of deques\\n\\n```\\nclass Solution:\\n    def totalSteps(self, n: List[int]) -> int:\\n        p,s,o=10**10,[],0\\n        for v in n:\\n            if v<p:s.append(deque())\\n            s[-1].append(p:=v)\\n        while (q:=len(s)-1):\\n            o+=1\\n            for m in range(q,0,-1):\\n                (t:=s[m]).popleft()\\n                if not t or s[m-1][-1]<=t[0]:\\n                    del s[m]\\n                    s[m-1].extend(t)\\n        return o\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def totalSteps(self, n: List[int]) -> int:\\n        p,s,o=10**10,[],0\\n        for v in n:\\n            if v<p:s.append(deque())\\n            s[-1].append(p:=v)\\n        while (q:=len(s)-1):\\n            o+=1\\n            for m in range(q,0,-1):\\n                (t:=s[m]).popleft()\\n                if not t or s[m-1][-1]<=t[0]:\\n                    del s[m]\\n                    s[m-1].extend(t)\\n        return o\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3994050,
                "title": "optimal-bruteforce-using-stack-cpp",
                "content": "# Intuition\\nThe problem asks us to find the number of steps required to make the given array non-decreasing. To achieve this, we need to remove elements from the array such that, after each removal, the remaining elements are in non-decreasing order. Our intuition is to iteratively remove elements from the array while maintaining this property until we can no longer remove any elements.\\n\\n# Approach - Brute Force\\nThe brute force approach involves repeatedly checking the array and removing elements if they violate the non-decreasing condition. This process continues until no more elements can be removed, and we keep count of the steps taken. We initialize a counter `cnt` to 0 and repeatedly perform the following steps:\\n\\n1. Initialize an index `i` to 1 and a flag to 0.\\n2. Initialize a variable `d` to the first element of the array.\\n3. While `i` is less than the length of the array:\\n   a. If `d` is greater than the element at index `i`, update `d` to the element at index `i`, remove the element at index `i`, and set the flag to 1.\\n   b. Otherwise, increment `i`.\\n4. If the flag remains 0 after going through the array, return `cnt` as the number of steps.\\n5. Otherwise, increment `cnt` and repeat the process.\\n\\n# Complexity\\n- Time complexity: The worst-case time complexity of this approach is O(n^2), where n is the length of the input array `nums`. This is because in the worst case, we might have to repeatedly traverse the entire array in each step.\\n- Space complexity: The space complexity is O(1) as we are not using any additional data structures.\\n\\n# Approach - Optimal\\nThe optimal approach involves using a stack to efficiently keep track of elements in the array and their counts. We iterate through the array from right to left and maintain a stack of pairs where each pair consists of an element and the count of elements removed before it.\\n\\n1. Initialize a stack `st` to store pairs of elements and counts.\\n2. Iterate through the elements of the array from right to left.\\n3. For each element, check the elements in the stack from the top while the element at the top of the stack is less than the current element. We update the count of removed elements and pop elements from the stack until the condition is met.\\n4. Update the maximum count of removed elements seen so far (`maxi`) with the maximum between the current count and the previous `maxi`.\\n5. Push the current element and its updated count into the stack.\\n6. After iterating through the entire array, return `maxi` as the number of steps.\\n\\n# Complexity\\n- Time complexity: The time complexity of this optimal approach is O(n), where n is the length of the input array `nums`. This is because we iterate through the array once, and the stack operations are constant time for each element.\\n- Space complexity: The space complexity is O(n) as the stack can store at most n elements in the worst case.\\n\\n# BRUTE FORCE\\n```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int cnt=0;\\n        while(true){\\n            int i=1,flag=0;\\n            int d=nums[0];\\n            while(i<nums.size()){\\n                if(d>nums[i]) d=nums[i],nums.erase(nums.begin()+i),flag=1;\\n                else d=nums[i],i++;\\n            }\\n            if(flag==0) return cnt;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n# OPTIMAL APPROACH\\n```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int n=nums.size(),maxi=0;\\n        stack<pair<int,int>>st;\\n        for(int i=n-1;i>=0;i--){\\n            int cnt=0;\\n            while(!st.empty() and st.top().first<nums[i]){\\n                cnt=max(st.top().second,cnt+1);\\n                st.pop();\\n            }\\n            maxi=max(maxi,cnt);\\n            st.push({nums[i],cnt});\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int cnt=0;\\n        while(true){\\n            int i=1,flag=0;\\n            int d=nums[0];\\n            while(i<nums.size()){\\n                if(d>nums[i]) d=nums[i],nums.erase(nums.begin()+i),flag=1;\\n                else d=nums[i],i++;\\n            }\\n            if(flag==0) return cnt;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int n=nums.size(),maxi=0;\\n        stack<pair<int,int>>st;\\n        for(int i=n-1;i>=0;i--){\\n            int cnt=0;\\n            while(!st.empty() and st.top().first<nums[i]){\\n                cnt=max(st.top().second,cnt+1);\\n                st.pop();\\n            }\\n            maxi=max(maxi,cnt);\\n            st.push({nums[i],cnt});\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979406,
                "title": "monotonic-stack",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        stack<int> st;\\n        int ans = 0, max_size = 0;\\n        for (int i = nums.size() - 1; i >= 0; i--) {\\n            for (; !st.empty() && nums[st.top()] < nums[i]; st.pop());\\n            ans = max(ans, max_size - (int)st.size());\\n            st.push(i);\\n            max_size = max(max_size, (int)st.size());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        stack<int> st;\\n        int ans = 0, max_size = 0;\\n        for (int i = nums.size() - 1; i >= 0; i--) {\\n            for (; !st.empty() && nums[st.top()] < nums[i]; st.pop());\\n            ans = max(ans, max_size - (int)st.size());\\n            st.push(i);\\n            max_size = max(max_size, (int)st.size());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971985,
                "title": "stack-based-step-counter-for-number-elimination",
                "content": "# Intuition\\nThe problem suggests using a monotonic stack approach to identify the first larger number to the left of every element. By iterating from left to right, the stack helps track numbers that can \\'eliminate\\' others. As numbers get \\'consumed\\' by larger ones, the steps array updates the elimination time for each. An inline_max lambda function optimizes the performance by bypassing the overhead of typical function calls. This concise method offers both elegance and efficiency in solving the problem.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom array import array\\n\\nclass Solution(object):\\n    def totalSteps(self, nums):\\n        n = len(nums)\\n        \\n        # Using array.array for possibly better memory usage\\n        stack = array(\\'i\\', [0] * n)\\n        steps = array(\\'i\\', [0] * n)\\n        \\n        top = -1\\n        get_num = nums.__getitem__\\n        get_step = steps.__getitem__\\n        get_stack = stack.__getitem__\\n        \\n        inline_max = lambda a, b: a if a > b else b\\n\\n        for i in xrange(n): \\n            num = get_num(i)\\n            max_step_of_popped = 0\\n\\n            while top >= 0 and get_num(get_stack(top)) <= num:\\n                max_step_of_popped = inline_max(max_step_of_popped, get_step(get_stack(top)))\\n                top -= 1\\n\\n            if top >= 0:\\n                steps[i] = max_step_of_popped + 1\\n\\n            top += 1\\n            stack[top] = i\\n\\n        return max(steps)\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom array import array\\n\\nclass Solution(object):\\n    def totalSteps(self, nums):\\n        n = len(nums)\\n        \\n        # Using array.array for possibly better memory usage\\n        stack = array(\\'i\\', [0] * n)\\n        steps = array(\\'i\\', [0] * n)\\n        \\n        top = -1\\n        get_num = nums.__getitem__\\n        get_step = steps.__getitem__\\n        get_stack = stack.__getitem__\\n        \\n        inline_max = lambda a, b: a if a > b else b\\n\\n        for i in xrange(n): \\n            num = get_num(i)\\n            max_step_of_popped = 0\\n\\n            while top >= 0 and get_num(get_stack(top)) <= num:\\n                max_step_of_popped = inline_max(max_step_of_popped, get_step(get_stack(top)))\\n                top -= 1\\n\\n            if top >= 0:\\n                steps[i] = max_step_of_popped + 1\\n\\n            top += 1\\n            stack[top] = i\\n\\n        return max(steps)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3964104,
                "title": "steps-to-make-array-non-decreasing",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- for each element in the array, we could consider all subsequent elements, calculating the steps needed to transform the subarray into a non-decreasing sequence.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Brute Approach:\\nIn the brute-force approach, for each element in the array, we could consider all subsequent elements, calculating the steps needed to transform the subarray into a non-decreasing sequence. This involves nested loops, resulting in O(n^2) time complexity.\\n\\n- Optimal Approach:\\nThe optimal approach utilizes a stack to efficiently process the array in reverse order. It iterates through elements, maintaining pairs of element and steps taken to create a non-decreasing sequence. It updates the step count for each element by considering the stack\\'s contents. This approach achieves linear time complexity of O(n), effectively determining the maximum steps required to transform the sequence into non-decreasing form.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- n\\n\\n# Code\\n\\n\\n```\\n/*class Solution {  // BRUTE FORCE \\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int n = nums.size();\\n        int totalSteps = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            int stepsNeeded = 0;\\n            for (int j = i + 1; j < n; j++) {\\n                if (nums[j] < nums[j - 1]) {\\n                    stepsNeeded++;\\n                }\\n            }\\n            totalSteps = max(totalSteps, stepsNeeded);\\n        }\\n        \\n        return totalSteps;\\n    }\\n};*/\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n\\n        stack<pair<int, int>> st;  // Initialize a stack to store pairs (element, steps)\\n        \\n        int ans = -1;  // Initialize the maximum step count as -1 (for comparison)\\n        for (int i = nums.size() - 1; i >= 0; i--) {\\n            int count = 0;  // Initialize the step count for the current element\\n            while (!st.empty() and st.top().first < nums[i]) {\\n                // While there are elements in the stack and the top element is larger\\n                // than the current element, indicating a need for adjustment\\n                count = max(count + 1, st.top().second); // Update the step count\\n                st.pop();  // Remove the element from the stack\\n            }\\n            ans = max(ans, count);  // Update the maximum step count seen so far\\n            st.push({nums[i], count});  // Push the current element and its step count onto the stack\\n        }\\n        \\n        return ans;  // Return the maximum step count required to make the sequence non-decreasing\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Stack"
                ],
                "code": "```\\n/*class Solution {  // BRUTE FORCE \\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int n = nums.size();\\n        int totalSteps = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            int stepsNeeded = 0;\\n            for (int j = i + 1; j < n; j++) {\\n                if (nums[j] < nums[j - 1]) {\\n                    stepsNeeded++;\\n                }\\n            }\\n            totalSteps = max(totalSteps, stepsNeeded);\\n        }\\n        \\n        return totalSteps;\\n    }\\n};*/\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n\\n        stack<pair<int, int>> st;  // Initialize a stack to store pairs (element, steps)\\n        \\n        int ans = -1;  // Initialize the maximum step count as -1 (for comparison)\\n        for (int i = nums.size() - 1; i >= 0; i--) {\\n            int count = 0;  // Initialize the step count for the current element\\n            while (!st.empty() and st.top().first < nums[i]) {\\n                // While there are elements in the stack and the top element is larger\\n                // than the current element, indicating a need for adjustment\\n                count = max(count + 1, st.top().second); // Update the step count\\n                st.pop();  // Remove the element from the stack\\n            }\\n            ans = max(ans, count);  // Update the maximum step count seen so far\\n            st.push({nums[i], count});  // Push the current element and its step count onto the stack\\n        }\\n        \\n        return ans;  // Return the maximum step count required to make the sequence non-decreasing\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3864822,
                "title": "stack-dp",
                "content": "```\\nint totalSteps(vector<int>& n) \\n{ \\n\\tint out{INT_MIN};      \\n\\tstack<int> s;\\n\\tfor(int i(size(n)-1), d[100001]{}; i>=0; --i)\\n\\t{\\n\\t\\tfor( ; !empty(s) and n[s.top()]<n[i]; s.pop()) \\n\\t\\t\\td[i] = max(d[i]+1, d[s.top()]);    \\n\\t\\ts.push(i);\\n\\t\\tout = max(out, d[i]);\\n\\t}\\n\\treturn out;\\n}\\n```\\n||\\n```\\nint totalSteps(vector<int>& n) \\n{ \\n\\tint out{INT_MIN};      \\n\\tstack<pair<int, int>> s;\\n\\tfor(int i(size(n)-1); i>=0; --i)\\n\\t{\\n        int t{};\\n\\t\\tfor( ; !empty(s) and s.top().first<n[i]; s.pop()) \\n\\t\\t\\tt = max(t+1, s.top().second);    \\n\\t\\ts.push({n[i],t});\\n\\t\\tout = max(out, t);\\n\\t}\\n\\treturn out;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint totalSteps(vector<int>& n) \\n{ \\n\\tint out{INT_MIN};      \\n\\tstack<int> s;\\n\\tfor(int i(size(n)-1), d[100001]{}; i>=0; --i)\\n\\t{\\n\\t\\tfor( ; !empty(s) and n[s.top()]<n[i]; s.pop()) \\n\\t\\t\\td[i] = max(d[i]+1, d[s.top()]);    \\n\\t\\ts.push(i);\\n\\t\\tout = max(out, d[i]);\\n\\t}\\n\\treturn out;\\n}\\n```\n```\\nint totalSteps(vector<int>& n) \\n{ \\n\\tint out{INT_MIN};      \\n\\tstack<pair<int, int>> s;\\n\\tfor(int i(size(n)-1); i>=0; --i)\\n\\t{\\n        int t{};\\n\\t\\tfor( ; !empty(s) and s.top().first<n[i]; s.pop()) \\n\\t\\t\\tt = max(t+1, s.top().second);    \\n\\t\\ts.push({n[i],t});\\n\\t\\tout = max(out, t);\\n\\t}\\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3857309,
                "title": "c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) \\n    {\\n        vector<int> v(nums.size()); \\n        stack<int> st;\\n        int ans = 0; \\n        for(int i=nums.size()-1;i>=0;i--)\\n        {\\n            while(!st.empty() && nums[i] > nums[st.top()])\\n            {\\n                v[i] = max(v[i]+1, v[st.top()]);\\n\\t\\t\\t\\tst.pop();\\n            }\\n            st.push(i);\\n            ans = max(ans, v[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) \\n    {\\n        vector<int> v(nums.size()); \\n        stack<int> st;\\n        int ans = 0; \\n        for(int i=nums.size()-1;i>=0;i--)\\n        {\\n            while(!st.empty() && nums[i] > nums[st.top()])\\n            {\\n                v[i] = max(v[i]+1, v[st.top()]);\\n\\t\\t\\t\\tst.pop();\\n            }\\n            st.push(i);\\n            ans = max(ans, v[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3834772,
                "title": "totalsteps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n       public static int totalSteps(int[] nums) {\\n        if (nums.length == 1)\\n            return 0;\\n        LinkedList<int[]> linkedList = new LinkedList<>();\\n        linkedList.add(new int[]{nums[0], 0});\\n        int max = 0;\\n        for (int i = 1; i < nums.length; i++) {\\n            int[] current = new int[]{nums[i], 1};\\n            while (true) {\\n                int[] last = linkedList.getLast();\\n                if (current[0] < last[0]) {\\n                    if (last[1] == current[1])\\n                        linkedList.removeLast();\\n                    linkedList.add(current);\\n                    break;\\n                } else {\\n                    current[1] = Math.max(current[1], last[1]) + 1;\\n                    linkedList.removeLast();\\n                    if (linkedList.size() == 0) {\\n                        current[1] = 0;\\n                        linkedList.add(current);\\n                        break;\\n                    }\\n                }\\n            }\\n            for (var array : linkedList)\\n                max = Math.max(max, array[1]);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n       public static int totalSteps(int[] nums) {\\n        if (nums.length == 1)\\n            return 0;\\n        LinkedList<int[]> linkedList = new LinkedList<>();\\n        linkedList.add(new int[]{nums[0], 0});\\n        int max = 0;\\n        for (int i = 1; i < nums.length; i++) {\\n            int[] current = new int[]{nums[i], 1};\\n            while (true) {\\n                int[] last = linkedList.getLast();\\n                if (current[0] < last[0]) {\\n                    if (last[1] == current[1])\\n                        linkedList.removeLast();\\n                    linkedList.add(current);\\n                    break;\\n                } else {\\n                    current[1] = Math.max(current[1], last[1]) + 1;\\n                    linkedList.removeLast();\\n                    if (linkedList.size() == 0) {\\n                        current[1] = 0;\\n                        linkedList.add(current);\\n                        break;\\n                    }\\n                }\\n            }\\n            for (var array : linkedList)\\n                max = Math.max(max, array[1]);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738546,
                "title": "monotonic-stack-based-approach-with-summarized-thought-process",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\n# This has been a tricky problem to solve.\\n# First we see if we can try to process the array from the right side, this would mean that\\n# when we are at a number and we see that it\\'s smaller than the previous number, we can try\\n# to delete the current number. However, deleting the current number removes context for the \\n# following number (if that\\'s smaller than the current number) because both the current and the\\n# following numbers can be deleted in the same step.\\n# So, we try to process the array from the right side. Whenever we see that the current number\\n# is greater than the number to its right, we can delete the number on the right, and record that\\n# it took 1 step to delete this number. The maximum number of steps that any number took to delete\\n# numbers to its right is what we\\'re looking for here. But we need to take into account that the \\n# number we are deleting could already have deleted some numbers. If the steps taken by that\\n# number are more than the steps I am taking to delete that number, the steps to delete that number\\n# should be the maximum of my steps and the steps it took for that number to delete numbers smaller\\n# than itself.\\nclass Solution:\\n  # If the current element is smaller than previous, we want to delete the current element\\n  # After the deletion if the new current element is smaller than previous, it shouldn\\'t be\\n  # deleted in the current step.\\n  def totalSteps(self, nums: List[int]) -> int:\\n    # stack stores tuples where the first element is the number itself and the second element\\n    # is the number of steps it has taken to delete the numbers smaller than itself.\\n    stack = []\\n    n = len(nums)\\n    max_steps = 0\\n\\n    # We process the array from the right end, and when we see smaller numbers to the right,\\n    # we can remove those numbers.\\n    for i in range(n-1, -1, -1):\\n\\n      my_steps_to_delete_smaller_numbers = 0\\n\\n      while stack and nums[i] > stack[-1][0]:\\n        removed_number, steps_taken_by_removed_number = stack.pop()\\n        my_steps_to_delete_smaller_numbers += 1\\n\\n        if steps_taken_by_removed_number > my_steps_to_delete_smaller_numbers:\\n          my_steps_to_delete_smaller_numbers = steps_taken_by_removed_number\\n\\n      stack.append((nums[i], my_steps_to_delete_smaller_numbers))\\n      max_steps = max(my_steps_to_delete_smaller_numbers, max_steps)\\n    \\n    return max_steps\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# This has been a tricky problem to solve.\\n# First we see if we can try to process the array from the right side, this would mean that\\n# when we are at a number and we see that it\\'s smaller than the previous number, we can try\\n# to delete the current number. However, deleting the current number removes context for the \\n# following number (if that\\'s smaller than the current number) because both the current and the\\n# following numbers can be deleted in the same step.\\n# So, we try to process the array from the right side. Whenever we see that the current number\\n# is greater than the number to its right, we can delete the number on the right, and record that\\n# it took 1 step to delete this number. The maximum number of steps that any number took to delete\\n# numbers to its right is what we\\'re looking for here. But we need to take into account that the \\n# number we are deleting could already have deleted some numbers. If the steps taken by that\\n# number are more than the steps I am taking to delete that number, the steps to delete that number\\n# should be the maximum of my steps and the steps it took for that number to delete numbers smaller\\n# than itself.\\nclass Solution:\\n  # If the current element is smaller than previous, we want to delete the current element\\n  # After the deletion if the new current element is smaller than previous, it shouldn\\'t be\\n  # deleted in the current step.\\n  def totalSteps(self, nums: List[int]) -> int:\\n    # stack stores tuples where the first element is the number itself and the second element\\n    # is the number of steps it has taken to delete the numbers smaller than itself.\\n    stack = []\\n    n = len(nums)\\n    max_steps = 0\\n\\n    # We process the array from the right end, and when we see smaller numbers to the right,\\n    # we can remove those numbers.\\n    for i in range(n-1, -1, -1):\\n\\n      my_steps_to_delete_smaller_numbers = 0\\n\\n      while stack and nums[i] > stack[-1][0]:\\n        removed_number, steps_taken_by_removed_number = stack.pop()\\n        my_steps_to_delete_smaller_numbers += 1\\n\\n        if steps_taken_by_removed_number > my_steps_to_delete_smaller_numbers:\\n          my_steps_to_delete_smaller_numbers = steps_taken_by_removed_number\\n\\n      stack.append((nums[i], my_steps_to_delete_smaller_numbers))\\n      max_steps = max(my_steps_to_delete_smaller_numbers, max_steps)\\n    \\n    return max_steps\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631347,
                "title": "py3-beats-100-time-easy-explanation-for-dp-index-stack",
                "content": "# Intuition\\nWe build a dynamic programming array. The index i of the array holds the minimum steps necessary to make the partial array `[i:n]` non decreasing.\\n\\n# Approach\\nBy walking backwards, we can simplify the problem into the following loop:\\n\\n1. For every Index `i` going from right to left:\\n   1. Look at every pre-compressed sub-array that starts at `j`. Take the next `j` from the stack:\\n      1. If `nums[j]` is smaller than or equal to `nums[i]`, break the loop and continue with the next `j`\\n      1. Otherwise: Pop j off the stack\\n      1. We compress the new sub-array, add `1` to `dp[i]`\\n      1. If the steps necessary to compress `j` (stored in `dp[j]`) are greater than `dp[i]`, set `dp[i]` to `dp[j]` instead.\\n   2. Add `i` to the stack of compressd sub-arrays (LIFO)\\n\\n## Some key insights to note:\\n- For every number $i$ on the stack, the numbers that are above it on the stack have to be $\\\\ge i$. This means the stack is sorted.\\n- For every outer loop index $i$, we don\\'t look at every $j$. We just look at $j$\\'s that are the leftmost index of an already compressed sub-array. Those $j$\\'s are local maxima.\\n- If we come across a new $i$ that\\'s larger than anything we\\'ve seen, it means we have to remove every single previous local maximum in order to still be non-decreasing. Effectively compressing every $j \\\\ge i$ into one new sub-array starting at $i$. The stack is left empty.\\n- If we come across an $i$ that\\'s somewhere in the middle of all $j$\\'s we\\'ve seen, it means we have to compress only the $j$\\'s that are smaller. That\\'s where the sorted stack really helps us out.\\n- If we come across an $i$ that\\'s lower or equal to everything we\\'ve seen, we do nothing. The array is already non-decreasing.\\n- Every compression adds at least $1$ to `dp[i]`. We also need to make sure that we don\\'t drop any steps that occured when compressing $j$. That\\'s where `if prev > dp[i]: dp[i] = prev` comes from.\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/b2201112-f6c1-4514-9c78-77ccee748de5_1686628111.405121.png)\\n\\n\\n# Code\\n\\n```\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        n = len(nums)        \\n        stack = deque([])\\n        dp = [0] * n\\n        for i in range(n)[::-1]:\\n            v = nums[i]\\n            while stack and v > nums[stack[-1]]:\\n                j = stack.pop()\\n                prev = dp[j]\\n                dp[i] += 1\\n                if prev > dp[i]:\\n                    dp[i] = prev\\n            stack.append(i)\\n        return max(dp)\\n```\\n\\n## Minified in 6 Lines:\\n\\n```\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        s, d, n = deque([]), [0] * len(nums), len(nums)\\n        for i, v in enumerate(reversed(nums)):\\n            while s and v > nums[n - s[-1] - 1]:\\n                d[i] = max(d[i] + 1, d[s.pop()])\\n            s.append(i)\\n        return max(d)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        n = len(nums)        \\n        stack = deque([])\\n        dp = [0] * n\\n        for i in range(n)[::-1]:\\n            v = nums[i]\\n            while stack and v > nums[stack[-1]]:\\n                j = stack.pop()\\n                prev = dp[j]\\n                dp[i] += 1\\n                if prev > dp[i]:\\n                    dp[i] = prev\\n            stack.append(i)\\n        return max(dp)\\n```\n```\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        s, d, n = deque([]), [0] * len(nums), len(nums)\\n        for i, v in enumerate(reversed(nums)):\\n            while s and v > nums[n - s[-1] - 1]:\\n                d[i] = max(d[i] + 1, d[s.pop()])\\n            s.append(i)\\n        return max(d)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3505892,
                "title": "very-easy-fast-solution-simple-approach-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        \\n        int n = nums.length;\\n        int answer = 0;\\n\\n        Stack<Pair<Integer, Integer>> stack = new Stack<>();\\n        stack.push(new Pair<>(nums[n - 1], 0));\\n\\n        for(int i = n - 2; i >= 0; i--) {\\n            int count = 0;\\n            while(!stack.isEmpty() && nums[i] > stack.peek().getKey()) {\\n                count = Math.max(count + 1, stack.peek().getValue());\\n                stack.pop();\\n            }\\n            answer = Math.max(answer, count);\\n            stack.push(new Pair(nums[i], count));\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        \\n        int n = nums.length;\\n        int answer = 0;\\n\\n        Stack<Pair<Integer, Integer>> stack = new Stack<>();\\n        stack.push(new Pair<>(nums[n - 1], 0));\\n\\n        for(int i = n - 2; i >= 0; i--) {\\n            int count = 0;\\n            while(!stack.isEmpty() && nums[i] > stack.peek().getKey()) {\\n                count = Math.max(count + 1, stack.peek().getValue());\\n                stack.pop();\\n            }\\n            answer = Math.max(answer, count);\\n            stack.push(new Pair(nums[i], count));\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3505891,
                "title": "very-easy-fast-solution-simple-approach-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        \\n        int n = nums.length;\\n        int answer = 0;\\n\\n        Stack<Pair<Integer, Integer>> stack = new Stack<>();\\n        stack.push(new Pair<>(nums[n - 1], 0));\\n\\n        for(int i = n - 2; i >= 0; i--) {\\n            int count = 0;\\n            while(!stack.isEmpty() && nums[i] > stack.peek().getKey()) {\\n                count = Math.max(count + 1, stack.peek().getValue());\\n                stack.pop();\\n            }\\n            answer = Math.max(answer, count);\\n            stack.push(new Pair(nums[i], count));\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        \\n        int n = nums.length;\\n        int answer = 0;\\n\\n        Stack<Pair<Integer, Integer>> stack = new Stack<>();\\n        stack.push(new Pair<>(nums[n - 1], 0));\\n\\n        for(int i = n - 2; i >= 0; i--) {\\n            int count = 0;\\n            while(!stack.isEmpty() && nums[i] > stack.peek().getKey()) {\\n                count = Math.max(count + 1, stack.peek().getValue());\\n                stack.pop();\\n            }\\n            answer = Math.max(answer, count);\\n            stack.push(new Pair(nums[i], count));\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502059,
                "title": "shortest-c-solution-using-simple-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        vector<int> ans(nums.size()); \\n        stack<int> s;\\n        for(int i=nums.size()-1;i>=0;i--)\\n        {\\n            while(!s.empty() && nums[i]>nums[s.top()])\\n            {\\n                ans[i]=max(ans[i]+1, ans[s.top()]);\\n                s.pop();\\n            }\\n            s.push(i);\\n        }\\n        return *max_element(ans.begin(), ans.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        vector<int> ans(nums.size()); \\n        stack<int> s;\\n        for(int i=nums.size()-1;i>=0;i--)\\n        {\\n            while(!s.empty() && nums[i]>nums[s.top()])\\n            {\\n                ans[i]=max(ans[i]+1, ans[s.top()]);\\n                s.pop();\\n            }\\n            s.push(i);\\n        }\\n        return *max_element(ans.begin(), ans.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3386151,
                "title": "monotonic-stack-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        Stack<Integer> stack = new Stack();\\n        int[] dp = new int[nums.length];\\n       int res = 0;\\n      for(int i = nums.length-1;i>=0;i--){\\n            while (!stack.isEmpty() &&  nums[i] > nums[stack.peek()]){\\n                    dp[i] = Math.max(dp[i] + 1, dp[stack.pop()]);\\n                     res = Math.max(res, dp[i]);\\n            }\\n            stack.push(i);\\n      }\\n      return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        Stack<Integer> stack = new Stack();\\n        int[] dp = new int[nums.length];\\n       int res = 0;\\n      for(int i = nums.length-1;i>=0;i--){\\n            while (!stack.isEmpty() &&  nums[i] > nums[stack.peek()]){\\n                    dp[i] = Math.max(dp[i] + 1, dp[stack.pop()]);\\n                     res = Math.max(res, dp[i]);\\n            }\\n            stack.push(i);\\n      }\\n      return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3360285,
                "title": "monotonic-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        //Learn it\\n        int len=nums.length;\\n        int ans=0;\\n        Stack<Pair<Integer,Integer>> stk=new Stack<>();//Monotonic stack\\n        stk.push(new Pair<>(nums[len-1],0));\\n        for(int i=len-2;i>=0;i--){\\n            int count=0;\\n            while(!stk.isEmpty() && nums[i]>stk.peek().getKey()){\\n                count=Math.max(count+1,stk.peek().getValue());\\n                stk.pop();\\n            }\\n            ans=Math.max(count,ans);\\n            stk.push(new Pair<>(nums[i],count));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        //Learn it\\n        int len=nums.length;\\n        int ans=0;\\n        Stack<Pair<Integer,Integer>> stk=new Stack<>();//Monotonic stack\\n        stk.push(new Pair<>(nums[len-1],0));\\n        for(int i=len-2;i>=0;i--){\\n            int count=0;\\n            while(!stk.isEmpty() && nums[i]>stk.peek().getKey()){\\n                count=Math.max(count+1,stk.peek().getValue());\\n                stk.pop();\\n            }\\n            ans=Math.max(count,ans);\\n            stk.push(new Pair<>(nums[i],count));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3335664,
                "title": "c-clean-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        stack<pair<int,int>> s;\\n        vector<int> dp(nums.size()+1,0);\\n        int c=0;\\n        for(int i=nums.size()-1;i>=0;i--)\\n        {\\n            int a=nums[i];\\n            int ct=0;\\n             while(s.size()>0 && a>s.top().first)\\n              {\\n                  dp[i]=max(dp[i]+1,dp[s.top().second]);\\n                  s.pop();\\n              }\\n            s.push({a,i});\\n        }\\n      for(auto j : dp)\\n      c=max(j,c);  \\n     return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        stack<pair<int,int>> s;\\n        vector<int> dp(nums.size()+1,0);\\n        int c=0;\\n        for(int i=nums.size()-1;i>=0;i--)\\n        {\\n            int a=nums[i];\\n            int ct=0;\\n             while(s.size()>0 && a>s.top().first)\\n              {\\n                  dp[i]=max(dp[i]+1,dp[s.top().second]);\\n                  s.pop();\\n              }\\n            s.push({a,i});\\n        }\\n      for(auto j : dp)\\n      c=max(j,c);  \\n     return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327178,
                "title": "c-golang-monotonic-stack-dp",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> DP(n, 0);\\n        stack<int> Stack;\\n        int ans = 0;\\n        for(int i = nums.size() - 1; i >= 0; i--) {\\n            while(!Stack.empty() && nums[Stack.top()] < nums[i]) {\\n                DP[i] = max(DP[Stack.top()], DP[i] + 1);\\n                Stack.pop();\\n            }\\n            ans = max(ans, DP[i]);\\n            Stack.push(i);\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc max(a, b int) int {\\n    if a > b {return a}\\n    return b\\n}\\n\\nfunc totalSteps(nums []int) int {\\n    n := len(nums)\\n    DP := make([]int, n)\\n    Stack := make([]int, 1e5)\\n    top := -1\\n    ans := 0\\n    for i := n - 1; i >= 0; i-- {\\n        for top != -1 && nums[Stack[top]] < nums[i] {\\n            DP[i] = max(DP[Stack[top]], DP[i] + 1)\\n            top--\\n        }\\n        ans = max(ans, DP[i])\\n        top++\\n        Stack[top] = i\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "Dynamic Programming",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> DP(n, 0);\\n        stack<int> Stack;\\n        int ans = 0;\\n        for(int i = nums.size() - 1; i >= 0; i--) {\\n            while(!Stack.empty() && nums[Stack.top()] < nums[i]) {\\n                DP[i] = max(DP[Stack.top()], DP[i] + 1);\\n                Stack.pop();\\n            }\\n            ans = max(ans, DP[i]);\\n            Stack.push(i);\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc max(a, b int) int {\\n    if a > b {return a}\\n    return b\\n}\\n\\nfunc totalSteps(nums []int) int {\\n    n := len(nums)\\n    DP := make([]int, n)\\n    Stack := make([]int, 1e5)\\n    top := -1\\n    ans := 0\\n    for i := n - 1; i >= 0; i-- {\\n        for top != -1 && nums[Stack[top]] < nums[i] {\\n            DP[i] = max(DP[Stack[top]], DP[i] + 1)\\n            top--\\n        }\\n        ans = max(ans, DP[i])\\n        top++\\n        Stack[top] = i\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3295891,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& A) {\\n        int n = A.size(), res = 0;\\n        vector<int> stack, dp(n);\\n        for (int i = n - 1; i >= 0; --i) {\\n            while (!stack.empty() && A[i] > A[stack.back()]) {\\n                dp[i] = max(++dp[i], dp[stack.back()]);\\n                stack.pop_back();\\n                res = max(res, dp[i]);\\n            }\\n            stack.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& A) {\\n        int n = A.size(), res = 0;\\n        vector<int> stack, dp(n);\\n        for (int i = n - 1; i >= 0; --i) {\\n            while (!stack.empty() && A[i] > A[stack.back()]) {\\n                dp[i] = max(++dp[i], dp[stack.back()]);\\n                stack.pop_back();\\n                res = max(res, dp[i]);\\n            }\\n            stack.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3181253,
                "title": "java-code-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n      int ans = 0;\\n      Stack<Pair<Integer, Integer>> st = new Stack<>();\\n      st.push(new Pair<>(nums[nums.length-1], 0));\\n      for(int i=nums.length-2; i>=0; i--){\\n           int count = 0;\\n         while(st.size()>0 && nums[i]>st.peek().getKey()){\\n             count = Math.max(count+1, st.peek().getValue());\\n              st.pop();\\n          }\\n          ans = Math.max(ans, count);\\n          st.push(new Pair(nums[i], count));\\n         \\n      }\\n\\n      return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n      int ans = 0;\\n      Stack<Pair<Integer, Integer>> st = new Stack<>();\\n      st.push(new Pair<>(nums[nums.length-1], 0));\\n      for(int i=nums.length-2; i>=0; i--){\\n           int count = 0;\\n         while(st.size()>0 && nums[i]>st.peek().getKey()){\\n             count = Math.max(count+1, st.peek().getValue());\\n              st.pop();\\n          }\\n          ans = Math.max(ans, count);\\n          st.push(new Pair(nums[i], count));\\n         \\n      }\\n\\n      return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112888,
                "title": "simple-dp-java-solution",
                "content": "# Intuition\\n1. Find the first previous element just bigger than current.\\n2. Assign current element answer to max answer of elements between current element and the first previous element just bigger than current + 1.\\n3. Max of all the answers is your final answer.\\n\\n# Code\\n```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        Stack<Integer> s=new Stack<>();\\n        int dp[]=new int[nums.length],ans=0;\\n        for(int i=0;i<nums.length;i++){\\n            while(!s.isEmpty() && nums[s.peek()]<=nums[i]){\\n                dp[i]=Math.max(dp[i],dp[s.pop()]);\\n            }\\n            dp[i]=s.isEmpty()?0:dp[i]+1;\\n            s.add(i);\\n            ans=Math.max(ans,dp[i]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        Stack<Integer> s=new Stack<>();\\n        int dp[]=new int[nums.length],ans=0;\\n        for(int i=0;i<nums.length;i++){\\n            while(!s.isEmpty() && nums[s.peek()]<=nums[i]){\\n                dp[i]=Math.max(dp[i],dp[s.pop()]);\\n            }\\n            dp[i]=s.isEmpty()?0:dp[i]+1;\\n            s.add(i);\\n            ans=Math.max(ans,dp[i]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3110247,
                "title": "easy-python-solution-using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        st = []\\n        n = len(nums)\\n        st.append((nums[n-1],0))\\n        stLen = 1\\n        ans = 0\\n        for i in range(n-2,-1,-1):\\n            count = 0\\n            while(st and st[stLen-1][0]<nums[i]):\\n                count = max(count+1,st[stLen-1][1])\\n                st.pop()\\n                stLen-=1\\n            ans = max(ans,count)\\n            st.append((nums[i],count))\\n            stLen+=1\\n        return ans\\n\\n        # st = []\\n        # cnt = 0\\n        # prevarrcnt = 0\\n        # cloneNums = nums\\n        # while(True):\\n        #     a = []\\n        #     prev = -1\\n        #     arrcnt = 1\\n        #     for i in nums:\\n        #         if prev == -1:\\n        #             st.append(i)\\n        #         elif prev <= i:\\n        #             arrcnt+=1\\n        #             st.append(i)\\n        #         prev = i\\n        #     nums = st\\n        #     st = []\\n        #     if arrcnt == prevarrcnt:\\n        #         break\\n        #     prevarrcnt = arrcnt\\n        #     cnt+=1\\n        # if len(cloneNums)==prevarrcnt:\\n        #     return 0\\n        # return cnt\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        st = []\\n        n = len(nums)\\n        st.append((nums[n-1],0))\\n        stLen = 1\\n        ans = 0\\n        for i in range(n-2,-1,-1):\\n            count = 0\\n            while(st and st[stLen-1][0]<nums[i]):\\n                count = max(count+1,st[stLen-1][1])\\n                st.pop()\\n                stLen-=1\\n            ans = max(ans,count)\\n            st.append((nums[i],count))\\n            stLen+=1\\n        return ans\\n\\n        # st = []\\n        # cnt = 0\\n        # prevarrcnt = 0\\n        # cloneNums = nums\\n        # while(True):\\n        #     a = []\\n        #     prev = -1\\n        #     arrcnt = 1\\n        #     for i in nums:\\n        #         if prev == -1:\\n        #             st.append(i)\\n        #         elif prev <= i:\\n        #             arrcnt+=1\\n        #             st.append(i)\\n        #         prev = i\\n        #     nums = st\\n        #     st = []\\n        #     if arrcnt == prevarrcnt:\\n        #         break\\n        #     prevarrcnt = arrcnt\\n        #     cnt+=1\\n        # if len(cloneNums)==prevarrcnt:\\n        #     return 0\\n        # return cnt\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109157,
                "title": "stack-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe elements which do not have previous greater element sustains at the end. Previous greater element calculations leads us to stack implementation.\\n\\n# Approach\\nTake a stack. The elements which are less than the top are pushed inside the stack with a counter as 0. Whereas if we encounter a more greater value than the current top then we simply pop the element from the stack. Also the counter will be maintained as **maximum** of stack top element counter or its orginal counter+1. The maximum is taken because here are operations can be done in *parallel*. So in a way it saves the total number of steps involved.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n      **due to stack implementation **\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> vect;\\n        stack<pair<int,int>> st;\\n        // int te = 0;\\n        // vect.push_back(te);\\n        for(int i=n-1 ; i>=0 ; i--){\\n            int steps = 0;\\n            while(!st.empty()){\\n                if(st.top().first>=nums[i]){\\n                    break;\\n                }\\n                steps = max(steps+1,st.top().second);\\n                st.pop();\\n            }\\n            st.push({nums[i],steps});\\n        }\\n        int maxi=0;\\n        while(!st.empty()){\\n            maxi = max(maxi,st.top().second);\\n            st.pop();\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> vect;\\n        stack<pair<int,int>> st;\\n        // int te = 0;\\n        // vect.push_back(te);\\n        for(int i=n-1 ; i>=0 ; i--){\\n            int steps = 0;\\n            while(!st.empty()){\\n                if(st.top().first>=nums[i]){\\n                    break;\\n                }\\n                steps = max(steps+1,st.top().second);\\n                st.pop();\\n            }\\n            st.push({nums[i],steps});\\n        }\\n        int maxi=0;\\n        while(!st.empty()){\\n            maxi = max(maxi,st.top().second);\\n            st.pop();\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3104113,
                "title": "rust-elixir-with-monotonic-stack",
                "content": "# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n# Rust\\n```rust\\nimpl Solution {\\n    pub fn total_steps(nums: Vec<i32>) -> i32 {\\n        let mut ans = 0;\\n        let mut count = 0;\\n        let mut stack = Vec::new();\\n        for &x in nums.iter().rev() {\\n            while !stack.is_empty() && *stack.last().unwrap() < x {\\n                stack.pop();\\n                count += 1;\\n            }\\n            ans = ans.max(count);\\n            stack.push(x);\\n            count = 0.max(count - 1);\\n        }\\n        ans\\n    }\\n}\\n```\\n# Elixir\\n```elixir\\ndefmodule Solution do\\n  @spec total_steps(nums :: [integer]) :: integer\\n  def total_steps(nums) do\\n    Enum.reverse(nums)\\n    |> solve([], 0, 0)\\n  end\\n  \\n  defp solve([], _, _, ans), do: ans\\n  defp solve([x | nums], [y | stack], count, ans) when x > y do\\n    solve([x | nums], stack, count + 1, ans)\\n  end\\n  defp solve([x | nums], stack, count, ans) do\\n    solve(nums, [x | stack], max(count - 1, 0), max(ans, count))\\n  end\\nend\\n```",
                "solutionTags": [
                    "Rust",
                    "Elixir",
                    "Monotonic Stack"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn total_steps(nums: Vec<i32>) -> i32 {\\n        let mut ans = 0;\\n        let mut count = 0;\\n        let mut stack = Vec::new();\\n        for &x in nums.iter().rev() {\\n            while !stack.is_empty() && *stack.last().unwrap() < x {\\n                stack.pop();\\n                count += 1;\\n            }\\n            ans = ans.max(count);\\n            stack.push(x);\\n            count = 0.max(count - 1);\\n        }\\n        ans\\n    }\\n}\\n```\n```elixir\\ndefmodule Solution do\\n  @spec total_steps(nums :: [integer]) :: integer\\n  def total_steps(nums) do\\n    Enum.reverse(nums)\\n    |> solve([], 0, 0)\\n  end\\n  \\n  defp solve([], _, _, ans), do: ans\\n  defp solve([x | nums], [y | stack], count, ans) when x > y do\\n    solve([x | nums], stack, count + 1, ans)\\n  end\\n  defp solve([x | nums], stack, count, ans) do\\n    solve(nums, [x | stack], max(count - 1, 0), max(ans, count))\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3066158,
                "title": "yet-another-python-solution",
                "content": "# Intuition\\nYet another nice problem from the leetcode.\\nSolution is rather obvious - iterate through array elements and get the max lifetime from all the decreasing elements.\\n\\n\\n# Approach\\nOne approach would be to use DP array to store N integers with the lifetime of all previous elements. for every next element - get the max from lifetime of precending elements that are less or equal, add 1 and store result as a lifetime of the current.\\n\\nAbove solution can be optimised by using stack since we do not need to scan local minimums in precending elements multiple times as a peak element would always have longer lifetime than its precending items with the lower value. \\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N) for the stack\\n\\n# Code\\n```\\nimport collections\\n\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        stack = collections.deque()\\n        ans = 0\\n        mx = nums[0]\\n        for n in nums:\\n            if n >= mx:\\n                stack.clear()\\n                mx = n\\n                continue\\n            lifetime = 0\\n            while stack and stack[-1][0] <= n:\\n                (v, t) = stack.pop()\\n                lifetime = max(lifetime, t)\\n            stack.append( (n, lifetime +1) )\\n            ans = max(ans, lifetime +1)\\n        return ans\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport collections\\n\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        stack = collections.deque()\\n        ans = 0\\n        mx = nums[0]\\n        for n in nums:\\n            if n >= mx:\\n                stack.clear()\\n                mx = n\\n                continue\\n            lifetime = 0\\n            while stack and stack[-1][0] <= n:\\n                (v, t) = stack.pop()\\n                lifetime = max(lifetime, t)\\n            stack.append( (n, lifetime +1) )\\n            ans = max(ans, lifetime +1)\\n        return ans\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2932794,
                "title": "can-anyone-pls-optimize-time-complexity-in-my-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n        class Solution {\\n        public:\\n\\n         bool check(stack<int>s,int &count){\\n             queue<int>p;\\n             while(!s.empty()){\\n                 p.push(s.top());\\n                 s.pop();\\n             }\\n             while(!p.empty()){\\n                 int y=p.front();\\n                 p.pop();\\n                 if(p.front()>y){\\n                    return false;\\n                }\\n            } return true;\\n         }\\n            int totalSteps(vector<int>& nums) {\\n             stack<int>s;\\n             stack<int>st;\\n             s.push(nums[0]);\\n             int count=0;\\n             for(int i=1;i<nums.size();i++){\\n                 int y=s.top();\\n             if(nums[i-1]<=nums[i]){\\n         s.push(nums[i]);\\n             }\\n                \\n             }\\n             if(s.size()==nums.size()){\\n                 return 0;\\n             }else{\\n                 count=1;\\n             }\\n             while(check(s,count)!=true){\\n         vector<int>v;\\n         while(!s.empty()){\\n             v.push_back(s.top());\\n             s.pop();\\n         }\\n         s.push(v[v.size()-1]);\\n         for(int i=v.size()-2;i>=0;i--){\\n             if(v[i+1]<=v[i]){\\n                 s.push(v[i]);\\n             }\\n         }\\n         count++;\\n             }\\n             return count;\\n        }\\n        };\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n        class Solution {\\n        public:\\n\\n         bool check(stack<int>s,int &count){\\n             queue<int>p;\\n             while(!s.empty()){\\n                 p.push(s.top());\\n                 s.pop();\\n             }\\n             while(!p.empty()){\\n                 int y=p.front();\\n                 p.pop();\\n                 if(p.front()>y){\\n                    return false;\\n                }\\n            } return true;\\n         }\\n            int totalSteps(vector<int>& nums) {\\n             stack<int>s;\\n             stack<int>st;\\n             s.push(nums[0]);\\n             int count=0;\\n             for(int i=1;i<nums.size();i++){\\n                 int y=s.top();\\n             if(nums[i-1]<=nums[i]){\\n         s.push(nums[i]);\\n             }\\n                \\n             }\\n             if(s.size()==nums.size()){\\n                 return 0;\\n             }else{\\n                 count=1;\\n             }\\n             while(check(s,count)!=true){\\n         vector<int>v;\\n         while(!s.empty()){\\n             v.push_back(s.top());\\n             s.pop();\\n         }\\n         s.push(v[v.size()-1]);\\n         for(int i=v.size()-2;i>=0;i--){\\n             if(v[i+1]<=v[i]){\\n                 s.push(v[i]);\\n             }\\n         }\\n         count++;\\n             }\\n             return count;\\n        }\\n        };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2849229,
                "title": "scala-functional-programming-some-extension",
                "content": "## 1. Mono-stack: O(N)\\nThe idea is, if an element `a` is removed in the `x`th step, then the first element in the right side of `a` which is no less than `a` will only be removed after the `x`th step. \\n```scala\\nimport scala.annotation.tailrec\\nobject Solution {\\n    def totalSteps(nums: Array[Int]): Int = {\\n        val huge = Int.MaxValue / 2    // step >= huge means an element will never be removed\\n        \\n\\t\\t@tailrec\\n        def helper(nums: List[Int], stack: List[(Int, Int)], res: Int): Int = nums match {\\n            case Nil => res\\n            case x::xs => {\\n                val (left, right) = stack.span(_._1 <= x)\\n\\t\\t\\t    // elements in @left is less or equal to x, delaying the removal of x like some \\'blockers\\'.\\n\\t\\t\\t\\t// We find out which blocker caused the longest delay and update the removal time of x by adding 1\\n                val step = if (left == Nil) 1 else left.map(_._2).max + 1\\n                helper(xs, (x, step)::right, res max (if (step >= huge) 0 else step))\\n            }\\n        }\\n        \\n\\t\\t// the first element will never be removed\\n        helper(nums.drop(1).toList, List((nums.head, huge)), 0)\\n    }\\n}\\n```\\n\\n## 2. Simulating the Removal Process: O(N^2)\\nThe brute force method takes n-squared time complexity. It would exceed time or memory limit.\\n```Scala\\nimport scala.annotation.tailrec\\nobject Solution {\\n    def totalSteps(nums: Array[Int]): Int = {\\n        @tailrec\\n        def doSteps(nums: Array[Int], accumu: Int): Int = if (nums sameElements nums.sorted) accumu else {\\n            doSteps((Int.MinValue +: nums).sliding(2).filter(x => x(0) <= x(1)).map(_(1)).toArray, 1 + accumu)\\n        }\\n        doSteps(nums, 0)\\n    }\\n}\\n```\\n## 3. Find the Result Array\\nWe can find the resulted array after all the removals by simply modifying the first Mono-stack method. All the elements with `step >= huge` will be remained in the final result. The time complexity is `O(N)`.\\n\\nThere\\'s also an interesting divide-and-conquer method to do that. we can obtain an `O(N Log(N))` time complexity to get the resulted array by doing so.\\n```Scala\\ndef doSteps(nums: Array[Int]): Array[Int] = if (nums.size <= 1) nums else {\\n\\tval mid = nums.size / 2;\\n\\tval (left, right) = (doSteps(nums.take(mid)), doSteps(nums.drop(mid)))\\n\\tleft ++ right.filter(_ >= left.last)\\n}\\n```",
                "solutionTags": [
                    "Scala",
                    "Stack"
                ],
                "code": "```scala\\nimport scala.annotation.tailrec\\nobject Solution {\\n    def totalSteps(nums: Array[Int]): Int = {\\n        val huge = Int.MaxValue / 2    // step >= huge means an element will never be removed\\n        \\n\\t\\t@tailrec\\n        def helper(nums: List[Int], stack: List[(Int, Int)], res: Int): Int = nums match {\\n            case Nil => res\\n            case x::xs => {\\n                val (left, right) = stack.span(_._1 <= x)\\n\\t\\t\\t    // elements in @left is less or equal to x, delaying the removal of x like some \\'blockers\\'.\\n\\t\\t\\t\\t// We find out which blocker caused the longest delay and update the removal time of x by adding 1\\n                val step = if (left == Nil) 1 else left.map(_._2).max + 1\\n                helper(xs, (x, step)::right, res max (if (step >= huge) 0 else step))\\n            }\\n        }\\n        \\n\\t\\t// the first element will never be removed\\n        helper(nums.drop(1).toList, List((nums.head, huge)), 0)\\n    }\\n}\\n```\n```Scala\\nimport scala.annotation.tailrec\\nobject Solution {\\n    def totalSteps(nums: Array[Int]): Int = {\\n        @tailrec\\n        def doSteps(nums: Array[Int], accumu: Int): Int = if (nums sameElements nums.sorted) accumu else {\\n            doSteps((Int.MinValue +: nums).sliding(2).filter(x => x(0) <= x(1)).map(_(1)).toArray, 1 + accumu)\\n        }\\n        doSteps(nums, 0)\\n    }\\n}\\n```\n```Scala\\ndef doSteps(nums: Array[Int]): Array[Int] = if (nums.size <= 1) nums else {\\n\\tval mid = nums.size / 2;\\n\\tval (left, right) = (doSteps(nums.take(mid)), doSteps(nums.drop(mid)))\\n\\tleft ++ right.filter(_ >= left.last)\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2800509,
                "title": "c-o-n-monostack",
                "content": "```\\nclass Solution {\\npublic:\\n    // monotonic stack\\n    int totalSteps(vector<int>& nums) {\\n        stack<pair<int,int>> st;\\n        int n = nums.size();\\n        for(int i=n-1;i>=0;i--){\\n            if(st.empty()){\\n                st.push({nums[i],0});\\n            }\\n            else{\\n                int ops = 0;\\n                while(!st.empty() && st.top().first<nums[i]){\\n                    if(st.top().second>ops){\\n                        ops= st.top().second;\\n                    }\\n                    else{\\n                        ops+=1;\\n                    }\\n                    st.pop();\\n                }\\n                st.push({nums[i],ops});\\n            }\\n        }\\n        int ans = 0;\\n        while(!st.empty()){\\n            ans = max(ans,st.top().second);\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // monotonic stack\\n    int totalSteps(vector<int>& nums) {\\n        stack<pair<int,int>> st;\\n        int n = nums.size();\\n        for(int i=n-1;i>=0;i--){\\n            if(st.empty()){\\n                st.push({nums[i],0});\\n            }\\n            else{\\n                int ops = 0;\\n                while(!st.empty() && st.top().first<nums[i]){\\n                    if(st.top().second>ops){\\n                        ops= st.top().second;\\n                    }\\n                    else{\\n                        ops+=1;\\n                    }\\n                    st.pop();\\n                }\\n                st.push({nums[i],ops});\\n            }\\n        }\\n        int ans = 0;\\n        while(!st.empty()){\\n            ans = max(ans,st.top().second);\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792994,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        ans = 0\\n        nums.reverse()\\n        list = [[nums[0], 0]]\\n        for i in range(1, len(nums)):\\n            count = 0\\n            while list and list[-1][0] < nums[i]:\\n                count = max(count + 1, list[-1][1])\\n                list.pop()\\n            list.append([nums[i], count])\\n            ans = max(ans, count)\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        ans = 0\\n        nums.reverse()\\n        list = [[nums[0], 0]]\\n        for i in range(1, len(nums)):\\n            count = 0\\n            while list and list[-1][0] < nums[i]:\\n                count = max(count + 1, list[-1][1])\\n                list.pop()\\n            list.append([nums[i], count])\\n            ans = max(ans, count)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2789100,
                "title": "typescript-solution-with-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nDP\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nfunction totalSteps(nums: number[]): number {\\n    let dp = new Array(nums.length).fill(0)\\n    let distances = new Array(nums.length).fill(0)\\n    let result = 0\\n    for(let i = dp.length - 2; i >= 0; i--) {\\n        for(let j = 1; i + j < nums.length; j++) {\\n            if(nums[i+j] >= nums[i]) {\\n                break\\n            } else {\\n                dp[i] += 1\\n                distances[i] += 1\\n                if(dp[i+j] === 0) {\\n                } else {\\n                    if(dp[i] < dp[i+j]) {\\n                        dp[i] = dp[i+j]\\n                    }\\n                    distances[i] += distances[i+j]\\n                    j += distances[i+j]\\n                }\\n                if(dp[i] > result) {\\n                    result = dp[i]\\n                }\\n            }\\n        }\\n    }\\n    return result\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction totalSteps(nums: number[]): number {\\n    let dp = new Array(nums.length).fill(0)\\n    let distances = new Array(nums.length).fill(0)\\n    let result = 0\\n    for(let i = dp.length - 2; i >= 0; i--) {\\n        for(let j = 1; i + j < nums.length; j++) {\\n            if(nums[i+j] >= nums[i]) {\\n                break\\n            } else {\\n                dp[i] += 1\\n                distances[i] += 1\\n                if(dp[i+j] === 0) {\\n                } else {\\n                    if(dp[i] < dp[i+j]) {\\n                        dp[i] = dp[i+j]\\n                    }\\n                    distances[i] += distances[i+j]\\n                    j += distances[i+j]\\n                }\\n                if(dp[i] > result) {\\n                    result = dp[i]\\n                }\\n            }\\n        }\\n    }\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2774102,
                "title": "java-javascript-python-solution-o-n-time-using-stack",
                "content": "**Java:**\\n```\\nimport java.util.Stack;\\n\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        int ans = 0;\\n        int n = nums.length;\\n        Stack<Integer[]> stack = new Stack<Integer[]>();\\n        stack.push(new Integer[] {nums[n-1], 0});\\n        \\n        for(int i = n-2; i >= 0; i--) {\\n            int count = 0;\\n            int max = 0;\\n            while(stack.size() > 0 && stack.peek()[0] < nums[i]) {\\n                Integer[] el = stack.pop();\\n                max = Math.max(max, el[1]);\\n                count++;\\n                count = Math.max(count, max);\\n            }\\n            stack.push(new Integer[]{nums[i], count});\\n            ans = Math.max(ans, count);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\n**Javascript:**\\n```\\nconst totalSteps = function(nums) {\\n    const n = nums.length;\\n    const stack = [[nums[n-1],0]];\\n    let ans = 0;\\n    for(let i = n-2; i >= 0; i--) {\\n        let count = 0;\\n        let max = 0;\\n        while(stack.length && stack[stack.length-1][0] < nums[i]) {\\n            max = Math.max(max, stack.pop()[1]);\\n            count++;\\n            count = Math.max(count, max);\\n        }\\n        stack.push([nums[i], count]);\\n        ans = Math.max(ans, count);\\n    }\\n    return ans;\\n};\\n```\\n**Python:**\\n```\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        n = len(nums);\\n        stack = [[nums[-1],0]];\\n        ans = 0;\\n        \\n        for i in range(n-2, -1, -1):\\n            count = 0;\\n            m = 0;\\n            while len(stack) > 0 and stack[-1][0] < nums[i]:\\n                m = max(m, stack.pop()[1]);\\n                count += 1;\\n                count = max(count, m);\\n            stack.append([nums[i], count]);\\n            ans = max(ans, count);\\n        \\n        return ans;\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript",
                    "Stack"
                ],
                "code": "```\\nimport java.util.Stack;\\n\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        int ans = 0;\\n        int n = nums.length;\\n        Stack<Integer[]> stack = new Stack<Integer[]>();\\n        stack.push(new Integer[] {nums[n-1], 0});\\n        \\n        for(int i = n-2; i >= 0; i--) {\\n            int count = 0;\\n            int max = 0;\\n            while(stack.size() > 0 && stack.peek()[0] < nums[i]) {\\n                Integer[] el = stack.pop();\\n                max = Math.max(max, el[1]);\\n                count++;\\n                count = Math.max(count, max);\\n            }\\n            stack.push(new Integer[]{nums[i], count});\\n            ans = Math.max(ans, count);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\n```\\nconst totalSteps = function(nums) {\\n    const n = nums.length;\\n    const stack = [[nums[n-1],0]];\\n    let ans = 0;\\n    for(let i = n-2; i >= 0; i--) {\\n        let count = 0;\\n        let max = 0;\\n        while(stack.length && stack[stack.length-1][0] < nums[i]) {\\n            max = Math.max(max, stack.pop()[1]);\\n            count++;\\n            count = Math.max(count, max);\\n        }\\n        stack.push([nums[i], count]);\\n        ans = Math.max(ans, count);\\n    }\\n    return ans;\\n};\\n```\n```\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        n = len(nums);\\n        stack = [[nums[-1],0]];\\n        ans = 0;\\n        \\n        for i in range(n-2, -1, -1):\\n            count = 0;\\n            m = 0;\\n            while len(stack) > 0 and stack[-1][0] < nums[i]:\\n                m = max(m, stack.pop()[1]);\\n                count += 1;\\n                count = max(count, m);\\n            stack.append([nums[i], count]);\\n            ans = max(ans, count);\\n        \\n        return ans;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2681851,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        int n=nums.length;\\n        int ans=0;\\n\\n        Stack<Pair<Integer,Integer>> st=new Stack<>();\\n        st.push(new Pair<>(nums[n-1],0));\\n        for(int i=n-2;i>=0;i--){\\n            int count=0;\\n            while(!st.isEmpty() && nums[i]>st.peek().getKey()){\\n                count=Math.max(count+1,st.peek().getValue());\\n                st.pop();\\n                }\\n                ans=Math.max(ans,count);\\n                st.push(new Pair(nums[i],count));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        int n=nums.length;\\n        int ans=0;\\n\\n        Stack<Pair<Integer,Integer>> st=new Stack<>();\\n        st.push(new Pair<>(nums[n-1],0));\\n        for(int i=n-2;i>=0;i--){\\n            int count=0;\\n            while(!st.isEmpty() && nums[i]>st.peek().getKey()){\\n                count=Math.max(count+1,st.peek().getValue());\\n                st.pop();\\n                }\\n                ans=Math.max(ans,count);\\n                st.push(new Pair(nums[i],count));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630986,
                "title": "golang-solution-by-chris",
                "content": "In go playground, the output is correct.\\nBut in the leetcode, it outputs \"Unknown Error\".\\nWhy?\\n```\\nfunc totalSteps(nums []int) int {\\n\\tlenNums := len(nums)\\n\\tvar nums1, nums2, empty []int\\n\\tnums1 = nums\\n\\tended := 1\\n\\tfor i := 0; i < lenNums-1; i++ {\\n\\t\\tended = 0\\n\\t\\tnums2 = append(empty, nums[0])\\n\\t\\tfor index := 1; index < len(nums1); index++ {\\n\\t\\t\\tif nums1[index] >= nums1[index-1] {\\n\\t\\t\\t\\tnums2 = append(nums2, nums1[index])\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tended = 1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif ended == 0 {\\n\\t\\t\\treturn i\\n\\t\\t}\\n\\t\\tnums1 = nums2\\n\\t}\\n\\treturn lenNums\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nfunc totalSteps(nums []int) int {\\n\\tlenNums := len(nums)\\n\\tvar nums1, nums2, empty []int\\n\\tnums1 = nums\\n\\tended := 1\\n\\tfor i := 0; i < lenNums-1; i++ {\\n\\t\\tended = 0\\n\\t\\tnums2 = append(empty, nums[0])\\n\\t\\tfor index := 1; index < len(nums1); index++ {\\n\\t\\t\\tif nums1[index] >= nums1[index-1] {\\n\\t\\t\\t\\tnums2 = append(nums2, nums1[index])\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tended = 1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif ended == 0 {\\n\\t\\t\\treturn i\\n\\t\\t}\\n\\t\\tnums1 = nums2\\n\\t}\\n\\treturn lenNums\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2606587,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int n = nums.size(), ans = 0;\\n        stack<int> s;\\n        vector<int> dp(n+1, 0);\\n        for(int i = n-1; i >= 0; i--){\\n            while(!s.empty()){\\n                if(nums[s.top()] < nums[i]){\\n                    dp[i] = max(dp[i] + 1, dp[s.top()]);\\n                    s.pop();\\n                    ans = max(dp[i], ans);\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            s.push(i);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int n = nums.size(), ans = 0;\\n        stack<int> s;\\n        vector<int> dp(n+1, 0);\\n        for(int i = n-1; i >= 0; i--){\\n            while(!s.empty()){\\n                if(nums[s.top()] < nums[i]){\\n                    dp[i] = max(dp[i] + 1, dp[s.top()]);\\n                    s.pop();\\n                    ans = max(dp[i], ans);\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            s.push(i);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2603448,
                "title": "java-stack",
                "content": "```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        int cur_max = -1, answer = 0;\\n        ArrayDeque<Node> stack = new ArrayDeque<>();\\n        for(int num: nums){\\n            if(cur_max<=num){\\n                cur_max = num;\\n                stack = new ArrayDeque<>();\\n                stack.push(new Node(num,0,Integer.MAX_VALUE));\\n            }\\n            else{\\n                while(stack.peek().value<=num) stack.pop();\\n                Node parent = stack.pop();\\n                Node child = new Node(num,0,++parent.helped);\\n                answer = Math.max(answer,parent.helped);\\n                if(parent.helped<parent.rank) stack.push(parent);\\n                stack.push(child);\\n            }\\n        }\\n        return answer;\\n    }\\n}\\nclass Node{\\n    int value;\\n    int helped;\\n    int rank;\\n    \\n    public Node(int value, int helped, int rank){\\n        this.value = value;\\n        this.helped = helped;\\n        this.rank = rank;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        int cur_max = -1, answer = 0;\\n        ArrayDeque<Node> stack = new ArrayDeque<>();\\n        for(int num: nums){\\n            if(cur_max<=num){\\n                cur_max = num;\\n                stack = new ArrayDeque<>();\\n                stack.push(new Node(num,0,Integer.MAX_VALUE));\\n            }\\n            else{\\n                while(stack.peek().value<=num) stack.pop();\\n                Node parent = stack.pop();\\n                Node child = new Node(num,0,++parent.helped);\\n                answer = Math.max(answer,parent.helped);\\n                if(parent.helped<parent.rank) stack.push(parent);\\n                stack.push(child);\\n            }\\n        }\\n        return answer;\\n    }\\n}\\nclass Node{\\n    int value;\\n    int helped;\\n    int rank;\\n    \\n    public Node(int value, int helped, int rank){\\n        this.value = value;\\n        this.helped = helped;\\n        this.rank = rank;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2567529,
                "title": "bfs-with-updating-neighbours-o-n-python3",
                "content": "```\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        l = [i-1 for i in range(n)]\\n        r = [i+1 for i in range(n)]\\n        q = []\\n        dist = dict()\\n        ans = 0\\n        for i in range(1, n):\\n            if nums[i] < nums[i-1]:\\n                q.append(i)\\n                dist[i] = 1\\n                ans = 1\\n        while len(q) != 0:\\n            u = q.pop(0)\\n            ans = max(ans, dist[u])\\n            if r[u] < n:\\n                l[r[u]] = l[u]\\n            if l[u] > -1:\\n                r[l[u]] = r[u]\\n            if r[u] not in dist and r[u] < n and nums[r[u]] < nums[l[u]]:\\n                dist[r[u]] = dist[u] + 1\\n                q.append(r[u])\\n        return ans\\n            \\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        l = [i-1 for i in range(n)]\\n        r = [i+1 for i in range(n)]\\n        q = []\\n        dist = dict()\\n        ans = 0\\n        for i in range(1, n):\\n            if nums[i] < nums[i-1]:\\n                q.append(i)\\n                dist[i] = 1\\n                ans = 1\\n        while len(q) != 0:\\n            u = q.pop(0)\\n            ans = max(ans, dist[u])\\n            if r[u] < n:\\n                l[r[u]] = l[u]\\n            if l[u] > -1:\\n                r[l[u]] = r[u]\\n            if r[u] not in dist and r[u] < n and nums[r[u]] < nums[l[u]]:\\n                dist[r[u]] = dist[u] + 1\\n                q.append(r[u])\\n        return ans\\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2558597,
                "title": "dp-stack-histogram-problem",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> vec, dp(n, 0);\\n        \\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n            while(!vec.empty() && nums[i]>nums[vec.back()])\\n            {\\n                dp[i] = max(dp[i]+1, dp[vec.back()]);\\n                vec.pop_back();\\n            }\\n            vec.push_back(i);\\n        }\\n        int cnt = 0;\\n        for(int i=0;i<dp.size();i++)\\n        {\\n            cnt = max(cnt, dp[i]);\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> vec, dp(n, 0);\\n        \\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n            while(!vec.empty() && nums[i]>nums[vec.back()])\\n            {\\n                dp[i] = max(dp[i]+1, dp[vec.back()]);\\n                vec.pop_back();\\n            }\\n            vec.push_back(i);\\n        }\\n        int cnt = 0;\\n        for(int i=0;i<dp.size();i++)\\n        {\\n            cnt = max(cnt, dp[i]);\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2551810,
                "title": "golang-stack-solution",
                "content": "```\\nfunc totalSteps(nums []int) int {\\n    steps := 0\\n    ans := 0\\n\\t// [][index,steps]\\n    stack := [][2]int{}\\n    for i := len(nums)-1 ; i >= 0; i-- {\\n        // start new iteration\\n        steps = 0\\n        for len(stack) > 0 {\\n            item := stack[len(stack)-1]\\n            \\n            // check if number is greater than our last added item -> nums[i - 1] > nums[i]\\n            if nums[i] > item[0] {\\n                // increase steps by 1 and attempt max update\\n                steps = max(steps+1, item[1])          \\n                // pop off stack\\n                stack = stack[:len(stack)-1]\\n            } else {\\n                // number is good, break out\\n                break\\n            }\\n        }\\n        \\n        // attempt max answer update\\n        ans = max(ans, steps)\\n        \\n        // push item onto the stack\\n        stack = append(stack, [2]int{nums[i], steps})\\n        \\n    }\\n    return ans\\n}\\n\\nfunc max (a,b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc totalSteps(nums []int) int {\\n    steps := 0\\n    ans := 0\\n\\t// [][index,steps]\\n    stack := [][2]int{}\\n    for i := len(nums)-1 ; i >= 0; i-- {\\n        // start new iteration\\n        steps = 0\\n        for len(stack) > 0 {\\n            item := stack[len(stack)-1]\\n            \\n            // check if number is greater than our last added item -> nums[i - 1] > nums[i]\\n            if nums[i] > item[0] {\\n                // increase steps by 1 and attempt max update\\n                steps = max(steps+1, item[1])          \\n                // pop off stack\\n                stack = stack[:len(stack)-1]\\n            } else {\\n                // number is good, break out\\n                break\\n            }\\n        }\\n        \\n        // attempt max answer update\\n        ans = max(ans, steps)\\n        \\n        // push item onto the stack\\n        stack = append(stack, [2]int{nums[i], steps})\\n        \\n    }\\n    return ans\\n}\\n\\nfunc max (a,b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2533195,
                "title": "c-easy-solution-stack",
                "content": "```\\nclass Solution {\\npublic:\\n\\tint totalSteps(vector<int>& nums) {\\n\\t\\tint n = nums.size(), ans = 0;\\n\\t\\tstack<pair<int, int>> st;\\n\\t\\tst.push({nums[n- 1], 0});\\n\\t\\tfor (int i = n - 2; i >= 0; --i) {\\n\\t\\t\\tint ct = 0;\\n\\t\\t\\twhile (st.size() && st.top().first < nums[i]) {\\n\\t\\t\\t\\tct = max(ct + 1, st.top().second);\\n\\t\\t\\t\\tst.pop();\\n\\t\\t\\t}\\n\\t\\t\\tans = max(ans, ct);\\n\\t\\t\\tst.push({nums[i], ct});\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint totalSteps(vector<int>& nums) {\\n\\t\\tint n = nums.size(), ans = 0;\\n\\t\\tstack<pair<int, int>> st;\\n\\t\\tst.push({nums[n- 1], 0});\\n\\t\\tfor (int i = n - 2; i >= 0; --i) {\\n\\t\\t\\tint ct = 0;\\n\\t\\t\\twhile (st.size() && st.top().first < nums[i]) {\\n\\t\\t\\t\\tct = max(ct + 1, st.top().second);\\n\\t\\t\\t\\tst.pop();\\n\\t\\t\\t}\\n\\t\\t\\tans = max(ans, ct);\\n\\t\\t\\tst.push({nums[i], ct});\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2526961,
                "title": "java-crisp-monotonic-stack-solution",
                "content": "Code:\\n```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        int max = 0;\\n        // stack of [num, #steps this num responsible for]\\n        Deque<int[]> stack = new ArrayDeque<>();\\n        for(int i=nums.length - 1; i>=0; i--) {\\n            int num = nums[i];\\n            // steps = how many steps num responsible for\\n            int steps = 0;\\n            while(!stack.isEmpty() && num > stack.peekLast()[0]) {\\n                steps++; // takes 1 step for num to pop the top\\n                int poppedSteps = stack.removeLast()[1];\\n                // so num has popped STEPS steps so far and sees POPPEDSTEPS\\n                // if STEPS >= POPPEDSTEPS well nothing happens due to parallel nature\\n                // so what matters is of STEPS < POPPEDSTEPS. we can \"steal\" those already popped\\n                if (steps < poppedSteps) {\\n                    steps = poppedSteps;\\n                } \\n            }\\n            stack.addLast(new int[]{num, steps});\\n            max = Math.max(max, steps);\\n        }\\n        return max;\\n    }\\n}\\n```\\nHopefully code comments are self-explanatory.  I wasn\\'t able to solve this with forward iteration monostack after far too much thinking and a failed submission so as with many other difficult questions, tried iterating backwards and quickly arrived at my solution.\\n\\nSome nice test cases to work through are: ```[9,6,1,2,3]``` and ```[9,5,6,1,2,3]``` to see how the \"stealing\" that ```steps = poppedSteps``` works as that\\'s the trick behind my solution. Basically ```9``` \"steals\" ```6```\\'s 3 steps.\\nFor good measure you can also work through  ```[9,4,5,6,1,2,3]``` and ```[9,3,4,5,6,1,2,3]```.",
                "solutionTags": [
                    "Java",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        int max = 0;\\n        // stack of [num, #steps this num responsible for]\\n        Deque<int[]> stack = new ArrayDeque<>();\\n        for(int i=nums.length - 1; i>=0; i--) {\\n            int num = nums[i];\\n            // steps = how many steps num responsible for\\n            int steps = 0;\\n            while(!stack.isEmpty() && num > stack.peekLast()[0]) {\\n                steps++; // takes 1 step for num to pop the top\\n                int poppedSteps = stack.removeLast()[1];\\n                // so num has popped STEPS steps so far and sees POPPEDSTEPS\\n                // if STEPS >= POPPEDSTEPS well nothing happens due to parallel nature\\n                // so what matters is of STEPS < POPPEDSTEPS. we can \"steal\" those already popped\\n                if (steps < poppedSteps) {\\n                    steps = poppedSteps;\\n                } \\n            }\\n            stack.addLast(new int[]{num, steps});\\n            max = Math.max(max, steps);\\n        }\\n        return max;\\n    }\\n}\\n```\n```[9,6,1,2,3]```\n```[9,5,6,1,2,3]```\n```steps = poppedSteps```\n```9```\n```6```\n```[9,4,5,6,1,2,3]```\n```[9,3,4,5,6,1,2,3]```",
                "codeTag": "Java"
            },
            {
                "id": 2440631,
                "title": "python3-monotonic-stack",
                "content": "class Solution:\\n\\n    def totalSteps(self, nums: List[int]) -> int:\\n        res = 0\\n        length = len(nums)\\n        stack = [[nums[-1],0]]\\n        \\n        for i in reversed(range(length-1)):\\n            count = 0\\n            while stack and stack[-1][0]<nums[i]:\\n                count = max(1+count,stack.pop()[1])\\n            res = max(res,count)\\n            stack.append([nums[i],count])\\n        \\n        return res",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def totalSteps(self, nums: List[int]) -> int:\\n        res = 0\\n        length = len(nums)\\n        stack = [[nums[-1],0]]\\n        \\n        for i in reversed(range(length-1)):\\n            count = 0\\n            while stack and stack[-1][0]<nums[i]:\\n                count = max(1+count,stack.pop()[1])\\n            res = max(res,count)\\n            stack.append([nums[i],count])\\n        \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2435598,
                "title": "monotonic-stack-dp",
                "content": "Intution: find the element of the index which will destroy the element and find the longest survival in that range and add 1 to your current element if its destroyed by its neighbour element just put your element survival day as your previous 1.\\n```\\n int totalSteps(vector<int>& nums) {\\n        nums.push_back(INT_MAX);\\n        stack<pair<int,int>>st;\\n        st.push({nums[0],0});\\n        int ans=0;\\n        for(int i=1;i<nums.size();i++)\\n        {\\n           if(nums[i]<st.top().first)\\n           {\\n               st.push({nums[i],1});\\n           }\\n            else{\\n                pair<int,int> a;\\n                int res=0;\\n            while(!st.empty() && nums[i]>=st.top().first)\\n            {\\n                a=st.top();\\n                ans=max(ans,a.second);\\n                res=max(res,a.second);\\n                st.pop();\\n            }\\n                if(st.empty())\\n                {\\n                  st.push({nums[i],0});  \\n                }\\n                else\\n                st.push({nums[i],res+1});\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\n int totalSteps(vector<int>& nums) {\\n        nums.push_back(INT_MAX);\\n        stack<pair<int,int>>st;\\n        st.push({nums[0],0});\\n        int ans=0;\\n        for(int i=1;i<nums.size();i++)\\n        {\\n           if(nums[i]<st.top().first)\\n           {\\n               st.push({nums[i],1});\\n           }\\n            else{\\n                pair<int,int> a;\\n                int res=0;\\n            while(!st.empty() && nums[i]>=st.top().first)\\n            {\\n                a=st.top();\\n                ans=max(ans,a.second);\\n                res=max(res,a.second);\\n                st.pop();\\n            }\\n                if(st.empty())\\n                {\\n                  st.push({nums[i],0});  \\n                }\\n                else\\n                st.push({nums[i],res+1});\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2434807,
                "title": "c-dp-monotonic-stack-clean-code",
                "content": "class Solution {\\npublic:\\n\\n    int totalSteps(vector<int>& nums) {\\n        int n = nums.size(), ans = 0;\\n        vector<int> v, dp(n);\\n        \\n        for(int i = n-1; i >= 0; --i){\\n            while(!v.empty() and nums[i] > nums[v.back()]){\\n                dp[i] = max(++dp[i], dp[v.back()]);\\n                v.pop_back();\\n                ans = max(ans, dp[i]);\\n            }\\n            v.push_back(i);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n**Time: O(N), Space: O(N).\\nPLEASE UPVOTE IF HELPFUL!!!**\\n\\nFor doubt, comment below.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int totalSteps(vector<int>& nums) {\\n        int n = nums.size(), ans = 0;\\n        vector<int> v, dp(n);\\n        \\n        for(int i = n-1; i >= 0; --i){\\n            while(!v.empty() and nums[i] > nums[v.back()]){\\n                dp[i] = max(++dp[i], dp[v.back()]);\\n                v.pop_back();\\n                ans = max(ans, dp[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2388219,
                "title": "c-easy-commented-solution",
                "content": "class Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int n=nums.size(); //Taking the size of the array\\n        stack<pair<int,int>>st; //making a stack of pair type to hold the key value pair \\n\\t\\t//in key placeholder I will store the element and in value placeholder I will hold the number of rounds.\\n        int ans=0;\\n        st.push({nums[n-1],0});  //storing the first element from right\\n        for(int i=n-2;i>=0;i--) //start to iterate from the second last element\\n        {\\n            int count=0;\\n            while(!st.empty() and nums[i]>st.top().first) //if the element pushed at the top of the stack is greater than the element which was previously at the top then we will remove the previous element and increase the count against the number of elements which is popped out\\n            {\\n                count=max(count+1,st.top().second);\\n                st.pop();\\n                \\n            }\\n            \\n            ans=max(ans,count);\\n            st.push({nums[i],count});  //else simply push the element\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int n=nums.size(); //Taking the size of the array\\n        stack<pair<int,int>>st; //making a stack of pair type to hold the key value pair \\n\\t\\t//in key placeholder I will store the element and in value placeholder I will hold the number of rounds.\\n        int ans=0;\\n        st.push({nums[n-1],0}",
                "codeTag": "Java"
            },
            {
                "id": 2367656,
                "title": "c-forward-traversal",
                "content": "TBH this problem has been driving me nuts but I finally got an accepted solution based on the following thoughts.\\n\\nLooking at any sequence it will be made up of a **non-descending sequence** *A,B,C...*  intersperced with zero or more other sequences *a,b,c,d...* where all values are **strictly less-than** the previous item in the non-descending sequence. \\n\\nIf a,b,c,d... is **strictly decreasing** (ie a > b, b > c etc) the sequence will be consumed in **one step** each item by the preceeding one.\\n\\nIf a,b,c,d... is **non-decreasing** (ie a<= b, b <= c etc) the number of steps will be **exactly the number of items in the sequence**.\\n\\nOf course the norm is a mixture of subsequences and the head scratching begins... at least for me...\\n\\nMy intuition was it should be possible to forward traverse the main sequence with only a couple of variables for protection from the LeetCode orcs testcases. Specifically: one int to hold the `last_max` and another to hold its `last_step`. This is due to the following:\\n\\nOur subsequence is made up of \"runs\" of non-decreasing numbers **a<sub>1</sub>..a<sub>i</sub>, b<sub>1</sub>..b<sub>j</sub>, c<sub>1</sub>..c<sub>k</sub>** etc. They always commence with a value strictly less than the previous value but subsequent values may be >= the `last_max` - if this is the case that value say **b<sub>x</sub>** terminates the consumption of the \"b\" sequence and becomes the next item in the **a<sub>1</sub>..a<sub>i</sub>** sequence. Specifically **a<sub>i+1</sub>**\\n\\nAdditionally if the \"b\" sequence is longer than the \"a\" sequence its last value say **a<sub>i</sub>** is consumed at the same time as **b<sub>i</sub>** (and **c<sub>i</sub>**...) so **b<sub>i+1</sub>** becomes the `last_max` we care about and `i+1` its `last_step` even if **b<sub>i+1</sub>** is less than **a<sub>i</sub>**.\\n\\nHowever its \"elephants all the way down\" so when there are many subsequences each pair needs to be looked at as above and we need more than a single pair of variables to to keep track as multiple subsequences are exhausted or extended *in parallel*. In other words we need a `stack`\\n\\nThis is my solution - not as efficient as I would like but I\\'m just happy to get it accepted.\\n\\nAll the best!\\n\\n```\\nclass Solution {\\n    struct Pair {\\n        int num,step;\\n        Pair(int n) : num(n), step(1) {}\\n        bool operator <= (const Pair& p) { return num <= p.num || step < p.step; }  // close enough... \\n    };\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int steps=0, nmax=nums.size()?nums[0]:0;\\n        vector<Pair> save;\\n        \\n        for (int i=1; i<nums.size(); i++) {\\n\\t\\t\\tif (nmax <= nums[i]) {                  // next non-decreasing value?\\n                if (save.size()) save.clear();\\n                nmax = nums[i];\\n            }\\n            else {\\n                Pair p(nums[i]);\\n                while (save.size() && save.back() <= p) {\\n                    p.step = max(p.step,save.back().step+1);\\n                    save.pop_back();\\n                }\\n                save.emplace_back(p);\\n                steps = max(steps,p.step);\\n            }\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    struct Pair {\\n        int num,step;\\n        Pair(int n) : num(n), step(1) {}\\n        bool operator <= (const Pair& p) { return num <= p.num || step < p.step; }  // close enough... \\n    };\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int steps=0, nmax=nums.size()?nums[0]:0;\\n        vector<Pair> save;\\n        \\n        for (int i=1; i<nums.size(); i++) {\\n\\t\\t\\tif (nmax <= nums[i]) {                  // next non-decreasing value?\\n                if (save.size()) save.clear();\\n                nmax = nums[i];\\n            }\\n            else {\\n                Pair p(nums[i]);\\n                while (save.size() && save.back() <= p) {\\n                    p.step = max(p.step,save.back().step+1);\\n                    save.pop_back();\\n                }\\n                save.emplace_back(p);\\n                steps = max(steps,p.step);\\n            }\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2341808,
                "title": "python3-stack-dp",
                "content": "```\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        dp=[0]*n\\n        stack=[]\\n        for i in range(n-1,-1,-1):\\n            while stack and nums[i]>nums[stack[-1]]:\\n                dp[i]=max(dp[i]+1,dp[stack[-1]])\\n                stack.pop()\\n            stack.append(i)\\n        return max(dp)\\n```\\nVideo Reference -> https://www.youtube.com/watch?v=XirZ8GtWxWA",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        dp=[0]*n\\n        stack=[]\\n        for i in range(n-1,-1,-1):\\n            while stack and nums[i]>nums[stack[-1]]:\\n                dp[i]=max(dp[i]+1,dp[stack[-1]])\\n                stack.pop()\\n            stack.append(i)\\n        return max(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2313932,
                "title": "python3-mono-stack",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/7a598e64fb507fc966a3025d8edd0c8e7caf0bec) for solutions of weekly 295. \\n\\n```\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        ans = 0 \\n        stack = []\\n        for x in nums: \\n            val = 1\\n            while stack and stack[-1][0] <= x: val = max(val, stack.pop()[1]+1)\\n            if not stack: val = 0\\n            stack.append((x, val))\\n            ans = max(ans, val)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        ans = 0 \\n        stack = []\\n        for x in nums: \\n            val = 1\\n            while stack and stack[-1][0] <= x: val = max(val, stack.pop()[1]+1)\\n            if not stack: val = 0\\n            stack.append((x, val))\\n            ans = max(ans, val)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2238056,
                "title": "c-simple-clean-and-elegant",
                "content": "\\t\\tint totalSteps(vector<int>& nums) \\n    {   \\n        \\n        int n=nums.size();\\n      \\n        stack<pair<int,int>> st;\\n        \\n        int res=0;\\n        \\n        st.push({INT_MAX,0});\\n        \\n        for(int i=nums.size()-1;i>=0;i--)\\n        {\\n            int c=0;\\n            \\n            while(st.top().first<nums[i])\\n            {\\n                c+=max(0,st.top().second-c-1)+1;\\n                st.pop();\\n                 \\n            }\\n            \\n            res=max(res,c);\\n            \\n            st.push({nums[i],c});\\n        }\\n        \\n        return res;\\n    }",
                "solutionTags": [],
                "code": "\\t\\tint totalSteps(vector<int>& nums) \\n    {   \\n        \\n        int n=nums.size();\\n      \\n        stack<pair<int,int>> st;\\n        \\n        int res=0;\\n        \\n        st.push({INT_MAX,0});\\n        \\n        for(int i=nums.size()-1;i>=0;i--)\\n        {\\n            int c=0;\\n            \\n            while(st.top().first<nums[i])\\n            {\\n                c+=max(0,st.top().second-c-1)+1;\\n                st.pop();\\n                 \\n            }\\n            \\n            res=max(res,c);\\n            \\n            st.push({nums[i],c});\\n        }\\n        \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2236324,
                "title": "java-monotonic-stack-solution",
                "content": "```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        int result = 0;\\n        Stack<int[]> stack = new Stack<>();\\n        for(int i=nums.length-1;i>=0;i--){\\n            if(stack.isEmpty())\\n                stack.push(new int[]{nums[i],0});\\n            else{\\n                int count = 0;\\n                while(!stack.isEmpty() && stack.peek()[0]<nums[i]){\\n                    count = Math.max(count+1,stack.peek()[1]);\\n                    stack.pop();\\n                }\\n                result = Math.max(count,result);\\n                stack.push(new int[]{nums[i],count});\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        int result = 0;\\n        Stack<int[]> stack = new Stack<>();\\n        for(int i=nums.length-1;i>=0;i--){\\n            if(stack.isEmpty())\\n                stack.push(new int[]{nums[i],0});\\n            else{\\n                int count = 0;\\n                while(!stack.isEmpty() && stack.peek()[0]<nums[i]){\\n                    count = Math.max(count+1,stack.peek()[1]);\\n                    stack.pop();\\n                }\\n                result = Math.max(count,result);\\n                stack.push(new int[]{nums[i],count});\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2213526,
                "title": "100-c-1-night-stack-pair",
                "content": "**1. PUSH IN STACK STRAIGHT AWAY IF LARGEST ELEMENT.\\n2. POP TILL GREATER ELEMENT NOT FOUND**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) \\n    {\\n        stack<pair<int,int>> st;\\n        st.push(make_pair(nums[0],0));\\n        \\n        int bg=nums[0];\\n        int ans=0;\\n        \\n        for(int i=1;i<nums.size();i=i+1)\\n        {\\n            int m = 0;\\n            \\n            if(nums[i]>bg)\\n            {\\n                 st.push(make_pair(nums[i],0));\\n                 bg=nums[i];\\n                 continue;\\n            } \\n            \\n            while(st.top().first<=nums[i])\\n            {\\n                if(st.top().first==nums[i] && st.top().second==0)\\n                {\\n                     m=-1;break;\\n                }\\n                m=max(st.top().second,m);\\n                st.pop();\\n            }\\n            \\n            st.push(make_pair(nums[i],m+1));\\n            ans=max(ans,m+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) \\n    {\\n        stack<pair<int,int>> st;\\n        st.push(make_pair(nums[0],0));\\n        \\n        int bg=nums[0];\\n        int ans=0;\\n        \\n        for(int i=1;i<nums.size();i=i+1)\\n        {\\n            int m = 0;\\n            \\n            if(nums[i]>bg)\\n            {\\n                 st.push(make_pair(nums[i],0));\\n                 bg=nums[i];\\n                 continue;\\n            } \\n            \\n            while(st.top().first<=nums[i])\\n            {\\n                if(st.top().first==nums[i] && st.top().second==0)\\n                {\\n                     m=-1;break;\\n                }\\n                m=max(st.top().second,m);\\n                st.pop();\\n            }\\n            \\n            st.push(make_pair(nums[i],m+1));\\n            ans=max(ans,m+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2211709,
                "title": "c-monotonic-stack-with-semantics-of-the-data-structure-used",
                "content": "[Self-Use]\\nTook me so long to understand this solution...\\nWe go in reverse order of nums, at each point, we try to figure out how many (**cnt**) rounds are needed  **till** the current element **x** has nothing left to the right to remove.\\ntop of the stack maintains the next greater element and it\\'s number of the same scemantics above (**topCount**).\\n\\nThe logic within the while loop tricked me for too long, - it can be explained like this.\\n\\n____________\\n```\\ncnt++; \\n```\\nwe need at least 1 more round to remove top, since top is smaller.\\n____________\\n____________\\n```\\nint topCount = st.top()[1]; st.pop();\\n```\\nrecords how many rounds needed to remove previous smaller element\\n__________________\\n```\\ncnt = max(topCount, cnt);\\n```\\nIf topCount < cnt, it is obvious that we need cnt number of operations to remove everything left to the right. For exmple [4,1,1,1,1], its obvious that when we get to 4, each time, cnt > topCount, so we just keep incrementing.\\n\\nIf topCount >= cnt, this means the top element itself will get removed be when we go beyond cnt operations.\\nFor example, [14, 13, 2, 6, 13], we\\'re at the point to add 14 to the stack.\\n14,? -> stack top[ (13,2) (13,0)\\nnow for 1st while loop of element 14, topCount=2, cnt = 1 \\nobserve that after operation1, we have [14 6 13], this means that 14 takes over 13\\'s topCount, and continues to remove elements after this point.\\n\\n_________________________\\n\\n```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int res = 0;\\n        stack<vector<int>> st;\\n        for (auto it = prev(nums.end()); it >= nums.begin(); it--) {\\n            int x = *it;\\n            int cnt = 0; //how many rounds needed to remove x\\n            while (!st.empty() && x > st.top()[0]) {\\n                cnt++;\\n                //rounds needed to remove top element\\n                int topCount = st.top()[1]; st.pop();\\n                cnt = max(topCount, cnt);\\n            }\\n            res = max(res, cnt);\\n            st.push({x, cnt});\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ncnt++; \\n```\n```\\nint topCount = st.top()[1]; st.pop();\\n```\n```\\ncnt = max(topCount, cnt);\\n```\n```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int res = 0;\\n        stack<vector<int>> st;\\n        for (auto it = prev(nums.end()); it >= nums.begin(); it--) {\\n            int x = *it;\\n            int cnt = 0; //how many rounds needed to remove x\\n            while (!st.empty() && x > st.top()[0]) {\\n                cnt++;\\n                //rounds needed to remove top element\\n                int topCount = st.top()[1]; st.pop();\\n                cnt = max(topCount, cnt);\\n            }\\n            res = max(res, cnt);\\n            st.push({x, cnt});\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2200571,
                "title": "c-96-faster",
                "content": "class Solution {\\npublic:\\n\\n\\t// firstly we found out the final sequence after the operations\\n\\t\\n\\t// and then stored their indexs in an array \\n\\t\\n\\t// now we know that between the indexes all elements would be removed\\n\\t\\n\\t// then we calculated the max length of the increasing sequence with the help of the stack\\n\\t//(in other words max count of the numbers which are to be deleted by a unique number)  \\n\\t//because in the range all  the elements would be deleted ( final stage) but there would be certain elements which would be deleted by the numbers in the range and some would be deleted by the border numbers i.e the indexes which we have passed\\n\\t\\n\\t// ** this length could not be found by lis(longest increasing subsequence) because lis would include that numbers also which are to be deleted by different  numbers\\n    int func(int st, int end, vector<int>& nums) \\n    {\\n        if(st>end)\\n            return 0;\\n        int ans=1;\\n        stack<int> ngr;\\n        for(int i=end; i>=st; i--)\\n        {\\n            while(!ngr.empty() && ngr.top()<nums[i])\\n                    ngr.pop();\\n            ngr.push(nums[i]);\\n            int sz = ngr.size();\\n            ans=max(ans,sz);            \\n        }\\n        return ans;\\n    }\\n    int totalSteps(vector<int>& nums) {\\n        int n = nums.size(),currmax=nums[0],res=0;\\n        vector<int> inds;\\n        inds.push_back(0);\\n        for(int i=1; i<n; i++)\\n        {\\n            if(currmax<=nums[i])\\n            {\\n                currmax=nums[i];\\n                inds.push_back(i);\\n            }\\n        }\\n        inds.push_back(n);\\n        for(int j=0; j<inds.size()-1; j++)\\n        res=max(res,func(inds[j]+1,inds[j+1]-1,nums));\\n            \\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "class Solution {\\npublic:\\n\\n\\t// firstly we found out the final sequence after the operations\\n\\t\\n\\t// and then stored their indexs in an array \\n\\t\\n\\t// now we know that between the indexes all elements would be removed\\n\\t\\n\\t// then we calculated the max length of the increasing sequence with the help of the stack\\n\\t//(in other words max count of the numbers which are to be deleted by a unique number)  \\n\\t//because in the range all  the elements would be deleted ( final stage) but there would be certain elements which would be deleted by the numbers in the range and some would be deleted by the border numbers i.e the indexes which we have passed\\n\\t\\n\\t// ** this length could not be found by lis(longest increasing subsequence) because lis would include that numbers also which are to be deleted by different  numbers\\n    int func(int st, int end, vector<int>& nums) \\n    {\\n        if(st>end)\\n            return 0;\\n        int ans=1;\\n        stack<int> ngr;\\n        for(int i=end; i>=st; i--)\\n        {\\n            while(!ngr.empty() && ngr.top()<nums[i])\\n                    ngr.pop();\\n            ngr.push(nums[i]);\\n            int sz = ngr.size();\\n            ans=max(ans,sz);            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2191943,
                "title": "c-bfs-list",
                "content": "```\\n/*\\n\\tidea borrowed from: https://github.com/wisdompeak/LeetCode/blob/master/Design/2289.Steps-to-Make-Array-Non-decreasing/2289.Steps-to-Make-Array-Non-decreasing_v1.cpp\\n*/\\nconst int N = 100010;\\nclass Solution {\\n    struct Node\\n    {\\n        Node(int v) : val(v) {}\\n        int val;\\n        Node* next = nullptr;\\n    };\\n    int ne[N], pre[N];\\n    bool del[N];\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        pre[0] = -1;\\n        ne[n-1] = n;\\n        \\n        for (int i = 0; i < n; ++ i) \\n        {\\n            if (i < n - 1) ne[i] = i + 1;   \\n            if (i) pre[i] = i - 1;\\n        }\\n\\n        queue<int> q;\\n        // for (int i = 1; i < n; ++ i) // wrong \\n        for (int i = n - 1; i >= 1; -- i)  // must going from right to left, because when we do push_back(ne[u]), we need to already know whether the next element is deleted or not in this round.\\n        {\\n            if (nums[i - 1] > nums[i])\\n                q.push(i);\\n        }\\n        int ans = 0;\\n        while (q.size())\\n        {   \\n            int len = q.size();\\n            vector<int> tmp;\\n            while (q.size())\\n            {\\n                int u = q.front(); q.pop(); \\n                //  (tmp.empty() || nums[ne[u]] != tmp.back()) this dedup is very clever\\n                if (ne[u] != n && (tmp.empty() || nums[ne[u]] != tmp.back())) tmp.push_back(ne[u]);\\n                if (pre[u] != -1) ne[pre[u]] = ne[u];\\n                if (ne[u] != n) pre[ne[u]] = pre[u];\\n                del[u] = true;\\n            }\\n            \\n            for (int i : tmp)\\n                if (!del[i] && pre[i] != -1 && nums[pre[i]] > nums[i]) q.push(i);\\n            \\n            \\n            ans ++ ;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n// [7,14,4,14,13,2,1,12,13]\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n\\tidea borrowed from: https://github.com/wisdompeak/LeetCode/blob/master/Design/2289.Steps-to-Make-Array-Non-decreasing/2289.Steps-to-Make-Array-Non-decreasing_v1.cpp\\n*/\\nconst int N = 100010;\\nclass Solution {\\n    struct Node\\n    {\\n        Node(int v) : val(v) {}\\n        int val;\\n        Node* next = nullptr;\\n    };\\n    int ne[N], pre[N];\\n    bool del[N];\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        pre[0] = -1;\\n        ne[n-1] = n;\\n        \\n        for (int i = 0; i < n; ++ i) \\n        {\\n            if (i < n - 1) ne[i] = i + 1;   \\n            if (i) pre[i] = i - 1;\\n        }\\n\\n        queue<int> q;\\n        // for (int i = 1; i < n; ++ i) // wrong \\n        for (int i = n - 1; i >= 1; -- i)  // must going from right to left, because when we do push_back(ne[u]), we need to already know whether the next element is deleted or not in this round.\\n        {\\n            if (nums[i - 1] > nums[i])\\n                q.push(i);\\n        }\\n        int ans = 0;\\n        while (q.size())\\n        {   \\n            int len = q.size();\\n            vector<int> tmp;\\n            while (q.size())\\n            {\\n                int u = q.front(); q.pop(); \\n                //  (tmp.empty() || nums[ne[u]] != tmp.back()) this dedup is very clever\\n                if (ne[u] != n && (tmp.empty() || nums[ne[u]] != tmp.back())) tmp.push_back(ne[u]);\\n                if (pre[u] != -1) ne[pre[u]] = ne[u];\\n                if (ne[u] != n) pre[ne[u]] = pre[u];\\n                del[u] = true;\\n            }\\n            \\n            for (int i : tmp)\\n                if (!del[i] && pre[i] != -1 && nums[pre[i]] > nums[i]) q.push(i);\\n            \\n            \\n            ans ++ ;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n// [7,14,4,14,13,2,1,12,13]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2189937,
                "title": "intuitions-and-proof-for-reducing-complexity-from-dp-o-n-2-to-o-n-stack-approach",
                "content": "Lets call the process of removing an element `i` with condition `num[i-1]  > nums[i]` consuming the `ith` element.\\nLet `steps[i]` be the step\\'s number at which `i` will get consumed if it is eligible for consumption. In this simulation process every eligible element will get consumed at some definite step, there will no min. or max. number of steps here.\\nNow the `ith` element can only be consumed either by the `i-1th` element or an element `j` which consumed the `i-1th` element or the element `k` which consumed the `jth` and so on.\\nLets call elements like `j,k...` the `parent(i-1)`.\\nLets call them the `consumerCandidates`.\\n\\nBasic intuition: Element `i` will get consumed only after all the elements between its consumer and it are consumed. Now the question is which elements are the candidates to be its consumer.\\n\\n**First intuition:**\\nThe `consumerCandidates` of `i` is \\n`{i-1}`  if `nums[i-1] > nums[i]`  \\notherwise, the elements in `consumerCandidates[i-1] which are > nums[i]` \\nAt the beginning of each iteration `consumerCandidates` stack represents the `consumerCandidates[i-1] + (i-1)th element` and at the end of this iteration, this stack represents `consumerCandidates[i] + (i)th element`\\n\\n**Second intuition:**\\nLet `aci` be the index of the element which actually consumes `i`\\nLet `ri` be the index of the right-most element greater than `nums[i]` in `consumerCandidates[i-1]`\\nNow, either `ri == aci` or `aci is parent(ri)`, which means either `ri consumed i` or `ri` was already consumed when `i` was consumed.\\n**Case 1**. If `ri consumed i`, then all the elements in `(ri, i)` were already consumed before that step, so\\n```\\nsteps[i] = {max(steps[k])  for k in consumerCandidates[i] intersection (ri, i)} + 1\\n```\\n**Case 2**. If `ri` was already consumed by the time `i` was consumed, then \\n```\\nThere was atleast one element still existing in (ri,i) at the time when all the elements in (aci, ri] were consumed otherwise ri would have been the one to consume i,\\nso the last element in (aci, i) before i is consumed still lies in (ri,i)\\nmax(steps[k]) for k in (aci, ri] < max(steps[p]) for p in (ri, i) \\n=> steps[i] = {max(steps[k]) for k in consumerCandidates[i-1] intersection (aci, i)} + 1 = {max(steps[k]) for k in consumerCandidates[i-1] intersection (ri, i)} + 1\\n```\\nIn both cases, \\n```\\nsteps[i] = {max(steps[k]) for k in consumerCandidates[i-1] intersection (ri, i)} + 1\\n```\\nmeaning we only need to check the elements between the `ith` and the last higher element(exclusive) and find the step at which the last of those element was consumed.\\n\\n\\n**Third intuition:**\\nInstead of maintaining and iterating through all `k in consumerCandidates[i-1] intersection (ri, i)} ` naively using an inner-loop for each `i` which will make the complexity `O(n^2)`, we can iterate through them using a stack to reduce it to `O(n)` because we only need a subset of values used by in the previous step and don\\'t need to reiterate over any seen value.\\n\\nThe final answer is the max `steps[i]` found.\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int n = nums.size();\\n        stack<int> consumerCandidates;\\n        vector<int> steps(n, 0); // the step at which the ith element will get consumed, will be 0 if it is never consumed.\\n        for (int i=0;i<n;i++) {\\n            int maxStepsBetweenConsumerAndI = 0; // number of steps it took for all the elements between i and the last element > ith element to get consumed \\n            while(!consumerCandidates.empty() && nums[consumerCandidates.top()] <= nums[i]) {\\n                maxStepsBetweenConsumerAndI = max(maxStepsBetweenConsumerAndI, steps[consumerCandidates.top()]);\\n                consumerCandidates.pop();\\n            }\\n            if (!consumerCandidates.empty()) { // does anyone remains to consume i\\n                steps[i] = maxStepsBetweenConsumerAndI + 1;  // steps to consume i are one plus the number of steps to consume everything between i and the last higer element\\n            }\\n            consumerCandidates.push(i);\\n        }\\n        \\n        return *max_element(steps.begin(), steps.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nsteps[i] = {max(steps[k])  for k in consumerCandidates[i] intersection (ri, i)} + 1\\n```\n```\\nThere was atleast one element still existing in (ri,i) at the time when all the elements in (aci, ri] were consumed otherwise ri would have been the one to consume i,\\nso the last element in (aci, i) before i is consumed still lies in (ri,i)\\nmax(steps[k]) for k in (aci, ri] < max(steps[p]) for p in (ri, i) \\n=> steps[i] = {max(steps[k]) for k in consumerCandidates[i-1] intersection (aci, i)} + 1 = {max(steps[k]) for k in consumerCandidates[i-1] intersection (ri, i)} + 1\\n```\n```\\nsteps[i] = {max(steps[k]) for k in consumerCandidates[i-1] intersection (ri, i)} + 1\\n```\n```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int n = nums.size();\\n        stack<int> consumerCandidates;\\n        vector<int> steps(n, 0); // the step at which the ith element will get consumed, will be 0 if it is never consumed.\\n        for (int i=0;i<n;i++) {\\n            int maxStepsBetweenConsumerAndI = 0; // number of steps it took for all the elements between i and the last element > ith element to get consumed \\n            while(!consumerCandidates.empty() && nums[consumerCandidates.top()] <= nums[i]) {\\n                maxStepsBetweenConsumerAndI = max(maxStepsBetweenConsumerAndI, steps[consumerCandidates.top()]);\\n                consumerCandidates.pop();\\n            }\\n            if (!consumerCandidates.empty()) { // does anyone remains to consume i\\n                steps[i] = maxStepsBetweenConsumerAndI + 1;  // steps to consume i are one plus the number of steps to consume everything between i and the last higer element\\n            }\\n            consumerCandidates.push(i);\\n        }\\n        \\n        return *max_element(steps.begin(), steps.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2182454,
                "title": "c-solution-using-stacks",
                "content": "Time complexity is O(n).\\n```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        stack<pair<int,int>>st;\\n        int ans=0,n=nums.size()-1;\\n        st.push({nums[n--],0});\\n        while(n>=0){\\n            int c=0;\\n            while(!st.empty()&&nums[n]>st.top().first){\\n                c=max(c+1,st.top().second);\\n                st.pop();\\n            }\\n            ans=max(ans,c);\\n            st.push({nums[n--],c});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        stack<pair<int,int>>st;\\n        int ans=0,n=nums.size()-1;\\n        st.push({nums[n--],0});\\n        while(n>=0){\\n            int c=0;\\n            while(!st.empty()&&nums[n]>st.top().first){\\n                c=max(c+1,st.top().second);\\n                st.pop();\\n            }\\n            ans=max(ans,c);\\n            st.push({nums[n--],c});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2177346,
                "title": "c-sol-using-monotonic-stack",
                "content": "\\t\\n\\t\\tint i=0;\\n        int n=a.size();\\n        vector<int> v(n);\\n        stack<int> s;\\n        for(i=0;i<n;i++)\\n        {\\n            int x=0;\\n            while(!s.empty() && a[s.top()]<=a[i])\\n            {\\n                if(v[s.top()]>x)\\n                    x=v[s.top()];\\n                s.pop();\\n            }\\n            if(s.empty())\\n                v[i]=0;\\n            else\\n                v[i]=x+1;\\n            s.push(i);\\n        }\\n        int m=0;\\n        for(i=0;i<n;i++)\\n        {\\n            if(v[i]>m)\\n                m=v[i];\\n        }\\n        return m;",
                "solutionTags": [],
                "code": "\\t\\n\\t\\tint i=0;\\n        int n=a.size();\\n        vector<int> v(n);\\n        stack<int> s;\\n        for(i=0;i<n;i++)\\n        {\\n            int x=0;\\n            while(!s.empty() && a[s.top()]<=a[i])\\n            {\\n                if(v[s.top()]>x)\\n                    x=v[s.top()];\\n                s.pop();\\n            }\\n            if(s.empty())\\n                v[i]=0;\\n            else\\n                v[i]=x+1;\\n            s.push(i);\\n        }\\n        int m=0;\\n        for(i=0;i<n;i++)\\n        {\\n            if(v[i]>m)\\n                m=v[i];\\n        }\\n        return m;",
                "codeTag": "Unknown"
            },
            {
                "id": 2163960,
                "title": "java-simple-monostack-o-n",
                "content": "```\\nclass Solution {\\n    \\n    public int totalSteps(int[] nums) {\\n        \\n        int n = nums.length, res = 0;\\n        final Deque<int[]> stack = new LinkedList<>();\\n        stack.push(new int[]{nums[n-1], 0});\\n        \\n        for (int i=n-2; i>=0; --i) {\\n            int count = 0;\\n            while (!stack.isEmpty() && stack.peek()[0] < nums[i]) {\\n                count = Math.max(count + 1, stack.pop()[1]);\\n            }\\n            stack.push(new int[]{nums[i], count});\\n            res = Math.max(res, count);\\n        }\\n        \\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Monotonic Stack"
                ],
                "code": "class Solution {\\n    \\n    public int totalSteps(int[] nums) {\\n        \\n        int n = nums.length, res = 0;\\n        final Deque<int[]> stack = new LinkedList<>();\\n        stack.push(new int[]{nums[n-1], 0}",
                "codeTag": "Java"
            },
            {
                "id": 2160169,
                "title": "java-long-but-intuitive-and-easy-to-understand-solution",
                "content": "2 observations:\\n1) the first number must be kept, so that basically means we start from the first number and scan backward and keep all numbers that are not smaller than the previous number. [5,3,4,4,7,3,6,11,8,5,11] -> [5,7,11,11]\\n2) then all numbers not in the final result ***must*** be removed. to do that we use a stack to keep only decreasing sequence.\\n\\nit\\'s not as simple as those very concise solution but easy to understand.\\n\\n```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        if (null==nums) {\\n            return -1;\\n        } else if (nums.length<=1) {\\n            return 0;\\n        }\\n        List<Integer> l=new ArrayList<Integer>();\\n        int prev=nums[0];\\n        l.add(0);\\n        for (int i=1;i<nums.length;i++) {\\n            if (prev<=nums[i]) {\\n                l.add(i);\\n                prev=nums[i];\\n            }\\n        }\\n        if (l.size()==nums.length) {\\n            return 0;\\n        }\\n        l.add(nums.length);\\n        int result=1;\\n        for (int i=1;i<l.size();i++) {\\n            Stack<int[]> s=new Stack<int[]>();\\n            for (int j=l.get(i-1)+1;j<l.get(i);j++) {\\n                if (s.isEmpty()) {\\n                    s.push(new int[]{nums[j],1});\\n                    continue;\\n                }\\n                int[] top=new int[2];\\n                top[1]=0;\\n                int localtop=0;\\n                while (!s.isEmpty()&&nums[j]>=s.peek()[0]) {\\n                    top=s.pop();\\n                    localtop=Math.max(top[1],localtop);\\n                }\\n                s.push(new int[]{nums[j],localtop+1});\\n                result=Math.max(localtop+1,result);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        if (null==nums) {\\n            return -1;\\n        } else if (nums.length<=1) {\\n            return 0;\\n        }\\n        List<Integer> l=new ArrayList<Integer>();\\n        int prev=nums[0];\\n        l.add(0);\\n        for (int i=1;i<nums.length;i++) {\\n            if (prev<=nums[i]) {\\n                l.add(i);\\n                prev=nums[i];\\n            }\\n        }\\n        if (l.size()==nums.length) {\\n            return 0;\\n        }\\n        l.add(nums.length);\\n        int result=1;\\n        for (int i=1;i<l.size();i++) {\\n            Stack<int[]> s=new Stack<int[]>();\\n            for (int j=l.get(i-1)+1;j<l.get(i);j++) {\\n                if (s.isEmpty()) {\\n                    s.push(new int[]{nums[j],1});\\n                    continue;\\n                }\\n                int[] top=new int[2];\\n                top[1]=0;\\n                int localtop=0;\\n                while (!s.isEmpty()&&nums[j]>=s.peek()[0]) {\\n                    top=s.pop();\\n                    localtop=Math.max(top[1],localtop);\\n                }\\n                s.push(new int[]{nums[j],localtop+1});\\n                result=Math.max(localtop+1,result);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2151244,
                "title": "java-solution-linkedlist-dp",
                "content": "```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        LinkedList<Integer> queue = new LinkedList<>();\\n        int max = 0;\\n        queue.addLast(0);\\n        int[] dp = new int[nums.length];\\n        for(int i =1;i< nums.length;i++){\\n          \\n            while(!queue.isEmpty()&& nums[i] >= nums[queue.peekLast()]){\\n                int idx = queue.pollLast();\\n                dp[i] = Math.max(dp[idx],dp[i]);\\n            }\\n            dp[i] = queue.isEmpty()? 0 : dp[i]+1;\\n            queue.addLast(i);\\n\\n            max = Math.max(max,dp[i]);\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        LinkedList<Integer> queue = new LinkedList<>();\\n        int max = 0;\\n        queue.addLast(0);\\n        int[] dp = new int[nums.length];\\n        for(int i =1;i< nums.length;i++){\\n          \\n            while(!queue.isEmpty()&& nums[i] >= nums[queue.peekLast()]){\\n                int idx = queue.pollLast();\\n                dp[i] = Math.max(dp[idx],dp[i]);\\n            }\\n            dp[i] = queue.isEmpty()? 0 : dp[i]+1;\\n            queue.addLast(i);\\n\\n            max = Math.max(max,dp[i]);\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139690,
                "title": "why-count-math-max-count-1-stk-peek-value",
                "content": "We start from ending, But how did we concluded that Math.max(count+1, stk.peek().value) will handle both cases where previous index\\'s value is to be included or not?\\n \\n\\n",
                "solutionTags": [],
                "code": "We start from ending, But how did we concluded that Math.max(count+1, stk.peek().value) will handle both cases where previous index\\'s value is to be included or not?\\n \\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2132225,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        stack = []\\n        dp = [0]*len(nums)\\n        for i in range(len(nums)-1,-1,-1):\\n            while stack and nums[i] > nums[stack[-1]]:\\n                dp[i] = max(dp[i]+1, dp[stack.pop()])\\n            stack.append(i)\\n        return max(dp)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        stack = []\\n        dp = [0]*len(nums)\\n        for i in range(len(nums)-1,-1,-1):\\n            while stack and nums[i] > nums[stack[-1]]:\\n                dp[i] = max(dp[i]+1, dp[stack.pop()])\\n            stack.append(i)\\n        return max(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2128593,
                "title": "python3-stack-with-explanation",
                "content": "```\\ndef totalSteps(self, nums: List[int]) -> int:\\n        stack = []\\n        # stack tracks [the number value nums[0], the rounds to remove the element]\\n        stack.append([nums[0],0])\\n        \\n        # use l to track the length of stack\\n        l = 1\\n        \\n        # initiate answer with 0 step\\n        ans = 0\\n        \\n        # loop through the array        \\n        for i in range(1,len(nums)):\\n            count = 1\\n            while l>0:\\n                # if nums[i] is greater than or equal to numbers in stack, \\n                # count is the max of (rounds of the number gets removed + 1, count)\\n                if stack[l-1][0]<=nums[i]:\\n                    count = max(count, stack[l-1][1]+1)\\n                    stack.pop()\\n                    l -= 1\\n                else:\\n                    ans = count if ans<count else ans\\n                    break\\n            stack.append([nums[i],count])\\n            l += 1\\n            \\n        return ans",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef totalSteps(self, nums: List[int]) -> int:\\n        stack = []\\n        # stack tracks [the number value nums[0], the rounds to remove the element]\\n        stack.append([nums[0],0])\\n        \\n        # use l to track the length of stack\\n        l = 1\\n        \\n        # initiate answer with 0 step\\n        ans = 0\\n        \\n        # loop through the array        \\n        for i in range(1,len(nums)):\\n            count = 1\\n            while l>0:\\n                # if nums[i] is greater than or equal to numbers in stack, \\n                # count is the max of (rounds of the number gets removed + 1, count)\\n                if stack[l-1][0]<=nums[i]:\\n                    count = max(count, stack[l-1][1]+1)\\n                    stack.pop()\\n                    l -= 1\\n                else:\\n                    ans = count if ans<count else ans\\n                    break\\n            stack.append([nums[i],count])\\n            l += 1\\n            \\n        return ans",
                "codeTag": "Python3"
            },
            {
                "id": 2114774,
                "title": "simple-stack-with-previous-greater-element",
                "content": "```\\nint totalSteps(vector<int>& nums) {\\n        \\n        // store just previous greater element for each number with its distance.(note we use max steps till  //       now as distance measure) \\n        // this way we know in how many steps will it be removed. \\n        // find max of all these steps/\\n        // 10 1 2  6 1 2 3 4 \\n        //. 0 1 2 \\xA03 1 2 3 4\\n        \\n        stack<pair<int,int>> st;\\n        int n=nums.size();\\n        int pge[n];\\n        st.push({nums[0],0});\\n        pge[0]=0;\\n        for(int i=1;i<n;i++){\\n           if(st.empty()){\\n               st.push({nums[i],i});\\n               pge[i]=0;\\n           }\\n          else{\\n             // pair<int,int> p=st.top();\\n              int maxpge=0;\\n             while(!st.empty() and st.top().first<= nums[i]){\\n                 maxpge=max(pge[st.top().second],maxpge);\\n                 st.pop();\\n             }\\n             if(!st.empty()){\\n                 pge[i]= maxpge+1;\\n             }\\n             else pge[i]=0;\\n             st.push({nums[i],i});\\n          }\\n        }\\n        \\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            ans=max(ans,pge[i]);\\n            // cout<<pge[i]<<\" \";\\n        }\\n        // cout<<\"\\\\n\";\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint totalSteps(vector<int>& nums) {\\n        \\n        // store just previous greater element for each number with its distance.(note we use max steps till  //       now as distance measure) \\n        // this way we know in how many steps will it be removed. \\n        // find max of all these steps/\\n        // 10 1 2  6 1 2 3 4 \\n        //. 0 1 2 \\xA03 1 2 3 4\\n        \\n        stack<pair<int,int>> st;\\n        int n=nums.size();\\n        int pge[n];\\n        st.push({nums[0],0});\\n        pge[0]=0;\\n        for(int i=1;i<n;i++){\\n           if(st.empty()){\\n               st.push({nums[i],i});\\n               pge[i]=0;\\n           }\\n          else{\\n             // pair<int,int> p=st.top();\\n              int maxpge=0;\\n             while(!st.empty() and st.top().first<= nums[i]){\\n                 maxpge=max(pge[st.top().second],maxpge);\\n                 st.pop();\\n             }\\n             if(!st.empty()){\\n                 pge[i]= maxpge+1;\\n             }\\n             else pge[i]=0;\\n             st.push({nums[i],i});\\n          }\\n        }\\n        \\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            ans=max(ans,pge[i]);\\n            // cout<<pge[i]<<\" \";\\n        }\\n        // cout<<\"\\\\n\";\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2108740,
                "title": "c-bfs-based-simulation",
                "content": "simulation says: \\n* \\ttake each number as centers who are eating their next element \\n* \\tin each step check weather it eats it\\'s next element. \\n\\t* if YES : then increase it\\'s size telling who should be checked in next iteration for eating\\n\\t* else : just remove it from iteration \\n* terminate when there is no center for eating left \\n**IMPORTANT** : we are triversing centers in reverse order because each number can eat it\\'s next element so condition like 11 8 5, where 8 eats 5 and 11 eats 8 in single iteration can be covered \\n```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int n = nums.size(); \\n        vector<int> res; \\n        for(int i=n-1;i>=0;i-=1){\\n            res.push_back(i); \\n        }\\n        vector<int> size(n,1); \\n        int ans = -1; \\n        while(res.size()){\\n            vector<int>tp; \\n            for(auto &i: res){\\n                if(i+size[i] < n and nums[i + size[i]] < nums[i]){\\n                    // it\\'s eaten if present in queue remove it \\n                    if(tp.size() and tp.back() == i + size[i]) tp.pop_back(); \\n                    size[i] += size[i+size[i]];\\n                    tp.push_back(i); // inserting index who has eaten in this iteration \\n                }\\n            }\\n            swap(res,tp); \\n            ans += 1; \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int n = nums.size(); \\n        vector<int> res; \\n        for(int i=n-1;i>=0;i-=1){\\n            res.push_back(i); \\n        }\\n        vector<int> size(n,1); \\n        int ans = -1; \\n        while(res.size()){\\n            vector<int>tp; \\n            for(auto &i: res){\\n                if(i+size[i] < n and nums[i + size[i]] < nums[i]){\\n                    // it\\'s eaten if present in queue remove it \\n                    if(tp.size() and tp.back() == i + size[i]) tp.pop_back(); \\n                    size[i] += size[i+size[i]];\\n                    tp.push_back(i); // inserting index who has eaten in this iteration \\n                }\\n            }\\n            swap(res,tp); \\n            ans += 1; \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2108067,
                "title": "steps-to-make-array-non-decreasing",
                "content": "why am i getting runtime error in my code ?\\n\\n\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        long long int count=0;\\n        while(true)\\n        {\\n            \\n        \\n            int a = nums[0];\\n            int c=0;\\n            for(auto it=nums.begin()+1;it!=nums.end();it++)\\n            {\\n                \\n                if(a>(*it))\\n                {\\n                    nums.erase(it);\\n                    c++;\\n                }\\n                \\n                a=(*it);\\n            }\\n            if(c==0)\\n              break;\\n            count++;\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        long long int count=0;\\n        while(true)\\n        {\\n            \\n        \\n            int a = nums[0];\\n            int c=0;\\n            for(auto it=nums.begin()+1;it!=nums.end();it++)\\n            {\\n                \\n                if(a>(*it))\\n                {\\n                    nums.erase(it);\\n                    c++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2098755,
                "title": "still-stack-but-could-be-more-straight-forward-no-reverse",
                "content": "Let start from the first element, let say `j` is the index of the neareset element that is greater than `nums[0]`, we know that any element in the range `(i,j)` would be removed in the en. We notice that any element would be discarded by its **previous greater element `k`** .The time an element would be discarded would be 1 + the maximum discared time of the elements among it and the k-index element . A monotoic stack is required to find the previous greater element, each time an element is poped out, update the maximum discard time by the discarded time of the poped element (These elements must be removed first otherwise the current element would not get a chance to be removed). Repeat this process until we visit all element then we would find the answer.\\n\\n```python\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        i = res = 0 \\n        while i < len(nums):\\n            j = i + 1\\n            stack = []\\n            while j < len(nums) and nums[j] < nums[i]:\\n                time = 0\\n                while stack and stack[-1][0] <= nums[j]:\\n                    time = max(time, stack.pop()[1])\\n                stack.append((nums[j], time+1))\\n                res = max(res, time+1)\\n                j += 1\\n            i = j\\n        return res \\n ```\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        i = res = 0 \\n        while i < len(nums):\\n            j = i + 1\\n            stack = []\\n            while j < len(nums) and nums[j] < nums[i]:\\n                time = 0\\n                while stack and stack[-1][0] <= nums[j]:\\n                    time = max(time, stack.pop()[1])\\n                stack.append((nums[j], time+1))\\n                res = max(res, time+1)\\n                j += 1\\n            i = j\\n        return res \\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2098565,
                "title": "easy-faster-efficient-java-soln",
                "content": "```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        Stack<int [] > st = new Stack<>();\\n        int ans = 0;\\n        for(int i = nums.length - 1; i >= 0; i--){\\n            int num = nums[i];\\n            int count = 0;\\n            while(!st.isEmpty() && st.peek()[0] < num){\\n                int [] rem = st.pop();\\n                count = Math.max(count + 1, rem[1]);\\n            }\\n            int [] arr = new int[2];\\n            arr[0] = num;\\n            arr[1] = count;\\n            st.push(arr);\\n            ans = Math.max(ans, count);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        Stack<int [] > st = new Stack<>();\\n        int ans = 0;\\n        for(int i = nums.length - 1; i >= 0; i--){\\n            int num = nums[i];\\n            int count = 0;\\n            while(!st.isEmpty() && st.peek()[0] < num){\\n                int [] rem = st.pop();\\n                count = Math.max(count + 1, rem[1]);\\n            }\\n            int [] arr = new int[2];\\n            arr[0] = num;\\n            arr[1] = count;\\n            st.push(arr);\\n            ans = Math.max(ans, count);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2098249,
                "title": "c-easy-solution-stacks",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        stack<pair<int,int>>st;\\n        int ans =0;\\n        st.push({nums[nums.size()-1],0});\\n        for(int i=nums.size()-2;i>=0;i--)\\n        {\\n            int t =0;\\n            while(!st.empty() && nums[i]>st.top().first)\\n            {\\n                t++;\\n                t = max(t,st.top().second);\\n                st.pop();\\n            }\\n            ans = max(ans,t);\\n            st.push({nums[i],t});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        stack<pair<int,int>>st;\\n        int ans =0;\\n        st.push({nums[nums.size()-1],0});\\n        for(int i=nums.size()-2;i>=0;i--)\\n        {\\n            int t =0;\\n            while(!st.empty() && nums[i]>st.top().first)\\n            {\\n                t++;\\n                t = max(t,st.top().second);\\n                st.pop();\\n            }\\n            ans = max(ans,t);\\n            st.push({nums[i],t});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2097777,
                "title": "simple-c-code",
                "content": "# **(upvote)If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        stack<pair<int,int>> StepOne;\\n        int ans = 0;\\n        int sz = nums.size();\\n        for(int i = sz-1; i >= 0; i--)\\n        {\\n            int cnt = 0;\\n            while(!StepOne.empty() && StepOne.top().first < nums[i])\\n            {\\n                if(StepOne.top().second == 0)\\n                {\\n                    cnt++;\\n                }\\n                else if(StepOne.top().second != 0)\\n                {\\n                    if(StepOne.top().second > cnt)\\n                    {\\n                        cnt += StepOne.top().second - cnt;\\n                    }\\n                    else\\n                    {\\n                        cnt += 1;\\n                    }\\n                }\\n                StepOne.pop();\\n            }\\n            StepOne.push({nums[i],cnt});\\n            ans = max(cnt,ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        stack<pair<int,int>> StepOne;\\n        int ans = 0;\\n        int sz = nums.size();\\n        for(int i = sz-1; i >= 0; i--)\\n        {\\n            int cnt = 0;\\n            while(!StepOne.empty() && StepOne.top().first < nums[i])\\n            {\\n                if(StepOne.top().second == 0)\\n                {\\n                    cnt++;\\n                }\\n                else if(StepOne.top().second != 0)\\n                {\\n                    if(StepOne.top().second > cnt)\\n                    {\\n                        cnt += StepOne.top().second - cnt;\\n                    }\\n                    else\\n                    {\\n                        cnt += 1;\\n                    }\\n                }\\n                StepOne.pop();\\n            }\\n            StepOne.push({nums[i],cnt});\\n            ans = max(cnt,ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2097552,
                "title": "c-solution",
                "content": "```\\nvoid next(int* nums, int numsSize, int k, int* i, int time){\\n    int now = 0;\\n    *i += 1;\\n    while( *i < numsSize ){\\n        if (k > nums[*i]){\\n            now++;\\n            next( nums, numsSize, nums[*i], i, now);\\n            if (now == time){\\n                return;\\n            }\\n        } else {\\n            return;\\n        }\\n    }\\n}\\n\\nint totalSteps(int* nums, int numsSize){\\n    int ans = 0;\\n    int time = 0;\\n    int k = nums[0];\\n    int i = 1;\\n    while( i < numsSize ){\\n        if (k > nums[i]){\\n            time++;\\n            next(nums, numsSize, nums[i], &i, time);\\n        } else {\\n            if (time > ans){\\n                ans = time;\\n            }\\n            time = 0;\\n            k = nums[i];\\n            i++;\\n        }\\n    }\\n    if (time > ans){\\n        ans = time;\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid next(int* nums, int numsSize, int k, int* i, int time){\\n    int now = 0;\\n    *i += 1;\\n    while( *i < numsSize ){\\n        if (k > nums[*i]){\\n            now++;\\n            next( nums, numsSize, nums[*i], i, now);\\n            if (now == time){\\n                return;\\n            }\\n        } else {\\n            return;\\n        }\\n    }\\n}\\n\\nint totalSteps(int* nums, int numsSize){\\n    int ans = 0;\\n    int time = 0;\\n    int k = nums[0];\\n    int i = 1;\\n    while( i < numsSize ){\\n        if (k > nums[i]){\\n            time++;\\n            next(nums, numsSize, nums[i], &i, time);\\n        } else {\\n            if (time > ans){\\n                ans = time;\\n            }\\n            time = 0;\\n            k = nums[i];\\n            i++;\\n        }\\n    }\\n    if (time > ans){\\n        ans = time;\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2096226,
                "title": "java-faster-than-100-less-than-85-47",
                "content": "```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        int max = 0;\\n        int[] pos = new int[nums.length+1];\\n        int[] steps = new int[nums.length+1];\\n        int top = -1;\\n        for (int i = 0; i <= nums.length; i++) {\\n            int val = i == nums.length ? Integer.MAX_VALUE : nums[i];\\n            while (top >= 0 && nums[pos[top]] <= val) {\\n                if (top == 0) max = Math.max(max, steps[pos[top--]]);\\n                else steps[pos[--top]] = Math.max(steps[pos[top]]+1, steps[pos[top+1]]);\\n            }\\n            pos[++top] = i;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        int max = 0;\\n        int[] pos = new int[nums.length+1];\\n        int[] steps = new int[nums.length+1];\\n        int top = -1;\\n        for (int i = 0; i <= nums.length; i++) {\\n            int val = i == nums.length ? Integer.MAX_VALUE : nums[i];\\n            while (top >= 0 && nums[pos[top]] <= val) {\\n                if (top == 0) max = Math.max(max, steps[pos[top--]]);\\n                else steps[pos[--top]] = Math.max(steps[pos[top]]+1, steps[pos[top+1]]);\\n            }\\n            pos[++top] = i;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2095558,
                "title": "solution-using-stack-dp-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int ans=0,n=nums.size();\\n        vector<int>dp(n,0);  // keeping track of the smaller elements to a element to its right\\n        stack<int>stk;\\n        for(int i=n-1;i>=0;i--){\\n            while(!stk.empty() && nums[i]>nums[stk.top()]){\\n                dp[i] = max(++dp[i],dp[stk.top()]);\\n                stk.pop();\\n                ans = max(ans,dp[i]);\\n            }\\n            stk.push(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int ans=0,n=nums.size();\\n        vector<int>dp(n,0);  // keeping track of the smaller elements to a element to its right\\n        stack<int>stk;\\n        for(int i=n-1;i>=0;i--){\\n            while(!stk.empty() && nums[i]>nums[stk.top()]){\\n                dp[i] = max(++dp[i],dp[stk.top()]);\\n                stk.pop();\\n                ans = max(ans,dp[i]);\\n            }\\n            stk.push(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2095306,
                "title": "java-stack",
                "content": "```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        int n = nums.length;\\n        int[] steps = new int[n];\\n        int ans = 0;\\n        Deque<Integer> deque = new ArrayDeque<>();\\n        for(int i = 0; i < nums.length; i++) {\\n            int maxSteps = 0;\\n            while(!deque.isEmpty() && (nums[deque.peekLast()] <= nums[i])) {\\n                int index = deque.removeLast();\\n                maxSteps = Math.max(maxSteps, steps[index]);\\n            }\\n            \\n            if(deque.isEmpty()) maxSteps = 0;\\n            else maxSteps += 1;\\n            steps[i] = maxSteps;\\n            deque.offerLast(i);\\n            ans = Math.max(ans, maxSteps);\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        int n = nums.length;\\n        int[] steps = new int[n];\\n        int ans = 0;\\n        Deque<Integer> deque = new ArrayDeque<>();\\n        for(int i = 0; i < nums.length; i++) {\\n            int maxSteps = 0;\\n            while(!deque.isEmpty() && (nums[deque.peekLast()] <= nums[i])) {\\n                int index = deque.removeLast();\\n                maxSteps = Math.max(maxSteps, steps[index]);\\n            }\\n            \\n            if(deque.isEmpty()) maxSteps = 0;\\n            else maxSteps += 1;\\n            steps[i] = maxSteps;\\n            deque.offerLast(i);\\n            ans = Math.max(ans, maxSteps);\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2093897,
                "title": "segment-tree-java-o-n-log-n",
                "content": "```\\nclass Solution {\\n    int[] tree;\\n    void update(int[] tree, int idx, int l, int r, int i, int v){\\n        if(l==r){\\n            tree[idx]=v;\\n            return ;\\n        }\\n        int mid = (l+r)/2;\\n        if(i<=mid){\\n            update(tree,idx*2+1, l, mid, i, v);\\n        } else {\\n            update(tree, idx*2+2,mid+1,r,i,v);\\n        }\\n        tree[idx]=Math.max(tree[idx*2+1],tree[idx*2+2]);\\n    }\\n    int query(int[] tree, int idx, int l, int r, int ql, int qr){\\n        if(ql<=l && qr>=r){\\n            return tree[idx];\\n        }\\n        int max = 0;\\n        int mid = (l+r)/2;\\n        if(ql<=mid){\\n            max=Math.max(max,query(tree,idx*2+1,l,mid,ql,qr));\\n        }\\n        if(qr>mid){\\n            max=Math.max(max,query(tree,idx*2+2,mid+1,r,ql,qr));\\n        }\\n        return max;\\n    }\\n    public int totalSteps(int[] nums) {\\n        int n = nums.length;\\n        int leaves = (Integer.highestOneBit(n)==n) ? n : (Integer.highestOneBit(n)<<1); //next power of 2\\n        tree = new int[n*4];\\n        Stack<Integer> stack = new Stack<>();\\n        int ans = 0;\\n        for(int i=0;i<nums.length;i++){\\n            while(!stack.isEmpty() && nums[stack.peek()]<=nums[i]){\\n                stack.pop();\\n            }\\n            if(!stack.isEmpty()){\\n                int steps = 1;\\n                if((i-stack.peek())>1){\\n                    steps = Math.max(steps,query(tree,0,0,leaves-1,stack.peek()+1,i-1)+1);\\n                }\\n                update(tree,0,0,leaves-1,i,steps);\\n                ans = Math.max(ans,steps);\\n            }\\n            stack.push(i);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Stack",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    int[] tree;\\n    void update(int[] tree, int idx, int l, int r, int i, int v){\\n        if(l==r){\\n            tree[idx]=v;\\n            return ;\\n        }\\n        int mid = (l+r)/2;\\n        if(i<=mid){\\n            update(tree,idx*2+1, l, mid, i, v);\\n        } else {\\n            update(tree, idx*2+2,mid+1,r,i,v);\\n        }\\n        tree[idx]=Math.max(tree[idx*2+1],tree[idx*2+2]);\\n    }\\n    int query(int[] tree, int idx, int l, int r, int ql, int qr){\\n        if(ql<=l && qr>=r){\\n            return tree[idx];\\n        }\\n        int max = 0;\\n        int mid = (l+r)/2;\\n        if(ql<=mid){\\n            max=Math.max(max,query(tree,idx*2+1,l,mid,ql,qr));\\n        }\\n        if(qr>mid){\\n            max=Math.max(max,query(tree,idx*2+2,mid+1,r,ql,qr));\\n        }\\n        return max;\\n    }\\n    public int totalSteps(int[] nums) {\\n        int n = nums.length;\\n        int leaves = (Integer.highestOneBit(n)==n) ? n : (Integer.highestOneBit(n)<<1); //next power of 2\\n        tree = new int[n*4];\\n        Stack<Integer> stack = new Stack<>();\\n        int ans = 0;\\n        for(int i=0;i<nums.length;i++){\\n            while(!stack.isEmpty() && nums[stack.peek()]<=nums[i]){\\n                stack.pop();\\n            }\\n            if(!stack.isEmpty()){\\n                int steps = 1;\\n                if((i-stack.peek())>1){\\n                    steps = Math.max(steps,query(tree,0,0,leaves-1,stack.peek()+1,i-1)+1);\\n                }\\n                update(tree,0,0,leaves-1,i,steps);\\n                ans = Math.max(ans,steps);\\n            }\\n            stack.push(i);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2093723,
                "title": "c-stack-segment-tree-explanation",
                "content": "It\\'s easy to figure out that if a[i] not in the final non-descending array, it should be erase after some smaller values between previous larger value of a[i], let called b, [b+1, i-1]\\n\\nFor example:\\n```\\n[3, 5, 7, 15, 13, 12, 14]\\n\\nround1:\\n[3, 5, 7, 15, 14]\\n\\nround2:\\n[3, 5, 7, 15]\\n\\n-\\n\\nanother case\\n[3, 5, 7, 15, 12, 13, 14]\\n\\nround1:\\n[3, 5, 7, 15, 13, 14]\\n\\nround2:\\n[3, 5, 7, 15, 14]\\n\\nround3:\\n[3, 5, 7, 15]\\n```\\n14 is removed after 13 and 12, that the value between previous larger value to current one\\nwe don\\'t care who was removed first\\nthe solution will be max([prevLargerIndex+1, current-1]) + 1\\n\\n- range query max could be solved by segment tree\\n- and previous larger index could be solved by strictly monotonic decreasing stack\\n\\nThe corner case is that, if there have a descending in array, there must has at least 1 operation\\nHow to check it? => Just use `previousGreater` to check it\\n- answer for position i will be `max(max([prevLargerIndex+1, current-1]+1, 1))`\\n\\nand after calculating value of position i, we need to update the result to segment tree for further calculation\\n\\nHere is the solution\\n```\\nconst int nax = 1e5+5;\\nclass Solution {\\npublic:    \\n    int node[nax*4+5];\\n    int lazy[nax*4+5];\\n    \\n    void push(int lo, int hi, int idx) {\\n        if (lazy[idx] == 0) return;\\n        node[idx] = lazy[idx];\\n\\n        // push to childrens\\n        if (lo != hi) {\\n            lazy[2*idx+1] = lazy[idx];\\n            lazy[2*idx+2] = lazy[idx];\\n        }\\n        \\n        lazy[idx] = 0;\\n    }\\n    \\n    void pull(int idx) {\\n        node[idx] = max(node[2*idx+1], node[2*idx+2]);\\n    }\\n    \\n    void upd(int us, int ue, int lo, int hi, int val, int idx = 0) {\\n        push(lo, hi, idx);\\n\\n        if (us > hi || ue < lo) return;\\n\\n        // in range\\n        if (lo >= us && hi <= ue) {\\n            lazy[idx] = val;\\n            push(lo, hi, idx);\\n            return;\\n        }\\n\\n        int mid = (lo + hi)/2;\\n        upd(us, ue, lo, mid, val, 2*idx+1);\\n        upd(us, ue, mid+1, hi, val, 2*idx+2);\\n        pull(idx);\\n    }\\n    \\n    int query(int qs, int qe, int lo = 0, int hi = -1, int idx = 0) {\\n        push(lo, hi, idx);\\n\\n        if (hi < qs || lo > qe) return 0;\\n        if (lo >= qs && hi <= qe) return node[idx];\\n        int mid = (lo + hi)/2;\\n        return max(query(qs, qe, lo, mid, 2*idx+1),\\n                query(qs, qe, mid+1, hi, 2*idx+2));\\n    }\\n    \\n    int totalSteps(vector<int>& a) {\\n        int n = a.size();\\n        \\n        memset(node, 0, sizeof(node));\\n        memset(lazy, 0, sizeof(lazy));\\n        \\n        // previous greater and equal\\n        vector<int> prevGreater(n);\\n        stack<pair<int, int>> st;\\n        st.push(make_pair(1e9+5, -1));\\n        for (int i = 0; i < n; i++) {\\n            while (!st.empty() && st.top().first <= a[i])\\n                st.pop();\\n            prevGreater[i] = st.top().second;\\n            st.push(make_pair(a[i], i));\\n        }\\n        \\n        int ans = 0;\\n        for (int i = 1; i < n; i++) {\\n            int idx = prevGreater[i];\\n            \\n            // greatest value so far\\n            if (idx < 0) continue;\\n            int res = query(idx+1, i-1, 0, n-1);\\n            res = max(res+1, 1);\\n            upd(i, i, 0, n-1, res);\\n            ans = max(ans, res);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nT: O(NlogN + N)\\nS: O(N)",
                "solutionTags": [
                    "Stack",
                    "Tree"
                ],
                "code": "```\\n[3, 5, 7, 15, 13, 12, 14]\\n\\nround1:\\n[3, 5, 7, 15, 14]\\n\\nround2:\\n[3, 5, 7, 15]\\n\\n-\\n\\nanother case\\n[3, 5, 7, 15, 12, 13, 14]\\n\\nround1:\\n[3, 5, 7, 15, 13, 14]\\n\\nround2:\\n[3, 5, 7, 15, 14]\\n\\nround3:\\n[3, 5, 7, 15]\\n```\n```\\nconst int nax = 1e5+5;\\nclass Solution {\\npublic:    \\n    int node[nax*4+5];\\n    int lazy[nax*4+5];\\n    \\n    void push(int lo, int hi, int idx) {\\n        if (lazy[idx] == 0) return;\\n        node[idx] = lazy[idx];\\n\\n        // push to childrens\\n        if (lo != hi) {\\n            lazy[2*idx+1] = lazy[idx];\\n            lazy[2*idx+2] = lazy[idx];\\n        }\\n        \\n        lazy[idx] = 0;\\n    }\\n    \\n    void pull(int idx) {\\n        node[idx] = max(node[2*idx+1], node[2*idx+2]);\\n    }\\n    \\n    void upd(int us, int ue, int lo, int hi, int val, int idx = 0) {\\n        push(lo, hi, idx);\\n\\n        if (us > hi || ue < lo) return;\\n\\n        // in range\\n        if (lo >= us && hi <= ue) {\\n            lazy[idx] = val;\\n            push(lo, hi, idx);\\n            return;\\n        }\\n\\n        int mid = (lo + hi)/2;\\n        upd(us, ue, lo, mid, val, 2*idx+1);\\n        upd(us, ue, mid+1, hi, val, 2*idx+2);\\n        pull(idx);\\n    }\\n    \\n    int query(int qs, int qe, int lo = 0, int hi = -1, int idx = 0) {\\n        push(lo, hi, idx);\\n\\n        if (hi < qs || lo > qe) return 0;\\n        if (lo >= qs && hi <= qe) return node[idx];\\n        int mid = (lo + hi)/2;\\n        return max(query(qs, qe, lo, mid, 2*idx+1),\\n                query(qs, qe, mid+1, hi, 2*idx+2));\\n    }\\n    \\n    int totalSteps(vector<int>& a) {\\n        int n = a.size();\\n        \\n        memset(node, 0, sizeof(node));\\n        memset(lazy, 0, sizeof(lazy));\\n        \\n        // previous greater and equal\\n        vector<int> prevGreater(n);\\n        stack<pair<int, int>> st;\\n        st.push(make_pair(1e9+5, -1));\\n        for (int i = 0; i < n; i++) {\\n            while (!st.empty() && st.top().first <= a[i])\\n                st.pop();\\n            prevGreater[i] = st.top().second;\\n            st.push(make_pair(a[i], i));\\n        }\\n        \\n        int ans = 0;\\n        for (int i = 1; i < n; i++) {\\n            int idx = prevGreater[i];\\n            \\n            // greatest value so far\\n            if (idx < 0) continue;\\n            int res = query(idx+1, i-1, 0, n-1);\\n            res = max(res+1, 1);\\n            upd(i, i, 0, n-1, res);\\n            ans = max(ans, res);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2093264,
                "title": "simple-efficient-solution",
                "content": "```\\ntypedef long long ll;\\ntypedef long double ld;\\ntypedef vector<ll> vi;\\n#define endl \\'\\\\n\\'\\n#define tn TreeNode\\n#define ln ListNode\\nconst ll mod = 1e9;\\n\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& v) {\\n        ll sz = v.size();\\n        stack<pair<ll, ll>>st;\\n        ll res = 0;\\n        for (ll i = sz - 1;i > -1;--i) {\\n            ll cnt = 0;\\n            while (!st.empty() && st.top().first < v[i]) {\\n                cnt = max(cnt + 1, st.top().second);\\n                st.pop();\\n            }\\n            res = max(res, cnt);\\n            st.push({ v[i], cnt });\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\ntypedef long long ll;\\ntypedef long double ld;\\ntypedef vector<ll> vi;\\n#define endl \\'\\\\n\\'\\n#define tn TreeNode\\n#define ln ListNode\\nconst ll mod = 1e9;\\n\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& v) {\\n        ll sz = v.size();\\n        stack<pair<ll, ll>>st;\\n        ll res = 0;\\n        for (ll i = sz - 1;i > -1;--i) {\\n            ll cnt = 0;\\n            while (!st.empty() && st.top().first < v[i]) {\\n                cnt = max(cnt + 1, st.top().second);\\n                st.pop();\\n            }\\n            res = max(res, cnt);\\n            st.push({ v[i], cnt });\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2092472,
                "title": "javascript-monotonic-stack-dp",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar totalSteps = function (nums) {\\n  let ans = 0;\\n  const n = nums.length;\\n  const stack = [];\\n  const dp = new Array(n).fill(0);\\n\\n  for (let i = n - 1; i >= 0; i--) {\\n    while (stack.length > 0 && nums[i] > nums[stack[stack.length - 1]]) {\\n      const j = stack.pop();\\n      dp[i] = Math.max(dp[i] + 1, dp[j]);\\n      ans = Math.max(ans, dp[i]);\\n    }\\n    stack.push(i);\\n  }\\n\\n  return ans;\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Monotonic Stack"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar totalSteps = function (nums) {\\n  let ans = 0;\\n  const n = nums.length;\\n  const stack = [];\\n  const dp = new Array(n).fill(0);\\n\\n  for (let i = n - 1; i >= 0; i--) {\\n    while (stack.length > 0 && nums[i] > nums[stack[stack.length - 1]]) {\\n      const j = stack.pop();\\n      dp[i] = Math.max(dp[i] + 1, dp[j]);\\n      ans = Math.max(ans, dp[i]);\\n    }\\n    stack.push(i);\\n  }\\n\\n  return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2092296,
                "title": "no-reverse-mono-stack",
                "content": "```\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        i = 0\\n        ans = 0\\n        while i < n:\\n            j = i + 1\\n            while j < n and nums[j] < nums[i]:\\n                j += 1\\n            # find the interval in which all the num smaller than left side nums[i]\\n            # maintain the descresing stack [a, b, c, d]\\n            # when comes e and (b, c, d) <= e, the cost to remove e is max(b, c, d) + 1\\n            st = []\\n            for k in range(i + 1, j):\\n                t = 0\\n                while st and st[-1][0] <= nums[k]:\\n                    _, tmp = st.pop()\\n                    t = max(t, tmp)\\n                t += 1\\n                st.append((nums[k], t))\\n                ans = max(ans, t)\\n            i = j\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        i = 0\\n        ans = 0\\n        while i < n:\\n            j = i + 1\\n            while j < n and nums[j] < nums[i]:\\n                j += 1\\n            # find the interval in which all the num smaller than left side nums[i]\\n            # maintain the descresing stack [a, b, c, d]\\n            # when comes e and (b, c, d) <= e, the cost to remove e is max(b, c, d) + 1\\n            st = []\\n            for k in range(i + 1, j):\\n                t = 0\\n                while st and st[-1][0] <= nums[k]:\\n                    _, tmp = st.pop()\\n                    t = max(t, tmp)\\n                t += 1\\n                st.append((nums[k], t))\\n                ans = max(ans, t)\\n            i = j\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565314,
                "content": [
                    {
                        "username": "DolphinsAtDaybreak",
                        "content": "**EDIT: They\\'ve fixed the hints now!**\\n\\nI got to the idea of monotonic stack during the contest but didn\\'t quite figure out the final algorithm.  Looking at the hints now I see:\\n\\nHint 3\\nConsider an element at index i. Say there exists a strictly greater element to its left, and the closest one is located at index j (i.e. there is no index k such that j < k < i and nums[k] > nums[i]). The number of rounds required to remove nums[i] is i - j.\\n\\nHow does that work?  If we have an array [6,5,4,3,2,1,5] -- shouldn\\'t it take 2 rounds to remove the 5, not i-j=6 rounds?\\n\\n"
                    },
                    {
                        "username": "Taranovski",
                        "content": "leetcode, forget about \"medium\" rating for anything monolithic stack, it is extremely non-intuitive and \"jumping through the hoops\", set the realistic \"hard\" rating for it!\\nExtremely confusing \"pattern\" of the solution, be real!"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "great question but should be hard"
                    },
                    {
                        "username": "XeBaGac",
                        "content": "Time Limit Exceeded with TC 79, i don\\'t know how to make my code quicker :((("
                    },
                    {
                        "username": "Flankerr",
                        "content": "can someone please explain how this array is completed in 1 step.\\n\\naccording to my calculation\\noriginal [10,6,5,10,15]\\n1st step [10,5,10,15]\\n2nd step [10,10,15]"
                    },
                    {
                        "username": "XeBaGac",
                        "content": "in step1 u erase both 6 and 5 because  6>5 . Therefore, the result is 10,10,15\\n"
                    },
                    {
                        "username": "prashantkumarrai8",
                        "content": "1st we remove 5 bcz of 6 and then 6 bcz of 10"
                    },
                    {
                        "username": "shhattali2002",
                        "content": "[@Gyaneswar Singh](/Flankerr) don't delete the integer directly first check out the index elements that satisfy given condition ( nums[i]<nums[i-1] ) than go for deletion.\neg. original [10,6,5,10,15]\nHere index 1,2 satisfy the condition than delete them it will take 1 step.\n\neg. Original [5,3,4,4,7,3,6,11,8,5,11]\nHere index 1,5,8,9 satisfy hence step 1.\n[5,4,4,7,6,11,11]\nIn step 2 index 1,4 satisfy condition\n[5,4,4,7,11,11]\nIn step 3 index 1 satisfy condition\n[5,7,11,11]\n"
                    },
                    {
                        "username": "aaks-ctrl",
                        "content": "Can someone tell me where an I going wrong with my approach ?\\n \\n `\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        stack<int> c;\\n        int ans{};\\n        int steps{};\\n        while(nums.size()){\\n            int last=nums.back();\\n            nums.pop_back();\\n            int i{};\\n            while(c.size() && last>c.top()){\\n                c.pop();\\n                i++;\\n            }\\n            ans=max(i,ans);\\n            c.push(last);\\n        }\\n        return ans;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "2uringTested",
                        "content": "i would\\'ve tried if it was written in a coding language...\\n\\n/s .... try writing a bit readable code."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "For the test case\\n\\n[5,1,2,3,4]\\n\\nJust removing 5 in the start would make it [1,2,3,4] which is a Non Decreasing Array . \\n\\nSo number of steps needed is \\'1\\' . But the solution expected is 4 . Am i missing something ? \\n\\nThanks in Advance."
                    },
                    {
                        "username": "ashishnethi",
                        "content": "We need to remove nums[i] not nums[i-1]"
                    },
                    {
                        "username": "MaverickEyedea",
                        "content": "[@sugreem](/sugreem) Thanks for this answer. I was removing nums[i - 1] and I was so confused. Should have read the question carefully."
                    },
                    {
                        "username": "sugreem",
                        "content": "remove nums[i] such that nums[i] < nums[i-1]"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1576819,
                "content": [
                    {
                        "username": "DolphinsAtDaybreak",
                        "content": "**EDIT: They\\'ve fixed the hints now!**\\n\\nI got to the idea of monotonic stack during the contest but didn\\'t quite figure out the final algorithm.  Looking at the hints now I see:\\n\\nHint 3\\nConsider an element at index i. Say there exists a strictly greater element to its left, and the closest one is located at index j (i.e. there is no index k such that j < k < i and nums[k] > nums[i]). The number of rounds required to remove nums[i] is i - j.\\n\\nHow does that work?  If we have an array [6,5,4,3,2,1,5] -- shouldn\\'t it take 2 rounds to remove the 5, not i-j=6 rounds?\\n\\n"
                    },
                    {
                        "username": "Taranovski",
                        "content": "leetcode, forget about \"medium\" rating for anything monolithic stack, it is extremely non-intuitive and \"jumping through the hoops\", set the realistic \"hard\" rating for it!\\nExtremely confusing \"pattern\" of the solution, be real!"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "great question but should be hard"
                    },
                    {
                        "username": "XeBaGac",
                        "content": "Time Limit Exceeded with TC 79, i don\\'t know how to make my code quicker :((("
                    },
                    {
                        "username": "Flankerr",
                        "content": "can someone please explain how this array is completed in 1 step.\\n\\naccording to my calculation\\noriginal [10,6,5,10,15]\\n1st step [10,5,10,15]\\n2nd step [10,10,15]"
                    },
                    {
                        "username": "XeBaGac",
                        "content": "in step1 u erase both 6 and 5 because  6>5 . Therefore, the result is 10,10,15\\n"
                    },
                    {
                        "username": "prashantkumarrai8",
                        "content": "1st we remove 5 bcz of 6 and then 6 bcz of 10"
                    },
                    {
                        "username": "shhattali2002",
                        "content": "[@Gyaneswar Singh](/Flankerr) don't delete the integer directly first check out the index elements that satisfy given condition ( nums[i]<nums[i-1] ) than go for deletion.\neg. original [10,6,5,10,15]\nHere index 1,2 satisfy the condition than delete them it will take 1 step.\n\neg. Original [5,3,4,4,7,3,6,11,8,5,11]\nHere index 1,5,8,9 satisfy hence step 1.\n[5,4,4,7,6,11,11]\nIn step 2 index 1,4 satisfy condition\n[5,4,4,7,11,11]\nIn step 3 index 1 satisfy condition\n[5,7,11,11]\n"
                    },
                    {
                        "username": "aaks-ctrl",
                        "content": "Can someone tell me where an I going wrong with my approach ?\\n \\n `\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        stack<int> c;\\n        int ans{};\\n        int steps{};\\n        while(nums.size()){\\n            int last=nums.back();\\n            nums.pop_back();\\n            int i{};\\n            while(c.size() && last>c.top()){\\n                c.pop();\\n                i++;\\n            }\\n            ans=max(i,ans);\\n            c.push(last);\\n        }\\n        return ans;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "2uringTested",
                        "content": "i would\\'ve tried if it was written in a coding language...\\n\\n/s .... try writing a bit readable code."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "For the test case\\n\\n[5,1,2,3,4]\\n\\nJust removing 5 in the start would make it [1,2,3,4] which is a Non Decreasing Array . \\n\\nSo number of steps needed is \\'1\\' . But the solution expected is 4 . Am i missing something ? \\n\\nThanks in Advance."
                    },
                    {
                        "username": "ashishnethi",
                        "content": "We need to remove nums[i] not nums[i-1]"
                    },
                    {
                        "username": "MaverickEyedea",
                        "content": "[@sugreem](/sugreem) Thanks for this answer. I was removing nums[i - 1] and I was so confused. Should have read the question carefully."
                    },
                    {
                        "username": "sugreem",
                        "content": "remove nums[i] such that nums[i] < nums[i-1]"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1862481,
                "content": [
                    {
                        "username": "DolphinsAtDaybreak",
                        "content": "**EDIT: They\\'ve fixed the hints now!**\\n\\nI got to the idea of monotonic stack during the contest but didn\\'t quite figure out the final algorithm.  Looking at the hints now I see:\\n\\nHint 3\\nConsider an element at index i. Say there exists a strictly greater element to its left, and the closest one is located at index j (i.e. there is no index k such that j < k < i and nums[k] > nums[i]). The number of rounds required to remove nums[i] is i - j.\\n\\nHow does that work?  If we have an array [6,5,4,3,2,1,5] -- shouldn\\'t it take 2 rounds to remove the 5, not i-j=6 rounds?\\n\\n"
                    },
                    {
                        "username": "Taranovski",
                        "content": "leetcode, forget about \"medium\" rating for anything monolithic stack, it is extremely non-intuitive and \"jumping through the hoops\", set the realistic \"hard\" rating for it!\\nExtremely confusing \"pattern\" of the solution, be real!"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "great question but should be hard"
                    },
                    {
                        "username": "XeBaGac",
                        "content": "Time Limit Exceeded with TC 79, i don\\'t know how to make my code quicker :((("
                    },
                    {
                        "username": "Flankerr",
                        "content": "can someone please explain how this array is completed in 1 step.\\n\\naccording to my calculation\\noriginal [10,6,5,10,15]\\n1st step [10,5,10,15]\\n2nd step [10,10,15]"
                    },
                    {
                        "username": "XeBaGac",
                        "content": "in step1 u erase both 6 and 5 because  6>5 . Therefore, the result is 10,10,15\\n"
                    },
                    {
                        "username": "prashantkumarrai8",
                        "content": "1st we remove 5 bcz of 6 and then 6 bcz of 10"
                    },
                    {
                        "username": "shhattali2002",
                        "content": "[@Gyaneswar Singh](/Flankerr) don't delete the integer directly first check out the index elements that satisfy given condition ( nums[i]<nums[i-1] ) than go for deletion.\neg. original [10,6,5,10,15]\nHere index 1,2 satisfy the condition than delete them it will take 1 step.\n\neg. Original [5,3,4,4,7,3,6,11,8,5,11]\nHere index 1,5,8,9 satisfy hence step 1.\n[5,4,4,7,6,11,11]\nIn step 2 index 1,4 satisfy condition\n[5,4,4,7,11,11]\nIn step 3 index 1 satisfy condition\n[5,7,11,11]\n"
                    },
                    {
                        "username": "aaks-ctrl",
                        "content": "Can someone tell me where an I going wrong with my approach ?\\n \\n `\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        stack<int> c;\\n        int ans{};\\n        int steps{};\\n        while(nums.size()){\\n            int last=nums.back();\\n            nums.pop_back();\\n            int i{};\\n            while(c.size() && last>c.top()){\\n                c.pop();\\n                i++;\\n            }\\n            ans=max(i,ans);\\n            c.push(last);\\n        }\\n        return ans;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "2uringTested",
                        "content": "i would\\'ve tried if it was written in a coding language...\\n\\n/s .... try writing a bit readable code."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "For the test case\\n\\n[5,1,2,3,4]\\n\\nJust removing 5 in the start would make it [1,2,3,4] which is a Non Decreasing Array . \\n\\nSo number of steps needed is \\'1\\' . But the solution expected is 4 . Am i missing something ? \\n\\nThanks in Advance."
                    },
                    {
                        "username": "ashishnethi",
                        "content": "We need to remove nums[i] not nums[i-1]"
                    },
                    {
                        "username": "MaverickEyedea",
                        "content": "[@sugreem](/sugreem) Thanks for this answer. I was removing nums[i - 1] and I was so confused. Should have read the question carefully."
                    },
                    {
                        "username": "sugreem",
                        "content": "remove nums[i] such that nums[i] < nums[i-1]"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1929815,
                "content": [
                    {
                        "username": "DolphinsAtDaybreak",
                        "content": "**EDIT: They\\'ve fixed the hints now!**\\n\\nI got to the idea of monotonic stack during the contest but didn\\'t quite figure out the final algorithm.  Looking at the hints now I see:\\n\\nHint 3\\nConsider an element at index i. Say there exists a strictly greater element to its left, and the closest one is located at index j (i.e. there is no index k such that j < k < i and nums[k] > nums[i]). The number of rounds required to remove nums[i] is i - j.\\n\\nHow does that work?  If we have an array [6,5,4,3,2,1,5] -- shouldn\\'t it take 2 rounds to remove the 5, not i-j=6 rounds?\\n\\n"
                    },
                    {
                        "username": "Taranovski",
                        "content": "leetcode, forget about \"medium\" rating for anything monolithic stack, it is extremely non-intuitive and \"jumping through the hoops\", set the realistic \"hard\" rating for it!\\nExtremely confusing \"pattern\" of the solution, be real!"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "great question but should be hard"
                    },
                    {
                        "username": "XeBaGac",
                        "content": "Time Limit Exceeded with TC 79, i don\\'t know how to make my code quicker :((("
                    },
                    {
                        "username": "Flankerr",
                        "content": "can someone please explain how this array is completed in 1 step.\\n\\naccording to my calculation\\noriginal [10,6,5,10,15]\\n1st step [10,5,10,15]\\n2nd step [10,10,15]"
                    },
                    {
                        "username": "XeBaGac",
                        "content": "in step1 u erase both 6 and 5 because  6>5 . Therefore, the result is 10,10,15\\n"
                    },
                    {
                        "username": "prashantkumarrai8",
                        "content": "1st we remove 5 bcz of 6 and then 6 bcz of 10"
                    },
                    {
                        "username": "shhattali2002",
                        "content": "[@Gyaneswar Singh](/Flankerr) don't delete the integer directly first check out the index elements that satisfy given condition ( nums[i]<nums[i-1] ) than go for deletion.\neg. original [10,6,5,10,15]\nHere index 1,2 satisfy the condition than delete them it will take 1 step.\n\neg. Original [5,3,4,4,7,3,6,11,8,5,11]\nHere index 1,5,8,9 satisfy hence step 1.\n[5,4,4,7,6,11,11]\nIn step 2 index 1,4 satisfy condition\n[5,4,4,7,11,11]\nIn step 3 index 1 satisfy condition\n[5,7,11,11]\n"
                    },
                    {
                        "username": "aaks-ctrl",
                        "content": "Can someone tell me where an I going wrong with my approach ?\\n \\n `\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        stack<int> c;\\n        int ans{};\\n        int steps{};\\n        while(nums.size()){\\n            int last=nums.back();\\n            nums.pop_back();\\n            int i{};\\n            while(c.size() && last>c.top()){\\n                c.pop();\\n                i++;\\n            }\\n            ans=max(i,ans);\\n            c.push(last);\\n        }\\n        return ans;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "2uringTested",
                        "content": "i would\\'ve tried if it was written in a coding language...\\n\\n/s .... try writing a bit readable code."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "For the test case\\n\\n[5,1,2,3,4]\\n\\nJust removing 5 in the start would make it [1,2,3,4] which is a Non Decreasing Array . \\n\\nSo number of steps needed is \\'1\\' . But the solution expected is 4 . Am i missing something ? \\n\\nThanks in Advance."
                    },
                    {
                        "username": "ashishnethi",
                        "content": "We need to remove nums[i] not nums[i-1]"
                    },
                    {
                        "username": "MaverickEyedea",
                        "content": "[@sugreem](/sugreem) Thanks for this answer. I was removing nums[i - 1] and I was so confused. Should have read the question carefully."
                    },
                    {
                        "username": "sugreem",
                        "content": "remove nums[i] such that nums[i] < nums[i-1]"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1693111,
                "content": [
                    {
                        "username": "DolphinsAtDaybreak",
                        "content": "**EDIT: They\\'ve fixed the hints now!**\\n\\nI got to the idea of monotonic stack during the contest but didn\\'t quite figure out the final algorithm.  Looking at the hints now I see:\\n\\nHint 3\\nConsider an element at index i. Say there exists a strictly greater element to its left, and the closest one is located at index j (i.e. there is no index k such that j < k < i and nums[k] > nums[i]). The number of rounds required to remove nums[i] is i - j.\\n\\nHow does that work?  If we have an array [6,5,4,3,2,1,5] -- shouldn\\'t it take 2 rounds to remove the 5, not i-j=6 rounds?\\n\\n"
                    },
                    {
                        "username": "Taranovski",
                        "content": "leetcode, forget about \"medium\" rating for anything monolithic stack, it is extremely non-intuitive and \"jumping through the hoops\", set the realistic \"hard\" rating for it!\\nExtremely confusing \"pattern\" of the solution, be real!"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "great question but should be hard"
                    },
                    {
                        "username": "XeBaGac",
                        "content": "Time Limit Exceeded with TC 79, i don\\'t know how to make my code quicker :((("
                    },
                    {
                        "username": "Flankerr",
                        "content": "can someone please explain how this array is completed in 1 step.\\n\\naccording to my calculation\\noriginal [10,6,5,10,15]\\n1st step [10,5,10,15]\\n2nd step [10,10,15]"
                    },
                    {
                        "username": "XeBaGac",
                        "content": "in step1 u erase both 6 and 5 because  6>5 . Therefore, the result is 10,10,15\\n"
                    },
                    {
                        "username": "prashantkumarrai8",
                        "content": "1st we remove 5 bcz of 6 and then 6 bcz of 10"
                    },
                    {
                        "username": "shhattali2002",
                        "content": "[@Gyaneswar Singh](/Flankerr) don't delete the integer directly first check out the index elements that satisfy given condition ( nums[i]<nums[i-1] ) than go for deletion.\neg. original [10,6,5,10,15]\nHere index 1,2 satisfy the condition than delete them it will take 1 step.\n\neg. Original [5,3,4,4,7,3,6,11,8,5,11]\nHere index 1,5,8,9 satisfy hence step 1.\n[5,4,4,7,6,11,11]\nIn step 2 index 1,4 satisfy condition\n[5,4,4,7,11,11]\nIn step 3 index 1 satisfy condition\n[5,7,11,11]\n"
                    },
                    {
                        "username": "aaks-ctrl",
                        "content": "Can someone tell me where an I going wrong with my approach ?\\n \\n `\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        stack<int> c;\\n        int ans{};\\n        int steps{};\\n        while(nums.size()){\\n            int last=nums.back();\\n            nums.pop_back();\\n            int i{};\\n            while(c.size() && last>c.top()){\\n                c.pop();\\n                i++;\\n            }\\n            ans=max(i,ans);\\n            c.push(last);\\n        }\\n        return ans;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "2uringTested",
                        "content": "i would\\'ve tried if it was written in a coding language...\\n\\n/s .... try writing a bit readable code."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "For the test case\\n\\n[5,1,2,3,4]\\n\\nJust removing 5 in the start would make it [1,2,3,4] which is a Non Decreasing Array . \\n\\nSo number of steps needed is \\'1\\' . But the solution expected is 4 . Am i missing something ? \\n\\nThanks in Advance."
                    },
                    {
                        "username": "ashishnethi",
                        "content": "We need to remove nums[i] not nums[i-1]"
                    },
                    {
                        "username": "MaverickEyedea",
                        "content": "[@sugreem](/sugreem) Thanks for this answer. I was removing nums[i - 1] and I was so confused. Should have read the question carefully."
                    },
                    {
                        "username": "sugreem",
                        "content": "remove nums[i] such that nums[i] < nums[i-1]"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1713368,
                "content": [
                    {
                        "username": "DolphinsAtDaybreak",
                        "content": "**EDIT: They\\'ve fixed the hints now!**\\n\\nI got to the idea of monotonic stack during the contest but didn\\'t quite figure out the final algorithm.  Looking at the hints now I see:\\n\\nHint 3\\nConsider an element at index i. Say there exists a strictly greater element to its left, and the closest one is located at index j (i.e. there is no index k such that j < k < i and nums[k] > nums[i]). The number of rounds required to remove nums[i] is i - j.\\n\\nHow does that work?  If we have an array [6,5,4,3,2,1,5] -- shouldn\\'t it take 2 rounds to remove the 5, not i-j=6 rounds?\\n\\n"
                    },
                    {
                        "username": "Taranovski",
                        "content": "leetcode, forget about \"medium\" rating for anything monolithic stack, it is extremely non-intuitive and \"jumping through the hoops\", set the realistic \"hard\" rating for it!\\nExtremely confusing \"pattern\" of the solution, be real!"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "great question but should be hard"
                    },
                    {
                        "username": "XeBaGac",
                        "content": "Time Limit Exceeded with TC 79, i don\\'t know how to make my code quicker :((("
                    },
                    {
                        "username": "Flankerr",
                        "content": "can someone please explain how this array is completed in 1 step.\\n\\naccording to my calculation\\noriginal [10,6,5,10,15]\\n1st step [10,5,10,15]\\n2nd step [10,10,15]"
                    },
                    {
                        "username": "XeBaGac",
                        "content": "in step1 u erase both 6 and 5 because  6>5 . Therefore, the result is 10,10,15\\n"
                    },
                    {
                        "username": "prashantkumarrai8",
                        "content": "1st we remove 5 bcz of 6 and then 6 bcz of 10"
                    },
                    {
                        "username": "shhattali2002",
                        "content": "[@Gyaneswar Singh](/Flankerr) don't delete the integer directly first check out the index elements that satisfy given condition ( nums[i]<nums[i-1] ) than go for deletion.\neg. original [10,6,5,10,15]\nHere index 1,2 satisfy the condition than delete them it will take 1 step.\n\neg. Original [5,3,4,4,7,3,6,11,8,5,11]\nHere index 1,5,8,9 satisfy hence step 1.\n[5,4,4,7,6,11,11]\nIn step 2 index 1,4 satisfy condition\n[5,4,4,7,11,11]\nIn step 3 index 1 satisfy condition\n[5,7,11,11]\n"
                    },
                    {
                        "username": "aaks-ctrl",
                        "content": "Can someone tell me where an I going wrong with my approach ?\\n \\n `\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        stack<int> c;\\n        int ans{};\\n        int steps{};\\n        while(nums.size()){\\n            int last=nums.back();\\n            nums.pop_back();\\n            int i{};\\n            while(c.size() && last>c.top()){\\n                c.pop();\\n                i++;\\n            }\\n            ans=max(i,ans);\\n            c.push(last);\\n        }\\n        return ans;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "2uringTested",
                        "content": "i would\\'ve tried if it was written in a coding language...\\n\\n/s .... try writing a bit readable code."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "For the test case\\n\\n[5,1,2,3,4]\\n\\nJust removing 5 in the start would make it [1,2,3,4] which is a Non Decreasing Array . \\n\\nSo number of steps needed is \\'1\\' . But the solution expected is 4 . Am i missing something ? \\n\\nThanks in Advance."
                    },
                    {
                        "username": "ashishnethi",
                        "content": "We need to remove nums[i] not nums[i-1]"
                    },
                    {
                        "username": "MaverickEyedea",
                        "content": "[@sugreem](/sugreem) Thanks for this answer. I was removing nums[i - 1] and I was so confused. Should have read the question carefully."
                    },
                    {
                        "username": "sugreem",
                        "content": "remove nums[i] such that nums[i] < nums[i-1]"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1576960,
                "content": [
                    {
                        "username": "DolphinsAtDaybreak",
                        "content": "**EDIT: They\\'ve fixed the hints now!**\\n\\nI got to the idea of monotonic stack during the contest but didn\\'t quite figure out the final algorithm.  Looking at the hints now I see:\\n\\nHint 3\\nConsider an element at index i. Say there exists a strictly greater element to its left, and the closest one is located at index j (i.e. there is no index k such that j < k < i and nums[k] > nums[i]). The number of rounds required to remove nums[i] is i - j.\\n\\nHow does that work?  If we have an array [6,5,4,3,2,1,5] -- shouldn\\'t it take 2 rounds to remove the 5, not i-j=6 rounds?\\n\\n"
                    },
                    {
                        "username": "Taranovski",
                        "content": "leetcode, forget about \"medium\" rating for anything monolithic stack, it is extremely non-intuitive and \"jumping through the hoops\", set the realistic \"hard\" rating for it!\\nExtremely confusing \"pattern\" of the solution, be real!"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "great question but should be hard"
                    },
                    {
                        "username": "XeBaGac",
                        "content": "Time Limit Exceeded with TC 79, i don\\'t know how to make my code quicker :((("
                    },
                    {
                        "username": "Flankerr",
                        "content": "can someone please explain how this array is completed in 1 step.\\n\\naccording to my calculation\\noriginal [10,6,5,10,15]\\n1st step [10,5,10,15]\\n2nd step [10,10,15]"
                    },
                    {
                        "username": "XeBaGac",
                        "content": "in step1 u erase both 6 and 5 because  6>5 . Therefore, the result is 10,10,15\\n"
                    },
                    {
                        "username": "prashantkumarrai8",
                        "content": "1st we remove 5 bcz of 6 and then 6 bcz of 10"
                    },
                    {
                        "username": "shhattali2002",
                        "content": "[@Gyaneswar Singh](/Flankerr) don't delete the integer directly first check out the index elements that satisfy given condition ( nums[i]<nums[i-1] ) than go for deletion.\neg. original [10,6,5,10,15]\nHere index 1,2 satisfy the condition than delete them it will take 1 step.\n\neg. Original [5,3,4,4,7,3,6,11,8,5,11]\nHere index 1,5,8,9 satisfy hence step 1.\n[5,4,4,7,6,11,11]\nIn step 2 index 1,4 satisfy condition\n[5,4,4,7,11,11]\nIn step 3 index 1 satisfy condition\n[5,7,11,11]\n"
                    },
                    {
                        "username": "aaks-ctrl",
                        "content": "Can someone tell me where an I going wrong with my approach ?\\n \\n `\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        stack<int> c;\\n        int ans{};\\n        int steps{};\\n        while(nums.size()){\\n            int last=nums.back();\\n            nums.pop_back();\\n            int i{};\\n            while(c.size() && last>c.top()){\\n                c.pop();\\n                i++;\\n            }\\n            ans=max(i,ans);\\n            c.push(last);\\n        }\\n        return ans;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "2uringTested",
                        "content": "i would\\'ve tried if it was written in a coding language...\\n\\n/s .... try writing a bit readable code."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "For the test case\\n\\n[5,1,2,3,4]\\n\\nJust removing 5 in the start would make it [1,2,3,4] which is a Non Decreasing Array . \\n\\nSo number of steps needed is \\'1\\' . But the solution expected is 4 . Am i missing something ? \\n\\nThanks in Advance."
                    },
                    {
                        "username": "ashishnethi",
                        "content": "We need to remove nums[i] not nums[i-1]"
                    },
                    {
                        "username": "MaverickEyedea",
                        "content": "[@sugreem](/sugreem) Thanks for this answer. I was removing nums[i - 1] and I was so confused. Should have read the question carefully."
                    },
                    {
                        "username": "sugreem",
                        "content": "remove nums[i] such that nums[i] < nums[i-1]"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1763841,
                "content": [
                    {
                        "username": "DolphinsAtDaybreak",
                        "content": "**EDIT: They\\'ve fixed the hints now!**\\n\\nI got to the idea of monotonic stack during the contest but didn\\'t quite figure out the final algorithm.  Looking at the hints now I see:\\n\\nHint 3\\nConsider an element at index i. Say there exists a strictly greater element to its left, and the closest one is located at index j (i.e. there is no index k such that j < k < i and nums[k] > nums[i]). The number of rounds required to remove nums[i] is i - j.\\n\\nHow does that work?  If we have an array [6,5,4,3,2,1,5] -- shouldn\\'t it take 2 rounds to remove the 5, not i-j=6 rounds?\\n\\n"
                    },
                    {
                        "username": "Taranovski",
                        "content": "leetcode, forget about \"medium\" rating for anything monolithic stack, it is extremely non-intuitive and \"jumping through the hoops\", set the realistic \"hard\" rating for it!\\nExtremely confusing \"pattern\" of the solution, be real!"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "great question but should be hard"
                    },
                    {
                        "username": "XeBaGac",
                        "content": "Time Limit Exceeded with TC 79, i don\\'t know how to make my code quicker :((("
                    },
                    {
                        "username": "Flankerr",
                        "content": "can someone please explain how this array is completed in 1 step.\\n\\naccording to my calculation\\noriginal [10,6,5,10,15]\\n1st step [10,5,10,15]\\n2nd step [10,10,15]"
                    },
                    {
                        "username": "XeBaGac",
                        "content": "in step1 u erase both 6 and 5 because  6>5 . Therefore, the result is 10,10,15\\n"
                    },
                    {
                        "username": "prashantkumarrai8",
                        "content": "1st we remove 5 bcz of 6 and then 6 bcz of 10"
                    },
                    {
                        "username": "shhattali2002",
                        "content": "[@Gyaneswar Singh](/Flankerr) don't delete the integer directly first check out the index elements that satisfy given condition ( nums[i]<nums[i-1] ) than go for deletion.\neg. original [10,6,5,10,15]\nHere index 1,2 satisfy the condition than delete them it will take 1 step.\n\neg. Original [5,3,4,4,7,3,6,11,8,5,11]\nHere index 1,5,8,9 satisfy hence step 1.\n[5,4,4,7,6,11,11]\nIn step 2 index 1,4 satisfy condition\n[5,4,4,7,11,11]\nIn step 3 index 1 satisfy condition\n[5,7,11,11]\n"
                    },
                    {
                        "username": "aaks-ctrl",
                        "content": "Can someone tell me where an I going wrong with my approach ?\\n \\n `\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        stack<int> c;\\n        int ans{};\\n        int steps{};\\n        while(nums.size()){\\n            int last=nums.back();\\n            nums.pop_back();\\n            int i{};\\n            while(c.size() && last>c.top()){\\n                c.pop();\\n                i++;\\n            }\\n            ans=max(i,ans);\\n            c.push(last);\\n        }\\n        return ans;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "2uringTested",
                        "content": "i would\\'ve tried if it was written in a coding language...\\n\\n/s .... try writing a bit readable code."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "For the test case\\n\\n[5,1,2,3,4]\\n\\nJust removing 5 in the start would make it [1,2,3,4] which is a Non Decreasing Array . \\n\\nSo number of steps needed is \\'1\\' . But the solution expected is 4 . Am i missing something ? \\n\\nThanks in Advance."
                    },
                    {
                        "username": "ashishnethi",
                        "content": "We need to remove nums[i] not nums[i-1]"
                    },
                    {
                        "username": "MaverickEyedea",
                        "content": "[@sugreem](/sugreem) Thanks for this answer. I was removing nums[i - 1] and I was so confused. Should have read the question carefully."
                    },
                    {
                        "username": "sugreem",
                        "content": "remove nums[i] such that nums[i] < nums[i-1]"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            }
        ]
    }
]