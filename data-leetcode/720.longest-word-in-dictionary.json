[
    {
        "title": "H-Index",
        "question_content": "Given an array of integers citations where citations[i] is the number of citations a researcher received for their ith paper, return the researcher's h-index.\nAccording to the definition of h-index on Wikipedia: The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times.\n&nbsp;\nExample 1:\n\nInput: citations = [3,0,6,1,5]\nOutput: 3\nExplanation: [3,0,6,1,5] means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively.\nSince the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3.\n\nExample 2:\n\nInput: citations = [1,3,1]\nOutput: 1\n\n&nbsp;\nConstraints:\n\n\tn == citations.length\n\t1 <= n <= 5000\n\t0 <= citations[i] <= 1000",
        "solutions": [
            {
                "id": 70768,
                "title": "java-bucket-sort-o-n-solution-with-detail-explanation",
                "content": "This type of problems always throw me off, but it just takes some getting used to.  The idea behind it is some bucket sort mechanisms.  First, you may ask why bucket sort.  Well, the h-index is defined as the number of papers with reference greater than the number.  So assume `n` is the total number of papers, if we have `n+1` buckets, number from 0 to n, then for any paper with reference corresponding to the index of the bucket, we increment the count for that bucket.  The only exception is that for any paper with larger number of reference than `n`, we put in the `n`-th bucket.  \\n\\nThen we iterate from the back to the front of the buckets, whenever the total count exceeds the index of the bucket, meaning that we have the index number of papers that have reference greater than or equal to the index.  Which will be our h-index result.  The reason to scan from the end of the array is that we are looking for the greatest h-index.  For example, given array `[3,0,6,5,1]`, we have 6 buckets to contain how many papers have the corresponding index.  Hope to image and explanation help.\\n\\n\\n![Buckets][1]\\n\\n\\n\\n\\n    public int hIndex(int[] citations) {\\n        int n = citations.length;\\n        int[] buckets = new int[n+1];\\n        for(int c : citations) {\\n            if(c >= n) {\\n                buckets[n]++;\\n            } else {\\n                buckets[c]++;\\n            }\\n        }\\n        int count = 0;\\n        for(int i = n; i >= 0; i--) {\\n            count += buckets[i];\\n            if(count >= i) {\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n\\n\\n  [1]: http://i67.tinypic.com/2yvpfv5.jpg",
                "solutionTags": [
                    "Java"
                ],
                "code": "This type of problems always throw me off, but it just takes some getting used to.  The idea behind it is some bucket sort mechanisms.  First, you may ask why bucket sort.  Well, the h-index is defined as the number of papers with reference greater than the number.  So assume `n` is the total number of papers, if we have `n+1` buckets, number from 0 to n, then for any paper with reference corresponding to the index of the bucket, we increment the count for that bucket.  The only exception is that for any paper with larger number of reference than `n`, we put in the `n`-th bucket.  \\n\\nThen we iterate from the back to the front of the buckets, whenever the total count exceeds the index of the bucket, meaning that we have the index number of papers that have reference greater than or equal to the index.  Which will be our h-index result.  The reason to scan from the end of the array is that we are looking for the greatest h-index.  For example, given array `[3,0,6,5,1]`, we have 6 buckets to contain how many papers have the corresponding index.  Hope to image and explanation help.\\n\\n\\n![Buckets][1]\\n\\n\\n\\n\\n    public int hIndex(int[] citations) {\\n        int n = citations.length;\\n        int[] buckets = new int[n+1];\\n        for(int c : citations) {\\n            if(c >= n) {\\n                buckets[n]++;\\n            } else {\\n                buckets[c]++;\\n            }\\n        }\\n        int count = 0;\\n        for(int i = n; i >= 0; i--) {\\n            count += buckets[i];\\n            if(count >= i) {\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n\\n\\n  [1]: http://i67.tinypic.com/2yvpfv5.jpg",
                "codeTag": "Unknown"
            },
            {
                "id": 70810,
                "title": "a-clean-o-n-solution-in-java",
                "content": "    public int hIndex(int[] citations) {\\n        int len = citations.length;\\n        int[] count = new int[len + 1];\\n        \\n        for (int c: citations)\\n            if (c > len) \\n                count[len]++;\\n            else \\n                count[c]++;\\n        \\n        \\n        int total = 0;\\n        for (int i = len; i >= 0; i--) {\\n            total += count[i];\\n            if (total >= i)\\n                return i;\\n        }\\n        \\n        return 0;\\n    }",
                "solutionTags": [],
                "code": "    public int hIndex(int[] citations) {\\n        int len = citations.length;\\n        int[] count = new int[len + 1];\\n        \\n        for (int c: citations)\\n            if (c > len) \\n                count[len]++;\\n            else \\n                count[c]++;\\n        \\n        \\n        int total = 0;\\n        for (int i = len; i >= 0; i--) {\\n            total += count[i];\\n            if (total >= i)\\n                return i;\\n        }\\n        \\n        return 0;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 71055,
                "title": "1-line-python-solution",
                "content": "It's straightforward:\\n\\n        return sum(i < j for i, j in enumerate(sorted(citations, reverse=True)))",
                "solutionTags": [
                    "Python"
                ],
                "code": "It's straightforward:\\n\\n        return sum(i < j for i, j in enumerate(sorted(citations, reverse=True)))",
                "codeTag": "Unknown"
            },
            {
                "id": 70818,
                "title": "java-o-n-time-with-easy-explanation",
                "content": "The idea is to see that the result can only range from 0 to the length of the array (because we can't have h-index greater than the total papers published). So we create an array \"arr\" which acts like a HashMap (using pigeon hole principle) and loop backwards from the highest element, then we find \"tot\" which is the total number of papers that has more than i citations, and we stop when tot>=i (total number of papers with more than i citations >= i). We don't need to keep going because we are trying the biggest i possible, we we stop and return the result.\\n\\n    public class Solution {\\n    public int hIndex(int[] citations) {\\n        int n = citations.length, tot=0;\\n        int[] arr = new int[n+1];\\n        for (int i=0; i<n; i++) {\\n            if (citations[i]>=n) arr[n]++;\\n            else arr[citations[i]]++;\\n        }\\n        for (int i=n; i>=0; i--) {\\n            tot += arr[i];\\n            if (tot>=i) return i;\\n        }\\n        return 0;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int hIndex(int[] citations) {\\n        int n = citations.length, tot=0;\\n        int[] arr = new int[n+1];\\n        for (int i=0; i<n; i++) {\\n            if (citations[i]>=n) arr[n]++;\\n            else arr[citations[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 785570,
                "title": "java-100-no-sort-o-n-explanation",
                "content": "**If useful, please up-vote.**\\nThe citations[ ] array contains the number of citations for each paper.  The number of papers publish is citations.length.\\n\\nThis is actually a \"counting sort\", which simply counts the number of papers with x citations.  Some discussion entries call this a \"bucket sort\", but technically a counting sort is different in that a bucket sort saves all of the original data.  A counting sort throws out the original data, and only saves aggregate information.  Counting sorts are O(N).  I don\\'t really consider counting sorts to be real sorts, because the original data is lost.  I consider it more of a data analysis.\\n\\nThe h-index value cannot be higher than the total number of papers, so we only need the count sort to hold values from 0 to the number of papers (citations.length).  Papers with more citations than the number of papers, will be counted as though they had number-of-papers citations.\\n```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        // Array to the contain the counts for number of papers \\n        // with x citations, where counts[x] will be the number of \\n        // papers with x citations.  Because the h value cannot be \\n        // larger than the number of papers, the last used count in \\n        // this array, count[citations.length], is a count of the \\n        // number of papers with citations.length or more citations.\\n        int[] counts = new int[citations.length + 2];\\n        \\n        // Build the counts of how many papers have x citations.  \\n        // If a paper has more than citations.length citations, then \\n        // count it as citations.length citations.\\n        for (int i = citations.length - 1; i >= 0; i--)  \\n            counts[Math.min(citations[i], citations.length)]++;\\n        \\n        // Go through the count[] array from last index down to 0, trying \\n        // successively smaller values for h.  Looping from high to low \\n        // possible values for h, will find the highest valid value for \\n        // h.  While descending through the count array, add the count \\n        // from the next higher index in the count array, which will \\n        // convert the current counts[h] value to become a count of \\n        // papers with h or more citations.  This is slightly confusing \\n        // because h is used as both an index and a value to compare to \\n        // the array value at that index.  The \"units\" for h feel \\n        // inconsistent.\\n        int h;\\n        for (h = citations.length; h > 0; h--) {\\n            counts[h] += counts[h + 1];\\n            if (counts[h] >= h)  break;\\n        }\\n        return h;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        // Array to the contain the counts for number of papers \\n        // with x citations, where counts[x] will be the number of \\n        // papers with x citations.  Because the h value cannot be \\n        // larger than the number of papers, the last used count in \\n        // this array, count[citations.length], is a count of the \\n        // number of papers with citations.length or more citations.\\n        int[] counts = new int[citations.length + 2];\\n        \\n        // Build the counts of how many papers have x citations.  \\n        // If a paper has more than citations.length citations, then \\n        // count it as citations.length citations.\\n        for (int i = citations.length - 1; i >= 0; i--)  \\n            counts[Math.min(citations[i], citations.length)]++;\\n        \\n        // Go through the count[] array from last index down to 0, trying \\n        // successively smaller values for h.  Looping from high to low \\n        // possible values for h, will find the highest valid value for \\n        // h.  While descending through the count array, add the count \\n        // from the next higher index in the count array, which will \\n        // convert the current counts[h] value to become a count of \\n        // papers with h or more citations.  This is slightly confusing \\n        // because h is used as both an index and a value to compare to \\n        // the array value at that index.  The \"units\" for h feel \\n        // inconsistent.\\n        int h;\\n        for (h = citations.length; h > 0; h--) {\\n            counts[h] += counts[h + 1];\\n            if (counts[h] >= h)  break;\\n        }\\n        return h;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 70918,
                "title": "my-easy-solution",
                "content": "     public int hIndex(int[] citations) {\\n       Arrays.sort(citations);\\n       int len=citations.length;\\n        for(int i=0;i<len;i++){\\n            if(citations[i]>=len-i) return len-i;\\n            \\n        }\\n        return 0;\\n    }",
                "solutionTags": [],
                "code": "     public int hIndex(int[] citations) {\\n       Arrays.sort(citations);\\n       int len=citations.length;\\n        for(int i=0;i<len;i++){\\n            if(citations[i]>=len-i) return len-i;\\n            \\n        }\\n        return 0;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 70894,
                "title": "o-n-time-c-solution-using-hash-table",
                "content": "class Solution {\\npublic:\\n\\n    int hIndex(vector<int>& citations) {\\n        if(citations.empty())\\n            return 0;\\n        int n = citations.size();\\n        vector<int> hash(n + 1, 0);\\n        for(int i = 0; i < n; ++i){\\n            if(citations[i] >= n)\\n                hash[n]++;\\n            else\\n                hash[citations[i]]++;\\n        }\\n        int paper = 0;\\n        for(int i = n; i >= 0; --i){\\n            paper += hash[i];\\n            if(paper >= i)\\n                return i;\\n        }\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    int hIndex(vector<int>& citations) {\\n        if(citations.empty())\\n            return 0;\\n        int n = citations.size();\\n        vector<int> hash(n + 1, 0);\\n        for(int i = 0; i < n; ++i){\\n            if(citations[i] >= n)\\n                hash[n]++;\\n            else\\n                hash[citations[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 70897,
                "title": "python-o-n-lgn-time-with-sort-o-n-time-with-o-n-space",
                "content": "Sort\\n\\n    def hIndex(self, citations):\\n        citations.sort()\\n        n = len(citations)\\n        for i in xrange(n):\\n            if citations[i] >= (n-i):\\n                return n-i\\n        return 0\\n\\n\\nO(n) space, O(n) time\\n\\n    def hIndex(self, citations):\\n        n = len(citations)\\n        citeCount = [0] * (n+1)\\n        for c in citations:\\n            if c >= n:\\n                citeCount[n] += 1\\n            else:\\n                citeCount[c] += 1\\n        \\n        i = n-1\\n        while i >= 0:\\n            citeCount[i] += citeCount[i+1]\\n            if citeCount[i+1] >= i+1:\\n                return i+1\\n            i -= 1\\n        return 0",
                "solutionTags": [],
                "code": "Sort\\n\\n    def hIndex(self, citations):\\n        citations.sort()\\n        n = len(citations)\\n        for i in xrange(n):\\n            if citations[i] >= (n-i):\\n                return n-i\\n        return 0\\n\\n\\nO(n) space, O(n) time\\n\\n    def hIndex(self, citations):\\n        n = len(citations)\\n        citeCount = [0] * (n+1)\\n        for c in citations:\\n            if c >= n:\\n                citeCount[n] += 1\\n            else:\\n                citeCount[c] += 1\\n        \\n        i = n-1\\n        while i >= 0:\\n            citeCount[i] += citeCount[i+1]\\n            if citeCount[i+1] >= i+1:\\n                return i+1\\n            i -= 1\\n        return 0",
                "codeTag": "Python3"
            },
            {
                "id": 785444,
                "title": "c-clean-and-simple-binary-search-based-solution-explained-92-time-80-space",
                "content": "So, in order to meet the requirement of this problem, we need to find a way to meet the `N - h` condition described in the specs, and for the maximum possible value.\\n\\nWell, that seems to me like a good use case of binary search and, since the problem boils down to this, I would not even bother to use the built-in C++ functions for that (`lower_bound` or, rather. `upper_bound`, but it really depends on how you play with them here).\\n\\nAlso, it is rather likely that in an interview you will be asked to avoid them and write your own logic, so I see no reason not to practice it here, not to mention that with the built in solutions you would have needed another vector to also store the respective index of each element (not sure you can otherwise access them, but correct me if I am wrong).\\n\\nFirst of all I will need 3 support variables to store the coordinates of my current start (`s`), end (`e`) and average (`avg`), respectively, and (have to) sort my array for the BS (I mean Binary Search!) to work.\\n\\nThen I will move on with it as long as my current start is `<=` current my end; if the condition is met (`c[avg = (e + s) / 2] < c.size() - avg`), then we move right (ie: towards higher values, since we sorted) updating `s`, otherwise we move left, updating `e` (ie: to lower values).\\n\\nOnce we have found our ideal value, we returrn `c.size - s` and we are done :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& c) {\\n        // 3 support variables for us\\n        int s = 0, e = c.size() - 1, avg;\\n        // the base of every happy binary search ever: having a sorted dataset\\n        sort(begin(c), end(c));\\n        // some good old binary search here to find the maximum element meeting the conditions\\n        while (s <= e) {\\n            if (c[avg = (e + s) / 2] < c.size() - avg) s = avg + 1;\\n            else e = avg - 1;\\n        }\\n        return c.size() - s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& c) {\\n        // 3 support variables for us\\n        int s = 0, e = c.size() - 1, avg;\\n        // the base of every happy binary search ever: having a sorted dataset\\n        sort(begin(c), end(c));\\n        // some good old binary search here to find the maximum element meeting the conditions\\n        while (s <= e) {\\n            if (c[avg = (e + s) / 2] < c.size() - avg) s = avg + 1;\\n            else e = avg - 1;\\n        }\\n        return c.size() - s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 656820,
                "title": "python-short-o-n-time-space-explained",
                "content": "### Explanations\\nThe main trick is to count for each possible number of citations, how many times we see this number in our `citations`. Note, that if number of citations is more than total number of papers `N`, we can reduce this numer to `N` and nothing will change. Let me explain my solutoin given test example `[3,0,6,1,5]`.\\n1. We create array, which I called `buckets = [1, 1, 0, 1, 0, 2]`, where `buckets[i]` is number of papers with `i` citations if `i < N` and `bucket[N]` is number of papers with `>=N` citations.\\n2. Now, we create `accum` array, where `accum[0]` is number of papers with `>=1` citation, `accum[1]` is number of papers with `>=2` citations and so on. When we evaluate it for our example we can see, that it is equal to `accum = [4,3,3,2,2]`. Note, that we start with 1 citation, not with zero, that is why we need to use `accum[1:]` in our code.\\n3. Finally, we need to go through this array and find the bigest number `i`, for which `accum[i] >= i + 1` and return `i + 1`, in our example it is equal to `3`.\\n\\n### Complexity\\nComplexity is O(n), though we traverse our data 4 times, and it is not the optimal solution. We can evaluate cumulative sums in place, and compare them in place with `i + 1` and keep the index of maximum reached so far, and interrupt when inequality `accum[i] >= i + 1` does not hold anymore. Howerer I like cumulative sums and code is more clean in my way.\\n\\n### Code\\n\\n```\\nclass Solution:\\n    def hIndex(self, citations):\\n        N = len(citations)\\n        buckets = [0] * (N + 1)\\n        \\n        for elem in citations:\\n            buckets[min(elem, N)] += 1\\n        \\n        accum = list(accumulate(buckets[1:][::-1]))[::-1]  \\n        compar = [accum[i] >= i + 1 for i in range(N)]  \\n        return (compar + [0]).index(0)      \\n```\\n\\nIf you have any questoins, feel free to ask. If you like the solution and explanation, please **upvote**!",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def hIndex(self, citations):\\n        N = len(citations)\\n        buckets = [0] * (N + 1)\\n        \\n        for elem in citations:\\n            buckets[min(elem, N)] += 1\\n        \\n        accum = list(accumulate(buckets[1:][::-1]))[::-1]  \\n        compar = [accum[i] >= i + 1 for i in range(N)]  \\n        return (compar + [0]).index(0)      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 70808,
                "title": "simple-java-solution-with-sort",
                "content": "    public class Solution {\\n        public int hIndex(int[] citations) {\\n            if (citations == null || citations.length == 0) return 0;\\n            Arrays.sort(citations);\\n            int len = citations.length;\\n            for (int i = 0; i < citations.length; i++) {\\n                if (len <= citations[i])\\n                    return len;\\n                else\\n                    len--;\\n            }\\n            return len;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int hIndex(int[] citations) {\\n            if (citations == null || citations.length == 0) return 0;\\n            Arrays.sort(citations);\\n            int len = citations.length;\\n            for (int i = 0; i < citations.length; i++) {\\n                if (len <= citations[i])\\n                    return len;\\n                else\\n                    len--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 786227,
                "title": "h-index-all-you-need-is-an-explanation",
                "content": "I found the definition of *h*-index really confusing. Luckily, I looked up the [Wikipedia page of *h*-index](http://https://en.wikipedia.org/wiki/H-index) which makes its calculation crystal clear.\\nIt states that,\\n>First we order the values of f from the largest to the lowest value. Then, we look for the last position in which f is greater than or equal to the position (we call h this position). For example, if we have a researcher with 5 publications A, B, C, D, and E with 10, 8, 5, 4, and 3 citations, respectively, the h-index is equal to 4 because the 4th publication has 4 citations and the 5th has only 3. In contrast, if the same publications have 25, 8, 5, 3, and 3 citations, then the index is 3 (i.e. the 3rd position) because the fourth paper has only 3 citations.\\n>\\n>    ```\\n>    f(A)=10, f(B)=8, f(C)=5, f(D)=4, f(E)=3\\u3000\\u2192 h-index=4\\n>    f(A)=25, f(B)=8, f(C)=5, f(D)=3, f(E)=3\\u3000\\u2192 h-index=3\\n\\nCode:\\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        int ans = 0;\\n        sort(citations.begin(), citations.end(), greater<int>());\\n        for (int i = 1; i <= citations.size(); i++) {\\n            if (citations[i-1] < i) break;\\n            ans = i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n>    f(A)=10, f(B)=8, f(C)=5, f(D)=4, f(E)=3\\u3000\\u2192 h-index=4\\n>    f(A)=25, f(B)=8, f(C)=5, f(D)=3, f(E)=3\\u3000\\u2192 h-index=3\\n\\nCode:\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 71008,
                "title": "o-n-java-solution-using-o-n-space",
                "content": "Explanation: The idea is to use another array, index is the citation and value is the number of papers that has at least the citation. Since the h-index can only be n, the new array will only need the index to be at most n, thus the array size will only need n+1. Papers that have more than n citations will store in array[n].\\nGo through the array based on h index definition: array[i]>=i, find the max value of i.\\n\\n\\n    public class Solution {\\n    public int hIndex(int[] citations) {\\n        if(citations == null || citations.length == 0) return 0;\\n        \\n        int n = citations.length;\\n        int[] num = new int[n+1];\\n        \\n        for(int i=0; i<n; i++) {\\n            if(citations[i]>n) num[n]++;\\n            else num[citations[i]]++;\\n        }\\n        \\n        if(num[n]>=n) return n;\\n        for(int i=n-1; i>=0; i--) {\\n            num[i] += num[i+1];\\n            if(num[i]>=i) return i;\\n        }\\n        return 0;\\n    }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int hIndex(int[] citations) {\\n        if(citations == null || citations.length == 0) return 0;\\n        \\n        int n = citations.length;\\n        int[] num = new int[n+1];\\n        \\n        for(int i=0; i<n; i++) {\\n            if(citations[i]>n) num[n]++;\\n            else num[citations[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3822262,
                "title": "binary-search-easy-explanation-short-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMaximum h-index possible is n and minimum possible is 0.\\nso we have a range of 0-n to apply **Binary Search**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCalculate the count of paper greater than mid.\\nNow if count is greater than we increase h-index =>i=mid\\n\\n\\n\\n# Complexity\\n- Time complexity:O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& c) {\\n        int low=0 , high = c.size();\\n        while(low < high){\\n            int mid = (low+high+1)/2;\\n            int cnt=0;\\n            for(int i=0 ; i<c.size() ; i++) if(c[i] >= mid) cnt++;\\n            if(cnt >= mid) low = mid;\\n            else high = mid-1;\\n        }\\n        return low;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int hIndex(int[] c) {\\n        int low=0 , high = c.length;\\n        while(low < high){\\n            int mid = (low+high+1)/2;\\n            int cnt=0;\\n            for(int i=0 ; i<c.length ; i++) if(c[i] >= mid) cnt++;\\n            if(cnt >= mid) low = mid;\\n            else high = high=mid-1;\\n        }\\n        return low;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Binary Search"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& c) {\\n        int low=0 , high = c.size();\\n        while(low < high){\\n            int mid = (low+high+1)/2;\\n            int cnt=0;\\n            for(int i=0 ; i<c.size() ; i++) if(c[i] >= mid) cnt++;\\n            if(cnt >= mid) low = mid;\\n            else high = mid-1;\\n        }\\n        return low;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int hIndex(int[] c) {\\n        int low=0 , high = c.length;\\n        while(low < high){\\n            int mid = (low+high+1)/2;\\n            int cnt=0;\\n            for(int i=0 ; i<c.length ; i++) if(c[i] >= mid) cnt++;\\n            if(cnt >= mid) low = mid;\\n            else high = high=mid-1;\\n        }\\n        return low;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 70927,
                "title": "better-solution-than-hint-no-extra-space",
                "content": "Have a better solution without extra space. \\nUsing in place divide (not sort) and the time in normal case is n + n/2 + n/4 + ... ~= 2n = O(n). \\nIn worst case is: O(n^2), but just like quicksort, in most cases, it's a better solution.\\nIt beats 100% submits at least in my desktop.\\n\\nHere is the code:\\n\\n    public int hIndex(int[] citations) \\n    {\\n        int length = citations.length;\\n        int start = 0;\\n        int end = length - 1;\\n        int hIndex = 0;\\n        \\n        while (start <= end)\\n        {\\n            int current = divideByPartition(citations, start, end);\\n            if (length - current <= citations[current])\\n            {\\n                hIndex = length - current;\\n                end = current - 1;\\n            }\\n            else\\n                start = current + 1;\\n        }\\n        \\n        return hIndex;\\n    }\\n\\n     // divide the array by the last item and return the new index of this partition item.\\n    private int divideByPartition(int[] a, int start, int end)\\n    {\\n        if (start == end) return end;\\n        \\n        int p = a[end];\\n        int head = start;\\n        for (int current = start; current < end; current++)\\n        {\\n            if (a[current] < p)\\n            {\\n                int temp = a[head];\\n                a[head] = a[current];\\n                a[current] = temp;\\n                head++;\\n            }\\n        }\\n        a[end] = a[head];\\n        a[head] = p;\\n        return head;\\n    }",
                "solutionTags": [],
                "code": "Have a better solution without extra space. \\nUsing in place divide (not sort) and the time in normal case is n + n/2 + n/4 + ... ~= 2n = O(n). \\nIn worst case is: O(n^2), but just like quicksort, in most cases, it's a better solution.\\nIt beats 100% submits at least in my desktop.\\n\\nHere is the code:\\n\\n    public int hIndex(int[] citations) \\n    {\\n        int length = citations.length;\\n        int start = 0;\\n        int end = length - 1;\\n        int hIndex = 0;\\n        \\n        while (start <= end)\\n        {\\n            int current = divideByPartition(citations, start, end);\\n            if (length - current <= citations[current])\\n            {\\n                hIndex = length - current;\\n                end = current - 1;\\n            }\\n            else\\n                start = current + 1;\\n        }\\n        \\n        return hIndex;\\n    }\\n\\n     // divide the array by the last item and return the new index of this partition item.\\n    private int divideByPartition(int[] a, int start, int end)\\n    {\\n        if (start == end) return end;\\n        \\n        int p = a[end];\\n        int head = start;\\n        for (int current = start; current < end; current++)\\n        {\\n            if (a[current] < p)\\n            {\\n                int temp = a[head];\\n                a[head] = a[current];\\n                a[current] = temp;\\n                head++;\\n            }\\n        }\\n        a[end] = a[head];\\n        a[head] = p;\\n        return head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3602383,
                "title": "explained-simple-and-clear-python3-code",
                "content": "# Intuition\\nThe problem asks for the h-index of a researcher based on the number of citations received for their papers. The h-index is the maximum value of h such that the researcher has published at least h papers that have each been cited at least h times. To find the h-index, we need to sort the array of citations in descending order and identify the largest h-value that satisfies the given condition.\\n\\n\\n# Approach\\nThe solution begins by sorting the array of citations in reverse order, ensuring that the papers with the highest citation counts are at the beginning. Next, several conditions are checked to determine the h-index. First, if the array contains only one element and it is greater than zero, the h-index is 1. If the smallest value in the sorted array is greater than or equal to the length of the array, the h-index is equal to the array length. Otherwise, the array is traversed, and for each index i, the value at that index is compared to i+1. If the value is less than i+1, i is returned as the h-index. If none of the conditions are met, the h-index is 0.\\n\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the solution primarily depends on the sorting operation, which has a time complexity of O(n log n), where n is the length of the input array. The subsequent iterations through the array and the condition checks have a linear time complexity of O(n). Therefore, the overall time complexity is O(n log n).\\n\\n\\n- Space complexity:\\nThe solution has a space complexity of O(1) since it only uses a constant amount of extra space to store variables and does not depend on the input size. No additional data structures are employed, and the sorting operation is performed in-place.\\n\\n# Code\\n```\\nclass Solution:\\n    def hIndex(self, c: List[int]) -> int:\\n        c.sort(reverse=True)\\n        if len(c)==1 and c[0]>0:\\n            return 1\\n        if c[-1]>=len(c):\\n            return len(c)\\n        for i in range(len(c)):\\n            if c[i]<i+1:\\n                return i\\n        return 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hIndex(self, c: List[int]) -> int:\\n        c.sort(reverse=True)\\n        if len(c)==1 and c[0]>0:\\n            return 1\\n        if c[-1]>=len(c):\\n            return len(c)\\n        for i in range(len(c)):\\n            if c[i]<i+1:\\n                return i\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 70946,
                "title": "ac-python-40-ms-solution-o-n-time-o-n-space-using-counting-sort",
                "content": "    def hIndex(self, citations):\\n        n = len(citations)\\n        papers = [0] * (n + 1)  # papers[i] is the number of papers with i citations.\\n        for c in citations:\\n            papers[min(n, c)] += 1  # All papers with citations larger than n is count as n.\\n        i = n\\n        s = papers[n]  # sum of papers with citations >= i\\n        while i > s:\\n            i -= 1\\n            s += papers[i]\\n        return i\\n\\n\\n    # 81 / 81 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 40 ms\\n    # 97.08%\\n\\nThe question is quite simple if the citations are sorted. Which means we need some kind of \"sorting\". The observation h index is limited by both citation and paper count gives us the idea of counting/bucket sort. We can consider any paper with citations larger than n as citation == n. This way we can sort the citations in O(n) time with O(n) space. The rest is trivial.",
                "solutionTags": [
                    "Python",
                    "Counting Sort"
                ],
                "code": "    def hIndex(self, citations):\\n        n = len(citations)\\n        papers = [0] * (n + 1)  # papers[i] is the number of papers with i citations.\\n        for c in citations:\\n            papers[min(n, c)] += 1  # All papers with citations larger than n is count as n.\\n        i = n\\n        s = papers[n]  # sum of papers with citations >= i\\n        while i > s:\\n            i -= 1\\n            s += papers[i]\\n        return i\\n\\n\\n    # 81 / 81 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 40 ms\\n    # 97.08%\\n\\nThe question is quite simple if the citations are sorted. Which means we need some kind of \"sorting\". The observation h index is limited by both citation and paper count gives us the idea of counting/bucket sort. We can consider any paper with citations larger than n as citation == n. This way we can sort the citations in O(n) time with O(n) space. The rest is trivial.",
                "codeTag": "Python3"
            },
            {
                "id": 70772,
                "title": "according-to-the-definition-of-h-index-in-wiki-it-is-simple",
                "content": "    static bool comp(int left, int right){return left>right;}\\n    int hIndex(vector<int>& citations) {\\n        if(citations.size()==0) return 0;\\n        sort(citations.begin(),citations.end(),comp);\\n        for(size_t i=0;i<citations.size();++i){\\n            if(citations[i]<i+1) return i;\\n        }\\n        return citations.size();\\n    }\\n\\nFrom wiki: Formally, if f is the function that corresponds to the number of citations for each publication, we compute the h index as follows. First we order the values of f from the largest to the lowest value. Then, we look for the last position in which f is greater than or equal to the position (we call h this position).",
                "solutionTags": [
                    "Math"
                ],
                "code": "    static bool comp(int left, int right){return left>right;}\\n    int hIndex(vector<int>& citations) {\\n        if(citations.size()==0) return 0;\\n        sort(citations.begin(),citations.end(),comp);\\n        for(size_t i=0;i<citations.size();++i){\\n            if(citations[i]<i+1) return i;\\n        }\\n        return citations.size();\\n    }\\n\\nFrom wiki: Formally, if f is the function that corresponds to the number of citations for each publication, we compute the h index as follows. First we order the values of f from the largest to the lowest value. Then, we look for the last position in which f is greater than or equal to the position (we call h this position).",
                "codeTag": "Unknown"
            },
            {
                "id": 71060,
                "title": "o-nlogn-12ms-solution",
                "content": "    class Solution {\\n    public:\\n        int hIndex(vector<int>& citations) {\\n            if(citations.empty())\\n                return 0;\\n            sort(citations.begin(), citations.end());\\n            int n=citations.size();\\n            int i=0;\\n            while(i<n && citations[i]<(n-i)) i++;\\n            return n-i;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int hIndex(vector<int>& citations) {\\n            if(citations.empty())\\n                return 0;\\n            sort(citations.begin(), citations.end());\\n            int n=citations.size();\\n            int i=0;\\n            while(i<n && citations[i]<(n-i)) i++;\\n            return n-i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 694842,
                "title": "python-sol-by-sorting-w-comment",
                "content": "Python sol by sorting.\\n\\n\\n---\\n\\n**Implementation** by sorting:\\n\\n```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        \\n        citations.sort( reverse = True )\\n        \\n        for idx, citation in enumerate(citations):\\n\\n            # find the first index where citation is smaller than or equal to array index            \\n            if idx >= citation:\\n                return idx\\n        \\n        return len(citations)\\n```\\n\\n---\\n\\nReference:\\n\\n[1] [Python official docs about sorting](https://docs.python.org/3/library/stdtypes.html#list.sort)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        \\n        citations.sort( reverse = True )\\n        \\n        for idx, citation in enumerate(citations):\\n\\n            # find the first index where citation is smaller than or equal to array index            \\n            if idx >= citation:\\n                return idx\\n        \\n        return len(citations)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 70990,
                "title": "java-ac-solution-by-binary-search",
                "content": "Suppose the citations is sorted, binary search could be used to solve this problem; at each check point, say k, and its value is v; we could check whether there are not more than v citations behind it, by comparing v and n - k; and after processing, the pointer j will be at the index which is just invalid; so the final answer is n - j - 1;\\n\\nthe code may be more clear to understand:\\n\\n    public int hIndex(int[] citations) {\\n        Arrays.sort(citations);\\n\\n        int n = citations.length;\\n        int i = 0, j = n - 1;\\n\\n        while (i <= j) {\\n            int k = (i + j) / 2;\\n            int v = citations[k];\\n            int h = n - k;\\n            if (v >= h) {\\n                j = k - 1;\\n            } else {\\n                i = k + 1;\\n            }\\n        }\\n\\n        return n - j - 1;\\n    }\\n\\nit takes O(nlogn) to sort, O(logn) to binary search;",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "Suppose the citations is sorted, binary search could be used to solve this problem; at each check point, say k, and its value is v; we could check whether there are not more than v citations behind it, by comparing v and n - k; and after processing, the pointer j will be at the index which is just invalid; so the final answer is n - j - 1;\\n\\nthe code may be more clear to understand:\\n\\n    public int hIndex(int[] citations) {\\n        Arrays.sort(citations);\\n\\n        int n = citations.length;\\n        int i = 0, j = n - 1;\\n\\n        while (i <= j) {\\n            int k = (i + j) / 2;\\n            int v = citations[k];\\n            int h = n - k;\\n            if (v >= h) {\\n                j = k - 1;\\n            } else {\\n                i = k + 1;\\n            }\\n        }\\n\\n        return n - j - 1;\\n    }\\n\\nit takes O(nlogn) to sort, O(logn) to binary search;",
                "codeTag": "Unknown"
            },
            {
                "id": 3842150,
                "title": "c-very-easy-and-intuitive-approach-in-o-nlogn-time-and-o-1-space-beats-100-of-users",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIts all about finding the sweet spot!\\n->you have to find maximum number of `h` papers who have got citations more than equal to `h` times.\\n->you can do this by`sorting` the citations array, and decrementing the value of `h`(initially equal to the size of array) one by one in each step then finding and returning the very first sweet spot that you encountered \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Step 1: Sort the citations vector in ascending order\\n- Step 2: Initialize a variable \\'h\\' to store the starting h-index value, which is equal to the size of the citations vector\\n- Step 3: Loop through the citations vector using a for loop\\n- Step 4: Check if the current citation count (citations[i]) is greater than or equal to the current h-index value (h)\\n- Step 5: If true, return the current h-index value as it represents the maximum h-index\\n- Step 6: If the current citation count is smaller than the current h-index value,\\ndecrease the h-index value by 1 to check the next lower h-index\\nNote: If h == 1, it means the lowest possible h-index is 1, and if there\\'s any citation count greater than 0, then the h-index is 1.\\n\\n- Step 7: If the loop completes without finding the h-index, it means h = 0, indicating that there are no citations meeting the h-index criteria.\\nIn this case, return h (which is 0).\\n\\n`I have also Commented step-by-step in the code for better understanding.`\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        // Step 1\\n        sort(citations.begin(), citations.end());\\n        // Step 2\\n        int h = citations.size();\\n        // Step 3\\n        for (int i = 0; i < citations.size(); i++) {\\n            // Step 4\\n            if (citations[i] >= h) {\\n                // Step 5:\\n                return h;\\n            } \\n            else {\\n                // Step 6: \\n                if (h == 1 && citations[i] != 0)\\n                    return 1;\\n                h--;\\n            }\\n        }\\n        return h;\\n    }\\n};\\n\\n```\\n# visual explanation\\n##### 1st test case simulated:\\n![image.png](https://assets.leetcode.com/users/images/9a198891-0a84-4bd7-93f5-285e23a1716c_1690794986.920532.png)\\n- here we can say that there are \\'3\\' papers who have got cited for more than equal to \\'3\\' times\\n- It can be possible for \\'2\\' and \\'1\\' also. but since \\'3\\' is the greatest it will return 3.\\n# Here you Go!\\n![WhatsApp Image 2023-07-30 at 23.55.32.jpg](https://assets.leetcode.com/users/images/54e80819-870f-40c9-8ef4-b341df5e70f6_1690741559.1301308.jpeg)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        // Step 1\\n        sort(citations.begin(), citations.end());\\n        // Step 2\\n        int h = citations.size();\\n        // Step 3\\n        for (int i = 0; i < citations.size(); i++) {\\n            // Step 4\\n            if (citations[i] >= h) {\\n                // Step 5:\\n                return h;\\n            } \\n            else {\\n                // Step 6: \\n                if (h == 1 && citations[i] != 0)\\n                    return 1;\\n                h--;\\n            }\\n        }\\n        return h;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2004209,
                "title": "c-0-ms-2-solutions-with-without-priority-queue-same-code-for-275-h-index-ii",
                "content": "//same solution for [275. H-Index II](https://leetcode.com/problems/h-index-ii/)\\n**WITH PRIORITY QUEUE**\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint hIndex(vector<int>& citations) {\\n\\t\\t\\t\\tint index;\\n\\t\\t\\t\\tpriority_queue<int> pq(begin(citations), end(citations));\\n\\n\\t\\t\\t\\tfor (index = 0; !pq.empty() && index < pq.top();index++)\\n\\t\\t\\t\\t\\tpq.pop();  \\n\\n\\t\\t\\t\\treturn index;\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\t\\n**WITHOUT PRIORITY QUEUE**\\n\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint hIndex(vector<int>& citations) {\\n\\t\\t\\t\\tint index;\\n\\t\\t\\t\\tsort(citations.begin(),citations.end(),greater<int>());\\n\\t\\t\\t\\tint n=citations.size();\\n\\t\\t\\t\\tfor (index = 0;index<n;index++){\\n\\t\\t\\t\\t\\tif(index>=citations[index])break;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn index;\\n\\t\\t\\t}\\n\\t\\t};\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint hIndex(vector<int>& citations) {\\n\\t\\t\\t\\tint index;\\n\\t\\t\\t\\tpriority_queue<int> pq(begin(citations), end(citations));\\n\\n\\t\\t\\t\\tfor (index = 0; !pq.empty() && index < pq.top();index++)\\n\\t\\t\\t\\t\\tpq.pop();  \\n\\n\\t\\t\\t\\treturn index;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 70823,
                "title": "o-n-time-o-1-space-solution",
                "content": "in order to reach O(N) time ,we need to sort array in O(N) time.\\nIn this problem, we can do that using counting sort.<br>However, counting sort requires extra O(N) space to do the trick, and as a result ,we will get the \"count\" for every element. <br>But in this problem, we only need the \"count\" information for element smaller than n <br>because h-index will be in range [0, n] <br>\\nSo we can get rid of elements bigger than n, then consider the array as a linkedlist  and do the counting sort right on itself <br>\\nHere is my implementation.\\n\\n    public int hIndex(int[] citations) {\\n        int c=0, num=0;\\n        \\n        for(int i=0;i<citations.length;i++){\\n            c = citations[i];\\n            if(c<0)continue;\\n            //-1 means that the count of number is 0\\n            //-2 means that the count of number is 1, and so forth\\n            citations[i] = -1;\\n            if(c<citations.length){\\n                //loop like a linkedlist\\n                while((num=citations[c])>-1){\\n                    citations[c] = -2;  \\n                    if(num>citations.length-1){\\n                        break;\\n                    }\\n                    c = num;\\n                }\\n                if(num<citations.length){\\n                    citations[c]--;\\n                }\\n            }\\n        }\\n        c = 0;\\n        for(int i=0;i<citations.length;i++){\\n            num = -citations[i]-1;  //occurrences of i\\n            if(num>0){\\n                if(i>=citations.length-(c+num-1)){\\n                    return i>=citations.length-c ? citations.length-c : i;\\n                }\\n                c += num;\\n            }\\n        }\\n        return citations.length-c;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "in order to reach O(N) time ,we need to sort array in O(N) time.\\nIn this problem, we can do that using counting sort.<br>However, counting sort requires extra O(N) space to do the trick, and as a result ,we will get the \"count\" for every element. <br>But in this problem, we only need the \"count\" information for element smaller than n <br>because h-index will be in range [0, n] <br>\\nSo we can get rid of elements bigger than n, then consider the array as a linkedlist  and do the counting sort right on itself <br>\\nHere is my implementation.\\n\\n    public int hIndex(int[] citations) {\\n        int c=0, num=0;\\n        \\n        for(int i=0;i<citations.length;i++){\\n            c = citations[i];\\n            if(c<0)continue;\\n            //-1 means that the count of number is 0\\n            //-2 means that the count of number is 1, and so forth\\n            citations[i] = -1;\\n            if(c<citations.length){\\n                //loop like a linkedlist\\n                while((num=citations[c])>-1){\\n                    citations[c] = -2;  \\n                    if(num>citations.length-1){\\n                        break;\\n                    }\\n                    c = num;\\n                }\\n                if(num<citations.length){\\n                    citations[c]--;\\n                }\\n            }\\n        }\\n        c = 0;\\n        for(int i=0;i<citations.length;i++){\\n            num = -citations[i]-1;  //occurrences of i\\n            if(num>0){\\n                if(i>=citations.length-(c+num-1)){\\n                    return i>=citations.length-c ? citations.length-c : i;\\n                }\\n                c += num;\\n            }\\n        }\\n        return citations.length-c;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3235206,
                "title": "274-time-90-70-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTo compute the researcher\\'s h-index, we can sort the citations array in non-increasing order and then iterate through the sorted array. For each citation count, we compare it to the number of papers that have at least that many citations, which can be calculated as the remaining elements in the array. If the citation count is greater than or equal to the number of papers with at least that many citations, we have found the h-index.\\n\\nFor example, given the citations array [3,0,6,1,5], we can sort it to obtain [6,5,3,1,0]. We then iterate through the sorted array and for each citation count, we compare it to the number of remaining elements in the array. For the first element, 6, there are 5 remaining elements in the array, all of which have at least 6 citations, so the h-index is 6. For the second element, 5, there are 4 remaining elements in the array, all of which have at least 5 citations, so the h-index is 5. For the third element, 3, there are 3 remaining elements in the array that have at least 3 citations, so the h-index is 3.\\n\\nTime Complexity: O(nlogn), where n is the length of the citations array. This is because we need to sort the array in non-increasing order, which takes O(nlogn) time.\\n\\nSpace Complexity: O(1), as we are sorting the array in-place and using only constant extra space.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        citations.sort(reverse=True) # Sort the array in non-increasing order\\n        n = len(citations)\\n        h = 0\\n        \\n        # Iterate through the sorted array and compare each citation count to the number of papers that have at least that many citations\\n        for i in range(n):\\n            if citations[i] >= i+1: # If the citation count is greater than or equal to the number of papers with at least that many citations, we have found the h-index\\n                h = i+1\\n        \\n        return h\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Sorting",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        citations.sort(reverse=True) # Sort the array in non-increasing order\\n        n = len(citations)\\n        h = 0\\n        \\n        # Iterate through the sorted array and compare each citation count to the number of papers that have at least that many citations\\n        for i in range(n):\\n            if citations[i] >= i+1: # If the citation count is greater than or equal to the number of papers with at least that many citations, we have found the h-index\\n                h = i+1\\n        \\n        return h\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 70874,
                "title": "two-method-with-explaination",
                "content": "I use Java.\\n\\nThere are two basic methods. The easy approach is sorting. Since the 0 elements don't effect the result,\\nwe can eliminate them in advance. The idea is: If index + nums[index] is greater or equal to `length`, which means we have found the `max(min (f(i), i)) (i = 0 ~ length - 1)`.\\n\\n    *  nums  : 0  3  3  3  6  7  9 \\n    *  index : 0  1  2  3  4  5  6\\n    *  sum   : 0  4  5  6 10 12 13\\n                           \\u2191\\n                          stop\\n\\ne.g. We have to stop at `index = 4`, and `length - index = 3` is the result we want.\\nWe used sorting, so the time Complexity is `o(nlogn)`.\\n\\n\\n    public class Solution {\\n        public int hIndex(int[] citations) {\\n            if(citations == null || citations.length == 0)\\n                return 0;\\n            Arrays.sort(citations);\\n            int index = 0;\\n            while(citations[index] == 0){\\n                index++;\\n                if(index == citations.length)\\n                    break;\\n            }\\n            int i;\\n            for(i = index; i < citations.length; i++)\\n                if(citations[i] + i >= citations.length)\\n                    break;\\n            return citations.length - i;\\n        }\\n    }\\n\\nThe second method uses extra spaces for faster speed. We maintain a table counting the the appearance of the numbers.\\n\\n    *  nums  : 0  3  3  3  6  7  9 \\n\\n    * -----------------table---------------------\\n    *       n     : 0  1  2  3  4  5  6  >=7  (length = 7) \\n    * appearance  : 0  0  0  3  0  0  1   2\\n    * -------------------------------------------\\n\\nThen we sum up from the end of the appearance array, if `sum >= n`, which means we have enough numbers greater than or equal to `n`. Then return. The time complexity is o(n).\\n\\n    public class Solution {\\n        public int hIndex(int[] citations) {\\n            int size = citations.length;\\n            if(size == 0)\\n                return 0;\\n            int[] stats = new int[size + 1];\\n            for(int element : citations){\\n                if(element > size)\\n                    stats[size] += 1;\\n                else\\n                    stats[element] += 1;\\n            }\\n            int sum = 0;\\n            for(int i = size; i >= 0; i--){\\n                sum += stats[i];\\n                if(sum >= i)\\n                    return i;\\n            }\\n            return 0;\\n        }\\n    }\\nEnglish is not my native language, may beg your pardon if my English ever bothered you.",
                "solutionTags": [],
                "code": "class Solution {\\n        public int hIndex(int[] citations) {\\n            if(citations == null || citations.length == 0)\\n                return 0;\\n            Arrays.sort(citations);\\n            int index = 0;\\n            while(citations[index] == 0){\\n                index++;\\n                if(index == citations.length)\\n                    break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 71018,
                "title": "java-o-n-log-n-time-o-1-space-with-explanation",
                "content": "Idea is we need to find if there exist a position in sorted array, that citation[i] >= citation.length - i.\\n\\nfor example:\\n\\n    2 5 6 9 10 12 15\\n    7 6 5 4 3  2  1   <=== reverse index, tells how many elements(inclusive) to the right.\\n\\nin order to find the h-index. we need to find if there exist a position that citation[i] >= reverse index.\\n\\n    So, like\\n    check elements 2 and after >= 7? --> No\\n    check elements 5 and after >= 6? --> No\\n    check elements 6 and after >= 5? --> Yes! This is the max \"h\" value, we return this 5.\\n\\n\\nCode:\\n\\n    public class Solution {\\n        public int hIndex(int[] citations) {\\n            if(citations == null || citations.length == 0)\\n                return 0;\\n                \\n            Arrays.sort(citations);\\n            for(int i = 0; i < citations.length; i++){\\n                if(citations[i] >= citations.length - i)\\n                    return citations.length - i;\\n            }\\n            return 0;\\n        }\\n    }\\n\\nTime Complexity O(n log n) + O(n) = O(n log n)\\nSpace Complexity O(1)",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int hIndex(int[] citations) {\\n            if(citations == null || citations.length == 0)\\n                return 0;\\n                \\n            Arrays.sort(citations);\\n            for(int i = 0; i < citations.length; i++){\\n                if(citations[i] >= citations.length - i)\\n                    return citations.length - i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 694000,
                "title": "simple-solution-with-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        int h;\\n        priority_queue<int> pq(begin(citations), end(citations));\\n        \\n        for (h = 0; !pq.empty() && h < pq.top(); ++h)\\n            pq.pop();  \\n\\n        return h;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        int h;\\n        priority_queue<int> pq(begin(citations), end(citations));\\n        \\n        for (h = 0; !pq.empty() && h < pq.top(); ++h)\\n            pq.pop();  \\n\\n        return h;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 558876,
                "title": "c-min-heap",
                "content": "```cpp\\nint hIndex(vector<int>& cit) {\\n    priority_queue<int, vector<int>, greater<int>> pq(begin(cit), end(cit));\\n    while (!pq.empty() && pq.top() < pq.size())\\n        pq.pop();\\n    return pq.size();\\n}\\n```\\nAnd another without using extra memory:\\n```cpp\\nint hIndex(vector<int>& cit) {\\n    make_heap(begin(cit), end(cit), greater<int>());\\n    while(!cit.empty() && cit.front() < cit.size()) {\\n        pop_heap (cit.begin(), cit.end(), greater<int>()); \\n        cit.pop_back();\\n    }\\n    return cit.size();\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint hIndex(vector<int>& cit) {\\n    priority_queue<int, vector<int>, greater<int>> pq(begin(cit), end(cit));\\n    while (!pq.empty() && pq.top() < pq.size())\\n        pq.pop();\\n    return pq.size();\\n}\\n```\n```cpp\\nint hIndex(vector<int>& cit) {\\n    make_heap(begin(cit), end(cit), greater<int>());\\n    while(!cit.empty() && cit.front() < cit.size()) {\\n        pop_heap (cit.begin(), cit.end(), greater<int>()); \\n        cit.pop_back();\\n    }\\n    return cit.size();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3570805,
                "title": "easy-c-beats-100",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach is simple, sort the array first and Travers the array and apply this formula:-\\n\\n**if(left-elements <= arr[i])\\nrerurn left;**\\n\\nThis formula check that how many papers have citations greater then or equal to current paper.\\n\\n# Complexity\\n- Time complexity: O(N*Log(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& arr) {\\n\\n        int n = arr.size();\\n        sort(arr.begin(),arr.end());\\n        if(arr[0]>=n)  return n;\\n        if(n==1) return !(arr[0]==0);\\n        for(int i = 0;i<n;i++)\\n        {\\n           int left = n-i;\\n           if(arr[i] >= left) return left;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& arr) {\\n\\n        int n = arr.size();\\n        sort(arr.begin(),arr.end());\\n        if(arr[0]>=n)  return n;\\n        if(n==1) return !(arr[0]==0);\\n        for(int i = 0;i<n;i++)\\n        {\\n           int left = n-i;\\n           if(arr[i] >= left) return left;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2604353,
                "title": "c-sort-4-lines",
                "content": "```\\nint hIndex(vector<int>& cit) {\\n        sort(cit.begin(),cit.end());\\n        int n=cit.size(),count=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(n-i<=cit[i])\\n                count++;\\n        }\\n        return count;\\n    }",
                "solutionTags": [],
                "code": "```\\nint hIndex(vector<int>& cit) {\\n        sort(cit.begin(),cit.end());\\n        int n=cit.size(),count=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(n-i<=cit[i])\\n                count++;\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 785622,
                "title": "python-clean-simple-solution-faster-than-92",
                "content": "```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        if len(citations) == 0:\\n            return 0\\n        \\n        res = 0\\n        citations.sort(reverse = True)\\n        \\n        if citations[-1] >= len(citations):\\n            return len(citations)\\n        \\n        for i in range(1, len(citations)+1):\\n            if i > citations[i-1]:\\n                res = i-1\\n                break\\n        return res\\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        if len(citations) == 0:\\n            return 0\\n        \\n        res = 0\\n        citations.sort(reverse = True)\\n        \\n        if citations[-1] >= len(citations):\\n            return len(citations)\\n        \\n        for i in range(1, len(citations)+1):\\n            if i > citations[i-1]:\\n                res = i-1\\n                break\\n        return res\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 785493,
                "title": "clean-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n\\t\\t// Sorting it so that \\n        sort(citations.begin(), citations.end(), greater<int>());\\n\\t\\t// while going from left to right, H-index will increase and will be matched with the decreasing no. of citations for the paper\\n        for(int i = 0; i < citations.size(); i++)\\n\\t\\t// the index at which H-index (i in this case) becomes >= to no. of citations at [i], it means the H - index cannot be greater than current i \\n            if(i >= citations[i]) {\\n\\t\\t\\t\\t// return i due to 0 - based indexing\\n                return i;\\n            }\\n\\t\\t//  when smallest value citation is > the total no. of citations on the paper (i.e. its size)\\n        return citations.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n\\t\\t// Sorting it so that \\n        sort(citations.begin(), citations.end(), greater<int>());\\n\\t\\t// while going from left to right, H-index will increase and will be matched with the decreasing no. of citations for the paper\\n        for(int i = 0; i < citations.size(); i++)\\n\\t\\t// the index at which H-index (i in this case) becomes >= to no. of citations at [i], it means the H - index cannot be greater than current i \\n            if(i >= citations[i]) {\\n\\t\\t\\t\\t// return i due to 0 - based indexing\\n                return i;\\n            }\\n\\t\\t//  when smallest value citation is > the total no. of citations on the paper (i.e. its size)\\n        return citations.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71043,
                "title": "1-line-ruby-5-lines-c-6-lines-java",
                "content": "I saw [the picture](https://commons.wikimedia.org/wiki/File%3AH-index-en.svg) in the Wikipedia article and thought I'll just count the papers above the diagonal (first sort by decreasing citation number, then count the papers whose citation number is larger than their array index).\\n\\n---\\n\\n**Ruby**\\n\\n    def h_index(citations)\\n      citations.sort.reverse.each_with_index.count(&:>)\\n    end\\n\\n---\\n\\n**C++**\\n\\n    int hIndex(vector<int>& citations) {\\n        sort(citations.rbegin(), citations.rend());\\n        int h = 0, i = 0;\\n        for (int c : citations)\\n            h += c > i++;\\n        return h;\\n    }\\n\\n---\\n\\n**Java**\\n\\nSince Java doesn't let me sort in reverse order nicely, I sort in normal order and reverse the array indexes instead.\\n\\n    public int hIndex(int[] citations) {\\n        Arrays.sort(citations);\\n        int h = 0, i = citations.length;\\n        for (int c : citations)\\n            if (c > --i)\\n                ++h;\\n        return h;\\n    }",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Ruby"
                ],
                "code": "I saw [the picture](https://commons.wikimedia.org/wiki/File%3AH-index-en.svg) in the Wikipedia article and thought I'll just count the papers above the diagonal (first sort by decreasing citation number, then count the papers whose citation number is larger than their array index).\\n\\n---\\n\\n**Ruby**\\n\\n    def h_index(citations)\\n      citations.sort.reverse.each_with_index.count(&:>)\\n    end\\n\\n---\\n\\n**C++**\\n\\n    int hIndex(vector<int>& citations) {\\n        sort(citations.rbegin(), citations.rend());\\n        int h = 0, i = 0;\\n        for (int c : citations)\\n            h += c > i++;\\n        return h;\\n    }\\n\\n---\\n\\n**Java**\\n\\nSince Java doesn't let me sort in reverse order nicely, I sort in normal order and reverse the array indexes instead.\\n\\n    public int hIndex(int[] citations) {\\n        Arrays.sort(citations);\\n        int h = 0, i = citations.length;\\n        for (int c : citations)\\n            if (c > --i)\\n                ++h;\\n        return h;\\n    }",
                "codeTag": "Python3"
            },
            {
                "id": 3825543,
                "title": "100-faster-sufficient-intuition-binary-search-line-by-line-code-explained",
                "content": "# Intuition\\n\\n **100 % fast solution**\\uD83C\\uDFC6\\uD83C\\uDFC6\\n\\n![Screenshot 2023-07-28 001104.png](https://assets.leetcode.com/users/images/f2c1960a-04b2-436d-b781-e3799a9c5dcf_1690484829.7037516.png)\\n\\n**we require atleast m numbers of papers, which having greater or equal to m citations.**\\n\\neg. [ 3 , 2 , 5 , 1 , 7 , 4] in this array [5,7,4] these are the elements that we can select (because these 3 papers citations are >= 3). \\n\\nif we select [3,5,7,4] from input array then there should be atleast 4 elements(in this problem called research paper) which have to greater than or equal to 4 . but in above selected array 3 element is not greater than 4 . which is not valid for citation criteria\\n\\nSo , we can\\'t include 3. hence ans will be 3 which is [5 , 7, 4].\\n\\n\\n# Complexity\\n- Time complexity:\\n    O(n logn + logn) ---- sorting + searching   \\uD83C\\uDFC6\\n\\n- Space complexity:\\n  O(1)\\n\\n\\n    ***if you find this helpful Kindly upvote me***\\uD83C\\uDFC6\\uD83C\\uDFC6\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n      sort(citations.begin() , citations.end());\\n\\t\\t\\tint l = 0 , h = citations.size()-1;\\n\\t\\t\\tint n = citations.size();\\n\\t\\t\\tint ans = 0; // to store ans \\n\\t\\t\\twhile(l <= h){\\n\\t\\t\\t\\tint mid  = l +(h-l)/2;\\n\\t\\t\\t    int idx = n  - mid ; // index = total number of papers - mid(almost half)\\n\\t\\t\\t\\tif(citations[mid] >= idx){ \\n\\t\\t\\t\\t\\tans = idx;\\n\\t\\t\\t\\t\\th = mid-1; //we want to include more papers for citations(maximize ans )\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tl = mid +1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n      sort(citations.begin() , citations.end());\\n\\t\\t\\tint l = 0 , h = citations.size()-1;\\n\\t\\t\\tint n = citations.size();\\n\\t\\t\\tint ans = 0; // to store ans \\n\\t\\t\\twhile(l <= h){\\n\\t\\t\\t\\tint mid  = l +(h-l)/2;\\n\\t\\t\\t    int idx = n  - mid ; // index = total number of papers - mid(almost half)\\n\\t\\t\\t\\tif(citations[mid] >= idx){ \\n\\t\\t\\t\\t\\tans = idx;\\n\\t\\t\\t\\t\\th = mid-1; //we want to include more papers for citations(maximize ans )\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tl = mid +1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507840,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int HIndex(int[] citations) {\\n        int res = 0;\\n        Array.Sort(citations);\\n\\n        for(int i = citations.Length -1; i>-1; i--)\\n        {\\n            if (res < citations[i])\\n            {\\n                res++;\\n            }\\n            else\\n            {\\n                return res;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int HIndex(int[] citations) {\\n        int res = 0;\\n        Array.Sort(citations);\\n\\n        for(int i = citations.Length -1; i>-1; i--)\\n        {\\n            if (res < citations[i])\\n            {\\n                res++;\\n            }\\n            else\\n            {\\n                return res;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 786206,
                "title": "o-n-bucket-approach",
                "content": "This approach **does not involve sorting** of the array, which would result in the solution being nlog n. *Hence, the overall complexity of the solution would be **O(n)**.* \\nWe take a bucket array of size n + 1, where n being the size of the given array.\\n\\nThe idea is to store the frequency of elements of the input array. If however we get a value which is larger than the size of the array, that itself won\\'t be a candidate for h-index, so we store it at the last index value. Otherwise we just store those values at the index value. Here is an implementation.\\n\\n```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        bucket = [0] * (len(citations) + 1)\\n        \\n        for i in range(len(citations)):\\n            if citations[i] > len(citations):\\n                bucket[len(citations)] += 1\\n            else:\\n                bucket[citations[i]] += 1\\n                \\n        count = 0\\n        for i in range(len(bucket) - 1, -1, -1):\\n            count += bucket[i]\\n            if count >= i:  #  If the value of count is greater than the index value then we return the index\\n                return i\\n        \\n        return 0  # If no such index is found then we simply return 0\\n```\\n\\nThe approach runs only twice, so the overall worst case scenario of the solution would be **O(n)**.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        bucket = [0] * (len(citations) + 1)\\n        \\n        for i in range(len(citations)):\\n            if citations[i] > len(citations):\\n                bucket[len(citations)] += 1\\n            else:\\n                bucket[citations[i]] += 1\\n                \\n        count = 0\\n        for i in range(len(bucket) - 1, -1, -1):\\n            count += bucket[i]\\n            if count >= i:  #  If the value of count is greater than the index value then we return the index\\n                return i\\n        \\n        return 0  # If no such index is found then we simply return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 785586,
                "title": "python3-o-n-without-sorting",
                "content": "```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        tmp = [0] * (len(citations) + 1)\\n\\t\\t\\n        for i in range(len(citations)):\\n            if citations[i] > len(citations):\\n                tmp[len(citations)] += 1\\n            else:\\n                tmp[citations[i]] += 1\\n\\n        sum_ = 0\\n        for i in range(len(tmp) - 1, -1, -1):\\n            sum_ += tmp[i]\\n            if sum_ >= i:\\n                return i\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        tmp = [0] * (len(citations) + 1)\\n\\t\\t\\n        for i in range(len(citations)):\\n            if citations[i] > len(citations):\\n                tmp[len(citations)] += 1\\n            else:\\n                tmp[citations[i]] += 1\\n\\n        sum_ = 0\\n        for i in range(len(tmp) - 1, -1, -1):\\n            sum_ += tmp[i]\\n            if sum_ >= i:\\n                return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 70957,
                "title": "simple-java-o-n-time-o-n-space-solution",
                "content": "   \\nBasically we iterate the array for two rounds. In first round we count how many citation in each bucket and in the second round we traverse back to find the maximum h.\\n\\n\\n    \\n    //O(n) solution O(n) space\\n    public int hIndex(int[] citations) {\\n        \\n        if(citations == null)   return 0;\\n        int[] buffer = new int[citations.length+1];\\n        Arrays.fill(buffer, 0);\\n        \\n        for(int num : citations) {\\n            int idx = Math.min(num, citations.length);\\n            buffer[idx]++;\\n        }\\n        \\n        int sum = 0;\\n        for(int i = buffer.length -1 ; i >= 0 ; i--) {\\n            sum += buffer[i];\\n            if(sum >= i) return i;\\n        }\\n        \\n        return 0;\\n}",
                "solutionTags": [],
                "code": "   \\nBasically we iterate the array for two rounds. In first round we count how many citation in each bucket and in the second round we traverse back to find the maximum h.\\n\\n\\n    \\n    //O(n) solution O(n) space\\n    public int hIndex(int[] citations) {\\n        \\n        if(citations == null)   return 0;\\n        int[] buffer = new int[citations.length+1];\\n        Arrays.fill(buffer, 0);\\n        \\n        for(int num : citations) {\\n            int idx = Math.min(num, citations.length);\\n            buffer[idx]++;\\n        }\\n        \\n        int sum = 0;\\n        for(int i = buffer.length -1 ; i >= 0 ; i--) {\\n            sum += buffer[i];\\n            if(sum >= i) return i;\\n        }\\n        \\n        return 0;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 70965,
                "title": "c-0-ms-o-n-solution",
                "content": "    int hIndex(int* citations, int citationsSize) {\\n        int i, j = 0, index = 0, *count = malloc(sizeof(int) * (citationsSize + 1));\\n        memset(count, 0, sizeof(int) * citationsSize);\\n        for (i = 0; i < citationsSize; ++i) {\\n            count[citations[i] > citationsSize ? citationsSize : citations[i]]++;\\n        }\\n        for (i = 0; i <= citationsSize; ++i) {\\n            if (citationsSize - j >= i) {\\n                index = i;\\n            }\\n            j += count[i];\\n        }\\n        free(count);\\n        return index;\\n    }",
                "solutionTags": [],
                "code": "    int hIndex(int* citations, int citationsSize) {\\n        int i, j = 0, index = 0, *count = malloc(sizeof(int) * (citationsSize + 1));\\n        memset(count, 0, sizeof(int) * citationsSize);\\n        for (i = 0; i < citationsSize; ++i) {\\n            count[citations[i] > citationsSize ? citationsSize : citations[i]]++;\\n        }\\n        for (i = 0; i <= citationsSize; ++i) {\\n            if (citationsSize - j >= i) {\\n                index = i;\\n            }\\n            j += count[i];\\n        }\\n        free(count);\\n        return index;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3248866,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& c) \\n    { int ans=0;\\n        sort(c.begin(),c.end());\\n        for(int i=c.size()-1;i>=0;i--) {\\n            if(c[i]>=c.size()-i) {\\n                  ans++;\\n            }  \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& c) \\n    { int ans=0;\\n        sort(c.begin(),c.end());\\n        for(int i=c.size()-1;i>=0;i--) {\\n            if(c[i]>=c.size()-i) {\\n                  ans++;\\n            }  \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3140725,
                "title": "c-simple-hash-map-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        unordered_map<int,int>m;\\n        for(int i=0;i<citations.size();i++){\\n            int count=citations[i];\\n            for(int i=0;i<=count;i++){\\n                m[i]++;\\n            }\\n        }\\n\\n        int ans=-1;\\n        for(auto it:m){\\n            int h=it.first;\\n            if(it.second>=h){\\n                ans=max(ans,h);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nConsider Upvoting if it helped :)",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        unordered_map<int,int>m;\\n        for(int i=0;i<citations.size();i++){\\n            int count=citations[i];\\n            for(int i=0;i<=count;i++){\\n                m[i]++;\\n            }\\n        }\\n\\n        int ans=-1;\\n        for(auto it:m){\\n            int h=it.first;\\n            if(it.second>=h){\\n                ans=max(ans,h);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086384,
                "title": "easy-python-solution-sorting",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        citations.sort()\\n        citations=citations[::-1]\\n        for i in range(len(citations)):\\n            if citations[i]<=i:\\n                return i\\n        return len(citations)     \\n```",
                "solutionTags": [
                    "Python3",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        citations.sort()\\n        citations=citations[::-1]\\n        for i in range(len(citations)):\\n            if citations[i]<=i:\\n                return i\\n        return len(citations)     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1170888,
                "title": "javascript-two-easy-understand-solutions-brute-force-binary-search",
                "content": "**1. Brute Force**\\nRuntime: 76 ms, faster than 82.98% of JavaScript online submissions for H-Index.\\nMemory Usage: 38.5 MB, less than 84.04% of JavaScript online submissions for H-Index.\\n```\\nvar hIndex = function(citations) {\\n    citations.sort((a,b)=>b-a)\\n    for(i=0;i<citations.length;i++){\\n        if(citations[i]<i+1) return i\\n    }\\n    return i\\n};\\n```\\n**2. Binary Search**\\nRuntime: 76 ms, faster than 82.98% of JavaScript online submissions for H-Index.\\nMemory Usage: 38.4 MB, less than 94.68% of JavaScript online submissions for H-Index.\\n```\\nvar hIndex = function(citations) {\\n    let a = 0\\n    let b = citations.length-1\\n    citations.sort((a,b)=>b-a)\\n    while(a<=b){\\n        let mid = a+Math.floor((b-a)/2)       \\n        if(citations[mid]>mid) a = mid+1\\n        else b = mid-1  \\n    }\\n    return a\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar hIndex = function(citations) {\\n    citations.sort((a,b)=>b-a)\\n    for(i=0;i<citations.length;i++){\\n        if(citations[i]<i+1) return i\\n    }\\n    return i\\n};\\n```\n```\\nvar hIndex = function(citations) {\\n    let a = 0\\n    let b = citations.length-1\\n    citations.sort((a,b)=>b-a)\\n    while(a<=b){\\n        let mid = a+Math.floor((b-a)/2)       \\n        if(citations[mid]>mid) a = mid+1\\n        else b = mid-1  \\n    }\\n    return a\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 786170,
                "title": "java-0ms-confusing-problem-statement-simplified",
                "content": "The problem statement seemed a little confusing to me, here is my attempt at simplifying it.\\n\\nWe are given a list of publications of an author that have been cited, the citations obviously would be positive numbers. We are then asked to calculate a metric called the Hirsch Index for the citation count.\\n\\nWikipedia does a great job explaining what the H index is and how it is calculated. Here is an excerpt:\\n\\nFormally, if f is the function that corresponds to the number of citations for each publication, we compute the h-index as follows: First we order the values of f from the largest to the lowest value. Then, we look for the last position in which f is greater than or equal to the position (we call h this position). For example, if we have a researcher with 5 publications A, B, C, D, and E with 10, 8, 5, 4, and 3 citations, respectively, the h-index is equal to 4 because the 4th publication has 4 citations and the 5th has only 3. In contrast, if the same publications have 25, 8, 5, 3, and 3 citations, then the index is 3 (i.e. the 3rd position) because the fourth paper has only 3 citations.\\n\\n    f(A)=10, f(B)=8, f(C)=5, f(D)=4, f(E)=3\\u3000\\u2192 h-index=4\\n    f(A)=25, f(B)=8, f(C)=5, f(D)=3, f(E)=3\\u3000\\u2192 h-index=3\\n\\nIf we have the function f ordered in decreasing order from the largest value to the lowest one, we can compute the h-index as follows:\\n\\n    h-index (f) = max i min ( f ( i ) , i ) {\\\\displaystyle \\\\max _{i}\\\\min(f(i),i)} \\\\max _{i}\\\\min(f(i),i)\\n\\t\\nHere are some key pieces of information for us to solve our problem.\\n\\n\"First we order the values of f from the largest to the lowest value\" \\n\\nThis tells me I need to sort the input array\\n\\n\"Then, we look for the last position in which f is greater than or equal to the position (we call h this position)\"\\n\\nThis tells me that I need to skip each item in the sorted array till I get to a point where the citations count is less than the current index. In our example, the 5th(index) publication has 3 citations, hence our H index is the index before 5.\\n\\nLets see how our pseudocode is shaping up.\\n\\n```\\nfunc(citations array) {\\n\\tSort the citations array \\n\\t//Java doesnt let me sort a primitive array in descending order, so I ll have to play with the indices\\n\\tSet current index to 1\\n\\tLoop through citations array\\n\\t\\tif current citation < current index\\n\\t\\t\\tbreak\\n\\t\\tincrement current index\\n\\treturn current index - 1\\n```\\n\\nLets test this with our example [10, 8, 5, 4, 3]\\n\\nSort in descding order (already sorted) -> [10, 8, 5, 4, 3]\\ncurrent index = 1\\nLoop through the array\\n\\tcurrent citation = 10\\n\\tcurrent index = 1, break condition not met\\n\\t\\n\\tcurrent citation = 8\\n\\tcurrent index = 2, break condition not met\\n\\t\\n\\tcurrent citation = 5\\n\\tcurrent index = 3, break condition not met\\n\\t\\n\\tcurrent citation = 4\\n\\tcurrent index = 4, break condition not met\\n\\t\\n\\tcurrent citation = 3\\n\\tcurrent index = 5, break condition met\\n\\tbreak the loop\\n\\nreturn current index - 1\\n\\nLets look at the code now:\\n\\n```\\npublic int hIndex(int[] citations) {\\n        Arrays.sort(citations);\\n        int currentIndex = 1;\\n\\n        while (currentIndex <= citations.length) {\\n            if (citations[citations.length - currentIndex] < currentIndex) {\\n                break;\\n            }\\n            currentIndex++;\\n        }\\n        return currentIndex-1;\\n    }\\n```\\n\\nI have seen people solve it without sorting and I commend them, I happened to read through the wiki and coded the way wiki explained it.\\n\\n\\t\\t\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nfunc(citations array) {\\n\\tSort the citations array \\n\\t//Java doesnt let me sort a primitive array in descending order, so I ll have to play with the indices\\n\\tSet current index to 1\\n\\tLoop through citations array\\n\\t\\tif current citation < current index\\n\\t\\t\\tbreak\\n\\t\\tincrement current index\\n\\treturn current index - 1\\n```\n```\\npublic int hIndex(int[] citations) {\\n        Arrays.sort(citations);\\n        int currentIndex = 1;\\n\\n        while (currentIndex <= citations.length) {\\n            if (citations[citations.length - currentIndex] < currentIndex) {\\n                break;\\n            }\\n            currentIndex++;\\n        }\\n        return currentIndex-1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 785640,
                "title": "easy-java-solution-faster-than-100-submission-in-0ms",
                "content": "```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        Arrays.sort(citations);\\n        int n=citations.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(citations[i]>=n-i)\\n            {\\n                return (n-i);\\n            }\\n        }\\n        return 0;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        Arrays.sort(citations);\\n        int n=citations.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(citations[i]>=n-i)\\n            {\\n                return (n-i);\\n            }\\n        }\\n        return 0;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 734842,
                "title": "how-to-explain-to-interviewer-274-h-index",
                "content": "#### 1. Clarify\\n- If citations = [100, 100], is h-index 2?  Answer is Yes, because we have at least 2 papers whose citation is >= 2 and 2 - 2 = 0 papers have no more than 2 citations\\n\\n#### 2. Idea, Code, Complexity Analysis\\nLet\\'s sort the citations array in increasing order and list the sorted array as below\\n\\n|sorted citations (there can be duplicates)|c<sub>0</sub> |c<sub>1</sub>|...|c<sub>n-(i+1)|c<sub>n-i</sub>|...|c<sub>n - 2</sub>|c<sub>n - 1</sub>|\\n|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|\\n|paper count accumulation(right to left)|n|n-1|...|i+1|i|...|2|1|\\n\\n\\nIf we can find an i such that:\\n-  i <= c<sub>n-i</sub> \\n-  c<sub>n-(i+1)</sub> <= i\\n\\nin which\\n-  i <= c<sub>n-i</sub> means that i papers have citations >= i because i <= c<sub>n-i</sub> < ...< c<sub>n - 2</sub> < c<sub>n - 1</sub>\\n-  c<sub>n-(i+1)</sub> <= i means that n - i papers have citations <= i because c<sub>0</sub> < c<sub>1</sub> <   ... < c<sub>n-(i+1)</sub> <= i\\n\\nThen i meets the definition of h-index:\\n- i papers\\' citations >= i each\\n- The other N - i papers\\' citations <= i each\\n\\nSo i is the h-index of this scientist\\n\\nThe code is below(**search i either from smallest or largest**):\\n```java\\nclass Solution {\\n\\t//search i from 1 to n\\n    public int hIndex(int[] citations) {\\n        Arrays.sort(citations);\\n        int n = citations.length;\\n        for(int i = 1; i <= n; i ++){\\n            if(citations[n - i] >= i && (n - i - 1 < 0 || citations[n - i - 1] <= i)){\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n\\nclass Solution {\\n\\t//search i from n to 1\\n    public int hIndex(int[] citations) {\\n        Arrays.sort(citations);\\n        int n = citations.length;\\n        for(int i = n; i >= 1; i --){\\n            if(citations[n - i] >= i && (n - i - 1 < 0 || citations[n - i - 1] <= i)){\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```\\n**The time complexity** is O(nlogn) where n is the length of citations array\\n**The space complexity** is O(1) because we only use some variables\\n\\nCan the time complexity be improved? The answer is Yes\\n\\n#### 3. Improvement\\nWe could use **bucket sort** to solve this problem:\\n\\n|sorted citations (no duplicates)|0|1|...|i|i+1|...|n|\\n|:---|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|\\n|paper count <br/>p<sub>i</sub> means<br/>- the number of papers that have i citations(if i < n) <br/>-  or the number of papers that have >= i citations(if i == n) |p<sub>0</sub>|p<sub>1</sub>|...|p<sub>i</sub>|p<sub>i+1</sub>|...|p<sub>n</sub>|\\n|paper count accumulation(right to left)<br/>a<sub>i</sub> = p<sub>i</sub>+p<sub>i+1</sub>+...+p<sub>n</sub>=a<sub>i+1</sub>+p<sub>i</sub>|a<sub>0</sub>|a<sub>1</sub>|...|a<sub>i</sub>|a<sub>i+1</sub>|...|a<sub>n</sub>| cc \\n\\n\\nIf we can find an i such that:\\n-  i <= a<sub>i</sub>\\n-  i + 1 > a<sub>i+1</sub> (is equal to a<sub>i+1</sub> - i < 1)\\n\\nin which\\n-  a<sub>i</sub> means the number of papers whose citations = [i, n], so a<sub>i</sub> papers have at least i citations each, and because a<sub>i</sub> >= i, **i papers have at least i citations each**\\n-  **The other n - i papers have <= i citations**, to prove this, we could divide them into two parts\\n\\t- part 1: a<sub>i</sub> - i papers\\n\\tbecause a<sub>i</sub> - i = a<sub>i+1</sub> + p<sub>i</sub> - i = (a<sub>i+1</sub> - i) + p<sub>i</sub> < 1 + p<sub>i</sub> <= p<sub>i</sub>, so all a<sub>i</sub> - i papers fall into papers with i citations\\n\\t- part 2: n - a<sub>i</sub> papers\\n\\ta<sub>i</sub> means the number of papers whose citations = [i, n], so n - a<sub>i</sub> means the number of papers whose citaions = [0, i - 1], all n - a<sub>i</sub> papers have < i citations\\n\\nThen i meets the definition of h-index:\\n- i papers\\' citations >= i each\\n- The other N - i papers\\' citations <= i each\\n\\nSo i is the h-index of this scientist\\n\\nThe code is below(search i either from smallest or largest):\\n```java\\nclass Solution {\\n\\t//search i from 1 to n\\n    public int hIndex(int[] citations) {\\n        int n = citations.length;\\n        int[] count = new int[n + 1];\\n        int[] accumulation = new int[n + 1];\\n\\n        for(int citation: citations){\\n            if(citation <= n){\\n                count[citation] ++;\\n            }\\n            else{\\n                count[n] ++;\\n            }\\n        }\\n        \\n        accumulation[n] = count[n];\\n        for(int i = n - 1; i >= 0; i --){\\n            accumulation[i] = count[i] + accumulation[i + 1];\\n        }\\n\\n        for(int i = 1; i <= n; i ++){\\n            if(i <= accumulation[i] && (i == n || i + 1 > accumulation[i + 1])){\\n                return i;\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n}\\n\\nclass Solution {\\n\\t//search i from n to 1\\n    public int hIndex(int[] citations) {\\n        int n = citations.length;\\n        int[] count = new int[n + 1];\\n\\n        for(int citation: citations){\\n            if(citation <= n){\\n                count[citation] ++;\\n            }\\n            else{\\n                count[n] ++;\\n            }\\n        }\\n\\n        int accumualtion = 0;\\n        for(int i = n; i >= 1; i --){\\n            accumualtion += count[i];\\n            if(i <= accumualtion){\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```\\n\\nTime Complexity: O(n) where n is the length of citations[] array\\nSpace Complexity: O(n)\\n\\n#### 4. There is one and only one h-index for any citations[] array\\nIn part 2, we proved that if we can find an i such that:\\n-  i <= c<sub>n-i</sub> \\n-  c<sub>n-(i+1)</sub> <= i\\n\\nThen i is the h-index of this scientist. \\n\\nActually, such an i is the only h-index of this scientist. \\n- If we increase i, for example we check i + 1, if i + 1 is the h-index of this scientist, then the following conditions must be met:\\n\\t-  i + 1 <= c<sub>n-(i+1)</sub> < c<sub>n-i</sub> < ...< c<sub>n - 2</sub> < c<sub>n - 1</sub> ----- condition 1\\n\\t-  c<sub>0</sub> < c<sub>1</sub> <   ... < c<sub>n-(i+2)</sub> <= i + 1 ------ condition 2\\n\\nApparently, conditions 2 is met but condition 1 isn\\'t because we know c<sub>n-(i+1)</sub> <= i but not c<sub>n-(i+1)</sub> >= i + 1\\n\\n- If we decrease i, for example we check i - 1, if i - 1 is the h-index of this scientist, then the following conditions must be met:\\n\\t-  i - 1 <= c<sub>n-(i-1)</sub> < ...< c<sub>n - 2</sub> < c<sub>n - 1</sub> ----- condition 1\\n\\t-  c<sub>0</sub> < c<sub>1</sub> <   ... < c<sub>n-i</sub> <= i - 1 ------ condition 2\\n\\nApparently, conditions 1 is met but condition 2 isn\\'t because we know c<sub>n-i</sub> >= i but not c<sub>n-i</sub> <= i - 1\\n\\nFrom the proof above we know that for a given citations[], there is one and only one h-index",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n\\t//search i from 1 to n\\n    public int hIndex(int[] citations) {\\n        Arrays.sort(citations);\\n        int n = citations.length;\\n        for(int i = 1; i <= n; i ++){\\n            if(citations[n - i] >= i && (n - i - 1 < 0 || citations[n - i - 1] <= i)){\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n\\nclass Solution {\\n\\t//search i from n to 1\\n    public int hIndex(int[] citations) {\\n        Arrays.sort(citations);\\n        int n = citations.length;\\n        for(int i = n; i >= 1; i --){\\n            if(citations[n - i] >= i && (n - i - 1 < 0 || citations[n - i - 1] <= i)){\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n\\t//search i from 1 to n\\n    public int hIndex(int[] citations) {\\n        int n = citations.length;\\n        int[] count = new int[n + 1];\\n        int[] accumulation = new int[n + 1];\\n\\n        for(int citation: citations){\\n            if(citation <= n){\\n                count[citation] ++;\\n            }\\n            else{\\n                count[n] ++;\\n            }\\n        }\\n        \\n        accumulation[n] = count[n];\\n        for(int i = n - 1; i >= 0; i --){\\n            accumulation[i] = count[i] + accumulation[i + 1];\\n        }\\n\\n        for(int i = 1; i <= n; i ++){\\n            if(i <= accumulation[i] && (i == n || i + 1 > accumulation[i + 1])){\\n                return i;\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n}\\n\\nclass Solution {\\n\\t//search i from n to 1\\n    public int hIndex(int[] citations) {\\n        int n = citations.length;\\n        int[] count = new int[n + 1];\\n\\n        for(int citation: citations){\\n            if(citation <= n){\\n                count[citation] ++;\\n            }\\n            else{\\n                count[n] ++;\\n            }\\n        }\\n\\n        int accumualtion = 0;\\n        for(int i = n; i >= 1; i --){\\n            accumualtion += count[i];\\n            if(i <= accumualtion){\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71032,
                "title": "simple-o-n-python-code-with-explanation",
                "content": "H-index is at most the number of papers, which is len(citations) . keep a list of length len(citations)+1, and at each index i, record the number of papers with citations exactly i (except for the last index, which records number of papers with citations >= i). After constructing such list, scan the list from the back, maintain the sum of all encountered number. The sum means how many paper with citation >= the index. If sum>= index, then the index is the h-index.\\n\\n        def hIndex(self, citations):\\n            stat = [0]*(len(citations)+1)\\n            for i in citations:\\n                if i>len(citations):\\n                    i = len(citations)\\n                stat[i] += 1\\n            \\n            sum = 0 \\n            for j in xrange(len(citations), -1, -1):\\n                sum += stat[j]\\n                if sum >= j:\\n                    return j\\n            return 0",
                "solutionTags": [],
                "code": "H-index is at most the number of papers, which is len(citations) . keep a list of length len(citations)+1, and at each index i, record the number of papers with citations exactly i (except for the last index, which records number of papers with citations >= i). After constructing such list, scan the list from the back, maintain the sum of all encountered number. The sum means how many paper with citation >= the index. If sum>= index, then the index is the h-index.\\n\\n        def hIndex(self, citations):\\n            stat = [0]*(len(citations)+1)\\n            for i in citations:\\n                if i>len(citations):\\n                    i = len(citations)\\n                stat[i] += 1\\n            \\n            sum = 0 \\n            for j in xrange(len(citations), -1, -1):\\n                sum += stat[j]\\n                if sum >= j:\\n                    return j\\n            return 0",
                "codeTag": "Python3"
            },
            {
                "id": 71061,
                "title": "ac-java-solution",
                "content": "    public class Solution {\\n        public int hIndex(int[] citations) {\\n            Arrays.sort(citations);\\n            for(int i = 0; i < citations.length; i++) {\\n                if(citations[i] >= citations.length - i) return citations.length - i;\\n            }\\n            return 0;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int hIndex(int[] citations) {\\n            Arrays.sort(citations);\\n            for(int i = 0; i < citations.length; i++) {\\n                if(citations[i] >= citations.length - i) return citations.length - i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3990012,
                "title": "simple-and-intuitive-solution-sort-c",
                "content": "### Intuition behind the approach\\n\\nAccording to the definition of h index, it is the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times. \\n\\nSo if we have any array which is sorted in non decreasing order, the h value for a particular index will be mininmum value of the difference between the total number of publications and i th index and number of number of citations of the ith index. \\n\\n* Initially we\\'ll sort the citations vector to get them in non decreasing order.\\n* Then we\\'ll just iterate over the citations index and for each index, ``` h_index = min(citations[i],m-i) ```  where m is the total number of publications.\\n\\n```\\n    int hIndex(vector<int>& citations) {\\n        sort(citations.begin(),citations.end());\\n        int h_index = 0;\\n        const int m = citations.size();\\n        for(int i=0;i<m;++i){\\n            h_index = max(h_index,min(citations[i],m-i));\\n        }\\n        return h_index;\\n    }\\n\\n```\\n\\nPlease upvote if it helped you! And also comment if you have any questions or modifications. It helps me as well!",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "``` h_index = min(citations[i],m-i) ```\n```\\n    int hIndex(vector<int>& citations) {\\n        sort(citations.begin(),citations.end());\\n        int h_index = 0;\\n        const int m = citations.size();\\n        for(int i=0;i<m;++i){\\n            h_index = max(h_index,min(citations[i],m-i));\\n        }\\n        return h_index;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3945230,
                "title": "2-java-solutions-beats-100-users-with-java",
                "content": "# Method 1\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirstly, I have created an Frequency array to Store the quantity of Papers. Then I traverse from last to frquency array till i did not get the count of papers Quantity greater or equal to Number of Papers(Current Index).\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n       int n = citations.length;\\n       int[]freq = new int[n+1];\\n\\n       for(int i=0;i<n;i++){\\n           if(citations[i]>citations.length){\\n               freq[citations.length]++;\\n           }else{\\n               freq[citations[i]]++;\\n           }\\n       }\\n        int cCount =0;\\n        for(int i=n;i>=0;i--){\\n            cCount+=freq[i];\\n            if(cCount>=i){\\n                return i;\\n            }\\n        }\\n\\n        return 0;\\n    }\\n\\n\\n}\\n```\\n\\n# Method 2\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Sort the Arrays first\\n2. Check each index till count of papers left `(n-currentIndex)`\\n\\n# Complexity\\n- Time complexity:$$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nclass Solution {\\n     \\n      public int hIndex(int[] citations){\\n\\n         Arrays.sort(citations);\\n         int n = citations.length;\\n       \\n         int idx = 0 ;\\n\\n         while(idx < n &&  n-idx >citations[idx]){\\n             idx++;\\n         }\\n\\n    return n-idx;\\n\\n   }\\n\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n       int n = citations.length;\\n       int[]freq = new int[n+1];\\n\\n       for(int i=0;i<n;i++){\\n           if(citations[i]>citations.length){\\n               freq[citations.length]++;\\n           }else{\\n               freq[citations[i]]++;\\n           }\\n       }\\n        int cCount =0;\\n        for(int i=n;i>=0;i--){\\n            cCount+=freq[i];\\n            if(cCount>=i){\\n                return i;\\n            }\\n        }\\n\\n        return 0;\\n    }\\n\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3775124,
                "title": "o-n-time-complexity",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$ \\n\\n- Space complexity: $$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\n    // citations means quality and index of array means quantity, x quality is h index if there are more than x papers\\n    // with atleast x quality.\\n    public int hIndex(int[] citations) {\\n        int n = citations.length;\\n        int[] freq = new int[n + 1];\\n        for(int num : citations){\\n            if(num > n) freq[n]++;\\n            else{\\n                freq[num]++;\\n            }\\n        }\\n        int sum = 0;\\n        for(int i = n; i >= 0; i--){\\n            sum += freq[i];\\n            if(sum >= i) return i;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution {\\n    // citations means quality and index of array means quantity, x quality is h index if there are more than x papers\\n    // with atleast x quality.\\n    public int hIndex(int[] citations) {\\n        int n = citations.length;\\n        int[] freq = new int[n + 1];\\n        for(int num : citations){\\n            if(num > n) freq[n]++;\\n            else{\\n                freq[num]++;\\n            }\\n        }\\n        int sum = 0;\\n        for(int i = n; i >= 0; i--){\\n            sum += freq[i];\\n            if(sum >= i) return i;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3755376,
                "title": "simple-and-easy-to-understand-python-solution-with-98-runtime-and-57-memory-beat",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        citations.sort()\\n        n = len(citations)\\n        h = 0\\n\\n        if n == 1 and citations[0] == 0:\\n            return 0\\n        else:\\n            for i in range(n):\\n                if citations[i] < n - i:\\n                   h = citations[i]\\n                else:\\n                    h = max(h, n-i)\\n            return h\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        citations.sort()\\n        n = len(citations)\\n        h = 0\\n\\n        if n == 1 and citations[0] == 0:\\n            return 0\\n        else:\\n            for i in range(n):\\n                if citations[i] < n - i:\\n                   h = citations[i]\\n                else:\\n                    h = max(h, n-i)\\n            return h\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3744147,
                "title": "most-easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n    sort(citations.rbegin(), citations.rend());\\n    int h = 0;\\n    while (h < citations.size() && citations[h] > h) {\\n        h++;\\n    }\\n    return h;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n    sort(citations.rbegin(), citations.rend());\\n    int h = 0;\\n    while (h < citations.size() && citations[h] > h) {\\n        h++;\\n    }\\n    return h;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224563,
                "title": "100-faster-then-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# store the freq.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n# using loop\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n# O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# O(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n      int n = citations.size();  \\n      vector<int> dp(n+1,0);\\n      for(int i=0;i<n;i++){\\n          if(citations[i] > n) dp[n]++; \\n          else dp[citations[i]]++;\\n      }\\n      int sum=0;\\n      for(int i=n;i>=0;i--){\\n          sum+=dp[i];\\n          if(i <= sum)\\n            return i;\\n      }\\n      return -1;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n      int n = citations.size();  \\n      vector<int> dp(n+1,0);\\n      for(int i=0;i<n;i++){\\n          if(citations[i] > n) dp[n]++; \\n          else dp[citations[i]]++;\\n      }\\n      int sum=0;\\n      for(int i=n;i>=0;i--){\\n          sum+=dp[i];\\n          if(i <= sum)\\n            return i;\\n      }\\n      return -1;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2793205,
                "title": "simple-java-solution-binary-search-n-log-n",
                "content": "```\\nclass Solution {\\n    public int find(int[]nums, int mid){\\n        int count = 0;\\n        for(int ele : nums){\\n            if(ele >= mid){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n    public int hIndex(int[] citations) {\\n        int low = 1;\\n        int high = citations.length;\\n        int ans = 0;\\n        while(low <= high){\\n            int mid = low + (high - low)/2;\\n            int k = find(citations, mid);\\n            if(k >= mid){\\n                ans = mid;\\n                low = mid + 1;\\n            }\\n            else{\\n                high = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int find(int[]nums, int mid){\\n        int count = 0;\\n        for(int ele : nums){\\n            if(ele >= mid){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n    public int hIndex(int[] citations) {\\n        int low = 1;\\n        int high = citations.length;\\n        int ans = 0;\\n        while(low <= high){\\n            int mid = low + (high - low)/2;\\n            int k = find(citations, mid);\\n            if(k >= mid){\\n                ans = mid;\\n                low = mid + 1;\\n            }\\n            else{\\n                high = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1738248,
                "title": "simple-python-counting-sort-o-n-solution-with-explanation",
                "content": "```\\n# Counting sort. Why? Number value range correlates with index.\\n# Given n papers, max H index is n. Have an additional one bucket to store all \\n# papers that have > n citations. To align array index number with citation value, add one \\n# more bucket. So total n+2 bucket. Then loop from index n to 0, accumulate the citation value\\n# along the way. If citations[i] >= i, i is the resulting max H index. \\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        n = len(citations)\\n        arr = [0] * (n + 2)\\n        for i in range(n):\\n            if citations[i] > n:\\n                arr[n + 1] += 1\\n            else:\\n                arr[citations[i]] += 1\\n            \\n        accSum = arr[n + 1]\\n        # iterate in reversed order from the last second one\\n        for i in range(n, -1, -1):\\n            accSum += arr[i]\\n            if accSum >= i:\\n                return i\\n        return 0\\n```",
                "solutionTags": [
                    "Python",
                    "Counting Sort"
                ],
                "code": "```\\n# Counting sort. Why? Number value range correlates with index.\\n# Given n papers, max H index is n. Have an additional one bucket to store all \\n# papers that have > n citations. To align array index number with citation value, add one \\n# more bucket. So total n+2 bucket. Then loop from index n to 0, accumulate the citation value\\n# along the way. If citations[i] >= i, i is the resulting max H index. \\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        n = len(citations)\\n        arr = [0] * (n + 2)\\n        for i in range(n):\\n            if citations[i] > n:\\n                arr[n + 1] += 1\\n            else:\\n                arr[citations[i]] += 1\\n            \\n        accSum = arr[n + 1]\\n        # iterate in reversed order from the last second one\\n        for i in range(n, -1, -1):\\n            accSum += arr[i]\\n            if accSum >= i:\\n                return i\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1605037,
                "title": "counting-sort-with-a-really-simple-explanation",
                "content": "This solution is an optimization of the worst-case solution i.e. simply running a linear search for each h-index to find the number of elements that are greater than or equal to it.\\n\\nFor instance, in our O(N^2) solution we do a linear search on each possible h-index 1 ~ array.length:\\n\\n\\n**idx = 1\\nnum_citations_greater_or_equal = 4\\nisPossibleSolution = true**\\n\\n**idx = 2\\nnum_citations_greater_or_equal = 3\\nisPossibleSolution = true**\\n\\n**idx = 3\\nnum_citations_greater_or_equal = 3\\nisPossibleSolution = true**\\n\\n**idx = 4\\nnum_citations_greater_or_equal = 2\\nisPossibleSolution = false**\\n\\n**idx = 5\\nnum_citations_greater_or_equal = 1\\nisPossibleSolution = false**\\n\\n\\nThis solution is exactly the same thing, except we pre-process the counts ahead of time - placing the values at their associated index.\\n\\n**input:  [3, 0, 6, 1, 5]**\\n\\n**index:  [0, 1, 2, 3, 4, 5]**\\n**count:  [1, 1, 0, 1, 0, 2]**\\n**sum  :  [5, 4, 3, 3, 2, 2]**\\n\\nNow, you may be wondering how the count array or sum arra may be useful.ne thing to remember is that we are simply looking for any h-index where at least h papers with h or more citations exist.  This is a confusing explanation, so an example helps:  if h = 2, we need at least 2 or more papers to exist that were cited at least twice.  \\n\\nHow do we do this? \\n\\nWe can simply walk from the end of our count array and compare our running sum with the current h-index (current index in this case).  If our sum, which represents the number of papers with at least h-index citations exists, is >= our index then we have found a solution.  We simply stop at the first value that meets this criteria, because it is the largest possible value.\\n\\n\\n```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        if (citations == null || citations.length == 0) return 0;\\n        \\n        final int MAX_SIZE = citations.length;\\n        int[] count = new int[MAX_SIZE + 1];\\n        int citationSum = 0;\\n        \\n        for (int citation : citations) {\\n            int idx = citation <= MAX_SIZE? citation : MAX_SIZE;\\n            count[idx]++;\\n        }\\n        \\n        for (int i = MAX_SIZE; i >= 0; i--) {\\n            citationSum += count[i];\\n            if (citationSum >= i) return i;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        if (citations == null || citations.length == 0) return 0;\\n        \\n        final int MAX_SIZE = citations.length;\\n        int[] count = new int[MAX_SIZE + 1];\\n        int citationSum = 0;\\n        \\n        for (int citation : citations) {\\n            int idx = citation <= MAX_SIZE? citation : MAX_SIZE;\\n            count[idx]++;\\n        }\\n        \\n        for (int i = MAX_SIZE; i >= 0; i--) {\\n            citationSum += count[i];\\n            if (citationSum >= i) return i;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1457176,
                "title": "h-index-using-sorting-library-c-easy-to-understand",
                "content": "class Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        \\n        //sort the citations(0,1,3,5,6)\\n        sort(citations.begin(),citations.end());\\n        //store citations in n\\n        int n=citations.size();\\n        //create index i\\n        int i;\\n        //iterate the loop \\n        for( i=1;i<=n;i++)\\n            \\n        //if n=6 and i=5 -> 6-5=1 <5 so its break the loop\\n            \\n            if(citations[n-i]<i)\\n                break;\\n        \\n        return i-1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        \\n        //sort the citations(0,1,3,5,6)\\n        sort(citations.begin(),citations.end());\\n        //store citations in n\\n        int n=citations.size();\\n        //create index i\\n        int i;\\n        //iterate the loop \\n        for( i=1;i<=n;i++)\\n            \\n        //if n=6 and i=5 -> 6-5=1 <5 so its break the loop\\n            \\n            if(citations[n-i]<i)\\n                break;\\n        \\n        return i-1;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 785356,
                "title": "c-bucket-sort-o-n",
                "content": "Suppose the author has `N` papers, then the `H-index <= N`. The straightforward approach is to sort with `O(N(logN))`, then count. But this is not fast enough for this problem. The trick for an `O(N)` solution is to sort papers into buckets.\\n\\nAssume we have N buckets, from `0`..`N-1`, one for each paper.\\n* for each paper, if the number of citations `n < N`, put that paper in the `n`-th bucket\\n* if `n >= N`, put that in that `N-1`-th bucket\\nHere is the code:\\n```\\n    int hIndex(vector<int>& citations) {\\n        int N = citations.size();\\n        vector<int> buckets(N+1, 0);\\n\\n        for(int i : citations){\\n            if (i >= N){\\n                buckets[N]++;\\n            } else {\\n                buckets[i]++;\\n            }\\n        }\\n\\n        int count = 0;\\n        for(int i = N; i >= 0; i--){\\n            count += buckets[i];\\n            if(count >= i) {\\n                return i;\\n            }\\n        }\\n\\n        // should not reach here\\n        return 0;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int hIndex(vector<int>& citations) {\\n        int N = citations.size();\\n        vector<int> buckets(N+1, 0);\\n\\n        for(int i : citations){\\n            if (i >= N){\\n                buckets[N]++;\\n            } else {\\n                buckets[i]++;\\n            }\\n        }\\n\\n        int count = 0;\\n        for(int i = N; i >= 0; i--){\\n            count += buckets[i];\\n            if(count >= i) {\\n                return i;\\n            }\\n        }\\n\\n        // should not reach here\\n        return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 693513,
                "title": "python-3-binary-search-sort-iterative-solution",
                "content": "```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        n , left , right = len(citations) , 0 , len(citations)\\n        citations.sort()\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            numGreater = n - mid\\n            if numGreater <= citations[mid]:\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return n - left\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        n , left , right = len(citations) , 0 , len(citations)\\n        citations.sort()\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            numGreater = n - mid\\n            if numGreater <= citations[mid]:\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return n - left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 70954,
                "title": "4-line-nlogn-simple-solution",
                "content": "      int hIndex(vector<int>& citations) {\\n            sort(citations.begin(), citations.end());\\n            const int size_c = citations.size();\\n            for (int i = 0; i < size_c; i++) {\\n                if (citations[i] >= size_c - i) return size_c - i;\\n            }\\n            return 0;\\n        }",
                "solutionTags": [],
                "code": "      int hIndex(vector<int>& citations) {\\n            sort(citations.begin(), citations.end());\\n            const int size_c = citations.size();\\n            for (int i = 0; i < size_c; i++) {\\n                if (citations[i] >= size_c - i) return size_c - i;\\n            }\\n            return 0;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 70997,
                "title": "my-0ms-ac-solution-using-hash-table",
                "content": "    int hIndex(vector<int>& citations) {\\n        int n = citations.size();\\n        if (n == 0) return 0;\\n        int* map = new int[n+1];\\n        memset(map, 0, (n+1)*sizeof(int));\\n        for (int i = 0; i < n; ++i){\\n            if (citations[i] < n) map[citations[i]] += 1;\\n            else map[n] += 1;\\n        }\\n        \\n        int acc = 0;\\n        for (int i = n; i >= 0; --i){\\n            acc += map[i];\\n            if (acc >= i) return i;\\n        }\\n    }",
                "solutionTags": [],
                "code": "    int hIndex(vector<int>& citations) {\\n        int n = citations.size();\\n        if (n == 0) return 0;\\n        int* map = new int[n+1];\\n        memset(map, 0, (n+1)*sizeof(int));\\n        for (int i = 0; i < n; ++i){\\n            if (citations[i] < n) map[citations[i]] += 1;\\n            else map[n] += 1;\\n        }\\n        \\n        int acc = 0;\\n        for (int i = n; i >= 0; --i){\\n            acc += map[i];\\n            if (acc >= i) return i;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 71019,
                "title": "java-o-n-solution",
                "content": "    public class Solution {\\n        public int hIndex(int[] citations) {\\n            int n = citations.length;\\n            int[] indexs = new int[n+1];\\n            for(int i = 0; i < n; i++) {\\n                if(citations[i]>=n) indexs[n]++; \\n                else indexs[citations[i]]++;\\n            }\\n            for(int j = n; j >= 0; j--) {\\n                if(indexs[j] >= j) return j;\\n                if(j!=0) indexs[j-1] += indexs[j];\\n            }\\n            return 0;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int hIndex(int[] citations) {\\n            int n = citations.length;\\n            int[] indexs = new int[n+1];\\n            for(int i = 0; i < n; i++) {\\n                if(citations[i]>=n) indexs[n]++; \\n                else indexs[citations[i]]++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 71054,
                "title": "o-n-c-solution",
                "content": "    class Solution {\\n    public:\\n    int hIndex(vector<int>& cit) {\\n        vector<long> hist(cit.size()+1,0);\\n        for(int i=0;i<cit.size();++i)\\n            ++hist[min<int>(cit.size(),cit[i])];\\n\\n        long cumSum=0;\\n        for(int i=hist.size()-1;i>=0;--i) {\\n            cumSum+=hist[i];\\n            if(cumSum>=i)\\n                return i;\\n        }        \\n        return 0;\\n    }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    int hIndex(vector<int>& cit) {\\n        vector<long> hist(cit.size()+1,0);\\n        for(int i=0;i<cit.size();++i)\\n            ++hist[min<int>(cit.size(),cit[i])];\\n\\n        long cumSum=0;\\n        for(int i=hist.size()-1;i>=0;--i) {\\n            cumSum+=hist[i];\\n            if(cumSum>=i)\\n                return i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3989302,
                "title": "two-easy-code-in-cpp",
                "content": "# Code1\\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        sort(citations.begin(),citations.end());\\n        int n=citations.size();\\n        for(int i=0;i<citations.size();i++){\\n            if(citations[i] >= n){\\n                return n;\\n            }\\n            else{\\n                if(n==1 && citations[i]!=0)\\n                    return 1;\\n                n--;\\n            }\\n        }\\n        return n;\\n    }\\n};\\n```\\n# Code2\\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        unordered_map<int, int>mp;\\n        int maxi=0;\\n        for(int i:citations){\\n            maxi = max(maxi, i);\\n            mp[i]++;\\n        }\\n        int tot=0;\\n        for(int i=maxi;i>=0;i--){\\n            tot += mp[i];\\n            if(tot >= i && i!=0) \\n                return i;\\n        }\\n        return citations.size()-mp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        sort(citations.begin(),citations.end());\\n        int n=citations.size();\\n        for(int i=0;i<citations.size();i++){\\n            if(citations[i] >= n){\\n                return n;\\n            }\\n            else{\\n                if(n==1 && citations[i]!=0)\\n                    return 1;\\n                n--;\\n            }\\n        }\\n        return n;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        unordered_map<int, int>mp;\\n        int maxi=0;\\n        for(int i:citations){\\n            maxi = max(maxi, i);\\n            mp[i]++;\\n        }\\n        int tot=0;\\n        for(int i=maxi;i>=0;i--){\\n            tot += mp[i];\\n            if(tot >= i && i!=0) \\n                return i;\\n        }\\n        return citations.size()-mp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3728231,
                "title": "frequency-array-o-n-time-and-o-n-space",
                "content": "# Intuition\\nCounting the number of occurences would allow us to determine the max h-index. But the range for the possible number of citations is quite large. Since the maximum h-index can only be the length of the citation array all occurences of papers with more than length many citations can be counted together.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Initialize the varible to count papers with large citation counts.\\n2. Initialize the frequency array, include zero.\\n3. Count the occurences of number of citations in citation array.\\n4. To find the maximum h-index, check if the largest possible h-index is an h-index, if not continue.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$. Two linear time loops.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$. The frequency array increases linearly with the length of the citation array.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        citationsAboveH = 0\\n        citationFrequencies = [0] * (len(citations)+1)\\n\\n        for i in range(len(citations)):\\n            if citations[i] > len(citations):\\n                citationsAboveH += 1 \\n            else:\\n                citationFrequencies[citations[i]] += 1\\n\\n        qualifyingPapers = citationsAboveH\\n        for h in range(len(citations), 0, -1):\\n            qualifyingPapers += citationFrequencies[h]\\n            if qualifyingPapers >= h:\\n                return h\\n        \\n        return 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        citationsAboveH = 0\\n        citationFrequencies = [0] * (len(citations)+1)\\n\\n        for i in range(len(citations)):\\n            if citations[i] > len(citations):\\n                citationsAboveH += 1 \\n            else:\\n                citationFrequencies[citations[i]] += 1\\n\\n        qualifyingPapers = citationsAboveH\\n        for h in range(len(citations), 0, -1):\\n            qualifyingPapers += citationFrequencies[h]\\n            if qualifyingPapers >= h:\\n                return h\\n        \\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3686346,
                "title": "very-very-easy-solution-o-n",
                "content": "# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int HIndex(int[] citations) {\\n        Array.Sort(citations, new Comparison<int>((i1, i2) => i2.CompareTo(i1)));\\n            for (int i = 0; i < citations.Length; i++)\\n                if (citations[i] < i + 1)\\n                    return i;\\n\\n            return citations.Length; \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int HIndex(int[] citations) {\\n        Array.Sort(citations, new Comparison<int>((i1, i2) => i2.CompareTo(i1)));\\n            for (int i = 0; i < citations.Length; i++)\\n                if (citations[i] < i + 1)\\n                    return i;\\n\\n            return citations.Length; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3676377,
                "title": "faster-than-100-sc-o-1-easy-to-understand",
                "content": "# Intuition\\nBrute force approach regardless of sorting the array and compare with position\\n\\n# Approach\\nSort the array in descending order then compare with the position of the element if position is less than equal to element then increase the count..\\nFor e.g. arr[]={4,3,2} the 4 belong to the the index 0 i.e. at place 1 which means (index+1)... \\nIf arr[i]>=arr[i+1] then it considered to be count...\\n\\n# Complexity\\n- Time complexity:\\n# **O(nlogn)+o(n)-->O(nlogn)**\\n\\n- Space complexity:\\n# **O(1)**\\n\\n# Code\\n//There is two solution for the given problem\\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        int count=0,val=1;\\n        sort(citations.begin(),citations.end(),greater<int>());\\n        for(int i=0;i<citations.size();i++)\\n        {\\n            if(citations[i]>=val)\\n            {\\n                count++;\\n            }\\n            val=val+1;//increment every time\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n//Second Solution will be \\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        int mini=0,maxi=INT_MIN;\\n        sort(citations.begin(),citations.end(),greater<int>());\\n        for(int i=0;i<citations.size();i++)\\n        {\\n            mini=min(citations[i],i+1);\\n            maxi=max(maxi,mini);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        int count=0,val=1;\\n        sort(citations.begin(),citations.end(),greater<int>());\\n        for(int i=0;i<citations.size();i++)\\n        {\\n            if(citations[i]>=val)\\n            {\\n                count++;\\n            }\\n            val=val+1;//increment every time\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        int mini=0,maxi=INT_MIN;\\n        sort(citations.begin(),citations.end(),greater<int>());\\n        for(int i=0;i<citations.size();i++)\\n        {\\n            mini=min(citations[i],i+1);\\n            maxi=max(maxi,mini);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624671,
                "title": "count-sort-o-n-classical-overlapping-interval-problem",
                "content": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        int n = citations.size(); \\n        vector<int> f(1002);\\n\\n        for(int i=0; i<n; i++) {\\n            f[0]++;\\n            f[citations[i]+1]--;\\n        }\\n\\n        int h_index = 0;\\n        int accumulate = 0;\\n\\n        for (int i=0; i<1002; i++) {\\n            accumulate += f[i];\\n            if (accumulate >= i) h_index = i;\\n        }\\n\\n        return h_index;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        int n = citations.size(); \\n        vector<int> f(1002);\\n\\n        for(int i=0; i<n; i++) {\\n            f[0]++;\\n            f[citations[i]+1]--;\\n        }\\n\\n        int h_index = 0;\\n        int accumulate = 0;\\n\\n        for (int i=0; i<1002; i++) {\\n            accumulate += f[i];\\n            if (accumulate >= i) h_index = i;\\n        }\\n\\n        return h_index;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496403,
                "title": "easy-solution-by-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        int n = citations.size();\\n        sort(citations.begin(), citations.end());\\n        int ans = 0;\\n        for(int i = 0; i < n; i++){\\n            if((n - i) >= citations[i]){\\n                ans = citations[i];\\n            }\\n            else{\\n                ans = max(ans, n - i);\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        int n = citations.size();\\n        sort(citations.begin(), citations.end());\\n        int ans = 0;\\n        for(int i = 0; i < n; i++){\\n            if((n - i) >= citations[i]){\\n                ans = citations[i];\\n            }\\n            else{\\n                ans = max(ans, n - i);\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3474203,
                "title": "typescript-javascript-oneliner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSort and filter the array and extract the length.\\n\\n# Code\\n```\\nfunction hIndex(citations: number[]): number {\\n    return citations.sort((a,b) => b-a).filter((x,i) => x > i).length \\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction hIndex(citations: number[]): number {\\n    return citations.sort((a,b) => b-a).filter((x,i) => x > i).length \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2738305,
                "title": "java-solution-understanding-problem-watch-yt-video",
                "content": "# class Solution {\\n    public int hIndex(int[] citations) {\\n        Arrays.sort(citations);\\n        int n=citations.length;\\n        int index=0;\\n           while(index<n && citations[index]<n-index)\\n           {\\n               index++;\\n           }\\n        return n-index;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int hIndex(int[] citations) {\\n        Arrays.sort(citations);\\n        int n=citations.length;\\n        int index=0;\\n           while(index<n && citations[index]<n-index)\\n           {\\n               index++;\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 2617728,
                "title": "very-easy-c-solution-very-fast",
                "content": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& c) \\n    {\\n        int ans=0;\\n        sort(c.begin(),c.end());\\n        for(int i=c.size()-1;i>=0;i--)\\n        {\\n            if(c[i]>=c.size()-i)\\n            {\\n                 ans++;\\n            }  \\n        }\\n        return ans;\\n    }\\n};\\n//Please upvote if you find the solution useful.\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& c) \\n    {\\n        int ans=0;\\n        sort(c.begin(),c.end());\\n        for(int i=c.size()-1;i>=0;i--)\\n        {\\n            if(c[i]>=c.size()-i)\\n            {\\n                 ans++;\\n            }  \\n        }\\n        return ans;\\n    }\\n};\\n//Please upvote if you find the solution useful.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2336982,
                "title": "simple-c-solution-0ms-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        sort(citations.begin(),citations.end(),greater<int>());\\n        int ans=0;\\n        for(int i=0;i<citations.size();i++){\\n            if(citations[i]>=i+1) ans=i+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        sort(citations.begin(),citations.end(),greater<int>());\\n        int ans=0;\\n        for(int i=0;i<citations.size();i++){\\n            if(citations[i]>=i+1) ans=i+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2228457,
                "title": "simple-sort",
                "content": "```\\nvar hIndex = function(citations) {\\n    citations.sort((a,b)=>b-a)\\n    let i=0\\n    while(citations[i]>i) i++\\n    \\n    return i\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar hIndex = function(citations) {\\n    citations.sort((a,b)=>b-a)\\n    let i=0\\n    while(citations[i]>i) i++\\n    \\n    return i\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1988187,
                "title": "c-clean-and-simple-binary-search-solution",
                "content": "class Solution {\\npublic:\\n    \\n    bool isValid(vector<int> &v,int mid){\\n        int count  = 0;\\n        for(auto x:v){\\n            if(x>=mid) count++;\\n        }\\n\\n    return count>=mid;\\n}\\n\\n    \\n    int hIndex(vector<int>& v) {\\n    \\n        int high = *max_element(v.begin(),v.end());\\n        int low = 1;\\n        int ans = 0;\\n\\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n            if(isValid(v,mid)){\\n                ans = mid;\\n                low = mid+1;\\n            }\\n            else high = mid-1;\\n        }   \\n        return ans; \\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    bool isValid(vector<int> &v,int mid){\\n        int count  = 0;\\n        for(auto x:v){\\n            if(x>=mid) count++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 786005,
                "title": "0-ms-and-o-1-space-soln",
                "content": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) { \\n        sort(citations.begin(),citations.end());\\n        int n=citations.size();\\n          if(n==0||citations[n-1]==0){return 0;}\\n     \\n      for(int i=0;i<n;i++)\\n        { if(n-i-1<citations[i]){return n-i;}   }\\n       \\n\\t   return 0;}\\n};\\n```\\n\\none more soln\\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& cit) {\\n    priority_queue<int, vector<int>, greater<int>> pq(begin(cit), end(cit));\\n    while (!pq.empty() && pq.top() < pq.size())\\n        pq.pop();\\n    return pq.size();\\n}\\n};\\n```\\n\\n\\nhappy coding :)\\nplease upvote",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) { \\n        sort(citations.begin(),citations.end());\\n        int n=citations.size();\\n          if(n==0||citations[n-1]==0){return 0;}\\n     \\n      for(int i=0;i<n;i++)\\n        { if(n-i-1<citations[i]){return n-i;}   }\\n       \\n\\t   return 0;}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& cit) {\\n    priority_queue<int, vector<int>, greater<int>> pq(begin(cit), end(cit));\\n    while (!pq.empty() && pq.top() < pq.size())\\n        pq.pop();\\n    return pq.size();\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 693431,
                "title": "simple-binary-search",
                "content": "```java\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        Arrays.sort(citations);\\n        int n = citations.length, l = 0, r = n - 1, result = 0;\\n        while (l <= r) {\\n            int mid = l + ((r - l) >> 1);\\n            int distance = n - mid;\\n            if (distance <= citations[mid]) {\\n                result = Math.max(result, distance);\\n                r = mid - 1;\\n            }\\n            else\\n                l = mid + 1;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        Arrays.sort(citations);\\n        int n = citations.length, l = 0, r = n - 1, result = 0;\\n        while (l <= r) {\\n            int mid = l + ((r - l) >> 1);\\n            int distance = n - mid;\\n            if (distance <= citations[mid]) {\\n                result = Math.max(result, distance);\\n                r = mid - 1;\\n            }\\n            else\\n                l = mid + 1;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 693375,
                "title": "short-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& c) {\\n        sort(c.begin(),c.end());\\n        int n=c.size(),l=0,h=n;\\n        while(l<h)\\n        {\\n            auto mid=(l+h)/2;\\n            if(c[mid]<n-mid) l=mid+1;\\n            else h=mid;\\n        }\\n        return n-l;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& c) {\\n        sort(c.begin(),c.end());\\n        int n=c.size(),l=0,h=n;\\n        while(l<h)\\n        {\\n            auto mid=(l+h)/2;\\n            if(c[mid]<n-mid) l=mid+1;\\n            else h=mid;\\n        }\\n        return n-l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 149341,
                "title": "java-very-easy-to-understand",
                "content": "```java\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        if(citations==null|| citations.length==0) return 0;  \\n        Arrays.sort(citations);\\n        int len = citations.length;\\n        int hIndex = 0;\\n        for (int i= 0; i<len; i++){\\n            if(citations[i]>=len-i){\\n                hIndex = len-i;\\n                break;\\n            }\\n        }\\n        return hIndex;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        if(citations==null|| citations.length==0) return 0;  \\n        Arrays.sort(citations);\\n        int len = citations.length;\\n        int hIndex = 0;\\n        for (int i= 0; i<len; i++){\\n            if(citations[i]>=len-i){\\n                hIndex = len-i;\\n                break;\\n            }\\n        }\\n        return hIndex;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 70900,
                "title": "o-n-1ms-solution-with-extra-space",
                "content": "This solution is inspired by skoy12 (https://leetcode.com/discuss/105676/o-n-with-java-1-ms). One modification is that the h-index can be at most n, the length of array. So I change \\n\"sum = Math.max(i, sum - hindex[i]); \" into just \"return i\".\\n\\n    public int hIndex(int[] citations) {\\n    int n = citations.length;\\n    if (n == 0) return 0;\\n    int[] hindex = new int[n + 1];\\n    for(int val: citations){\\n        if(val >= n) hindex[n]++;\\n        else hindex[val]++;\\n    }\\n    int sum = 0;\\n    int i = n;\\n    while (i > 0) {\\n        sum += hindex[i];\\n        if (i <= sum) return i;\\n        i--;\\n    }\\n    return 0;\\n   }",
                "solutionTags": [
                    "Java"
                ],
                "code": "This solution is inspired by skoy12 (https://leetcode.com/discuss/105676/o-n-with-java-1-ms). One modification is that the h-index can be at most n, the length of array. So I change \\n\"sum = Math.max(i, sum - hindex[i]); \" into just \"return i\".\\n\\n    public int hIndex(int[] citations) {\\n    int n = citations.length;\\n    if (n == 0) return 0;\\n    int[] hindex = new int[n + 1];\\n    for(int val: citations){\\n        if(val >= n) hindex[n]++;\\n        else hindex[val]++;\\n    }\\n    int sum = 0;\\n    int i = n;\\n    while (i > 0) {\\n        sum += hindex[i];\\n        if (i <= sum) return i;\\n        i--;\\n    }\\n    return 0;\\n   }",
                "codeTag": "Unknown"
            },
            {
                "id": 70911,
                "title": "java-o-n-solution-1ms",
                "content": "The thinking is, if an author has N papers, then his/her h-index cannot be higher than N.\\nThat means we only need to have an array with size N + 1, the index of which records the citation number. If the citation number > N, i.e, one of his 5 papers was referenced 100 times, then this credit goes to citation N.\\nIn the first pass, we can build the freq array with the number of papers in each citation bucket.\\nThen the 2nd pass, we iterate from tail to head, add all the citations backwards until freq[i] > i, then return i.\\n\\n    public int hIndex(int[] citations) {\\n        if(citations == null || citations.length == 0)\\n            return 0;\\n\\n        int N = citations.length;\\n        int[] freq = new int[N+1];\\n        for(int i=0;i<N;i++){\\n            if(citations[i] == 0)\\n                continue;\\n            if(citations[i] > N)\\n                freq[N]++;\\n            else\\n                freq[citations[i]]++;\\n        }\\n        \\n        for(int i=N;i>0;i--){\\n            if(i < N){\\n                freq[i] = freq[i] + freq[i+1];\\n            }\\n            if(freq[i] >= i)\\n                return i;\\n        }\\n        return 0;\\n    }",
                "solutionTags": [],
                "code": "The thinking is, if an author has N papers, then his/her h-index cannot be higher than N.\\nThat means we only need to have an array with size N + 1, the index of which records the citation number. If the citation number > N, i.e, one of his 5 papers was referenced 100 times, then this credit goes to citation N.\\nIn the first pass, we can build the freq array with the number of papers in each citation bucket.\\nThen the 2nd pass, we iterate from tail to head, add all the citations backwards until freq[i] > i, then return i.\\n\\n    public int hIndex(int[] citations) {\\n        if(citations == null || citations.length == 0)\\n            return 0;\\n\\n        int N = citations.length;\\n        int[] freq = new int[N+1];\\n        for(int i=0;i<N;i++){\\n            if(citations[i] == 0)\\n                continue;\\n            if(citations[i] > N)\\n                freq[N]++;\\n            else\\n                freq[citations[i]]++;\\n        }\\n        \\n        for(int i=N;i>0;i--){\\n            if(i < N){\\n                freq[i] = freq[i] + freq[i+1];\\n            }\\n            if(freq[i] >= i)\\n                return i;\\n        }\\n        return 0;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 70934,
                "title": "using-sorting-really-small-solution",
                "content": "We can optimize this from O(n) to O(logn) (leaving aside the time complexity of sorting)   by travelling the array as a binary tree using mid, low and high\\n\\n    public int hIndex(int[] a) {\\n                if(a==null)\\n                    return 0;\\n                Arrays.sort(a);\\n                int len = a.length;\\n                int i = len-1, h = 1, hMax = 0;\\n                while(i >= 0){\\n                    if(h <= a[i] && h == len-i){\\n                        hMax = Math.max(h, hMax);\\n                    }\\n                    h++; i--;\\n                }\\n                return hMax;\\n            }",
                "solutionTags": [
                    "Java"
                ],
                "code": "We can optimize this from O(n) to O(logn) (leaving aside the time complexity of sorting)   by travelling the array as a binary tree using mid, low and high\\n\\n    public int hIndex(int[] a) {\\n                if(a==null)\\n                    return 0;\\n                Arrays.sort(a);\\n                int len = a.length;\\n                int i = len-1, h = 1, hMax = 0;\\n                while(i >= 0){\\n                    if(h <= a[i] && h == len-i){\\n                        hMax = Math.max(h, hMax);\\n                    }\\n                    h++; i--;\\n                }\\n                return hMax;\\n            }",
                "codeTag": "Unknown"
            },
            {
                "id": 70943,
                "title": "binary-search-in-python-with-explanation",
                "content": "My idea is using binary search.\\n\\n\\n 1. Suppose we have a list of citation [3,0,6,1,5]. First, sort the\\n   citation in decreasing order --> [6,5,3,1,0] \\n 2. Now it is obvious that we need to find the one whose number of citation is just >= its\\n   index+1 (citations[i] >= i+1), and those who is after this element,\\n   the number of citation should <= its index + 1(citations[i] < i+1). \\n   This is because, if we look from left to right, the index+1 shows us\\n   how many elements appears for now,  and we want to find how many\\n   elements whose number of citation > the number of those elements. \\n\\n 3. Therefore, using binary search. Reduce the size of list by comparing\\n   citations[mid] with mid+1\\n\\n========================================================================\\n\\n    def hIndex(self, citations):\\n        \"\"\"\\n        :type citations: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if citations == []:\\n            return 0\\n        citations.sort(reverse = True)\\n        end = len(citations) - 1\\n        start = 0\\n        while start < end - 1:\\n            mid = (start + end) / 2\\n            if citations[mid] < mid + 1: # cut the right part and remain left part\\n                end = mid\\n            elif citations[mid] == mid + 1: # just the answer\\n                return mid+1\\n            else: # remain the right part\\n                start = mid\\n        # If only two elements left, check if all the citation>=index+1 or h-index=0 or just around the boundary\\n        if citations[end] >= end + 1:\\n            return end + 1\\n        elif citations[start] < start + 1:\\n                return 0\\n        else:\\n            return start + 1",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "My idea is using binary search.\\n\\n\\n 1. Suppose we have a list of citation [3,0,6,1,5]. First, sort the\\n   citation in decreasing order --> [6,5,3,1,0] \\n 2. Now it is obvious that we need to find the one whose number of citation is just >= its\\n   index+1 (citations[i] >= i+1), and those who is after this element,\\n   the number of citation should <= its index + 1(citations[i] < i+1). \\n   This is because, if we look from left to right, the index+1 shows us\\n   how many elements appears for now,  and we want to find how many\\n   elements whose number of citation > the number of those elements. \\n\\n 3. Therefore, using binary search. Reduce the size of list by comparing\\n   citations[mid] with mid+1\\n\\n========================================================================\\n\\n    def hIndex(self, citations):\\n        \"\"\"\\n        :type citations: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if citations == []:\\n            return 0\\n        citations.sort(reverse = True)\\n        end = len(citations) - 1\\n        start = 0\\n        while start < end - 1:\\n            mid = (start + end) / 2\\n            if citations[mid] < mid + 1: # cut the right part and remain left part\\n                end = mid\\n            elif citations[mid] == mid + 1: # just the answer\\n                return mid+1\\n            else: # remain the right part\\n                start = mid\\n        # If only two elements left, check if all the citation>=index+1 or h-index=0 or just around the boundary\\n        if citations[end] >= end + 1:\\n            return end + 1\\n        elif citations[start] < start + 1:\\n                return 0\\n        else:\\n            return start + 1",
                "codeTag": "Python3"
            },
            {
                "id": 70964,
                "title": "javascript-solution",
                "content": "    function hIndex(citations) {\\n      var map = {};\\n      var h = citations.length;\\n      var i = 0;\\n      var max = 0;\\n      citations.map(c => map[c] = map[c] ? map[c] + 1 : 1);\\n      for (; i <= h; i++) {\\n        max = Math.max(max, h >= i ? i : 0);\\n        h -= map[i] ? map[i] : 0;\\n      }\\n      return max;\\n    }",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    function hIndex(citations) {\\n      var map = {};\\n      var h = citations.length;\\n      var i = 0;\\n      var max = 0;\\n      citations.map(c => map[c] = map[c] ? map[c] + 1 : 1);\\n      for (; i <= h; i++) {\\n        max = Math.max(max, h >= i ? i : 0);\\n        h -= map[i] ? map[i] : 0;\\n      }\\n      return max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 70985,
                "title": "java-1ms-o-n-solution-using-counting-sort",
                "content": "    \\n    public int hIndex(int[] citations) {\\n        int n = citations.length;\\n        int[] count = new int[n+1];\\n        for (int i = 0; i < n; i++) {\\n            if (citations[i] > n) count[n]++;\\n            else count[citations[i]]++;\\n        }\\n        for (int i = n; i > 0; i--) {\\n            if (count[i] >= i) return i;\\n            count[i-1] += count[i];\\n        }\\n        return 0;\\n    }",
                "solutionTags": [],
                "code": "    \\n    public int hIndex(int[] citations) {\\n        int n = citations.length;\\n        int[] count = new int[n+1];\\n        for (int i = 0; i < n; i++) {\\n            if (citations[i] > n) count[n]++;\\n            else count[citations[i]]++;\\n        }\\n        for (int i = n; i > 0; i--) {\\n            if (count[i] >= i) return i;\\n            count[i-1] += count[i];\\n        }\\n        return 0;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 70986,
                "title": "4ms-c-without-sort-beats-100",
                "content": "    int hIndex(vector<int>& citations) {\\n            if (citations.empty())\\n                return 0;\\n            vector<int> count(citations.size()+1, 0); // record 0-size\\n            for (int i = 0; i < citations.size(); ++i)\\n            {\\n                count[citations[i] < count.size() ? citations[i] : count.size() - 1]++;\\n            }\\n            int sum = 0;\\n            for (int j = count.size() - 1; j >= 0; --j)\\n            {\\n                sum += count[j];\\n                if (j <= sum)\\n                    return j;\\n            }\\n            return 0;\\n        }",
                "solutionTags": [],
                "code": "    int hIndex(vector<int>& citations) {\\n            if (citations.empty())\\n                return 0;\\n            vector<int> count(citations.size()+1, 0); // record 0-size\\n            for (int i = 0; i < citations.size(); ++i)\\n            {\\n                count[citations[i] < count.size() ? citations[i] : count.size() - 1]++;\\n            }\\n            int sum = 0;\\n            for (int j = count.size() - 1; j >= 0; --j)\\n            {\\n                sum += count[j];\\n                if (j <= sum)\\n                    return j;\\n            }\\n            return 0;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 70989,
                "title": "c-solution-sort-first-and-hash-table",
                "content": "sort first\\n\\n    static bool myfun(int a, int b)\\n    {\\n    \\treturn a > b; \\n    }\\n    int hIndex(vector<int>& cit) \\n    {\\n    \\tif (!cit.size())\\n    \\t\\treturn 0;\\n    \\tint sz = cit.size();\\n    \\tsort(cit.begin(), cit.end(), myfun);\\n    \\tint i;\\n    \\tfor (i = 0; i < sz && (cit[i] >= i + 1); ++i);\\n    \\treturn i;\\n    }\\n\\nhash table\\n\\n    int hIndex(vector<int>& cit)\\n    {\\n    \\tif (!cit.size())\\n    \\t\\treturn 0;\\n    \\tint sz = cit.size();\\n    \\tvector<int> table(sz + 1);\\n    \\tint i, sum = 0;\\n    \\tfor (i = 0; i < sz; ++i)\\n    \\t{\\n    \\t\\tif (cit[i] >= sz)\\n    \\t\\t\\t++table[sz];\\n    \\t\\telse\\n    \\t\\t\\t++table[cit[i]];\\n    \\t}\\n    \\tfor (i = sz; i >= 0; --i)\\n    \\t{\\n    \\t\\tsum += table[i];\\n    \\t\\tif (sum >= i)\\n    \\t\\t\\tbreak;\\n    \\t}\\n    \\treturn i;\\n    }",
                "solutionTags": [
                    "Hash Table"
                ],
                "code": "sort first\\n\\n    static bool myfun(int a, int b)\\n    {\\n    \\treturn a > b; \\n    }\\n    int hIndex(vector<int>& cit) \\n    {\\n    \\tif (!cit.size())\\n    \\t\\treturn 0;\\n    \\tint sz = cit.size();\\n    \\tsort(cit.begin(), cit.end(), myfun);\\n    \\tint i;\\n    \\tfor (i = 0; i < sz && (cit[i] >= i + 1); ++i);\\n    \\treturn i;\\n    }\\n\\nhash table\\n\\n    int hIndex(vector<int>& cit)\\n    {\\n    \\tif (!cit.size())\\n    \\t\\treturn 0;\\n    \\tint sz = cit.size();\\n    \\tvector<int> table(sz + 1);\\n    \\tint i, sum = 0;\\n    \\tfor (i = 0; i < sz; ++i)\\n    \\t{\\n    \\t\\tif (cit[i] >= sz)\\n    \\t\\t\\t++table[sz];\\n    \\t\\telse\\n    \\t\\t\\t++table[cit[i]];\\n    \\t}\\n    \\tfor (i = sz; i >= 0; --i)\\n    \\t{\\n    \\t\\tsum += table[i];\\n    \\t\\tif (sum >= i)\\n    \\t\\t\\tbreak;\\n    \\t}\\n    \\treturn i;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 70992,
                "title": "detailed-explanation-and-my-3-line-sample-python-code",
                "content": "Most important of all: The definition.\\n\\n\"A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\"\\n\\nSo the observation is: If I `sort` the *citations*, then the `idx`-element in the sorted array means `there are at least N-idx papers have citations count more than or equal to citations[idx]`\\n\\nFor example, \\n\\n               idx:  0 1 2 3 4\\n             N-idx:  5 4 3 2 1\\n    citations[idx]:  0 1 3 5 6\\n\\n - For idx == 0, it means there are at least 5 papers have citations count more than or equal to 0\\n - For idx == 3, it means there are at least 3 papers have citations count more than or equal to 3\\n - For idx == 4, it means there are at least 1 papers have citations count more than or equal to 6\\n\\nBut how do we connect it to the definition, which said that it want h papers with at least h citations?\\nThe answer is that  we can further modify the observation to\\n\\n `there are at least N-idx papers have citations count more than or equal to min(N-idx, citations[idx])`\\n\\nWhy? I actually notice this transformation when I failed with the case [100], which follow by what I observed could be:\\n\\n - For idx == 0, it means there are at least 1 papers have citations count more than or equal to 100\\n\\nIt's right, but from the definition, h papers with at least h citations, h could not be 100, instead, it should be 1!!\\n\\nAnd the answer would be the largest value for `min(N-idx, citations[idx])` in each idx!\\nSo, that's pretty much how I think of this problem, hope it helps you!\\n\\nSample Python Code:\\n\\n    def hIndex(self, citations):\\n        citations.sort()\\n        comparePairs = zip([len(citations)-i for i in range(len(citations))], citations)\\n        return max([min(p) for p in comparePairs]) if citations else 0\\n\\nor\\n\\n    def hIndex(self, citations):\\n        citations.sort()\\n        maxh, lc = 0, len(citations)\\n        for i, n in enumerate(citations):\\n            maxh = max(min(lc-i, n), maxh)\\n        return maxh",
                "solutionTags": [
                    "Python"
                ],
                "code": "Most important of all: The definition.\\n\\n\"A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\"\\n\\nSo the observation is: If I `sort` the *citations*, then the `idx`-element in the sorted array means `there are at least N-idx papers have citations count more than or equal to citations[idx]`\\n\\nFor example, \\n\\n               idx:  0 1 2 3 4\\n             N-idx:  5 4 3 2 1\\n    citations[idx]:  0 1 3 5 6\\n\\n - For idx == 0, it means there are at least 5 papers have citations count more than or equal to 0\\n - For idx == 3, it means there are at least 3 papers have citations count more than or equal to 3\\n - For idx == 4, it means there are at least 1 papers have citations count more than or equal to 6\\n\\nBut how do we connect it to the definition, which said that it want h papers with at least h citations?\\nThe answer is that  we can further modify the observation to\\n\\n `there are at least N-idx papers have citations count more than or equal to min(N-idx, citations[idx])`\\n\\nWhy? I actually notice this transformation when I failed with the case [100], which follow by what I observed could be:\\n\\n - For idx == 0, it means there are at least 1 papers have citations count more than or equal to 100\\n\\nIt's right, but from the definition, h papers with at least h citations, h could not be 100, instead, it should be 1!!\\n\\nAnd the answer would be the largest value for `min(N-idx, citations[idx])` in each idx!\\nSo, that's pretty much how I think of this problem, hope it helps you!\\n\\nSample Python Code:\\n\\n    def hIndex(self, citations):\\n        citations.sort()\\n        comparePairs = zip([len(citations)-i for i in range(len(citations))], citations)\\n        return max([min(p) for p in comparePairs]) if citations else 0\\n\\nor\\n\\n    def hIndex(self, citations):\\n        citations.sort()\\n        maxh, lc = 0, len(citations)\\n        for i, n in enumerate(citations):\\n            maxh = max(min(lc-i, n), maxh)\\n        return maxh",
                "codeTag": "Python3"
            },
            {
                "id": 4007955,
                "title": "simplest-approch",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1.) Sort the vector in descending order.\\n2.) For loop the vector:\\n        the number of elements the loop passed through should be greater than the value of h. h less than x means there are less than h elements are equal or greater than the value h.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        // Sort in descending order\\n        sort(citations.begin(), citations.end(), greater<int>());\\n\\n        int h = 0;\\n        for(auto x : citations){\\n            if(x > h){\\n                h++;\\n            } else {\\n                return h;\\n            }\\n        }\\n\\n        return h;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        // Sort in descending order\\n        sort(citations.begin(), citations.end(), greater<int>());\\n\\n        int h = 0;\\n        for(auto x : citations){\\n            if(x > h){\\n                h++;\\n            } else {\\n                return h;\\n            }\\n        }\\n\\n        return h;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001857,
                "title": "easy-and-simple-code-in-c-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nPut n as size, .sort\\u2026 while iterating if (c[I]>=n) return n; else decrese n\\u2014 and check if (c[I]!=0 && n==1) return 1;\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        int n=citations.size();\\n        sort(citations.begin(),citations.end());\\n        for(int i=0;i<citations.size();i++){\\n            if(citations[i]>=n)\\n                return n;\\n            else{\\n                if(n==1 && citations[i]!=0)\\n                    return 1;\\n                n--;\\n            }\\n        }\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        int n=citations.size();\\n        sort(citations.begin(),citations.end());\\n        for(int i=0;i<citations.size();i++){\\n            if(citations[i]>=n)\\n                return n;\\n            else{\\n                if(n==1 && citations[i]!=0)\\n                    return 1;\\n                n--;\\n            }\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3809728,
                "title": "simple-c-beats-100-easy-to-understand",
                "content": "## Please upvote if you like the solution\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& c) {\\n        int n = c.size();\\n        sort(c.begin(), c.end(), greater<int>()); // Sort the vector in descending order\\n\\n        int hIndex = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (c[i] >= i + 1) {\\n                hIndex = i + 1;\\n            } else {\\n                break;\\n            }\\n        }\\n        return hIndex;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& c) {\\n        int n = c.size();\\n        sort(c.begin(), c.end(), greater<int>()); // Sort the vector in descending order\\n\\n        int hIndex = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (c[i] >= i + 1) {\\n                hIndex = i + 1;\\n            } else {\\n                break;\\n            }\\n        }\\n        return hIndex;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3754983,
                "title": "without-using-any-in-built-function-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        int ans=0;\\n        for(int i=0;i<citations.length;i++)\\n        {\\n            for(int j=i+1;j<citations.length;j++)\\n            {\\n                if( citations[i]< citations[j])\\n                {\\n                    int temp =  citations[i];\\n                     citations[i]= citations[j];\\n                      citations[j]=temp;\\n                }\\n            }\\n        }\\n        int check=0;\\n        for(int i=0;i<citations.length;i++)\\n        {    check++;\\n            if(citations[i]>=check)\\n              // System.out.print(check);\\n            ans = check;\\n    \\n            else break;\\n        }\\n        //System.out.print(Arrays.toString( citations));\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        int ans=0;\\n        for(int i=0;i<citations.length;i++)\\n        {\\n            for(int j=i+1;j<citations.length;j++)\\n            {\\n                if( citations[i]< citations[j])\\n                {\\n                    int temp =  citations[i];\\n                     citations[i]= citations[j];\\n                      citations[j]=temp;\\n                }\\n            }\\n        }\\n        int check=0;\\n        for(int i=0;i<citations.length;i++)\\n        {    check++;\\n            if(citations[i]>=check)\\n              // System.out.print(check);\\n            ans = check;\\n    \\n            else break;\\n        }\\n        //System.out.print(Arrays.toString( citations));\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607514,
                "title": "sorting-and-linear-search-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& c) {\\n        //sorting\\n        sort(c.begin(), c.end());\\n        //linear search\\n        int max_val = 0;\\n        for(int i = 1; i <= c.size(); i++){\\n            if(c[c.size()-i] >= i){\\n                if((i == c.size()) || (c[c.size()-i-1] <= i))\\n                    max_val = i;\\n                }\\n        }\\n\\t\\t\\n        return max_val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& c) {\\n        //sorting\\n        sort(c.begin(), c.end());\\n        //linear search\\n        int max_val = 0;\\n        for(int i = 1; i <= c.size(); i++){\\n            if(c[c.size()-i] >= i){\\n                if((i == c.size()) || (c[c.size()-i-1] <= i))\\n                    max_val = i;\\n                }\\n        }\\n\\t\\t\\n        return max_val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3591133,
                "title": "h-index-javascript-sort-an-array-70-63",
                "content": "```\\n/**\\n * @param {number[]} citations\\n * @return {number}\\n */\\nvar hIndex = function(citations) {    \\n    citations.sort((a, b) => b - a)    \\n    i = 0\\n\\n    while (citations[i] > i) {        \\n        i ++        \\n    }\\n    \\n    return i \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} citations\\n * @return {number}\\n */\\nvar hIndex = function(citations) {    \\n    citations.sort((a, b) => b - a)    \\n    i = 0\\n\\n    while (citations[i] > i) {        \\n        i ++        \\n    }\\n    \\n    return i \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3562476,
                "title": "simple-solution-linear-time",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} citations\\n * @return {number}\\n */\\nvar hIndex = function(citations) {\\n    const len = citations.length\\n    let i = 1\\n    let j = 0\\n\\n    if (len === 1 && citations[j] === 0) return 0\\n    if (len === 1) return i\\n\\n    const sortedArray = citations.sort((a, b) => b - a)\\n\\n    while(j < len) {\\n        const el = sortedArray[j]\\n        if (el === i) return i\\n        if (len === i && el > i) return i\\n        if (len === i && el < i) return i - 1\\n        if (el < i) return i - 1\\n        i++\\n        j++\\n    }\\n\\n    return i\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} citations\\n * @return {number}\\n */\\nvar hIndex = function(citations) {\\n    const len = citations.length\\n    let i = 1\\n    let j = 0\\n\\n    if (len === 1 && citations[j] === 0) return 0\\n    if (len === 1) return i\\n\\n    const sortedArray = citations.sort((a, b) => b - a)\\n\\n    while(j < len) {\\n        const el = sortedArray[j]\\n        if (el === i) return i\\n        if (len === i && el > i) return i\\n        if (len === i && el < i) return i - 1\\n        if (el < i) return i - 1\\n        i++\\n        j++\\n    }\\n\\n    return i\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3557783,
                "title": "python-single-line-solution",
                "content": "# Intuition\\nTop `i+1` papers have a h-index of `min(i+1, citations[i])` since they have at least `i+1` papers with h-index of `citations[i]`.\\n\\n# Code\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        return max(min(i+1, c) for i, c in enumerate(sorted(citations, reverse=True)))\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        return max(min(i+1, c) for i, c in enumerate(sorted(citations, reverse=True)))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518414,
                "title": "simplest-intuitive-java-solution-5-lines-of-logic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to find the h_index such that there are atleast h citations for atleast h papers. We can achieve this by sorting.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhen we sort the array, we can find the remaining papers with atleast h citations for a given h.\\n\\nExample:\\n[3, 0, 1, 6, 5]\\n\\nWhen we sort this array, we get\\n[0, 1, 3, 5, 6]\\n\\nSo we have to find the maximum h value such that there are atleast h papers with h citations. We can find this by finding the remaining number of papers. As the array is sorted, the remaining papers will always have atleast h citations.(i.e. h or more)\\n\\nLets say, n is the number of research papers.\\n\\nIn the given array,\\n\\nFor 0, \\n\\n0 is not greater than the remaining number of papers which is n-i = 5-0 = 5. (0 < 5)\\nSo we continue.\\n\\nSame with 1. n-i = 5-1 = 4. (1 < 4)\\n\\nFor 3, there are atleast 3 papers with atleast 3 citations (n-i = 5-2 = 3) (3 == 3)\\n\\nMath.max (3,0) = 3\\nSo h_index = 3\\n\\nWe can break the loop at this point because 3 is the maximum value which has atleast 3 citations.\\n\\nWhen we go to the next element 5, there are only 2 papers with atleast 5 citations. For 5 to be the h_index, there should be atleast 5 papers. Therefore, it cant be the h_index.\\n\\nWe are skipping 0 and 1 because, though there are atleast 0 paper with atleast 0 citations & atleast 1 paper with atleast 1 citation, it cant be the maximum value.\\n\\n# Complexity\\n- Time complexity: O(n*logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) -> No extra space is used\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        int n = citations.length;\\n        int h_index = 0;\\n        // Sorting the array\\n        Arrays.sort(citations);\\n        // Finding the citations[i] say t such that the remaining papers have atleast t citations\\n        for (int i=0; i<citations.length; i++) {\\n            if (citations[i] >= n-i) {\\n                h_index = Math.max(n-i, h_index);\\n                break;\\n            }\\n        }\\n        return h_index;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        int n = citations.length;\\n        int h_index = 0;\\n        // Sorting the array\\n        Arrays.sort(citations);\\n        // Finding the citations[i] say t such that the remaining papers have atleast t citations\\n        for (int i=0; i<citations.length; i++) {\\n            if (citations[i] >= n-i) {\\n                h_index = Math.max(n-i, h_index);\\n                break;\\n            }\\n        }\\n        return h_index;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3274633,
                "title": "solution-using-sort-and-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int HIndex(int[] citations) {\\n        Array.Sort(citations);\\n        int min = 0, n = citations.Length, max = n - 1;\\n        \\n        while(min <= max){\\n            int mid = (min + max)/2;\\n            if(citations[mid] < n - mid)\\n                min = mid + 1;\\n            else\\n                max = mid - 1;\\n        }\\n        return n - min;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int HIndex(int[] citations) {\\n        Array.Sort(citations);\\n        int min = 0, n = citations.Length, max = n - 1;\\n        \\n        while(min <= max){\\n            int mid = (min + max)/2;\\n            if(citations[mid] < n - mid)\\n                min = mid + 1;\\n            else\\n                max = mid - 1;\\n        }\\n        return n - min;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3064834,
                "title": "c-4-lines-sort-and-traverse-o-nlogn",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        sort(citations.begin(), citations.end());\\n        int ans = citations.size() + 1;\\n        for (int i = 0; i < citations.size(); i++) {\\n            if (citations[i] >= ans) return ans;\\n            ans--;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**For more solutions, check out this \\uD83C\\uDFC6  [GITHUB REPOSITORY](https://github.com/MuhtasimTanmoy/playground) with over 1500+ solutions.**",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        sort(citations.begin(), citations.end());\\n        int ans = citations.size() + 1;\\n        for (int i = 0; i < citations.size(); i++) {\\n            if (citations[i] >= ans) return ans;\\n            ans--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2951798,
                "title": "python3-using-heaps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUse heaps\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n\\n        cit = [-i for i in citations]\\n\\n        heapq.heapify(cit)\\n\\n        res = 0\\n        i = 1\\n        while i <= len(citations):\\n            val = heapq.heappop(cit)\\n\\n            if -val < i:\\n                break\\n            else:\\n                res = i\\n            i += 1\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n\\n        cit = [-i for i in citations]\\n\\n        heapq.heapify(cit)\\n\\n        res = 0\\n        i = 1\\n        while i <= len(citations):\\n            val = heapq.heappop(cit)\\n\\n            if -val < i:\\n                break\\n            else:\\n                res = i\\n            i += 1\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946516,
                "title": "c-binary-search-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:O(logN)+O(nlogn)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        sort(citations.begin(), citations.end());\\n        int i=0, j=1e9, n=citations.size(), ans=0;\\n        while(i<=j){\\n            int mid=i+(j-i)/2;\\n            int cnt=lower_bound(citations.begin(), citations.end(), mid)-citations.begin();\\n            if(n-cnt>=mid){\\n                ans=mid;\\n                i=mid+1;\\n            }\\n            else{\\n                j=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        sort(citations.begin(), citations.end());\\n        int i=0, j=1e9, n=citations.size(), ans=0;\\n        while(i<=j){\\n            int mid=i+(j-i)/2;\\n            int cnt=lower_bound(citations.begin(), citations.end(), mid)-citations.begin();\\n            if(n-cnt>=mid){\\n                ans=mid;\\n                i=mid+1;\\n            }\\n            else{\\n                j=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2927488,
                "title": "c-o-n-0ms-w-explanation",
                "content": "Just looking at the problem you can guess you need to sort.\\nDoing some examples shows the information you need is always held further down the array.\\n\\n--- begin example ---\\n[3,0,6,1,5]\\nsorted is [0,1,3,5,6]\\n\\nLook at the two conditions for a valid h-index for h\\'s starting at 0.\\n\\nh=0\\n1 - 0 papers have atleast 0 citations, true (0,1,3,5,6)\\n2 - 5 - 0 = 5 papers have no more than 0 citation, false (1,3,5,6)\\nh=1\\n1 - 1 papers have atleast 1 citation, true (1,3,5,6)\\n2 - 5 - 1 = 4 papers have no mare than 1 citation, false (3,5,6)\\nh=2\\n1 - true (3,5,6) \\n2 - true (3,5,6)\\nh=3\\n1 - true (3,5,6) \\n2 - true (5,6)\\nh=4\\n1 - false (5,6)\\n2 - true (5,6)\\n\\ncontinue to h=1000 since h is bounded by number of citations.\\n--- end example --- \\n\\nAt every h we only need to know about papers with >= h citations. Let\\'s us conclude sorting is not actually needed and can simply keep track of in array the frequency of which number of citations occur. Bringing complexity from nlgn to n;\\n\\nDoing more examples should bring out two rules when to determine when a value of h is valid.\\n1. \\\\>= h papers have >= h citations each\\n2. number of papers > h is <= h\\n\\nUsing these rules on an example\\n--- begin example ---\\n [3,0,6,1,5]\\n \\nCan create frequency array where index i is a h value and arr[i] is the number of times a paper with i citations occured.\\n1,1,0,1,0,1,1,0,... length 1000\\n\\nThen creating arrays based of the two rules\\n(1) At index i, arr[i] is number of papers with citations >= i\\n5,4,4,3,3,2,1,0,...\\n(2) At index i, arr[i] is the number of papers with citations > i\\n4,3,3,2,2,1,0,0,...\\n\\nCan see array (2) is just array (1) shifterd one to the left.\\n--- end example ---\\n\\nCode\\n```\\n        vector<int> v(1028, 0);\\n        \\n        for (int i : citations) ++v[i];\\n        \\n        int total = size(citations), prev = 0;\\n        for (int i = 0; i != size(v); ++i){\\n            int temp = v[i];\\n            total -= prev;\\n            v[i] = total;\\n            prev = temp;\\n        }\\n        \\n        int res = 0;\\n        for (int i = 0; v[i]; ++i) {\\n            if (v[i] >= i && v[i + 1] <= i) {\\n                res = i;\\n            }\\n        }\\n        \\n        return res;\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n        vector<int> v(1028, 0);\\n        \\n        for (int i : citations) ++v[i];\\n        \\n        int total = size(citations), prev = 0;\\n        for (int i = 0; i != size(v); ++i){\\n            int temp = v[i];\\n            total -= prev;\\n            v[i] = total;\\n            prev = temp;\\n        }\\n        \\n        int res = 0;\\n        for (int i = 0; v[i]; ++i) {\\n            if (v[i] >= i && v[i + 1] <= i) {\\n                res = i;\\n            }\\n        }\\n        \\n        return res;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2226072,
                "title": "java-solution-using-typical-binary-search-easy-to-understand-beginner-friendly",
                "content": "Here I am just counting how many elements are greater than or equal to mid. And if this count is greater than or equal to mid, i am soring mid in ans and checking for right side for better ans.\\n```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        int n = citations.length;\\n        int max=citations[0];\\n        for(int i=0;i<n;i++){\\n            max=Math.max(max,citations[i]);}\\n        int low=0;\\n        int high=max;\\n        int ans=low;\\n        while(low<=high){\\n            int mid = low+(high-low)/2;\\n            int k = find(citations,n,mid);\\n            if(k>=mid){\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    public static int find(int arr[],int n,int mid){\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            if(arr[i]>=mid){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n//Please upvote if you find it helpful....Thank You..!",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public int hIndex(int[] citations) {\\n        int n = citations.length;\\n        int max=citations[0];\\n        for(int i=0;i<n;i++){\\n            max=Math.max(max,citations[i]);}",
                "codeTag": "Java"
            },
            {
                "id": 2101138,
                "title": "python-sorting-solution-with-explanation",
                "content": "Sort all the citations in descending order. Now iterate through all the citations starting from the largest one. Since we require ```h``` papers to have ```h``` citations atleast, we keep going onto smaller and smaller number of citations until we reach a point where the index (the number of papers) is greater than the number of citations.\\n\\nNote that at each point of iteration (until we stop), the number of papers covered so far (starting from the left-most index) are less than the value of the smallest citations encountered so far.\\nUpon encountering an index that\\'s greater than the number of citations, we can say that it was till the previous index that the constraint (that ```h``` number of papers need to have ```h``` citations atleast) was satisfied.\\n\\nHence it\\'s all the papers till the previous index that we need to count and return. To do that, we can simply return the index at which the constraint breaks, since because the indexing actually starts from ```0``` (meaning index ```5``` means we\\'re on the 6th element).\\n\\nIf we never encounter a point where the constraint breaks, then all the papers have very large number of citations (by large I mean the least value of the number of citations is greater than the number of papers themselves).\\n\\nFor example:\\n\\n```[103,102,101,100,99]```\\n\\nHere, there are just 5 papers but the least value of the number of citations is ```99```.\\n\\nIn this kind of scenario, we need to return the number of paper themselves, because it\\'s for certain then that the number of citations are greater than the number of papers themselves.\\n\\nSo, in the given example, we would return ```5```.\\n\\nHere\\'s the code for the same:\\n\\n    def hIndex(self, citations):\\n        citations.sort(reverse = True)\\n        i = 0\\n        for i,citation in enumerate(citations):\\n            if i >= citation:\\n                return i\\n        return i+1",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```h```\n```h```\n```h```\n```h```\n```0```\n```5```\n```[103,102,101,100,99]```\n```99```\n```5```",
                "codeTag": "Unknown"
            },
            {
                "id": 2049204,
                "title": "java-simple-o-n-o-n-without-sorting",
                "content": "1. create a memo and increase the counter having value as index.\\n2. traverse throught the memo and if running sum is greater than the index, return the index.\\n```\\npublic int hIndex(int[] citations) {\\n        int[] memo = new int[1001];\\n        \\n        for(int i: citations)\\n            memo[i]++;\\n        \\n        int sum=0;\\n        for(int i=1000; i>=0; i--){\\n            sum += memo[i];\\n            if(sum >=i) return i;\\n        }\\n        \\n        return 0;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int hIndex(int[] citations) {\\n        int[] memo = new int[1001];\\n        \\n        for(int i: citations)\\n            memo[i]++;\\n        \\n        int sum=0;\\n        for(int i=1000; i>=0; i--){\\n            sum += memo[i];\\n            if(sum >=i) return i;\\n        }\\n        \\n        return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2003487,
                "title": "c-intuitive-solution-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int> &citations)\\n    {\\n        sort(citations.begin(), citations.end());\\n        int n = citations.size();\\n        for (int i = 0; i < n; ++i) {\\n            int hi = n-i;   // num papers with citations  >= citations[i]\\n            if (citations[i] >= hi) return hi; // there are atleast \"hi\" papers with citation >= citations[i] (and automatically there are n-hi papers with citations <= hi)\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int> &citations)\\n    {\\n        sort(citations.begin(), citations.end());\\n        int n = citations.size();\\n        for (int i = 0; i < n; ++i) {\\n            int hi = n-i;   // num papers with citations  >= citations[i]\\n            if (citations[i] >= hi) return hi; // there are atleast \"hi\" papers with citation >= citations[i] (and automatically there are n-hi papers with citations <= hi)\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1971978,
                "title": "isn-t-the-second-example-incorrect",
                "content": "The second given example is [1,3,1], and the given answer is 1\\n\\nIn this example, according to the h-index definition, for 1 to be h-index, it has to meet the following two conditions which it doesn\\'t\\n\\nh=1, n=3\\n1 of 3 papers have at least 1 citation (x) -> all 3 papers have at least 1 citation\\n2 papers have no more than 1 citation each (x) -> All exceed or equal to 1\\n\\nI feel like I am the only one not understanding this question correctly.\\nCan someone please explain it for me? \\n\\n\\n",
                "solutionTags": [],
                "code": "The second given example is [1,3,1], and the given answer is 1\\n\\nIn this example, according to the h-index definition, for 1 to be h-index, it has to meet the following two conditions which it doesn\\'t\\n\\nh=1, n=3\\n1 of 3 papers have at least 1 citation (x) -> all 3 papers have at least 1 citation\\n2 papers have no more than 1 citation each (x) -> All exceed or equal to 1\\n\\nI feel like I am the only one not understanding this question correctly.\\nCan someone please explain it for me? \\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1774991,
                "title": "c-postfix-sum-o-n-t-c-o-max-element-s-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n         int mx = *max_element(citations.begin(), citations.end());\\n         vector<int> post_sum(mx + 1, 0);\\n         \\n         for(int ele : citations){\\n             post_sum[ele]++;\\n         }\\n        \\n         for(int i=post_sum.size() - 2; i>0; i--){\\n              post_sum[i] = post_sum[i] + post_sum[i+1];\\n         }\\n        \\n         int ans = 0;\\n        \\n         for(int i=1; i<post_sum.size(); i++){\\n             if(post_sum[i] >= i){\\n                 ans = max(ans, i);\\n             }\\n         }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n         int mx = *max_element(citations.begin(), citations.end());\\n         vector<int> post_sum(mx + 1, 0);\\n         \\n         for(int ele : citations){\\n             post_sum[ele]++;\\n         }",
                "codeTag": "Java"
            },
            {
                "id": 1608438,
                "title": "why-use-count-sort-when-you-can-use-binary-search-100-percent",
                "content": "since the input size is small  we can use binary search\\ncount sort -> time O(N) space O(N)\\nbinary search  -> time(Nlog(N)) space O(1)\\n\\n```\\nclass Solution {\\npublic:\\n    int count(vector<int> arr, int val){\\n        int cnt = 0;\\n        for(int i = 0; i < arr.size(); ++i){\\n            if(arr[i] >= val){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n    \\n    int hIndex(vector<int>& arr) {\\n        int n = arr.size();\\n        int i = 0;\\n        int j = n;\\n        int ans = 0;\\n        while(i <= j){\\n            int mid = (i+j)/2;\\n            if(count(arr,mid) >= mid){\\n                ans = mid;\\n                i = mid+1;\\n            }\\n            else{\\n                j = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int count(vector<int> arr, int val){\\n        int cnt = 0;\\n        for(int i = 0; i < arr.size(); ++i){\\n            if(arr[i] >= val){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n    \\n    int hIndex(vector<int>& arr) {\\n        int n = arr.size();\\n        int i = 0;\\n        int j = n;\\n        int ans = 0;\\n        while(i <= j){\\n            int mid = (i+j)/2;\\n            if(count(arr,mid) >= mid){\\n                ans = mid;\\n                i = mid+1;\\n            }\\n            else{\\n                j = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1546654,
                "title": "no-binary-search-easy-c",
                "content": "Idea- since range of numbers is upto 5000 , first make array which will contain count of each number.\\n\\ne.g-  3 0 6 1 5 \\n        here max number is 6 so we will make array of size 7. \\n\\t\\tthis array will look like this\\n\\t\\t0->1\\n\\t\\t1->1\\n\\t\\t2->0\\n\\t\\t3->1\\n\\t\\t4->0\\n\\t\\t5->1\\n\\t\\t6->1\\n\\tnow start from the end of this new array, take a count of citations, add cnt[i] to count for every i and when condition count>=i is met that i is your answer.\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t```\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n    \\n\\t\\tint hIndex(vector<int>& c) {\\n        \\n        int max=0;\\n        for(int i=0;i<c.size();i++)\\n        {\\n            \\n            if(max<c[i])\\n            {\\n                max=c[i];\\n            }\\n        }\\n        \\n        vector<int>count(max+1,0);\\n        \\n        for(int i=0;i<c.size();i++)\\n        {\\n            count[c[i]]++;\\n        }\\n        \\n        int cnt=0;\\n        \\n        for(int i=max;i>=0;i--)\\n        {\\n            cnt+=count[i];\\n            \\n            if(cnt>=i)\\n            {\\n                return i;\\n            }\\n        }\\n        \\n        \\n        return 0;\\n        \\n\\t\\t}\\n\\t\\t};\\n\\t\\t```",
                "solutionTags": [
                    "C",
                    "Counting Sort"
                ],
                "code": "```\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n    \\n\\t\\tint hIndex(vector<int>& c) {\\n        \\n        int max=0;\\n        for(int i=0;i<c.size();i++)\\n        {\\n            \\n            if(max<c[i])\\n            {\\n                max=c[i];\\n            }\\n        }\\n        \\n        vector<int>count(max+1,0);\\n        \\n        for(int i=0;i<c.size();i++)\\n        {\\n            count[c[i]]++;\\n        }\\n        \\n        int cnt=0;\\n        \\n        for(int i=max;i>=0;i--)\\n        {\\n            cnt+=count[i];\\n            \\n            if(cnt>=i)\\n            {\\n                return i;\\n            }\\n        }\\n        \\n        \\n        return 0;\\n        \\n\\t\\t}\\n\\t\\t};\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1370235,
                "title": "question-description-is-wrong",
                "content": "I wonder why don\\'t they just copy and paste the definition of H index from WIKI, because the description in problem is wrong.\\nIn wiki:\\n```\\nThe h-index is defined as the maximum value of h such that the given author/journal has published at least h papers that have each been cited at least h times.\\n```\\nBut in question description:\\n```\\nA scientist has an index h if h of their n papers have at least h citations each, and the other n \\u2212 h papers have no more than h citations each.\\n```\\nBut it should be\\n```\\nA scientist has an index h if at least h of their n papers have at least h citations each...\\n```\\nHehe, it takes me a bit time to figure out. Am I the only one notice this?",
                "solutionTags": [],
                "code": "```\\nThe h-index is defined as the maximum value of h such that the given author/journal has published at least h papers that have each been cited at least h times.\\n```\n```\\nA scientist has an index h if h of their n papers have at least h citations each, and the other n \\u2212 h papers have no more than h citations each.\\n```\n```\\nA scientist has an index h if at least h of their n papers have at least h citations each...\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1003285,
                "title": "java-0-ms-sorting-binary-search",
                "content": "```\\nclass Solution {\\n    public int hIndex(int[] nums) {\\n        int n = nums.length;\\n        int left = 0, right = n-1;\\n\\n        Arrays.sort(nums);\\n        while(left <= right){\\n            int mid = left + (right-left)/2;\\n            if(nums[mid] == n-mid){\\n                return nums[mid];\\n            } else if(nums[mid] > n-mid){\\n                right = mid-1;\\n            } else {\\n                left = mid+1;\\n            }\\n        }\\n\\n        return n-left;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int hIndex(int[] nums) {\\n        int n = nums.length;\\n        int left = 0, right = n-1;\\n\\n        Arrays.sort(nums);\\n        while(left <= right){\\n            int mid = left + (right-left)/2;\\n            if(nums[mid] == n-mid){\\n                return nums[mid];\\n            } else if(nums[mid] > n-mid){\\n                right = mid-1;\\n            } else {\\n                left = mid+1;\\n            }\\n        }\\n\\n        return n-left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 786707,
                "title": "java-accepted-with-approach-0-ms-binary-search",
                "content": "# ***Please upvote if helpful!!!***\\n * Problem is same as h-index 2 .\\n* We need to sort the elements and use binary search.\\n* If you are unable to understand the code. This is the best video : https://www.youtube.com/watch?v=CjKJDloMnwE . Very clear approach. and excellent explaination .\\n\\nCode : \\n\\n```\\n\\t\\tArrays.sort(citations);\\n        int low = 0;\\n        int high = citations.length - 1;\\n\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n\\n            final int numberOfCitationsGreaterThanOrEqualToCurrentMidElement = citations.length - mid; // array is ascending order. .\\n            // so the number of elements after the mid elements is the number of citations greater than equal to the mid Element.\\n            if (citations[mid] == numberOfCitationsGreaterThanOrEqualToCurrentMidElement)\\n                return citations[mid];\\n            else if (citations[mid] < numberOfCitationsGreaterThanOrEqualToCurrentMidElement) {\\n                low = mid + 1;\\n            } else {\\n                high = mid - 1;\\n            }\\n        }\\n        return citations.length - low;\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\n\\t\\tArrays.sort(citations);\\n        int low = 0;\\n        int high = citations.length - 1;\\n\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n\\n            final int numberOfCitationsGreaterThanOrEqualToCurrentMidElement = citations.length - mid; // array is ascending order. .\\n            // so the number of elements after the mid elements is the number of citations greater than equal to the mid Element.\\n            if (citations[mid] == numberOfCitationsGreaterThanOrEqualToCurrentMidElement)\\n                return citations[mid];\\n            else if (citations[mid] < numberOfCitationsGreaterThanOrEqualToCurrentMidElement) {\\n                low = mid + 1;\\n            } else {\\n                high = mid - 1;\\n            }\\n        }\\n        return citations.length - low;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 786250,
                "title": "c-h-index-100-o-n-o-n",
                "content": "First, count the number of citations for each possible h (clamped to the number of citations). Then build a prefix sum from the right by initially setting h = n and decrementing h until sum >= h. As soon as sum >= h, we know that 1) there are at least h papers with h citations each and 2) there are no other papers that have more than h citations left, so it\\'s a valid solution.\\n\\n```\\nclass Solution {\\npublic:\\n    // Time: O(n)\\n    // Space: O(n)\\n    int hIndex(vector<int>& citations) {\\n        \\n        if (citations.empty()) return 0;\\n        \\n        const int n = citations.size();\\n        vector<int> counts(n+1, 0);\\n        for (int i = 0; i < n; ++i) {\\n            int h = min(citations[i], n);\\n            counts[h]++;\\n        }\\n        \\n        int h = n;\\n        for (int sum = 0; h > 0; --h) {\\n            sum += counts[h];\\n            if (sum >= h) {\\n                break;\\n            }\\n        }\\n                \\n        return h;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // Time: O(n)\\n    // Space: O(n)\\n    int hIndex(vector<int>& citations) {\\n        \\n        if (citations.empty()) return 0;\\n        \\n        const int n = citations.size();\\n        vector<int> counts(n+1, 0);\\n        for (int i = 0; i < n; ++i) {\\n            int h = min(citations[i], n);\\n            counts[h]++;\\n        }\\n        \\n        int h = n;\\n        for (int sum = 0; h > 0; --h) {\\n            sum += counts[h];\\n            if (sum >= h) {\\n                break;\\n            }\\n        }\\n                \\n        return h;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 786145,
                "title": "java-0ms-beats-100-sorting-then-binary-search",
                "content": "```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        Arrays.sort(citations);\\n        int n = citations.length;\\n        int left = 0;\\n        int right = n - 1;\\n        \\n        while(left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if(citations[mid] < n - mid)\\n                left = mid + 1;\\n            else\\n                right = mid - 1;\\n        }\\n        return n - left;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public int hIndex(int[] citations) {\\n        Arrays.sort(citations);\\n        int n = citations.length;\\n        int left = 0;\\n        int right = n - 1;\\n        \\n        while(left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if(citations[mid] < n - mid)\\n                left = mid + 1;\\n            else\\n                right = mid - 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 786032,
                "title": "h-index-python-98",
                "content": "```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        citations.sort(reverse=True)\\n        c=0\\n        for i in range(len(citations)):\\n            if citations[i]>=i+1:\\n                c+=1\\n            else:\\n                break\\n        return c\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        citations.sort(reverse=True)\\n        c=0\\n        for i in range(len(citations)):\\n            if citations[i]>=i+1:\\n                c+=1\\n            else:\\n                break\\n        return c\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 786007,
                "title": "c-not-all-sorting-are-equal-o-nlogn-vs-o-n",
                "content": "Solution 1: O(NlogN) sorting soltuion\\n```\\nclass Solution {\\npublic: //Time/Space: O(NlogN); O(1)\\n    int hIndex(vector<int>& citations) {\\n        sort(citations.rbegin(), citations.rend()); // descending order\\n        int ans = 0;\\n        for(int i = 0; i < citations.size(); i++) // linear search\\n            if(citations[i]>i) ans++;        \\n        return ans;        \\n    }\\n};\\n```\\n\\nSolution 2: O(N) counting sorting soltuion\\nRef: https://leetcode.com/problems/h-index/solution/\\n```\\nclass Solution { // Counting sort\\npublic: // Time/Space: O(N); O(N)\\n    int hIndex(vector<int>& citations) {\\n        const int n = citations.size();\\n        vector<int> paper(n+1); // paper[i]: # of paper with i-citation\\n        for(int c: citations) paper[min(n, c)]++; // compress range with cutting-off trick, then count\\n        int k = n;\\n        for(int s = paper[k]; k > s; s += paper[k]) k--;\\n        return k; // when hit here: k <= s, then k is the answer, i.e., h-index\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic: //Time/Space: O(NlogN); O(1)\\n    int hIndex(vector<int>& citations) {\\n        sort(citations.rbegin(), citations.rend()); // descending order\\n        int ans = 0;\\n        for(int i = 0; i < citations.size(); i++) // linear search\\n            if(citations[i]>i) ans++;        \\n        return ans;        \\n    }\\n};\\n```\n```\\nclass Solution { // Counting sort\\npublic: // Time/Space: O(N); O(N)\\n    int hIndex(vector<int>& citations) {\\n        const int n = citations.size();\\n        vector<int> paper(n+1); // paper[i]: # of paper with i-citation\\n        for(int c: citations) paper[min(n, c)]++; // compress range with cutting-off trick, then count\\n        int k = n;\\n        for(int s = paper[k]; k > s; s += paper[k]) k--;\\n        return k; // when hit here: k <= s, then k is the answer, i.e., h-index\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 785724,
                "title": "java-100-basic-explanation-no-more-confusion-about-problem-statement",
                "content": "**If helpful please do Upvote!!!**\\n```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        //Problem Statement:-\\n        //In this we have to find the H-index , A number x is said to be H-index ,if and only if one researcher publish x or more quality(citations) papers ,at least x times.\\n        \\n        //example :- \\n        //arr[3,1,2,3,2]\\n        // In this 3 occur 2 times -> 3 is not H-index because 3 not occur atleast 3 times\\n        //         2 occur 2 times -> 2 is H-index because 2 occur at least 2 time (and it is greater number among H-index eligible numbers , So we consider it as H-index )\\n        //         1 occur 1 time ->  1 is H-index because 1 occur at least 1 time (but we don\\'t consider it as we it is smaller than and we want Greatest number)\\n        \\n        \\n        //Solution:- (Bucket Sort) O(n) complexity , we can also use sorting but it takes O(nlogn)\\n        //idea:-.\\n        //Step-1 (populate bucket array)\\n        //we make the bucket array for n+1 size\\n        //For every number in citations we increament that particular index in our bucket array\\n        //for all numbers which are greater than our index array increament our last index(that is n)\\n        \\n        //Step-2 (Find the H-index)\\n        //Start from last and add the value to the countSum and when we get countSum greater than or equal to index return that index\\n        //(means we are able to find atleast i numbers)\\n        int n=citations.length;\\n        int[] bucket=new int[n+1];\\n        for(int i=0;i<n;i++){\\n            if(citations[i]>n){\\n                bucket[n]++;\\n            }\\n            else{\\n                bucket[citations[i]]++;\\n            }\\n        }\\n        int countSum=0;\\n        for(int i=n;i>=0;i--){\\n            countSum+=bucket[i];\\n            if(countSum>=i){\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        //Problem Statement:-\\n        //In this we have to find the H-index , A number x is said to be H-index ,if and only if one researcher publish x or more quality(citations) papers ,at least x times.\\n        \\n        //example :- \\n        //arr[3,1,2,3,2]\\n        // In this 3 occur 2 times -> 3 is not H-index because 3 not occur atleast 3 times\\n        //         2 occur 2 times -> 2 is H-index because 2 occur at least 2 time (and it is greater number among H-index eligible numbers , So we consider it as H-index )\\n        //         1 occur 1 time ->  1 is H-index because 1 occur at least 1 time (but we don\\'t consider it as we it is smaller than and we want Greatest number)\\n        \\n        \\n        //Solution:- (Bucket Sort) O(n) complexity , we can also use sorting but it takes O(nlogn)\\n        //idea:-.\\n        //Step-1 (populate bucket array)\\n        //we make the bucket array for n+1 size\\n        //For every number in citations we increament that particular index in our bucket array\\n        //for all numbers which are greater than our index array increament our last index(that is n)\\n        \\n        //Step-2 (Find the H-index)\\n        //Start from last and add the value to the countSum and when we get countSum greater than or equal to index return that index\\n        //(means we are able to find atleast i numbers)\\n        int n=citations.length;\\n        int[] bucket=new int[n+1];\\n        for(int i=0;i<n;i++){\\n            if(citations[i]>n){\\n                bucket[n]++;\\n            }\\n            else{\\n                bucket[citations[i]]++;\\n            }\\n        }\\n        int countSum=0;\\n        for(int i=n;i>=0;i--){\\n            countSum+=bucket[i];\\n            if(countSum>=i){\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 785716,
                "title": "sorting-binary-search-o-n-logn",
                "content": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& arr) {\\n        sort(arr.begin(), arr.end(), greater<int>());\\n        int n = arr.size();\\n        int ans = 0;\\n        int lo=0, hi=n-1;\\n        while(lo<=hi){\\n            int mid = (lo+hi)/2;\\n            int cur_idx = min(arr[mid], mid+1);\\n            ans = max(ans, cur_idx);\\n\\t\\t\\t\\n            if(arr[mid]>mid)lo = mid+1;\\n            else hi = mid-1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& arr) {\\n        sort(arr.begin(), arr.end(), greater<int>());\\n        int n = arr.size();\\n        int ans = 0;\\n        int lo=0, hi=n-1;\\n        while(lo<=hi){\\n            int mid = (lo+hi)/2;\\n            int cur_idx = min(arr[mid], mid+1);\\n            ans = max(ans, cur_idx);\\n\\t\\t\\t\\n            if(arr[mid]>mid)lo = mid+1;\\n            else hi = mid-1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 693946,
                "title": "javascript-two-approaches-1-with-o-n-time-o-n-space-and-another-with-o-n-log-n-time",
                "content": "```\\n\\n// how to do better than O(n*logn)?\\n// most h can be is total\\n// \\'bucket\\' sort.  bucket size bounded by total papers or citations.length\\n// Much better at O(n) time complexity with extra O(n) space\\nvar hIndex = function(citations) {\\n    let total = citations.length\\n    if (total === 0) return 0\\n    let bucket = new Array(total+1).fill(0)\\n    for (let i = 0; i < total; i++){\\n        if (citations[i] >= total){\\n            bucket[total]++\\n        } else {\\n            bucket[citations[i]]++\\n        }\\n    }\\n    // console.log(bucket)\\n    let sum = 0\\n    for (let i = 0; i < bucket.length; i++){\\n        sum+=bucket[i]\\n        if (sum >= total-i) {\\n            return i\\n        }\\n    }\\n    return 0\\n}\\n```\\nnaive approach  is by sorting which takes O(n log n) time, & then search either linearly at O(n) or binary search O(log n). Overall time is still dominated by sort O(n log n) though\\n```\\n var hIndex = function(citations) {\\n     let total = citations.length\\n     if (total === 0) return 0\\n    \\n     citations.sort((a,b) => a - b)\\n     let left = 0, right = total - 1\\n     while (left <= right){\\n         let mid = left + Math.floor((right - left) / 2)\\n         if (citations[mid] === total - mid) return total - mid\\n         else if (citations[mid] < total - mid){\\n             left = mid + 1\\n         } else{\\n             right = mid - 1\\n         }\\n     }\\n     return total - left\\n };\\n```",
                "solutionTags": [],
                "code": "```\\n\\n// how to do better than O(n*logn)?\\n// most h can be is total\\n// \\'bucket\\' sort.  bucket size bounded by total papers or citations.length\\n// Much better at O(n) time complexity with extra O(n) space\\nvar hIndex = function(citations) {\\n    let total = citations.length\\n    if (total === 0) return 0\\n    let bucket = new Array(total+1).fill(0)\\n    for (let i = 0; i < total; i++){\\n        if (citations[i] >= total){\\n            bucket[total]++\\n        } else {\\n            bucket[citations[i]]++\\n        }\\n    }\\n    // console.log(bucket)\\n    let sum = 0\\n    for (let i = 0; i < bucket.length; i++){\\n        sum+=bucket[i]\\n        if (sum >= total-i) {\\n            return i\\n        }\\n    }\\n    return 0\\n}\\n```\n```\\n var hIndex = function(citations) {\\n     let total = citations.length\\n     if (total === 0) return 0\\n    \\n     citations.sort((a,b) => a - b)\\n     let left = 0, right = total - 1\\n     while (left <= right){\\n         let mid = left + Math.floor((right - left) / 2)\\n         if (citations[mid] === total - mid) return total - mid\\n         else if (citations[mid] < total - mid){\\n             left = mid + 1\\n         } else{\\n             right = mid - 1\\n         }\\n     }\\n     return total - left\\n };\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 675332,
                "title": "c-o-n-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& c) {\\n        int n = c.size();\\n        vector<int> res(n+1,0);\\n        for(auto x: c){\\n            x >= n ? res[n]++ : res[x]++;\\n        }\\n        if(res[n]==n) return n;\\n        for(int i=n-1;i>=0;i--){\\n            res[i] += res[i+1];\\n            if(res[i] >= i) return i;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& c) {\\n        int n = c.size();\\n        vector<int> res(n+1,0);\\n        for(auto x: c){\\n            x >= n ? res[n]++ : res[x]++;\\n        }\\n        if(res[n]==n) return n;\\n        for(int i=n-1;i>=0;i--){\\n            res[i] += res[i+1];\\n            if(res[i] >= i) return i;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 605785,
                "title": "o-n-java-solution",
                "content": "```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        int[] count = new int[citations.length + 1];\\n        \\n        for (int c : citations)\\n            count[Math.min(count.length - 1, c)]++;\\n        \\n        int sum = 0;\\n        for (int i = count.length - 1; i >=0; i--) {\\n            sum += count[i];\\n            if (sum >= i)\\n                return i;\\n        }\\n        \\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        int[] count = new int[citations.length + 1];\\n        \\n        for (int c : citations)\\n            count[Math.min(count.length - 1, c)]++;\\n        \\n        int sum = 0;\\n        for (int i = count.length - 1; i >=0; i--) {\\n            sum += count[i];\\n            if (sum >= i)\\n                return i;\\n        }\\n        \\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 479756,
                "title": "single-pass-o-n-solution-very-easy-to-understand-and-works-for-online-data",
                "content": "I discovered this problem when I was practicing Google\\'s Kickstart archives. I came up with this O(n) solution after re-attempting the problem after a few days.\\n\\nWe create an empty list. Let\\'s call it `greaterThanMax`. As we iterate through the array, we keep track of the maximum possible H-Index till i\\'th citations (I\\'ll explain later how). And in our list `greaterThanMax`, we maintain elements that are **more than or equal to our current maximum H-index**.\\n\\nLet\\'s take this example : `[1,2,3,3,1,4,4,4,10,12,0,14,5]`\\n\\n**0th iteration:**\\n`[1,2,3,3,1,4,4,4,10,12,0,14,5]`\\n`greaterThanMax : []`\\n`h_index: 0`\\n\\n**1st iteration:**\\nWe see that 1 is more than current h_index. We add 1 to our list, and h_index is equal to the size of the list.\\n`[*1*,2,3,3,1,4,4,4,10,12,0,14,5]`\\n`greaterThanMax : [1]`\\n `h_index=1`\\n\\n **2nd iteration:**\\nHere notice that, we can add 2 to our list. But we are now limited by the least element in our list, 1. No matter what we add, h_index will always be limited by that element. So, **replace** 1 with 2. Again, h_index is equal to the size of the `greaterThanMax` list.\\n `[1,*2*,3,3,1,4,4,4,10,12,0,14,5]`\\n `greaterThanMax : [2]`\\n  `h_index=1`\\n \\n**3rd iteration**:\\nSimilarly, we add 3 and update h_index:\\n `[1,2,*3*,3,1,4,4,4,10,12,0,14,5]`\\n `greaterThanMax : [2,3]`\\n  `h_index=2`\\n \\n**4th iteration:** (important)\\n `[1,2,3,*3*,1,4,4,4,10,12,0,14,5]`\\n `greaterThanMax : [2,3,3]` <- WRONG\\n  `h_index=3` <- WRONG\\n\\nWe encounter 3. However, if we straightaway add it to the list and increment h_index to 3 we will break our constraint -  *All elements in the list must be more than or equal current h_index*. We cannot increase h_index. However, we can improve our state by replacing 2 by 3.\\n\\n `[1,2,3,*3*,1,4,4,4,10,12,0,14,5]`\\n `greaterThanMax : [3,3]`\\n  `h_index=2`\\n\\nOur h_index stays the same, but we have replaced 2 with 3, and we are no longer limited by that element. Any time we encounter an element more than our current h_index, if there\\'s an element equal h_index, we replace it with this larger element. (This way, in future iterations we are no longer limited by that least element.) Otherwise, we simply add the element. \\n\\nNow, follow this logic till the end:\\n 5. `greaterThanMax : [3,3]`  - `h_index=2`\\n 6. `greaterThanMax : [3,3,4]`  - `h_index=3`\\n 7. `greaterThanMax : [3,4,4]`  - `h_index=3`\\n 8. `greaterThanMax : [4,4,4]`  - `h_index=3`\\n 9. `greaterThanMax : [4,4,4,10]`  - `h_index=4`\\n 10. `greaterThanMax : [12,4,4,10]`  `h_index=4`\\n 11. `greaterThanMax : [12,4,4,10]`  `h_index=4`\\n 12. `greaterThanMax : [12,14,4,10]`  `h_index=4`\\n 13. `greaterThanMax : [12,14,5,10]`  `h_index=4`\\n\\nWe can use this logic and implement it with a minHeap. However, we can improve it further. We don\\'t really need to maintain a minHeap list to figure out our limiting element. We know that the least possible element that can be in our `greaterThanMax` list is always the h_index. So all we need to know is how many elements in our list are equal to h_index. We can use a hash table to store this.\\n\\nWhenever we encounter an element greater than h_index, we check if there is an element with the same value as h_index in the table. If so, we cannot increase h_index, but we can improve our state. The least element can be replaced by our current greater element, and we do that by decrementing the value in the table at h_index.\\n\\nWe also put this larger element in our hash table and increment it by one, since this element can be the least limiting element in the future.\\n\\nFinally, here\\'s the code that implements this:\\n\\n```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        int N = citations.length;\\n\\t\\t\\n\\t\\t/* h_index can range from 0 to number of citations, hence the size+1 */\\n        int[] table = new int[N+1];\\n        \\n\\t\\t/* maintains max possible H-Index at ith index */\\n\\t\\tint max = 0;\\n        \\n\\t\\tfor (int i = 0; i < N; i++) {\\n            int x = citations[i];\\n        \\n\\t\\t\\t/* elements less than current h_index cannot affect its value */\\n\\t\\t\\tif(x<=max) continue;\\n            \\n\\t\\t\\t/* element which is greater than no. of citations is equivalent to maximum h_index value possible */\\n            table[Math.min(x,N)]++; \\n            \\n\\t\\t\\t/* we can only increment h_index if there\\'s no element in our \"list\" with same value as h_index, otherwise we can only improve our state */\\n            if(table[max]>0) table[max]--;\\n\\t\\t\\telse max++;\\n        }\\n        \\n\\t\\treturn max;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        int N = citations.length;\\n\\t\\t\\n\\t\\t/* h_index can range from 0 to number of citations, hence the size+1 */\\n        int[] table = new int[N+1];\\n        \\n\\t\\t/* maintains max possible H-Index at ith index */\\n\\t\\tint max = 0;\\n        \\n\\t\\tfor (int i = 0; i < N; i++) {\\n            int x = citations[i];\\n        \\n\\t\\t\\t/* elements less than current h_index cannot affect its value */\\n\\t\\t\\tif(x<=max) continue;\\n            \\n\\t\\t\\t/* element which is greater than no. of citations is equivalent to maximum h_index value possible */\\n            table[Math.min(x,N)]++; \\n            \\n\\t\\t\\t/* we can only increment h_index if there\\'s no element in our \"list\" with same value as h_index, otherwise we can only improve our state */\\n            if(table[max]>0) table[max]--;\\n\\t\\t\\telse max++;\\n        }\\n        \\n\\t\\treturn max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 420554,
                "title": "java-0-n-compact-solution",
                "content": "```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        int n = citations.length;\\n        int[] map = new int[n + 1];\\n\\n        for (int val : citations) {\\n            map[Math.min(val, n)] += 1;\\n        }\\n        \\n        int sum = 0;\\n        while (n > 0) {\\n            sum += map[n];\\n            if (sum >= n) {\\n                return n;\\n            }\\n            \\n            n--;\\n        }\\n        \\n        return n;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        int n = citations.length;\\n        int[] map = new int[n + 1];\\n\\n        for (int val : citations) {\\n            map[Math.min(val, n)] += 1;\\n        }\\n        \\n        int sum = 0;\\n        while (n > 0) {\\n            sum += map[n];\\n            if (sum >= n) {\\n                return n;\\n            }\\n            \\n            n--;\\n        }\\n        \\n        return n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 359359,
                "title": "a-few-lines-of-javascript-without-map",
                "content": "```\\n/**\\n * @param {number[]} citations\\n * @return {number}\\n */\\nvar hIndex = function(citations) {    \\n    let pass = [];\\n    \\n    for (let i = 0; i < citations.length; i++) {\\n        if (citations[i] > pass.length) {\\n            pass.push(citations[i]);\\n            \\n            if (Math.min(...pass) < pass.length) {\\n                pass.splice(pass.indexOf(Math.min(...pass)), 1);\\n            }\\n        }\\n    }\\n    \\n    return pass.length;\\n};\\n```\\n\\nExplaination: the if (Math.min(...pass) < pass.length) removes paper less than the updated citations after push.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} citations\\n * @return {number}\\n */\\nvar hIndex = function(citations) {    \\n    let pass = [];\\n    \\n    for (let i = 0; i < citations.length; i++) {\\n        if (citations[i] > pass.length) {\\n            pass.push(citations[i]);\\n            \\n            if (Math.min(...pass) < pass.length) {\\n                pass.splice(pass.indexOf(Math.min(...pass)), 1);\\n            }\\n        }\\n    }\\n    \\n    return pass.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 179097,
                "title": "java-quick-select-solution",
                "content": "```\\n    public int hIndex(int[] c) {\\n        if(c.length == 0) return 0;\\n        int l = 0, h = c.length - 1;\\n        while(l < h) {\\n            int pos = partition(c, l, h);\\n            if(c[pos] >= pos + 1) {\\n                l = pos + 1;\\n            } else {\\n                h = pos - 1;\\n            }\\n        }\\n        if(l == c.length) return l;\\n        return c[l] >= l + 1 ? l + 1 : l;\\n    }\\n    \\n    int partition(int[] c, int s, int e) {\\n        int pivot = c[e];\\n        int j = s;\\n        for(int i = s; i < e; i++) {\\n          if(c[i] > pivot) swap(c, i, j++);  \\n        }\\n        swap(c, j, e);\\n        return j;\\n    }\\n    \\n    void swap(int[] c, int i, int j) {\\n        int t = c[i];\\n        c[i] = c[j];\\n        c[j] = t;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int hIndex(int[] c) {\\n        if(c.length == 0) return 0;\\n        int l = 0, h = c.length - 1;\\n        while(l < h) {\\n            int pos = partition(c, l, h);\\n            if(c[pos] >= pos + 1) {\\n                l = pos + 1;\\n            } else {\\n                h = pos - 1;\\n            }\\n        }\\n        if(l == c.length) return l;\\n        return c[l] >= l + 1 ? l + 1 : l;\\n    }\\n    \\n    int partition(int[] c, int s, int e) {\\n        int pivot = c[e];\\n        int j = s;\\n        for(int i = s; i < e; i++) {\\n          if(c[i] > pivot) swap(c, i, j++);  \\n        }\\n        swap(c, j, e);\\n        return j;\\n    }\\n    \\n    void swap(int[] c, int i, int j) {\\n        int t = c[i];\\n        c[i] = c[j];\\n        c[j] = t;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 70844,
                "title": "with-and-without-sort-java-ac-solution",
                "content": "Below is using `sort()`. The idea is actually the same with no sort() solution. The most significant disadvantage I think is not the time performance, is the `if statement`, I tried many times to pass all the test cases.....\\n```\\npublic int hIndex(int[] c) {\\n        if (c.length == 0) return 0;\\n        int len = c.length;\\n        Arrays.sort(c);\\n        \\n        int count = 0;\\n        int h = 1;\\n        \\n        for (int i = len - 1; i >= 0; i--) {\\n            h = c[i];\\n            count++;\\n            if (count == h) return h;\\n            if (count > h && count > 1) return Math.min(count - 1, c[i + 1]);\\n            if (count == 1 && count > h) return 0;\\n        }\\n        return count;\\n    }\\n```\\n\\nWithout `sort()`, this method actually also *sorts* (not real sort, but kind of sort) the citation, just by ourselves instead of `sort()`. \\n```\\npublic int hIndex(int[] c) {\\n        int n = c.length;\\n        if (n == 0) return 0;\\n        \\n        // the number of high citations\\n        int[] record = new int[n + 1];\\n        \\n        // count the citations\\n        for (int i : c) {\\n            if (i >= n) record[n]++;\\n            else record[i]++;\\n        }\\n        \\n        // get the h\\n        int count = 0;\\n        for (int i = n; i > 0; i--) {\\n            count += record[i];\\n            if (count >= i) {\\n                return i;\\n            } \\n        }\\n        return 0;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int hIndex(int[] c) {\\n        if (c.length == 0) return 0;\\n        int len = c.length;\\n        Arrays.sort(c);\\n        \\n        int count = 0;\\n        int h = 1;\\n        \\n        for (int i = len - 1; i >= 0; i--) {\\n            h = c[i];\\n            count++;\\n            if (count == h) return h;\\n            if (count > h && count > 1) return Math.min(count - 1, c[i + 1]);\\n            if (count == 1 && count > h) return 0;\\n        }\\n        return count;\\n    }\\n```\n```\\npublic int hIndex(int[] c) {\\n        int n = c.length;\\n        if (n == 0) return 0;\\n        \\n        // the number of high citations\\n        int[] record = new int[n + 1];\\n        \\n        // count the citations\\n        for (int i : c) {\\n            if (i >= n) record[n]++;\\n            else record[i]++;\\n        }\\n        \\n        // get the h\\n        int count = 0;\\n        for (int i = n; i > 0; i--) {\\n            count += record[i];\\n            if (count >= i) {\\n                return i;\\n            } \\n        }\\n        return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 70909,
                "title": "o-n-5-lines-1ms-concise-code",
                "content": "    public int hIndex(int[] citations) {\\n            int n = citations.length, h = n, sum;\\n            int[] cnt = new int[n + 1];\\n            for (int c : citations) cnt[Math.min(n, c)]++;\\n            for (h = n, sum = cnt[n]; sum < h; sum += cnt[--h]);\\n            return h;\\n        }",
                "solutionTags": [],
                "code": "    public int hIndex(int[] citations) {\\n            int n = citations.length, h = n, sum;\\n            int[] cnt = new int[n + 1];\\n            for (int c : citations) cnt[Math.min(n, c)]++;\\n            for (h = n, sum = cnt[n]; sum < h; sum += cnt[--h]);\\n            return h;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 70920,
                "title": "8ms-golang-solution-with-o-n-space-o-n-time",
                "content": "    func hIndex(citations []int) int {\\n    \\tm, max := make(map[int]int), 0\\n    \\tfor _, v := range citations {\\n    \\t\\tm[v]++\\n    \\t}\\n    \\tfor i, h := 0, len(citations); i <= h; i++ {\\n    \\t\\tmax = i\\n    \\t\\th = h - m[i]\\n    \\t}\\n    \\treturn max\\n    }",
                "solutionTags": [
                    "Go"
                ],
                "code": "    func hIndex(citations []int) int {\\n    \\tm, max := make(map[int]int), 0\\n    \\tfor _, v := range citations {\\n    \\t\\tm[v]++\\n    \\t}\\n    \\tfor i, h := 0, len(citations); i <= h; i++ {\\n    \\t\\tmax = i\\n    \\t\\th = h - m[i]\\n    \\t}\\n    \\treturn max\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 70928,
                "title": "easy-java-solution-with-comments-runs-in-2ms",
                "content": "public class Solution {\\n    public int hIndex(int[] citations) {\\n        \\n        //Base case : if array is empty, return 0\\n        if(citations==null || citations.length==0 )\\n            return 0;\\n        \\n        //if array has 1 element greater than 0, return 1    \\n        if(citations.length==1 && citations[0]>=1)\\n            return 1;\\n            \\n        //sort the array\\n        Arrays.sort(citations);\\n            \\n        //variable to keep track of length of array, hIndex\\n        int length=citations.length;\\n        int hIndex=0;\\n        \\n        //for loop to traverse the array\\n        for(int i=length-1;i>=0;i--)\\n        {\\n            //if value is present in array\\n            if(length-i==citations[i])\\n            {\\n                hIndex=citations[i];\\n            }\\n            else\\n            {\\n                //if value is not present in array\\n                if(i>0 &&citations[i-1]<=length-i && citations[i]>=length-i)\\n                    hIndex=length-i;\\n            }\\n            \\n            \\n        }\\n        \\n        //first element is greater than 0, and hash index is 0, return the length of the array as answer\\n        if(citations.length>1 && citations[0]>citations.length && hIndex==0)\\n            hIndex=citations.length;\\n        \\n        \\n        //return the answer\\n        return hIndex;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int hIndex(int[] citations) {\\n        \\n        //Base case : if array is empty, return 0\\n        if(citations==null || citations.length==0 )\\n            return 0;\\n        \\n        //if array has 1 element greater than 0, return 1    \\n        if(citations.length==1 && citations[0]>=1)\\n            return 1;\\n            \\n        //sort the array\\n        Arrays.sort(citations);\\n            \\n        //variable to keep track of length of array, hIndex\\n        int length=citations.length;\\n        int hIndex=0;\\n        \\n        //for loop to traverse the array\\n        for(int i=length-1;i>=0;i--)\\n        {\\n            //if value is present in array\\n            if(length-i==citations[i])\\n            {\\n                hIndex=citations[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 70949,
                "title": "c-solution-with-o-n-time-and-o-n-space",
                "content": "    int hIndex(int* citations, int citationsSize) {\\n        if (!citations || (citationsSize <= 0)) return 0;\\n        const int N = citationsSize;\\n        int hi[N + 1];\\n        int i, h;\\n        memset(hi, 0, sizeof(int) * (N + 1));\\n        for (i = 0; i < N; i++) {\\n            h = citations[i];\\n            if (h > N) h = N; // If a paper has > N citations, treat it as N citations\\n            hi[h]++;\\n        }\\n        for (i = N; i > 0; i--) {\\n            if (hi[i] >= i) return i; // At least i papers has >= i citations\\n            hi[i - 1] += hi[i];\\n        }\\n        return 0;\\n    }",
                "solutionTags": [],
                "code": "    int hIndex(int* citations, int citationsSize) {\\n        if (!citations || (citationsSize <= 0)) return 0;\\n        const int N = citationsSize;\\n        int hi[N + 1];\\n        int i, h;\\n        memset(hi, 0, sizeof(int) * (N + 1));\\n        for (i = 0; i < N; i++) {\\n            h = citations[i];\\n            if (h > N) h = N; // If a paper has > N citations, treat it as N citations\\n            hi[h]++;\\n        }\\n        for (i = N; i > 0; i--) {\\n            if (hi[i] >= i) return i; // At least i papers has >= i citations\\n            hi[i - 1] += hi[i];\\n        }\\n        return 0;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 70952,
                "title": "12-line-of-c-code-o-n-0-00012s-execution-time-3-solutions-inside",
                "content": "## my best solution as described in the title\\n\\n     class Solution {\\n        public:\\n            int cycle(vector<int>& citations){\\n                // there are 'flag' nums greater than 'ret + 1'\\n                int ret = 0, flag = 0, size = citations.size();\\n                int record[size + 1];\\n                memset(record, 0, sizeof(record));\\n                for (int i = 0; i < size; ++i){\\n                    int cur = citations[i];\\n                    if (cur >= size) record[size]++;\\n                    else record[cur] += 1;\\n                    if (cur <= ret) continue;\\n                    if (++flag < ret + 1) continue;\\n                    flag -= record[++ret];\\n                }\\n                return ret;\\n            }\\n        \\n            int hIndex(vector<int>& citations) {\\n                for (int i = 0; i < 99; ++i) cycle(citations);\\n                return cycle(citations);   \\n            }\\n        };\\n\\nSince the execution time is so fast, I wrap it with a 100 times cycle. \\nWhile it still only needs 12ms time.\\n\\n**several tips to consider:**\\nlet's assume the total num of vector is 6\\n\\n1. the answer must be less than or equal 6.\\n2. any number larger than 6 can be treated the same as 6.\\n3. record 2 number: flag and ret. which means there are 'flag' nums greater than 'ret + 1'\\n4. iterate the vector once, and the ret is what the solution is.\\n\\n\\n##here I provide another 2 solutions: \\n### second solution:\\nthe second solution is the same idea with the first but I use `unordered_map`, which takes much more time of 2.56ms:\\n\\n    class Solution {\\n    public:\\n        int cycle(vector<int>& citations){\\n            // there are 'flag' nums greater than 'ret + 1'\\n            int ret = 0, flag = 0;\\n            unordered_map<int, int> uii;\\n            for (int i = 0; i < citations.size(); ++i){\\n                int cur = citations[i];\\n                uii[cur] += 1;\\n                if (cur <= ret) continue;\\n                if (++flag >= ret + 1){\\n                    ++ret;\\n                    flag -= uii[ret];\\n                }\\n            }\\n            return ret;\\n        }\\n    \\n        int hIndex(vector<int>& citations) {\\n            for (int i = 0; i < 99; ++i) cycle(citations);\\n            return cycle(citations);   \\n        }\\n    };\\n\\n### the third solution:\\nit sorts the vector first. time complexity of O(n*logn), **it is faster than the second(1.16ms), amazing!**\\n\\n    class Solution {\\n    public:\\n        int cycle(vector<int>& citations){\\n            sort(citations.begin(), citations.end());\\n            int i = citations.size() - 1;\\n            for (; i >= 0; --i){\\n                int c = citations.size() - i;\\n                if (citations[i] < c) break;\\n            }\\n            return citations.size() - 1 -i;\\n        }\\n    \\n        int hIndex(vector<int>& citations) {\\n            for (int i = 0; i < 99; ++i) cycle(citations);\\n            return cycle(citations);   \\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "class Solution {\\n        public:\\n            int cycle(vector<int>& citations){\\n                // there are 'flag' nums greater than 'ret + 1'\\n                int ret = 0, flag = 0, size = citations.size();\\n                int record[size + 1];\\n                memset(record, 0, sizeof(record));\\n                for (int i = 0; i < size; ++i){\\n                    int cur = citations[i];\\n                    if (cur >= size) record[size]++;\\n                    else record[cur] += 1;\\n                    if (cur <= ret) continue;\\n                    if (++flag < ret + 1) continue;\\n                    flag -= record[++ret];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 70969,
                "title": "share-my-c-solution-using-o-1-space-and-o-n-average-time",
                "content": "the algorithm is binary search and the partition of qsort. Here is my code: \\n\\n    class Solution {\\n    public:\\n        int hIndex(vector<int>& citations) {\\n            int l = 0, r = citations.size(), ans = 0; \\n            while (l < r) {\\n                int pix = citations[l];\\n                int i = l, j = r; \\n                while (i < j) {  \\n                    while (i < --j && citations[j] < pix); \\n                    while (++i < j && citations[i] >= pix);\\n                    if (i < j) {\\n                        swap(citations[i], citations[j]); \\n                    }\\n                }\\n                swap(citations[j], citations[l]); \\n                if (pix >= j + 1) {\\n                    ans = j + 1; \\n                    l = j + 1; \\n                } else {\\n                    r = j; \\n                }\\n            }\\n            return l; \\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int hIndex(vector<int>& citations) {\\n            int l = 0, r = citations.size(), ans = 0; \\n            while (l < r) {\\n                int pix = citations[l];\\n                int i = l, j = r; \\n                while (i < j) {  \\n                    while (i < --j && citations[j] < pix); \\n                    while (++i < j && citations[i] >= pix);\\n                    if (i < j) {\\n                        swap(citations[i], citations[j]); \\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 70991,
                "title": "6-line-concise-java-sort-solution",
                "content": "    public int hIndex(int[] citations) {\\n    \\n    \\t\\tArrays.sort(citations);\\n    \\n    \\t\\tint h_index = 0;\\n    \\t\\tfor (int i = citations.length - 1; i >= 0; i--)\\n    \\t\\t\\tif (citations[i] > h_index)\\n    \\t\\t\\t\\th_index++;\\n    \\n    \\t\\treturn h_index;\\n    \\t}",
                "solutionTags": [],
                "code": "    public int hIndex(int[] citations) {\\n    \\n    \\t\\tArrays.sort(citations);\\n    \\n    \\t\\tint h_index = 0;\\n    \\t\\tfor (int i = citations.length - 1; i >= 0; i--)\\n    \\t\\t\\tif (citations[i] > h_index)\\n    \\t\\t\\t\\th_index++;\\n    \\n    \\t\\treturn h_index;\\n    \\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 70966,
                "title": "fast-java-solution",
                "content": "    public class Solution {\\n        public int hIndex(int[] citations) {\\n            int len = citations.length;\\n            int[] map = new int[len + 1];\\n            for (int i = 0; i < len; i++) {\\n                if (citations[i] >= len) map[len]++;\\n                else map[citations[i]]++;\\n            }\\n            for (int i = len; i >= 1; i--) {\\n                if (map[i] >= i) return i;\\n                map[i - 1] += map[i];\\n            }\\n            return 0;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int hIndex(int[] citations) {\\n            int len = citations.length;\\n            int[] map = new int[len + 1];\\n            for (int i = 0; i < len; i++) {\\n                if (citations[i] >= len) map[len]++;\\n                else map[citations[i]]++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 71025,
                "title": "c-solution-using-heap-faster-than-sort",
                "content": "    int hIndex(vector<int>& citations) {\\n        int len = citations.size(), last = INT_MIN;\\n        make_heap(citations.begin(),citations.end(),greater<int>());\\n        for (int h = len;h >0;--h) {\\n            if (citations[0] >= h && last <= h)\\n                return h;\\n            last = citations[0];\\n            pop_heap(citations.begin(),citations.end()-(len-h),greater<int>());\\n        }\\n        return 0;\\n    }",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "    int hIndex(vector<int>& citations) {\\n        int len = citations.size(), last = INT_MIN;\\n        make_heap(citations.begin(),citations.end(),greater<int>());\\n        for (int h = len;h >0;--h) {\\n            if (citations[0] >= h && last <= h)\\n                return h;\\n            last = citations[0];\\n            pop_heap(citations.begin(),citations.end()-(len-h),greater<int>());\\n        }\\n        return 0;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4044089,
                "title": "o-n-kotlin-solution-without-sorting",
                "content": "# Intuition\\nA lot of solutions here rely on sorting the input array which isn\\'t very elegant. An $$O(n)$$ solution is possible using a cache.\\n\\n# Approach\\n$$P$$ is a set of citation counts (papers) $$ p_i^k $$. We can define a function $$\\\\phi(P, c)$$ that counts the number of papers in $$P$$ having a citation count as least as big as $$c$$.\\n\\n$ \\\\phi(P, c) = \\\\sum_{0}^{n} \\\\delta[p_i^k \\\\ge c]  $\\n\\nWe can rewrite the sum as:\\n\\n$$ \\\\phi(P, c) = \\\\sum_{c}^{1000} \\\\sum_{0}^{n} \\\\delta[p_i^k = c] $$\\n\\nWhere the inner sum is the count of all papers with a given citation count ($$C(P, c)$$). Note that $$\\\\phi$$ is decreasing in $$c$$ and that we can efficiently calculate $$C(P, c)$$ in one pass over the input.\\n\\nTo compute the H-index for $$P$$ we need:\\n$$ \\\\text{H}(P) = \\\\underset{c}{\\\\arg\\\\max} \\\\{ \\\\phi(P, c) : \\\\phi(P, c) \\\\ge c \\\\} = \\\\underset{c}{\\\\arg\\\\max} \\\\{ \\\\sum_{c}^{1000} C(P, c) : \\\\sum_{c}^{1000} C(P, c)  \\\\ge c \\\\} $$\\n\\nBecause $$\\\\phi$$ is decreasing in $$c$$, finding the value of $$c$$ that maximises $$\\\\phi(P, c)$$ can be done by setting $$c=1000$$, calculating the sum $$\\\\sum_{c}^{1000} C(P, c)$$, halting and returning if the condition is met or decrementing $$c$$ and looping. This calculation takes constant time.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$, one pass across the input data\\n\\n- Space complexity:\\n$$O(1)$$, preallocated cache to hold $$C(P, c)$$\\n\\n# Code\\n```\\nclass Solution {\\n    fun hIndex(citations: IntArray): Int {\\n\\n        // Set up the cache to hold C(P, c)\\n        val counts = IntArray(1000) { 0 }\\n\\n        // Calculate C(P, c)\\n        for (c in citations) {\\n            counts[c]++\\n        }\\n\\n        // Calculate argmax_c starting at c=1000\\n        return counts.foldRightIndexed(0) { i, acc, c ->\\n\\n            // phi(P, i)\\n            val new = acc + c\\n\\n            // Check the halting condition\\n            if (new >= i) {\\n                return i\\n            }\\n            new\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun hIndex(citations: IntArray): Int {\\n\\n        // Set up the cache to hold C(P, c)\\n        val counts = IntArray(1000) { 0 }\\n\\n        // Calculate C(P, c)\\n        for (c in citations) {\\n            counts[c]++\\n        }\\n\\n        // Calculate argmax_c starting at c=1000\\n        return counts.foldRightIndexed(0) { i, acc, c ->\\n\\n            // phi(P, i)\\n            val new = acc + c\\n\\n            // Check the halting condition\\n            if (new >= i) {\\n                return i\\n            }\\n            new\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4019226,
                "title": "h-index",
                "content": "# Intuition\\nsorting the array: Why? read the Hvalue definition again.\\nNow, the largest no is at end and let the numbering from behind is from 1{n-i, 0<=i<=n-1} which acts as a possible Hvalue. Here, we can get some idea how we can get the h value. two things - no of elements(n-i) and element value(citation[i])\\n if(citations[i] >= n-i) hvalue = n-i \\ntry dry run on [5,0,0,0,0,8,9,6,3]\\n\\n# Complexity\\n- Time complexity: O(nlogn){sorting} + O(n){array traversal} => O(nlogn){overall complexity}\\n- for taversal we can also do binary search but with some modifications.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        int n = citations.size();\\n        if(n==1)\\n        {\\n            if(citations[0] >=1) return 1;\\n            else return 0;\\n        }\\n        sort(citations.begin(),citations.end());\\n\\n        int hValue=citations[0];\\n        for(int i = n-1 ;i>=0;i--)\\n        {\\n            if(citations[i] >= n-i) {hValue = n-i;}\\n        }\\n        return hValue;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        int n = citations.size();\\n        if(n==1)\\n        {\\n            if(citations[0] >=1) return 1;\\n            else return 0;\\n        }\\n        sort(citations.begin(),citations.end());\\n\\n        int hValue=citations[0];\\n        for(int i = n-1 ;i>=0;i--)\\n        {\\n            if(citations[i] >= n-i) {hValue = n-i;}\\n        }\\n        return hValue;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4008527,
                "title": "c-solution-with-bucket-sort-o-n",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nint hIndex(int* citations, int citationsSize){\\n    int *buckets = calloc(citationsSize+1, sizeof(*buckets));\\n\\n    for (int i = 0; i < citationsSize; ++i) {\\n        if(citations[i] >= citationsSize) {\\n            buckets[citationsSize]++;\\n        } else {\\n            buckets[citations[i]]++;\\n        }\\n    }\\n    int count = 0;\\n    for (int i = citationsSize; i >= 0; --i) {\\n        count += buckets[i];\\n        if (count >= i) {\\n            return i;\\n        }\\n    }\\n    free(buckets);\\n    \\n    return 0;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint hIndex(int* citations, int citationsSize){\\n    int *buckets = calloc(citationsSize+1, sizeof(*buckets));\\n\\n    for (int i = 0; i < citationsSize; ++i) {\\n        if(citations[i] >= citationsSize) {\\n            buckets[citationsSize]++;\\n        } else {\\n            buckets[citations[i]]++;\\n        }\\n    }\\n    int count = 0;\\n    for (int i = citationsSize; i >= 0; --i) {\\n        count += buckets[i];\\n        if (count >= i) {\\n            return i;\\n        }\\n    }\\n    free(buckets);\\n    \\n    return 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3975577,
                "title": "c-binary-search-nlogn",
                "content": "# Intuition\\n- Calculate the cound of element present in the right of current element including current one `countOfElementsInRightIncludingCurrent`\\n- if current citation count == `countOfElementsInRightIncludingCurrent`, that is the answer\\n- if current citation count < countOfElementsInRightIncludingCurrent, the possible answer will be present in the right\\n- else possible answer will be present in the left\\n- once the while loop is over, possible answer would be n - start;\\n\\n# Complexity\\n- Time complexity: O(nLogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int HIndex(int[] citations) {\\n        \\n        Array.Sort(citations);\\n        \\n        int n = citations.Length;\\n        int start = 0;\\n        int end = n - 1;\\n\\n        while(start <= end)\\n        {\\n            int mid = start +  (end - start)/2;\\n            int countOfElementsInRightIncludingCurrent = n - mid ;\\n\\n            if(citations[mid] == countOfElementsInRightIncludingCurrent){\\n                return citations[mid];\\n            }\\n            else if(citations[mid] < countOfElementsInRightIncludingCurrent)\\n            {\\n                start = mid + 1;\\n            }   \\n            else\\n                end = mid - 1;\\n        }\\n\\n        return n - start;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Binary Search"
                ],
                "code": "```\\npublic class Solution {\\n    public int HIndex(int[] citations) {\\n        \\n        Array.Sort(citations);\\n        \\n        int n = citations.Length;\\n        int start = 0;\\n        int end = n - 1;\\n\\n        while(start <= end)\\n        {\\n            int mid = start +  (end - start)/2;\\n            int countOfElementsInRightIncludingCurrent = n - mid ;\\n\\n            if(citations[mid] == countOfElementsInRightIncludingCurrent){\\n                return citations[mid];\\n            }\\n            else if(citations[mid] < countOfElementsInRightIncludingCurrent)\\n            {\\n                start = mid + 1;\\n            }   \\n            else\\n                end = mid - 1;\\n        }\\n\\n        return n - start;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3959453,
                "title": "swift-solution-using-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSort in decending order and then keep moving to index till we have \\n`sortedCitations[i] > i` and next index will be the answer, since the value at `index + 1` should be the min value present in all citations.\\n\\n# Complexity\\n- Time complexity:\\n$$ 0(2n) ~ sorting will also take 0(n)\\n\\n- Space complexity:\\n$$0(1)\\n\\n# Code\\n```\\nclass Solution {\\n    func hIndex(_ citations: [Int]) -> Int {\\n        let sortedCitations = citations.sorted {$0 > $1}\\n\\n        var i = 0 \\n        var hIndex = 0 \\n\\n        while i < sortedCitations.count {\\n            if sortedCitations[i] > i {\\n                hIndex = i + 1\\n            }\\n\\n            i += 1\\n        }\\n\\n        return hIndex\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func hIndex(_ citations: [Int]) -> Int {\\n        let sortedCitations = citations.sorted {$0 > $1}\\n\\n        var i = 0 \\n        var hIndex = 0 \\n\\n        while i < sortedCitations.count {\\n            if sortedCitations[i] > i {\\n                hIndex = i + 1\\n            }\\n\\n            i += 1\\n        }\\n\\n        return hIndex\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3904184,
                "title": "5-lines-of-code-the-easiest-solution-with-o-n-log-and-o-1-for-space-complexity",
                "content": "\\n# Approach\\n1. Let\\'s sort the given array and take a look at a random element.\\n\\n2. All elements after this element are greater or equal.\\n\\n3. So we can take Math.min(citations[i], n-i) elements including this one. The answer shall be the maximum of this calculated values for each i = 0...n-1\\n\\n# Complexity\\n- Time complexity:\\nO(n log)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} citations\\n * @return {number}\\n */\\nvar hIndex = function(citations) {\\n    citations.sort((a, b) => a - b)\\n    let result = 0;\\n    let n = citations.length;\\n    for(let i = 0; i < n; i++){\\n        result = Math.max(result, Math.min(citations[i], n-i))\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} citations\\n * @return {number}\\n */\\nvar hIndex = function(citations) {\\n    citations.sort((a, b) => a - b)\\n    let result = 0;\\n    let n = citations.length;\\n    for(let i = 0; i < n; i++){\\n        result = Math.max(result, Math.min(citations[i], n-i))\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3888144,
                "title": "o-n-using-hash-map-h-index-solution-beats-99-typescript",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nfunction hIndex(citations: number[]): number {\\n  const map = new Map<number, number>(); // <citations, papers count>\\n  let maxCitations = 0;\\n\\n  for (let currCitations of citations) {\\n    maxCitations = Math.max(currCitations, maxCitations);\\n    const papersCount = map.has(currCitations) ? map.get(currCitations) : 0;\\n    map.set(currCitations, papersCount + 1);\\n  }\\n\\n  let citationsPapers = 0;\\n\\n  for (let index = maxCitations; index > 0; index--) {\\n    const currCitationsPapers = map.get(index) || 0;\\n    citationsPapers += currCitationsPapers;\\n\\n    if (citationsPapers >= index) return index;\\n  }\\n\\n  return 0;\\n}\\n\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Hash Table"
                ],
                "code": "```\\nfunction hIndex(citations: number[]): number {\\n  const map = new Map<number, number>(); // <citations, papers count>\\n  let maxCitations = 0;\\n\\n  for (let currCitations of citations) {\\n    maxCitations = Math.max(currCitations, maxCitations);\\n    const papersCount = map.has(currCitations) ? map.get(currCitations) : 0;\\n    map.set(currCitations, papersCount + 1);\\n  }\\n\\n  let citationsPapers = 0;\\n\\n  for (let index = maxCitations; index > 0; index--) {\\n    const currCitationsPapers = map.get(index) || 0;\\n    citationsPapers += currCitationsPapers;\\n\\n    if (citationsPapers >= index) return index;\\n  }\\n\\n  return 0;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3847860,
                "title": "easy-approch",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} citations\\n * @return {number}\\n */\\nvar hIndex = function(citations) {\\n    const h = citations.length;\\n  citations.sort ((a,b)=>(a-b));\\n         let i;\\n    for(i=0;i<h;i++){\\n        if(h-i<=citations[i]){\\n            break;\\n        }\\n    }\\n    return h-i;\\n};\\n \\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} citations\\n * @return {number}\\n */\\nvar hIndex = function(citations) {\\n    const h = citations.length;\\n  citations.sort ((a,b)=>(a-b));\\n         let i;\\n    for(i=0;i<h;i++){\\n        if(h-i<=citations[i]){\\n            break;\\n        }\\n    }\\n    return h-i;\\n};\\n \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3839806,
                "title": "beats-98-78-using-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(log(len(citations)))$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        def util(mid):\\n            cnt = 0\\n            for citation in citations:\\n                if citation >= mid:\\n                    cnt += 1\\n            return cnt\\n\\n        left = 0\\n        right = len(citations)\\n        while left <= right:\\n            mid = (left + right) // 2\\n            res = util(mid)\\n            if res >= mid:\\n                left = mid + 1\\n            if res < mid:\\n                right = mid - 1\\n        return left - 1\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        def util(mid):\\n            cnt = 0\\n            for citation in citations:\\n                if citation >= mid:\\n                    cnt += 1\\n            return cnt\\n\\n        left = 0\\n        right = len(citations)\\n        while left <= right:\\n            mid = (left + right) // 2\\n            res = util(mid)\\n            if res >= mid:\\n                left = mid + 1\\n            if res < mid:\\n                right = mid - 1\\n        return left - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819863,
                "title": "c-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) \\n    {\\n        int ans=0;\\n        int n=citations.size();\\n        sort(citations.begin(),citations.begin()+n);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(citations[i]>= n-i) \\n            ans = max(ans, n-i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) \\n    {\\n        int ans=0;\\n        int n=citations.size();\\n        sort(citations.begin(),citations.begin()+n);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(citations[i]>= n-i) \\n            ans = max(ans, n-i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3772365,
                "title": "using-counting-sort-technique",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing Counting Sort Techinque\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n/**\\n    * For this input this how algo works citations = [3,0,6,1,5]\\n    * Freq array = [0, 0, 0, 0, 0, 0] => after all freq = [1, 1, 0, 1, 0, 2]\\n    * Cumative from reverse => where sum >= i \\n     */\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTC :- O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace Complexity:- O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n    /**\\n    * For this input this how algo works citations = [3,0,6,1,5]\\n    * Freq array = [0, 0, 0, 0, 0, 0] => after all freq = [1, 1, 0, 1, 0, 2]\\n    * Cumative from reverse => where sum >= i \\n     */\\n\\n        int[] freq = new int [citations.length+1];\\n        int freqSum =0;\\n        //Storing the citations frequency based on counting Sort\\n        for(int i=0; i<citations.length; i++){\\n            if(citations[i]>citations.length){\\n               freq[citations.length]=  freq[citations.length]+1;\\n            }else{\\n               freq[citations[i]] = freq[citations[i]]+1;\\n            }\\n        }\\n\\n        for(int j= citations.length; j>=0; j--){\\n            freqSum +=freq[j];\\n            if(freqSum >= j){\\n                return j;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n    /**\\n    * For this input this how algo works citations = [3,0,6,1,5]\\n    * Freq array = [0, 0, 0, 0, 0, 0] => after all freq = [1, 1, 0, 1, 0, 2]\\n    * Cumative from reverse => where sum >= i \\n     */\\n\\n        int[] freq = new int [citations.length+1];\\n        int freqSum =0;\\n        //Storing the citations frequency based on counting Sort\\n        for(int i=0; i<citations.length; i++){\\n            if(citations[i]>citations.length){\\n               freq[citations.length]=  freq[citations.length]+1;\\n            }else{\\n               freq[citations[i]] = freq[citations[i]]+1;\\n            }\\n        }\\n\\n        for(int j= citations.length; j>=0; j--){\\n            freqSum +=freq[j];\\n            if(freqSum >= j){\\n                return j;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3753679,
                "title": "java-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        if(citations == null || citations.length == 0) return 0;\\n    \\n    int n = citations.length;\\n    int[] num = new int[n+1];\\n    \\n    for(int i=0; i<n; i++) {\\n        if(citations[i]>n) num[n]++;\\n        else num[citations[i]]++;\\n    }\\n    \\n    if(num[n]>=n) return n;\\n    for(int i=n-1; i>=0; i--) {\\n        num[i] += num[i+1];\\n        if(num[i]>=i) return i;\\n    }\\n    return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        if(citations == null || citations.length == 0) return 0;\\n    \\n    int n = citations.length;\\n    int[] num = new int[n+1];\\n    \\n    for(int i=0; i<n; i++) {\\n        if(citations[i]>n) num[n]++;\\n        else num[citations[i]]++;\\n    }\\n    \\n    if(num[n]>=n) return n;\\n    for(int i=n-1; i>=0; i--) {\\n        num[i] += num[i+1];\\n        if(num[i]>=i) return i;\\n    }\\n    return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1870167,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Excuse me, what kind of madman has published 5000 highly-cited papers?\\nI swear that dude must know incredibly much about Riemannian geometry and incredibly little about women"
                    },
                    {
                        "username": "ignacioariasdev",
                        "content": "[@dungtuanuet](/dungtuanuet) what gives u money?"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "rolf\\n"
                    },
                    {
                        "username": "ourlord",
                        "content": "According to the hint, I tried my version with the build-in `sort()` and get a one time AC. But if in a real interview scenario, do we allow to use build-in sort to solve this problem?\\n\\nWhat would the actual point the interviewee might look for?"
                    },
                    {
                        "username": "isydor",
                        "content": "[@Tribhuwan-Joshi](/Tribhuwan-Joshi) it is literally mentioned on the wiki page..."
                    },
                    {
                        "username": "NareshSawlani",
                        "content": "interviewer would be looking for your approach like in this question it would be using count sort manually no API"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "Please don\\'t share hints like using `sort()` in the discussion "
                    },
                    {
                        "username": "haucaucau",
                        "content": "What if the input is [4,4,4,4,4,4,5]?\\nWhen I run with my code the answer is 4 and it was accepted.\\nBut I don\\'t understand cause there are 7 papers that have at least 4 citations,\\nand 0 paper no more than 4, which contradicts the description."
                    },
                    {
                        "username": "DxRz729",
                        "content": "Yes your the input has 7 papers with 4 citations, but the h in h-index means that it should be the same for no of citations and no of papers, so we will only take 4 papers as it is min of (4,7)"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": "[@hemantsingh4774](/hemantsingh4774)  reference: https://en.wikipedia.org/wiki/H-index"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": " For example, if an author has five publications, with 9, 7, 6, 2, and 1 citations (ordered from greatest to least), then the author\\'s h-index is 3, because the author has three publications with 3 or more citations. However, the author does not have four publications with 4 or more citations."
                    },
                    {
                        "username": "han35",
                        "content": "[0] means there is 1 paper and the citation is 0.\\nAccording to the description\\n\\n> A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each\\n\\nA scientist has 1(h) of his/her 1 paper has at least 0(h) citation, and the other 0 paper has no more than 0 citation.\\n\\nIs this a contradiction?"
                    },
                    {
                        "username": "yellowstar1014",
                        "content": "is it possible to have two h in this problem? please give an example?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "it literaly says to be a maximum value. how in the world would something have two distinct maximum values?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "![hehe.png](https://assets.leetcode.com/users/images/f16e4f9d-434f-4e5c-bf36-3cc106ea074a_1677794934.0254838.png)"
                    },
                    {
                        "username": "shuyi@cvs",
                        "content": "Hi,\\n\\nI came across a situation:  given citations = [3, 1, 7, 8, 9]. What will be the answer be?\\n\\nAccording to the definition of h-index on Wikipedia: \"A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\"\\n\\nWhen h=3, the definition will be \"A scientist has index 3 if 3 of his/her 5 papers have at least 3 citations each, and the other 2 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nWhen h=4, the definition will be \"A scientist has index 4 if 4 of his/her 5 papers have at least 4 citations each, and the other 1 papers have no more than 4 citations each.\" Obviously wrong....\\n\\nWhen h=2, the definition will be \"A scientist has index 2 if 2 of his/her 5 papers have at least 2 citations each, and the other 3 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nSo anybody can give me an answer? Or this question is a wrong one?"
                    },
                    {
                        "username": "user2118U",
                        "content": "Definition of h is The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times. See it is written at least h papers not exact h papers"
                    },
                    {
                        "username": "user2118U",
                        "content": "Dude there  is nothing written like that other papers have no more h citations. your example answer is 3 because researcher has published at least 3 papers and each paper has atleast 3 citations"
                    },
                    {
                        "username": "saurabh8katyal",
                        "content": "Answer will be 3, as the other 2 papers have no more than 3 citations each(1, 3). Not more than 3. Can be equal to."
                    },
                    {
                        "username": "Tsien",
                        "content": "In the problem description, there is a line \"Note: If there are several possible values for h, the maximum one is taken as the h-index.\"\\nI cannot come up with an example that could have several possible values for h. \\nIMO, there is only one value for h for each example according to the definition of H-Index.\\nPlease correct me if i'm wrong.\\nThanks!"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Anyone thought of Binary search, no need of sorting technique required,\\nDon\\'t open solution if you have not gave it a try using binary search:\\nhttps://leetcode.com/problems/h-index/solutions/3741453/easy-binary-search-problem-no-sorting-technique-required-o-nlogn/ "
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "[@RajputShivraj](/RajputShivraj) He probably meant to apply binary search on the answer and not on the given array."
                    },
                    {
                        "username": "CriticalCorduroy",
                        "content": "How would binary search be beneficial without a sort applied to the citations?"
                    },
                    {
                        "username": "RajputShivraj",
                        "content": "binary search can be applied on sorted arrays na and you are saying no need of sorting techniques\\n"
                    },
                    {
                        "username": "lowiq",
                        "content": "According to the definition of h, \"if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\" Looks like the h value is unique. The \"Note\" part looks unnecessary. \\n\\nProof: say there exist two h-indices, h1 < h2 (1), which means that, there are h2 numbers have value at least h2 (2) and N-h2 values have value at most h2 (3); there are h1 numbers have value at least h1 (4) and N-h1 values have value at most h1(5).\\n\\nWe have (1)(2)(3), (1) and (2) implies (4), but we can see (5) is not possible. Because we have N-h1 > N-h2, there exists at least one paper not in the set of N-h2 but in the set of N-h1, this paper should have value <= h1 (according to 5) and have value >= h2 (according to 2), this contradicts to (1). \\n\\nThe uniqueness follows."
                    },
                    {
                        "username": "job_xu",
                        "content": "Have two questions about the example 1:why not 5? There are two papers be cited at least 5 times.  why not 1? There are four papers be cited at least 1 times.  "
                    },
                    {
                        "username": "shivam_sharma2004",
                        "content": "5 cant be the ans because there do not exist atleast 5 elements in the array which are greater than 5. Talking about 1 yes it is valid value of h but you need to return the max value of h possible which is 3 in this case ."
                    }
                ]
            },
            {
                "id": 1565530,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Excuse me, what kind of madman has published 5000 highly-cited papers?\\nI swear that dude must know incredibly much about Riemannian geometry and incredibly little about women"
                    },
                    {
                        "username": "ignacioariasdev",
                        "content": "[@dungtuanuet](/dungtuanuet) what gives u money?"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "rolf\\n"
                    },
                    {
                        "username": "ourlord",
                        "content": "According to the hint, I tried my version with the build-in `sort()` and get a one time AC. But if in a real interview scenario, do we allow to use build-in sort to solve this problem?\\n\\nWhat would the actual point the interviewee might look for?"
                    },
                    {
                        "username": "isydor",
                        "content": "[@Tribhuwan-Joshi](/Tribhuwan-Joshi) it is literally mentioned on the wiki page..."
                    },
                    {
                        "username": "NareshSawlani",
                        "content": "interviewer would be looking for your approach like in this question it would be using count sort manually no API"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "Please don\\'t share hints like using `sort()` in the discussion "
                    },
                    {
                        "username": "haucaucau",
                        "content": "What if the input is [4,4,4,4,4,4,5]?\\nWhen I run with my code the answer is 4 and it was accepted.\\nBut I don\\'t understand cause there are 7 papers that have at least 4 citations,\\nand 0 paper no more than 4, which contradicts the description."
                    },
                    {
                        "username": "DxRz729",
                        "content": "Yes your the input has 7 papers with 4 citations, but the h in h-index means that it should be the same for no of citations and no of papers, so we will only take 4 papers as it is min of (4,7)"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": "[@hemantsingh4774](/hemantsingh4774)  reference: https://en.wikipedia.org/wiki/H-index"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": " For example, if an author has five publications, with 9, 7, 6, 2, and 1 citations (ordered from greatest to least), then the author\\'s h-index is 3, because the author has three publications with 3 or more citations. However, the author does not have four publications with 4 or more citations."
                    },
                    {
                        "username": "han35",
                        "content": "[0] means there is 1 paper and the citation is 0.\\nAccording to the description\\n\\n> A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each\\n\\nA scientist has 1(h) of his/her 1 paper has at least 0(h) citation, and the other 0 paper has no more than 0 citation.\\n\\nIs this a contradiction?"
                    },
                    {
                        "username": "yellowstar1014",
                        "content": "is it possible to have two h in this problem? please give an example?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "it literaly says to be a maximum value. how in the world would something have two distinct maximum values?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "![hehe.png](https://assets.leetcode.com/users/images/f16e4f9d-434f-4e5c-bf36-3cc106ea074a_1677794934.0254838.png)"
                    },
                    {
                        "username": "shuyi@cvs",
                        "content": "Hi,\\n\\nI came across a situation:  given citations = [3, 1, 7, 8, 9]. What will be the answer be?\\n\\nAccording to the definition of h-index on Wikipedia: \"A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\"\\n\\nWhen h=3, the definition will be \"A scientist has index 3 if 3 of his/her 5 papers have at least 3 citations each, and the other 2 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nWhen h=4, the definition will be \"A scientist has index 4 if 4 of his/her 5 papers have at least 4 citations each, and the other 1 papers have no more than 4 citations each.\" Obviously wrong....\\n\\nWhen h=2, the definition will be \"A scientist has index 2 if 2 of his/her 5 papers have at least 2 citations each, and the other 3 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nSo anybody can give me an answer? Or this question is a wrong one?"
                    },
                    {
                        "username": "user2118U",
                        "content": "Definition of h is The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times. See it is written at least h papers not exact h papers"
                    },
                    {
                        "username": "user2118U",
                        "content": "Dude there  is nothing written like that other papers have no more h citations. your example answer is 3 because researcher has published at least 3 papers and each paper has atleast 3 citations"
                    },
                    {
                        "username": "saurabh8katyal",
                        "content": "Answer will be 3, as the other 2 papers have no more than 3 citations each(1, 3). Not more than 3. Can be equal to."
                    },
                    {
                        "username": "Tsien",
                        "content": "In the problem description, there is a line \"Note: If there are several possible values for h, the maximum one is taken as the h-index.\"\\nI cannot come up with an example that could have several possible values for h. \\nIMO, there is only one value for h for each example according to the definition of H-Index.\\nPlease correct me if i'm wrong.\\nThanks!"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Anyone thought of Binary search, no need of sorting technique required,\\nDon\\'t open solution if you have not gave it a try using binary search:\\nhttps://leetcode.com/problems/h-index/solutions/3741453/easy-binary-search-problem-no-sorting-technique-required-o-nlogn/ "
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "[@RajputShivraj](/RajputShivraj) He probably meant to apply binary search on the answer and not on the given array."
                    },
                    {
                        "username": "CriticalCorduroy",
                        "content": "How would binary search be beneficial without a sort applied to the citations?"
                    },
                    {
                        "username": "RajputShivraj",
                        "content": "binary search can be applied on sorted arrays na and you are saying no need of sorting techniques\\n"
                    },
                    {
                        "username": "lowiq",
                        "content": "According to the definition of h, \"if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\" Looks like the h value is unique. The \"Note\" part looks unnecessary. \\n\\nProof: say there exist two h-indices, h1 < h2 (1), which means that, there are h2 numbers have value at least h2 (2) and N-h2 values have value at most h2 (3); there are h1 numbers have value at least h1 (4) and N-h1 values have value at most h1(5).\\n\\nWe have (1)(2)(3), (1) and (2) implies (4), but we can see (5) is not possible. Because we have N-h1 > N-h2, there exists at least one paper not in the set of N-h2 but in the set of N-h1, this paper should have value <= h1 (according to 5) and have value >= h2 (according to 2), this contradicts to (1). \\n\\nThe uniqueness follows."
                    },
                    {
                        "username": "job_xu",
                        "content": "Have two questions about the example 1:why not 5? There are two papers be cited at least 5 times.  why not 1? There are four papers be cited at least 1 times.  "
                    },
                    {
                        "username": "shivam_sharma2004",
                        "content": "5 cant be the ans because there do not exist atleast 5 elements in the array which are greater than 5. Talking about 1 yes it is valid value of h but you need to return the max value of h possible which is 3 in this case ."
                    }
                ]
            },
            {
                "id": 1573901,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Excuse me, what kind of madman has published 5000 highly-cited papers?\\nI swear that dude must know incredibly much about Riemannian geometry and incredibly little about women"
                    },
                    {
                        "username": "ignacioariasdev",
                        "content": "[@dungtuanuet](/dungtuanuet) what gives u money?"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "rolf\\n"
                    },
                    {
                        "username": "ourlord",
                        "content": "According to the hint, I tried my version with the build-in `sort()` and get a one time AC. But if in a real interview scenario, do we allow to use build-in sort to solve this problem?\\n\\nWhat would the actual point the interviewee might look for?"
                    },
                    {
                        "username": "isydor",
                        "content": "[@Tribhuwan-Joshi](/Tribhuwan-Joshi) it is literally mentioned on the wiki page..."
                    },
                    {
                        "username": "NareshSawlani",
                        "content": "interviewer would be looking for your approach like in this question it would be using count sort manually no API"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "Please don\\'t share hints like using `sort()` in the discussion "
                    },
                    {
                        "username": "haucaucau",
                        "content": "What if the input is [4,4,4,4,4,4,5]?\\nWhen I run with my code the answer is 4 and it was accepted.\\nBut I don\\'t understand cause there are 7 papers that have at least 4 citations,\\nand 0 paper no more than 4, which contradicts the description."
                    },
                    {
                        "username": "DxRz729",
                        "content": "Yes your the input has 7 papers with 4 citations, but the h in h-index means that it should be the same for no of citations and no of papers, so we will only take 4 papers as it is min of (4,7)"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": "[@hemantsingh4774](/hemantsingh4774)  reference: https://en.wikipedia.org/wiki/H-index"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": " For example, if an author has five publications, with 9, 7, 6, 2, and 1 citations (ordered from greatest to least), then the author\\'s h-index is 3, because the author has three publications with 3 or more citations. However, the author does not have four publications with 4 or more citations."
                    },
                    {
                        "username": "han35",
                        "content": "[0] means there is 1 paper and the citation is 0.\\nAccording to the description\\n\\n> A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each\\n\\nA scientist has 1(h) of his/her 1 paper has at least 0(h) citation, and the other 0 paper has no more than 0 citation.\\n\\nIs this a contradiction?"
                    },
                    {
                        "username": "yellowstar1014",
                        "content": "is it possible to have two h in this problem? please give an example?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "it literaly says to be a maximum value. how in the world would something have two distinct maximum values?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "![hehe.png](https://assets.leetcode.com/users/images/f16e4f9d-434f-4e5c-bf36-3cc106ea074a_1677794934.0254838.png)"
                    },
                    {
                        "username": "shuyi@cvs",
                        "content": "Hi,\\n\\nI came across a situation:  given citations = [3, 1, 7, 8, 9]. What will be the answer be?\\n\\nAccording to the definition of h-index on Wikipedia: \"A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\"\\n\\nWhen h=3, the definition will be \"A scientist has index 3 if 3 of his/her 5 papers have at least 3 citations each, and the other 2 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nWhen h=4, the definition will be \"A scientist has index 4 if 4 of his/her 5 papers have at least 4 citations each, and the other 1 papers have no more than 4 citations each.\" Obviously wrong....\\n\\nWhen h=2, the definition will be \"A scientist has index 2 if 2 of his/her 5 papers have at least 2 citations each, and the other 3 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nSo anybody can give me an answer? Or this question is a wrong one?"
                    },
                    {
                        "username": "user2118U",
                        "content": "Definition of h is The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times. See it is written at least h papers not exact h papers"
                    },
                    {
                        "username": "user2118U",
                        "content": "Dude there  is nothing written like that other papers have no more h citations. your example answer is 3 because researcher has published at least 3 papers and each paper has atleast 3 citations"
                    },
                    {
                        "username": "saurabh8katyal",
                        "content": "Answer will be 3, as the other 2 papers have no more than 3 citations each(1, 3). Not more than 3. Can be equal to."
                    },
                    {
                        "username": "Tsien",
                        "content": "In the problem description, there is a line \"Note: If there are several possible values for h, the maximum one is taken as the h-index.\"\\nI cannot come up with an example that could have several possible values for h. \\nIMO, there is only one value for h for each example according to the definition of H-Index.\\nPlease correct me if i'm wrong.\\nThanks!"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Anyone thought of Binary search, no need of sorting technique required,\\nDon\\'t open solution if you have not gave it a try using binary search:\\nhttps://leetcode.com/problems/h-index/solutions/3741453/easy-binary-search-problem-no-sorting-technique-required-o-nlogn/ "
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "[@RajputShivraj](/RajputShivraj) He probably meant to apply binary search on the answer and not on the given array."
                    },
                    {
                        "username": "CriticalCorduroy",
                        "content": "How would binary search be beneficial without a sort applied to the citations?"
                    },
                    {
                        "username": "RajputShivraj",
                        "content": "binary search can be applied on sorted arrays na and you are saying no need of sorting techniques\\n"
                    },
                    {
                        "username": "lowiq",
                        "content": "According to the definition of h, \"if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\" Looks like the h value is unique. The \"Note\" part looks unnecessary. \\n\\nProof: say there exist two h-indices, h1 < h2 (1), which means that, there are h2 numbers have value at least h2 (2) and N-h2 values have value at most h2 (3); there are h1 numbers have value at least h1 (4) and N-h1 values have value at most h1(5).\\n\\nWe have (1)(2)(3), (1) and (2) implies (4), but we can see (5) is not possible. Because we have N-h1 > N-h2, there exists at least one paper not in the set of N-h2 but in the set of N-h1, this paper should have value <= h1 (according to 5) and have value >= h2 (according to 2), this contradicts to (1). \\n\\nThe uniqueness follows."
                    },
                    {
                        "username": "job_xu",
                        "content": "Have two questions about the example 1:why not 5? There are two papers be cited at least 5 times.  why not 1? There are four papers be cited at least 1 times.  "
                    },
                    {
                        "username": "shivam_sharma2004",
                        "content": "5 cant be the ans because there do not exist atleast 5 elements in the array which are greater than 5. Talking about 1 yes it is valid value of h but you need to return the max value of h possible which is 3 in this case ."
                    }
                ]
            },
            {
                "id": 1567937,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Excuse me, what kind of madman has published 5000 highly-cited papers?\\nI swear that dude must know incredibly much about Riemannian geometry and incredibly little about women"
                    },
                    {
                        "username": "ignacioariasdev",
                        "content": "[@dungtuanuet](/dungtuanuet) what gives u money?"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "rolf\\n"
                    },
                    {
                        "username": "ourlord",
                        "content": "According to the hint, I tried my version with the build-in `sort()` and get a one time AC. But if in a real interview scenario, do we allow to use build-in sort to solve this problem?\\n\\nWhat would the actual point the interviewee might look for?"
                    },
                    {
                        "username": "isydor",
                        "content": "[@Tribhuwan-Joshi](/Tribhuwan-Joshi) it is literally mentioned on the wiki page..."
                    },
                    {
                        "username": "NareshSawlani",
                        "content": "interviewer would be looking for your approach like in this question it would be using count sort manually no API"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "Please don\\'t share hints like using `sort()` in the discussion "
                    },
                    {
                        "username": "haucaucau",
                        "content": "What if the input is [4,4,4,4,4,4,5]?\\nWhen I run with my code the answer is 4 and it was accepted.\\nBut I don\\'t understand cause there are 7 papers that have at least 4 citations,\\nand 0 paper no more than 4, which contradicts the description."
                    },
                    {
                        "username": "DxRz729",
                        "content": "Yes your the input has 7 papers with 4 citations, but the h in h-index means that it should be the same for no of citations and no of papers, so we will only take 4 papers as it is min of (4,7)"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": "[@hemantsingh4774](/hemantsingh4774)  reference: https://en.wikipedia.org/wiki/H-index"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": " For example, if an author has five publications, with 9, 7, 6, 2, and 1 citations (ordered from greatest to least), then the author\\'s h-index is 3, because the author has three publications with 3 or more citations. However, the author does not have four publications with 4 or more citations."
                    },
                    {
                        "username": "han35",
                        "content": "[0] means there is 1 paper and the citation is 0.\\nAccording to the description\\n\\n> A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each\\n\\nA scientist has 1(h) of his/her 1 paper has at least 0(h) citation, and the other 0 paper has no more than 0 citation.\\n\\nIs this a contradiction?"
                    },
                    {
                        "username": "yellowstar1014",
                        "content": "is it possible to have two h in this problem? please give an example?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "it literaly says to be a maximum value. how in the world would something have two distinct maximum values?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "![hehe.png](https://assets.leetcode.com/users/images/f16e4f9d-434f-4e5c-bf36-3cc106ea074a_1677794934.0254838.png)"
                    },
                    {
                        "username": "shuyi@cvs",
                        "content": "Hi,\\n\\nI came across a situation:  given citations = [3, 1, 7, 8, 9]. What will be the answer be?\\n\\nAccording to the definition of h-index on Wikipedia: \"A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\"\\n\\nWhen h=3, the definition will be \"A scientist has index 3 if 3 of his/her 5 papers have at least 3 citations each, and the other 2 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nWhen h=4, the definition will be \"A scientist has index 4 if 4 of his/her 5 papers have at least 4 citations each, and the other 1 papers have no more than 4 citations each.\" Obviously wrong....\\n\\nWhen h=2, the definition will be \"A scientist has index 2 if 2 of his/her 5 papers have at least 2 citations each, and the other 3 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nSo anybody can give me an answer? Or this question is a wrong one?"
                    },
                    {
                        "username": "user2118U",
                        "content": "Definition of h is The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times. See it is written at least h papers not exact h papers"
                    },
                    {
                        "username": "user2118U",
                        "content": "Dude there  is nothing written like that other papers have no more h citations. your example answer is 3 because researcher has published at least 3 papers and each paper has atleast 3 citations"
                    },
                    {
                        "username": "saurabh8katyal",
                        "content": "Answer will be 3, as the other 2 papers have no more than 3 citations each(1, 3). Not more than 3. Can be equal to."
                    },
                    {
                        "username": "Tsien",
                        "content": "In the problem description, there is a line \"Note: If there are several possible values for h, the maximum one is taken as the h-index.\"\\nI cannot come up with an example that could have several possible values for h. \\nIMO, there is only one value for h for each example according to the definition of H-Index.\\nPlease correct me if i'm wrong.\\nThanks!"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Anyone thought of Binary search, no need of sorting technique required,\\nDon\\'t open solution if you have not gave it a try using binary search:\\nhttps://leetcode.com/problems/h-index/solutions/3741453/easy-binary-search-problem-no-sorting-technique-required-o-nlogn/ "
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "[@RajputShivraj](/RajputShivraj) He probably meant to apply binary search on the answer and not on the given array."
                    },
                    {
                        "username": "CriticalCorduroy",
                        "content": "How would binary search be beneficial without a sort applied to the citations?"
                    },
                    {
                        "username": "RajputShivraj",
                        "content": "binary search can be applied on sorted arrays na and you are saying no need of sorting techniques\\n"
                    },
                    {
                        "username": "lowiq",
                        "content": "According to the definition of h, \"if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\" Looks like the h value is unique. The \"Note\" part looks unnecessary. \\n\\nProof: say there exist two h-indices, h1 < h2 (1), which means that, there are h2 numbers have value at least h2 (2) and N-h2 values have value at most h2 (3); there are h1 numbers have value at least h1 (4) and N-h1 values have value at most h1(5).\\n\\nWe have (1)(2)(3), (1) and (2) implies (4), but we can see (5) is not possible. Because we have N-h1 > N-h2, there exists at least one paper not in the set of N-h2 but in the set of N-h1, this paper should have value <= h1 (according to 5) and have value >= h2 (according to 2), this contradicts to (1). \\n\\nThe uniqueness follows."
                    },
                    {
                        "username": "job_xu",
                        "content": "Have two questions about the example 1:why not 5? There are two papers be cited at least 5 times.  why not 1? There are four papers be cited at least 1 times.  "
                    },
                    {
                        "username": "shivam_sharma2004",
                        "content": "5 cant be the ans because there do not exist atleast 5 elements in the array which are greater than 5. Talking about 1 yes it is valid value of h but you need to return the max value of h possible which is 3 in this case ."
                    }
                ]
            },
            {
                "id": 1566081,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Excuse me, what kind of madman has published 5000 highly-cited papers?\\nI swear that dude must know incredibly much about Riemannian geometry and incredibly little about women"
                    },
                    {
                        "username": "ignacioariasdev",
                        "content": "[@dungtuanuet](/dungtuanuet) what gives u money?"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "rolf\\n"
                    },
                    {
                        "username": "ourlord",
                        "content": "According to the hint, I tried my version with the build-in `sort()` and get a one time AC. But if in a real interview scenario, do we allow to use build-in sort to solve this problem?\\n\\nWhat would the actual point the interviewee might look for?"
                    },
                    {
                        "username": "isydor",
                        "content": "[@Tribhuwan-Joshi](/Tribhuwan-Joshi) it is literally mentioned on the wiki page..."
                    },
                    {
                        "username": "NareshSawlani",
                        "content": "interviewer would be looking for your approach like in this question it would be using count sort manually no API"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "Please don\\'t share hints like using `sort()` in the discussion "
                    },
                    {
                        "username": "haucaucau",
                        "content": "What if the input is [4,4,4,4,4,4,5]?\\nWhen I run with my code the answer is 4 and it was accepted.\\nBut I don\\'t understand cause there are 7 papers that have at least 4 citations,\\nand 0 paper no more than 4, which contradicts the description."
                    },
                    {
                        "username": "DxRz729",
                        "content": "Yes your the input has 7 papers with 4 citations, but the h in h-index means that it should be the same for no of citations and no of papers, so we will only take 4 papers as it is min of (4,7)"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": "[@hemantsingh4774](/hemantsingh4774)  reference: https://en.wikipedia.org/wiki/H-index"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": " For example, if an author has five publications, with 9, 7, 6, 2, and 1 citations (ordered from greatest to least), then the author\\'s h-index is 3, because the author has three publications with 3 or more citations. However, the author does not have four publications with 4 or more citations."
                    },
                    {
                        "username": "han35",
                        "content": "[0] means there is 1 paper and the citation is 0.\\nAccording to the description\\n\\n> A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each\\n\\nA scientist has 1(h) of his/her 1 paper has at least 0(h) citation, and the other 0 paper has no more than 0 citation.\\n\\nIs this a contradiction?"
                    },
                    {
                        "username": "yellowstar1014",
                        "content": "is it possible to have two h in this problem? please give an example?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "it literaly says to be a maximum value. how in the world would something have two distinct maximum values?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "![hehe.png](https://assets.leetcode.com/users/images/f16e4f9d-434f-4e5c-bf36-3cc106ea074a_1677794934.0254838.png)"
                    },
                    {
                        "username": "shuyi@cvs",
                        "content": "Hi,\\n\\nI came across a situation:  given citations = [3, 1, 7, 8, 9]. What will be the answer be?\\n\\nAccording to the definition of h-index on Wikipedia: \"A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\"\\n\\nWhen h=3, the definition will be \"A scientist has index 3 if 3 of his/her 5 papers have at least 3 citations each, and the other 2 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nWhen h=4, the definition will be \"A scientist has index 4 if 4 of his/her 5 papers have at least 4 citations each, and the other 1 papers have no more than 4 citations each.\" Obviously wrong....\\n\\nWhen h=2, the definition will be \"A scientist has index 2 if 2 of his/her 5 papers have at least 2 citations each, and the other 3 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nSo anybody can give me an answer? Or this question is a wrong one?"
                    },
                    {
                        "username": "user2118U",
                        "content": "Definition of h is The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times. See it is written at least h papers not exact h papers"
                    },
                    {
                        "username": "user2118U",
                        "content": "Dude there  is nothing written like that other papers have no more h citations. your example answer is 3 because researcher has published at least 3 papers and each paper has atleast 3 citations"
                    },
                    {
                        "username": "saurabh8katyal",
                        "content": "Answer will be 3, as the other 2 papers have no more than 3 citations each(1, 3). Not more than 3. Can be equal to."
                    },
                    {
                        "username": "Tsien",
                        "content": "In the problem description, there is a line \"Note: If there are several possible values for h, the maximum one is taken as the h-index.\"\\nI cannot come up with an example that could have several possible values for h. \\nIMO, there is only one value for h for each example according to the definition of H-Index.\\nPlease correct me if i'm wrong.\\nThanks!"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Anyone thought of Binary search, no need of sorting technique required,\\nDon\\'t open solution if you have not gave it a try using binary search:\\nhttps://leetcode.com/problems/h-index/solutions/3741453/easy-binary-search-problem-no-sorting-technique-required-o-nlogn/ "
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "[@RajputShivraj](/RajputShivraj) He probably meant to apply binary search on the answer and not on the given array."
                    },
                    {
                        "username": "CriticalCorduroy",
                        "content": "How would binary search be beneficial without a sort applied to the citations?"
                    },
                    {
                        "username": "RajputShivraj",
                        "content": "binary search can be applied on sorted arrays na and you are saying no need of sorting techniques\\n"
                    },
                    {
                        "username": "lowiq",
                        "content": "According to the definition of h, \"if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\" Looks like the h value is unique. The \"Note\" part looks unnecessary. \\n\\nProof: say there exist two h-indices, h1 < h2 (1), which means that, there are h2 numbers have value at least h2 (2) and N-h2 values have value at most h2 (3); there are h1 numbers have value at least h1 (4) and N-h1 values have value at most h1(5).\\n\\nWe have (1)(2)(3), (1) and (2) implies (4), but we can see (5) is not possible. Because we have N-h1 > N-h2, there exists at least one paper not in the set of N-h2 but in the set of N-h1, this paper should have value <= h1 (according to 5) and have value >= h2 (according to 2), this contradicts to (1). \\n\\nThe uniqueness follows."
                    },
                    {
                        "username": "job_xu",
                        "content": "Have two questions about the example 1:why not 5? There are two papers be cited at least 5 times.  why not 1? There are four papers be cited at least 1 times.  "
                    },
                    {
                        "username": "shivam_sharma2004",
                        "content": "5 cant be the ans because there do not exist atleast 5 elements in the array which are greater than 5. Talking about 1 yes it is valid value of h but you need to return the max value of h possible which is 3 in this case ."
                    }
                ]
            },
            {
                "id": 1569052,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Excuse me, what kind of madman has published 5000 highly-cited papers?\\nI swear that dude must know incredibly much about Riemannian geometry and incredibly little about women"
                    },
                    {
                        "username": "ignacioariasdev",
                        "content": "[@dungtuanuet](/dungtuanuet) what gives u money?"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "rolf\\n"
                    },
                    {
                        "username": "ourlord",
                        "content": "According to the hint, I tried my version with the build-in `sort()` and get a one time AC. But if in a real interview scenario, do we allow to use build-in sort to solve this problem?\\n\\nWhat would the actual point the interviewee might look for?"
                    },
                    {
                        "username": "isydor",
                        "content": "[@Tribhuwan-Joshi](/Tribhuwan-Joshi) it is literally mentioned on the wiki page..."
                    },
                    {
                        "username": "NareshSawlani",
                        "content": "interviewer would be looking for your approach like in this question it would be using count sort manually no API"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "Please don\\'t share hints like using `sort()` in the discussion "
                    },
                    {
                        "username": "haucaucau",
                        "content": "What if the input is [4,4,4,4,4,4,5]?\\nWhen I run with my code the answer is 4 and it was accepted.\\nBut I don\\'t understand cause there are 7 papers that have at least 4 citations,\\nand 0 paper no more than 4, which contradicts the description."
                    },
                    {
                        "username": "DxRz729",
                        "content": "Yes your the input has 7 papers with 4 citations, but the h in h-index means that it should be the same for no of citations and no of papers, so we will only take 4 papers as it is min of (4,7)"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": "[@hemantsingh4774](/hemantsingh4774)  reference: https://en.wikipedia.org/wiki/H-index"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": " For example, if an author has five publications, with 9, 7, 6, 2, and 1 citations (ordered from greatest to least), then the author\\'s h-index is 3, because the author has three publications with 3 or more citations. However, the author does not have four publications with 4 or more citations."
                    },
                    {
                        "username": "han35",
                        "content": "[0] means there is 1 paper and the citation is 0.\\nAccording to the description\\n\\n> A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each\\n\\nA scientist has 1(h) of his/her 1 paper has at least 0(h) citation, and the other 0 paper has no more than 0 citation.\\n\\nIs this a contradiction?"
                    },
                    {
                        "username": "yellowstar1014",
                        "content": "is it possible to have two h in this problem? please give an example?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "it literaly says to be a maximum value. how in the world would something have two distinct maximum values?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "![hehe.png](https://assets.leetcode.com/users/images/f16e4f9d-434f-4e5c-bf36-3cc106ea074a_1677794934.0254838.png)"
                    },
                    {
                        "username": "shuyi@cvs",
                        "content": "Hi,\\n\\nI came across a situation:  given citations = [3, 1, 7, 8, 9]. What will be the answer be?\\n\\nAccording to the definition of h-index on Wikipedia: \"A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\"\\n\\nWhen h=3, the definition will be \"A scientist has index 3 if 3 of his/her 5 papers have at least 3 citations each, and the other 2 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nWhen h=4, the definition will be \"A scientist has index 4 if 4 of his/her 5 papers have at least 4 citations each, and the other 1 papers have no more than 4 citations each.\" Obviously wrong....\\n\\nWhen h=2, the definition will be \"A scientist has index 2 if 2 of his/her 5 papers have at least 2 citations each, and the other 3 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nSo anybody can give me an answer? Or this question is a wrong one?"
                    },
                    {
                        "username": "user2118U",
                        "content": "Definition of h is The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times. See it is written at least h papers not exact h papers"
                    },
                    {
                        "username": "user2118U",
                        "content": "Dude there  is nothing written like that other papers have no more h citations. your example answer is 3 because researcher has published at least 3 papers and each paper has atleast 3 citations"
                    },
                    {
                        "username": "saurabh8katyal",
                        "content": "Answer will be 3, as the other 2 papers have no more than 3 citations each(1, 3). Not more than 3. Can be equal to."
                    },
                    {
                        "username": "Tsien",
                        "content": "In the problem description, there is a line \"Note: If there are several possible values for h, the maximum one is taken as the h-index.\"\\nI cannot come up with an example that could have several possible values for h. \\nIMO, there is only one value for h for each example according to the definition of H-Index.\\nPlease correct me if i'm wrong.\\nThanks!"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Anyone thought of Binary search, no need of sorting technique required,\\nDon\\'t open solution if you have not gave it a try using binary search:\\nhttps://leetcode.com/problems/h-index/solutions/3741453/easy-binary-search-problem-no-sorting-technique-required-o-nlogn/ "
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "[@RajputShivraj](/RajputShivraj) He probably meant to apply binary search on the answer and not on the given array."
                    },
                    {
                        "username": "CriticalCorduroy",
                        "content": "How would binary search be beneficial without a sort applied to the citations?"
                    },
                    {
                        "username": "RajputShivraj",
                        "content": "binary search can be applied on sorted arrays na and you are saying no need of sorting techniques\\n"
                    },
                    {
                        "username": "lowiq",
                        "content": "According to the definition of h, \"if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\" Looks like the h value is unique. The \"Note\" part looks unnecessary. \\n\\nProof: say there exist two h-indices, h1 < h2 (1), which means that, there are h2 numbers have value at least h2 (2) and N-h2 values have value at most h2 (3); there are h1 numbers have value at least h1 (4) and N-h1 values have value at most h1(5).\\n\\nWe have (1)(2)(3), (1) and (2) implies (4), but we can see (5) is not possible. Because we have N-h1 > N-h2, there exists at least one paper not in the set of N-h2 but in the set of N-h1, this paper should have value <= h1 (according to 5) and have value >= h2 (according to 2), this contradicts to (1). \\n\\nThe uniqueness follows."
                    },
                    {
                        "username": "job_xu",
                        "content": "Have two questions about the example 1:why not 5? There are two papers be cited at least 5 times.  why not 1? There are four papers be cited at least 1 times.  "
                    },
                    {
                        "username": "shivam_sharma2004",
                        "content": "5 cant be the ans because there do not exist atleast 5 elements in the array which are greater than 5. Talking about 1 yes it is valid value of h but you need to return the max value of h possible which is 3 in this case ."
                    }
                ]
            },
            {
                "id": 1569050,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Excuse me, what kind of madman has published 5000 highly-cited papers?\\nI swear that dude must know incredibly much about Riemannian geometry and incredibly little about women"
                    },
                    {
                        "username": "ignacioariasdev",
                        "content": "[@dungtuanuet](/dungtuanuet) what gives u money?"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "rolf\\n"
                    },
                    {
                        "username": "ourlord",
                        "content": "According to the hint, I tried my version with the build-in `sort()` and get a one time AC. But if in a real interview scenario, do we allow to use build-in sort to solve this problem?\\n\\nWhat would the actual point the interviewee might look for?"
                    },
                    {
                        "username": "isydor",
                        "content": "[@Tribhuwan-Joshi](/Tribhuwan-Joshi) it is literally mentioned on the wiki page..."
                    },
                    {
                        "username": "NareshSawlani",
                        "content": "interviewer would be looking for your approach like in this question it would be using count sort manually no API"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "Please don\\'t share hints like using `sort()` in the discussion "
                    },
                    {
                        "username": "haucaucau",
                        "content": "What if the input is [4,4,4,4,4,4,5]?\\nWhen I run with my code the answer is 4 and it was accepted.\\nBut I don\\'t understand cause there are 7 papers that have at least 4 citations,\\nand 0 paper no more than 4, which contradicts the description."
                    },
                    {
                        "username": "DxRz729",
                        "content": "Yes your the input has 7 papers with 4 citations, but the h in h-index means that it should be the same for no of citations and no of papers, so we will only take 4 papers as it is min of (4,7)"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": "[@hemantsingh4774](/hemantsingh4774)  reference: https://en.wikipedia.org/wiki/H-index"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": " For example, if an author has five publications, with 9, 7, 6, 2, and 1 citations (ordered from greatest to least), then the author\\'s h-index is 3, because the author has three publications with 3 or more citations. However, the author does not have four publications with 4 or more citations."
                    },
                    {
                        "username": "han35",
                        "content": "[0] means there is 1 paper and the citation is 0.\\nAccording to the description\\n\\n> A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each\\n\\nA scientist has 1(h) of his/her 1 paper has at least 0(h) citation, and the other 0 paper has no more than 0 citation.\\n\\nIs this a contradiction?"
                    },
                    {
                        "username": "yellowstar1014",
                        "content": "is it possible to have two h in this problem? please give an example?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "it literaly says to be a maximum value. how in the world would something have two distinct maximum values?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "![hehe.png](https://assets.leetcode.com/users/images/f16e4f9d-434f-4e5c-bf36-3cc106ea074a_1677794934.0254838.png)"
                    },
                    {
                        "username": "shuyi@cvs",
                        "content": "Hi,\\n\\nI came across a situation:  given citations = [3, 1, 7, 8, 9]. What will be the answer be?\\n\\nAccording to the definition of h-index on Wikipedia: \"A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\"\\n\\nWhen h=3, the definition will be \"A scientist has index 3 if 3 of his/her 5 papers have at least 3 citations each, and the other 2 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nWhen h=4, the definition will be \"A scientist has index 4 if 4 of his/her 5 papers have at least 4 citations each, and the other 1 papers have no more than 4 citations each.\" Obviously wrong....\\n\\nWhen h=2, the definition will be \"A scientist has index 2 if 2 of his/her 5 papers have at least 2 citations each, and the other 3 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nSo anybody can give me an answer? Or this question is a wrong one?"
                    },
                    {
                        "username": "user2118U",
                        "content": "Definition of h is The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times. See it is written at least h papers not exact h papers"
                    },
                    {
                        "username": "user2118U",
                        "content": "Dude there  is nothing written like that other papers have no more h citations. your example answer is 3 because researcher has published at least 3 papers and each paper has atleast 3 citations"
                    },
                    {
                        "username": "saurabh8katyal",
                        "content": "Answer will be 3, as the other 2 papers have no more than 3 citations each(1, 3). Not more than 3. Can be equal to."
                    },
                    {
                        "username": "Tsien",
                        "content": "In the problem description, there is a line \"Note: If there are several possible values for h, the maximum one is taken as the h-index.\"\\nI cannot come up with an example that could have several possible values for h. \\nIMO, there is only one value for h for each example according to the definition of H-Index.\\nPlease correct me if i'm wrong.\\nThanks!"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Anyone thought of Binary search, no need of sorting technique required,\\nDon\\'t open solution if you have not gave it a try using binary search:\\nhttps://leetcode.com/problems/h-index/solutions/3741453/easy-binary-search-problem-no-sorting-technique-required-o-nlogn/ "
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "[@RajputShivraj](/RajputShivraj) He probably meant to apply binary search on the answer and not on the given array."
                    },
                    {
                        "username": "CriticalCorduroy",
                        "content": "How would binary search be beneficial without a sort applied to the citations?"
                    },
                    {
                        "username": "RajputShivraj",
                        "content": "binary search can be applied on sorted arrays na and you are saying no need of sorting techniques\\n"
                    },
                    {
                        "username": "lowiq",
                        "content": "According to the definition of h, \"if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\" Looks like the h value is unique. The \"Note\" part looks unnecessary. \\n\\nProof: say there exist two h-indices, h1 < h2 (1), which means that, there are h2 numbers have value at least h2 (2) and N-h2 values have value at most h2 (3); there are h1 numbers have value at least h1 (4) and N-h1 values have value at most h1(5).\\n\\nWe have (1)(2)(3), (1) and (2) implies (4), but we can see (5) is not possible. Because we have N-h1 > N-h2, there exists at least one paper not in the set of N-h2 but in the set of N-h1, this paper should have value <= h1 (according to 5) and have value >= h2 (according to 2), this contradicts to (1). \\n\\nThe uniqueness follows."
                    },
                    {
                        "username": "job_xu",
                        "content": "Have two questions about the example 1:why not 5? There are two papers be cited at least 5 times.  why not 1? There are four papers be cited at least 1 times.  "
                    },
                    {
                        "username": "shivam_sharma2004",
                        "content": "5 cant be the ans because there do not exist atleast 5 elements in the array which are greater than 5. Talking about 1 yes it is valid value of h but you need to return the max value of h possible which is 3 in this case ."
                    }
                ]
            },
            {
                "id": 1963174,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Excuse me, what kind of madman has published 5000 highly-cited papers?\\nI swear that dude must know incredibly much about Riemannian geometry and incredibly little about women"
                    },
                    {
                        "username": "ignacioariasdev",
                        "content": "[@dungtuanuet](/dungtuanuet) what gives u money?"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "rolf\\n"
                    },
                    {
                        "username": "ourlord",
                        "content": "According to the hint, I tried my version with the build-in `sort()` and get a one time AC. But if in a real interview scenario, do we allow to use build-in sort to solve this problem?\\n\\nWhat would the actual point the interviewee might look for?"
                    },
                    {
                        "username": "isydor",
                        "content": "[@Tribhuwan-Joshi](/Tribhuwan-Joshi) it is literally mentioned on the wiki page..."
                    },
                    {
                        "username": "NareshSawlani",
                        "content": "interviewer would be looking for your approach like in this question it would be using count sort manually no API"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "Please don\\'t share hints like using `sort()` in the discussion "
                    },
                    {
                        "username": "haucaucau",
                        "content": "What if the input is [4,4,4,4,4,4,5]?\\nWhen I run with my code the answer is 4 and it was accepted.\\nBut I don\\'t understand cause there are 7 papers that have at least 4 citations,\\nand 0 paper no more than 4, which contradicts the description."
                    },
                    {
                        "username": "DxRz729",
                        "content": "Yes your the input has 7 papers with 4 citations, but the h in h-index means that it should be the same for no of citations and no of papers, so we will only take 4 papers as it is min of (4,7)"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": "[@hemantsingh4774](/hemantsingh4774)  reference: https://en.wikipedia.org/wiki/H-index"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": " For example, if an author has five publications, with 9, 7, 6, 2, and 1 citations (ordered from greatest to least), then the author\\'s h-index is 3, because the author has three publications with 3 or more citations. However, the author does not have four publications with 4 or more citations."
                    },
                    {
                        "username": "han35",
                        "content": "[0] means there is 1 paper and the citation is 0.\\nAccording to the description\\n\\n> A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each\\n\\nA scientist has 1(h) of his/her 1 paper has at least 0(h) citation, and the other 0 paper has no more than 0 citation.\\n\\nIs this a contradiction?"
                    },
                    {
                        "username": "yellowstar1014",
                        "content": "is it possible to have two h in this problem? please give an example?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "it literaly says to be a maximum value. how in the world would something have two distinct maximum values?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "![hehe.png](https://assets.leetcode.com/users/images/f16e4f9d-434f-4e5c-bf36-3cc106ea074a_1677794934.0254838.png)"
                    },
                    {
                        "username": "shuyi@cvs",
                        "content": "Hi,\\n\\nI came across a situation:  given citations = [3, 1, 7, 8, 9]. What will be the answer be?\\n\\nAccording to the definition of h-index on Wikipedia: \"A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\"\\n\\nWhen h=3, the definition will be \"A scientist has index 3 if 3 of his/her 5 papers have at least 3 citations each, and the other 2 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nWhen h=4, the definition will be \"A scientist has index 4 if 4 of his/her 5 papers have at least 4 citations each, and the other 1 papers have no more than 4 citations each.\" Obviously wrong....\\n\\nWhen h=2, the definition will be \"A scientist has index 2 if 2 of his/her 5 papers have at least 2 citations each, and the other 3 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nSo anybody can give me an answer? Or this question is a wrong one?"
                    },
                    {
                        "username": "user2118U",
                        "content": "Definition of h is The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times. See it is written at least h papers not exact h papers"
                    },
                    {
                        "username": "user2118U",
                        "content": "Dude there  is nothing written like that other papers have no more h citations. your example answer is 3 because researcher has published at least 3 papers and each paper has atleast 3 citations"
                    },
                    {
                        "username": "saurabh8katyal",
                        "content": "Answer will be 3, as the other 2 papers have no more than 3 citations each(1, 3). Not more than 3. Can be equal to."
                    },
                    {
                        "username": "Tsien",
                        "content": "In the problem description, there is a line \"Note: If there are several possible values for h, the maximum one is taken as the h-index.\"\\nI cannot come up with an example that could have several possible values for h. \\nIMO, there is only one value for h for each example according to the definition of H-Index.\\nPlease correct me if i'm wrong.\\nThanks!"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Anyone thought of Binary search, no need of sorting technique required,\\nDon\\'t open solution if you have not gave it a try using binary search:\\nhttps://leetcode.com/problems/h-index/solutions/3741453/easy-binary-search-problem-no-sorting-technique-required-o-nlogn/ "
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "[@RajputShivraj](/RajputShivraj) He probably meant to apply binary search on the answer and not on the given array."
                    },
                    {
                        "username": "CriticalCorduroy",
                        "content": "How would binary search be beneficial without a sort applied to the citations?"
                    },
                    {
                        "username": "RajputShivraj",
                        "content": "binary search can be applied on sorted arrays na and you are saying no need of sorting techniques\\n"
                    },
                    {
                        "username": "lowiq",
                        "content": "According to the definition of h, \"if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\" Looks like the h value is unique. The \"Note\" part looks unnecessary. \\n\\nProof: say there exist two h-indices, h1 < h2 (1), which means that, there are h2 numbers have value at least h2 (2) and N-h2 values have value at most h2 (3); there are h1 numbers have value at least h1 (4) and N-h1 values have value at most h1(5).\\n\\nWe have (1)(2)(3), (1) and (2) implies (4), but we can see (5) is not possible. Because we have N-h1 > N-h2, there exists at least one paper not in the set of N-h2 but in the set of N-h1, this paper should have value <= h1 (according to 5) and have value >= h2 (according to 2), this contradicts to (1). \\n\\nThe uniqueness follows."
                    },
                    {
                        "username": "job_xu",
                        "content": "Have two questions about the example 1:why not 5? There are two papers be cited at least 5 times.  why not 1? There are four papers be cited at least 1 times.  "
                    },
                    {
                        "username": "shivam_sharma2004",
                        "content": "5 cant be the ans because there do not exist atleast 5 elements in the array which are greater than 5. Talking about 1 yes it is valid value of h but you need to return the max value of h possible which is 3 in this case ."
                    }
                ]
            },
            {
                "id": 1569051,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Excuse me, what kind of madman has published 5000 highly-cited papers?\\nI swear that dude must know incredibly much about Riemannian geometry and incredibly little about women"
                    },
                    {
                        "username": "ignacioariasdev",
                        "content": "[@dungtuanuet](/dungtuanuet) what gives u money?"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "rolf\\n"
                    },
                    {
                        "username": "ourlord",
                        "content": "According to the hint, I tried my version with the build-in `sort()` and get a one time AC. But if in a real interview scenario, do we allow to use build-in sort to solve this problem?\\n\\nWhat would the actual point the interviewee might look for?"
                    },
                    {
                        "username": "isydor",
                        "content": "[@Tribhuwan-Joshi](/Tribhuwan-Joshi) it is literally mentioned on the wiki page..."
                    },
                    {
                        "username": "NareshSawlani",
                        "content": "interviewer would be looking for your approach like in this question it would be using count sort manually no API"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "Please don\\'t share hints like using `sort()` in the discussion "
                    },
                    {
                        "username": "haucaucau",
                        "content": "What if the input is [4,4,4,4,4,4,5]?\\nWhen I run with my code the answer is 4 and it was accepted.\\nBut I don\\'t understand cause there are 7 papers that have at least 4 citations,\\nand 0 paper no more than 4, which contradicts the description."
                    },
                    {
                        "username": "DxRz729",
                        "content": "Yes your the input has 7 papers with 4 citations, but the h in h-index means that it should be the same for no of citations and no of papers, so we will only take 4 papers as it is min of (4,7)"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": "[@hemantsingh4774](/hemantsingh4774)  reference: https://en.wikipedia.org/wiki/H-index"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": " For example, if an author has five publications, with 9, 7, 6, 2, and 1 citations (ordered from greatest to least), then the author\\'s h-index is 3, because the author has three publications with 3 or more citations. However, the author does not have four publications with 4 or more citations."
                    },
                    {
                        "username": "han35",
                        "content": "[0] means there is 1 paper and the citation is 0.\\nAccording to the description\\n\\n> A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each\\n\\nA scientist has 1(h) of his/her 1 paper has at least 0(h) citation, and the other 0 paper has no more than 0 citation.\\n\\nIs this a contradiction?"
                    },
                    {
                        "username": "yellowstar1014",
                        "content": "is it possible to have two h in this problem? please give an example?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "it literaly says to be a maximum value. how in the world would something have two distinct maximum values?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "![hehe.png](https://assets.leetcode.com/users/images/f16e4f9d-434f-4e5c-bf36-3cc106ea074a_1677794934.0254838.png)"
                    },
                    {
                        "username": "shuyi@cvs",
                        "content": "Hi,\\n\\nI came across a situation:  given citations = [3, 1, 7, 8, 9]. What will be the answer be?\\n\\nAccording to the definition of h-index on Wikipedia: \"A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\"\\n\\nWhen h=3, the definition will be \"A scientist has index 3 if 3 of his/her 5 papers have at least 3 citations each, and the other 2 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nWhen h=4, the definition will be \"A scientist has index 4 if 4 of his/her 5 papers have at least 4 citations each, and the other 1 papers have no more than 4 citations each.\" Obviously wrong....\\n\\nWhen h=2, the definition will be \"A scientist has index 2 if 2 of his/her 5 papers have at least 2 citations each, and the other 3 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nSo anybody can give me an answer? Or this question is a wrong one?"
                    },
                    {
                        "username": "user2118U",
                        "content": "Definition of h is The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times. See it is written at least h papers not exact h papers"
                    },
                    {
                        "username": "user2118U",
                        "content": "Dude there  is nothing written like that other papers have no more h citations. your example answer is 3 because researcher has published at least 3 papers and each paper has atleast 3 citations"
                    },
                    {
                        "username": "saurabh8katyal",
                        "content": "Answer will be 3, as the other 2 papers have no more than 3 citations each(1, 3). Not more than 3. Can be equal to."
                    },
                    {
                        "username": "Tsien",
                        "content": "In the problem description, there is a line \"Note: If there are several possible values for h, the maximum one is taken as the h-index.\"\\nI cannot come up with an example that could have several possible values for h. \\nIMO, there is only one value for h for each example according to the definition of H-Index.\\nPlease correct me if i'm wrong.\\nThanks!"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Anyone thought of Binary search, no need of sorting technique required,\\nDon\\'t open solution if you have not gave it a try using binary search:\\nhttps://leetcode.com/problems/h-index/solutions/3741453/easy-binary-search-problem-no-sorting-technique-required-o-nlogn/ "
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "[@RajputShivraj](/RajputShivraj) He probably meant to apply binary search on the answer and not on the given array."
                    },
                    {
                        "username": "CriticalCorduroy",
                        "content": "How would binary search be beneficial without a sort applied to the citations?"
                    },
                    {
                        "username": "RajputShivraj",
                        "content": "binary search can be applied on sorted arrays na and you are saying no need of sorting techniques\\n"
                    },
                    {
                        "username": "lowiq",
                        "content": "According to the definition of h, \"if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\" Looks like the h value is unique. The \"Note\" part looks unnecessary. \\n\\nProof: say there exist two h-indices, h1 < h2 (1), which means that, there are h2 numbers have value at least h2 (2) and N-h2 values have value at most h2 (3); there are h1 numbers have value at least h1 (4) and N-h1 values have value at most h1(5).\\n\\nWe have (1)(2)(3), (1) and (2) implies (4), but we can see (5) is not possible. Because we have N-h1 > N-h2, there exists at least one paper not in the set of N-h2 but in the set of N-h1, this paper should have value <= h1 (according to 5) and have value >= h2 (according to 2), this contradicts to (1). \\n\\nThe uniqueness follows."
                    },
                    {
                        "username": "job_xu",
                        "content": "Have two questions about the example 1:why not 5? There are two papers be cited at least 5 times.  why not 1? There are four papers be cited at least 1 times.  "
                    },
                    {
                        "username": "shivam_sharma2004",
                        "content": "5 cant be the ans because there do not exist atleast 5 elements in the array which are greater than 5. Talking about 1 yes it is valid value of h but you need to return the max value of h possible which is 3 in this case ."
                    }
                ]
            },
            {
                "id": 1941363,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Excuse me, what kind of madman has published 5000 highly-cited papers?\\nI swear that dude must know incredibly much about Riemannian geometry and incredibly little about women"
                    },
                    {
                        "username": "ignacioariasdev",
                        "content": "[@dungtuanuet](/dungtuanuet) what gives u money?"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "rolf\\n"
                    },
                    {
                        "username": "ourlord",
                        "content": "According to the hint, I tried my version with the build-in `sort()` and get a one time AC. But if in a real interview scenario, do we allow to use build-in sort to solve this problem?\\n\\nWhat would the actual point the interviewee might look for?"
                    },
                    {
                        "username": "isydor",
                        "content": "[@Tribhuwan-Joshi](/Tribhuwan-Joshi) it is literally mentioned on the wiki page..."
                    },
                    {
                        "username": "NareshSawlani",
                        "content": "interviewer would be looking for your approach like in this question it would be using count sort manually no API"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "Please don\\'t share hints like using `sort()` in the discussion "
                    },
                    {
                        "username": "haucaucau",
                        "content": "What if the input is [4,4,4,4,4,4,5]?\\nWhen I run with my code the answer is 4 and it was accepted.\\nBut I don\\'t understand cause there are 7 papers that have at least 4 citations,\\nand 0 paper no more than 4, which contradicts the description."
                    },
                    {
                        "username": "DxRz729",
                        "content": "Yes your the input has 7 papers with 4 citations, but the h in h-index means that it should be the same for no of citations and no of papers, so we will only take 4 papers as it is min of (4,7)"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": "[@hemantsingh4774](/hemantsingh4774)  reference: https://en.wikipedia.org/wiki/H-index"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": " For example, if an author has five publications, with 9, 7, 6, 2, and 1 citations (ordered from greatest to least), then the author\\'s h-index is 3, because the author has three publications with 3 or more citations. However, the author does not have four publications with 4 or more citations."
                    },
                    {
                        "username": "han35",
                        "content": "[0] means there is 1 paper and the citation is 0.\\nAccording to the description\\n\\n> A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each\\n\\nA scientist has 1(h) of his/her 1 paper has at least 0(h) citation, and the other 0 paper has no more than 0 citation.\\n\\nIs this a contradiction?"
                    },
                    {
                        "username": "yellowstar1014",
                        "content": "is it possible to have two h in this problem? please give an example?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "it literaly says to be a maximum value. how in the world would something have two distinct maximum values?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "![hehe.png](https://assets.leetcode.com/users/images/f16e4f9d-434f-4e5c-bf36-3cc106ea074a_1677794934.0254838.png)"
                    },
                    {
                        "username": "shuyi@cvs",
                        "content": "Hi,\\n\\nI came across a situation:  given citations = [3, 1, 7, 8, 9]. What will be the answer be?\\n\\nAccording to the definition of h-index on Wikipedia: \"A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\"\\n\\nWhen h=3, the definition will be \"A scientist has index 3 if 3 of his/her 5 papers have at least 3 citations each, and the other 2 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nWhen h=4, the definition will be \"A scientist has index 4 if 4 of his/her 5 papers have at least 4 citations each, and the other 1 papers have no more than 4 citations each.\" Obviously wrong....\\n\\nWhen h=2, the definition will be \"A scientist has index 2 if 2 of his/her 5 papers have at least 2 citations each, and the other 3 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nSo anybody can give me an answer? Or this question is a wrong one?"
                    },
                    {
                        "username": "user2118U",
                        "content": "Definition of h is The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times. See it is written at least h papers not exact h papers"
                    },
                    {
                        "username": "user2118U",
                        "content": "Dude there  is nothing written like that other papers have no more h citations. your example answer is 3 because researcher has published at least 3 papers and each paper has atleast 3 citations"
                    },
                    {
                        "username": "saurabh8katyal",
                        "content": "Answer will be 3, as the other 2 papers have no more than 3 citations each(1, 3). Not more than 3. Can be equal to."
                    },
                    {
                        "username": "Tsien",
                        "content": "In the problem description, there is a line \"Note: If there are several possible values for h, the maximum one is taken as the h-index.\"\\nI cannot come up with an example that could have several possible values for h. \\nIMO, there is only one value for h for each example according to the definition of H-Index.\\nPlease correct me if i'm wrong.\\nThanks!"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Anyone thought of Binary search, no need of sorting technique required,\\nDon\\'t open solution if you have not gave it a try using binary search:\\nhttps://leetcode.com/problems/h-index/solutions/3741453/easy-binary-search-problem-no-sorting-technique-required-o-nlogn/ "
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "[@RajputShivraj](/RajputShivraj) He probably meant to apply binary search on the answer and not on the given array."
                    },
                    {
                        "username": "CriticalCorduroy",
                        "content": "How would binary search be beneficial without a sort applied to the citations?"
                    },
                    {
                        "username": "RajputShivraj",
                        "content": "binary search can be applied on sorted arrays na and you are saying no need of sorting techniques\\n"
                    },
                    {
                        "username": "lowiq",
                        "content": "According to the definition of h, \"if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\" Looks like the h value is unique. The \"Note\" part looks unnecessary. \\n\\nProof: say there exist two h-indices, h1 < h2 (1), which means that, there are h2 numbers have value at least h2 (2) and N-h2 values have value at most h2 (3); there are h1 numbers have value at least h1 (4) and N-h1 values have value at most h1(5).\\n\\nWe have (1)(2)(3), (1) and (2) implies (4), but we can see (5) is not possible. Because we have N-h1 > N-h2, there exists at least one paper not in the set of N-h2 but in the set of N-h1, this paper should have value <= h1 (according to 5) and have value >= h2 (according to 2), this contradicts to (1). \\n\\nThe uniqueness follows."
                    },
                    {
                        "username": "job_xu",
                        "content": "Have two questions about the example 1:why not 5? There are two papers be cited at least 5 times.  why not 1? There are four papers be cited at least 1 times.  "
                    },
                    {
                        "username": "shivam_sharma2004",
                        "content": "5 cant be the ans because there do not exist atleast 5 elements in the array which are greater than 5. Talking about 1 yes it is valid value of h but you need to return the max value of h possible which is 3 in this case ."
                    }
                ]
            },
            {
                "id": 1870167,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Excuse me, what kind of madman has published 5000 highly-cited papers?\\nI swear that dude must know incredibly much about Riemannian geometry and incredibly little about women"
                    },
                    {
                        "username": "ignacioariasdev",
                        "content": "[@dungtuanuet](/dungtuanuet) what gives u money?"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "rolf\\n"
                    },
                    {
                        "username": "ourlord",
                        "content": "According to the hint, I tried my version with the build-in `sort()` and get a one time AC. But if in a real interview scenario, do we allow to use build-in sort to solve this problem?\\n\\nWhat would the actual point the interviewee might look for?"
                    },
                    {
                        "username": "isydor",
                        "content": "[@Tribhuwan-Joshi](/Tribhuwan-Joshi) it is literally mentioned on the wiki page..."
                    },
                    {
                        "username": "NareshSawlani",
                        "content": "interviewer would be looking for your approach like in this question it would be using count sort manually no API"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "Please don\\'t share hints like using `sort()` in the discussion "
                    },
                    {
                        "username": "haucaucau",
                        "content": "What if the input is [4,4,4,4,4,4,5]?\\nWhen I run with my code the answer is 4 and it was accepted.\\nBut I don\\'t understand cause there are 7 papers that have at least 4 citations,\\nand 0 paper no more than 4, which contradicts the description."
                    },
                    {
                        "username": "DxRz729",
                        "content": "Yes your the input has 7 papers with 4 citations, but the h in h-index means that it should be the same for no of citations and no of papers, so we will only take 4 papers as it is min of (4,7)"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": "[@hemantsingh4774](/hemantsingh4774)  reference: https://en.wikipedia.org/wiki/H-index"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": " For example, if an author has five publications, with 9, 7, 6, 2, and 1 citations (ordered from greatest to least), then the author\\'s h-index is 3, because the author has three publications with 3 or more citations. However, the author does not have four publications with 4 or more citations."
                    },
                    {
                        "username": "han35",
                        "content": "[0] means there is 1 paper and the citation is 0.\\nAccording to the description\\n\\n> A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each\\n\\nA scientist has 1(h) of his/her 1 paper has at least 0(h) citation, and the other 0 paper has no more than 0 citation.\\n\\nIs this a contradiction?"
                    },
                    {
                        "username": "yellowstar1014",
                        "content": "is it possible to have two h in this problem? please give an example?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "it literaly says to be a maximum value. how in the world would something have two distinct maximum values?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "![hehe.png](https://assets.leetcode.com/users/images/f16e4f9d-434f-4e5c-bf36-3cc106ea074a_1677794934.0254838.png)"
                    },
                    {
                        "username": "shuyi@cvs",
                        "content": "Hi,\\n\\nI came across a situation:  given citations = [3, 1, 7, 8, 9]. What will be the answer be?\\n\\nAccording to the definition of h-index on Wikipedia: \"A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\"\\n\\nWhen h=3, the definition will be \"A scientist has index 3 if 3 of his/her 5 papers have at least 3 citations each, and the other 2 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nWhen h=4, the definition will be \"A scientist has index 4 if 4 of his/her 5 papers have at least 4 citations each, and the other 1 papers have no more than 4 citations each.\" Obviously wrong....\\n\\nWhen h=2, the definition will be \"A scientist has index 2 if 2 of his/her 5 papers have at least 2 citations each, and the other 3 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nSo anybody can give me an answer? Or this question is a wrong one?"
                    },
                    {
                        "username": "user2118U",
                        "content": "Definition of h is The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times. See it is written at least h papers not exact h papers"
                    },
                    {
                        "username": "user2118U",
                        "content": "Dude there  is nothing written like that other papers have no more h citations. your example answer is 3 because researcher has published at least 3 papers and each paper has atleast 3 citations"
                    },
                    {
                        "username": "saurabh8katyal",
                        "content": "Answer will be 3, as the other 2 papers have no more than 3 citations each(1, 3). Not more than 3. Can be equal to."
                    },
                    {
                        "username": "Tsien",
                        "content": "In the problem description, there is a line \"Note: If there are several possible values for h, the maximum one is taken as the h-index.\"\\nI cannot come up with an example that could have several possible values for h. \\nIMO, there is only one value for h for each example according to the definition of H-Index.\\nPlease correct me if i'm wrong.\\nThanks!"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Anyone thought of Binary search, no need of sorting technique required,\\nDon\\'t open solution if you have not gave it a try using binary search:\\nhttps://leetcode.com/problems/h-index/solutions/3741453/easy-binary-search-problem-no-sorting-technique-required-o-nlogn/ "
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "[@RajputShivraj](/RajputShivraj) He probably meant to apply binary search on the answer and not on the given array."
                    },
                    {
                        "username": "CriticalCorduroy",
                        "content": "How would binary search be beneficial without a sort applied to the citations?"
                    },
                    {
                        "username": "RajputShivraj",
                        "content": "binary search can be applied on sorted arrays na and you are saying no need of sorting techniques\\n"
                    },
                    {
                        "username": "lowiq",
                        "content": "According to the definition of h, \"if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\" Looks like the h value is unique. The \"Note\" part looks unnecessary. \\n\\nProof: say there exist two h-indices, h1 < h2 (1), which means that, there are h2 numbers have value at least h2 (2) and N-h2 values have value at most h2 (3); there are h1 numbers have value at least h1 (4) and N-h1 values have value at most h1(5).\\n\\nWe have (1)(2)(3), (1) and (2) implies (4), but we can see (5) is not possible. Because we have N-h1 > N-h2, there exists at least one paper not in the set of N-h2 but in the set of N-h1, this paper should have value <= h1 (according to 5) and have value >= h2 (according to 2), this contradicts to (1). \\n\\nThe uniqueness follows."
                    },
                    {
                        "username": "job_xu",
                        "content": "Have two questions about the example 1:why not 5? There are two papers be cited at least 5 times.  why not 1? There are four papers be cited at least 1 times.  "
                    },
                    {
                        "username": "shivam_sharma2004",
                        "content": "5 cant be the ans because there do not exist atleast 5 elements in the array which are greater than 5. Talking about 1 yes it is valid value of h but you need to return the max value of h possible which is 3 in this case ."
                    }
                ]
            },
            {
                "id": 1565530,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Excuse me, what kind of madman has published 5000 highly-cited papers?\\nI swear that dude must know incredibly much about Riemannian geometry and incredibly little about women"
                    },
                    {
                        "username": "ignacioariasdev",
                        "content": "[@dungtuanuet](/dungtuanuet) what gives u money?"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "rolf\\n"
                    },
                    {
                        "username": "ourlord",
                        "content": "According to the hint, I tried my version with the build-in `sort()` and get a one time AC. But if in a real interview scenario, do we allow to use build-in sort to solve this problem?\\n\\nWhat would the actual point the interviewee might look for?"
                    },
                    {
                        "username": "isydor",
                        "content": "[@Tribhuwan-Joshi](/Tribhuwan-Joshi) it is literally mentioned on the wiki page..."
                    },
                    {
                        "username": "NareshSawlani",
                        "content": "interviewer would be looking for your approach like in this question it would be using count sort manually no API"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "Please don\\'t share hints like using `sort()` in the discussion "
                    },
                    {
                        "username": "haucaucau",
                        "content": "What if the input is [4,4,4,4,4,4,5]?\\nWhen I run with my code the answer is 4 and it was accepted.\\nBut I don\\'t understand cause there are 7 papers that have at least 4 citations,\\nand 0 paper no more than 4, which contradicts the description."
                    },
                    {
                        "username": "DxRz729",
                        "content": "Yes your the input has 7 papers with 4 citations, but the h in h-index means that it should be the same for no of citations and no of papers, so we will only take 4 papers as it is min of (4,7)"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": "[@hemantsingh4774](/hemantsingh4774)  reference: https://en.wikipedia.org/wiki/H-index"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": " For example, if an author has five publications, with 9, 7, 6, 2, and 1 citations (ordered from greatest to least), then the author\\'s h-index is 3, because the author has three publications with 3 or more citations. However, the author does not have four publications with 4 or more citations."
                    },
                    {
                        "username": "han35",
                        "content": "[0] means there is 1 paper and the citation is 0.\\nAccording to the description\\n\\n> A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each\\n\\nA scientist has 1(h) of his/her 1 paper has at least 0(h) citation, and the other 0 paper has no more than 0 citation.\\n\\nIs this a contradiction?"
                    },
                    {
                        "username": "yellowstar1014",
                        "content": "is it possible to have two h in this problem? please give an example?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "it literaly says to be a maximum value. how in the world would something have two distinct maximum values?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "![hehe.png](https://assets.leetcode.com/users/images/f16e4f9d-434f-4e5c-bf36-3cc106ea074a_1677794934.0254838.png)"
                    },
                    {
                        "username": "shuyi@cvs",
                        "content": "Hi,\\n\\nI came across a situation:  given citations = [3, 1, 7, 8, 9]. What will be the answer be?\\n\\nAccording to the definition of h-index on Wikipedia: \"A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\"\\n\\nWhen h=3, the definition will be \"A scientist has index 3 if 3 of his/her 5 papers have at least 3 citations each, and the other 2 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nWhen h=4, the definition will be \"A scientist has index 4 if 4 of his/her 5 papers have at least 4 citations each, and the other 1 papers have no more than 4 citations each.\" Obviously wrong....\\n\\nWhen h=2, the definition will be \"A scientist has index 2 if 2 of his/her 5 papers have at least 2 citations each, and the other 3 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nSo anybody can give me an answer? Or this question is a wrong one?"
                    },
                    {
                        "username": "user2118U",
                        "content": "Definition of h is The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times. See it is written at least h papers not exact h papers"
                    },
                    {
                        "username": "user2118U",
                        "content": "Dude there  is nothing written like that other papers have no more h citations. your example answer is 3 because researcher has published at least 3 papers and each paper has atleast 3 citations"
                    },
                    {
                        "username": "saurabh8katyal",
                        "content": "Answer will be 3, as the other 2 papers have no more than 3 citations each(1, 3). Not more than 3. Can be equal to."
                    },
                    {
                        "username": "Tsien",
                        "content": "In the problem description, there is a line \"Note: If there are several possible values for h, the maximum one is taken as the h-index.\"\\nI cannot come up with an example that could have several possible values for h. \\nIMO, there is only one value for h for each example according to the definition of H-Index.\\nPlease correct me if i'm wrong.\\nThanks!"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Anyone thought of Binary search, no need of sorting technique required,\\nDon\\'t open solution if you have not gave it a try using binary search:\\nhttps://leetcode.com/problems/h-index/solutions/3741453/easy-binary-search-problem-no-sorting-technique-required-o-nlogn/ "
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "[@RajputShivraj](/RajputShivraj) He probably meant to apply binary search on the answer and not on the given array."
                    },
                    {
                        "username": "CriticalCorduroy",
                        "content": "How would binary search be beneficial without a sort applied to the citations?"
                    },
                    {
                        "username": "RajputShivraj",
                        "content": "binary search can be applied on sorted arrays na and you are saying no need of sorting techniques\\n"
                    },
                    {
                        "username": "lowiq",
                        "content": "According to the definition of h, \"if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\" Looks like the h value is unique. The \"Note\" part looks unnecessary. \\n\\nProof: say there exist two h-indices, h1 < h2 (1), which means that, there are h2 numbers have value at least h2 (2) and N-h2 values have value at most h2 (3); there are h1 numbers have value at least h1 (4) and N-h1 values have value at most h1(5).\\n\\nWe have (1)(2)(3), (1) and (2) implies (4), but we can see (5) is not possible. Because we have N-h1 > N-h2, there exists at least one paper not in the set of N-h2 but in the set of N-h1, this paper should have value <= h1 (according to 5) and have value >= h2 (according to 2), this contradicts to (1). \\n\\nThe uniqueness follows."
                    },
                    {
                        "username": "job_xu",
                        "content": "Have two questions about the example 1:why not 5? There are two papers be cited at least 5 times.  why not 1? There are four papers be cited at least 1 times.  "
                    },
                    {
                        "username": "shivam_sharma2004",
                        "content": "5 cant be the ans because there do not exist atleast 5 elements in the array which are greater than 5. Talking about 1 yes it is valid value of h but you need to return the max value of h possible which is 3 in this case ."
                    }
                ]
            },
            {
                "id": 1573901,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Excuse me, what kind of madman has published 5000 highly-cited papers?\\nI swear that dude must know incredibly much about Riemannian geometry and incredibly little about women"
                    },
                    {
                        "username": "ignacioariasdev",
                        "content": "[@dungtuanuet](/dungtuanuet) what gives u money?"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "rolf\\n"
                    },
                    {
                        "username": "ourlord",
                        "content": "According to the hint, I tried my version with the build-in `sort()` and get a one time AC. But if in a real interview scenario, do we allow to use build-in sort to solve this problem?\\n\\nWhat would the actual point the interviewee might look for?"
                    },
                    {
                        "username": "isydor",
                        "content": "[@Tribhuwan-Joshi](/Tribhuwan-Joshi) it is literally mentioned on the wiki page..."
                    },
                    {
                        "username": "NareshSawlani",
                        "content": "interviewer would be looking for your approach like in this question it would be using count sort manually no API"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "Please don\\'t share hints like using `sort()` in the discussion "
                    },
                    {
                        "username": "haucaucau",
                        "content": "What if the input is [4,4,4,4,4,4,5]?\\nWhen I run with my code the answer is 4 and it was accepted.\\nBut I don\\'t understand cause there are 7 papers that have at least 4 citations,\\nand 0 paper no more than 4, which contradicts the description."
                    },
                    {
                        "username": "DxRz729",
                        "content": "Yes your the input has 7 papers with 4 citations, but the h in h-index means that it should be the same for no of citations and no of papers, so we will only take 4 papers as it is min of (4,7)"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": "[@hemantsingh4774](/hemantsingh4774)  reference: https://en.wikipedia.org/wiki/H-index"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": " For example, if an author has five publications, with 9, 7, 6, 2, and 1 citations (ordered from greatest to least), then the author\\'s h-index is 3, because the author has three publications with 3 or more citations. However, the author does not have four publications with 4 or more citations."
                    },
                    {
                        "username": "han35",
                        "content": "[0] means there is 1 paper and the citation is 0.\\nAccording to the description\\n\\n> A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each\\n\\nA scientist has 1(h) of his/her 1 paper has at least 0(h) citation, and the other 0 paper has no more than 0 citation.\\n\\nIs this a contradiction?"
                    },
                    {
                        "username": "yellowstar1014",
                        "content": "is it possible to have two h in this problem? please give an example?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "it literaly says to be a maximum value. how in the world would something have two distinct maximum values?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "![hehe.png](https://assets.leetcode.com/users/images/f16e4f9d-434f-4e5c-bf36-3cc106ea074a_1677794934.0254838.png)"
                    },
                    {
                        "username": "shuyi@cvs",
                        "content": "Hi,\\n\\nI came across a situation:  given citations = [3, 1, 7, 8, 9]. What will be the answer be?\\n\\nAccording to the definition of h-index on Wikipedia: \"A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\"\\n\\nWhen h=3, the definition will be \"A scientist has index 3 if 3 of his/her 5 papers have at least 3 citations each, and the other 2 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nWhen h=4, the definition will be \"A scientist has index 4 if 4 of his/her 5 papers have at least 4 citations each, and the other 1 papers have no more than 4 citations each.\" Obviously wrong....\\n\\nWhen h=2, the definition will be \"A scientist has index 2 if 2 of his/her 5 papers have at least 2 citations each, and the other 3 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nSo anybody can give me an answer? Or this question is a wrong one?"
                    },
                    {
                        "username": "user2118U",
                        "content": "Definition of h is The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times. See it is written at least h papers not exact h papers"
                    },
                    {
                        "username": "user2118U",
                        "content": "Dude there  is nothing written like that other papers have no more h citations. your example answer is 3 because researcher has published at least 3 papers and each paper has atleast 3 citations"
                    },
                    {
                        "username": "saurabh8katyal",
                        "content": "Answer will be 3, as the other 2 papers have no more than 3 citations each(1, 3). Not more than 3. Can be equal to."
                    },
                    {
                        "username": "Tsien",
                        "content": "In the problem description, there is a line \"Note: If there are several possible values for h, the maximum one is taken as the h-index.\"\\nI cannot come up with an example that could have several possible values for h. \\nIMO, there is only one value for h for each example according to the definition of H-Index.\\nPlease correct me if i'm wrong.\\nThanks!"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Anyone thought of Binary search, no need of sorting technique required,\\nDon\\'t open solution if you have not gave it a try using binary search:\\nhttps://leetcode.com/problems/h-index/solutions/3741453/easy-binary-search-problem-no-sorting-technique-required-o-nlogn/ "
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "[@RajputShivraj](/RajputShivraj) He probably meant to apply binary search on the answer and not on the given array."
                    },
                    {
                        "username": "CriticalCorduroy",
                        "content": "How would binary search be beneficial without a sort applied to the citations?"
                    },
                    {
                        "username": "RajputShivraj",
                        "content": "binary search can be applied on sorted arrays na and you are saying no need of sorting techniques\\n"
                    },
                    {
                        "username": "lowiq",
                        "content": "According to the definition of h, \"if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\" Looks like the h value is unique. The \"Note\" part looks unnecessary. \\n\\nProof: say there exist two h-indices, h1 < h2 (1), which means that, there are h2 numbers have value at least h2 (2) and N-h2 values have value at most h2 (3); there are h1 numbers have value at least h1 (4) and N-h1 values have value at most h1(5).\\n\\nWe have (1)(2)(3), (1) and (2) implies (4), but we can see (5) is not possible. Because we have N-h1 > N-h2, there exists at least one paper not in the set of N-h2 but in the set of N-h1, this paper should have value <= h1 (according to 5) and have value >= h2 (according to 2), this contradicts to (1). \\n\\nThe uniqueness follows."
                    },
                    {
                        "username": "job_xu",
                        "content": "Have two questions about the example 1:why not 5? There are two papers be cited at least 5 times.  why not 1? There are four papers be cited at least 1 times.  "
                    },
                    {
                        "username": "shivam_sharma2004",
                        "content": "5 cant be the ans because there do not exist atleast 5 elements in the array which are greater than 5. Talking about 1 yes it is valid value of h but you need to return the max value of h possible which is 3 in this case ."
                    }
                ]
            },
            {
                "id": 1567937,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Excuse me, what kind of madman has published 5000 highly-cited papers?\\nI swear that dude must know incredibly much about Riemannian geometry and incredibly little about women"
                    },
                    {
                        "username": "ignacioariasdev",
                        "content": "[@dungtuanuet](/dungtuanuet) what gives u money?"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "rolf\\n"
                    },
                    {
                        "username": "ourlord",
                        "content": "According to the hint, I tried my version with the build-in `sort()` and get a one time AC. But if in a real interview scenario, do we allow to use build-in sort to solve this problem?\\n\\nWhat would the actual point the interviewee might look for?"
                    },
                    {
                        "username": "isydor",
                        "content": "[@Tribhuwan-Joshi](/Tribhuwan-Joshi) it is literally mentioned on the wiki page..."
                    },
                    {
                        "username": "NareshSawlani",
                        "content": "interviewer would be looking for your approach like in this question it would be using count sort manually no API"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "Please don\\'t share hints like using `sort()` in the discussion "
                    },
                    {
                        "username": "haucaucau",
                        "content": "What if the input is [4,4,4,4,4,4,5]?\\nWhen I run with my code the answer is 4 and it was accepted.\\nBut I don\\'t understand cause there are 7 papers that have at least 4 citations,\\nand 0 paper no more than 4, which contradicts the description."
                    },
                    {
                        "username": "DxRz729",
                        "content": "Yes your the input has 7 papers with 4 citations, but the h in h-index means that it should be the same for no of citations and no of papers, so we will only take 4 papers as it is min of (4,7)"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": "[@hemantsingh4774](/hemantsingh4774)  reference: https://en.wikipedia.org/wiki/H-index"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": " For example, if an author has five publications, with 9, 7, 6, 2, and 1 citations (ordered from greatest to least), then the author\\'s h-index is 3, because the author has three publications with 3 or more citations. However, the author does not have four publications with 4 or more citations."
                    },
                    {
                        "username": "han35",
                        "content": "[0] means there is 1 paper and the citation is 0.\\nAccording to the description\\n\\n> A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each\\n\\nA scientist has 1(h) of his/her 1 paper has at least 0(h) citation, and the other 0 paper has no more than 0 citation.\\n\\nIs this a contradiction?"
                    },
                    {
                        "username": "yellowstar1014",
                        "content": "is it possible to have two h in this problem? please give an example?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "it literaly says to be a maximum value. how in the world would something have two distinct maximum values?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "![hehe.png](https://assets.leetcode.com/users/images/f16e4f9d-434f-4e5c-bf36-3cc106ea074a_1677794934.0254838.png)"
                    },
                    {
                        "username": "shuyi@cvs",
                        "content": "Hi,\\n\\nI came across a situation:  given citations = [3, 1, 7, 8, 9]. What will be the answer be?\\n\\nAccording to the definition of h-index on Wikipedia: \"A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\"\\n\\nWhen h=3, the definition will be \"A scientist has index 3 if 3 of his/her 5 papers have at least 3 citations each, and the other 2 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nWhen h=4, the definition will be \"A scientist has index 4 if 4 of his/her 5 papers have at least 4 citations each, and the other 1 papers have no more than 4 citations each.\" Obviously wrong....\\n\\nWhen h=2, the definition will be \"A scientist has index 2 if 2 of his/her 5 papers have at least 2 citations each, and the other 3 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nSo anybody can give me an answer? Or this question is a wrong one?"
                    },
                    {
                        "username": "user2118U",
                        "content": "Definition of h is The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times. See it is written at least h papers not exact h papers"
                    },
                    {
                        "username": "user2118U",
                        "content": "Dude there  is nothing written like that other papers have no more h citations. your example answer is 3 because researcher has published at least 3 papers and each paper has atleast 3 citations"
                    },
                    {
                        "username": "saurabh8katyal",
                        "content": "Answer will be 3, as the other 2 papers have no more than 3 citations each(1, 3). Not more than 3. Can be equal to."
                    },
                    {
                        "username": "Tsien",
                        "content": "In the problem description, there is a line \"Note: If there are several possible values for h, the maximum one is taken as the h-index.\"\\nI cannot come up with an example that could have several possible values for h. \\nIMO, there is only one value for h for each example according to the definition of H-Index.\\nPlease correct me if i'm wrong.\\nThanks!"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Anyone thought of Binary search, no need of sorting technique required,\\nDon\\'t open solution if you have not gave it a try using binary search:\\nhttps://leetcode.com/problems/h-index/solutions/3741453/easy-binary-search-problem-no-sorting-technique-required-o-nlogn/ "
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "[@RajputShivraj](/RajputShivraj) He probably meant to apply binary search on the answer and not on the given array."
                    },
                    {
                        "username": "CriticalCorduroy",
                        "content": "How would binary search be beneficial without a sort applied to the citations?"
                    },
                    {
                        "username": "RajputShivraj",
                        "content": "binary search can be applied on sorted arrays na and you are saying no need of sorting techniques\\n"
                    },
                    {
                        "username": "lowiq",
                        "content": "According to the definition of h, \"if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\" Looks like the h value is unique. The \"Note\" part looks unnecessary. \\n\\nProof: say there exist two h-indices, h1 < h2 (1), which means that, there are h2 numbers have value at least h2 (2) and N-h2 values have value at most h2 (3); there are h1 numbers have value at least h1 (4) and N-h1 values have value at most h1(5).\\n\\nWe have (1)(2)(3), (1) and (2) implies (4), but we can see (5) is not possible. Because we have N-h1 > N-h2, there exists at least one paper not in the set of N-h2 but in the set of N-h1, this paper should have value <= h1 (according to 5) and have value >= h2 (according to 2), this contradicts to (1). \\n\\nThe uniqueness follows."
                    },
                    {
                        "username": "job_xu",
                        "content": "Have two questions about the example 1:why not 5? There are two papers be cited at least 5 times.  why not 1? There are four papers be cited at least 1 times.  "
                    },
                    {
                        "username": "shivam_sharma2004",
                        "content": "5 cant be the ans because there do not exist atleast 5 elements in the array which are greater than 5. Talking about 1 yes it is valid value of h but you need to return the max value of h possible which is 3 in this case ."
                    }
                ]
            },
            {
                "id": 1566081,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Excuse me, what kind of madman has published 5000 highly-cited papers?\\nI swear that dude must know incredibly much about Riemannian geometry and incredibly little about women"
                    },
                    {
                        "username": "ignacioariasdev",
                        "content": "[@dungtuanuet](/dungtuanuet) what gives u money?"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "rolf\\n"
                    },
                    {
                        "username": "ourlord",
                        "content": "According to the hint, I tried my version with the build-in `sort()` and get a one time AC. But if in a real interview scenario, do we allow to use build-in sort to solve this problem?\\n\\nWhat would the actual point the interviewee might look for?"
                    },
                    {
                        "username": "isydor",
                        "content": "[@Tribhuwan-Joshi](/Tribhuwan-Joshi) it is literally mentioned on the wiki page..."
                    },
                    {
                        "username": "NareshSawlani",
                        "content": "interviewer would be looking for your approach like in this question it would be using count sort manually no API"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "Please don\\'t share hints like using `sort()` in the discussion "
                    },
                    {
                        "username": "haucaucau",
                        "content": "What if the input is [4,4,4,4,4,4,5]?\\nWhen I run with my code the answer is 4 and it was accepted.\\nBut I don\\'t understand cause there are 7 papers that have at least 4 citations,\\nand 0 paper no more than 4, which contradicts the description."
                    },
                    {
                        "username": "DxRz729",
                        "content": "Yes your the input has 7 papers with 4 citations, but the h in h-index means that it should be the same for no of citations and no of papers, so we will only take 4 papers as it is min of (4,7)"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": "[@hemantsingh4774](/hemantsingh4774)  reference: https://en.wikipedia.org/wiki/H-index"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": " For example, if an author has five publications, with 9, 7, 6, 2, and 1 citations (ordered from greatest to least), then the author\\'s h-index is 3, because the author has three publications with 3 or more citations. However, the author does not have four publications with 4 or more citations."
                    },
                    {
                        "username": "han35",
                        "content": "[0] means there is 1 paper and the citation is 0.\\nAccording to the description\\n\\n> A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each\\n\\nA scientist has 1(h) of his/her 1 paper has at least 0(h) citation, and the other 0 paper has no more than 0 citation.\\n\\nIs this a contradiction?"
                    },
                    {
                        "username": "yellowstar1014",
                        "content": "is it possible to have two h in this problem? please give an example?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "it literaly says to be a maximum value. how in the world would something have two distinct maximum values?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "![hehe.png](https://assets.leetcode.com/users/images/f16e4f9d-434f-4e5c-bf36-3cc106ea074a_1677794934.0254838.png)"
                    },
                    {
                        "username": "shuyi@cvs",
                        "content": "Hi,\\n\\nI came across a situation:  given citations = [3, 1, 7, 8, 9]. What will be the answer be?\\n\\nAccording to the definition of h-index on Wikipedia: \"A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\"\\n\\nWhen h=3, the definition will be \"A scientist has index 3 if 3 of his/her 5 papers have at least 3 citations each, and the other 2 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nWhen h=4, the definition will be \"A scientist has index 4 if 4 of his/her 5 papers have at least 4 citations each, and the other 1 papers have no more than 4 citations each.\" Obviously wrong....\\n\\nWhen h=2, the definition will be \"A scientist has index 2 if 2 of his/her 5 papers have at least 2 citations each, and the other 3 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nSo anybody can give me an answer? Or this question is a wrong one?"
                    },
                    {
                        "username": "user2118U",
                        "content": "Definition of h is The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times. See it is written at least h papers not exact h papers"
                    },
                    {
                        "username": "user2118U",
                        "content": "Dude there  is nothing written like that other papers have no more h citations. your example answer is 3 because researcher has published at least 3 papers and each paper has atleast 3 citations"
                    },
                    {
                        "username": "saurabh8katyal",
                        "content": "Answer will be 3, as the other 2 papers have no more than 3 citations each(1, 3). Not more than 3. Can be equal to."
                    },
                    {
                        "username": "Tsien",
                        "content": "In the problem description, there is a line \"Note: If there are several possible values for h, the maximum one is taken as the h-index.\"\\nI cannot come up with an example that could have several possible values for h. \\nIMO, there is only one value for h for each example according to the definition of H-Index.\\nPlease correct me if i'm wrong.\\nThanks!"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Anyone thought of Binary search, no need of sorting technique required,\\nDon\\'t open solution if you have not gave it a try using binary search:\\nhttps://leetcode.com/problems/h-index/solutions/3741453/easy-binary-search-problem-no-sorting-technique-required-o-nlogn/ "
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "[@RajputShivraj](/RajputShivraj) He probably meant to apply binary search on the answer and not on the given array."
                    },
                    {
                        "username": "CriticalCorduroy",
                        "content": "How would binary search be beneficial without a sort applied to the citations?"
                    },
                    {
                        "username": "RajputShivraj",
                        "content": "binary search can be applied on sorted arrays na and you are saying no need of sorting techniques\\n"
                    },
                    {
                        "username": "lowiq",
                        "content": "According to the definition of h, \"if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\" Looks like the h value is unique. The \"Note\" part looks unnecessary. \\n\\nProof: say there exist two h-indices, h1 < h2 (1), which means that, there are h2 numbers have value at least h2 (2) and N-h2 values have value at most h2 (3); there are h1 numbers have value at least h1 (4) and N-h1 values have value at most h1(5).\\n\\nWe have (1)(2)(3), (1) and (2) implies (4), but we can see (5) is not possible. Because we have N-h1 > N-h2, there exists at least one paper not in the set of N-h2 but in the set of N-h1, this paper should have value <= h1 (according to 5) and have value >= h2 (according to 2), this contradicts to (1). \\n\\nThe uniqueness follows."
                    },
                    {
                        "username": "job_xu",
                        "content": "Have two questions about the example 1:why not 5? There are two papers be cited at least 5 times.  why not 1? There are four papers be cited at least 1 times.  "
                    },
                    {
                        "username": "shivam_sharma2004",
                        "content": "5 cant be the ans because there do not exist atleast 5 elements in the array which are greater than 5. Talking about 1 yes it is valid value of h but you need to return the max value of h possible which is 3 in this case ."
                    }
                ]
            },
            {
                "id": 1569052,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Excuse me, what kind of madman has published 5000 highly-cited papers?\\nI swear that dude must know incredibly much about Riemannian geometry and incredibly little about women"
                    },
                    {
                        "username": "ignacioariasdev",
                        "content": "[@dungtuanuet](/dungtuanuet) what gives u money?"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "rolf\\n"
                    },
                    {
                        "username": "ourlord",
                        "content": "According to the hint, I tried my version with the build-in `sort()` and get a one time AC. But if in a real interview scenario, do we allow to use build-in sort to solve this problem?\\n\\nWhat would the actual point the interviewee might look for?"
                    },
                    {
                        "username": "isydor",
                        "content": "[@Tribhuwan-Joshi](/Tribhuwan-Joshi) it is literally mentioned on the wiki page..."
                    },
                    {
                        "username": "NareshSawlani",
                        "content": "interviewer would be looking for your approach like in this question it would be using count sort manually no API"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "Please don\\'t share hints like using `sort()` in the discussion "
                    },
                    {
                        "username": "haucaucau",
                        "content": "What if the input is [4,4,4,4,4,4,5]?\\nWhen I run with my code the answer is 4 and it was accepted.\\nBut I don\\'t understand cause there are 7 papers that have at least 4 citations,\\nand 0 paper no more than 4, which contradicts the description."
                    },
                    {
                        "username": "DxRz729",
                        "content": "Yes your the input has 7 papers with 4 citations, but the h in h-index means that it should be the same for no of citations and no of papers, so we will only take 4 papers as it is min of (4,7)"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": "[@hemantsingh4774](/hemantsingh4774)  reference: https://en.wikipedia.org/wiki/H-index"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": " For example, if an author has five publications, with 9, 7, 6, 2, and 1 citations (ordered from greatest to least), then the author\\'s h-index is 3, because the author has three publications with 3 or more citations. However, the author does not have four publications with 4 or more citations."
                    },
                    {
                        "username": "han35",
                        "content": "[0] means there is 1 paper and the citation is 0.\\nAccording to the description\\n\\n> A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each\\n\\nA scientist has 1(h) of his/her 1 paper has at least 0(h) citation, and the other 0 paper has no more than 0 citation.\\n\\nIs this a contradiction?"
                    },
                    {
                        "username": "yellowstar1014",
                        "content": "is it possible to have two h in this problem? please give an example?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "it literaly says to be a maximum value. how in the world would something have two distinct maximum values?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "![hehe.png](https://assets.leetcode.com/users/images/f16e4f9d-434f-4e5c-bf36-3cc106ea074a_1677794934.0254838.png)"
                    },
                    {
                        "username": "shuyi@cvs",
                        "content": "Hi,\\n\\nI came across a situation:  given citations = [3, 1, 7, 8, 9]. What will be the answer be?\\n\\nAccording to the definition of h-index on Wikipedia: \"A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\"\\n\\nWhen h=3, the definition will be \"A scientist has index 3 if 3 of his/her 5 papers have at least 3 citations each, and the other 2 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nWhen h=4, the definition will be \"A scientist has index 4 if 4 of his/her 5 papers have at least 4 citations each, and the other 1 papers have no more than 4 citations each.\" Obviously wrong....\\n\\nWhen h=2, the definition will be \"A scientist has index 2 if 2 of his/her 5 papers have at least 2 citations each, and the other 3 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nSo anybody can give me an answer? Or this question is a wrong one?"
                    },
                    {
                        "username": "user2118U",
                        "content": "Definition of h is The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times. See it is written at least h papers not exact h papers"
                    },
                    {
                        "username": "user2118U",
                        "content": "Dude there  is nothing written like that other papers have no more h citations. your example answer is 3 because researcher has published at least 3 papers and each paper has atleast 3 citations"
                    },
                    {
                        "username": "saurabh8katyal",
                        "content": "Answer will be 3, as the other 2 papers have no more than 3 citations each(1, 3). Not more than 3. Can be equal to."
                    },
                    {
                        "username": "Tsien",
                        "content": "In the problem description, there is a line \"Note: If there are several possible values for h, the maximum one is taken as the h-index.\"\\nI cannot come up with an example that could have several possible values for h. \\nIMO, there is only one value for h for each example according to the definition of H-Index.\\nPlease correct me if i'm wrong.\\nThanks!"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Anyone thought of Binary search, no need of sorting technique required,\\nDon\\'t open solution if you have not gave it a try using binary search:\\nhttps://leetcode.com/problems/h-index/solutions/3741453/easy-binary-search-problem-no-sorting-technique-required-o-nlogn/ "
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "[@RajputShivraj](/RajputShivraj) He probably meant to apply binary search on the answer and not on the given array."
                    },
                    {
                        "username": "CriticalCorduroy",
                        "content": "How would binary search be beneficial without a sort applied to the citations?"
                    },
                    {
                        "username": "RajputShivraj",
                        "content": "binary search can be applied on sorted arrays na and you are saying no need of sorting techniques\\n"
                    },
                    {
                        "username": "lowiq",
                        "content": "According to the definition of h, \"if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\" Looks like the h value is unique. The \"Note\" part looks unnecessary. \\n\\nProof: say there exist two h-indices, h1 < h2 (1), which means that, there are h2 numbers have value at least h2 (2) and N-h2 values have value at most h2 (3); there are h1 numbers have value at least h1 (4) and N-h1 values have value at most h1(5).\\n\\nWe have (1)(2)(3), (1) and (2) implies (4), but we can see (5) is not possible. Because we have N-h1 > N-h2, there exists at least one paper not in the set of N-h2 but in the set of N-h1, this paper should have value <= h1 (according to 5) and have value >= h2 (according to 2), this contradicts to (1). \\n\\nThe uniqueness follows."
                    },
                    {
                        "username": "job_xu",
                        "content": "Have two questions about the example 1:why not 5? There are two papers be cited at least 5 times.  why not 1? There are four papers be cited at least 1 times.  "
                    },
                    {
                        "username": "shivam_sharma2004",
                        "content": "5 cant be the ans because there do not exist atleast 5 elements in the array which are greater than 5. Talking about 1 yes it is valid value of h but you need to return the max value of h possible which is 3 in this case ."
                    }
                ]
            },
            {
                "id": 1569050,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Excuse me, what kind of madman has published 5000 highly-cited papers?\\nI swear that dude must know incredibly much about Riemannian geometry and incredibly little about women"
                    },
                    {
                        "username": "ignacioariasdev",
                        "content": "[@dungtuanuet](/dungtuanuet) what gives u money?"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "rolf\\n"
                    },
                    {
                        "username": "ourlord",
                        "content": "According to the hint, I tried my version with the build-in `sort()` and get a one time AC. But if in a real interview scenario, do we allow to use build-in sort to solve this problem?\\n\\nWhat would the actual point the interviewee might look for?"
                    },
                    {
                        "username": "isydor",
                        "content": "[@Tribhuwan-Joshi](/Tribhuwan-Joshi) it is literally mentioned on the wiki page..."
                    },
                    {
                        "username": "NareshSawlani",
                        "content": "interviewer would be looking for your approach like in this question it would be using count sort manually no API"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "Please don\\'t share hints like using `sort()` in the discussion "
                    },
                    {
                        "username": "haucaucau",
                        "content": "What if the input is [4,4,4,4,4,4,5]?\\nWhen I run with my code the answer is 4 and it was accepted.\\nBut I don\\'t understand cause there are 7 papers that have at least 4 citations,\\nand 0 paper no more than 4, which contradicts the description."
                    },
                    {
                        "username": "DxRz729",
                        "content": "Yes your the input has 7 papers with 4 citations, but the h in h-index means that it should be the same for no of citations and no of papers, so we will only take 4 papers as it is min of (4,7)"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": "[@hemantsingh4774](/hemantsingh4774)  reference: https://en.wikipedia.org/wiki/H-index"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": " For example, if an author has five publications, with 9, 7, 6, 2, and 1 citations (ordered from greatest to least), then the author\\'s h-index is 3, because the author has three publications with 3 or more citations. However, the author does not have four publications with 4 or more citations."
                    },
                    {
                        "username": "han35",
                        "content": "[0] means there is 1 paper and the citation is 0.\\nAccording to the description\\n\\n> A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each\\n\\nA scientist has 1(h) of his/her 1 paper has at least 0(h) citation, and the other 0 paper has no more than 0 citation.\\n\\nIs this a contradiction?"
                    },
                    {
                        "username": "yellowstar1014",
                        "content": "is it possible to have two h in this problem? please give an example?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "it literaly says to be a maximum value. how in the world would something have two distinct maximum values?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "![hehe.png](https://assets.leetcode.com/users/images/f16e4f9d-434f-4e5c-bf36-3cc106ea074a_1677794934.0254838.png)"
                    },
                    {
                        "username": "shuyi@cvs",
                        "content": "Hi,\\n\\nI came across a situation:  given citations = [3, 1, 7, 8, 9]. What will be the answer be?\\n\\nAccording to the definition of h-index on Wikipedia: \"A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\"\\n\\nWhen h=3, the definition will be \"A scientist has index 3 if 3 of his/her 5 papers have at least 3 citations each, and the other 2 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nWhen h=4, the definition will be \"A scientist has index 4 if 4 of his/her 5 papers have at least 4 citations each, and the other 1 papers have no more than 4 citations each.\" Obviously wrong....\\n\\nWhen h=2, the definition will be \"A scientist has index 2 if 2 of his/her 5 papers have at least 2 citations each, and the other 3 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nSo anybody can give me an answer? Or this question is a wrong one?"
                    },
                    {
                        "username": "user2118U",
                        "content": "Definition of h is The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times. See it is written at least h papers not exact h papers"
                    },
                    {
                        "username": "user2118U",
                        "content": "Dude there  is nothing written like that other papers have no more h citations. your example answer is 3 because researcher has published at least 3 papers and each paper has atleast 3 citations"
                    },
                    {
                        "username": "saurabh8katyal",
                        "content": "Answer will be 3, as the other 2 papers have no more than 3 citations each(1, 3). Not more than 3. Can be equal to."
                    },
                    {
                        "username": "Tsien",
                        "content": "In the problem description, there is a line \"Note: If there are several possible values for h, the maximum one is taken as the h-index.\"\\nI cannot come up with an example that could have several possible values for h. \\nIMO, there is only one value for h for each example according to the definition of H-Index.\\nPlease correct me if i'm wrong.\\nThanks!"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Anyone thought of Binary search, no need of sorting technique required,\\nDon\\'t open solution if you have not gave it a try using binary search:\\nhttps://leetcode.com/problems/h-index/solutions/3741453/easy-binary-search-problem-no-sorting-technique-required-o-nlogn/ "
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "[@RajputShivraj](/RajputShivraj) He probably meant to apply binary search on the answer and not on the given array."
                    },
                    {
                        "username": "CriticalCorduroy",
                        "content": "How would binary search be beneficial without a sort applied to the citations?"
                    },
                    {
                        "username": "RajputShivraj",
                        "content": "binary search can be applied on sorted arrays na and you are saying no need of sorting techniques\\n"
                    },
                    {
                        "username": "lowiq",
                        "content": "According to the definition of h, \"if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\" Looks like the h value is unique. The \"Note\" part looks unnecessary. \\n\\nProof: say there exist two h-indices, h1 < h2 (1), which means that, there are h2 numbers have value at least h2 (2) and N-h2 values have value at most h2 (3); there are h1 numbers have value at least h1 (4) and N-h1 values have value at most h1(5).\\n\\nWe have (1)(2)(3), (1) and (2) implies (4), but we can see (5) is not possible. Because we have N-h1 > N-h2, there exists at least one paper not in the set of N-h2 but in the set of N-h1, this paper should have value <= h1 (according to 5) and have value >= h2 (according to 2), this contradicts to (1). \\n\\nThe uniqueness follows."
                    },
                    {
                        "username": "job_xu",
                        "content": "Have two questions about the example 1:why not 5? There are two papers be cited at least 5 times.  why not 1? There are four papers be cited at least 1 times.  "
                    },
                    {
                        "username": "shivam_sharma2004",
                        "content": "5 cant be the ans because there do not exist atleast 5 elements in the array which are greater than 5. Talking about 1 yes it is valid value of h but you need to return the max value of h possible which is 3 in this case ."
                    }
                ]
            },
            {
                "id": 1963174,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Excuse me, what kind of madman has published 5000 highly-cited papers?\\nI swear that dude must know incredibly much about Riemannian geometry and incredibly little about women"
                    },
                    {
                        "username": "ignacioariasdev",
                        "content": "[@dungtuanuet](/dungtuanuet) what gives u money?"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "rolf\\n"
                    },
                    {
                        "username": "ourlord",
                        "content": "According to the hint, I tried my version with the build-in `sort()` and get a one time AC. But if in a real interview scenario, do we allow to use build-in sort to solve this problem?\\n\\nWhat would the actual point the interviewee might look for?"
                    },
                    {
                        "username": "isydor",
                        "content": "[@Tribhuwan-Joshi](/Tribhuwan-Joshi) it is literally mentioned on the wiki page..."
                    },
                    {
                        "username": "NareshSawlani",
                        "content": "interviewer would be looking for your approach like in this question it would be using count sort manually no API"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "Please don\\'t share hints like using `sort()` in the discussion "
                    },
                    {
                        "username": "haucaucau",
                        "content": "What if the input is [4,4,4,4,4,4,5]?\\nWhen I run with my code the answer is 4 and it was accepted.\\nBut I don\\'t understand cause there are 7 papers that have at least 4 citations,\\nand 0 paper no more than 4, which contradicts the description."
                    },
                    {
                        "username": "DxRz729",
                        "content": "Yes your the input has 7 papers with 4 citations, but the h in h-index means that it should be the same for no of citations and no of papers, so we will only take 4 papers as it is min of (4,7)"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": "[@hemantsingh4774](/hemantsingh4774)  reference: https://en.wikipedia.org/wiki/H-index"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": " For example, if an author has five publications, with 9, 7, 6, 2, and 1 citations (ordered from greatest to least), then the author\\'s h-index is 3, because the author has three publications with 3 or more citations. However, the author does not have four publications with 4 or more citations."
                    },
                    {
                        "username": "han35",
                        "content": "[0] means there is 1 paper and the citation is 0.\\nAccording to the description\\n\\n> A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each\\n\\nA scientist has 1(h) of his/her 1 paper has at least 0(h) citation, and the other 0 paper has no more than 0 citation.\\n\\nIs this a contradiction?"
                    },
                    {
                        "username": "yellowstar1014",
                        "content": "is it possible to have two h in this problem? please give an example?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "it literaly says to be a maximum value. how in the world would something have two distinct maximum values?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "![hehe.png](https://assets.leetcode.com/users/images/f16e4f9d-434f-4e5c-bf36-3cc106ea074a_1677794934.0254838.png)"
                    },
                    {
                        "username": "shuyi@cvs",
                        "content": "Hi,\\n\\nI came across a situation:  given citations = [3, 1, 7, 8, 9]. What will be the answer be?\\n\\nAccording to the definition of h-index on Wikipedia: \"A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\"\\n\\nWhen h=3, the definition will be \"A scientist has index 3 if 3 of his/her 5 papers have at least 3 citations each, and the other 2 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nWhen h=4, the definition will be \"A scientist has index 4 if 4 of his/her 5 papers have at least 4 citations each, and the other 1 papers have no more than 4 citations each.\" Obviously wrong....\\n\\nWhen h=2, the definition will be \"A scientist has index 2 if 2 of his/her 5 papers have at least 2 citations each, and the other 3 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nSo anybody can give me an answer? Or this question is a wrong one?"
                    },
                    {
                        "username": "user2118U",
                        "content": "Definition of h is The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times. See it is written at least h papers not exact h papers"
                    },
                    {
                        "username": "user2118U",
                        "content": "Dude there  is nothing written like that other papers have no more h citations. your example answer is 3 because researcher has published at least 3 papers and each paper has atleast 3 citations"
                    },
                    {
                        "username": "saurabh8katyal",
                        "content": "Answer will be 3, as the other 2 papers have no more than 3 citations each(1, 3). Not more than 3. Can be equal to."
                    },
                    {
                        "username": "Tsien",
                        "content": "In the problem description, there is a line \"Note: If there are several possible values for h, the maximum one is taken as the h-index.\"\\nI cannot come up with an example that could have several possible values for h. \\nIMO, there is only one value for h for each example according to the definition of H-Index.\\nPlease correct me if i'm wrong.\\nThanks!"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Anyone thought of Binary search, no need of sorting technique required,\\nDon\\'t open solution if you have not gave it a try using binary search:\\nhttps://leetcode.com/problems/h-index/solutions/3741453/easy-binary-search-problem-no-sorting-technique-required-o-nlogn/ "
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "[@RajputShivraj](/RajputShivraj) He probably meant to apply binary search on the answer and not on the given array."
                    },
                    {
                        "username": "CriticalCorduroy",
                        "content": "How would binary search be beneficial without a sort applied to the citations?"
                    },
                    {
                        "username": "RajputShivraj",
                        "content": "binary search can be applied on sorted arrays na and you are saying no need of sorting techniques\\n"
                    },
                    {
                        "username": "lowiq",
                        "content": "According to the definition of h, \"if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\" Looks like the h value is unique. The \"Note\" part looks unnecessary. \\n\\nProof: say there exist two h-indices, h1 < h2 (1), which means that, there are h2 numbers have value at least h2 (2) and N-h2 values have value at most h2 (3); there are h1 numbers have value at least h1 (4) and N-h1 values have value at most h1(5).\\n\\nWe have (1)(2)(3), (1) and (2) implies (4), but we can see (5) is not possible. Because we have N-h1 > N-h2, there exists at least one paper not in the set of N-h2 but in the set of N-h1, this paper should have value <= h1 (according to 5) and have value >= h2 (according to 2), this contradicts to (1). \\n\\nThe uniqueness follows."
                    },
                    {
                        "username": "job_xu",
                        "content": "Have two questions about the example 1:why not 5? There are two papers be cited at least 5 times.  why not 1? There are four papers be cited at least 1 times.  "
                    },
                    {
                        "username": "shivam_sharma2004",
                        "content": "5 cant be the ans because there do not exist atleast 5 elements in the array which are greater than 5. Talking about 1 yes it is valid value of h but you need to return the max value of h possible which is 3 in this case ."
                    }
                ]
            },
            {
                "id": 1569051,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Excuse me, what kind of madman has published 5000 highly-cited papers?\\nI swear that dude must know incredibly much about Riemannian geometry and incredibly little about women"
                    },
                    {
                        "username": "ignacioariasdev",
                        "content": "[@dungtuanuet](/dungtuanuet) what gives u money?"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "rolf\\n"
                    },
                    {
                        "username": "ourlord",
                        "content": "According to the hint, I tried my version with the build-in `sort()` and get a one time AC. But if in a real interview scenario, do we allow to use build-in sort to solve this problem?\\n\\nWhat would the actual point the interviewee might look for?"
                    },
                    {
                        "username": "isydor",
                        "content": "[@Tribhuwan-Joshi](/Tribhuwan-Joshi) it is literally mentioned on the wiki page..."
                    },
                    {
                        "username": "NareshSawlani",
                        "content": "interviewer would be looking for your approach like in this question it would be using count sort manually no API"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "Please don\\'t share hints like using `sort()` in the discussion "
                    },
                    {
                        "username": "haucaucau",
                        "content": "What if the input is [4,4,4,4,4,4,5]?\\nWhen I run with my code the answer is 4 and it was accepted.\\nBut I don\\'t understand cause there are 7 papers that have at least 4 citations,\\nand 0 paper no more than 4, which contradicts the description."
                    },
                    {
                        "username": "DxRz729",
                        "content": "Yes your the input has 7 papers with 4 citations, but the h in h-index means that it should be the same for no of citations and no of papers, so we will only take 4 papers as it is min of (4,7)"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": "[@hemantsingh4774](/hemantsingh4774)  reference: https://en.wikipedia.org/wiki/H-index"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": " For example, if an author has five publications, with 9, 7, 6, 2, and 1 citations (ordered from greatest to least), then the author\\'s h-index is 3, because the author has three publications with 3 or more citations. However, the author does not have four publications with 4 or more citations."
                    },
                    {
                        "username": "han35",
                        "content": "[0] means there is 1 paper and the citation is 0.\\nAccording to the description\\n\\n> A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each\\n\\nA scientist has 1(h) of his/her 1 paper has at least 0(h) citation, and the other 0 paper has no more than 0 citation.\\n\\nIs this a contradiction?"
                    },
                    {
                        "username": "yellowstar1014",
                        "content": "is it possible to have two h in this problem? please give an example?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "it literaly says to be a maximum value. how in the world would something have two distinct maximum values?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "![hehe.png](https://assets.leetcode.com/users/images/f16e4f9d-434f-4e5c-bf36-3cc106ea074a_1677794934.0254838.png)"
                    },
                    {
                        "username": "shuyi@cvs",
                        "content": "Hi,\\n\\nI came across a situation:  given citations = [3, 1, 7, 8, 9]. What will be the answer be?\\n\\nAccording to the definition of h-index on Wikipedia: \"A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\"\\n\\nWhen h=3, the definition will be \"A scientist has index 3 if 3 of his/her 5 papers have at least 3 citations each, and the other 2 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nWhen h=4, the definition will be \"A scientist has index 4 if 4 of his/her 5 papers have at least 4 citations each, and the other 1 papers have no more than 4 citations each.\" Obviously wrong....\\n\\nWhen h=2, the definition will be \"A scientist has index 2 if 2 of his/her 5 papers have at least 2 citations each, and the other 3 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nSo anybody can give me an answer? Or this question is a wrong one?"
                    },
                    {
                        "username": "user2118U",
                        "content": "Definition of h is The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times. See it is written at least h papers not exact h papers"
                    },
                    {
                        "username": "user2118U",
                        "content": "Dude there  is nothing written like that other papers have no more h citations. your example answer is 3 because researcher has published at least 3 papers and each paper has atleast 3 citations"
                    },
                    {
                        "username": "saurabh8katyal",
                        "content": "Answer will be 3, as the other 2 papers have no more than 3 citations each(1, 3). Not more than 3. Can be equal to."
                    },
                    {
                        "username": "Tsien",
                        "content": "In the problem description, there is a line \"Note: If there are several possible values for h, the maximum one is taken as the h-index.\"\\nI cannot come up with an example that could have several possible values for h. \\nIMO, there is only one value for h for each example according to the definition of H-Index.\\nPlease correct me if i'm wrong.\\nThanks!"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Anyone thought of Binary search, no need of sorting technique required,\\nDon\\'t open solution if you have not gave it a try using binary search:\\nhttps://leetcode.com/problems/h-index/solutions/3741453/easy-binary-search-problem-no-sorting-technique-required-o-nlogn/ "
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "[@RajputShivraj](/RajputShivraj) He probably meant to apply binary search on the answer and not on the given array."
                    },
                    {
                        "username": "CriticalCorduroy",
                        "content": "How would binary search be beneficial without a sort applied to the citations?"
                    },
                    {
                        "username": "RajputShivraj",
                        "content": "binary search can be applied on sorted arrays na and you are saying no need of sorting techniques\\n"
                    },
                    {
                        "username": "lowiq",
                        "content": "According to the definition of h, \"if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\" Looks like the h value is unique. The \"Note\" part looks unnecessary. \\n\\nProof: say there exist two h-indices, h1 < h2 (1), which means that, there are h2 numbers have value at least h2 (2) and N-h2 values have value at most h2 (3); there are h1 numbers have value at least h1 (4) and N-h1 values have value at most h1(5).\\n\\nWe have (1)(2)(3), (1) and (2) implies (4), but we can see (5) is not possible. Because we have N-h1 > N-h2, there exists at least one paper not in the set of N-h2 but in the set of N-h1, this paper should have value <= h1 (according to 5) and have value >= h2 (according to 2), this contradicts to (1). \\n\\nThe uniqueness follows."
                    },
                    {
                        "username": "job_xu",
                        "content": "Have two questions about the example 1:why not 5? There are two papers be cited at least 5 times.  why not 1? There are four papers be cited at least 1 times.  "
                    },
                    {
                        "username": "shivam_sharma2004",
                        "content": "5 cant be the ans because there do not exist atleast 5 elements in the array which are greater than 5. Talking about 1 yes it is valid value of h but you need to return the max value of h possible which is 3 in this case ."
                    }
                ]
            },
            {
                "id": 1941363,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Excuse me, what kind of madman has published 5000 highly-cited papers?\\nI swear that dude must know incredibly much about Riemannian geometry and incredibly little about women"
                    },
                    {
                        "username": "ignacioariasdev",
                        "content": "[@dungtuanuet](/dungtuanuet) what gives u money?"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "rolf\\n"
                    },
                    {
                        "username": "ourlord",
                        "content": "According to the hint, I tried my version with the build-in `sort()` and get a one time AC. But if in a real interview scenario, do we allow to use build-in sort to solve this problem?\\n\\nWhat would the actual point the interviewee might look for?"
                    },
                    {
                        "username": "isydor",
                        "content": "[@Tribhuwan-Joshi](/Tribhuwan-Joshi) it is literally mentioned on the wiki page..."
                    },
                    {
                        "username": "NareshSawlani",
                        "content": "interviewer would be looking for your approach like in this question it would be using count sort manually no API"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "Please don\\'t share hints like using `sort()` in the discussion "
                    },
                    {
                        "username": "haucaucau",
                        "content": "What if the input is [4,4,4,4,4,4,5]?\\nWhen I run with my code the answer is 4 and it was accepted.\\nBut I don\\'t understand cause there are 7 papers that have at least 4 citations,\\nand 0 paper no more than 4, which contradicts the description."
                    },
                    {
                        "username": "DxRz729",
                        "content": "Yes your the input has 7 papers with 4 citations, but the h in h-index means that it should be the same for no of citations and no of papers, so we will only take 4 papers as it is min of (4,7)"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": "[@hemantsingh4774](/hemantsingh4774)  reference: https://en.wikipedia.org/wiki/H-index"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": " For example, if an author has five publications, with 9, 7, 6, 2, and 1 citations (ordered from greatest to least), then the author\\'s h-index is 3, because the author has three publications with 3 or more citations. However, the author does not have four publications with 4 or more citations."
                    },
                    {
                        "username": "han35",
                        "content": "[0] means there is 1 paper and the citation is 0.\\nAccording to the description\\n\\n> A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each\\n\\nA scientist has 1(h) of his/her 1 paper has at least 0(h) citation, and the other 0 paper has no more than 0 citation.\\n\\nIs this a contradiction?"
                    },
                    {
                        "username": "yellowstar1014",
                        "content": "is it possible to have two h in this problem? please give an example?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "it literaly says to be a maximum value. how in the world would something have two distinct maximum values?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "![hehe.png](https://assets.leetcode.com/users/images/f16e4f9d-434f-4e5c-bf36-3cc106ea074a_1677794934.0254838.png)"
                    },
                    {
                        "username": "shuyi@cvs",
                        "content": "Hi,\\n\\nI came across a situation:  given citations = [3, 1, 7, 8, 9]. What will be the answer be?\\n\\nAccording to the definition of h-index on Wikipedia: \"A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\"\\n\\nWhen h=3, the definition will be \"A scientist has index 3 if 3 of his/her 5 papers have at least 3 citations each, and the other 2 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nWhen h=4, the definition will be \"A scientist has index 4 if 4 of his/her 5 papers have at least 4 citations each, and the other 1 papers have no more than 4 citations each.\" Obviously wrong....\\n\\nWhen h=2, the definition will be \"A scientist has index 2 if 2 of his/her 5 papers have at least 2 citations each, and the other 3 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nSo anybody can give me an answer? Or this question is a wrong one?"
                    },
                    {
                        "username": "user2118U",
                        "content": "Definition of h is The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times. See it is written at least h papers not exact h papers"
                    },
                    {
                        "username": "user2118U",
                        "content": "Dude there  is nothing written like that other papers have no more h citations. your example answer is 3 because researcher has published at least 3 papers and each paper has atleast 3 citations"
                    },
                    {
                        "username": "saurabh8katyal",
                        "content": "Answer will be 3, as the other 2 papers have no more than 3 citations each(1, 3). Not more than 3. Can be equal to."
                    },
                    {
                        "username": "Tsien",
                        "content": "In the problem description, there is a line \"Note: If there are several possible values for h, the maximum one is taken as the h-index.\"\\nI cannot come up with an example that could have several possible values for h. \\nIMO, there is only one value for h for each example according to the definition of H-Index.\\nPlease correct me if i'm wrong.\\nThanks!"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Anyone thought of Binary search, no need of sorting technique required,\\nDon\\'t open solution if you have not gave it a try using binary search:\\nhttps://leetcode.com/problems/h-index/solutions/3741453/easy-binary-search-problem-no-sorting-technique-required-o-nlogn/ "
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "[@RajputShivraj](/RajputShivraj) He probably meant to apply binary search on the answer and not on the given array."
                    },
                    {
                        "username": "CriticalCorduroy",
                        "content": "How would binary search be beneficial without a sort applied to the citations?"
                    },
                    {
                        "username": "RajputShivraj",
                        "content": "binary search can be applied on sorted arrays na and you are saying no need of sorting techniques\\n"
                    },
                    {
                        "username": "lowiq",
                        "content": "According to the definition of h, \"if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\" Looks like the h value is unique. The \"Note\" part looks unnecessary. \\n\\nProof: say there exist two h-indices, h1 < h2 (1), which means that, there are h2 numbers have value at least h2 (2) and N-h2 values have value at most h2 (3); there are h1 numbers have value at least h1 (4) and N-h1 values have value at most h1(5).\\n\\nWe have (1)(2)(3), (1) and (2) implies (4), but we can see (5) is not possible. Because we have N-h1 > N-h2, there exists at least one paper not in the set of N-h2 but in the set of N-h1, this paper should have value <= h1 (according to 5) and have value >= h2 (according to 2), this contradicts to (1). \\n\\nThe uniqueness follows."
                    },
                    {
                        "username": "job_xu",
                        "content": "Have two questions about the example 1:why not 5? There are two papers be cited at least 5 times.  why not 1? There are four papers be cited at least 1 times.  "
                    },
                    {
                        "username": "shivam_sharma2004",
                        "content": "5 cant be the ans because there do not exist atleast 5 elements in the array which are greater than 5. Talking about 1 yes it is valid value of h but you need to return the max value of h possible which is 3 in this case ."
                    }
                ]
            },
            {
                "id": 2039649,
                "content": [
                    {
                        "username": "Vinayellulla",
                        "content": "what is meant by citations?\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A very similar question with https://leetcode.com/problems/h-index-ii/ .\\nBoth can be solved by sorting and binary search the best h index. (max number of \"good\" publications)"
                    },
                    {
                        "username": "lenhatduc30042003",
                        "content": " given citations = [1,2]. What will be the answer be?"
                    },
                    {
                        "username": "harishgokul",
                        "content": "i think 1 because each value has 1 citations."
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "Why would a binary search solution that searches for the max valid h-index not work for this question?"
                    },
                    {
                        "username": "bernikovich",
                        "content": "It works. I think it\\'s even better than sorting. However, counting has a better time complexity of $$O(n)$$ compared to $$O(n logn)$$."
                    },
                    {
                        "username": "LearnUnlearnRepeat",
                        "content": "how come the expected answer is 2 for the input [11,15].."
                    },
                    {
                        "username": "bernikovich",
                        "content": "Because [11, 15] indicates that the researcher has only 2 papers with 11 and 15 citations, respectively. By definition, the H-index cannot exceed the number of papers, which in this case is 2."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "This is solution is java: https://leetcode.com/problems/h-index/submissions/987689138"
                    },
                    {
                        "username": "Anantashayana",
                        "content": "For [100] why 1 and not 100?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You are returning the number of papers, not the number of citations."
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "[1,2,0] what would be the output?\nmy output is 0\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "The answer is 1. The researcher published 2 papers that had at least 1 citation.\\n(Had we said that the answer was 2 then there is only 1 paper published that has 2 citations and that is less than the h-index)."
                    },
                    {
                        "username": "prakhar3062",
                        "content": "I tried to apply counting sort in non-increasing order but only one test case passes\\n "
                    },
                    {
                        "username": "Avirat06",
                        "content": "getting internal error on my submission for this question"
                    }
                ]
            },
            {
                "id": 2026158,
                "content": [
                    {
                        "username": "Vinayellulla",
                        "content": "what is meant by citations?\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A very similar question with https://leetcode.com/problems/h-index-ii/ .\\nBoth can be solved by sorting and binary search the best h index. (max number of \"good\" publications)"
                    },
                    {
                        "username": "lenhatduc30042003",
                        "content": " given citations = [1,2]. What will be the answer be?"
                    },
                    {
                        "username": "harishgokul",
                        "content": "i think 1 because each value has 1 citations."
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "Why would a binary search solution that searches for the max valid h-index not work for this question?"
                    },
                    {
                        "username": "bernikovich",
                        "content": "It works. I think it\\'s even better than sorting. However, counting has a better time complexity of $$O(n)$$ compared to $$O(n logn)$$."
                    },
                    {
                        "username": "LearnUnlearnRepeat",
                        "content": "how come the expected answer is 2 for the input [11,15].."
                    },
                    {
                        "username": "bernikovich",
                        "content": "Because [11, 15] indicates that the researcher has only 2 papers with 11 and 15 citations, respectively. By definition, the H-index cannot exceed the number of papers, which in this case is 2."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "This is solution is java: https://leetcode.com/problems/h-index/submissions/987689138"
                    },
                    {
                        "username": "Anantashayana",
                        "content": "For [100] why 1 and not 100?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You are returning the number of papers, not the number of citations."
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "[1,2,0] what would be the output?\nmy output is 0\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "The answer is 1. The researcher published 2 papers that had at least 1 citation.\\n(Had we said that the answer was 2 then there is only 1 paper published that has 2 citations and that is less than the h-index)."
                    },
                    {
                        "username": "prakhar3062",
                        "content": "I tried to apply counting sort in non-increasing order but only one test case passes\\n "
                    },
                    {
                        "username": "Avirat06",
                        "content": "getting internal error on my submission for this question"
                    }
                ]
            },
            {
                "id": 2022443,
                "content": [
                    {
                        "username": "Vinayellulla",
                        "content": "what is meant by citations?\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A very similar question with https://leetcode.com/problems/h-index-ii/ .\\nBoth can be solved by sorting and binary search the best h index. (max number of \"good\" publications)"
                    },
                    {
                        "username": "lenhatduc30042003",
                        "content": " given citations = [1,2]. What will be the answer be?"
                    },
                    {
                        "username": "harishgokul",
                        "content": "i think 1 because each value has 1 citations."
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "Why would a binary search solution that searches for the max valid h-index not work for this question?"
                    },
                    {
                        "username": "bernikovich",
                        "content": "It works. I think it\\'s even better than sorting. However, counting has a better time complexity of $$O(n)$$ compared to $$O(n logn)$$."
                    },
                    {
                        "username": "LearnUnlearnRepeat",
                        "content": "how come the expected answer is 2 for the input [11,15].."
                    },
                    {
                        "username": "bernikovich",
                        "content": "Because [11, 15] indicates that the researcher has only 2 papers with 11 and 15 citations, respectively. By definition, the H-index cannot exceed the number of papers, which in this case is 2."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "This is solution is java: https://leetcode.com/problems/h-index/submissions/987689138"
                    },
                    {
                        "username": "Anantashayana",
                        "content": "For [100] why 1 and not 100?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You are returning the number of papers, not the number of citations."
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "[1,2,0] what would be the output?\nmy output is 0\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "The answer is 1. The researcher published 2 papers that had at least 1 citation.\\n(Had we said that the answer was 2 then there is only 1 paper published that has 2 citations and that is less than the h-index)."
                    },
                    {
                        "username": "prakhar3062",
                        "content": "I tried to apply counting sort in non-increasing order but only one test case passes\\n "
                    },
                    {
                        "username": "Avirat06",
                        "content": "getting internal error on my submission for this question"
                    }
                ]
            },
            {
                "id": 2017824,
                "content": [
                    {
                        "username": "Vinayellulla",
                        "content": "what is meant by citations?\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A very similar question with https://leetcode.com/problems/h-index-ii/ .\\nBoth can be solved by sorting and binary search the best h index. (max number of \"good\" publications)"
                    },
                    {
                        "username": "lenhatduc30042003",
                        "content": " given citations = [1,2]. What will be the answer be?"
                    },
                    {
                        "username": "harishgokul",
                        "content": "i think 1 because each value has 1 citations."
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "Why would a binary search solution that searches for the max valid h-index not work for this question?"
                    },
                    {
                        "username": "bernikovich",
                        "content": "It works. I think it\\'s even better than sorting. However, counting has a better time complexity of $$O(n)$$ compared to $$O(n logn)$$."
                    },
                    {
                        "username": "LearnUnlearnRepeat",
                        "content": "how come the expected answer is 2 for the input [11,15].."
                    },
                    {
                        "username": "bernikovich",
                        "content": "Because [11, 15] indicates that the researcher has only 2 papers with 11 and 15 citations, respectively. By definition, the H-index cannot exceed the number of papers, which in this case is 2."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "This is solution is java: https://leetcode.com/problems/h-index/submissions/987689138"
                    },
                    {
                        "username": "Anantashayana",
                        "content": "For [100] why 1 and not 100?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You are returning the number of papers, not the number of citations."
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "[1,2,0] what would be the output?\nmy output is 0\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "The answer is 1. The researcher published 2 papers that had at least 1 citation.\\n(Had we said that the answer was 2 then there is only 1 paper published that has 2 citations and that is less than the h-index)."
                    },
                    {
                        "username": "prakhar3062",
                        "content": "I tried to apply counting sort in non-increasing order but only one test case passes\\n "
                    },
                    {
                        "username": "Avirat06",
                        "content": "getting internal error on my submission for this question"
                    }
                ]
            },
            {
                "id": 2001424,
                "content": [
                    {
                        "username": "Vinayellulla",
                        "content": "what is meant by citations?\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A very similar question with https://leetcode.com/problems/h-index-ii/ .\\nBoth can be solved by sorting and binary search the best h index. (max number of \"good\" publications)"
                    },
                    {
                        "username": "lenhatduc30042003",
                        "content": " given citations = [1,2]. What will be the answer be?"
                    },
                    {
                        "username": "harishgokul",
                        "content": "i think 1 because each value has 1 citations."
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "Why would a binary search solution that searches for the max valid h-index not work for this question?"
                    },
                    {
                        "username": "bernikovich",
                        "content": "It works. I think it\\'s even better than sorting. However, counting has a better time complexity of $$O(n)$$ compared to $$O(n logn)$$."
                    },
                    {
                        "username": "LearnUnlearnRepeat",
                        "content": "how come the expected answer is 2 for the input [11,15].."
                    },
                    {
                        "username": "bernikovich",
                        "content": "Because [11, 15] indicates that the researcher has only 2 papers with 11 and 15 citations, respectively. By definition, the H-index cannot exceed the number of papers, which in this case is 2."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "This is solution is java: https://leetcode.com/problems/h-index/submissions/987689138"
                    },
                    {
                        "username": "Anantashayana",
                        "content": "For [100] why 1 and not 100?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You are returning the number of papers, not the number of citations."
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "[1,2,0] what would be the output?\nmy output is 0\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "The answer is 1. The researcher published 2 papers that had at least 1 citation.\\n(Had we said that the answer was 2 then there is only 1 paper published that has 2 citations and that is less than the h-index)."
                    },
                    {
                        "username": "prakhar3062",
                        "content": "I tried to apply counting sort in non-increasing order but only one test case passes\\n "
                    },
                    {
                        "username": "Avirat06",
                        "content": "getting internal error on my submission for this question"
                    }
                ]
            },
            {
                "id": 1958622,
                "content": [
                    {
                        "username": "Vinayellulla",
                        "content": "what is meant by citations?\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A very similar question with https://leetcode.com/problems/h-index-ii/ .\\nBoth can be solved by sorting and binary search the best h index. (max number of \"good\" publications)"
                    },
                    {
                        "username": "lenhatduc30042003",
                        "content": " given citations = [1,2]. What will be the answer be?"
                    },
                    {
                        "username": "harishgokul",
                        "content": "i think 1 because each value has 1 citations."
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "Why would a binary search solution that searches for the max valid h-index not work for this question?"
                    },
                    {
                        "username": "bernikovich",
                        "content": "It works. I think it\\'s even better than sorting. However, counting has a better time complexity of $$O(n)$$ compared to $$O(n logn)$$."
                    },
                    {
                        "username": "LearnUnlearnRepeat",
                        "content": "how come the expected answer is 2 for the input [11,15].."
                    },
                    {
                        "username": "bernikovich",
                        "content": "Because [11, 15] indicates that the researcher has only 2 papers with 11 and 15 citations, respectively. By definition, the H-index cannot exceed the number of papers, which in this case is 2."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "This is solution is java: https://leetcode.com/problems/h-index/submissions/987689138"
                    },
                    {
                        "username": "Anantashayana",
                        "content": "For [100] why 1 and not 100?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You are returning the number of papers, not the number of citations."
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "[1,2,0] what would be the output?\nmy output is 0\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "The answer is 1. The researcher published 2 papers that had at least 1 citation.\\n(Had we said that the answer was 2 then there is only 1 paper published that has 2 citations and that is less than the h-index)."
                    },
                    {
                        "username": "prakhar3062",
                        "content": "I tried to apply counting sort in non-increasing order but only one test case passes\\n "
                    },
                    {
                        "username": "Avirat06",
                        "content": "getting internal error on my submission for this question"
                    }
                ]
            },
            {
                "id": 1956621,
                "content": [
                    {
                        "username": "Vinayellulla",
                        "content": "what is meant by citations?\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A very similar question with https://leetcode.com/problems/h-index-ii/ .\\nBoth can be solved by sorting and binary search the best h index. (max number of \"good\" publications)"
                    },
                    {
                        "username": "lenhatduc30042003",
                        "content": " given citations = [1,2]. What will be the answer be?"
                    },
                    {
                        "username": "harishgokul",
                        "content": "i think 1 because each value has 1 citations."
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "Why would a binary search solution that searches for the max valid h-index not work for this question?"
                    },
                    {
                        "username": "bernikovich",
                        "content": "It works. I think it\\'s even better than sorting. However, counting has a better time complexity of $$O(n)$$ compared to $$O(n logn)$$."
                    },
                    {
                        "username": "LearnUnlearnRepeat",
                        "content": "how come the expected answer is 2 for the input [11,15].."
                    },
                    {
                        "username": "bernikovich",
                        "content": "Because [11, 15] indicates that the researcher has only 2 papers with 11 and 15 citations, respectively. By definition, the H-index cannot exceed the number of papers, which in this case is 2."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "This is solution is java: https://leetcode.com/problems/h-index/submissions/987689138"
                    },
                    {
                        "username": "Anantashayana",
                        "content": "For [100] why 1 and not 100?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You are returning the number of papers, not the number of citations."
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "[1,2,0] what would be the output?\nmy output is 0\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "The answer is 1. The researcher published 2 papers that had at least 1 citation.\\n(Had we said that the answer was 2 then there is only 1 paper published that has 2 citations and that is less than the h-index)."
                    },
                    {
                        "username": "prakhar3062",
                        "content": "I tried to apply counting sort in non-increasing order but only one test case passes\\n "
                    },
                    {
                        "username": "Avirat06",
                        "content": "getting internal error on my submission for this question"
                    }
                ]
            },
            {
                "id": 1950086,
                "content": [
                    {
                        "username": "Vinayellulla",
                        "content": "what is meant by citations?\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A very similar question with https://leetcode.com/problems/h-index-ii/ .\\nBoth can be solved by sorting and binary search the best h index. (max number of \"good\" publications)"
                    },
                    {
                        "username": "lenhatduc30042003",
                        "content": " given citations = [1,2]. What will be the answer be?"
                    },
                    {
                        "username": "harishgokul",
                        "content": "i think 1 because each value has 1 citations."
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "Why would a binary search solution that searches for the max valid h-index not work for this question?"
                    },
                    {
                        "username": "bernikovich",
                        "content": "It works. I think it\\'s even better than sorting. However, counting has a better time complexity of $$O(n)$$ compared to $$O(n logn)$$."
                    },
                    {
                        "username": "LearnUnlearnRepeat",
                        "content": "how come the expected answer is 2 for the input [11,15].."
                    },
                    {
                        "username": "bernikovich",
                        "content": "Because [11, 15] indicates that the researcher has only 2 papers with 11 and 15 citations, respectively. By definition, the H-index cannot exceed the number of papers, which in this case is 2."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "This is solution is java: https://leetcode.com/problems/h-index/submissions/987689138"
                    },
                    {
                        "username": "Anantashayana",
                        "content": "For [100] why 1 and not 100?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You are returning the number of papers, not the number of citations."
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "[1,2,0] what would be the output?\nmy output is 0\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "The answer is 1. The researcher published 2 papers that had at least 1 citation.\\n(Had we said that the answer was 2 then there is only 1 paper published that has 2 citations and that is less than the h-index)."
                    },
                    {
                        "username": "prakhar3062",
                        "content": "I tried to apply counting sort in non-increasing order but only one test case passes\\n "
                    },
                    {
                        "username": "Avirat06",
                        "content": "getting internal error on my submission for this question"
                    }
                ]
            },
            {
                "id": 1940189,
                "content": [
                    {
                        "username": "Vinayellulla",
                        "content": "what is meant by citations?\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A very similar question with https://leetcode.com/problems/h-index-ii/ .\\nBoth can be solved by sorting and binary search the best h index. (max number of \"good\" publications)"
                    },
                    {
                        "username": "lenhatduc30042003",
                        "content": " given citations = [1,2]. What will be the answer be?"
                    },
                    {
                        "username": "harishgokul",
                        "content": "i think 1 because each value has 1 citations."
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "Why would a binary search solution that searches for the max valid h-index not work for this question?"
                    },
                    {
                        "username": "bernikovich",
                        "content": "It works. I think it\\'s even better than sorting. However, counting has a better time complexity of $$O(n)$$ compared to $$O(n logn)$$."
                    },
                    {
                        "username": "LearnUnlearnRepeat",
                        "content": "how come the expected answer is 2 for the input [11,15].."
                    },
                    {
                        "username": "bernikovich",
                        "content": "Because [11, 15] indicates that the researcher has only 2 papers with 11 and 15 citations, respectively. By definition, the H-index cannot exceed the number of papers, which in this case is 2."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "This is solution is java: https://leetcode.com/problems/h-index/submissions/987689138"
                    },
                    {
                        "username": "Anantashayana",
                        "content": "For [100] why 1 and not 100?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You are returning the number of papers, not the number of citations."
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "[1,2,0] what would be the output?\nmy output is 0\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "The answer is 1. The researcher published 2 papers that had at least 1 citation.\\n(Had we said that the answer was 2 then there is only 1 paper published that has 2 citations and that is less than the h-index)."
                    },
                    {
                        "username": "prakhar3062",
                        "content": "I tried to apply counting sort in non-increasing order but only one test case passes\\n "
                    },
                    {
                        "username": "Avirat06",
                        "content": "getting internal error on my submission for this question"
                    }
                ]
            },
            {
                "id": 1886242,
                "content": [
                    {
                        "username": "Vinayellulla",
                        "content": "what is meant by citations?\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A very similar question with https://leetcode.com/problems/h-index-ii/ .\\nBoth can be solved by sorting and binary search the best h index. (max number of \"good\" publications)"
                    },
                    {
                        "username": "lenhatduc30042003",
                        "content": " given citations = [1,2]. What will be the answer be?"
                    },
                    {
                        "username": "harishgokul",
                        "content": "i think 1 because each value has 1 citations."
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "Why would a binary search solution that searches for the max valid h-index not work for this question?"
                    },
                    {
                        "username": "bernikovich",
                        "content": "It works. I think it\\'s even better than sorting. However, counting has a better time complexity of $$O(n)$$ compared to $$O(n logn)$$."
                    },
                    {
                        "username": "LearnUnlearnRepeat",
                        "content": "how come the expected answer is 2 for the input [11,15].."
                    },
                    {
                        "username": "bernikovich",
                        "content": "Because [11, 15] indicates that the researcher has only 2 papers with 11 and 15 citations, respectively. By definition, the H-index cannot exceed the number of papers, which in this case is 2."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "This is solution is java: https://leetcode.com/problems/h-index/submissions/987689138"
                    },
                    {
                        "username": "Anantashayana",
                        "content": "For [100] why 1 and not 100?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You are returning the number of papers, not the number of citations."
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "[1,2,0] what would be the output?\nmy output is 0\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "The answer is 1. The researcher published 2 papers that had at least 1 citation.\\n(Had we said that the answer was 2 then there is only 1 paper published that has 2 citations and that is less than the h-index)."
                    },
                    {
                        "username": "prakhar3062",
                        "content": "I tried to apply counting sort in non-increasing order but only one test case passes\\n "
                    },
                    {
                        "username": "Avirat06",
                        "content": "getting internal error on my submission for this question"
                    }
                ]
            }
        ]
    },
    {
        "title": "Longest Word in Dictionary",
        "question_content": "<p>Given an array of strings <code>words</code> representing an English Dictionary, return <em>the longest word in</em> <code>words</code> <em>that can be built one character at a time by other words in</em> <code>words</code>.</p>\n\n<p>If there is more than one possible answer, return the longest word with the smallest lexicographical order. If there is no answer, return the empty string.</p>\n\n<p>Note that the word should be built from left to right with each additional character being added to the end of a previous word.&nbsp;</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;w&quot;,&quot;wo&quot;,&quot;wor&quot;,&quot;worl&quot;,&quot;world&quot;]\n<strong>Output:</strong> &quot;world&quot;\n<strong>Explanation:</strong> The word &quot;world&quot; can be built one character at a time by &quot;w&quot;, &quot;wo&quot;, &quot;wor&quot;, and &quot;worl&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;a&quot;,&quot;banana&quot;,&quot;app&quot;,&quot;appl&quot;,&quot;ap&quot;,&quot;apply&quot;,&quot;apple&quot;]\n<strong>Output:</strong> &quot;apple&quot;\n<strong>Explanation:</strong> Both &quot;apply&quot; and &quot;apple&quot; can be built from other words in the dictionary. However, &quot;apple&quot; is lexicographically smaller than &quot;apply&quot;.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 30</code></li>\n\t<li><code>words[i]</code> consists of lowercase English letters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 109114,
                "title": "java-c-clean-code",
                "content": "1. Sort the words alphabetically, therefore shorter words always comes before longer words;\\n2. Along the sorted list, populate the words that can be built;\\n3. Any prefix of a word must comes before that  word.\\n\\n**Java**\\n```\\nclass Solution {\\n    public String longestWord(String[] words) {\\n        Arrays.sort(words);\\n        Set<String> built = new HashSet<String>();\\n        String res = \"\";\\n        for (String w : words) {\\n            if (w.length() == 1 || built.contains(w.substring(0, w.length() - 1))) {\\n                res = w.length() > res.length() ? w : res;\\n                built.add(w);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    string longestWord(vector<string>& words) {\\n        sort(words.begin(), words.end());\\n        unordered_set<string> built;\\n        string res;\\n        for (string w : words) {\\n            if (w.size() == 1 || built.count(w.substr(0, w.size() - 1))) {\\n                res = w.size() > res.size() ? w : res;\\n                built.insert(w);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String longestWord(String[] words) {\\n        Arrays.sort(words);\\n        Set<String> built = new HashSet<String>();\\n        String res = \"\";\\n        for (String w : words) {\\n            if (w.length() == 1 || built.contains(w.substring(0, w.length() - 1))) {\\n                res = w.length() > res.length() ? w : res;\\n                built.add(w);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    string longestWord(vector<string>& words) {\\n        sort(words.begin(), words.end());\\n        unordered_set<string> built;\\n        string res;\\n        for (string w : words) {\\n            if (w.size() == 1 || built.count(w.substr(0, w.size() - 1))) {\\n                res = w.size() > res.size() ? w : res;\\n                built.insert(w);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 113916,
                "title": "python-trie-bfs",
                "content": "```\\nclass TrieNode(object):\\n    def __init__(self):\\n        self.children=collections.defaultdict(TrieNode)\\n        self.isEnd=False\\n        self.word =''\\n        \\nclass Trie(object):\\n    def __init__(self):\\n        self.root=TrieNode()\\n        \\n    def insert(self, word):\\n        node=self.root\\n        for c in word:\\n            node =node.children[c]\\n        node.isEnd=True\\n        node.word=word\\n    \\n    def bfs(self):\\n        q=collections.deque([self.root])\\n        res=''\\n        while q:\\n            cur=q.popleft()\\n            for n in cur.children.values():\\n                if n.isEnd:\\n                    q.append(n)\\n                    if len(n.word)>len(res) or n.word<res:\\n                        res=n.word\\n        return res \\n    \\nclass Solution(object):\\n    def longestWord(self, words):\\n        trie = Trie()\\n        for w in words: trie.insert(w)\\n        return trie.bfs()\\n\\n    \\n```",
                "solutionTags": [],
                "code": "```\\nclass TrieNode(object):\\n    def __init__(self):\\n        self.children=collections.defaultdict(TrieNode)\\n        self.isEnd=False\\n        self.word =''\\n        \\nclass Trie(object):\\n    def __init__(self):\\n        self.root=TrieNode()\\n        \\n    def insert(self, word):\\n        node=self.root\\n        for c in word:\\n            node =node.children[c]\\n        node.isEnd=True\\n        node.word=word\\n    \\n    def bfs(self):\\n        q=collections.deque([self.root])\\n        res=''\\n        while q:\\n            cur=q.popleft()\\n            for n in cur.children.values():\\n                if n.isEnd:\\n                    q.append(n)\\n                    if len(n.word)>len(res) or n.word<res:\\n                        res=n.word\\n        return res \\n    \\nclass Solution(object):\\n    def longestWord(self, words):\\n        trie = Trie()\\n        for w in words: trie.insert(w)\\n        return trie.bfs()\\n\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 634793,
                "title": "java-the-easiest-to-understand-trie-solution-100-explanation",
                "content": "We will use `Trie`, also called `Prefix tree`, structure to solve the problem.  \\nIf you don\\'t know what the `Trie` is, then complete this problem first https://leetcode.com/problems/implement-trie-prefix-tree/\\n\\nFirst of all, let\\'s define our node of tree:\\n\\n\\tclass TreeNode {\\n\\t\\tTreeNode[] children = new TreeNode[26];\\n\\t\\tString word;\\n\\n\\t\\tTreeNode () {}\\n\\t}\\n\\nAs said in constraints, words contains lowercase letters only; That\\'s why we can simply use array `TreeNode[26]` to store node children. To compute the index we will use next trick - `index = character - \\'a\\'`.\\nWe need to, somehow, check is the node represents a word. So, let\\'s store in each `TreeNode` field `word`. If node is representing the word, then value of word will be in the field `word`, otherwise field will be empty.\\n\\nHow to insert a word into our `Trie`? - Using `current` as pointer of node. If `current` don\\'t have `character` in his children, just put new `TreeNode` to `current` children.\\nWe have to put word character by character into Tree. There are 2 cases:\\n- 1) We already have the character -  just set `current` to `current.children[c - \\'a\\']`\\n- 2) We don\\'t have the character yet - put it into `current.children` and then set `current` to `current.children[c - \\'a\\']`\\n\\nAt the end of inserting operation we need to take node, represanting the last character of a word, and set it `word` field to whole word.\\n\\nThe code below insert word into our `Trie`:\\n\\n\\tprivate void insert(String word) {\\n\\t\\tTreeNode current = root;\\n\\t\\tfor (char c : word.toCharArray()) {\\n\\t\\t\\tif (current.children[c - \\'a\\'] == null)\\n\\t\\t\\t\\tcurrent.children[c - \\'a\\'] = new TreeNode();\\n\\t\\t\\tcurrent = current.children[c - \\'a\\'];\\n\\t\\t}\\n\\t\\tcurrent.word = word;\\n\\t}\\n\\n\\nAs we defined our `TreeNode` and `insert` function, let\\'s fill it by all words, we have in input:\\n\\n\\tfor (String w : words)\\n\\t\\t\\t\\tinsert(w);\\n\\nNow we have all words in our `Trie` and just have to iterate over the whole tree and find the longest word.\\nWe will use `Depth-First Search` to iterate over it.\\nAs said in the problem defenition, we should build each word `character by character`. It means, if we have character, which isn\\'t word - we should stop `DFS` for this branch of our `Trie`.\\nIf current `TreeNode` have word - then check is it the longest word, we are looking for.\\n\\nNext code describes `DFS`, looking for the longest word:\\n\\n\\tprivate void dfs(TreeNode node) {\\n\\t\\tif (node == null)\\n\\t\\t\\treturn;\\n\\n\\t\\tif (node.word != null) {\\n\\t\\t\\tif (node.word.length() > result.length())\\n\\t\\t\\t\\tresult = node.word;\\n\\t\\t\\telse if (node.word.length() == result.length() && node.word.compareTo(result) < 0)\\n\\t\\t\\t\\tresult = node.word;\\n\\t\\t}\\n\\n\\t\\tfor (TreeNode child : node.children)\\n\\t\\t\\tif (child != null && child.word != null)\\n\\t\\t\\t\\tdfs(child);\\n\\t}\\n\\nEnjoy ;)\\nThe whole solution:\\n\\n\\tclass Solution {\\n\\t\\tprivate TreeNode root;\\n\\t\\tprivate String result = \"\";\\n\\n\\t\\tpublic String longestWord(String[] words) {\\n\\t\\t\\troot = new TreeNode();\\n\\n\\t\\t\\tfor (String w : words)\\n\\t\\t\\t\\tinsert(w);\\n\\n\\t\\t\\tdfs(root);\\n\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\n\\t\\tprivate void dfs(TreeNode node) {\\n\\t\\t\\tif (node == null)\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tif (node.word != null) {\\n\\t\\t\\t\\tif (node.word.length() > result.length())\\n\\t\\t\\t\\t\\tresult = node.word;\\n\\t\\t\\t\\telse if (node.word.length() == result.length() && node.word.compareTo(result) < 0)\\n\\t\\t\\t\\t\\tresult = node.word;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (TreeNode child : node.children)\\n\\t\\t\\t\\tif (child != null && child.word != null)\\n\\t\\t\\t\\t\\tdfs(child);\\n\\t\\t}\\n\\n\\t\\tprivate void insert(String word) {\\n\\t\\t\\tTreeNode current = root;\\n\\t\\t\\tfor (char c : word.toCharArray()) {\\n\\t\\t\\t\\tif (current.children[c - \\'a\\'] == null)\\n\\t\\t\\t\\t\\tcurrent.children[c - \\'a\\'] = new TreeNode();\\n\\t\\t\\t\\tcurrent = current.children[c - \\'a\\'];\\n\\t\\t\\t}\\n\\t\\t\\tcurrent.word = word;\\n\\t\\t}\\n\\n\\t}\\n\\n\\tclass TreeNode {\\n\\t\\tTreeNode[] children = new TreeNode[26];\\n\\t\\tString word;\\n\\n\\t\\tTreeNode () {}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "class Solution {\\n\\t\\tprivate TreeNode root;\\n\\t\\tprivate String result = \"\";\\n\\n\\t\\tpublic String longestWord(String[] words) {\\n\\t\\t\\troot = new TreeNode();\\n\\n\\t\\t\\tfor (String w : words)\\n\\t\\t\\t\\tinsert(w);\\n\\n\\t\\t\\tdfs(root);\\n\\n\\t\\t\\treturn result;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 109113,
                "title": "java-solution-with-trie-bfs",
                "content": "The idea is simple. First, we construct a trie for the dictionary. Then we traverse the whole trie to get the longest word.\\nWe could choose DFS or BFS to achieve the trie traversal. Here, I leverage the property of BFS that it would get a layer of a tree from top to down at one time. Therefore, every time we get a new candidate word, we could replace the old one. Also, I scan the children of a trie node from last to first because we want the word with the smallest lexicographical order.\\n```\\nclass Solution {\\n    class TrieNode {\\n        TrieNode[] children;\\n        boolean isWord;\\n        String word;\\n        \\n        public TrieNode() {\\n            children = new TrieNode[26];\\n        }\\n    }\\n    \\n    class Trie {\\n        private TrieNode root;\\n        \\n        public Trie() {\\n            root = new TrieNode();\\n        }\\n        \\n        public void insert(String word) {\\n            TrieNode node = root;\\n            for (int i = 0; i < word.length(); i++) {\\n                int idx = word.charAt(i) - 'a';\\n                if (node.children[idx] == null) {\\n                    node.children[idx] = new TrieNode();\\n                }\\n                node = node.children[idx];\\n            }\\n            node.isWord = true;\\n            node.word = word;\\n        }\\n        \\n        public String findLongestWord() {\\n            String result = null;\\n            Queue<TrieNode> queue = new LinkedList<>();\\n            queue.offer(root);\\n            while (!queue.isEmpty()) {\\n                int size = queue.size();\\n                for (int i = 0; i < size; i++) {\\n                    TrieNode node = queue.poll();\\n                    for (int j = 25; j >= 0; j--) {\\n                        if (node.children[j] != null && node.children[j].isWord) {\\n                            result = node.children[j].word;\\n                            queue.offer(node.children[j]);\\n                        }\\n                    }\\n                }\\n            }\\n            return result;\\n        }\\n    }\\n    \\n    public String longestWord(String[] words) {\\n        Trie trie = new Trie();\\n        for (String word : words) {\\n            trie.insert(word);\\n        }\\n        \\n        return trie.findLongestWord();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class TrieNode {\\n        TrieNode[] children;\\n        boolean isWord;\\n        String word;\\n        \\n        public TrieNode() {\\n            children = new TrieNode[26];\\n        }\\n    }\\n    \\n    class Trie {\\n        private TrieNode root;\\n        \\n        public Trie() {\\n            root = new TrieNode();\\n        }\\n        \\n        public void insert(String word) {\\n            TrieNode node = root;\\n            for (int i = 0; i < word.length(); i++) {\\n                int idx = word.charAt(i) - 'a';\\n                if (node.children[idx] == null) {\\n                    node.children[idx] = new TrieNode();\\n                }\\n                node = node.children[idx];\\n            }\\n            node.isWord = true;\\n            node.word = word;\\n        }\\n        \\n        public String findLongestWord() {\\n            String result = null;\\n            Queue<TrieNode> queue = new LinkedList<>();\\n            queue.offer(root);\\n            while (!queue.isEmpty()) {\\n                int size = queue.size();\\n                for (int i = 0; i < size; i++) {\\n                    TrieNode node = queue.poll();\\n                    for (int j = 25; j >= 0; j--) {\\n                        if (node.children[j] != null && node.children[j].isWord) {\\n                            result = node.children[j].word;\\n                            queue.offer(node.children[j]);\\n                        }\\n                    }\\n                }\\n            }\\n            return result;\\n        }\\n    }\\n    \\n    public String longestWord(String[] words) {\\n        Trie trie = new Trie();\\n        for (String word : words) {\\n            trie.insert(word);\\n        }\\n        \\n        return trie.findLongestWord();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 112720,
                "title": "java-16ms-99-20180108-trie-dfs-clean-easy-explained-and-illustrated",
                "content": "Build a trie in the normal way, then do a dfs to find the longest **continuous** downward path from the root. This is not a particularly hard question in the context of trie, the point of this solution is to present a generic way of trie building and inserting that can be easily adapted to similar questions. Code:\\n\\n```java\\nclass Solution {\\n    public String longestWord(String[] words) {\\n        TrieNode root = new TrieNode ();\\n        root.word = \"-\";\\n        for (String word : words)\\n            root.insert (word);\\n        return dfs (root, \"\");\\n    }\\n\\n    String dfs (TrieNode node, String accum) {\\n        if (node == null || node.word.length () == 0)\\n            return accum;\\n        String res = \"\";\\n        if (!node.word.equals (\"-\"))\\n            accum = node.word;\\n        for (TrieNode child : node.links) {\\n            String curRes = dfs (child, accum);\\n            if (curRes.length () > res.length () || (curRes.length () == res.length () && curRes.compareTo (res) < 0))\\n                res = curRes;\\n        }\\n        return res;\\n    }\\n\\n    /* Hand write this class every time you need to so you can remember well */\\n    static class TrieNode {\\n        String word = \"\";\\n        TrieNode[] links = new TrieNode[26];\\n\\n        void insert (String s) {\\n            char[] chs = s.toCharArray ();\\n            TrieNode curNode = this;\\n            for (int i = 0; i < chs.length; i++) {\\n                int index = chs[i] - 'a';\\n                if (curNode.links[index] == null)\\n                    curNode.links[index] = new TrieNode ();\\n                curNode = curNode.links[index];\\n            }\\n            curNode.word = s;\\n        }\\n    }\\n}\\n```\\n\\nA typical trie for the list of `\"ab\", \"ac\"`:\\n<img src=\"http://i63.tinypic.com/2jbtwjl.png\" width = \"300\"/>",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public String longestWord(String[] words) {\\n        TrieNode root = new TrieNode ();\\n        root.word = \"-\";\\n        for (String word : words)\\n            root.insert (word);\\n        return dfs (root, \"\");\\n    }\\n\\n    String dfs (TrieNode node, String accum) {\\n        if (node == null || node.word.length () == 0)\\n            return accum;\\n        String res = \"\";\\n        if (!node.word.equals (\"-\"))\\n            accum = node.word;\\n        for (TrieNode child : node.links) {\\n            String curRes = dfs (child, accum);\\n            if (curRes.length () > res.length () || (curRes.length () == res.length () && curRes.compareTo (res) < 0))\\n                res = curRes;\\n        }\\n        return res;\\n    }\\n\\n    /* Hand write this class every time you need to so you can remember well */\\n    static class TrieNode {\\n        String word = \"\";\\n        TrieNode[] links = new TrieNode[26];\\n\\n        void insert (String s) {\\n            char[] chs = s.toCharArray ();\\n            TrieNode curNode = this;\\n            for (int i = 0; i < chs.length; i++) {\\n                int index = chs[i] - 'a';\\n                if (curNode.links[index] == null)\\n                    curNode.links[index] = new TrieNode ();\\n                curNode = curNode.links[index];\\n            }\\n            curNode.word = s;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 137172,
                "title": "python-5-line-straightforward-solution",
                "content": "```\\nclass Solution(object):\\n    def longestWord(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: str\\n        \"\"\"\\n        valid = set([\"\"])\\n       \\n        for word in sorted(words, key=lambda x: len(x)):\\n           if word[:-1] in valid:\\n                valid.add(word)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n        return max(sorted(valid), key=lambda x: len(x))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def longestWord(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: str\\n        \"\"\"\\n        valid = set([\"\"])\\n       \\n        for word in sorted(words, key=lambda x: len(x)):\\n           if word[:-1] in valid:\\n                valid.add(word)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n        return max(sorted(valid), key=lambda x: len(x))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1412660,
                "title": "python-3-solutions-bfs-sorting-trienode-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: BFS**\\n- Same idea with [127. Word Ladder](https://leetcode.com/problems/word-ladder/)\\n```python\\nclass Solution:\\n    def longestWord(self, words: List[str]) -> str:\\n        wordSet = set(words)\\n        q = deque([\"\"])\\n        ans = \"\"\\n        while q:\\n            word = q.popleft()\\n            if len(word) > len(ans):\\n                ans = word\\n                \\n            for c in ascii_lowercase:\\n                newWord = word + c\\n                if newWord in wordSet:\\n                    q.append(newWord)\\n                    wordSet.remove(newWord)\\n                    \\n        return ans\\n```\\n**Complexity**\\n- Time: `O(27N * M)`, where `N <= 1000` is length of `words`, `M <= 30` is length of each word.\\n   Explain: BFS takes `O(E+V)`, where `V` is number of vertices = number of words in the dictionary, `E = 26V` is number of edges (because each vertice there is up to 26 neighbors). Each time, the cost to build new string is `O(M)`.\\n   So total time complexity is `O(27N * M)`.\\n- Space: `O(N * M)`\\n\\n---\\n\\n**\\u2714\\uFE0F Solution 2: Sorting**\\n- Sort the `words` alphabetically, therefore shorter words always comes before longer words.\\n- Along the sorted list, populate the words that can be built.\\n- Any prefix of a word must comes before that word.\\nCredit the idea from @alexander under this post [Java/C++ Clean Code](https://leetcode.com/problems/longest-word-in-dictionary/discuss/109114)\\n\\n```python\\nclass Solution:\\n    def longestWord(self, words: List[str]) -> str:\\n        words.sort()\\n        seen = set([\"\"])\\n        ans = \"\"\\n        for word in words:\\n            if word[:-1] in seen:\\n                seen.add(word)\\n                if len(word) > len(ans):\\n                    ans = word\\n        return ans\\n```\\n**Complexity**\\n- Time: `O(NlogN * M)`, where `N <= 1000` is length of `words`, `M <= 30` is length of each word.\\n- Space: `O(N * M)`\\n\\n---\\n\\n**\\u2714\\uFE0F Solution 3: Trie Node**\\n```python\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = defaultdict(TrieNode)\\n        self.word = None\\n    def addWord(self, word):\\n        cur = self\\n        for c in word:\\n            cur = cur.children[c]\\n        cur.word = word\\n\\nclass Solution:\\n    def longestWord(self, words: List[str]) -> str:\\n        trieRoot = TrieNode()\\n        for word in words:\\n            trieRoot.addWord(word)\\n            \\n        ans = \"\"\\n        bfs = deque([trieRoot])\\n        while bfs:\\n            cur = bfs.popleft()\\n            for child in cur.children.values():\\n                if child.word != None:\\n                    if len(child.word) > len(ans) or len(child.word) == len(ans) and child.word < ans:\\n                        ans = child.word\\n                    bfs.append(child)\\n        return ans\\n```\\n**Complexity**\\n- Time: `O(N * M)`, where `N <= 1000` is length of `words`, `M <= 30` is length of each word.\\n- Space: `O(N * M)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def longestWord(self, words: List[str]) -> str:\\n        wordSet = set(words)\\n        q = deque([\"\"])\\n        ans = \"\"\\n        while q:\\n            word = q.popleft()\\n            if len(word) > len(ans):\\n                ans = word\\n                \\n            for c in ascii_lowercase:\\n                newWord = word + c\\n                if newWord in wordSet:\\n                    q.append(newWord)\\n                    wordSet.remove(newWord)\\n                    \\n        return ans\\n```\n```python\\nclass Solution:\\n    def longestWord(self, words: List[str]) -> str:\\n        words.sort()\\n        seen = set([\"\"])\\n        ans = \"\"\\n        for word in words:\\n            if word[:-1] in seen:\\n                seen.add(word)\\n                if len(word) > len(ans):\\n                    ans = word\\n        return ans\\n```\n```python\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = defaultdict(TrieNode)\\n        self.word = None\\n    def addWord(self, word):\\n        cur = self\\n        for c in word:\\n            cur = cur.children[c]\\n        cur.word = word\\n\\nclass Solution:\\n    def longestWord(self, words: List[str]) -> str:\\n        trieRoot = TrieNode()\\n        for word in words:\\n            trieRoot.addWord(word)\\n            \\n        ans = \"\"\\n        bfs = deque([trieRoot])\\n        while bfs:\\n            cur = bfs.popleft()\\n            for child in cur.children.values():\\n                if child.word != None:\\n                    if len(child.word) > len(ans) or len(child.word) == len(ans) and child.word < ans:\\n                        ans = child.word\\n                    bfs.append(child)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 203730,
                "title": "python-trie-dfs-no-extensive-loops-or-complicated-trienode",
                "content": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.end = False\\n        \\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n    def insert(self, word):\\n        cur = self.root\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n        cur.end = True\\n    \\n    def longest_word(self):\\n        def helper(node, partial_res):\\n            res = partial_res\\n            for c, child in node.children.items():\\n                if child.end:\\n                    pot = helper(child, partial_res + c)\\n                    if len(pot) > len(res):\\n                        res = pot\\n                    elif len(pot) == len(res) and pot < res:\\n                        res = pot\\n            return res\\n        return helper(self.root, \\'\\')\\n\\nclass Solution:\\n    def longestWord(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: str\\n        \"\"\"\\n        T = Trie()\\n        for word in words:\\n            T.insert(word)\\n        return T.longest_word()\\n```",
                "solutionTags": [],
                "code": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.end = False\\n        \\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n    def insert(self, word):\\n        cur = self.root\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n        cur.end = True\\n    \\n    def longest_word(self):\\n        def helper(node, partial_res):\\n            res = partial_res\\n            for c, child in node.children.items():\\n                if child.end:\\n                    pot = helper(child, partial_res + c)\\n                    if len(pot) > len(res):\\n                        res = pot\\n                    elif len(pot) == len(res) and pot < res:\\n                        res = pot\\n            return res\\n        return helper(self.root, \\'\\')\\n\\nclass Solution:\\n    def longestWord(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: str\\n        \"\"\"\\n        T = Trie()\\n        for word in words:\\n            T.insert(word)\\n        return T.longest_word()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 109143,
                "title": "1-liner",
                "content": "I build triples `(missingPrefixes, negatedLength, word)` so I can just take the smallest such triple and extract its word. I add the empty string to the words so it's there already and beats any word with missing prefixes. And `accumulate` supports strings, giving me all non-empty prefixes (e.g., for \"test\" it produces \"t\", \"te\", \"tes\" and \"test\").\\n\\n    def longestWord(self, words):\\n        return min((set(itertools.accumulate(w)) - set(words), -len(w), w)\\n                   for w in words + [''])[2]\\n\\nDense version:\\n\\n    def longestWord(self, W):\\n        return min((set(itertools.accumulate(w))-set(W),-len(w),w)for w in W+[''])[2]",
                "solutionTags": [],
                "code": "I build triples `(missingPrefixes, negatedLength, word)` so I can just take the smallest such triple and extract its word. I add the empty string to the words so it's there already and beats any word with missing prefixes. And `accumulate` supports strings, giving me all non-empty prefixes (e.g., for \"test\" it produces \"t\", \"te\", \"tes\" and \"test\").\\n\\n    def longestWord(self, words):\\n        return min((set(itertools.accumulate(w)) - set(words), -len(w), w)\\n                   for w in words + [''])[2]\\n\\nDense version:\\n\\n    def longestWord(self, W):\\n        return min((set(itertools.accumulate(w))-set(W),-len(w),w)for w in W+[''])[2]",
                "codeTag": "Python3"
            },
            {
                "id": 795469,
                "title": "c-trie-solution-with-explanation",
                "content": "When using Trie I personally don\\'t understand why the question has been labelled as easy.\\nAnyways upvote if you like the explanation.\\n```\\n class Trie{\\n        public:\\n\\t\\t//Initializing Trie\\n        Trie* child[26]={NULL};\\n        bool end;\\n    };\\nclass Solution {\\npublic:\\n\\t//Stores the final answer string\\n    string ans=\"\";\\n\\t\\n\\t//Inserts the ith word int the Trie\\n    void insert(string w, Trie* root){\\n\\t\\n\\t\\t//Stores the current word only if it\\'s prefix is present\\n        string s=\"\";\\n        int n=w.length();\\n        Trie* cur=root;\\n\\t\\t\\n        for(int i=0;i<n;i++){\\n\\t\\t\\tif(i==n-1)s+=w[i]; //stores the first char or the last char in the temporary string s\\n            int k=w[i]-\\'a\\';\\n            if(cur->child[k]==NULL){\\n                if(i!=n-1)break; //if the char is not present and it isn\\'t the last char of the word\\n\\t\\t\\t\\t//then no need to insert it. EX: {\"a\",\"ad\",\"adpf\"} we won\\'t be inserting adpf \\n\\t\\t\\t\\t//as there is no \"adp\"\\n                cur->child[k]=new Trie(); //creates a new child trie\\n            }\\n            else s+=w[i]; //if prefix is present we add it in the string s\\n            cur=cur->child[k];\\n        }\\n\\t\\t\\n        if(s.length()>ans.length())ans=s; //if cur string s length > ans then update ans\\n        else if(s.length()==ans.length() && s<ans)ans=s; //if both lengths are same \\n\\t\\t//check for lexigraphical order and update accordingly\\n        cur->end=true;\\n    }\\n   \\n    string longestWord(vector<string>& words) {\\n        int n=words.size();\\n        sort(begin(words),end(words));\\n        Trie *root =new Trie();\\n        for(int i=0;i<n;i++){\\n\\t\\t\\t//if consecutive words are same no need to call insert function for duplicate words\\n            if(i+1<n && words[i]==words[i+1])continue;\\n            insert(words[i],root);\\n        }\\n\\t\\t//returns the globally declared ans string\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Trie"
                ],
                "code": "```\\n class Trie{\\n        public:\\n\\t\\t//Initializing Trie\\n        Trie* child[26]={NULL};\\n        bool end;\\n    };\\nclass Solution {\\npublic:\\n\\t//Stores the final answer string\\n    string ans=\"\";\\n\\t\\n\\t//Inserts the ith word int the Trie\\n    void insert(string w, Trie* root){\\n\\t\\n\\t\\t//Stores the current word only if it\\'s prefix is present\\n        string s=\"\";\\n        int n=w.length();\\n        Trie* cur=root;\\n\\t\\t\\n        for(int i=0;i<n;i++){\\n\\t\\t\\tif(i==n-1)s+=w[i]; //stores the first char or the last char in the temporary string s\\n            int k=w[i]-\\'a\\';\\n            if(cur->child[k]==NULL){\\n                if(i!=n-1)break; //if the char is not present and it isn\\'t the last char of the word\\n\\t\\t\\t\\t//then no need to insert it. EX: {\"a\",\"ad\",\"adpf\"} we won\\'t be inserting adpf \\n\\t\\t\\t\\t//as there is no \"adp\"\\n                cur->child[k]=new Trie(); //creates a new child trie\\n            }\\n            else s+=w[i]; //if prefix is present we add it in the string s\\n            cur=cur->child[k];\\n        }\\n\\t\\t\\n        if(s.length()>ans.length())ans=s; //if cur string s length > ans then update ans\\n        else if(s.length()==ans.length() && s<ans)ans=s; //if both lengths are same \\n\\t\\t//check for lexigraphical order and update accordingly\\n        cur->end=true;\\n    }\\n   \\n    string longestWord(vector<string>& words) {\\n        int n=words.size();\\n        sort(begin(words),end(words));\\n        Trie *root =new Trie();\\n        for(int i=0;i<n;i++){\\n\\t\\t\\t//if consecutive words are same no need to call insert function for duplicate words\\n            if(i+1<n && words[i]==words[i+1])continue;\\n            insert(words[i],root);\\n        }\\n\\t\\t//returns the globally declared ans string\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 367203,
                "title": "easy-peasy-python-solution-using-sorting-and-set",
                "content": "\\tdef longestWord(self, words: List[str]) -> str:\\n        #sort the words, then keep in the set and check for nextWord[:-1] in the set\\n        words.sort()\\n        st, res = set(), \"\" #res == result\\n        st.add(\"\")\\n        for word in words:\\n            if word[:-1] in st:\\n                if len(word) > len(res):\\n                    res = word\\n                st.add(word)\\n        \\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "\\tdef longestWord(self, words: List[str]) -> str:\\n        #sort the words, then keep in the set and check for nextWord[:-1] in the set\\n        words.sort()\\n        st, res = set(), \"\" #res == result\\n        st.add(\"\")\\n        for word in words:\\n            if word[:-1] in st:\\n                if len(word) > len(res):\\n                    res = word\\n                st.add(word)\\n        \\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 109140,
                "title": "simple-short-7-lines-python-solution-using-sorting-and-set",
                "content": "The idea is to first sort the words, and once sorted, add each word to the resultset, if the prefix of the word word[:-1] is there in the sortedset. \\n\\nBy commutative property, if the prefix is there in the resultset, then that implies all the prefixes of length 1, 2, 3 .. are also there in the resultset, due to sorted data.\\n\\nAlso maintaining a global res_word and updating it every time we add a word to the resultset, makes it easy to find the final result.\\n\\n```\\n    def longestWord(self, words):\\n        words, resword, res = sorted(words), '', set()\\n        for word in words:\\n            if len(word) == 1 or word[:-1] in res:\\n                res.add(word)\\n                resword = word if resword == '' else word if len(word) > len(resword) else resword\\n        return resword\\n```",
                "solutionTags": [],
                "code": "```\\n    def longestWord(self, words):\\n        words, resword, res = sorted(words), '', set()\\n        for word in words:\\n            if len(word) == 1 or word[:-1] in res:\\n                res.add(word)\\n                resword = word if resword == '' else word if len(word) > len(resword) else resword\\n        return resword\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 434396,
                "title": "fast-short-intuitive-javascript-solution-using-sets",
                "content": "Here is a solution that leverages a Set which only contains a word if all the letters in that word, minus the last, are already present in the set, as words.   Faster than ~86% of submissions, as per my machine.\\n\\nNote: it uses the built in sort function as well as the builtin string.slice() functions. you can also use str.substr(0, str.length-1) , instead of slice.\\n\\n```JavaScript\\n/**\\n * @param {string[]} words\\n * @return {string}\\n */\\nvar longestWord = function(words) {\\n  words.sort();\\n  let set = new Set();\\n  let res = \\'\\';\\n\\n  for (let word of words) {\\n    if (word.length === 1 || set.has(word.slice(0, -1))) {\\n      set.add(word);\\n      if (word.length > res.length) {\\n        res = word;\\n      }\\n    }\\n  }\\n  return res;\\n};\\n\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```JavaScript\\n/**\\n * @param {string[]} words\\n * @return {string}\\n */\\nvar longestWord = function(words) {\\n  words.sort();\\n  let set = new Set();\\n  let res = \\'\\';\\n\\n  for (let word of words) {\\n    if (word.length === 1 || set.has(word.slice(0, -1))) {\\n      set.add(word);\\n      if (word.length > res.length) {\\n        res = word;\\n      }\\n    }\\n  }\\n  return res;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 659686,
                "title": "c-trie-implementation-prefix-tree-readable-understandable",
                "content": "```\\nclass TrieNode{\\npublic:\\n    unordered_map<char, TrieNode*> children;\\n    bool isWord = false;\\n    char val;\\n    \\n    TrieNode(){}\\n    \\n    TrieNode(char v){ this->val = v; }\\n};\\n\\nclass Trie{\\nprivate:\\n    TrieNode* root;\\npublic:\\n    Trie(){\\n        root = new TrieNode();\\n    }\\n    \\n    void insert(string word){\\n        TrieNode* temp = root;\\n        \\n        for(char ch : word){\\n            if(temp->children.find(ch) == temp->children.end()){\\n                temp->children[ch] = new TrieNode(ch);\\n            }\\n            temp = temp->children[ch];\\n        }\\n        \\n        temp->isWord = true;\\n    }\\n    \\n    bool isOrdered(string word){\\n        TrieNode* temp = root;\\n        \\n        for(char ch : word){\\n            if(temp == root || temp->isWord){\\n                temp = temp->children[ch];\\n                continue;\\n            }\\n            return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    string longestWord(vector<string>& words) {\\n        Trie* search = new Trie();\\n        string curr (\"\");\\n        int size = 0;\\n        \\n        for(string str : words){\\n            search->insert(str);\\n        }\\n        \\n        for(string str : words){\\n            if(search->isOrdered(str) && size <= str.size()){\\n                curr = (size == str.size()) ? min(curr, str) : str;\\n                size = str.size();\\n            }\\n        }\\n        \\n        return curr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode{\\npublic:\\n    unordered_map<char, TrieNode*> children;\\n    bool isWord = false;\\n    char val;\\n    \\n    TrieNode(){}\\n    \\n    TrieNode(char v){ this->val = v; }\\n};\\n\\nclass Trie{\\nprivate:\\n    TrieNode* root;\\npublic:\\n    Trie(){\\n        root = new TrieNode();\\n    }\\n    \\n    void insert(string word){\\n        TrieNode* temp = root;\\n        \\n        for(char ch : word){\\n            if(temp->children.find(ch) == temp->children.end()){\\n                temp->children[ch] = new TrieNode(ch);\\n            }\\n            temp = temp->children[ch];\\n        }\\n        \\n        temp->isWord = true;\\n    }\\n    \\n    bool isOrdered(string word){\\n        TrieNode* temp = root;\\n        \\n        for(char ch : word){\\n            if(temp == root || temp->isWord){\\n                temp = temp->children[ch];\\n                continue;\\n            }\\n            return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    string longestWord(vector<string>& words) {\\n        Trie* search = new Trie();\\n        string curr (\"\");\\n        int size = 0;\\n        \\n        for(string str : words){\\n            search->insert(str);\\n        }\\n        \\n        for(string str : words){\\n            if(search->isOrdered(str) && size <= str.size()){\\n                curr = (size == str.size()) ? min(curr, str) : str;\\n                size = str.size();\\n            }\\n        }\\n        \\n        return curr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 171726,
                "title": "java-trie-without-dfs-bfs",
                "content": "Lots of solutions build the Trie and use DFS/BFS to find the deepest node.\\nBut actually, we can just get the longest word while building the Trie.\\n\\n**How to solve without DFS/BFS?**\\nThe idea is using a variable `maxString` to store the longest word.\\nIf it\\'s the last character, we compare the word length with `maxString` and update  `maxString` if needed.\\nAt the end, we can just return the `maxString`.\\n\\n**What if two words length are the same?**\\nWe sort the words first so it gurantees that we meet the string by lexicographical order.\\nTherefore, the first word to be updated as `maxStrinig` is the lexicographically smallest word. No need to modify our algorithm.\\ne.g. [\"a\",  \"ap\", \"app\", \"appl\", \"apple\", \"apply\"]\\nWhile building the Trie: `\"a\"->\"p\"->\"p\"->\"l\"->\"e\"`\\nHere `maxString` is updated to \"apple\"\\nAnd while inserting \"apply\": `\"a\"->\"p\"->\"p\"->\"l\"->\"y\"`, here `maxString` will not be updated\\n                                                                          \\n**Special operation for this problem:**\\nWords are sorted. We are inserting a `word` into Trie, and we are now traversing to `word[i]` in the Trie and begin to build for `word[i+1]`, if `word[i]` is not the last character (`i < word.length() - 1`) and the Trie node  `word[i+1]` doesn\\'t already exist. This situation means we cannot build for `word`\\ne.g. words: [\"w\", \"wo\", \"wor\", \"world\"] \\nAfter inserting \"w\", \"wo\" and \"wor\"\\nWhen inserting \"world\", we traverse the Trie: `\"w\" -> \"o\" -> \"r\"` and here normally we are going to insert `\"l\"` for \"world\", but not for this problem.\\nSince there\\'s no `\"l\"` node for `\"r\"`, it means that we cannot build \"world\" because we lack of the word `\"worl\"`. \"world\" is defintely not the answer, so we can just stop insertion.\\n\\n```\\nclass Solution {\\n    public String longestWord(String[] words) {\\n        if (words == null || words.length == 0)\\n            return \"\";\\n        Trie head = new Trie();\\n        Arrays.sort(words);\\n        for (String word : words)\\n            head.insert(word);\\n        return head.maxString;\\n    }\\n    public class Trie {\\n        public String maxString = \"\";\\n        public Trie[] children = new Trie[26];\\n        public void insert(String s) {\\n            Trie cur = this;\\n            char[] chs = s.toCharArray();\\n            for (int i = 0; i < chs.length; i++) {\\n                int idx = chs[i] - \\'a\\';\\n                if (cur.children[idx] != null) {\\n                    cur = cur.children[idx];\\n                } else {\\n                    if (i < s.length() - 1) //special operation (refer to explaination above)\\n                        return;\\n                    cur.children[idx] = new Trie();\\n                    cur = cur.children[idx];\\n                    if (s.length() > maxString.length())\\n                        maxString = s;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String longestWord(String[] words) {\\n        if (words == null || words.length == 0)\\n            return \"\";\\n        Trie head = new Trie();\\n        Arrays.sort(words);\\n        for (String word : words)\\n            head.insert(word);\\n        return head.maxString;\\n    }\\n    public class Trie {\\n        public String maxString = \"\";\\n        public Trie[] children = new Trie[26];\\n        public void insert(String s) {\\n            Trie cur = this;\\n            char[] chs = s.toCharArray();\\n            for (int i = 0; i < chs.length; i++) {\\n                int idx = chs[i] - \\'a\\';\\n                if (cur.children[idx] != null) {\\n                    cur = cur.children[idx];\\n                } else {\\n                    if (i < s.length() - 1) //special operation (refer to explaination above)\\n                        return;\\n                    cur.children[idx] = new Trie();\\n                    cur = cur.children[idx];\\n                    if (s.length() > maxString.length())\\n                        maxString = s;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1941155,
                "title": "python-trie-solution-explained",
                "content": "```\\nclass TrieNode(object):\\n    def __init__(self):\\n        self.children = {}\\n        self.end = False\\n\\nclass Solution:\\n    def longestWord(self, words: List[str]) -> str:\\n        root = TrieNode()\\n\\n        # populate all the elements in the trie\\n        # word by word, no need for sorting here\\n        for word in words:\\n            cur = root\\n            for letter in word:\\n                if letter not in cur.children:\\n                    cur.children[letter] = TrieNode()\\n                cur = cur.children[letter]\\n            cur.end = True\\n            \\n        res = \\'\\'\\n        \\n        # iterate over all the words\\n        # in our words array\\n        for word in words:\\n            # if the length of the word\\n            # isn\\'t > our res, there\\'s no\\n            # point in exploring further\\n            # since we want the longest word\\n            if len(word) < len(res): continue\\n            \\n            # start a temp cur var\\n            # init at root to iterate\\n            # trie for every word\\n            cur = root\\n            \\n            # for every letter in the current\\n            # word, traverse the trie and see\\n            # that for every letter in this\\n            # word, there\\'s a node in the trie\\n            # which has end = True (i.e. a word \\n            # on its own, if not just break out)\\n            for letter in word:\\n                cur = cur.children[letter]\\n                if not cur.end: break\\n            \\n            # proceed only if you didn\\'t break\\n            # out of the previous loop (cur.end == True)\\n            # and then check if the cur word is longer\\n            # than the cur res, or if they are equal in length\\n            # use the lexicographically smaller one (word < res)\\n            if cur.end and (len(word) > len(res) or (len(word) == len(res) and word < res)):\\n                res = word        \\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode(object):\\n    def __init__(self):\\n        self.children = {}\\n        self.end = False\\n\\nclass Solution:\\n    def longestWord(self, words: List[str]) -> str:\\n        root = TrieNode()\\n\\n        # populate all the elements in the trie\\n        # word by word, no need for sorting here\\n        for word in words:\\n            cur = root\\n            for letter in word:\\n                if letter not in cur.children:\\n                    cur.children[letter] = TrieNode()\\n                cur = cur.children[letter]\\n            cur.end = True\\n            \\n        res = \\'\\'\\n        \\n        # iterate over all the words\\n        # in our words array\\n        for word in words:\\n            # if the length of the word\\n            # isn\\'t > our res, there\\'s no\\n            # point in exploring further\\n            # since we want the longest word\\n            if len(word) < len(res): continue\\n            \\n            # start a temp cur var\\n            # init at root to iterate\\n            # trie for every word\\n            cur = root\\n            \\n            # for every letter in the current\\n            # word, traverse the trie and see\\n            # that for every letter in this\\n            # word, there\\'s a node in the trie\\n            # which has end = True (i.e. a word \\n            # on its own, if not just break out)\\n            for letter in word:\\n                cur = cur.children[letter]\\n                if not cur.end: break\\n            \\n            # proceed only if you didn\\'t break\\n            # out of the previous loop (cur.end == True)\\n            # and then check if the cur word is longer\\n            # than the cur res, or if they are equal in length\\n            # use the lexicographically smaller one (word < res)\\n            if cur.end and (len(word) > len(res) or (len(word) == len(res) and word < res)):\\n                res = word        \\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 934013,
                "title": "c-using-trie-explained",
                "content": "First store every word in the Trie and mark a boolean value `isEnd = true`, as this will indicate the ending of word. Now for every string in words, traverse Trie and count the `isEnd` boolean value is the path. If the `count` equals the length of string that means we encounter all the possible prefix of the current word.\\n\\n```\\nclass TrieNode {\\npublic:\\n    unordered_map<char, TrieNode*> mp;\\n    bool isEnd;\\n    \\n    TrieNode() {\\n        this->isEnd = false;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    string longestWord(vector<string>& words) \\n    {\\n        TrieNode *root = new TrieNode();\\n        for(string s: words) {\\n            insert(root, s);\\n        }\\n        \\n        string ans;\\n        for(string s: words) \\n        {\\n            if(ans.size() > s.size()) continue;\\n            if(search(root, s)) {\\n                if(ans.size() == s.size()) ans = min(s, ans);\\n                else ans = s;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    void insert(TrieNode *root, string s)\\n    {\\n        TrieNode *curr = root;\\n        for(char c: s)\\n        {\\n            if(curr->mp.find(c) == curr->mp.end()) {\\n                curr->mp[c] = new TrieNode();\\n            }\\n            curr = curr->mp[c];\\n        }\\n        curr->isEnd = true;\\n    }\\n    \\n    bool search(TrieNode *root, string s)\\n    {\\n        int count = 0;\\n        TrieNode *curr = root;\\n        for(char c: s)\\n        {\\n            curr = curr->mp[c];\\n            if(curr->isEnd) ++count;\\n        }\\n        return count == s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass TrieNode {\\npublic:\\n    unordered_map<char, TrieNode*> mp;\\n    bool isEnd;\\n    \\n    TrieNode() {\\n        this->isEnd = false;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    string longestWord(vector<string>& words) \\n    {\\n        TrieNode *root = new TrieNode();\\n        for(string s: words) {\\n            insert(root, s);\\n        }\\n        \\n        string ans;\\n        for(string s: words) \\n        {\\n            if(ans.size() > s.size()) continue;\\n            if(search(root, s)) {\\n                if(ans.size() == s.size()) ans = min(s, ans);\\n                else ans = s;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    void insert(TrieNode *root, string s)\\n    {\\n        TrieNode *curr = root;\\n        for(char c: s)\\n        {\\n            if(curr->mp.find(c) == curr->mp.end()) {\\n                curr->mp[c] = new TrieNode();\\n            }\\n            curr = curr->mp[c];\\n        }\\n        curr->isEnd = true;\\n    }\\n    \\n    bool search(TrieNode *root, string s)\\n    {\\n        int count = 0;\\n        TrieNode *curr = root;\\n        for(char c: s)\\n        {\\n            curr = curr->mp[c];\\n            if(curr->isEnd) ++count;\\n        }\\n        return count == s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 683059,
                "title": "c-clean-readable-solution-using-trie",
                "content": "```\\nclass TrieNode {\\npublic:\\n    vector<TrieNode*> children;\\n    bool isTerminal;\\n    \\n    TrieNode() {\\n        children.resize(26, NULL);\\n        isTerminal = false;\\n    }\\n};\\n\\nclass Trie {\\n    TrieNode *root;\\n    int maxLen;\\n    string maxWord;\\n\\npublic:\\n    Trie() {\\n        root = new TrieNode();\\n        root->isTerminal = true;\\n        maxLen = 0;\\n    }\\n    \\n    string getMaxWord() {\\n        return maxWord;\\n    }\\n    \\n    void insert(string word) {\\n        TrieNode *cur = root;\\n        bool flag = true;\\n        \\n        for (int i = 0; i < word.length(); i++) {\\n            char ch = word[i];\\n            \\n            if (!cur->isTerminal)\\n                flag = false;\\n            \\n            if (cur->children[ch - \\'a\\'] == NULL)\\n                cur->children[ch - \\'a\\'] = new TrieNode();\\n            \\n            cur = cur->children[ch - \\'a\\'];\\n        }\\n        \\n        cur->isTerminal = true;\\n        \\n        if (flag and word.length() > maxLen) {\\n            maxLen = word.length();\\n            maxWord = word;\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    string longestWord(vector<string>& words) {\\n        Trie *myTrie = new Trie();\\n        \\n        sort(words.begin(), words.end());\\n        \\n        for (auto word : words)\\n            myTrie->insert(word);\\n        \\n        return myTrie->getMaxWord();        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string longestWord(vector<string>& words) {\\n        Trie *myTrie = new Trie();\\n        \\n        sort(words.begin(), words.end());\\n        \\n        for (auto word : words)\\n            myTrie->insert(word);\\n        \\n        return myTrie->getMaxWord();        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 109119,
                "title": "simple-javascript-solution",
                "content": "```\\nconst longestWord = (words) => {\\n    words.sort()\\n    const wordSet = new Set(words)\\n    let res = ''\\n    for (const w of words) {\\n        let isValid = true\\n        let key = ''\\n        for (let i = 0; i < w.length - 1; i++) {\\n            key += w[i]\\n            if (!wordSet.has(key)) {\\n                isValid = false\\n                break;\\n            }\\n        }\\n        if (isValid && w.length > res.length) {\\n            res = w\\n        }\\n    }\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst longestWord = (words) => {\\n    words.sort()\\n    const wordSet = new Set(words)\\n    let res = ''\\n    for (const w of words) {\\n        let isValid = true\\n        let key = ''\\n        for (let i = 0; i < w.length - 1; i++) {\\n            key += w[i]\\n            if (!wordSet.has(key)) {\\n                isValid = false\\n                break;\\n            }\\n        }\\n        if (isValid && w.length > res.length) {\\n            res = w\\n        }\\n    }\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2075062,
                "title": "trie-bfs-python-solution-with-comments-easy-to-understand",
                "content": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.endOfWord = False\\n        self.val = \\'\\'           # to define the value of end node as word\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n    def addWord(self, word):\\n        cur = self.root\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n        cur.endOfWord = True\\n        cur.val = word     # definging the end value as whole word\\n    \\n    def bfs(self):         # as I am starting from the root itself, so bfs have only argument self for referring the root\\n        q = [self.root]\\n        res = \\'\\'\\n        while q:\\n            cur = q.pop(0)\\n            for child in cur.children.values():     # traversing all the nodes of cur not keys\\n                if child.endOfWord:                 # ONLY go to the node which is of length 1 and end of a word also\\n                    q.append(child)\\n                    if len(child.val) > len(res):   # for greater length as for lexicografical I have already sorted words \\n                        res = child.val\\n        return res\\n        \\nclass Solution:\\n    def longestWord(self, words: List[str]) -> str:\\n        words.sort()        # sort in lexicografical order\\n        trie = Trie()       # making object of the Trie Class\\n        for word in words:  # adding all words to trie structre\\n            trie.addWord(word)\\n        \\n        return trie.bfs()   # calling the bfs function \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.endOfWord = False\\n        self.val = \\'\\'           # to define the value of end node as word\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n    def addWord(self, word):\\n        cur = self.root\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n        cur.endOfWord = True\\n        cur.val = word     # definging the end value as whole word\\n    \\n    def bfs(self):         # as I am starting from the root itself, so bfs have only argument self for referring the root\\n        q = [self.root]\\n        res = \\'\\'\\n        while q:\\n            cur = q.pop(0)\\n            for child in cur.children.values():     # traversing all the nodes of cur not keys\\n                if child.endOfWord:                 # ONLY go to the node which is of length 1 and end of a word also\\n                    q.append(child)\\n                    if len(child.val) > len(res):   # for greater length as for lexicografical I have already sorted words \\n                        res = child.val\\n        return res\\n        \\nclass Solution:\\n    def longestWord(self, words: List[str]) -> str:\\n        words.sort()        # sort in lexicografical order\\n        trie = Trie()       # making object of the Trie Class\\n        for word in words:  # adding all words to trie structre\\n            trie.addWord(word)\\n        \\n        return trie.bfs()   # calling the bfs function \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1507117,
                "title": "c-easy-to-understand-using-set",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool comp(string a,string b)\\n    {\\n        if(a.size()!=b.size())\\n        return a.size()<b.size();\\n        else\\n        return a>b;\\n    }\\n    string longestWord(vector<string>& words) {\\n        vector<string> v;\\n        unordered_set<string> s;\\n        int n=words.size(),c;\\n        for(int i=0;i<n;i++)\\n        s.insert(words[i]);\\n        for(int i=0;i<n;i++)\\n        {\\n            c=0;\\n            string str;\\n            int k;\\n            for(int j=1;j<=words[i].size();j++)\\n            {\\n                str=words[i].substr(0,j);\\n                k=str.size();\\n                if(s.find(str)!=s.end())\\n                c++;\\n            }\\n            if(c==k)\\n            v.push_back(str);\\n        }\\n        if(v.size()==0)\\n        return \"\";\\n        sort(v.begin(),v.end(),comp);\\n        return v[v.size()-1];\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [
                    "C",
                    "String",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool comp(string a,string b)\\n    {\\n        if(a.size()!=b.size())\\n        return a.size()<b.size();\\n        else\\n        return a>b;\\n    }\\n    string longestWord(vector<string>& words) {\\n        vector<string> v;\\n        unordered_set<string> s;\\n        int n=words.size(),c;\\n        for(int i=0;i<n;i++)\\n        s.insert(words[i]);\\n        for(int i=0;i<n;i++)\\n        {\\n            c=0;\\n            string str;\\n            int k;\\n            for(int j=1;j<=words[i].size();j++)\\n            {\\n                str=words[i].substr(0,j);\\n                k=str.size();\\n                if(s.find(str)!=s.end())\\n                c++;\\n            }\\n            if(c==k)\\n            v.push_back(str);\\n        }\\n        if(v.size()==0)\\n        return \"\";\\n        sort(v.begin(),v.end(),comp);\\n        return v[v.size()-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 109118,
                "title": "java-solution-with-trie",
                "content": "```\\nclass Solution {\\n    class TrieNode{\\n        public char val;\\n        public TrieNode[] hash;\\n        public boolean isWord;\\n        public TrieNode(){\\n            this.val='\\\\u0000';\\n            this.hash=new TrieNode[26];\\n            this.isWord=false;\\n        }\\n        public TrieNode(char c){\\n            this.val=c;\\n            this.hash=new TrieNode[26];\\n            this.isWord=false;\\n        }\\n        public StringBuilder dfs(StringBuilder res){\\n             \\n            StringBuilder max=new StringBuilder();\\n            for(int i=0;i<26;i++){\\n                if(hash[i]!=null && hash[i].isWord){\\n                    StringBuilder temp=new StringBuilder();\\n                    temp.append(hash[i].val);\\n                    temp.append(hash[i].dfs(temp));\\n                    if(temp.length() > max.length())\\n                        max=temp;\\n                }\\n            }\\n            return max;\\n        }\\n        \\n    }\\n    public String longestWord(String[] words) {\\n        TrieNode root=new TrieNode();\\n        for(String word:words){\\n            TrieNode curr=root;\\n            for(int i=0;i<word.length();i++){\\n                if(curr.hash[word.charAt(i)-'a']==null){\\n                    TrieNode temp=new TrieNode(word.charAt(i));\\n                    curr.hash[word.charAt(i)-'a']=temp;\\n                }\\n                curr=curr.hash[word.charAt(i)-'a'];\\n                if(i==word.length()-1)\\n                    curr.isWord=true;                    \\n            }\\n        }\\n        StringBuilder res=new StringBuilder();\\n        res=root.dfs(res);\\n        \\n        return res.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class TrieNode{\\n        public char val;\\n        public TrieNode[] hash;\\n        public boolean isWord;\\n        public TrieNode(){\\n            this.val='\\\\u0000';\\n            this.hash=new TrieNode[26];\\n            this.isWord=false;\\n        }\\n        public TrieNode(char c){\\n            this.val=c;\\n            this.hash=new TrieNode[26];\\n            this.isWord=false;\\n        }\\n        public StringBuilder dfs(StringBuilder res){\\n             \\n            StringBuilder max=new StringBuilder();\\n            for(int i=0;i<26;i++){\\n                if(hash[i]!=null && hash[i].isWord){\\n                    StringBuilder temp=new StringBuilder();\\n                    temp.append(hash[i].val);\\n                    temp.append(hash[i].dfs(temp));\\n                    if(temp.length() > max.length())\\n                        max=temp;\\n                }\\n            }\\n            return max;\\n        }\\n        \\n    }\\n    public String longestWord(String[] words) {\\n        TrieNode root=new TrieNode();\\n        for(String word:words){\\n            TrieNode curr=root;\\n            for(int i=0;i<word.length();i++){\\n                if(curr.hash[word.charAt(i)-'a']==null){\\n                    TrieNode temp=new TrieNode(word.charAt(i));\\n                    curr.hash[word.charAt(i)-'a']=temp;\\n                }\\n                curr=curr.hash[word.charAt(i)-'a'];\\n                if(i==word.length()-1)\\n                    curr.isWord=true;                    \\n            }\\n        }\\n        StringBuilder res=new StringBuilder();\\n        res=root.dfs(res);\\n        \\n        return res.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652066,
                "title": "easy-python-solution-prefix-clean-code",
                "content": "# Python Code\\n---\\n```\\nclass Solution:\\n    def longestWord(self, words: List[str]) -> str:\\n        map = {}\\n        for word in words:\\n            map[word] = 1\\n        result = \"\"\\n        words.sort()\\n        for word in words:\\n            flag = True\\n            for i in range(len(word)-1):\\n                if word[:i+1] not in map:\\n                    flag = False\\n                    break\\n            if flag == True:\\n                if(len(result) < len(word)):\\n                    result = word\\n        return result\\n        \\n```\\n---\\n#### *Please don\\'t forget to upvote if you\\'ve liked my solution.* \\u2B06\\uFE0F\\n---",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def longestWord(self, words: List[str]) -> str:\\n        map = {}\\n        for word in words:\\n            map[word] = 1\\n        result = \"\"\\n        words.sort()\\n        for word in words:\\n            flag = True\\n            for i in range(len(word)-1):\\n                if word[:i+1] not in map:\\n                    flag = False\\n                    break\\n            if flag == True:\\n                if(len(result) < len(word)):\\n                    result = word\\n        return result\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1325279,
                "title": "2-solutions-set-and-trie",
                "content": "Solution 1: \\nThis is a naive Solution checking all prefixs \\n```\\nclass Solution {\\npublic:\\n    string longestWord(vector<string>& words) {\\n        string ans = \"\";\\n        set<string> st;\\n        for(auto s : words)\\n            st.insert(s);\\n        \\n        for(string word : words) {\\n            if(word.length()>ans.length() || (word.length()==ans.length() && ans>word))  {\\n                bool fine = 1;\\n                for(int k=1;k<word.length();k++){\\n                    if(st.find(word.substr(0,k)) == st.end()){\\n                        fine = 0;\\n                        break;\\n                    }\\n                }\\n                if(fine) ans = word;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\nSolution 2 :  Using trie data structure:\\n```\\nclass TrieNode{\\n  public : \\n    vector<TrieNode*> children;\\n    bool isEnd;\\n    \\n    TrieNode(){\\n        children.assign(26,NULL);\\n        isEnd = 0;\\n    }    \\n};\\n\\nclass Trie{\\n  public: \\n    TrieNode* root;\\n    Trie(){\\n        root = new TrieNode();\\n    }\\n    void insert(string s){\\n        TrieNode* curr = root;\\n        for(int i=0;i<s.length();i++){\\n            if(curr->children[s[i]-\\'a\\'] == NULL) \\n                curr->children[s[i]-\\'a\\'] = new TrieNode();\\n            curr = curr->children[s[i]-\\'a\\'];\\n        }\\n        curr->isEnd = true;\\n    }\\n    \\n    bool present(string word){\\n        TrieNode* curr = root;\\n        for(int i=0;i<word.length();i++){\\n            if(root ==curr || curr->isEnd) \\n                curr = curr->children[word[i]-\\'a\\'];\\n            else \\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    \\n};\\n\\nclass Solution {\\npublic:\\n    string longestWord(vector<string>& words) {\\n        Trie* trie = new Trie();\\n        for(string s : words){\\n            trie->insert(s);\\n        }\\n        string ans = \"\";\\n        for(string word : words) {\\n            if(trie->present(word) && word.length()>=ans.length()) {\\n                ans = (ans.length() == word.length()) ? min(ans, word) : word;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestWord(vector<string>& words) {\\n        string ans = \"\";\\n        set<string> st;\\n        for(auto s : words)\\n            st.insert(s);\\n        \\n        for(string word : words) {\\n            if(word.length()>ans.length() || (word.length()==ans.length() && ans>word))  {\\n                bool fine = 1;\\n                for(int k=1;k<word.length();k++){\\n                    if(st.find(word.substr(0,k)) == st.end()){\\n                        fine = 0;\\n                        break;\\n                    }\\n                }\\n                if(fine) ans = word;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass TrieNode{\\n  public : \\n    vector<TrieNode*> children;\\n    bool isEnd;\\n    \\n    TrieNode(){\\n        children.assign(26,NULL);\\n        isEnd = 0;\\n    }    \\n};\\n\\nclass Trie{\\n  public: \\n    TrieNode* root;\\n    Trie(){\\n        root = new TrieNode();\\n    }\\n    void insert(string s){\\n        TrieNode* curr = root;\\n        for(int i=0;i<s.length();i++){\\n            if(curr->children[s[i]-\\'a\\'] == NULL) \\n                curr->children[s[i]-\\'a\\'] = new TrieNode();\\n            curr = curr->children[s[i]-\\'a\\'];\\n        }\\n        curr->isEnd = true;\\n    }\\n    \\n    bool present(string word){\\n        TrieNode* curr = root;\\n        for(int i=0;i<word.length();i++){\\n            if(root ==curr || curr->isEnd) \\n                curr = curr->children[word[i]-\\'a\\'];\\n            else \\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    \\n};\\n\\nclass Solution {\\npublic:\\n    string longestWord(vector<string>& words) {\\n        Trie* trie = new Trie();\\n        for(string s : words){\\n            trie->insert(s);\\n        }\\n        string ans = \"\";\\n        for(string word : words) {\\n            if(trie->present(word) && word.length()>=ans.length()) {\\n                ans = (ans.length() == word.length()) ? min(ans, word) : word;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 969298,
                "title": "please-see-if-this-test-case-is-correct",
                "content": "Your Input : [\"yo\",\"ew\",\"fc\",\"zrc\",\"yodn\",\"fcm\",\"qm\",\"qmo\",\"fcmz\",\"z\",\"ewq\",\"yod\",\"ewqz\",\"y\"]\\nOutput : \"ewqz\"\\nExpected : \"yodn\"\\n\\nI think ewqz is lexicographically smaller than yodn , then why yodn is the answer ?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 853277,
                "title": "python-trie-straightforward-solution",
                "content": "Standard implementation of the Trie, but save the length of the word that is continuousely building when inserting the word.\\n\\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = defaultdict(TrieNode)\\n        self.word = None  # Record the built word for the current node\\n        self.length = 0  # Record the continue length of the build word\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n        self.max_length = -1  # the max length of the word in the entire words list\\n        self.word = None  # the resulting word\\n    \\n    def insert(self, word):\\n        current = self.root\\n        word_length = 1\\n        for letter in word:\\n            if current.word:\\n                word_length += 1\\n            else:\\n                # Reset length if one character is skipped\\n                word_length = 1\\n            current = current.children[letter]\\n        current.word = word\\n        current.length = word_length if word_length == len(word) else 1\\n        \\n        if current.length > self.max_length:\\n            self.max_length = current.length\\n            self.word = word\\n        elif current.length == self.max_length:\\n            self.word = min(word, self.word)\\n        \\nclass Solution:\\n    def longestWord(self, words: List[str]) -> str:\\n        tree = Trie()\\n        [tree.insert(word) for word in sorted(words)]  # Have to sort to make sure the word is built in order\\n        \\n        return tree.word\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = defaultdict(TrieNode)\\n        self.word = None  # Record the built word for the current node\\n        self.length = 0  # Record the continue length of the build word\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n        self.max_length = -1  # the max length of the word in the entire words list\\n        self.word = None  # the resulting word\\n    \\n    def insert(self, word):\\n        current = self.root\\n        word_length = 1\\n        for letter in word:\\n            if current.word:\\n                word_length += 1\\n            else:\\n                # Reset length if one character is skipped\\n                word_length = 1\\n            current = current.children[letter]\\n        current.word = word\\n        current.length = word_length if word_length == len(word) else 1\\n        \\n        if current.length > self.max_length:\\n            self.max_length = current.length\\n            self.word = word\\n        elif current.length == self.max_length:\\n            self.word = min(word, self.word)\\n        \\nclass Solution:\\n    def longestWord(self, words: List[str]) -> str:\\n        tree = Trie()\\n        [tree.insert(word) for word in sorted(words)]  # Have to sort to make sure the word is built in order\\n        \\n        return tree.word\\n```",
                "codeTag": "Java"
            },
            {
                "id": 833318,
                "title": "python-super-simple-explained-solution-faster-than-95",
                "content": "**Like it? please upvote...**\\n```\\nclass Solution:\\n    def longestWord(self, words: List[str]) -> str:\\n\\t\\t\\t# helper function to check if all prefixes are in dictionary:\\n        def check_pre(word):\\n            for i in range(1, len(word)):\\n                if word[:i] not in words:\\n                    return False\\n            return True\\n                \\n\\t\\t\\t# sort by reversed lexicographical order:\\n        words.sort(reverse = True)\\n\\t\\t\\t# sort by length of word:\\n        words.sort(key = lambda a: len(a))\\n\\t\\t\\t# go through all words from end and check prefixes:\\n        for word in words[::-1]:\\n            if check_pre(word) == True:\\n                return word\\n        return \"\"\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestWord(self, words: List[str]) -> str:\\n\\t\\t\\t# helper function to check if all prefixes are in dictionary:\\n        def check_pre(word):\\n            for i in range(1, len(word)):\\n                if word[:i] not in words:\\n                    return False\\n            return True\\n                \\n\\t\\t\\t# sort by reversed lexicographical order:\\n        words.sort(reverse = True)\\n\\t\\t\\t# sort by length of word:\\n        words.sort(key = lambda a: len(a))\\n\\t\\t\\t# go through all words from end and check prefixes:\\n        for word in words[::-1]:\\n            if check_pre(word) == True:\\n                return word\\n        return \"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 734750,
                "title": "python-with-trie-and-sort",
                "content": "```\\nclass TrieNode(object):\\n    def __init__(self):\\n        self.children = {}\\n        self.end = False\\n\\nclass Solution(object):\\n    def longestWord(self, words):\\n        self.root = TrieNode()    \\n        words = sorted(set(words), key = lambda word:(-len(word), word))\\n        for word in words:\\n            cur = self.root\\n            for letter in word:\\n                if letter not in cur.children:\\n                    cur.children[letter] = TrieNode()\\n                cur = cur.children[letter]\\n            cur.end = True\\n        for word in words:\\n            flag = True\\n            cur = self.root\\n            for letter in word:\\n                if cur.children[letter].end == False:\\n                    flag = False\\n                    break\\n                else:\\n                    cur = cur.children[letter]\\n            if flag:\\n                return word\\n        return \\'\\'\\n            \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Trie",
                    "Sorting"
                ],
                "code": "```\\nclass TrieNode(object):\\n    def __init__(self):\\n        self.children = {}\\n        self.end = False\\n\\nclass Solution(object):\\n    def longestWord(self, words):\\n        self.root = TrieNode()    \\n        words = sorted(set(words), key = lambda word:(-len(word), word))\\n        for word in words:\\n            cur = self.root\\n            for letter in word:\\n                if letter not in cur.children:\\n                    cur.children[letter] = TrieNode()\\n                cur = cur.children[letter]\\n            cur.end = True\\n        for word in words:\\n            flag = True\\n            cur = self.root\\n            for letter in word:\\n                if cur.children[letter].end == False:\\n                    flag = False\\n                    break\\n                else:\\n                    cur = cur.children[letter]\\n            if flag:\\n                return word\\n        return \\'\\'\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 473991,
                "title": "trie-c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    struct trie\\n    {\\n        trie* c[26];\\n        bool isend;\\n        \\n        trie()\\n        {\\n            isend=false;\\n            for(int i=0;i<26;i++) c[i]=nullptr;\\n        }\\n    };\\n    \\n    trie* root= new trie();\\n    string ans;\\n    \\n    void insert(string& word)\\n    {\\n        trie* temp = root;\\n        for(auto& letter: word)\\n        {\\n            int idx = letter - \\'a\\';\\n            \\n            if(temp->c[idx] == nullptr)\\n            {\\n                temp->c[idx] = new trie();\\n            }\\n            \\n            temp = temp->c[idx]; \\n        }\\n        \\n        temp->isend = true;\\n    }\\n    \\n    void dfs(trie* root,string temp)\\n    {\\n        for(int i=0;i<26;i++)\\n        {\\n            if(root->c[i]!=nullptr and root->c[i]->isend==true)\\n            {\\n                temp+=char(i+\\'a\\');\\n                if(temp.size()>ans.size()) ans=temp;\\n                else if(temp.size()==ans.size() and ans>temp)   ans=temp;\\n                dfs(root->c[i],temp);\\n                temp.pop_back();\\n            }\\n        }\\n        \\n    }\\n    \\n    string longestWord(vector<string>& words) {\\n        for(auto word:words)\\n        {\\n            insert(word);\\n        }\\n        dfs(root,\"\");\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    struct trie\\n    {\\n        trie* c[26];\\n        bool isend;\\n        \\n        trie()\\n        {\\n            isend=false;\\n            for(int i=0;i<26;i++) c[i]=nullptr;\\n        }\\n    };\\n    \\n    trie* root= new trie();\\n    string ans;\\n    \\n    void insert(string& word)\\n    {\\n        trie* temp = root;\\n        for(auto& letter: word)\\n        {\\n            int idx = letter - \\'a\\';\\n            \\n            if(temp->c[idx] == nullptr)\\n            {\\n                temp->c[idx] = new trie();\\n            }\\n            \\n            temp = temp->c[idx]; \\n        }\\n        \\n        temp->isend = true;\\n    }\\n    \\n    void dfs(trie* root,string temp)\\n    {\\n        for(int i=0;i<26;i++)\\n        {\\n            if(root->c[i]!=nullptr and root->c[i]->isend==true)\\n            {\\n                temp+=char(i+\\'a\\');\\n                if(temp.size()>ans.size()) ans=temp;\\n                else if(temp.size()==ans.size() and ans>temp)   ans=temp;\\n                dfs(root->c[i],temp);\\n                temp.pop_back();\\n            }\\n        }\\n        \\n    }\\n    \\n    string longestWord(vector<string>& words) {\\n        for(auto word:words)\\n        {\\n            insert(word);\\n        }\\n        dfs(root,\"\");\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 186128,
                "title": "o-1-space-nlogn-solution-python-c",
                "content": "this takes advantage of lexicographic ordering. i think the code is self explanatory.\\n\\nhad idea after reading wofainta\\'s solution [here](https://leetcode.com/problems/longest-word-in-dictionary/discuss/175385/C++-O(N-logN)-time-O(1)-space-solution): \\n\\nc++\\n```\\nclass Solution {\\npublic:\\n    string longestWord(vector<string>& words) {\\n        string best, prefix;\\n        sort(words.begin(), words.end());\\n        for (string w: words) {\\n            int sz = w.size();\\n            if (w.substr(0, sz - 1) == prefix.substr(0, sz - 1)) {\\n                prefix = w;\\n                if (sz > best.size()) best = w;\\n            }\\n        }\\n        return best;\\n    }\\n};\\n```\\npython\\n```\\nclass Solution(object):\\n    def longestWord(self, words):\\n        best = prefix = \"\"\\n        for w in sorted(words):\\n            if w[:len(w) - 1] == prefix[:len(w) - 1]:\\n                prefix = w\\n                best = max([best, w], key=len)\\n        return best\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestWord(vector<string>& words) {\\n        string best, prefix;\\n        sort(words.begin(), words.end());\\n        for (string w: words) {\\n            int sz = w.size();\\n            if (w.substr(0, sz - 1) == prefix.substr(0, sz - 1)) {\\n                prefix = w;\\n                if (sz > best.size()) best = w;\\n            }\\n        }\\n        return best;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def longestWord(self, words):\\n        best = prefix = \"\"\\n        for w in sorted(words):\\n            if w[:len(w) - 1] == prefix[:len(w) - 1]:\\n                prefix = w\\n                best = max([best, w], key=len)\\n        return best\\n```",
                "codeTag": "Java"
            },
            {
                "id": 134640,
                "title": "c-trie-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    /** Initialize your data structure here. */\\n    struct TrieNode{\\n        TrieNode* arr[26];\\n        bool eow;\\n    };\\n    \\n    /**Build a function to make a node and return TrieNode **/\\n    TrieNode* getNode()\\n    {\\n        TrieNode* node = new TrieNode;\\n        for(int i=0;i<26;i++)\\n            node->arr[i]=NULL;\\n        node->eow = false;\\n        \\n        return node;\\n    }\\n    \\n    /** Make the root TrieNode **/\\n    TrieNode* root;\\n    \\n    Solution(){\\n        root = getNode();\\n    }\\n    \\n    /** Insert a word into Trie **/\\n    void insert(string word)\\n    {\\n        TrieNode* temp = root;\\n        for(auto w: word)\\n        {\\n            int index = w - \\'a\\';\\n            if(temp->arr[index]==NULL)\\n                temp->arr[index] = getNode();\\n            temp = temp->arr[index];\\n            \\n        }\\n        temp->eow = true;\\n    }\\n    \\n    \\n    /** SPECIAL Search function specially for this problem **/\\n    \\n    string search()\\n    {\\n        string ans=\"\";\\n        int maxvalue=0;\\n        spsearch(root,0,\"\",maxvalue,ans);\\n        \\n        return ans;\\n    }\\n    \\n    void spsearch(TrieNode* r,int curr,string currstr,int& max,string& ans)\\n    {\\n        TrieNode* temp = r;\\n        \\n        //For each node check all alphabets from a-z (Since lexico) \\n        for(int i=0;i<26;i++)\\n        {\\n            if(temp->arr[i]==NULL)\\n                continue;\\n            \\n            if(temp->arr[i]->eow)\\n            {\\n                curr++;\\n                currstr+=(char)(i+\\'a\\');\\n                \\n                // cout<<\"--------------------\"<<endl;\\n                // cout<<\" Word: \"<<(char)(i+\\'a\\')<<\"   \"<<curr<<\"  y: \"<<currstr<<endl;\\n                ans = curr>max ? currstr : ans;\\n                max = curr>max ? curr : max;\\n                \\n                \\n                // cout<<\" Word: \"<<(char)(i+\\'a\\')<<\"   \"<<max<<\"  y: \"<<ans<<endl;\\n                // cout<<\"--------------------\"<<endl;\\n                spsearch(temp->arr[i],curr,currstr,max,ans);\\n\\n                curr--;\\n                currstr.pop_back();\\n            }\\n            \\n        }//for\\n    }\\n    \\n    /** Main Function **/\\n    string longestWord(vector<string>& words) {\\n        \\n        for(auto word:words)\\n            insert(word);\\n        \\n        string result = search();\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    /** Initialize your data structure here. */\\n    struct TrieNode{\\n        TrieNode* arr[26];\\n        bool eow;\\n    };\\n    \\n    /**Build a function to make a node and return TrieNode **/\\n    TrieNode* getNode()\\n    {\\n        TrieNode* node = new TrieNode;\\n        for(int i=0;i<26;i++)\\n            node->arr[i]=NULL;\\n        node->eow = false;\\n        \\n        return node;\\n    }\\n    \\n    /** Make the root TrieNode **/\\n    TrieNode* root;\\n    \\n    Solution(){\\n        root = getNode();\\n    }\\n    \\n    /** Insert a word into Trie **/\\n    void insert(string word)\\n    {\\n        TrieNode* temp = root;\\n        for(auto w: word)\\n        {\\n            int index = w - \\'a\\';\\n            if(temp->arr[index]==NULL)\\n                temp->arr[index] = getNode();\\n            temp = temp->arr[index];\\n            \\n        }\\n        temp->eow = true;\\n    }\\n    \\n    \\n    /** SPECIAL Search function specially for this problem **/\\n    \\n    string search()\\n    {\\n        string ans=\"\";\\n        int maxvalue=0;\\n        spsearch(root,0,\"\",maxvalue,ans);\\n        \\n        return ans;\\n    }\\n    \\n    void spsearch(TrieNode* r,int curr,string currstr,int& max,string& ans)\\n    {\\n        TrieNode* temp = r;\\n        \\n        //For each node check all alphabets from a-z (Since lexico) \\n        for(int i=0;i<26;i++)\\n        {\\n            if(temp->arr[i]==NULL)\\n                continue;\\n            \\n            if(temp->arr[i]->eow)\\n            {\\n                curr++;\\n                currstr+=(char)(i+\\'a\\');\\n                \\n                // cout<<\"--------------------\"<<endl;\\n                // cout<<\" Word: \"<<(char)(i+\\'a\\')<<\"   \"<<curr<<\"  y: \"<<currstr<<endl;\\n                ans = curr>max ? currstr : ans;\\n                max = curr>max ? curr : max;\\n                \\n                \\n                // cout<<\" Word: \"<<(char)(i+\\'a\\')<<\"   \"<<max<<\"  y: \"<<ans<<endl;\\n                // cout<<\"--------------------\"<<endl;\\n                spsearch(temp->arr[i],curr,currstr,max,ans);\\n\\n                curr--;\\n                currstr.pop_back();\\n            }\\n            \\n        }//for\\n    }\\n    \\n    /** Main Function **/\\n    string longestWord(vector<string>& words) {\\n        \\n        for(auto word:words)\\n            insert(word);\\n        \\n        string result = search();\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3139949,
                "title": "by-using-map-simple-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string longestWord(vector<string>& a) {\\n        sort(a.begin(), a.end());\\n         map<string, int>mp;\\n\\n             mp[\"\"]++;\\n             string ans;\\n\\n          for(auto i:a){\\n              \\n              string temp=i.substr(0,i.size()-1);\\n\\n              if(mp[temp]!=0){\\n                  if(ans.size()<i.size()){\\n                      ans=i;\\n                  }\\n                  mp[i]++;\\n              }\\n          }\\nreturn ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestWord(vector<string>& a) {\\n        sort(a.begin(), a.end());\\n         map<string, int>mp;\\n\\n             mp[\"\"]++;\\n             string ans;\\n\\n          for(auto i:a){\\n              \\n              string temp=i.substr(0,i.size()-1);\\n\\n              if(mp[temp]!=0){\\n                  if(ans.size()<i.size()){\\n                      ans=i;\\n                  }\\n                  mp[i]++;\\n              }\\n          }\\nreturn ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2608494,
                "title": "java-using-trie-simple-solution",
                "content": "```\\nclass Node{\\n    Node links[]=new Node[26];\\n    int end=0;\\n    Node(){}\\n    //checking whther char is already present in trienode or not\\n    boolean containsKey(char ch){\\n        return (links[ch-\\'a\\']!=null);\\n    }\\n    //creating new node from char\\n    void put(char ch ,Node node){\\n        links[ch-\\'a\\']=node;\\n    }\\n    //returning value of node\\n    Node get(char ch){\\n        return links[ch-\\'a\\'];\\n    }\\n    //setting the end of each word\\n    void setEnd(){ \\n        end=1;\\n    }\\n    int getEnd(){\\n        return end;\\n    }\\n}\\n//trie class\\nclass Trie{\\n    Node root;\\n    Trie(){\\n        root=new Node();\\n    }\\n    //inserting each character of word\\n    public void insert(String word){\\n        Node node=root;\\n        for(int i=0;i<word.length();i++){\\n            if(!node.containsKey(word.charAt(i))){\\n                node.put(word.charAt(i),new Node());\\n            }\\n            node=node.get(word.charAt(i));\\n        }\\n        node.setEnd();\\n    }\\n    //checking that my current string ends with 1 with its all characters\\n    public boolean iscorrect(String word){\\n        Node node=root;\\n        for(int i=0;i<word.length();i++){\\n            node=node.get(word.charAt(i));\\n            if(node.getEnd()==0){\\n                return false;\\n            }\\n            \\n        }\\n        return node.getEnd()==1?true:false;\\n    }\\n}\\nclass Solution {\\n    public String longestWord(String[] words) {\\n        Trie obj=new Trie();\\n        for(String x:words){\\n            obj.insert(x);\\n        }\\n        String lon=\"\";\\n        for(String x:words){\\n      \\n            if(obj.iscorrect(x)){\\n                if(x.length()>lon.length()){\\n                    lon=x;\\n                }\\n                //when string len equals checking which is lexicographically smaller\\n                else if(x.length()==lon.length() && x.compareTo(lon)<0){\\n                    lon=x;\\n                }\\n            }\\n        }\\n        return lon;\\n    }\\n}\\n```\\n***please upvote if you like my solution~***",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```\\nclass Node{\\n    Node links[]=new Node[26];\\n    int end=0;\\n    Node(){}\\n    //checking whther char is already present in trienode or not\\n    boolean containsKey(char ch){\\n        return (links[ch-\\'a\\']!=null);\\n    }\\n    //creating new node from char\\n    void put(char ch ,Node node){\\n        links[ch-\\'a\\']=node;\\n    }\\n    //returning value of node\\n    Node get(char ch){\\n        return links[ch-\\'a\\'];\\n    }\\n    //setting the end of each word\\n    void setEnd(){ \\n        end=1;\\n    }\\n    int getEnd(){\\n        return end;\\n    }\\n}\\n//trie class\\nclass Trie{\\n    Node root;\\n    Trie(){\\n        root=new Node();\\n    }\\n    //inserting each character of word\\n    public void insert(String word){\\n        Node node=root;\\n        for(int i=0;i<word.length();i++){\\n            if(!node.containsKey(word.charAt(i))){\\n                node.put(word.charAt(i),new Node());\\n            }\\n            node=node.get(word.charAt(i));\\n        }\\n        node.setEnd();\\n    }\\n    //checking that my current string ends with 1 with its all characters\\n    public boolean iscorrect(String word){\\n        Node node=root;\\n        for(int i=0;i<word.length();i++){\\n            node=node.get(word.charAt(i));\\n            if(node.getEnd()==0){\\n                return false;\\n            }\\n            \\n        }\\n        return node.getEnd()==1?true:false;\\n    }\\n}\\nclass Solution {\\n    public String longestWord(String[] words) {\\n        Trie obj=new Trie();\\n        for(String x:words){\\n            obj.insert(x);\\n        }\\n        String lon=\"\";\\n        for(String x:words){\\n      \\n            if(obj.iscorrect(x)){\\n                if(x.length()>lon.length()){\\n                    lon=x;\\n                }\\n                //when string len equals checking which is lexicographically smaller\\n                else if(x.length()==lon.length() && x.compareTo(lon)<0){\\n                    lon=x;\\n                }\\n            }\\n        }\\n        return lon;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2075147,
                "title": "python-o-n-log-n-time-o-n-space-faster-than-95",
                "content": "```\\nclass Solution:\\n    def longestWord(self, words: List[str]) -> str:\\n        words.sort()                  # for smallest lexicographical order\\n        visited = {\"\"}                # hashset to keep a track of visited words\\n        res = \\'\\'\\n        \\n        for word in words:\\n            if word[:-1] in visited:     # check previous word ie. word[:len(word)-1] visited or not\\n                visited.add(word)        # add this word to the set\\n                if len(word) > len(res): # current word have greater lenght and lexicographically smaller\\n                    res = word           # update res\\n        \\n        return res\\n    \\n    \\n    \\n# Time: O(n log(n))   # for sorting the words\\n# Space: O(n)         # for making the set visited\\n```\\n\\nSolution using Trie+BFS: https://leetcode.com/problems/longest-word-in-dictionary/discuss/2075062/Trie+BFS-or-Python-Solution-with-Comments-Easy-to-Understand",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def longestWord(self, words: List[str]) -> str:\\n        words.sort()                  # for smallest lexicographical order\\n        visited = {\"\"}                # hashset to keep a track of visited words\\n        res = \\'\\'\\n        \\n        for word in words:\\n            if word[:-1] in visited:     # check previous word ie. word[:len(word)-1] visited or not\\n                visited.add(word)        # add this word to the set\\n                if len(word) > len(res): # current word have greater lenght and lexicographically smaller\\n                    res = word           # update res\\n        \\n        return res\\n    \\n    \\n    \\n# Time: O(n log(n))   # for sorting the words\\n# Space: O(n)         # for making the set visited\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2042233,
                "title": "runtime-45-ms-o-s-c-solution",
                "content": "## Approach\\nLets say,\\n> **words** = [\"a\",\"banana\",\"app\",\"appl\",\"ap\",\"apply\",\"apple\"]\\n\\n* Traverse through the words array and insert every word in `Trie`.\\n* Traverse again and check whether `words[i]` contains all the prefixes or not.\\n\\n![ss-01](https://user-images.githubusercontent.com/32735407/168482696-55e7bfec-748b-4ca7-81d3-c7bab035d3d3.png)\\n\\nHere, we can see that `apple` and `apply` both are having all prefixes. So, both can be valid answers. But we need **lexicographically** the smallest one. So, the result is `apple`.\\n\\n## Complexity\\n> **Time**: `O(S)` where, S = sum of all strings.\\n> **Space**: `O(S)`\\n\\n## Code\\n```cpp\\nstruct TrieNode {\\n    bool isWord = false;\\n    TrieNode* children[26];\\n    \\n    bool containsKey(char key) {\\n        return (children[key - \\'a\\'] != NULL);\\n    }\\n    \\n    void put(char ch, TrieNode* node) {\\n        children[ch - \\'a\\'] = node;\\n    }\\n    \\n    TrieNode* nextNode(char ch) {\\n        return children[ch - \\'a\\'];\\n    }\\n    \\n    void setWord() {\\n        isWord = true;\\n    }\\n};\\n\\nclass Trie {\\nprivate: \\n    TrieNode* root;\\npublic: \\n    Trie() {\\n        root = new TrieNode();\\n    }\\n    \\n    void insert(string word) {\\n        TrieNode* curr = root;\\n        for(auto &ch : word) {\\n            if(!curr->containsKey(ch)) {\\n                curr->put(ch, new TrieNode());\\n            }\\n            curr = curr->nextNode(ch);\\n        }\\n        curr->setWord();\\n    }\\n    \\n    bool doesPrefixExist(string word) {\\n        bool isExist = true;\\n        TrieNode* curr = root;\\n        for(auto &ch : word) {\\n            if(curr->containsKey(ch)) {\\n                curr = curr->nextNode(ch);\\n                isExist = isExist & curr->isWord;\\n            } else {\\n                return false;\\n            }\\n        }\\n        return isExist;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    string longestWord(vector<string>& words) {\\n        Trie trie;\\n        string longest = \"\";\\n        \\n        for(auto &word : words) {\\n            trie.insert(word);\\n        }\\n        \\n        for(auto &word : words) {\\n            if(trie.doesPrefixExist(word)) {\\n                if(word.size() > longest.size()) {\\n                    longest = word;\\n                } else if(word.size() == longest.size() && word < longest) {\\n                    longest = word;\\n                }\\n            }\\n        }\\n        \\n        return longest;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```cpp\\nstruct TrieNode {\\n    bool isWord = false;\\n    TrieNode* children[26];\\n    \\n    bool containsKey(char key) {\\n        return (children[key - \\'a\\'] != NULL);\\n    }\\n    \\n    void put(char ch, TrieNode* node) {\\n        children[ch - \\'a\\'] = node;\\n    }\\n    \\n    TrieNode* nextNode(char ch) {\\n        return children[ch - \\'a\\'];\\n    }\\n    \\n    void setWord() {\\n        isWord = true;\\n    }\\n};\\n\\nclass Trie {\\nprivate: \\n    TrieNode* root;\\npublic: \\n    Trie() {\\n        root = new TrieNode();\\n    }\\n    \\n    void insert(string word) {\\n        TrieNode* curr = root;\\n        for(auto &ch : word) {\\n            if(!curr->containsKey(ch)) {\\n                curr->put(ch, new TrieNode());\\n            }\\n            curr = curr->nextNode(ch);\\n        }\\n        curr->setWord();\\n    }\\n    \\n    bool doesPrefixExist(string word) {\\n        bool isExist = true;\\n        TrieNode* curr = root;\\n        for(auto &ch : word) {\\n            if(curr->containsKey(ch)) {\\n                curr = curr->nextNode(ch);\\n                isExist = isExist & curr->isWord;\\n            } else {\\n                return false;\\n            }\\n        }\\n        return isExist;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    string longestWord(vector<string>& words) {\\n        Trie trie;\\n        string longest = \"\";\\n        \\n        for(auto &word : words) {\\n            trie.insert(word);\\n        }\\n        \\n        for(auto &word : words) {\\n            if(trie.doesPrefixExist(word)) {\\n                if(word.size() > longest.size()) {\\n                    longest = word;\\n                } else if(word.size() == longest.size() && word < longest) {\\n                    longest = word;\\n                }\\n            }\\n        }\\n        \\n        return longest;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1722662,
                "title": "python-clean-sort-set-with-workthrough-o-n-log-n",
                "content": "```\\nclass Solution:\\n    \"\"\"\\n    First sort the list by lexicographic orer.\\n    \\n    Then, iterate through the sorted list. \\n    \\n    If the length of word is 1, just add to hashset.\\n    \\n    If length larger than one, we need to check whether its [:-1] part in set or not. If so, then\\n    it is a candidate for the longest word seen so far. We add the word itself to the hash set to it can be used\\n    to form other words.\\n    \\n    hashset contents example: \\n    {\\'worl\\', \\'world\\', \\'w\\', \\'wo\\', \\'wor\\'}\\n\\n    \"\"\"\\n    \\n    def longestWord(self, words: List[str]) -> str:\\n        words.sort()\\n        \\n        result = \\'\\'\\n        seen = set()\\n        for w in words:\\n            if len(w) == 1 or w[0:-1] in seen:\\n                if len(w) > len(result):\\n                    result = w\\n                seen.add(w)\\n  \\n        return result\\n\\t\\t```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    \"\"\"\\n    First sort the list by lexicographic orer.\\n    \\n    Then, iterate through the sorted list. \\n    \\n    If the length of word is 1, just add to hashset.\\n    \\n    If length larger than one, we need to check whether its [:-1] part in set or not. If so, then\\n    it is a candidate for the longest word seen so far. We add the word itself to the hash set to it can be used\\n    to form other words.\\n    \\n    hashset contents example: \\n    {\\'worl\\', \\'world\\', \\'w\\', \\'wo\\', \\'wor\\'}\\n\\n    \"\"\"\\n    \\n    def longestWord(self, words: List[str]) -> str:\\n        words.sort()\\n        \\n        result = \\'\\'\\n        seen = set()\\n        for w in words:\\n            if len(w) == 1 or w[0:-1] in seen:\\n                if len(w) > len(result):\\n                    result = w\\n                seen.add(w)\\n  \\n        return result\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1410288,
                "title": "python-trie-dfs-solution",
                "content": "We first insert all the words to the Trie. Then, we go through the words again and look for the longest word in the dictionary using DFS. As soon as we see that any word leading up to a word doesn\\'t exist in the Trie we can stop searching deeper. Since we sort the words beforehand we have the longest word with the smallest lexicographical order. Instead of sorting we can also check upon a tie whether the new path is lexicographically smaller.\\n```Python\\nfrom collections import defaultdict\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = defaultdict(TrieNode)\\n        self.isWord = False\\n        \\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n        self.ret = \"\"\\n\\n    def insert(self, word):\\n        node = self.root\\n        for letter in word:\\n            node = node.children[letter]\\n        node.isWord = True\\n\\nclass Solution:            \\n    def longestWord(self, words: List[str]) -> str:\\n        def dfs(node, path):\\n            if not node.isWord:\\n                return\\n            if len(path) > len(self.ret):\\n                self.ret = \"\".join(path)\\n            for letter in node.children:\\n                dfs(node.children[letter], path+[letter])\\n            \\n        words.sort()\\n        trie = Trie()\\n        trie.root.isWord = True\\n        for word in words:\\n            trie.insert(word)\\n        self.ret = \"\"\\n        dfs(trie.root, [])\\n        return self.ret\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Trie",
                    "Sorting"
                ],
                "code": "```Python\\nfrom collections import defaultdict\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = defaultdict(TrieNode)\\n        self.isWord = False\\n        \\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n        self.ret = \"\"\\n\\n    def insert(self, word):\\n        node = self.root\\n        for letter in word:\\n            node = node.children[letter]\\n        node.isWord = True\\n\\nclass Solution:            \\n    def longestWord(self, words: List[str]) -> str:\\n        def dfs(node, path):\\n            if not node.isWord:\\n                return\\n            if len(path) > len(self.ret):\\n                self.ret = \"\".join(path)\\n            for letter in node.children:\\n                dfs(node.children[letter], path+[letter])\\n            \\n        words.sort()\\n        trie = Trie()\\n        trie.root.isWord = True\\n        for word in words:\\n            trie.insert(word)\\n        self.ret = \"\"\\n        dfs(trie.root, [])\\n        return self.ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780606,
                "title": "javascript-solutions-set-beats-97-trie-beats-66",
                "content": "```\\n/**\\n * @param {string[]} words\\n * @return {string}\\n */\\nvar longestWord = function(words) {\\n    if (!words.length) return \\'\\'\\n    words.sort()\\n    let set = new Set()\\n    let ans = \\'\\'\\n    for (let i = 0; i < words.length; i++) {\\n        let prev = words[i].substring(0, words[i].length - 1)\\n        if (words[i].length === 1 || set.has(prev)) {\\n          ans = words[i].length > ans.length ? words[i] : ans\\n          set.add(words[i])\\n        }\\n    }\\n    return ans\\n};\\n\\n/**\\n * @param {string[]} words\\n * @return {string}\\n */\\nvar longestWord = function(words) {\\n    let trie = new Trie()\\n    for (let i = 0; i < words.length; i++) {\\n      trie.add(words[i])\\n    }\\n    let longestWord = \\'\\'\\n    var dfs = function(node, s) {\\n      let keys = Object.keys(node.storage)\\n      for (let i = 0; i < keys.length; i++) {\\n        if (node.storage[keys[i]].isWord) {\\n          dfs(node.storage[keys[i]], s + keys[i])\\n        }\\n      }\\n      if (s.length > longestWord.length) {\\n        longestWord = s\\n      } else if (s.length === longestWord.length) {\\n        longestWord = getSmallest(s, longestWord)\\n      }\\n    }\\n    dfs(trie.root, \\'\\')\\n    return longestWord\\n};\\n\\nvar getSmallest = function(a, b) {\\n    for (let i = 0; i < a.length; i++) {\\n        if (a[i] < b[i]) {\\n            return a\\n        } else if (b[i] < a[i]) {\\n            return b\\n        }\\n    }\\n    return a\\n}\\n\\nclass Node {\\n    constructor() {\\n        this.isWord = false\\n        this.storage = {}\\n    }\\n}\\n\\nclass Trie {\\n    constructor() {\\n        this.root = new Node()\\n    }\\n    add(word) {\\n        let curr = this.root\\n        for (let i = 0; i < word.length; i++) {\\n            if (!curr.storage[word[i]]) {\\n                curr.storage[word[i]] = new Node()\\n            }\\n            curr = curr.storage[word[i]]\\n        }\\n        curr.isWord = true\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Trie",
                    "Ordered Set"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {string}\\n */\\nvar longestWord = function(words) {\\n    if (!words.length) return \\'\\'\\n    words.sort()\\n    let set = new Set()\\n    let ans = \\'\\'\\n    for (let i = 0; i < words.length; i++) {\\n        let prev = words[i].substring(0, words[i].length - 1)\\n        if (words[i].length === 1 || set.has(prev)) {\\n          ans = words[i].length > ans.length ? words[i] : ans\\n          set.add(words[i])\\n        }\\n    }\\n    return ans\\n};\\n\\n/**\\n * @param {string[]} words\\n * @return {string}\\n */\\nvar longestWord = function(words) {\\n    let trie = new Trie()\\n    for (let i = 0; i < words.length; i++) {\\n      trie.add(words[i])\\n    }\\n    let longestWord = \\'\\'\\n    var dfs = function(node, s) {\\n      let keys = Object.keys(node.storage)\\n      for (let i = 0; i < keys.length; i++) {\\n        if (node.storage[keys[i]].isWord) {\\n          dfs(node.storage[keys[i]], s + keys[i])\\n        }\\n      }\\n      if (s.length > longestWord.length) {\\n        longestWord = s\\n      } else if (s.length === longestWord.length) {\\n        longestWord = getSmallest(s, longestWord)\\n      }\\n    }\\n    dfs(trie.root, \\'\\')\\n    return longestWord\\n};\\n\\nvar getSmallest = function(a, b) {\\n    for (let i = 0; i < a.length; i++) {\\n        if (a[i] < b[i]) {\\n            return a\\n        } else if (b[i] < a[i]) {\\n            return b\\n        }\\n    }\\n    return a\\n}\\n\\nclass Node {\\n    constructor() {\\n        this.isWord = false\\n        this.storage = {}\\n    }\\n}\\n\\nclass Trie {\\n    constructor() {\\n        this.root = new Node()\\n    }\\n    add(word) {\\n        let curr = this.root\\n        for (let i = 0; i < word.length; i++) {\\n            if (!curr.storage[word[i]]) {\\n                curr.storage[word[i]] = new Node()\\n            }\\n            curr = curr.storage[word[i]]\\n        }\\n        curr.isWord = true\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 453451,
                "title": "python3-easy-solution",
                "content": "```\\nclass Solution:\\n\\tdef longestWord(self, words: List[str]) -> str:\\n\\t\\twords.sort()\\n\\t\\tht = {}\\n\\t\\tfor w in words:\\n\\t\\t\\tif len(w) == 1 and w not in ht:\\n\\t\\t\\t\\tht[w] = 1\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tif w[:-1] in ht:\\n\\t\\t\\t\\tht[w] = 1\\n\\t\\ts = sorted(ht.keys(),reverse=True,key=len)\\n\\t\\t#print(s)\\n\\t\\tres = []\\n\\t\\tfor item in s:\\n\\t\\t\\tif len(res) == 0:\\n\\t\\t\\t\\tres.append(item)\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tif len(item) < len(res[0]):\\n\\t\\t\\t\\tbreak\\n\\t\\t\\telse:\\n\\t\\t\\t\\tres.append(item)\\n\\t\\tif len(res) == 0:\\n\\t\\t\\treturn \"\"\\n\\t\\treturn res[0]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\tdef longestWord(self, words: List[str]) -> str:\\n\\t\\twords.sort()\\n\\t\\tht = {}\\n\\t\\tfor w in words:\\n\\t\\t\\tif len(w) == 1 and w not in ht:\\n\\t\\t\\t\\tht[w] = 1\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tif w[:-1] in ht:\\n\\t\\t\\t\\tht[w] = 1\\n\\t\\ts = sorted(ht.keys(),reverse=True,key=len)\\n\\t\\t#print(s)\\n\\t\\tres = []\\n\\t\\tfor item in s:\\n\\t\\t\\tif len(res) == 0:\\n\\t\\t\\t\\tres.append(item)\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tif len(item) < len(res[0]):\\n\\t\\t\\t\\tbreak\\n\\t\\t\\telse:\\n\\t\\t\\t\\tres.append(item)\\n\\t\\tif len(res) == 0:\\n\\t\\t\\treturn \"\"\\n\\t\\treturn res[0]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 367848,
                "title": "c-trie",
                "content": "```c\\ntypedef struct node {\\n    bool end;\\n    struct node *children[26];\\n} Node;\\n\\nint cmp(const void *a, const void *b) {\\n    return strcmp(*(const char **)a, *(const char **)b);\\n}\\n\\nchar *longestWord(char **words, int wordsSize) {\\n    qsort(words, wordsSize, sizeof(words[0]), cmp);\\n    Node *trie = malloc(sizeof(Node));\\n    for (int i = 0; i < 26; i++) trie->children[i] = NULL;\\n    int max = 0, index = 0;\\n    for (int i = 0; i < wordsSize; i++) {\\n        Node *next = trie;\\n        int temp = 0, len = strlen(words[i]);\\n        for (int j = 0; j < len; j++) {\\n            Node *n;\\n            if (next->children[words[i][j] - \\'a\\'] == NULL) {\\n                n = malloc(sizeof(Node));\\n                for (int i = 0; i < 26; i++) n->children[i] = NULL;\\n                n->end = false;\\n            } else {\\n                n = next->children[words[i][j] - \\'a\\'];\\n            }\\n            if (j == len - 1) n->end = true;\\n            if (n->end == false) break;\\n            next = next->children[words[i][j] - \\'a\\'] = n;\\n            if (next->end == true) temp++;\\n            if (j == len - 1 && temp > max) {\\n                max = temp;\\n                index = i;\\n            }\\n        }\\n    }\\n    return words[index];\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```c\\ntypedef struct node {\\n    bool end;\\n    struct node *children[26];\\n} Node;\\n\\nint cmp(const void *a, const void *b) {\\n    return strcmp(*(const char **)a, *(const char **)b);\\n}\\n\\nchar *longestWord(char **words, int wordsSize) {\\n    qsort(words, wordsSize, sizeof(words[0]), cmp);\\n    Node *trie = malloc(sizeof(Node));\\n    for (int i = 0; i < 26; i++) trie->children[i] = NULL;\\n    int max = 0, index = 0;\\n    for (int i = 0; i < wordsSize; i++) {\\n        Node *next = trie;\\n        int temp = 0, len = strlen(words[i]);\\n        for (int j = 0; j < len; j++) {\\n            Node *n;\\n            if (next->children[words[i][j] - \\'a\\'] == NULL) {\\n                n = malloc(sizeof(Node));\\n                for (int i = 0; i < 26; i++) n->children[i] = NULL;\\n                n->end = false;\\n            } else {\\n                n = next->children[words[i][j] - \\'a\\'];\\n            }\\n            if (j == len - 1) n->end = true;\\n            if (n->end == false) break;\\n            next = next->children[words[i][j] - \\'a\\'] = n;\\n            if (next->end == true) temp++;\\n            if (j == len - 1 && temp > max) {\\n                max = temp;\\n                index = i;\\n            }\\n        }\\n    }\\n    return words[index];\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 160763,
                "title": "why-i-always-get-compile-error",
                "content": "I compiled my Java code locally and it will succeed, but every time I submit on LeetCode it will report \"Line 8: error: cannot find symbol: class Solution\"\\nCan anyone tell me whether my code has an error or the LeetCode has a bug?\\n\\nMy code:\\n```java\\nimport java.util.*;\\nclass Solution {\\n    public String longestWord(String[] words) {\\n        if (null == words || 0 == words.length) return \"\";\\n        Trie root = new Trie();\\n        for (String word : words)\\n            root.insert(word);\\n        List<String> list = new ArrayList<>();\\n        for (String word : words)\\n            if (root.search(word))\\n                list.add(word);\\n        Collections.sort(list, (String a, String b) -> {\\n            if (a.length() == b.length())\\n                return a.compareTo(b);\\n            return b.length() - a.length();\\n        });\\n        return list.get(0);\\n    }\\n    public class Trie {\\n        Trie[] children = new Trie[\\'z\\'-\\'a\\'+1];\\n        public boolean isWord = false;\\n        public int childrenNum = 0;\\n        public Trie get(char c) {\\n            return children[c-\\'a\\'];\\n        }\\n        public void set(char c, Trie t) {\\n            childrenNum++;\\n            children[c-\\'a\\'] = t;\\n        }\\n        public void insert(String word, int i) {\\n            if (word.length() == i) {\\n                isWord = true;\\n                return;\\n            }\\n            char c = word.charAt(i);\\n            Trie child = get(c);\\n            if (null == child) {\\n                child = new Trie();\\n                set(c, child);\\n            }\\n            child.insert(word, i+1);\\n        }\\n        public void insert(String word) {\\n            insert(word, 0);\\n        }\\n        public boolean search(String word, int i) {\\n            if (word.length() == i) {\\n                if (isWord)\\n                    return childrenNum == 0;\\n            }\\n            char c = word.charAt(i);\\n            Trie child = get(c);\\n            if (null == child || !child.isWord) \\n                return false;\\n            return child.search(word, i+1);\\n        }\\n        public boolean search(String word) {\\n            return search(word, 0);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nimport java.util.*;\\nclass Solution {\\n    public String longestWord(String[] words) {\\n        if (null == words || 0 == words.length) return \"\";\\n        Trie root = new Trie();\\n        for (String word : words)\\n            root.insert(word);\\n        List<String> list = new ArrayList<>();\\n        for (String word : words)\\n            if (root.search(word))\\n                list.add(word);\\n        Collections.sort(list, (String a, String b) -> {\\n            if (a.length() == b.length())\\n                return a.compareTo(b);\\n            return b.length() - a.length();\\n        });\\n        return list.get(0);\\n    }\\n    public class Trie {\\n        Trie[] children = new Trie[\\'z\\'-\\'a\\'+1];\\n        public boolean isWord = false;\\n        public int childrenNum = 0;\\n        public Trie get(char c) {\\n            return children[c-\\'a\\'];\\n        }\\n        public void set(char c, Trie t) {\\n            childrenNum++;\\n            children[c-\\'a\\'] = t;\\n        }\\n        public void insert(String word, int i) {\\n            if (word.length() == i) {\\n                isWord = true;\\n                return;\\n            }\\n            char c = word.charAt(i);\\n            Trie child = get(c);\\n            if (null == child) {\\n                child = new Trie();\\n                set(c, child);\\n            }\\n            child.insert(word, i+1);\\n        }\\n        public void insert(String word) {\\n            insert(word, 0);\\n        }\\n        public boolean search(String word, int i) {\\n            if (word.length() == i) {\\n                if (isWord)\\n                    return childrenNum == 0;\\n            }\\n            char c = word.charAt(i);\\n            Trie child = get(c);\\n            if (null == child || !child.isWord) \\n                return false;\\n            return child.search(word, i+1);\\n        }\\n        public boolean search(String word) {\\n            return search(word, 0);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3182159,
                "title": "java-solution-using-tries",
                "content": "# Code\\n```\\nclass TrieNode{\\n  TrieNode[] children;\\n  boolean end;\\n  TrieNode(){\\n    children = new TrieNode[26];\\n    end = false;\\n  }\\n}\\nclass Trie{\\n  public static TrieNode root;\\n  Trie(){\\n    root = new TrieNode();\\n  }\\n  public static void insert(String word){\\n    TrieNode curr = root;\\n    for(int i=0;i<word.length();i++){\\n      char ch = word.charAt(i);\\n      if(curr.children[ch-\\'a\\']==null){\\n        curr.children[ch-\\'a\\'] = new TrieNode();\\n      }\\n      curr = curr.children[ch-\\'a\\'];\\n    }\\n    curr.end = true;\\n  }\\n  public static boolean search(String word){\\n    TrieNode curr = root;\\n    for(int i=0;i<word.length();i++){\\n      char ch = word.charAt(i);\\n      if(curr.children[ch-\\'a\\']==null) return false;\\n      curr = curr.children[ch-\\'a\\'];\\n    }\\n    return curr.end;\\n  }\\n}\\nclass Solution {\\n    public String longestWord(String[] a) {\\n        Trie t = new Trie();\\n        for(String s:a){\\n          t.insert(s);\\n        }\\n        String answer = \"\";\\n        for(String s:a){\\n          boolean flag = false;\\n          for(int i=0;i<s.length();i++){\\n            if(!t.search(s.substring(0,i+1))){\\n              flag = false;\\n              break;\\n            }\\n            else flag = true;\\n          }\\n          if(flag){\\n            if(answer.length()<s.length()) answer = s;\\n            else if(answer.length()==s.length()){\\n              if(answer.compareTo(s)>0) answer = s;\\n              else continue;\\n            }\\n          }\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode{\\n  TrieNode[] children;\\n  boolean end;\\n  TrieNode(){\\n    children = new TrieNode[26];\\n    end = false;\\n  }\\n}\\nclass Trie{\\n  public static TrieNode root;\\n  Trie(){\\n    root = new TrieNode();\\n  }\\n  public static void insert(String word){\\n    TrieNode curr = root;\\n    for(int i=0;i<word.length();i++){\\n      char ch = word.charAt(i);\\n      if(curr.children[ch-\\'a\\']==null){\\n        curr.children[ch-\\'a\\'] = new TrieNode();\\n      }\\n      curr = curr.children[ch-\\'a\\'];\\n    }\\n    curr.end = true;\\n  }\\n  public static boolean search(String word){\\n    TrieNode curr = root;\\n    for(int i=0;i<word.length();i++){\\n      char ch = word.charAt(i);\\n      if(curr.children[ch-\\'a\\']==null) return false;\\n      curr = curr.children[ch-\\'a\\'];\\n    }\\n    return curr.end;\\n  }\\n}\\nclass Solution {\\n    public String longestWord(String[] a) {\\n        Trie t = new Trie();\\n        for(String s:a){\\n          t.insert(s);\\n        }\\n        String answer = \"\";\\n        for(String s:a){\\n          boolean flag = false;\\n          for(int i=0;i<s.length();i++){\\n            if(!t.search(s.substring(0,i+1))){\\n              flag = false;\\n              break;\\n            }\\n            else flag = true;\\n          }\\n          if(flag){\\n            if(answer.length()<s.length()) answer = s;\\n            else if(answer.length()==s.length()){\\n              if(answer.compareTo(s)>0) answer = s;\\n              else continue;\\n            }\\n          }\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3140352,
                "title": "by-using-trie-simple",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public: \\n    struct Node{\\n        Node* children[26];\\n        bool isend = false;\\n    };\\npublic:\\n     Node* root = new Node();\\n     void insert(string &word){\\n         Node*node=root;\\n         for(int i=0; i<word.size(); i++){\\n             int index=word[i]-\\'a\\';\\n             if(!node->children[index]){\\n                 node->children[index]=new Node();\\n             }\\n             node=node->children[index];\\n         }\\n         node->isend=true;\\n     }\\n      bool isValid(string &word){\\n             Node * node = root;\\n                int n = word.size();\\n                   for(int i =0;i<n;i++){    \\n                       int index=word[i]-\\'a\\';   \\n                    node = node->children[index];\\n                    if(node->isend == false) return false;       \\n                }\\n       return true;\\n    }\\n    string longestWord(vector<string>& words) {\\n        string ans =\"\";\\n        for(auto w: words){\\n            insert(w);\\n        }  \\n        for(auto i: words){\\n            if(isValid(i)){\\n                if(i.length() > ans.length()){\\n                    ans =i;\\n                }else if(i.length() == ans.length()){\\n                    ans = min(i, ans);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    public: \\n    struct Node{\\n        Node* children[26];\\n        bool isend = false;\\n    };\\npublic:\\n     Node* root = new Node();\\n     void insert(string &word){\\n         Node*node=root;\\n         for(int i=0; i<word.size(); i++){\\n             int index=word[i]-\\'a\\';\\n             if(!node->children[index]){\\n                 node->children[index]=new Node();\\n             }\\n             node=node->children[index];\\n         }\\n         node->isend=true;\\n     }\\n      bool isValid(string &word){\\n             Node * node = root;\\n                int n = word.size();\\n                   for(int i =0;i<n;i++){    \\n                       int index=word[i]-\\'a\\';   \\n                    node = node->children[index];\\n                    if(node->isend == false) return false;       \\n                }\\n       return true;\\n    }\\n    string longestWord(vector<string>& words) {\\n        string ans =\"\";\\n        for(auto w: words){\\n            insert(w);\\n        }  \\n        for(auto i: words){\\n            if(isValid(i)){\\n                if(i.length() > ans.length()){\\n                    ans =i;\\n                }else if(i.length() == ans.length()){\\n                    ans = min(i, ans);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2951085,
                "title": "o-n-solution-using-queue-in-java",
                "content": "\\n# Approach\\n- Find words in dictionary, adding 1 character at a time. Add such words to queue and iterate. If the queue gets empty we can\\'t move forward anymore by 1 character, then return answer. Adding characters z->a, to get lexicographically smaller word.\\n\\n# Complexity\\n- Time complexity:\\nO(n) :  For each word in the array, we iterate 26 times to find words in dictionary adding 1 character. Therefor it will be run in O(26n) ~ O(n). \\n\\n- Space complexity:\\nO(n) for HashSet.\\n\\n# Code\\n```\\nclass Solution {\\n    public String longestWord(String[] words) {\\n        Set<String> set = new HashSet<>();\\n\\n        for(int i = 0; i < words.length; i++){\\n            set.add(words[i]);\\n        }\\n\\n        Queue<String> q = new LinkedList<>();\\n\\n        q.add(\"\");\\n        String prev = \"\";\\n\\n        while(!q.isEmpty()){\\n            String s = q.poll();\\n            prev = s;\\n            for(int i = 25; i >=0 ; i--){\\n                String key = s + String.valueOf((char) (\\'a\\' + i));\\n                if(set.contains(key)){\\n                    q.add(key);;\\n                }\\n            }\\n        }\\n        return prev;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String longestWord(String[] words) {\\n        Set<String> set = new HashSet<>();\\n\\n        for(int i = 0; i < words.length; i++){\\n            set.add(words[i]);\\n        }\\n\\n        Queue<String> q = new LinkedList<>();\\n\\n        q.add(\"\");\\n        String prev = \"\";\\n\\n        while(!q.isEmpty()){\\n            String s = q.poll();\\n            prev = s;\\n            for(int i = 25; i >=0 ; i--){\\n                String key = s + String.valueOf((char) (\\'a\\' + i));\\n                if(set.contains(key)){\\n                    q.add(key);;\\n                }\\n            }\\n        }\\n        return prev;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1689716,
                "title": "c-simple-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check_valid(string s,vector<string> &words)\\n    {\\n        s.erase(s.size()-1,1);\\n        if(s.size() == 0) return true;\\n        auto it = find(words.begin(),words.end(),s);\\n        if(it == words.end()) return false;\\n        return check_valid(s,words);\\n    }\\n    \\n    string longestWord(vector<string>& words) \\n    {\\n        string ans=\"\";\\n        for(int i=0;i<words.size();i++)\\n        {\\n            bool val = check_valid(words[i],words);\\n            if(val == true)\\n            {\\n                if(words[i].length() > ans.length() || (words[i].length()==ans.length() && words[i] < ans)) ans = words[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool check_valid(string s,vector<string> &words)\\n    {\\n        s.erase(s.size()-1,1);\\n        if(s.size() == 0) return true;\\n        auto it = find(words.begin(),words.end(),s);\\n        if(it == words.end()) return false;\\n        return check_valid(s,words);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1262934,
                "title": "c-2-solns-tries-hashset",
                "content": "```\\nclass Solution {\\npublic:\\n    string longestWord(vector<string>& words) \\n    {\\n        sort(words.begin(), words.end());\\n        string result = \"\";\\n        unordered_set<string> allwords;\\n        \\n        for ( string word : words ) {\\n            if ( word.length() == 1 || allwords.find(word.substr(0,word.length()-1)) != allwords.end() ) {\\n                if ( word.length() > result.length() ) {\\n                    result = word;\\n                }\\n                allwords.insert(word);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    class Node \\n    {\\n    public:\\n        char val;\\n        bool isend;\\n        Node* children[26];\\n        \\n        Node( char ch ) {\\n            val = ch;\\n            isend = false;\\n            for ( int i=0; i<26; i++ ) {\\n                children[i] = NULL;\\n            }\\n        }\\n    };\\n    \\n    Node* root = new Node(\\' \\');\\n    string maxValidWord = \"\";\\n    int maxValidWordSize = INT_MIN;\\n    \\n    void insertIntoTrie ( string word )\\n    {\\n        Node* cur = root;\\n        for ( char ch : word ) {\\n            if ( cur->children[ch-\\'a\\'] == NULL ) {\\n                cur->children[ch-\\'a\\'] = new Node(ch);\\n            }\\n            cur = cur->children[ch-\\'a\\'];\\n        }\\n        cur->isend = true;\\n    }\\n    \\n    void displayAllValidWords ( Node* root, bool valid, string word) \\n    {\\n        if ( root == NULL ) {\\n            return;\\n        }\\n        \\n        word = word + root->val;\\n        \\n        if ( root->val != \\' \\' && !root->isend ) {\\n            valid = false;\\n        }\\n        \\n        if ( valid ) {\\n            int cursize = word.length();\\n            if ( cursize > maxValidWordSize ) {\\n                maxValidWordSize = word.length();\\n                maxValidWord = word.substr(1);\\n            }\\n        }\\n        else {\\n            return;\\n        }\\n        \\n        for ( int i=0; i<26; i++ ) {\\n            displayAllValidWords(root->children[i], valid, word);\\n        }\\n    }\\n    \\n    string longestWord ( vector<string>& words ) \\n    {\\n        for ( string word : words ) {\\n            insertIntoTrie(word);\\n        }\\n        displayAllValidWords(root, true, \"\");\\n        return maxValidWord;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestWord(vector<string>& words) \\n    {\\n        sort(words.begin(), words.end());\\n        string result = \"\";\\n        unordered_set<string> allwords;\\n        \\n        for ( string word : words ) {\\n            if ( word.length() == 1 || allwords.find(word.substr(0,word.length()-1)) != allwords.end() ) {\\n                if ( word.length() > result.length() ) {\\n                    result = word;\\n                }\\n                allwords.insert(word);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    class Node \\n    {\\n    public:\\n        char val;\\n        bool isend;\\n        Node* children[26];\\n        \\n        Node( char ch ) {\\n            val = ch;\\n            isend = false;\\n            for ( int i=0; i<26; i++ ) {\\n                children[i] = NULL;\\n            }\\n        }\\n    };\\n    \\n    Node* root = new Node(\\' \\');\\n    string maxValidWord = \"\";\\n    int maxValidWordSize = INT_MIN;\\n    \\n    void insertIntoTrie ( string word )\\n    {\\n        Node* cur = root;\\n        for ( char ch : word ) {\\n            if ( cur->children[ch-\\'a\\'] == NULL ) {\\n                cur->children[ch-\\'a\\'] = new Node(ch);\\n            }\\n            cur = cur->children[ch-\\'a\\'];\\n        }\\n        cur->isend = true;\\n    }\\n    \\n    void displayAllValidWords ( Node* root, bool valid, string word) \\n    {\\n        if ( root == NULL ) {\\n            return;\\n        }\\n        \\n        word = word + root->val;\\n        \\n        if ( root->val != \\' \\' && !root->isend ) {\\n            valid = false;\\n        }\\n        \\n        if ( valid ) {\\n            int cursize = word.length();\\n            if ( cursize > maxValidWordSize ) {\\n                maxValidWordSize = word.length();\\n                maxValidWord = word.substr(1);\\n            }\\n        }\\n        else {\\n            return;\\n        }\\n        \\n        for ( int i=0; i<26; i++ ) {\\n            displayAllValidWords(root->children[i], valid, word);\\n        }\\n    }\\n    \\n    string longestWord ( vector<string>& words ) \\n    {\\n        for ( string word : words ) {\\n            insertIntoTrie(word);\\n        }\\n        displayAllValidWords(root, true, \"\");\\n        return maxValidWord;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1064991,
                "title": "java-hashset-stringbuilder-5ms-beats-99-54-o-words-length-words-i-length",
                "content": "\\n    public String longestWord(String[] words) {\\n\\n\\t\\tString ans = \"\";\\n\\t\\tHashSet<String> set = new HashSet<String>();\\n\\t\\tfor (String word : words)\\n\\t\\t\\tset.add(word);\\n\\n\\t\\tfor (String word : words) {\\n\\t\\t\\tif ((word.length() > ans.length()) || (word.length() == ans.length() && word.compareTo(ans) < 0)) {\\n\\t\\t\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\t\\t\\tboolean good = true;\\n\\t\\t\\t\\tfor (int i = 0; i < word.length() - 1; i++) {\\n\\t\\t\\t\\t\\tsb.append(word.charAt(i));\\n\\t\\t\\t\\t\\tif (!set.contains(sb.toString())) {\\n\\t\\t\\t\\t\\t\\tgood = false;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (good)\\n\\t\\t\\t\\t\\tans = word;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n",
                "solutionTags": [],
                "code": "\\n    public String longestWord(String[] words) {\\n\\n\\t\\tString ans = \"\";\\n\\t\\tHashSet<String> set = new HashSet<String>();\\n\\t\\tfor (String word : words)\\n\\t\\t\\tset.add(word);\\n\\n\\t\\tfor (String word : words) {\\n\\t\\t\\tif ((word.length() > ans.length()) || (word.length() == ans.length() && word.compareTo(ans) < 0)) {\\n\\t\\t\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\t\\t\\tboolean good = true;\\n\\t\\t\\t\\tfor (int i = 0; i < word.length() - 1; i++) {\\n\\t\\t\\t\\t\\tsb.append(word.charAt(i));\\n\\t\\t\\t\\t\\tif (!set.contains(sb.toString())) {\\n\\t\\t\\t\\t\\t\\tgood = false;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (good)\\n\\t\\t\\t\\t\\tans = word;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 775190,
                "title": "javascript-set-easiest",
                "content": "```\\n/*\\nSee this is prefix Tree(Trie)\\nSort dict: solve all prefix words and get lexicographical order\\nTraverse dict:\\n1step check if set has word before itself, if yes, valid\\n2step check if need update res compare string.length\\n3step then find longest word with smallest lexicographical order\\n*/\\nvar longestWord = function(words) {\\n    if (!words || words.length == 0) return \"\";\\n    let res = \"\";\\n    let set = new Set(); //store valid word\\n    words.sort(); //sort string \\n    for (let word of words){\\n        let prev = word.substring(0, word.length -1);\\n        if (word.length == 1 || set.has(prev)){  //store only one char, or has word before itself\\n            res = (word.length > res.length) ? word : res;\\n            set.add(word);\\n        }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/*\\nSee this is prefix Tree(Trie)\\nSort dict: solve all prefix words and get lexicographical order\\nTraverse dict:\\n1step check if set has word before itself, if yes, valid\\n2step check if need update res compare string.length\\n3step then find longest word with smallest lexicographical order\\n*/\\nvar longestWord = function(words) {\\n    if (!words || words.length == 0) return \"\";\\n    let res = \"\";\\n    let set = new Set(); //store valid word\\n    words.sort(); //sort string \\n    for (let word of words){\\n        let prev = word.substring(0, word.length -1);\\n        if (word.length == 1 || set.has(prev)){  //store only one char, or has word before itself\\n            res = (word.length > res.length) ? word : res;\\n            set.add(word);\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 709053,
                "title": "c-python-solutions-using-trie",
                "content": "C++ solution,\\n```\\nclass TrieNode {\\npublic:\\n\\tunordered_map<char,shared_ptr<TrieNode>> children;\\n\\tbool end = false;\\n};\\n\\nclass Trie {\\npublic:\\n\\tTrie () {\\n\\t\\troot = make_shared<TrieNode>();\\n\\t}\\n\\n\\tvoid insert(string word) {\\n\\t\\tshared_ptr<TrieNode> cur = root;\\n\\n\\t\\tfor (auto& c : word) {\\n\\t\\t\\tif (!cur->children.count(c))\\n\\t\\t\\t\\tcur->children[c] = shared_ptr<TrieNode>(new TrieNode);\\n\\n\\t\\t\\tcur = cur->children[c];\\n\\t\\t}\\n\\n\\t\\tcur->end = true;\\n\\t}\\n\\n\\tstring helper(shared_ptr<TrieNode> node, string partial_res) {\\n\\t\\tstring res = partial_res;\\n\\n\\t\\tfor (auto& i : node->children)\\n\\t\\t\\tif (i.second->end) {\\n\\t\\t\\t\\tstring res_ = helper(i.second, partial_res + i.first);\\n\\n\\t\\t\\t\\tif (res_.size() > res.size() || (res_.size() == res.size() && res_ < res))\\n\\t\\t\\t\\t\\tres = res_;\\n\\t\\t\\t}\\n\\n\\t\\treturn res;\\n\\t}\\n\\n\\tstring longest_word() {\\n\\t\\treturn helper(root, \"\");\\n\\t}\\n\\nprivate:\\n\\tshared_ptr<TrieNode> root;\\n};\\n\\n\\n//\\nclass Solution {\\npublic:\\n\\tstring longestWord(vector<string>& words) {\\n\\t\\tTrie T;\\n\\n\\t\\tfor (auto& word : words)\\n\\t\\t\\tT.insert(word);\\n\\n\\t\\treturn T.longest_word();\\n\\t}\\n};\\n```\\n\\nPython solution,\\n```\\nclass TrieNode:\\n\\tdef __init__(self):\\n\\t\\tself.children = {}\\n\\t\\tself.end = False\\n\\nclass Trie:\\n\\tdef __init__(self):\\n\\t\\tself.root = TrieNode()\\n\\n\\tdef insert(self, word):\\n\\t\\tcur = self.root\\n\\n\\t\\tfor c in word:\\n\\t\\t\\tif c not in cur.children:\\n\\t\\t\\t\\tcur.children[c] = TrieNode()\\n\\n\\t\\t\\tcur = cur.children[c]\\n\\n\\t\\tcur.end = True\\n\\n\\tdef helper(self, node, partial_res):\\n\\t\\tres = partial_res\\n\\n\\t\\tfor c, child in node.children.items():\\n\\t\\t\\tif child.end:\\n\\t\\t\\t\\tpot = self.helper(child, partial_res + c)\\n\\t\\t\\t\\tif len(pot) > len(res) or (len(pot) == len(res) and pot < res):\\n\\t\\t\\t\\t\\tres = pot\\n\\n\\t\\treturn res\\n\\n\\tdef longest_word(self):\\n\\t\\treturn self.helper(self.root, \\'\\')\\n\\nclass Solution:\\n\\tdef longestWord(self, words):\\n\\t\\tT = Trie()\\n\\n\\t\\tfor word in words:\\n\\t\\t\\tT.insert(word)\\n\\n\\t\\treturn T.longest_word()\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nclass TrieNode {\\npublic:\\n\\tunordered_map<char,shared_ptr<TrieNode>> children;\\n\\tbool end = false;\\n};\\n\\nclass Trie {\\npublic:\\n\\tTrie () {\\n\\t\\troot = make_shared<TrieNode>();\\n\\t}\\n\\n\\tvoid insert(string word) {\\n\\t\\tshared_ptr<TrieNode> cur = root;\\n\\n\\t\\tfor (auto& c : word) {\\n\\t\\t\\tif (!cur->children.count(c))\\n\\t\\t\\t\\tcur->children[c] = shared_ptr<TrieNode>(new TrieNode);\\n\\n\\t\\t\\tcur = cur->children[c];\\n\\t\\t}\\n\\n\\t\\tcur->end = true;\\n\\t}\\n\\n\\tstring helper(shared_ptr<TrieNode> node, string partial_res) {\\n\\t\\tstring res = partial_res;\\n\\n\\t\\tfor (auto& i : node->children)\\n\\t\\t\\tif (i.second->end) {\\n\\t\\t\\t\\tstring res_ = helper(i.second, partial_res + i.first);\\n\\n\\t\\t\\t\\tif (res_.size() > res.size() || (res_.size() == res.size() && res_ < res))\\n\\t\\t\\t\\t\\tres = res_;\\n\\t\\t\\t}\\n\\n\\t\\treturn res;\\n\\t}\\n\\n\\tstring longest_word() {\\n\\t\\treturn helper(root, \"\");\\n\\t}\\n\\nprivate:\\n\\tshared_ptr<TrieNode> root;\\n};\\n\\n\\n//\\nclass Solution {\\npublic:\\n\\tstring longestWord(vector<string>& words) {\\n\\t\\tTrie T;\\n\\n\\t\\tfor (auto& word : words)\\n\\t\\t\\tT.insert(word);\\n\\n\\t\\treturn T.longest_word();\\n\\t}\\n};\\n```\n```\\nclass TrieNode:\\n\\tdef __init__(self):\\n\\t\\tself.children = {}\\n\\t\\tself.end = False\\n\\nclass Trie:\\n\\tdef __init__(self):\\n\\t\\tself.root = TrieNode()\\n\\n\\tdef insert(self, word):\\n\\t\\tcur = self.root\\n\\n\\t\\tfor c in word:\\n\\t\\t\\tif c not in cur.children:\\n\\t\\t\\t\\tcur.children[c] = TrieNode()\\n\\n\\t\\t\\tcur = cur.children[c]\\n\\n\\t\\tcur.end = True\\n\\n\\tdef helper(self, node, partial_res):\\n\\t\\tres = partial_res\\n\\n\\t\\tfor c, child in node.children.items():\\n\\t\\t\\tif child.end:\\n\\t\\t\\t\\tpot = self.helper(child, partial_res + c)\\n\\t\\t\\t\\tif len(pot) > len(res) or (len(pot) == len(res) and pot < res):\\n\\t\\t\\t\\t\\tres = pot\\n\\n\\t\\treturn res\\n\\n\\tdef longest_word(self):\\n\\t\\treturn self.helper(self.root, \\'\\')\\n\\nclass Solution:\\n\\tdef longestWord(self, words):\\n\\t\\tT = Trie()\\n\\n\\t\\tfor word in words:\\n\\t\\t\\tT.insert(word)\\n\\n\\t\\treturn T.longest_word()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 560359,
                "title": "java-hashset-intuitive-solution",
                "content": "```\\nclass Solution {\\n    public String longestWord(String[] words) {\\n       Arrays.sort(words);\\n       HashSet<String> hash = new HashSet();\\n       String result = \"\";\\n       for(String str : words){\\n           if(str.length() == 1 || hash.contains(str.substring(0, str.length()-1))){\\n               if(str.length() > result.length()) result = str;\\n               hash.add(str);\\n           }\\n       }\\n       return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String longestWord(String[] words) {\\n       Arrays.sort(words);\\n       HashSet<String> hash = new HashSet();\\n       String result = \"\";\\n       for(String str : words){\\n           if(str.length() == 1 || hash.contains(str.substring(0, str.length()-1))){\\n               if(str.length() > result.length()) result = str;\\n               hash.add(str);\\n           }\\n       }\\n       return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 450549,
                "title": "c-trie-96-time-100-memory",
                "content": "```\\nstruct Node {\\n    bool is = false;\\n    int children[26] = {0};\\n} nodes[301000];\\nint cnt = 1;\\n\\nvoid insert(const string& s) {\\n    int cur = 1;\\n    for (char c : s) {\\n        if (!nodes[cur].children[c - \\'a\\']) {\\n            ++cnt;\\n            memset(&nodes[cnt], 0, sizeof(nodes[cnt]));\\n            nodes[cur].children[c - \\'a\\'] = cnt;\\n        }\\n        cur = nodes[cur].children[c - \\'a\\'];\\n    }\\n    nodes[cur].is = true;\\n}\\n\\nstring res;\\nstring s;\\n\\nvoid dfs(int cur) {\\n    for (int i = 0; i < 26; ++i) {\\n        int child = nodes[cur].children[i];\\n        if (!child || !nodes[child].is) {\\n            continue;\\n        }\\n        s.push_back(\\'a\\' + i);\\n        if (s.size() > res.size()) {\\n            res = s;\\n        }\\n        dfs(child);\\n        s.pop_back();\\n    }\\n}\\n\\nclass Solution {\\npublic:\\n    string longestWord(vector<string>& words) {\\n        cnt = 1;\\n        memset(&nodes[1], 0, sizeof(nodes[1]));\\n        for (const string& word : words) {\\n            insert(word);\\n        }\\n        res.clear();\\n        s.clear();\\n        dfs(1);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstruct Node {\\n    bool is = false;\\n    int children[26] = {0};\\n} nodes[301000];\\nint cnt = 1;\\n\\nvoid insert(const string& s) {\\n    int cur = 1;\\n    for (char c : s) {\\n        if (!nodes[cur].children[c - \\'a\\']) {\\n            ++cnt;\\n            memset(&nodes[cnt], 0, sizeof(nodes[cnt]));\\n            nodes[cur].children[c - \\'a\\'] = cnt;\\n        }\\n        cur = nodes[cur].children[c - \\'a\\'];\\n    }\\n    nodes[cur].is = true;\\n}\\n\\nstring res;\\nstring s;\\n\\nvoid dfs(int cur) {\\n    for (int i = 0; i < 26; ++i) {\\n        int child = nodes[cur].children[i];\\n        if (!child || !nodes[child].is) {\\n            continue;\\n        }\\n        s.push_back(\\'a\\' + i);\\n        if (s.size() > res.size()) {\\n            res = s;\\n        }\\n        dfs(child);\\n        s.pop_back();\\n    }\\n}\\n\\nclass Solution {\\npublic:\\n    string longestWord(vector<string>& words) {\\n        cnt = 1;\\n        memset(&nodes[1], 0, sizeof(nodes[1]));\\n        for (const string& word : words) {\\n            insert(word);\\n        }\\n        res.clear();\\n        s.clear();\\n        dfs(1);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 300575,
                "title": "javascript-beat-100",
                "content": "```\\nvar longestWord = function(words) { \\n    let set = new Set(words);\\n    let res = \"\";\\n    words.forEach(a => {\\n        if(a.length < res.length) return;\\n        if(a.length == res.length && a > res) return;\\n        for(let i = a.length - 1; i> 0 ; i--) {\\n            if( !set.has( a.substring(0, i))) return\\n            \\n        }\\n        res = a;\\n    })\\n    return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar longestWord = function(words) { \\n    let set = new Set(words);\\n    let res = \"\";\\n    words.forEach(a => {\\n        if(a.length < res.length) return;\\n        if(a.length == res.length && a > res) return;\\n        for(let i = a.length - 1; i> 0 ; i--) {\\n            if( !set.has( a.substring(0, i))) return\\n            \\n        }\\n        res = a;\\n    })\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 184246,
                "title": "python3-trie-solution",
                "content": "I don't use `defaultdict`, just a plain OO solution..\n\n```\nclass TrieNode:\n    def __init__(self, word='', end=False):\n        self.end = end\n        self.word = word\n        self.children = {}\n\nclass Solution:\n    def longestWord(self, words):\n        # build Trie\n        root = TrieNode()\n        for word in words:\n            cur = root\n            for i, ch in enumerate(word):\n                if ch in cur.children:\n                    cur = cur.children[ch]\n                else:\n                    nextNode = TrieNode()\n                    cur.children[ch] = nextNode\n                    cur = nextNode\n                if i == len(word) - 1:\n                    cur.end = True\n                    cur.word = word\n        \n        # check Trie\n        stack = list(root.children.values())\n        res = ''\n        while stack:\n            node = stack.pop(-1)\n            if node.end:\n                if len(res) < len(node.word) or (len(res) == len(node.word) and res > node.word):\n                    res = node.word\n                stack.extend(list(node.children.values()))\n        return res\n```",
                "solutionTags": [],
                "code": "```\nclass TrieNode:\n    def __init__(self, word='', end=False):\n        self.end = end\n        self.word = word\n        self.children = {}\n\nclass Solution:\n    def longestWord(self, words):\n        # build Trie\n        root = TrieNode()\n        for word in words:\n            cur = root\n            for i, ch in enumerate(word):\n                if ch in cur.children:\n                    cur = cur.children[ch]\n                else:\n                    nextNode = TrieNode()\n                    cur.children[ch] = nextNode\n                    cur = nextNode\n                if i == len(word) - 1:\n                    cur.end = True\n                    cur.word = word\n        \n        # check Trie\n        stack = list(root.children.values())\n        res = ''\n        while stack:\n            node = stack.pop(-1)\n            if node.end:\n                if len(res) < len(node.word) or (len(res) == len(node.word) and res > node.word):\n                    res = node.word\n                stack.extend(list(node.children.values()))\n        return res\n```",
                "codeTag": "Java"
            },
            {
                "id": 109149,
                "title": "easy-to-understand-using-set-c-with-explanation",
                "content": "Pretty straightforward implementation:\\n\\n````\\nclass Solution {\\npublic:\\n    \\n//The comparator is used for sorting the set elements when they are inserted.\\n    struct myComp {\\n        bool operator()(auto& lhs, auto& rhs) const{\\n            if(lhs.size() > rhs.size())\\n                return true;\\n            if(lhs.size() == rhs.size())\\n                return lhs<rhs;\\n            return false;\\n        }\\n    };\\n    \\n    string longestWord(vector<string>& words) {\\n        if(words.empty())\\n            return \"\";\\n        \\n        //create a set such that the elements are ordered as per their decreasing lengths.  If the lengths are equal, then they are ordered lexicographically.  \\n        set<string, myComp> s(words.begin(), words.end());\\n        \\n        int i=1;\\n        for(auto& each : s) {\\n            for(i=1; i<each.size(); i++) {\\n                //Find the substring starting from the 0th character to `i`\\n                string str = each.substr(0, i);\\n                if(s.find(str)==s.end())\\n                    break;\\n            }\\n            if (i==each.size()) return each;\\n        }\\n        \\n        return \"\";\\n    }\\n};\\n````",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    \\n//The comparator is used for sorting the set elements when they are inserted.\\n    struct myComp {\\n        bool operator()(auto& lhs, auto& rhs) const{\\n            if(lhs.size() > rhs.size())\\n                return true;\\n            if(lhs.size() == rhs.size())\\n                return lhs<rhs;\\n            return false;\\n        }\\n    };\\n    \\n    string longestWord(vector<string>& words) {\\n        if(words.empty())\\n            return \"\";\\n        \\n        //create a set such that the elements are ordered as per their decreasing lengths.  If the lengths are equal, then they are ordered lexicographically.  \\n        set<string, myComp> s(words.begin(), words.end());\\n        \\n        int i=1;\\n        for(auto& each : s) {\\n            for(i=1; i<each.size(); i++) {\\n                //Find the substring starting from the 0th character to `i`\\n                string str = each.substr(0, i);\\n                if(s.find(str)==s.end())\\n                    break;\\n            }\\n            if (i==each.size()) return each;\\n        }\\n        \\n        return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3458213,
                "title": "easy-trie-c-solution",
                "content": "```\\nclass TrieNode {\\npublic:\\n    TrieNode* children[26];\\n    bool isEnd;\\n\\n    TrieNode() {\\n        memset(children, 0, sizeof(children));\\n        isEnd = false;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n\\n    TrieNode *root;\\n\\n    void addWord(string word) {\\n        TrieNode *curr = root;\\n        for(auto ch: word) {\\n            int index = ch - \\'a\\';\\n            if(curr->children[index] == NULL) {\\n                curr->children[index] = new TrieNode();\\n            }\\n            curr = curr->children[index];\\n        }\\n        curr->isEnd = true;\\n    }\\n\\n    bool search(string word) {\\n        TrieNode *curr = root;\\n        for(auto ch: word) {\\n            int index = ch - \\'a\\';\\n            if(curr->children[index] == NULL) {\\n                return false;\\n            }\\n            curr = curr->children[index];\\n        }\\n        if(curr != NULL and curr->isEnd == true) {\\n            return true;\\n        }  \\n        return false;\\n    }\\n\\n    bool isValid(string word) {\\n        TrieNode *curr = root;\\n        for(auto ch: word) {\\n            int index = ch - \\'a\\';\\n            curr = curr->children[index];\\n            if(!curr->isEnd) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    string longestWord(vector<string>& words) {\\n\\n        // My approach is to make a trie and see those terminal nodes who have already \\n        // have the terminal nodes in their path i.e count == n-1;\\n        // make a max count and update the answer \\n\\n        root = new TrieNode();\\n\\n        for(auto word: words) {\\n            addWord(word);\\n        }\\n        string ans = \"\";\\n        for(auto word: words) {\\n            if(isValid(word)) {\\n                if(word.size() > ans.size()) {\\n                    ans = word;\\n                } else if(word.size() == ans.size()) {\\n                    ans = min(ans, word);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode {\\npublic:\\n    TrieNode* children[26];\\n    bool isEnd;\\n\\n    TrieNode() {\\n        memset(children, 0, sizeof(children));\\n        isEnd = false;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n\\n    TrieNode *root;\\n\\n    void addWord(string word) {\\n        TrieNode *curr = root;\\n        for(auto ch: word) {\\n            int index = ch - \\'a\\';\\n            if(curr->children[index] == NULL) {\\n                curr->children[index] = new TrieNode();\\n            }\\n            curr = curr->children[index];\\n        }\\n        curr->isEnd = true;\\n    }\\n\\n    bool search(string word) {\\n        TrieNode *curr = root;\\n        for(auto ch: word) {\\n            int index = ch - \\'a\\';\\n            if(curr->children[index] == NULL) {\\n                return false;\\n            }\\n            curr = curr->children[index];\\n        }\\n        if(curr != NULL and curr->isEnd == true) {\\n            return true;\\n        }  \\n        return false;\\n    }\\n\\n    bool isValid(string word) {\\n        TrieNode *curr = root;\\n        for(auto ch: word) {\\n            int index = ch - \\'a\\';\\n            curr = curr->children[index];\\n            if(!curr->isEnd) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    string longestWord(vector<string>& words) {\\n\\n        // My approach is to make a trie and see those terminal nodes who have already \\n        // have the terminal nodes in their path i.e count == n-1;\\n        // make a max count and update the answer \\n\\n        root = new TrieNode();\\n\\n        for(auto word: words) {\\n            addWord(word);\\n        }\\n        string ans = \"\";\\n        for(auto word: words) {\\n            if(isValid(word)) {\\n                if(word.size() > ans.size()) {\\n                    ans = word;\\n                } else if(word.size() == ans.size()) {\\n                    ans = min(ans, word);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3440604,
                "title": "solution",
                "content": "```C++ []\\nstruct TrieNode {\\npublic:\\n    TrieNode() :  is_end{false} {\\n        for (int i = 0; i < 26; i++) children[i] = nullptr;\\n    }  \\npublic:\\n    TrieNode* children[26];\\n    bool is_end;\\n};\\nclass Trie {\\npublic:\\n    Trie() : root_{new TrieNode()} {}\\n    void insert(const std::string& str) {\\n        TrieNode* p = root_;\\n        for (const auto& c : str) {\\n            if (p->children[c - \\'a\\'] == nullptr) {\\n                p->children[c - \\'a\\'] = new TrieNode();\\n            }\\n            p = p->children[c - \\'a\\'];\\n        }\\n        p->is_end = true;\\n    }\\n    TrieNode* getRoot() {\\n        return root_;\\n    }\\nprivate:\\n    TrieNode* root_;\\n};\\nclass Solution {\\npublic:\\n    string longestWord(vector<string>& words) {\\n        auto trie = std::make_unique<Trie>();\\n        for (const auto& word : words) {\\n            trie->insert(word);\\n        }\\n        TrieNode* root = trie->getRoot();\\n        std::string curr_str;\\n        std::string res;\\n        dfs(root, curr_str, res);\\n        return res;\\n    }\\n    void dfs(TrieNode* curr_node, std::string& curr_str, std::string& res) {\\n        if (!curr_node) return;\\n        if (curr_str.length() > res.length()) res = curr_str;\\n        for (int i = 0; i < 26; i++) {\\n            if (curr_node->children[i] && curr_node->children[i]->is_end) {\\n                curr_str.push_back(static_cast<char>(\\'a\\' + i)); \\n                dfs(curr_node->children[i], curr_str, res);\\n                curr_str.pop_back();\\n            }\\n        }\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def longestWord(self, words: List[str]) -> str:\\n        words.sort(key=len)\\n        buildable = set()\\n\\n        for w in words:\\n            pre = w[:-1]\\n            if not pre or pre in buildable:\\n                buildable.add(w)\\n\\n        res = \\'\\'\\n        for w in buildable:\\n            if len(w) > len(res) or (len(w) == len(res) and w < res):\\n                res = w\\n        return res\\n```\\n\\n```Java []\\nclass Solution {\\n    String result = \"\";\\n    public String longestWord(String[] words) {\\n        TrieNode root = new TrieNode();\\n        for (String word: words) {\\n            buildTrie(word, root);\\n        }\\n        dfs(root);\\n        return result;\\n    }\\n    private void dfs(TrieNode node) {\\n        if (node == null) return;\\n        if (node.word != null) {\\n            result = node.word.length() > result.length() ? node.word : result;\\n        }\\n        for (TrieNode child: node.children) {\\n            if (child != null && child.word != null)\\n                dfs(child);\\n        }   \\n    }\\n    private void buildTrie(String word, TrieNode node) {\\n        for (int i = 0; i < word.length(); i++) {\\n            char c = word.charAt(i);\\n            if (node.children[c - \\'a\\'] == null) {\\n                node.children[c - \\'a\\'] = new TrieNode();\\n            }\\n            node = node.children[c - \\'a\\'];\\n        }\\n        node.word = word;\\n    }\\n    class TrieNode {\\n        TrieNode[] children;\\n        String word;\\n        TrieNode() {\\n            children = new TrieNode[26];\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nstruct TrieNode {\\npublic:\\n    TrieNode() :  is_end{false} {\\n        for (int i = 0; i < 26; i++) children[i] = nullptr;\\n    }  \\npublic:\\n    TrieNode* children[26];\\n    bool is_end;\\n};\\nclass Trie {\\npublic:\\n    Trie() : root_{new TrieNode()} {}\\n    void insert(const std::string& str) {\\n        TrieNode* p = root_;\\n        for (const auto& c : str) {\\n            if (p->children[c - \\'a\\'] == nullptr) {\\n                p->children[c - \\'a\\'] = new TrieNode();\\n            }\\n            p = p->children[c - \\'a\\'];\\n        }\\n        p->is_end = true;\\n    }\\n    TrieNode* getRoot() {\\n        return root_;\\n    }\\nprivate:\\n    TrieNode* root_;\\n};\\nclass Solution {\\npublic:\\n    string longestWord(vector<string>& words) {\\n        auto trie = std::make_unique<Trie>();\\n        for (const auto& word : words) {\\n            trie->insert(word);\\n        }\\n        TrieNode* root = trie->getRoot();\\n        std::string curr_str;\\n        std::string res;\\n        dfs(root, curr_str, res);\\n        return res;\\n    }\\n    void dfs(TrieNode* curr_node, std::string& curr_str, std::string& res) {\\n        if (!curr_node) return;\\n        if (curr_str.length() > res.length()) res = curr_str;\\n        for (int i = 0; i < 26; i++) {\\n            if (curr_node->children[i] && curr_node->children[i]->is_end) {\\n                curr_str.push_back(static_cast<char>(\\'a\\' + i)); \\n                dfs(curr_node->children[i], curr_str, res);\\n                curr_str.pop_back();\\n            }\\n        }\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def longestWord(self, words: List[str]) -> str:\\n        words.sort(key=len)\\n        buildable = set()\\n\\n        for w in words:\\n            pre = w[:-1]\\n            if not pre or pre in buildable:\\n                buildable.add(w)\\n\\n        res = \\'\\'\\n        for w in buildable:\\n            if len(w) > len(res) or (len(w) == len(res) and w < res):\\n                res = w\\n        return res\\n```\n```Java []\\nclass Solution {\\n    String result = \"\";\\n    public String longestWord(String[] words) {\\n        TrieNode root = new TrieNode();\\n        for (String word: words) {\\n            buildTrie(word, root);\\n        }\\n        dfs(root);\\n        return result;\\n    }\\n    private void dfs(TrieNode node) {\\n        if (node == null) return;\\n        if (node.word != null) {\\n            result = node.word.length() > result.length() ? node.word : result;\\n        }\\n        for (TrieNode child: node.children) {\\n            if (child != null && child.word != null)\\n                dfs(child);\\n        }   \\n    }\\n    private void buildTrie(String word, TrieNode node) {\\n        for (int i = 0; i < word.length(); i++) {\\n            char c = word.charAt(i);\\n            if (node.children[c - \\'a\\'] == null) {\\n                node.children[c - \\'a\\'] = new TrieNode();\\n            }\\n            node = node.children[c - \\'a\\'];\\n        }\\n        node.word = word;\\n    }\\n    class TrieNode {\\n        TrieNode[] children;\\n        String word;\\n        TrieNode() {\\n            children = new TrieNode[26];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3091472,
                "title": "c-o-n-solution-using-set",
                "content": "\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // bool check()\\n    string longestWord(vector<string>& words) {\\n        string ans=\"\";\\n        unordered_set<string> s(words.begin(),words.end());\\n        for(auto x:words){\\n            int i=0;\\n            while(i<x.size()){\\n                if(s.find(x.substr(0,i+1))!=s.end())\\n                    i++;\\n                else break;\\n            }\\n            if(i==x.size()){\\n                if(x.size()>ans.size()){\\n                    ans=x;\\n                }\\n                if(x.size()==ans.size()){\\n                    ans=min(ans,x);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n*if u like pls upvote:)*",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // bool check()\\n    string longestWord(vector<string>& words) {\\n        string ans=\"\";\\n        unordered_set<string> s(words.begin(),words.end());\\n        for(auto x:words){\\n            int i=0;\\n            while(i<x.size()){\\n                if(s.find(x.substr(0,i+1))!=s.end())\\n                    i++;\\n                else break;\\n            }\\n            if(i==x.size()){\\n                if(x.size()>ans.size()){\\n                    ans=x;\\n                }\\n                if(x.size()==ans.size()){\\n                    ans=min(ans,x);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2921987,
                "title": "easy-trie-solution-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    struct Node {\\n        Node * links[26];\\n        bool flag = false;\\n        bool isContains(char ch){       // Node has ch or not\\n            return links[ch-\\'a\\'] != NULL;\\n        }\\n        void put (char ch, Node * node){\\n            links[ch-\\'a\\'] = node;\\n        }\\n        Node* get(char ch){\\n            return links[ch-\\'a\\'];\\n        }\\n    };\\n    class Trie {\\n    private : Node * root;\\n    public:\\n        Trie() {\\n            root = new Node();\\n        }\\n        \\n        void insert(string word) {\\n            Node * node = root;\\n            int n = word.size();\\n            for(int i = 0;i<n;i++){\\n                if(!(node ->isContains(word[i]))){       // if node doesn\\'t contain word[i]\\n                    node->put(word[i],new Node());\\n                }\\n                node = node->get(word[i]);          // move forward\\n            }\\n            node->flag = true;                      // word is end here mark flag as true \\n        }\\n        bool isComplete(string &word){\\n                Node * node = root;\\n                int n = word.size();\\n                for(int i =0;i<n;i++){         // already inserted the string so it will always contain so need to check isContain\\n                    node = node->get(word[i]);\\n                    if(node->flag == false) return false;       // check flag in each step to assure that all the prefixes of word exists\\n                }\\n                return true;\\n            }\\n    };\\n    string longestWord(vector<string>& words) {\\n        Trie trie;\\n        for(auto i : words){\\n            trie.insert(i);\\n        }\\n            string ans = \"\";\\n        for(auto i : words){\\n            if(trie.isComplete(i)){\\n                if(ans.size()<i.size()) ans = i;\\n                if(ans.size() == i.size()) ans = min(ans,i);\\n            }    \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct Node {\\n        Node * links[26];\\n        bool flag = false;\\n        bool isContains(char ch){       // Node has ch or not\\n            return links[ch-\\'a\\'] != NULL;\\n        }\\n        void put (char ch, Node * node){\\n            links[ch-\\'a\\'] = node;\\n        }\\n        Node* get(char ch){\\n            return links[ch-\\'a\\'];\\n        }\\n    };\\n    class Trie {\\n    private : Node * root;\\n    public:\\n        Trie() {\\n            root = new Node();\\n        }\\n        \\n        void insert(string word) {\\n            Node * node = root;\\n            int n = word.size();\\n            for(int i = 0;i<n;i++){\\n                if(!(node ->isContains(word[i]))){       // if node doesn\\'t contain word[i]\\n                    node->put(word[i],new Node());\\n                }\\n                node = node->get(word[i]);          // move forward\\n            }\\n            node->flag = true;                      // word is end here mark flag as true \\n        }\\n        bool isComplete(string &word){\\n                Node * node = root;\\n                int n = word.size();\\n                for(int i =0;i<n;i++){         // already inserted the string so it will always contain so need to check isContain\\n                    node = node->get(word[i]);\\n                    if(node->flag == false) return false;       // check flag in each step to assure that all the prefixes of word exists\\n                }\\n                return true;\\n            }\\n    };\\n    string longestWord(vector<string>& words) {\\n        Trie trie;\\n        for(auto i : words){\\n            trie.insert(i);\\n        }\\n            string ans = \"\";\\n        for(auto i : words){\\n            if(trie.isComplete(i)){\\n                if(ans.size()<i.size()) ans = i;\\n                if(ans.size() == i.size()) ans = min(ans,i);\\n            }    \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2733662,
                "title": "no-sorting-required",
                "content": "```\\nclass Solution {\\n    class trie{\\n        struct node{\\n            node* links[26];\\n            bool flag=false;\\n        };\\n    public:\\n        node* root;\\n        trie(){\\n            root=new node();\\n        }\\n        void insert(string word){\\n            node* nd=root;\\n            for(int i=0;i<word.size();i++){\\n                if(nd->links[word[i]-\\'a\\']==NULL){\\n                    nd->links[word[i]-\\'a\\']=new node();\\n                }\\n                nd=nd->links[word[i]-\\'a\\'];\\n            }\\n            nd->flag=true;\\n        }\\n        bool search(string word){\\n            node* nd=root;\\n            for(int i=0;i<word.size();i++){\\n                if(nd->links[word[i]-\\'a\\']==nullptr)\\n                    return false;\\n                nd=nd->links[word[i]-\\'a\\'];\\n            }\\n            return nd->flag;\\n        }\\n    };\\npublic:\\n    string longestWord(vector<string>& words) {\\n        string ans=\"\";\\n        trie *t1=new trie();\\n        for(auto&it:words)t1->insert(it);\\n        for(auto&it:words){\\n            bool gotIt=true;\\n            for(int i=1;i<it.size();i++){\\n                if(!t1->search(it.substr(0,i))){\\n                    gotIt=false;\\n                    break;\\n                }\\n            }\\n            if(gotIt){\\n                if(it.size()>ans.size())ans=it; //if current string has greater size update it\\n                if(it.size()==ans.size()&&it<ans)ans=it; //if current string is lexicographicaly smaller update it\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Trie",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\n    class trie{\\n        struct node{\\n            node* links[26];\\n            bool flag=false;\\n        };\\n    public:\\n        node* root;\\n        trie(){\\n            root=new node();\\n        }\\n        void insert(string word){\\n            node* nd=root;\\n            for(int i=0;i<word.size();i++){\\n                if(nd->links[word[i]-\\'a\\']==NULL){\\n                    nd->links[word[i]-\\'a\\']=new node();\\n                }\\n                nd=nd->links[word[i]-\\'a\\'];\\n            }\\n            nd->flag=true;\\n        }\\n        bool search(string word){\\n            node* nd=root;\\n            for(int i=0;i<word.size();i++){\\n                if(nd->links[word[i]-\\'a\\']==nullptr)\\n                    return false;\\n                nd=nd->links[word[i]-\\'a\\'];\\n            }\\n            return nd->flag;\\n        }\\n    };\\npublic:\\n    string longestWord(vector<string>& words) {\\n        string ans=\"\";\\n        trie *t1=new trie();\\n        for(auto&it:words)t1->insert(it);\\n        for(auto&it:words){\\n            bool gotIt=true;\\n            for(int i=1;i<it.size();i++){\\n                if(!t1->search(it.substr(0,i))){\\n                    gotIt=false;\\n                    break;\\n                }\\n            }\\n            if(gotIt){\\n                if(it.size()>ans.size())ans=it; //if current string has greater size update it\\n                if(it.size()==ans.size()&&it<ans)ans=it; //if current string is lexicographicaly smaller update it\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629220,
                "title": "c-trie",
                "content": "**Steps:**\\n* Insert all the strings in the vector in a trie.\\n* Start checking the strings one by one.\\n* For the string to be a valid answer, all the prefixes of the word should be present in the trie as a word, i.e the boolean variable we use to mark the end of the word should be marked true in the trie.\\n* So we traverse word and check if any one of the nodes has the word end variable marked as false, if so then the word is not a valid ans\\n* If the string is valid we check if the length of the length of the word is greater than the existing answer, if yes then update, if the length is same as existing answer then we choose the lexicographically smaller between them\\n\\n```\\nclass Solution {\\nprivate: \\n    struct Node{\\n        Node* arr[26];\\n        bool end = false;\\n    };\\npublic:\\n    Node* root = new Node();\\n    void trie_insert(string &word){\\n        Node* node = root;\\n        for(int i = 0; i < word.size(); i++){\\n            if(node->arr[word[i] - \\'a\\'] == NULL){\\n                node->arr[word[i] - \\'a\\'] = new Node();\\n            }\\n            node = node->arr[word[i] - \\'a\\'];\\n        }\\n        node->end = true;\\n    }\\n    bool isValid(string &word, Node* curr){\\n        for(int i = 0; i < word.size(); i++){\\n            curr = curr->arr[word[i] - \\'a\\'];\\n            if(!curr->end) return false;\\n        }\\n        return true;\\n    }\\n    string longestWord(vector<string>& words) {\\n        string ans = \"\";\\n        for(auto w: words){\\n            trie_insert(w);\\n        }    \\n        for(int i = words.size() - 1; i >= 0; i--){\\n            if(isValid(words[i], root)){\\n                if(words[i].length() > ans.length()){\\n                    ans = words[i];\\n                }else if(words[i].length() == ans.length()){\\n                    ans = min(words[i], ans);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "class Solution {\\nprivate: \\n    struct Node{\\n        Node* arr[26];\\n        bool end = false;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2626553,
                "title": "java-set-easy",
                "content": "```\\nclass Solution {\\n    public String longestWord(String[] words) {\\n        HashSet<String > h=new HashSet<>();\\n        for(String s:words){\\n            h.add(s);\\n        }\\n        String res=\"\";\\n       for(String s:words){\\n            if (s.length() > res.length() ||\\n                    s.length() == res.length() && s.compareTo(res) < 0) {\\n                boolean b=true;\\n                for(int j=1;j<s.length();j++){\\n                    if(!h.contains(s.substring(0,j))){\\n                        b=false;\\n                        break;\\n                    }\\n                }\\n                if(b){\\n                    res=s;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String longestWord(String[] words) {\\n        HashSet<String > h=new HashSet<>();\\n        for(String s:words){\\n            h.add(s);\\n        }\\n        String res=\"\";\\n       for(String s:words){\\n            if (s.length() > res.length() ||\\n                    s.length() == res.length() && s.compareTo(res) < 0) {\\n                boolean b=true;\\n                for(int j=1;j<s.length();j++){\\n                    if(!h.contains(s.substring(0,j))){\\n                        b=false;\\n                        break;\\n                    }\\n                }\\n                if(b){\\n                    res=s;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2472481,
                "title": "a-different-approach-using-recursion-slower-than-tries-but-unique",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(string w, vector <string> &words, unordered_set <string> &st, int ctr)\\n    {\\n        if(w==\"\")\\n            return ctr;\\n        \\n        string t=w;\\n        t.pop_back();\\n        if(st.find(t)!=st.end() || t==\"\")\\n        {\\n            return solve(t, words, st, ctr+1);\\n        }\\n        else\\n            return -1;\\n    }\\n    string longestWord(vector<string>& words) \\n    {\\n        unordered_set <string> st;\\n        for(string w: words)\\n            st.insert(w);\\n        \\n        string ans=\"\";\\n        for(string w: words)\\n        {\\n            int len=solve(w, words, st, 0);\\n            //cout<<len<<\" \"<<ans.size()<<endl;\\n            if(len!=-1 && len>ans.size())\\n            {\\n                ans=w;\\n                //cout<<ans<<endl;\\n            }\\n            else if(len==ans.size())\\n                ans=min(ans, w);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(string w, vector <string> &words, unordered_set <string> &st, int ctr)\\n    {\\n        if(w==\"\")\\n            return ctr;\\n        \\n        string t=w;\\n        t.pop_back();\\n        if(st.find(t)!=st.end() || t==\"\")\\n        {\\n            return solve(t, words, st, ctr+1);\\n        }\\n        else\\n            return -1;\\n    }\\n    string longestWord(vector<string>& words) \\n    {\\n        unordered_set <string> st;\\n        for(string w: words)\\n            st.insert(w);\\n        \\n        string ans=\"\";\\n        for(string w: words)\\n        {\\n            int len=solve(w, words, st, 0);\\n            //cout<<len<<\" \"<<ans.size()<<endl;\\n            if(len!=-1 && len>ans.size())\\n            {\\n                ans=w;\\n                //cout<<ans<<endl;\\n            }\\n            else if(len==ans.size())\\n                ans=min(ans, w);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2403898,
                "title": "c-easiest-trie-implementation-longest-string-with-all-prefix-present-in-the-given-array",
                "content": "**Kindly Upvote**\\n```\\nclass Solution {\\npublic:\\n    class TrieNode{\\n        public:\\n        char data;\\n        TrieNode* child[26];\\n        bool isWord;\\n        TrieNode(){\\n            this->data = \\'$\\';\\n            for(int i = 0;i < 26;i++){\\n                this->child[i] = nullptr;\\n            }\\n            this->isWord = false;\\n        }\\n    };\\n    class Trie{\\n        public:\\n        TrieNode* root;\\n        Trie(){\\n            root = new TrieNode();\\n        }\\n        void insertHelp(string word,TrieNode* root){\\n            if(word.length() == 0){\\n                root->isWord = true;\\n                return;\\n            }\\n            int index = word[0] - \\'a\\';\\n            if(root->child[index] == nullptr){\\n                TrieNode* c = new TrieNode();\\n                c->data = word[0];\\n                root->child[index] = c;\\n            }\\n            insertHelp(word.substr(1),root->child[index]);\\n            return;\\n        }\\n        void insert(string word){\\n            insertHelp(word,root);\\n        }\\n        bool isGoodHelp(string word,TrieNode* root){\\n            if(word.length() == 0){\\n                return root->isWord;\\n            }\\n            int index = word[0] - \\'a\\';\\n            if(root->child[index] == nullptr || root->child[index]->isWord == false){\\n                return false;\\n            }\\n            return isGoodHelp(word.substr(1),root->child[index]);\\n        }\\n        bool isGood(string word){\\n            return isGoodHelp(word,root);\\n        }\\n    };\\n    string longestWord(vector<string>& words) {\\n        Trie PrefixTree;\\n        for(auto it:words){\\n            PrefixTree.insert(it);\\n        }\\n        string ans = \"\";\\n        for(auto it:words){\\n            if(PrefixTree.isGood(it)){\\n                if(it.size() > ans.size()){\\n                    ans = it;\\n                }\\n                else if(it.size() == ans.size()){\\n                    ans = min(ans,it);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    class TrieNode{\\n        public:\\n        char data;\\n        TrieNode* child[26];\\n        bool isWord;\\n        TrieNode(){\\n            this->data = \\'$\\';\\n            for(int i = 0;i < 26;i++){\\n                this->child[i] = nullptr;\\n            }\\n            this->isWord = false;\\n        }\\n    };\\n    class Trie{\\n        public:\\n        TrieNode* root;\\n        Trie(){\\n            root = new TrieNode();\\n        }\\n        void insertHelp(string word,TrieNode* root){\\n            if(word.length() == 0){\\n                root->isWord = true;\\n                return;\\n            }\\n            int index = word[0] - \\'a\\';\\n            if(root->child[index] == nullptr){\\n                TrieNode* c = new TrieNode();\\n                c->data = word[0];\\n                root->child[index] = c;\\n            }\\n            insertHelp(word.substr(1),root->child[index]);\\n            return;\\n        }\\n        void insert(string word){\\n            insertHelp(word,root);\\n        }\\n        bool isGoodHelp(string word,TrieNode* root){\\n            if(word.length() == 0){\\n                return root->isWord;\\n            }\\n            int index = word[0] - \\'a\\';\\n            if(root->child[index] == nullptr || root->child[index]->isWord == false){\\n                return false;\\n            }\\n            return isGoodHelp(word.substr(1),root->child[index]);\\n        }\\n        bool isGood(string word){\\n            return isGoodHelp(word,root);\\n        }\\n    };\\n    string longestWord(vector<string>& words) {\\n        Trie PrefixTree;\\n        for(auto it:words){\\n            PrefixTree.insert(it);\\n        }\\n        string ans = \"\";\\n        for(auto it:words){\\n            if(PrefixTree.isGood(it)){\\n                if(it.size() > ans.size()){\\n                    ans = it;\\n                }\\n                else if(it.size() == ans.size()){\\n                    ans = min(ans,it);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2161672,
                "title": "c-solution-trie-backtracking",
                "content": "```\\nclass Trie{\\n    \\npublic:\\n    Trie *child[26];\\n    bool isEnd;\\n    \\n    Trie() {\\n        isEnd = false;\\n        for(int i = 0; i<26; i++){\\n            child[i] = NULL;\\n        }\\n        \\n    }\\n    \\n    void insert(string word) {\\n        \\n        Trie *curr = this;\\n        int len = word.length();\\n        for(int i = 0; i<len; i++){\\n            int index = word[i] - \\'a\\';\\n            if(curr->child[index]==NULL)\\n                curr->child[index] = new Trie();\\n            curr = curr->child[index];\\n        }\\n        curr->isEnd = true;\\n           \\n    }\\n    \\n    bool search(string word) {\\n        Trie *curr = this;\\n        int len = word.length();\\n        for(int i = 0; i<len; ++i){\\n            int index = word[i] - \\'a\\';\\n            if(curr->child[index] == NULL)\\n                return false;\\n            curr = curr->child[index];\\n        }\\n        if(curr->isEnd ==false)\\n            return false;\\n        return true;\\n    }   \\n};\\n\\nclass Solution {\\n    \\npublic:\\n    string mxStr = \"\";\\n    bool isEmpty(Trie *root){\\n        for(int i = 0; i<26; i++){\\n            if(root->child[i] != NULL)\\n                return false;\\n        }\\n        return true;\\n    }\\n    void backT(Trie *root, string &ans){\\n        if(root->isEnd == false || isEmpty(root)){\\n            \\n            return;\\n        }\\n        else{\\n            for(int i = 0; i<26; i++){\\n                if(root->child[i]!=NULL){\\n                    if(root->child[i]->isEnd == false)\\n                        continue;// avoid useless call.\\n                    ans.push_back(\\'a\\'+i);\\n                    if(mxStr.length()<ans.length())\\n                        mxStr = ans;\\n                    backT(root->child[i], ans);\\n\\t\\t\\t\\t\\t//backtracking.\\n                    ans.pop_back();\\n                }\\n            }\\n        }\\n    }\\n    string longestWord(vector<string>& words) {\\n        Trie *root = new Trie();\\n        for(auto w :words){\\n            root->insert(w);\\n        }\\n        string ans = \"\";\\n        for(int i = 0; i<26; i++){\\n            if(root->child[i]!=NULL){\\n                if(root->child[i]->isEnd == false){\\n                    continue; //despite backtracking The mxStr is single direction so avoid useless call.\\n                }\\n                ans.push_back(\\'a\\'+i);\\n                if(mxStr.length()<ans.length())\\n                    mxStr = ans;\\n                backT(root->child[i], ans);\\n                // Backtracking.\\n                ans.pop_back();\\n            }\\n                \\n        }\\n        return mxStr;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass Trie{\\n    \\npublic:\\n    Trie *child[26];\\n    bool isEnd;\\n    \\n    Trie() {\\n        isEnd = false;\\n        for(int i = 0; i<26; i++){\\n            child[i] = NULL;\\n        }\\n        \\n    }\\n    \\n    void insert(string word) {\\n        \\n        Trie *curr = this;\\n        int len = word.length();\\n        for(int i = 0; i<len; i++){\\n            int index = word[i] - \\'a\\';\\n            if(curr->child[index]==NULL)\\n                curr->child[index] = new Trie();\\n            curr = curr->child[index];\\n        }\\n        curr->isEnd = true;\\n           \\n    }\\n    \\n    bool search(string word) {\\n        Trie *curr = this;\\n        int len = word.length();\\n        for(int i = 0; i<len; ++i){\\n            int index = word[i] - \\'a\\';\\n            if(curr->child[index] == NULL)\\n                return false;\\n            curr = curr->child[index];\\n        }\\n        if(curr->isEnd ==false)\\n            return false;\\n        return true;\\n    }   \\n};\\n\\nclass Solution {\\n    \\npublic:\\n    string mxStr = \"\";\\n    bool isEmpty(Trie *root){\\n        for(int i = 0; i<26; i++){\\n            if(root->child[i] != NULL)\\n                return false;\\n        }\\n        return true;\\n    }\\n    void backT(Trie *root, string &ans){\\n        if(root->isEnd == false || isEmpty(root)){\\n            \\n            return;\\n        }\\n        else{\\n            for(int i = 0; i<26; i++){\\n                if(root->child[i]!=NULL){\\n                    if(root->child[i]->isEnd == false)\\n                        continue;// avoid useless call.\\n                    ans.push_back(\\'a\\'+i);\\n                    if(mxStr.length()<ans.length())\\n                        mxStr = ans;\\n                    backT(root->child[i], ans);\\n\\t\\t\\t\\t\\t//backtracking.\\n                    ans.pop_back();\\n                }\\n            }\\n        }\\n    }\\n    string longestWord(vector<string>& words) {\\n        Trie *root = new Trie();\\n        for(auto w :words){\\n            root->insert(w);\\n        }\\n        string ans = \"\";\\n        for(int i = 0; i<26; i++){\\n            if(root->child[i]!=NULL){\\n                if(root->child[i]->isEnd == false){\\n                    continue; //despite backtracking The mxStr is single direction so avoid useless call.\\n                }\\n                ans.push_back(\\'a\\'+i);\\n                if(mxStr.length()<ans.length())\\n                    mxStr = ans;\\n                backT(root->child[i], ans);\\n                // Backtracking.\\n                ans.pop_back();\\n            }\\n                \\n        }\\n        return mxStr;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1904977,
                "title": "simple-python-code-trie-single-scan",
                "content": "Sort the list to make sure it\\'s in alphabetic order (so that we don\\'t need to update previously-visited longer words\\' values, and also make sure for same length of result, the alphabetic order is in place).\\n\\nWe just scan each word and add to Trie, while keep counting whether it can be built letter by letter (cur.value == len(word)) and longer than previous res.\\n\\n```\\nclass TrieNode:\\n    def __init__(self, val):\\n        self.children = {}\\n        self.value = val\\n        self.endOfWord = False\\n        \\nclass Solution:\\n    def longestWord(self, words: List[str]) -> str:\\n        root = TrieNode(0)\\n        maxLen = 0\\n        res = \"\"\\n        for word in sorted(words):\\n            cur = root\\n            count = 0\\n            for letter in word:\\n                if letter not in cur.children:\\n                    cur.children[letter] = TrieNode(count)\\n                cur = cur.children[letter]\\n                if cur.endOfWord: count += 1\\n            cur.endOfWord = True\\n            cur.value += 1\\n            if cur.value == len(word) and cur.value > maxLen:\\n                maxLen = cur.value\\n                res = word\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode:\\n    def __init__(self, val):\\n        self.children = {}\\n        self.value = val\\n        self.endOfWord = False\\n        \\nclass Solution:\\n    def longestWord(self, words: List[str]) -> str:\\n        root = TrieNode(0)\\n        maxLen = 0\\n        res = \"\"\\n        for word in sorted(words):\\n            cur = root\\n            count = 0\\n            for letter in word:\\n                if letter not in cur.children:\\n                    cur.children[letter] = TrieNode(count)\\n                cur = cur.children[letter]\\n                if cur.endOfWord: count += 1\\n            cur.endOfWord = True\\n            cur.value += 1\\n            if cur.value == len(word) and cur.value > maxLen:\\n                maxLen = cur.value\\n                res = word\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1657108,
                "title": "c-trie",
                "content": "```\\nclass Solution {\\npublic:\\n    struct Node{\\n        Node* children[26];\\n        bool end;\\n    };\\n    Node* getNode()\\n    {\\n        Node* temp = new Node();\\n        for (int i = 0;i < 26;i++)\\n            temp -> children[i] = NULL;\\n        temp -> end = false;\\n        return temp;\\n    }\\n    \\n    void insert(string s, Node* root)\\n    {\\n        Node* temp = root;\\n        int n = s.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (!temp -> children[s[i] - \\'a\\'])\\n                temp -> children[s[i] - \\'a\\'] = getNode();\\n            temp = temp->children[s[i] - \\'a\\'];\\n        }\\n        temp -> end = true;\\n    }\\n    string comp(string a, string b)\\n    {\\n        if (a.size() > b.size())\\n            return a;\\n        else if (a.size() < b.size())\\n            return b;\\n        else if (a.size() == b.size())\\n        {\\n            for (int i = 0; i < a.size(); i++)\\n            {\\n                if (a[i] < b[i])\\n                    return a;\\n                else if (b[i] < a[i])\\n                    return b;\\n            }\\n        }\\n        return NULL;\\n    }\\n    string compute(Node* root, string s)\\n    {\\n        string temp = s;\\n        string ans = temp;\\n        for (int i = 0; i < 26; i++)\\n        {\\n            if (root -> children[i] && root -> children[i] -> end)\\n            { \\n                ans = comp(ans,\\n                           compute(root->children[i], temp + char(i + \\'a\\'))\\n                          );\\n            }\\n        }\\n        return ans;\\n    }\\n    string longestWord(vector<string>& words) {\\n        int n = words.size();\\n        Node* root = getNode();\\n        for (int i = 0; i < n; i++)\\n            insert(words[i], root);\\n        string ans = compute(root, \"\");\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    struct Node{\\n        Node* children[26];\\n        bool end;\\n    };\\n    Node* getNode()\\n    {\\n        Node* temp = new Node();\\n        for (int i = 0;i < 26;i++)\\n            temp -> children[i] = NULL;\\n        temp -> end = false;\\n        return temp;\\n    }\\n    \\n    void insert(string s, Node* root)\\n    {\\n        Node* temp = root;\\n        int n = s.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (!temp -> children[s[i] - \\'a\\'])\\n                temp -> children[s[i] - \\'a\\'] = getNode();\\n            temp = temp->children[s[i] - \\'a\\'];\\n        }\\n        temp -> end = true;\\n    }\\n    string comp(string a, string b)\\n    {\\n        if (a.size() > b.size())\\n            return a;\\n        else if (a.size() < b.size())\\n            return b;\\n        else if (a.size() == b.size())\\n        {\\n            for (int i = 0; i < a.size(); i++)\\n            {\\n                if (a[i] < b[i])\\n                    return a;\\n                else if (b[i] < a[i])\\n                    return b;\\n            }\\n        }\\n        return NULL;\\n    }\\n    string compute(Node* root, string s)\\n    {\\n        string temp = s;\\n        string ans = temp;\\n        for (int i = 0; i < 26; i++)\\n        {\\n            if (root -> children[i] && root -> children[i] -> end)\\n            { \\n                ans = comp(ans,\\n                           compute(root->children[i], temp + char(i + \\'a\\'))\\n                          );\\n            }\\n        }\\n        return ans;\\n    }\\n    string longestWord(vector<string>& words) {\\n        int n = words.size();\\n        Node* root = getNode();\\n        for (int i = 0; i < n; i++)\\n            insert(words[i], root);\\n        string ans = compute(root, \"\");\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1364086,
                "title": "simple-solution-using-trie-in-c",
                "content": "```\\nstruct trie{\\n    \\n    trie* children[26];\\n    string val;\\n};\\n\\ntrie* newnode(){\\n    \\n    trie* curr=new trie();\\n    for(int i=0;i<26;i++){\\n        curr->children[i]=NULL;\\n    }\\n    curr->val=\"\";\\n    return curr;\\n}\\n\\nvoid insert(trie *&root,string word){\\n    \\n    trie* curr=root;\\n    for(int i=0;i<word.size();i++){\\n        int index=word[i]-\\'a\\';\\n        \\n        if(curr->children[index]==NULL){\\n            curr->children[index]=newnode();\\n        }\\n        curr=curr->children[index];\\n    }\\n    curr->val=word;\\n}\\n\\nvoid dfs(trie* root,string &ans){\\n    \\n    for(auto child:root->children){\\n        if(child!=NULL && child->val.size()>0){\\n            if(child->val.size()>ans.size()){\\n                ans=child->val;\\n            }\\n            dfs(child,ans);\\n        }\\n    }\\n}\\n\\nclass Solution {\\npublic:\\n    trie* root;\\n    string ans=\"\";\\n    string longestWord(vector<string>& words) {\\n        \\n        root=newnode();\\n        for(int i=0;i<words.size();i++){\\n            insert(root,words[i]);\\n        }\\n        \\n        dfs(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstruct trie{\\n    \\n    trie* children[26];\\n    string val;\\n};\\n\\ntrie* newnode(){\\n    \\n    trie* curr=new trie();\\n    for(int i=0;i<26;i++){\\n        curr->children[i]=NULL;\\n    }\\n    curr->val=\"\";\\n    return curr;\\n}\\n\\nvoid insert(trie *&root,string word){\\n    \\n    trie* curr=root;\\n    for(int i=0;i<word.size();i++){\\n        int index=word[i]-\\'a\\';\\n        \\n        if(curr->children[index]==NULL){\\n            curr->children[index]=newnode();\\n        }\\n        curr=curr->children[index];\\n    }\\n    curr->val=word;\\n}\\n\\nvoid dfs(trie* root,string &ans){\\n    \\n    for(auto child:root->children){\\n        if(child!=NULL && child->val.size()>0){\\n            if(child->val.size()>ans.size()){\\n                ans=child->val;\\n            }\\n            dfs(child,ans);\\n        }\\n    }\\n}\\n\\nclass Solution {\\npublic:\\n    trie* root;\\n    string ans=\"\";\\n    string longestWord(vector<string>& words) {\\n        \\n        root=newnode();\\n        for(int i=0;i<words.size();i++){\\n            insert(root,words[i]);\\n        }\\n        \\n        dfs(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1129778,
                "title": "simple-solution-using-trie-no-sorting-java",
                "content": "\\tclass LongestWordInDictionary {\\n    \\n\\t\\t// Time Complexity: O(sum of length of each string in the arr) --> O(sum(len(s)))   (where s -> string in arr)\\n\\t\\t// Space Complexity: O(sum(len(s)))\\n    \\n\\t\\tclass TrieNode{\\n\\t\\t\\tTrieNode[] children;\\n\\t\\t\\tString word;\\n\\n\\t\\t\\tpublic TrieNode(){\\n\\t\\t\\t\\tchildren = new TrieNode[26];\\n\\t\\t\\t\\tword = \"\";\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tTrieNode root;\\n\\t\\tString result = \"\";\\n    \\n\\t\\tpublic String longestWord(String[] words) {\\n\\t\\t\\t// Edge case checking\\n\\t\\t\\tif(words == null || words.length == 0)\\n\\t\\t\\t\\treturn \"\";\\n\\n\\t\\t\\troot = new TrieNode();\\n\\n\\t\\t\\t//insert and build trie dictionary\\n\\t\\t\\tinsert(words);\\n\\n\\t\\t\\t//dfs\\n\\t\\t\\tdfs(root);\\n\\n\\t\\t\\treturn result;\\n\\t\\t}\\n    \\n\\t\\tprivate void insert(String[] words){\\n\\t\\t\\t// For every word in words - we construct the trie, character by character also keep the track of word at each point\\n\\t\\t\\tfor(String s: words){\\n\\t\\t\\t\\tTrieNode curr = root;\\n\\t\\t\\t\\tfor(char c : s.toCharArray()){\\n\\t\\t\\t\\t\\tif(curr.children[c - \\'a\\'] == null)\\n\\t\\t\\t\\t\\t\\tcurr.children[c - \\'a\\'] = new TrieNode();\\n\\t\\t\\t\\t\\tcurr = curr.children[c - \\'a\\'];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcurr.word = s;\\n\\t\\t\\t}\\n\\t\\t}\\n    \\n\\t\\tprivate void dfs(TrieNode root){\\n\\t\\t\\t// If our word length > result length - then update result\\n\\t\\t\\tif(root.word.length() > result.length())\\n\\t\\t\\t\\tresult = root.word;\\n\\n\\t\\t\\t/// Traverse the nodes of a trie from left to right (a to z) (No need for sorting)\\n\\t\\t\\tfor(int i = 0; i < 26; i++){\\n\\t\\t\\t\\tif(root.children[i] != null && root.children[i].word != \"\")\\n\\t\\t\\t\\t\\tdfs(root.children[i]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "\\tclass LongestWordInDictionary {\\n    \\n\\t\\t// Time Complexity: O(sum of length of each string in the arr) --> O(sum(len(s)))   (where s -> string in arr)\\n\\t\\t// Space Complexity: O(sum(len(s)))\\n    \\n\\t\\tclass TrieNode{\\n\\t\\t\\tTrieNode[] children;\\n\\t\\t\\tString word;\\n\\n\\t\\t\\tpublic TrieNode(){\\n\\t\\t\\t\\tchildren = new TrieNode[26];\\n\\t\\t\\t\\tword = \"\";\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tTrieNode root;\\n\\t\\tString result = \"\";\\n    \\n\\t\\tpublic String longestWord(String[] words) {\\n\\t\\t\\t// Edge case checking\\n\\t\\t\\tif(words == null || words.length == 0)\\n\\t\\t\\t\\treturn \"\";\\n\\n\\t\\t\\troot = new TrieNode();\\n\\n\\t\\t\\t//insert and build trie dictionary\\n\\t\\t\\tinsert(words);\\n\\n\\t\\t\\t//dfs\\n\\t\\t\\tdfs(root);\\n\\n\\t\\t\\treturn result;\\n\\t\\t}\\n    \\n\\t\\tprivate void insert(String[] words){\\n\\t\\t\\t// For every word in words - we construct the trie, character by character also keep the track of word at each point\\n\\t\\t\\tfor(String s: words){\\n\\t\\t\\t\\tTrieNode curr = root;\\n\\t\\t\\t\\tfor(char c : s.toCharArray()){\\n\\t\\t\\t\\t\\tif(curr.children[c - \\'a\\'] == null)\\n\\t\\t\\t\\t\\t\\tcurr.children[c - \\'a\\'] = new TrieNode();\\n\\t\\t\\t\\t\\tcurr = curr.children[c - \\'a\\'];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcurr.word = s;\\n\\t\\t\\t}\\n\\t\\t}\\n    \\n\\t\\tprivate void dfs(TrieNode root){\\n\\t\\t\\t// If our word length > result length - then update result\\n\\t\\t\\tif(root.word.length() > result.length())\\n\\t\\t\\t\\tresult = root.word;\\n\\n\\t\\t\\t/// Traverse the nodes of a trie from left to right (a to z) (No need for sorting)\\n\\t\\t\\tfor(int i = 0; i < 26; i++){\\n\\t\\t\\t\\tif(root.children[i] != null && root.children[i].word != \"\")\\n\\t\\t\\t\\t\\tdfs(root.children[i]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1064950,
                "title": "java-trie-8ms-o-words-length-words-i-length",
                "content": "\\n    public class Trie {\\n\\n\\t\\tprivate class Node {\\n\\n\\t\\t\\tchar data;\\n\\t\\t\\tNode[] children;\\n\\t\\t\\tboolean isTerminal;\\n\\n\\t\\t\\tpublic Node(char data, boolean isTerminal) {\\n\\t\\t\\t\\tthis.data = data;\\n\\t\\t\\t\\tthis.isTerminal = isTerminal;\\n\\t\\t\\t\\tthis.children = new Node[26];\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tprivate Node root;\\n\\n\\t\\t// O(1)\\n\\t\\tpublic Trie() {\\n\\t\\t\\tthis.root = new Node(\\'\\\\0\\', false);\\n\\t\\t}\\n\\n\\t\\t// O(word.length)\\n\\t\\tpublic void addWord(String word) {\\n\\t\\t\\tNode curr = root;\\n\\t\\t\\tfor (char ch : word.toCharArray()) {\\n\\t\\t\\t\\tNode temp = curr.children[ch - \\'a\\'];\\n\\t\\t\\t\\tif (temp == null) {\\n\\t\\t\\t\\t\\ttemp = new Node(ch, false);\\n\\t\\t\\t\\t\\tcurr.children[ch - \\'a\\'] = temp;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcurr = temp;\\n\\t\\t\\t}\\n\\t\\t\\tcurr.isTerminal = true;\\n\\t\\t}\\n\\n\\t\\t// O(word.length)\\n\\t\\tpublic boolean searchWord(String word) {\\n\\t\\t\\tNode curr = root;\\n\\t\\t\\tfor (char ch : word.toCharArray()) {\\n\\t\\t\\t\\tNode temp = curr.children[ch - \\'a\\'];\\n\\t\\t\\t\\tif (!temp.isTerminal) {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcurr = temp;\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t}\\n\\n\\tString ans = \"\";\\n\\n\\t// O(words.length*words[i].length) \\n\\tpublic String longestWord(String[] words) {\\n\\t\\tTrie trie = new Trie();\\n\\t\\tfor (String word : words)\\n\\t\\t\\ttrie.addWord(word);\\n\\t\\tfor (String word : words) {\\n\\t\\t\\tif (trie.searchWord(word)) {\\n\\t\\t\\t\\tif (word.length() > ans.length())\\n\\t\\t\\t\\t\\tans = word;\\n\\t\\t\\t\\telse if (word.length() == ans.length())\\n\\t\\t\\t\\t\\tans = (word.compareTo(ans) < 0) ? word : ans;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n",
                "solutionTags": [],
                "code": "\\n    public class Trie {\\n\\n\\t\\tprivate class Node {\\n\\n\\t\\t\\tchar data;\\n\\t\\t\\tNode[] children;\\n\\t\\t\\tboolean isTerminal;\\n\\n\\t\\t\\tpublic Node(char data, boolean isTerminal) {\\n\\t\\t\\t\\tthis.data = data;\\n\\t\\t\\t\\tthis.isTerminal = isTerminal;\\n\\t\\t\\t\\tthis.children = new Node[26];\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tprivate Node root;\\n\\n\\t\\t// O(1)\\n\\t\\tpublic Trie() {\\n\\t\\t\\tthis.root = new Node(\\'\\\\0\\', false);\\n\\t\\t}\\n\\n\\t\\t// O(word.length)\\n\\t\\tpublic void addWord(String word) {\\n\\t\\t\\tNode curr = root;\\n\\t\\t\\tfor (char ch : word.toCharArray()) {\\n\\t\\t\\t\\tNode temp = curr.children[ch - \\'a\\'];\\n\\t\\t\\t\\tif (temp == null) {\\n\\t\\t\\t\\t\\ttemp = new Node(ch, false);\\n\\t\\t\\t\\t\\tcurr.children[ch - \\'a\\'] = temp;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcurr = temp;\\n\\t\\t\\t}\\n\\t\\t\\tcurr.isTerminal = true;\\n\\t\\t}\\n\\n\\t\\t// O(word.length)\\n\\t\\tpublic boolean searchWord(String word) {\\n\\t\\t\\tNode curr = root;\\n\\t\\t\\tfor (char ch : word.toCharArray()) {\\n\\t\\t\\t\\tNode temp = curr.children[ch - \\'a\\'];\\n\\t\\t\\t\\tif (!temp.isTerminal) {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcurr = temp;\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t}\\n\\n\\tString ans = \"\";\\n\\n\\t// O(words.length*words[i].length) \\n\\tpublic String longestWord(String[] words) {\\n\\t\\tTrie trie = new Trie();\\n\\t\\tfor (String word : words)\\n\\t\\t\\ttrie.addWord(word);\\n\\t\\tfor (String word : words) {\\n\\t\\t\\tif (trie.searchWord(word)) {\\n\\t\\t\\t\\tif (word.length() > ans.length())\\n\\t\\t\\t\\t\\tans = word;\\n\\t\\t\\t\\telse if (word.length() == ans.length())\\n\\t\\t\\t\\t\\tans = (word.compareTo(ans) < 0) ? word : ans;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n",
                "codeTag": "Java"
            },
            {
                "id": 919614,
                "title": "clean-and-simple-python-solution-standard-trie-dfs",
                "content": "Trie + DFS\\n\\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.isword =False\\n        \\n    @staticmethod\\n    def construct_trie(words):\\n        root = TrieNode()\\n        for w in words :\\n            node = root\\n            for c in w:\\n                node.children.setdefault(c,TrieNode())\\n                node = node.children[c]\\n            node.isword=True\\n        return root\\n\\nclass Solution:\\n    def longestWord(self, words: List[str]) -> str:\\n\\t\\t# Loading list in Trie structure\\n        trie = TrieNode.construct_trie(words)\\n\\n        self.longest=\"\"\\n        \\n        def record_max(root,S):\\n            if root.isword:\\n                # if we are in a valid tree\\n\\t\\t\\t\\t# check if we found a new long string\\n                if len(S) > len(self.longest):\\n                    self.longest = S\\n\\t\\t\\t\\t# sorting because we need smallest lexical word\\n                for c in sorted(root.children):\\n\\t\\t\\t\\t\\t# recursion \\n                    record_max(root.children[c],S+c)\\n       \\n\\t   # setting root.isword as True for cleaner code and getting kick start with root\\n\\t   trie.isword= True\\n       \\n\\t   record_max(trie,\"\")\\n       return self.longest\\n\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.isword =False\\n        \\n    @staticmethod\\n    def construct_trie(words):\\n        root = TrieNode()\\n        for w in words :\\n            node = root\\n            for c in w:\\n                node.children.setdefault(c,TrieNode())\\n                node = node.children[c]\\n            node.isword=True\\n        return root\\n\\nclass Solution:\\n    def longestWord(self, words: List[str]) -> str:\\n\\t\\t# Loading list in Trie structure\\n        trie = TrieNode.construct_trie(words)\\n\\n        self.longest=\"\"\\n        \\n        def record_max(root,S):\\n            if root.isword:\\n                # if we are in a valid tree\\n\\t\\t\\t\\t# check if we found a new long string\\n                if len(S) > len(self.longest):\\n                    self.longest = S\\n\\t\\t\\t\\t# sorting because we need smallest lexical word\\n                for c in sorted(root.children):\\n\\t\\t\\t\\t\\t# recursion \\n                    record_max(root.children[c],S+c)\\n       \\n\\t   # setting root.isword as True for cleaner code and getting kick start with root\\n\\t   trie.isword= True\\n       \\n\\t   record_max(trie,\"\")\\n       return self.longest\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 900867,
                "title": "python-dp-solution-with-annotations",
                "content": "I just realized you can use DP to solve this problem, which is sort of strange that no one has mentioned it.\\n\\nThe code is not polished, so feel free to optimize it.\\n\\n```\\nclass Solution:\\n    def longestWord(self, words: List[str]) -> str:\\n        \\'\\'\\'\\n        Initialize the dp table, where key is every word in the dictionary\\n        and the value is a boolean value indciating whether this word\\n        can be reached step by step\\n        \\'\\'\\'\\n        table = {w : None for w in words}\\n        \\n        def dp(w):\\n            \\'\\'\\'\\n            a recursive function that fills in the dp table\\n            \\'\\'\\'\\n            nonlocal table\\n            if len(w) == 0:\\n                return True\\n            elif w not in table:\\n                return False\\n            elif table[w] != None:\\n                return table[w]\\n            else:\\n                return dp(w[:-1])\\n        \\n        cur_max, res = 0, \\'\\'\\n        for word in words:\\n            table[word] = dp(word)\\n            if table[word]:\\n                if len(word) > cur_max:\\n                    cur_max = len(word)\\n                    res = word\\n                elif len(word) == cur_max and word < res:\\n                    # if they have the same length and \\n                    # this word is lexicographically smaller, replace the current res\\n                    res = word\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def longestWord(self, words: List[str]) -> str:\\n        \\'\\'\\'\\n        Initialize the dp table, where key is every word in the dictionary\\n        and the value is a boolean value indciating whether this word\\n        can be reached step by step\\n        \\'\\'\\'\\n        table = {w : None for w in words}\\n        \\n        def dp(w):\\n            \\'\\'\\'\\n            a recursive function that fills in the dp table\\n            \\'\\'\\'\\n            nonlocal table\\n            if len(w) == 0:\\n                return True\\n            elif w not in table:\\n                return False\\n            elif table[w] != None:\\n                return table[w]\\n            else:\\n                return dp(w[:-1])\\n        \\n        cur_max, res = 0, \\'\\'\\n        for word in words:\\n            table[word] = dp(word)\\n            if table[word]:\\n                if len(word) > cur_max:\\n                    cur_max = len(word)\\n                    res = word\\n                elif len(word) == cur_max and word < res:\\n                    # if they have the same length and \\n                    # this word is lexicographically smaller, replace the current res\\n                    res = word\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 851271,
                "title": "c-trie-based-linear-approach-98-time-35-space",
                "content": "Typical trie problem, so first of all we need to define a `Trie` structure - no frills, with just 2 properties:\\n* `children`, an array of 26 pointers to other `Trie`s (one for each lowercase letter);\\n* `eow`, which marks the end of a word.\\n\\nSome people might have build an `add` method here, but it is kinda unnecessary and just wasteful in terms of memory to have one such method for each instance of this struct.\\n\\nIn our main function we are then going to create first of all a `res` variable, initially empty, and a base `Trie`, creatively called `trie`, which we will populate passing all the strings and all the characters from all the strings, once.\\n\\nWe will go down this path, or at least a rather similar one, once more, checking all the strings once we are done and verifying which ones do not have even a single character\\'s `eow` flagged as `true` (meaning they would not be built from intermediate partial strings), provided the string we are currently checking is not smaller than `res`, in which case we just `continue` and move to the next string.\\n\\nIf we meet even just one character with `eow` still set to `false` (default value), we `break` and we move on to the next string.\\n\\nIf we finish looping all the characters and `eow` is `true` even for the last one (`curr->eow`) and the size of the string `s` is either greater than the size of `res` or if the sizes are the same, but `s < res`, then we update `res` to be the value of `s`.\\n\\nAt the end of the loop, we return `res`.\\n\\nThe code:\\n\\n```cpp\\nstruct Trie {\\n    Trie *children[26] = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};\\n    bool eow = false;\\n};\\n\\nclass Solution {\\npublic:\\n    string longestWord(vector<string>& words) {\\n        string res;\\n        // creating and populating a tree structure\\n        Trie *trie = new Trie(), *curr;\\n        for (string s: words) {\\n            curr = trie;\\n            for (char c: s) {\\n                // normalising c to be in the 0 - 26 range\\n                c -= \\'a\\';\\n                if (!curr->children[c]) curr->children[c] = new Trie();\\n                curr = curr->children[c];\\n            }\\n            curr->eow = true;\\n        }\\n        // parsing the trie to find the best longer full matches\\n        for (string s: words) {\\n            // avoiding unnecessary loops\\n            if (s.size() < res.size()) continue;\\n            curr = trie;\\n            for (char c: s) {\\n                // normalising c to be in the 0 - 26 range, again\\n                c -= \\'a\\';\\n                curr = curr->children[c];\\n                if (!curr->eow) break;\\n            }\\n            // updating res if it is all matching and s is either longer\\n            // or same length and minor in lexicographic order\\n            if (curr->eow && (s.size() > res.size() || s.size() == res.size() && s < res)) res = s;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```cpp\\nstruct Trie {\\n    Trie *children[26] = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};\\n    bool eow = false;\\n};\\n\\nclass Solution {\\npublic:\\n    string longestWord(vector<string>& words) {\\n        string res;\\n        // creating and populating a tree structure\\n        Trie *trie = new Trie(), *curr;\\n        for (string s: words) {\\n            curr = trie;\\n            for (char c: s) {\\n                // normalising c to be in the 0 - 26 range\\n                c -= \\'a\\';\\n                if (!curr->children[c]) curr->children[c] = new Trie();\\n                curr = curr->children[c];\\n            }\\n            curr->eow = true;\\n        }\\n        // parsing the trie to find the best longer full matches\\n        for (string s: words) {\\n            // avoiding unnecessary loops\\n            if (s.size() < res.size()) continue;\\n            curr = trie;\\n            for (char c: s) {\\n                // normalising c to be in the 0 - 26 range, again\\n                c -= \\'a\\';\\n                curr = curr->children[c];\\n                if (!curr->eow) break;\\n            }\\n            // updating res if it is all matching and s is either longer\\n            // or same length and minor in lexicographic order\\n            if (curr->eow && (s.size() > res.size() || s.size() == res.size() && s < res)) res = s;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 753980,
                "title": "python-solution-using-sort-and-set",
                "content": "**Intuition**\\n1. sort the `words` list as their length and lexicographical order.\\n2. use `seen` to record words whose prefix `words[:-1]` is also in seen. \\n```\\nclass Solution:\\n    def longestWord(self, words: List[str]) -> str:\\n        res = \\'\\'\\n        words.sort(key=lambda word: (len(word), word))\\n        seen = {\\'\\'}\\n        for i in range(len(words)):\\n            if words[i][:-1] in seen:\\n                seen.add(words[i])\\n                if len(words[i]) > len(res) or len(words[i]) == len(res) and words[i] <= res:\\n                    res = words[i]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestWord(self, words: List[str]) -> str:\\n        res = \\'\\'\\n        words.sort(key=lambda word: (len(word), word))\\n        seen = {\\'\\'}\\n        for i in range(len(words)):\\n            if words[i][:-1] in seen:\\n                seen.add(words[i])\\n                if len(words[i]) > len(res) or len(words[i]) == len(res) and words[i] <= res:\\n                    res = words[i]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 671183,
                "title": "c-a-bloodily-optimized-brute-force-solution-with-string-view-beat-90-time-space",
                "content": "```\\nclass Solution {\\npublic:\\n    string longestWord(vector<string>& words) {\\n        unordered_set<string_view> dict(begin(words), end(words)); \\n        string ans=\"\";                \\n        for(string_view w: dict){ // This will save huge amount of time in case of lots of repetition in words\\n            if(w.size() < ans.size() || w.size() == ans.size() && w > ans) continue;            \\n            bool valid = true;                                     \\n            for(int i = 1; i <= w.size() - 1 && valid; i++)\\n               if(!dict.count(w.substr(0,i))) valid = false;\\n                \\n            if(valid) ans = w;                \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestWord(vector<string>& words) {\\n        unordered_set<string_view> dict(begin(words), end(words)); \\n        string ans=\"\";                \\n        for(string_view w: dict){ // This will save huge amount of time in case of lots of repetition in words\\n            if(w.size() < ans.size() || w.size() == ans.size() && w > ans) continue;            \\n            bool valid = true;                                     \\n            for(int i = 1; i <= w.size() - 1 && valid; i++)\\n               if(!dict.count(w.substr(0,i))) valid = false;\\n                \\n            if(valid) ans = w;                \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 578778,
                "title": "go-clean-code-4ms-beats-100",
                "content": "```\\nfunc longestWord(words []string) string {\\n\\tsort.Strings(words)\\n    var ret string\\n\\tset := make(map[string]struct{}, len(words))\\n\\tfor _, word := range words {\\n\\t\\tif _, ok := set[word[:len(word)-1]]; !ok && len(word) != 1 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tset[word] = struct{}{}\\n\\t\\tif len(word) > len(ret) {\\n\\t\\t\\tret = word\\n\\t\\t}\\n\\t}\\n\\treturn ret\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc longestWord(words []string) string {\\n\\tsort.Strings(words)\\n    var ret string\\n\\tset := make(map[string]struct{}, len(words))\\n\\tfor _, word := range words {\\n\\t\\tif _, ok := set[word[:len(word)-1]]; !ok && len(word) != 1 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tset[word] = struct{}{}\\n\\t\\tif len(word) > len(ret) {\\n\\t\\t\\tret = word\\n\\t\\t}\\n\\t}\\n\\treturn ret\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 469858,
                "title": "python-trie-dfs-solution",
                "content": "```python\\nfrom collections import defaultdict\\n\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = defaultdict(TrieNode)\\n        self.isWord = False\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n    def insert(self, word):\\n        cur = self.root\\n        for letter in word:\\n            cur = cur.children[letter]\\n        cur.isWord = True\\n\\nclass Solution:\\n    def dfs(self, root, s):\\n        if root.isWord and len(s) > len(self.res):\\n            self.res = s\\n        for k in sorted(root.children):\\n            if root.children[k].isWord:\\n                self.dfs(root.children[k], s+k)\\n    \\n    def longestWord(self, words: List[str]) -> str:\\n        self.res = \\'\\'\\n        trie = Trie()\\n        for word in words:\\n            trie.insert(word)\\n        root = trie.root\\n        self.dfs(root, \\'\\')\\n        \\n        return self.res\\n```",
                "solutionTags": [],
                "code": "```python\\nfrom collections import defaultdict\\n\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = defaultdict(TrieNode)\\n        self.isWord = False\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n    def insert(self, word):\\n        cur = self.root\\n        for letter in word:\\n            cur = cur.children[letter]\\n        cur.isWord = True\\n\\nclass Solution:\\n    def dfs(self, root, s):\\n        if root.isWord and len(s) > len(self.res):\\n            self.res = s\\n        for k in sorted(root.children):\\n            if root.children[k].isWord:\\n                self.dfs(root.children[k], s+k)\\n    \\n    def longestWord(self, words: List[str]) -> str:\\n        self.res = \\'\\'\\n        trie = Trie()\\n        for word in words:\\n            trie.insert(word)\\n        root = trie.root\\n        self.dfs(root, \\'\\')\\n        \\n        return self.res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 430473,
                "title": "python-trie",
                "content": "```\\nclass TrieNode(object):\\n    def __init__(self):\\n        self.node ={}\\n        self.end = False\\n        \\n    def get(self,c):\\n        return self.node.get(c)\\n    \\n    def put(self, c, new_node):\\n        self.node[c] = new_node\\n\\nclass Trie():\\n    def __init__(self):\\n        self.root = TrieNode()\\n        self.longest_word = \\'\\'\\n        self.flag=False\\n        \\n    def insert(self, word):\\n        temp_node = self.root\\n        for c in word:\\n            if not temp_node.get(c):\\n                temp_node.put(c, TrieNode())\\n            temp_node = temp_node.node[c]\\n        temp_node.end = True\\n     \\n    def find_longest_string(self,tnode,res):\\n        \\n        for n in tnode.node.keys():\\n            if self.flag:\\n                self.flag=False\\n                res=res[:-1]\\n            if tnode.node[n].end:\\n\\t\\t\\t#if its the end of word add that to temp res and continue with its children\\n                res+=n\\n                self.find_longest_string(tnode.node[n],res)\\n            else:\\n                self.largest_string(res)\\n        self.largest_string(res)\\n        self.flag=True\\n        \\n    def largest_string(self,res):\\n        if len(res)>len(self.longest_word):\\n            self.longest_word = res\\n        if len(res)==len(self.longest_word):\\n            self.longest_word = self.longest_word if self.longest_word < res else                      res\\n        \\nclass Solution(object):\\n    def longestWord(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: str\\n        \"\"\"\\n        t = Trie()\\n        for word in words:\\n            t.insert(word)\\n        t.find_longest_string(t.root, \\'\\')\\n        return t.longest_word\\n```",
                "solutionTags": [],
                "code": "```\\nclass TrieNode(object):\\n    def __init__(self):\\n        self.node ={}\\n        self.end = False\\n        \\n    def get(self,c):\\n        return self.node.get(c)\\n    \\n    def put(self, c, new_node):\\n        self.node[c] = new_node\\n\\nclass Trie():\\n    def __init__(self):\\n        self.root = TrieNode()\\n        self.longest_word = \\'\\'\\n        self.flag=False\\n        \\n    def insert(self, word):\\n        temp_node = self.root\\n        for c in word:\\n            if not temp_node.get(c):\\n                temp_node.put(c, TrieNode())\\n            temp_node = temp_node.node[c]\\n        temp_node.end = True\\n     \\n    def find_longest_string(self,tnode,res):\\n        \\n        for n in tnode.node.keys():\\n            if self.flag:\\n                self.flag=False\\n                res=res[:-1]\\n            if tnode.node[n].end:\\n\\t\\t\\t#if its the end of word add that to temp res and continue with its children\\n                res+=n\\n                self.find_longest_string(tnode.node[n],res)\\n            else:\\n                self.largest_string(res)\\n        self.largest_string(res)\\n        self.flag=True\\n        \\n    def largest_string(self,res):\\n        if len(res)>len(self.longest_word):\\n            self.longest_word = res\\n        if len(res)==len(self.longest_word):\\n            self.longest_word = self.longest_word if self.longest_word < res else                      res\\n        \\nclass Solution(object):\\n    def longestWord(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: str\\n        \"\"\"\\n        t = Trie()\\n        for word in words:\\n            t.insert(word)\\n        t.find_longest_string(t.root, \\'\\')\\n        return t.longest_word\\n```",
                "codeTag": "Java"
            },
            {
                "id": 391136,
                "title": "here-is-my-easy-to-understand-c-sloution",
                "content": "```\\nclass Solution {\\n    \\npublic:\\n    struct TrieNode{\\n    struct TrieNode *child[26];\\n    bool eow;\\n};\\nstruct TrieNode *getNode(void)\\n{\\n    struct TrieNode *node = new TrieNode;\\n    node->eow = false;\\n    for(int i=0;i<26;i++)\\n    {\\n        node->child[i] = NULL;\\n    }\\n    return node;\\n}\\nbool insert(struct TrieNode *root, string word)\\n{\\n    struct TrieNode *pcrawl = root;\\n    int count = 0;\\n    for(int i=0;i<word.length();i++)\\n    {\\n        int index = word[i] - \\'a\\';\\n        if(!pcrawl->eow)\\n            count++;\\n        if(!pcrawl->child[index])\\n        {\\n            pcrawl->child[index] = getNode();\\n        }\\n        pcrawl = pcrawl->child[index];\\n        \\n    }\\n    pcrawl->eow = true;\\n    if(count == 1)\\n        return true;\\n    else\\n        return false;\\n}\\n    string longestWord(vector<string>& words) {\\n        int l = words.size();\\n        if(l == 1)\\n            return words[0];\\n        if(l==0)\\n            return \"\";\\n        struct TrieNode *root = getNode();\\n        sort(words.begin(),words.end());\\n        int count = 0;\\n        string str = \"\";\\n        for(int i=0;i<l;i++)\\n        {\\n            bool valid = insert(root, words[i]);\\n            if(valid)\\n            {\\n                if(words[i].length() > str.length())\\n                {\\n                    str = words[i];\\n                }\\n            }\\n        }\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n    \\npublic:\\n    struct TrieNode{\\n    struct TrieNode *child[26];\\n    bool eow;\\n};\\nstruct TrieNode *getNode(void)\\n{\\n    struct TrieNode *node = new TrieNode;\\n    node->eow = false;\\n    for(int i=0;i<26;i++)\\n    {\\n        node->child[i] = NULL;\\n    }\\n    return node;\\n}\\nbool insert(struct TrieNode *root, string word)\\n{\\n    struct TrieNode *pcrawl = root;\\n    int count = 0;\\n    for(int i=0;i<word.length();i++)\\n    {\\n        int index = word[i] - \\'a\\';\\n        if(!pcrawl->eow)\\n            count++;\\n        if(!pcrawl->child[index])\\n        {\\n            pcrawl->child[index] = getNode();\\n        }\\n        pcrawl = pcrawl->child[index];\\n        \\n    }\\n    pcrawl->eow = true;\\n    if(count == 1)\\n        return true;\\n    else\\n        return false;\\n}\\n    string longestWord(vector<string>& words) {\\n        int l = words.size();\\n        if(l == 1)\\n            return words[0];\\n        if(l==0)\\n            return \"\";\\n        struct TrieNode *root = getNode();\\n        sort(words.begin(),words.end());\\n        int count = 0;\\n        string str = \"\";\\n        for(int i=0;i<l;i++)\\n        {\\n            bool valid = insert(root, words[i]);\\n            if(valid)\\n            {\\n                if(words[i].length() > str.length())\\n                {\\n                    str = words[i];\\n                }\\n            }\\n        }\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 389006,
                "title": "javascript-trie-dfs",
                "content": "```\\nclass TrieNode {\\n    constructor(value, isWord = false) {\\n        this.value = value;\\n        this.isWord = isWord;\\n        this.children = {};\\n    }\\n    \\n    addChild(value, isWord) {\\n        if (this.children[value]) {\\n            const node = this.children[value];\\n            node.isWord = node.isWord || isWord;\\n            return node;\\n        }\\n\\n        const node = new TrieNode(value, isWord);\\n        this.children[value] = node;\\n        return node;\\n    }\\n}\\n\\nclass Trie {\\n    constructor() {\\n        this.root = new TrieNode(\\'*\\');\\n    }\\n    \\n    addWord(word, callback) {\\n        let node = this.root;\\n\\n        for (let i = 0; i < word.length; i++) {\\n            node = node.addChild(word[i], i === word.length - 1);\\n        }\\n    }\\n    \\n    dfs(callback) {\\n        return this._dfs(callback, this.root, \\'\\');\\n    }\\n    \\n    _dfs(callback, node, s) {\\n        Object\\n            .values(node.children)\\n            .forEach(child => {\\n                if (child.isWord) {\\n                    callback(s + child.value);\\n                    this._dfs(callback, child, s + child.value);\\n                }\\n            });\\n    }\\n}\\n\\n/**\\n * @param {string[]} words\\n * @return {string}\\n */\\nvar longestWord = function(words) {\\n    const trie = new Trie();\\n\\n    for (const word of words) {\\n        trie.addWord(word);\\n    }\\n\\n    let longest = \\'\\';\\n\\n    trie.dfs(word => {\\n        if (word.length < longest.length) return;\\n\\n        longest = word.length > longest.length ? word : word < longest ? word : longest;\\n    });\\n\\n    return longest;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass TrieNode {\\n    constructor(value, isWord = false) {\\n        this.value = value;\\n        this.isWord = isWord;\\n        this.children = {};\\n    }\\n    \\n    addChild(value, isWord) {\\n        if (this.children[value]) {\\n            const node = this.children[value];\\n            node.isWord = node.isWord || isWord;\\n            return node;\\n        }\\n\\n        const node = new TrieNode(value, isWord);\\n        this.children[value] = node;\\n        return node;\\n    }\\n}\\n\\nclass Trie {\\n    constructor() {\\n        this.root = new TrieNode(\\'*\\');\\n    }\\n    \\n    addWord(word, callback) {\\n        let node = this.root;\\n\\n        for (let i = 0; i < word.length; i++) {\\n            node = node.addChild(word[i], i === word.length - 1);\\n        }\\n    }\\n    \\n    dfs(callback) {\\n        return this._dfs(callback, this.root, \\'\\');\\n    }\\n    \\n    _dfs(callback, node, s) {\\n        Object\\n            .values(node.children)\\n            .forEach(child => {\\n                if (child.isWord) {\\n                    callback(s + child.value);\\n                    this._dfs(callback, child, s + child.value);\\n                }\\n            });\\n    }\\n}\\n\\n/**\\n * @param {string[]} words\\n * @return {string}\\n */\\nvar longestWord = function(words) {\\n    const trie = new Trie();\\n\\n    for (const word of words) {\\n        trie.addWord(word);\\n    }\\n\\n    let longest = \\'\\';\\n\\n    trie.dfs(word => {\\n        if (word.length < longest.length) return;\\n\\n        longest = word.length > longest.length ? word : word < longest ? word : longest;\\n    });\\n\\n    return longest;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 360650,
                "title": "cpp-trie-dfs-memory-100-and-runtime-92",
                "content": "**Explanation**:\\nAlongwith trie I keep a \"we\" (Word Ending) array to mark which nodes in the trie represent ending of a word. In case the next node while doing the DFS isn\\'t a word ending, for sure it is not going to lead to an answer, so we can prune.\\nUsing an array instead of struct for trie reduces memory consumption and also improves performance. To learn how to represent tries (as well as Segment Trees for that matter), please give this a reading: https://www.commonlounge.com/discussion/f0a9acb28617471cb286d84c68a0d210 .\\nWe do a DFS from left to right, thus, if a string of length ml (max_len) is found later, it for sure will be lexicographically larger than the previous answer. So, we can ignore it.\\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    int trie[30003][26];\\n    bool we[30003];\\n    int next = 1;\\n    \\n    string ans = \"\";\\n    int ml = 0;\\n    \\n    void insert(string &word){\\n        int now = 1;\\n        int n = word.size();\\n        \\n        for(int i = 0; i < n; ++i){\\n            if(trie[now][word[i] - \\'a\\'] == -1){\\n                trie[now][word[i] - \\'a\\'] = ++next;\\n            }\\n            now = trie[now][word[i] - \\'a\\'];\\n        }\\n        we[now] = true;\\n    }\\n    \\n    void dfs(int nd, int clen, string &c_s){\\n        if(clen > ml){\\n            ml = clen;\\n            ans = c_s;\\n        }\\n        \\n        for(int i = 0; i < 26; ++i){\\n            if(trie[nd][i] != -1 and we[trie[nd][i]]){\\n                c_s.push_back(static_cast<char>(\\'a\\' + i));\\n                dfs(trie[nd][i], clen + 1, c_s);\\n                c_s.pop_back();\\n            }\\n        }\\n    }\\n    \\n    string longestWord(vector<string>& words) {\\n        memset(trie, -1, sizeof trie);\\n        memset(we, 0, sizeof we);\\n        \\n        next = 1;\\n        \\n        for(auto &w: words){\\n            insert(w);\\n        }\\n        \\n        ans = \"\";\\n        ml = 0;\\n        \\n        string a = \"\";\\n        \\n        dfs(1, 0, a);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int trie[30003][26];\\n    bool we[30003];\\n    int next = 1;\\n    \\n    string ans = \"\";\\n    int ml = 0;\\n    \\n    void insert(string &word){\\n        int now = 1;\\n        int n = word.size();\\n        \\n        for(int i = 0; i < n; ++i){\\n            if(trie[now][word[i] - \\'a\\'] == -1){\\n                trie[now][word[i] - \\'a\\'] = ++next;\\n            }\\n            now = trie[now][word[i] - \\'a\\'];\\n        }\\n        we[now] = true;\\n    }\\n    \\n    void dfs(int nd, int clen, string &c_s){\\n        if(clen > ml){\\n            ml = clen;\\n            ans = c_s;\\n        }\\n        \\n        for(int i = 0; i < 26; ++i){\\n            if(trie[nd][i] != -1 and we[trie[nd][i]]){\\n                c_s.push_back(static_cast<char>(\\'a\\' + i));\\n                dfs(trie[nd][i], clen + 1, c_s);\\n                c_s.pop_back();\\n            }\\n        }\\n    }\\n    \\n    string longestWord(vector<string>& words) {\\n        memset(trie, -1, sizeof trie);\\n        memset(we, 0, sizeof we);\\n        \\n        next = 1;\\n        \\n        for(auto &w: words){\\n            insert(w);\\n        }\\n        \\n        ans = \"\";\\n        ml = 0;\\n        \\n        string a = \"\";\\n        \\n        dfs(1, 0, a);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 279464,
                "title": "javascript-solution-using-just-a-hash",
                "content": "```\\n/**\\n * @param {string[]} words\\n * @return {string}\\n */\\nvar longestWord = function(words) {\\n    words.sort((a, b) => a.length - b.length);\\n    let i = 0;\\n    let hash = {};\\n    let longest = \\'\\'\\n    while(i < words.length) {\\n        if (words[i].length == 1) {\\n            hash[words[i]] = true;\\n            if (longest.length == 0 || words[i].localeCompare(longest) < 0) {\\n                longest = words[i];\\n            }\\n        } else {\\n            let prevWord = words[i].substring(0, words[i].length - 1)\\n            if (hash[prevWord]) {\\n                if (words[i].length > longest.length || (words[i].length == longest.length && words[i].localeCompare(longest) < 0))\\n                    longest = words[i];\\n                hash[words[i]] = true\\n            }\\n        }\\n        i++;\\n    }\\n    return longest\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {string}\\n */\\nvar longestWord = function(words) {\\n    words.sort((a, b) => a.length - b.length);\\n    let i = 0;\\n    let hash = {};\\n    let longest = \\'\\'\\n    while(i < words.length) {\\n        if (words[i].length == 1) {\\n            hash[words[i]] = true;\\n            if (longest.length == 0 || words[i].localeCompare(longest) < 0) {\\n                longest = words[i];\\n            }\\n        } else {\\n            let prevWord = words[i].substring(0, words[i].length - 1)\\n            if (hash[prevWord]) {\\n                if (words[i].length > longest.length || (words[i].length == longest.length && words[i].localeCompare(longest) < 0))\\n                    longest = words[i];\\n                hash[words[i]] = true\\n            }\\n        }\\n        i++;\\n    }\\n    return longest\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 197958,
                "title": "python-solution",
                "content": "Time complexity: `O(nl^2)`, space complexity: `O(l)`, where `n = len(words)`, and `l` is the length of the longest string in `words`.\\n```\\nclass Solution:\\n    def longestWord(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: str\\n        \"\"\"\\n        res = None\\n        maxlen = 0\\n        look_up = set(words)\\n        for word in words:\\n            if len(word) >= maxlen:\\n                if len(word) == maxlen:\\n                    if word < res:\\n                        if all(word[:i] in look_up for i in range(1, len(word))):\\n                            res = word\\n                else:\\n                    if all(word[:i] in look_up for i in range(1, len(word))):\\n                        res = word\\n                        maxlen = len(word)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestWord(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: str\\n        \"\"\"\\n        res = None\\n        maxlen = 0\\n        look_up = set(words)\\n        for word in words:\\n            if len(word) >= maxlen:\\n                if len(word) == maxlen:\\n                    if word < res:\\n                        if all(word[:i] in look_up for i in range(1, len(word))):\\n                            res = word\\n                else:\\n                    if all(word[:i] in look_up for i in range(1, len(word))):\\n                        res = word\\n                        maxlen = len(word)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 175220,
                "title": "c-quick-and-easy-to-write-solution-using-hashset",
                "content": "Sept. 27, 2018\\nIt is easy level algorithm tagged by HashTable. There is a very smart solution to sort the words, therefore any word will be listed after its prefix word. \\n\\nTwo things are very important to come out the solution using HashSet. \\n1. Sort the words in ascending order. \\n2. If the word \"world\" is visited, then \"worl\" must have been visited before if worl is in dictionary; think recursively, only need to check \"worl\" is in visited dictionary and also satisfy the constraint \"all prefixs are in dictionary\".\\n\\nI will make it more clear in English later on. I like to share my C# code. \\n\\n```\\npublic class Solution {\\n    public string LongestWord(string[] words) {\\n            if(words == null)\\n                return null;\\n\\n            Array.Sort(words); \\n\\n            // word with prefixes in the dictionary\\n            var visitedPrefix = new HashSet<string>(); \\n\\n            string maximumWord = \"\";\\n\\n            foreach(var word in words)\\n            {\\n                var length = word.Length;\\n\\n                // think carefully about this reason using w, wo, wor, word\\n                if(length == 1 || visitedPrefix.Contains(word.Substring(0, length - 1)))\\n                {\\n                    // keep lexico order - apple will be checked before apply\\n                    maximumWord = word.Length > maximumWord.Length? word : maximumWord; \\n                    visitedPrefix.Add(word); \\n                }\\n            }\\n\\n            return maximumWord;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string LongestWord(string[] words) {\\n            if(words == null)\\n                return null;\\n\\n            Array.Sort(words); \\n\\n            // word with prefixes in the dictionary\\n            var visitedPrefix = new HashSet<string>(); \\n\\n            string maximumWord = \"\";\\n\\n            foreach(var word in words)\\n            {\\n                var length = word.Length;\\n\\n                // think carefully about this reason using w, wo, wor, word\\n                if(length == 1 || visitedPrefix.Contains(word.Substring(0, length - 1)))\\n                {\\n                    // keep lexico order - apple will be checked before apply\\n                    maximumWord = word.Length > maximumWord.Length? word : maximumWord; \\n                    visitedPrefix.Add(word); \\n                }\\n            }\\n\\n            return maximumWord;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 112717,
                "title": "java-trie-solution-easy-and-clear",
                "content": "```\\nclass Solution {\\n    class Trie {\\n        class Node {\\n            Node[] next = new Node[26];\\n            boolean isEnd;\\n        }\\n        Node root;\\n        public Trie() {\\n            root = new Node();\\n            root.isEnd = true;\\n        }\\n        public void insert(String s) {\\n            Node node = root;\\n            for(char c : s.toCharArray()) {\\n                if(node.next[c - 'a'] == null) node.next[c - 'a'] = new Node();\\n                node = node.next[c - 'a'];\\n            }\\n            node.isEnd = true;\\n        }\\n        public boolean canForm(String s) {\\n            Node node = root;\\n            for(char c : s.toCharArray()) {\\n                if(node.next[c - 'a'] == null || !node.isEnd) return false;\\n                node = node.next[c - 'a'];\\n            }\\n            return true;\\n        }\\n    }\\n    public String longestWord(String[] words) {\\n        Trie t = new Trie();\\n        for(String w : words) t.insert(w);\\n        String res = \"\";\\n        for(String w : words) {\\n            if(w.length() >= res.length() && t.canForm(w)) {\\n                if(w.length() > res.length()) res = w;\\n                else res = w.compareTo(res) < 0 ? w : res;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class Trie {\\n        class Node {\\n            Node[] next = new Node[26];\\n            boolean isEnd;\\n        }\\n        Node root;\\n        public Trie() {\\n            root = new Node();\\n            root.isEnd = true;\\n        }\\n        public void insert(String s) {\\n            Node node = root;\\n            for(char c : s.toCharArray()) {\\n                if(node.next[c - 'a'] == null) node.next[c - 'a'] = new Node();\\n                node = node.next[c - 'a'];\\n            }\\n            node.isEnd = true;\\n        }\\n        public boolean canForm(String s) {\\n            Node node = root;\\n            for(char c : s.toCharArray()) {\\n                if(node.next[c - 'a'] == null || !node.isEnd) return false;\\n                node = node.next[c - 'a'];\\n            }\\n            return true;\\n        }\\n    }\\n    public String longestWord(String[] words) {\\n        Trie t = new Trie();\\n        for(String w : words) t.insert(w);\\n        String res = \"\";\\n        for(String w : words) {\\n            if(w.length() >= res.length() && t.canForm(w)) {\\n                if(w.length() > res.length()) res = w;\\n                else res = w.compareTo(res) < 0 ? w : res;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 109117,
                "title": "short-python-beats-98",
                "content": "Basically, I did several tricks. \\n\\n1. split words in ```words``` into a list of different sets called ```apart``` by their lengths. Then every time we wanna do a check, we can save some effort.\\n2. keep checking while there still are candidates survive during last check\\n3. return the most recent survived candidate who has smallest lexicographical order\\n\\n```\\nclass Solution(object):\\n    def longestWord(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: str\\n        \"\"\"\\n        apart = [set() for _ in range(30)]\\n        for word in words:\\n            apart[len(word)-1].add(word)\\n        res = {\"\"}\\n        n = 0\\n        while res and n < 30:\\n            last = res\\n            res = {word for word in apart[n] if word[:-1] in last}\\n            n += 1\\n        return sorted(list(res or last))[0]\\n```",
                "solutionTags": [],
                "code": "```words```\n```apart```\n```\\nclass Solution(object):\\n    def longestWord(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: str\\n        \"\"\"\\n        apart = [set() for _ in range(30)]\\n        for word in words:\\n            apart[len(word)-1].add(word)\\n        res = {\"\"}\\n        n = 0\\n        while res and n < 30:\\n            last = res\\n            res = {word for word in apart[n] if word[:-1] in last}\\n            n += 1\\n        return sorted(list(res or last))[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 109151,
                "title": "java-solution-easy-to-understand",
                "content": "```\\n    public String longestWord(String[] words) {\\n        Arrays.sort(words);\\n        Set<String> set = new HashSet<String>();\\n        String max = \"\";\\n        for (int i = 0; i < words.length; i++) {\\n            if (words[i].length() == 1 || set.contains(words[i].substring(0, words[i].length() - 1))) {\\n                set.add(words[i]);\\n                if (max.length() < words[i].length()) max = words[i];\\n            }\\n        }\\n        return max;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public String longestWord(String[] words) {\\n        Arrays.sort(words);\\n        Set<String> set = new HashSet<String>();\\n        String max = \"\";\\n        for (int i = 0; i < words.length; i++) {\\n            if (words[i].length() == 1 || set.contains(words[i].substring(0, words[i].length() - 1))) {\\n                set.add(words[i]);\\n                if (max.length() < words[i].length()) max = words[i];\\n            }\\n        }\\n        return max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3736233,
                "title": "java-solution-using-trie",
                "content": "# Complexity\\n- Time complexity:O(n + m * k)\\n    \\'k\\' is the number of words in the input array\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Node{\\n    Node[] children;\\n    boolean eow;\\n\\n    public Node(){\\n        children = new Node[26];\\n        for(int i=0; i<26; i++){\\n            children[i] = null;\\n        }\\n        eow = false;\\n    }\\n}\\nclass Solution {\\n    Node root = new Node();\\n    String ans = \"\";\\n    public void insert(String word){\\n        Node curr = root;\\n        for(int i=0; i<word.length(); i++){\\n            int index = word.charAt(i) - \\'a\\';\\n\\n            if(curr.children[index] == null){\\n                curr.children[index] = new Node();\\n            }\\n\\n            if(i == word.length() - 1){\\n                curr.children[index].eow = true;\\n            }\\n            curr = curr.children[index];\\n        }\\n    }\\n\\n    public void helper(Node root, StringBuilder temp){\\n        if(root == null){\\n            return;\\n        }\\n\\n        for(int i=0; i<26; i++){\\n            if(root.children[i] != null && root.children[i].eow == true){\\n                temp.append((char)(i+\\'a\\'));\\n\\n                if(temp.length() > ans.length()){\\n                    ans = temp.toString();\\n                }\\n\\n                helper(root.children[i], temp);\\n\\n                temp.deleteCharAt(temp.length() - 1);\\n            }\\n        }\\n    }\\n\\n    public String longestWord(String[] words) {\\n\\n        for(int i=0; i<words.length; i++){\\n            insert(words[i]);\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n\\n        helper(root, sb);\\n\\n        return ans;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Trie"
                ],
                "code": "```\\nclass Node{\\n    Node[] children;\\n    boolean eow;\\n\\n    public Node(){\\n        children = new Node[26];\\n        for(int i=0; i<26; i++){\\n            children[i] = null;\\n        }\\n        eow = false;\\n    }\\n}\\nclass Solution {\\n    Node root = new Node();\\n    String ans = \"\";\\n    public void insert(String word){\\n        Node curr = root;\\n        for(int i=0; i<word.length(); i++){\\n            int index = word.charAt(i) - \\'a\\';\\n\\n            if(curr.children[index] == null){\\n                curr.children[index] = new Node();\\n            }\\n\\n            if(i == word.length() - 1){\\n                curr.children[index].eow = true;\\n            }\\n            curr = curr.children[index];\\n        }\\n    }\\n\\n    public void helper(Node root, StringBuilder temp){\\n        if(root == null){\\n            return;\\n        }\\n\\n        for(int i=0; i<26; i++){\\n            if(root.children[i] != null && root.children[i].eow == true){\\n                temp.append((char)(i+\\'a\\'));\\n\\n                if(temp.length() > ans.length()){\\n                    ans = temp.toString();\\n                }\\n\\n                helper(root.children[i], temp);\\n\\n                temp.deleteCharAt(temp.length() - 1);\\n            }\\n        }\\n    }\\n\\n    public String longestWord(String[] words) {\\n\\n        for(int i=0; i<words.length; i++){\\n            insert(words[i]);\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n\\n        helper(root, sb);\\n\\n        return ans;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3662643,
                "title": "trie-dfs-on-tree-beats-60-java-o-n-m",
                "content": "# Note:\\n- m: length of longest str\\n- n: number of strings\\n\\n# Complexity\\n- Time complexity: $$O(m*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m*n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass TrieNode {\\n    private final int ALPHABET_SIZE = 26;\\n    TrieNode[] children;\\n    boolean isEnd;\\n    TrieNode() {\\n        children = new TrieNode[ALPHABET_SIZE];\\n        isEnd = false;\\n    }\\n}\\n\\nclass Trie {\\n    private final TrieNode root = new TrieNode();\\n    private int maxLength = 0;\\n    private String longestStr = \"\";\\n    Trie(){}\\n    \\n    public void insert(String word) {\\n        TrieNode current = root;\\n        for (Character c: word.toCharArray()) {\\n            TrieNode child = current.children[c - 97];\\n            if(child == null) {\\n                child = new TrieNode();\\n                current.children[c - 97] = child;\\n            }\\n            current = child;\\n        }\\n        current.isEnd = true;\\n    }\\n    \\n    public String getLongestStr() {\\n        for (int i = 0; i < root.children.length; i++) {\\n            if (root.children[i] != null) {\\n                dfs(\"\" + ((char) (i + 97)), root.children[i]);\\n            }\\n        }\\n        return longestStr;\\n    }\\n\\n    private void dfs(String str, TrieNode node) {\\n        if(!node.isEnd) return;\\n        if(str.length() > maxLength) {\\n            maxLength = str.length();\\n            longestStr = str;\\n        }\\n        for (int i = 0; i < node.children.length; i++) {\\n            if(node.children[i] != null) {\\n                dfs(str + ((char) (i + 97)), node.children[i]);\\n            }\\n        }\\n    }\\n}\\n\\nclass Solution {\\n    public String longestWord(String[] words) {\\n        Trie trie = new Trie();\\n        for (String word: words) trie.insert(word);\\n        return trie.getLongestStr();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode {\\n    private final int ALPHABET_SIZE = 26;\\n    TrieNode[] children;\\n    boolean isEnd;\\n    TrieNode() {\\n        children = new TrieNode[ALPHABET_SIZE];\\n        isEnd = false;\\n    }\\n}\\n\\nclass Trie {\\n    private final TrieNode root = new TrieNode();\\n    private int maxLength = 0;\\n    private String longestStr = \"\";\\n    Trie(){}\\n    \\n    public void insert(String word) {\\n        TrieNode current = root;\\n        for (Character c: word.toCharArray()) {\\n            TrieNode child = current.children[c - 97];\\n            if(child == null) {\\n                child = new TrieNode();\\n                current.children[c - 97] = child;\\n            }\\n            current = child;\\n        }\\n        current.isEnd = true;\\n    }\\n    \\n    public String getLongestStr() {\\n        for (int i = 0; i < root.children.length; i++) {\\n            if (root.children[i] != null) {\\n                dfs(\"\" + ((char) (i + 97)), root.children[i]);\\n            }\\n        }\\n        return longestStr;\\n    }\\n\\n    private void dfs(String str, TrieNode node) {\\n        if(!node.isEnd) return;\\n        if(str.length() > maxLength) {\\n            maxLength = str.length();\\n            longestStr = str;\\n        }\\n        for (int i = 0; i < node.children.length; i++) {\\n            if(node.children[i] != null) {\\n                dfs(str + ((char) (i + 97)), node.children[i]);\\n            }\\n        }\\n    }\\n}\\n\\nclass Solution {\\n    public String longestWord(String[] words) {\\n        Trie trie = new Trie();\\n        for (String word: words) trie.insert(word);\\n        return trie.getLongestStr();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2890353,
                "title": "easy-java-solution-using-hashmap",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String longestWord(String[] words) {\\n        Arrays.sort(words);\\n        HashMap<String, Integer>map=new HashMap<>();\\n        for(int i=0;i<words.length;i++){\\n            map.put(words[i],map.getOrDefault(words[i],0)+1);\\n        }\\n        boolean flag=false;\\n        String ans=\"\";\\n        for(int i=words.length-1;i>=0;i--){\\n            if(words[i].length()<ans.length()){\\n                continue;\\n            }\\n            else{\\n                String word=\"\";\\n                boolean f=false;\\n                for(int j=0;j<words[i].length();j++){\\n                    word+=words[i].charAt(j);\\n                    if(!map.containsKey(word)){\\n                        f=true;\\n                        break;\\n                    }\\n                    \\n                }\\n                if(!f){\\n                    ans=words[i];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "String",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\n    public String longestWord(String[] words) {\\n        Arrays.sort(words);\\n        HashMap<String, Integer>map=new HashMap<>();\\n        for(int i=0;i<words.length;i++){\\n            map.put(words[i],map.getOrDefault(words[i],0)+1);\\n        }\\n        boolean flag=false;\\n        String ans=\"\";\\n        for(int i=words.length-1;i>=0;i--){\\n            if(words[i].length()<ans.length()){\\n                continue;\\n            }\\n            else{\\n                String word=\"\";\\n                boolean f=false;\\n                for(int j=0;j<words[i].length();j++){\\n                    word+=words[i].charAt(j);\\n                    if(!map.containsKey(word)){\\n                        f=true;\\n                        break;\\n                    }\\n                    \\n                }\\n                if(!f){\\n                    ans=words[i];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2598346,
                "title": "faster-than-90-python-set-dp",
                "content": "```\\nclass Solution:\\n    def longestWord(self, words: List[str]) -> str:\\n        s = set(words)\\n        \\n        words = sorted(words, key=len, reverse=True)\\n\\n        @cache\\n        def check_word(word):\\n            if len(word) > 0:\\n                if word[0: -1] in s:\\n                    return 1 + check_word(word[0:-1])\\n                else:\\n                    return 0\\n            else:\\n                return 0\\n                    \\n        ans = (\"\", 0)     \\n        for i in words:\\n            steps = check_word(i)\\n            if steps >= ans[1] and len(i) == steps+1:\\n                w = i if ans[0] == \"\" else sorted([i, ans[0]])[0]\\n                ans = (w, steps)\\n            \\n        return ans[0]\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def longestWord(self, words: List[str]) -> str:\\n        s = set(words)\\n        \\n        words = sorted(words, key=len, reverse=True)\\n\\n        @cache\\n        def check_word(word):\\n            if len(word) > 0:\\n                if word[0: -1] in s:\\n                    return 1 + check_word(word[0:-1])\\n                else:\\n                    return 0\\n            else:\\n                return 0\\n                    \\n        ans = (\"\", 0)     \\n        for i in words:\\n            steps = check_word(i)\\n            if steps >= ans[1] and len(i) == steps+1:\\n                w = i if ans[0] == \"\" else sorted([i, ans[0]])[0]\\n                ans = (w, steps)\\n            \\n        return ans[0]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2419415,
                "title": "no-trie-no-bfs-simple-solution",
                "content": "1. We start from sorting given input array\\n2. Then we check validity of words from the array..whether it can be broken down into the smaller chunks removing a letter from end every time and we maintain a count of the steps it takes.\\n3. for every word we check whether the word after removing the last letter does it exist in set.if yes..call the dfs again or just return.\\n\\n```\\nclass Solution {\\npublic:\\n    string longestWord(vector<string>& words) {\\n        unordered_set<string>st(begin(words),end(words));\\n        sort(begin(words),end(words));\\n        //for(auto i:words) cout<<i<<\".\";\\n        //vector<string>same;\\n        int maxcnt=-1;\\n        string str=\"\";\\n        for(int i=0;i<words.size();i++)\\n        {   \\n            int cnt=0;\\n            if(isvalid(words[i],st,cnt) and cnt>maxcnt){\\n                maxcnt=cnt;\\n                str=words[i];\\n            }\\n        }\\n        return str;\\n    }\\n    \\n    bool isvalid(string word,unordered_set<string>&st,int &cnt)\\n    {   \\n        if(word.size()==1 and st.count(word)) return true;//if size of word become 1 and it exist in set return\\n        word.pop_back();//removing last character form the word\\n        if(st.count(word)){\\n            cnt++;\\n            return isvalid(word,st,cnt);\\n        }\\n        return false;//if above condition fails return false\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestWord(vector<string>& words) {\\n        unordered_set<string>st(begin(words),end(words));\\n        sort(begin(words),end(words));\\n        //for(auto i:words) cout<<i<<\".\";\\n        //vector<string>same;\\n        int maxcnt=-1;\\n        string str=\"\";\\n        for(int i=0;i<words.size();i++)\\n        {   \\n            int cnt=0;\\n            if(isvalid(words[i],st,cnt) and cnt>maxcnt){\\n                maxcnt=cnt;\\n                str=words[i];\\n            }\\n        }\\n        return str;\\n    }\\n    \\n    bool isvalid(string word,unordered_set<string>&st,int &cnt)\\n    {   \\n        if(word.size()==1 and st.count(word)) return true;//if size of word become 1 and it exist in set return\\n        word.pop_back();//removing last character form the word\\n        if(st.count(word)){\\n            cnt++;\\n            return isvalid(word,st,cnt);\\n        }\\n        return false;//if above condition fails return false\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2219674,
                "title": "c-trie-well-explained",
                "content": "Tricky explanation in my opinion. First, you need to understand, that our result word, should be constructed from other words in given array. Therefore it means: [\"a\",\"banana\",\"app\",\"appl\",\"ap\",\"apply\",\"apple\"]\\n - We CAN create words \"apply\" and \"apple\" in this way: \"a\", \"ap\", \"app\", \"appl\", and at last we have two options \"apply\" or \"apple\". All previously built strings were actual words, so that\\'s why we could use them.\\n - We CAN\\'T use word \"banana\" cause it\\'s impossible to build it. There is no such strings like:  \"b\", \"ba\", \"ban\", \"bana\", etc. \\n\\nIf you understand it, then it\\'s quite easy to find out that Trie, with little updates works great here. We iterate through array(vector) and add every word to Trie. Then we search for longest word in filled Trie. Let\\'s consider another example:  [\"w\",\"wo\",\"wor\",\"worl\",\"world\"]\\n - Initially we consider longest string as \"\".\\n - Start traversal, checking that current letter is actual end of some word. If it isn\\'t word end, skip this letter. \\n\\t - Pick \"w\", check that it\\'s a word.\\n - Go so far, as we can go, and update longest string, when we met new word.\\n\\t - Try to build a longet word upon \"w\". Update result after traversal.\\n\\t - 1st level \"w\" -> 2nd level \"wo\" ->  3rd level \"wor\" -> 4th level \"worl\" -> 5th level \"world\".\\n \\n Here is my solution: \\n```\\nclass TrieNode {\\n\\t\\tpublic:\\n\\t\\t\\tbool isWord = false;\\n\\t\\t\\tTrieNode* next[26] = {};\\n};\\nclass Solution {\\n\\tpublic:\\n\\t\\tstring longestWord(vector<string>& words) {\\n\\t\\t\\t// iterate and add each word\\n\\t\\t\\tfor (string word: words) {\\n\\t\\t\\t  save(word);\\n\\t\\t\\t}\\n\\t\\t\\treturn searchLongest();\\n\\t\\t}\\n\\n\\t  private: \\n\\t\\tTrieNode* root = new TrieNode();\\n  \\n\\t\\tvoid save(string word) {\\n\\t\\t  TrieNode* node = root;\\n\\t\\t  for (char ch : word) {\\n\\t\\t\\tch -= \\'a\\';\\n\\t\\t\\tif (!node->next[ch]) {\\n\\t\\t\\t  node->next[ch] = new TrieNode();\\n\\t\\t\\t}\\n\\t\\t\\tnode = node->next[ch];\\n\\t\\t  }\\n\\t\\t  node->isWord = true;\\n\\t\\t}\\n\\n\\t\\tstring searchLongest() {\\n\\t\\t  return search(root, \"\");\\n\\t\\t}\\n\\n\\t\\tstring search(TrieNode* node, string word) {\\n\\t\\t  string res = word, temp;\\n\\t\\t  // check every letter\\n\\t\\t  for (int i = 0; i < 26; i++) {\\n\\t\\t    // if pointer exists and and it\\'s a word\\n\\t\\t\\tif (node->next[i] && node->next[i]->isWord) {\\n\\t\\t\\t  // add letter to word\\n\\t\\t\\t  word.push_back((char)(i + \\'a\\'));\\n\\t\\t\\t  // search further\\n\\t\\t\\t  temp = search(node->next[i], word);\\n\\t\\t\\t  // remove letter, to not sabotage next searches from this word\\n\\t\\t\\t  word.pop_back();\\n\\t\\t\\t  if (res.length() < temp.length()) {\\n\\t\\t\\t\\tres = temp;\\n\\t\\t\\t  } else if(res.length() == temp.length()) {\\n\\t\\t\\t\\tres = res < temp ? res : temp;\\n\\t\\t\\t  }\\n\\t\\t\\t}\\n\\t\\t  }\\n\\t\\t  return res;\\n\\t\\t}\\n\\t};\\n```\\n\\nThere is several ways to improve this code. You can do it by yourself, once you get the idea. Good luck!",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode {\\n\\t\\tpublic:\\n\\t\\t\\tbool isWord = false;\\n\\t\\t\\tTrieNode* next[26] = {};\\n};\\nclass Solution {\\n\\tpublic:\\n\\t\\tstring longestWord(vector<string>& words) {\\n\\t\\t\\t// iterate and add each word\\n\\t\\t\\tfor (string word: words) {\\n\\t\\t\\t  save(word);\\n\\t\\t\\t}\\n\\t\\t\\treturn searchLongest();\\n\\t\\t}\\n\\n\\t  private: \\n\\t\\tTrieNode* root = new TrieNode();\\n  \\n\\t\\tvoid save(string word) {\\n\\t\\t  TrieNode* node = root;\\n\\t\\t  for (char ch : word) {\\n\\t\\t\\tch -= \\'a\\';\\n\\t\\t\\tif (!node->next[ch]) {\\n\\t\\t\\t  node->next[ch] = new TrieNode();\\n\\t\\t\\t}\\n\\t\\t\\tnode = node->next[ch];\\n\\t\\t  }\\n\\t\\t  node->isWord = true;\\n\\t\\t}\\n\\n\\t\\tstring searchLongest() {\\n\\t\\t  return search(root, \"\");\\n\\t\\t}\\n\\n\\t\\tstring search(TrieNode* node, string word) {\\n\\t\\t  string res = word, temp;\\n\\t\\t  // check every letter\\n\\t\\t  for (int i = 0; i < 26; i++) {\\n\\t\\t    // if pointer exists and and it\\'s a word\\n\\t\\t\\tif (node->next[i] && node->next[i]->isWord) {\\n\\t\\t\\t  // add letter to word\\n\\t\\t\\t  word.push_back((char)(i + \\'a\\'));\\n\\t\\t\\t  // search further\\n\\t\\t\\t  temp = search(node->next[i], word);\\n\\t\\t\\t  // remove letter, to not sabotage next searches from this word\\n\\t\\t\\t  word.pop_back();\\n\\t\\t\\t  if (res.length() < temp.length()) {\\n\\t\\t\\t\\tres = temp;\\n\\t\\t\\t  } else if(res.length() == temp.length()) {\\n\\t\\t\\t\\tres = res < temp ? res : temp;\\n\\t\\t\\t  }\\n\\t\\t\\t}\\n\\t\\t  }\\n\\t\\t  return res;\\n\\t\\t}\\n\\t};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2167062,
                "title": "javascript-solution-using-trie-class-object",
                "content": "Trie Class Object\\n```\\nclass Trie {\\n  constructor() {\\n    this.root = {};\\n  }\\n\\n  insert(word) {\\n    let node = this.root;\\n    \\n    for(const char of word) {\\n      if(!node[char]) node[char] = {}; // char doesn\\'t exist, add it\\n      node = node[char]; // move to next node\\n    }\\n    \\n    node.isEnd = true; // reached end of current word\\n  }\\n\\n  search(word) {\\n    let node = this.root;\\n\\n    for(const char of word) {\\n      if(!node[char]) return false; // if char does not exist, prefix is invalid\\n      node = node[char]; // move to next node\\n    }\\n\\n    return node.isEnd || false; // if node is a word, return true (return false otherwise)\\n  }\\n\\n  startsWith(prefix) { // didn\\'t use this method in the longestWord() function\\n    let node = this.root;\\n\\n    for(const char of prefix) {\\n      if(!node[char]) return false; // if char does not exist, prefix is invalid\\n      node = node[char]; // move to next node\\n    }\\n\\n    return true;\\n  }\\n}\\n```\\nlongestWord() function\\n```\\nvar longestWord = function(words) {\\n  words.sort();\\n  let trie = new Trie();\\n  let result = \"\"\\n  \\n  for (const word of words) {\\n      if (word.length === 1) {\\n          trie.insert(word);\\n          result = word.length > result.length ? word : result;\\n      } else {\\n          let has = trie.search(word.slice(0, word.length-1));\\n          if (has) {\\n              trie.insert(word);\\n              result = word.length > result.length ? word : result;\\n          }\\n      }\\n  }\\n  \\n  return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Trie"
                ],
                "code": "```\\nclass Trie {\\n  constructor() {\\n    this.root = {};\\n  }\\n\\n  insert(word) {\\n    let node = this.root;\\n    \\n    for(const char of word) {\\n      if(!node[char]) node[char] = {}; // char doesn\\'t exist, add it\\n      node = node[char]; // move to next node\\n    }\\n    \\n    node.isEnd = true; // reached end of current word\\n  }\\n\\n  search(word) {\\n    let node = this.root;\\n\\n    for(const char of word) {\\n      if(!node[char]) return false; // if char does not exist, prefix is invalid\\n      node = node[char]; // move to next node\\n    }\\n\\n    return node.isEnd || false; // if node is a word, return true (return false otherwise)\\n  }\\n\\n  startsWith(prefix) { // didn\\'t use this method in the longestWord() function\\n    let node = this.root;\\n\\n    for(const char of prefix) {\\n      if(!node[char]) return false; // if char does not exist, prefix is invalid\\n      node = node[char]; // move to next node\\n    }\\n\\n    return true;\\n  }\\n}\\n```\n```\\nvar longestWord = function(words) {\\n  words.sort();\\n  let trie = new Trie();\\n  let result = \"\"\\n  \\n  for (const word of words) {\\n      if (word.length === 1) {\\n          trie.insert(word);\\n          result = word.length > result.length ? word : result;\\n      } else {\\n          let has = trie.search(word.slice(0, word.length-1));\\n          if (has) {\\n              trie.insert(word);\\n              result = word.length > result.length ? word : result;\\n          }\\n      }\\n  }\\n  \\n  return result;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2113293,
                "title": "hashset-c-medium-difficult-to-understand-similar-to-trie",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    class node\\n    {\\n    public:\\n        char val;\\n        set<node *> children;\\n        node(char ch)\\n        {\\n            val = ch;\\n        }\\n    };\\n    void traverse(node *root, string &ans, int &mx_size, string s, map<string, int> &mp)\\n    {\\n        s += root->val;\\n        if (mp[s] != 1)\\n        {\\n            s.pop_back();\\n            if ((int)s.size() > mx_size)\\n            {\\n                mx_size = s.size();\\n                ans = s;\\n            }\\n            else if ((int)s.size() == mx_size)\\n            {\\n                if (s < ans)\\n                    ans = s;\\n            }\\n            return;\\n        }\\n        \\n        if (root->children.size() == 0)\\n        {\\n            if ((int)s.size() > mx_size)\\n            {\\n                mx_size = s.size();\\n                ans = s;\\n            }\\n            else if ((int)s.size() == mx_size)\\n            {\\n                if (s < ans)\\n                    ans = s;\\n            }\\n        }\\n        for (auto it : root->children)\\n        {\\n            traverse(it, ans, mx_size, s, mp);\\n        }\\n    }\\n    string longestWord(vector<string> &words)\\n    {\\n        map<string, int> mp;\\n        for (auto it : words)\\n            mp[it] = 1;\\n        node *root = new node(\\'.\\');\\n        node *temp;\\n        bool found;\\n        for (auto it : words)\\n        {\\n            temp = root;\\n            for (auto i : it)\\n            {\\n                found = false;\\n                for (auto child : temp->children)\\n                {\\n                    if (child->val == i)\\n                    {\\n                        found = true;\\n                        temp = child;\\n                        break;\\n                    }\\n                }\\n                if (found == false)\\n                {\\n                    node *new_child = new node(i);\\n                    temp->children.insert(new_child);\\n                    temp = new_child;\\n                }\\n            }\\n        }\\n        string ans;\\n        int mx = -1;\\n        for (auto it : root->children)\\n            traverse(it, ans, mx, \"\", mp);\\n        return ans;\\n    }\\n};\\n```\\n ![image](https://assets.leetcode.com/users/images/6b051394-a2ae-4159-a781-14c4143720da_1654413565.920411.png)\\n \\n![image](https://assets.leetcode.com/users/images/1e377837-61f8-44da-8a87-b9698a17b427_1654413592.510828.png)\\n\\n![image](https://assets.leetcode.com/users/images/54b982b4-5d4f-409f-bcae-dbd95810d00a_1654413619.6681156.png)\\n\\n# Please Upvote if you like it !!\\n",
                "solutionTags": [
                    "Trie",
                    "Recursion",
                    "Iterator",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    class node\\n    {\\n    public:\\n        char val;\\n        set<node *> children;\\n        node(char ch)\\n        {\\n            val = ch;\\n        }\\n    };\\n    void traverse(node *root, string &ans, int &mx_size, string s, map<string, int> &mp)\\n    {\\n        s += root->val;\\n        if (mp[s] != 1)\\n        {\\n            s.pop_back();\\n            if ((int)s.size() > mx_size)\\n            {\\n                mx_size = s.size();\\n                ans = s;\\n            }\\n            else if ((int)s.size() == mx_size)\\n            {\\n                if (s < ans)\\n                    ans = s;\\n            }\\n            return;\\n        }\\n        \\n        if (root->children.size() == 0)\\n        {\\n            if ((int)s.size() > mx_size)\\n            {\\n                mx_size = s.size();\\n                ans = s;\\n            }\\n            else if ((int)s.size() == mx_size)\\n            {\\n                if (s < ans)\\n                    ans = s;\\n            }\\n        }\\n        for (auto it : root->children)\\n        {\\n            traverse(it, ans, mx_size, s, mp);\\n        }\\n    }\\n    string longestWord(vector<string> &words)\\n    {\\n        map<string, int> mp;\\n        for (auto it : words)\\n            mp[it] = 1;\\n        node *root = new node(\\'.\\');\\n        node *temp;\\n        bool found;\\n        for (auto it : words)\\n        {\\n            temp = root;\\n            for (auto i : it)\\n            {\\n                found = false;\\n                for (auto child : temp->children)\\n                {\\n                    if (child->val == i)\\n                    {\\n                        found = true;\\n                        temp = child;\\n                        break;\\n                    }\\n                }\\n                if (found == false)\\n                {\\n                    node *new_child = new node(i);\\n                    temp->children.insert(new_child);\\n                    temp = new_child;\\n                }\\n            }\\n        }\\n        string ans;\\n        int mx = -1;\\n        for (auto it : root->children)\\n            traverse(it, ans, mx, \"\", mp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875488,
                "title": "easy-trie-c-solution-explained",
                "content": "Approach\\n1.Store all the words in a trie \\n2.Then  traverse the array and check if all of its prefixes exist in the trie \\n3.If they exist then update ans according to the lengths of the words\\n4.To check if all the prefixes of a word exist loop through the word and if the charcter is not in trie return false\\n5.Else check if the character is the end of a string example for word \"ninja\" we check if \"n\" exists and n is the end of a string similarly \"ni\" exists and \"ni\" is the end of a string similarly for \"nin\" ,\"ninj\" and \"ninja\"\\n```\\nstruct Node{\\n    Node* links[26];\\n    bool isEOW = false;\\n    bool containsKey(char ch){\\n        return links[ch-\\'a\\']!=NULL;\\n    }\\n    Node* get(char ch){\\n        return links[ch-\\'a\\'];\\n    }\\n    void put(char ch,Node* node){\\n        links[ch-\\'a\\']=node;\\n    }\\n    void setEnd(){\\n        isEOW = true;\\n    }\\n    bool isEnd(){\\n        return isEOW;\\n    }\\n};\\nclass Trie{\\nprivate:\\n    Node* root;\\npublic:\\n    Trie(){\\n        root = new Node();\\n    }\\n    void insert(string word){\\n        Node* temp = root;\\n        for(int i=0;i<word.size();i++){\\n            if(!temp->containsKey(word[i]))\\n            {\\n                temp->put(word[i],new Node());\\n            }\\n            temp = temp->get(word[i]);\\n        }\\n        temp->setEnd();\\n    }\\n    bool isPrefix(string word){\\n        Node* temp = root;\\n        bool flag = true;\\n        for(int i=0;i<word.size();i++){\\n            if(!temp->containsKey(word[i]))\\n                return false;\\n            temp = temp->get(word[i]);\\n            flag = flag&temp->isEnd();\\n        }\\n        flag = flag&temp->isEnd();\\n        return flag;\\n    }\\n};\\nclass Solution {\\npublic:\\n    string longestWord(vector<string>& words) {\\n        Trie* trie = new Trie();\\n        for(auto x : words)\\n            trie->insert(x);\\n        string ans = \"\";\\n        for(auto x : words){\\n            if(trie->isPrefix(x)){\\n                if(ans.size()==x.size())\\n                    ans = ans<x?ans:x;\\n                else\\n                    ans = ans.size()>x.size()?ans:x;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstruct Node{\\n    Node* links[26];\\n    bool isEOW = false;\\n    bool containsKey(char ch){\\n        return links[ch-\\'a\\']!=NULL;\\n    }\\n    Node* get(char ch){\\n        return links[ch-\\'a\\'];\\n    }\\n    void put(char ch,Node* node){\\n        links[ch-\\'a\\']=node;\\n    }\\n    void setEnd(){\\n        isEOW = true;\\n    }\\n    bool isEnd(){\\n        return isEOW;\\n    }\\n};\\nclass Trie{\\nprivate:\\n    Node* root;\\npublic:\\n    Trie(){\\n        root = new Node();\\n    }\\n    void insert(string word){\\n        Node* temp = root;\\n        for(int i=0;i<word.size();i++){\\n            if(!temp->containsKey(word[i]))\\n            {\\n                temp->put(word[i],new Node());\\n            }\\n            temp = temp->get(word[i]);\\n        }\\n        temp->setEnd();\\n    }\\n    bool isPrefix(string word){\\n        Node* temp = root;\\n        bool flag = true;\\n        for(int i=0;i<word.size();i++){\\n            if(!temp->containsKey(word[i]))\\n                return false;\\n            temp = temp->get(word[i]);\\n            flag = flag&temp->isEnd();\\n        }\\n        flag = flag&temp->isEnd();\\n        return flag;\\n    }\\n};\\nclass Solution {\\npublic:\\n    string longestWord(vector<string>& words) {\\n        Trie* trie = new Trie();\\n        for(auto x : words)\\n            trie->insert(x);\\n        string ans = \"\";\\n        for(auto x : words){\\n            if(trie->isPrefix(x)){\\n                if(ans.size()==x.size())\\n                    ans = ans<x?ans:x;\\n                else\\n                    ans = ans.size()>x.size()?ans:x;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1851972,
                "title": "c-solution-using-trie-no-sorting-modified-searchtrie-function",
                "content": "As we use Trie to store the prefixes, we do not need to sort the words.\\nSorting surely bumps up the time taken to O(N LogN). \\nMy solution includes a modified searchTrie() function which returns false when any of in between characters didn\\'t form a word during search. We return true only if current word forms a word (and all its previous characters). After returning update the result if the current word\\'s length is longer than previous or it is lexicographically smaller word than previous. Check out the comments and code. \\n\\n```\\n#define CHAR_SET    26\\n#define WLEN        31\\n\\ntypedef struct Trie{\\n    struct Trie *children[CHAR_SET];\\n    bool isWord;\\n} Trie;\\n\\n/** Initialize your data structure here. */\\n\\nTrie* trieCreate() {\\n    Trie *newNode = malloc(sizeof(Trie));\\n    newNode->isWord = false;\\n    for(int i = 0; i < CHAR_SET; i++)\\n        newNode->children[i] = NULL;\\n    return newNode;\\n}\\n\\n/** Inserts a word into the trie. */\\nvoid trieInsert(Trie* obj, char * word) {\\n    int len = strlen(word), i, idx;\\n    for(i = 0; i < len; i++) {\\n        if(!obj->children[word[i] - \\'a\\'])\\n            obj->children[word[i] - \\'a\\'] = trieCreate();\\n        \\n        obj = obj->children[word[i] - \\'a\\'];\\n    }\\n    obj->isWord = true;\\n}\\n\\n/** Returns if the word is in the trie. */\\nbool trieSearch(Trie* obj, char * word, int len, int *words) {\\n    for(int i = 0; i < len; i++) {\\n        if(!obj->children[word[i] - \\'a\\']) \\n            return false;\\n        \\n        obj = obj->children[word[i] - \\'a\\'];\\n        // every character in the prefix should have been one of the words in list\\n        if(!obj->isWord)    \\n            return false;\\n    }\\n    \\n    return obj->isWord;\\n}\\n\\nchar * longestWord(char ** words, int wordsSize){\\n    char *result = calloc(WLEN, 1);\\n    Trie* root = trieCreate();\\n    int maxLen = INT_MIN, prevWords = 0, len;\\n    \\n    // insert all words to trie\\n    for(int i = 0; i < wordsSize; i++)\\n        trieInsert(root, words[i]);\\n        \\n    // search for word which matches all prefixes from previous words\\n    for(int i = 0; i < wordsSize; i++) {\\n        len = strlen(words[i]);\\n        // All characters in current word forms a words in input list?\\n        if(trieSearch(root, words[i], len, &prevWords)) {\\n            if(len > maxLen) {\\n                maxLen = len;\\n                strcpy(result, words[i]);\\n            } else if(len == maxLen) {        \\n                // lexicographically smaller word is the result\\n                if(strcmp(result, words[i]) > 0)\\n                    strcpy(result, words[i]);\\n            }\\n        }\\n    }\\n    return result;\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\n#define CHAR_SET    26\\n#define WLEN        31\\n\\ntypedef struct Trie{\\n    struct Trie *children[CHAR_SET];\\n    bool isWord;\\n} Trie;\\n\\n/** Initialize your data structure here. */\\n\\nTrie* trieCreate() {\\n    Trie *newNode = malloc(sizeof(Trie));\\n    newNode->isWord = false;\\n    for(int i = 0; i < CHAR_SET; i++)\\n        newNode->children[i] = NULL;\\n    return newNode;\\n}\\n\\n/** Inserts a word into the trie. */\\nvoid trieInsert(Trie* obj, char * word) {\\n    int len = strlen(word), i, idx;\\n    for(i = 0; i < len; i++) {\\n        if(!obj->children[word[i] - \\'a\\'])\\n            obj->children[word[i] - \\'a\\'] = trieCreate();\\n        \\n        obj = obj->children[word[i] - \\'a\\'];\\n    }\\n    obj->isWord = true;\\n}\\n\\n/** Returns if the word is in the trie. */\\nbool trieSearch(Trie* obj, char * word, int len, int *words) {\\n    for(int i = 0; i < len; i++) {\\n        if(!obj->children[word[i] - \\'a\\']) \\n            return false;\\n        \\n        obj = obj->children[word[i] - \\'a\\'];\\n        // every character in the prefix should have been one of the words in list\\n        if(!obj->isWord)    \\n            return false;\\n    }\\n    \\n    return obj->isWord;\\n}\\n\\nchar * longestWord(char ** words, int wordsSize){\\n    char *result = calloc(WLEN, 1);\\n    Trie* root = trieCreate();\\n    int maxLen = INT_MIN, prevWords = 0, len;\\n    \\n    // insert all words to trie\\n    for(int i = 0; i < wordsSize; i++)\\n        trieInsert(root, words[i]);\\n        \\n    // search for word which matches all prefixes from previous words\\n    for(int i = 0; i < wordsSize; i++) {\\n        len = strlen(words[i]);\\n        // All characters in current word forms a words in input list?\\n        if(trieSearch(root, words[i], len, &prevWords)) {\\n            if(len > maxLen) {\\n                maxLen = len;\\n                strcpy(result, words[i]);\\n            } else if(len == maxLen) {        \\n                // lexicographically smaller word is the result\\n                if(strcmp(result, words[i]) > 0)\\n                    strcpy(result, words[i]);\\n            }\\n        }\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1827804,
                "title": "python-easiest-to-understand-o-w-solution",
                "content": "Method:\\n1. Get prefix of each word\\n2. Construct a start_list of words with only 1 letter\\n3. BFS starting from the 1 letter to find longest word. This is O(W) as the queue of each BFS will be different given the different prefix (i.e. queue created from the start_word \"a\" will always be different from a queue created from start_word \"b\")\\n\\n```\\nclass Solution:\\n    def longestWord(self, words: List[str]) -> str:\\n        prefix_dict = defaultdict(list)\\n        start_list = []\\n        \\n        for word in words:\\n            if len(word) == 1:\\n                start_list.append(word)\\n            prefix_dict[word[:-1]].append(word)\\n        \\n\\n        if len(start_list) == 0:\\n            return \"\"\\n        \\n\\n        longest_word = start_list[0]     \\n        for word in start_list:\\n            queue = []\\n            queue += prefix_dict[word]\\n            print(queue)\\n            while queue:\\n                cur = queue.pop()\\n                if len(cur) > len(longest_word):\\n                    longest_word = cur\\n                if len(cur) == len(longest_word):\\n                    longest_word = min(longest_word, cur)\\n                queue += prefix_dict[cur] \\n                \\n        return longest_word\\n                \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass Solution:\\n    def longestWord(self, words: List[str]) -> str:\\n        prefix_dict = defaultdict(list)\\n        start_list = []\\n        \\n        for word in words:\\n            if len(word) == 1:\\n                start_list.append(word)\\n            prefix_dict[word[:-1]].append(word)\\n        \\n\\n        if len(start_list) == 0:\\n            return \"\"\\n        \\n\\n        longest_word = start_list[0]     \\n        for word in start_list:\\n            queue = []\\n            queue += prefix_dict[word]\\n            print(queue)\\n            while queue:\\n                cur = queue.pop()\\n                if len(cur) > len(longest_word):\\n                    longest_word = cur\\n                if len(cur) == len(longest_word):\\n                    longest_word = min(longest_word, cur)\\n                queue += prefix_dict[cur] \\n                \\n        return longest_word\\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1757394,
                "title": "python-trie-bfs-without-using-extra-class",
                "content": "Using dictionary in dictionary to represent trie tree, in this case we don\\'t need to create extra TrieNode class.\\n\\n**Complexity**\\n\\nTime: O(N * M), where N <= 1000 is length of words, M <= 30 is length of each word.\\nSpace: O(N * M)\\n\\n```\\nclass Solution:\\n    def longestWord(self, words: List[str]) -> str:\\n        trie = {}\\n        for word in words:\\n            curr_node = trie\\n            for c in word:\\n                if c not in curr_node:\\n                    curr_node[c] = {}\\n                curr_node = curr_node[c]\\n            curr_node[\"#\"] = word\\n        \\n        queue = collections.deque()\\n        queue.append(trie)\\n        res = \"\"\\n        while queue:\\n            curr_node = queue.popleft()\\n            for char in curr_node.keys():\\n                if \"#\" in curr_node[char]:\\n                    next_node = curr_node[char]\\n                    queue.append(next_node)\\n                    if len(next_node[\"#\"]) > len(res) or next_node[\"#\"] < res:\\n                        res = next_node[\"#\"]\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass Solution:\\n    def longestWord(self, words: List[str]) -> str:\\n        trie = {}\\n        for word in words:\\n            curr_node = trie\\n            for c in word:\\n                if c not in curr_node:\\n                    curr_node[c] = {}\\n                curr_node = curr_node[c]\\n            curr_node[\"#\"] = word\\n        \\n        queue = collections.deque()\\n        queue.append(trie)\\n        res = \"\"\\n        while queue:\\n            curr_node = queue.popleft()\\n            for char in curr_node.keys():\\n                if \"#\" in curr_node[char]:\\n                    next_node = curr_node[char]\\n                    queue.append(next_node)\\n                    if len(next_node[\"#\"]) > len(res) or next_node[\"#\"] < res:\\n                        res = next_node[\"#\"]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1722216,
                "title": "clean-and-easy-java-code",
                "content": "```\\nclass Solution {\\n    public String longestWord(String[] words) {\\n       Set<String> set = new HashSet<>();\\n        Arrays.sort(words);\\n        \\n       int max = 0; String res = \"\";\\n        \\n        for(String w : words) {      \\n            int n = w.length();            \\n            if(n == 1 || set.contains(w.substring(0,n-1))){\\n                set.add(w);\\n                if(max < n) {\\n                    max = n;\\n                    res = w;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String longestWord(String[] words) {\\n       Set<String> set = new HashSet<>();\\n        Arrays.sort(words);\\n        \\n       int max = 0; String res = \"\";\\n        \\n        for(String w : words) {      \\n            int n = w.length();            \\n            if(n == 1 || set.contains(w.substring(0,n-1))){\\n                set.add(w);\\n                if(max < n) {\\n                    max = n;\\n                    res = w;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1714699,
                "title": "python-3-sort-set",
                "content": "```\\nclass Solution:\\n    def longestWord(self, words: List[str]) -> str:\\n        # 1. Use a hashset (pre) to store prefixes\\n        # 2. Sort the dictionary in ascending order\\n        res, pre, words = \"\", set(), sorted(words)\\n        \\n        for w in words:\\n            # 1. Only store prefixes that is a single character\\n            #    or already has prefix in the hashset\\n            # 2. Only update the result when the length\\n            #    of the new word exceeds the old result\\n            if len(w) == 1 or w[:-1] in pre:\\n                pre.add(w)\\n                res = w if len(w) > len(res) else res\\n\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestWord(self, words: List[str]) -> str:\\n        # 1. Use a hashset (pre) to store prefixes\\n        # 2. Sort the dictionary in ascending order\\n        res, pre, words = \"\", set(), sorted(words)\\n        \\n        for w in words:\\n            # 1. Only store prefixes that is a single character\\n            #    or already has prefix in the hashset\\n            # 2. Only update the result when the length\\n            #    of the new word exceeds the old result\\n            if len(w) == 1 or w[:-1] in pre:\\n                pre.add(w)\\n                res = w if len(w) > len(res) else res\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1704680,
                "title": "c-simplest-intuitive-solution-faster-than-90-25-trie",
                "content": "* Insert all the words into a trie.\\n* If all the prefixes of a word exist & the word is longer than the current ```longest``` or is lexiographically smaller than ```longest``` then make it ```longest```.\\n\\n**Time Complexity :** O(n *x* m) - n = length of the array ```words``` & m = length of the longest word in ```words```.\\n\\n**Code :**\\n```\\nclass TrieNode{\\npublic:\\n    TrieNode *child[26];\\n    bool isEnd;\\n    \\n    TrieNode(){\\n        this->isEnd = false;\\n        for(int i=0; i<26; i++) this->child[i] = NULL;\\n    }\\n};\\n\\nclass Solution {\\nprivate:\\n    TrieNode *newNode;\\n    //To check is all the prefixes of a word exist ie; if \"temp->isEnd\" for all the letters/ nodes of the word\\n    bool AllPrefixesExist(string word){\\n        TrieNode *t = newNode;\\n        bool flag = true;\\n        \\n        for(auto &w : word){\\n            if(t->child[w-\\'a\\']){\\n                t = t->child[w-\\'a\\'];\\n                flag = flag & t->isEnd;\\n            }else return false;\\n        }\\n        return flag;\\n    }\\n    \\n    //Inserts a word into trie & sets isEnd of last node to true indicating that it is the end of the word\\n    void insert(string s){\\n        TrieNode *temp = newNode;\\n        for(auto l : s){\\n            if(!temp->child[l-\\'a\\']) temp->child[l-\\'a\\'] = new TrieNode();\\n            temp = temp->child[l-\\'a\\'];\\n        }\\n        temp->isEnd = true;\\n    }\\n    \\npublic:\\n    string longestWord(vector<string>& words) {\\n        newNode = new TrieNode();\\n        \\n        for(auto &x : words) insert(x);\\n        \\n        string longest = \"\";\\n        for(auto &x : words){\\n            \\n            if(AllPrefixesExist(x)){ \\n                //If all the prefixes of a word exist & the word is greater than the prev longest or it\\'s lexiographically smaller, make it longest\\n                if((x.size() > longest.size()) ||\\n                   (x.size() == longest.size() && x < longest)) \\n                    longest = x;\\n            }\\n        }\\n        if(longest == \"\") return \"\";\\n        return longest;\\n    }\\n};\\n```\\n\\n**Do upvote if you like the solution!**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Trie"
                ],
                "code": "```longest```\n```longest```\n```longest```\n```words```\n```words```\n```\\nclass TrieNode{\\npublic:\\n    TrieNode *child[26];\\n    bool isEnd;\\n    \\n    TrieNode(){\\n        this->isEnd = false;\\n        for(int i=0; i<26; i++) this->child[i] = NULL;\\n    }\\n};\\n\\nclass Solution {\\nprivate:\\n    TrieNode *newNode;\\n    //To check is all the prefixes of a word exist ie; if \"temp->isEnd\" for all the letters/ nodes of the word\\n    bool AllPrefixesExist(string word){\\n        TrieNode *t = newNode;\\n        bool flag = true;\\n        \\n        for(auto &w : word){\\n            if(t->child[w-\\'a\\']){\\n                t = t->child[w-\\'a\\'];\\n                flag = flag & t->isEnd;\\n            }else return false;\\n        }\\n        return flag;\\n    }\\n    \\n    //Inserts a word into trie & sets isEnd of last node to true indicating that it is the end of the word\\n    void insert(string s){\\n        TrieNode *temp = newNode;\\n        for(auto l : s){\\n            if(!temp->child[l-\\'a\\']) temp->child[l-\\'a\\'] = new TrieNode();\\n            temp = temp->child[l-\\'a\\'];\\n        }\\n        temp->isEnd = true;\\n    }\\n    \\npublic:\\n    string longestWord(vector<string>& words) {\\n        newNode = new TrieNode();\\n        \\n        for(auto &x : words) insert(x);\\n        \\n        string longest = \"\";\\n        for(auto &x : words){\\n            \\n            if(AllPrefixesExist(x)){ \\n                //If all the prefixes of a word exist & the word is greater than the prev longest or it\\'s lexiographically smaller, make it longest\\n                if((x.size() > longest.size()) ||\\n                   (x.size() == longest.size() && x < longest)) \\n                    longest = x;\\n            }\\n        }\\n        if(longest == \"\") return \"\";\\n        return longest;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1637850,
                "title": "c-using-set-with-explanation",
                "content": "in this approach we store all string set and choose one string and find all prefix of that in set if find the we store as result and compare max length and lexigraphically small string.\\n```\\n        string res=\"\";\\n        set<string>st;\\n        for(auto i:words)\\n        {\\n            st.insert(i);\\n        }\\n        for(int i=0;i<words.size();i++)\\n        {\\n            string s=words[i];\\n            int n=s.size();\\n            int f=0;\\n            while(n-1>0)\\n            {\\n                string k=s.substr(0,n-1);\\n                if(st.find(k)==st.end())\\n                {\\n                    f=1;\\n                    break;\\n                }\\n               \\n                n--;\\n            }\\n            if(f==0&&res.size()<=s.size())\\n            {\\n                if(res.size()==s.size())\\n                {\\n                    if(res>s)\\n                    {\\n                        res=s;\\n                    }\\n                    \\n                }\\n                else\\n                {\\n                    res=s;\\n                }  \\n            }\\n        }\\n        return res;\\n\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\n        string res=\"\";\\n        set<string>st;\\n        for(auto i:words)\\n        {\\n            st.insert(i);\\n        }\\n        for(int i=0;i<words.size();i++)\\n        {\\n            string s=words[i];\\n            int n=s.size();\\n            int f=0;\\n            while(n-1>0)\\n            {\\n                string k=s.substr(0,n-1);\\n                if(st.find(k)==st.end())\\n                {\\n                    f=1;\\n                    break;\\n                }\\n               \\n                n--;\\n            }\\n            if(f==0&&res.size()<=s.size())\\n            {\\n                if(res.size()==s.size())\\n                {\\n                    if(res>s)\\n                    {\\n                        res=s;\\n                    }\\n                    \\n                }\\n                else\\n                {\\n                    res=s;\\n                }  \\n            }\\n        }\\n        return res;\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1518850,
                "title": "java-trie-sorting-with-comments",
                "content": "Here is a solution using a trie and sorting our array initially. Added some comments to make it easier to understand. Slightly different implementation than the solution. \\n\\n```\\nclass Solution {\\n    public String longestWord(String[] words) {\\n        \\n        //Sort array by size, if equal, lexicographical order\\n        Arrays.sort(words, new customComp());\\n        Tnode root = new Tnode(); \\n        \\n        // Build Tri\\n        for(String s : words) {\\n            addWord(s, root);\\n        }\\n        \\n        // Since it is sorted, first one to match, will be answer\\n        for(String s : words) {\\n            if(canBuild(s, root)) return s; \\n        }\\n        \\n        // Nothing found\\n        return \"\"; \\n    }\\n    \\n    // Checks if all prefixes are words, if not, false\\n    public boolean canBuild(String word, Tnode root) {\\n        Tnode iter = root; \\n        for(int i = 0; i < word.length(); i++) {\\n            int cInt = word.charAt(i) - \\'a\\'; \\n            if(!iter.ch[cInt].word) return false;\\n            iter = iter.ch[cInt];\\n        }\\n        return true; \\n    } \\n    \\n    //Adding words to our tri\\n    public void addWord(String s, Tnode root) {\\n        Tnode iter = root; \\n        for(int i = 0;i < s.length(); i++) {\\n            int cInt = s.charAt(i) - \\'a\\'; \\n            if(iter.ch[cInt] == null) {\\n                iter.ch[cInt] = new Tnode(); \\n            }\\n            iter = iter.ch[cInt]; \\n        }\\n        iter.word = true; \\n        \\n    }\\n    \\n    // Custom Node for Tri\\n    public class Tnode {\\n        Tnode[] ch; \\n        boolean word; \\n        \\n        public Tnode() {\\n            ch = new Tnode[26];\\n        }\\n    }\\n    \\n    // Custom comparator for our array. 1. length 2. lexiographical \\n    public class customComp implements Comparator<String> {\\n        @Override\\n        public int compare(String a, String b) {\\n            int r = b.length() - a.length(); \\n            if(r == 0) \\n                return a.compareTo(b);\\n        \\n            return r; \\n        \\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public String longestWord(String[] words) {\\n        \\n        //Sort array by size, if equal, lexicographical order\\n        Arrays.sort(words, new customComp());\\n        Tnode root = new Tnode(); \\n        \\n        // Build Tri\\n        for(String s : words) {\\n            addWord(s, root);\\n        }\\n        \\n        // Since it is sorted, first one to match, will be answer\\n        for(String s : words) {\\n            if(canBuild(s, root)) return s; \\n        }\\n        \\n        // Nothing found\\n        return \"\"; \\n    }\\n    \\n    // Checks if all prefixes are words, if not, false\\n    public boolean canBuild(String word, Tnode root) {\\n        Tnode iter = root; \\n        for(int i = 0; i < word.length(); i++) {\\n            int cInt = word.charAt(i) - \\'a\\'; \\n            if(!iter.ch[cInt].word) return false;\\n            iter = iter.ch[cInt];\\n        }\\n        return true; \\n    } \\n    \\n    //Adding words to our tri\\n    public void addWord(String s, Tnode root) {\\n        Tnode iter = root; \\n        for(int i = 0;i < s.length(); i++) {\\n            int cInt = s.charAt(i) - \\'a\\'; \\n            if(iter.ch[cInt] == null) {\\n                iter.ch[cInt] = new Tnode(); \\n            }\\n            iter = iter.ch[cInt]; \\n        }\\n        iter.word = true; \\n        \\n    }\\n    \\n    // Custom Node for Tri\\n    public class Tnode {\\n        Tnode[] ch; \\n        boolean word; \\n        \\n        public Tnode() {\\n            ch = new Tnode[26];\\n        }\\n    }\\n    \\n    // Custom comparator for our array. 1. length 2. lexiographical \\n    public class customComp implements Comparator<String> {\\n        @Override\\n        public int compare(String a, String b) {\\n            int r = b.length() - a.length(); \\n            if(r == 0) \\n                return a.compareTo(b);\\n        \\n            return r; \\n        \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1493457,
                "title": "trie-based-approach-c-clean-code",
                "content": "# Code : \\n```\\nstruct Node {\\n  \\n    Node* arr[26];\\n    bool flag = false;\\n    \\n    bool contains(char ch) {\\n        return arr[ch-\\'a\\'] != NULL;\\n    }\\n    \\n    void put(char ch, Node* newNode) {\\n        arr[ch-\\'a\\'] = newNode;\\n    }\\n    \\n    Node* getNext(char ch) {\\n\\t\\treturn arr[ch - \\'a\\']; \\n\\t}\\n \\n\\tvoid setFlag() {\\n\\t\\tflag = true; \\n\\t}\\n \\n\\tbool isFlagSet() {\\n\\t\\treturn flag; \\n\\t}\\n};\\n\\nclass Solution {\\npublic:\\n    Node* root = new Node();\\n    \\n    int insert(string word) {\\n        Node* temp = root;\\n        int cnt = 0;    \\n        for(auto& ch : word)\\n        {\\n            if(! temp->contains(ch)) {\\n                Node* newNode = new Node();\\n                temp->put(ch, newNode);\\n            }\\n            \\n            if(temp->isFlagSet()) cnt++;\\n            temp = temp->getNext(ch);\\n        }\\n        temp->setFlag();\\n        return cnt;\\n    }\\n    \\n    string longestWord(vector<string>& words) {\\n        \\n        sort(words.begin(), words.end());\\n        string res = \"\";\\n        \\n        for(int i=0; i<words.size(); i++) {\\n            int count = insert(words[i]);\\n            \\n            if(count + 1 == words[i].size() && count + 1 > res.size()) {\\n                res = words[i];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\nstruct Node {\\n  \\n    Node* arr[26];\\n    bool flag = false;\\n    \\n    bool contains(char ch) {\\n        return arr[ch-\\'a\\'] != NULL;\\n    }\\n    \\n    void put(char ch, Node* newNode) {\\n        arr[ch-\\'a\\'] = newNode;\\n    }\\n    \\n    Node* getNext(char ch) {\\n\\t\\treturn arr[ch - \\'a\\']; \\n\\t}\\n \\n\\tvoid setFlag() {\\n\\t\\tflag = true; \\n\\t}\\n \\n\\tbool isFlagSet() {\\n\\t\\treturn flag; \\n\\t}\\n};\\n\\nclass Solution {\\npublic:\\n    Node* root = new Node();\\n    \\n    int insert(string word) {\\n        Node* temp = root;\\n        int cnt = 0;    \\n        for(auto& ch : word)\\n        {\\n            if(! temp->contains(ch)) {\\n                Node* newNode = new Node();\\n                temp->put(ch, newNode);\\n            }\\n            \\n            if(temp->isFlagSet()) cnt++;\\n            temp = temp->getNext(ch);\\n        }\\n        temp->setFlag();\\n        return cnt;\\n    }\\n    \\n    string longestWord(vector<string>& words) {\\n        \\n        sort(words.begin(), words.end());\\n        string res = \"\";\\n        \\n        for(int i=0; i<words.size(); i++) {\\n            int count = insert(words[i]);\\n            \\n            if(count + 1 == words[i].size() && count + 1 > res.size()) {\\n                res = words[i];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1490896,
                "title": "c-trie-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    struct Node{\\n        Node* arr[26];\\n        string str;\\n        Node(){\\n            for(int i=0;i<26;i++){\\n                arr[i]=NULL;\\n            }\\n            str=\"\";\\n        }\\n    };\\n    Node* root=new Node();\\n    void insert(string word){\\n        Node* curr=root;\\n        for(int i=0;i<word.size();i++){\\n            if(curr->arr[word[i]-\\'a\\']==NULL){\\n                curr->arr[word[i]-\\'a\\']=new Node();\\n            }\\n            curr=curr->arr[word[i]-\\'a\\'];\\n        }\\n        curr->str=word;\\n        \\n    }\\n    string ans=\"\";\\n    void dfs(Node* curr)\\n    {\\n        for(int i=0;i<26;i++){\\n            if(curr->arr[i]!=NULL&&curr->arr[i]->str!=\"\"){\\n                if(curr->arr[i]->str.size()>ans.size()){\\n                    ans=curr->arr[i]->str;\\n                }\\n                dfs(curr->arr[i]);\\n            }\\n        }\\n    }\\n    string longestWord(vector<string>& words) {\\n        for(string word:words){\\n            insert(word);\\n        }\\n        dfs(root);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct Node{\\n        Node* arr[26];\\n        string str;\\n        Node(){\\n            for(int i=0;i<26;i++){\\n                arr[i]=NULL;\\n            }\\n            str=\"\";\\n        }\\n    };\\n    Node* root=new Node();\\n    void insert(string word){\\n        Node* curr=root;\\n        for(int i=0;i<word.size();i++){\\n            if(curr->arr[word[i]-\\'a\\']==NULL){\\n                curr->arr[word[i]-\\'a\\']=new Node();\\n            }\\n            curr=curr->arr[word[i]-\\'a\\'];\\n        }\\n        curr->str=word;\\n        \\n    }\\n    string ans=\"\";\\n    void dfs(Node* curr)\\n    {\\n        for(int i=0;i<26;i++){\\n            if(curr->arr[i]!=NULL&&curr->arr[i]->str!=\"\"){\\n                if(curr->arr[i]->str.size()>ans.size()){\\n                    ans=curr->arr[i]->str;\\n                }\\n                dfs(curr->arr[i]);\\n            }\\n        }\\n    }\\n    string longestWord(vector<string>& words) {\\n        for(string word:words){\\n            insert(word);\\n        }\\n        dfs(root);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1490458,
                "title": "trie-dfs-lex-score",
                "content": "```\\nimport collections\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = collections.defaultdict(TrieNode)\\n        self.word = \\'\\'\\n        self.score = float(\\'inf\\')\\n        \\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n    def insert(self, word):\\n        cur = self.root\\n        score, depth = 0, 0\\n        for c in word:\\n            cur = cur.children[c]\\n            score = score * 26 + ord(c) - ord(\\'a\\')\\n            depth += 1\\n        cur.word = word\\n        cur.score = score * (26 ** (30 - depth))\\n        \\n    \\nclass Solution:\\n    def longestWord(self, words: List[str]) -> str:\\n        if not words: return \\'\\'\\n        \\n        trie = Trie()\\n        for word in words:\\n            trie.insert(word)\\n            \\n        ans = \\'\\'\\n        score = float(\\'inf\\')\\n        \\n        def dfs(node = trie.root):\\n            nonlocal ans, score\\n            if node != trie.root and not node.word:                \\n                return \\n            \\n            if len(node.word) > len(ans) or (len(node.word) == len(ans) and node.score < score):\\n                ans = node.word\\n                score = node.score\\n            \\n            for c in node.children:\\n                dfs(node = node.children[c])\\n                \\n        dfs()\\n        \\n        return ans         \\n```",
                "solutionTags": [],
                "code": "```\\nimport collections\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = collections.defaultdict(TrieNode)\\n        self.word = \\'\\'\\n        self.score = float(\\'inf\\')\\n        \\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n    def insert(self, word):\\n        cur = self.root\\n        score, depth = 0, 0\\n        for c in word:\\n            cur = cur.children[c]\\n            score = score * 26 + ord(c) - ord(\\'a\\')\\n            depth += 1\\n        cur.word = word\\n        cur.score = score * (26 ** (30 - depth))\\n        \\n    \\nclass Solution:\\n    def longestWord(self, words: List[str]) -> str:\\n        if not words: return \\'\\'\\n        \\n        trie = Trie()\\n        for word in words:\\n            trie.insert(word)\\n            \\n        ans = \\'\\'\\n        score = float(\\'inf\\')\\n        \\n        def dfs(node = trie.root):\\n            nonlocal ans, score\\n            if node != trie.root and not node.word:                \\n                return \\n            \\n            if len(node.word) > len(ans) or (len(node.word) == len(ans) and node.score < score):\\n                ans = node.word\\n                score = node.score\\n            \\n            for c in node.children:\\n                dfs(node = node.children[c])\\n                \\n        dfs()\\n        \\n        return ans         \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1373267,
                "title": "longest-word-in-dictionary-linear-time-trie-dfs",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    \\n    void dfs(int node, string &so_far, string &answer, const vector<int> &is_terminal, const vector<vector<int>> &trie)\\n    {\\n        if(so_far.length()>answer.length()) answer=so_far;\\n        for(int c=0; c<26; c++)\\n        {\\n            int child=trie[node][c];\\n            if(child!=0 && is_terminal[child]) \\n            {\\n                so_far.push_back(\\'a\\'+c);\\n                dfs(child,so_far,answer,is_terminal,trie);\\n                so_far.pop_back();\\n            }\\n        }\\n    }\\n    \\n    string longestWord(vector<string>& words) \\n    {\\n        vector<vector<int>> trie(1,vector<int>(26));\\n        int N=0;\\n        vector<int> is_terminal={false};\\n        for(auto str:words)\\n        {\\n            int node=0;\\n            for(auto chr:str)\\n            {\\n                if(trie[node][chr-\\'a\\']==0)\\n                {\\n                    trie.push_back(vector<int>(26));\\n                    is_terminal.push_back(false);\\n                    N++;\\n                    trie[node][chr-\\'a\\']=N;\\n                }\\n                node=trie[node][chr-\\'a\\'];\\n            }\\n            is_terminal[node]=1;\\n        }\\n        string answer=\"\", so_far=\"\";\\n        dfs(0,so_far,answer,is_terminal,trie);\\n        return answer;\\n    }    \\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    \\n    void dfs(int node, string &so_far, string &answer, const vector<int> &is_terminal, const vector<vector<int>> &trie)\\n    {\\n        if(so_far.length()>answer.length()) answer=so_far;\\n        for(int c=0; c<26; c++)\\n        {\\n            int child=trie[node][c];\\n            if(child!=0 && is_terminal[child]) \\n            {\\n                so_far.push_back(\\'a\\'+c);\\n                dfs(child,so_far,answer,is_terminal,trie);\\n                so_far.pop_back();\\n            }\\n        }\\n    }\\n    \\n    string longestWord(vector<string>& words) \\n    {\\n        vector<vector<int>> trie(1,vector<int>(26));\\n        int N=0;\\n        vector<int> is_terminal={false};\\n        for(auto str:words)\\n        {\\n            int node=0;\\n            for(auto chr:str)\\n            {\\n                if(trie[node][chr-\\'a\\']==0)\\n                {\\n                    trie.push_back(vector<int>(26));\\n                    is_terminal.push_back(false);\\n                    N++;\\n                    trie[node][chr-\\'a\\']=N;\\n                }\\n                node=trie[node][chr-\\'a\\'];\\n            }\\n            is_terminal[node]=1;\\n        }\\n        string answer=\"\", so_far=\"\";\\n        dfs(0,so_far,answer,is_terminal,trie);\\n        return answer;\\n    }    \\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1365532,
                "title": "java-trie-solution-faster-than-99",
                "content": "**Creating a prefix tree (TRIE) with all the words in the array and performing DFS from beginning of the childs of root (a to z) so that we can get lexicographically short but largest length word.**\\n```\\nclass Solution {\\n    \\n    public String ans = \"\";\\n    \\n    public String longestWord(String[] words) {\\n        TrieNode root = new TrieNode();\\n\\t\\tfor (int i = 0; i < words.length; i++) {\\n\\t\\t\\tinsert(root, words[i]);\\n\\t\\t}\\n\\t\\tans = \"\";\\n\\t\\tdfs(root);\\n\\t\\treturn ans;\\n    }\\n    \\n    private void dfs(TrieNode root) {\\n\\t\\t// TODO Auto-generated method stub\\n\\t\\tif (root.isWord && root.word.length() > ans.length()) {\\n\\t\\t\\tans = root.word;\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < 26; i++) {\\n\\t\\t\\tif (root.childs[i] != null && root.childs[i].isWord) {\\n\\t\\t\\t\\tdfs(root.childs[i]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tpublic void insert(TrieNode curr, String word) {\\n\\t\\tfor (int i = 0; i < word.length(); i++) {\\n\\t\\t\\tint pos = word.charAt(i) - \\'a\\';\\n\\t\\t\\tif (curr.childs[pos] == null) {\\n\\t\\t\\t\\tTrieNode newNode = new TrieNode();\\n\\t\\t\\t\\tcurr.childs[pos] = newNode;\\n\\t\\t\\t}\\n\\t\\t\\tcurr = curr.childs[pos];\\n\\t\\t}\\n\\t\\tcurr.isWord = true;\\n\\t\\tcurr.word = word;\\n\\t}\\n}\\n\\nclass TrieNode {\\n\\tTrieNode[] childs;\\n\\tboolean isWord;\\n\\tString word;\\n\\n\\tpublic TrieNode() {\\n\\t\\tsuper();\\n\\t\\tthis.childs = new TrieNode[26];\\n\\t\\tthis.isWord = false;\\n\\t}\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public String ans = \"\";\\n    \\n    public String longestWord(String[] words) {\\n        TrieNode root = new TrieNode();\\n\\t\\tfor (int i = 0; i < words.length; i++) {\\n\\t\\t\\tinsert(root, words[i]);\\n\\t\\t}\\n\\t\\tans = \"\";\\n\\t\\tdfs(root);\\n\\t\\treturn ans;\\n    }\\n    \\n    private void dfs(TrieNode root) {\\n\\t\\t// TODO Auto-generated method stub\\n\\t\\tif (root.isWord && root.word.length() > ans.length()) {\\n\\t\\t\\tans = root.word;\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < 26; i++) {\\n\\t\\t\\tif (root.childs[i] != null && root.childs[i].isWord) {\\n\\t\\t\\t\\tdfs(root.childs[i]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tpublic void insert(TrieNode curr, String word) {\\n\\t\\tfor (int i = 0; i < word.length(); i++) {\\n\\t\\t\\tint pos = word.charAt(i) - \\'a\\';\\n\\t\\t\\tif (curr.childs[pos] == null) {\\n\\t\\t\\t\\tTrieNode newNode = new TrieNode();\\n\\t\\t\\t\\tcurr.childs[pos] = newNode;\\n\\t\\t\\t}\\n\\t\\t\\tcurr = curr.childs[pos];\\n\\t\\t}\\n\\t\\tcurr.isWord = true;\\n\\t\\tcurr.word = word;\\n\\t}\\n}\\n\\nclass TrieNode {\\n\\tTrieNode[] childs;\\n\\tboolean isWord;\\n\\tString word;\\n\\n\\tpublic TrieNode() {\\n\\t\\tsuper();\\n\\t\\tthis.childs = new TrieNode[26];\\n\\t\\tthis.isWord = false;\\n\\t}\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1341182,
                "title": "java-easy-trie",
                "content": "class TrieNode{\\n\\n\\tTrieNode[] children;\\n\\tboolean isEnd;\\n\\tpublic TrieNode() {\\n\\t\\tthis.isEnd = false;\\n\\t\\tthis.children = new TrieNode[26];\\n\\t}\\n\\t\\n}\\n\\n\\n   class Solution {\\n   \\n\\t    \\tTrieNode root = new TrieNode();\\n        public String longestWord(String[] words) {\\n        if(words.length==0) return null;\\n        if(words.length==1) return words[0];\\n\\t\\t\\n        String res=new String();\\n\\n        Arrays.sort(words);\\n\\n        for(String word : words){\\n            insert(word);\\n        }\\n\\t\\t\\n\\t\\t\\n    for(String word : words){\\n\\t\\n       if(word.length()==1){\\n           if(res.length()==0){\\n             res=word;\\n\\n           }\\n       }else{\\n\\n        if(word.length()>res.length()){\\n             boolean check=false;\\n\\t\\t\\t\\n            for(int d=1;d<word.length();d++){\\n\\t\\t\\t\\n             check= search(word.substring(0,d));\\n\\t\\n                if(!check){\\n                    break;\\n                }\\n            }\\n\\t\\t\\n            if(check){\\n                                res=word;\\n\\n              }\\n\\t\\t\\t}\\n       }     \\n    }\\n     return res;\\n    }\\n\\n\\n\\tpublic void insert(String word) {\\n\\t\\n\\t\\tTrieNode cur = root;\\n\\t\\tfor (int i = 0; i < word.length(); i++) {\\n\\t\\t\\tint pos = word.charAt(i) - \\'a\\';\\n\\t\\t\\tif (cur.children[pos] == null) {\\n\\t\\t\\t\\tcur.children[pos] = new TrieNode();                \\n\\t\\t\\t}\\n\\t\\t\\tcur = cur.children[pos];            \\n\\t\\t}\\n\\t\\tcur.isEnd = true;\\n\\t}\\n    \\n\\t\\n\\tpublic boolean search(String word) {\\n\\t\\n\\t\\tTrieNode cur = root;\\n\\t\\tfor (int i = 0; i < word.length(); i++) {\\n\\t\\t\\tint pos = word.charAt(i) - \\'a\\';\\n\\t\\t\\tif (cur.children[pos] != null) {\\n\\t\\t\\t\\tcur = cur.children[pos];\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn cur.isEnd;\\n\\t}  \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n   \\n\\t    \\tTrieNode root = new TrieNode();\\n        public String longestWord(String[] words) {\\n        if(words.length==0) return null;\\n        if(words.length==1) return words[0];\\n\\t\\t\\n        String res=new String();\\n\\n        Arrays.sort(words);\\n\\n        for(String word : words){\\n            insert(word);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1313065,
                "title": "c-tries-are-great",
                "content": "```\\nclass Trie {\\n    map<char, Trie*> childrens;\\n    bool isWord;\\n    \\npublic:\\n    Trie() {\\n        isWord = false;\\n    }\\n    \\n    void insert(string word) {\\n        Trie* root = this;\\n        \\n        for(char ch: word) {\\n            if(root->childrens.find(ch) == root->childrens.end())\\n                root->childrens[ch] = new Trie();\\n            \\n            root = root->childrens[ch];\\n        }\\n        \\n        root->isWord = true;\\n    }\\n    \\n    int prefixes(Trie* root, string word, int idx) {\\n        if(idx == word.size())\\n            return 0;\\n        \\n        if(root->childrens.find(word[idx]) != root->childrens.end()) {\\n            root = root->childrens[word[idx]];\\n            \\n            if(root->isWord)\\n                return 1 + prefixes(root, word, idx+1);\\n        }\\n        \\n        return 0;\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    string longestWord(vector<string>& words) {\\n        Trie* root = new Trie();\\n        \\n        for(string word: words) \\n            root->insert(word);\\n        \\n        string result = \"\";\\n        \\n        for(string word: words) {\\n            int pcount = root->prefixes(root, word, 0);\\n            \\n            if(pcount > result.size())\\n                result = word;\\n        }\\n        \\n        return result;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string longestWord(vector<string>& words) {\\n        Trie* root = new Trie();\\n        \\n        for(string word: words) \\n            root->insert(word);\\n        \\n        string result = \"\";\\n        \\n        for(string word: words) {\\n            int pcount = root->prefixes(root, word, 0);\\n            \\n            if(pcount > result.size())\\n                result = word;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1285906,
                "title": "o-n-k-solution-c-trie",
                "content": "Please upvote if this helps! :)\\n```\\nclass Trie{\\n  public:\\n    unordered_map<char,Trie*> m;\\n    bool wordEnd=false;\\n    Trie(){}\\n    void insert(string w){\\n        auto root=this;\\n        for(char i:w){\\n            if(!root->m[i])root->m[i]=new Trie();\\n            root=root->m[i];\\n        };\\n        root->wordEnd=true;\\n    }\\n    bool find(string w){\\n        auto root=this;\\n        for(char i:w){\\n            if(!root->m[i]||!root->m[i]->wordEnd)return false;\\n            root=root->m[i];\\n        };\\n        return true;\\n    };\\n};\\nclass Solution {\\npublic:\\n    static bool comp(string &a,string &b){\\n        return a.length()==b.length()?a>b:a.length()<b.length();\\n    }\\n    string longestWord(vector<string>& w) {\\n        Trie* root=new Trie();\\n        sort(w.begin(),w.end(),comp);\\n        string ans;\\n        for(string word: w){\\n            if(root->find(word.substr(0,word.length()-1))){\\n                ans=word;\\n            };\\n            root->insert(word);\\n        };\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Trie{\\n  public:\\n    unordered_map<char,Trie*> m;\\n    bool wordEnd=false;\\n    Trie(){}\\n    void insert(string w){\\n        auto root=this;\\n        for(char i:w){\\n            if(!root->m[i])root->m[i]=new Trie();\\n            root=root->m[i];\\n        };\\n        root->wordEnd=true;\\n    }\\n    bool find(string w){\\n        auto root=this;\\n        for(char i:w){\\n            if(!root->m[i]||!root->m[i]->wordEnd)return false;\\n            root=root->m[i];\\n        };\\n        return true;\\n    };\\n};\\nclass Solution {\\npublic:\\n    static bool comp(string &a,string &b){\\n        return a.length()==b.length()?a>b:a.length()<b.length();\\n    }\\n    string longestWord(vector<string>& w) {\\n        Trie* root=new Trie();\\n        sort(w.begin(),w.end(),comp);\\n        string ans;\\n        for(string word: w){\\n            if(root->find(word.substr(0,word.length()-1))){\\n                ans=word;\\n            };\\n            root->insert(word);\\n        };\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1259624,
                "title": "9ms-80-faster-trie-solution",
                "content": "java code is:\\n# \\n```\\nclass node{\\n    int val;\\n    node next[];\\n}\\nclass Solution {\\n    String res=\"\";\\n    node newNode(){\\n        node n =new node();\\n        n.next=new node[26];\\n        for(int i=0;i<26;i++)\\n        n.next[i]=null;\\n        return n;\\n    }\\n   void insert(node r,String word){\\n        node root=r;\\n        int i=0;\\n        for(char c : word.toCharArray()){\\n            int index=c-\\'a\\';\\n            if(root.next[index]==null){\\n                if(i!=word.length()-1)return ;\\n                root.next[index]=newNode();\\n            }\\n            root=root.next[index];\\n            i++;\\n        }\\n        if(res.length()==word.length()&&res.compareTo(word)>0)res=word;\\n        else if(word.length()>res.length())res=word;\\n       return ;\\n    }\\n    public String longestWord(String[] words) {\\n       node root=newNode();\\n      Arrays.sort(words,(a,b)->a.length()-b.length());\\n      for(String word : words)insert(root,word);\\n          return res;\\n    }\\n}\\n```\\n**Please,Upvote if this is helpful**",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```\\nclass node{\\n    int val;\\n    node next[];\\n}\\nclass Solution {\\n    String res=\"\";\\n    node newNode(){\\n        node n =new node();\\n        n.next=new node[26];\\n        for(int i=0;i<26;i++)\\n        n.next[i]=null;\\n        return n;\\n    }\\n   void insert(node r,String word){\\n        node root=r;\\n        int i=0;\\n        for(char c : word.toCharArray()){\\n            int index=c-\\'a\\';\\n            if(root.next[index]==null){\\n                if(i!=word.length()-1)return ;\\n                root.next[index]=newNode();\\n            }\\n            root=root.next[index];\\n            i++;\\n        }\\n        if(res.length()==word.length()&&res.compareTo(word)>0)res=word;\\n        else if(word.length()>res.length())res=word;\\n       return ;\\n    }\\n    public String longestWord(String[] words) {\\n       node root=newNode();\\n      Arrays.sort(words,(a,b)->a.length()-b.length());\\n      for(String word : words)insert(root,word);\\n          return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1253482,
                "title": "o-n-javascript",
                "content": "1) sort using bucket sort\\n2) iterate and save into hashset, only if word (excluding the last character of word) is present in the hashset.\\n3) Assign the word to \\'res\\', only if current\\'s word length is more than res.length, or if it is smaller in lexicographical order;\\n4) return res;\\n\\n```\\n/**\\n * @param {string[]} words\\n * @return {string}\\n */\\nvar longestWord = function(words) {\\n    let map = {};\\n   \\n    let resWord = \"\";\\n    \\n    let newArr = new Array(31).fill(\\'\\');\\n    words.forEach(item => {\\n        newArr[item.length] += \" \" + item;\\n    })\\n\\n    words = newArr.join(\\'\\').split(\\' \\').filter(item => item);\\n    \\n    \\n    \\n    for (let i = 0; i < words.length; i++) {\\n        if (words[i].length === 1) {\\n            map[words[i]] = words[i].length;\\n        } else {\\n            if (map[words[i].slice(0, -1)] !== undefined) {\\n                map[words[i]] = words[i].length;\\n            }\\n        }\\n        \\n        if (map[words[i]]) {           \\n           if (!resWord || words[i].length > resWord.length || resWord.localeCompare(words[i]) > 0) resWord = words[i];\\n        }\\n    }\\n    \\n   return resWord;\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {string}\\n */\\nvar longestWord = function(words) {\\n    let map = {};\\n   \\n    let resWord = \"\";\\n    \\n    let newArr = new Array(31).fill(\\'\\');\\n    words.forEach(item => {\\n        newArr[item.length] += \" \" + item;\\n    })\\n\\n    words = newArr.join(\\'\\').split(\\' \\').filter(item => item);\\n    \\n    \\n    \\n    for (let i = 0; i < words.length; i++) {\\n        if (words[i].length === 1) {\\n            map[words[i]] = words[i].length;\\n        } else {\\n            if (map[words[i].slice(0, -1)] !== undefined) {\\n                map[words[i]] = words[i].length;\\n            }\\n        }\\n        \\n        if (map[words[i]]) {           \\n           if (!resWord || words[i].length > resWord.length || resWord.localeCompare(words[i]) > 0) resWord = words[i];\\n        }\\n    }\\n    \\n   return resWord;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1250034,
                "title": "javascript-trie-dfs-implementation",
                "content": "```\\n/**\\n * @param {string[]} words\\n * @return {string}\\n */\\n\\nclass Trie {\\n    constructor() {\\n        this.root = new Node(null);\\n    }\\n    \\n\\t// Inserts words into our Trie\\n    insert(word) {\\n        let curr = this.root;\\n        for (const char of word) {\\n            if (!curr.children.has(char)) {\\n                curr.children.set(char, new Node(char));\\n            }\\n            curr = curr.children.get(char);\\n        }\\n        \\n        curr.isWord = true;\\n    }\\n\\n    dfs() {\\n\\t\\t// Store our largest word so far\\n        let largest = \"\";\\n        \\n\\t\\t// Helper function for DFS\\n        const findLargest = (node, currentWord = \"\") => {\\n\\t\\t\\t// If node isnt a word and it isn\\'t the root, we stop.\\n\\t\\t\\t// This is because the problem asks us for longest \"word\" that can be\\n\\t\\t\\t// constructed out of other \"words\" in the dictionary.\\n            if (!node.isWord && node.char !== null) return; \\n            \\n\\t\\t\\t// With every word, check if it is longer than the largest word.\\n            if (currentWord.length > largest.length) {\\n                largest = currentWord;\\n            } else if (currentWord.length === largest.length) {\\n\\t\\t\\t\\t// If equal, take the alphabetically first one\\n                if (currentWord < largest) {\\n                    largest = currentWord;\\n                }\\n            }\\n        \\n\\t\\t\\t// Iterate through children and continue\\n            for (const child of node.children.values()) {\\n                findLargest(child, currentWord + child.char);\\n            }\\n        }\\n        \\n        findLargest(this.root);\\n        \\n        return largest;\\n    }\\n}\\n    \\nclass Node {\\n    constructor(val) {\\n        this.char = val;\\n        this.children = new Map();\\n        this.isWord = false;\\n    }\\n}\\n    \\nvar longestWord = function(words) {\\n    const myTrie = new Trie();\\n    for (const word of words) {\\n        myTrie.insert(word);\\n    }\\n    \\n   return myTrie.dfs();\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {string}\\n */\\n\\nclass Trie {\\n    constructor() {\\n        this.root = new Node(null);\\n    }\\n    \\n\\t// Inserts words into our Trie\\n    insert(word) {\\n        let curr = this.root;\\n        for (const char of word) {\\n            if (!curr.children.has(char)) {\\n                curr.children.set(char, new Node(char));\\n            }\\n            curr = curr.children.get(char);\\n        }\\n        \\n        curr.isWord = true;\\n    }\\n\\n    dfs() {\\n\\t\\t// Store our largest word so far\\n        let largest = \"\";\\n        \\n\\t\\t// Helper function for DFS\\n        const findLargest = (node, currentWord = \"\") => {\\n\\t\\t\\t// If node isnt a word and it isn\\'t the root, we stop.\\n\\t\\t\\t// This is because the problem asks us for longest \"word\" that can be\\n\\t\\t\\t// constructed out of other \"words\" in the dictionary.\\n            if (!node.isWord && node.char !== null) return; \\n            \\n\\t\\t\\t// With every word, check if it is longer than the largest word.\\n            if (currentWord.length > largest.length) {\\n                largest = currentWord;\\n            } else if (currentWord.length === largest.length) {\\n\\t\\t\\t\\t// If equal, take the alphabetically first one\\n                if (currentWord < largest) {\\n                    largest = currentWord;\\n                }\\n            }\\n        \\n\\t\\t\\t// Iterate through children and continue\\n            for (const child of node.children.values()) {\\n                findLargest(child, currentWord + child.char);\\n            }\\n        }\\n        \\n        findLargest(this.root);\\n        \\n        return largest;\\n    }\\n}\\n    \\nclass Node {\\n    constructor(val) {\\n        this.char = val;\\n        this.children = new Map();\\n        this.isWord = false;\\n    }\\n}\\n    \\nvar longestWord = function(words) {\\n    const myTrie = new Trie();\\n    for (const word of words) {\\n        myTrie.insert(word);\\n    }\\n    \\n   return myTrie.dfs();\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1232445,
                "title": "python-trie-search-only-returns-valid-buildable-words",
                "content": "```\\nfrom collections import defaultdict\\n\\nclass TrieNode(object):\\n    \\n    def __init__(self):\\n        self.children = defaultdict()\\n        self.isEnd = False\\n        \\n        \\nclass Trie(object):\\n    \\n    def __init__(self):\\n        self.root = TrieNode()\\n        \\n    \\n    def insert(self, word):\\n        curr = self.root\\n        \\n        for c in word:\\n            if c not in curr.children:\\n                curr.children[c] = TrieNode()\\n                \\n            curr = curr.children[c]\\n    \\n        curr.isEnd = True\\n        \\n    \\n    def search(self, word):\\n        curr = self.root\\n        \\n        for c in word:\\n            if c not in curr.children: return False\\n            \\n            curr = curr.children[c]\\n            if not curr.isEnd: return False\\n            \\n        return curr.isEnd\\n        \\n\\nclass Solution(object):\\n    def longestWord(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: str\\n        \"\"\"\\n        # initialize Trie\\n        trie = Trie()\\n        \\n        # put elements into Trie\\n        for word in words:\\n            trie.insert(word)\\n        \\n        # find longest word\\n        longest = \"\"\\n        \\n        for word in words:\\n            # find words where each char\\'s isEnd == True\\n            if trie.search(word) and len(longest) <= len(word):\\n                if len(longest) == len(word) and word > longest:\\n                    continue\\n                \\n                longest = word\\n        \\n        return longest\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass TrieNode(object):\\n    \\n    def __init__(self):\\n        self.children = defaultdict()\\n        self.isEnd = False\\n        \\n        \\nclass Trie(object):\\n    \\n    def __init__(self):\\n        self.root = TrieNode()\\n        \\n    \\n    def insert(self, word):\\n        curr = self.root\\n        \\n        for c in word:\\n            if c not in curr.children:\\n                curr.children[c] = TrieNode()\\n                \\n            curr = curr.children[c]\\n    \\n        curr.isEnd = True\\n        \\n    \\n    def search(self, word):\\n        curr = self.root\\n        \\n        for c in word:\\n            if c not in curr.children: return False\\n            \\n            curr = curr.children[c]\\n            if not curr.isEnd: return False\\n            \\n        return curr.isEnd\\n        \\n\\nclass Solution(object):\\n    def longestWord(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: str\\n        \"\"\"\\n        # initialize Trie\\n        trie = Trie()\\n        \\n        # put elements into Trie\\n        for word in words:\\n            trie.insert(word)\\n        \\n        # find longest word\\n        longest = \"\"\\n        \\n        for word in words:\\n            # find words where each char\\'s isEnd == True\\n            if trie.search(word) and len(longest) <= len(word):\\n                if len(longest) == len(word) and word > longest:\\n                    continue\\n                \\n                longest = word\\n        \\n        return longest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1208141,
                "title": "c-trie-with-line-by-line-comments",
                "content": "44 ms\\n31.8 MB\\n```\\nclass Trie{\\n    public:\\n     Trie* children[26]={NULL};     // a Trie array having 26 blocks for each letter\\n     bool end;                      // to mark the end of the word\\n};\\n\\nclass Solution {\\npublic:\\n      \\n    void insert(string key , Trie* root)\\n    {\\n         Trie* curr = root;     // start from root\\n         int n = key.length();      // length of our word\\n        \\n        for (int i = 0; i < n; i++)         // travel through each character of ther word\\n        {\\n            int index = key[i] - \\'a\\';       // get each charcter index value in the given word(key) just by sub \\'a\\' the ascii value of a we can now say a to z are 1 to 26\\n            \\n            if (!curr->children[index])     // if no same word is repeated till now \\n                curr->children[index] = new Trie();     //attach a new child trie which will have its own tail(end)\\n\\n            curr = curr->children[index];   // link the curr to the next charcter in the word\\n        }\\n    curr->end = true;       // after getting all the charcters mark end is true means the word ends here\\n}\\n    \\n    \\n    bool search( string key , Trie* root )\\n    {\\n        int count = 0;\\n        \\n        Trie* curr = root;   // start from root\\n        int n = key.length(); // start from root\\n        \\n        \\n        for (int i = 0; i < n ; i++)    // travel through each character of ther word\\n        {\\n            int index = key[i] - \\'a\\';       // get each charcter index value in the given word(key) just by sub \\'a\\' the ascii value of a we can now say a to z are 1 to 26\\n            \\n            if (!curr->children[index])         // if the charcter of the word we are  searching doesnt match with the charcter of the word in the words array\\n                return false;\\n\\n            curr = curr ->children[index];  // go to the next character in the word\\n            if(curr->end) ++count;\\n        }\\n  \\n   // return (curr != NULL && curr->end);     // if the curr is not NUll and the end is true then return true(this is not workig)\\n        return count == key.size();\\n}\\n    \\n    \\n    string longestWord(vector<string>& words) {\\n        \\n        Trie *root =new Trie();     // create a root node\\n    //    sort(begin(words),end(words));      // sort the words so that we can add them chronologically\\n        int n=words.size();     // size of dictionary\\n        \\n//         for(string s: words) {   // we can write this also\\n//             insert(s,root);\\n//         }\\n        \\n        for(int i=0;i<n;i++){\\n        //if consecutive words are same no need to call insert function for duplicate words\\n            // if(i+1<n && words[i]==words[i+1])  \\n            //     continue;\\n            insert(words[i],root);      // insert the words in dictionary\\n        }\\n        \\n        \\n        string ans;     // store our ans\\n        \\n        for(string s: words)    // travel through each word\\n        {\\n            if(ans.size() > s.size()) continue;     // if our previous ans is greater than the current word no need to do this \\n            // by the way this is also not needed as we have already sorted the words \\n            \\n            if(search(s,root)) // now seach the word in the words in the Trie if there is the word it will return true\\n            {\\n                if(ans.size() == s.size()) ans = min(s, ans); // if both the word are of same size then the word which appers first will be our ans\\n                \\n                else ans = s;   //if not same than the ans for this iteration is s only the word we found in the Trie\\n            }\\n        }\\n       return ans;  // return the ans\\n    }\\n\\t\\n};\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Trie"
                ],
                "code": "class Solution {\\npublic:\\n      \\n    void insert(string key , Trie* root)\\n    {\\n         Trie* curr = root;     // start from root\\n         int n = key.length();      // length of our word\\n        \\n        for (int i = 0; i < n; i++)         // travel through each character of ther word\\n        {\\n            int index = key[i] - \\'a\\';       // get each charcter index value in the given word(key) just by sub \\'a\\' the ascii value of a we can now say a to z are 1 to 26\\n            \\n            if (!curr->children[index])     // if no same word is repeated till now \\n                curr->children[index] = new Trie();     //attach a new child trie which will have its own tail(end)\\n\\n            curr = curr->children[index];   // link the curr to the next charcter in the word\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1202469,
                "title": "interesting-question-for-understanding-trie",
                "content": "The trie code may look longer but its quite easy to understand once know how Trie.insert() and Trie.isValid is working !\\n\\nTry taking small inputs to trace the code .\\n```\\nclass Solution {\\n    public String longestWord(String[] words) {\\n        int wn = words.length;\\n        \\n        // insert all words in Trie\\n        Trie trie = new Trie();\\n        for(String word: words){\\n            trie.insert(word);\\n        }\\n        \\n        // check all word for possible answer\\n        String lonWord = \"\", curWord = \"\";\\n        for(int i = 0; i < wn; i++){\\n            curWord = words[i];\\n            if(trie.isValid(curWord) == true){\\n                if(curWord.length() > lonWord.length() || (curWord.length() == lonWord.length() && curWord.compareTo(lonWord) < 0)){\\n                    lonWord = curWord;\\n                }\\n            }\\n        }\\n        return lonWord;\\n    }\\n}\\n\\nclass TrieNode{\\n    Map<Character, TrieNode> children;\\n    boolean isWord;\\n    \\n    TrieNode(){\\n        this.children = new HashMap<>();\\n    }\\n}\\n\\nclass Trie{\\n    TrieNode root;\\n    Trie(){\\n        root = new TrieNode();\\n    }\\n    \\n    /* Insert a word in Trie\\n    */\\n    public boolean insert(String word){\\n        int n = word.length();\\n        TrieNode curNode = root;\\n        \\n        char ch;\\n        for(int i = 0; i < n; i++){\\n            ch = word.charAt(i);\\n            if(curNode.children.containsKey(ch) == false){\\n                curNode.children.put(ch, new TrieNode());\\n            }\\n            curNode = curNode.children.get(ch);\\n        }\\n        curNode.isWord = true;\\n        return true;\\n    }\\n    \\n    /* Check if word.substring(0, i), for all i > 0 && i < word.length()\\n    is a word in Trie .\\n    */\\n    public boolean isValid(String word){\\n        int n = word.length();\\n        TrieNode curNode = root;\\n        \\n        char ch = \\' \\';\\n        for(int i = 0; i < n; i++){\\n            ch = word.charAt(i);\\n            \\n            // return false immediately if char is not in Trie\\n            if(curNode.children.containsKey(ch) == false){\\n                return false;\\n            }\\n            \\n            // return false if there is word ending at ch\\n            curNode = curNode.children.get(ch);\\n            if(curNode.isWord == false){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n    public String longestWord(String[] words) {\\n        int wn = words.length;\\n        \\n        // insert all words in Trie\\n        Trie trie = new Trie();\\n        for(String word: words){\\n            trie.insert(word);\\n        }\\n        \\n        // check all word for possible answer\\n        String lonWord = \"\", curWord = \"\";\\n        for(int i = 0; i < wn; i++){\\n            curWord = words[i];\\n            if(trie.isValid(curWord) == true){\\n                if(curWord.length() > lonWord.length() || (curWord.length() == lonWord.length() && curWord.compareTo(lonWord) < 0)){\\n                    lonWord = curWord;\\n                }\\n            }\\n        }\\n        return lonWord;\\n    }\\n}\\n\\nclass TrieNode{\\n    Map<Character, TrieNode> children;\\n    boolean isWord;\\n    \\n    TrieNode(){\\n        this.children = new HashMap<>();\\n    }\\n}\\n\\nclass Trie{\\n    TrieNode root;\\n    Trie(){\\n        root = new TrieNode();\\n    }\\n    \\n    /* Insert a word in Trie\\n    */\\n    public boolean insert(String word){\\n        int n = word.length();\\n        TrieNode curNode = root;\\n        \\n        char ch;\\n        for(int i = 0; i < n; i++){\\n            ch = word.charAt(i);\\n            if(curNode.children.containsKey(ch) == false){\\n                curNode.children.put(ch, new TrieNode());\\n            }\\n            curNode = curNode.children.get(ch);\\n        }\\n        curNode.isWord = true;\\n        return true;\\n    }\\n    \\n    /* Check if word.substring(0, i), for all i > 0 && i < word.length()\\n    is a word in Trie .\\n    */\\n    public boolean isValid(String word){\\n        int n = word.length();\\n        TrieNode curNode = root;\\n        \\n        char ch = \\' \\';\\n        for(int i = 0; i < n; i++){\\n            ch = word.charAt(i);\\n            \\n            // return false immediately if char is not in Trie\\n            if(curNode.children.containsKey(ch) == false){\\n                return false;\\n            }\\n            \\n            // return false if there is word ending at ch\\n            curNode = curNode.children.get(ch);\\n            if(curNode.isWord == false){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1190580,
                "title": "trie-and-dfs-without-sort",
                "content": "```java\\nclass Solution {\\n    static int R = 256;\\n    int max = 0;\\n    String longest = \"\";\\n    public String longestWord(String[] words) {\\n        Trie trie = new Trie(\\'#\\');\\n        trie.isWord = true;\\n        for (String word: words) {\\n            int c = trie.insert(word);\\n        }\\n        dfs(trie, \"\", 0);\\n        return longest;\\n    }\\n    \\n    void dfs(Trie node, String word, int counter) {\\n        if (node == null) return ;\\n        \\n        if (node.isWord == false) return;\\n        \\n        if (counter > max) {\\n            max = counter;\\n            longest = word;\\n        }\\n        \\n        for (Trie t: node.next) {\\n            if (t != null) {\\n               dfs(t, word + \"\" + t.symbol, counter + 1); \\n            }\\n        }\\n    }\\n    \\n    class Trie {\\n        \\n        Trie[] next = new Trie[R];\\n        char symbol;\\n        boolean isWord;\\n        \\n        public Trie(char symbol) {\\n            this.symbol = symbol;\\n        }\\n        \\n        int insert(String word) {\\n            int counter = 0;\\n            Trie node = this;\\n            int n = word.length();\\n            for (char c: word.toCharArray()) {\\n                Trie curr = node.next[c];\\n                if (curr == null) {\\n                    curr = new Trie(c);\\n                } else {\\n                    if (curr.isWord) counter++;\\n                }\\n                node.next[c] = curr;\\n                node = curr;\\n            }\\n            node.isWord = true;\\n            counter++;\\n            return counter;\\n        }\\n    }\\n    \\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    static int R = 256;\\n    int max = 0;\\n    String longest = \"\";\\n    public String longestWord(String[] words) {\\n        Trie trie = new Trie(\\'#\\');\\n        trie.isWord = true;\\n        for (String word: words) {\\n            int c = trie.insert(word);\\n        }\\n        dfs(trie, \"\", 0);\\n        return longest;\\n    }\\n    \\n    void dfs(Trie node, String word, int counter) {\\n        if (node == null) return ;\\n        \\n        if (node.isWord == false) return;\\n        \\n        if (counter > max) {\\n            max = counter;\\n            longest = word;\\n        }\\n        \\n        for (Trie t: node.next) {\\n            if (t != null) {\\n               dfs(t, word + \"\" + t.symbol, counter + 1); \\n            }\\n        }\\n    }\\n    \\n    class Trie {\\n        \\n        Trie[] next = new Trie[R];\\n        char symbol;\\n        boolean isWord;\\n        \\n        public Trie(char symbol) {\\n            this.symbol = symbol;\\n        }\\n        \\n        int insert(String word) {\\n            int counter = 0;\\n            Trie node = this;\\n            int n = word.length();\\n            for (char c: word.toCharArray()) {\\n                Trie curr = node.next[c];\\n                if (curr == null) {\\n                    curr = new Trie(c);\\n                } else {\\n                    if (curr.isWord) counter++;\\n                }\\n                node.next[c] = curr;\\n                node = curr;\\n            }\\n            node.isWord = true;\\n            counter++;\\n            return counter;\\n        }\\n    }\\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1173630,
                "title": "c-trie-dfs-solution-beats-95-57-time",
                "content": "```\\nconst int CHILDREN = 26;\\nclass trienode{\\npublic:\\n    trienode(){\\n        for(int i=0; i<CHILDREN; i++)\\n            children[i]= NULL;\\n        leaf = false;\\n    }\\n    \\n    void insert(string& word, unsigned int pos){\\n        if(pos >= word.size())\\n            return;\\n        int index = word[pos] - \\'a\\';\\n        if(!children[index])\\n            children[index] = new trienode();\\n        if(pos<word.size()-1)\\n            children[index]->insert(word, pos+1);\\n        else\\n            children[index]->leaf = true;\\n    }\\n    \\n    trienode* children[CHILDREN];\\n    bool leaf;\\n};\\n\\nclass Solution {\\npublic:\\n\\tstring longestWord2(vector<string>& words) {\\n        unordered_set<string> wordset(words.begin(), words.end());\\n        sort(words.begin(), words.end());\\n        int length = 0;\\n        string str;\\n        for(unsigned int i=0; i<words.size(); i++){\\n            if(words[i].size()<=length)\\n                continue;\\n            bool existed = true;\\n            for(unsigned int j=1; j<words[i].size(); j++)\\n                if(wordset.find(words[i].substr(0, j))==wordset.end()){\\n                    existed = false;\\n                    break;\\n                }\\n            if(existed)\\n            {\\n                length = words[i].size();\\n                str = words[i];\\n            }\\n        }\\n        return str;\\n    }\\n\\n    string longestWord(vector<string>& words) {\\n        trienode* root = new trienode();\\n        for(unsigned int i=0; i<words.size(); i++)\\n            root->insert(words[i], 0);\\n        int length = -1;\\n        string str = \"\";\\n        char buf[32];\\n        dfs(root, buf, 0, length, str);\\n        return str;\\n    }\\n    \\n    void dfs(trienode* p, char* buf, int pos, int& length, string& str){\\n        for(unsigned int i=0; i<CHILDREN; i++) {\\n            if(p->children[i]){\\n                if(p->children[i]->leaf){\\n                    buf[pos] = (char)(\\'a\\'+i);\\n                    if(pos > length){\\n                        length = pos;\\n                        buf[pos+1] = 0;\\n                        str = buf;\\n                    }\\n                    dfs(p->children[i], buf, pos+1, length, str);\\n                }\\n            }\\n        }\\n    }\\n\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst int CHILDREN = 26;\\nclass trienode{\\npublic:\\n    trienode(){\\n        for(int i=0; i<CHILDREN; i++)\\n            children[i]= NULL;\\n        leaf = false;\\n    }\\n    \\n    void insert(string& word, unsigned int pos){\\n        if(pos >= word.size())\\n            return;\\n        int index = word[pos] - \\'a\\';\\n        if(!children[index])\\n            children[index] = new trienode();\\n        if(pos<word.size()-1)\\n            children[index]->insert(word, pos+1);\\n        else\\n            children[index]->leaf = true;\\n    }\\n    \\n    trienode* children[CHILDREN];\\n    bool leaf;\\n};\\n\\nclass Solution {\\npublic:\\n\\tstring longestWord2(vector<string>& words) {\\n        unordered_set<string> wordset(words.begin(), words.end());\\n        sort(words.begin(), words.end());\\n        int length = 0;\\n        string str;\\n        for(unsigned int i=0; i<words.size(); i++){\\n            if(words[i].size()<=length)\\n                continue;\\n            bool existed = true;\\n            for(unsigned int j=1; j<words[i].size(); j++)\\n                if(wordset.find(words[i].substr(0, j))==wordset.end()){\\n                    existed = false;\\n                    break;\\n                }\\n            if(existed)\\n            {\\n                length = words[i].size();\\n                str = words[i];\\n            }\\n        }\\n        return str;\\n    }\\n\\n    string longestWord(vector<string>& words) {\\n        trienode* root = new trienode();\\n        for(unsigned int i=0; i<words.size(); i++)\\n            root->insert(words[i], 0);\\n        int length = -1;\\n        string str = \"\";\\n        char buf[32];\\n        dfs(root, buf, 0, length, str);\\n        return str;\\n    }\\n    \\n    void dfs(trienode* p, char* buf, int pos, int& length, string& str){\\n        for(unsigned int i=0; i<CHILDREN; i++) {\\n            if(p->children[i]){\\n                if(p->children[i]->leaf){\\n                    buf[pos] = (char)(\\'a\\'+i);\\n                    if(pos > length){\\n                        length = pos;\\n                        buf[pos+1] = 0;\\n                        str = buf;\\n                    }\\n                    dfs(p->children[i], buf, pos+1, length, str);\\n                }\\n            }\\n        }\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1155916,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string longestWord(vector<string>& words) {\\n        sort(words.begin(), words.end());\\n        unordered_set<string> cache;\\n        string res;\\n        for(const auto &word : words){\\n            if(word.size() == 1 || cache.count(word.substr(0,word.size()-1))){\\n                cache.insert(word);\\n                if(word.size() > res.size()) res = word;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestWord(vector<string>& words) {\\n        sort(words.begin(), words.end());\\n        unordered_set<string> cache;\\n        string res;\\n        for(const auto &word : words){\\n            if(word.size() == 1 || cache.count(word.substr(0,word.size()-1))){\\n                cache.insert(word);\\n                if(word.size() > res.size()) res = word;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152047,
                "title": "c-720-longest-word-in-dictionary",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    string longestWord(vector<string>& words) {\\n        sort(words.begin(), words.end()); \\n        \\n        string ans; \\n        unordered_set<string> seen = {\"\"}; \\n        for (int i = 0; i < words.size(); ++i) {\\n            int n = words[i].size(); \\n            if (seen.count(words[i].substr(0, n-1))) {\\n                if (n > ans.size())\\n                    ans = words[i]; \\n                seen.insert(words[i]); \\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestWord(vector<string>& words) {\\n        sort(words.begin(), words.end()); \\n        \\n        string ans; \\n        unordered_set<string> seen = {\"\"}; \\n        for (int i = 0; i < words.size(); ++i) {\\n            int n = words[i].size(); \\n            if (seen.count(words[i].substr(0, n-1))) {\\n                if (n > ans.size())\\n                    ans = words[i]; \\n                seen.insert(words[i]); \\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1077834,
                "title": "c-java-solutions-using-map",
                "content": "### C++ version\\n```\\n string longestWord(vector<string>& words) {\\n        sort(words.begin(), words.end());\\n        string result = \"\";\\n        set<string> builtWords;\\n        for(auto w : words) {\\n            if(w.length() == 1 || builtWords.find(w.substr(0, w.length()-1)) != builtWords.end()) {\\n                if(w.length()  > result.length()) result = w;\\n                builtWords.insert(w);\\n            }\\n        }\\n        return result;\\n    }\\n```\\n\\n### JAVA version\\n\\n```\\n   public String longestWord(String[] words) {\\n        Arrays.sort(words);\\n        String result = \"\";\\n        HashSet<String> builtWords = new HashSet();\\n        for(String w : words) {\\n            if(w.length() == 1 || builtWords.contains(w.substring(0, w.length()-1))) {\\n                if(w.length() > result.length()) result = w;\\n                builtWords.add(w);\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\n string longestWord(vector<string>& words) {\\n        sort(words.begin(), words.end());\\n        string result = \"\";\\n        set<string> builtWords;\\n        for(auto w : words) {\\n            if(w.length() == 1 || builtWords.find(w.substr(0, w.length()-1)) != builtWords.end()) {\\n                if(w.length()  > result.length()) result = w;\\n                builtWords.insert(w);\\n            }\\n        }\\n        return result;\\n    }\\n```\n```\\n   public String longestWord(String[] words) {\\n        Arrays.sort(words);\\n        String result = \"\";\\n        HashSet<String> builtWords = new HashSet();\\n        for(String w : words) {\\n            if(w.length() == 1 || builtWords.contains(w.substring(0, w.length()-1))) {\\n                if(w.length() > result.length()) result = w;\\n                builtWords.add(w);\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1059021,
                "title": "simple-understandable-solution-with-high-time-complexity-python",
                "content": "```\\nclass Solution(object):\\n    def longestWord(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: str\\n        \"\"\"\\n        nl=[\\'\\']\\n        words.sort()\\n        res=\\'\\'\\n        for i in words:\\n            if i[:len(i)-1] in nl:\\n                nl.append(i)\\n                if len(i)>len(res):\\n                    res=i\\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def longestWord(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: str\\n        \"\"\"\\n        nl=[\\'\\']\\n        words.sort()\\n        res=\\'\\'\\n        for i in words:\\n            if i[:len(i)-1] in nl:\\n                nl.append(i)\\n                if len(i)>len(res):\\n                    res=i\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1015084,
                "title": "python-solution",
                "content": "\\ts, result = [\"\"], \"\"\\n\\twords.sort(key = len)\\n\\tfor word in words:\\n\\t\\tif word[:-1] in s:\\n\\t\\t\\ts.append(word)\\n\\tfor word in s:\\n\\t\\tif len(word) > len(result):\\n\\t\\t\\tresult = word\\n\\t\\telif len(word) == len(result) and word < result:\\n\\t\\t\\tresult = word\\n\\treturn result",
                "solutionTags": [],
                "code": "\\ts, result = [\"\"], \"\"\\n\\twords.sort(key = len)\\n\\tfor word in words:\\n\\t\\tif word[:-1] in s:\\n\\t\\t\\ts.append(word)\\n\\tfor word in s:\\n\\t\\tif len(word) > len(result):\\n\\t\\t\\tresult = word\\n\\t\\telif len(word) == len(result) and word < result:\\n\\t\\t\\tresult = word\\n\\treturn result",
                "codeTag": "Unknown"
            },
            {
                "id": 975618,
                "title": "trie-custom-sorting-java-solution-beats-75",
                "content": "**Approach 1: Custom sort + Trie**\\n```\\n/*\\n    Trie Based Impleementation\\n    Insert words in Trie. \\n    Searching in Trie is fast than searching in HashSet because we \\n    don\\'t have to use substring() plus we can use TrieNode root pointer to move along the \\n    characters of the word\\n\\t\\n\\tWe don\\'t need any search() method for Trie b\\'cz we will use TrieNode root pointer to look for characters in\\n\\tthe word we are searching\\n*/\\nclass Solution {\\n    public class TrieNode {\\n        char c;\\n        TrieNode[] children;\\n        boolean isEnd;\\n        public TrieNode(char c){\\n            this.isEnd = false;\\n            this.children = new TrieNode[26];\\n            this.c = c;\\n        }\\n        public TrieNode(){\\n            this.children = new TrieNode[26];\\n            this.isEnd = false;\\n        }\\n        \\n        public String toString(){\\n            return \"[\" + this.c + \"]\" ;  \\n        }\\n    }\\n    \\n    TrieNode root;\\n    \\n    public void insert(String word){\\n        TrieNode curr = root;\\n        for(int i = 0; i < word.length(); i++){\\n            char c = word.charAt(i);\\n            if(curr.children[c - \\'a\\'] == null){\\n                curr.children[c - \\'a\\'] = new TrieNode(c);\\n            }\\n            curr = curr.children[c - \\'a\\'];\\n        }\\n\\t\\t//Mark the end of word is very important here\\n        curr.isEnd=true;\\n    }\\n    \\n    public String longestWord(String[] words) {\\n        root = new TrieNode();\\n        for(String word: words){\\n            insert(word);\\n        }\\n        \\n        //This is very important. \\n        /*\\n            If length is same then sort in descending order because we want to check alphabetically smallest word\\n            If length is different then sort in ASC order of lengths because we want to check longest words first\\n        */\\n        Arrays.sort(words, (s1, s2) -> {\\n\\t\\t\\tif (s1.length() == s2.length()) {\\n\\t\\t\\t\\treturn s2.compareTo(s1);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn s1.length() - s2.length();\\n\\t\\t\\t}\\n\\t\\t});\\n        String result = \"\";\\n        \\n        //We start processing from the end of sorted array\\n        for(int i = words.length-1; i>=0; i--){\\n            boolean found = true;\\n            \\n            //Set to root for every new word scanning\\n            TrieNode curr = root;\\n            for(int j = 0; j < words[i].length(); j++){\\n                char c = words[i].charAt(j);\\n                \\n                //When there is a word ending at every character only then it is good for our result\\n                if(curr.children[c-\\'a\\'] != null && curr.children[c-\\'a\\'].isEnd){\\n                    curr = curr.children[c - \\'a\\'];\\n                    continue;\\n                }\\n                //Either character not found or isEnd is false then we didn\\'t find prefix word in given words dictionary\\n                else{\\n                    found = false;\\n                    break;\\n                }\\n            }\\n            if(found){\\n                return words[i];\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\n**Approach 2: Custom Sort + HashSet**\\n```\\nclass Solution {\\n    public String longestWord(String[] words) {\\n        HashSet<String> set = new HashSet<>();\\n        for(String word: words){\\n            set.add(word);\\n        }\\n        \\n        Arrays.sort(words, (s1, s2) -> {\\n\\t\\t\\tif (s1.length() == s2.length()) {\\n\\t\\t\\t\\treturn s2.compareTo(s1);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn s1.length() - s2.length();\\n\\t\\t\\t}\\n\\t\\t});\\n        System.out.println(Arrays.toString(words));\\n        String result = \"\";\\n        for(int i = words.length-1; i>=0; i--){\\n            boolean found = true;\\n            for(int j = 0; j < words[i].length(); j++){\\n                if(!set.contains(words[i].substring(0,j+1))){\\n                    found = false;\\n                    break;\\n                }\\n            }\\n            if(found){\\n                result = words[i];\\n                break;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n    Trie Based Impleementation\\n    Insert words in Trie. \\n    Searching in Trie is fast than searching in HashSet because we \\n    don\\'t have to use substring() plus we can use TrieNode root pointer to move along the \\n    characters of the word\\n\\t\\n\\tWe don\\'t need any search() method for Trie b\\'cz we will use TrieNode root pointer to look for characters in\\n\\tthe word we are searching\\n*/\\nclass Solution {\\n    public class TrieNode {\\n        char c;\\n        TrieNode[] children;\\n        boolean isEnd;\\n        public TrieNode(char c){\\n            this.isEnd = false;\\n            this.children = new TrieNode[26];\\n            this.c = c;\\n        }\\n        public TrieNode(){\\n            this.children = new TrieNode[26];\\n            this.isEnd = false;\\n        }\\n        \\n        public String toString(){\\n            return \"[\" + this.c + \"]\" ;  \\n        }\\n    }\\n    \\n    TrieNode root;\\n    \\n    public void insert(String word){\\n        TrieNode curr = root;\\n        for(int i = 0; i < word.length(); i++){\\n            char c = word.charAt(i);\\n            if(curr.children[c - \\'a\\'] == null){\\n                curr.children[c - \\'a\\'] = new TrieNode(c);\\n            }\\n            curr = curr.children[c - \\'a\\'];\\n        }\\n\\t\\t//Mark the end of word is very important here\\n        curr.isEnd=true;\\n    }\\n    \\n    public String longestWord(String[] words) {\\n        root = new TrieNode();\\n        for(String word: words){\\n            insert(word);\\n        }\\n        \\n        //This is very important. \\n        /*\\n            If length is same then sort in descending order because we want to check alphabetically smallest word\\n            If length is different then sort in ASC order of lengths because we want to check longest words first\\n        */\\n        Arrays.sort(words, (s1, s2) -> {\\n\\t\\t\\tif (s1.length() == s2.length()) {\\n\\t\\t\\t\\treturn s2.compareTo(s1);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn s1.length() - s2.length();\\n\\t\\t\\t}\\n\\t\\t});\\n        String result = \"\";\\n        \\n        //We start processing from the end of sorted array\\n        for(int i = words.length-1; i>=0; i--){\\n            boolean found = true;\\n            \\n            //Set to root for every new word scanning\\n            TrieNode curr = root;\\n            for(int j = 0; j < words[i].length(); j++){\\n                char c = words[i].charAt(j);\\n                \\n                //When there is a word ending at every character only then it is good for our result\\n                if(curr.children[c-\\'a\\'] != null && curr.children[c-\\'a\\'].isEnd){\\n                    curr = curr.children[c - \\'a\\'];\\n                    continue;\\n                }\\n                //Either character not found or isEnd is false then we didn\\'t find prefix word in given words dictionary\\n                else{\\n                    found = false;\\n                    break;\\n                }\\n            }\\n            if(found){\\n                return words[i];\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String longestWord(String[] words) {\\n        HashSet<String> set = new HashSet<>();\\n        for(String word: words){\\n            set.add(word);\\n        }\\n        \\n        Arrays.sort(words, (s1, s2) -> {\\n\\t\\t\\tif (s1.length() == s2.length()) {\\n\\t\\t\\t\\treturn s2.compareTo(s1);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn s1.length() - s2.length();\\n\\t\\t\\t}\\n\\t\\t});\\n        System.out.println(Arrays.toString(words));\\n        String result = \"\";\\n        for(int i = words.length-1; i>=0; i--){\\n            boolean found = true;\\n            for(int j = 0; j < words[i].length(); j++){\\n                if(!set.contains(words[i].substring(0,j+1))){\\n                    found = false;\\n                    break;\\n                }\\n            }\\n            if(found){\\n                result = words[i];\\n                break;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 954638,
                "title": "java-easy-to-understand-well-commented-code-trie-implementation",
                "content": "First, here is a bit of important theory which you need to know to understand how trie works.\\n\\nWhat does a trie node looks like and how does it stores the characters ?\\n*  A trie node consists of a HashMap of [character : NextNode of character] and a boolean flag endOfWord. If this flag is true, it means there is a word in trie ending at this node. \\n\\n* Note that we always add one extra node in addition to length of word. For eg. if we have a word of length 3, so we add 4 nodes into the trie, \\n\\n* In above example, the first 3 character will be present in first 3 nodes and the 4th node will be having endOfWord flag set to true\\n\\n* Also Note here that, as hashmap is used, so a trie node will not contains any duplicate characters. A trienode can contains many characters but for a word it will contains only one char per trie node.\\n\\n```\\n// A Trie Node\\nclass Node{\\n    HashMap<Character,Node> chars;\\n    boolean endOfWord;\\n    Node(){\\n        this.chars = new HashMap<>();\\n        this.endOfWord = false;\\n    }\\n}\\n\\npublic class Solution {\\n    // The head/root Node of Trie\\n    Node head = new Node();\\n    \\n\\t// Method to add a word into the trie\\n    private void addWord(String word){\\n\\t\\n\\t\\t// create a temporary pointer to keep track of the current node in Trie\\n        Node curr = head;\\n        \\n\\t\\t// for all the characters in the word\\n        for(int i=0; i<word.length(); i++){\\n\\t\\t\\n\\t\\t\\t// the current character\\n            char ch = word.charAt(i);\\n\\t\\t\\t\\n\\t\\t\\t// If my current node contains the char ch, we just move our temporary pointer \"curr\" to point to next node\\n            if(curr.chars.containsKey(ch)){\\n\\t\\t\\t\\t// get the address of the next node\\n                Node nextNode = curr.chars.get(ch);\\n\\t\\t\\t\\t// move our temporary pointer \"curr\" to point to next node\\n                curr = nextNode;\\n            }\\n\\t\\t\\t// else if my current node do not contains char ch, we create a new node to be the next node \\n            else{\\n\\t\\t\\t\\t// creating a next node\\n                Node nextNode = new Node();\\n\\t\\t\\t\\t// putting the current char \"ch\" in the current node \"curr\" and nextNode as it\\'s value\\n                curr.chars.put(ch,nextNode);\\n\\t\\t\\t\\t// move our temporary pointer \"curr\" to point to next node\\n                curr = nextNode;\\n            }\\n            \\n\\t\\t\\t// If we reach the last character, notice we have already moved to the nextNode of current char by the above conditions. \\n\\t\\t\\t// so, we just mark the endOfWord flag of current node as true, to mark the end of current word\\n            if(i==word.length()-1){\\n                curr.endOfWord = true;\\n            }\\n        }\\n    }\\n    \\n\\t// method to check if all prefixes to a given word is present in the Trie\\n    private boolean isAllPrefixExists(String word){\\n\\t\\n\\t// create a temporary pointer to keep track of the current node in Trie\\n        Node curr = head;\\n        \\n\\t\\t// for all the characters in the word\\n        for(int i=0; i<word.length(); i++){\\n\\t\\t\\n\\t\\t// the current character\\n            char ch = word.charAt(i);\\n\\t\\t\\t\\n\\t\\t\\t// If my current node contains the char ch, we just move our temporary pointer \"curr\" to point to next node\\n            if(curr.chars.containsKey(ch)){\\n\\t\\t\\t// get the address of the next node\\n                Node nextNode = curr.chars.get(ch);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// as we are checking for all pefixes, so all prefixes of the current word must be present it the trie and that too as a seprate word.\\n\\t\\t\\t\\t// Hence, every next node must have endOfWord flag set to true, so as to indicate the presence of every prefix word\\n\\t\\t\\t\\t// If above is not true, it means some prefix is missing, so we just return false\\n                if(!nextNode.endOfWord){\\n                    return false;\\n                }\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// move our temporary pointer \"curr\" to point to next node\\n                curr = nextNode;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// if curr node do not contain curr char, we need not think much and return false\\n            else{\\n                return false;\\n            }\\n            \\n\\t\\t\\t// If we reach the end of word, this means all prefixes of given has been found in Trie, so we return true\\n            if(i==word.length()-1){\\n                return true;\\n            }\\n        }\\n        \\n\\t\\t// return true by default, take a case where a string is of only 1 length\\n        return true;\\n    }\\n    \\n    public String longestWord(String[] words) {\\n\\t\\t\\n\\t\\t// variable to store max len of String whose all prefixes is present in Trie\\n        int maxLen = Integer.MIN_VALUE;\\n\\t\\t\\n\\t\\t// To store the max length string whose all prefixes is present in Trie\\n        StringBuilder sb = new StringBuilder();\\n        \\n\\t\\t// iterating through all word in words array and adding each word into Trie\\n        for(String word : words){\\n            addWord(word);\\n        }\\n        \\n\\t\\t// For each word in words array, we check if all its prefixes exists in the trie\\n\\t\\t// If all its prefixes exists, we just try to find the max length string\\n        for(String word : words){\\n            if(isAllPrefixExists(word)){\\n                if(word.length()>maxLen){\\n                    maxLen = word.length();\\n                    sb = new StringBuilder(word);\\n                }\\n\\t\\t\\t\\t// if we find a word whose length is same as max length string whose all prefix is present in trie, we just chose lexicographically smaller one (this condition has been given in question)\\n                else if(word.length()==maxLen){\\n                    if(sb.toString().compareTo(word)>0){\\n                        sb = new StringBuilder(word);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```\\n\\n***Time Complexity -* O(n.k), where n is total words in words array and k is the length of max length word**\\n\\n***Space Complexity [As we are storing each word in Trie] -* O(n.k), where n is total words in words array and k is the length of max length word**\\n\\nPlease let me know in comments if you are facing any difficulty in understanding the solution. \\n\\nIf you like this solution, please upvote :) \\n\\nHappy Coding!",
                "solutionTags": [],
                "code": "```\\n// A Trie Node\\nclass Node{\\n    HashMap<Character,Node> chars;\\n    boolean endOfWord;\\n    Node(){\\n        this.chars = new HashMap<>();\\n        this.endOfWord = false;\\n    }\\n}\\n\\npublic class Solution {\\n    // The head/root Node of Trie\\n    Node head = new Node();\\n    \\n\\t// Method to add a word into the trie\\n    private void addWord(String word){\\n\\t\\n\\t\\t// create a temporary pointer to keep track of the current node in Trie\\n        Node curr = head;\\n        \\n\\t\\t// for all the characters in the word\\n        for(int i=0; i<word.length(); i++){\\n\\t\\t\\n\\t\\t\\t// the current character\\n            char ch = word.charAt(i);\\n\\t\\t\\t\\n\\t\\t\\t// If my current node contains the char ch, we just move our temporary pointer \"curr\" to point to next node\\n            if(curr.chars.containsKey(ch)){\\n\\t\\t\\t\\t// get the address of the next node\\n                Node nextNode = curr.chars.get(ch);\\n\\t\\t\\t\\t// move our temporary pointer \"curr\" to point to next node\\n                curr = nextNode;\\n            }\\n\\t\\t\\t// else if my current node do not contains char ch, we create a new node to be the next node \\n            else{\\n\\t\\t\\t\\t// creating a next node\\n                Node nextNode = new Node();\\n\\t\\t\\t\\t// putting the current char \"ch\" in the current node \"curr\" and nextNode as it\\'s value\\n                curr.chars.put(ch,nextNode);\\n\\t\\t\\t\\t// move our temporary pointer \"curr\" to point to next node\\n                curr = nextNode;\\n            }\\n            \\n\\t\\t\\t// If we reach the last character, notice we have already moved to the nextNode of current char by the above conditions. \\n\\t\\t\\t// so, we just mark the endOfWord flag of current node as true, to mark the end of current word\\n            if(i==word.length()-1){\\n                curr.endOfWord = true;\\n            }\\n        }\\n    }\\n    \\n\\t// method to check if all prefixes to a given word is present in the Trie\\n    private boolean isAllPrefixExists(String word){\\n\\t\\n\\t// create a temporary pointer to keep track of the current node in Trie\\n        Node curr = head;\\n        \\n\\t\\t// for all the characters in the word\\n        for(int i=0; i<word.length(); i++){\\n\\t\\t\\n\\t\\t// the current character\\n            char ch = word.charAt(i);\\n\\t\\t\\t\\n\\t\\t\\t// If my current node contains the char ch, we just move our temporary pointer \"curr\" to point to next node\\n            if(curr.chars.containsKey(ch)){\\n\\t\\t\\t// get the address of the next node\\n                Node nextNode = curr.chars.get(ch);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// as we are checking for all pefixes, so all prefixes of the current word must be present it the trie and that too as a seprate word.\\n\\t\\t\\t\\t// Hence, every next node must have endOfWord flag set to true, so as to indicate the presence of every prefix word\\n\\t\\t\\t\\t// If above is not true, it means some prefix is missing, so we just return false\\n                if(!nextNode.endOfWord){\\n                    return false;\\n                }\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// move our temporary pointer \"curr\" to point to next node\\n                curr = nextNode;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// if curr node do not contain curr char, we need not think much and return false\\n            else{\\n                return false;\\n            }\\n            \\n\\t\\t\\t// If we reach the end of word, this means all prefixes of given has been found in Trie, so we return true\\n            if(i==word.length()-1){\\n                return true;\\n            }\\n        }\\n        \\n\\t\\t// return true by default, take a case where a string is of only 1 length\\n        return true;\\n    }\\n    \\n    public String longestWord(String[] words) {\\n\\t\\t\\n\\t\\t// variable to store max len of String whose all prefixes is present in Trie\\n        int maxLen = Integer.MIN_VALUE;\\n\\t\\t\\n\\t\\t// To store the max length string whose all prefixes is present in Trie\\n        StringBuilder sb = new StringBuilder();\\n        \\n\\t\\t// iterating through all word in words array and adding each word into Trie\\n        for(String word : words){\\n            addWord(word);\\n        }\\n        \\n\\t\\t// For each word in words array, we check if all its prefixes exists in the trie\\n\\t\\t// If all its prefixes exists, we just try to find the max length string\\n        for(String word : words){\\n            if(isAllPrefixExists(word)){\\n                if(word.length()>maxLen){\\n                    maxLen = word.length();\\n                    sb = new StringBuilder(word);\\n                }\\n\\t\\t\\t\\t// if we find a word whose length is same as max length string whose all prefix is present in trie, we just chose lexicographically smaller one (this condition has been given in question)\\n                else if(word.length()==maxLen){\\n                    if(sb.toString().compareTo(word)>0){\\n                        sb = new StringBuilder(word);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 945026,
                "title": "go-map",
                "content": "```\\nfunc longestWord(words []string) string {\\n    sort.Slice(words, func(i int, j int) bool {\\n        if len(words[i]) == len(words[j]) {\\n            return words[i] > words[j]\\n        }\\n        return len(words[i]) < len(words[j])\\n    })\\n    \\n    set := make(map[string]struct{})\\n    set[\"\"] = struct{}{}\\n    \\n    var res string\\n    for _, s := range words {\\n        if _, ok := set[s[:len(s) - 1]]; ok {\\n            set[s] = struct{}{}\\n            res = s\\n        }\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc longestWord(words []string) string {\\n    sort.Slice(words, func(i int, j int) bool {\\n        if len(words[i]) == len(words[j]) {\\n            return words[i] > words[j]\\n        }\\n        return len(words[i]) < len(words[j])\\n    })\\n    \\n    set := make(map[string]struct{})\\n    set[\"\"] = struct{}{}\\n    \\n    var res string\\n    for _, s := range words {\\n        if _, ok := set[s[:len(s) - 1]]; ok {\\n            set[s] = struct{}{}\\n            res = s\\n        }\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 944319,
                "title": "python-solution-with-trie",
                "content": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.edges = {}\\n        self.isWordEnd = False\\n        \\n    def insert(self, word):\\n        currentNode = self\\n        \\n        for c in word:\\n            if c not in currentNode.edges:\\n                currentNode.edges[c] = TrieNode()\\n            currentNode = currentNode.edges[c]\\n        \\n        currentNode.isWordEnd = True\\n     \\n    def word_of_words(self, word):\\n        currentNode = self\\n        edges = currentNode.edges\\n        \\n        for c in word:\\n            if c not in currentNode.edges:\\n                return False\\n            node = currentNode.edges[c]\\n            if not node.isWordEnd:\\n                return False\\n            currentNode = currentNode.edges[c]\\n        return currentNode.isWordEnd\\n        \\nclass Solution:\\n    def longestWord(self, words: List[str]) -> str:\\n        longest_word = \"\"\\n        max_length = 0\\n        root = TrieNode()\\n        \\n        for word in words:\\n            root.insert(word)\\n        \\n        for word in words:\\n            if root.word_of_words(word):\\n                if len(word) == max_length:\\n                    # see which one is lexographically smallest order\\n                    lex_sort = [longest_word, word]\\n                    lex_sort.sort()\\n                    longest_word = lex_sort[0]\\n                elif len(word) > max_length:\\n                    longest_word = word \\n                max_length = max(max_length, len(word))\\n        return longest_word\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.edges = {}\\n        self.isWordEnd = False\\n        \\n    def insert(self, word):\\n        currentNode = self\\n        \\n        for c in word:\\n            if c not in currentNode.edges:\\n                currentNode.edges[c] = TrieNode()\\n            currentNode = currentNode.edges[c]\\n        \\n        currentNode.isWordEnd = True\\n     \\n    def word_of_words(self, word):\\n        currentNode = self\\n        edges = currentNode.edges\\n        \\n        for c in word:\\n            if c not in currentNode.edges:\\n                return False\\n            node = currentNode.edges[c]\\n            if not node.isWordEnd:\\n                return False\\n            currentNode = currentNode.edges[c]\\n        return currentNode.isWordEnd\\n        \\nclass Solution:\\n    def longestWord(self, words: List[str]) -> str:\\n        longest_word = \"\"\\n        max_length = 0\\n        root = TrieNode()\\n        \\n        for word in words:\\n            root.insert(word)\\n        \\n        for word in words:\\n            if root.word_of_words(word):\\n                if len(word) == max_length:\\n                    # see which one is lexographically smallest order\\n                    lex_sort = [longest_word, word]\\n                    lex_sort.sort()\\n                    longest_word = lex_sort[0]\\n                elif len(word) > max_length:\\n                    longest_word = word \\n                max_length = max(max_length, len(word))\\n        return longest_word\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936133,
                "title": "java-trie-solution",
                "content": "```\\n    TrieNode root = new TrieNode();\\n    String res = \"\";\\n    public String longestWord(String[] words) {\\n        for (String w : words) {\\n            build(w);\\n        }\\n        TrieNode node = root;\\n         dfs(node);\\n        return res; \\n    }\\n\\n    private void dfs(TrieNode node) {\\n       \\n        \\n        for (char c : node.children.keySet()) {\\n            TrieNode cur = node.children.get(c); \\n            if (cur.isWord) {\\n                if (res.length() == cur.word.length()) {\\n                    if (res.compareTo(cur.word) > 0) {\\n                        res = cur.word; \\n                    }\\n                } else if (res.length() < cur.word.length()) {\\n                    res = cur.word; \\n                }\\n                dfs(cur); \\n            }\\n\\n        }\\n    }\\n\\n    private void build(String w) {\\n        TrieNode node = root;\\n\\n        for (char c : w.toCharArray()) {\\n            if (!node.children.containsKey(c)) {\\n                node.children.put(c, new TrieNode());\\n            }\\n            node = node.children.get(c);\\n        }\\n        node.isWord = true;\\n        node.word = w;\\n    }\\n\\n    class TrieNode {\\n        Map<Character, TrieNode> children = new HashMap<>();\\n        boolean isWord = false;\\n        String word = \"\";\\n    }",
                "solutionTags": [],
                "code": "```\\n    TrieNode root = new TrieNode();\\n    String res = \"\";\\n    public String longestWord(String[] words) {\\n        for (String w : words) {\\n            build(w);\\n        }\\n        TrieNode node = root;\\n         dfs(node);\\n        return res; \\n    }\\n\\n    private void dfs(TrieNode node) {\\n       \\n        \\n        for (char c : node.children.keySet()) {\\n            TrieNode cur = node.children.get(c); \\n            if (cur.isWord) {\\n                if (res.length() == cur.word.length()) {\\n                    if (res.compareTo(cur.word) > 0) {\\n                        res = cur.word; \\n                    }\\n                } else if (res.length() < cur.word.length()) {\\n                    res = cur.word; \\n                }\\n                dfs(cur); \\n            }\\n\\n        }\\n    }\\n\\n    private void build(String w) {\\n        TrieNode node = root;\\n\\n        for (char c : w.toCharArray()) {\\n            if (!node.children.containsKey(c)) {\\n                node.children.put(c, new TrieNode());\\n            }\\n            node = node.children.get(c);\\n        }\\n        node.isWord = true;\\n        node.word = w;\\n    }\\n\\n    class TrieNode {\\n        Map<Character, TrieNode> children = new HashMap<>();\\n        boolean isWord = false;\\n        String word = \"\";\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 911777,
                "title": "python3-simple-solution",
                "content": "```\\nclass Solution:\\n    def longestWord(self, words: List[str]) -> str:\\n        wordSet = set(words)\\n        returnList = []\\n        for word in words:\\n            if all(word[:k] in wordSet for k in range(1,len(word))):\\n                    returnList.append(word)\\n\\n        returnList.sort() # sorts normally by alphabetical order\\n        returnList.sort(key=len, reverse=True) # sorts by descending length\\n\\n        return returnList[0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestWord(self, words: List[str]) -> str:\\n        wordSet = set(words)\\n        returnList = []\\n        for word in words:\\n            if all(word[:k] in wordSet for k in range(1,len(word))):\\n                    returnList.append(word)\\n\\n        returnList.sort() # sorts normally by alphabetical order\\n        returnList.sort(key=len, reverse=True) # sorts by descending length\\n\\n        return returnList[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 892192,
                "title": "simple-javascript-trie-dfs-solution",
                "content": "```\\nfunction TrieNode(){\\n    this.children = new Map()\\n    this.endOfWord = false\\n}\\n\\nvar longestWord = function(words) {\\n    let root = new TrieNode()\\n    \\n    words.sort((a,b)=>a.localeCompare(b))\\n    for(let word of words){\\n        let curr = root\\n        for(let w of word){\\n            let map = curr.children\\n            if(!map.has(w)) map.set(w, new TrieNode())\\n            curr = map.get(w)\\n        }\\n        curr.endOfWord = true\\n    }\\n    \\n    \\n    function dfs(root, str, res){\\n        for(let [char, node] of root.children){\\n            if(!node.endOfWord) continue\\n            res = dfs(node, str+char, res)\\n        }\\n        res = res.length<str.length ? str : res\\n        return res;\\n    }\\n    \\n    return dfs(root, \\'\\', \\'\\')\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nfunction TrieNode(){\\n    this.children = new Map()\\n    this.endOfWord = false\\n}\\n\\nvar longestWord = function(words) {\\n    let root = new TrieNode()\\n    \\n    words.sort((a,b)=>a.localeCompare(b))\\n    for(let word of words){\\n        let curr = root\\n        for(let w of word){\\n            let map = curr.children\\n            if(!map.has(w)) map.set(w, new TrieNode())\\n            curr = map.get(w)\\n        }\\n        curr.endOfWord = true\\n    }\\n    \\n    \\n    function dfs(root, str, res){\\n        for(let [char, node] of root.children){\\n            if(!node.endOfWord) continue\\n            res = dfs(node, str+char, res)\\n        }\\n        res = res.length<str.length ? str : res\\n        return res;\\n    }\\n    \\n    return dfs(root, \\'\\', \\'\\')\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 888841,
                "title": "python-simple-set-solution-90-10-10-2020",
                "content": "I\\'ve submitted different variations of the same solution, but for some reason this code is faster according to leetcode. \\n\\nThe solution works by sorting by length at first and checking if the current_prefix (everything but the last character) is in the set of prefixes. \\n\\nThe set of prefixes is first built by adding all the characters of length one since those are our building blocks from the very beginning.\\n\\nThe second step if for the current word, consider the current_prefix (everything but the last character) if we have seen it in prefixes set then go ahead and add the current word to the set of prefixes and update the answer. \\n\\nThere is the case were the answer will be same length, in this case we only choose the smallest lexicographically which is done using the min() function.\\n\\nOne final case is when no words are buildable aside from the initial words of len 1, in this case we return the first element of words e.g words[0] since the sorted(key=len) call will sort by the first character (lexicographically) and by the length. \\n\\nI did make a cleaner version of this answer but it is slower, check the second version.\\n\\n90%\\n```\\nclass Solution:\\n    def longestWord(self, words: List[str]) -> str:\\n        prefixes = set()\\n                \\n        words = sorted(words, key=len)\\n        ans = \"\"\\n        for idx, word in enumerate(words):\\n        \\n            current_prefix = word[:len(word) - 1]\\n            if len(word) == 1:\\n                current_prefix = word\\n    \\n            if current_prefix not in prefixes and len(word) > 1:\\n                pass \\n            \\n            else:\\n                prefixes.add(word)\\n                if ans != \"\" and len(ans) == len(word):\\n                    ans = min(ans, word)\\n                else:\\n                    ans = word\\n        return ans\\n```\\n\\nHere\\'s the second variation of the same solution but with two sorts at the beginning and a bit slower \\n70%\\n```\\nclass Solution:\\n    def longestWord(self, words: List[str]) -> str:\\n        words.sort()\\n        words.sort(key=len)\\n        \\n        prefixes = set()\\n        longestWord = words[0]\\n        \\n        for word in words:\\n            if len(word) == 1:\\n                prefixes.add(word)\\n                continue\\n            \\n            # the prefix of the current word is everything but the last character\\n            currentPrefix = word[:len(word) - 1]\\n            \\n            # if the current prefix is in the set of previously possible \\n            # strings then we know we can add it to prefixes and it is a \\n            # candidate for the longest possible string\\n            \\n            if currentPrefix in prefixes:\\n                if len(longestWord) < len(word):\\n                    longestWord = word\\n                prefixes.add(word)\\n            \\n        print(words)\\n        return longestWord\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def longestWord(self, words: List[str]) -> str:\\n        prefixes = set()\\n                \\n        words = sorted(words, key=len)\\n        ans = \"\"\\n        for idx, word in enumerate(words):\\n        \\n            current_prefix = word[:len(word) - 1]\\n            if len(word) == 1:\\n                current_prefix = word\\n    \\n            if current_prefix not in prefixes and len(word) > 1:\\n                pass \\n            \\n            else:\\n                prefixes.add(word)\\n                if ans != \"\" and len(ans) == len(word):\\n                    ans = min(ans, word)\\n                else:\\n                    ans = word\\n        return ans\\n```\n```\\nclass Solution:\\n    def longestWord(self, words: List[str]) -> str:\\n        words.sort()\\n        words.sort(key=len)\\n        \\n        prefixes = set()\\n        longestWord = words[0]\\n        \\n        for word in words:\\n            if len(word) == 1:\\n                prefixes.add(word)\\n                continue\\n            \\n            # the prefix of the current word is everything but the last character\\n            currentPrefix = word[:len(word) - 1]\\n            \\n            # if the current prefix is in the set of previously possible \\n            # strings then we know we can add it to prefixes and it is a \\n            # candidate for the longest possible string\\n            \\n            if currentPrefix in prefixes:\\n                if len(longestWord) < len(word):\\n                    longestWord = word\\n                prefixes.add(word)\\n            \\n        print(words)\\n        return longestWord\\n```",
                "codeTag": "Java"
            },
            {
                "id": 872425,
                "title": "python-trie-solution-failing-on-eq",
                "content": "python trie solution - failing on this test case and not sure what i\\'m missing? this seems to be lexicographically sorted?\\n\\nInput: [\"yo\",\"ew\",\"fc\",\"zrc\",\"yodn\",\"fcm\",\"qm\",\"qmo\",\"fcmz\",\"z\",\"ewq\",\"yod\",\"ewqz\",\"y\"]\\nOutput: \"ewqz\"\\nExpected: \"yodn\"\\n\\n```\\nclass Solution:\\n    def longestWord(self, words: List[str]) -> str:\\n        trie = {}\\n        maxlen, maxword = 0, \"\"\\n        \\n        for word in words:\\n            node = trie\\n            curlen = 0\\n            \\n            for char in list(word):\\n                if char not in node:\\n                    node[char] = {}\\n                else:\\n                    curlen += 1\\n                    \\n                node = node[char]\\n                \\n            if not maxword or (curlen > maxlen or (curlen == maxlen and word < maxword)):\\n                maxword = word\\n                maxlen = curlen\\n                \\n        return maxword\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestWord(self, words: List[str]) -> str:\\n        trie = {}\\n        maxlen, maxword = 0, \"\"\\n        \\n        for word in words:\\n            node = trie\\n            curlen = 0\\n            \\n            for char in list(word):\\n                if char not in node:\\n                    node[char] = {}\\n                else:\\n                    curlen += 1\\n                    \\n                node = node[char]\\n                \\n            if not maxword or (curlen > maxlen or (curlen == maxlen and word < maxword)):\\n                maxword = word\\n                maxlen = curlen\\n                \\n        return maxword\\n```",
                "codeTag": "Java"
            },
            {
                "id": 824946,
                "title": "trie-solution-c-better-than-88",
                "content": "```\\nstruct trie{\\n    trie* next[26];\\n    bool isword;\\n    trie()\\n    {\\n        for(int i=0;i<26;i++)\\n        {\\n            next[i]=NULL;\\n        }\\n        isword=false;\\n    }\\n};\\n\\nclass trieNode{\\n    trie dummy;\\n    trie* root;\\n    public:\\n    trieNode()\\n    {\\n        root=new trie();\\n    }\\n    void insert(string s)\\n    {\\n        trie* curr=root;\\n        int n=s.length();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(curr->next[s[i]-\\'a\\']==NULL)\\n            {\\n                curr->next[s[i]-\\'a\\']=new trie();\\n            }\\n            curr=curr->next[s[i]-\\'a\\'];\\n        }\\n        curr->isword=true;\\n    }\\n    bool isPrefix(string s)\\n    {\\n        trie* curr=root;\\n        int n=s.length();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(curr->next[s[i]-\\'a\\']==NULL)\\n                return false;\\n            if(curr->next[s[i]-\\'a\\']->isword==false)\\n                return false;\\n            curr=curr->next[s[i]-\\'a\\'];\\n        }\\n        return true;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    string longestWord(vector<string>& words) {\\n     \\n        trieNode* t=new trieNode();\\n        int n=words.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            t->insert(words[i]);\\n        }\\n        \\n        int length=0;\\n        string str=\"\";\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            //cout<<words[i]<<endl;\\n            string s=words[i];\\n            if(t->isPrefix(words[i]))\\n            {\\n                if(words[i].length()>=length)\\n                {\\n                    if(str.length()==s.length())\\n                    {\\n                        str=min(str,s);\\n                    }\\n                    else\\n                    {\\n                        str=s;\\n                    }\\n                    length=str.length();\\n                }\\n            }\\n        }\\n        return str;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Trie"
                ],
                "code": "class Solution {\\npublic:\\n    string longestWord(vector<string>& words) {\\n     \\n        trieNode* t=new trieNode();\\n        int n=words.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            t->insert(words[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 812026,
                "title": "c-trie-solution",
                "content": "Runtime: 49 ms, faster than 82.07% of C++ online submissions for Longest Word in Dictionary.\\nMemory Usage: 30.3 MB, less than 44.48% of C++ online submissions for Longest Word in Dictionary.\\n\\n```\\n\\n1. Store all words in to trie and also make a bucket of word length and index\\n2. Loop through bucket from max length to min length \\n3. For each bucket check all words in trie if every char of that word is a leaf\\n4. Then check the current word with previous result and update with lexically smaller one\\n5. As soon as result found in a certain bucket then return result\\n\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    struct Trie {\\n      Trie * child[26];\\n      bool leaf; \\n    };\\n\\n    // create trie node\\n    Trie * trieCreate()\\n    {\\n        Trie * trie = new Trie();\\n        for(int i =0;i<26;i++)\\n            trie->child[i] = NULL;\\n\\n        trie->leaf = false;\\n\\n        return trie;\\n    }\\n    \\n    // insert words in to trie\\n    void trieInsert(Trie * obj, string word)\\n    {\\n        int i = 0;\\n        int index;\\n        while(word[i]!=\\'\\\\0\\')\\n        {\\n            index = word[i] - \\'a\\';\\n            if(obj->child[index]==NULL)\\n                obj->child[index] = trieCreate();              \\n\\n            obj = obj->child[index];\\n            \\n            i++;\\n        }\\n        \\n        obj->leaf = true;        \\n    }\\n    \\n    // search in to trie such that every char of the word is a leaf node\\n    bool trieSearch(Trie * obj, string &str)\\n    {\\n        int index;\\n        int sl = str.length();\\n        for(int i=0;i<sl;i++)\\n        {\\n            index = str[i]-\\'a\\';\\n            if(obj->child[index]==NULL || !obj->child[index]->leaf)return false;\\n            \\n            obj = obj->child[index];\\n        }\\n        \\n        return obj->leaf;\\n    }\\n    \\n    \\n    string longestWord(vector<string>& words) {\\n        \\n        Trie * trie = trieCreate();\\n        int n = words.size();\\n        \\n        // string length and index bucket\\n        vector<vector<int>>lengthTrack(31);\\n        \\n        // track the max length of the words\\n        int maxLength = INT_MIN;\\n        int len;\\n        \\n        // add words in to trie and update bucket with length and track max length\\n        for(int i=0;i<n;i++)\\n        {\\n            trieInsert(trie,words[i]); \\n            \\n            len = words[i].length();         \\n            lengthTrack[len].push_back(i);\\n            \\n            maxLength = max(maxLength,len);\\n        }\\n\\n        \\n        // result word index\\n        int res = -1;\\n        int index;\\n        \\n        // loop from max length bucket to min length bucket and search words which have every char as leaf in trie\\n        // for certain length bucket for multiple string get the lexically smaller one\\n        // as soon as all words in a bucket are processed and result index is found return word of the result index\\n        for(int i=maxLength;i>=1;i--)\\n        {\\n            for(int j=0;j<lengthTrack[i].size();j++)\\n            {\\n                index = lengthTrack[i][j];\\n                \\n                // check current word has all char as leaf in trie\\n                if(trieSearch(trie,words[index]))\\n                {\\n                    // get the lexically smaller word for same length\\n                    if(res==-1 || lexicographical_compare(words[index].begin(),words[index].end(),words[res].begin(),words[res].end()))\\n                        res = index;\\n                }\\n            }\\n            \\n            // result found for current bucket and so return\\n            if(res!=-1) return words[res];\\n        }\\n        \\n        // no possible solution\\n        return \"\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\n\\n1. Store all words in to trie and also make a bucket of word length and index\\n2. Loop through bucket from max length to min length \\n3. For each bucket check all words in trie if every char of that word is a leaf\\n4. Then check the current word with previous result and update with lexically smaller one\\n5. As soon as result found in a certain bucket then return result\\n\\n```\n```\\nclass Solution {\\npublic:\\n    struct Trie {\\n      Trie * child[26];\\n      bool leaf; \\n    };\\n\\n    // create trie node\\n    Trie * trieCreate()\\n    {\\n        Trie * trie = new Trie();\\n        for(int i =0;i<26;i++)\\n            trie->child[i] = NULL;\\n\\n        trie->leaf = false;\\n\\n        return trie;\\n    }\\n    \\n    // insert words in to trie\\n    void trieInsert(Trie * obj, string word)\\n    {\\n        int i = 0;\\n        int index;\\n        while(word[i]!=\\'\\\\0\\')\\n        {\\n            index = word[i] - \\'a\\';\\n            if(obj->child[index]==NULL)\\n                obj->child[index] = trieCreate();              \\n\\n            obj = obj->child[index];\\n            \\n            i++;\\n        }\\n        \\n        obj->leaf = true;        \\n    }\\n    \\n    // search in to trie such that every char of the word is a leaf node\\n    bool trieSearch(Trie * obj, string &str)\\n    {\\n        int index;\\n        int sl = str.length();\\n        for(int i=0;i<sl;i++)\\n        {\\n            index = str[i]-\\'a\\';\\n            if(obj->child[index]==NULL || !obj->child[index]->leaf)return false;\\n            \\n            obj = obj->child[index];\\n        }\\n        \\n        return obj->leaf;\\n    }\\n    \\n    \\n    string longestWord(vector<string>& words) {\\n        \\n        Trie * trie = trieCreate();\\n        int n = words.size();\\n        \\n        // string length and index bucket\\n        vector<vector<int>>lengthTrack(31);\\n        \\n        // track the max length of the words\\n        int maxLength = INT_MIN;\\n        int len;\\n        \\n        // add words in to trie and update bucket with length and track max length\\n        for(int i=0;i<n;i++)\\n        {\\n            trieInsert(trie,words[i]); \\n            \\n            len = words[i].length();         \\n            lengthTrack[len].push_back(i);\\n            \\n            maxLength = max(maxLength,len);\\n        }\\n\\n        \\n        // result word index\\n        int res = -1;\\n        int index;\\n        \\n        // loop from max length bucket to min length bucket and search words which have every char as leaf in trie\\n        // for certain length bucket for multiple string get the lexically smaller one\\n        // as soon as all words in a bucket are processed and result index is found return word of the result index\\n        for(int i=maxLength;i>=1;i--)\\n        {\\n            for(int j=0;j<lengthTrack[i].size();j++)\\n            {\\n                index = lengthTrack[i][j];\\n                \\n                // check current word has all char as leaf in trie\\n                if(trieSearch(trie,words[index]))\\n                {\\n                    // get the lexically smaller word for same length\\n                    if(res==-1 || lexicographical_compare(words[index].begin(),words[index].end(),words[res].begin(),words[res].end()))\\n                        res = index;\\n                }\\n            }\\n            \\n            // result found for current bucket and so return\\n            if(res!=-1) return words[res];\\n        }\\n        \\n        // no possible solution\\n        return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 781387,
                "title": "java-solution-trie-dfs",
                "content": "```\\n//Trie Node \\nclass TrieNode{\\n    String word;\\n    TrieNode[] childrend = new TrieNode[26];\\n    TrieNode(){}\\n}\\n\\nclass Solution {\\n    TrieNode root;\\n    String result = \"\";\\n    public String longestWord(String[] words) {\\n        root = new TrieNode();\\n        if(words == null) return result;\\n        for(String w: words){\\n            insert(w);\\n        }\\n        dfs(root);\\n        \\n        return result;\\n    }\\n    \\n    private void dfs(TrieNode node){\\n        if(node == null) return;\\n        \\n        if(node.word != null){\\n            if(node.word.length() > result.length()){\\n                result = node.word;\\n            }else if(node.word.length() == result.length() && node.word.compareTo(result) < 0){\\n                result = node.word;\\n            }\\n        }\\n        \\n        for(TrieNode child : node.childrend){\\n            if(child != null && child.word != null)\\n                dfs(child);\\n        }\\n        \\n    }\\n    \\n    private void insert(String word){\\n        TrieNode curr = root;\\n        \\n        for(char c: word.toCharArray()){\\n            \\n            if(curr.childrend[c-\\'a\\'] == null){\\n                curr.childrend[c-\\'a\\'] = new TrieNode();\\n            }\\n            curr = curr.childrend[c-\\'a\\']; \\n        }\\n        \\n        curr.word = word;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\n//Trie Node \\nclass TrieNode{\\n    String word;\\n    TrieNode[] childrend = new TrieNode[26];\\n    TrieNode(){}\\n}\\n\\nclass Solution {\\n    TrieNode root;\\n    String result = \"\";\\n    public String longestWord(String[] words) {\\n        root = new TrieNode();\\n        if(words == null) return result;\\n        for(String w: words){\\n            insert(w);\\n        }\\n        dfs(root);\\n        \\n        return result;\\n    }\\n    \\n    private void dfs(TrieNode node){\\n        if(node == null) return;\\n        \\n        if(node.word != null){\\n            if(node.word.length() > result.length()){\\n                result = node.word;\\n            }else if(node.word.length() == result.length() && node.word.compareTo(result) < 0){\\n                result = node.word;\\n            }\\n        }\\n        \\n        for(TrieNode child : node.childrend){\\n            if(child != null && child.word != null)\\n                dfs(child);\\n        }\\n        \\n    }\\n    \\n    private void insert(String word){\\n        TrieNode curr = root;\\n        \\n        for(char c: word.toCharArray()){\\n            \\n            if(curr.childrend[c-\\'a\\'] == null){\\n                curr.childrend[c-\\'a\\'] = new TrieNode();\\n            }\\n            curr = curr.childrend[c-\\'a\\']; \\n        }\\n        \\n        curr.word = word;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 777103,
                "title": "python-using-hashset",
                "content": "\"\"\"\\n\\n\\tclass Solution:\\n    def longestWord(self, words: List[str]) -> str:\\n        words.sort()\\n        hashmap=set()\\n        res=\"\"\\n        for w in words:\\n            \\n\\t\\t\\t   if len(w)==1 or w[:len(w)-1] in hashmap:\\n                \\n                if len(w) > len(res) or w < res:\\n                    res = w\\n                    \\n                hashmap.add(w)\\n                \\n        return res\\n   \"\"\"",
                "solutionTags": [],
                "code": "\"\"\"\\n\\n\\tclass Solution:\\n    def longestWord(self, words: List[str]) -> str:\\n        words.sort()\\n        hashmap=set()\\n        res=\"\"\\n        for w in words:\\n            \\n\\t\\t\\t   if len(w)==1 or w[:len(w)-1] in hashmap:\\n                \\n                if len(w) > len(res) or w < res:\\n                    res = w\\n                    \\n                hashmap.add(w)\\n                \\n        return res\\n   \"\"\"",
                "codeTag": "Java"
            },
            {
                "id": 746739,
                "title": "cpp-solution-commented-solution-easy-to-understand-fully-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    string res=\"\";  //final result variable\\n    class TriNode  //build a trie to store words\\n    {   public: \\n        int end;\\n        TriNode *child[26]={NULL};\\n    };\\n    \\n    void insert(string w, TriNode *root)\\n    {    \\n        string s=\"\"; \\n        for(int i=0;i<w.size();i++)\\n        {   if(i==w.size()-1) s+=w[i];  //if it is last char or size is 1\\n                \\n            \\n            if(!root->child[w[i]-\\'a\\'])\\n            {       if(i!=w.size()-1) break; //if it is not last char then no need to add it in tree\\n               //i.e a ap apdl appde here if \\'d\\' is encounter then it is not last char , it means after ap no suffix is valid hence no need to add\\n                root->child[w[i]-\\'a\\'] = new TriNode();  //if char is not in tree and it is last char\\n            }\\n            else s+=w[i];  //if prefix is present add it to s\\n             \\n            root=root->child[w[i]-\\'a\\'];\\n        }\\n        root->end=1;\\n        if(s.length()==res.length()&&s<res) { res=s;}  //for lexigraphical order\\n        if(s.length()>res.length()) { res=s;} //if size is greater then update\\n    \\n    }\\n     \\n    string longestWord(vector<string>& words) { \\n         sort(begin(words), end(words));\\n         TriNode *root= new TriNode();\\n        for(int i=0;i<words.size();i++)\\n        {\\n            if(i+1<words.size())\\n            {\\n                if(words[i]==words[i+1]) continue;  //if words are same no need to insert in trie\\n            }\\n            insert(words[i],root);\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string res=\"\";  //final result variable\\n    class TriNode  //build a trie to store words\\n    {   public: \\n        int end;\\n        TriNode *child[26]={NULL};\\n    };\\n    \\n    void insert(string w, TriNode *root)\\n    {    \\n        string s=\"\"; \\n        for(int i=0;i<w.size();i++)\\n        {   if(i==w.size()-1) s+=w[i];  //if it is last char or size is 1\\n                \\n            \\n            if(!root->child[w[i]-\\'a\\'])\\n            {       if(i!=w.size()-1) break; //if it is not last char then no need to add it in tree\\n               //i.e a ap apdl appde here if \\'d\\' is encounter then it is not last char , it means after ap no suffix is valid hence no need to add\\n                root->child[w[i]-\\'a\\'] = new TriNode();  //if char is not in tree and it is last char\\n            }\\n            else s+=w[i];  //if prefix is present add it to s\\n             \\n            root=root->child[w[i]-\\'a\\'];\\n        }\\n        root->end=1;\\n        if(s.length()==res.length()&&s<res) { res=s;}  //for lexigraphical order\\n        if(s.length()>res.length()) { res=s;} //if size is greater then update\\n    \\n    }\\n     \\n    string longestWord(vector<string>& words) { \\n         sort(begin(words), end(words));\\n         TriNode *root= new TriNode();\\n        for(int i=0;i<words.size();i++)\\n        {\\n            if(i+1<words.size())\\n            {\\n                if(words[i]==words[i+1]) continue;  //if words are same no need to insert in trie\\n            }\\n            insert(words[i],root);\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 735184,
                "title": "java-trie-dfs-with-explanation",
                "content": "```\\nclass Solution {\\n    //build the Trie class\\n    public class Trie{\\n        char val; // the character\\n        Trie[] children; //26 children\\n        boolean isWord; //if it is a word at this point\\n        String word = null; //iif it is a word, we can return this word here.\\n        public Trie(){\\n            isWord = false;\\n            children = new Trie[26];\\n            word = null;\\n        }\\n        public Trie(char val){\\n            this.val = val;\\n            isWord = false;\\n            children = new Trie[26];\\n            word = null;\\n        }\\n    }\\n    \\n    //the root\\n    private Trie root = new Trie();\\n    \\n    //a list to store all posible choices here\\n    List<String> list = new ArrayList<>();\\n    \\n    //the so far longest word\\'s length we got.\\n    int maxindex = 0;\\n    \\n    // add every word in the Trie Tree\\n    public void addword(String s){\\n        Trie itr = root;\\n        for(char c : s.toCharArray()){\\n            if(itr.children[c-\\'a\\'] == null){\\n                itr.children[c-\\'a\\'] = new Trie(c);\\n            }\\n            itr = itr.children[c-\\'a\\']; \\n        }\\n        itr.isWord = true; //at the end, mark it is  a word\\n        itr.word = s; // also attach what this word is.\\n    }\\n    \\n    \\n    public String longestWord(String[] words) {\\n        \\n        //first add all the words in the trie tree\\n        for(String s :words){\\n            addword(s);\\n        }\\n        \\n        //dfs all the words\\n        dfs(root, 0);\\n        \\n        // if no words we got.\\n        if(list.size() == 0) return \"\";\\n        \\n        // return the last one we got in the list, which is the longest one.\\n        return list.get(list.size() -1);\\n    }\\n    \\n    \\n    public void dfs(Trie root, int len){ // len is depth of the tree\\n        boolean flag = false;//to mark if we can go to next level\\n        for(Trie r : root.children){\\n            // this the children of this root has a complete word, we go to next level:\\n            if(r != null && r.isWord){\\n                flag = true;\\n                dfs(r, len+1);\\n            }\\n        }\\n        //if root\\'s children have no exsiting word\\n        if(flag == false){\\n            //if it is longer than the current longest word, we put it in the list.\\n            //we do not have to worry about lexicographical order becuase the search naturally follows it.\\n            if(len > maxindex){\\n                maxindex = len;\\n                list.add(root.word);\\n            }\\n        }\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    //build the Trie class\\n    public class Trie{\\n        char val; // the character\\n        Trie[] children; //26 children\\n        boolean isWord; //if it is a word at this point\\n        String word = null; //iif it is a word, we can return this word here.\\n        public Trie(){\\n            isWord = false;\\n            children = new Trie[26];\\n            word = null;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 735183,
                "title": "java-trie-and-dfs-with-detailed-explanation",
                "content": "class Solution {\\n    //build the Trie class\\n    public class Trie{\\n        char val; // the character\\n        Trie[] children; //26 children\\n        boolean isWord; //if it is a word at this point\\n        String word = null; //iif it is a word, we can return this word here.\\n        public Trie(){\\n            isWord = false;\\n            children = new Trie[26];\\n            word = null;\\n        }\\n        public Trie(char val){\\n            this.val = val;\\n            isWord = false;\\n            children = new Trie[26];\\n            word = null;\\n        }\\n    }\\n    \\n    //the root\\n    private Trie root = new Trie();\\n    \\n    //a list to store all posible choices here\\n    List<String> list = new ArrayList<>();\\n    \\n    //the so far longest word\\'s length we got.\\n    int maxindex = 0;\\n    \\n    // add every word in the Trie Tree\\n    public void addword(String s){\\n        Trie itr = root;\\n        for(char c : s.toCharArray()){\\n            if(itr.children[c-\\'a\\'] == null){\\n                itr.children[c-\\'a\\'] = new Trie(c);\\n            }\\n            itr = itr.children[c-\\'a\\']; \\n        }\\n        itr.isWord = true; //at the end, mark it is  a word\\n        itr.word = s; // also attach what this word is.\\n    }\\n    \\n    \\n    public String longestWord(String[] words) {\\n        \\n        //first add all the words in the trie tree\\n        for(String s :words){\\n            addword(s);\\n        }\\n        \\n        //dfs all the words\\n        dfs(root, 0);\\n        \\n        // if no words we got.\\n        if(list.size() == 0) return \"\";\\n        \\n        // return the last one we got in the list, which is the longest one.\\n        return list.get(list.size() -1);\\n    }\\n    \\n    \\n    public void dfs(Trie root, int len){ // len is depth of the tree\\n        boolean flag = false;//to mark if we can go to next level\\n        for(Trie r : root.children){\\n            // this the children of this root has a complete word, we go to next level:\\n            if(r != null && r.isWord){\\n                flag = true;\\n                dfs(r, len+1);\\n            }\\n        }\\n        //if root\\'s children have no exsiting word\\n        if(flag == false){\\n            //if it is longer than the current longest word, we put it in the list.\\n            //we do not have to worry about lexicographical order becuase the search naturally follows it.\\n            if(len > maxindex){\\n                maxindex = len;\\n                list.add(root.word);\\n            }\\n        }\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    //build the Trie class\\n    public class Trie{\\n        char val; // the character\\n        Trie[] children; //26 children\\n        boolean isWord; //if it is a word at this point\\n        String word = null; //iif it is a word, we can return this word here.\\n        public Trie(){\\n            isWord = false;\\n            children = new Trie[26];\\n            word = null;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 715093,
                "title": "beginner-friendly-brute-force-by-checking-prefixes",
                "content": "```\\nclass Solution {\\npublic:\\n    /*\\n        Runtime: 220 ms, faster than 22.26% of C++ online submissions for Longest Word in Dictionary.\\n\\t\\tMemory Usage: 30.8 MB, less than 42.23% of C++ online submissions for Longest Word in Dictionary.\\n    */\\n    string longestWord(vector<string>& words) {\\n        string result = \"\";;\\n        unordered_set<string> uset(words.begin(), words.end());\\n        for(const auto &word : words) {\\n            bool isCanBeBuilt = true;\\n            for(int i = 1; i <= word.length(); i++) {\\n                string str = word.substr(0, i);\\n                if(uset.find(str) == uset.end()){\\n                    isCanBeBuilt = false;\\n                    break;\\n                }\\n            }\\n            \\n            if(isCanBeBuilt) {\\n                if(word.length() > result.length()) {\\n                    result = word;\\n                }else if(word.length() == result.length() && word < result)\\n                    result = word;  \\n            }\\n        }\\n        \\n        return result != \"\" ? result : \"\";\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    /*\\n        Runtime: 220 ms, faster than 22.26% of C++ online submissions for Longest Word in Dictionary.\\n\\t\\tMemory Usage: 30.8 MB, less than 42.23% of C++ online submissions for Longest Word in Dictionary.\\n    */\\n    string longestWord(vector<string>& words) {\\n        string result = \"\";;\\n        unordered_set<string> uset(words.begin(), words.end());\\n        for(const auto &word : words) {\\n            bool isCanBeBuilt = true;\\n            for(int i = 1; i <= word.length(); i++) {\\n                string str = word.substr(0, i);\\n                if(uset.find(str) == uset.end()){\\n                    isCanBeBuilt = false;\\n                    break;\\n                }\\n            }\\n            \\n            if(isCanBeBuilt) {\\n                if(word.length() > result.length()) {\\n                    result = word;\\n                }else if(word.length() == result.length() && word < result)\\n                    result = word;  \\n            }\\n        }\\n        \\n        return result != \"\" ? result : \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 713197,
                "title": "c-trie-bfs",
                "content": "```csharp\\npublic class Solution \\n{\\n    public class TrieNode\\n    {\\n        public TrieNode[] Children = new TrieNode[26];\\n        public bool IsWord;\\n        public string Word;\\n    }\\n    \\n    public string LongestWord(string[] words) \\n    {\\n        TrieNode root = new TrieNode(){ IsWord = true, Word = string.Empty};\\n        \\n        foreach(var word in words)\\n        {\\n            TrieNode node = root;\\n            foreach(char c in word)\\n            {\\n                int index = c - \\'a\\';\\n                \\n                if(node.Children[index] == null)\\n                {\\n                    node.Children[index] = new TrieNode();\\n                }\\n                \\n                node = node.Children[index];                \\n            }\\n            \\n            node.IsWord = true;\\n            node.Word = word;\\n        }\\n        \\n        string result = String.Empty;\\n        Queue<TrieNode> queue = new Queue<TrieNode>();\\n        queue.Enqueue(root);\\n        \\n        while(queue.Count > 0)\\n        {\\n            var node = queue.Dequeue();\\n            if(node.IsWord)\\n            {\\n                if(node.Word.Length > result.Length)\\n                {\\n                    result = node.Word;\\n                }\\n                \\n                for(int i = 0; i < 26; i++)\\n                {\\n                    if(node.Children[i] != null)\\n                    {\\n                        queue.Enqueue(node.Children[i]);\\n                    }\\n                }\\n            }            \\n        }\\n        \\n        return result;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```csharp\\npublic class Solution \\n{\\n    public class TrieNode\\n    {\\n        public TrieNode[] Children = new TrieNode[26];\\n        public bool IsWord;\\n        public string Word;\\n    }\\n    \\n    public string LongestWord(string[] words) \\n    {\\n        TrieNode root = new TrieNode(){ IsWord = true, Word = string.Empty};\\n        \\n        foreach(var word in words)\\n        {\\n            TrieNode node = root;\\n            foreach(char c in word)\\n            {\\n                int index = c - \\'a\\';\\n                \\n                if(node.Children[index] == null)\\n                {\\n                    node.Children[index] = new TrieNode();\\n                }\\n                \\n                node = node.Children[index];                \\n            }\\n            \\n            node.IsWord = true;\\n            node.Word = word;\\n        }\\n        \\n        string result = String.Empty;\\n        Queue<TrieNode> queue = new Queue<TrieNode>();\\n        queue.Enqueue(root);\\n        \\n        while(queue.Count > 0)\\n        {\\n            var node = queue.Dequeue();\\n            if(node.IsWord)\\n            {\\n                if(node.Word.Length > result.Length)\\n                {\\n                    result = node.Word;\\n                }\\n                \\n                for(int i = 0; i < 26; i++)\\n                {\\n                    if(node.Children[i] != null)\\n                    {\\n                        queue.Enqueue(node.Children[i]);\\n                    }\\n                }\\n            }            \\n        }\\n        \\n        return result;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 699231,
                "title": "javascript-sort-reduce-set-89-faster",
                "content": "suffice to sort by word length(though I didn\\'t bother)\\n```javascript\\nconst longestWord = words =>\\n  words.sort().reduce(\\n    ({ result, seen }, word, idx, arr) => {\\n      if (seen.has(word.substring(0, word.length - 1))) {\\n        seen.add(word)\\n        if (word.length > result.length) result = word\\n      }\\n      return { result, seen }\\n    },\\n    { result: \\'\\', seen: new Set([\\'\\']) }\\n  ).result\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nconst longestWord = words =>\\n  words.sort().reduce(\\n    ({ result, seen }, word, idx, arr) => {\\n      if (seen.has(word.substring(0, word.length - 1))) {\\n        seen.add(word)\\n        if (word.length > result.length) result = word\\n      }\\n      return { result, seen }\\n    },\\n    { result: \\'\\', seen: new Set([\\'\\']) }\\n  ).result\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 690664,
                "title": "java-simple-solution",
                "content": "```\\n    public String longestWord(String[] words) {\\n        Arrays.sort(words);\\n        Map<String,Integer> map = new HashMap<>();\\n        map.put(\"\",0);\\n        for (String str: words ) {\\n            map.put(str,str.length());\\n        }        \\n        StringBuilder sb = new StringBuilder();\\n        int maxLength = Integer.MIN_VALUE;\\n        for (String str: words) {\\n            if(map.containsKey(str.substring(0,str.length()-1))){\\n                if(str.length() > maxLength){\\n                    maxLength = str.length();\\n                    sb.setLength(0);\\n                    sb.append(str);\\n                }\\n            }\\n            else{\\n                map.remove(str);\\n            }\\n        }\\n    return sb.toString();",
                "solutionTags": [],
                "code": "```\\n    public String longestWord(String[] words) {\\n        Arrays.sort(words);\\n        Map<String,Integer> map = new HashMap<>();\\n        map.put(\"\",0);\\n        for (String str: words ) {\\n            map.put(str,str.length());\\n        }        \\n        StringBuilder sb = new StringBuilder();\\n        int maxLength = Integer.MIN_VALUE;\\n        for (String str: words) {\\n            if(map.containsKey(str.substring(0,str.length()-1))){\\n                if(str.length() > maxLength){\\n                    maxLength = str.length();\\n                    sb.setLength(0);\\n                    sb.append(str);\\n                }\\n            }\\n            else{\\n                map.remove(str);\\n            }\\n        }\\n    return sb.toString();",
                "codeTag": "Unknown"
            },
            {
                "id": 665748,
                "title": "java-trie",
                "content": "```\\nclass Solution {\\n    TrieNode root = new TrieNode(\\' \\');\\n    String result = \"\";\\n    public String longestWord(String[] words) {\\n        for(String word:words) insert(word);\\n        for(String word:words) \\n            if(search(word))\\n                if(word.length()>result.length()|| word.length() == result.length() && word.compareTo(result)<0) result = word;\\n        return result;\\n    }\\n    \\n    private void insert(String word) {\\n        TrieNode currentNode = root;\\n        for(int i=0;i<word.length();i++) {\\n            if (currentNode.children.get(word.charAt(i)) == null) {\\n                currentNode.children.put(word.charAt(i), new TrieNode(word.charAt(i)));\\n            }\\n            currentNode = currentNode.children.get(word.charAt(i));\\n        }\\n        currentNode.isEndOfWord = true;\\n    }\\n    \\n    private boolean search(String word) {\\n        TrieNode currentNode = root;\\n        for(int i=0;i<word.length();i++) {\\n            currentNode = currentNode.children.get(word.charAt(i));\\n            if (currentNode == null || !currentNode.isEndOfWord) return false;\\n        }\\n        return currentNode.isEndOfWord;\\n    }\\n}\\nclass TrieNode {\\n    char ch;\\n    Map<Character, TrieNode> children;\\n    boolean isEndOfWord;\\n    \\n    public TrieNode(char ch) {\\n        this.ch = ch;\\n        children = new HashMap<>();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    TrieNode root = new TrieNode(\\' \\');\\n    String result = \"\";\\n    public String longestWord(String[] words) {\\n        for(String word:words) insert(word);\\n        for(String word:words) \\n            if(search(word))\\n                if(word.length()>result.length()|| word.length() == result.length() && word.compareTo(result)<0) result = word;\\n        return result;\\n    }\\n    \\n    private void insert(String word) {\\n        TrieNode currentNode = root;\\n        for(int i=0;i<word.length();i++) {\\n            if (currentNode.children.get(word.charAt(i)) == null) {\\n                currentNode.children.put(word.charAt(i), new TrieNode(word.charAt(i)));\\n            }\\n            currentNode = currentNode.children.get(word.charAt(i));\\n        }\\n        currentNode.isEndOfWord = true;\\n    }\\n    \\n    private boolean search(String word) {\\n        TrieNode currentNode = root;\\n        for(int i=0;i<word.length();i++) {\\n            currentNode = currentNode.children.get(word.charAt(i));\\n            if (currentNode == null || !currentNode.isEndOfWord) return false;\\n        }\\n        return currentNode.isEndOfWord;\\n    }\\n}\\nclass TrieNode {\\n    char ch;\\n    Map<Character, TrieNode> children;\\n    boolean isEndOfWord;\\n    \\n    public TrieNode(char ch) {\\n        this.ch = ch;\\n        children = new HashMap<>();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 631504,
                "title": "python-trie-without-using-node",
                "content": "```python\\nclass Solution:\\n    def longestWord(self, words):\\n        self.trie = {}\\n        \\n        def insert(word):\\n            now = self.trie\\n            for c in word:\\n                if c not in now: now[c] = {\\'#\\': False}\\n                now = now[c]\\n            now[\\'#\\'] = True\\n        \\n        def search(word):\\n            now = self.trie\\n            for c in word:\\n                if \\'#\\' in now and not now[\\'#\\']: return False\\n                now = now[c]\\n            return now[\\'#\\']\\n        \\n        for word in words:\\n            insert(word)\\n        \\n        ans = \"\"\\n        for word in words:\\n            if (search(word) and (len(word) > len(ans) or (len(word) == len(ans) and word < ans))):\\n                ans = word\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def longestWord(self, words):\\n        self.trie = {}\\n        \\n        def insert(word):\\n            now = self.trie\\n            for c in word:\\n                if c not in now: now[c] = {\\'#\\': False}\\n                now = now[c]\\n            now[\\'#\\'] = True\\n        \\n        def search(word):\\n            now = self.trie\\n            for c in word:\\n                if \\'#\\' in now and not now[\\'#\\']: return False\\n                now = now[c]\\n            return now[\\'#\\']\\n        \\n        for word in words:\\n            insert(word)\\n        \\n        ans = \"\"\\n        for word in words:\\n            if (search(word) and (len(word) > len(ans) or (len(word) == len(ans) and word < ans))):\\n                ans = word\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 578058,
                "title": "java-trie-original-with-comments",
                "content": "```\\nclass TrieNode {\\n    \\n    public char ltr;\\n    public Boolean isWord = false;\\n    public TrieNode[] children;\\n    \\n    public TrieNode() {\\n    }\\n    \\n    TrieNode(char c) {\\n        children = new TrieNode[26];\\n        ltr = c;\\n    }\\n}\\n\\nclass Solution {\\n    \\n    public TrieNode root;\\n    public String match;\\n    \\n    public String longestWord(String[] words) {\\n        // let\\'s find the length of the longest character, then let\\'s insert words progressively starting at length 1\\n        if (words.length == 0) return \"\";\\n        \\n        root = new TrieNode(\\' \\');\\n        \\n        int longest = 0;\\n        // let\\'s also insert the smallest words\\n        for (int i = 0; i < words.length; i++) {\\n            if (words[i].length() == 1) {\\n                insert(words[i]);\\n                \\n                // if first match - insert, otherwise check lexi order\\n                if (match == null) {\\n                    match = words[i];\\n                } else if (lexi(words[i], match) == true) {\\n                    match = words[i];\\n                }\\n            }\\n            \\n            longest = Math.max(words[i].length(), longest);\\n        }\\n        \\n        // let\\'s insert the rest in order, if they have a prefix\\n        for (int i = 2; i <= longest; i++) {\\n            for (int j = 0; j < words.length; j++) {\\n                if (words[j].length() == i && isPrefix(words[j])) {\\n                    // insert(words[j]); -- insert directly from the prefix check for speed optimization\\n                    \\n                    // compare match by going letter by letter -- check size first\\n                    if (match.length() < words[j].length()) {\\n                        match = words[j];\\n                    } else if (lexi(words[j], match) == true) {\\n                        match = words[j];\\n                    }\\n                }\\n            }\\n        }\\n        \\n            \\n        return match;\\n    }\\n    \\n    public void insert(String word) {\\n        \\n        TrieNode ws = root;\\n        \\n        for (int i = 0; i < word.length(); i++) {\\n            char currLtr = word.charAt(i);\\n            if (currLtr != ws.ltr) {\\n                TrieNode tmp = new TrieNode(currLtr);\\n                ws.children[currLtr - \\'a\\'] = tmp; // add the next node\\n            }\\n            ws = ws.children[currLtr - \\'a\\']; // advance the root to the next character\\n        }\\n        \\n        ws.isWord = true; // mark as a complete word\\n    }\\n    \\n    public Boolean isPrefix(String word) {\\n        \\n        TrieNode ws = root;\\n        \\n        // go one less characters!\\n        for (int i = 0; i < word.length() - 1; i++) {\\n            char currLtr = word.charAt(i);\\n            if (ws.children[currLtr - \\'a\\'] == null) {\\n                return false;\\n            }\\n            \\n            ws = ws.children[currLtr - \\'a\\']; // advance the root to the next character\\n        }\\n        \\n        quickInsert(ws, word);\\n        \\n        return true;\\n    }\\n    \\n    public void quickInsert(TrieNode ws, String word) {\\n        // let\\'s insert directly from here!\\n        char lastLtr = word.charAt(word.length() - 1);\\n        ws.children[lastLtr - \\'a\\'] = new TrieNode(lastLtr);\\n    }\\n    \\n    // true indicates it\\'s in better order\\n    public Boolean lexi(String s1, String s2) {\\n        for (int i = 0; i < s1.length(); i++) {\\n            if (s1.charAt(i) < s2.charAt(i)) {\\n                return true;\\n            } else if (s1.charAt(i) > s2.charAt(i)) {\\n                return false;\\n            }\\n        }\\n        \\n        // same word!\\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "class Solution {\\n    \\n    public TrieNode root;\\n    public String match;\\n    \\n    public String longestWord(String[] words) {\\n        // let\\'s find the length of the longest character, then let\\'s insert words progressively starting at length 1\\n        if (words.length == 0) return \"\";\\n        \\n        root = new TrieNode(\\' \\');\\n        \\n        int longest = 0;\\n        // let\\'s also insert the smallest words\\n        for (int i = 0; i < words.length; i++) {\\n            if (words[i].length() == 1) {\\n                insert(words[i]);\\n                \\n                // if first match - insert, otherwise check lexi order\\n                if (match == null) {\\n                    match = words[i];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 553304,
                "title": "javascript-trie-human-readable-solution-with-explanation",
                "content": "I came to this question from the Trie tag so I didn\\'t even think about ideas of set or anything. \\nI found out using set is much easier for this question. If using Trie, it will be trivial and at least Medium difficulty (spent me one hour).\\n```\\nvar longestWord = function(words) {\\n    const trie = {};\\n    const insert = (str) => {\\n        let node = trie, count = 0;\\n        for(const s of str) {\\n            if(!node[s]) node[s] = {};\\n            node = node[s];\\n        }\\n        node[\\'end\\'] = true;\\n    }\\n\\t// get the trie ready\\n    words.forEach(w => insert(w));\\n    let res = \\'\\';\\n\\t// finding out if the word can be built letter by letter from others words in the array, if yes, return the length;\\n    const search = (str) => {\\n        let node = trie[str[0]], count = 0;\\n\\t\\t// here must start from 1 because the trie\\'s root will not have a filed call \\'end\\'\\n        for(let i = 1; i < str.length; i++) {\\n\\t\\t// break if finding out that the word cannot built from letter to letter, return 0 since it must be smaller than the one letter \\'word\\' in the array \\n            if(!node.end) return 0;\\n            count++;\\n            node = node[str[i]];\\n        }\\n        return count + 1;\\n    }\\n    let max = 0;\\n    words.forEach(w => {\\n        const count = search(w);\\n\\t\\t// compare and find out the longest\\n        if(count === max) {\\n            res = res > w ? w : res;\\n        } else if(count > max) {\\n            res = w;\\n            max = count;\\n        }\\n    });\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Trie"
                ],
                "code": "```\\nvar longestWord = function(words) {\\n    const trie = {};\\n    const insert = (str) => {\\n        let node = trie, count = 0;\\n        for(const s of str) {\\n            if(!node[s]) node[s] = {};\\n            node = node[s];\\n        }\\n        node[\\'end\\'] = true;\\n    }\\n\\t// get the trie ready\\n    words.forEach(w => insert(w));\\n    let res = \\'\\';\\n\\t// finding out if the word can be built letter by letter from others words in the array, if yes, return the length;\\n    const search = (str) => {\\n        let node = trie[str[0]], count = 0;\\n\\t\\t// here must start from 1 because the trie\\'s root will not have a filed call \\'end\\'\\n        for(let i = 1; i < str.length; i++) {\\n\\t\\t// break if finding out that the word cannot built from letter to letter, return 0 since it must be smaller than the one letter \\'word\\' in the array \\n            if(!node.end) return 0;\\n            count++;\\n            node = node[str[i]];\\n        }\\n        return count + 1;\\n    }\\n    let max = 0;\\n    words.forEach(w => {\\n        const count = search(w);\\n\\t\\t// compare and find out the longest\\n        if(count === max) {\\n            res = res > w ? w : res;\\n        } else if(count > max) {\\n            res = w;\\n            max = count;\\n        }\\n    });\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 537661,
                "title": "python-no-global-sort-elegant-solution",
                "content": "```\\nfrom collections import defaultdict\\n\\n\\nclass Solution(object):\\n    CHARS = \\'abcdefghijklmnopqrstuvwxyz\\'\\n    def longestWord(self, words):\\n        mp = defaultdict(set)\\n        \\n        longest_length = 0\\n        for w in words:\\n            mp[len(w)].add(w)\\n            longest_length = max(longest_length, len(w))\\n        \\n        word_with_len = set()\\n        for i in range(1, longest_length+2):\\n            if not mp[i]:\\n                if not word_with_len:\\n                    return \"\"\\n                return sorted(list(word_with_len))[0]\\n\\n            if i == 1:\\n                word_with_len = mp[i]\\n            else:\\n                nxt_word_with_len = set()\\n\\n                for w in word_with_len:\\n                    for c in self.CHARS:\\n                        new_w = w + c\\n                        if new_w in mp[i]:\\n                            nxt_word_with_len.add(new_w)\\n                \\n                if not nxt_word_with_len:      \\n                    if not word_with_len:\\n                        return \"\"\\n                    return sorted(list(word_with_len))[0]\\n                \\n                word_with_len = nxt_word_with_len\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\n\\n\\nclass Solution(object):\\n    CHARS = \\'abcdefghijklmnopqrstuvwxyz\\'\\n    def longestWord(self, words):\\n        mp = defaultdict(set)\\n        \\n        longest_length = 0\\n        for w in words:\\n            mp[len(w)].add(w)\\n            longest_length = max(longest_length, len(w))\\n        \\n        word_with_len = set()\\n        for i in range(1, longest_length+2):\\n            if not mp[i]:\\n                if not word_with_len:\\n                    return \"\"\\n                return sorted(list(word_with_len))[0]\\n\\n            if i == 1:\\n                word_with_len = mp[i]\\n            else:\\n                nxt_word_with_len = set()\\n\\n                for w in word_with_len:\\n                    for c in self.CHARS:\\n                        new_w = w + c\\n                        if new_w in mp[i]:\\n                            nxt_word_with_len.add(new_w)\\n                \\n                if not nxt_word_with_len:      \\n                    if not word_with_len:\\n                        return \"\"\\n                    return sorted(list(word_with_len))[0]\\n                \\n                word_with_len = nxt_word_with_len\\n```",
                "codeTag": "Java"
            },
            {
                "id": 533566,
                "title": "ruby-50ms-11mb",
                "content": "Let me know if you find rooms for improvemenst + error on run-time/space analysis!\\n\\nRun-time: O(n(log(n))\\nSpace: O(n)\\n\\n```\\ndef longest_word(words)\\n  words.sort!\\n  \\n  memo = {}\\n  candidate = \"\"\\n\\n  words.each do |word|\\n    if word.length == 1 || memo[word[0..-2]]\\n      memo[word] = true\\n      candidate = word if word.length > candidate.length\\n    end\\n  end\\n  \\n  candidate\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef longest_word(words)\\n  words.sort!\\n  \\n  memo = {}\\n  candidate = \"\"\\n\\n  words.each do |word|\\n    if word.length == 1 || memo[word[0..-2]]\\n      memo[word] = true\\n      candidate = word if word.length > candidate.length\\n    end\\n  end\\n  \\n  candidate\\nend\\n```",
                "codeTag": "Python3"
            }
        ],
        "discussions": [
            {
                "id": 1565388,
                "content": [
                    {
                        "username": "ChristoPalas",
                        "content": "How can this testcase be correct?\\nInput\\n[\"yo\",\"ew\",\"fc\",\"zrc\",\"yodn\",\"fcm\",\"qm\",\"qmo\",\"fcmz\",\"z\",\"ewq\",\"yod\",\"ewqz\",\"y\"]\\nOutput\\n\"ewqz\"\\nExpected\\n\"yodn\"\\n\\n\"ewqz\" can be built from \"ewq\" and is the same length with \"yodn\" but lexicographically smaller than it."
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@ChristoPalas](/ChristoPalas) for word \"ewqz\", \\'e\\' is not present in word array so that cannot be the answer whereas in case of \"yodn\", each of \\'yodn\\', \\'yod\\', \\'yo\\' and \\'y\\' are present so the correct answer is \"yodn\" for this testcase. Hope its clear."
                    },
                    {
                        "username": "iChuan",
                        "content": "Totally lost myself in this description. Thank you!"
                    },
                    {
                        "username": "vmk1802",
                        "content": "Can anyone explain why this answer is wrong?\\n\\n## Input:\\n[\"yo\",\"ew\",\"fc\",\"zrc\",\"yodn\",\"fcm\",\"qm\",\"qmo\",\"fcmz\",\"z\",\"ewq\",\"yod\",\"ewqz\",\"y\"]\\n\\n## Output:\\n\"ewqz\"\\n\\n## Expected:\\n\"yodn\"\\n\\nProblem clearly states, \" ***If there is more than one possible answer, return the longest word with the smallest lexicographical order.*** \"\\nLexicographically \\'e\\' is smaller than \\'y\\'. Both \"ewqz\" & \"yodn\" are same length. So my expectation is \"ewqz\" should be the answer.\\n\\nAm I missing something? ;-/"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@AdityaShaw](/AdityaShaw)  I believe you are incorrect. I think the reason ewqz is not correct is that it cannot be traced back to a single character. In other words, there is no \\'e\\' in the array so it is a non-starter. Your explanantion would also work, because you would always pick the word that can be traced back to a single charter if there is one. But ewqz would also not be the right answer if yodn wasn\\'t an option."
                    },
                    {
                        "username": "AdityaShaw",
                        "content": "\"y\"=>\"yo\"=>\"yod\"=>\"yodn\"\\n\"ew\"=>\"ewq\"=>\"ewqz\"\\nThe length of words that leads to the formation of the word \"yodn\" is greater compared to \"ewqz\". Hence, that turn out to be the preferred solution."
                    },
                    {
                        "username": "vfvf4002",
                        "content": "In the question description, it is stated that we have to make the words one character at a time.\\nSo given an array:\\n[\"o\", \"or\", \"wor\", \"worl\", \"world\"],\\nwe should be able to make the word \"world\". But, the answer of this comes out to be \"or\" as they are considering only cases wherein the previous word is a prefix of the fiven word."
                    },
                    {
                        "username": "parameterNextNaive",
                        "content": "For people who are not able to understand this question, read this: https://leetcode.com/problems/longest-word-with-all-prefixes/description/.\\n\\nThey are exactly same questions with different wording."
                    },
                    {
                        "username": "jinlibao",
                        "content": "According to the description, \"find the longest word in words that can be built one character at a time by other words in words\", technically, `[\"d\", \"ld\", \"rld\", \"orld\", \"world\"]` also works as `[\"w\",\"wo\",\"wor\",\"worl\", \"world\"]`, right? But according to the output of \"Run Code\", it is not. :("
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Note that the word should be built from left to right with each additional character being added to the end of a previous word. "
                    },
                    {
                        "username": "learnSomeCode",
                        "content": "can some one explain why the solution to this test case is \"eyj\" instead of \"eyjuoi\"?\\n[\"ogz\",\"eyj\",\"e\",\"ey\",\"hmn\",\"v\",\"hm\",\"ogznkb\",\"ogzn\",\"hmnm\",\"eyjuo\",\"vuq\",\"ogznk\",\"og\",\"eyjuoi\",\"d\"]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@drc354](/drc354) A bit late, but you cannot start at \\'og\\', you have to start at \\'o\\', and there is no \\'o\\' in the dictionary"
                    },
                    {
                        "username": "drc354",
                        "content": "[@Mister_CK](/Mister_CK) Why would the answer not be ogznkb considering that in the test case, there are og -> ogz -> ogzn -> ognzk -> ognzkb"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "\\'eyju\\' is not part of the array if I see correctly, so you can never get to eyjuoi "
                    },
                    {
                        "username": "pansari",
                        "content": "[\"wo\",\"wor\",\"worl\",\"world\"]\\nMy answer = \"world\"\\nAnswer by OJ = \"\"\\nThis can be ``` built one character at a time by other words in words.```"
                    },
                    {
                        "username": "kaxagvimraze",
                        "content": "can anyone help because my code works but fails on last test case (59/59) where there is no input and i got time limit exceeded, so is there a big input and I have a problem with algorithm or i may check existence if an input?"
                    },
                    {
                        "username": "refleks1a",
                        "content": "input:\\n[\"yo\",\"ew\",\"fc\",\"zrc\",\"yodn\",\"fcm\",\"qm\",\"qmo\",\"fcmz\",\"z\",\"ewq\",\"yod\",\"ewqz\",\"y\"]\\noutput:\\n\"fcmz\"\\nexpected:\\n\"yodn\"\\n\\n\"fcmz\" is lexicographically smaller than \"yodn\" but the correct answer is \"yodn\".\\nWHY?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don\\'t see an \\'f\\' in the dictionary, so how can you form \\'fcmz\\'?\\n\\nGiven an array of strings words representing an English Dictionary, return the longest word in words that can be built one character at a time by other words in words."
                    }
                ]
            },
            {
                "id": 1569291,
                "content": [
                    {
                        "username": "ChristoPalas",
                        "content": "How can this testcase be correct?\\nInput\\n[\"yo\",\"ew\",\"fc\",\"zrc\",\"yodn\",\"fcm\",\"qm\",\"qmo\",\"fcmz\",\"z\",\"ewq\",\"yod\",\"ewqz\",\"y\"]\\nOutput\\n\"ewqz\"\\nExpected\\n\"yodn\"\\n\\n\"ewqz\" can be built from \"ewq\" and is the same length with \"yodn\" but lexicographically smaller than it."
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@ChristoPalas](/ChristoPalas) for word \"ewqz\", \\'e\\' is not present in word array so that cannot be the answer whereas in case of \"yodn\", each of \\'yodn\\', \\'yod\\', \\'yo\\' and \\'y\\' are present so the correct answer is \"yodn\" for this testcase. Hope its clear."
                    },
                    {
                        "username": "iChuan",
                        "content": "Totally lost myself in this description. Thank you!"
                    },
                    {
                        "username": "vmk1802",
                        "content": "Can anyone explain why this answer is wrong?\\n\\n## Input:\\n[\"yo\",\"ew\",\"fc\",\"zrc\",\"yodn\",\"fcm\",\"qm\",\"qmo\",\"fcmz\",\"z\",\"ewq\",\"yod\",\"ewqz\",\"y\"]\\n\\n## Output:\\n\"ewqz\"\\n\\n## Expected:\\n\"yodn\"\\n\\nProblem clearly states, \" ***If there is more than one possible answer, return the longest word with the smallest lexicographical order.*** \"\\nLexicographically \\'e\\' is smaller than \\'y\\'. Both \"ewqz\" & \"yodn\" are same length. So my expectation is \"ewqz\" should be the answer.\\n\\nAm I missing something? ;-/"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@AdityaShaw](/AdityaShaw)  I believe you are incorrect. I think the reason ewqz is not correct is that it cannot be traced back to a single character. In other words, there is no \\'e\\' in the array so it is a non-starter. Your explanantion would also work, because you would always pick the word that can be traced back to a single charter if there is one. But ewqz would also not be the right answer if yodn wasn\\'t an option."
                    },
                    {
                        "username": "AdityaShaw",
                        "content": "\"y\"=>\"yo\"=>\"yod\"=>\"yodn\"\\n\"ew\"=>\"ewq\"=>\"ewqz\"\\nThe length of words that leads to the formation of the word \"yodn\" is greater compared to \"ewqz\". Hence, that turn out to be the preferred solution."
                    },
                    {
                        "username": "vfvf4002",
                        "content": "In the question description, it is stated that we have to make the words one character at a time.\\nSo given an array:\\n[\"o\", \"or\", \"wor\", \"worl\", \"world\"],\\nwe should be able to make the word \"world\". But, the answer of this comes out to be \"or\" as they are considering only cases wherein the previous word is a prefix of the fiven word."
                    },
                    {
                        "username": "parameterNextNaive",
                        "content": "For people who are not able to understand this question, read this: https://leetcode.com/problems/longest-word-with-all-prefixes/description/.\\n\\nThey are exactly same questions with different wording."
                    },
                    {
                        "username": "jinlibao",
                        "content": "According to the description, \"find the longest word in words that can be built one character at a time by other words in words\", technically, `[\"d\", \"ld\", \"rld\", \"orld\", \"world\"]` also works as `[\"w\",\"wo\",\"wor\",\"worl\", \"world\"]`, right? But according to the output of \"Run Code\", it is not. :("
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Note that the word should be built from left to right with each additional character being added to the end of a previous word. "
                    },
                    {
                        "username": "learnSomeCode",
                        "content": "can some one explain why the solution to this test case is \"eyj\" instead of \"eyjuoi\"?\\n[\"ogz\",\"eyj\",\"e\",\"ey\",\"hmn\",\"v\",\"hm\",\"ogznkb\",\"ogzn\",\"hmnm\",\"eyjuo\",\"vuq\",\"ogznk\",\"og\",\"eyjuoi\",\"d\"]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@drc354](/drc354) A bit late, but you cannot start at \\'og\\', you have to start at \\'o\\', and there is no \\'o\\' in the dictionary"
                    },
                    {
                        "username": "drc354",
                        "content": "[@Mister_CK](/Mister_CK) Why would the answer not be ogznkb considering that in the test case, there are og -> ogz -> ogzn -> ognzk -> ognzkb"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "\\'eyju\\' is not part of the array if I see correctly, so you can never get to eyjuoi "
                    },
                    {
                        "username": "pansari",
                        "content": "[\"wo\",\"wor\",\"worl\",\"world\"]\\nMy answer = \"world\"\\nAnswer by OJ = \"\"\\nThis can be ``` built one character at a time by other words in words.```"
                    },
                    {
                        "username": "kaxagvimraze",
                        "content": "can anyone help because my code works but fails on last test case (59/59) where there is no input and i got time limit exceeded, so is there a big input and I have a problem with algorithm or i may check existence if an input?"
                    },
                    {
                        "username": "refleks1a",
                        "content": "input:\\n[\"yo\",\"ew\",\"fc\",\"zrc\",\"yodn\",\"fcm\",\"qm\",\"qmo\",\"fcmz\",\"z\",\"ewq\",\"yod\",\"ewqz\",\"y\"]\\noutput:\\n\"fcmz\"\\nexpected:\\n\"yodn\"\\n\\n\"fcmz\" is lexicographically smaller than \"yodn\" but the correct answer is \"yodn\".\\nWHY?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don\\'t see an \\'f\\' in the dictionary, so how can you form \\'fcmz\\'?\\n\\nGiven an array of strings words representing an English Dictionary, return the longest word in words that can be built one character at a time by other words in words."
                    }
                ]
            },
            {
                "id": 1570265,
                "content": [
                    {
                        "username": "ChristoPalas",
                        "content": "How can this testcase be correct?\\nInput\\n[\"yo\",\"ew\",\"fc\",\"zrc\",\"yodn\",\"fcm\",\"qm\",\"qmo\",\"fcmz\",\"z\",\"ewq\",\"yod\",\"ewqz\",\"y\"]\\nOutput\\n\"ewqz\"\\nExpected\\n\"yodn\"\\n\\n\"ewqz\" can be built from \"ewq\" and is the same length with \"yodn\" but lexicographically smaller than it."
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@ChristoPalas](/ChristoPalas) for word \"ewqz\", \\'e\\' is not present in word array so that cannot be the answer whereas in case of \"yodn\", each of \\'yodn\\', \\'yod\\', \\'yo\\' and \\'y\\' are present so the correct answer is \"yodn\" for this testcase. Hope its clear."
                    },
                    {
                        "username": "iChuan",
                        "content": "Totally lost myself in this description. Thank you!"
                    },
                    {
                        "username": "vmk1802",
                        "content": "Can anyone explain why this answer is wrong?\\n\\n## Input:\\n[\"yo\",\"ew\",\"fc\",\"zrc\",\"yodn\",\"fcm\",\"qm\",\"qmo\",\"fcmz\",\"z\",\"ewq\",\"yod\",\"ewqz\",\"y\"]\\n\\n## Output:\\n\"ewqz\"\\n\\n## Expected:\\n\"yodn\"\\n\\nProblem clearly states, \" ***If there is more than one possible answer, return the longest word with the smallest lexicographical order.*** \"\\nLexicographically \\'e\\' is smaller than \\'y\\'. Both \"ewqz\" & \"yodn\" are same length. So my expectation is \"ewqz\" should be the answer.\\n\\nAm I missing something? ;-/"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@AdityaShaw](/AdityaShaw)  I believe you are incorrect. I think the reason ewqz is not correct is that it cannot be traced back to a single character. In other words, there is no \\'e\\' in the array so it is a non-starter. Your explanantion would also work, because you would always pick the word that can be traced back to a single charter if there is one. But ewqz would also not be the right answer if yodn wasn\\'t an option."
                    },
                    {
                        "username": "AdityaShaw",
                        "content": "\"y\"=>\"yo\"=>\"yod\"=>\"yodn\"\\n\"ew\"=>\"ewq\"=>\"ewqz\"\\nThe length of words that leads to the formation of the word \"yodn\" is greater compared to \"ewqz\". Hence, that turn out to be the preferred solution."
                    },
                    {
                        "username": "vfvf4002",
                        "content": "In the question description, it is stated that we have to make the words one character at a time.\\nSo given an array:\\n[\"o\", \"or\", \"wor\", \"worl\", \"world\"],\\nwe should be able to make the word \"world\". But, the answer of this comes out to be \"or\" as they are considering only cases wherein the previous word is a prefix of the fiven word."
                    },
                    {
                        "username": "parameterNextNaive",
                        "content": "For people who are not able to understand this question, read this: https://leetcode.com/problems/longest-word-with-all-prefixes/description/.\\n\\nThey are exactly same questions with different wording."
                    },
                    {
                        "username": "jinlibao",
                        "content": "According to the description, \"find the longest word in words that can be built one character at a time by other words in words\", technically, `[\"d\", \"ld\", \"rld\", \"orld\", \"world\"]` also works as `[\"w\",\"wo\",\"wor\",\"worl\", \"world\"]`, right? But according to the output of \"Run Code\", it is not. :("
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Note that the word should be built from left to right with each additional character being added to the end of a previous word. "
                    },
                    {
                        "username": "learnSomeCode",
                        "content": "can some one explain why the solution to this test case is \"eyj\" instead of \"eyjuoi\"?\\n[\"ogz\",\"eyj\",\"e\",\"ey\",\"hmn\",\"v\",\"hm\",\"ogznkb\",\"ogzn\",\"hmnm\",\"eyjuo\",\"vuq\",\"ogznk\",\"og\",\"eyjuoi\",\"d\"]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@drc354](/drc354) A bit late, but you cannot start at \\'og\\', you have to start at \\'o\\', and there is no \\'o\\' in the dictionary"
                    },
                    {
                        "username": "drc354",
                        "content": "[@Mister_CK](/Mister_CK) Why would the answer not be ogznkb considering that in the test case, there are og -> ogz -> ogzn -> ognzk -> ognzkb"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "\\'eyju\\' is not part of the array if I see correctly, so you can never get to eyjuoi "
                    },
                    {
                        "username": "pansari",
                        "content": "[\"wo\",\"wor\",\"worl\",\"world\"]\\nMy answer = \"world\"\\nAnswer by OJ = \"\"\\nThis can be ``` built one character at a time by other words in words.```"
                    },
                    {
                        "username": "kaxagvimraze",
                        "content": "can anyone help because my code works but fails on last test case (59/59) where there is no input and i got time limit exceeded, so is there a big input and I have a problem with algorithm or i may check existence if an input?"
                    },
                    {
                        "username": "refleks1a",
                        "content": "input:\\n[\"yo\",\"ew\",\"fc\",\"zrc\",\"yodn\",\"fcm\",\"qm\",\"qmo\",\"fcmz\",\"z\",\"ewq\",\"yod\",\"ewqz\",\"y\"]\\noutput:\\n\"fcmz\"\\nexpected:\\n\"yodn\"\\n\\n\"fcmz\" is lexicographically smaller than \"yodn\" but the correct answer is \"yodn\".\\nWHY?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don\\'t see an \\'f\\' in the dictionary, so how can you form \\'fcmz\\'?\\n\\nGiven an array of strings words representing an English Dictionary, return the longest word in words that can be built one character at a time by other words in words."
                    }
                ]
            },
            {
                "id": 1576959,
                "content": [
                    {
                        "username": "ChristoPalas",
                        "content": "How can this testcase be correct?\\nInput\\n[\"yo\",\"ew\",\"fc\",\"zrc\",\"yodn\",\"fcm\",\"qm\",\"qmo\",\"fcmz\",\"z\",\"ewq\",\"yod\",\"ewqz\",\"y\"]\\nOutput\\n\"ewqz\"\\nExpected\\n\"yodn\"\\n\\n\"ewqz\" can be built from \"ewq\" and is the same length with \"yodn\" but lexicographically smaller than it."
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@ChristoPalas](/ChristoPalas) for word \"ewqz\", \\'e\\' is not present in word array so that cannot be the answer whereas in case of \"yodn\", each of \\'yodn\\', \\'yod\\', \\'yo\\' and \\'y\\' are present so the correct answer is \"yodn\" for this testcase. Hope its clear."
                    },
                    {
                        "username": "iChuan",
                        "content": "Totally lost myself in this description. Thank you!"
                    },
                    {
                        "username": "vmk1802",
                        "content": "Can anyone explain why this answer is wrong?\\n\\n## Input:\\n[\"yo\",\"ew\",\"fc\",\"zrc\",\"yodn\",\"fcm\",\"qm\",\"qmo\",\"fcmz\",\"z\",\"ewq\",\"yod\",\"ewqz\",\"y\"]\\n\\n## Output:\\n\"ewqz\"\\n\\n## Expected:\\n\"yodn\"\\n\\nProblem clearly states, \" ***If there is more than one possible answer, return the longest word with the smallest lexicographical order.*** \"\\nLexicographically \\'e\\' is smaller than \\'y\\'. Both \"ewqz\" & \"yodn\" are same length. So my expectation is \"ewqz\" should be the answer.\\n\\nAm I missing something? ;-/"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@AdityaShaw](/AdityaShaw)  I believe you are incorrect. I think the reason ewqz is not correct is that it cannot be traced back to a single character. In other words, there is no \\'e\\' in the array so it is a non-starter. Your explanantion would also work, because you would always pick the word that can be traced back to a single charter if there is one. But ewqz would also not be the right answer if yodn wasn\\'t an option."
                    },
                    {
                        "username": "AdityaShaw",
                        "content": "\"y\"=>\"yo\"=>\"yod\"=>\"yodn\"\\n\"ew\"=>\"ewq\"=>\"ewqz\"\\nThe length of words that leads to the formation of the word \"yodn\" is greater compared to \"ewqz\". Hence, that turn out to be the preferred solution."
                    },
                    {
                        "username": "vfvf4002",
                        "content": "In the question description, it is stated that we have to make the words one character at a time.\\nSo given an array:\\n[\"o\", \"or\", \"wor\", \"worl\", \"world\"],\\nwe should be able to make the word \"world\". But, the answer of this comes out to be \"or\" as they are considering only cases wherein the previous word is a prefix of the fiven word."
                    },
                    {
                        "username": "parameterNextNaive",
                        "content": "For people who are not able to understand this question, read this: https://leetcode.com/problems/longest-word-with-all-prefixes/description/.\\n\\nThey are exactly same questions with different wording."
                    },
                    {
                        "username": "jinlibao",
                        "content": "According to the description, \"find the longest word in words that can be built one character at a time by other words in words\", technically, `[\"d\", \"ld\", \"rld\", \"orld\", \"world\"]` also works as `[\"w\",\"wo\",\"wor\",\"worl\", \"world\"]`, right? But according to the output of \"Run Code\", it is not. :("
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Note that the word should be built from left to right with each additional character being added to the end of a previous word. "
                    },
                    {
                        "username": "learnSomeCode",
                        "content": "can some one explain why the solution to this test case is \"eyj\" instead of \"eyjuoi\"?\\n[\"ogz\",\"eyj\",\"e\",\"ey\",\"hmn\",\"v\",\"hm\",\"ogznkb\",\"ogzn\",\"hmnm\",\"eyjuo\",\"vuq\",\"ogznk\",\"og\",\"eyjuoi\",\"d\"]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@drc354](/drc354) A bit late, but you cannot start at \\'og\\', you have to start at \\'o\\', and there is no \\'o\\' in the dictionary"
                    },
                    {
                        "username": "drc354",
                        "content": "[@Mister_CK](/Mister_CK) Why would the answer not be ogznkb considering that in the test case, there are og -> ogz -> ogzn -> ognzk -> ognzkb"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "\\'eyju\\' is not part of the array if I see correctly, so you can never get to eyjuoi "
                    },
                    {
                        "username": "pansari",
                        "content": "[\"wo\",\"wor\",\"worl\",\"world\"]\\nMy answer = \"world\"\\nAnswer by OJ = \"\"\\nThis can be ``` built one character at a time by other words in words.```"
                    },
                    {
                        "username": "kaxagvimraze",
                        "content": "can anyone help because my code works but fails on last test case (59/59) where there is no input and i got time limit exceeded, so is there a big input and I have a problem with algorithm or i may check existence if an input?"
                    },
                    {
                        "username": "refleks1a",
                        "content": "input:\\n[\"yo\",\"ew\",\"fc\",\"zrc\",\"yodn\",\"fcm\",\"qm\",\"qmo\",\"fcmz\",\"z\",\"ewq\",\"yod\",\"ewqz\",\"y\"]\\noutput:\\n\"fcmz\"\\nexpected:\\n\"yodn\"\\n\\n\"fcmz\" is lexicographically smaller than \"yodn\" but the correct answer is \"yodn\".\\nWHY?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don\\'t see an \\'f\\' in the dictionary, so how can you form \\'fcmz\\'?\\n\\nGiven an array of strings words representing an English Dictionary, return the longest word in words that can be built one character at a time by other words in words."
                    }
                ]
            },
            {
                "id": 1760053,
                "content": [
                    {
                        "username": "ChristoPalas",
                        "content": "How can this testcase be correct?\\nInput\\n[\"yo\",\"ew\",\"fc\",\"zrc\",\"yodn\",\"fcm\",\"qm\",\"qmo\",\"fcmz\",\"z\",\"ewq\",\"yod\",\"ewqz\",\"y\"]\\nOutput\\n\"ewqz\"\\nExpected\\n\"yodn\"\\n\\n\"ewqz\" can be built from \"ewq\" and is the same length with \"yodn\" but lexicographically smaller than it."
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@ChristoPalas](/ChristoPalas) for word \"ewqz\", \\'e\\' is not present in word array so that cannot be the answer whereas in case of \"yodn\", each of \\'yodn\\', \\'yod\\', \\'yo\\' and \\'y\\' are present so the correct answer is \"yodn\" for this testcase. Hope its clear."
                    },
                    {
                        "username": "iChuan",
                        "content": "Totally lost myself in this description. Thank you!"
                    },
                    {
                        "username": "vmk1802",
                        "content": "Can anyone explain why this answer is wrong?\\n\\n## Input:\\n[\"yo\",\"ew\",\"fc\",\"zrc\",\"yodn\",\"fcm\",\"qm\",\"qmo\",\"fcmz\",\"z\",\"ewq\",\"yod\",\"ewqz\",\"y\"]\\n\\n## Output:\\n\"ewqz\"\\n\\n## Expected:\\n\"yodn\"\\n\\nProblem clearly states, \" ***If there is more than one possible answer, return the longest word with the smallest lexicographical order.*** \"\\nLexicographically \\'e\\' is smaller than \\'y\\'. Both \"ewqz\" & \"yodn\" are same length. So my expectation is \"ewqz\" should be the answer.\\n\\nAm I missing something? ;-/"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@AdityaShaw](/AdityaShaw)  I believe you are incorrect. I think the reason ewqz is not correct is that it cannot be traced back to a single character. In other words, there is no \\'e\\' in the array so it is a non-starter. Your explanantion would also work, because you would always pick the word that can be traced back to a single charter if there is one. But ewqz would also not be the right answer if yodn wasn\\'t an option."
                    },
                    {
                        "username": "AdityaShaw",
                        "content": "\"y\"=>\"yo\"=>\"yod\"=>\"yodn\"\\n\"ew\"=>\"ewq\"=>\"ewqz\"\\nThe length of words that leads to the formation of the word \"yodn\" is greater compared to \"ewqz\". Hence, that turn out to be the preferred solution."
                    },
                    {
                        "username": "vfvf4002",
                        "content": "In the question description, it is stated that we have to make the words one character at a time.\\nSo given an array:\\n[\"o\", \"or\", \"wor\", \"worl\", \"world\"],\\nwe should be able to make the word \"world\". But, the answer of this comes out to be \"or\" as they are considering only cases wherein the previous word is a prefix of the fiven word."
                    },
                    {
                        "username": "parameterNextNaive",
                        "content": "For people who are not able to understand this question, read this: https://leetcode.com/problems/longest-word-with-all-prefixes/description/.\\n\\nThey are exactly same questions with different wording."
                    },
                    {
                        "username": "jinlibao",
                        "content": "According to the description, \"find the longest word in words that can be built one character at a time by other words in words\", technically, `[\"d\", \"ld\", \"rld\", \"orld\", \"world\"]` also works as `[\"w\",\"wo\",\"wor\",\"worl\", \"world\"]`, right? But according to the output of \"Run Code\", it is not. :("
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Note that the word should be built from left to right with each additional character being added to the end of a previous word. "
                    },
                    {
                        "username": "learnSomeCode",
                        "content": "can some one explain why the solution to this test case is \"eyj\" instead of \"eyjuoi\"?\\n[\"ogz\",\"eyj\",\"e\",\"ey\",\"hmn\",\"v\",\"hm\",\"ogznkb\",\"ogzn\",\"hmnm\",\"eyjuo\",\"vuq\",\"ogznk\",\"og\",\"eyjuoi\",\"d\"]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@drc354](/drc354) A bit late, but you cannot start at \\'og\\', you have to start at \\'o\\', and there is no \\'o\\' in the dictionary"
                    },
                    {
                        "username": "drc354",
                        "content": "[@Mister_CK](/Mister_CK) Why would the answer not be ogznkb considering that in the test case, there are og -> ogz -> ogzn -> ognzk -> ognzkb"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "\\'eyju\\' is not part of the array if I see correctly, so you can never get to eyjuoi "
                    },
                    {
                        "username": "pansari",
                        "content": "[\"wo\",\"wor\",\"worl\",\"world\"]\\nMy answer = \"world\"\\nAnswer by OJ = \"\"\\nThis can be ``` built one character at a time by other words in words.```"
                    },
                    {
                        "username": "kaxagvimraze",
                        "content": "can anyone help because my code works but fails on last test case (59/59) where there is no input and i got time limit exceeded, so is there a big input and I have a problem with algorithm or i may check existence if an input?"
                    },
                    {
                        "username": "refleks1a",
                        "content": "input:\\n[\"yo\",\"ew\",\"fc\",\"zrc\",\"yodn\",\"fcm\",\"qm\",\"qmo\",\"fcmz\",\"z\",\"ewq\",\"yod\",\"ewqz\",\"y\"]\\noutput:\\n\"fcmz\"\\nexpected:\\n\"yodn\"\\n\\n\"fcmz\" is lexicographically smaller than \"yodn\" but the correct answer is \"yodn\".\\nWHY?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don\\'t see an \\'f\\' in the dictionary, so how can you form \\'fcmz\\'?\\n\\nGiven an array of strings words representing an English Dictionary, return the longest word in words that can be built one character at a time by other words in words."
                    }
                ]
            },
            {
                "id": 1572052,
                "content": [
                    {
                        "username": "ChristoPalas",
                        "content": "How can this testcase be correct?\\nInput\\n[\"yo\",\"ew\",\"fc\",\"zrc\",\"yodn\",\"fcm\",\"qm\",\"qmo\",\"fcmz\",\"z\",\"ewq\",\"yod\",\"ewqz\",\"y\"]\\nOutput\\n\"ewqz\"\\nExpected\\n\"yodn\"\\n\\n\"ewqz\" can be built from \"ewq\" and is the same length with \"yodn\" but lexicographically smaller than it."
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@ChristoPalas](/ChristoPalas) for word \"ewqz\", \\'e\\' is not present in word array so that cannot be the answer whereas in case of \"yodn\", each of \\'yodn\\', \\'yod\\', \\'yo\\' and \\'y\\' are present so the correct answer is \"yodn\" for this testcase. Hope its clear."
                    },
                    {
                        "username": "iChuan",
                        "content": "Totally lost myself in this description. Thank you!"
                    },
                    {
                        "username": "vmk1802",
                        "content": "Can anyone explain why this answer is wrong?\\n\\n## Input:\\n[\"yo\",\"ew\",\"fc\",\"zrc\",\"yodn\",\"fcm\",\"qm\",\"qmo\",\"fcmz\",\"z\",\"ewq\",\"yod\",\"ewqz\",\"y\"]\\n\\n## Output:\\n\"ewqz\"\\n\\n## Expected:\\n\"yodn\"\\n\\nProblem clearly states, \" ***If there is more than one possible answer, return the longest word with the smallest lexicographical order.*** \"\\nLexicographically \\'e\\' is smaller than \\'y\\'. Both \"ewqz\" & \"yodn\" are same length. So my expectation is \"ewqz\" should be the answer.\\n\\nAm I missing something? ;-/"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@AdityaShaw](/AdityaShaw)  I believe you are incorrect. I think the reason ewqz is not correct is that it cannot be traced back to a single character. In other words, there is no \\'e\\' in the array so it is a non-starter. Your explanantion would also work, because you would always pick the word that can be traced back to a single charter if there is one. But ewqz would also not be the right answer if yodn wasn\\'t an option."
                    },
                    {
                        "username": "AdityaShaw",
                        "content": "\"y\"=>\"yo\"=>\"yod\"=>\"yodn\"\\n\"ew\"=>\"ewq\"=>\"ewqz\"\\nThe length of words that leads to the formation of the word \"yodn\" is greater compared to \"ewqz\". Hence, that turn out to be the preferred solution."
                    },
                    {
                        "username": "vfvf4002",
                        "content": "In the question description, it is stated that we have to make the words one character at a time.\\nSo given an array:\\n[\"o\", \"or\", \"wor\", \"worl\", \"world\"],\\nwe should be able to make the word \"world\". But, the answer of this comes out to be \"or\" as they are considering only cases wherein the previous word is a prefix of the fiven word."
                    },
                    {
                        "username": "parameterNextNaive",
                        "content": "For people who are not able to understand this question, read this: https://leetcode.com/problems/longest-word-with-all-prefixes/description/.\\n\\nThey are exactly same questions with different wording."
                    },
                    {
                        "username": "jinlibao",
                        "content": "According to the description, \"find the longest word in words that can be built one character at a time by other words in words\", technically, `[\"d\", \"ld\", \"rld\", \"orld\", \"world\"]` also works as `[\"w\",\"wo\",\"wor\",\"worl\", \"world\"]`, right? But according to the output of \"Run Code\", it is not. :("
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Note that the word should be built from left to right with each additional character being added to the end of a previous word. "
                    },
                    {
                        "username": "learnSomeCode",
                        "content": "can some one explain why the solution to this test case is \"eyj\" instead of \"eyjuoi\"?\\n[\"ogz\",\"eyj\",\"e\",\"ey\",\"hmn\",\"v\",\"hm\",\"ogznkb\",\"ogzn\",\"hmnm\",\"eyjuo\",\"vuq\",\"ogznk\",\"og\",\"eyjuoi\",\"d\"]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@drc354](/drc354) A bit late, but you cannot start at \\'og\\', you have to start at \\'o\\', and there is no \\'o\\' in the dictionary"
                    },
                    {
                        "username": "drc354",
                        "content": "[@Mister_CK](/Mister_CK) Why would the answer not be ogznkb considering that in the test case, there are og -> ogz -> ogzn -> ognzk -> ognzkb"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "\\'eyju\\' is not part of the array if I see correctly, so you can never get to eyjuoi "
                    },
                    {
                        "username": "pansari",
                        "content": "[\"wo\",\"wor\",\"worl\",\"world\"]\\nMy answer = \"world\"\\nAnswer by OJ = \"\"\\nThis can be ``` built one character at a time by other words in words.```"
                    },
                    {
                        "username": "kaxagvimraze",
                        "content": "can anyone help because my code works but fails on last test case (59/59) where there is no input and i got time limit exceeded, so is there a big input and I have a problem with algorithm or i may check existence if an input?"
                    },
                    {
                        "username": "refleks1a",
                        "content": "input:\\n[\"yo\",\"ew\",\"fc\",\"zrc\",\"yodn\",\"fcm\",\"qm\",\"qmo\",\"fcmz\",\"z\",\"ewq\",\"yod\",\"ewqz\",\"y\"]\\noutput:\\n\"fcmz\"\\nexpected:\\n\"yodn\"\\n\\n\"fcmz\" is lexicographically smaller than \"yodn\" but the correct answer is \"yodn\".\\nWHY?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don\\'t see an \\'f\\' in the dictionary, so how can you form \\'fcmz\\'?\\n\\nGiven an array of strings words representing an English Dictionary, return the longest word in words that can be built one character at a time by other words in words."
                    }
                ]
            },
            {
                "id": 1571898,
                "content": [
                    {
                        "username": "ChristoPalas",
                        "content": "How can this testcase be correct?\\nInput\\n[\"yo\",\"ew\",\"fc\",\"zrc\",\"yodn\",\"fcm\",\"qm\",\"qmo\",\"fcmz\",\"z\",\"ewq\",\"yod\",\"ewqz\",\"y\"]\\nOutput\\n\"ewqz\"\\nExpected\\n\"yodn\"\\n\\n\"ewqz\" can be built from \"ewq\" and is the same length with \"yodn\" but lexicographically smaller than it."
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@ChristoPalas](/ChristoPalas) for word \"ewqz\", \\'e\\' is not present in word array so that cannot be the answer whereas in case of \"yodn\", each of \\'yodn\\', \\'yod\\', \\'yo\\' and \\'y\\' are present so the correct answer is \"yodn\" for this testcase. Hope its clear."
                    },
                    {
                        "username": "iChuan",
                        "content": "Totally lost myself in this description. Thank you!"
                    },
                    {
                        "username": "vmk1802",
                        "content": "Can anyone explain why this answer is wrong?\\n\\n## Input:\\n[\"yo\",\"ew\",\"fc\",\"zrc\",\"yodn\",\"fcm\",\"qm\",\"qmo\",\"fcmz\",\"z\",\"ewq\",\"yod\",\"ewqz\",\"y\"]\\n\\n## Output:\\n\"ewqz\"\\n\\n## Expected:\\n\"yodn\"\\n\\nProblem clearly states, \" ***If there is more than one possible answer, return the longest word with the smallest lexicographical order.*** \"\\nLexicographically \\'e\\' is smaller than \\'y\\'. Both \"ewqz\" & \"yodn\" are same length. So my expectation is \"ewqz\" should be the answer.\\n\\nAm I missing something? ;-/"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@AdityaShaw](/AdityaShaw)  I believe you are incorrect. I think the reason ewqz is not correct is that it cannot be traced back to a single character. In other words, there is no \\'e\\' in the array so it is a non-starter. Your explanantion would also work, because you would always pick the word that can be traced back to a single charter if there is one. But ewqz would also not be the right answer if yodn wasn\\'t an option."
                    },
                    {
                        "username": "AdityaShaw",
                        "content": "\"y\"=>\"yo\"=>\"yod\"=>\"yodn\"\\n\"ew\"=>\"ewq\"=>\"ewqz\"\\nThe length of words that leads to the formation of the word \"yodn\" is greater compared to \"ewqz\". Hence, that turn out to be the preferred solution."
                    },
                    {
                        "username": "vfvf4002",
                        "content": "In the question description, it is stated that we have to make the words one character at a time.\\nSo given an array:\\n[\"o\", \"or\", \"wor\", \"worl\", \"world\"],\\nwe should be able to make the word \"world\". But, the answer of this comes out to be \"or\" as they are considering only cases wherein the previous word is a prefix of the fiven word."
                    },
                    {
                        "username": "parameterNextNaive",
                        "content": "For people who are not able to understand this question, read this: https://leetcode.com/problems/longest-word-with-all-prefixes/description/.\\n\\nThey are exactly same questions with different wording."
                    },
                    {
                        "username": "jinlibao",
                        "content": "According to the description, \"find the longest word in words that can be built one character at a time by other words in words\", technically, `[\"d\", \"ld\", \"rld\", \"orld\", \"world\"]` also works as `[\"w\",\"wo\",\"wor\",\"worl\", \"world\"]`, right? But according to the output of \"Run Code\", it is not. :("
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Note that the word should be built from left to right with each additional character being added to the end of a previous word. "
                    },
                    {
                        "username": "learnSomeCode",
                        "content": "can some one explain why the solution to this test case is \"eyj\" instead of \"eyjuoi\"?\\n[\"ogz\",\"eyj\",\"e\",\"ey\",\"hmn\",\"v\",\"hm\",\"ogznkb\",\"ogzn\",\"hmnm\",\"eyjuo\",\"vuq\",\"ogznk\",\"og\",\"eyjuoi\",\"d\"]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@drc354](/drc354) A bit late, but you cannot start at \\'og\\', you have to start at \\'o\\', and there is no \\'o\\' in the dictionary"
                    },
                    {
                        "username": "drc354",
                        "content": "[@Mister_CK](/Mister_CK) Why would the answer not be ogznkb considering that in the test case, there are og -> ogz -> ogzn -> ognzk -> ognzkb"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "\\'eyju\\' is not part of the array if I see correctly, so you can never get to eyjuoi "
                    },
                    {
                        "username": "pansari",
                        "content": "[\"wo\",\"wor\",\"worl\",\"world\"]\\nMy answer = \"world\"\\nAnswer by OJ = \"\"\\nThis can be ``` built one character at a time by other words in words.```"
                    },
                    {
                        "username": "kaxagvimraze",
                        "content": "can anyone help because my code works but fails on last test case (59/59) where there is no input and i got time limit exceeded, so is there a big input and I have a problem with algorithm or i may check existence if an input?"
                    },
                    {
                        "username": "refleks1a",
                        "content": "input:\\n[\"yo\",\"ew\",\"fc\",\"zrc\",\"yodn\",\"fcm\",\"qm\",\"qmo\",\"fcmz\",\"z\",\"ewq\",\"yod\",\"ewqz\",\"y\"]\\noutput:\\n\"fcmz\"\\nexpected:\\n\"yodn\"\\n\\n\"fcmz\" is lexicographically smaller than \"yodn\" but the correct answer is \"yodn\".\\nWHY?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don\\'t see an \\'f\\' in the dictionary, so how can you form \\'fcmz\\'?\\n\\nGiven an array of strings words representing an English Dictionary, return the longest word in words that can be built one character at a time by other words in words."
                    }
                ]
            },
            {
                "id": 2035861,
                "content": [
                    {
                        "username": "ChristoPalas",
                        "content": "How can this testcase be correct?\\nInput\\n[\"yo\",\"ew\",\"fc\",\"zrc\",\"yodn\",\"fcm\",\"qm\",\"qmo\",\"fcmz\",\"z\",\"ewq\",\"yod\",\"ewqz\",\"y\"]\\nOutput\\n\"ewqz\"\\nExpected\\n\"yodn\"\\n\\n\"ewqz\" can be built from \"ewq\" and is the same length with \"yodn\" but lexicographically smaller than it."
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@ChristoPalas](/ChristoPalas) for word \"ewqz\", \\'e\\' is not present in word array so that cannot be the answer whereas in case of \"yodn\", each of \\'yodn\\', \\'yod\\', \\'yo\\' and \\'y\\' are present so the correct answer is \"yodn\" for this testcase. Hope its clear."
                    },
                    {
                        "username": "iChuan",
                        "content": "Totally lost myself in this description. Thank you!"
                    },
                    {
                        "username": "vmk1802",
                        "content": "Can anyone explain why this answer is wrong?\\n\\n## Input:\\n[\"yo\",\"ew\",\"fc\",\"zrc\",\"yodn\",\"fcm\",\"qm\",\"qmo\",\"fcmz\",\"z\",\"ewq\",\"yod\",\"ewqz\",\"y\"]\\n\\n## Output:\\n\"ewqz\"\\n\\n## Expected:\\n\"yodn\"\\n\\nProblem clearly states, \" ***If there is more than one possible answer, return the longest word with the smallest lexicographical order.*** \"\\nLexicographically \\'e\\' is smaller than \\'y\\'. Both \"ewqz\" & \"yodn\" are same length. So my expectation is \"ewqz\" should be the answer.\\n\\nAm I missing something? ;-/"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@AdityaShaw](/AdityaShaw)  I believe you are incorrect. I think the reason ewqz is not correct is that it cannot be traced back to a single character. In other words, there is no \\'e\\' in the array so it is a non-starter. Your explanantion would also work, because you would always pick the word that can be traced back to a single charter if there is one. But ewqz would also not be the right answer if yodn wasn\\'t an option."
                    },
                    {
                        "username": "AdityaShaw",
                        "content": "\"y\"=>\"yo\"=>\"yod\"=>\"yodn\"\\n\"ew\"=>\"ewq\"=>\"ewqz\"\\nThe length of words that leads to the formation of the word \"yodn\" is greater compared to \"ewqz\". Hence, that turn out to be the preferred solution."
                    },
                    {
                        "username": "vfvf4002",
                        "content": "In the question description, it is stated that we have to make the words one character at a time.\\nSo given an array:\\n[\"o\", \"or\", \"wor\", \"worl\", \"world\"],\\nwe should be able to make the word \"world\". But, the answer of this comes out to be \"or\" as they are considering only cases wherein the previous word is a prefix of the fiven word."
                    },
                    {
                        "username": "parameterNextNaive",
                        "content": "For people who are not able to understand this question, read this: https://leetcode.com/problems/longest-word-with-all-prefixes/description/.\\n\\nThey are exactly same questions with different wording."
                    },
                    {
                        "username": "jinlibao",
                        "content": "According to the description, \"find the longest word in words that can be built one character at a time by other words in words\", technically, `[\"d\", \"ld\", \"rld\", \"orld\", \"world\"]` also works as `[\"w\",\"wo\",\"wor\",\"worl\", \"world\"]`, right? But according to the output of \"Run Code\", it is not. :("
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Note that the word should be built from left to right with each additional character being added to the end of a previous word. "
                    },
                    {
                        "username": "learnSomeCode",
                        "content": "can some one explain why the solution to this test case is \"eyj\" instead of \"eyjuoi\"?\\n[\"ogz\",\"eyj\",\"e\",\"ey\",\"hmn\",\"v\",\"hm\",\"ogznkb\",\"ogzn\",\"hmnm\",\"eyjuo\",\"vuq\",\"ogznk\",\"og\",\"eyjuoi\",\"d\"]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@drc354](/drc354) A bit late, but you cannot start at \\'og\\', you have to start at \\'o\\', and there is no \\'o\\' in the dictionary"
                    },
                    {
                        "username": "drc354",
                        "content": "[@Mister_CK](/Mister_CK) Why would the answer not be ogznkb considering that in the test case, there are og -> ogz -> ogzn -> ognzk -> ognzkb"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "\\'eyju\\' is not part of the array if I see correctly, so you can never get to eyjuoi "
                    },
                    {
                        "username": "pansari",
                        "content": "[\"wo\",\"wor\",\"worl\",\"world\"]\\nMy answer = \"world\"\\nAnswer by OJ = \"\"\\nThis can be ``` built one character at a time by other words in words.```"
                    },
                    {
                        "username": "kaxagvimraze",
                        "content": "can anyone help because my code works but fails on last test case (59/59) where there is no input and i got time limit exceeded, so is there a big input and I have a problem with algorithm or i may check existence if an input?"
                    },
                    {
                        "username": "refleks1a",
                        "content": "input:\\n[\"yo\",\"ew\",\"fc\",\"zrc\",\"yodn\",\"fcm\",\"qm\",\"qmo\",\"fcmz\",\"z\",\"ewq\",\"yod\",\"ewqz\",\"y\"]\\noutput:\\n\"fcmz\"\\nexpected:\\n\"yodn\"\\n\\n\"fcmz\" is lexicographically smaller than \"yodn\" but the correct answer is \"yodn\".\\nWHY?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don\\'t see an \\'f\\' in the dictionary, so how can you form \\'fcmz\\'?\\n\\nGiven an array of strings words representing an English Dictionary, return the longest word in words that can be built one character at a time by other words in words."
                    }
                ]
            },
            {
                "id": 1972875,
                "content": [
                    {
                        "username": "ChristoPalas",
                        "content": "How can this testcase be correct?\\nInput\\n[\"yo\",\"ew\",\"fc\",\"zrc\",\"yodn\",\"fcm\",\"qm\",\"qmo\",\"fcmz\",\"z\",\"ewq\",\"yod\",\"ewqz\",\"y\"]\\nOutput\\n\"ewqz\"\\nExpected\\n\"yodn\"\\n\\n\"ewqz\" can be built from \"ewq\" and is the same length with \"yodn\" but lexicographically smaller than it."
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@ChristoPalas](/ChristoPalas) for word \"ewqz\", \\'e\\' is not present in word array so that cannot be the answer whereas in case of \"yodn\", each of \\'yodn\\', \\'yod\\', \\'yo\\' and \\'y\\' are present so the correct answer is \"yodn\" for this testcase. Hope its clear."
                    },
                    {
                        "username": "iChuan",
                        "content": "Totally lost myself in this description. Thank you!"
                    },
                    {
                        "username": "vmk1802",
                        "content": "Can anyone explain why this answer is wrong?\\n\\n## Input:\\n[\"yo\",\"ew\",\"fc\",\"zrc\",\"yodn\",\"fcm\",\"qm\",\"qmo\",\"fcmz\",\"z\",\"ewq\",\"yod\",\"ewqz\",\"y\"]\\n\\n## Output:\\n\"ewqz\"\\n\\n## Expected:\\n\"yodn\"\\n\\nProblem clearly states, \" ***If there is more than one possible answer, return the longest word with the smallest lexicographical order.*** \"\\nLexicographically \\'e\\' is smaller than \\'y\\'. Both \"ewqz\" & \"yodn\" are same length. So my expectation is \"ewqz\" should be the answer.\\n\\nAm I missing something? ;-/"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@AdityaShaw](/AdityaShaw)  I believe you are incorrect. I think the reason ewqz is not correct is that it cannot be traced back to a single character. In other words, there is no \\'e\\' in the array so it is a non-starter. Your explanantion would also work, because you would always pick the word that can be traced back to a single charter if there is one. But ewqz would also not be the right answer if yodn wasn\\'t an option."
                    },
                    {
                        "username": "AdityaShaw",
                        "content": "\"y\"=>\"yo\"=>\"yod\"=>\"yodn\"\\n\"ew\"=>\"ewq\"=>\"ewqz\"\\nThe length of words that leads to the formation of the word \"yodn\" is greater compared to \"ewqz\". Hence, that turn out to be the preferred solution."
                    },
                    {
                        "username": "vfvf4002",
                        "content": "In the question description, it is stated that we have to make the words one character at a time.\\nSo given an array:\\n[\"o\", \"or\", \"wor\", \"worl\", \"world\"],\\nwe should be able to make the word \"world\". But, the answer of this comes out to be \"or\" as they are considering only cases wherein the previous word is a prefix of the fiven word."
                    },
                    {
                        "username": "parameterNextNaive",
                        "content": "For people who are not able to understand this question, read this: https://leetcode.com/problems/longest-word-with-all-prefixes/description/.\\n\\nThey are exactly same questions with different wording."
                    },
                    {
                        "username": "jinlibao",
                        "content": "According to the description, \"find the longest word in words that can be built one character at a time by other words in words\", technically, `[\"d\", \"ld\", \"rld\", \"orld\", \"world\"]` also works as `[\"w\",\"wo\",\"wor\",\"worl\", \"world\"]`, right? But according to the output of \"Run Code\", it is not. :("
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Note that the word should be built from left to right with each additional character being added to the end of a previous word. "
                    },
                    {
                        "username": "learnSomeCode",
                        "content": "can some one explain why the solution to this test case is \"eyj\" instead of \"eyjuoi\"?\\n[\"ogz\",\"eyj\",\"e\",\"ey\",\"hmn\",\"v\",\"hm\",\"ogznkb\",\"ogzn\",\"hmnm\",\"eyjuo\",\"vuq\",\"ogznk\",\"og\",\"eyjuoi\",\"d\"]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@drc354](/drc354) A bit late, but you cannot start at \\'og\\', you have to start at \\'o\\', and there is no \\'o\\' in the dictionary"
                    },
                    {
                        "username": "drc354",
                        "content": "[@Mister_CK](/Mister_CK) Why would the answer not be ogznkb considering that in the test case, there are og -> ogz -> ogzn -> ognzk -> ognzkb"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "\\'eyju\\' is not part of the array if I see correctly, so you can never get to eyjuoi "
                    },
                    {
                        "username": "pansari",
                        "content": "[\"wo\",\"wor\",\"worl\",\"world\"]\\nMy answer = \"world\"\\nAnswer by OJ = \"\"\\nThis can be ``` built one character at a time by other words in words.```"
                    },
                    {
                        "username": "kaxagvimraze",
                        "content": "can anyone help because my code works but fails on last test case (59/59) where there is no input and i got time limit exceeded, so is there a big input and I have a problem with algorithm or i may check existence if an input?"
                    },
                    {
                        "username": "refleks1a",
                        "content": "input:\\n[\"yo\",\"ew\",\"fc\",\"zrc\",\"yodn\",\"fcm\",\"qm\",\"qmo\",\"fcmz\",\"z\",\"ewq\",\"yod\",\"ewqz\",\"y\"]\\noutput:\\n\"fcmz\"\\nexpected:\\n\"yodn\"\\n\\n\"fcmz\" is lexicographically smaller than \"yodn\" but the correct answer is \"yodn\".\\nWHY?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don\\'t see an \\'f\\' in the dictionary, so how can you form \\'fcmz\\'?\\n\\nGiven an array of strings words representing an English Dictionary, return the longest word in words that can be built one character at a time by other words in words."
                    }
                ]
            },
            {
                "id": 1920386,
                "content": [
                    {
                        "username": "ChristoPalas",
                        "content": "How can this testcase be correct?\\nInput\\n[\"yo\",\"ew\",\"fc\",\"zrc\",\"yodn\",\"fcm\",\"qm\",\"qmo\",\"fcmz\",\"z\",\"ewq\",\"yod\",\"ewqz\",\"y\"]\\nOutput\\n\"ewqz\"\\nExpected\\n\"yodn\"\\n\\n\"ewqz\" can be built from \"ewq\" and is the same length with \"yodn\" but lexicographically smaller than it."
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@ChristoPalas](/ChristoPalas) for word \"ewqz\", \\'e\\' is not present in word array so that cannot be the answer whereas in case of \"yodn\", each of \\'yodn\\', \\'yod\\', \\'yo\\' and \\'y\\' are present so the correct answer is \"yodn\" for this testcase. Hope its clear."
                    },
                    {
                        "username": "iChuan",
                        "content": "Totally lost myself in this description. Thank you!"
                    },
                    {
                        "username": "vmk1802",
                        "content": "Can anyone explain why this answer is wrong?\\n\\n## Input:\\n[\"yo\",\"ew\",\"fc\",\"zrc\",\"yodn\",\"fcm\",\"qm\",\"qmo\",\"fcmz\",\"z\",\"ewq\",\"yod\",\"ewqz\",\"y\"]\\n\\n## Output:\\n\"ewqz\"\\n\\n## Expected:\\n\"yodn\"\\n\\nProblem clearly states, \" ***If there is more than one possible answer, return the longest word with the smallest lexicographical order.*** \"\\nLexicographically \\'e\\' is smaller than \\'y\\'. Both \"ewqz\" & \"yodn\" are same length. So my expectation is \"ewqz\" should be the answer.\\n\\nAm I missing something? ;-/"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@AdityaShaw](/AdityaShaw)  I believe you are incorrect. I think the reason ewqz is not correct is that it cannot be traced back to a single character. In other words, there is no \\'e\\' in the array so it is a non-starter. Your explanantion would also work, because you would always pick the word that can be traced back to a single charter if there is one. But ewqz would also not be the right answer if yodn wasn\\'t an option."
                    },
                    {
                        "username": "AdityaShaw",
                        "content": "\"y\"=>\"yo\"=>\"yod\"=>\"yodn\"\\n\"ew\"=>\"ewq\"=>\"ewqz\"\\nThe length of words that leads to the formation of the word \"yodn\" is greater compared to \"ewqz\". Hence, that turn out to be the preferred solution."
                    },
                    {
                        "username": "vfvf4002",
                        "content": "In the question description, it is stated that we have to make the words one character at a time.\\nSo given an array:\\n[\"o\", \"or\", \"wor\", \"worl\", \"world\"],\\nwe should be able to make the word \"world\". But, the answer of this comes out to be \"or\" as they are considering only cases wherein the previous word is a prefix of the fiven word."
                    },
                    {
                        "username": "parameterNextNaive",
                        "content": "For people who are not able to understand this question, read this: https://leetcode.com/problems/longest-word-with-all-prefixes/description/.\\n\\nThey are exactly same questions with different wording."
                    },
                    {
                        "username": "jinlibao",
                        "content": "According to the description, \"find the longest word in words that can be built one character at a time by other words in words\", technically, `[\"d\", \"ld\", \"rld\", \"orld\", \"world\"]` also works as `[\"w\",\"wo\",\"wor\",\"worl\", \"world\"]`, right? But according to the output of \"Run Code\", it is not. :("
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Note that the word should be built from left to right with each additional character being added to the end of a previous word. "
                    },
                    {
                        "username": "learnSomeCode",
                        "content": "can some one explain why the solution to this test case is \"eyj\" instead of \"eyjuoi\"?\\n[\"ogz\",\"eyj\",\"e\",\"ey\",\"hmn\",\"v\",\"hm\",\"ogznkb\",\"ogzn\",\"hmnm\",\"eyjuo\",\"vuq\",\"ogznk\",\"og\",\"eyjuoi\",\"d\"]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@drc354](/drc354) A bit late, but you cannot start at \\'og\\', you have to start at \\'o\\', and there is no \\'o\\' in the dictionary"
                    },
                    {
                        "username": "drc354",
                        "content": "[@Mister_CK](/Mister_CK) Why would the answer not be ogznkb considering that in the test case, there are og -> ogz -> ogzn -> ognzk -> ognzkb"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "\\'eyju\\' is not part of the array if I see correctly, so you can never get to eyjuoi "
                    },
                    {
                        "username": "pansari",
                        "content": "[\"wo\",\"wor\",\"worl\",\"world\"]\\nMy answer = \"world\"\\nAnswer by OJ = \"\"\\nThis can be ``` built one character at a time by other words in words.```"
                    },
                    {
                        "username": "kaxagvimraze",
                        "content": "can anyone help because my code works but fails on last test case (59/59) where there is no input and i got time limit exceeded, so is there a big input and I have a problem with algorithm or i may check existence if an input?"
                    },
                    {
                        "username": "refleks1a",
                        "content": "input:\\n[\"yo\",\"ew\",\"fc\",\"zrc\",\"yodn\",\"fcm\",\"qm\",\"qmo\",\"fcmz\",\"z\",\"ewq\",\"yod\",\"ewqz\",\"y\"]\\noutput:\\n\"fcmz\"\\nexpected:\\n\"yodn\"\\n\\n\"fcmz\" is lexicographically smaller than \"yodn\" but the correct answer is \"yodn\".\\nWHY?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don\\'t see an \\'f\\' in the dictionary, so how can you form \\'fcmz\\'?\\n\\nGiven an array of strings words representing an English Dictionary, return the longest word in words that can be built one character at a time by other words in words."
                    }
                ]
            },
            {
                "id": 1565388,
                "content": [
                    {
                        "username": "ChristoPalas",
                        "content": "How can this testcase be correct?\\nInput\\n[\"yo\",\"ew\",\"fc\",\"zrc\",\"yodn\",\"fcm\",\"qm\",\"qmo\",\"fcmz\",\"z\",\"ewq\",\"yod\",\"ewqz\",\"y\"]\\nOutput\\n\"ewqz\"\\nExpected\\n\"yodn\"\\n\\n\"ewqz\" can be built from \"ewq\" and is the same length with \"yodn\" but lexicographically smaller than it."
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@ChristoPalas](/ChristoPalas) for word \"ewqz\", \\'e\\' is not present in word array so that cannot be the answer whereas in case of \"yodn\", each of \\'yodn\\', \\'yod\\', \\'yo\\' and \\'y\\' are present so the correct answer is \"yodn\" for this testcase. Hope its clear."
                    },
                    {
                        "username": "iChuan",
                        "content": "Totally lost myself in this description. Thank you!"
                    },
                    {
                        "username": "vmk1802",
                        "content": "Can anyone explain why this answer is wrong?\\n\\n## Input:\\n[\"yo\",\"ew\",\"fc\",\"zrc\",\"yodn\",\"fcm\",\"qm\",\"qmo\",\"fcmz\",\"z\",\"ewq\",\"yod\",\"ewqz\",\"y\"]\\n\\n## Output:\\n\"ewqz\"\\n\\n## Expected:\\n\"yodn\"\\n\\nProblem clearly states, \" ***If there is more than one possible answer, return the longest word with the smallest lexicographical order.*** \"\\nLexicographically \\'e\\' is smaller than \\'y\\'. Both \"ewqz\" & \"yodn\" are same length. So my expectation is \"ewqz\" should be the answer.\\n\\nAm I missing something? ;-/"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@AdityaShaw](/AdityaShaw)  I believe you are incorrect. I think the reason ewqz is not correct is that it cannot be traced back to a single character. In other words, there is no \\'e\\' in the array so it is a non-starter. Your explanantion would also work, because you would always pick the word that can be traced back to a single charter if there is one. But ewqz would also not be the right answer if yodn wasn\\'t an option."
                    },
                    {
                        "username": "AdityaShaw",
                        "content": "\"y\"=>\"yo\"=>\"yod\"=>\"yodn\"\\n\"ew\"=>\"ewq\"=>\"ewqz\"\\nThe length of words that leads to the formation of the word \"yodn\" is greater compared to \"ewqz\". Hence, that turn out to be the preferred solution."
                    },
                    {
                        "username": "vfvf4002",
                        "content": "In the question description, it is stated that we have to make the words one character at a time.\\nSo given an array:\\n[\"o\", \"or\", \"wor\", \"worl\", \"world\"],\\nwe should be able to make the word \"world\". But, the answer of this comes out to be \"or\" as they are considering only cases wherein the previous word is a prefix of the fiven word."
                    },
                    {
                        "username": "parameterNextNaive",
                        "content": "For people who are not able to understand this question, read this: https://leetcode.com/problems/longest-word-with-all-prefixes/description/.\\n\\nThey are exactly same questions with different wording."
                    },
                    {
                        "username": "jinlibao",
                        "content": "According to the description, \"find the longest word in words that can be built one character at a time by other words in words\", technically, `[\"d\", \"ld\", \"rld\", \"orld\", \"world\"]` also works as `[\"w\",\"wo\",\"wor\",\"worl\", \"world\"]`, right? But according to the output of \"Run Code\", it is not. :("
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Note that the word should be built from left to right with each additional character being added to the end of a previous word. "
                    },
                    {
                        "username": "learnSomeCode",
                        "content": "can some one explain why the solution to this test case is \"eyj\" instead of \"eyjuoi\"?\\n[\"ogz\",\"eyj\",\"e\",\"ey\",\"hmn\",\"v\",\"hm\",\"ogznkb\",\"ogzn\",\"hmnm\",\"eyjuo\",\"vuq\",\"ogznk\",\"og\",\"eyjuoi\",\"d\"]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@drc354](/drc354) A bit late, but you cannot start at \\'og\\', you have to start at \\'o\\', and there is no \\'o\\' in the dictionary"
                    },
                    {
                        "username": "drc354",
                        "content": "[@Mister_CK](/Mister_CK) Why would the answer not be ogznkb considering that in the test case, there are og -> ogz -> ogzn -> ognzk -> ognzkb"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "\\'eyju\\' is not part of the array if I see correctly, so you can never get to eyjuoi "
                    },
                    {
                        "username": "pansari",
                        "content": "[\"wo\",\"wor\",\"worl\",\"world\"]\\nMy answer = \"world\"\\nAnswer by OJ = \"\"\\nThis can be ``` built one character at a time by other words in words.```"
                    },
                    {
                        "username": "kaxagvimraze",
                        "content": "can anyone help because my code works but fails on last test case (59/59) where there is no input and i got time limit exceeded, so is there a big input and I have a problem with algorithm or i may check existence if an input?"
                    },
                    {
                        "username": "refleks1a",
                        "content": "input:\\n[\"yo\",\"ew\",\"fc\",\"zrc\",\"yodn\",\"fcm\",\"qm\",\"qmo\",\"fcmz\",\"z\",\"ewq\",\"yod\",\"ewqz\",\"y\"]\\noutput:\\n\"fcmz\"\\nexpected:\\n\"yodn\"\\n\\n\"fcmz\" is lexicographically smaller than \"yodn\" but the correct answer is \"yodn\".\\nWHY?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don\\'t see an \\'f\\' in the dictionary, so how can you form \\'fcmz\\'?\\n\\nGiven an array of strings words representing an English Dictionary, return the longest word in words that can be built one character at a time by other words in words."
                    }
                ]
            },
            {
                "id": 1569291,
                "content": [
                    {
                        "username": "ChristoPalas",
                        "content": "How can this testcase be correct?\\nInput\\n[\"yo\",\"ew\",\"fc\",\"zrc\",\"yodn\",\"fcm\",\"qm\",\"qmo\",\"fcmz\",\"z\",\"ewq\",\"yod\",\"ewqz\",\"y\"]\\nOutput\\n\"ewqz\"\\nExpected\\n\"yodn\"\\n\\n\"ewqz\" can be built from \"ewq\" and is the same length with \"yodn\" but lexicographically smaller than it."
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@ChristoPalas](/ChristoPalas) for word \"ewqz\", \\'e\\' is not present in word array so that cannot be the answer whereas in case of \"yodn\", each of \\'yodn\\', \\'yod\\', \\'yo\\' and \\'y\\' are present so the correct answer is \"yodn\" for this testcase. Hope its clear."
                    },
                    {
                        "username": "iChuan",
                        "content": "Totally lost myself in this description. Thank you!"
                    },
                    {
                        "username": "vmk1802",
                        "content": "Can anyone explain why this answer is wrong?\\n\\n## Input:\\n[\"yo\",\"ew\",\"fc\",\"zrc\",\"yodn\",\"fcm\",\"qm\",\"qmo\",\"fcmz\",\"z\",\"ewq\",\"yod\",\"ewqz\",\"y\"]\\n\\n## Output:\\n\"ewqz\"\\n\\n## Expected:\\n\"yodn\"\\n\\nProblem clearly states, \" ***If there is more than one possible answer, return the longest word with the smallest lexicographical order.*** \"\\nLexicographically \\'e\\' is smaller than \\'y\\'. Both \"ewqz\" & \"yodn\" are same length. So my expectation is \"ewqz\" should be the answer.\\n\\nAm I missing something? ;-/"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@AdityaShaw](/AdityaShaw)  I believe you are incorrect. I think the reason ewqz is not correct is that it cannot be traced back to a single character. In other words, there is no \\'e\\' in the array so it is a non-starter. Your explanantion would also work, because you would always pick the word that can be traced back to a single charter if there is one. But ewqz would also not be the right answer if yodn wasn\\'t an option."
                    },
                    {
                        "username": "AdityaShaw",
                        "content": "\"y\"=>\"yo\"=>\"yod\"=>\"yodn\"\\n\"ew\"=>\"ewq\"=>\"ewqz\"\\nThe length of words that leads to the formation of the word \"yodn\" is greater compared to \"ewqz\". Hence, that turn out to be the preferred solution."
                    },
                    {
                        "username": "vfvf4002",
                        "content": "In the question description, it is stated that we have to make the words one character at a time.\\nSo given an array:\\n[\"o\", \"or\", \"wor\", \"worl\", \"world\"],\\nwe should be able to make the word \"world\". But, the answer of this comes out to be \"or\" as they are considering only cases wherein the previous word is a prefix of the fiven word."
                    },
                    {
                        "username": "parameterNextNaive",
                        "content": "For people who are not able to understand this question, read this: https://leetcode.com/problems/longest-word-with-all-prefixes/description/.\\n\\nThey are exactly same questions with different wording."
                    },
                    {
                        "username": "jinlibao",
                        "content": "According to the description, \"find the longest word in words that can be built one character at a time by other words in words\", technically, `[\"d\", \"ld\", \"rld\", \"orld\", \"world\"]` also works as `[\"w\",\"wo\",\"wor\",\"worl\", \"world\"]`, right? But according to the output of \"Run Code\", it is not. :("
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Note that the word should be built from left to right with each additional character being added to the end of a previous word. "
                    },
                    {
                        "username": "learnSomeCode",
                        "content": "can some one explain why the solution to this test case is \"eyj\" instead of \"eyjuoi\"?\\n[\"ogz\",\"eyj\",\"e\",\"ey\",\"hmn\",\"v\",\"hm\",\"ogznkb\",\"ogzn\",\"hmnm\",\"eyjuo\",\"vuq\",\"ogznk\",\"og\",\"eyjuoi\",\"d\"]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@drc354](/drc354) A bit late, but you cannot start at \\'og\\', you have to start at \\'o\\', and there is no \\'o\\' in the dictionary"
                    },
                    {
                        "username": "drc354",
                        "content": "[@Mister_CK](/Mister_CK) Why would the answer not be ogznkb considering that in the test case, there are og -> ogz -> ogzn -> ognzk -> ognzkb"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "\\'eyju\\' is not part of the array if I see correctly, so you can never get to eyjuoi "
                    },
                    {
                        "username": "pansari",
                        "content": "[\"wo\",\"wor\",\"worl\",\"world\"]\\nMy answer = \"world\"\\nAnswer by OJ = \"\"\\nThis can be ``` built one character at a time by other words in words.```"
                    },
                    {
                        "username": "kaxagvimraze",
                        "content": "can anyone help because my code works but fails on last test case (59/59) where there is no input and i got time limit exceeded, so is there a big input and I have a problem with algorithm or i may check existence if an input?"
                    },
                    {
                        "username": "refleks1a",
                        "content": "input:\\n[\"yo\",\"ew\",\"fc\",\"zrc\",\"yodn\",\"fcm\",\"qm\",\"qmo\",\"fcmz\",\"z\",\"ewq\",\"yod\",\"ewqz\",\"y\"]\\noutput:\\n\"fcmz\"\\nexpected:\\n\"yodn\"\\n\\n\"fcmz\" is lexicographically smaller than \"yodn\" but the correct answer is \"yodn\".\\nWHY?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don\\'t see an \\'f\\' in the dictionary, so how can you form \\'fcmz\\'?\\n\\nGiven an array of strings words representing an English Dictionary, return the longest word in words that can be built one character at a time by other words in words."
                    }
                ]
            },
            {
                "id": 1570265,
                "content": [
                    {
                        "username": "ChristoPalas",
                        "content": "How can this testcase be correct?\\nInput\\n[\"yo\",\"ew\",\"fc\",\"zrc\",\"yodn\",\"fcm\",\"qm\",\"qmo\",\"fcmz\",\"z\",\"ewq\",\"yod\",\"ewqz\",\"y\"]\\nOutput\\n\"ewqz\"\\nExpected\\n\"yodn\"\\n\\n\"ewqz\" can be built from \"ewq\" and is the same length with \"yodn\" but lexicographically smaller than it."
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@ChristoPalas](/ChristoPalas) for word \"ewqz\", \\'e\\' is not present in word array so that cannot be the answer whereas in case of \"yodn\", each of \\'yodn\\', \\'yod\\', \\'yo\\' and \\'y\\' are present so the correct answer is \"yodn\" for this testcase. Hope its clear."
                    },
                    {
                        "username": "iChuan",
                        "content": "Totally lost myself in this description. Thank you!"
                    },
                    {
                        "username": "vmk1802",
                        "content": "Can anyone explain why this answer is wrong?\\n\\n## Input:\\n[\"yo\",\"ew\",\"fc\",\"zrc\",\"yodn\",\"fcm\",\"qm\",\"qmo\",\"fcmz\",\"z\",\"ewq\",\"yod\",\"ewqz\",\"y\"]\\n\\n## Output:\\n\"ewqz\"\\n\\n## Expected:\\n\"yodn\"\\n\\nProblem clearly states, \" ***If there is more than one possible answer, return the longest word with the smallest lexicographical order.*** \"\\nLexicographically \\'e\\' is smaller than \\'y\\'. Both \"ewqz\" & \"yodn\" are same length. So my expectation is \"ewqz\" should be the answer.\\n\\nAm I missing something? ;-/"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@AdityaShaw](/AdityaShaw)  I believe you are incorrect. I think the reason ewqz is not correct is that it cannot be traced back to a single character. In other words, there is no \\'e\\' in the array so it is a non-starter. Your explanantion would also work, because you would always pick the word that can be traced back to a single charter if there is one. But ewqz would also not be the right answer if yodn wasn\\'t an option."
                    },
                    {
                        "username": "AdityaShaw",
                        "content": "\"y\"=>\"yo\"=>\"yod\"=>\"yodn\"\\n\"ew\"=>\"ewq\"=>\"ewqz\"\\nThe length of words that leads to the formation of the word \"yodn\" is greater compared to \"ewqz\". Hence, that turn out to be the preferred solution."
                    },
                    {
                        "username": "vfvf4002",
                        "content": "In the question description, it is stated that we have to make the words one character at a time.\\nSo given an array:\\n[\"o\", \"or\", \"wor\", \"worl\", \"world\"],\\nwe should be able to make the word \"world\". But, the answer of this comes out to be \"or\" as they are considering only cases wherein the previous word is a prefix of the fiven word."
                    },
                    {
                        "username": "parameterNextNaive",
                        "content": "For people who are not able to understand this question, read this: https://leetcode.com/problems/longest-word-with-all-prefixes/description/.\\n\\nThey are exactly same questions with different wording."
                    },
                    {
                        "username": "jinlibao",
                        "content": "According to the description, \"find the longest word in words that can be built one character at a time by other words in words\", technically, `[\"d\", \"ld\", \"rld\", \"orld\", \"world\"]` also works as `[\"w\",\"wo\",\"wor\",\"worl\", \"world\"]`, right? But according to the output of \"Run Code\", it is not. :("
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Note that the word should be built from left to right with each additional character being added to the end of a previous word. "
                    },
                    {
                        "username": "learnSomeCode",
                        "content": "can some one explain why the solution to this test case is \"eyj\" instead of \"eyjuoi\"?\\n[\"ogz\",\"eyj\",\"e\",\"ey\",\"hmn\",\"v\",\"hm\",\"ogznkb\",\"ogzn\",\"hmnm\",\"eyjuo\",\"vuq\",\"ogznk\",\"og\",\"eyjuoi\",\"d\"]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@drc354](/drc354) A bit late, but you cannot start at \\'og\\', you have to start at \\'o\\', and there is no \\'o\\' in the dictionary"
                    },
                    {
                        "username": "drc354",
                        "content": "[@Mister_CK](/Mister_CK) Why would the answer not be ogznkb considering that in the test case, there are og -> ogz -> ogzn -> ognzk -> ognzkb"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "\\'eyju\\' is not part of the array if I see correctly, so you can never get to eyjuoi "
                    },
                    {
                        "username": "pansari",
                        "content": "[\"wo\",\"wor\",\"worl\",\"world\"]\\nMy answer = \"world\"\\nAnswer by OJ = \"\"\\nThis can be ``` built one character at a time by other words in words.```"
                    },
                    {
                        "username": "kaxagvimraze",
                        "content": "can anyone help because my code works but fails on last test case (59/59) where there is no input and i got time limit exceeded, so is there a big input and I have a problem with algorithm or i may check existence if an input?"
                    },
                    {
                        "username": "refleks1a",
                        "content": "input:\\n[\"yo\",\"ew\",\"fc\",\"zrc\",\"yodn\",\"fcm\",\"qm\",\"qmo\",\"fcmz\",\"z\",\"ewq\",\"yod\",\"ewqz\",\"y\"]\\noutput:\\n\"fcmz\"\\nexpected:\\n\"yodn\"\\n\\n\"fcmz\" is lexicographically smaller than \"yodn\" but the correct answer is \"yodn\".\\nWHY?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don\\'t see an \\'f\\' in the dictionary, so how can you form \\'fcmz\\'?\\n\\nGiven an array of strings words representing an English Dictionary, return the longest word in words that can be built one character at a time by other words in words."
                    }
                ]
            },
            {
                "id": 1576959,
                "content": [
                    {
                        "username": "ChristoPalas",
                        "content": "How can this testcase be correct?\\nInput\\n[\"yo\",\"ew\",\"fc\",\"zrc\",\"yodn\",\"fcm\",\"qm\",\"qmo\",\"fcmz\",\"z\",\"ewq\",\"yod\",\"ewqz\",\"y\"]\\nOutput\\n\"ewqz\"\\nExpected\\n\"yodn\"\\n\\n\"ewqz\" can be built from \"ewq\" and is the same length with \"yodn\" but lexicographically smaller than it."
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@ChristoPalas](/ChristoPalas) for word \"ewqz\", \\'e\\' is not present in word array so that cannot be the answer whereas in case of \"yodn\", each of \\'yodn\\', \\'yod\\', \\'yo\\' and \\'y\\' are present so the correct answer is \"yodn\" for this testcase. Hope its clear."
                    },
                    {
                        "username": "iChuan",
                        "content": "Totally lost myself in this description. Thank you!"
                    },
                    {
                        "username": "vmk1802",
                        "content": "Can anyone explain why this answer is wrong?\\n\\n## Input:\\n[\"yo\",\"ew\",\"fc\",\"zrc\",\"yodn\",\"fcm\",\"qm\",\"qmo\",\"fcmz\",\"z\",\"ewq\",\"yod\",\"ewqz\",\"y\"]\\n\\n## Output:\\n\"ewqz\"\\n\\n## Expected:\\n\"yodn\"\\n\\nProblem clearly states, \" ***If there is more than one possible answer, return the longest word with the smallest lexicographical order.*** \"\\nLexicographically \\'e\\' is smaller than \\'y\\'. Both \"ewqz\" & \"yodn\" are same length. So my expectation is \"ewqz\" should be the answer.\\n\\nAm I missing something? ;-/"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@AdityaShaw](/AdityaShaw)  I believe you are incorrect. I think the reason ewqz is not correct is that it cannot be traced back to a single character. In other words, there is no \\'e\\' in the array so it is a non-starter. Your explanantion would also work, because you would always pick the word that can be traced back to a single charter if there is one. But ewqz would also not be the right answer if yodn wasn\\'t an option."
                    },
                    {
                        "username": "AdityaShaw",
                        "content": "\"y\"=>\"yo\"=>\"yod\"=>\"yodn\"\\n\"ew\"=>\"ewq\"=>\"ewqz\"\\nThe length of words that leads to the formation of the word \"yodn\" is greater compared to \"ewqz\". Hence, that turn out to be the preferred solution."
                    },
                    {
                        "username": "vfvf4002",
                        "content": "In the question description, it is stated that we have to make the words one character at a time.\\nSo given an array:\\n[\"o\", \"or\", \"wor\", \"worl\", \"world\"],\\nwe should be able to make the word \"world\". But, the answer of this comes out to be \"or\" as they are considering only cases wherein the previous word is a prefix of the fiven word."
                    },
                    {
                        "username": "parameterNextNaive",
                        "content": "For people who are not able to understand this question, read this: https://leetcode.com/problems/longest-word-with-all-prefixes/description/.\\n\\nThey are exactly same questions with different wording."
                    },
                    {
                        "username": "jinlibao",
                        "content": "According to the description, \"find the longest word in words that can be built one character at a time by other words in words\", technically, `[\"d\", \"ld\", \"rld\", \"orld\", \"world\"]` also works as `[\"w\",\"wo\",\"wor\",\"worl\", \"world\"]`, right? But according to the output of \"Run Code\", it is not. :("
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Note that the word should be built from left to right with each additional character being added to the end of a previous word. "
                    },
                    {
                        "username": "learnSomeCode",
                        "content": "can some one explain why the solution to this test case is \"eyj\" instead of \"eyjuoi\"?\\n[\"ogz\",\"eyj\",\"e\",\"ey\",\"hmn\",\"v\",\"hm\",\"ogznkb\",\"ogzn\",\"hmnm\",\"eyjuo\",\"vuq\",\"ogznk\",\"og\",\"eyjuoi\",\"d\"]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@drc354](/drc354) A bit late, but you cannot start at \\'og\\', you have to start at \\'o\\', and there is no \\'o\\' in the dictionary"
                    },
                    {
                        "username": "drc354",
                        "content": "[@Mister_CK](/Mister_CK) Why would the answer not be ogznkb considering that in the test case, there are og -> ogz -> ogzn -> ognzk -> ognzkb"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "\\'eyju\\' is not part of the array if I see correctly, so you can never get to eyjuoi "
                    },
                    {
                        "username": "pansari",
                        "content": "[\"wo\",\"wor\",\"worl\",\"world\"]\\nMy answer = \"world\"\\nAnswer by OJ = \"\"\\nThis can be ``` built one character at a time by other words in words.```"
                    },
                    {
                        "username": "kaxagvimraze",
                        "content": "can anyone help because my code works but fails on last test case (59/59) where there is no input and i got time limit exceeded, so is there a big input and I have a problem with algorithm or i may check existence if an input?"
                    },
                    {
                        "username": "refleks1a",
                        "content": "input:\\n[\"yo\",\"ew\",\"fc\",\"zrc\",\"yodn\",\"fcm\",\"qm\",\"qmo\",\"fcmz\",\"z\",\"ewq\",\"yod\",\"ewqz\",\"y\"]\\noutput:\\n\"fcmz\"\\nexpected:\\n\"yodn\"\\n\\n\"fcmz\" is lexicographically smaller than \"yodn\" but the correct answer is \"yodn\".\\nWHY?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don\\'t see an \\'f\\' in the dictionary, so how can you form \\'fcmz\\'?\\n\\nGiven an array of strings words representing an English Dictionary, return the longest word in words that can be built one character at a time by other words in words."
                    }
                ]
            },
            {
                "id": 1760053,
                "content": [
                    {
                        "username": "ChristoPalas",
                        "content": "How can this testcase be correct?\\nInput\\n[\"yo\",\"ew\",\"fc\",\"zrc\",\"yodn\",\"fcm\",\"qm\",\"qmo\",\"fcmz\",\"z\",\"ewq\",\"yod\",\"ewqz\",\"y\"]\\nOutput\\n\"ewqz\"\\nExpected\\n\"yodn\"\\n\\n\"ewqz\" can be built from \"ewq\" and is the same length with \"yodn\" but lexicographically smaller than it."
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@ChristoPalas](/ChristoPalas) for word \"ewqz\", \\'e\\' is not present in word array so that cannot be the answer whereas in case of \"yodn\", each of \\'yodn\\', \\'yod\\', \\'yo\\' and \\'y\\' are present so the correct answer is \"yodn\" for this testcase. Hope its clear."
                    },
                    {
                        "username": "iChuan",
                        "content": "Totally lost myself in this description. Thank you!"
                    },
                    {
                        "username": "vmk1802",
                        "content": "Can anyone explain why this answer is wrong?\\n\\n## Input:\\n[\"yo\",\"ew\",\"fc\",\"zrc\",\"yodn\",\"fcm\",\"qm\",\"qmo\",\"fcmz\",\"z\",\"ewq\",\"yod\",\"ewqz\",\"y\"]\\n\\n## Output:\\n\"ewqz\"\\n\\n## Expected:\\n\"yodn\"\\n\\nProblem clearly states, \" ***If there is more than one possible answer, return the longest word with the smallest lexicographical order.*** \"\\nLexicographically \\'e\\' is smaller than \\'y\\'. Both \"ewqz\" & \"yodn\" are same length. So my expectation is \"ewqz\" should be the answer.\\n\\nAm I missing something? ;-/"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@AdityaShaw](/AdityaShaw)  I believe you are incorrect. I think the reason ewqz is not correct is that it cannot be traced back to a single character. In other words, there is no \\'e\\' in the array so it is a non-starter. Your explanantion would also work, because you would always pick the word that can be traced back to a single charter if there is one. But ewqz would also not be the right answer if yodn wasn\\'t an option."
                    },
                    {
                        "username": "AdityaShaw",
                        "content": "\"y\"=>\"yo\"=>\"yod\"=>\"yodn\"\\n\"ew\"=>\"ewq\"=>\"ewqz\"\\nThe length of words that leads to the formation of the word \"yodn\" is greater compared to \"ewqz\". Hence, that turn out to be the preferred solution."
                    },
                    {
                        "username": "vfvf4002",
                        "content": "In the question description, it is stated that we have to make the words one character at a time.\\nSo given an array:\\n[\"o\", \"or\", \"wor\", \"worl\", \"world\"],\\nwe should be able to make the word \"world\". But, the answer of this comes out to be \"or\" as they are considering only cases wherein the previous word is a prefix of the fiven word."
                    },
                    {
                        "username": "parameterNextNaive",
                        "content": "For people who are not able to understand this question, read this: https://leetcode.com/problems/longest-word-with-all-prefixes/description/.\\n\\nThey are exactly same questions with different wording."
                    },
                    {
                        "username": "jinlibao",
                        "content": "According to the description, \"find the longest word in words that can be built one character at a time by other words in words\", technically, `[\"d\", \"ld\", \"rld\", \"orld\", \"world\"]` also works as `[\"w\",\"wo\",\"wor\",\"worl\", \"world\"]`, right? But according to the output of \"Run Code\", it is not. :("
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Note that the word should be built from left to right with each additional character being added to the end of a previous word. "
                    },
                    {
                        "username": "learnSomeCode",
                        "content": "can some one explain why the solution to this test case is \"eyj\" instead of \"eyjuoi\"?\\n[\"ogz\",\"eyj\",\"e\",\"ey\",\"hmn\",\"v\",\"hm\",\"ogznkb\",\"ogzn\",\"hmnm\",\"eyjuo\",\"vuq\",\"ogznk\",\"og\",\"eyjuoi\",\"d\"]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@drc354](/drc354) A bit late, but you cannot start at \\'og\\', you have to start at \\'o\\', and there is no \\'o\\' in the dictionary"
                    },
                    {
                        "username": "drc354",
                        "content": "[@Mister_CK](/Mister_CK) Why would the answer not be ogznkb considering that in the test case, there are og -> ogz -> ogzn -> ognzk -> ognzkb"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "\\'eyju\\' is not part of the array if I see correctly, so you can never get to eyjuoi "
                    },
                    {
                        "username": "pansari",
                        "content": "[\"wo\",\"wor\",\"worl\",\"world\"]\\nMy answer = \"world\"\\nAnswer by OJ = \"\"\\nThis can be ``` built one character at a time by other words in words.```"
                    },
                    {
                        "username": "kaxagvimraze",
                        "content": "can anyone help because my code works but fails on last test case (59/59) where there is no input and i got time limit exceeded, so is there a big input and I have a problem with algorithm or i may check existence if an input?"
                    },
                    {
                        "username": "refleks1a",
                        "content": "input:\\n[\"yo\",\"ew\",\"fc\",\"zrc\",\"yodn\",\"fcm\",\"qm\",\"qmo\",\"fcmz\",\"z\",\"ewq\",\"yod\",\"ewqz\",\"y\"]\\noutput:\\n\"fcmz\"\\nexpected:\\n\"yodn\"\\n\\n\"fcmz\" is lexicographically smaller than \"yodn\" but the correct answer is \"yodn\".\\nWHY?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don\\'t see an \\'f\\' in the dictionary, so how can you form \\'fcmz\\'?\\n\\nGiven an array of strings words representing an English Dictionary, return the longest word in words that can be built one character at a time by other words in words."
                    }
                ]
            },
            {
                "id": 1572052,
                "content": [
                    {
                        "username": "ChristoPalas",
                        "content": "How can this testcase be correct?\\nInput\\n[\"yo\",\"ew\",\"fc\",\"zrc\",\"yodn\",\"fcm\",\"qm\",\"qmo\",\"fcmz\",\"z\",\"ewq\",\"yod\",\"ewqz\",\"y\"]\\nOutput\\n\"ewqz\"\\nExpected\\n\"yodn\"\\n\\n\"ewqz\" can be built from \"ewq\" and is the same length with \"yodn\" but lexicographically smaller than it."
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@ChristoPalas](/ChristoPalas) for word \"ewqz\", \\'e\\' is not present in word array so that cannot be the answer whereas in case of \"yodn\", each of \\'yodn\\', \\'yod\\', \\'yo\\' and \\'y\\' are present so the correct answer is \"yodn\" for this testcase. Hope its clear."
                    },
                    {
                        "username": "iChuan",
                        "content": "Totally lost myself in this description. Thank you!"
                    },
                    {
                        "username": "vmk1802",
                        "content": "Can anyone explain why this answer is wrong?\\n\\n## Input:\\n[\"yo\",\"ew\",\"fc\",\"zrc\",\"yodn\",\"fcm\",\"qm\",\"qmo\",\"fcmz\",\"z\",\"ewq\",\"yod\",\"ewqz\",\"y\"]\\n\\n## Output:\\n\"ewqz\"\\n\\n## Expected:\\n\"yodn\"\\n\\nProblem clearly states, \" ***If there is more than one possible answer, return the longest word with the smallest lexicographical order.*** \"\\nLexicographically \\'e\\' is smaller than \\'y\\'. Both \"ewqz\" & \"yodn\" are same length. So my expectation is \"ewqz\" should be the answer.\\n\\nAm I missing something? ;-/"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@AdityaShaw](/AdityaShaw)  I believe you are incorrect. I think the reason ewqz is not correct is that it cannot be traced back to a single character. In other words, there is no \\'e\\' in the array so it is a non-starter. Your explanantion would also work, because you would always pick the word that can be traced back to a single charter if there is one. But ewqz would also not be the right answer if yodn wasn\\'t an option."
                    },
                    {
                        "username": "AdityaShaw",
                        "content": "\"y\"=>\"yo\"=>\"yod\"=>\"yodn\"\\n\"ew\"=>\"ewq\"=>\"ewqz\"\\nThe length of words that leads to the formation of the word \"yodn\" is greater compared to \"ewqz\". Hence, that turn out to be the preferred solution."
                    },
                    {
                        "username": "vfvf4002",
                        "content": "In the question description, it is stated that we have to make the words one character at a time.\\nSo given an array:\\n[\"o\", \"or\", \"wor\", \"worl\", \"world\"],\\nwe should be able to make the word \"world\". But, the answer of this comes out to be \"or\" as they are considering only cases wherein the previous word is a prefix of the fiven word."
                    },
                    {
                        "username": "parameterNextNaive",
                        "content": "For people who are not able to understand this question, read this: https://leetcode.com/problems/longest-word-with-all-prefixes/description/.\\n\\nThey are exactly same questions with different wording."
                    },
                    {
                        "username": "jinlibao",
                        "content": "According to the description, \"find the longest word in words that can be built one character at a time by other words in words\", technically, `[\"d\", \"ld\", \"rld\", \"orld\", \"world\"]` also works as `[\"w\",\"wo\",\"wor\",\"worl\", \"world\"]`, right? But according to the output of \"Run Code\", it is not. :("
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Note that the word should be built from left to right with each additional character being added to the end of a previous word. "
                    },
                    {
                        "username": "learnSomeCode",
                        "content": "can some one explain why the solution to this test case is \"eyj\" instead of \"eyjuoi\"?\\n[\"ogz\",\"eyj\",\"e\",\"ey\",\"hmn\",\"v\",\"hm\",\"ogznkb\",\"ogzn\",\"hmnm\",\"eyjuo\",\"vuq\",\"ogznk\",\"og\",\"eyjuoi\",\"d\"]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@drc354](/drc354) A bit late, but you cannot start at \\'og\\', you have to start at \\'o\\', and there is no \\'o\\' in the dictionary"
                    },
                    {
                        "username": "drc354",
                        "content": "[@Mister_CK](/Mister_CK) Why would the answer not be ogznkb considering that in the test case, there are og -> ogz -> ogzn -> ognzk -> ognzkb"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "\\'eyju\\' is not part of the array if I see correctly, so you can never get to eyjuoi "
                    },
                    {
                        "username": "pansari",
                        "content": "[\"wo\",\"wor\",\"worl\",\"world\"]\\nMy answer = \"world\"\\nAnswer by OJ = \"\"\\nThis can be ``` built one character at a time by other words in words.```"
                    },
                    {
                        "username": "kaxagvimraze",
                        "content": "can anyone help because my code works but fails on last test case (59/59) where there is no input and i got time limit exceeded, so is there a big input and I have a problem with algorithm or i may check existence if an input?"
                    },
                    {
                        "username": "refleks1a",
                        "content": "input:\\n[\"yo\",\"ew\",\"fc\",\"zrc\",\"yodn\",\"fcm\",\"qm\",\"qmo\",\"fcmz\",\"z\",\"ewq\",\"yod\",\"ewqz\",\"y\"]\\noutput:\\n\"fcmz\"\\nexpected:\\n\"yodn\"\\n\\n\"fcmz\" is lexicographically smaller than \"yodn\" but the correct answer is \"yodn\".\\nWHY?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don\\'t see an \\'f\\' in the dictionary, so how can you form \\'fcmz\\'?\\n\\nGiven an array of strings words representing an English Dictionary, return the longest word in words that can be built one character at a time by other words in words."
                    }
                ]
            },
            {
                "id": 1571898,
                "content": [
                    {
                        "username": "ChristoPalas",
                        "content": "How can this testcase be correct?\\nInput\\n[\"yo\",\"ew\",\"fc\",\"zrc\",\"yodn\",\"fcm\",\"qm\",\"qmo\",\"fcmz\",\"z\",\"ewq\",\"yod\",\"ewqz\",\"y\"]\\nOutput\\n\"ewqz\"\\nExpected\\n\"yodn\"\\n\\n\"ewqz\" can be built from \"ewq\" and is the same length with \"yodn\" but lexicographically smaller than it."
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@ChristoPalas](/ChristoPalas) for word \"ewqz\", \\'e\\' is not present in word array so that cannot be the answer whereas in case of \"yodn\", each of \\'yodn\\', \\'yod\\', \\'yo\\' and \\'y\\' are present so the correct answer is \"yodn\" for this testcase. Hope its clear."
                    },
                    {
                        "username": "iChuan",
                        "content": "Totally lost myself in this description. Thank you!"
                    },
                    {
                        "username": "vmk1802",
                        "content": "Can anyone explain why this answer is wrong?\\n\\n## Input:\\n[\"yo\",\"ew\",\"fc\",\"zrc\",\"yodn\",\"fcm\",\"qm\",\"qmo\",\"fcmz\",\"z\",\"ewq\",\"yod\",\"ewqz\",\"y\"]\\n\\n## Output:\\n\"ewqz\"\\n\\n## Expected:\\n\"yodn\"\\n\\nProblem clearly states, \" ***If there is more than one possible answer, return the longest word with the smallest lexicographical order.*** \"\\nLexicographically \\'e\\' is smaller than \\'y\\'. Both \"ewqz\" & \"yodn\" are same length. So my expectation is \"ewqz\" should be the answer.\\n\\nAm I missing something? ;-/"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@AdityaShaw](/AdityaShaw)  I believe you are incorrect. I think the reason ewqz is not correct is that it cannot be traced back to a single character. In other words, there is no \\'e\\' in the array so it is a non-starter. Your explanantion would also work, because you would always pick the word that can be traced back to a single charter if there is one. But ewqz would also not be the right answer if yodn wasn\\'t an option."
                    },
                    {
                        "username": "AdityaShaw",
                        "content": "\"y\"=>\"yo\"=>\"yod\"=>\"yodn\"\\n\"ew\"=>\"ewq\"=>\"ewqz\"\\nThe length of words that leads to the formation of the word \"yodn\" is greater compared to \"ewqz\". Hence, that turn out to be the preferred solution."
                    },
                    {
                        "username": "vfvf4002",
                        "content": "In the question description, it is stated that we have to make the words one character at a time.\\nSo given an array:\\n[\"o\", \"or\", \"wor\", \"worl\", \"world\"],\\nwe should be able to make the word \"world\". But, the answer of this comes out to be \"or\" as they are considering only cases wherein the previous word is a prefix of the fiven word."
                    },
                    {
                        "username": "parameterNextNaive",
                        "content": "For people who are not able to understand this question, read this: https://leetcode.com/problems/longest-word-with-all-prefixes/description/.\\n\\nThey are exactly same questions with different wording."
                    },
                    {
                        "username": "jinlibao",
                        "content": "According to the description, \"find the longest word in words that can be built one character at a time by other words in words\", technically, `[\"d\", \"ld\", \"rld\", \"orld\", \"world\"]` also works as `[\"w\",\"wo\",\"wor\",\"worl\", \"world\"]`, right? But according to the output of \"Run Code\", it is not. :("
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Note that the word should be built from left to right with each additional character being added to the end of a previous word. "
                    },
                    {
                        "username": "learnSomeCode",
                        "content": "can some one explain why the solution to this test case is \"eyj\" instead of \"eyjuoi\"?\\n[\"ogz\",\"eyj\",\"e\",\"ey\",\"hmn\",\"v\",\"hm\",\"ogznkb\",\"ogzn\",\"hmnm\",\"eyjuo\",\"vuq\",\"ogznk\",\"og\",\"eyjuoi\",\"d\"]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@drc354](/drc354) A bit late, but you cannot start at \\'og\\', you have to start at \\'o\\', and there is no \\'o\\' in the dictionary"
                    },
                    {
                        "username": "drc354",
                        "content": "[@Mister_CK](/Mister_CK) Why would the answer not be ogznkb considering that in the test case, there are og -> ogz -> ogzn -> ognzk -> ognzkb"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "\\'eyju\\' is not part of the array if I see correctly, so you can never get to eyjuoi "
                    },
                    {
                        "username": "pansari",
                        "content": "[\"wo\",\"wor\",\"worl\",\"world\"]\\nMy answer = \"world\"\\nAnswer by OJ = \"\"\\nThis can be ``` built one character at a time by other words in words.```"
                    },
                    {
                        "username": "kaxagvimraze",
                        "content": "can anyone help because my code works but fails on last test case (59/59) where there is no input and i got time limit exceeded, so is there a big input and I have a problem with algorithm or i may check existence if an input?"
                    },
                    {
                        "username": "refleks1a",
                        "content": "input:\\n[\"yo\",\"ew\",\"fc\",\"zrc\",\"yodn\",\"fcm\",\"qm\",\"qmo\",\"fcmz\",\"z\",\"ewq\",\"yod\",\"ewqz\",\"y\"]\\noutput:\\n\"fcmz\"\\nexpected:\\n\"yodn\"\\n\\n\"fcmz\" is lexicographically smaller than \"yodn\" but the correct answer is \"yodn\".\\nWHY?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don\\'t see an \\'f\\' in the dictionary, so how can you form \\'fcmz\\'?\\n\\nGiven an array of strings words representing an English Dictionary, return the longest word in words that can be built one character at a time by other words in words."
                    }
                ]
            },
            {
                "id": 2035861,
                "content": [
                    {
                        "username": "ChristoPalas",
                        "content": "How can this testcase be correct?\\nInput\\n[\"yo\",\"ew\",\"fc\",\"zrc\",\"yodn\",\"fcm\",\"qm\",\"qmo\",\"fcmz\",\"z\",\"ewq\",\"yod\",\"ewqz\",\"y\"]\\nOutput\\n\"ewqz\"\\nExpected\\n\"yodn\"\\n\\n\"ewqz\" can be built from \"ewq\" and is the same length with \"yodn\" but lexicographically smaller than it."
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@ChristoPalas](/ChristoPalas) for word \"ewqz\", \\'e\\' is not present in word array so that cannot be the answer whereas in case of \"yodn\", each of \\'yodn\\', \\'yod\\', \\'yo\\' and \\'y\\' are present so the correct answer is \"yodn\" for this testcase. Hope its clear."
                    },
                    {
                        "username": "iChuan",
                        "content": "Totally lost myself in this description. Thank you!"
                    },
                    {
                        "username": "vmk1802",
                        "content": "Can anyone explain why this answer is wrong?\\n\\n## Input:\\n[\"yo\",\"ew\",\"fc\",\"zrc\",\"yodn\",\"fcm\",\"qm\",\"qmo\",\"fcmz\",\"z\",\"ewq\",\"yod\",\"ewqz\",\"y\"]\\n\\n## Output:\\n\"ewqz\"\\n\\n## Expected:\\n\"yodn\"\\n\\nProblem clearly states, \" ***If there is more than one possible answer, return the longest word with the smallest lexicographical order.*** \"\\nLexicographically \\'e\\' is smaller than \\'y\\'. Both \"ewqz\" & \"yodn\" are same length. So my expectation is \"ewqz\" should be the answer.\\n\\nAm I missing something? ;-/"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@AdityaShaw](/AdityaShaw)  I believe you are incorrect. I think the reason ewqz is not correct is that it cannot be traced back to a single character. In other words, there is no \\'e\\' in the array so it is a non-starter. Your explanantion would also work, because you would always pick the word that can be traced back to a single charter if there is one. But ewqz would also not be the right answer if yodn wasn\\'t an option."
                    },
                    {
                        "username": "AdityaShaw",
                        "content": "\"y\"=>\"yo\"=>\"yod\"=>\"yodn\"\\n\"ew\"=>\"ewq\"=>\"ewqz\"\\nThe length of words that leads to the formation of the word \"yodn\" is greater compared to \"ewqz\". Hence, that turn out to be the preferred solution."
                    },
                    {
                        "username": "vfvf4002",
                        "content": "In the question description, it is stated that we have to make the words one character at a time.\\nSo given an array:\\n[\"o\", \"or\", \"wor\", \"worl\", \"world\"],\\nwe should be able to make the word \"world\". But, the answer of this comes out to be \"or\" as they are considering only cases wherein the previous word is a prefix of the fiven word."
                    },
                    {
                        "username": "parameterNextNaive",
                        "content": "For people who are not able to understand this question, read this: https://leetcode.com/problems/longest-word-with-all-prefixes/description/.\\n\\nThey are exactly same questions with different wording."
                    },
                    {
                        "username": "jinlibao",
                        "content": "According to the description, \"find the longest word in words that can be built one character at a time by other words in words\", technically, `[\"d\", \"ld\", \"rld\", \"orld\", \"world\"]` also works as `[\"w\",\"wo\",\"wor\",\"worl\", \"world\"]`, right? But according to the output of \"Run Code\", it is not. :("
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Note that the word should be built from left to right with each additional character being added to the end of a previous word. "
                    },
                    {
                        "username": "learnSomeCode",
                        "content": "can some one explain why the solution to this test case is \"eyj\" instead of \"eyjuoi\"?\\n[\"ogz\",\"eyj\",\"e\",\"ey\",\"hmn\",\"v\",\"hm\",\"ogznkb\",\"ogzn\",\"hmnm\",\"eyjuo\",\"vuq\",\"ogznk\",\"og\",\"eyjuoi\",\"d\"]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@drc354](/drc354) A bit late, but you cannot start at \\'og\\', you have to start at \\'o\\', and there is no \\'o\\' in the dictionary"
                    },
                    {
                        "username": "drc354",
                        "content": "[@Mister_CK](/Mister_CK) Why would the answer not be ogznkb considering that in the test case, there are og -> ogz -> ogzn -> ognzk -> ognzkb"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "\\'eyju\\' is not part of the array if I see correctly, so you can never get to eyjuoi "
                    },
                    {
                        "username": "pansari",
                        "content": "[\"wo\",\"wor\",\"worl\",\"world\"]\\nMy answer = \"world\"\\nAnswer by OJ = \"\"\\nThis can be ``` built one character at a time by other words in words.```"
                    },
                    {
                        "username": "kaxagvimraze",
                        "content": "can anyone help because my code works but fails on last test case (59/59) where there is no input and i got time limit exceeded, so is there a big input and I have a problem with algorithm or i may check existence if an input?"
                    },
                    {
                        "username": "refleks1a",
                        "content": "input:\\n[\"yo\",\"ew\",\"fc\",\"zrc\",\"yodn\",\"fcm\",\"qm\",\"qmo\",\"fcmz\",\"z\",\"ewq\",\"yod\",\"ewqz\",\"y\"]\\noutput:\\n\"fcmz\"\\nexpected:\\n\"yodn\"\\n\\n\"fcmz\" is lexicographically smaller than \"yodn\" but the correct answer is \"yodn\".\\nWHY?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don\\'t see an \\'f\\' in the dictionary, so how can you form \\'fcmz\\'?\\n\\nGiven an array of strings words representing an English Dictionary, return the longest word in words that can be built one character at a time by other words in words."
                    }
                ]
            },
            {
                "id": 1972875,
                "content": [
                    {
                        "username": "ChristoPalas",
                        "content": "How can this testcase be correct?\\nInput\\n[\"yo\",\"ew\",\"fc\",\"zrc\",\"yodn\",\"fcm\",\"qm\",\"qmo\",\"fcmz\",\"z\",\"ewq\",\"yod\",\"ewqz\",\"y\"]\\nOutput\\n\"ewqz\"\\nExpected\\n\"yodn\"\\n\\n\"ewqz\" can be built from \"ewq\" and is the same length with \"yodn\" but lexicographically smaller than it."
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@ChristoPalas](/ChristoPalas) for word \"ewqz\", \\'e\\' is not present in word array so that cannot be the answer whereas in case of \"yodn\", each of \\'yodn\\', \\'yod\\', \\'yo\\' and \\'y\\' are present so the correct answer is \"yodn\" for this testcase. Hope its clear."
                    },
                    {
                        "username": "iChuan",
                        "content": "Totally lost myself in this description. Thank you!"
                    },
                    {
                        "username": "vmk1802",
                        "content": "Can anyone explain why this answer is wrong?\\n\\n## Input:\\n[\"yo\",\"ew\",\"fc\",\"zrc\",\"yodn\",\"fcm\",\"qm\",\"qmo\",\"fcmz\",\"z\",\"ewq\",\"yod\",\"ewqz\",\"y\"]\\n\\n## Output:\\n\"ewqz\"\\n\\n## Expected:\\n\"yodn\"\\n\\nProblem clearly states, \" ***If there is more than one possible answer, return the longest word with the smallest lexicographical order.*** \"\\nLexicographically \\'e\\' is smaller than \\'y\\'. Both \"ewqz\" & \"yodn\" are same length. So my expectation is \"ewqz\" should be the answer.\\n\\nAm I missing something? ;-/"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@AdityaShaw](/AdityaShaw)  I believe you are incorrect. I think the reason ewqz is not correct is that it cannot be traced back to a single character. In other words, there is no \\'e\\' in the array so it is a non-starter. Your explanantion would also work, because you would always pick the word that can be traced back to a single charter if there is one. But ewqz would also not be the right answer if yodn wasn\\'t an option."
                    },
                    {
                        "username": "AdityaShaw",
                        "content": "\"y\"=>\"yo\"=>\"yod\"=>\"yodn\"\\n\"ew\"=>\"ewq\"=>\"ewqz\"\\nThe length of words that leads to the formation of the word \"yodn\" is greater compared to \"ewqz\". Hence, that turn out to be the preferred solution."
                    },
                    {
                        "username": "vfvf4002",
                        "content": "In the question description, it is stated that we have to make the words one character at a time.\\nSo given an array:\\n[\"o\", \"or\", \"wor\", \"worl\", \"world\"],\\nwe should be able to make the word \"world\". But, the answer of this comes out to be \"or\" as they are considering only cases wherein the previous word is a prefix of the fiven word."
                    },
                    {
                        "username": "parameterNextNaive",
                        "content": "For people who are not able to understand this question, read this: https://leetcode.com/problems/longest-word-with-all-prefixes/description/.\\n\\nThey are exactly same questions with different wording."
                    },
                    {
                        "username": "jinlibao",
                        "content": "According to the description, \"find the longest word in words that can be built one character at a time by other words in words\", technically, `[\"d\", \"ld\", \"rld\", \"orld\", \"world\"]` also works as `[\"w\",\"wo\",\"wor\",\"worl\", \"world\"]`, right? But according to the output of \"Run Code\", it is not. :("
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Note that the word should be built from left to right with each additional character being added to the end of a previous word. "
                    },
                    {
                        "username": "learnSomeCode",
                        "content": "can some one explain why the solution to this test case is \"eyj\" instead of \"eyjuoi\"?\\n[\"ogz\",\"eyj\",\"e\",\"ey\",\"hmn\",\"v\",\"hm\",\"ogznkb\",\"ogzn\",\"hmnm\",\"eyjuo\",\"vuq\",\"ogznk\",\"og\",\"eyjuoi\",\"d\"]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@drc354](/drc354) A bit late, but you cannot start at \\'og\\', you have to start at \\'o\\', and there is no \\'o\\' in the dictionary"
                    },
                    {
                        "username": "drc354",
                        "content": "[@Mister_CK](/Mister_CK) Why would the answer not be ogznkb considering that in the test case, there are og -> ogz -> ogzn -> ognzk -> ognzkb"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "\\'eyju\\' is not part of the array if I see correctly, so you can never get to eyjuoi "
                    },
                    {
                        "username": "pansari",
                        "content": "[\"wo\",\"wor\",\"worl\",\"world\"]\\nMy answer = \"world\"\\nAnswer by OJ = \"\"\\nThis can be ``` built one character at a time by other words in words.```"
                    },
                    {
                        "username": "kaxagvimraze",
                        "content": "can anyone help because my code works but fails on last test case (59/59) where there is no input and i got time limit exceeded, so is there a big input and I have a problem with algorithm or i may check existence if an input?"
                    },
                    {
                        "username": "refleks1a",
                        "content": "input:\\n[\"yo\",\"ew\",\"fc\",\"zrc\",\"yodn\",\"fcm\",\"qm\",\"qmo\",\"fcmz\",\"z\",\"ewq\",\"yod\",\"ewqz\",\"y\"]\\noutput:\\n\"fcmz\"\\nexpected:\\n\"yodn\"\\n\\n\"fcmz\" is lexicographically smaller than \"yodn\" but the correct answer is \"yodn\".\\nWHY?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don\\'t see an \\'f\\' in the dictionary, so how can you form \\'fcmz\\'?\\n\\nGiven an array of strings words representing an English Dictionary, return the longest word in words that can be built one character at a time by other words in words."
                    }
                ]
            },
            {
                "id": 1920386,
                "content": [
                    {
                        "username": "ChristoPalas",
                        "content": "How can this testcase be correct?\\nInput\\n[\"yo\",\"ew\",\"fc\",\"zrc\",\"yodn\",\"fcm\",\"qm\",\"qmo\",\"fcmz\",\"z\",\"ewq\",\"yod\",\"ewqz\",\"y\"]\\nOutput\\n\"ewqz\"\\nExpected\\n\"yodn\"\\n\\n\"ewqz\" can be built from \"ewq\" and is the same length with \"yodn\" but lexicographically smaller than it."
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@ChristoPalas](/ChristoPalas) for word \"ewqz\", \\'e\\' is not present in word array so that cannot be the answer whereas in case of \"yodn\", each of \\'yodn\\', \\'yod\\', \\'yo\\' and \\'y\\' are present so the correct answer is \"yodn\" for this testcase. Hope its clear."
                    },
                    {
                        "username": "iChuan",
                        "content": "Totally lost myself in this description. Thank you!"
                    },
                    {
                        "username": "vmk1802",
                        "content": "Can anyone explain why this answer is wrong?\\n\\n## Input:\\n[\"yo\",\"ew\",\"fc\",\"zrc\",\"yodn\",\"fcm\",\"qm\",\"qmo\",\"fcmz\",\"z\",\"ewq\",\"yod\",\"ewqz\",\"y\"]\\n\\n## Output:\\n\"ewqz\"\\n\\n## Expected:\\n\"yodn\"\\n\\nProblem clearly states, \" ***If there is more than one possible answer, return the longest word with the smallest lexicographical order.*** \"\\nLexicographically \\'e\\' is smaller than \\'y\\'. Both \"ewqz\" & \"yodn\" are same length. So my expectation is \"ewqz\" should be the answer.\\n\\nAm I missing something? ;-/"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@AdityaShaw](/AdityaShaw)  I believe you are incorrect. I think the reason ewqz is not correct is that it cannot be traced back to a single character. In other words, there is no \\'e\\' in the array so it is a non-starter. Your explanantion would also work, because you would always pick the word that can be traced back to a single charter if there is one. But ewqz would also not be the right answer if yodn wasn\\'t an option."
                    },
                    {
                        "username": "AdityaShaw",
                        "content": "\"y\"=>\"yo\"=>\"yod\"=>\"yodn\"\\n\"ew\"=>\"ewq\"=>\"ewqz\"\\nThe length of words that leads to the formation of the word \"yodn\" is greater compared to \"ewqz\". Hence, that turn out to be the preferred solution."
                    },
                    {
                        "username": "vfvf4002",
                        "content": "In the question description, it is stated that we have to make the words one character at a time.\\nSo given an array:\\n[\"o\", \"or\", \"wor\", \"worl\", \"world\"],\\nwe should be able to make the word \"world\". But, the answer of this comes out to be \"or\" as they are considering only cases wherein the previous word is a prefix of the fiven word."
                    },
                    {
                        "username": "parameterNextNaive",
                        "content": "For people who are not able to understand this question, read this: https://leetcode.com/problems/longest-word-with-all-prefixes/description/.\\n\\nThey are exactly same questions with different wording."
                    },
                    {
                        "username": "jinlibao",
                        "content": "According to the description, \"find the longest word in words that can be built one character at a time by other words in words\", technically, `[\"d\", \"ld\", \"rld\", \"orld\", \"world\"]` also works as `[\"w\",\"wo\",\"wor\",\"worl\", \"world\"]`, right? But according to the output of \"Run Code\", it is not. :("
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Note that the word should be built from left to right with each additional character being added to the end of a previous word. "
                    },
                    {
                        "username": "learnSomeCode",
                        "content": "can some one explain why the solution to this test case is \"eyj\" instead of \"eyjuoi\"?\\n[\"ogz\",\"eyj\",\"e\",\"ey\",\"hmn\",\"v\",\"hm\",\"ogznkb\",\"ogzn\",\"hmnm\",\"eyjuo\",\"vuq\",\"ogznk\",\"og\",\"eyjuoi\",\"d\"]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@drc354](/drc354) A bit late, but you cannot start at \\'og\\', you have to start at \\'o\\', and there is no \\'o\\' in the dictionary"
                    },
                    {
                        "username": "drc354",
                        "content": "[@Mister_CK](/Mister_CK) Why would the answer not be ogznkb considering that in the test case, there are og -> ogz -> ogzn -> ognzk -> ognzkb"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "\\'eyju\\' is not part of the array if I see correctly, so you can never get to eyjuoi "
                    },
                    {
                        "username": "pansari",
                        "content": "[\"wo\",\"wor\",\"worl\",\"world\"]\\nMy answer = \"world\"\\nAnswer by OJ = \"\"\\nThis can be ``` built one character at a time by other words in words.```"
                    },
                    {
                        "username": "kaxagvimraze",
                        "content": "can anyone help because my code works but fails on last test case (59/59) where there is no input and i got time limit exceeded, so is there a big input and I have a problem with algorithm or i may check existence if an input?"
                    },
                    {
                        "username": "refleks1a",
                        "content": "input:\\n[\"yo\",\"ew\",\"fc\",\"zrc\",\"yodn\",\"fcm\",\"qm\",\"qmo\",\"fcmz\",\"z\",\"ewq\",\"yod\",\"ewqz\",\"y\"]\\noutput:\\n\"fcmz\"\\nexpected:\\n\"yodn\"\\n\\n\"fcmz\" is lexicographically smaller than \"yodn\" but the correct answer is \"yodn\".\\nWHY?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don\\'t see an \\'f\\' in the dictionary, so how can you form \\'fcmz\\'?\\n\\nGiven an array of strings words representing an English Dictionary, return the longest word in words that can be built one character at a time by other words in words."
                    }
                ]
            }
        ]
    }
]