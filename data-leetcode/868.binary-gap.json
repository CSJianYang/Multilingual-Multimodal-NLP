[
    {
        "title": "Binary Gap",
        "question_content": "Given a positive integer n, find and return the longest distance between any two adjacent 1's in the binary representation of n. If there are no two adjacent 1's, return 0.\nTwo 1's are adjacent if there are only 0's separating them (possibly no 0's). The distance between two 1's is the absolute difference between their bit positions. For example, the two 1's in \"1001\" have a distance of 3.\n&nbsp;\nExample 1:\n\nInput: n = 22\nOutput: 2\nExplanation: 22 in binary is \"10110\".\nThe first adjacent pair of 1's is \"10110\" with a distance of 2.\nThe second adjacent pair of 1's is \"10110\" with a distance of 1.\nThe answer is the largest of these two distances, which is 2.\nNote that \"10110\" is not a valid pair since there is a 1 separating the two 1's underlined.\n\nExample 2:\n\nInput: n = 8\nOutput: 0\nExplanation: 8 in binary is \"1000\".\nThere are not any adjacent pairs of 1's in the binary representation of 8, so we return 0.\n\nExample 3:\n\nInput: n = 5\nOutput: 2\nExplanation: 5 in binary is \"101\".\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 109",
        "solutions": [
            {
                "id": 149835,
                "title": "c-java-python-dividing-by-2",
                "content": "One pass on `N` in binary from right to left.\\n`d` means the distance from the last 1 position.\\n`d` is initial to a small enough value `-32`\\n\\n**C++:**\\n```\\n    int binaryGap(int N) {\\n        int res = 0;\\n        for (int d = -32; N; N /= 2, d++)\\n            if (N % 2) res = max(res, d), d = 0;\\n        return res;\\n    }\\n```\\n\\n**Java:**\\n```\\n    public int binaryGap(int N) {\\n        int res = 0;\\n        for (int d = -32; N > 0; N /= 2, d++)\\n            if (N % 2 == 1) {\\n                res = Math.max(res, d);\\n                d = 0;\\n            }\\n        return res;\\n    }\\n```\\n**Python:**\\n```\\n    def binaryGap(self, N):\\n        index = [i for i, v in enumerate(bin(N)) if v == \\'1\\']\\n        return max([b - a for a, b in zip(index, index[1:])] or [0])\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    int binaryGap(int N) {\\n        int res = 0;\\n        for (int d = -32; N; N /= 2, d++)\\n            if (N % 2) res = max(res, d), d = 0;\\n        return res;\\n    }\\n```\n```\\n    public int binaryGap(int N) {\\n        int res = 0;\\n        for (int d = -32; N > 0; N /= 2, d++)\\n            if (N % 2 == 1) {\\n                res = Math.max(res, d);\\n                d = 0;\\n            }\\n        return res;\\n    }\\n```\n```\\n    def binaryGap(self, N):\\n        index = [i for i, v in enumerate(bin(N)) if v == \\'1\\']\\n        return max([b - a for a, b in zip(index, index[1:])] or [0])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 149945,
                "title": "simple-java-10-ms",
                "content": "```java\\nclass Solution {\\n    public int binaryGap(int N) {\\n        int max = 0;\\n        int pos = 0;\\n        int lastPos = -1;\\n        while (N != 0) {\\n            pos++;\\n            if ((N & 1) == 1) {\\n                if (lastPos != -1) {\\n                    max = Math.max(max, pos-lastPos);\\n                }\\n                lastPos = pos;\\n            }\\n            N >>= 1;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int binaryGap(int N) {\\n        int max = 0;\\n        int pos = 0;\\n        int lastPos = -1;\\n        while (N != 0) {\\n            pos++;\\n            if ((N & 1) == 1) {\\n                if (lastPos != -1) {\\n                    max = Math.max(max, pos-lastPos);\\n                }\\n                lastPos = pos;\\n            }\\n            N >>= 1;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 149834,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def binaryGap(self, N):\\n        pre = dist = 0\\n        for i, c in enumerate(bin(N)[2:]):\\n            if c == \"1\":\\n                dist = max(dist, i - pre)\\n                pre = i\\n        return dist\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, N):\\n        pre = dist = 0\\n        for i, c in enumerate(bin(N)[2:]):\\n            if c == \"1\":\\n                dist = max(dist, i - pre)\\n                pre = i\\n        return dist\\n```",
                "codeTag": "Java"
            },
            {
                "id": 358693,
                "title": "868-javascript-1-line-solution",
                "content": "> Runtime: **48 ms**, faster than *95.29%* of JavaScript online submissions\\n> Memory Usage: **33.9 MB**, less than *100.00%* of JavaScript online submissions\\n\\n```javascript\\n/**\\n * @param {number} N\\n * @return {number}\\n */\\nconst binaryGap = N =>\\n  Math.max(\\n    0,\\n    ...N.toString(2)\\n      .split(\\'1\\')\\n      .slice(1, -1)\\n      .map(gap => gap.length + 1),\\n  );\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {number} N\\n * @return {number}\\n */\\nconst binaryGap = N =>\\n  Math.max(\\n    0,\\n    ...N.toString(2)\\n      .split(\\'1\\')\\n      .slice(1, -1)\\n      .map(gap => gap.length + 1),\\n  );\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 151143,
                "title": "python-1-line-solution",
                "content": "If only one \\'1\\' exists in the binary, the number must be 2^N where N is a natural number and we return 0. Otherwise, given the binary, we strip \\'0\\' from both sides and split the string into sections by \\'1\\', and return the max length of consecutive \\'0\\'s plus 1.\\n```\\nclass Solution:\\n    def binaryGap(self, N):\\n        return max(len(c) for c in bin(N)[2:].strip(\\'0\\').split(\\'1\\')) + 1 if N & (N-1) else 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, N):\\n        return max(len(c) for c in bin(N)[2:].strip(\\'0\\').split(\\'1\\')) + 1 if N & (N-1) else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1382476,
                "title": "c-0-ms-simple-o-32",
                "content": "```\\nclass Solution {\\npublic:\\n\\tint binaryGap(int n) {\\n\\t\\tint lastone = 32;\\n\\t\\tint ans = 0;\\n\\t\\tfor (int i = 0; i < 32; i++) {\\n\\t\\t\\tif (n & (1 << i)) {\\n\\t\\t\\t\\tans = max(ans, i - lastone);\\n\\t\\t\\t\\tlastone = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint binaryGap(int n) {\\n\\t\\tint lastone = 32;\\n\\t\\tint ans = 0;\\n\\t\\tfor (int i = 0; i < 32; i++) {\\n\\t\\t\\tif (n & (1 << i)) {\\n\\t\\t\\t\\tans = max(ans, i - lastone);\\n\\t\\t\\t\\tlastone = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 613498,
                "title": "java-solution-100-with-explanation",
                "content": "The answer key to this problem uses bitwise from the start -- which is not where my mind immediately went; nor did my mind think to use linear space in the naive implementation (since we only care about space between consecutive 1\\'s). Hopefully this solution will help you think through the problem logically.\\n\\nThe first time I did the problem, I came up with a linear time solution that used linear space.\\n\\nRuntime: 1 ms, faster than 42.91% of Java online submissions for Binary Gap.\\nMemory Usage: 36 MB, less than 7.14% of Java online submissions for Binary Gap.\\n```java\\nclass Solution {\\n    public int binaryGap(int N) {\\n        String binaryRepresentation = Integer.toBinaryString(N); // O(n) space\\n        int longestDistance = 0;\\n        int indexOne = binaryRepresentation.indexOf(\\'1\\');\\n        for (int i = 1; i < binaryRepresentation.length(); ++i) { // O(n) time\\n            if (binaryRepresentation.charAt(i) == \\'1\\') {\\n                longestDistance = Math.max(longestDistance, i - indexOne); // greedy\\n                indexOne = i; // update the index of the most recently seen \\'1\\'\\n            }\\n        }\\n        \\n        return longestDistance;\\n    }\\n}\\n```\\n\\nI then realized this can be done faster since numbers are already stored as their binary representations. We can use bitwise operators, specifically, the bitwise right shift operator. All this means is take the rightmost bit off the binary representation during each iteration. This results in a solution with logarithmic time and constant space.\\n\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Binary Gap.\\nMemory Usage: 36.1 MB, less than 7.14% of Java online submissions for Binary Gap.\\n\\n```java\\nclass Solution {\\n    public int binaryGap(int N) {\\n        int indexOne = -1, longestDistance = 0;\\n        for (int i = 0; i < 32; ++i) { // 32 bit number so 32 iterations, could also use Integer.toBinaryString(N).length() but the time it takes to convert to binary string is longer than just doing extra iterations for numbers smaller than 32 bits in size\\n            if (((N >> i) & 1) == 1) { // take the right most bit, use the bitwise \\'AND\\' operator, if result is 1 then bit was a 1\\n                if (indexOne != -1) // only the first 1 will not trigger this conditional\\n                    longestDistance = Math.max(longestDistance, i - indexOne); // greedy\\n                indexOne = i; // update the index of the most recently seen \\'1\\'\\n            }\\n        }\\n\\n        return longestDistance;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Bit Manipulation"
                ],
                "code": "```java\\nclass Solution {\\n    public int binaryGap(int N) {\\n        String binaryRepresentation = Integer.toBinaryString(N); // O(n) space\\n        int longestDistance = 0;\\n        int indexOne = binaryRepresentation.indexOf(\\'1\\');\\n        for (int i = 1; i < binaryRepresentation.length(); ++i) { // O(n) time\\n            if (binaryRepresentation.charAt(i) == \\'1\\') {\\n                longestDistance = Math.max(longestDistance, i - indexOne); // greedy\\n                indexOne = i; // update the index of the most recently seen \\'1\\'\\n            }\\n        }\\n        \\n        return longestDistance;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int binaryGap(int N) {\\n        int indexOne = -1, longestDistance = 0;\\n        for (int i = 0; i < 32; ++i) { // 32 bit number so 32 iterations, could also use Integer.toBinaryString(N).length() but the time it takes to convert to binary string is longer than just doing extra iterations for numbers smaller than 32 bits in size\\n            if (((N >> i) & 1) == 1) { // take the right most bit, use the bitwise \\'AND\\' operator, if result is 1 then bit was a 1\\n                if (indexOne != -1) // only the first 1 will not trigger this conditional\\n                    longestDistance = Math.max(longestDistance, i - indexOne); // greedy\\n                indexOne = i; // update the index of the most recently seen \\'1\\'\\n            }\\n        }\\n\\n        return longestDistance;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1519571,
                "title": "simple-python-solution-o-log-n-t-o-log-n-s-explanation",
                "content": "We first convert the number to binary and then find the 1\\'s in the binary representation. We store the location of adjacent 1\\'s in the variables i and j. The maximum difference between these successive 1\\'s is the answer. \\nA number \\'n\\' has (log n) bits, hence the time complexity is log(n) and since we are storing these bits as a string, the space complexity is also log(n).\\n\\n```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        bi = bin(n)[2:]\\n        maxi = 0\\n        i = 0\\n        j = 0\\n        \\n        for x in range(1, len(bi)):\\n            if bi[x] == \\'1\\':\\n                i = j\\n                j = x\\n                maxi = max(maxi, j - i)\\n                \\n        return maxi\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        bi = bin(n)[2:]\\n        maxi = 0\\n        i = 0\\n        j = 0\\n        \\n        for x in range(1, len(bi)):\\n            if bi[x] == \\'1\\':\\n                i = j\\n                j = x\\n                maxi = max(maxi, j - i)\\n                \\n        return maxi\\n```",
                "codeTag": "Java"
            },
            {
                "id": 380567,
                "title": "easy-c-solution-0ms-bit-manipulation",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Binary Gap.\\nMemory Usage: 8.2 MB, less than 100.00% of C++ online submissions for Binary Gap.\\n\\n```\\nint binaryGap(int N) {\\n        \\n        int maxGap = 0;\\n        int i = 1;\\n        int last = -1;\\n        \\n        while(N > 0)\\n        {\\n            int bit = N%2;\\n            if(bit == 1)\\n            {\\n                if(last >= 0)\\n                    maxGap = max(maxGap, i - last);\\n                last = i;\\n            }\\n            \\n            i++;\\n            N /= 2;\\n        }\\n        \\n        return maxGap;\\n    }\\n\\t```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint binaryGap(int N) {\\n        \\n        int maxGap = 0;\\n        int i = 1;\\n        int last = -1;\\n        \\n        while(N > 0)\\n        {\\n            int bit = N%2;\\n            if(bit == 1)\\n            {\\n                if(last >= 0)\\n                    maxGap = max(maxGap, i - last);\\n                last = i;\\n            }\\n            \\n            i++;\\n            N /= 2;\\n        }\\n        \\n        return maxGap;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1321031,
                "title": "intuitive-java-solution-with-explanation",
                "content": "We will first convert `n` into a character array which represents the binary string of `n`. We will then iterate over this array and store the indices of where a 1 occurs in this character array. If there was only one 1 in the binary string representation of `n` then we return 0 as the problem statement says. We then iterate over `indices` and calculate the distance of a 1 with its adjacent neighbor and update `ans` accordingly.\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        char[] bits = Integer.toBinaryString(n).toCharArray();\\n        List<Integer> indices = new ArrayList<>();\\n        for (int i = 0; i < bits.length; i++) {\\n            if (bits[i] == \\'1\\') indices.add(i);\\n        }\\n        if (indices.size() == 1) return 0;\\n        int ans = 0;\\n        for (int i = 0; i < indices.size()-1; i++) {\\n            ans = Math.max(ans, indices.get(i+1)-indices.get(i));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        char[] bits = Integer.toBinaryString(n).toCharArray();\\n        List<Integer> indices = new ArrayList<>();\\n        for (int i = 0; i < bits.length; i++) {\\n            if (bits[i] == \\'1\\') indices.add(i);\\n        }\\n        if (indices.size() == 1) return 0;\\n        int ans = 0;\\n        for (int i = 0; i < indices.size()-1; i++) {\\n            ans = Math.max(ans, indices.get(i+1)-indices.get(i));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481624,
                "title": "easy-solution-finding-the-total-number-of-set-bits",
                "content": "\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint binaryGap(int n) {\\n\\t\\t\\tint i = 0;\\n\\t\\t\\tvector<int> aux;\\n\\t\\t\\twhile(n!=0){\\n\\t\\t\\t\\tif((n & 1) == 1)\\n\\t\\t\\t\\t\\taux.push_back(i);\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tn = n>>1;\\n\\t\\t\\t}\\n\\t\\t\\tif(aux.size()==1)\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\tint m = INT_MIN;\\n\\t\\t\\tfor(int x=1;x<aux.size();x++){\\n\\t\\t\\t\\tm = max(m,(aux[x]-aux[x-1]));\\n        }\\n\\t\\t\\treturn m;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint binaryGap(int n) {\\n\\t\\t\\tint i = 0;\\n\\t\\t\\tvector<int> aux;\\n\\t\\t\\twhile(n!=0){\\n\\t\\t\\t\\tif((n & 1) == 1)\\n\\t\\t\\t\\t\\taux.push_back(i);\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tn = n>>1;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1129220,
                "title": "java-0ms",
                "content": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int curr = -1;\\n        int max = 0;\\n        \\n        while(n%2==0)\\n            n /= 2;\\n        \\n        while(n > 0) {\\n            if(n%2 == 1) {\\n                curr++;\\n                max = Math.max(curr, max);\\n                curr = 0;\\n            } else {\\n                curr++;\\n            }\\n            n /= 2;\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int curr = -1;\\n        int max = 0;\\n        \\n        while(n%2==0)\\n            n /= 2;\\n        \\n        while(n > 0) {\\n            if(n%2 == 1) {\\n                curr++;\\n                max = Math.max(curr, max);\\n                curr = 0;\\n            } else {\\n                curr++;\\n            }\\n            n /= 2;\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 508760,
                "title": "python3-beats-96-time-100-memory",
                "content": "\\'\\'\\'\\n\\n\\n    class Solution:\\n\\tdef binaryGap(self, N: int) -> int:\\n        \\n\\t\\tl = bin(N)\\n        p1, p2 = 0, 0\\n        dtc = 0\\n    \\n        for i in range(2, len(l)):\\n            if l[i] == \\'1\\':\\n                if p1 == 0:\\n                    p1 = i\\n                else:\\n                    p2 = i\\n                    dtc = max((p2-p1), dtc)\\n                    p1 = p2\\n                \\n        return dtc\\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\'\\'\\'\\n\\n\\n    class Solution:\\n\\tdef binaryGap(self, N: int) -> int:\\n        \\n\\t\\tl = bin(N)\\n        p1, p2 = 0, 0\\n        dtc = 0\\n    \\n        for i in range(2, len(l)):\\n            if l[i] == \\'1\\':\\n                if p1 == 0:\\n                    p1 = i\\n                else:\\n                    p2 = i\\n                    dtc = max((p2-p1), dtc)\\n                    p1 = p2\\n                \\n        return dtc\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 2913701,
                "title": "java-1-ms-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        String bin = Integer.toBinaryString(n);\\n        int idx = 0, max = -1;\\n        for (int i = 0; i < bin.length(); i++) {\\n            char c = bin.charAt(i);\\n            if (c == \\'1\\') {\\n                int cur = i - idx;\\n                if (max < cur) {\\n                    max = cur;\\n                }\\n                idx = i;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        String bin = Integer.toBinaryString(n);\\n        int idx = 0, max = -1;\\n        for (int i = 0; i < bin.length(); i++) {\\n            char c = bin.charAt(i);\\n            if (c == \\'1\\') {\\n                int cur = i - idx;\\n                if (max < cur) {\\n                    max = cur;\\n                }\\n                idx = i;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2308293,
                "title": "0ms-easy-c-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int Prev = -1, i = 0, Answer = 0;\\n\\t\\t/*\\n\\t\\t    Prev is the position of the previous 1\\n\\t\\t\\ti is the position\\n\\t\\t*/\\n        while(n)\\n        {\\n            if (n % 2) // if the bit is 1\\n            {\\n                if (Prev != -1 && i - Prev > Answer) \\n                    Answer = i - Prev;\\n\\t\\t\\t\\t\\t/*\\n\\t\\t\\t\\t\\t    if we have seen a one before and\\n\\t\\t\\t\\t\\t\\tthe current index minus previous \\n\\t\\t\\t\\t\\t\\tindex is more than the answer \\n\\t\\t\\t\\t\\t*/\\n                Prev = i;\\n\\t\\t\\t\\t/*\\n\\t\\t\\t\\t    previous index equals the current index\\n\\t\\t\\t\\t\\tbecause the bit is equal to one\\n\\t\\t\\t\\t*/\\n            }\\n            ++i; // increment the position\\n            n /= 2;\\n        }\\n        return Answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int Prev = -1, i = 0, Answer = 0;\\n\\t\\t/*\\n\\t\\t    Prev is the position of the previous 1\\n\\t\\t\\ti is the position\\n\\t\\t*/\\n        while(n)\\n        {\\n            if (n % 2) // if the bit is 1\\n            {\\n                if (Prev != -1 && i - Prev > Answer) \\n                    Answer = i - Prev;\\n\\t\\t\\t\\t\\t/*\\n\\t\\t\\t\\t\\t    if we have seen a one before and\\n\\t\\t\\t\\t\\t\\tthe current index minus previous \\n\\t\\t\\t\\t\\t\\tindex is more than the answer \\n\\t\\t\\t\\t\\t*/\\n                Prev = i;\\n\\t\\t\\t\\t/*\\n\\t\\t\\t\\t    previous index equals the current index\\n\\t\\t\\t\\t\\tbecause the bit is equal to one\\n\\t\\t\\t\\t*/\\n            }\\n            ++i; // increment the position\\n            n /= 2;\\n        }\\n        return Answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1968113,
                "title": "c-faster-than-100-0ms-bit-manipulation-diagrammatic-representation",
                "content": "***Diagrammatic representation***\\n![image](https://assets.leetcode.com/users/images/64c84117-88d6-47e0-8f70-0a208378086d_1650504132.5012343.png)\\n![image](https://assets.leetcode.com/users/images/5759fe91-4034-47a8-8a60-c72533f6bd23_1650504170.695796.png)\\n\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int count=INT_MIN,res=0;\\n        while(n>0){\\n            if(n&1){\\n                res=max(count,res);\\n                count=0;\\n            }\\n            count++;\\n            n=n>>1;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nIf you find this solution useful, kindly **upvote** it.",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int count=INT_MIN,res=0;\\n        while(n>0){\\n            if(n&1){\\n                res=max(count,res);\\n                count=0;\\n            }\\n            count++;\\n            n=n>>1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1697161,
                "title": "simple-javascript-solution",
                "content": "```\\nvar binaryGap = function(n) {\\n    const binary = n.toString(2);\\n    let max = 0, last = 0, i = 0;\\n    while(i < binary.length){\\n        if(binary[i] === \"1\"){\\n            let distance = i - last;\\n            last = i;\\n            max = Math.max(max, distance)\\n        }\\n        i++;\\n    }\\n    return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar binaryGap = function(n) {\\n    const binary = n.toString(2);\\n    let max = 0, last = 0, i = 0;\\n    while(i < binary.length){\\n        if(binary[i] === \"1\"){\\n            let distance = i - last;\\n            last = i;\\n            max = Math.max(max, distance)\\n        }\\n        i++;\\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 365234,
                "title": "c-std-bitset-0-ms-8-3-mb",
                "content": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int N) \\n    {\\n        constexpr const size_t Byte_Size = 8;\\n        std::bitset<sizeof(N) * Byte_Size> bits{ N };\\n        \\n        size_t i = 0;\\n        while(!bits.test(i)) // find first set bit\\n            ++i; \\n        \\n        auto max_dist = 0;\\n        auto current_dist = 0;\\n        for(++i; i < bits.size(); ++i)\\n        {\\n            ++current_dist;\\n            if(bits.test(i))\\n            {\\n                max_dist = std::max(max_dist, current_dist);\\n                current_dist = 0;\\n            }\\n        }\\n        \\n        return max_dist;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int N) \\n    {\\n        constexpr const size_t Byte_Size = 8;\\n        std::bitset<sizeof(N) * Byte_Size> bits{ N };\\n        \\n        size_t i = 0;\\n        while(!bits.test(i)) // find first set bit\\n            ++i; \\n        \\n        auto max_dist = 0;\\n        auto current_dist = 0;\\n        for(++i; i < bits.size(); ++i)\\n        {\\n            ++current_dist;\\n            if(bits.test(i))\\n            {\\n                max_dist = std::max(max_dist, current_dist);\\n                current_dist = 0;\\n            }\\n        }\\n        \\n        return max_dist;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 316060,
                "title": "c-beats-100-time-and-92-memory",
                "content": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int N) {\\n        int ans = 0;\\n        if(N &&  !(N & (N-1))) return 0; //power of 2\\n        bool first_one = false;\\n        int k = 0;\\n        int one_idx;\\n        while(N) {\\n            k++;\\n            if(first_one) {\\n                if(N&1 == 1) {\\n                    ans = max(ans, k - one_idx);\\n                }\\n            }\\n            if(N&1 == 1) {\\n                first_one=true;\\n                one_idx = k;\\n            }\\n            N >>= 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int N) {\\n        int ans = 0;\\n        if(N &&  !(N & (N-1))) return 0; //power of 2\\n        bool first_one = false;\\n        int k = 0;\\n        int one_idx;\\n        while(N) {\\n            k++;\\n            if(first_one) {\\n                if(N&1 == 1) {\\n                    ans = max(ans, k - one_idx);\\n                }\\n            }\\n            if(N&1 == 1) {\\n                first_one=true;\\n                one_idx = k;\\n            }\\n            N >>= 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 152701,
                "title": "easy-understand-java-solution",
                "content": "```\\n\\n```public int binaryGap(int N) {\\n        int max = 0;\\n        int d = -32;\\n        while(N > 0){\\n            if(N % 2 == 1){\\n                max = Math.max(max, d);\\n                d = 0;\\n            }\\n            N /= 2;\\n            d++;\\n        }\\n        return max;\\n    }",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2816558,
                "title": "simple-java-solution-in-linear-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGenerate a binary string then loop over string to find distance between two 1\\'s and then store the max distance in a variable\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\nwhere N=length of Binary String\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n       String s=\"\";\\n        int t=n;\\n        while(t>0)\\n        {\\n            int r=t%2;\\n            s=s+r+\"\";\\n            t=t/2;\\n        }\\n       \\n        int mx=0;\\n        int start=s.indexOf(\\'1\\');\\n        for(int i=0;i<s.length();i++)\\n        {\\n\\n            if(s.charAt(i)==\\'1\\')\\n            {\\n                 mx=Math.max(mx,i-start);\\n                 start=i;\\n            }\\n        }\\n        return mx;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n       String s=\"\";\\n        int t=n;\\n        while(t>0)\\n        {\\n            int r=t%2;\\n            s=s+r+\"\";\\n            t=t/2;\\n        }\\n       \\n        int mx=0;\\n        int start=s.indexOf(\\'1\\');\\n        for(int i=0;i<s.length();i++)\\n        {\\n\\n            if(s.charAt(i)==\\'1\\')\\n            {\\n                 mx=Math.max(mx,i-start);\\n                 start=i;\\n            }\\n        }\\n        return mx;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2677249,
                "title": "java-simple-solution",
                "content": "```\\n public int binaryGap(int n) {\\n        int lastPos =-1;\\n        int max = 0;\\n        int pos =0;\\n        \\n       while(n>0){\\n         pos++;\\n           if((n&1)==1){\\n               if(lastPos!=-1){\\n                   max = Math.max(max, pos-lastPos);\\n               }\\n               lastPos = pos;\\n           }\\n           n= n/2;\\n       }\\n        return max;\\n        \\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public int binaryGap(int n) {\\n        int lastPos =-1;\\n        int max = 0;\\n        int pos =0;\\n        \\n       while(n>0){\\n         pos++;\\n           if((n&1)==1){\\n               if(lastPos!=-1){\\n                   max = Math.max(max, pos-lastPos);\\n               }\\n               lastPos = pos;\\n           }\\n           n= n/2;\\n       }\\n        return max;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2485217,
                "title": "c-faster-than-100-setbits",
                "content": "class Solution {\\npublic:\\n\\n    int binaryGap(int n) {\\n        int maxi=0,one=0,count=0;\\n        while(n){\\n            if((n&1)==1 &&one==1){\\n                maxi=max(maxi,count);\\n                count=0;\\n            }\\n            else if((n&1)==1&&one==0){\\n                one=1;\\n            }\\n            if(one==1)\\n            count++;   \\n            n>>=1;\\n        }\\n        return maxi;\\n    }\\n};",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int binaryGap(int n) {\\n        int maxi=0,one=0,count=0;\\n        while(n){\\n            if((n&1)==1 &&one==1){\\n                maxi=max(maxi,count);\\n                count=0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1582979,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn binary_gap(mut n: i32) -> i32 {\\n        let (mut max_dist, mut cur_dist) = (0, 0);\\n        n >>= n.trailing_zeros(); // drop zeros 10100000 => 101\\n\\n        while n > 0 {\\n            if n & 1 == 1 && cur_dist > 0 {\\n                max_dist = max_dist.max(cur_dist);\\n                cur_dist = 0;\\n            }\\n            cur_dist += 1;\\n            n >>= 1;\\n        }\\n        max_dist\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Bit Manipulation"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn binary_gap(mut n: i32) -> i32 {\\n        let (mut max_dist, mut cur_dist) = (0, 0);\\n        n >>= n.trailing_zeros(); // drop zeros 10100000 => 101\\n\\n        while n > 0 {\\n            if n & 1 == 1 && cur_dist > 0 {\\n                max_dist = max_dist.max(cur_dist);\\n                cur_dist = 0;\\n            }\\n            cur_dist += 1;\\n            n >>= 1;\\n        }\\n        max_dist\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1364757,
                "title": "golang-bitwise-shift",
                "content": "```\\nfunc binaryGap(n int) int {\\n\\tcurDistance, maxDistance := 0, 0\\n\\tseenOne := false\\n\\tfor ; n > 0; n >>= 1 {\\n\\t\\tif n & 1 == 1 {\\n\\t\\t\\tif curDistance > maxDistance {\\n\\t\\t\\t\\tmaxDistance = curDistance\\n\\t\\t\\t}\\n\\t\\t\\tcurDistance = 1\\n\\t\\t\\tseenOne = true\\n\\t\\t} else if seenOne {\\n\\t\\t\\tcurDistance++\\n\\t\\t}\\n\\t}\\n\\treturn maxDistance\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc binaryGap(n int) int {\\n\\tcurDistance, maxDistance := 0, 0\\n\\tseenOne := false\\n\\tfor ; n > 0; n >>= 1 {\\n\\t\\tif n & 1 == 1 {\\n\\t\\t\\tif curDistance > maxDistance {\\n\\t\\t\\t\\tmaxDistance = curDistance\\n\\t\\t\\t}\\n\\t\\t\\tcurDistance = 1\\n\\t\\t\\tseenOne = true\\n\\t\\t} else if seenOne {\\n\\t\\t\\tcurDistance++\\n\\t\\t}\\n\\t}\\n\\treturn maxDistance\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1306246,
                "title": "easy-python-solution-100",
                "content": "Runtime: 16 ms, faster than 100.00% of Python3 online submissions for Binary Gap.\\nMemory Usage: 14.2 MB, less than 44.00% of Python3 online submissions for Binary Gap.\\n```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        if(bin(n).count(\\'1\\'))==1:\\n            return 0\\n        c=0\\n        x=bin(n)[2:]\\n        for i in range(len(x)):\\n            if(x[i]==\\'1\\'):\\n                j=i+1\\n                while j<len(x):\\n                    if(x[j]==\\'1\\'):\\n                        c=max(j-i,c)\\n                        break\\n                    j+=1\\n        return c",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Runtime: 16 ms, faster than 100.00% of Python3 online submissions for Binary Gap.\\nMemory Usage: 14.2 MB, less than 44.00% of Python3 online submissions for Binary Gap.\\n```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        if(bin(n).count(\\'1\\'))==1:\\n            return 0\\n        c=0\\n        x=bin(n)[2:]\\n        for i in range(len(x)):\\n            if(x[i]==\\'1\\'):\\n                j=i+1\\n                while j<len(x):\\n                    if(x[j]==\\'1\\'):\\n                        c=max(j-i,c)\\n                        break\\n                    j+=1\\n        return c",
                "codeTag": "Java"
            },
            {
                "id": 157931,
                "title": "0ms-commented-golang",
                "content": "```\\nfunc binaryGap(N int) int {\\n    maxGap := 0\\n    \\n    currentGap := 0\\n    for N > 0 {\\n        \\n        //Check if right most bit is a one\\n        if (N & 1 == 1) {\\n            if(currentGap > maxGap){\\n                maxGap = currentGap\\n            }\\n            currentGap = 1\\n        \\n            //need this to make sure we don\\'t increment currentGap until we have actualy hit our first one\\n        } else if (currentGap > 0){\\n            currentGap++\\n        }\\n        //right shift by 1\\n        N = N >> 1\\n    }\\n    \\n    return maxGap\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc binaryGap(N int) int {\\n    maxGap := 0\\n    \\n    currentGap := 0\\n    for N > 0 {\\n        \\n        //Check if right most bit is a one\\n        if (N & 1 == 1) {\\n            if(currentGap > maxGap){\\n                maxGap = currentGap\\n            }\\n            currentGap = 1\\n        \\n            //need this to make sure we don\\'t increment currentGap until we have actualy hit our first one\\n        } else if (currentGap > 0){\\n            currentGap++\\n        }\\n        //right shift by 1\\n        N = N >> 1\\n    }\\n    \\n    return maxGap\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3992567,
                "title": "solution",
                "content": "# Complexity\\n- Time complexity: O(n^2)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def binaryGap(self, n):\\n        b=bin(n)[2:]\\n        l=len(b)\\n        m=0\\n        for i in range(l):\\n            if b[i]==\\'1\\':\\n                for j in range(i+1,l):\\n                    if b[j]==\\'1\\':\\n                        d=j-i\\n                        if d>m:\\n                            m=d\\n                        break\\n        return m\\n\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution(object):\\n    def binaryGap(self, n):\\n        b=bin(n)[2:]\\n        l=len(b)\\n        m=0\\n        for i in range(l):\\n            if b[i]==\\'1\\':\\n                for j in range(i+1,l):\\n                    if b[j]==\\'1\\':\\n                        d=j-i\\n                        if d>m:\\n                            m=d\\n                        break\\n        return m\\n\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3555976,
                "title": "868-binary-gap",
                "content": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int count=0;\\n        int c=0;\\n        while(n>0){\\n            if(n%2==0){\\n                if(count>0){\\n                    count++;\\n                }\\n                c=max(c,count);\\n                n=n/2;\\n            }\\n            else{\\n                c=max(c,count);\\n                count=1;\\n                n=n/2;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int count=0;\\n        int c=0;\\n        while(n>0){\\n            if(n%2==0){\\n                if(count>0){\\n                    count++;\\n                }\\n                c=max(c,count);\\n                n=n/2;\\n            }\\n            else{\\n                c=max(c,count);\\n                count=1;\\n                n=n/2;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3499368,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int binaryGap(int N) {\\n        int result = 0;\\n        int last = -1;\\n        for (int i = 0; i < 32; ++i) {\\n            if ((N >> i) & 1) {\\n                if (last != -1) {\\n                    result = max(result, i - last);\\n                }\\n                last = i;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        s = f\\'{n:b}\\'\\n        result = 0\\n        for i in range(len(s)):\\n            if s[i] == \\'0\\':\\n                continue\\n            for j in range(i + 1, len(s)):\\n                if s[j] == \\'0\\':\\n                    continue\\n                result = max(result, j - i)\\n                break\\n        return result\\n```\\n\\n```Java []\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int prev=-1;\\n        int tc=0;\\n        int mx=-1,ct=0;\\n        while(n>0){\\n            int r= n&1;\\n            if(r==1 ){\\n                ++tc;\\n                prev=0;\\n                    mx=Math.max(ct,mx);\\n                    ct=0;\\n                \\n            }else {\\n                if(prev!=-1){\\n                    ct++;\\n                }\\n            }\\n            n=n>>1;\\n        }\\n        if(tc<=1){\\n            return 0;\\n        }\\n        return mx+1;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int binaryGap(int N) {\\n        int result = 0;\\n        int last = -1;\\n        for (int i = 0; i < 32; ++i) {\\n            if ((N >> i) & 1) {\\n                if (last != -1) {\\n                    result = max(result, i - last);\\n                }\\n                last = i;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        s = f\\'{n:b}\\'\\n        result = 0\\n        for i in range(len(s)):\\n            if s[i] == \\'0\\':\\n                continue\\n            for j in range(i + 1, len(s)):\\n                if s[j] == \\'0\\':\\n                    continue\\n                result = max(result, j - i)\\n                break\\n        return result\\n```\n```Java []\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int prev=-1;\\n        int tc=0;\\n        int mx=-1,ct=0;\\n        while(n>0){\\n            int r= n&1;\\n            if(r==1 ){\\n                ++tc;\\n                prev=0;\\n                    mx=Math.max(ct,mx);\\n                    ct=0;\\n                \\n            }else {\\n                if(prev!=-1){\\n                    ct++;\\n                }\\n            }\\n            n=n>>1;\\n        }\\n        if(tc<=1){\\n            return 0;\\n        }\\n        return mx+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464142,
                "title": "beats-100-easy-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int ans = 0, count = 1;\\n        \\n        while(n > 0 ){\\n            // first n\\n           if(n&1){\\n               cout << n << \" break\" << endl;\\n              n  =n >> 1;\\n               break;\\n\\n           }\\n           n = n >> 1;\\n        }\\n\\n        while(n > 0 ){\\n            if(n&1){\\n                // cout << n << \" 2 one \"<<  endl;\\n                ans = max(count , ans);\\n                count =1;\\n            }\\n            else\\n                count++;\\n            // n/=2;\\n           n =  n >> 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int ans = 0, count = 1;\\n        \\n        while(n > 0 ){\\n            // first n\\n           if(n&1){\\n               cout << n << \" break\" << endl;\\n              n  =n >> 1;\\n               break;\\n\\n           }\\n           n = n >> 1;\\n        }\\n\\n        while(n > 0 ){\\n            if(n&1){\\n                // cout << n << \" 2 one \"<<  endl;\\n                ans = max(count , ans);\\n                count =1;\\n            }\\n            else\\n                count++;\\n            // n/=2;\\n           n =  n >> 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3457342,
                "title": "easiest-solution-bit-manipulation-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int last=-1;\\n        int ans=0;\\n   for(int i=0;i<32;i++){\\n       if(n&(1<<i)){\\n           if(last==-1) last=i;\\n           else{\\n               ans=max(ans,i-last);\\n               last=i;\\n           }\\n       }\\n   }\\n   return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int last=-1;\\n        int ans=0;\\n   for(int i=0;i<32;i++){\\n       if(n&(1<<i)){\\n           if(last==-1) last=i;\\n           else{\\n               ans=max(ans,i-last);\\n               last=i;\\n           }\\n       }\\n   }\\n   return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3409133,
                "title": "very-understandable-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        b=bin(n)[2:]\\n        maxx=0\\n        x=0\\n        y=0\\n        for i in range(len(b)):\\n            if b[i]==\"1\":\\n                maxx=max(maxx,abs(x-y))\\n                x=y\\n            y=i+1\\n        return maxx\\n\\n\\n\\n        \"\"\"(or)\\n\\n        res=[i for i,j in enumerate(bin(n)[2:]) if j==\"1\"]\\n        return max([j-i for i,j in zip(res,res[1:])] or [0])\"\"\"\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        b=bin(n)[2:]\\n        maxx=0\\n        x=0\\n        y=0\\n        for i in range(len(b)):\\n            if b[i]==\"1\":\\n                maxx=max(maxx,abs(x-y))\\n                x=y\\n            y=i+1\\n        return maxx\\n\\n\\n\\n        \"\"\"(or)\\n\\n        res=[i for i,j in enumerate(bin(n)[2:]) if j==\"1\"]\\n        return max([j-i for i,j in zip(res,res[1:])] or [0])\"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3303808,
                "title": "c-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        string bin;\\n        while(n){\\n            bin+=to_string(n%2);\\n            n/=2;\\n        }\\n        reverse(bin.begin(), bin.end());\\n\\n        int maxi = INT_MIN;\\n        int count=1, t=0;\\n        \\n        for(int i = 0; i<bin.size(); i++){\\n            if(bin[i] == \\'1\\'){\\n                t++;\\n                maxi = max(maxi,count);\\n                count=1;\\n            }\\n            else count++;\\n        }\\n        return t > 1 ? maxi : 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        string bin;\\n        while(n){\\n            bin+=to_string(n%2);\\n            n/=2;\\n        }\\n        reverse(bin.begin(), bin.end());\\n\\n        int maxi = INT_MIN;\\n        int count=1, t=0;\\n        \\n        for(int i = 0; i<bin.size(); i++){\\n            if(bin[i] == \\'1\\'){\\n                t++;\\n                maxi = max(maxi,count);\\n                count=1;\\n            }\\n            else count++;\\n        }\\n        return t > 1 ? maxi : 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3181929,
                "title": "beats-98-easy-solution-please-upvote",
                "content": "\\n# Code\\n```\\npublic class Solution {\\n    public int BinaryGap(int n) {\\n        int last = -1, ans = 0;\\n        for (int i = 0; i < 32; ++i)\\n            if (((n >> i) & 1) > 0) {\\n                if (last >= 0)\\n                    ans = Math.Max(ans, i - last);\\n                last = i;\\n            }\\n\\n        return ans; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int BinaryGap(int n) {\\n        int last = -1, ans = 0;\\n        for (int i = 0; i < 32; ++i)\\n            if (((n >> i) & 1) > 0) {\\n                if (last >= 0)\\n                    ans = Math.Max(ans, i - last);\\n                last = i;\\n            }\\n\\n        return ans; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176459,
                "title": "easy-solution-using-bin-function",
                "content": "\\n\\n# Approach\\nFirst of all ,We have to convert the given integer into its equivalent binary string. Then we will store all the indexes of \"1\" in an array.\\nThen we will calculate the difference between adjacent elements. After calculating the differences we will return the maximum difference ..\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        a=[]\\n        l=bin(n).replace(\"0b\",\"\")\\n        for i in range(len(l)):\\n            if l[i]==\"1\":\\n                a.append(i)\\n        if len(a)<=1:\\n            return 0\\n        maxi=0\\n        \\n        for i in range(len(a)-1):\\n            maxi=max(maxi,int(a[i+1])-int(a[i]))\\n        return maxi\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        a=[]\\n        l=bin(n).replace(\"0b\",\"\")\\n        for i in range(len(l)):\\n            if l[i]==\"1\":\\n                a.append(i)\\n        if len(a)<=1:\\n            return 0\\n        maxi=0\\n        \\n        for i in range(len(a)-1):\\n            maxi=max(maxi,int(a[i+1])-int(a[i]))\\n        return maxi\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3113966,
                "title": "python3-easy",
                "content": "# Code\\n```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        \\n        ans = 0\\n        m = -1\\n        while n:\\n            if 1&n:\\n                if m==-1:\\n                    m = 1\\n                else:\\n                    ans = max(ans,m)\\n                    m=1\\n            else:\\n                if m!=-1:\\n                    m+=1\\n                \\n            n = n>>1\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        \\n        ans = 0\\n        m = -1\\n        while n:\\n            if 1&n:\\n                if m==-1:\\n                    m = 1\\n                else:\\n                    ans = max(ans,m)\\n                    m=1\\n            else:\\n                if m!=-1:\\n                    m+=1\\n                \\n            n = n>>1\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2816573,
                "title": "simple-java-solution-in-linear-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGenerate a binary string then loop over string to find distance between two 1\\'s and then store the max distance in a variable\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\nwhere N=length of Binary String\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n       String s=\"\";\\n        int t=n;\\n        while(t>0)\\n        {\\n            int r=t%2;\\n            s=s+r+\"\";\\n            t=t/2;\\n        }\\n       \\n        int mx=0;\\n        int start=s.indexOf(\\'1\\');\\n        for(int i=0;i<s.length();i++)\\n        {\\n\\n            if(s.charAt(i)==\\'1\\')\\n            {\\n                 mx=Math.max(mx,i-start);\\n                 start=i;\\n            }\\n        }\\n        return mx;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n       String s=\"\";\\n        int t=n;\\n        while(t>0)\\n        {\\n            int r=t%2;\\n            s=s+r+\"\";\\n            t=t/2;\\n        }\\n       \\n        int mx=0;\\n        int start=s.indexOf(\\'1\\');\\n        for(int i=0;i<s.length();i++)\\n        {\\n\\n            if(s.charAt(i)==\\'1\\')\\n            {\\n                 mx=Math.max(mx,i-start);\\n                 start=i;\\n            }\\n        }\\n        return mx;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2790637,
                "title": "python-simple-solution-ii-o-n-one-pass",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        binary = bin(n)\\n        binary= binary[2:]\\n        found = False\\n        max_count =0\\n        for i in range(len(binary)):\\n             if(binary[i]==\\'1\\' and found ==False):\\n                 start= i\\n                 found = True\\n             elif(binary[i]==\\'1\\' and found==True):\\n                 count = i- start\\n                 start= i\\n                 if(count>max_count):\\n                     max_count= count\\n        return max_count\\n\\n             \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        binary = bin(n)\\n        binary= binary[2:]\\n        found = False\\n        max_count =0\\n        for i in range(len(binary)):\\n             if(binary[i]==\\'1\\' and found ==False):\\n                 start= i\\n                 found = True\\n             elif(binary[i]==\\'1\\' and found==True):\\n                 count = i- start\\n                 start= i\\n                 if(count>max_count):\\n                     max_count= count\\n        return max_count\\n\\n             \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2687088,
                "title": "c-0ms-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int ans = 0,c=0,t=0;long x = 1;bool flag = false;\\n        while(n>=x){\\n            c++;\\n            if(x&n) {\\n                if(flag) ans = max(ans,c-t);\\n                t = c;\\n                flag = true;\\n            } x<<=1;\\n        }return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int ans = 0,c=0,t=0;long x = 1;bool flag = false;\\n        while(n>=x){\\n            c++;\\n            if(x&n) {\\n                if(flag) ans = max(ans,c-t);\\n                t = c;\\n                flag = true;\\n            } x<<=1;\\n        }return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2565781,
                "title": "js-easy-solution-100-o-n",
                "content": "![image](https://assets.leetcode.com/users/images/475ee9ed-ee46-4a6a-a0f9-f5783f5b13de_1662972381.4477122.png)\\n\\n```\\nvar binaryGap = function(n) {\\n    const binaryString = (n >>> 0).toString(2);\\n    let output = 0;\\n    let start;\\n\\n    for (let i = 0; i < binaryString.length; i++) {\\n        if (binaryString[i] === \"1\") {\\n            output = Math.max(output, start !== undefined ? (i - start) : 0);\\n            start = i;\\n        }\\n    }\\n    \\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar binaryGap = function(n) {\\n    const binaryString = (n >>> 0).toString(2);\\n    let output = 0;\\n    let start;\\n\\n    for (let i = 0; i < binaryString.length; i++) {\\n        if (binaryString[i] === \"1\") {\\n            output = Math.max(output, start !== undefined ? (i - start) : 0);\\n            start = i;\\n        }\\n    }\\n    \\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2437228,
                "title": "my-kotlin-solution-with-time-o-1-and-space-o-1",
                "content": "Below is my solution in kotlin, it preprocess the n with it right most bit and calculate the gap through shift right.\\n```\\nclass Solution {\\n    /* Complexity:\\n     * Time O(1) & Space O(1);\\n     */\\n    fun binaryGap(n: Int): Int {\\n        tailrec fun process(num: Int, gap: Int = 0, maxGap: Int = 0): Int =\\n            when {\\n                num == 0 -> maxGap\\n                num and 1 == 0 -> process(num shr 1, gap + 1, maxGap)\\n                else -> process(num shr 1, 1, maxOf(gap, maxGap))\\n            }\\n\\n        val rightMostBit = n - (n and (n - 1))\\n        return if (rightMostBit == 0) 0 else process(num = n / rightMostBit)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    /* Complexity:\\n     * Time O(1) & Space O(1);\\n     */\\n    fun binaryGap(n: Int): Int {\\n        tailrec fun process(num: Int, gap: Int = 0, maxGap: Int = 0): Int =\\n            when {\\n                num == 0 -> maxGap\\n                num and 1 == 0 -> process(num shr 1, gap + 1, maxGap)\\n                else -> process(num shr 1, 1, maxOf(gap, maxGap))\\n            }\\n\\n        val rightMostBit = n - (n and (n - 1))\\n        return if (rightMostBit == 0) 0 else process(num = n / rightMostBit)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2430116,
                "title": "binary-gap-c-5ms",
                "content": "class Solution {\\npublic:\\n    int binaryGap(int &n) {\\n        int ans = 0,x = 0;\\n        while(n){\\n            if(n%2==1){\\n                ans = max(ans,x-1);\\n                x = 1;\\n            }\\n            x > 0? x++: x = 0;\\n            n = n >> 1;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int binaryGap(int &n) {\\n        int ans = 0,x = 0;\\n        while(n){\\n            if(n%2==1){\\n                ans = max(ans,x-1);\\n                x = 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2145256,
                "title": "c-fast-easy-code-bit-manipulation",
                "content": "Check each bit from the back and if it\\'s \\'1\\', we calculate the distance using the difference between the current index and the previous index that points to the previous \\'1\\' found. Compare the value with the current max distance and store the larger value back. There\\'s no previous index for the first \\'1\\' so we simply set previous index to the current index.\\n\\n**Code:**\\n```\\nclass Solution {\\n public:\\n  int BinaryGap(int n) {\\n    int index = 0, prev_index = -1;\\n    int max_distance = 0;\\n\\n    while (n) {\\n      if (n & 1) {\\n        if (prev_index != -1)\\n          max_distance = std::max(max_distance, index - prev_index);\\n        prev_index = index;\\n      }\\n      n >>= 1, index++;\\n    }\\n\\n    return max_distance;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int BinaryGap(int n) {\\n    int index = 0, prev_index = -1;\\n    int max_distance = 0;\\n\\n    while (n) {\\n      if (n & 1) {\\n        if (prev_index != -1)\\n          max_distance = std::max(max_distance, index - prev_index);\\n        prev_index = index;\\n      }\\n      n >>= 1, index++;\\n    }\\n\\n    return max_distance;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2091944,
                "title": "java-simple-solution",
                "content": "Here is a simple approach to solve this question.\\nWhat we are doing here is\\ni) if(n&1) is equal to 1 then find next 1\\n\\t\\t........**(subcondition)**.........if(n==0) then it means next 1 not found else 1 is found so set the value of max\\nii) else right shift.\\n\\n```class Solution {\\n    public int binaryGap(int n) {\\n        int max=0;\\n        while(n>0){\\n            int r=n&1;\\n\\t\\t\\t//if r==1 then search next occurence of 1\\n            if(r==1){\\n                n=n>>1;\\n                int var=1;\\n                while(n>0 && (n&1)!=1){\\n                    n=n>>1;\\n                    var++;\\n                }\\n                if(n!=0){\\n                    max=Math.max(max,var);\\n                }\\n                // else right shift\\n            }else{\\n                n=n>>1;\\n            }\\n        }\\n        return max;\\n    }\\n}```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```class Solution {\\n    public int binaryGap(int n) {\\n        int max=0;\\n        while(n>0){\\n            int r=n&1;\\n\\t\\t\\t//if r==1 then search next occurence of 1\\n            if(r==1){\\n                n=n>>1;\\n                int var=1;\\n                while(n>0 && (n&1)!=1){\\n                    n=n>>1;\\n                    var++;\\n                }\\n                if(n!=0){\\n                    max=Math.max(max,var);\\n                }\\n                // else right shift\\n            }else{\\n                n=n>>1;\\n            }\\n        }\\n        return max;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 1984287,
                "title": "super-clear-illustrated-explanation",
                "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/4517167f-0053-4740-b183-710c7bd81536_1650990891.4216025.png)\\n\\n\\n    def binaryGap(self, n: int) -> int:\\n        \"\"\" O(logN)T O(1)S \"\"\"\\n        num, ans, prev = bin(n)[2:], 0, math.inf\\n\\n        for i, b in enumerate(num):\\n            if b == \\'1\\':\\n                ans, prev = max(ans, i - prev), i\\n\\n        return ans\\n\\n    def binaryGap(self, n: int) -> int:\\n        \"\"\" O(logN)T O(1)S \"\"\"\\n        num, size = map(int, bin(n)[2:]), math.floor(math.log2(n)) + 1  # size = bit cnt\\n        return max((b - a for a, b in itertools.pairwise(itertools.compress(range(size), num))), default=0)\\n\\n    def binaryGap(self, n: int) -> int:\\n        \"\"\" O(logN)T O(1)S \"\"\"\\n        idx = [i for i, v in enumerate(bin(n)) if v == \\'1\\']\\n        return max((b - a for a, b in itertools.pairwise(idx)), default=0)",
                "solutionTags": [],
                "code": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/4517167f-0053-4740-b183-710c7bd81536_1650990891.4216025.png)\\n\\n\\n    def binaryGap(self, n: int) -> int:\\n        \"\"\" O(logN)T O(1)S \"\"\"\\n        num, ans, prev = bin(n)[2:], 0, math.inf\\n\\n        for i, b in enumerate(num):\\n            if b == \\'1\\':\\n                ans, prev = max(ans, i - prev), i\\n\\n        return ans\\n\\n    def binaryGap(self, n: int) -> int:\\n        \"\"\" O(logN)T O(1)S \"\"\"\\n        num, size = map(int, bin(n)[2:]), math.floor(math.log2(n)) + 1  # size = bit cnt\\n        return max((b - a for a, b in itertools.pairwise(itertools.compress(range(size), num))), default=0)\\n\\n    def binaryGap(self, n: int) -> int:\\n        \"\"\" O(logN)T O(1)S \"\"\"\\n        idx = [i for i, v in enumerate(bin(n)) if v == \\'1\\']\\n        return max((b - a for a, b in itertools.pairwise(idx)), default=0)",
                "codeTag": "Python3"
            },
            {
                "id": 1919356,
                "title": "fast-solution-in-python3",
                "content": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        a=list(bin(n)[2:])\\n        s=[]\\n        for i in range(len(a)):\\n            if a[i]!=\\'0\\':\\n                s.append(i)\\n        t=[]\\n        for i in range(len(s)):\\n            t.append(s[i]-s[i-1])\\n        return(max(t))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        a=list(bin(n)[2:])\\n        s=[]\\n        for i in range(len(a)):\\n            if a[i]!=\\'0\\':\\n                s.append(i)\\n        t=[]\\n        for i in range(len(s)):\\n            t.append(s[i]-s[i-1])\\n        return(max(t))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1859275,
                "title": "100-time-o-logn-easy-to-understand",
                "content": "**here we are using  differnt function of bit to solve question**\\n***be noted why we initialize count to -32 i wrote it in comment in code***\\n\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int count = -32, maxi = 0;//-32 is the smallest possible bit \\n\\t\\t//maxi is our answer\\n        //we have to start counting from -32 because we are moving reverse like if n=8 than we are travarsing 0->0->0->1 so be noted about it\\n        while (n != 0) {\\n            if ((n & 1) == 1) {// also write \\'n%2\\'\\n                maxi = max(maxi, count);\\n                count = 0;\\n            }\\n            count++;\\n            n >>= 1;//also write \\'n/=2\\'\\n        }\\n        return maxi;\\n    }\\n};\\n```\\n***this is my solution if yu have any doubt than fill free to ask in comment if i can than absolutly solve it***\\n***if you find solution use ful than upwote else downvote***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int count = -32, maxi = 0;//-32 is the smallest possible bit \\n\\t\\t//maxi is our answer\\n        //we have to start counting from -32 because we are moving reverse like if n=8 than we are travarsing 0->0->0->1 so be noted about it\\n        while (n != 0) {\\n            if ((n & 1) == 1) {// also write \\'n%2\\'\\n                maxi = max(maxi, count);\\n                count = 0;\\n            }\\n            count++;\\n            n >>= 1;//also write \\'n/=2\\'\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1794889,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n\\t\\t int max=0;\\n\\t\\t while(n!=1) {\\n             int c=0;\\n\\t\\t\\t if((n&1)==1) {\\n\\t\\t\\t\\t while(n!=0&&(n>>1&1)==0) {\\n\\t\\t\\t\\t\\t c++;\\n\\t\\t\\t\\t\\t n>>=1;\\n\\t\\t\\t\\t }\\n\\t\\t\\t\\t if(max<c+1) { \\n\\t\\t\\t\\t\\t max=(c+1);\\n\\t\\t\\t\\t }\\n\\t\\t\\t }\\t\\t\\t\\n\\t\\t\\t n>>=1;\\n\\t\\t }\\n\\t\\n\\t\\treturn max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n\\t\\t int max=0;\\n\\t\\t while(n!=1) {\\n             int c=0;\\n\\t\\t\\t if((n&1)==1) {\\n\\t\\t\\t\\t while(n!=0&&(n>>1&1)==0) {\\n\\t\\t\\t\\t\\t c++;\\n\\t\\t\\t\\t\\t n>>=1;\\n\\t\\t\\t\\t }\\n\\t\\t\\t\\t if(max<c+1) { \\n\\t\\t\\t\\t\\t max=(c+1);\\n\\t\\t\\t\\t }\\n\\t\\t\\t }\\t\\t\\t\\n\\t\\t\\t n>>=1;\\n\\t\\t }\\n\\t\\n\\t\\treturn max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1736152,
                "title": "javascript-solution-using-bit-manipulation",
                "content": "```\\nvar max = (a,b) => {\\n    return a>b?a:b;\\n}\\nvar binaryGap = function(n) {\\n    var maxs = 0;\\n    var d=0;\\n    var i=0;\\n    var last=-1\\n    while(n!=0){\\n        if(last === -1 && n&1===1){\\n            last = i; \\n        }\\n        else if(n&1===1){\\n            maxs=max(maxs,i-last);\\n            last = i;\\n        }\\n        n=n>>1;\\n        i++;\\n    }\\n    return maxs\\n};",
                "solutionTags": [],
                "code": "```\\nvar max = (a,b) => {\\n    return a>b?a:b;\\n}\\nvar binaryGap = function(n) {\\n    var maxs = 0;\\n    var d=0;\\n    var i=0;\\n    var last=-1\\n    while(n!=0){\\n        if(last === -1 && n&1===1){\\n            last = i; \\n        }\\n        else if(n&1===1){\\n            maxs=max(maxs,i-last);\\n            last = i;\\n        }\\n        n=n>>1;\\n        i++;\\n    }\\n    return maxs\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1722203,
                "title": "using-format-for-binary-string",
                "content": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        curr = \"{:b}\".format(n)\\n        n = len(curr)\\n        mdist = 0\\n        prev = -1\\n        for i in range(n):\\n            if curr[i] == \"1\":\\n                if prev >= 0:\\n                    mdist = max(mdist, i - prev)\\n                prev = i\\n        return mdist\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        curr = \"{:b}\".format(n)\\n        n = len(curr)\\n        mdist = 0\\n        prev = -1\\n        for i in range(n):\\n            if curr[i] == \"1\":\\n                if prev >= 0:\\n                    mdist = max(mdist, i - prev)\\n                prev = i\\n        return mdist\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1519288,
                "title": "fastest-100-passed-c-clear-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int dis =0, max_dis = 0,flag =0;\\n        while(n)\\n        {\\n            if(n&1)\\n            {\\n                flag =1;\\n                max_dis = max(max_dis,dis);\\n                dis = 1;\\n            }\\n            else if(flag)\\n            {\\n                dis++;\\n            }\\n            \\n            n = n>>1;\\n        }\\n        \\n        return max_dis;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int dis =0, max_dis = 0,flag =0;\\n        while(n)\\n        {\\n            if(n&1)\\n            {\\n                flag =1;\\n                max_dis = max(max_dis,dis);\\n                dis = 1;\\n            }\\n            else if(flag)\\n            {\\n                dis++;\\n            }\\n            \\n            n = n>>1;\\n        }\\n        \\n        return max_dis;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1467446,
                "title": "simple-c-o-log-n-constant-space",
                "content": "\\n    int binaryGap(int n) {\\n        \\n        int temp{0}, ans{0}, curr{INT_MAX};\\n        \\n        while(n){\\n            temp++;\\n            if(n&1){\\n                ans=max(ans, temp-curr);\\n                curr=temp;                \\n            } \\n            n=n>>1;\\n        }\\n        return ans;\\n    }\\n",
                "solutionTags": [],
                "code": "\\n    int binaryGap(int n) {\\n        \\n        int temp{0}, ans{0}, curr{INT_MAX};\\n        \\n        while(n){\\n            temp++;\\n            if(n&1){\\n                ans=max(ans, temp-curr);\\n                curr=temp;                \\n            } \\n            n=n>>1;\\n        }\\n        return ans;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1410829,
                "title": "simple-java-solution",
                "content": "class Solution {\\n\\n    public int binaryGap(int n) {\\n        String p=Integer.toBinaryString(n);\\n        int i,c=0,k=0,j=0;\\n        for(i=0;i<p.length();i++)\\n        {\\n            if(p.charAt(i)==\\'1\\'&&c>0)\\n            {\\n                k=Math.max(k,(i-j));\\n                j=i;\\n                c++;\\n            }\\n            else if(p.charAt(i)==\\'1\\')\\n            {\\n                j=i;\\n                c++;\\n            }\\n        }\\n        return k;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int binaryGap(int n) {\\n        String p=Integer.toBinaryString(n);\\n        int i,c=0,k=0,j=0;\\n        for(i=0;i<p.length();i++)\\n        {\\n            if(p.charAt(i)==\\'1\\'&&c>0)\\n            {\\n                k=Math.max(k,(i-j));\\n                j=i;\\n                c++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1405152,
                "title": "fast-c-solution-o-1-space-0-ms-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int dig, cur = 0, max = 0;\\n        if(n == 0) {\\n            return 0;\\n        }\\n        while(n > 0 && n % 2 == 0) {\\n            n /= 2;\\n        }\\n        if(n == 0) {\\n            return 0;\\n        }\\n        int count = 0;\\n        while(n > 0) {\\n            if(n % 2 == 0) {\\n                cur++;\\n            } else {\\n                max = std::max(cur, max);\\n                count++;\\n                cur = 0;\\n            }\\n            n /= 2;\\n        }\\n        if(count == 1) {\\n            return 0;\\n        }\\n        return max + 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int dig, cur = 0, max = 0;\\n        if(n == 0) {\\n            return 0;\\n        }\\n        while(n > 0 && n % 2 == 0) {\\n            n /= 2;\\n        }\\n        if(n == 0) {\\n            return 0;\\n        }\\n        int count = 0;\\n        while(n > 0) {\\n            if(n % 2 == 0) {\\n                cur++;\\n            } else {\\n                max = std::max(cur, max);\\n                count++;\\n                cur = 0;\\n            }\\n            n /= 2;\\n        }\\n        if(count == 1) {\\n            return 0;\\n        }\\n        return max + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1362260,
                "title": "o-n-0ms-100-fast",
                "content": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int k=INT_MIN,count=0;\\n        while(n!=0){\\n            if(n%2==1){\\n                count=max(count,k); k=0;\\n            }\\n            k+=1; n/=2;\\n        }\\n    \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int k=INT_MIN,count=0;\\n        while(n!=0){\\n            if(n%2==1){\\n                count=max(count,k); k=0;\\n            }\\n            k+=1; n/=2;\\n        }\\n    \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1337314,
                "title": "simple-python-o-n-solution",
                "content": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        ons = []\\n        for i in range(len(bin(n)[2:])):\\n            if bin(n)[2:][i] == \\'1\\': ons.append(i)\\n        if len(ons) >= 2:\\n            maxi = -1\\n            for i in range(len(ons)-1):\\n                if ons[i+1] - ons[i] > maxi: maxi = ons[i+1] - ons[i]\\n            return maxi\\n        else:return 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        ons = []\\n        for i in range(len(bin(n)[2:])):\\n            if bin(n)[2:][i] == \\'1\\': ons.append(i)\\n        if len(ons) >= 2:\\n            maxi = -1\\n            for i in range(len(ons)-1):\\n                if ons[i+1] - ons[i] > maxi: maxi = ons[i+1] - ons[i]\\n            return maxi\\n        else:return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1263330,
                "title": "c-simple-solution-0ms",
                "content": "```\\nint binaryGap(int n){\\n    int max=0, i=0, pre=-1;\\n    while(n > 0){\\n        if(n & 1){\\n            if(pre > -1 && max < i - pre)\\n                max = i - pre;\\n            pre = i;\\n        }\\n        i++;\\n        n = n >> 1;\\n    }\\n    return max;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint binaryGap(int n){\\n    int max=0, i=0, pre=-1;\\n    while(n > 0){\\n        if(n & 1){\\n            if(pre > -1 && max < i - pre)\\n                max = i - pre;\\n            pre = i;\\n        }\\n        i++;\\n        n = n >> 1;\\n    }\\n    return max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1200055,
                "title": "hashing-steps-explanation-0ms-c",
                "content": "**STEPS:-**\\n**1) convert the number in binary format and store it in a string (LSB at 0 index)**\\n**2) declare a  map( key = char, value = int) and define an int dist = 0**\\n**3) then just iterate over the string, if map does not contain key = \\'1\\' , then just insert it with value = index**\\n**4) if key = \\'1\\', already present then simply update the dist as max(dist,abs(map[\\'1\\']-index))**\\n**5) return the dist**\\n**NOTE: Why its working ??, you got it by now :)**\\n```\\n    int binaryGap(int n) {\\n        string s;\\n        while(n!=0){\\n            s+=to_string(n%2);\\n            n/=2;\\n        }\\n        unordered_map<char,int> mp;\\n        int dist=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'1\\'&&mp.count(s[i])!=0)\\n                dist=max(dist,abs(mp[s[i]]-i));\\n            mp[s[i]]=i;\\n        }\\n        return dist;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int binaryGap(int n) {\\n        string s;\\n        while(n!=0){\\n            s+=to_string(n%2);\\n            n/=2;\\n        }\\n        unordered_map<char,int> mp;\\n        int dist=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'1\\'&&mp.count(s[i])!=0)\\n                dist=max(dist,abs(mp[s[i]]-i));\\n            mp[s[i]]=i;\\n        }\\n        return dist;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1156816,
                "title": "super-simple-and-easy-cpp-solution-must-check",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        \\n        int flag =0;\\n        int dis =0;\\n        int maxi =0;\\n        while(n> 0)\\n        {\\n            if(n %2==1 and flag ==0)\\n                flag =1;\\n            \\n            else if( n %2 and flag)\\n            {\\n                dis++;\\n                maxi = max(dis,maxi);\\n                dis =0;\\n            }\\n            else if(flag)\\n                dis++;\\n            n = n>>1;    \\n        }\\n        return maxi;\\n    }\\n};\\n\\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int binaryGap(int n) {\\n        \\n        int flag =0;\\n        int dis =0;\\n        int maxi =0;\\n        while(n> 0)\\n        {\\n            if(n %2==1 and flag ==0)\\n                flag =1;\\n            \\n            else if( n %2 and flag)\\n            {\\n                dis++;\\n                maxi = max(dis,maxi);\\n                dis =0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1081801,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        \\n        \\n        lst = list(bin(n)[2:])\\n        max_length = -float(\\'inf\\')\\n        flag = False\\n        \\n        for idx,val in enumerate(lst):\\n            if(val == \\'1\\'):\\n                if(flag == False):\\n                    start = idx\\n                    flag = True\\n                else:\\n                    max_length = max(max_length,idx-start)\\n                    start = idx\\n                    \\n        if(max_length == -float(\\'inf\\')):\\n            return 0\\n        \\n        return max_length\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        \\n        \\n        lst = list(bin(n)[2:])\\n        max_length = -float(\\'inf\\')\\n        flag = False\\n        \\n        for idx,val in enumerate(lst):\\n            if(val == \\'1\\'):\\n                if(flag == False):\\n                    start = idx\\n                    flag = True\\n                else:\\n                    max_length = max(max_length,idx-start)\\n                    start = idx\\n                    \\n        if(max_length == -float(\\'inf\\')):\\n            return 0\\n        \\n        return max_length\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1030187,
                "title": "python-solution",
                "content": "```\\ndef binary_gap(n: int):\\n    dist = 0\\n    x = float(\\'-inf\\')\\n\\n    while n > 0:\\n        if n % 2 == 1:\\n            dist = max(dist, x)\\n            x = 0\\n\\n        n//=2\\n        x+=1\\n\\n    return dist\\n```",
                "solutionTags": [],
                "code": "```\\ndef binary_gap(n: int):\\n    dist = 0\\n    x = float(\\'-inf\\')\\n\\n    while n > 0:\\n        if n % 2 == 1:\\n            dist = max(dist, x)\\n            x = 0\\n\\n        n//=2\\n        x+=1\\n\\n    return dist\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1020460,
                "title": "python-bitwise-95-faster",
                "content": "Every odd value will have a 1 on the right hand side of the binary digit (because this is the ones digit and all factors of 2 are even except 2 raised to the 0 power).  We can then bitwise right shift by 1 (i.e. integer division by 2, effectively dropping the right digit) to \\'traverse\\' across the binary and count the times until we obtain another odd (1) value.\\n\\n```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        \\n        ans = 0\\n        while n > 1:\\n            if n % 2 == 1:\\n                count = 1\\n                n >>= 1\\n                while n % 2 == 0:\\n                    count += 1\\n                    n >>= 1\\n                ans = max(ans, count)\\n            else:\\n                n >>= 1\\n            \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        \\n        ans = 0\\n        while n > 1:\\n            if n % 2 == 1:\\n                count = 1\\n                n >>= 1\\n                while n % 2 == 0:\\n                    count += 1\\n                    n >>= 1\\n                ans = max(ans, count)\\n            else:\\n                n >>= 1\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1017556,
                "title": "clean-js-solution",
                "content": "Remove the first \\'1\\' in the binary, then loop through the string. If we hit a \\'1\\', record the gap and compare it to the max gap then reset the gap to 0.\\n```\\nvar binaryGap = function (n) {\\n  const binary = n.toString(2).substring(1)\\n  let [maxGap, gap] = [0, 0];\\n\\n  for (let num of binary) {\\n    gap++;\\n    if (num === \\'1\\') {\\n      maxGap = Math.max(maxGap, gap);\\n      gap = 0;\\n    }\\n  }\\n\\n  return maxGap;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar binaryGap = function (n) {\\n  const binary = n.toString(2).substring(1)\\n  let [maxGap, gap] = [0, 0];\\n\\n  for (let num of binary) {\\n    gap++;\\n    if (num === \\'1\\') {\\n      maxGap = Math.max(maxGap, gap);\\n      gap = 0;\\n    }\\n  }\\n\\n  return maxGap;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 989270,
                "title": "simple-java-solution-1-ms-with-explanation",
                "content": "- Intially store the first occur \\'1\\'\\n- Next if the current value is \\'1\\' then minu the previous value with current index and change the previous value\\n\\n```\\nclass Solution {\\n    public int binaryGap(int N) {\\n        String b  = Integer.toBinaryString(N);\\n        \\n        int n = b.length();\\n        int dif = 0;\\n        int prev = b.indexOf(\"1\"); \\n        \\n        for(int i=prev+1;i<n;i++){\\n            if(b.charAt(i) == \\'1\\'){\\n                dif = Integer.max(dif,i-prev);\\n                prev = i;\\n            }\\n        }\\n        return dif;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int N) {\\n        String b  = Integer.toBinaryString(N);\\n        \\n        int n = b.length();\\n        int dif = 0;\\n        int prev = b.indexOf(\"1\"); \\n        \\n        for(int i=prev+1;i<n;i++){\\n            if(b.charAt(i) == \\'1\\'){\\n                dif = Integer.max(dif,i-prev);\\n                prev = i;\\n            }\\n        }\\n        return dif;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 982479,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int binaryGap(int n) {\\n        while(n%2==0)\\n            n/=2;\\n        if(n==1)\\n            return 0;\\n        int tot=0,max=0;\\n        while(n!=0){\\n            if(n%2==0)\\n                tot++;\\n            else{\\n                if(tot>max)\\n                    max=tot;\\n                tot=0;\\n            }\\n            n/=2;\\n        }\\n        return max+1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int binaryGap(int n) {\\n        while(n%2==0)\\n            n/=2;\\n        if(n==1)\\n            return 0;\\n        int tot=0,max=0;\\n        while(n!=0){\\n            if(n%2==0)\\n                tot++;\\n            else{\\n                if(tot>max)\\n                    max=tot;\\n                tot=0;\\n            }\\n            n/=2;\\n        }\\n        return max+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 964373,
                "title": "ugly-code-but-one-pass-without-casting-to-string",
                "content": "```\\nvar binaryGap = function(n) {\\n    let max = 0;\\n    let counter = 0;\\n    let found = false;\\n    while(n){\\n        if(!found && !(n%2 == 0)){\\n          found = true;\\n          n = n>>1;\\n        } else if(found && (n%2 == 0)){\\n            counter++;\\n            n = n>>1;\\n        } else if(found && !(n%2 == 0)) {\\n            counter++;\\n            max = counter > max ? counter : max;\\n            counter = 0;\\n            found = false;\\n        } else {\\n            n = n>>1\\n        }\\n    }\\n    return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```\\nvar binaryGap = function(n) {\\n    let max = 0;\\n    let counter = 0;\\n    let found = false;\\n    while(n){\\n        if(!found && !(n%2 == 0)){\\n          found = true;\\n          n = n>>1;\\n        } else if(found && (n%2 == 0)){\\n            counter++;\\n            n = n>>1;\\n        } else if(found && !(n%2 == 0)) {\\n            counter++;\\n            max = counter > max ? counter : max;\\n            counter = 0;\\n            found = false;\\n        } else {\\n            n = n>>1\\n        }\\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 929372,
                "title": "3-solutions",
                "content": "**two indices**\\n```\\nint binaryGap(int n)\\n{\\n\\tint out{0};\\n\\tfor(auto i{0}, j{32}; n; n>>=1, ++i)\\n\\t\\tif(n&1) out=max(out, i-j), j=i;\\n\\treturn out;\\n}\\n```\\n**distance**\\n```\\nint binaryGap(int n)\\n{\\n\\tint out{0};\\n\\tfor(auto i{-32}; n; n>>=1, ++i)\\n\\t\\tif(n&1) out=max(out, i), i=0;              // if(n&1) out=max(out, exchange(i, 0));\\n\\treturn out;\\n}\\n```\\n\\n**`builtin_ctz` \\u2014 `gcc` builtin function that counts the number of trailing zeroes**\\n```\\nint binaryGap(int n)\\n{\\n\\tint out{0};\\n\\tfor(auto i{32}; n; n&=n-1)\\n\\t{\\n\\t\\tout = max(out, __builtin_ctz(n)-i);\\n\\t\\ti   = __builtin_ctz(n);\\n\\t}\\n\\treturn out;\\n}\\n```\\nor\\n```\\nint binaryGap(int n)\\n{\\n\\tint out{0};\\n\\tfor(auto i{32}; n; n&=n-1)\\n\\t{\\n\\t\\tauto j = exchange(i, __builtin_ctz(n));\\n        out    = max(out, i - j);\\n\\t}\\n\\treturn out;\\n}\\n```\\n\\nHere https://leetcode.com/problems/get-maximum-in-generated-array/discuss/930626/elegant-o1-space you can  different recipes on how to write `__builtin_ctz` function yourself.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint binaryGap(int n)\\n{\\n\\tint out{0};\\n\\tfor(auto i{0}, j{32}; n; n>>=1, ++i)\\n\\t\\tif(n&1) out=max(out, i-j), j=i;\\n\\treturn out;\\n}\\n```\n```\\nint binaryGap(int n)\\n{\\n\\tint out{0};\\n\\tfor(auto i{-32}; n; n>>=1, ++i)\\n\\t\\tif(n&1) out=max(out, i), i=0;              // if(n&1) out=max(out, exchange(i, 0));\\n\\treturn out;\\n}\\n```\n```\\nint binaryGap(int n)\\n{\\n\\tint out{0};\\n\\tfor(auto i{32}; n; n&=n-1)\\n\\t{\\n\\t\\tout = max(out, __builtin_ctz(n)-i);\\n\\t\\ti   = __builtin_ctz(n);\\n\\t}\\n\\treturn out;\\n}\\n```\n```\\nint binaryGap(int n)\\n{\\n\\tint out{0};\\n\\tfor(auto i{32}; n; n&=n-1)\\n\\t{\\n\\t\\tauto j = exchange(i, __builtin_ctz(n));\\n        out    = max(out, i - j);\\n\\t}\\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 806074,
                "title": "faster-than-100-c-online-submisssion",
                "content": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int N) {\\n        int count=0,pos=0, maxDist =INT_MIN;\\n        while(N){\\n            count++;\\n            if(N&1){\\n                if(pos){\\n                    maxDist = max(maxDist, count-pos);\\n                    pos =count;\\n                }else{\\n                    pos =count;\\n                }\\n            }\\n            N = N>>1;\\n        }\\n        \\n        return maxDist==INT_MIN?0:maxDist;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int N) {\\n        int count=0,pos=0, maxDist =INT_MIN;\\n        while(N){\\n            count++;\\n            if(N&1){\\n                if(pos){\\n                    maxDist = max(maxDist, count-pos);\\n                    pos =count;\\n                }else{\\n                    pos =count;\\n                }\\n            }\\n            N = N>>1;\\n        }\\n        \\n        return maxDist==INT_MIN?0:maxDist;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 798058,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def binaryGap(self, N: int) -> int:\\n        \\n        def findbinary(x):\\n            if x//2 < 2:\\n                return str(x//2)+str(x%2)\\n            else:\\n                return findbinary(x//2)+str(x%2)\\n            \\n        num = findbinary(N)\\n        l = [i for i in range(len(num)) if num[i] == \\'1\\']\\n        \\n        if len(l) <= 1:\\n            return 0\\n        \\n        return max([l[i]-l[i-1] for i in range(1,len(l))])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, N: int) -> int:\\n        \\n        def findbinary(x):\\n            if x//2 < 2:\\n                return str(x//2)+str(x%2)\\n            else:\\n                return findbinary(x//2)+str(x%2)\\n            \\n        num = findbinary(N)\\n        l = [i for i in range(len(num)) if num[i] == \\'1\\']\\n        \\n        if len(l) <= 1:\\n            return 0\\n        \\n        return max([l[i]-l[i-1] for i in range(1,len(l))])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 730010,
                "title": "python3-easy-soln",
                "content": "class Solution:\\n\\n\\n    def binaryGap(self, N: int) -> int:\\n        x=str(bin(N))[2:]\\n        l=[]\\n        prev=0\\n        \\n        for i in range(len(x)):\\n            if x[i]==\\'1\\':\\n                l.append(i-prev)\\n                prev=i\\n                \\n        return max(l)\\n        \\n            \\n",
                "solutionTags": [],
                "code": "class Solution:\\n\\n\\n    def binaryGap(self, N: int) -> int:\\n        x=str(bin(N))[2:]\\n        l=[]\\n        prev=0\\n        \\n        for i in range(len(x)):\\n            if x[i]==\\'1\\':\\n                l.append(i-prev)\\n                prev=i\\n                \\n        return max(l)\\n        \\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 696308,
                "title": "java-simple-neat-solution-with-two-pointers-beat-100",
                "content": "\\t// Two pointers\\n    public int binaryGap(int N) {\\n        int max = 0;\\n        \\n        int i = 0, j = -1;\\n        while (N != 0) {\\n            if ((N & 1) > 0) {\\n                if (j >= 0) {\\n                    max = Math.max(max, i - j);\\n                }\\n                j = i;\\n            }\\n            \\n            N >>>= 1;\\n            i++;\\n        }\\n        \\n        return max;\\n    }\\n",
                "solutionTags": [],
                "code": "\\t// Two pointers\\n    public int binaryGap(int N) {\\n        int max = 0;\\n        \\n        int i = 0, j = -1;\\n        while (N != 0) {\\n            if ((N & 1) > 0) {\\n                if (j >= 0) {\\n                    max = Math.max(max, i - j);\\n                }\\n                j = i;\\n            }\\n            \\n            N >>>= 1;\\n            i++;\\n        }\\n        \\n        return max;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 654605,
                "title": "simple-c-solution-o-n-easy-to-understand-with-explain",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Binary Gap.\\nMemory Usage: 5.9 MB, less than 100.00% of C++ online submissions for Binary Gap.\\n**The problem is that find longest distance between two 1\\'s such that between them all the characters are 0;\\ne.g; 110000110 ans=5\\n11101 ans=2\\n100000001 ans=8\\n1001000100001 ans=5**\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int N) {\\n       string s=\"\";  //convert it into binary string\\n        while(N)\\n        {\\n            int p=N%2;\\n            if(p) s=\\'1\\'+s;\\n            else\\n                s=\\'0\\'+s;\\n            N/=2;\\n        }\\n        cout<<s<<\"\\\\n\";\\n        int i=0,k=0;\\n        while(s[i]!=\\'1\\')  //find position of first one in string\\n            i++;\\n        for(int j=i+1;j<s.length();j++)\\n            \\n        {  //cout<<i<<\" \";\\n            while(s[j]==\\'0\\') j++;  //find next position of one\\n          if(j>=s.size()) break; \\n            k=max(k,j-i); //store maximum length difference\\n            i=j;\\n         //cout<<j<<\" \\\\n\";\\n        }\\n        return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int N) {\\n       string s=\"\";  //convert it into binary string\\n        while(N)\\n        {\\n            int p=N%2;\\n            if(p) s=\\'1\\'+s;\\n            else\\n                s=\\'0\\'+s;\\n            N/=2;\\n        }\\n        cout<<s<<\"\\\\n\";\\n        int i=0,k=0;\\n        while(s[i]!=\\'1\\')  //find position of first one in string\\n            i++;\\n        for(int j=i+1;j<s.length();j++)\\n            \\n        {  //cout<<i<<\" \";\\n            while(s[j]==\\'0\\') j++;  //find next position of one\\n          if(j>=s.size()) break; \\n            k=max(k,j-i); //store maximum length difference\\n            i=j;\\n         //cout<<j<<\" \\\\n\";\\n        }\\n        return k;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 645879,
                "title": "o-log-binary-n-time-o-log-binary-n-space-java-solution",
                "content": "```\\n//O(log binary(N)) time where binary(N) is the binary string representation of N\\n    //O(log binary(N)) space taken by the string\\n    public int binaryGap(int N) {\\n        String n = Integer.toString(N,2);\\n        int first =-1, second =-1;\\n        int diff = 0;\\n        \\n        for(int i=0;i<n.length();i++){\\n            if(n.charAt(i) ==\\'1\\'){\\n                if(first == -1)\\n                    first = i;\\n                else if(second == -1){\\n                    second = i;\\n                    diff = Math.max(diff, second - first);\\n                }\\n                else{\\n                    first = second;\\n                    second = i;\\n                    diff = Math.max(diff, second - first);\\n                }\\n            }\\n        }\\n        \\n        return diff;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//O(log binary(N)) time where binary(N) is the binary string representation of N\\n    //O(log binary(N)) space taken by the string\\n    public int binaryGap(int N) {\\n        String n = Integer.toString(N,2);\\n        int first =-1, second =-1;\\n        int diff = 0;\\n        \\n        for(int i=0;i<n.length();i++){\\n            if(n.charAt(i) ==\\'1\\'){\\n                if(first == -1)\\n                    first = i;\\n                else if(second == -1){\\n                    second = i;\\n                    diff = Math.max(diff, second - first);\\n                }\\n                else{\\n                    first = second;\\n                    second = i;\\n                    diff = Math.max(diff, second - first);\\n                }\\n            }\\n        }\\n        \\n        return diff;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 639188,
                "title": "java-simple-solution",
                "content": "class Solution {\\n    public int binaryGap(int n)\\n    {\\n         int[] a = new int[1000]; \\n   \\n        \\n        int i = 0; \\n        while (n > 0)  \\n        { \\n           \\n            a[i] = n % 2; \\n            n = n / 2; \\n            i++; \\n        } \\n       \\n         int k=i-1;\\n         int d=0;\\n        int b=0;\\n        int c=0;\\n        int co=0;\\n        int max=0;\\n        for (int j = i - 1; j >= 0; j--) \\n        {\\n            if(a[j]==1 && co==0)\\n            {\\n                b=j;\\n                co++;\\n            }\\n            else\\n                if(a[j]==1)\\n                {\\n                  int t=b;\\n                    c=j;\\n                    d=t-c;\\n                    max=(max>=d)?max:d;\\n                    \\n                    b=c;                    \\n                }\\n                  \\n        }\\n        \\n        return max;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int binaryGap(int n)\\n    {\\n         int[] a = new int[1000]; \\n   \\n        \\n        int i = 0; \\n        while (n > 0)  \\n        { \\n           \\n            a[i] = n % 2; \\n            n = n / 2; \\n            i++; \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 628726,
                "title": "0ms-c-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int N) {\\n         vector<int>pos;\\n        for(int i=0;i<32;i++)\\n        {\\n            if((N&(1<<i)))\\n                pos.push_back(i);\\n        }\\n        int mx = 0;\\n        for(int i=1;i<pos.size();i++)\\n        {\\n            mx = max(mx,pos[i]-pos[i-1]);\\n        }\\n        return mx;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\npublic:\\n    int binaryGap(int N) {\\n         vector<int>pos;\\n        for(int i=0;i<32;i++)\\n        {\\n            if((N&(1<<i)))\\n                pos.push_back(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 608977,
                "title": "go-solution-clean-and-fast-beats-100",
                "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Binary Gap.\\nMemory Usage: 2.1 MB, less than 100.00% of Go online submissions for Binary Gap.\\n```\\nfunc binaryGap(N int) int {\\n    cnt, maxOnes := 0, 0\\n\\t// strip \\n    for N != 0 && N & 1 != 1 {\\n        N >>= 1\\n    }\\n    for N != 0 {\\n        if N&1 == 1 {\\n            maxOnes = max(maxOnes, cnt)\\n            cnt = 0\\n        }\\n        N >>= 1\\n        cnt++\\n    }\\n    return maxOnes \\n}\\n\\nfunc max(x, y int) int {\\n    if x > y { return x }\\n    return y\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc binaryGap(N int) int {\\n    cnt, maxOnes := 0, 0\\n\\t// strip \\n    for N != 0 && N & 1 != 1 {\\n        N >>= 1\\n    }\\n    for N != 0 {\\n        if N&1 == 1 {\\n            maxOnes = max(maxOnes, cnt)\\n            cnt = 0\\n        }\\n        N >>= 1\\n        cnt++\\n    }\\n    return maxOnes \\n}\\n\\nfunc max(x, y int) int {\\n    if x > y { return x }\\n    return y\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 578704,
                "title": "java-solution-use-bit-operation",
                "content": "```\\npublic int binaryGap(int N) {\\n    int gap = 0;\\n\\n    int cur = 0;\\n    int last = 33;\\n    while (N > 0) {\\n        if ((N & 1) == 1) {\\n            gap = Math.max(cur - last, gap);\\n            last = cur;\\n        }\\n\\n        cur++;\\n        N >>>= 1;\\n    }\\n\\n    return gap;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int binaryGap(int N) {\\n    int gap = 0;\\n\\n    int cur = 0;\\n    int last = 33;\\n    while (N > 0) {\\n        if ((N & 1) == 1) {\\n            gap = Math.max(cur - last, gap);\\n            last = cur;\\n        }\\n\\n        cur++;\\n        N >>>= 1;\\n    }\\n\\n    return gap;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 537449,
                "title": "c-simple-solution-beats-100-100-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int N) {\\n        int last = -1;\\n        int max = 0;\\n        // Run through each bit \\n        for (int i = 0; i < 32; i++) {\\n            // If the bit is a 1\\n            if (N & (1 << i))  {\\n                // If this isn\\'t the first bit, check to see if the\\n                // this bit defines the new max distance\\n                if (last != -1) max = std::max(max, i - last);\\n                // Change this bit to last\\n                last = i;\\n            }\\n        }\\n        return max;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int N) {\\n        int last = -1;\\n        int max = 0;\\n        // Run through each bit \\n        for (int i = 0; i < 32; i++) {\\n            // If the bit is a 1\\n            if (N & (1 << i))  {\\n                // If this isn\\'t the first bit, check to see if the\\n                // this bit defines the new max distance\\n                if (last != -1) max = std::max(max, i - last);\\n                // Change this bit to last\\n                last = i;\\n            }\\n        }\\n        return max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 528358,
                "title": "c-100-space-100-time-solution-o-log-n-time-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int N) {\\n        int gap = 0;\\n        int gap_so_far = 0;\\n        while(N % 2 == 0) {\\n            N /= 2;\\n        }\\n        while(N) {\\n            if (N % 2) {\\n                gap = max(gap, gap_so_far);\\n                gap_so_far = 1;\\n            } else {\\n                gap_so_far++;\\n            }\\n            N /= 2;\\n        }\\n        return gap;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int N) {\\n        int gap = 0;\\n        int gap_so_far = 0;\\n        while(N % 2 == 0) {\\n            N /= 2;\\n        }\\n        while(N) {\\n            if (N % 2) {\\n                gap = max(gap, gap_so_far);\\n                gap_so_far = 1;\\n            } else {\\n                gap_so_far++;\\n            }\\n            N /= 2;\\n        }\\n        return gap;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 515335,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int binaryGap(int N) {\\n        while ((N&0x1) == 0)\\n            N = N>>1;\\n        \\n        int d = 1;\\n        int max = 0;\\n        while (N>0) {\\n            N = N>>1;\\n            if ((N&0x1) == 0) {\\n                d++;\\n            }\\n            else {\\n                max = Math.max(max, d);\\n                d = 1;\\n            }\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int N) {\\n        while ((N&0x1) == 0)\\n            N = N>>1;\\n        \\n        int d = 1;\\n        int max = 0;\\n        while (N>0) {\\n            N = N>>1;\\n            if ((N&0x1) == 0) {\\n                d++;\\n            }\\n            else {\\n                max = Math.max(max, d);\\n                d = 1;\\n            }\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 410886,
                "title": "c-0ms-solution-using-bitset",
                "content": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int N) {\\n        bitset<32>b(N);\\n        int last=-1,ans=0;\\n        for(int i=0;i<32;++i){\\n            if(b[i]){\\n                ans=last==-1?0:max(ans,i-last);\\n                last=i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int N) {\\n        bitset<32>b(N);\\n        int last=-1,ans=0;\\n        for(int i=0;i<32;++i){\\n            if(b[i]){\\n                ans=last==-1?0:max(ans,i-last);\\n                last=i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 402093,
                "title": "java-0ms-100",
                "content": "```\\nclass Solution {\\n    public int binaryGap(int N) {\\n       int lastpos = -1;\\n\\t\\tint currentpos = -1;\\n\\t\\tint max = 0;\\n\\t\\twhile (N > 0) {\\n\\t\\t\\tint a = N % 2;\\n\\t\\t\\tcurrentpos++;\\n\\t\\t\\tif (a == 1) {\\n\\t\\t\\t\\tif (lastpos >= 0)\\n\\t\\t\\t\\t\\tmax = Math.max(max, currentpos - lastpos);\\n\\t\\t\\t\\tlastpos = currentpos;\\n\\t\\t\\t}\\n\\t\\t\\tN = N / 2;\\n\\n\\t\\t}\\n\\n\\t\\treturn max;    \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int N) {\\n       int lastpos = -1;\\n\\t\\tint currentpos = -1;\\n\\t\\tint max = 0;\\n\\t\\twhile (N > 0) {\\n\\t\\t\\tint a = N % 2;\\n\\t\\t\\tcurrentpos++;\\n\\t\\t\\tif (a == 1) {\\n\\t\\t\\t\\tif (lastpos >= 0)\\n\\t\\t\\t\\t\\tmax = Math.max(max, currentpos - lastpos);\\n\\t\\t\\t\\tlastpos = currentpos;\\n\\t\\t\\t}\\n\\t\\t\\tN = N / 2;\\n\\n\\t\\t}\\n\\n\\t\\treturn max;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 377082,
                "title": "simple-solution-using-bit-manipulation-java-0ms",
                "content": "Used a very simple concept of Bitwise AND (&) to check the last bit and Right shift (>>).\\n\\nclass Solution {\\n    public int binaryGap(int N) {\\n        int res = 0;\\n        int index = -1;\\n        int i=0;\\n        \\n        while(N>0){\\n            \\n            if((N&1) == 1){\\n                if(index >= 0){\\n                    res = Math.max(res, (i-index));\\n                }\\n                index = i;\\n            }\\n            \\n            N = N >> 1;\\n            i++;\\n        }\\n        \\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int binaryGap(int N) {\\n        int res = 0;\\n        int index = -1;\\n        int i=0;\\n        \\n        while(N>0){\\n            \\n            if((N&1) == 1){\\n                if(index >= 0){\\n                    res = Math.max(res, (i-index));\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 360221,
                "title": "go-golang-0ms-clean-solution",
                "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Binary Gap.\\nMemory Usage: 2 MB, less than 100.00% of Go online submissions for Binary Gap.\\n\\n```go\\nfunc binaryGap(N int) int {\\n\\n\\ts := strconv.FormatInt(int64(N), 2)\\n\\tone := \"1\"\\n\\tindexArr := []int{}\\n\\tgap := []int{}\\n\\ttmp := 0\\n\\n\\tfor i, v := range s {\\n\\t\\tif string(v) == one {\\n\\t\\t\\tindexArr = append(indexArr, i)\\n\\t\\t}\\n\\t}\\n\\tfor i := len(indexArr); i > 0; i-- {\\n\\t\\tif i-2 >= 0 {\\n\\t\\t\\tgap = append(gap, indexArr[i-1]-indexArr[i-2])\\n\\t\\t}\\n\\t}\\n\\tfor _, v := range gap {\\n\\t\\tif v > tmp {\\n\\t\\t\\ttmp = v\\n\\t\\t}\\n\\t}\\n\\treturn tmp\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc binaryGap(N int) int {\\n\\n\\ts := strconv.FormatInt(int64(N), 2)\\n\\tone := \"1\"\\n\\tindexArr := []int{}\\n\\tgap := []int{}\\n\\ttmp := 0\\n\\n\\tfor i, v := range s {\\n\\t\\tif string(v) == one {\\n\\t\\t\\tindexArr = append(indexArr, i)\\n\\t\\t}\\n\\t}\\n\\tfor i := len(indexArr); i > 0; i-- {\\n\\t\\tif i-2 >= 0 {\\n\\t\\t\\tgap = append(gap, indexArr[i-1]-indexArr[i-2])\\n\\t\\t}\\n\\t}\\n\\tfor _, v := range gap {\\n\\t\\tif v > tmp {\\n\\t\\t\\ttmp = v\\n\\t\\t}\\n\\t}\\n\\treturn tmp\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 297792,
                "title": "simple-python-solution-faster-than-94-64-and-less-than-83-31-of-python3",
                "content": "it\\'s pretty simple solution and easy to understand \\n\\n```\\nclass Solution:\\n    def binaryGap(self, N: int) -> int:\\n        BinaryN =bin(N)\\n        BinaryN = BinaryN[2::]\\n        FoundOne = False\\n        Max=0\\n        count=0\\n\\n        for i in BinaryN:\\n            \\n            if(i == \\'1\\'):\\n                if(FoundOne == True):\\n                    Max = max(count,Max)\\n                    count =0   \\n\\n                else:\\n                    FoundOne = True\\n                    \\n            if(FoundOne):\\n                count = count+1\\n            \\n                \\n        return Max\\n                    \\n                \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, N: int) -> int:\\n        BinaryN =bin(N)\\n        BinaryN = BinaryN[2::]\\n        FoundOne = False\\n        Max=0\\n        count=0\\n\\n        for i in BinaryN:\\n            \\n            if(i == \\'1\\'):\\n                if(FoundOne == True):\\n                    Max = max(count,Max)\\n                    count =0   \\n\\n                else:\\n                    FoundOne = True\\n                    \\n            if(FoundOne):\\n                count = count+1\\n            \\n                \\n        return Max\\n                    \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 293442,
                "title": "o-log-log-n",
                "content": "```\\nint binaryGap(int x){\\n    x>>=__builtin_ctz(x);\\n    if (x==1)return 0;\\n    int y=x,s=0; y|=y>>1; y|=y>>2; y|=y>>4; y|=y>>8; y|=y>>16;\\n    if (x==y)return 1;\\n    if ((x|x>>1)!=y)x|=x>>1,s+=1;else goto l3;\\n    if ((x|x>>2)!=y)x|=x>>2,s+=2;else goto l2;\\n    if ((x|x>>4)!=y)x|=x>>4,s+=4;else goto l1;\\n    if ((x|x>>8)!=y)x|=x>>8,s+=8;\\n    if ((x|x>>4)!=y)x|=x>>4,s+=4;\\n    l1:if ((x|x>>2)!=y)x|=x>>2,s+=2;\\n    l2:if ((x|x>>1)!=y)x|=x>>1,s+=1;\\n    l3:return s+2;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint binaryGap(int x){\\n    x>>=__builtin_ctz(x);\\n    if (x==1)return 0;\\n    int y=x,s=0; y|=y>>1; y|=y>>2; y|=y>>4; y|=y>>8; y|=y>>16;\\n    if (x==y)return 1;\\n    if ((x|x>>1)!=y)x|=x>>1,s+=1;else goto l3;\\n    if ((x|x>>2)!=y)x|=x>>2,s+=2;else goto l2;\\n    if ((x|x>>4)!=y)x|=x>>4,s+=4;else goto l1;\\n    if ((x|x>>8)!=y)x|=x>>8,s+=8;\\n    if ((x|x>>4)!=y)x|=x>>4,s+=4;\\n    l1:if ((x|x>>2)!=y)x|=x>>2,s+=2;\\n    l2:if ((x|x>>1)!=y)x|=x>>1,s+=1;\\n    l3:return s+2;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 286322,
                "title": "python-split-bin-n-by-1",
                "content": "```\\nclass Solution:\\n    def binaryGap(self, N: int) -> int:\\n        a = bin(N)[2:].split(\\'1\\')[1:-1]\\n        if len(a) == 0:\\n            return 0\\n        else:\\n            return max(map(len, a)) + 1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, N: int) -> int:\\n        a = bin(N)[2:].split(\\'1\\')[1:-1]\\n        if len(a) == 0:\\n            return 0\\n        else:\\n            return max(map(len, a)) + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 260480,
                "title": "functional-js-solution-faster-than-90",
                "content": "```\\n/**\\n * @param {number} N\\n * @return {number}\\n */\\nvar binaryGap = function(N) {\\n    const str = N.toString(2);\\n    const bits = str.split(\\'\\');\\n    \\n    let maxDist = 0;\\n    let countBeginIndex = 0;\\n    bits.forEach((bit, index) => {\\n        if (bit !== \\'1\\') {\\n            return;\\n        }\\n        \\n        maxDist = Math.max(index - countBeginIndex, maxDist);\\n        countBeginIndex = index;\\n    });\\n    \\n    return maxDist;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} N\\n * @return {number}\\n */\\nvar binaryGap = function(N) {\\n    const str = N.toString(2);\\n    const bits = str.split(\\'\\');\\n    \\n    let maxDist = 0;\\n    let countBeginIndex = 0;\\n    bits.forEach((bit, index) => {\\n        if (bit !== \\'1\\') {\\n            return;\\n        }\\n        \\n        maxDist = Math.max(index - countBeginIndex, maxDist);\\n        countBeginIndex = index;\\n    });\\n    \\n    return maxDist;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 160233,
                "title": "fast-swift-solution",
                "content": "```\\nclass Solution {\\n    func binaryGap(_ N: Int) -> Int {\\n        let str = String(N, radix: 2)\\n\\n        let position = str.enumerated().compactMap {\\n            $0.element == \"1\" ? $0.offset : nil\\n        }\\n\\n        if position.count <= 1  {\\n            return 0\\n        } else {\\n            var curGap = abs(position[0] - position[1])\\n\\n            for index in 1..<position.count - 1 {\\n                curGap = max(curGap, abs(position[index] - position[index + 1]))\\n            }\\n\\n            return curGap\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func binaryGap(_ N: Int) -> Int {\\n        let str = String(N, radix: 2)\\n\\n        let position = str.enumerated().compactMap {\\n            $0.element == \"1\" ? $0.offset : nil\\n        }\\n\\n        if position.count <= 1  {\\n            return 0\\n        } else {\\n            var curGap = abs(position[0] - position[1])\\n\\n            for index in 1..<position.count - 1 {\\n                curGap = max(curGap, abs(position[index] - position[index + 1]))\\n            }\\n\\n            return curGap\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 158803,
                "title": "c-solution-using-while-loop",
                "content": "```\\npublic class Solution\\n{\\n    public int BinaryGap(int N)\\n    {\\n        if ((N & (N - 1)) == 0) // Checks for N == 0 and N being a power of two\\n            return 0;\\n        // If the preceding condition was false then N has at leat two 1s\\n        while ((N & 1) == 0) // Find the first 1\\n            N >>= 1;\\n        N >>= 1; // Since we\\'re intrested in the gap between 1s the first 1 is skipped\\n\\t\\t\\t\\t//(otherwise it would cause an additional meaningless iteration of the following loop)\\n        int maxGap = 0;\\n        int gap = 0;\\n        while (N != 0)\\n        {\\n            if ((N & 1) == 0) // If it\\'s 0 then increase the current gap\\n                gap++;\\n            else // If it\\'s 1\\n            {\\n                if (gap > maxGap) // If current gap is bigger than the max one we change the max\\n                    maxGap = gap;\\n                gap = 0; // Reset the counter\\n            }\\n            N >>= 1;\\n        }\\n        return maxGap + 1; // Because maxGap holds the number of 0s between two 1s we increment it to represent the gap\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    public int BinaryGap(int N)\\n    {\\n        if ((N & (N - 1)) == 0) // Checks for N == 0 and N being a power of two\\n            return 0;\\n        // If the preceding condition was false then N has at leat two 1s\\n        while ((N & 1) == 0) // Find the first 1\\n            N >>= 1;\\n        N >>= 1; // Since we\\'re intrested in the gap between 1s the first 1 is skipped\\n\\t\\t\\t\\t//(otherwise it would cause an additional meaningless iteration of the following loop)\\n        int maxGap = 0;\\n        int gap = 0;\\n        while (N != 0)\\n        {\\n            if ((N & 1) == 0) // If it\\'s 0 then increase the current gap\\n                gap++;\\n            else // If it\\'s 1\\n            {\\n                if (gap > maxGap) // If current gap is bigger than the max one we change the max\\n                    maxGap = gap;\\n                gap = 0; // Reset the counter\\n            }\\n            N >>= 1;\\n        }\\n        return maxGap + 1; // Because maxGap holds the number of 0s between two 1s we increment it to represent the gap\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 151314,
                "title": "simple-java-solution",
                "content": "```\\npublic int binaryGap(int N) {\\n        int max = 0, lastSeen=-1, tmp = 0, curr = 0;\\n        while(N != 0){\\n            tmp = N % 2;\\n            if(tmp == 1){\\n                if(lastSeen != -1) /*do not calc distance for first \\'1\\'*/\\n                    max = Math.max(max, curr-lastSeen);\\n                lastSeen = curr;\\n            }\\n            N/=2;\\n            ++curr;\\n        }\\n        return max;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int binaryGap(int N) {\\n        int max = 0, lastSeen=-1, tmp = 0, curr = 0;\\n        while(N != 0){\\n            tmp = N % 2;\\n            if(tmp == 1){\\n                if(lastSeen != -1) /*do not calc distance for first \\'1\\'*/\\n                    max = Math.max(max, curr-lastSeen);\\n                lastSeen = curr;\\n            }\\n            N/=2;\\n            ++curr;\\n        }\\n        return max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 150926,
                "title": "c-average-case-faster-than-simple-right-shifting-0-ms",
                "content": "```\\n\\nclass Solution {\\n   \\n    constexpr inline int trailing_zero(int n) {\\n    \\n        constexpr int table[] = {32, 0, 1,\\n            26, 2, 23, 27, 0, 3, 16, 24, 30, 28, 11,\\n            0, 13, 4, 7, 17, 0, 25, 22, 31, 15, 29,\\n            10, 12, 6, 0, 21, 14, 9, 5, 20, 8, 19,\\n            18};\\n        \\n        \\n        return table[(-n & n) % 37];        \\n    }\\n    \\npublic:\\n    int binaryGap(int N) {\\n        int m = 0;\\n        \\n        int last = trailing_zero(N);\\n        while(N) {\\n            int t = trailing_zero(N);  // computes the number of zeros to the right of the rightmost one\\n            \\n            m = max(m, t - last);\\n            last = t;\\n                        \\n            N -= (1 << t);  // Zeroes out the rightmost one\\n        }\\n        \\n        return m;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n   \\n    constexpr inline int trailing_zero(int n) {\\n    \\n        constexpr int table[] = {32, 0, 1,\\n            26, 2, 23, 27, 0, 3, 16, 24, 30, 28, 11,\\n            0, 13, 4, 7, 17, 0, 25, 22, 31, 15, 29,\\n            10, 12, 6, 0, 21, 14, 9, 5, 20, 8, 19,\\n            18};\\n        \\n        \\n        return table[(-n & n) % 37];        \\n    }\\n    \\npublic:\\n    int binaryGap(int N) {\\n        int m = 0;\\n        \\n        int last = trailing_zero(N);\\n        while(N) {\\n            int t = trailing_zero(N);  // computes the number of zeros to the right of the rightmost one\\n            \\n            m = max(m, t - last);\\n            last = t;\\n                        \\n            N -= (1 << t);  // Zeroes out the rightmost one\\n        }\\n        \\n        return m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 150846,
                "title": "python-solution-using-3-if-statements-and-a-counter",
                "content": "```\\nclass Solution:\\n    def binaryGap(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        max_num = 0\\n        counting = False\\n        counter = 0\\n        binary = bin(N)\\n        \\n        for index in range(0, len(binary)):\\n            \\n            if (binary[index] == \\'1\\') and (counting == False):\\n                counting = True\\n                \\n            elif (binary[index] != \\'1\\') and (counting == True):\\n                counter += 1\\n                \\n            elif (binary[index] == \\'1\\') and (counting == True):\\n                counter += 1\\n                if counter > max_num:\\n                    max_num = counter\\n                counter = 0\\n                \\n        return max_num\\n\\t\\t\\t\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        max_num = 0\\n        counting = False\\n        counter = 0\\n        binary = bin(N)\\n        \\n        for index in range(0, len(binary)):\\n            \\n            if (binary[index] == \\'1\\') and (counting == False):\\n                counting = True\\n                \\n            elif (binary[index] != \\'1\\') and (counting == True):\\n                counter += 1\\n                \\n            elif (binary[index] == \\'1\\') and (counting == True):\\n                counter += 1\\n                if counter > max_num:\\n                    max_num = counter\\n                counter = 0\\n                \\n        return max_num\\n\\t\\t\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 149904,
                "title": "c-like-languages-o-1-simple-solution",
                "content": "In fact, I realized that it\\'s O(log N) thanks to [@sasha.pad](https://leetcode.com/sashapad) reminded me. Sorry to showed an inaccurate statement to you.\\n```C\\nint binaryGap(int N) {\\n    int max = 0;\\n    int dis = 0;\\n    // get the rightmost 1\\n    while (N % 2 == 0)\\n        N >>= 1;\\n    // find the max distance\\n    while (N != 0) {\\n        N >>= 1;\\n        ++dis;\\n        if (N % 2 == 1) {\\n            if (dis > max)\\n                max = dis;\\n            dis = 0;\\n        }\\n    }\\n    return max;\\n}\\n```",
                "solutionTags": [],
                "code": "```C\\nint binaryGap(int N) {\\n    int max = 0;\\n    int dis = 0;\\n    // get the rightmost 1\\n    while (N % 2 == 0)\\n        N >>= 1;\\n    // find the max distance\\n    while (N != 0) {\\n        N >>= 1;\\n        ++dis;\\n        if (N % 2 == 1) {\\n            if (dis > max)\\n                max = dis;\\n            dis = 0;\\n        }\\n    }\\n    return max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 149841,
                "title": "simple-java-o-1-time",
                "content": "Just maintain a variable which is a power of 2 (i.e. contains only 1 one). We right shift this every time in a loop taking at max 32 right shfift for an integer. Simply keep track of `lastPosition` where we found a one and a `max` distance between 1\\'s. \\n```\\nclass  Solution {\\n    public int binaryGap(int N) {\\n        int dist = 1, lastPos = -1, incr = 0 ; \\n        int max = Integer.MIN_VALUE; \\n        while(dist <= N){\\n            dist = 1 << incr; \\n            if((dist & N) > 0 ){\\n                if(lastPos != -1)max = Math.max(max, incr - lastPos); \\n                lastPos = incr; \\n            }\\n            incr++; \\n        }\\n        return max==Integer.MIN_VALUE ? 0 : max; \\n    }\\n}\\n```\\n\\nA bit more compact version \\n```\\nclass Solution {\\n    public int binaryGap(int N) {\\n        int max = Integer.MIN_VALUE; \\n        for(int dist = 1, lastPos = -1, incr = 0; (dist = (1 << incr)) <= N; incr++)\\n            if((dist & N) > 0 ){\\n                if(lastPos != -1)max = Math.max(max, incr - lastPos); \\n                lastPos = incr ;\\n            }\\n        return max==Integer.MIN_VALUE ? 0 : max; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass  Solution {\\n    public int binaryGap(int N) {\\n        int dist = 1, lastPos = -1, incr = 0 ; \\n        int max = Integer.MIN_VALUE; \\n        while(dist <= N){\\n            dist = 1 << incr; \\n            if((dist & N) > 0 ){\\n                if(lastPos != -1)max = Math.max(max, incr - lastPos); \\n                lastPos = incr; \\n            }\\n            incr++; \\n        }\\n        return max==Integer.MIN_VALUE ? 0 : max; \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int binaryGap(int N) {\\n        int max = Integer.MIN_VALUE; \\n        for(int dist = 1, lastPos = -1, incr = 0; (dist = (1 << incr)) <= N; incr++)\\n            if((dist & N) > 0 ){\\n                if(lastPos != -1)max = Math.max(max, incr - lastPos); \\n                lastPos = incr ;\\n            }\\n        return max==Integer.MIN_VALUE ? 0 : max; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4086691,
                "title": "bitset-lib",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n      bitset<sizeof(int) * 8> binary(n);\\n      string binaryStr = binary.to_string();\\n      int last1 = -1;\\n      int gap = 0;\\n      for (int i = 0; i < binaryStr.size(); ++i) {\\n        char cur = binaryStr[i];\\n        if (cur == \\'1\\') {\\n          if (last1 >= 0) {\\n            int diff = i - last1;\\n            gap = max(gap,diff);\\n          }\\n          last1 = i;\\n        }\\n      }\\n      return gap;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n      bitset<sizeof(int) * 8> binary(n);\\n      string binaryStr = binary.to_string();\\n      int last1 = -1;\\n      int gap = 0;\\n      for (int i = 0; i < binaryStr.size(); ++i) {\\n        char cur = binaryStr[i];\\n        if (cur == \\'1\\') {\\n          if (last1 >= 0) {\\n            int diff = i - last1;\\n            gap = max(gap,diff);\\n          }\\n          last1 = i;\\n        }\\n      }\\n      return gap;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055804,
                "title": "c-easy-and-readable-solution-faster-than-70",
                "content": "![image.png](https://assets.leetcode.com/users/images/aaf78b84-c2d4-40bf-89c6-7aa0d31faa17_1694955763.498142.png)\\n\\n**Don\\'t hesitate to suggest or ask bellow about something that you don\\'t understand**\\n\\n```\\npublic class Solution {\\n    public int BinaryGap(int n) {\\n        int previouse = 32;\\n        int distance = 0;\\n        int pos = 0;\\n        while (n > 0)\\n        {\\n            if (n % 2 == 1)\\n            {\\n                distance = Math.Max(distance, pos - previouse);\\n                previouse = pos;\\n            }\\n            n /= 2;\\n            pos++;\\n        }\\n        return distance;\\n    }\\n}\\n```\\n\\nIf you like it don\\'t forget to **upvote!**",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int BinaryGap(int n) {\\n        int previouse = 32;\\n        int distance = 0;\\n        int pos = 0;\\n        while (n > 0)\\n        {\\n            if (n % 2 == 1)\\n            {\\n                distance = Math.Max(distance, pos - previouse);\\n                previouse = pos;\\n            }\\n            n /= 2;\\n            pos++;\\n        }\\n        return distance;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4054572,
                "title": "easiest-solution",
                "content": "\\n\\n# Code\\n```java []\\nclass Solution {\\n     public int binaryGap(int n) {\\n        int lastPos =-1;\\n        int max = 0;\\n        int pos =0;\\n        \\n       while(n>0){\\n         pos++;\\n           if((n&1)==1){\\n               if(lastPos!=-1){\\n                   max = Math.max(max, pos-lastPos);\\n               }\\n               lastPos = pos;\\n           }\\n           n= n/2;\\n       }\\n        return max;\\n        \\n    }\\n}\\n```\\n```c++ []\\nclass Solution {\\n public:\\n  int BinaryGap(int n) {\\n    int index = 0, prev_index = -1;\\n    int max_distance = 0;\\n\\n    while (n) {\\n      if (n & 1) {\\n        if (prev_index != -1)\\n          max_distance = std::max(max_distance, index - prev_index);\\n        prev_index = index;\\n      }\\n      n >>= 1, index++;\\n    }\\n\\n    return max_distance;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n     public int binaryGap(int n) {\\n        int lastPos =-1;\\n        int max = 0;\\n        int pos =0;\\n        \\n       while(n>0){\\n         pos++;\\n           if((n&1)==1){\\n               if(lastPos!=-1){\\n                   max = Math.max(max, pos-lastPos);\\n               }\\n               lastPos = pos;\\n           }\\n           n= n/2;\\n       }\\n        return max;\\n        \\n    }\\n}\\n```\n```c++ []\\nclass Solution {\\n public:\\n  int BinaryGap(int n) {\\n    int index = 0, prev_index = -1;\\n    int max_distance = 0;\\n\\n    while (n) {\\n      if (n & 1) {\\n        if (prev_index != -1)\\n          max_distance = std::max(max_distance, index - prev_index);\\n        prev_index = index;\\n      }\\n      n >>= 1, index++;\\n    }\\n\\n    return max_distance;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048317,
                "title": "fastest-c-single-pass-easy-to-understand",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) { \\n        int distance=0;\\n        int last=-1;\\n        int i=1;\\n        while(n)\\n        {\\n            if((n&1)==1)\\n            {\\n                if(i-last!=i+1)\\n                distance=max(distance,i-last);\\n                last=i;\\n            }\\n            n=n>>1;\\n            i++;\\n        }\\n        return distance;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) { \\n        int distance=0;\\n        int last=-1;\\n        int i=1;\\n        while(n)\\n        {\\n            if((n&1)==1)\\n            {\\n                if(i-last!=i+1)\\n                distance=max(distance,i-last);\\n                last=i;\\n            }\\n            n=n>>1;\\n            i++;\\n        }\\n        return distance;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048241,
                "title": "fastest-c-easy-to-understand",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(logn)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        vector<int> positions;\\n        int i=1;\\n        while(n)\\n        {\\n            if((n&1)==1)\\n            {\\n                positions.push_back(i);\\n            }\\n            n=n>>1;\\n            i++;\\n        }\\n        int ans=INT_MIN;\\n        for(int i=1;i<positions.size();i++)\\n        ans=max(ans,positions[i]-positions[i-1]);\\n        if(ans==INT_MIN)\\n        return 0;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        vector<int> positions;\\n        int i=1;\\n        while(n)\\n        {\\n            if((n&1)==1)\\n            {\\n                positions.push_back(i);\\n            }\\n            n=n>>1;\\n            i++;\\n        }\\n        int ans=INT_MIN;\\n        for(int i=1;i<positions.size();i++)\\n        ans=max(ans,positions[i]-positions[i-1]);\\n        if(ans==INT_MIN)\\n        return 0;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037525,
                "title": "100-faster-with-branchless-techniques",
                "content": "# Intuition\\nMy attempt to get rid of as much branching as possible, even though the compiler will probably do better with optimization flags.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        auto max_distance = 0;\\n        while (!(n & 1)) n >>= 1;\\n        auto distance = 0;\\n        while (n != 0) {\\n            const bool increase = (max_distance - distance) & (1 << 31);\\n            max_distance = increase * distance + (!increase) * max_distance;\\n            distance = !(n & 1) * distance + 1;\\n            n >>= 1;\\n        }\\n        return max_distance;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        auto max_distance = 0;\\n        while (!(n & 1)) n >>= 1;\\n        auto distance = 0;\\n        while (n != 0) {\\n            const bool increase = (max_distance - distance) & (1 << 31);\\n            max_distance = increase * distance + (!increase) * max_distance;\\n            distance = !(n & 1) * distance + 1;\\n            n >>= 1;\\n        }\\n        return max_distance;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4031355,
                "title": "for-loop-java-sol",
                "content": "# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n            String b = Integer.toBinaryString(n);\\n    int max = 0, t = 0, j = b.indexOf(\\'1\\');\\n\\n    // System.out.println(b);\\n    // System.out.println(b.indexOf(\\'1\\'));\\n\\n    for (int i = j + 1; i < b.length(); i++) {\\n      if (b.charAt(i) == \\'1\\') {\\n        t = i - j;\\n        max = Math.max(t, max);\\n        j = i;\\n      }\\n    }\\n    return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n            String b = Integer.toBinaryString(n);\\n    int max = 0, t = 0, j = b.indexOf(\\'1\\');\\n\\n    // System.out.println(b);\\n    // System.out.println(b.indexOf(\\'1\\'));\\n\\n    for (int i = j + 1; i < b.length(); i++) {\\n      if (b.charAt(i) == \\'1\\') {\\n        t = i - j;\\n        max = Math.max(t, max);\\n        j = i;\\n      }\\n    }\\n    return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4030878,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int ans=0;\\n        int count=0;\\n        if((n&(n-1))==0){\\n            return 0;\\n        }\\n        boolean yes=false;\\n        while(n>0){\\n            if((n&1)==1){\\n                if(count>ans){\\n                    ans=count;\\n                }\\n                count=1;\\n                yes=true;\\n            }\\n            if((n&1)==0){\\n                if(yes==true){\\n                    count++;\\n                }  \\n            }\\n            n=n>>1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int ans=0;\\n        int count=0;\\n        if((n&(n-1))==0){\\n            return 0;\\n        }\\n        boolean yes=false;\\n        while(n>0){\\n            if((n&1)==1){\\n                if(count>ans){\\n                    ans=count;\\n                }\\n                count=1;\\n                yes=true;\\n            }\\n            if((n&1)==0){\\n                if(yes==true){\\n                    count++;\\n                }  \\n            }\\n            n=n>>1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4024404,
                "title": "easy-python-solution-using-list-comprehension-and-bin-function-beats-81",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/b25e8437-66c7-427b-9cf4-7703085d7645_1694311239.7161283.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        a=(bin(n))[2:]\\n        l=[i for i in range(len(a)) if a[i]==\"1\"]\\n        temp=0\\n        for i in range(len(l)-1):\\n            x=l[i+1]-l[i]\\n            if x>temp:\\n                temp=x\\n        return temp\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        a=(bin(n))[2:]\\n        l=[i for i in range(len(a)) if a[i]==\"1\"]\\n        temp=0\\n        for i in range(len(l)-1):\\n            x=l[i+1]-l[i]\\n            if x>temp:\\n                temp=x\\n        return temp\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4017029,
                "title": "java-solution-using-bit-manipulation",
                "content": "# Intuition\\nUsing bit operations like and operation with 1 followed by right shift of 1 we can solve this.\\n\\n# Approach\\n(n & 1) will yeild right most bit. Whenever we see right most bit as 1, we will compare is there any max previous distance. If it is not 1 then we increment the distance.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int count = 0;\\n        int max = 0;\\n        while(n > 0) {\\n            if ((n & 1) == 1) {\\n                max = Math.max(count, max);\\n                count = 1;\\n            } else if(count > 0) {\\n                count++;\\n            }\\n            n >>= 1;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int count = 0;\\n        int max = 0;\\n        while(n > 0) {\\n            if ((n & 1) == 1) {\\n                max = Math.max(count, max);\\n                count = 1;\\n            } else if(count > 0) {\\n                count++;\\n            }\\n            n >>= 1;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011074,
                "title": "python-rust-solutions",
                "content": "# Code\\n```python []\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        result, prev = 0, None\\n        for index, char in enumerate(f\"{n:b}\"):\\n            if char == \"1\":\\n                if prev is not None:\\n                    result = max(result, index - prev)\\n                prev = index\\n\\n        return result\\n```\\n```rust []\\nimpl Solution {\\n    pub fn binary_gap(n: i32) -> i32 {\\n        let mut result = usize::MIN;\\n        let mut prev: Option<usize> = None;\\n\\n        for (index, char) in format!(\"{:b}\", n).char_indices() {\\n            if char == \\'1\\' {\\n                if let Some(x) = prev {\\n                    result = result.max(index - x);\\n                }\\n                prev = Some(index);\\n            }\\n        }\\n\\n        result as _\\n    }\\n}\\n```",
                "solutionTags": [
                    "Python3",
                    "Rust"
                ],
                "code": "```python []\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        result, prev = 0, None\\n        for index, char in enumerate(f\"{n:b}\"):\\n            if char == \"1\":\\n                if prev is not None:\\n                    result = max(result, index - prev)\\n                prev = index\\n\\n        return result\\n```\n```rust []\\nimpl Solution {\\n    pub fn binary_gap(n: i32) -> i32 {\\n        let mut result = usize::MIN;\\n        let mut prev: Option<usize> = None;\\n\\n        for (index, char) in format!(\"{:b}\", n).char_indices() {\\n            if char == \\'1\\' {\\n                if let Some(x) = prev {\\n                    result = result.max(index - x);\\n                }\\n                prev = Some(index);\\n            }\\n        }\\n\\n        result as _\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010516,
                "title": "typescript-javascript-regex-solution",
                "content": "```ts\\nfunction binaryGap(n: number): number {\\n    const bin = n.toString(2);\\n    const timeAppear: number = `${bin}`.match(/1/g)?.length || 0;\\n    if(timeAppear < 2) return 0;\\n    let maxGap: number = 0;\\n    let gap: number = 0;\\n    const binArr = bin.replace(/^0+|0+$/g, \"\").split(\\'\\');\\n    for(let num of binArr){\\n        gap++;\\n        if(gap > maxGap) maxGap = gap;\\n        if(num == \\'1\\') gap = 0;\\n    }\\n    return maxGap;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```ts\\nfunction binaryGap(n: number): number {\\n    const bin = n.toString(2);\\n    const timeAppear: number = `${bin}`.match(/1/g)?.length || 0;\\n    if(timeAppear < 2) return 0;\\n    let maxGap: number = 0;\\n    let gap: number = 0;\\n    const binArr = bin.replace(/^0+|0+$/g, \"\").split(\\'\\');\\n    for(let num of binArr){\\n        gap++;\\n        if(gap > maxGap) maxGap = gap;\\n        if(num == \\'1\\') gap = 0;\\n    }\\n    return maxGap;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4004034,
                "title": "the-best-available-solution-that-beats-100-of-existing-solution",
                "content": "# Intuition\\nThe problem requires finding the maximum distance between two \\'1\\'s in the binary representation of a given integer \\'n\\'. To solve this problem, you can first convert the integer \\'n\\' to its binary representation as a string, and then iterate through the string to find the maximum gap between two \\'1\\'s. This gap represents the distance between two consecutive \\'1\\'s in the binary representation.\\n\\n# Approach\\n1. Initialize an empty string \\'bin\\' to store the binary representation of \\'n\\'.\\n2. Initialize a variable \\'result\\' to store the maximum binary gap, initially set to 0.\\n3. Use a while loop to convert \\'n\\' to its binary representation:\\n   a. Check if \\'n\\' is even (n % 2 == 0), and if so, insert \\'0\\' at the beginning of the \\'bin\\' string.\\n   b. Otherwise, insert \\'1\\' at the beginning of the \\'bin\\' string.\\n   c. Update \\'n\\' by performing integer division by 2 (n /= 2).\\n4. Initialize a temporary variable \\'temp\\' to 0, which will be used to keep track of the current binary gap.\\n5. Iterate through the \\'bin\\' string:\\n   a. If the current character is \\'1\\' and \\'temp\\' is 0, increment \\'temp\\' by 1.\\n   b. If the current character is \\'0\\', increment \\'temp\\' by 1.\\n   c. If the current character is \\'1\\' and \\'temp\\' is not 0, update \\'result\\' with the maximum of \\'result\\' and \\'temp\\', then reset \\'temp\\' to 1.\\n6. After the loop, return \\'result\\' as the maximum binary gap.\\n\\n# Complexity\\n- Time complexity: The time complexity of this solution depends on the number of bits in the binary representation of \\'n\\'. In the worst case, \\'n\\' has \\'log2(n)\\' bits. Therefore, the time complexity is O(log n) for converting \\'n\\' to its binary representation and O(log n) for iterating through the binary representation, resulting in an overall time complexity of O(log n).\\n\\n- Space complexity: Space Complexity: The space complexity is determined by the space needed for the \\'bin\\' string, which stores the binary representation of \\'n\\'. In the worst case, the length of the binary representation is \\'log2(n)\\' characters. Thus, the space complexity is O(log n) for the \\'bin\\' string, and O(1) for other variables.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        string bin;\\n        int result = 0;\\n        while(n > 0)\\n        {\\n            if(n % 2 == 0){\\n                bin.insert(bin.begin() + 0, \\'0\\');\\n            }\\n            else{\\n                bin.insert(bin.begin() + 0, \\'1\\');\\n            }\\n            n /= 2;\\n        }\\n        int temp = 0;\\n        for(int i = 0; i < bin.length(); ++i)\\n        {\\n            if((bin[i] == \\'1\\' && temp == 0) || bin[i] == \\'0\\')\\n            {\\n                ++temp;\\n            }\\n            else{\\n                if(result < temp)\\n                    result = temp;\\n                temp = 1;\\n            }\\n        }\\n        return result;\\n        \\n    }\\n}; \\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        string bin;\\n        int result = 0;\\n        while(n > 0)\\n        {\\n            if(n % 2 == 0){\\n                bin.insert(bin.begin() + 0, \\'0\\');\\n            }\\n            else{\\n                bin.insert(bin.begin() + 0, \\'1\\');\\n            }\\n            n /= 2;\\n        }\\n        int temp = 0;\\n        for(int i = 0; i < bin.length(); ++i)\\n        {\\n            if((bin[i] == \\'1\\' && temp == 0) || bin[i] == \\'0\\')\\n            {\\n                ++temp;\\n            }\\n            else{\\n                if(result < temp)\\n                    result = temp;\\n                temp = 1;\\n            }\\n        }\\n        return result;\\n        \\n    }\\n}; \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980521,
                "title": "easy-python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        def adjDif(arr):\\n            ans = 0\\n            for i in range(len(arr) - 1):\\n                if arr[i + 1] - arr[i] > ans:\\n                    ans = arr[i + 1] - arr[i]\\n            return ans\\n\\n\\n        index = []\\n        arr = list(str(bin(n))[2:])\\n\\n        for i in range(len(arr)):\\n            if arr[i] == \\'1\\':\\n                index.append(i)\\n                \\n        return adjDif(index)\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        def adjDif(arr):\\n            ans = 0\\n            for i in range(len(arr) - 1):\\n                if arr[i + 1] - arr[i] > ans:\\n                    ans = arr[i + 1] - arr[i]\\n            return ans\\n\\n\\n        index = []\\n        arr = list(str(bin(n))[2:])\\n\\n        for i in range(len(arr)):\\n            if arr[i] == \\'1\\':\\n                index.append(i)\\n                \\n        return adjDif(index)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3967409,
                "title": "c-solution-with-tc-o-logn-sc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int BinaryGap(int n) {\\n        int ans=0;\\n        bool countS=false;\\n        int i=0;\\n        while(n>0){\\n            if((n&1)==1){\\n                countS=true;\\n                ans=Math.Max(ans,i);\\n                i=1;\\n            }else{\\n                if(countS)\\n                   i++;     \\n            }\\n            n=n>>1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int BinaryGap(int n) {\\n        int ans=0;\\n        bool countS=false;\\n        int i=0;\\n        while(n>0){\\n            if((n&1)==1){\\n                countS=true;\\n                ans=Math.Max(ans,i);\\n                i=1;\\n            }else{\\n                if(countS)\\n                   i++;     \\n            }\\n            n=n>>1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960208,
                "title": "ugly-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nMy ugly solution\\n```\\nimpl Solution {\\n    pub fn binary_gap(n: i32) -> i32 {\\n        let mut res_vec: Vec<i32> = Vec::new();\\n        let mut res: i32 = 0;\\n        let str = format!(\"{:b}\", n);\\n        if str.matches(\\'1\\').count() > 1 {\\n            for i in 0..str.len() {\\n                res += 1;\\n                if str.as_bytes()[i] as char == \\'1\\' {\\n                    res_vec.push(res);\\n                    res = 0;\\n                }\\n            }\\n            match res_vec.iter().max() {\\n                Some(max) => return *max,\\n                None => {},\\n            }\\n        } \\n        0\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn binary_gap(n: i32) -> i32 {\\n        let mut res_vec: Vec<i32> = Vec::new();\\n        let mut res: i32 = 0;\\n        let str = format!(\"{:b}\", n);\\n        if str.matches(\\'1\\').count() > 1 {\\n            for i in 0..str.len() {\\n                res += 1;\\n                if str.as_bytes()[i] as char == \\'1\\' {\\n                    res_vec.push(res);\\n                    res = 0;\\n                }\\n            }\\n            match res_vec.iter().max() {\\n                Some(max) => return *max,\\n                None => {},\\n            }\\n        } \\n        0\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3952135,
                "title": "mom-we-have-java-solution-at-home-java-solution-at-home",
                "content": "# Approach\\nIn this solution, we are processing the input in multiple steps. First, we are converting the integer value to a binary string (I felt like it will be easier to check every characters). Then chop off the zeros before and after the \\'1\\'s.\\n\\nAt this point, we have to see if there is only a single \\'1\\' character in the string. If so, there can\\'t be a distance value.\\n\\nWe define an ArrayList to keep all distances we counted with the for loop. After that, if there is at least a distance element in the arraylist, we are finding the maximum and return the result. \\u2615\\n\\nThis may seem ugly but I think this is a really simple and easy to understand solution. \\uD83D\\uDE4C\\n\\nPlease leave an upvote, to keep a random person motivated \\uD83D\\uDC7D\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(log(n))$$\\n\\n- Space complexity:\\n$$O(log(n))$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        // Convert n to binary string.\\n        String binaryString = Integer.toBinaryString(n);\\n        \\n        // Remove the leading and the trailing zeros.\\n        int start = binaryString.indexOf(\\'1\\');\\n        int end = binaryString.lastIndexOf(\\'1\\');\\n        binaryString = binaryString.substring(start, end + 1);\\n\\n        // Check the cases where there is zero or one \\'1\\'.\\n        if (binaryString.length() <= 1) { return 0; }\\n\\n        // Count zeros and store the distances in an arraylist.\\n        ArrayList<Integer> distances = new ArrayList<>();\\n        int counter = 1;\\n        for (int i = 1; i < binaryString.length(); i++) {\\n            if (binaryString.charAt(i) == \\'1\\') {\\n                distances.add(counter);\\n                counter = 0;\\n            }\\n            counter += 1;\\n        }\\n\\n        // If there was no gap between ones, return 1.\\n        if (distances.size() == 0) { return 1; }\\n\\n        // Get the max distance.\\n        int max = 1;\\n        for (int distance : distances) {\\n            if (distance > max) {\\n                max = distance;\\n            }\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        // Convert n to binary string.\\n        String binaryString = Integer.toBinaryString(n);\\n        \\n        // Remove the leading and the trailing zeros.\\n        int start = binaryString.indexOf(\\'1\\');\\n        int end = binaryString.lastIndexOf(\\'1\\');\\n        binaryString = binaryString.substring(start, end + 1);\\n\\n        // Check the cases where there is zero or one \\'1\\'.\\n        if (binaryString.length() <= 1) { return 0; }\\n\\n        // Count zeros and store the distances in an arraylist.\\n        ArrayList<Integer> distances = new ArrayList<>();\\n        int counter = 1;\\n        for (int i = 1; i < binaryString.length(); i++) {\\n            if (binaryString.charAt(i) == \\'1\\') {\\n                distances.add(counter);\\n                counter = 0;\\n            }\\n            counter += 1;\\n        }\\n\\n        // If there was no gap between ones, return 1.\\n        if (distances.size() == 0) { return 1; }\\n\\n        // Get the max distance.\\n        int max = 1;\\n        for (int distance : distances) {\\n            if (distance > max) {\\n                max = distance;\\n            }\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3949547,
                "title": "python-beats-100-get-1s-indices",
                "content": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        ones = [i for i,v in enumerate(bin(n)) if v==\\'1\\']\\n        maxi = 0\\n        for i in range(1,len(ones)):\\n            maxi = max(maxi, ones[i]-ones[i-1])\\n        return maxi\\n```\\n\\n![image](https://assets.leetcode.com/users/images/2eb9ab23-c46f-475e-8683-48b3aa516616_1692786972.5100787.png)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        ones = [i for i,v in enumerate(bin(n)) if v==\\'1\\']\\n        maxi = 0\\n        for i in range(1,len(ones)):\\n            maxi = max(maxi, ones[i]-ones[i-1])\\n        return maxi\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943485,
                "title": "optimized-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int maxDistance = 0;\\n        int lastOnePos = -1;\\n        int bitPos = 0;\\n        \\n        while (n > 0) {\\n            if ((n & 1) == 1) {\\n                if (lastOnePos != -1) {\\n                    maxDistance = Math.max(maxDistance, bitPos - lastOnePos);\\n                }\\n                lastOnePos = bitPos;\\n            }\\n            n >>= 1;\\n            bitPos++;\\n        }\\n        \\n        return maxDistance;\\n        }\\n    }\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int maxDistance = 0;\\n        int lastOnePos = -1;\\n        int bitPos = 0;\\n        \\n        while (n > 0) {\\n            if ((n & 1) == 1) {\\n                if (lastOnePos != -1) {\\n                    maxDistance = Math.max(maxDistance, bitPos - lastOnePos);\\n                }\\n                lastOnePos = bitPos;\\n            }\\n            n >>= 1;\\n            bitPos++;\\n        }\\n        \\n        return maxDistance;\\n        }\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939109,
                "title": "1ms-o-n-time-complexity-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int largest = 0;\\n        int lastOne = -1;\\n        char[] digits = Integer.toBinaryString(n).toCharArray();\\n        for (int i =0; i < digits.length; i++ ) {\\n            if (digits[i] == \\'1\\') {\\n                if (lastOne > -1) {\\n                    largest = Math.max(largest, i - lastOne);\\n                    lastOne = i;\\n                }\\n                if (lastOne == -1) { lastOne = i;}\\n            }\\n        }\\n\\n        return largest;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int largest = 0;\\n        int lastOne = -1;\\n        char[] digits = Integer.toBinaryString(n).toCharArray();\\n        for (int i =0; i < digits.length; i++ ) {\\n            if (digits[i] == \\'1\\') {\\n                if (lastOne > -1) {\\n                    largest = Math.max(largest, i - lastOne);\\n                    lastOne = i;\\n                }\\n                if (lastOne == -1) { lastOne = i;}\\n            }\\n        }\\n\\n        return largest;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929262,
                "title": "python-beats-100-time",
                "content": "\\n![image.png](https://assets.leetcode.com/users/images/74782748-f21c-4d2a-bd3d-9b8be148fde0_1692415205.3358538.png)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def binaryGap(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        s = bin(n)[2:]\\n        track = False\\n        res = 0\\n        curr = 0\\n        for c in s:\\n            if int(c) == 1 and track:\\n                res = max(curr, res)\\n                curr = 1\\n            elif int(c) == 1 and not track:\\n                track = True\\n                curr += 1\\n            else:\\n                curr += 1\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def binaryGap(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        s = bin(n)[2:]\\n        track = False\\n        res = 0\\n        curr = 0\\n        for c in s:\\n            if int(c) == 1 and track:\\n                res = max(curr, res)\\n                curr = 1\\n            elif int(c) == 1 and not track:\\n                track = True\\n                curr += 1\\n            else:\\n                curr += 1\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3914260,
                "title": "step-by-step",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        w = bin(n)[2:]\\n        mx = 0\\n        start = 0\\n        i = 0\\n        zero = False\\n        for ch in w:\\n            # print(zero, ch)\\n            if ch == \\'1\\':\\n                mx = max(mx, i-start)\\n                start = i\\n\\n            i += 1\\n        return mx\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        w = bin(n)[2:]\\n        mx = 0\\n        start = 0\\n        i = 0\\n        zero = False\\n        for ch in w:\\n            # print(zero, ch)\\n            if ch == \\'1\\':\\n                mx = max(mx, i-start)\\n                start = i\\n\\n            i += 1\\n        return mx\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3903222,
                "title": "c-easy-sol-without-storing-the-binary-in-a-variable",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int rem,result=0,dis=0,i=0,flag=0;\\n        while(n){\\n            rem=n%2;\\n            if(rem==1){\\n                if(flag!=0){\\n                    result=max(result,i-dis);\\n                    dis=i;\\n                }\\n                if(flag==0){\\n                    flag=1;\\n                    dis=i;\\n                }\\n            }\\n            n=n/2;\\n            i++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int rem,result=0,dis=0,i=0,flag=0;\\n        while(n){\\n            rem=n%2;\\n            if(rem==1){\\n                if(flag!=0){\\n                    result=max(result,i-dis);\\n                    dis=i;\\n                }\\n                if(flag==0){\\n                    flag=1;\\n                    dis=i;\\n                }\\n            }\\n            n=n/2;\\n            i++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3892743,
                "title": "python-beats-90",
                "content": "# Code\\n```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n\\n        n = list(bin(n)[2:])\\n\\n        if n.count(\\'1\\') == 1 or n.count(\\'1\\') == 0:\\n            return 0\\n\\n        output = 0\\n        for i in range(len(n)):\\n            temp = 0\\n            if n[i] == \\'1\\':\\n                for x in range(i+1,len(n)):\\n                    if n[x] == \\'1\\':\\n                        temp+=1\\n                        output = max(output,temp)\\n                        break\\n                    else:\\n                        temp+=1                    \\n        return output\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n\\n        n = list(bin(n)[2:])\\n\\n        if n.count(\\'1\\') == 1 or n.count(\\'1\\') == 0:\\n            return 0\\n\\n        output = 0\\n        for i in range(len(n)):\\n            temp = 0\\n            if n[i] == \\'1\\':\\n                for x in range(i+1,len(n)):\\n                    if n[x] == \\'1\\':\\n                        temp+=1\\n                        output = max(output,temp)\\n                        break\\n                    else:\\n                        temp+=1                    \\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889546,
                "title": "quick-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int counter = 0;\\n        int maxCount = 0;\\n        int mask = 1;\\n        bool flag = false;\\n        while(n > 0) {\\n            // getting the first bit from the right\\n            if(n&mask == 1) {\\n                // there is one\\n                flag = true;\\n                maxCount = max(maxCount, counter);\\n                counter = 0;\\n            }\\n            if(flag == true){\\n                counter++;\\n            }\\n            n = n >> 1;\\n        }\\n        return maxCount;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int counter = 0;\\n        int maxCount = 0;\\n        int mask = 1;\\n        bool flag = false;\\n        while(n > 0) {\\n            // getting the first bit from the right\\n            if(n&mask == 1) {\\n                // there is one\\n                flag = true;\\n                maxCount = max(maxCount, counter);\\n                counter = 0;\\n            }\\n            if(flag == true){\\n                counter++;\\n            }\\n            n = n >> 1;\\n        }\\n        return maxCount;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3888853,
                "title": "c-simplest-solution-using-bit-manipulation",
                "content": "# Complexity\\n- Time complexity:\\nO(log n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n\\n        int ans = 0;\\n        int cnt = 0;\\n        int flag = 0;\\n\\n        while(n > 0) {\\n            if(n % 2 == 0) {\\n                if(flag == 1) {\\n                    cnt++;\\n                }\\n            }\\n            else {\\n                if(flag == 0) \\n                    flag = 1;\\n                else {\\n                    ans = max(cnt+1, ans);\\n                    cnt = 0;\\n                }\\n            }\\n            n = n/2;\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n\\n        int ans = 0;\\n        int cnt = 0;\\n        int flag = 0;\\n\\n        while(n > 0) {\\n            if(n % 2 == 0) {\\n                if(flag == 1) {\\n                    cnt++;\\n                }\\n            }\\n            else {\\n                if(flag == 0) \\n                    flag = 1;\\n                else {\\n                    ans = max(cnt+1, ans);\\n                    cnt = 0;\\n                }\\n            }\\n            n = n/2;\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3855124,
                "title": "strictly-bit-manipulation-beats-100-explained-java",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBroke the problem down into steps:\\n\\n1. Iterate through each bit of the number\\n2. Count the number of zeroes between each pair of ones\\n3. return the greatest \\'gap\\'.\\n\\n---\\nThe following code iterates through the each bit from right to left:\\n```\\nwhile(n != 0){\\n    int a = n & 1; // retrieves the rightmost bit.\\n    n >>= 1; // performs a logical bitewise shift right.\\n}\\n```\\nThis boolean variable ensures that the counter \"runningCount\" does not begin counting the zeroes until the first \"1\" is encountered:\\n```\\nboolean first = true;\\n```\\nWhen a second \"1\" bit is encountered, a check is made to see if the \"runningCount\" is greater than the recorded \"max\" count and \"max\" is updated accordingly.\\n\\n---\\n\\n# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n\\n        int max = 0;\\n        int runningCount = 0;\\n        boolean first = true;\\n\\n        if(Integer.bitCount(n) == 1){\\n            return 0;\\n        }\\n\\n        while(n != 0){\\n            int a = n & 1;\\n            n>>=1;\\n            if(a == 1){\\n                if(runningCount > max){\\n                    max = runningCount;\\n                }\\n                runningCount = 1;\\n                first = false;\\n            }\\n            else if(first == false){\\n                runningCount++; \\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nwhile(n != 0){\\n    int a = n & 1; // retrieves the rightmost bit.\\n    n >>= 1; // performs a logical bitewise shift right.\\n}\\n```\n```\\nboolean first = true;\\n```\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n\\n        int max = 0;\\n        int runningCount = 0;\\n        boolean first = true;\\n\\n        if(Integer.bitCount(n) == 1){\\n            return 0;\\n        }\\n\\n        while(n != 0){\\n            int a = n & 1;\\n            n>>=1;\\n            if(a == 1){\\n                if(runningCount > max){\\n                    max = runningCount;\\n                }\\n                runningCount = 1;\\n                first = false;\\n            }\\n            else if(first == false){\\n                runningCount++; \\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3847840,
                "title": "go-bits-shift",
                "content": "```\\nfunc binaryGap(n int) int {\\n    max := 0\\n\\n    for counter := 0 ;n > 0; n >>= 1 {\\n        if n & 1 == 0 {\\n            if counter > 0 {\\n                counter++\\n            }\\n            continue\\n        }\\n        \\n        if max < counter {\\n            max = counter\\n        }\\n        \\n        counter = 1\\n    }\\n\\n    return max\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc binaryGap(n int) int {\\n    max := 0\\n\\n    for counter := 0 ;n > 0; n >>= 1 {\\n        if n & 1 == 0 {\\n            if counter > 0 {\\n                counter++\\n            }\\n            continue\\n        }\\n        \\n        if max < counter {\\n            max = counter\\n        }\\n        \\n        counter = 1\\n    }\\n\\n    return max\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3833523,
                "title": "explained-js-ts-solution",
                "content": "# Intuition\\nThe intuition behind this solution is to convert the given positive integer n to its binary representation as a string and then traverse the binary string to find the longest distance between any two adjacent 1\\'s. We keep track of the count of consecutive zeros after each \\'1\\', and whenever we encounter a \\'1\\', we update the maximum distance found so far.\\n\\n# Approach\\n1) Convert n to its binary representation as a string using toString(2).\\n\\n2) Initialize variables isOpen as false (to keep track of whether we have encountered a \\'1\\' yet), count to 0 (to track the number of consecutive zeros after each \\'1\\'), and max to 0 (to store the maximum distance found).\\n\\n3) Traverse the binary string character by character using a for-loop.\\n\\n4) When we encounter a \\'0\\' and isOpen is true (indicating we have seen a \\'1\\' already), increment the count.\\n\\n5) When we encounter a \\'1\\' and isOpen is true, update the max distance by taking the maximum of the current count + 1 and the existing max, and reset the count to 0.\\n\\n6) If we encounter a \\'1\\' and isOpen is false, set isOpen to true.\\n\\n7) After the loop, return the max, which represents the longest distance between any two adjacent 1\\'s in the binary representation of n.\\n\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity is dominated by the conversion of n to its binary representation, which takes O(log n) time.\\nThe subsequent loop to traverse the binary string takes linear time, but its complexity is bounded by O(log n) since the binary representation of n has O(log n) digits.\\n\\n- Space complexity:\\nThe space complexity is mainly determined by the binary string representation of n, which has O(log n) bits in the worst case.\\n\\n# Code\\n```\\nfunction binaryGap(n: number): number {\\n    let chars = n.toString(2)\\n    let isOpen = false\\n    let count = 0\\n    let max = count\\n    for (let char of chars) {\\n        if (char === \\'0\\' && isOpen) {\\n            count++\\n        }\\n        if (char === \\'1\\' && isOpen) {\\n            max = Math.max(count + 1, max)\\n            count = 0\\n        } else {\\n            isOpen = true\\n        }\\n    }\\n    return max\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction binaryGap(n: number): number {\\n    let chars = n.toString(2)\\n    let isOpen = false\\n    let count = 0\\n    let max = count\\n    for (let char of chars) {\\n        if (char === \\'0\\' && isOpen) {\\n            count++\\n        }\\n        if (char === \\'1\\' && isOpen) {\\n            max = Math.max(count + 1, max)\\n            count = 0\\n        } else {\\n            isOpen = true\\n        }\\n    }\\n    return max\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3806424,
                "title": "fast-solution-on-bit-operations-runtime-96-62",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n\\n        while n%2 == 0:\\n            n //= 2\\n        if n == 1:\\n            return 0\\n        count = 1\\n        while n&(n+1) != 0:\\n            n = n|(n>>1)\\n            count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n\\n        while n%2 == 0:\\n            n //= 2\\n        if n == 1:\\n            return 0\\n        count = 1\\n        while n&(n+1) != 0:\\n            n = n|(n>>1)\\n            count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3801920,
                "title": "java-o-n-time-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince we need to find the farthest adjacent 1\\'s, we actually need the longest sequence of 0\\'s.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can start by getting rid of the trailing 0\\'s in the binary string representation of the number and then finding the longest sequence of 0\\'s.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        String s = Integer.toBinaryString(n);\\n        int i = 0, j = s.length() - 1, cnt = 0, maxCnt = Integer.MIN_VALUE;\\n        while (s.charAt(i) == \\'0\\') {\\n            i++;\\n        }\\n        while (s.charAt(j) == \\'0\\') {\\n            j--;\\n        }\\n        while (i < j) {\\n            char c = s.charAt(i);\\n            if (c == \\'1\\') {\\n                cnt = 0;\\n            } else if (c == \\'0\\') {\\n                cnt++;\\n            }\\n            maxCnt = Math.max(maxCnt, cnt);\\n            i++;\\n        }\\n        return (Math.abs(maxCnt - s.length()) <= 1 || \\n        maxCnt == Integer.MIN_VALUE) ? 0 : maxCnt + 1;\\n   }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        String s = Integer.toBinaryString(n);\\n        int i = 0, j = s.length() - 1, cnt = 0, maxCnt = Integer.MIN_VALUE;\\n        while (s.charAt(i) == \\'0\\') {\\n            i++;\\n        }\\n        while (s.charAt(j) == \\'0\\') {\\n            j--;\\n        }\\n        while (i < j) {\\n            char c = s.charAt(i);\\n            if (c == \\'1\\') {\\n                cnt = 0;\\n            } else if (c == \\'0\\') {\\n                cnt++;\\n            }\\n            maxCnt = Math.max(maxCnt, cnt);\\n            i++;\\n        }\\n        return (Math.abs(maxCnt - s.length()) <= 1 || \\n        maxCnt == Integer.MIN_VALUE) ? 0 : maxCnt + 1;\\n   }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3801129,
                "title": "java-bit-manipulation-0ms-beats-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int curr_dis=0;\\n        int max_dis=0;\\n        while(n!=0){\\n            if((n&1)==1)break;\\n            n >>= 1;\\n        }\\n        n >>= 1;\\n        while(n!=0)\\n        {\\n            curr_dis++;\\n            if( (n&1) == 1)\\n            {\\n                max_dis=Math.max(max_dis,curr_dis);\\n                curr_dis=0;\\n            }\\n            n >>= 1;\\n        }\\n        return max_dis;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int curr_dis=0;\\n        int max_dis=0;\\n        while(n!=0){\\n            if((n&1)==1)break;\\n            n >>= 1;\\n        }\\n        n >>= 1;\\n        while(n!=0)\\n        {\\n            curr_dis++;\\n            if( (n&1) == 1)\\n            {\\n                max_dis=Math.max(max_dis,curr_dis);\\n                curr_dis=0;\\n            }\\n            n >>= 1;\\n        }\\n        return max_dis;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3784102,
                "title": "convert-to-string-first-then-get-a-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn binary_gap(n: i32) -> i32 {\\n        let s = format!(\"{:b}\", n);\\n        let s = s\\n            .char_indices()\\n            .filter(|n| n.1 == \\'1\\')\\n            .collect::<Vec<(_, _)>>();\\n\\n        s.windows(2).map(|n| n[1].0 - n[0].0).max().unwrap_or(0) as i32\\n    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn binary_gap(n: i32) -> i32 {\\n        let s = format!(\"{:b}\", n);\\n        let s = s\\n            .char_indices()\\n            .filter(|n| n.1 == \\'1\\')\\n            .collect::<Vec<(_, _)>>();\\n\\n        s.windows(2).map(|n| n[1].0 - n[0].0).max().unwrap_or(0) as i32\\n    \\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3753700,
                "title": "using-math-max-and-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int BinaryGap(int n) \\n    {\\n        string s = Convert.ToString(n,2);\\n\\n        int max = 0;\\n        int startPoint = 0;\\n        int endPoint = 0;\\n        for(int i = 0 ; i < s.Length ;)\\n        {\\n            if(s[i] == \\'1\\')\\n            {\\n                startPoint=1;\\n            }\\n            i++;\\n            while(i < s.Length && s[i] != \\'1\\' && startPoint == 1)\\n            {\\n                endPoint++;\\n                i++;\\n            }            \\n            if(i < s.Length && s[i] == \\'1\\' && startPoint == 1)\\n            {\\n                    max = Math.Max(max, endPoint+startPoint);\\n                    endPoint = 0;\\n            }\\n        }\\n\\n        return max;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int BinaryGap(int n) \\n    {\\n        string s = Convert.ToString(n,2);\\n\\n        int max = 0;\\n        int startPoint = 0;\\n        int endPoint = 0;\\n        for(int i = 0 ; i < s.Length ;)\\n        {\\n            if(s[i] == \\'1\\')\\n            {\\n                startPoint=1;\\n            }\\n            i++;\\n            while(i < s.Length && s[i] != \\'1\\' && startPoint == 1)\\n            {\\n                endPoint++;\\n                i++;\\n            }            \\n            if(i < s.Length && s[i] == \\'1\\' && startPoint == 1)\\n            {\\n                    max = Math.Max(max, endPoint+startPoint);\\n                    endPoint = 0;\\n            }\\n        }\\n\\n        return max;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738607,
                "title": "easy-to-understand-java-beginner-s-need",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int[] binary =new int[50];\\n        int i=0,max=0,start=0,length=0;\\n        while(n>0)\\n        {\\n            binary[i++]= n%2;\\n            n/=2;\\n            if(binary[i-1]==1)\\n            start=i-1;\\n        }\\nstart=i-start-1;//0\\n        for(int j=i-1;j>=0;j--)\\n        {\\n            \\n            if(binary[j]==1)\\n            {\\n                \\n                length=(i-1-j)-start;\\n                start=i-1-j;\\n                if(length>max)\\n                {\\n                    System.out.println(length);\\n                max=length;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int[] binary =new int[50];\\n        int i=0,max=0,start=0,length=0;\\n        while(n>0)\\n        {\\n            binary[i++]= n%2;\\n            n/=2;\\n            if(binary[i-1]==1)\\n            start=i-1;\\n        }\\nstart=i-start-1;//0\\n        for(int j=i-1;j>=0;j--)\\n        {\\n            \\n            if(binary[j]==1)\\n            {\\n                \\n                length=(i-1-j)-start;\\n                start=i-1-j;\\n                if(length>max)\\n                {\\n                    System.out.println(length);\\n                max=length;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735371,
                "title": "100-beats-eaisest-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int maxi=0;\\n        int start=n&1;\\n        int prev=n&1;\\n        int cnt=0;\\n        int temp=n;\\n        n=n>>1;\\n        while(n>0)\\n        {\\n            if(prev==0 && start==1)\\n            { \\n                cnt++;\\n                maxi=max(maxi,cnt);\\n            }\\n            else\\n            {\\n                cnt=0;\\n                start=prev;\\n            }\\n            prev=n&1;\\n            n=n>>1;\\n        }\\n        if(maxi!=0)\\n        return maxi+1;\\n        else if(start==1 && temp!=1) return 1;\\n        else return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int maxi=0;\\n        int start=n&1;\\n        int prev=n&1;\\n        int cnt=0;\\n        int temp=n;\\n        n=n>>1;\\n        while(n>0)\\n        {\\n            if(prev==0 && start==1)\\n            { \\n                cnt++;\\n                maxi=max(maxi,cnt);\\n            }\\n            else\\n            {\\n                cnt=0;\\n                start=prev;\\n            }\\n            prev=n&1;\\n            n=n>>1;\\n        }\\n        if(maxi!=0)\\n        return maxi+1;\\n        else if(start==1 && temp!=1) return 1;\\n        else return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729550,
                "title": "easy-solution-in-ts",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction binaryGap(n: number): number {\\n    const binary = (n >>> 0).toString(2);\\n    let first = -1;\\n    let second = -1;\\n    let dist = 0;\\n\\n    for(let i = 0 ; i < binary.length; i++) {\\n        if(binary[i] === \\'1\\') {\\n            if(first < 0) first = i;\\n            else second = i;\\n        }\\n\\n        if(first >= 0 && second >= 0){\\n            const auxDist = second - first;\\n            if(auxDist > dist) {\\n                dist = auxDist;\\n            }\\n            first = second;\\n            second = undefined;\\n        }\\n    }\\n\\n    return dist;\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "String"
                ],
                "code": "```\\nfunction binaryGap(n: number): number {\\n    const binary = (n >>> 0).toString(2);\\n    let first = -1;\\n    let second = -1;\\n    let dist = 0;\\n\\n    for(let i = 0 ; i < binary.length; i++) {\\n        if(binary[i] === \\'1\\') {\\n            if(first < 0) first = i;\\n            else second = i;\\n        }\\n\\n        if(first >= 0 && second >= 0){\\n            const auxDist = second - first;\\n            if(auxDist > dist) {\\n                dist = auxDist;\\n            }\\n            first = second;\\n            second = undefined;\\n        }\\n    }\\n\\n    return dist;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3728531,
                "title": "aniruddha-s-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int nm = n;\\n        int cnt = 0;\\n        int cnt1 = 0;\\n        int mx = 0;\\n        bool f = false;\\n        while(nm){\\n            if(nm & 1){\\n                f = true;\\n                cnt1++;\\n                if(mx < cnt ){\\n                    mx = cnt;\\n                }\\n                cnt = 0;\\n            }else if(f){\\n                cnt++;\\n            }\\n            nm = nm >> 1;   \\n\\n        }\\n        int ans = 0;\\n        if(mx>0 ){\\n            ans = mx + 1;\\n        }else if(cnt1 > 1){\\n            ans = 1;\\n        }else{\\n            ans = 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int nm = n;\\n        int cnt = 0;\\n        int cnt1 = 0;\\n        int mx = 0;\\n        bool f = false;\\n        while(nm){\\n            if(nm & 1){\\n                f = true;\\n                cnt1++;\\n                if(mx < cnt ){\\n                    mx = cnt;\\n                }\\n                cnt = 0;\\n            }else if(f){\\n                cnt++;\\n            }\\n            nm = nm >> 1;   \\n\\n        }\\n        int ans = 0;\\n        if(mx>0 ){\\n            ans = mx + 1;\\n        }else if(cnt1 > 1){\\n            ans = 1;\\n        }else{\\n            ans = 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3724037,
                "title": "nothing-special",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        n = bin(n) # to binary\\n        n = n.replace(\\'0b\\', \\'\\')\\n        print(n)\\n        if n.count(\\'1\\') == 1:\\n            return 0\\n        x = 0\\n        y = 0\\n        count_on = 0\\n        for i in range(0,len(n)):\\n            if n[i] == \\'1\\' and count_on == 0:\\n                count_on = 1\\n            if n[i] == \\'1\\' and count_on == 1:\\n                y = max(x,y)\\n                x = 0\\n            if n[i] == \\'0\\' and count_on == 1:\\n                x += 1\\n        return y+1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        n = bin(n) # to binary\\n        n = n.replace(\\'0b\\', \\'\\')\\n        print(n)\\n        if n.count(\\'1\\') == 1:\\n            return 0\\n        x = 0\\n        y = 0\\n        count_on = 0\\n        for i in range(0,len(n)):\\n            if n[i] == \\'1\\' and count_on == 0:\\n                count_on = 1\\n            if n[i] == \\'1\\' and count_on == 1:\\n                y = max(x,y)\\n                x = 0\\n            if n[i] == \\'0\\' and count_on == 1:\\n                x += 1\\n        return y+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3721068,
                "title": "c-one-pass-beats-100-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int dis = 0, prev = -1;\\n        for(int i=0;i<31;i++)\\n        {\\n            int curr = n&(1<<i);\\n            if(curr!=0)\\n            {\\n                if(prev!=-1)\\n                    dis = max(dis, i-prev);\\n                prev = i;\\n            }\\n        }\\n        return dis;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int dis = 0, prev = -1;\\n        for(int i=0;i<31;i++)\\n        {\\n            int curr = n&(1<<i);\\n            if(curr!=0)\\n            {\\n                if(prev!=-1)\\n                    dis = max(dis, i-prev);\\n                prev = i;\\n            }\\n        }\\n        return dis;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716617,
                "title": "straightforward",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar binaryGap = function(n) {\\n    let firstIndexOf1 = undefined\\n    let secondIndexOf1 = undefined\\n    let longestDis = 0\\n    let binary = \\'\\'\\n    let newNum = n\\n    while (newNum > 0) {\\n        newNum = newNum / 2\\n        let isInt = Number(newNum) === newNum && newNum % 1 === 0;\\n        if(!isInt) {\\n        newNum = newNum.toString().substring(0, newNum.toString().indexOf(\".\"));\\n        }\\n        binary += isInt ? \\'0\\' : \\'1\\'\\n    }\\n    for (let i = 0; i < binary.length; i++) {\\n        if(binary[i] === \\'1\\') {\\n            if(firstIndexOf1 || firstIndexOf1 === 0) {\\n                secondIndexOf1 = i\\n            } else {\\n                firstIndexOf1 = i\\n            }\\n        } \\n        if (secondIndexOf1 && (firstIndexOf1 || firstIndexOf1 === 0)) {\\n        let dis = secondIndexOf1 - firstIndexOf1\\n        longestDis = dis > longestDis ? dis : longestDis\\n        firstIndexOf1 = secondIndexOf1\\n        secondIndexOf1 = undefined\\n        }\\n    }\\n\\n    return longestDis\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar binaryGap = function(n) {\\n    let firstIndexOf1 = undefined\\n    let secondIndexOf1 = undefined\\n    let longestDis = 0\\n    let binary = \\'\\'\\n    let newNum = n\\n    while (newNum > 0) {\\n        newNum = newNum / 2\\n        let isInt = Number(newNum) === newNum && newNum % 1 === 0;\\n        if(!isInt) {\\n        newNum = newNum.toString().substring(0, newNum.toString().indexOf(\".\"));\\n        }\\n        binary += isInt ? \\'0\\' : \\'1\\'\\n    }\\n    for (let i = 0; i < binary.length; i++) {\\n        if(binary[i] === \\'1\\') {\\n            if(firstIndexOf1 || firstIndexOf1 === 0) {\\n                secondIndexOf1 = i\\n            } else {\\n                firstIndexOf1 = i\\n            }\\n        } \\n        if (secondIndexOf1 && (firstIndexOf1 || firstIndexOf1 === 0)) {\\n        let dis = secondIndexOf1 - firstIndexOf1\\n        longestDis = dis > longestDis ? dis : longestDis\\n        firstIndexOf1 = secondIndexOf1\\n        secondIndexOf1 = undefined\\n        }\\n    }\\n\\n    return longestDis\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3714117,
                "title": "java-solution-with-detailed-explanation-beats-100",
                "content": "# Approach\\nHere, we need to track when we get the first 1 of the pair (if there is any) and the last 1 of the pair (the last 1 would be the first 1 of the next pair if there is any, and so on). Also, we need to count the in-between 0s of the pair.\\nTo do so, we will initialize two variables that will track the current (say, `currGap`) and maximum (say, `largestGap`) gaps between the pairs. Both will be initialized as 0, which will indicate that no pairs of 1 are still found. Then, we will run a loop that will run until the number becomes 0 (we will right shift the number to 1 position on each iteration).\\nIf we find a 1, that means it could be the start of a new pair (if there is any) or the end of an existing pair (also the start of a new pair if there is any). In both cases, we need to update the `currGap` to 1 (which will indicate that the start of a pair is found). And, if it\\'s the end of the existing pair, we need to update the `largestGap`, if applicable.\\nOn the other hand, if we encounter a 0 and the `currGap` is not 0, it means that the 0 resides in-between the pair (if there is any) of 1s. In this case, we need to increment the `currGap` by 1.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n  public int binaryGap(int n) {\\n    int currGap = 0;\\n    int largestGap = 0;\\n    while (n != 0) {\\n      if ((n & 1) == 1) {\\n        if (currGap != 0) { // Last 1 of the pair and the beginning of a new pair\\n          largestGap = currGap > largestGap ? currGap : largestGap;\\n        }\\n        currGap = 1; // First 1 of the pair \\n      } else if (currGap != 0) {\\n        currGap += 1;\\n      }\\n      n >>= 1;\\n    }\\n    return largestGap;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int binaryGap(int n) {\\n    int currGap = 0;\\n    int largestGap = 0;\\n    while (n != 0) {\\n      if ((n & 1) == 1) {\\n        if (currGap != 0) { // Last 1 of the pair and the beginning of a new pair\\n          largestGap = currGap > largestGap ? currGap : largestGap;\\n        }\\n        currGap = 1; // First 1 of the pair \\n      } else if (currGap != 0) {\\n        currGap += 1;\\n      }\\n      n >>= 1;\\n    }\\n    return largestGap;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713538,
                "title": "easy-sol-100-faster-95-in-space-bitwise-left-shift-c",
                "content": "# Complexity\\n- Time complexity:\\nO(N) where N is number of bits.\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int arr[2]={-1,-1};\\n        long long a=1,i=0;\\n        int ans=INT_MIN;\\n\\n        while(i<32)\\n        {\\n            if(n&a)\\n            {\\n                arr[0]=arr[1];\\n                arr[1]=i;\\n\\n                if(arr[0]!=-1 && arr[1]!=-1)\\n                {\\n                    ans=max(ans,arr[1]-arr[0]);\\n                }\\n            }\\n            a=a<<1;\\n            i++;\\n        }\\n        if(arr[0]==-1 || arr[1]==-1)\\n            return 0;\\n    \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int arr[2]={-1,-1};\\n        long long a=1,i=0;\\n        int ans=INT_MIN;\\n\\n        while(i<32)\\n        {\\n            if(n&a)\\n            {\\n                arr[0]=arr[1];\\n                arr[1]=i;\\n\\n                if(arr[0]!=-1 && arr[1]!=-1)\\n                {\\n                    ans=max(ans,arr[1]-arr[0]);\\n                }\\n            }\\n            a=a<<1;\\n            i++;\\n        }\\n        if(arr[0]==-1 || arr[1]==-1)\\n            return 0;\\n    \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710994,
                "title": "868-binary-gap-100-beats-than-all-java-submissions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntuition for finding the longest distance between adjacent 1\\'s in the binary representation of a positive integer:\\n\\n**-** Initialize variables: Set the longest distance and the current distance between adjacent 1\\'s to 0. Also, set a flag to keep track of the existence of the first 1 bit.\\n\\n**-** Iterate through the binary representation: Start from the least significant bit and move towards the most significant bit.\\n\\n**-** Handling 0 bits: If a 0 bit is encountered, shift the bits to the right. If the first 1 bit has been found (flag is true), increment the current distance between adjacent 1\\'s.\\n\\n**-** Handling 1 bits: If a 1 bit is encountered, update the longest distance with the maximum value between the current distance and the longest distance found so far. Set the first 1 bit flag to true and reset the current distance to 0.\\n\\n**-** Continue iteration: Repeat steps 3 and 4 until all bits have been processed.\\n\\n**-** Return the longest distance: After iterating through all bits, return the longest distance as the result.\\n\\nThe intuition behind this approach is to identify consecutive 1 bits and calculate the distance between them. By using bitwise operations and maintaining appropriate variables, the code tracks the longest distance between adjacent 1\\'s. It handles the case when there are no adjacent 1\\'s by returning 0.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code uses a bitwise operation to calculate the binary gap of a given integer. It iterates over the binary representation of the number, keeping track of the longest distance between consecutive 1 bits. It uses a distance variable to keep track of the current distance between 1 bits and updates the longestDistance variable whenever a new longest distance is found. The code also uses a **firstOneBitExist boolean flag to handle the case when the first 1 bit is encountered**. Overall, the approach is to shift the bits to the right and perform bitwise operations to identify the binary gap.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe code iterates over the bits of the given integer, which takes O(log n) time, where n is the value of the integer.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe code uses a constant amount of extra space, so the space complexity is O(1).\\n# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int longestDistance = 0, distance = 0;\\n        boolean firstOneBitExist = false;\\n        while(n != 0){\\n            if((n & 1) == 0){\\n                n >>= 1;\\n                if(firstOneBitExist)\\n                    distance++;\\n            } else {\\n                if(firstOneBitExist)\\n                    distance++;\\n                longestDistance = Math.max(distance, longestDistance);\\n                firstOneBitExist = true;\\n                distance = 0;\\n                n >>= 1;\\n            }\\n        }\\n        return longestDistance;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int longestDistance = 0, distance = 0;\\n        boolean firstOneBitExist = false;\\n        while(n != 0){\\n            if((n & 1) == 0){\\n                n >>= 1;\\n                if(firstOneBitExist)\\n                    distance++;\\n            } else {\\n                if(firstOneBitExist)\\n                    distance++;\\n                longestDistance = Math.max(distance, longestDistance);\\n                firstOneBitExist = true;\\n                distance = 0;\\n                n >>= 1;\\n            }\\n        }\\n        return longestDistance;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3705608,
                "title": "beats-100-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int dis=0, i=0,j=0;\\n        while(n>0){\\n            if((n&1)!=0){\\n                if(j==0){\\n                    j=1;\\n                    // i++;\\n                }\\n                else{\\n                    // j=0;\\n                    if(dis<i){\\n                        dis=i;\\n                        // i=0;\\n                    }\\n                    i=0;\\n                }\\n                // i++;\\n                \\n            }\\n            if(j==1){\\n                i++;\\n            }\\n            n=n>>1;\\n        }\\n        return dis;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int dis=0, i=0,j=0;\\n        while(n>0){\\n            if((n&1)!=0){\\n                if(j==0){\\n                    j=1;\\n                    // i++;\\n                }\\n                else{\\n                    // j=0;\\n                    if(dis<i){\\n                        dis=i;\\n                        // i=0;\\n                    }\\n                    i=0;\\n                }\\n                // i++;\\n                \\n            }\\n            if(j==1){\\n                i++;\\n            }\\n            n=n>>1;\\n        }\\n        return dis;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3697621,
                "title": "fastest",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int binaryGap(int n) \\n    {\\n        int i=0;\\n        int li=-1;\\n        int ans = 0;\\n        while(n>0)\\n        {\\n            if(n%2)\\n            {\\n                if(li==-1)\\n                {\\n                    li=i;\\n                }\\n                else\\n                {\\n                    ans = max(i-li, ans);\\n                    li=i;\\n                }            \\n            }\\n            n/=2;\\n            i++;\\n        }\\n        \\n\\n        // std::cout<<;        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int binaryGap(int n) \\n    {\\n        int i=0;\\n        int li=-1;\\n        int ans = 0;\\n        while(n>0)\\n        {\\n            if(n%2)\\n            {\\n                if(li==-1)\\n                {\\n                    li=i;\\n                }\\n                else\\n                {\\n                    ans = max(i-li, ans);\\n                    li=i;\\n                }            \\n            }\\n            n/=2;\\n            i++;\\n        }\\n        \\n\\n        // std::cout<<;        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3687494,
                "title": "100-100-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int max = 0;\\n        int k = -1;\\n        int i = 0;\\n        while(n > 0)\\n        {\\n            if((n&1) == 1)\\n            {\\n               if(k != -1)\\n               {\\n                    max = Math.max(max,i-k);\\n               }\\n                k = i;\\n            }\\n            i++;\\n            n>>=1;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int max = 0;\\n        int k = -1;\\n        int i = 0;\\n        while(n > 0)\\n        {\\n            if((n&1) == 1)\\n            {\\n               if(k != -1)\\n               {\\n                    max = Math.max(max,i-k);\\n               }\\n                k = i;\\n            }\\n            i++;\\n            n>>=1;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3675230,
                "title": "python-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n\\n        l = list(bin(n)[2:])\\n        lg=[]\\n        while \"1\" in l:\\n            indice = l.index(\"1\")\\n            lg.append(indice)\\n            l[indice]=\"0\"\\n        maximo=0\\n        for i in range(1,len(lg)):\\n            var=lg[i]-lg[i-1]\\n            if maximo<var:\\n                maximo=var\\n        return maximo\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n\\n        l = list(bin(n)[2:])\\n        lg=[]\\n        while \"1\" in l:\\n            indice = l.index(\"1\")\\n            lg.append(indice)\\n            l[indice]=\"0\"\\n        maximo=0\\n        for i in range(1,len(lg)):\\n            var=lg[i]-lg[i-1]\\n            if maximo<var:\\n                maximo=var\\n        return maximo\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669421,
                "title": "javascript-bit-manipulation",
                "content": "# Code\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar binaryGap = function(n) {\\n\\n    let prevIndex = -1;\\n    let diff = 0;\\n    \\n    let index = 0;\\n    while(n > 0) {\\n        const bit = n & 1;\\n        if(bit === 1) {\\n            if(prevIndex === -1) {\\n                prevIndex = index; \\n            }\\n            else{\\n                diff = Math.max(diff, index - prevIndex);\\n                prevIndex = index;\\n            }\\n        }\\n\\n        n >>= 1;\\n        index++;\\n    }\\n\\n    return diff;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar binaryGap = function(n) {\\n\\n    let prevIndex = -1;\\n    let diff = 0;\\n    \\n    let index = 0;\\n    while(n > 0) {\\n        const bit = n & 1;\\n        if(bit === 1) {\\n            if(prevIndex === -1) {\\n                prevIndex = index; \\n            }\\n            else{\\n                diff = Math.max(diff, index - prevIndex);\\n                prevIndex = index;\\n            }\\n        }\\n\\n        n >>= 1;\\n        index++;\\n    }\\n\\n    return diff;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3644406,
                "title": "easy-to-understand-beats-100-0ms-tc-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int last = -1 , MaxGap = 0;\\n\\n        for(int i =0 ; i<32 ; i++){\\n            if((n&1) !=0){\\n                if(last==-1){\\n                    last=i;\\n                }else{\\n                    MaxGap=Math.max(MaxGap,i-last);\\n                    last=i;\\n                }\\n            }\\n            n>>=1;\\n        }\\n        return MaxGap; \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int last = -1 , MaxGap = 0;\\n\\n        for(int i =0 ; i<32 ; i++){\\n            if((n&1) !=0){\\n                if(last==-1){\\n                    last=i;\\n                }else{\\n                    MaxGap=Math.max(MaxGap,i-last);\\n                    last=i;\\n                }\\n            }\\n            n>>=1;\\n        }\\n        return MaxGap; \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3636123,
                "title": "bitwise-operation-play-with-bits",
                "content": "# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int ans = 0;\\n        int cur = 0;\\n        while( n > 0 ){\\n            int lsb = (n&1);\\n            if( lsb == 1 && cur == 0 ) cur++;\\n            else if( lsb == 1 && cur != 0 ) {\\n                ans = Math.max( ans , cur );\\n                cur = 1;\\n            }\\n            else if( cur != 0 ) cur++;\\n            n = n >> 1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int ans = 0;\\n        int cur = 0;\\n        while( n > 0 ){\\n            int lsb = (n&1);\\n            if( lsb == 1 && cur == 0 ) cur++;\\n            else if( lsb == 1 && cur != 0 ) {\\n                ans = Math.max( ans , cur );\\n                cur = 1;\\n            }\\n            else if( cur != 0 ) cur++;\\n            n = n >> 1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623422,
                "title": "doing-it-in-a-normal-way-thinking",
                "content": "# Intuition\\nThis is probably the first idea that comes to mind.\\n\\n# Complexity\\n- Time complexity:\\n O(n)\\n\\n- Space complexity:\\n O(n) + O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    fun binaryGap(n: Int): Int {\\n      val binaryString = Integer.toBinaryString(n)\\n        var max = 0\\n        var count = 0\\n        for (i in binaryString.indices) {\\n            if (binaryString[i] == \\'1\\') {\\n                if (count > max) max = count\\n                count = 1\\n            } else {\\n                count++\\n            }\\n        }\\n        return max  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun binaryGap(n: Int): Int {\\n      val binaryString = Integer.toBinaryString(n)\\n        var max = 0\\n        var count = 0\\n        for (i in binaryString.indices) {\\n            if (binaryString[i] == \\'1\\') {\\n                if (count > max) max = count\\n                count = 1\\n            } else {\\n                count++\\n            }\\n        }\\n        return max  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3617317,
                "title": "easy-solution-with-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint binaryGap(int n){\\n    int max = 0 , cnt = 0, flag = 0;\\n    while ( n > 0){\\n        if ( ( n & 1) == 1 ){\\n            if ( flag == 1 ){\\n                if ( max < cnt){\\n                    max  = cnt;\\n                }\\n                cnt = 1;\\n            } else {\\n                flag = 1;\\n                cnt = 1;\\n            }\\n            n >>= 1;\\n        } else {\\n            cnt++;\\n            n >>= 1;\\n        }\\n    }\\n    return max;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nint binaryGap(int n){\\n    int max = 0 , cnt = 0, flag = 0;\\n    while ( n > 0){\\n        if ( ( n & 1) == 1 ){\\n            if ( flag == 1 ){\\n                if ( max < cnt){\\n                    max  = cnt;\\n                }\\n                cnt = 1;\\n            } else {\\n                flag = 1;\\n                cnt = 1;\\n            }\\n            n >>= 1;\\n        } else {\\n            cnt++;\\n            n >>= 1;\\n        }\\n    }\\n    return max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3605910,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->so the approach is i take an pointer start which is the first bit and take another pointer end if character at start is equal to character at end then start pointer is equal to end pointer and the end will be incremented \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n         String s = Integer.toBinaryString(n);\\n          int ans = 0;\\n          int temp =0;\\n          //so first I took an initial pointer start that is equal to first index that is always one//\\n        int start = 0;\\n        //then I will take another pointer that will point to the one //\\n        int end  = start+1;\\n\\n        while(end<s.length()){\\n              if(s.charAt(start)!=s.charAt(end))\\n              {\\n                  end=end+1;\\n              }else{\\n                  temp = end-start;\\n                  start = end ;\\n                  end = end +1;\\n                  ans = Math.max(ans,temp);\\n              }\\n            }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n         String s = Integer.toBinaryString(n);\\n          int ans = 0;\\n          int temp =0;\\n          //so first I took an initial pointer start that is equal to first index that is always one//\\n        int start = 0;\\n        //then I will take another pointer that will point to the one //\\n        int end  = start+1;\\n\\n        while(end<s.length()){\\n              if(s.charAt(start)!=s.charAt(end))\\n              {\\n                  end=end+1;\\n              }else{\\n                  temp = end-start;\\n                  start = end ;\\n                  end = end +1;\\n                  ans = Math.max(ans,temp);\\n              }\\n            }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565853,
                "content": [
                    {
                        "username": "1creation",
                        "content": "distance between \\'1\\' and \\'1\\'\\nlet`s check all distances in binary representation\\n10010001101\\n\\t1. first distance 1001 (from 0 to 3 index) -> distance 3\\n2.10001 (from 3 to 7) -> distance 4\\n3.11 (from 7 to 8) -> distance 1\\n4.101 (from 8 to 10) -> distance 2"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Why does this problem has so many dislikes? Think it is a good problem."
                    },
                    {
                        "username": "ajbeach2",
                        "content": "The solution is wrong:\\n\\ncheck out 1041 as a test case. The solution in the editorial returns 6, but the answer should be 5"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "so why is the  test case of n=6\\nhave expected output of 1 when 6 ie. 0110, has two adjacent st bits with no 0s in between?\\ndoesnt the prob description say that return result should be 0 if thats\\'s the case?\\nany help?"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "The problem description says return 0 if there are no adjacent 1 bits . For n = 6(0110) there are two adjacent 1 bits which are at a distance of 1 apart."
                    },
                    {
                        "username": "mo7",
                        "content": "Xodility also have a question like this with different define of the distance."
                    },
                    {
                        "username": "saiful007",
                        "content": "I am struggling with the problem desciption can anyone help me with that?"
                    },
                    {
                        "username": "Adiyadav23",
                        "content": "The question is asking for absolute difference between the indices of 1's, not the number of 0's between them.\nEg: '11' = 1, not 0."
                    },
                    {
                        "username": "ajbeach2",
                        "content": "The editorial solution is wrong for 1041\\n\\n10000010001 is 1041 in binary.\\n\\nThe solution should be 5, but the editorial solution, 6 is returned. "
                    }
                ]
            },
            {
                "id": 1859732,
                "content": [
                    {
                        "username": "1creation",
                        "content": "distance between \\'1\\' and \\'1\\'\\nlet`s check all distances in binary representation\\n10010001101\\n\\t1. first distance 1001 (from 0 to 3 index) -> distance 3\\n2.10001 (from 3 to 7) -> distance 4\\n3.11 (from 7 to 8) -> distance 1\\n4.101 (from 8 to 10) -> distance 2"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Why does this problem has so many dislikes? Think it is a good problem."
                    },
                    {
                        "username": "ajbeach2",
                        "content": "The solution is wrong:\\n\\ncheck out 1041 as a test case. The solution in the editorial returns 6, but the answer should be 5"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "so why is the  test case of n=6\\nhave expected output of 1 when 6 ie. 0110, has two adjacent st bits with no 0s in between?\\ndoesnt the prob description say that return result should be 0 if thats\\'s the case?\\nany help?"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "The problem description says return 0 if there are no adjacent 1 bits . For n = 6(0110) there are two adjacent 1 bits which are at a distance of 1 apart."
                    },
                    {
                        "username": "mo7",
                        "content": "Xodility also have a question like this with different define of the distance."
                    },
                    {
                        "username": "saiful007",
                        "content": "I am struggling with the problem desciption can anyone help me with that?"
                    },
                    {
                        "username": "Adiyadav23",
                        "content": "The question is asking for absolute difference between the indices of 1's, not the number of 0's between them.\nEg: '11' = 1, not 0."
                    },
                    {
                        "username": "ajbeach2",
                        "content": "The editorial solution is wrong for 1041\\n\\n10000010001 is 1041 in binary.\\n\\nThe solution should be 5, but the editorial solution, 6 is returned. "
                    }
                ]
            },
            {
                "id": 1633657,
                "content": [
                    {
                        "username": "1creation",
                        "content": "distance between \\'1\\' and \\'1\\'\\nlet`s check all distances in binary representation\\n10010001101\\n\\t1. first distance 1001 (from 0 to 3 index) -> distance 3\\n2.10001 (from 3 to 7) -> distance 4\\n3.11 (from 7 to 8) -> distance 1\\n4.101 (from 8 to 10) -> distance 2"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Why does this problem has so many dislikes? Think it is a good problem."
                    },
                    {
                        "username": "ajbeach2",
                        "content": "The solution is wrong:\\n\\ncheck out 1041 as a test case. The solution in the editorial returns 6, but the answer should be 5"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "so why is the  test case of n=6\\nhave expected output of 1 when 6 ie. 0110, has two adjacent st bits with no 0s in between?\\ndoesnt the prob description say that return result should be 0 if thats\\'s the case?\\nany help?"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "The problem description says return 0 if there are no adjacent 1 bits . For n = 6(0110) there are two adjacent 1 bits which are at a distance of 1 apart."
                    },
                    {
                        "username": "mo7",
                        "content": "Xodility also have a question like this with different define of the distance."
                    },
                    {
                        "username": "saiful007",
                        "content": "I am struggling with the problem desciption can anyone help me with that?"
                    },
                    {
                        "username": "Adiyadav23",
                        "content": "The question is asking for absolute difference between the indices of 1's, not the number of 0's between them.\nEg: '11' = 1, not 0."
                    },
                    {
                        "username": "ajbeach2",
                        "content": "The editorial solution is wrong for 1041\\n\\n10000010001 is 1041 in binary.\\n\\nThe solution should be 5, but the editorial solution, 6 is returned. "
                    }
                ]
            },
            {
                "id": 1685912,
                "content": [
                    {
                        "username": "1creation",
                        "content": "distance between \\'1\\' and \\'1\\'\\nlet`s check all distances in binary representation\\n10010001101\\n\\t1. first distance 1001 (from 0 to 3 index) -> distance 3\\n2.10001 (from 3 to 7) -> distance 4\\n3.11 (from 7 to 8) -> distance 1\\n4.101 (from 8 to 10) -> distance 2"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Why does this problem has so many dislikes? Think it is a good problem."
                    },
                    {
                        "username": "ajbeach2",
                        "content": "The solution is wrong:\\n\\ncheck out 1041 as a test case. The solution in the editorial returns 6, but the answer should be 5"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "so why is the  test case of n=6\\nhave expected output of 1 when 6 ie. 0110, has two adjacent st bits with no 0s in between?\\ndoesnt the prob description say that return result should be 0 if thats\\'s the case?\\nany help?"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "The problem description says return 0 if there are no adjacent 1 bits . For n = 6(0110) there are two adjacent 1 bits which are at a distance of 1 apart."
                    },
                    {
                        "username": "mo7",
                        "content": "Xodility also have a question like this with different define of the distance."
                    },
                    {
                        "username": "saiful007",
                        "content": "I am struggling with the problem desciption can anyone help me with that?"
                    },
                    {
                        "username": "Adiyadav23",
                        "content": "The question is asking for absolute difference between the indices of 1's, not the number of 0's between them.\nEg: '11' = 1, not 0."
                    },
                    {
                        "username": "ajbeach2",
                        "content": "The editorial solution is wrong for 1041\\n\\n10000010001 is 1041 in binary.\\n\\nThe solution should be 5, but the editorial solution, 6 is returned. "
                    }
                ]
            },
            {
                "id": 1573579,
                "content": [
                    {
                        "username": "1creation",
                        "content": "distance between \\'1\\' and \\'1\\'\\nlet`s check all distances in binary representation\\n10010001101\\n\\t1. first distance 1001 (from 0 to 3 index) -> distance 3\\n2.10001 (from 3 to 7) -> distance 4\\n3.11 (from 7 to 8) -> distance 1\\n4.101 (from 8 to 10) -> distance 2"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Why does this problem has so many dislikes? Think it is a good problem."
                    },
                    {
                        "username": "ajbeach2",
                        "content": "The solution is wrong:\\n\\ncheck out 1041 as a test case. The solution in the editorial returns 6, but the answer should be 5"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "so why is the  test case of n=6\\nhave expected output of 1 when 6 ie. 0110, has two adjacent st bits with no 0s in between?\\ndoesnt the prob description say that return result should be 0 if thats\\'s the case?\\nany help?"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "The problem description says return 0 if there are no adjacent 1 bits . For n = 6(0110) there are two adjacent 1 bits which are at a distance of 1 apart."
                    },
                    {
                        "username": "mo7",
                        "content": "Xodility also have a question like this with different define of the distance."
                    },
                    {
                        "username": "saiful007",
                        "content": "I am struggling with the problem desciption can anyone help me with that?"
                    },
                    {
                        "username": "Adiyadav23",
                        "content": "The question is asking for absolute difference between the indices of 1's, not the number of 0's between them.\nEg: '11' = 1, not 0."
                    },
                    {
                        "username": "ajbeach2",
                        "content": "The editorial solution is wrong for 1041\\n\\n10000010001 is 1041 in binary.\\n\\nThe solution should be 5, but the editorial solution, 6 is returned. "
                    }
                ]
            },
            {
                "id": 2058642,
                "content": [
                    {
                        "username": "1creation",
                        "content": "distance between \\'1\\' and \\'1\\'\\nlet`s check all distances in binary representation\\n10010001101\\n\\t1. first distance 1001 (from 0 to 3 index) -> distance 3\\n2.10001 (from 3 to 7) -> distance 4\\n3.11 (from 7 to 8) -> distance 1\\n4.101 (from 8 to 10) -> distance 2"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Why does this problem has so many dislikes? Think it is a good problem."
                    },
                    {
                        "username": "ajbeach2",
                        "content": "The solution is wrong:\\n\\ncheck out 1041 as a test case. The solution in the editorial returns 6, but the answer should be 5"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "so why is the  test case of n=6\\nhave expected output of 1 when 6 ie. 0110, has two adjacent st bits with no 0s in between?\\ndoesnt the prob description say that return result should be 0 if thats\\'s the case?\\nany help?"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "The problem description says return 0 if there are no adjacent 1 bits . For n = 6(0110) there are two adjacent 1 bits which are at a distance of 1 apart."
                    },
                    {
                        "username": "mo7",
                        "content": "Xodility also have a question like this with different define of the distance."
                    },
                    {
                        "username": "saiful007",
                        "content": "I am struggling with the problem desciption can anyone help me with that?"
                    },
                    {
                        "username": "Adiyadav23",
                        "content": "The question is asking for absolute difference between the indices of 1's, not the number of 0's between them.\nEg: '11' = 1, not 0."
                    },
                    {
                        "username": "ajbeach2",
                        "content": "The editorial solution is wrong for 1041\\n\\n10000010001 is 1041 in binary.\\n\\nThe solution should be 5, but the editorial solution, 6 is returned. "
                    }
                ]
            },
            {
                "id": 1945810,
                "content": [
                    {
                        "username": "1creation",
                        "content": "distance between \\'1\\' and \\'1\\'\\nlet`s check all distances in binary representation\\n10010001101\\n\\t1. first distance 1001 (from 0 to 3 index) -> distance 3\\n2.10001 (from 3 to 7) -> distance 4\\n3.11 (from 7 to 8) -> distance 1\\n4.101 (from 8 to 10) -> distance 2"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Why does this problem has so many dislikes? Think it is a good problem."
                    },
                    {
                        "username": "ajbeach2",
                        "content": "The solution is wrong:\\n\\ncheck out 1041 as a test case. The solution in the editorial returns 6, but the answer should be 5"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "so why is the  test case of n=6\\nhave expected output of 1 when 6 ie. 0110, has two adjacent st bits with no 0s in between?\\ndoesnt the prob description say that return result should be 0 if thats\\'s the case?\\nany help?"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "The problem description says return 0 if there are no adjacent 1 bits . For n = 6(0110) there are two adjacent 1 bits which are at a distance of 1 apart."
                    },
                    {
                        "username": "mo7",
                        "content": "Xodility also have a question like this with different define of the distance."
                    },
                    {
                        "username": "saiful007",
                        "content": "I am struggling with the problem desciption can anyone help me with that?"
                    },
                    {
                        "username": "Adiyadav23",
                        "content": "The question is asking for absolute difference between the indices of 1's, not the number of 0's between them.\nEg: '11' = 1, not 0."
                    },
                    {
                        "username": "ajbeach2",
                        "content": "The editorial solution is wrong for 1041\\n\\n10000010001 is 1041 in binary.\\n\\nThe solution should be 5, but the editorial solution, 6 is returned. "
                    }
                ]
            }
        ]
    }
]