[
    {
        "title": "Count Increasing Quadruplets",
        "question_content": "Given a 0-indexed integer array nums of size n containing all numbers from 1 to n, return the number of increasing quadruplets.\nA quadruplet (i, j, k, l) is increasing if:\n\n\t0 <= i < j < k < l < n, and\n\tnums[i] < nums[k] < nums[j] < nums[l].\n\n&nbsp;\nExample 1:\n\nInput: nums = [1,3,2,4,5]\nOutput: 2\nExplanation: \n- When i = 0, j = 1, k = 2, and l = 3, nums[i] < nums[k] < nums[j] < nums[l].\n- When i = 0, j = 1, k = 2, and l = 4, nums[i] < nums[k] < nums[j] < nums[l]. \nThere are no other quadruplets, so we return 2.\n\nExample 2:\n\nInput: nums = [1,2,3,4]\nOutput: 0\nExplanation: There exists only one quadruplet with i = 0, j = 1, k = 2, l = 3, but since nums[j] < nums[k], we return 0.\n\n&nbsp;\nConstraints:\n\n\t4 <= nums.length <= 4000\n\t1 <= nums[i] <= nums.length\n\tAll the integers of nums are unique. nums is a permutation.",
        "solutions": [
            {
                "id": 3111697,
                "title": "c-java-python3-cleanest-code-with-clarification-o-n-2",
                "content": "# Intuition\\n\\nWe will break this problem down to counting the number of **132 triplet** first, then we count **1324 quadraplet** based on **triplet counts**.\\n\\nSpecifically, We use `cnt[j]` stores the **count** of all valid 132 triplets `(i, j, k)` that satisfies `i < j < k` and `nums[i] < nums[k] < nums[j]` and using the current index number as the role `j`. (Similar question [Leetcode Q456 132 pattern](https://leetcode.com/problems/132-pattern/))\\n\\nFor every new value `l`, iterate all previous stored `cnt[j]` (132 pattern counts). If `nums[l] > nums[j]`, they can form a valid 1324 quadruplet pattern, then add `cnt[j]` into total 1324 counts.\\n\\nDuring iteration, we also update previous `cnt[j]` by keeping track of the amount of numbers smaller than new value (`l`) in front of `j`. If `nums[l] < nums[j]`, the new value (`l`) is a potential `k` for `j` in the future, so add its `previous_small` to the `cnt[j]`.\\n\\nNote that in code, $i$ is actually `j`, $j$ is actually `l`, relate to above explanation.\\n\\n# Complexity\\n\\n- Time complexity: $O(n^2)$\\n\\n- Space complexity: $O(n)$\\n\\n# Code\\n```python []\\nclass Solution:\\n    def countQuadruplets(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        cnt = [0] * n\\n        ans = 0\\n        for j in range(n):\\n            prev_small = 0\\n            for i in range(j):\\n                if nums[j] > nums[i]:\\n                    prev_small += 1\\n                    ans += cnt[i]\\n                elif nums[j] < nums[i]:\\n                    cnt[i] += prev_small\\n        return ans\\n```\\n```java []\\nclass Solution {\\n    public long countQuadruplets(int[] nums) {\\n        int n = nums.length;\\n        long[] cnt = new long[n];\\n        long ans = 0;\\n        for (int j = 0; j < n; j++) {\\n            int prev_small = 0;\\n            for (int i = 0; i < j; i++) {\\n                if (nums[j] > nums[i]) {\\n                    prev_small++;\\n                    ans += cnt[i];\\n                } else if (nums[j] < nums[i]) {\\n                    cnt[i] += prev_small;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& nums) {\\n        long long ans=0;\\n        int n=nums.size();\\n        long long prev_small=0;\\n        vector<long long> cnt(n,0);\\n        for(int i=0 ; i<n  ; i++){\\n            prev_small=0;\\n            for(int j=0 ; j<i ; j++){\\n                if(nums[i]>nums[j]){\\n                    prev_small++;\\n                    ans+=cnt[j];\\n                }\\n                else if(nums[i]<nums[j]){\\n                    cnt[j]+=prev_small;\\n                }\\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```\\n```Javascript []\\nvar countQuadruplets = function (nums) {\\n  const N = nums.length;\\n  let ans = 0;\\n  let cnt = Array(N).fill(0);\\n\\n  for (let j = 0; j < N; j++) {\\n    let prev_small = 0;\\n    for (let i = 0; i < j; i++) {\\n      if (nums[j] > nums[i]) {\\n        prev_small++;\\n        ans += cnt[i];\\n      } else if (nums[j] < nums[i]) {\\n        cnt[i] += prev_small;\\n      }\\n    }\\n  }\\n  return ans;\\n};\\n```\\n\\nC++ is contributed by @Manan_Jain_4, Java is contributed by @ibmtp380, Javascript is contributed by @Gang-Li.\\n\\n# Lets do some Simulation\\n\\n![2552.png](https://assets.leetcode.com/users/images/c2e957e4-7e68-483a-9726-28012d0ad613_1687130320.432753.png)\\n\\n\\n\\n# Please Vote Up if this helps ;D",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```python []\\nclass Solution:\\n    def countQuadruplets(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        cnt = [0] * n\\n        ans = 0\\n        for j in range(n):\\n            prev_small = 0\\n            for i in range(j):\\n                if nums[j] > nums[i]:\\n                    prev_small += 1\\n                    ans += cnt[i]\\n                elif nums[j] < nums[i]:\\n                    cnt[i] += prev_small\\n        return ans\\n```\n```java []\\nclass Solution {\\n    public long countQuadruplets(int[] nums) {\\n        int n = nums.length;\\n        long[] cnt = new long[n];\\n        long ans = 0;\\n        for (int j = 0; j < n; j++) {\\n            int prev_small = 0;\\n            for (int i = 0; i < j; i++) {\\n                if (nums[j] > nums[i]) {\\n                    prev_small++;\\n                    ans += cnt[i];\\n                } else if (nums[j] < nums[i]) {\\n                    cnt[i] += prev_small;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& nums) {\\n        long long ans=0;\\n        int n=nums.size();\\n        long long prev_small=0;\\n        vector<long long> cnt(n,0);\\n        for(int i=0 ; i<n  ; i++){\\n            prev_small=0;\\n            for(int j=0 ; j<i ; j++){\\n                if(nums[i]>nums[j]){\\n                    prev_small++;\\n                    ans+=cnt[j];\\n                }\\n                else if(nums[i]<nums[j]){\\n                    cnt[j]+=prev_small;\\n                }\\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```\n```Javascript []\\nvar countQuadruplets = function (nums) {\\n  const N = nums.length;\\n  let ans = 0;\\n  let cnt = Array(N).fill(0);\\n\\n  for (let j = 0; j < N; j++) {\\n    let prev_small = 0;\\n    for (let i = 0; i < j; i++) {\\n      if (nums[j] > nums[i]) {\\n        prev_small++;\\n        ans += cnt[i];\\n      } else if (nums[j] < nums[i]) {\\n        cnt[i] += prev_small;\\n      }\\n    }\\n  }\\n  return ans;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111829,
                "title": "c-java-python-enumerate-all-j-k-pairs-with-o-n-complexity",
                "content": "> **I know almost nothing about English, pointing out the mistakes in my article would be much appreciated.**\\n\\n> **In addition, I\\'m too weak, please be critical of my ideas.**\\n---\\n\\nThis is an [Better answer](https://leetcode.com/problems/count-increasing-quadruplets/solutions/3111697/python3-clean-dp-with-clarification-o-n-2/)!\\n\\n# Intuition\\n1. The data range is no greater than $4000$, so we can consider an angorithm with around $O(n^2)$ time complexity.\\n2. This problem seems like [LeetCode 493](https://leetcode.com/problems/reverse-pairs/) and [LeetCode 2179](https://leetcode.com/problems/count-good-triplets-in-an-array/), a direct idea is enumerating all the middle pairs, and count how many numbers could be the $i$ and $l$ for each $j$ and $k$.\\n3. A simple way to count is to use a [Binary Index Tree](https://en.wikipedia.org/wiki/Fenwick_tree), which allows for fast point updates and range sums.\\n4. But notice that the range of $a[i]$ will never greater than $n$, so we can generate two tables:\\n    - $left[i][j]$ records \"from $0$ to $i-1$, the count of $< j$\"\\n    - $right[i][j]$ records \"from $n-1$ to $i+1$, the count of $>j$\".\\n5. Enumerate all the $jk$ pairs, the answer can be obtained using the [Rule of product](https://en.wikipedia.org/wiki/Rule_of_product).\\n\\n# Complexity\\n- Time complexity: $O(n^2)$\\n- Space complexity: $O(n^2)$\\n\\n# Code\\n``` C++ []\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& a) {\\n        long long res = 0;\\n        int n = a.size();\\n        vector<vector<int>> left(n, vector<int>(n+1, 0));\\n        vector<vector<int>> right(n, vector<int>(n+1, 0));\\n        for (int i = 1; i < n; ++i) {\\n            // new array will based on the old array\\n            left[i] = left[i-1];\\n            // update all the elements greater than a[i-1]\\n            for (int j = a[i-1] + 1; j <= n; ++j)\\n                left[i][j]++;\\n        }\\n        for (int i = n-2; i >= 0; --i) {\\n            right[i] = right[i+1];\\n            for (int j = 0; j < a[i+1]; ++j)\\n                right[i][j]++;\\n        }\\n        for (int j = 0; j < n; ++j) {\\n            for (int k = j+1; k < n; ++k) {\\n                if (a[j] <= a[k]) continue;\\n                // left[j][a[k]] is the count of feasible i\\n                // right[k][a[j]] is the count of feasible l\\n                res += left[j][a[k]] * right[k][a[j]];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n``` Java []\\nclass Solution {\\n    public long countQuadruplets(int[] a) {\\n        long res = 0;\\n        int n = a.length;\\n        int [][]left = new int[n][n+1];\\n        int [][]right = new int[n][n+1];\\n        for (int i = 1; i < n; ++i) {\\n            // new array will based on the old array\\n            for (int j = 0; j <= n; ++j) \\n                left[i][j] = left[i-1][j];\\n            // update all the elements greater than a[i-1]\\n            for (int j = a[i-1] + 1; j <= n; ++j)\\n                left[i][j]++;\\n        }\\n        for (int i = n-2; i >= 0; --i) {\\n            for (int j = 0; j <= n; ++j) \\n                right[i][j] = right[i+1][j];\\n            for (int j = 0; j < a[i+1]; ++j) \\n                right[i][j]++;\\n        }\\n        for (int j = 0; j < n; ++j) {\\n            for (int k = j+1; k < n; ++k) {\\n                if (a[j] <= a[k]) continue;\\n                // left[j][a[k]] is the count of feasible i\\n                // right[k][a[j]] is the count of feasible l\\n                res += left[j][a[k]] * right[k][a[j]];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n``` Python3 []\\nclass Solution:\\n    def countQuadruplets(self, a: List[int]) -> int:\\n        res, n = 0, len(a)\\n        left = [None for j in range(n)]\\n        right = [None for j in range(n)]\\n        left[0] = [0 for i in range(n+1)]\\n        right[-1] = [0 for i in range(n+1)]\\n        for i in range(1, n):\\n            # new array will based on the old array\\n            left[i] = left[i-1].copy()\\n            # update all the elements greater than a[i-1]\\n            for j in range(a[i-1] + 1, n + 1):\\n                left[i][j] += 1\\n        for i in range(n-2, -1, -1):\\n            right[i] = right[i+1].copy()\\n            for j in range(a[i+1]):\\n                right[i][j] += 1\\n        for j in range(n):\\n            for k in range(j+1, n):\\n                # left[j][a[k]] is the count of feasible i\\n                # right[k][a[j]] is the count of feasible l\\n                if a[j] > a[k]:\\n                    res += left[j][a[k]] * right[k][a[j]]\\n        return res\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Enumeration"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& a) {\\n        long long res = 0;\\n        int n = a.size();\\n        vector<vector<int>> left(n, vector<int>(n+1, 0));\\n        vector<vector<int>> right(n, vector<int>(n+1, 0));\\n        for (int i = 1; i < n; ++i) {\\n            // new array will based on the old array\\n            left[i] = left[i-1];\\n            // update all the elements greater than a[i-1]\\n            for (int j = a[i-1] + 1; j <= n; ++j)\\n                left[i][j]++;\\n        }\\n        for (int i = n-2; i >= 0; --i) {\\n            right[i] = right[i+1];\\n            for (int j = 0; j < a[i+1]; ++j)\\n                right[i][j]++;\\n        }\\n        for (int j = 0; j < n; ++j) {\\n            for (int k = j+1; k < n; ++k) {\\n                if (a[j] <= a[k]) continue;\\n                // left[j][a[k]] is the count of feasible i\\n                // right[k][a[j]] is the count of feasible l\\n                res += left[j][a[k]] * right[k][a[j]];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n``` Java []\\nclass Solution {\\n    public long countQuadruplets(int[] a) {\\n        long res = 0;\\n        int n = a.length;\\n        int [][]left = new int[n][n+1];\\n        int [][]right = new int[n][n+1];\\n        for (int i = 1; i < n; ++i) {\\n            // new array will based on the old array\\n            for (int j = 0; j <= n; ++j) \\n                left[i][j] = left[i-1][j];\\n            // update all the elements greater than a[i-1]\\n            for (int j = a[i-1] + 1; j <= n; ++j)\\n                left[i][j]++;\\n        }\\n        for (int i = n-2; i >= 0; --i) {\\n            for (int j = 0; j <= n; ++j) \\n                right[i][j] = right[i+1][j];\\n            for (int j = 0; j < a[i+1]; ++j) \\n                right[i][j]++;\\n        }\\n        for (int j = 0; j < n; ++j) {\\n            for (int k = j+1; k < n; ++k) {\\n                if (a[j] <= a[k]) continue;\\n                // left[j][a[k]] is the count of feasible i\\n                // right[k][a[j]] is the count of feasible l\\n                res += left[j][a[k]] * right[k][a[j]];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\n``` Python3 []\\nclass Solution:\\n    def countQuadruplets(self, a: List[int]) -> int:\\n        res, n = 0, len(a)\\n        left = [None for j in range(n)]\\n        right = [None for j in range(n)]\\n        left[0] = [0 for i in range(n+1)]\\n        right[-1] = [0 for i in range(n+1)]\\n        for i in range(1, n):\\n            # new array will based on the old array\\n            left[i] = left[i-1].copy()\\n            # update all the elements greater than a[i-1]\\n            for j in range(a[i-1] + 1, n + 1):\\n                left[i][j] += 1\\n        for i in range(n-2, -1, -1):\\n            right[i] = right[i+1].copy()\\n            for j in range(a[i+1]):\\n                right[i][j] += 1\\n        for j in range(n):\\n            for k in range(j+1, n):\\n                # left[j][a[k]] is the count of feasible i\\n                # right[k][a[j]] is the count of feasible l\\n                if a[j] > a[k]:\\n                    res += left[j][a[k]] * right[k][a[j]]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111870,
                "title": "c-short-and-simple-no-dp-explained",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst precompute an array `lessthan` where `lessthan[i][j]` is the number of elements less than `i` in the first `j` elements.\\n\\nThen you loop through pairs (j, k), so for each iteration, you only need to find how many possible pairs (i, l) there are.\\n\\nTo do this, notice the number of potential `i` is equal to the count of numbers less than `nums[k]` before `j`. And the number of potential `l` is equal to the count of numbers greater than `nums[j]` after `k`. We can compute this in O(1) using `lessthan`. \\nSee below.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        int lessthan[n+1][n+1];\\n        for(int i = 0; i <= n; i++) lessthan[i][0] = 0;        \\n        for(int i = 1; i <= n; i++) \\n            for(int j = 0; j <= n; j++) \\n                lessthan[j][i] = lessthan[j][i-1] + (nums[i-1] < j);\\n        \\n        long long re = 0;\\n        for(int i = 0; i < n; i++){\\n            for(int j = i+1; j < n; j++){\\n                if(nums[i] > nums[j]){\\n                    \\n                    long long g = n-nums[i]-(j - lessthan[nums[i]][j+1]);\\n                    long long l = lessthan[nums[j]][i+1];\\n                    re += g*l;\\n                }\\n            }\\n        }\\n        return re;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        int lessthan[n+1][n+1];\\n        for(int i = 0; i <= n; i++) lessthan[i][0] = 0;        \\n        for(int i = 1; i <= n; i++) \\n            for(int j = 0; j <= n; j++) \\n                lessthan[j][i] = lessthan[j][i-1] + (nums[i-1] < j);\\n        \\n        long long re = 0;\\n        for(int i = 0; i < n; i++){\\n            for(int j = i+1; j < n; j++){\\n                if(nums[i] > nums[j]){\\n                    \\n                    long long g = n-nums[i]-(j - lessthan[nums[i]][j+1]);\\n                    long long l = lessthan[nums[j]][i+1];\\n                    re += g*l;\\n                }\\n            }\\n        }\\n        return re;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3113090,
                "title": "explained-with-diagram-fix-j-and-k-video-explanation-c-code",
                "content": "# Intuition\\nIndices are increasing in i < j < k < l\\nBut requirement is \\nnums[i] < nums[k] < nums[j] < nums[l]\\nRepreseting this visually:\\n![Screenshot 2023-01-29 at 15.41.42.png](https://assets.leetcode.com/users/images/cdb3bcbe-17ac-4e98-881d-64ef3129f4fb_1674987118.6553085.png)\\n\\nThere is a irregularity at j and k.\\nSo if we fix j and k index and get the count of all possible i and l indexes, we will be able to get count of quadraples.\\n \\n# Approach\\nUse pre computation to create 2d arrays leftC and rightC.\\n\\nleftC[i][no] represents count of elements towards the left of index i who are less than no\\n\\nrightC[i][no] represents count of elements towards the right of index i who are greater than no\\n\\nSince values in array are from 1 to n only where n is size of array.\\n\\nWe can do above precomputation easily in O(n^2)\\n\\nNow using two points fix j and k, and using leftC and rightC, get the count of quadraples.\\n\\nVideo for better understanding:\\n<iframe width=\"580\" height=\"315\" src=\"https://www.youtube.com/embed/CwN2GdDck7A\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n\\n- Space complexity: O(n^2)\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n\\tlong long countQuadruplets(vector<int>& nums) {\\n\\t\\tint n = nums.size();\\n\\t\\tvector<vector<int>> leftC(n + 1, vector<int>(n + 1, 0));\\n\\t\\tfor (int i = 0; i < nums.size(); ++i)\\n\\t\\t{\\n\\t\\t\\tfor (int no = 1; no <= n; ++no)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (nums[i] < no)\\n\\t\\t\\t\\t\\tleftC[i][no]++;\\n\\t\\t\\t\\tif (i > 0)\\n\\t\\t\\t\\t\\tleftC[i][no] += leftC[i - 1][no];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvector<vector<int>> rightC(n + 1, vector<int>(n + 1, 0));\\n\\t\\tfor (int i = nums.size() - 1; i >= 0; --i)\\n\\t\\t{\\n\\t\\t\\tfor (int no = 1; no <= n; ++no)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (nums[i] > no)\\n\\t\\t\\t\\t\\trightC[i][no]++;\\n\\t\\t\\t\\tif (i != nums.size() - 1)\\n\\t\\t\\t\\t\\trightC[i][no] += rightC[i + 1][no];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint j, k;\\n\\t\\tlong long lc, rc;\\n\\t\\tlong long ans = 0;\\n\\t\\tfor (j = 1; j < nums.size() - 2; ++j)\\n\\t\\t{\\n\\t\\t\\tfor (k = nums.size() - 2; k > j ; --k)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (nums[j] > nums[k])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tlc = leftC[j][nums[k]];\\n\\t\\t\\t\\t\\trc = rightC[k][nums[j]];\\n\\t\\t\\t\\t\\tans += lc * rc;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tlong long countQuadruplets(vector<int>& nums) {\\n\\t\\tint n = nums.size();\\n\\t\\tvector<vector<int>> leftC(n + 1, vector<int>(n + 1, 0));\\n\\t\\tfor (int i = 0; i < nums.size(); ++i)\\n\\t\\t{\\n\\t\\t\\tfor (int no = 1; no <= n; ++no)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (nums[i] < no)\\n\\t\\t\\t\\t\\tleftC[i][no]++;\\n\\t\\t\\t\\tif (i > 0)\\n\\t\\t\\t\\t\\tleftC[i][no] += leftC[i - 1][no];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvector<vector<int>> rightC(n + 1, vector<int>(n + 1, 0));\\n\\t\\tfor (int i = nums.size() - 1; i >= 0; --i)\\n\\t\\t{\\n\\t\\t\\tfor (int no = 1; no <= n; ++no)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (nums[i] > no)\\n\\t\\t\\t\\t\\trightC[i][no]++;\\n\\t\\t\\t\\tif (i != nums.size() - 1)\\n\\t\\t\\t\\t\\trightC[i][no] += rightC[i + 1][no];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint j, k;\\n\\t\\tlong long lc, rc;\\n\\t\\tlong long ans = 0;\\n\\t\\tfor (j = 1; j < nums.size() - 2; ++j)\\n\\t\\t{\\n\\t\\t\\tfor (k = nums.size() - 2; k > j ; --k)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (nums[j] > nums[k])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tlc = leftC[j][nums[k]];\\n\\t\\t\\t\\t\\trc = rightC[k][nums[j]];\\n\\t\\t\\t\\t\\tans += lc * rc;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112839,
                "title": "easy-video-solution-dp-c",
                "content": "# Intuition\\nconsider the pairs for the indices $j,k$ such that $j<k$ and $nums[j]>\\nnums[k]$. for all of these indices let\\'s check for all possibilities of $i$ and $l$ such that for $i$=> ($i<j$ and $nums[i]<nums[k]$) and for $l$=> ($l>k$ and $nums[l]>nums[j]$), we can call these possibilities as $poss_i$ and $poss_l$, on multiplying it we would get all quadruplets consider $j$ and $k$ as the inner pairs. We would perform traverse the entire array for checking all possible pairs of $j$ and $k$. \\nNow in order to calculate the $poss_i$ and $poss_l$ we can use the prefix array, let there be 2 2D arrays namely lesserThan and greaterThan let $lesserThan[i][j]$ denote the number of elements in the range $[i,j]$ which are lesser than $nums[j]$, let $greaterThan[i][j]$ denote the number of elementa in the $range[i][j]$ which are greater than $nums[i]$.\\n\\nThis a video tutorial of the same logic -> https://youtu.be/RxsbwiXvNkQ\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n $$O(n^2)$$ \\n\\n- Space complexity:\\n $$O(n^2)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<vector<int>> greaterThan(n,vector<int>(n,0)),lesserThan(n,vector<int>(n,0));\\n        // let greaterThan[i][j] represent number of elements in range i to j which are greater than nums[i]\\n        \\n        // let lesserThan[i][j] represent number of elements in range i to j which are lesser than nums[j];\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1,greater=0;j<n;j++){\\n                greater+=(nums[j]>nums[i]);\\n                greaterThan[i][j]=greater;\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=i-1,smaller=0;j>=0;j--){\\n                smaller+=(nums[j]<nums[i]);\\n                lesserThan[j][i]=smaller;\\n            }\\n        }\\n\\n        long long res=0;\\n        for(int j=1;j<n-2;j++){\\n            for(int k=j+1;k<n-1;k++){\\n                if(nums[j]>nums[k]){\\n                    int poss_i=(lesserThan[0][k]-lesserThan[j][k]);\\n                    int poss_l=(greaterThan[j][n-1]-greaterThan[j][k]);\\n                    res+=1ll*poss_i*poss_l;\\n                }\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<vector<int>> greaterThan(n,vector<int>(n,0)),lesserThan(n,vector<int>(n,0));\\n        // let greaterThan[i][j] represent number of elements in range i to j which are greater than nums[i]\\n        \\n        // let lesserThan[i][j] represent number of elements in range i to j which are lesser than nums[j];\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1,greater=0;j<n;j++){\\n                greater+=(nums[j]>nums[i]);\\n                greaterThan[i][j]=greater;\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=i-1,smaller=0;j>=0;j--){\\n                smaller+=(nums[j]<nums[i]);\\n                lesserThan[j][i]=smaller;\\n            }\\n        }\\n\\n        long long res=0;\\n        for(int j=1;j<n-2;j++){\\n            for(int k=j+1;k<n-1;k++){\\n                if(nums[j]>nums[k]){\\n                    int poss_i=(lesserThan[0][k]-lesserThan[j][k]);\\n                    int poss_l=(greaterThan[j][n-1]-greaterThan[j][k]);\\n                    res+=1ll*poss_i*poss_l;\\n                }\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111821,
                "title": "java-prefix-and-suffix-clean-code-with-explanation-o-n-2-time-complexity",
                "content": "The brutal force solution is obvious, just need to check every quadruplets(i, j, k, l), in which we need four for loops, and the time complexity is O(n^4). n is the length of nums array. But the n can be 4000, this solutio is impossible.\\n\\nIn this case, O(n^2) might be possible intuitively.\\n\\nIf the time complexity is O(n^2), which means we might need two for loops. Then the question will be like:\\nwhich two indexes we need choose from i, j, k, l?\\n\\nThe answer is **j** and **k**.\\n\\nSince we notice that:\\nwe want **j < k** but **nums[j] > nums[k]**\\nand for every j and k, we check every i < j to see if nums[i] < nums[k], and every l > k to see if nums[l] > nums[i], this two for loops take O(n^2), so making the total time complexity to n^4 in the brutal force solution. But what if we can do these beforehand?\\n\\nWe can use two arrays similar to prefix/suffix sum to pre-store the counts. We can have two n x n array countLarger and countSmaller:\\n- **countLarger[i][j]** means how many numbers between index i and index j (both inclusive) that is larger than nums[i];\\n- **countSmaller[i][j]** means how many numbers between index i and index j (both inclusive) that is smaller than nums[j].\\n\\nThus, we only need O(1) time to get what we want:\\n- number of indexes i < j satisfying nums[i] < nums[k]:\\ncountSmaller[0][k] - countSmaller[j][k];\\n- number of indexes l > k satisfying nums[l] > nums[j]:\\ncountLarger[j][n - 1] - countLarger[j][k].\\n    \\n```\\nclass Solution {\\n    public long countQuadruplets(int[] nums) {\\n        int n = nums.length;\\n        /*\\n        countLarger[i][j] means how many numbers between index i and index j (both inclusive) that is larger than nums[i]\\n        countSmaller[i][j] means how many numbers between index i and index j (both inclusive) that is smaller than nums[j]\\n        */\\n        int[][] countLarger = new int[n][n], countSmaller = new int[n][n];\\n        for (int i = 0; i < n; i++) {\\n            int c = 0;\\n            for (int j = i + 1; j < n; j++) {\\n                if (nums[j] > nums[i]) {\\n                    countLarger[i][j] = ++c;\\n                } else {\\n                    countLarger[i][j] = c;\\n                }\\n            }\\n        }\\n        for (int i = n - 1; i >= 0; i--) {\\n            int c = 0;\\n            for (int j = i - 1; j >= 0; j--) {\\n                if (nums[j] < nums[i]) {\\n                    countSmaller[j][i] = ++c;\\n                } else {\\n                    countSmaller[j][i] = c;\\n                }\\n            }\\n        }       \\n        long res = 0;\\n        for (int j = 1; j < n - 2; j++) {\\n            for (int k = j + 1; k < n - 1; k++) {\\n                if (nums[k] > nums[j]) continue;\\n                // find the count how many numbers smaller than nums[k] and index smaller than j, and how many numbers larger than nums[j] and index larger than k\\uFF0C than add the product of them into res\\n                res += (countSmaller[0][k] - countSmaller[j][k]) * (countLarger[j][n - 1] - countLarger[j][k]);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\nbrutal force:\\n ```\\n   public long countQuadruplets(int[] nums) {\\n        int n = nums.length;\\n        long res = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                for (int k = j + 1; k < n; k++) {\\n                    for (int l = k + 1; l < n; l++) {\\n                        if (nums[i] < nums[k] && nums[k] < nums[j] && nums[j] < nums[l]) res++;\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution {\\n    public long countQuadruplets(int[] nums) {\\n        int n = nums.length;\\n        /*\\n        countLarger[i][j] means how many numbers between index i and index j (both inclusive) that is larger than nums[i]\\n        countSmaller[i][j] means how many numbers between index i and index j (both inclusive) that is smaller than nums[j]\\n        */\\n        int[][] countLarger = new int[n][n], countSmaller = new int[n][n];\\n        for (int i = 0; i < n; i++) {\\n            int c = 0;\\n            for (int j = i + 1; j < n; j++) {\\n                if (nums[j] > nums[i]) {\\n                    countLarger[i][j] = ++c;\\n                } else {\\n                    countLarger[i][j] = c;\\n                }\\n            }\\n        }\\n        for (int i = n - 1; i >= 0; i--) {\\n            int c = 0;\\n            for (int j = i - 1; j >= 0; j--) {\\n                if (nums[j] < nums[i]) {\\n                    countSmaller[j][i] = ++c;\\n                } else {\\n                    countSmaller[j][i] = c;\\n                }\\n            }\\n        }       \\n        long res = 0;\\n        for (int j = 1; j < n - 2; j++) {\\n            for (int k = j + 1; k < n - 1; k++) {\\n                if (nums[k] > nums[j]) continue;\\n                // find the count how many numbers smaller than nums[k] and index smaller than j, and how many numbers larger than nums[j] and index larger than k\\uFF0C than add the product of them into res\\n                res += (countSmaller[0][k] - countSmaller[j][k]) * (countLarger[j][n - 1] - countLarger[j][k]);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\n   public long countQuadruplets(int[] nums) {\\n        int n = nums.length;\\n        long res = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                for (int k = j + 1; k < n; k++) {\\n                    for (int l = k + 1; l < n; l++) {\\n                        if (nums[i] < nums[k] && nums[k] < nums[j] && nums[j] < nums[l]) res++;\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3140023,
                "title": "prefix-sum",
                "content": "We fix one number in quadruplet, and solve the problem for that number.\\n\\nLet\\'s rewrite the problem condition:\\n- `nums[i] < nums[k] < nums[j] < nums[l]`\\n\\nas:\\n- `nums[i] <  nums[j] > nums[k]`\\n- `nums[i] < nums[k]`\\n- `nums[j] < nums[l]`\\n\\n`nums[j]` is peaks, and that\\'s the element we fix.\\n\\nFor elements before `j`, we track elements `nums[i] < nums[j]` using a prefix sum (`ps`) array.\\n- We can build the prefix sum array after we count all elements before `j`.\\n\\nAfter we reach `j`, we count the number of valid triplets `nums[i] <  nums[j] > nums[k]`.\\n- For `nums[j] > nums[k]`, we use the prefix sum to count `nums[i] < nums[k]`.\\n- If `nums[j] < nums[k]`, this is the final element in the quadruplet `nums[l]`. \\n\\t- It completes all valid triplets, so we add the current triplet count to the result.\\n\\nThis example shows the calculatoin for `j == 4`:\\n![image](https://assets.leetcode.com/users/images/e3751e54-b810-49fc-8c70-d74d72be0fb2_1675802211.9329166.png)\\n\\n**C++**\\n```cpp\\nlong long countQuadruplets(vector<int>& nums) {\\n    long long res = 0, sz = nums.size(), ps[4001] = {};\\n    for (int j = 0; j < sz; ++j) {\\n        int triplets = 0;\\n        for (int num_i = nums[j] + 1; num_i < sz; ++num_i)\\n            ++ps[num_i];\\n        for (int k = j + 1; k < sz; ++k)\\n            if (nums[k] < nums[j])\\n                triplets += ps[nums[k]];\\n            else\\n                res += triplets;\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nlong long countQuadruplets(vector<int>& nums) {\\n    long long res = 0, sz = nums.size(), ps[4001] = {};\\n    for (int j = 0; j < sz; ++j) {\\n        int triplets = 0;\\n        for (int num_i = nums[j] + 1; num_i < sz; ++num_i)\\n            ++ps[num_i];\\n        for (int k = j + 1; k < sz; ++k)\\n            if (nums[k] < nums[j])\\n                triplets += ps[nums[k]];\\n            else\\n                res += triplets;\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3114477,
                "title": "java-2d-dp-explained",
                "content": "---\\n# Please Upvote \\uD83D\\uDE07\\n---\\n![image.png](https://assets.leetcode.com/users/images/156ad25c-6ada-40c4-89f9-7c394baa4f3d_1675000414.544189.png)\\n\\n### Code:\\n``` java []\\nclass Solution {\\n    public long countQuadruplets(int[] nums) {\\n        int n = nums.length;\\n        int[][] greaterThan = new int[n][n];\\n        int[][] lesserThan = new int[n][n];\\n        // greaterThan[i][j] means count of numbers between index i & j larger than nums[i]\\n        // lesserThan[i][j] means count of numbers between index i & j smaller than nums[j]\\n        // i & j are both inclusive\\n        \\n        // MOTTO: nums[i] < nums[k] < nums[j] < nums[l]\\n\\n        // Iterate to look for \\'nums[j] > nums[i]\\' possibilities\\n        for (int i = 0; i < n; i++) {\\n            int count = 0;  // for the current window (i -> j)\\n            for (int j = i + 1; j < n; j++) {\\n                // increment count if nums[j] > nums[i]\\n                count += (nums[j] > nums[i])? 1 : 0;\\n                greaterThan[i][j] = count;  // record the count\\n            }\\n        }\\n        \\n        // Iterate to look for \\'nums[l] > nums[k]\\' possibilities\\n        for (int l = n - 1; l >= 0; l--) {\\n            int count = 0;  // for the current window (k -> l)\\n            for (int k = l - 1; k >= 0; k--) {\\n                // increment count if nums[l] > nums[k]\\n                count += (nums[k] < nums[l])? 1 : 0;\\n                lesserThan[k][l] = count;   // record the count\\n            }\\n        }\\n        \\n        long ans = 0;\\n        // Iterate to look for \\'nums[j] > nums[k]\\' possibilities\\n        for (int j = 1; j < n - 2; j++) {\\n            for (int k = j + 1; k < n - 1; k++) {\\n                if (nums[j] < nums[k]) {    // if the opposite\\n                    continue;               // then simply ignore and skip\\n                }\\n\\n                // We have now reached at a position where nums[j] > nums[k]\\n                // We need the number of elements which are smaller than nums[j]\\n\\n                // 1  2  3  5  6  4  5  7  8  9\\n                //             j  k\\n                // |--------------|  --> count of (0 -> k)\\n                //             |--|  --> count of (j -> k)\\n                // |-----------|     --> count of (0 -> j) => which we want!!!\\n\\n                // So number of elements less than nums[j] in the range i -> j is\\n                // count of (0 -> k) - count of (j -> k)\\n                int possibleI = lesserThan[0][k] - lesserThan[j][k];\\n\\n                // Now we need the number of elements which are greater than nums[k]\\n\\n                // 1  2  3  5  6  4  5  7  8  9\\n                //             j  k\\n                //             |--------------|  --> count of (j -> n-1)\\n                //             |--|              --> count of (j -> k)\\n                //                |-----------|  --> count of (k -> n-1) => which we want!!!\\n\\n                // So number of elements greater than nums[k] in the range k -> n-1 is\\n                // count of (j -> n-1) - count of (j -> k)\\n                int possibleL = greaterThan[j][n-1] - greaterThan[j][k];\\n\\n                // multiply both of them to get the number of possible permutation of indices\\n                ans += (possibleI * possibleL);     // and add to ans variable\\n            }\\n        }\\n        \\n        return ans;     // return the final answer\\n    }\\n}\\n```\\n---\\n### Clean solution:\\n``` java []\\nclass Solution {\\n    public long countQuadruplets(int[] nums) {\\n        int n = nums.length;\\n        int[][] greaterThan = new int[n][n];\\n        int[][] lesserThan = new int[n][n];\\n\\n        for (int i = 0; i < n; i++) {\\n            int count = 0;  \\n            for (int j = i + 1; j < n; j++) {\\n                count += (nums[j] > nums[i])? 1 : 0;\\n                greaterThan[i][j] = count;  \\n            }\\n        }\\n        \\n        for (int l = n - 1; l >= 0; l--) {\\n            int count = 0;  \\n            for (int k = l - 1; k >= 0; k--) {\\n                count += (nums[k] < nums[l])? 1 : 0;\\n                lesserThan[k][l] = count;   \\n            }\\n        }\\n        \\n        long ans = 0;\\n        for (int j = 1; j < n - 2; j++) {\\n            for (int k = j + 1; k < n - 1; k++) {\\n                if (nums[j] < nums[k]) {   \\n                    continue;               \\n                }\\n\\n                int possibleI = lesserThan[0][k] - lesserThan[j][k];\\n                int possibleL = greaterThan[j][n-1] - greaterThan[j][k];\\n                ans += (possibleI * possibleL);     \\n            }\\n        }\\n        \\n        return ans;   \\n    }\\n}\\n```\\n--- \\n#### Time complexity: $$O(3 n ^ 2) => O(n ^ 2)$$\\n#### Space complexity: $$O(2 n ^ 2) => O(n ^ 2)$$\\n---\\n***[Check out this video to understand this solution \\u2714\\uFE0F](https://www.youtube.com/watch?v=RxsbwiXvNkQ)***",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "``` java []\\nclass Solution {\\n    public long countQuadruplets(int[] nums) {\\n        int n = nums.length;\\n        int[][] greaterThan = new int[n][n];\\n        int[][] lesserThan = new int[n][n];\\n        // greaterThan[i][j] means count of numbers between index i & j larger than nums[i]\\n        // lesserThan[i][j] means count of numbers between index i & j smaller than nums[j]\\n        // i & j are both inclusive\\n        \\n        // MOTTO: nums[i] < nums[k] < nums[j] < nums[l]\\n\\n        // Iterate to look for \\'nums[j] > nums[i]\\' possibilities\\n        for (int i = 0; i < n; i++) {\\n            int count = 0;  // for the current window (i -> j)\\n            for (int j = i + 1; j < n; j++) {\\n                // increment count if nums[j] > nums[i]\\n                count += (nums[j] > nums[i])? 1 : 0;\\n                greaterThan[i][j] = count;  // record the count\\n            }\\n        }\\n        \\n        // Iterate to look for \\'nums[l] > nums[k]\\' possibilities\\n        for (int l = n - 1; l >= 0; l--) {\\n            int count = 0;  // for the current window (k -> l)\\n            for (int k = l - 1; k >= 0; k--) {\\n                // increment count if nums[l] > nums[k]\\n                count += (nums[k] < nums[l])? 1 : 0;\\n                lesserThan[k][l] = count;   // record the count\\n            }\\n        }\\n        \\n        long ans = 0;\\n        // Iterate to look for \\'nums[j] > nums[k]\\' possibilities\\n        for (int j = 1; j < n - 2; j++) {\\n            for (int k = j + 1; k < n - 1; k++) {\\n                if (nums[j] < nums[k]) {    // if the opposite\\n                    continue;               // then simply ignore and skip\\n                }\\n\\n                // We have now reached at a position where nums[j] > nums[k]\\n                // We need the number of elements which are smaller than nums[j]\\n\\n                // 1  2  3  5  6  4  5  7  8  9\\n                //             j  k\\n                // |--------------|  --> count of (0 -> k)\\n                //             |--|  --> count of (j -> k)\\n                // |-----------|     --> count of (0 -> j) => which we want!!!\\n\\n                // So number of elements less than nums[j] in the range i -> j is\\n                // count of (0 -> k) - count of (j -> k)\\n                int possibleI = lesserThan[0][k] - lesserThan[j][k];\\n\\n                // Now we need the number of elements which are greater than nums[k]\\n\\n                // 1  2  3  5  6  4  5  7  8  9\\n                //             j  k\\n                //             |--------------|  --> count of (j -> n-1)\\n                //             |--|              --> count of (j -> k)\\n                //                |-----------|  --> count of (k -> n-1) => which we want!!!\\n\\n                // So number of elements greater than nums[k] in the range k -> n-1 is\\n                // count of (j -> n-1) - count of (j -> k)\\n                int possibleL = greaterThan[j][n-1] - greaterThan[j][k];\\n\\n                // multiply both of them to get the number of possible permutation of indices\\n                ans += (possibleI * possibleL);     // and add to ans variable\\n            }\\n        }\\n        \\n        return ans;     // return the final answer\\n    }\\n}\\n```\n``` java []\\nclass Solution {\\n    public long countQuadruplets(int[] nums) {\\n        int n = nums.length;\\n        int[][] greaterThan = new int[n][n];\\n        int[][] lesserThan = new int[n][n];\\n\\n        for (int i = 0; i < n; i++) {\\n            int count = 0;  \\n            for (int j = i + 1; j < n; j++) {\\n                count += (nums[j] > nums[i])? 1 : 0;\\n                greaterThan[i][j] = count;  \\n            }\\n        }\\n        \\n        for (int l = n - 1; l >= 0; l--) {\\n            int count = 0;  \\n            for (int k = l - 1; k >= 0; k--) {\\n                count += (nums[k] < nums[l])? 1 : 0;\\n                lesserThan[k][l] = count;   \\n            }\\n        }\\n        \\n        long ans = 0;\\n        for (int j = 1; j < n - 2; j++) {\\n            for (int k = j + 1; k < n - 1; k++) {\\n                if (nums[j] < nums[k]) {   \\n                    continue;               \\n                }\\n\\n                int possibleI = lesserThan[0][k] - lesserThan[j][k];\\n                int possibleL = greaterThan[j][n-1] - greaterThan[j][k];\\n                ans += (possibleI * possibleL);     \\n            }\\n        }\\n        \\n        return ans;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111696,
                "title": "python3-sortedlist-bisect-insort-solution-clean-concise",
                "content": "# Approach\\nWe break the quadruple into `(i, j)` and `(k, l)`, and use a `SortedList` data structure in Python to maintain the ongoing subarray up to `j`.\\n\\nFor each current element `nums[j]` (maintained using a for loop from left to right), we loop through the possible value of `nums[k]` from right to left, and count\\n\\n(1) how many element on the left of `j` that satisfies `nums[k] > nums[i]`, this can be achieved using a binary search;\\n(2) how many element on the right of `k` has the value `nums[l] > nums[j]`, this can be achieved by comparing the value of `nums[k]` with `nums[j]` each time;\\n\\nand add the product from (1) and (2) to the final `ans`.\\n\\n# Complexity\\n- Time complexity: $$O(n^2\\\\log n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def countQuadruplets(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        sl = SortedList([nums[0]])\\n        ans = 0\\n        for j in range(1, n):\\n            sl.add(nums[j])\\n            cnt = 1 if nums[j] < nums[-1] else 0\\n            for k in range(n - 2, j, -1):\\n                if nums[j] < nums[k]:\\n                    cnt += 1\\n                    continue\\n                ans += sl.bisect_left(nums[k]) * cnt\\n        return ans\\n```\\n\\n# Updated Code (02/08/2023)\\nIt has come to my attention that LC recently included additional long test cases that will make the above solution TLE (thanks to [noniero](https://leetcode.com/nonieno/) for pointing it out). Using the same algorithm but with the built-in `bisect.insort` method, we have the following `Accepted` solution (thanks to [chestnut890123](https://leetcode.com/chestnut890123/)).\\n```\\nclass Solution:\\n    def countQuadruplets(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        sl = [nums[0]]\\n        ans = 0\\n        for j in range(1, n):\\n            bisect.insort(sl, nums[j])\\n            cnt = 1 if nums[j] < nums[-1] else 0\\n            for k in range(n - 2, j, -1):\\n                if nums[j] < nums[k]:\\n                    cnt += 1\\n                    continue\\n                ans += bisect_left(sl, nums[k]) * cnt\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def countQuadruplets(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        sl = SortedList([nums[0]])\\n        ans = 0\\n        for j in range(1, n):\\n            sl.add(nums[j])\\n            cnt = 1 if nums[j] < nums[-1] else 0\\n            for k in range(n - 2, j, -1):\\n                if nums[j] < nums[k]:\\n                    cnt += 1\\n                    continue\\n                ans += sl.bisect_left(nums[k]) * cnt\\n        return ans\\n```\n```\\nclass Solution:\\n    def countQuadruplets(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        sl = [nums[0]]\\n        ans = 0\\n        for j in range(1, n):\\n            bisect.insort(sl, nums[j])\\n            cnt = 1 if nums[j] < nums[-1] else 0\\n            for k in range(n - 2, j, -1):\\n                if nums[j] < nums[k]:\\n                    cnt += 1\\n                    continue\\n                ans += bisect_left(sl, nums[k]) * cnt\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3115377,
                "title": "java-enumerate-j-k-with-prefix-suffix-sum-preprocessing-o-n-2",
                "content": "## Enumerate all (j, k) pairs - O(n^2)\\n\\nFor every` (j, k)` pair, we need find \\n1. the number of elements before index `j` and less than `nums[k]`, and\\n2. the number of elements after index `k` and larger than `nums[j]`\\n\\nThen the number of all increasing quadruplets containing the `(j, k)` pair  is the multiplication of above two numbers. \\nThe answer is summation of increasing quadruplets for every `(j, k)` pair.\\n\\n\\n## Preprocessing Procedure - O(n^2)\\n\\nNote we can find the number of elements before index `j` and less than `nums[k]` or the number of elements after index `k` and larger than `nums[j]` in `O(1)`.\\nThe trick is similar to [Prefix Sum](https://en.wikipedia.org/wiki/Prefix_sum). Let `prev(i, num)` be the number of elements less than `num` before index `i`. Then we have \\n* `prev(i, num) = prev(i - 1, num) + 1` if `nums[i - 1] < num`, and \\n* `prev(i, num) = prev(i - 1, num)` otherwise. \\n* The base case is `prev(0, num) = 0` since there is no element before index `0`.\\n\\n\\nSimilarly, let `suff(i, num)` be the number of elements larger than `num` after index `i`. Then we have \\n* `suff(i, num) = suff(i + 1, num) + 1` if `nums[i + 1] > num`, and \\n* `suff(i, num) = suff(i + 1, num)` otherwise. \\n* The base case is `suff(n - 1, num) = 0` since there is no element after index `n - 1`.\\n\\nFrom the above definition, we have\\n* `prev[j][nums[k]]` is the number of elements before index `j` and less than `nums[k]`, and\\n* `suff[k][nums[j]]` is the number of elements after index `k` and larger than `nums[j]`.\\n\\n\\n```\\nclass Solution {\\n    public long countQuadruplets(int[] nums) {\\n        int n = nums.length;\\n        \\n        // prev[i][j]: # of elements less then j before index i\\n        int[][] prev = new int[n][n + 1];\\n        for (int i = 1; i < n; i++) {\\n            for (int num = 1; num <= n; num++) {\\n                if (nums[i - 1] < num) prev[i][num] = prev[i - 1][num] + 1;\\n                else prev[i][num] = prev[i - 1][num];\\n            }\\n        }\\n        \\n        // suff[i][j]: # of elements larger than j after index i\\n        int[][] suff = new int[n][n + 1];\\n        for (int i = n - 2; i >= 0; i--) {\\n            for (int num = 1; num <= n; num++) {\\n                if (nums[i + 1] > num) suff[i][num] = suff[i + 1][num] + 1;\\n                else suff[i][num] = suff[i + 1][num];\\n            }\\n        }\\n        \\n        long res = 0l;\\n        \\n        // Enumerate (j, k)\\n        for (int i = 1; i < n - 1; i++) {\\n            for (int j = i + 1; j < n - 1; j++) {\\n                if (nums[i] > nums[j]) {\\n                    res += prev[i][nums[j]] * suff[j][nums[i]];\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Enumeration",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public long countQuadruplets(int[] nums) {\\n        int n = nums.length;\\n        \\n        // prev[i][j]: # of elements less then j before index i\\n        int[][] prev = new int[n][n + 1];\\n        for (int i = 1; i < n; i++) {\\n            for (int num = 1; num <= n; num++) {\\n                if (nums[i - 1] < num) prev[i][num] = prev[i - 1][num] + 1;\\n                else prev[i][num] = prev[i - 1][num];\\n            }\\n        }\\n        \\n        // suff[i][j]: # of elements larger than j after index i\\n        int[][] suff = new int[n][n + 1];\\n        for (int i = n - 2; i >= 0; i--) {\\n            for (int num = 1; num <= n; num++) {\\n                if (nums[i + 1] > num) suff[i][num] = suff[i + 1][num] + 1;\\n                else suff[i][num] = suff[i + 1][num];\\n            }\\n        }\\n        \\n        long res = 0l;\\n        \\n        // Enumerate (j, k)\\n        for (int i = 1; i < n - 1; i++) {\\n            for (int j = i + 1; j < n - 1; j++) {\\n                if (nums[i] > nums[j]) {\\n                    res += prev[i][nums[j]] * suff[j][nums[i]];\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111626,
                "title": "bit",
                "content": "# Intuition\\nTo form an increasing quadruplets\\n\\n1. i < j < k < l \\n2. nums[i] < nums[k] < nums[j] < nums[l]\\n\\nFocus on `j` and `k`, find a `k` after `j` and add \\ncount(nums[l] > nums[j] on the right side of `k`)*count(nums[i] < nums[k] on the right side of `j`) to result.\\nJust like [count-of-smaller-numbers-after-self](https://leetcode.com/problems/count-of-smaller-numbers-after-self/).\\nYou can use BIT to record and query.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n * nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nusing LL = long long;\\n\\nclass BIT {\\nprivate:\\n    vector<int> tree;\\n    int n;\\npublic:\\n    BIT(int n_){\\n        tree = vector<int>(n_, 0);\\n        n = n_;\\n    }\\n    void update(int idx, int delta) {\\n        for(idx = idx+1; idx<n; idx+=idx&(-idx)) \\n            tree[idx]+=delta;\\n    }\\n    LL prefixSum(int idx) {\\n        LL sum = 0;\\n        for(idx = idx+1; idx>0; idx-=idx&(-idx))\\n            sum += tree[idx];\\n        return sum;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& nums) {\\n        LL res = 0;\\n        int n = nums.size();\\n        BIT bitLeft = BIT(n+2);\\n        for(int i = 0; i < n; i++) {\\n            BIT bitRight = BIT(n+2);\\n            for(int j = n-1; j > i; j--) {\\n                if(nums[j]<nums[i]) \\n                    res += (bitRight.prefixSum(n) - bitRight.prefixSum(nums[i])) * bitLeft.prefixSum(nums[j]-1);\\n                bitRight.update(nums[j], 1);\\n            }\\n            bitLeft.update(nums[i], 1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Indexed Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nusing LL = long long;\\n\\nclass BIT {\\nprivate:\\n    vector<int> tree;\\n    int n;\\npublic:\\n    BIT(int n_){\\n        tree = vector<int>(n_, 0);\\n        n = n_;\\n    }\\n    void update(int idx, int delta) {\\n        for(idx = idx+1; idx<n; idx+=idx&(-idx)) \\n            tree[idx]+=delta;\\n    }\\n    LL prefixSum(int idx) {\\n        LL sum = 0;\\n        for(idx = idx+1; idx>0; idx-=idx&(-idx))\\n            sum += tree[idx];\\n        return sum;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& nums) {\\n        LL res = 0;\\n        int n = nums.size();\\n        BIT bitLeft = BIT(n+2);\\n        for(int i = 0; i < n; i++) {\\n            BIT bitRight = BIT(n+2);\\n            for(int j = n-1; j > i; j--) {\\n                if(nums[j]<nums[i]) \\n                    res += (bitRight.prefixSum(n) - bitRight.prefixSum(nums[i])) * bitLeft.prefixSum(nums[j]-1);\\n                bitRight.update(nums[j], 1);\\n            }\\n            bitLeft.update(nums[i], 1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112039,
                "title": "c-fenwick-tree-solution",
                "content": "# Intuition\\nThe intuition is to simplify the problem , since we can go upto n^2 time-complexity we can just fix two points for the problem and find remaining two points in linear ofr logirithmic time\\n\\nPicking the correct 2 points to fix is important else u will end up leaving cases , i did a similar mistake and ended up not submitting in the contest\\n\\nwe will try to fix two points such that we have to calculate queries like count numbers < x and count numbers > x(just an example) , This way our queries will not interefere with each other\\n\\n# Approach\\n\\n1. Fix the points j and k , and for each each pair nums[j] > nums[k] calculate the ans\\n2. On the left of j count numbers less than nums[k] and on the right of k we need to calculate numbers > nums[j]\\n3. This was we surely know that our numbers > nums[j]( l points) are surely greater than numbers <nums[k] (i points) and we end up satisfying\\n\\nnums[i] < nums[j] > nums[k] < nums[l]\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    class BIT {\\n    int n;\\n    vector<long long> v;\\npublic:\\n    BIT(int sz) {\\n        n = sz;\\n        v.resize(n + 1);\\n    }\\n    long long sum(int k) {\\n        //sum till index k\\n        long long sum = 0;\\n        while (k > 0) {\\n            sum += v[k];\\n            k -= k & -k;\\n        }\\n\\n        return sum;\\n    }\\n   void add(int k , int x) {\\n\\n        while (k <= n) {\\n            v[k] += x;\\n            k += k & -k;\\n        }\\n    }\\n\\n};\\n    long long countQuadruplets(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n        long long ans=0;\\n        BIT t1(4005);\\n        for(int j=0;j<n;j++){\\n            BIT t2(4005);\\n            //intitally add all the elements from k to end so that we can later remove them while iterating\\n            for(int k = j+1;k<n;k++) t2.add(nums[k],+1);\\n\\n            for(int k=j+1;k<n;k++){\\n                //fix the current k and remove it from the fenwick tree\\n                t2.add(nums[k],-1);\\n                if(nums[j] > nums[k]){\\n                    //calulate elements less than nums[k]\\n                    long long left = t1.sum(nums[k]);\\n                    //calculate elements greater than nums[j]\\n                    long long right = t2.sum(4002) - t2.sum(nums[j]);               \\n\\n                    ans += left * right;\\n                }\\n            }\\n            //add nums[j] in tree so that we consider it when j moves to right\\n            t1.add(nums[j],+1);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    class BIT {\\n    int n;\\n    vector<long long> v;\\npublic:\\n    BIT(int sz) {\\n        n = sz;\\n        v.resize(n + 1);\\n    }\\n    long long sum(int k) {\\n        //sum till index k\\n        long long sum = 0;\\n        while (k > 0) {\\n            sum += v[k];\\n            k -= k & -k;\\n        }\\n\\n        return sum;\\n    }\\n   void add(int k , int x) {\\n\\n        while (k <= n) {\\n            v[k] += x;\\n            k += k & -k;\\n        }\\n    }\\n\\n};\\n    long long countQuadruplets(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n        long long ans=0;\\n        BIT t1(4005);\\n        for(int j=0;j<n;j++){\\n            BIT t2(4005);\\n            //intitally add all the elements from k to end so that we can later remove them while iterating\\n            for(int k = j+1;k<n;k++) t2.add(nums[k],+1);\\n\\n            for(int k=j+1;k<n;k++){\\n                //fix the current k and remove it from the fenwick tree\\n                t2.add(nums[k],-1);\\n                if(nums[j] > nums[k]){\\n                    //calulate elements less than nums[k]\\n                    long long left = t1.sum(nums[k]);\\n                    //calculate elements greater than nums[j]\\n                    long long right = t2.sum(4002) - t2.sum(nums[j]);               \\n\\n                    ans += left * right;\\n                }\\n            }\\n            //add nums[j] in tree so that we consider it when j moves to right\\n            t1.add(nums[j],+1);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111875,
                "title": "easy-prefix-sums-with-intuition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. Here the constraints are 4000 so O(N^2) or O(N^2 logn) will work.\\n2. So to achieve N^2 we can at max fix 2 indexes .\\n3. Since we are given i<j<k<l and nums[i]<nums[k]<nums[j]<nums[l] , For simplicity sake lets find nums[i]<nums[j]<nums[k]<nums[l].\\n4. Can we fix any 2 indexes and find other two index in O(1) or O(Logn )  time ?\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.I am assuming we have to find i<j<k<l and  nums[i]<nums[j]<nums[k]<nums[l].\\n2. So lets fix j and k since it is easier to find elements> nums[k] from [k+1...n] and elements < nums[j] from [1..j-1].\\n3. We can pre compute such elements in O(N) time using prefix sum.\\n4. We can go across all possible j and k and number of elements for a fixed j and k would be l*r where l= number of elements on left of j such that it is smaller than nums[j] and number of elements >nums[k] and whose index is >k.\\n5.Now our main question, i<j<k<l and nums[i]<nums[k]<nums[j]<nums[l] can we change something in our code to achieve this? Yes , instead of just precomputing for number of elements < nums[j] we also have to store indexes .We can achieve this by prefix sums as well(see code for more clarification).\\n6. For Prefix sums implementation check my code i have added comments for more clarification.    \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N^2)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& nums) {\\n        int n = nums.size();\\n        long long ans=0;\\n        \\n        \\n        vector<vector<long long>> ls(n + 1, vector<long long>(n + 1, 0));  // ls[i][j]= num of elements smaller than nums[i] on the left side till index j where j belongs to 0..i-1 \\n        vector<vector<long long>> rs(n + 1, vector<long long>(n + 1, 0)); // rs[i][j]= num of elements greater than nums[i] on the right side  till index j where j belongs to n,n-1....i+1 \\n        \\n         \\n        for (int j = 1; j < n; j++) { \\n             // i from 0 to j-1 \\n           for (int i = 0; j < j; i++) {\\n                if (nums[i] < nums[j]) {\\n                    ls[j][i] += 1;\\n                }\\n            }\\n       }\\n        for (int i = 0; i < n - 1; i++){\\n            for (int j = n - 1; j > i; j--) {\\n                if (nums[j] > nums[i]) {\\n                    rs[i][j]++;\\n                }\\n            }\\n        }\\n        \\n        // prefix sum\\n       for (int i = 1; i < n; i++){\\n        for (int j = 0; j < i; j++){\\n            if (j == 0)\\n                continue;\\n            ls[i][j] += ls[i][j - 1];\\n        }\\n    }\\n        \\n    // prefix sums\\n    for (int i = 0; i < n - 1; i++) {\\n      for (int j = n - 1; j > i; j--) {\\n            rs[i][j] += rs[i][j + 1];\\n        }\\n    }\\n    for (int j = 1; j < n - 1; j++){\\n        for (int k = j + 1; k < n - 1; k++) {\\n             if (nums[j] > nums[k]){\\n                // num of elements smaller than nums[k] but from [0...j-1 index] and Number of elements greater than nums[j] in [k+1...n]\\n                ans += ls[k][j - 1] * rs[j][k + 1];\\n            }\\n        }\\n    }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& nums) {\\n        int n = nums.size();\\n        long long ans=0;\\n        \\n        \\n        vector<vector<long long>> ls(n + 1, vector<long long>(n + 1, 0));  // ls[i][j]= num of elements smaller than nums[i] on the left side till index j where j belongs to 0..i-1 \\n        vector<vector<long long>> rs(n + 1, vector<long long>(n + 1, 0)); // rs[i][j]= num of elements greater than nums[i] on the right side  till index j where j belongs to n,n-1....i+1 \\n        \\n         \\n        for (int j = 1; j < n; j++) { \\n             // i from 0 to j-1 \\n           for (int i = 0; j < j; i++) {\\n                if (nums[i] < nums[j]) {\\n                    ls[j][i] += 1;\\n                }\\n            }\\n       }\\n        for (int i = 0; i < n - 1; i++){\\n            for (int j = n - 1; j > i; j--) {\\n                if (nums[j] > nums[i]) {\\n                    rs[i][j]++;\\n                }\\n            }\\n        }\\n        \\n        // prefix sum\\n       for (int i = 1; i < n; i++){\\n        for (int j = 0; j < i; j++){\\n            if (j == 0)\\n                continue;\\n            ls[i][j] += ls[i][j - 1];\\n        }\\n    }\\n        \\n    // prefix sums\\n    for (int i = 0; i < n - 1; i++) {\\n      for (int j = n - 1; j > i; j--) {\\n            rs[i][j] += rs[i][j + 1];\\n        }\\n    }\\n    for (int j = 1; j < n - 1; j++){\\n        for (int k = j + 1; k < n - 1; k++) {\\n             if (nums[j] > nums[k]){\\n                // num of elements smaller than nums[k] but from [0...j-1 index] and Number of elements greater than nums[j] in [k+1...n]\\n                ans += ls[k][j - 1] * rs[j][k + 1];\\n            }\\n        }\\n    }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111837,
                "title": "ordered-set-c-solution",
                "content": "\\n# Code\\n```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n#define ll long long\\n#define ordered_set tree<ll, null_type,less<ll>, rb_tree_tag,tree_order_statistics_node_update>\\n\\nclass Solution {\\npublic\\n    long long countQuadruplets(vector<int>& nums) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n        \\n        int n= nums.size();\\n\\n        ordered_set st2;\\n        ll ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int cnt=0;\\n            for(int j=n-1;j>i;j--)\\n            {\\n                if(nums[j]< nums[i])\\n                {\\n                   int x= st2.order_of_key(nums[j]);\\n                   int y= cnt;\\n                   ans+= x* y;\\n                }\\n                else if(nums[j] > nums[i]) cnt++;\\n            }\\n            st2.insert(nums[i]);\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n#define ll long long\\n#define ordered_set tree<ll, null_type,less<ll>, rb_tree_tag,tree_order_statistics_node_update>\\n\\nclass Solution {\\npublic\\n    long long countQuadruplets(vector<int>& nums) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n        \\n        int n= nums.size();\\n\\n        ordered_set st2;\\n        ll ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int cnt=0;\\n            for(int j=n-1;j>i;j--)\\n            {\\n                if(nums[j]< nums[i])\\n                {\\n                   int x= st2.order_of_key(nums[j]);\\n                   int y= cnt;\\n                   ans+= x* y;\\n                }\\n                else if(nums[j] > nums[i]) cnt++;\\n            }\\n            st2.insert(nums[i]);\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3115097,
                "title": "javascript-bottom-up-dp",
                "content": "I was smashing my head against a wall trying to make divide-and-conquer work for this. Should\\'ve considered an O(n^2) solution..\\n\\nWe want quadruplets in this arrangement\\n![image](https://assets.leetcode.com/users/images/c72c80df-c65d-425a-9f32-41690765e1bd_1675033503.1004598.png)\\n\\n\\nIt\\'s easy to find the A-B relationship in O(n^2)\\n*To find the A-B-C relationship*\\n- We have ```C``` at index ```i```\\n\\t- Iterate through all the nums ```j``` which come to the left of ```i```\\n\\t- Count up the nums that are smaller than ```nums[i]```, these are the ```A```s\\n\\t- When we reach a number that\\'s greater than ```nums[i]```\\n\\t\\t- We\\'ve already counted the numbers smaller than ```C```, and they\\'re all to the left of ```nums[j]```\\n\\t\\t- So we\\'ve found ```countSmaller``` number of ```A-B-C``` relationships\\n\\n![image](https://assets.leetcode.com/users/images/454f6fb6-cde0-4f8c-bfe8-5919789c5235_1675033560.8585966.png)\\n\\n- The tricky part here is that we can\\'t memoize the number of ```A-B-C``` relationships at index ```i```. If we did, when we try to find the ```C-D``` relationships we won\\'t know how many ```B```s are smaller than ```D```. So instead we\\'ll say that the number at index ```j``` is a ```B``` for ```countSmaller``` number of ```C```s. Then when we look at potential ```D```s, we know that when we see a ```B``` that\\'s smaller than us, all the ```C```s are also to the left of us. \\n\\n![image](https://assets.leetcode.com/users/images/03634837-c1a8-436e-88f0-a2df19e9224e_1675033621.1498117.png)\\n\\n\\n```javascript\\nvar countQuadruplets = function(nums) {\\n  const B = new Array(nums.length + 1).fill(0);\\n  let quadruplets = 0;\\n\\n  for (let i = 0; i < nums.length; i += 1) {\\n    let countSmaller = 0;\\n\\n    for (let j = 0; j < i; j += 1) {\\n      if (nums[j] < nums[i]) {\\n        countSmaller += 1;\\n        quadruplets += B[nums[j]];\\n      } else {\\n\\t    // countSmaller is all the As nums[j] is the B, nums[i] is C\\n\\t\\t// so nums[j] is apart of countSmaller A-B-C relationships with nums[i]\\n        B[nums[j]] += countSmaller;\\n      }\\n    }\\n  }\\n\\n  return quadruplets\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```C```\n```i```\n```j```\n```i```\n```nums[i]```\n```A```\n```nums[i]```\n```C```\n```nums[j]```\n```countSmaller```\n```A-B-C```\n```A-B-C```\n```i```\n```C-D```\n```B```\n```D```\n```j```\n```B```\n```countSmaller```\n```C```\n```D```\n```B```\n```C```\n```javascript\\nvar countQuadruplets = function(nums) {\\n  const B = new Array(nums.length + 1).fill(0);\\n  let quadruplets = 0;\\n\\n  for (let i = 0; i < nums.length; i += 1) {\\n    let countSmaller = 0;\\n\\n    for (let j = 0; j < i; j += 1) {\\n      if (nums[j] < nums[i]) {\\n        countSmaller += 1;\\n        quadruplets += B[nums[j]];\\n      } else {\\n\\t    // countSmaller is all the As nums[j] is the B, nums[i] is C\\n\\t\\t// so nums[j] is apart of countSmaller A-B-C relationships with nums[i]\\n        B[nums[j]] += countSmaller;\\n      }\\n    }\\n  }\\n\\n  return quadruplets\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3111930,
                "title": "dynamic-programming-o-n-2-c",
                "content": "# Intuition\\nFocus only on j and k. Precompute rest of the information required.\\n\\n# Approach\\nDynamic Programming\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(n^2)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> map(n+1);\\n        for (int i=0;i<n;i++) map[nums[i]]=i;\\n        vector<vector<int>> small(n, vector<int>(n+1)), large(n, vector<int>(n+1));\\n        for (int i=1;i<n;i++) {\\n            for (int j=2;j<=n;j++) small[i][j]=small[i][j-1]+(map[j-1]<i);\\n        }\\n        for (int i=n-2;i>=0;i--) {\\n            for (int j=n-1;j>0;j--) {\\n                large[i][j]=large[i][j+1]+(map[j+1]>i);\\n            }\\n        }\\n        long long cnt=0;\\n        for (int i=0;i<n;i++) {\\n            for (int j=i+1;j<n;j++) {\\n                if (nums[j]<nums[i]) {\\n                    cnt += small[i][nums[j]]*large[j][nums[i]];\\n                }\\n            }\\n        }\\n        return cnt;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> map(n+1);\\n        for (int i=0;i<n;i++) map[nums[i]]=i;\\n        vector<vector<int>> small(n, vector<int>(n+1)), large(n, vector<int>(n+1));\\n        for (int i=1;i<n;i++) {\\n            for (int j=2;j<=n;j++) small[i][j]=small[i][j-1]+(map[j-1]<i);\\n        }\\n        for (int i=n-2;i>=0;i--) {\\n            for (int j=n-1;j>0;j--) {\\n                large[i][j]=large[i][j+1]+(map[j+1]>i);\\n            }\\n        }\\n        long long cnt=0;\\n        for (int i=0;i<n;i++) {\\n            for (int j=i+1;j<n;j++) {\\n                if (nums[j]<nums[i]) {\\n                    cnt += small[i][nums[j]]*large[j][nums[i]];\\n                }\\n            }\\n        }\\n        return cnt;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111627,
                "title": "java-solution-with-detailed-explanation",
                "content": "Here we iterate using two nested loops. It is assumed that the outer loop is j, the inner loop could be k or l. In the inner loop we iterate from j + 1 to n.\\n\\nWhile iterating through the inner loop, Maintain a running sum of the number of I,j,k triplets that satisfies the condition in the question.\\n \\nIf we encounter a value that is less than nums[j], Assume that value is k, then count the number of elements less than nums[k] added to the binary index tree. Since we only add values in the binary index tree up to j, it is guaranteed that the number of elements in the binary index tree less than nums[k] gives the number of triplets that could be formed with j and k as the second and third element. This value could then be added to the running sum of the current iteration of j.\\n\\nOn the other hand, if we encounter a value in the inner loop such that nums[k] > nums[j], Assume k is l, then add the running sum to the result, we can justify this because nums[j] is the maximum value of the triplets I, j, k. So if we encounter nums[l] at a further index and nums[l] > nums[j], nums[l] could be appended to all the triplets to satisfy the quadruplets condition.\\n\\nAfter each outer loop iteration, add the value of nums[j] to the binary index tree to keep track of the i\\u2019s count in future iterations\\n\\nTime Complexity is O(n^2 log n)\\n\\nPlease upvote if you like the solution :)\\n\\n```\\nclass Solution {\\n    public long countQuadruplets(int[] nums) {\\n        \\n        int n = nums.length;\\n        \\n        BIT bit = new BIT(n);\\n        \\n        int val;\\n        long running;\\n        \\n        long result = 0;\\n        \\n        for (int j = 0; j < n; ++j) {\\n            running = 0;\\n            val = nums[j];\\n            for (int k = j + 1; k < n; ++k) {\\n                if (nums[k] == nums[j])\\n                    continue;\\n                else if (nums[k] > nums[j]){\\n                    result += running;\\n                }else {\\n                    running += bit.get(nums[k] - 1);\\n                }\\n            }\\n            \\n            bit.update(val, 1);\\n        }\\n        \\n        return result;\\n    }\\n}\\nclass BIT {\\n\\t\\t\\n    long [] arr;\\n\\n    BIT(int n){\\n        arr = new long [n + 1];\\n    }\\n\\n    void update (int idx, long val) {\\n\\n        for (int i = idx; i < arr.length; i += (i & -i)) {\\n            arr[i] += val;\\n        }\\n    }\\n\\n    long get(int idx) {\\n        long result = 0;\\n\\n        for (int i = idx; i > 0; i -= (i & -i)) {\\n            result += arr[i];\\n        }\\n\\n        return result;\\n    }\\n\\n    long query(int a, int b) {\\n        return get(b) - get(a - 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Indexed Tree"
                ],
                "code": "```\\nclass Solution {\\n    public long countQuadruplets(int[] nums) {\\n        \\n        int n = nums.length;\\n        \\n        BIT bit = new BIT(n);\\n        \\n        int val;\\n        long running;\\n        \\n        long result = 0;\\n        \\n        for (int j = 0; j < n; ++j) {\\n            running = 0;\\n            val = nums[j];\\n            for (int k = j + 1; k < n; ++k) {\\n                if (nums[k] == nums[j])\\n                    continue;\\n                else if (nums[k] > nums[j]){\\n                    result += running;\\n                }else {\\n                    running += bit.get(nums[k] - 1);\\n                }\\n            }\\n            \\n            bit.update(val, 1);\\n        }\\n        \\n        return result;\\n    }\\n}\\nclass BIT {\\n\\t\\t\\n    long [] arr;\\n\\n    BIT(int n){\\n        arr = new long [n + 1];\\n    }\\n\\n    void update (int idx, long val) {\\n\\n        for (int i = idx; i < arr.length; i += (i & -i)) {\\n            arr[i] += val;\\n        }\\n    }\\n\\n    long get(int idx) {\\n        long result = 0;\\n\\n        for (int i = idx; i > 0; i -= (i & -i)) {\\n            result += arr[i];\\n        }\\n\\n        return result;\\n    }\\n\\n    long query(int a, int b) {\\n        return get(b) - get(a - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3113280,
                "title": "c-counting-o-n-2-14-lines-explanation",
                "content": "# Clear Code (14 lines)\\n```C++\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> M=vector<vector<int>>(n,vector<int>(n,0)),&L=M,&R=M;\\n        for(int j=2;j<n-1;j++) //O(N^2) calculate prefix sum of count for L\\n            for(int h =0;h<j-1;h++) \\n                L[j][h] =  (h-1<0?0:L[j][h-1]) + (nums[h]<nums[j]);\\n        for(int i=1;i<n-2;i++) ////O(N^2) calculate suffix sum of count for R\\n            for(int k=n-1;k>i+1;k--)\\n                R[i][k] = (k+1>=n?0:R[i][k+1]) + (nums[k]>nums[i]);\\n        long long ans = 0;\\n        for(int i=1;i<n-2;i++) \\n            for(int j=i+1;j<n-1;j++) \\n                if(nums[i]>nums[j]) \\n                    ans += (long long)L[j][i-1]*(long long)R[i][j+1];\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n# Explanation\\n```\\nThe condition of quadruplets we need to satisfy is. \\n0 <= h<i<j<k < n\\nnums[h]<nums[j]<nums[i]<nums[k]\\n```\\nThe key point is we can find all pairs i<j (i,j) s.t. nums[i]>nums[j] by a 2-level loop first.\\nIt takes O(N^2). For each specific (i,j).\\n\\nWe can  do counting of nums[h] (left part) that can satisfy the condition and how many \\nnums[k] (right part) can satisfy the condition.\\n\\nFor example, for the specific pair (i,j), if we find out the left part counts as 10 and the right \\npart counts as 15. Then the pair(i,j) contributes 10 * 15 for the final solution. \\n\\nFor the reason to save time, we make prefix sum for the left part counting by 2-level loop \\nand make suffix sum for the right part counting by the 2-level loop.\\n\\nThe following code, which is the same logic as the above clear code,  \\nshows the detail and observation.\\n\\n\\n```C++\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    long long countQuadruplets(vector<int>& nums) {\\n        /*\\n        Observation. \\n        \\n        0<= h<i<j<k <n\\n        nums[h]<nums[j]<nums[i]<nums[k]\\n        \\n        That\\'s we can find all pair i<j (i,j) s.t. nums[i]>nums[j] by O(N^2) first \\n        by the 2-level loop. \\n        \\n        After we find out nums[i]>nums[j]...\\n        We need find the elements e_h in nums[0 .. i-1] s.t. e_h < nums[j] ...(1) \\n        We need find the elements e_k in nums[j+1..n-1] s.t. e_k > nums[i] ...(2)\\n\\n        For case (1) --we calculate Left part prefix sum of count\\n        For case (2) --we calculate Right part suffix sum of count\\n\\n        This observation is contributed by ZZZ, \\u54CE\\u5440\\u5440 in \\n        LeetCode Contest After Party (https://www.facebook.com/IM.LeetCoder/)\\n        */\\n        int n = nums.size();\\n        //vector<vector<int>> cnt = vector<vector<int>>(n, vector<int>(n,0));\\n        //vector<vector<int>> &h_cnt = cnt, &k_cnt=cnt;\\n        vector<vector<int>> h_cnt = vector<vector<int>>(n, vector<int>(n,0)); //Left part prefix sum of count\\n        vector<vector<int>> r_cnt = vector<vector<int>>(n, vector<int>(n,0)); //Right part suffix sum of count\\n        \\n        for(int j=2;j<n-1;j++){\\n            int max_i = j-1;\\n            for(int h =0;h<max_i;h++) {\\n                int h_cnt_minus = h-1<0?0:h_cnt[j][h-1];\\n                h_cnt[j][h] =  h_cnt_minus + (nums[h]<nums[j]);\\n            }\\n        }\\n\\n        for(int i=1;i<n-2;i++) {\\n            int min_j = i+1;\\n            for(int k=n-1;k>min_j;k--){\\n                int k_cnt_plus = k+1>=n?0:k_cnt[i][k+1];\\n                k_cnt[i][k] = k_cnt_plus + (nums[k]>nums[i]);\\n            }\\n        }\\n        ll ans = 0;\\n        for(int i=1;i<n-2;i++) {\\n            for(int j=i+1;j<n-1;j++) {\\n                if(nums[i]>nums[j]) {\\n                    ans += (ll)h_cnt[j][i-1]*(ll)k_cnt[i][j+1];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> M=vector<vector<int>>(n,vector<int>(n,0)),&L=M,&R=M;\\n        for(int j=2;j<n-1;j++) //O(N^2) calculate prefix sum of count for L\\n            for(int h =0;h<j-1;h++) \\n                L[j][h] =  (h-1<0?0:L[j][h-1]) + (nums[h]<nums[j]);\\n        for(int i=1;i<n-2;i++) ////O(N^2) calculate suffix sum of count for R\\n            for(int k=n-1;k>i+1;k--)\\n                R[i][k] = (k+1>=n?0:R[i][k+1]) + (nums[k]>nums[i]);\\n        long long ans = 0;\\n        for(int i=1;i<n-2;i++) \\n            for(int j=i+1;j<n-1;j++) \\n                if(nums[i]>nums[j]) \\n                    ans += (long long)L[j][i-1]*(long long)R[i][j+1];\\n        return ans;\\n    }\\n};\\n```\n```\\nThe condition of quadruplets we need to satisfy is. \\n0 <= h<i<j<k < n\\nnums[h]<nums[j]<nums[i]<nums[k]\\n```\n```C++\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    long long countQuadruplets(vector<int>& nums) {\\n        /*\\n        Observation. \\n        \\n        0<= h<i<j<k <n\\n        nums[h]<nums[j]<nums[i]<nums[k]\\n        \\n        That\\'s we can find all pair i<j (i,j) s.t. nums[i]>nums[j] by O(N^2) first \\n        by the 2-level loop. \\n        \\n        After we find out nums[i]>nums[j]...\\n        We need find the elements e_h in nums[0 .. i-1] s.t. e_h < nums[j] ...(1) \\n        We need find the elements e_k in nums[j+1..n-1] s.t. e_k > nums[i] ...(2)\\n\\n        For case (1) --we calculate Left part prefix sum of count\\n        For case (2) --we calculate Right part suffix sum of count\\n\\n        This observation is contributed by ZZZ, \\u54CE\\u5440\\u5440 in \\n        LeetCode Contest After Party (https://www.facebook.com/IM.LeetCoder/)\\n        */\\n        int n = nums.size();\\n        //vector<vector<int>> cnt = vector<vector<int>>(n, vector<int>(n,0));\\n        //vector<vector<int>> &h_cnt = cnt, &k_cnt=cnt;\\n        vector<vector<int>> h_cnt = vector<vector<int>>(n, vector<int>(n,0)); //Left part prefix sum of count\\n        vector<vector<int>> r_cnt = vector<vector<int>>(n, vector<int>(n,0)); //Right part suffix sum of count\\n        \\n        for(int j=2;j<n-1;j++){\\n            int max_i = j-1;\\n            for(int h =0;h<max_i;h++) {\\n                int h_cnt_minus = h-1<0?0:h_cnt[j][h-1];\\n                h_cnt[j][h] =  h_cnt_minus + (nums[h]<nums[j]);\\n            }\\n        }\\n\\n        for(int i=1;i<n-2;i++) {\\n            int min_j = i+1;\\n            for(int k=n-1;k>min_j;k--){\\n                int k_cnt_plus = k+1>=n?0:k_cnt[i][k+1];\\n                k_cnt[i][k] = k_cnt_plus + (nums[k]>nums[i]);\\n            }\\n        }\\n        ll ans = 0;\\n        for(int i=1;i<n-2;i++) {\\n            for(int j=i+1;j<n-1;j++) {\\n                if(nums[i]>nums[j]) {\\n                    ans += (ll)h_cnt[j][i-1]*(ll)k_cnt[i][j+1];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3122535,
                "title": "c-2d-prefix-sum-o-n-2",
                "content": "## Approach:\\n1. For a Quadruplets (i,j,k,l), we want `nums[i] < nums[k] < nums[j] < nums[l]`. We can iterate for all (j,k) pair where `nums[k] < nums[j]`.\\n1. For a pair (j,k), we want no. of elements (say **X**) from 0 to j-1 which are smaller than `num[k]` and no. of elements (say **Y**) from k+1 to n-1 which are larger than `num[j]`.\\n1. So, no. of Quadruplets with pair (j,k) = product of **X** and **Y**. \\n1. We can maintain 2D prefix and suffix array to find value of **X** and **Y**\\n```\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> pre(n+1,vector<int>(n+1,0));\\n        vector<vector<int>> suff(n+1,vector<int>(n+1,0));\\n        for(int i = 0; i<n-1; i++){\\n            for(int j = n-1; j>i;--j){\\n                suff[i][j] = suff[i][j+1];\\n                if(j+1<n && nums[j+1]>nums[i]) suff[i][j]++;\\n            }\\n        }\\n        for(int i = 1; i<n-1; i++){\\n            for(int j = 0; j<i;++j){\\n                if(j-1>=0) pre[i][j] = pre[i][j-1];\\n                if(j-1>=0 && nums[j-1]<nums[i]) pre[i][j]++;\\n            }\\n        }\\n        long long re = 0;\\n        for(int i = 0; i<n;++i){\\n            for(int j = i+1; j<n;++j){\\n                if(nums[i]>nums[j]){\\n                    re+= (long long)pre[j][i]*suff[i][j];\\n                }\\n            }\\n        }\\n        return re;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> pre(n+1,vector<int>(n+1,0));\\n        vector<vector<int>> suff(n+1,vector<int>(n+1,0));\\n        for(int i = 0; i<n-1; i++){\\n            for(int j = n-1; j>i;--j){\\n                suff[i][j] = suff[i][j+1];\\n                if(j+1<n && nums[j+1]>nums[i]) suff[i][j]++;\\n            }\\n        }\\n        for(int i = 1; i<n-1; i++){\\n            for(int j = 0; j<i;++j){\\n                if(j-1>=0) pre[i][j] = pre[i][j-1];\\n                if(j-1>=0 && nums[j-1]<nums[i]) pre[i][j]++;\\n            }\\n        }\\n        long long re = 0;\\n        for(int i = 0; i<n;++i){\\n            for(int j = i+1; j<n;++j){\\n                if(nums[i]>nums[j]){\\n                    re+= (long long)pre[j][i]*suff[i][j];\\n                }\\n            }\\n        }\\n        return re;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111998,
                "title": "c-easy-o-n-2-direct-do-what-given-in-problem",
                "content": "# Intuition\\nLoop on j and k and find what is needed to calculate rest according to given inequality.\\n\\n# Approach\\nDo some precalculation on prefixes and suffixes. ( Easy! ) \\nSee code : self explainatory.\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& a) {\\n        //loop on j and k\\n        int n = a.size();\\n        for (auto &x : a) {\\n            x--;\\n        }\\n        vector <vector<int>> pre_less(n, vector<int>(n, 0));\\n        vector <vector<int>> suff_greater(n, vector<int>(n, 0));\\n\\n        for (int j = 0; j < n; ++j) {\\n            for (int i = 0; i < n; ++i) {\\n                if (a[i] < j) pre_less[i][j]++;\\n                if (i) pre_less[i][j] += pre_less[i - 1][j];\\n            }\\n        }\\n\\n        for (int j = 0; j < n; ++j) {\\n            for (int i = n - 1; i >= 0; --i) {\\n                if (a[i] > j) suff_greater[i][j]++;\\n                if (i != n - 1) suff_greater[i][j] += suff_greater[i + 1][j];\\n            }\\n        }\\n\\n        long long res = 0;\\n\\n        for (int j = 1; j < n - 2; ++j) {\\n            for (int k = j + 1; k < n - 1; ++k) {\\n                if (a[k] > a[j]) continue;\\n                res += 1LL * pre_less[j - 1][a[k]] * suff_greater[k + 1][a[j]];\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& a) {\\n        //loop on j and k\\n        int n = a.size();\\n        for (auto &x : a) {\\n            x--;\\n        }\\n        vector <vector<int>> pre_less(n, vector<int>(n, 0));\\n        vector <vector<int>> suff_greater(n, vector<int>(n, 0));\\n\\n        for (int j = 0; j < n; ++j) {\\n            for (int i = 0; i < n; ++i) {\\n                if (a[i] < j) pre_less[i][j]++;\\n                if (i) pre_less[i][j] += pre_less[i - 1][j];\\n            }\\n        }\\n\\n        for (int j = 0; j < n; ++j) {\\n            for (int i = n - 1; i >= 0; --i) {\\n                if (a[i] > j) suff_greater[i][j]++;\\n                if (i != n - 1) suff_greater[i][j] += suff_greater[i + 1][j];\\n            }\\n        }\\n\\n        long long res = 0;\\n\\n        for (int j = 1; j < n - 2; ++j) {\\n            for (int k = j + 1; k < n - 1; ++k) {\\n                if (a[k] > a[j]) continue;\\n                res += 1LL * pre_less[j - 1][a[k]] * suff_greater[k + 1][a[j]];\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111708,
                "title": "java-fenwick-tree",
                "content": "# Intuition\\nFixed j and k, and find i and L using Fenwick tree.\\n\\n\\n# Complexity\\n- Time complexity: O(N * N * log(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long countQuadruplets(int[] nums) {\\n        \\n        int n = nums.length;\\n        \\n        \\n        Fenwick t1 = new Fenwick(new int[n + 1]);\\n        Fenwick t2 = new Fenwick(new int[n + 1]);\\n        long ans = 0;\\n        \\n        for(int i=1;i<=n;i++) t2.update(i,1);\\n        \\n        for(int j = 0 ; j < n ; j++) {\\n            \\n            t2.update(nums[j], -1);\\n            \\n            for(int k = j + 1 ; k < n ; k++) {\\n                \\n                t2.update(nums[k],-1);\\n                \\n                if(nums[j] > nums[k]) {\\n                    \\n                    long c1 = t1.query(1, nums[k]);\\n                    long c2 = t2.query(nums[j], n);\\n                    \\n                    ans += (c1 * c2);\\n                }\\n            }\\n            \\n            for(int k = j + 1 ; k < n ; k ++) t2.update(nums[k], 1);\\n            \\n            t1.update(nums[j],1);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\nclass Fenwick {\\n\\n    long[] bit;\\n \\n    public Fenwick(int arr[]) {\\n        \\n        // arr has to be in 1-based indexing\\n\\t\\tbit = new long[arr.length]; \\n \\n        for(int i = 1 ; i < arr.length ; i++) {\\n\\n\\t\\t\\tupdate(i, arr[i]);\\n\\t\\t}\\n    }\\n \\n    public long sum(int index) {\\n        \\n\\t\\tlong sum = 0;\\n\\n\\t\\twhile(index > 0) {\\n\\n\\t\\t\\tsum += bit[index];\\n\\t\\t\\tindex = index - (index & -index);\\n\\t\\t}\\n\\n\\t\\treturn sum;\\n    }\\n\\n\\tpublic long query(int l,int r) {\\n\\n\\t\\tr = Math.min(r, bit.length - 1);\\n        \\tl = Math.max(l, 1);\\n\\n\\t\\treturn sum(r) - sum(l - 1);\\n\\n\\t}\\n\\n    public void update(int index, int val) {\\n\\n\\t\\twhile(index < bit.length) {\\n\\n\\t\\t\\tbit[index] += val;\\n\\t\\t\\tindex = index + (index & -index);\\n\\t\\t}\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Indexed Tree"
                ],
                "code": "```\\nclass Solution {\\n    public long countQuadruplets(int[] nums) {\\n        \\n        int n = nums.length;\\n        \\n        \\n        Fenwick t1 = new Fenwick(new int[n + 1]);\\n        Fenwick t2 = new Fenwick(new int[n + 1]);\\n        long ans = 0;\\n        \\n        for(int i=1;i<=n;i++) t2.update(i,1);\\n        \\n        for(int j = 0 ; j < n ; j++) {\\n            \\n            t2.update(nums[j], -1);\\n            \\n            for(int k = j + 1 ; k < n ; k++) {\\n                \\n                t2.update(nums[k],-1);\\n                \\n                if(nums[j] > nums[k]) {\\n                    \\n                    long c1 = t1.query(1, nums[k]);\\n                    long c2 = t2.query(nums[j], n);\\n                    \\n                    ans += (c1 * c2);\\n                }\\n            }\\n            \\n            for(int k = j + 1 ; k < n ; k ++) t2.update(nums[k], 1);\\n            \\n            t1.update(nums[j],1);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\nclass Fenwick {\\n\\n    long[] bit;\\n \\n    public Fenwick(int arr[]) {\\n        \\n        // arr has to be in 1-based indexing\\n\\t\\tbit = new long[arr.length]; \\n \\n        for(int i = 1 ; i < arr.length ; i++) {\\n\\n\\t\\t\\tupdate(i, arr[i]);\\n\\t\\t}\\n    }\\n \\n    public long sum(int index) {\\n        \\n\\t\\tlong sum = 0;\\n\\n\\t\\twhile(index > 0) {\\n\\n\\t\\t\\tsum += bit[index];\\n\\t\\t\\tindex = index - (index & -index);\\n\\t\\t}\\n\\n\\t\\treturn sum;\\n    }\\n\\n\\tpublic long query(int l,int r) {\\n\\n\\t\\tr = Math.min(r, bit.length - 1);\\n        \\tl = Math.max(l, 1);\\n\\n\\t\\treturn sum(r) - sum(l - 1);\\n\\n\\t}\\n\\n    public void update(int index, int val) {\\n\\n\\t\\twhile(index < bit.length) {\\n\\n\\t\\t\\tbit[index] += val;\\n\\t\\t\\tindex = index + (index & -index);\\n\\t\\t}\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111612,
                "title": "2d-prefix-to-get-minimum-and-maximum-in-range-with-an-explanation-of-the-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nfirst thing loop over all numbers and put 1 in index j if(nums[i]>nums[j]) in preGra , in preLess put 1 in index j if(nums[i]<nums[j])\\nand make prefix sum in the array \\nafter make that to all numbers \\nloop (n^2)\\nif(nums[j]<nums[i]) then find number of elements less than nums[j] in range 0 to i and find number of elements grater than nums[i] in range j to n-1\\nthen muliply them and add them too answer\\nI\\'ts to easy to do that without and compelx data structure\\nand we can remove preLess or preGra and use one of them only\\n\\nThank you for viewing the solution, and excuse me if I made a mistake in writing because I am not very good at writing in English.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n         public long countQuadruplets(int[] nums) {\\n        int preGra[][] = new int[nums.length][nums.length];\\n        int preLess[][] = new int[nums.length][nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = 0; j < nums.length; j++) {\\n                if (nums[j] > nums[i]) {\\n                    preGra[i][j]++;\\n                }\\n                if (nums[j] < nums[i]) {\\n                    preLess[i][j]++;\\n                }\\n            }\\n            for (int j = 1; j < nums.length; j++) {\\n                preGra[i][j] += preGra[i][j - 1];\\n                preLess[i][j] += preLess[i][j - 1];\\n            }\\n        }\\n        long res = 0;\\n        for (int i = 1; i < nums.length; i++) {\\n            for (int j = i + 1; j < nums.length - 1; j++) {\\n                if (nums[j] < nums[i]) {\\n                    long v = preLess[j][i];\\n                    v *= (long) preGra[i][nums.length - 1] - preGra[i][j];\\n                    res += v;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n         public long countQuadruplets(int[] nums) {\\n        int preGra[][] = new int[nums.length][nums.length];\\n        int preLess[][] = new int[nums.length][nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = 0; j < nums.length; j++) {\\n                if (nums[j] > nums[i]) {\\n                    preGra[i][j]++;\\n                }\\n                if (nums[j] < nums[i]) {\\n                    preLess[i][j]++;\\n                }\\n            }\\n            for (int j = 1; j < nums.length; j++) {\\n                preGra[i][j] += preGra[i][j - 1];\\n                preLess[i][j] += preLess[i][j - 1];\\n            }\\n        }\\n        long res = 0;\\n        for (int i = 1; i < nums.length; i++) {\\n            for (int j = i + 1; j < nums.length - 1; j++) {\\n                if (nums[j] < nums[i]) {\\n                    long v = preLess[j][i];\\n                    v *= (long) preGra[i][nums.length - 1] - preGra[i][j];\\n                    res += v;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3114072,
                "title": "full-explanation-intutution-and-approach-c-easy",
                "content": "Yes, The Question Looks easy but you need some observation and you are done.\\n1.  First look at the constraints you can use $$O(N*N)$$\\n2.  All the elements will be in range 1 to N\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSo we need four numbers and they should be in Order \\nindexes - > i < j < k < l < n\\nvalues - > nums[i] < nums[k] < nums[j] < nums[l]\\n\\nSo we can use two for loops(n*n ) \\nWe will follow these steps \\n 1. fix two indexes j  and k , that is for every possible j and k\\n 2. Find out number of i and l \\n 3. multilply count(l)*count(i)\\n 4. add in the ans\\n\\n# Approach\\nWe can use prefix sum to find the count of possible i\\'s count and l\\'s count\\nHere we will use the observation 2\\nSo while precomputing we will store all the numbers from 1 to n which are less than nums[i] and are in left of i and which are greater than nums[i] and are in right of i.\\nThat\\'s why I have created two 2d vectors right and left\\nJust see the code now you\\'ll get it\\n**I know the concept is Messy But I tried My best to explain \\nPlease Do Upvote :)**\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N*N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N*N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& nums) {\\n        int n =  nums.size() ;\\n        vector<vector<int>>left(n+1,vector<int>(n+1,0));\\n        vector<vector<int>>right(n+1,vector<int>(n+1,0));\\n        \\n        for(int i = 0 ; i < nums.size() ; ++i){\\n            for(int no = 1 ; no<=n ; ++no){\\n                if(nums[i]<no){\\n                    left[i][no]++;\\n                }\\n                if(i!=0){\\n                    left[i][no]+=left[i-1][no];\\n                }\\n            }\\n        }\\n        \\n        for(int i = nums.size()-1; i>=0; --i){\\n            for(int no = 1 ; no<=n ; ++no){\\n                if(nums[i]>no){\\n                    right[i][no]++;\\n                }\\n                if(i!=nums.size()-1){\\n                   right[i][no]+=right[i+1][no];\\n                }\\n            }\\n        }\\n        long long ans = 0 ;\\n        long long left_count = 0 ; \\n        long long right_count = 0 ; \\n        for(int j =1 ;j < nums.size()-2 ; ++j){\\n            for(int k = nums.size()-2 ; k >j ; --k){\\n                if(nums[k]<nums[j]){\\n                     left_count = left[j][nums[k]];\\n                     right_count = right[k][nums[j]] ;\\n                    ans+=left_count*right_count; \\n                }\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& nums) {\\n        int n =  nums.size() ;\\n        vector<vector<int>>left(n+1,vector<int>(n+1,0));\\n        vector<vector<int>>right(n+1,vector<int>(n+1,0));\\n        \\n        for(int i = 0 ; i < nums.size() ; ++i){\\n            for(int no = 1 ; no<=n ; ++no){\\n                if(nums[i]<no){\\n                    left[i][no]++;\\n                }\\n                if(i!=0){\\n                    left[i][no]+=left[i-1][no];\\n                }\\n            }\\n        }\\n        \\n        for(int i = nums.size()-1; i>=0; --i){\\n            for(int no = 1 ; no<=n ; ++no){\\n                if(nums[i]>no){\\n                    right[i][no]++;\\n                }\\n                if(i!=nums.size()-1){\\n                   right[i][no]+=right[i+1][no];\\n                }\\n            }\\n        }\\n        long long ans = 0 ;\\n        long long left_count = 0 ; \\n        long long right_count = 0 ; \\n        for(int j =1 ;j < nums.size()-2 ; ++j){\\n            for(int k = nums.size()-2 ; k >j ; --k){\\n                if(nums[k]<nums[j]){\\n                     left_count = left[j][nums[k]];\\n                     right_count = right[k][nums[j]] ;\\n                    ans+=left_count*right_count; \\n                }\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3113941,
                "title": "swift-solution-with-explanation",
                "content": "# Explanation\\nWe can use a dp array to store the number of quadruplets that can be formed with the first i elements and the last element is smaller than the second element. Then we can iterate through the array and for each element, we can count the number of elements that are smaller than it and add it to the answer. We can also update the dp array for the next iteration.\\n\\n# Working\\n1. Create a dp array of size n, and initialize it to all 0\\'s, like this: var dp = [Int](repeating: 0, count: n)\\n2. Create a variable called ans and initialize it to 0. This will be the final answer and return value of the function.\\n3. Create a nested for loop. The outer loop will iterate from 0 to n-1 (j). The inner loop will iterate from 0 to j-1 (i).\\n4. Create a variable called previousSmaller and initialize it to 0.\\n5. If the number at index j is greater than the number at index i, then increment previousSmaller by 1 and add dp[i] to ans.\\n6. If the number at index j is less than the number at index i, then add previousSmaller to dp[i].\\n7. Return ans.\\n\\n# Complexity\\n> Time complexity: O(n^2)\\n> Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution \\n{\\n    func countQuadruplets(_ nums: [Int]) -> Int \\n    {\\n        var n = nums.count\\n        var dp = [Int](repeating: 0, count: n)\\n        var ans = 0\\n        \\n        for j in 0..<n \\n        {\\n            var previousSmaller = 0\\n            \\n            for i in 0..<j \\n            {\\n                if nums[j] > nums[i] \\n                {\\n                    previousSmaller += 1\\n                    ans += dp[i]\\n                } \\n                else if nums[j] < nums[i] \\n                {\\n                    dp[i] += previousSmaller\\n                }\\n            }\\n        }\\n        \\n        return ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution \\n{\\n    func countQuadruplets(_ nums: [Int]) -> Int \\n    {\\n        var n = nums.count\\n        var dp = [Int](repeating: 0, count: n)\\n        var ans = 0\\n        \\n        for j in 0..<n \\n        {\\n            var previousSmaller = 0\\n            \\n            for i in 0..<j \\n            {\\n                if nums[j] > nums[i] \\n                {\\n                    previousSmaller += 1\\n                    ans += dp[i]\\n                } \\n                else if nums[j] < nums[i] \\n                {\\n                    dp[i] += previousSmaller\\n                }\\n            }\\n        }\\n        \\n        return ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111792,
                "title": "c-o-n-2-log-n-with-fenwick-trees",
                "content": "# Intuition\\nIterate through each pair of j and k and using a fenwick tree find all on the left from j that is less than nums[k] and all on the right of k that is more than nums[j] and multiply them and add them to result.\\n\\n# Complexity\\n- Time complexity:\\nO(n^2 * log(n))\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nstruct FT {\\n    int size;\\n    vector<int>tree;\\n    FT(int size) : size(size) {\\n        tree.resize(size + 1);\\n    }\\n    int lsb(int n) {\\n        return n & -n;\\n    }\\n    void add(int i, int val) {\\n        i = max(i + 1, 1);\\n        while (i <= size) {\\n            tree[i] += val;\\n            i += lsb(i);\\n        }\\n    }\\n    int getSum(int i) {\\n        i = min(i + 1, size);\\n        int res = 0;\\n        while (i) {\\n            res += tree[i];\\n            i -= lsb(i);\\n        }\\n        return res;\\n    }\\n};\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& nums) {\\n        FT left(nums.size() + 1), right(nums.size() + 1);\\n        long long res = 0;\\n        for (int i = 0; i < nums.size(); i++) right.add(nums[i], 1);\\n        for (int k = 0; k < nums.size(); k++) {\\n            right.add(nums[k], -1);\\n            for (int j = 0; j < k; j++) {\\n                left.add(nums[j], 1);\\n                if (nums[j] < nums[k]) continue;\\n                res += (long long) (right.getSum(nums.size()) - right.getSum(nums[j])) * left.getSum(nums[k] - 1);\\n            }\\n            for (int j = 0; j < k; j++) left.add(nums[j], -1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct FT {\\n    int size;\\n    vector<int>tree;\\n    FT(int size) : size(size) {\\n        tree.resize(size + 1);\\n    }\\n    int lsb(int n) {\\n        return n & -n;\\n    }\\n    void add(int i, int val) {\\n        i = max(i + 1, 1);\\n        while (i <= size) {\\n            tree[i] += val;\\n            i += lsb(i);\\n        }\\n    }\\n    int getSum(int i) {\\n        i = min(i + 1, size);\\n        int res = 0;\\n        while (i) {\\n            res += tree[i];\\n            i -= lsb(i);\\n        }\\n        return res;\\n    }\\n};\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& nums) {\\n        FT left(nums.size() + 1), right(nums.size() + 1);\\n        long long res = 0;\\n        for (int i = 0; i < nums.size(); i++) right.add(nums[i], 1);\\n        for (int k = 0; k < nums.size(); k++) {\\n            right.add(nums[k], -1);\\n            for (int j = 0; j < k; j++) {\\n                left.add(nums[j], 1);\\n                if (nums[j] < nums[k]) continue;\\n                res += (long long) (right.getSum(nums.size()) - right.getSum(nums[j])) * left.getSum(nums[k] - 1);\\n            }\\n            for (int j = 0; j < k; j++) left.add(nums[j], -1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111614,
                "title": "naive-o-n-2-logn-solution-python",
                "content": "the idea similar to 132 pattern\\n\\nbut now we have 1324 words\\nwe keep the 3 as middle \\n- first get the distribution of left hand side -> smaller\\n- then check right hand side:\\n    - if bigger than 3 -> might be 4\\n    - if smaller than 3 -> count into 2\\n\\n\\n```\\nclass Solution:\\n    # Time: O(n^2 * logn)\\n    # Space: O(n)\\n    def countQuadruplets(self, nums: List[int]) -> int:\\n        # dp\\n        dp = [0] * len(nums)\\n        \\n        ans = 0\\n        for idx in range(1, len(nums)-1):\\n            num = nums[idx]\\n            # forward, get small distribution\\n            smaller = []\\n            for j in range(idx):\\n                if num > nums[j]:\\n                    smaller.append(nums[j])\\n            if not smaller:\\n                continue\\n            smaller = sorted(smaller)\\n\\n            # backward\\n            bigger = []\\n            for j in range(idx+1, len(nums)):\\n                # O(logn)\\n                if num > nums[j]:\\n                    dp[idx] += bisect_left(smaller, nums[j])\\n                        \\n                elif num < nums[j]:\\n                    ans += dp[idx]\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    # Time: O(n^2 * logn)\\n    # Space: O(n)\\n    def countQuadruplets(self, nums: List[int]) -> int:\\n        # dp\\n        dp = [0] * len(nums)\\n        \\n        ans = 0\\n        for idx in range(1, len(nums)-1):\\n            num = nums[idx]\\n            # forward, get small distribution\\n            smaller = []\\n            for j in range(idx):\\n                if num > nums[j]:\\n                    smaller.append(nums[j])\\n            if not smaller:\\n                continue\\n            smaller = sorted(smaller)\\n\\n            # backward\\n            bigger = []\\n            for j in range(idx+1, len(nums)):\\n                # O(logn)\\n                if num > nums[j]:\\n                    dp[idx] += bisect_left(smaller, nums[j])\\n                        \\n                elif num < nums[j]:\\n                    ans += dp[idx]\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3970634,
                "title": "c-short-and-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nMaintain a prefix array for every index i which tells us the number of elements upto index j < i which are less than a[i].\\nNow we have to iterate for the j given in the problem and use another for loop to find k and l. we can just store the count of a[l] > a[j]...Check the code you will understand what i am doing.\\n\\n# Complexity\\n- Time complexity:\\nO(n*n)\\n\\n- Space complexity:\\nO(n*n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& a) {\\n        int n = a.size();\\n        vector<vector<int>> vi(n + 1);\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            vector<int> pr(i + 1);\\n            pr[0] = 0;\\n            for(int j = 0; j < i; j++)\\n            {\\n               pr[j + 1] = pr[j] + (a[j] < a[i]);\\n            }\\n            vi[a[i]] = pr;\\n        }\\n        \\n        long long int ans = 0;\\n        for(int i = 1; i < n - 1; i++)//i corresponds to j of the problem\\n        {\\n            int cnt = 0 , cur = 0;\\n            for(int j = n - 1; j > i; j--)\\n            {\\n                if(a[j] > a[i])\\n                {\\n                    cnt++;\\n                }\\n                else\\n                {\\n                    int sz =  vi[a[j]][i];\\n                    cur += (sz) * cnt;\\n                }\\n            }\\n            ans += cur;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& a) {\\n        int n = a.size();\\n        vector<vector<int>> vi(n + 1);\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            vector<int> pr(i + 1);\\n            pr[0] = 0;\\n            for(int j = 0; j < i; j++)\\n            {\\n               pr[j + 1] = pr[j] + (a[j] < a[i]);\\n            }\\n            vi[a[i]] = pr;\\n        }\\n        \\n        long long int ans = 0;\\n        for(int i = 1; i < n - 1; i++)//i corresponds to j of the problem\\n        {\\n            int cnt = 0 , cur = 0;\\n            for(int j = n - 1; j > i; j--)\\n            {\\n                if(a[j] > a[i])\\n                {\\n                    cnt++;\\n                }\\n                else\\n                {\\n                    int sz =  vi[a[j]][i];\\n                    cur += (sz) * cnt;\\n                }\\n            }\\n            ans += cur;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3961497,
                "title": "2552-count-increasing-quadruplets",
                "content": "```\\nclass Solution {\\n public:\\n  long long countQuadruplets(vector<int>& nums) {\\n    long long ans = 0;\\n    // dp[j] := # of triplets (i, j, k) where i < j < k and nums[i] < nums[k] <\\n    // nums[j]. Keep this information for l to use later.\\n    vector<int> dp(nums.size());\\n\\n    // k can be treated as l.\\n    for (int k = 2; k < nums.size(); ++k)\\n      // j can be treated as i.\\n      for (int j = 0, numLessThanK = 0; j < k; ++j)\\n        if (nums[j] < nums[k]) {\\n          ++numLessThanK;  // nums[i] < nums[k]\\n          ans += dp[j];    // nums[j] < nums[l], so we should add dp[j] since we\\n                           // find a new quadruplets for (i, j, k, l).\\n        } else if (nums[j] > nums[k]) {\\n          dp[j] += numLessThanK;\\n        }\\n\\n    return ans;\\n  }\\n};\\n",
                "solutionTags": [
                    "Array",
                    "Dynamic Programming",
                    "Binary Indexed Tree",
                    "Enumeration",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\n public:\\n  long long countQuadruplets(vector<int>& nums) {\\n    long long ans = 0;\\n    // dp[j] := # of triplets (i, j, k) where i < j < k and nums[i] < nums[k] <\\n    // nums[j]. Keep this information for l to use later.\\n    vector<int> dp(nums.size());\\n\\n    // k can be treated as l.\\n    for (int k = 2; k < nums.size(); ++k)\\n      // j can be treated as i.\\n      for (int j = 0, numLessThanK = 0; j < k; ++j)\\n        if (nums[j] < nums[k]) {\\n          ++numLessThanK;  // nums[i] < nums[k]\\n          ans += dp[j];    // nums[j] < nums[l], so we should add dp[j] since we\\n                           // find a new quadruplets for (i, j, k, l).\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3909987,
                "title": "c-o-n-2-hacky-100ms-solution",
                "content": "For each `(j, k)` pair with `nums[j] > nums[k]`, we want to count the number of indices `i < j` where `nums[i] < nums[k]` and `l > k` where `nums[l] > nums[j]`.\\nMultiplying these two counts will give us the number of quadruplets for each pair.\\n\\nWe will keep an `i` counter for each potential value of `nums[k]`. That is, `icount[val]` will be the number of indices `i < j` where `nums[i] < val`.\\nNotice when `j = 0`, all these counters are zero.\\nAs `j` increases, we need to update these counters by incrementing all `icount[val]` where `val > nums[j]`.\\nNow, for the `l` counter, we already know that we\\'re comparing against `nums[j]`, so we only need one counter `lcount`.\\nNotice when `k = n`, this counter is zero.\\nThis suggests that our inner `k` loop should iterate backwards from `n`.\\nThen, as `k` decreases, we need to increment `lcount` if `nums[j] > nums[k]`.\\n\\nThis gives us our starting point:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& nums) {\\n        int n = nums.size();\\n        std::vector<int16_t> icount(n + 1);\\n        int64_t ret = 0;\\n        for (int j = 0; j < n; ++j) {\\n            int lcount = 0;\\n            for (int k = n; --k > j; ) {\\n                if (nums[j] > nums[k]) {\\n                    ret += icount[nums[k]] * lcount;\\n                } else {\\n\\t\\t\\t\\t\\t++lcount;\\n\\t\\t\\t\\t}\\n            }\\n            for (int val = nums[j]; ++val <= n; ) {\\n                ++icount[val];\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```\\n\\nThis\\'ll get us into the 300-400ms range.\\n\\n---\\n\\nWe can abuse the fact that even though our input is given as `vector<int>`, all the given values fit into `int16_t`.\\nSo, in effect, half of our input vector is completely unused, and we can reuse that space for our `icount` array.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& nums) {\\n        int n = nums.size();\\n        int16_t* raw_nums = reinterpret_cast<int16_t*>(nums.data());\\n        int16_t* raw_icount = raw_nums - 1;\\n        int64_t ret = 0;\\n        for (int j = 0; j < n; ++j) {\\n            int lcount = 0;\\n            int jnum = raw_nums[2 * j];\\n            for (int k = n; --k > j; ) {\\n                int knum = raw_nums[2 * k];\\n                if (jnum > knum) {\\n                    ret += raw_icount[2 * knum] * lcount;\\n                } else {\\n                    ++lcount;\\n                }\\n            }\\n            for (int val = jnum; val < n; ++val) {\\n                ++raw_icount[2 * val];\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```\\n\\nThis gets us to around 120-130ms.\\n\\n---\\n\\nNow, the loop to increment `icount` is very simple, we\\'re just adding 1 to every element in a range.\\nWe can use a simd-like idea to bundle two increments into one addition to an `int64_t`.\\n\\nWe know this is a `vector<int>`, so it is guaranteed to be 4-byte aligned.\\nNormally, we\\'d have to worry about the alignment of both ends of the range we want to add to.\\nHowever, since we know we won\\'t ever access `nums[j]` again, it\\'s fine if we unintentionally increment an extra value at the beginning of the range.\\nTherefore, once we round the start to an 8-byte aligned address, we only need an extra condition to maybe handle the last element.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& nums) {\\n        int n = nums.size();\\n        int16_t* raw_nums = reinterpret_cast<int16_t*>(nums.data());\\n        int16_t* raw_icount = raw_nums - 1;\\n        int64_t ret = 0;\\n        for (int j = 0; j < n; ++j) {\\n            int lcount = 0;\\n            int jnum = raw_nums[2 * j];\\n            for (int k = n; --k > j; ) {\\n                int knum = raw_nums[2 * k];\\n                if (jnum > knum) {\\n                    ret += raw_icount[2 * knum] * lcount;\\n                } else {\\n                    ++lcount;\\n                }\\n            }\\n            int64_t* s = reinterpret_cast<int64_t*>(reinterpret_cast<size_t>(&nums[jnum]) & ~0x7);\\n            int64_t* e = reinterpret_cast<int64_t*>(reinterpret_cast<size_t>(&nums[n]) & ~0x7);\\n            for (; s < e; ++s) {\\n                *s += 0x1000000010000;\\n            }\\n            if (reinterpret_cast<size_t>(&nums[n]) & 0x3) {\\n                ++reinterpret_cast<int16_t*>(e)[-1];\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```\\n\\nThis final hack gets us to the promised ~100ms solution.\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/e352cc38-8161-4c38-b562-f9c0481fb276_1692035256.9009948.png)\\n\\n---\\n\\nWhat a beautiful screenshot :)",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& nums) {\\n        int n = nums.size();\\n        std::vector<int16_t> icount(n + 1);\\n        int64_t ret = 0;\\n        for (int j = 0; j < n; ++j) {\\n            int lcount = 0;\\n            for (int k = n; --k > j; ) {\\n                if (nums[j] > nums[k]) {\\n                    ret += icount[nums[k]] * lcount;\\n                } else {\\n\\t\\t\\t\\t\\t++lcount;\\n\\t\\t\\t\\t}\\n            }\\n            for (int val = nums[j]; ++val <= n; ) {\\n                ++icount[val];\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& nums) {\\n        int n = nums.size();\\n        int16_t* raw_nums = reinterpret_cast<int16_t*>(nums.data());\\n        int16_t* raw_icount = raw_nums - 1;\\n        int64_t ret = 0;\\n        for (int j = 0; j < n; ++j) {\\n            int lcount = 0;\\n            int jnum = raw_nums[2 * j];\\n            for (int k = n; --k > j; ) {\\n                int knum = raw_nums[2 * k];\\n                if (jnum > knum) {\\n                    ret += raw_icount[2 * knum] * lcount;\\n                } else {\\n                    ++lcount;\\n                }\\n            }\\n            for (int val = jnum; val < n; ++val) {\\n                ++raw_icount[2 * val];\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& nums) {\\n        int n = nums.size();\\n        int16_t* raw_nums = reinterpret_cast<int16_t*>(nums.data());\\n        int16_t* raw_icount = raw_nums - 1;\\n        int64_t ret = 0;\\n        for (int j = 0; j < n; ++j) {\\n            int lcount = 0;\\n            int jnum = raw_nums[2 * j];\\n            for (int k = n; --k > j; ) {\\n                int knum = raw_nums[2 * k];\\n                if (jnum > knum) {\\n                    ret += raw_icount[2 * knum] * lcount;\\n                } else {\\n                    ++lcount;\\n                }\\n            }\\n            int64_t* s = reinterpret_cast<int64_t*>(reinterpret_cast<size_t>(&nums[jnum]) & ~0x7);\\n            int64_t* e = reinterpret_cast<int64_t*>(reinterpret_cast<size_t>(&nums[n]) & ~0x7);\\n            for (; s < e; ++s) {\\n                *s += 0x1000000010000;\\n            }\\n            if (reinterpret_cast<size_t>(&nums[n]) & 0x3) {\\n                ++reinterpret_cast<int16_t*>(e)[-1];\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3898955,
                "title": "simple-counting-code-with-explanation",
                "content": "# Intuition\\nwe can go back to counting the triplets where `i < j < k` & `nums[i] < nums[k] < nums[j]` this means that as a brute force solution for each index `j` we will iterate over all the indices that follow and for each of them as `k` we will iterate back till `j` and count all numbers smaller than `nums[k]` hence we satisfy that these numbers are before `j` and smaller than `nums[k]`. But that would be $$O(n^3)$$ **but** what if we had this count calculated ahead? hence we already know how many numbers are smaller than element `nums[k]` that lie before position `j` this will make our algorithm for counting triplets run in $$O(n^2)$$ instead. Subsequently we can precalculate all the triplets ending at `j` and whose second element lies before position `l` and we can calculate all quadriplets in $$O(n^2)$$ as well.\\n\\n# Approach\\nWe will precalculate our `duplets` array which holds at index `[i,j]` all duplets ending at index `i` and starting before index `j`, this is simply by accumulating sums for each `i` and incrementing on `j` where `j < i` and `nums[j] < nums[i]`.\\nNow we want to calculate the `triplets` array which holds at index `[i,j]` the triplets ending at index `i` and with second element at index `j`, this is also by accumulating sums for each `i` and if `j > i` &`nums[j] < nums[i]` then we increment `duplets[j][i]` (all duplets ending at `j` and first element is before `i`). this gurantees that for each triplet count the first element `k` is before `i` which is before `j` hence `k < i < j`and we already verified while counting that `nums[k] < nums[j] < nums[i]`.\\n\\nNow to calculate all quadriplets ending at index `l` then we just need to iterate over all elements of index `j` before `l` and if `nums[j] < nums[l]` we just need to add all the triplets ending at `j` and second element is before `l` which is `triplets[j][l]`.\\nWe can then add all quadriplets at all indices. \\n\\n# Complexity\\n- Time complexity:\\n $$O(n^2)$$\\n\\n- Space complexity:\\nWe are holding duplets and triplets so\\n $$O(n^2)$$\\n# Code\\n```\\nclass Solution {\\n\\npublic:\\n    long long countQuadruplets(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<vector<long long>> duplets(n, vector<long long>(n, 0L));\\n        vector<vector<long long>> triplets(n, vector<long long>(n, 0L));\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j<i; j++) {\\n                duplets[i][j] = ((j > 0) ? duplets[i][j-1] : 0L) + (nums[i] > nums[j]);\\n            }\\n        }\\n\\n        for(int i = 0; i < n; i++) {\\n            for(int j = i+1; j<n; j++) {\\n                triplets[i][j] = triplets[i][j-1] + (nums[i] > nums[j]) * duplets[j][i];\\n            }\\n        }\\n        long long sol=0L;\\n\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j<i; j++) {\\n                if(nums[i] > nums[j])\\n               sol += triplets[j][i];\\n            }\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n\\npublic:\\n    long long countQuadruplets(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<vector<long long>> duplets(n, vector<long long>(n, 0L));\\n        vector<vector<long long>> triplets(n, vector<long long>(n, 0L));\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j<i; j++) {\\n                duplets[i][j] = ((j > 0) ? duplets[i][j-1] : 0L) + (nums[i] > nums[j]);\\n            }\\n        }\\n\\n        for(int i = 0; i < n; i++) {\\n            for(int j = i+1; j<n; j++) {\\n                triplets[i][j] = triplets[i][j-1] + (nums[i] > nums[j]) * duplets[j][i];\\n            }\\n        }\\n        long long sol=0L;\\n\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j<i; j++) {\\n                if(nums[i] > nums[j])\\n               sol += triplets[j][i];\\n            }\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3864315,
                "title": "c-simple-as-logic-like-quadruple-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> pre(n+1, vector<int> (n+1,0)), suf(n+1, vector<int>(n+1,0));\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            int cnt =0;\\n            for(int j=0;j<n;j++)\\n            {\\n                pre[i][j] = cnt;\\n                if(nums[j]<i)\\n                {\\n                    cnt++;\\n                }\\n            }\\n        }\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            int cnt =0;\\n            for(int j=n-1;j>=0;j--)\\n            {\\n                suf[i][j] = cnt;\\n                if(nums[j]>i)\\n                {\\n                    cnt++;\\n                }\\n            }\\n        }\\n        long long ans =0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(nums[i]>nums[j])\\n                {\\n                    ans+=(pre[nums[j]][i]*suf[nums[i]][j]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> pre(n+1, vector<int> (n+1,0)), suf(n+1, vector<int>(n+1,0));\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            int cnt =0;\\n            for(int j=0;j<n;j++)\\n            {\\n                pre[i][j] = cnt;\\n                if(nums[j]<i)\\n                {\\n                    cnt++;\\n                }\\n            }\\n        }\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            int cnt =0;\\n            for(int j=n-1;j>=0;j--)\\n            {\\n                suf[i][j] = cnt;\\n                if(nums[j]>i)\\n                {\\n                    cnt++;\\n                }\\n            }\\n        }\\n        long long ans =0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(nums[i]>nums[j])\\n                {\\n                    ans+=(pre[nums[j]][i]*suf[nums[i]][j]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3850875,
                "title": "sorted-list",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nC# version of this sorted list solution:\\nhttps://leetcode.com/problems/count-increasing-quadruplets/solutions/3111696/python3-sortedlist-bisect-insort-solution-clean-concise/\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nExplanations are added inline. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n^{2}logn)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public long CountQuadruplets(int[] nums) {\\n        long ans = 0;\\n        List<int> sl = new List<int>(){ nums[0] };\\n\\n        // For each current element nums[j] (maintained using a for loop from left to right), \\n        // we loop through the possible value of nums[k] from right to left, and count\\n        // (1) how many element on the left of j that satisfies nums[k] > nums[i], this \\n        //     can be achieved using a binary search;\\n        // (2) how many element on the right of k has the value nums[l] > nums[j], this \\n        //     can be achieved by comparing the value of nums[k] with nums[j] each time;\\n        // and add the product from (1) and (2) to the final ans.\\n        for(int j = 1; j < nums.Length; j++){\\n            var idx = sl.BinarySearch(nums[j]);\\n            if(idx < 0) idx = ~idx;\\n            sl.Insert(idx, nums[j]);\\n\\n            // The variable cnt is being used to keep track of how many elements that appear \\n            // after nums[j] in the array are greater than nums[j]\\n            int cnt = nums[j] < nums[^1] ? 1 : 0; \\n            // loop backwards is first do cnt++, then do idx * cnt\\n            // loop forwards is first do idx * cnt, then do cnt++\\n            // when looping backward, cnt accumulates counts of numbers greater than nums[j] \\n            // that we\\'ve already encountered, and applies that count to the calculation for \\n            // smaller nums[k]\\'s.\\n            // When looping forward, cnt is incremented after the calculation for each nums[k], \\n            // so it doesn\\'t apply to that nums[k]\\'s calculation but will apply to the next \\n            // larger nums[k]\\'s calculation.\\n            for (int k = nums.Length - 2; k > j; k--){\\n                // The check nums[j] < nums[k] is there to increment cnt each time we \\n                // encounter an element that\\'s greater than nums[j] while iterating over the array.\\n                // if all elements after j are larger than nums[j], ans will be 0.\\n                if(nums[j] < nums[k]) {   // this k is actually l. \\n                    cnt++;\\n                    continue;\\n                }\\n                // after we find an appropriate number k, we use binary search to\\n                // check how many number is smaller than k. \\n                idx = sl.BinarySearch(nums[k]);  \\n                if(idx < 0) idx = ~idx;\\n                ans += idx * cnt;     // when j is at current position, how many ans do we have.\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public long CountQuadruplets(int[] nums) {\\n        long ans = 0;\\n        List<int> sl = new List<int>(){ nums[0] };\\n\\n        // For each current element nums[j] (maintained using a for loop from left to right), \\n        // we loop through the possible value of nums[k] from right to left, and count\\n        // (1) how many element on the left of j that satisfies nums[k] > nums[i], this \\n        //     can be achieved using a binary search;\\n        // (2) how many element on the right of k has the value nums[l] > nums[j], this \\n        //     can be achieved by comparing the value of nums[k] with nums[j] each time;\\n        // and add the product from (1) and (2) to the final ans.\\n        for(int j = 1; j < nums.Length; j++){\\n            var idx = sl.BinarySearch(nums[j]);\\n            if(idx < 0) idx = ~idx;\\n            sl.Insert(idx, nums[j]);\\n\\n            // The variable cnt is being used to keep track of how many elements that appear \\n            // after nums[j] in the array are greater than nums[j]\\n            int cnt = nums[j] < nums[^1] ? 1 : 0; \\n            // loop backwards is first do cnt++, then do idx * cnt\\n            // loop forwards is first do idx * cnt, then do cnt++\\n            // when looping backward, cnt accumulates counts of numbers greater than nums[j] \\n            // that we\\'ve already encountered, and applies that count to the calculation for \\n            // smaller nums[k]\\'s.\\n            // When looping forward, cnt is incremented after the calculation for each nums[k], \\n            // so it doesn\\'t apply to that nums[k]\\'s calculation but will apply to the next \\n            // larger nums[k]\\'s calculation.\\n            for (int k = nums.Length - 2; k > j; k--){\\n                // The check nums[j] < nums[k] is there to increment cnt each time we \\n                // encounter an element that\\'s greater than nums[j] while iterating over the array.\\n                // if all elements after j are larger than nums[j], ans will be 0.\\n                if(nums[j] < nums[k]) {   // this k is actually l. \\n                    cnt++;\\n                    continue;\\n                }\\n                // after we find an appropriate number k, we use binary search to\\n                // check how many number is smaller than k. \\n                idx = sl.BinarySearch(nums[k]);  \\n                if(idx < 0) idx = ~idx;\\n                ans += idx * cnt;     // when j is at current position, how many ans do we have.\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3813132,
                "title": "rust-answer",
                "content": "# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn count_quadruplets(nums: Vec<i32>) -> i64 {\\n        let len = nums.len();\\n        let mut mat_ij = vec![vec![0;len];len+1];\\n        let mut mat_kl = vec![vec![0;len];len+1];\\n        for i in 0..len {\\n            for j in 0..len {\\n                mat_ij[i+1][j]=mat_ij[i][j]+if nums[i]<nums[j] {1} else {0};\\n                mat_kl[len-i-1][j]=mat_kl[len-i][j]+if nums[len-i-1]>nums[j] {1} else {0};\\n            }\\n        }\\n        let mut sum = 0;\\n        for i in 0..len-1 {\\n            for j in i+1..len {\\n                if nums[i]>nums[j] {sum+=(mat_ij[i+1][j]*mat_kl[j][i]) as i64;}\\n            }\\n        }\\n        sum\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn count_quadruplets(nums: Vec<i32>) -> i64 {\\n        let len = nums.len();\\n        let mut mat_ij = vec![vec![0;len];len+1];\\n        let mut mat_kl = vec![vec![0;len];len+1];\\n        for i in 0..len {\\n            for j in 0..len {\\n                mat_ij[i+1][j]=mat_ij[i][j]+if nums[i]<nums[j] {1} else {0};\\n                mat_kl[len-i-1][j]=mat_kl[len-i][j]+if nums[len-i-1]>nums[j] {1} else {0};\\n            }\\n        }\\n        let mut sum = 0;\\n        for i in 0..len-1 {\\n            for j in i+1..len {\\n                if nums[i]>nums[j] {sum+=(mat_ij[i+1][j]*mat_kl[j][i]) as i64;}\\n            }\\n        }\\n        sum\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3805798,
                "title": "c-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n*n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        vector<vector<int>> greater(n,vector<int>(n)),lower(n, vector<int>(n));\\n\\n        for(int i = 0;i<n;i++) {\\n            int count = 0;\\n            for(int j = i + 1;j<n;j++) {\\n                if(nums[j] > nums[i]) {\\n                    count++;\\n                }\\n                greater[i][j] = count;\\n            }\\n        }\\n\\n        for(int l = n- 1;l>=0;l--) {\\n            int count = 0;\\n            for(int k = l - 1;k>=0;k--) {\\n                if(nums[k] < nums[l]){\\n                    count++;\\n                }\\n                 lower[k][l] = count;\\n            }\\n        }\\n\\n        long ans = 0;\\n\\n        for(int j = 1;j<n - 2;j++) {\\n            for(int k = j + 1;k<n - 1;k++) {\\n                if(nums[j]< nums[k]) continue;\\n                int countI = lower[0][k] - lower[j][k];\\n                int countL = greater[j][n-1] - greater[j][k];\\n                ans += (countI * countL);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        vector<vector<int>> greater(n,vector<int>(n)),lower(n, vector<int>(n));\\n\\n        for(int i = 0;i<n;i++) {\\n            int count = 0;\\n            for(int j = i + 1;j<n;j++) {\\n                if(nums[j] > nums[i]) {\\n                    count++;\\n                }\\n                greater[i][j] = count;\\n            }\\n        }\\n\\n        for(int l = n- 1;l>=0;l--) {\\n            int count = 0;\\n            for(int k = l - 1;k>=0;k--) {\\n                if(nums[k] < nums[l]){\\n                    count++;\\n                }\\n                 lower[k][l] = count;\\n            }\\n        }\\n\\n        long ans = 0;\\n\\n        for(int j = 1;j<n - 2;j++) {\\n            for(int k = j + 1;k<n - 1;k++) {\\n                if(nums[j]< nums[k]) continue;\\n                int countI = lower[0][k] - lower[j][k];\\n                int countL = greater[j][n-1] - greater[j][k];\\n                ans += (countI * countL);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3787185,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    long long countQuadruplets(vector<int>&v) {\\n        ll n = v.size(), ans = 0;\\n        vector<ll>patterns(n); // patterns[i] = num of 132 patterns with their 3 at i\\n        for(ll i=0; i<n; ++i){\\n            ll preSmall = 0; // num of j such that v[j]<v[i]\\n            for(ll j=0; j<i; ++j){\\n                if(v[j]<v[i]){\\n                    ++preSmall;\\n                    ans+=patterns[j]; // current element can simply append as d\\n                } else if(v[j]>v[i]){\\n                    patterns[j]+=preSmall;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    long long countQuadruplets(vector<int>&v) {\\n        ll n = v.size(), ans = 0;\\n        vector<ll>patterns(n); // patterns[i] = num of 132 patterns with their 3 at i\\n        for(ll i=0; i<n; ++i){\\n            ll preSmall = 0; // num of j such that v[j]<v[i]\\n            for(ll j=0; j<i; ++j){\\n                if(v[j]<v[i]){\\n                    ++preSmall;\\n                    ans+=patterns[j]; // current element can simply append as d\\n                } else if(v[j]>v[i]){\\n                    patterns[j]+=preSmall;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691287,
                "title": "find-middle-pair-and-count-outer-pairs",
                "content": "```\\nclass BIT{\\npublic:\\n    vector<int> a;\\n    int N;\\n    BIT(int n){\\n        a.resize(n + 1);\\n        N = n;\\n    }\\n    \\n    void update(int ind,int val){\\n        while(ind <= N){\\n            a[ind] += val;\\n            ind += ind & (-ind);\\n        }\\n    }\\n    \\n    long long query(int ind){\\n        long long sum = 0;\\n        while(ind > 0){\\n            sum += a[ind];\\n            ind -= ind & (-ind);\\n        }\\n        return sum;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    long long int countQuadruplets(vector<int>& nums) {\\n        int n = nums.size();\\n        int M = *max_element(nums.begin(), nums.end());\\n        long long int res = 0;\\n        BIT left(M + 1);\\n        for (int i = 0; i < n; i++) {\\n            BIT right(M + 1);\\n            for (int j = n - 1; j > i; j--) {\\n                if (nums[i] > nums[j]) {\\n                    int l = left.query(nums[j]);\\n                    int r = right.query(M + 1) - right.query(nums[i]);\\n                    res += l * r;\\n                }\\n                right.update(nums[j], 1);\\n            }\\n            left.update(nums[i], 1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass BIT{\\npublic:\\n    vector<int> a;\\n    int N;\\n    BIT(int n){\\n        a.resize(n + 1);\\n        N = n;\\n    }\\n    \\n    void update(int ind,int val){\\n        while(ind <= N){\\n            a[ind] += val;\\n            ind += ind & (-ind);\\n        }\\n    }\\n    \\n    long long query(int ind){\\n        long long sum = 0;\\n        while(ind > 0){\\n            sum += a[ind];\\n            ind -= ind & (-ind);\\n        }\\n        return sum;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    long long int countQuadruplets(vector<int>& nums) {\\n        int n = nums.size();\\n        int M = *max_element(nums.begin(), nums.end());\\n        long long int res = 0;\\n        BIT left(M + 1);\\n        for (int i = 0; i < n; i++) {\\n            BIT right(M + 1);\\n            for (int j = n - 1; j > i; j--) {\\n                if (nums[i] > nums[j]) {\\n                    int l = left.query(nums[j]);\\n                    int r = right.query(M + 1) - right.query(nums[i]);\\n                    res += l * r;\\n                }\\n                right.update(nums[j], 1);\\n            }\\n            left.update(nums[i], 1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3642275,
                "title": "simple-prefix-sum-no-dp-o-n-2-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTake two indexes (such that `nums[i1]>nums[i2]`) and multiply the number of indexes before i1 which have value less than nums[i2] with the number of indexes after i2 with value more that nums[i1].\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& nums) {\\n        vector<vector<int>> v(nums.size(),vector<int>(nums.size()));\\n        for(int i = 0; i<nums.size(); i++){\\n            int curr = 0;\\n            for(int j = i-1; j>=0; j--){\\n                if(nums[j]<nums[i]){\\n                    curr++;\\n                }\\n                v[i][j]=curr;\\n            }\\n            curr=0;\\n            for(int j = i+1; j<nums.size(); j++){\\n                if(nums[j]>nums[i]){\\n                    curr++;\\n                }\\n                v[i][j]=curr;\\n            }\\n        }\\n        long long count = 0;\\n        for(int i = 1; i<nums.size()-1; i++){\\n            for(int j = i+1; j<nums.size(); j++){\\n                if(nums[j]<nums[i]){\\n                    count+=(v[i][nums.size()-1]-v[i][j])*(v[j][0]-v[j][i]);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& nums) {\\n        vector<vector<int>> v(nums.size(),vector<int>(nums.size()));\\n        for(int i = 0; i<nums.size(); i++){\\n            int curr = 0;\\n            for(int j = i-1; j>=0; j--){\\n                if(nums[j]<nums[i]){\\n                    curr++;\\n                }\\n                v[i][j]=curr;\\n            }\\n            curr=0;\\n            for(int j = i+1; j<nums.size(); j++){\\n                if(nums[j]>nums[i]){\\n                    curr++;\\n                }\\n                v[i][j]=curr;\\n            }\\n        }\\n        long long count = 0;\\n        for(int i = 1; i<nums.size()-1; i++){\\n            for(int j = i+1; j<nums.size(); j++){\\n                if(nums[j]<nums[i]){\\n                    count+=(v[i][nums.size()-1]-v[i][j])*(v[j][0]-v[j][i]);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3635503,
                "title": "c-o-2-optimized-process",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    The time complexity of exhausted search is O{n^4}.\\n\\n---\\n\\n\\n    How to lower the time complexity?\\n    If we enumerate all possible pairs of i and l, we should count there are how many reverse order pairs between i and l. This solution is gonna be difficult!\\n\\n    If we enumerate all possible pairs of j and k, we should count there are how many numbers greater than j after k, and count there are how many numbers smaller then k before j. This solution is better.\\n\\n    For now, we got a solution that has time complexity of O{n^3}: Two for loop to enumerate all possible paires of j and k. Within each loop, we are going to count the numbers of greater than j after k, and count the numbers of smaller than k before j. We denote them as cntLeft and cntRight. ResultNumber += cntLeft * cntRight;\\n\\n---\\n\\n\\n    As we shown above, we compute the numbers repeatly, so that we can store the numbers to reduce the double counting. How to store the computing results?\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n    We create a 2-D metrix called int help[n][n];\\n    For any pairs of row and column, if column < row, we are gonna store the numbers smaller than nums[row] before index column. Similarly, if colmn > row, we are gonna store the numbers greater than nums[row] after index column. Once we have the help metrix, we can simply compute the numbers of any pairs of j and k. For example, we are gonna compute the pair j = 5, k = 8. we can get `cntLeft` = help[k][j] and `cntRight` = help[j][k]; And then mutiply them together cntLeft * cntRight that would contribute to the numbers of result.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O {n^2}\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O {n^2}\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> help(n, vector<int>(n, 0));\\n\\n        for (int i = 0; i < n; i++) { \\n            int cntSmall = 0;\\n            for (int j = 1; j < i ; j++) { // Count the number smaller \\n                if (nums[j - 1] < nums[i]) { // Not including current one\\n                    cntSmall++;\\n                    help[i][j] = cntSmall;\\n                }\\n                else {\\n                    help[i][j] = help[i][j - 1];\\n                }\\n            }\\n            int cntBig = 0;\\n            for (int j = n - 2; j > i; j--) {\\n                if (nums[j + 1] > nums[i]) {\\n                    cntBig++;\\n                    help[i][j] = cntBig;\\n                }\\n                else {\\n                    help[i][j] = help[i][j + 1];\\n                }\\n            }\\n        }\\n        long long res = 0;\\n\\n        for (int i = 1; i < n - 2; i++) {\\n            for (int j = i + 1; j < n - 1; j++) {\\n                if (nums[i] > nums[j]) {\\n                    // Inverted Pair\\n                    int leftCnt = help[j][i];\\n                    int rightCnt = help[i][j];\\n                    res = res + leftCnt * rightCnt;\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> help(n, vector<int>(n, 0));\\n\\n        for (int i = 0; i < n; i++) { \\n            int cntSmall = 0;\\n            for (int j = 1; j < i ; j++) { // Count the number smaller \\n                if (nums[j - 1] < nums[i]) { // Not including current one\\n                    cntSmall++;\\n                    help[i][j] = cntSmall;\\n                }\\n                else {\\n                    help[i][j] = help[i][j - 1];\\n                }\\n            }\\n            int cntBig = 0;\\n            for (int j = n - 2; j > i; j--) {\\n                if (nums[j + 1] > nums[i]) {\\n                    cntBig++;\\n                    help[i][j] = cntBig;\\n                }\\n                else {\\n                    help[i][j] = help[i][j + 1];\\n                }\\n            }\\n        }\\n        long long res = 0;\\n\\n        for (int i = 1; i < n - 2; i++) {\\n            for (int j = i + 1; j < n - 1; j++) {\\n                if (nums[i] > nums[j]) {\\n                    // Inverted Pair\\n                    int leftCnt = help[j][i];\\n                    int rightCnt = help[i][j];\\n                    res = res + leftCnt * rightCnt;\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3409673,
                "title": "o-n-2-log-n-using-binary-indexed-tree",
                "content": "# Intuition\\nIterate through each pair of i and j and maintain forward and back fenwick tree forward which will tell number of element smaller than v[j] on left side of i and back will tell number of element greater than v[i] on right side of j and add there product in ans.\\n\\n\\n# Complexity\\n- Time complexity:\\n O(n^2 * log(N))\\n\\n- Space complexity:\\n O(N)\\n\\n# Code\\n```\\n#define fr(i, a, b) for (int i = a; i < b; i++)   \\n#define frr(i, a, b) for (int i = a; i >= b; i--)  \\n#define pb push_back \\n\\nclass Solution {\\npublic:\\n\\n    \\nstatic const int N = 4e3+10;\\n\\nvoid update(int i, int x,vector<int>&bit){\\n\\tfor(; i < N; i += (i&-i))\\n\\t\\tbit[i] += x;\\n}\\n\\nint sum(int i,vector<int>&bit){\\n\\tint ans = 0;\\n\\tfor(; i > 0; i -= (i&-i))\\n\\t\\tans += bit[i];\\n\\treturn ans;\\n}\\n\\nlong long countQuadruplets(vector<int>& v) \\n{\\n    int n=v.size();\\n    vector<int>forward(N+1,0),back(N+1,0);\\n    for(auto it:v)\\n    update(it,1,back);\\n\\n    long long ans=0;\\n    fr(i,0,n)    \\n    {\\n        update(v[i],1,forward);\\n        update(v[i],-1,back);\\n        long long x=sum(v[i]-1,forward);\\n        if(x<=0)\\n        continue;\\n        fr(j,i+1,n)\\n        {\\n            update(v[j],-1,back);\\n            if(v[j]<v[i])\\n            {\\n                  int x=sum(v[j],forward);\\n                  int y=sum(N,back)-sum(v[i],back);\\n                //   cout<<v[i]<<\" \"<<v[j]<<\" \"<<x<<\" \"<<y<<\"\\\\n\";\\n                  ans+=x*y;\\n            }\\n        }\\n        fr(j,i+1,n)\\n            update(v[j],1,back);\\n    }\\n    return ans;\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define fr(i, a, b) for (int i = a; i < b; i++)   \\n#define frr(i, a, b) for (int i = a; i >= b; i--)  \\n#define pb push_back \\n\\nclass Solution {\\npublic:\\n\\n    \\nstatic const int N = 4e3+10;\\n\\nvoid update(int i, int x,vector<int>&bit){\\n\\tfor(; i < N; i += (i&-i))\\n\\t\\tbit[i] += x;\\n}\\n\\nint sum(int i,vector<int>&bit){\\n\\tint ans = 0;\\n\\tfor(; i > 0; i -= (i&-i))\\n\\t\\tans += bit[i];\\n\\treturn ans;\\n}\\n\\nlong long countQuadruplets(vector<int>& v) \\n{\\n    int n=v.size();\\n    vector<int>forward(N+1,0),back(N+1,0);\\n    for(auto it:v)\\n    update(it,1,back);\\n\\n    long long ans=0;\\n    fr(i,0,n)    \\n    {\\n        update(v[i],1,forward);\\n        update(v[i],-1,back);\\n        long long x=sum(v[i]-1,forward);\\n        if(x<=0)\\n        continue;\\n        fr(j,i+1,n)\\n        {\\n            update(v[j],-1,back);\\n            if(v[j]<v[i])\\n            {\\n                  int x=sum(v[j],forward);\\n                  int y=sum(N,back)-sum(v[i],back);\\n                //   cout<<v[i]<<\" \"<<v[j]<<\" \"<<x<<\" \"<<y<<\"\\\\n\";\\n                  ans+=x*y;\\n            }\\n        }\\n        fr(j,i+1,n)\\n            update(v[j],1,back);\\n    }\\n    return ans;\\n}\\n\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3278023,
                "title": "c-dp",
                "content": "```\\npublic class Solution {\\n    public long CountQuadruplets(int[] nums) {\\n        int n=nums.Length;\\n        long[,] dp=new long[n,5];\\n        \\n        dp[0,1]=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            dp[i,1]=1;\\n            int gc=0;\\n            for(int j=0;j<i;j++)\\n            {\\n                if(nums[i]<nums[j]){\\n                    dp[j,3]+=gc;\\n                }else {\\n                    gc++;\\n                    dp[i,2]+=dp[j,1];\\n                    dp[i,4]+=dp[j,3];\\n                }\\n            }\\n            dp[i,0]+=dp[i-1,0];\\n            dp[i,0]+=dp[i,4];\\n        }\\n        return dp[n-1,0];\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\npublic class Solution {\\n    public long CountQuadruplets(int[] nums) {\\n        int n=nums.Length;\\n        long[,] dp=new long[n,5];\\n        \\n        dp[0,1]=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            dp[i,1]=1;\\n            int gc=0;\\n            for(int j=0;j<i;j++)\\n            {\\n                if(nums[i]<nums[j]){\\n                    dp[j,3]+=gc;\\n                }else {\\n                    gc++;\\n                    dp[i,2]+=dp[j,1];\\n                    dp[i,4]+=dp[j,3];\\n                }\\n            }\\n            dp[i,0]+=dp[i-1,0];\\n            dp[i,0]+=dp[i,4];\\n        }\\n        return dp[n-1,0];\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3239554,
                "title": "bit-solution-clean",
                "content": "<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUsed bit\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O((N^2)*LOGN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FenTree{\\n     public:\\n        FenTree(int n){\\n            this->size=n+1;\\n            this->tree.resize(size);\\n        }\\n        int sum(int i){\\n            int res=0;\\n            for(++i;i>0;i-=i&-i){\\n                res+=tree[i];\\n            }\\n            return res;\\n\\n        }\\n        int add(int id,int delta){\\n            for(++id;id<size;id+=id&(-id)){\\n                tree[id]+=delta;\\n            }\\n          return 0;\\n        }\\n\\n        void reset(){\\n            this->tree.resize(size,0);\\n\\n        }\\n\\n\\n    private:\\n        vector<int>tree;\\n        int size;\\n\\n };\\n\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& a) {\\n        int n=a.size();\\n        FenTree btl(n+1);\\n        long long  ans=0;\\n        for(int j=0;j<n;j++){\\n            FenTree btr(n+1);\\n            for(int k=n-1;k>j;k--){\\n                if(a[k]<a[j]){\\n                    int l=btl.sum(a[k]);\\n                    int r=btr.sum(n)-btr.sum(a[j]);\\n                    ans+=(l*r*1ll);\\n                }\\n                btr.add(a[k],1);\\n            }\\n            btl.add(a[j],1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FenTree{\\n     public:\\n        FenTree(int n){\\n            this->size=n+1;\\n            this->tree.resize(size);\\n        }\\n        int sum(int i){\\n            int res=0;\\n            for(++i;i>0;i-=i&-i){\\n                res+=tree[i];\\n            }\\n            return res;\\n\\n        }\\n        int add(int id,int delta){\\n            for(++id;id<size;id+=id&(-id)){\\n                tree[id]+=delta;\\n            }\\n          return 0;\\n        }\\n\\n        void reset(){\\n            this->tree.resize(size,0);\\n\\n        }\\n\\n\\n    private:\\n        vector<int>tree;\\n        int size;\\n\\n };\\n\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& a) {\\n        int n=a.size();\\n        FenTree btl(n+1);\\n        long long  ans=0;\\n        for(int j=0;j<n;j++){\\n            FenTree btr(n+1);\\n            for(int k=n-1;k>j;k--){\\n                if(a[k]<a[j]){\\n                    int l=btl.sum(a[k]);\\n                    int r=btr.sum(n)-btr.sum(a[j]);\\n                    ans+=(l*r*1ll);\\n                }\\n                btr.add(a[k],1);\\n            }\\n            btl.add(a[j],1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3220143,
                "title": "python-using-dp-easy",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def countQuadruplets(self, nums: List[int]) -> int:\\n\\n        dp = [0] * len(nums)\\n        contador = 0\\n\\n        for j in range(len(nums)):\\n            prv = 0\\n\\n            for i in range(j):\\n                if nums[j] > nums[i]:\\n                    prv = prv+ 1\\n                    contador =contador+ dp[i]\\n                elif nums[j] < nums[i]:\\n                    dp[i] = dp[i]+ prv\\n\\n        return contador\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countQuadruplets(self, nums: List[int]) -> int:\\n\\n        dp = [0] * len(nums)\\n        contador = 0\\n\\n        for j in range(len(nums)):\\n            prv = 0\\n\\n            for i in range(j):\\n                if nums[j] > nums[i]:\\n                    prv = prv+ 1\\n                    contador =contador+ dp[i]\\n                elif nums[j] < nums[i]:\\n                    dp[i] = dp[i]+ prv\\n\\n        return contador\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207789,
                "title": "c-o-n-2-easy-to-understand",
                "content": "# Intuition\\nprecompute vl and vi\\nvl[j][k] is the count of l where l>=k && v[l] > v[j]\\nvi[j][k] is the count of i where i<=j && v[i] < v[k]\\n\\nthen loop j, k\\nsum += vi[j][k] * vl[j][k]; \\n\\n# Complexity\\n- Time complexity:\\nO(N^2)\\n\\n- Space complexity:\\nO(N^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& nums) {\\n        const int n = nums.size();\\n        auto vl = vector(n, vector(n, 0LL)), vi = vl;\\n        for(int i=0;i<n;i++){\\n            for(int j=n-1, cnt = 0;j>i;j--){\\n                if(nums[j]>nums[i]) cnt++;\\n                vl[i][j] = cnt;\\n            }                 \\n        }\\n\\n        for(int k=0;k<n;k++){\\n            for(int i=0, cnt=0;i<k;i++){\\n                if(nums[i]<nums[k]) cnt++;\\n                vi[k][i] = cnt;\\n            }\\n        }\\n\\n        long long res = 0;\\n        for(int j=1;j<n-2;j++) for(int k=j+1;k<n-1;k++){\\n            if(nums[k] < nums[j]) res += vi[k][j-1] * vl[j][k+1];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& nums) {\\n        const int n = nums.size();\\n        auto vl = vector(n, vector(n, 0LL)), vi = vl;\\n        for(int i=0;i<n;i++){\\n            for(int j=n-1, cnt = 0;j>i;j--){\\n                if(nums[j]>nums[i]) cnt++;\\n                vl[i][j] = cnt;\\n            }                 \\n        }\\n\\n        for(int k=0;k<n;k++){\\n            for(int i=0, cnt=0;i<k;i++){\\n                if(nums[i]<nums[k]) cnt++;\\n                vi[k][i] = cnt;\\n            }\\n        }\\n\\n        long long res = 0;\\n        for(int j=1;j<n-2;j++) for(int k=j+1;k<n-1;k++){\\n            if(nums[k] < nums[j]) res += vi[k][j-1] * vl[j][k+1];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3167845,
                "title": "antarnab-100-faster-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& a) {\\n        long long res = 0;\\n        int n = a.size();\\n        vector<vector<int>> left(n, vector<int>(n+1, 0));\\n        vector<vector<int>> right(n, vector<int>(n+1, 0));\\n        for (int i = 1; i < n; ++i) {\\n            // new array will based on the old array\\n            left[i] = left[i-1];\\n            // update all the elements greater than a[i-1]\\n            for (int j = a[i-1] + 1; j <= n; ++j)\\n                left[i][j]++;\\n        }\\n        for (int i = n-2; i >= 0; --i) {\\n            right[i] = right[i+1];\\n            for (int j = 0; j < a[i+1]; ++j)\\n                right[i][j]++;\\n        }\\n        for (int j = 0; j < n; ++j) {\\n            for (int k = j+1; k < n; ++k) {\\n                if (a[j] <= a[k]) continue;\\n                // left[j][a[k]] is the count of feasible i\\n                // right[k][a[j]] is the count of feasible l\\n                res += left[j][a[k]] * right[k][a[j]];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& a) {\\n        long long res = 0;\\n        int n = a.size();\\n        vector<vector<int>> left(n, vector<int>(n+1, 0));\\n        vector<vector<int>> right(n, vector<int>(n+1, 0));\\n        for (int i = 1; i < n; ++i) {\\n            // new array will based on the old array\\n            left[i] = left[i-1];\\n            // update all the elements greater than a[i-1]\\n            for (int j = a[i-1] + 1; j <= n; ++j)\\n                left[i][j]++;\\n        }\\n        for (int i = n-2; i >= 0; --i) {\\n            right[i] = right[i+1];\\n            for (int j = 0; j < a[i+1]; ++j)\\n                right[i][j]++;\\n        }\\n        for (int j = 0; j < n; ++j) {\\n            for (int k = j+1; k < n; ++k) {\\n                if (a[j] <= a[k]) continue;\\n                // left[j][a[k]] is the count of feasible i\\n                // right[k][a[j]] is the count of feasible l\\n                res += left[j][a[k]] * right[k][a[j]];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3167841,
                "title": "antarnab-100-faster-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& a) {\\n        long long res = 0;\\n        int n = a.size();\\n        vector<vector<int>> left(n, vector<int>(n+1, 0));\\n        vector<vector<int>> right(n, vector<int>(n+1, 0));\\n        for (int i = 1; i < n; ++i) {\\n            // new array will based on the old array\\n            left[i] = left[i-1];\\n            // update all the elements greater than a[i-1]\\n            for (int j = a[i-1] + 1; j <= n; ++j)\\n                left[i][j]++;\\n        }\\n        for (int i = n-2; i >= 0; --i) {\\n            right[i] = right[i+1];\\n            for (int j = 0; j < a[i+1]; ++j)\\n                right[i][j]++;\\n        }\\n        for (int j = 0; j < n; ++j) {\\n            for (int k = j+1; k < n; ++k) {\\n                if (a[j] <= a[k]) continue;\\n                // left[j][a[k]] is the count of feasible i\\n                // right[k][a[j]] is the count of feasible l\\n                res += left[j][a[k]] * right[k][a[j]];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& a) {\\n        long long res = 0;\\n        int n = a.size();\\n        vector<vector<int>> left(n, vector<int>(n+1, 0));\\n        vector<vector<int>> right(n, vector<int>(n+1, 0));\\n        for (int i = 1; i < n; ++i) {\\n            // new array will based on the old array\\n            left[i] = left[i-1];\\n            // update all the elements greater than a[i-1]\\n            for (int j = a[i-1] + 1; j <= n; ++j)\\n                left[i][j]++;\\n        }\\n        for (int i = n-2; i >= 0; --i) {\\n            right[i] = right[i+1];\\n            for (int j = 0; j < a[i+1]; ++j)\\n                right[i][j]++;\\n        }\\n        for (int j = 0; j < n; ++j) {\\n            for (int k = j+1; k < n; ++k) {\\n                if (a[j] <= a[k]) continue;\\n                // left[j][a[k]] is the count of feasible i\\n                // right[k][a[j]] is the count of feasible l\\n                res += left[j][a[k]] * right[k][a[j]];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3159166,
                "title": "my-solution",
                "content": "**Solution I**\\n```\\n/**\\n * Time Complexity: O(n * n)\\n * Space Complexity: O(n * n)\\n * where `n` is the length of the vector `nums`\\n */\\nclass Solution {\\n public:\\n  long long countQuadruplets(const vector<int> &nums) {\\n    const int n = static_cast<int>(nums.size());\\n    vector<int> dp_less(n * n);\\n    for (int prev_j = 0; prev_j < n; ++prev_j) {\\n      for (int k = 0; k < n; ++k) {\\n        dp_less[prev_j * n + k] = (prev_j == 0 ? 0 : dp_less[(prev_j - 1) * n + k]) + (nums[prev_j] < nums[k] ? 1 : 0);\\n      }\\n    }\\n    \\n    vector<int> dp_greater(n * n);\\n    for (int post_k = n - 1; post_k > -1; --post_k) {\\n      for (int j = 0; j < n; ++j) {\\n        dp_greater[post_k * n + j] = (post_k == n - 1 ? 0 : dp_greater[(post_k + 1) * n + j]) + (nums[post_k] > nums[j] ? 1 : 0);\\n      }\\n    }\\n\\n    long long ret = 0LL;\\n    for (int j = 1; j < n - 2; ++j) {\\n      for (int k = j + 1; k < n - 1; ++k) {\\n        if (nums[j] > nums[k]) {\\n          ret += dp_less[(j - 1) * n + k] * dp_greater[(k + 1) * n + j];\\n        }\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```\\n**Solution II**\\n```\\n/**\\n * Time Complexity: O(n * n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `nums`\\n */\\nclass Solution {\\n public:\\n  long long countQuadruplets(const vector<int> &nums) {\\n    const int n = static_cast<int>(nums.size());\\n    /**\\n     * dp[j] means the count of the triplets (i, j, k),\\n     *             where i < j < k and nums[i] < nums[k] < nums[j]\\n     */\\n    int dp[n];\\n    memset(dp, 0, sizeof(dp));\\n    long long ret = 0;\\n    for (int x = 2; x < n; ++x) {\\n      int smaller_than_k = 0;\\n      for (int y = 0; y < x; ++y) {\\n        if (nums[x] > nums[y]) {\\n          /**\\n           * x --> k\\n           * y --> i\\n           */\\n          ++smaller_than_k;\\n          /**\\n           * x --> l\\n           * y --> j\\n           */\\n          ret += dp[y];\\n        } else {\\n          // nums[x] < nums[y]\\n          /**\\n           * x --> k\\n           * y --> j\\n           */\\n          dp[y] += smaller_than_k;\\n        }\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n * n)\\n * Space Complexity: O(n * n)\\n * where `n` is the length of the vector `nums`\\n */\\nclass Solution {\\n public:\\n  long long countQuadruplets(const vector<int> &nums) {\\n    const int n = static_cast<int>(nums.size());\\n    vector<int> dp_less(n * n);\\n    for (int prev_j = 0; prev_j < n; ++prev_j) {\\n      for (int k = 0; k < n; ++k) {\\n        dp_less[prev_j * n + k] = (prev_j == 0 ? 0 : dp_less[(prev_j - 1) * n + k]) + (nums[prev_j] < nums[k] ? 1 : 0);\\n      }\\n    }\\n    \\n    vector<int> dp_greater(n * n);\\n    for (int post_k = n - 1; post_k > -1; --post_k) {\\n      for (int j = 0; j < n; ++j) {\\n        dp_greater[post_k * n + j] = (post_k == n - 1 ? 0 : dp_greater[(post_k + 1) * n + j]) + (nums[post_k] > nums[j] ? 1 : 0);\\n      }\\n    }\\n\\n    long long ret = 0LL;\\n    for (int j = 1; j < n - 2; ++j) {\\n      for (int k = j + 1; k < n - 1; ++k) {\\n        if (nums[j] > nums[k]) {\\n          ret += dp_less[(j - 1) * n + k] * dp_greater[(k + 1) * n + j];\\n        }\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```\n```\\n/**\\n * Time Complexity: O(n * n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `nums`\\n */\\nclass Solution {\\n public:\\n  long long countQuadruplets(const vector<int> &nums) {\\n    const int n = static_cast<int>(nums.size());\\n    /**\\n     * dp[j] means the count of the triplets (i, j, k),\\n     *             where i < j < k and nums[i] < nums[k] < nums[j]\\n     */\\n    int dp[n];\\n    memset(dp, 0, sizeof(dp));\\n    long long ret = 0;\\n    for (int x = 2; x < n; ++x) {\\n      int smaller_than_k = 0;\\n      for (int y = 0; y < x; ++y) {\\n        if (nums[x] > nums[y]) {\\n          /**\\n           * x --> k\\n           * y --> i\\n           */\\n          ++smaller_than_k;\\n          /**\\n           * x --> l\\n           * y --> j\\n           */\\n          ret += dp[y];\\n        } else {\\n          // nums[x] < nums[y]\\n          /**\\n           * x --> k\\n           * y --> j\\n           */\\n          dp[y] += smaller_than_k;\\n        }\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3147436,
                "title": "doubt",
                "content": "```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\nusing namespace std;\\n#define ll long long\\n#define ordered_set tree<ll, null_type,less, rb_tree_tag,tree_order_statistics_node_update>\\nclass Solution {\\npublic:\\n\\n\\tll countQuadruplets(vector<int>& nums) {\\n\\t\\tint n=nums.size();\\n\\t\\tios_base::sync_with_stdio(false);\\n\\t\\tcin.tie(NULL);\\n\\t\\tcout.tie(NULL);\\n\\t\\tlong long res=0;\\n\\t\\tvector<ll>cnt(n,0);\\n\\t\\tfor (int j=0;j<n;j++){\\n\\t\\t\\tordered_set st_right;\\n\\t\\t\\tfor (int k=n-1;k>j;k--){\\n\\t\\t\\t\\tif (nums[k]<nums[j]){\\n\\t\\t\\t\\t\\tll cnt_right=n-1-k-st_right.order_of_key(nums[j]);\\n\\t\\t\\t\\t\\tll cnt_left=cnt[k];\\n\\t\\t\\t\\t\\tres+=cnt_right*cnt_left;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse cnt[k]++;\\n\\t\\t\\t\\tst_right.insert(nums[k]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n};\\n```\\n\\nThis code is almost similar to the ordered_set solutions above, but this fails at the 118th text case for no obvious reason. Does anyone have a clue why?",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\nusing namespace std;\\n#define ll long long\\n#define ordered_set tree<ll, null_type,less, rb_tree_tag,tree_order_statistics_node_update>\\nclass Solution {\\npublic:\\n\\n\\tll countQuadruplets(vector<int>& nums) {\\n\\t\\tint n=nums.size();\\n\\t\\tios_base::sync_with_stdio(false);\\n\\t\\tcin.tie(NULL);\\n\\t\\tcout.tie(NULL);\\n\\t\\tlong long res=0;\\n\\t\\tvector<ll>cnt(n,0);\\n\\t\\tfor (int j=0;j<n;j++){\\n\\t\\t\\tordered_set st_right;\\n\\t\\t\\tfor (int k=n-1;k>j;k--){\\n\\t\\t\\t\\tif (nums[k]<nums[j]){\\n\\t\\t\\t\\t\\tll cnt_right=n-1-k-st_right.order_of_key(nums[j]);\\n\\t\\t\\t\\t\\tll cnt_left=cnt[k];\\n\\t\\t\\t\\t\\tres+=cnt_right*cnt_left;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse cnt[k]++;\\n\\t\\t\\t\\tst_right.insert(nums[k]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3142802,
                "title": "1sentence-dp-keep-the-number-of-good-i-j-k-and-the-number-of-good-i-k",
                "content": "# Code\\n```\\nimport numpy as np\\n\\nclass Solution:\\n    def countQuadruplets(self, A: List[int]) -> int:\\n        n = len(A)\\n        dp = [0]*n  # Number of growing i->k->j ending at j.\\n        res = 0\\n        for j, v in enumerate(A):\\n            cnt = 0   # cnt_j counts A[i] < A[j] seen so far\\n            for i in range(j):\\n                if A[i] > v:\\n                    dp[i] += cnt  # (we found cnt of {i},j,k = (optimised),i,k)\\n                else:\\n                    res += dp[i]  # our i,j = desc j,l ; \\n                    cnt += 1      # our i,j = desc i,k\\n        return res\\n                    \\n\\nclass Solution2:\\n    def countQuadruplets(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        pre  = [[0] * n for _ in range(n)]   #np.zeros((n,n), dtype=int)\\n        post = [[0] * n for _ in range(n)]   #np.zeros((n,n), dtype=int)\\n        for k in range(2, n-1):\\n            cum = int(nums[0] < nums[k])\\n            for j in range(1, k):\\n                if nums[j] > nums[k]:\\n                    pre[k][j] = cum\\n                cum += int(nums[j] < nums[k])\\n        for j in range(n-3, 0, -1):\\n            cum = int(nums[n-1] > nums[j])\\n            for k in range(n-2, j, -1):\\n                if nums[j] > nums[k]:\\n                    post[k][j] = cum\\n                cum += int(nums[k] > nums[j])\\n        #print(pre)\\n        #print(post)\\n        ret = 0\\n        for k in range(2, n-1):\\n            for j in range(n-3, 0, -1):\\n                ret += pre[k][j] * post[k][j]\\n        return ret\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport numpy as np\\n\\nclass Solution:\\n    def countQuadruplets(self, A: List[int]) -> int:\\n        n = len(A)\\n        dp = [0]*n  # Number of growing i->k->j ending at j.\\n        res = 0\\n        for j, v in enumerate(A):\\n            cnt = 0   # cnt_j counts A[i] < A[j] seen so far\\n            for i in range(j):\\n                if A[i] > v:\\n                    dp[i] += cnt  # (we found cnt of {i},j,k = (optimised),i,k)\\n                else:\\n                    res += dp[i]  # our i,j = desc j,l ; \\n                    cnt += 1      # our i,j = desc i,k\\n        return res\\n                    \\n\\nclass Solution2:\\n    def countQuadruplets(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        pre  = [[0] * n for _ in range(n)]   #np.zeros((n,n), dtype=int)\\n        post = [[0] * n for _ in range(n)]   #np.zeros((n,n), dtype=int)\\n        for k in range(2, n-1):\\n            cum = int(nums[0] < nums[k])\\n            for j in range(1, k):\\n                if nums[j] > nums[k]:\\n                    pre[k][j] = cum\\n                cum += int(nums[j] < nums[k])\\n        for j in range(n-3, 0, -1):\\n            cum = int(nums[n-1] > nums[j])\\n            for k in range(n-2, j, -1):\\n                if nums[j] > nums[k]:\\n                    post[k][j] = cum\\n                cum += int(nums[k] > nums[j])\\n        #print(pre)\\n        #print(post)\\n        ret = 0\\n        for k in range(2, n-1):\\n            for j in range(n-3, 0, -1):\\n                ret += pre[k][j] * post[k][j]\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3138637,
                "title": "c-o-n-2-solution",
                "content": "# Approach\\n\\nI thought this problem as this way: we pick a pair `(j, k)`. We switch those numbers. Then, `nums[i] < nums[j] < nums[k] < nums[l]` should be satisfied. We should count how many numbers can be `i`th and `l`th number seperately. We multiply them, and that\\'s the answer for the pair. There are at most $$O(n^2)$$ pairs, so it should take $$O(1)$$ for each pair. Preprocessing to that takes $$O(n^2)$$.\\n\\nWe should store how many numbers are less than specific number under specific index. `dyn[k][j]` means if `k`th number goes to `j`th number, how many numbers can be `i`th number. This is only when `j < k`. If `j > k`, we switch `k` and `j`, so `dyn[j][k]` means if `j`th number goes to `k`th number, how many numbers can be `l`th number. Conditions that some number can be `i`th and `j`th number are different.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& nums) {\\n\\n        // if i > j, dyn[i][j] means dyn[k][j].\\n        //   moves kth number to jth position, and count i such that i < j and nums[i] < nums[k]\\n        // if i < j, dyn[i][j] means dyn[j][k].\\n        //   moves jth number to kth position, and count l such that k < l and nums[j] < nums[l]\\n        vector<vector<long long>> dyn(nums.size(), vector<long long>(nums.size(), 0));\\n\\n        // we start i=1 because second element can\\'t be zero.\\n        for(int i = 1; i < nums.size() - 1; i++){\\n            \\n            // this is case i > j\\n            // think we moved kth number to jth position, and count possible `i`s.\\n            long long sum = 0;\\n            for (int j = 1; j < i; j++){\\n                if (nums[j - 1] < nums[i]){\\n                    sum++;\\n                }\\n                dyn[i][j] = sum;\\n            }\\n\\n            // this is case i < j\\n            sum = 0;\\n            for (int j = nums.size() - 2; j > i; j--){\\n                if (nums[j + 1] > nums[i]){\\n                    sum++;\\n                }\\n                dyn[i][j] = sum;\\n            }\\n        }\\n\\n        // we look at every pair (j, k)\\n        // for each pair (j, k),\\n        //   there are dyn[k][j] cases of i.\\n        //   there are dyn[j][k] cases of l.\\n        long long ans = 0;\\n        for(int j = 1; j < nums.size() - 1; j++){\\n            for(int k = j + 1; k < nums.size() - 1; k++){\\n                // for j < k, nums[j] > nums[k] should be satisfied.\\n                if (nums[j] < nums[k]) continue;\\n                ans += dyn[j][k] * dyn[k][j];\\n            }\\n        }\\n\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& nums) {\\n\\n        // if i > j, dyn[i][j] means dyn[k][j].\\n        //   moves kth number to jth position, and count i such that i < j and nums[i] < nums[k]\\n        // if i < j, dyn[i][j] means dyn[j][k].\\n        //   moves jth number to kth position, and count l such that k < l and nums[j] < nums[l]\\n        vector<vector<long long>> dyn(nums.size(), vector<long long>(nums.size(), 0));\\n\\n        // we start i=1 because second element can\\'t be zero.\\n        for(int i = 1; i < nums.size() - 1; i++){\\n            \\n            // this is case i > j\\n            // think we moved kth number to jth position, and count possible `i`s.\\n            long long sum = 0;\\n            for (int j = 1; j < i; j++){\\n                if (nums[j - 1] < nums[i]){\\n                    sum++;\\n                }\\n                dyn[i][j] = sum;\\n            }\\n\\n            // this is case i < j\\n            sum = 0;\\n            for (int j = nums.size() - 2; j > i; j--){\\n                if (nums[j + 1] > nums[i]){\\n                    sum++;\\n                }\\n                dyn[i][j] = sum;\\n            }\\n        }\\n\\n        // we look at every pair (j, k)\\n        // for each pair (j, k),\\n        //   there are dyn[k][j] cases of i.\\n        //   there are dyn[j][k] cases of l.\\n        long long ans = 0;\\n        for(int j = 1; j < nums.size() - 1; j++){\\n            for(int k = j + 1; k < nums.size() - 1; k++){\\n                // for j < k, nums[j] > nums[k] should be satisfied.\\n                if (nums[j] < nums[k]) continue;\\n                ans += dyn[j][k] * dyn[k][j];\\n            }\\n        }\\n\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3136578,
                "title": "c-dynamic-programming",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        // {j, i} number of element less than i from (0 to j)\\n        vector<vector<int>> pref(n, vector<int>(n+1, 0));\\n        for(int j = 0; j < n; j++) {\\n            if(j > 0)\\n                pref[j] = pref[j-1];\\n            for(int i = nums[j]+1; i <= n; i++)\\n                pref[j][i] += 1;\\n        }\\n\\n        // {j, i} number of element greater than i from (j to n-1)\\n        vector<vector<int>> suff(n, vector<int>(n+1, 0));\\n        for(int j = n-1; j >= 0; j--) {\\n            if(j < n-1)\\n                suff[j] = suff[j+1];\\n            for(int i = nums[j]-1; i >= 1; i--)\\n                suff[j][i] += 1;\\n        }\\n\\n        // calculate for all (j, k)\\n        long long ans = 0;\\n        for(int j = 1; j < n-2; j++) {\\n            for(int k = j + 1; k < n-1; k++) {\\n                if(nums[j] > nums[k]) {\\n                    int a = nums[k];\\n                    int b = nums[j];\\n                    ans += (1LL * pref[j-1][a] * suff[k+1][b]);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        // {j, i} number of element less than i from (0 to j)\\n        vector<vector<int>> pref(n, vector<int>(n+1, 0));\\n        for(int j = 0; j < n; j++) {\\n            if(j > 0)\\n                pref[j] = pref[j-1];\\n            for(int i = nums[j]+1; i <= n; i++)\\n                pref[j][i] += 1;\\n        }\\n\\n        // {j, i} number of element greater than i from (j to n-1)\\n        vector<vector<int>> suff(n, vector<int>(n+1, 0));\\n        for(int j = n-1; j >= 0; j--) {\\n            if(j < n-1)\\n                suff[j] = suff[j+1];\\n            for(int i = nums[j]-1; i >= 1; i--)\\n                suff[j][i] += 1;\\n        }\\n\\n        // calculate for all (j, k)\\n        long long ans = 0;\\n        for(int j = 1; j < n-2; j++) {\\n            for(int k = j + 1; k < n-1; k++) {\\n                if(nums[j] > nums[k]) {\\n                    int a = nums[k];\\n                    int b = nums[j];\\n                    ans += (1LL * pref[j-1][a] * suff[k+1][b]);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3130779,
                "title": "c-precomputation-fix-two-indexes",
                "content": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    \\n    vector<vector<ll>> calculateBefore(vector<int> &arr){\\n        int n = arr.size();\\n        \\n        // result[i][j].\\n        // - \\'i\\' > \\'j\\'\\n        // - how many indexes are there before \\'j\\' which are less than arr[i].\\n        \\n        // Took this array for prefix sum.\\n        vector<vector<ll>> result(n, vector<ll> (n, 0));\\n        \\n        for(int i = 0;i < n;i++){\\n            for(int j = 0;j < i;j++){\\n                // Prefix sum approach.\\n                result[i][j] = (j > 0) ? result[i][j - 1] : 0;\\n                if(arr[i] > arr[j]) result[i][j]++;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    vector<vector<ll>> calculateAfter(vector<int> &arr){\\n        \\n        int n = arr.size();\\n        \\n        // result[i][j]\\n        // result[j][k + 1];\\n        \\n        // - \\'\\' < \\'\\'\\n        // - how many indexes are there after j which are greater than nums[i].\\n        \\n        vector<vector<ll>> result(n, vector<ll>(n, 0));\\n        \\n        for(int j = 1;j < (n);j++){\\n            for(int k = n - 1;k > j;k--){\\n                result[j][k] = (k + 1 < n) ? result[j][k + 1] : 0;\\n                if(arr[k] > arr[j]) result[j][k]++;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    long long countQuadruplets(vector<int>& nums) {\\n        // Here we can have time complexity upto O(n^2).\\n        // There we can only fix at max 2 tuples.\\n        \\n        // Which two tuples to fix.\\n        // For that first analyse how we can optimise the simplified problem.\\n        // Let\\'s say for i < j < k.\\n        // nums[i] < nums[j] < nums[k], find the number of such triplets.\\n        // This can be easily done using three for loops. in O(n^3) time complexity.\\n        \\n        // Fixing i and j and then calculation all such k\\'s for which nums[k] > nums[j].\\n        // This can be easily done by using calculateAfter().\\n        \\n        // CalculateAfter will also take a time complexity of O(n^2).\\n        // This time complexity can be reduced down to O(n * log(n)).\\n        \\n        // Now can we reduce the calculation much further.\\n        // So the answer is yes. If we fix j and for j calculate the before_smaller as \\n        // well then for that j, the answer will be after_greater[j + 1] * before_smaller[j - 1].\\n        \\n        // Now let\\'s look at the larger problem, which two tuples to fix.\\n        // i and j. No because then after values for k still l remains(by method of after).\\n        // i and k. k ke liye l can compute ho jaayenga in O(n^2), but the calculation of\\n        // but for computation of j, i and k are changing and we have to traverse between \\n        // i and k to find satisfying values of j which will take O(n^3).\\n\\n        // j and k. let\\'s see. If we fix k, computation of l is sorted. and for computation of\\n        // i we take help of j. Through this we can compute the answer in O(n^2).\\n        \\n        // Now let\\'s start.\\n        int n = nums.size();\\n        \\n        vector<vector<ll>> before_smaller = calculateBefore(nums);\\n        vector<vector<ll>> after_greater = calculateAfter(nums);\\n        \\n        ll result = 0;\\n        for(int j = 1;j < (n - 2);j++){\\n            for(int k = j + 1;k < n - 1;k++){\\n                if(nums[j] <= nums[k]) continue;\\n                \\n                result += (before_smaller[k][j - 1] * after_greater[j][k + 1]);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Enumeration",
                    "Prefix Sum"
                ],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    \\n    vector<vector<ll>> calculateBefore(vector<int> &arr){\\n        int n = arr.size();\\n        \\n        // result[i][j].\\n        // - \\'i\\' > \\'j\\'\\n        // - how many indexes are there before \\'j\\' which are less than arr[i].\\n        \\n        // Took this array for prefix sum.\\n        vector<vector<ll>> result(n, vector<ll> (n, 0));\\n        \\n        for(int i = 0;i < n;i++){\\n            for(int j = 0;j < i;j++){\\n                // Prefix sum approach.\\n                result[i][j] = (j > 0) ? result[i][j - 1] : 0;\\n                if(arr[i] > arr[j]) result[i][j]++;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    vector<vector<ll>> calculateAfter(vector<int> &arr){\\n        \\n        int n = arr.size();\\n        \\n        // result[i][j]\\n        // result[j][k + 1];\\n        \\n        // - \\'\\' < \\'\\'\\n        // - how many indexes are there after j which are greater than nums[i].\\n        \\n        vector<vector<ll>> result(n, vector<ll>(n, 0));\\n        \\n        for(int j = 1;j < (n);j++){\\n            for(int k = n - 1;k > j;k--){\\n                result[j][k] = (k + 1 < n) ? result[j][k + 1] : 0;\\n                if(arr[k] > arr[j]) result[j][k]++;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    long long countQuadruplets(vector<int>& nums) {\\n        // Here we can have time complexity upto O(n^2).\\n        // There we can only fix at max 2 tuples.\\n        \\n        // Which two tuples to fix.\\n        // For that first analyse how we can optimise the simplified problem.\\n        // Let\\'s say for i < j < k.\\n        // nums[i] < nums[j] < nums[k], find the number of such triplets.\\n        // This can be easily done using three for loops. in O(n^3) time complexity.\\n        \\n        // Fixing i and j and then calculation all such k\\'s for which nums[k] > nums[j].\\n        // This can be easily done by using calculateAfter().\\n        \\n        // CalculateAfter will also take a time complexity of O(n^2).\\n        // This time complexity can be reduced down to O(n * log(n)).\\n        \\n        // Now can we reduce the calculation much further.\\n        // So the answer is yes. If we fix j and for j calculate the before_smaller as \\n        // well then for that j, the answer will be after_greater[j + 1] * before_smaller[j - 1].\\n        \\n        // Now let\\'s look at the larger problem, which two tuples to fix.\\n        // i and j. No because then after values for k still l remains(by method of after).\\n        // i and k. k ke liye l can compute ho jaayenga in O(n^2), but the calculation of\\n        // but for computation of j, i and k are changing and we have to traverse between \\n        // i and k to find satisfying values of j which will take O(n^3).\\n\\n        // j and k. let\\'s see. If we fix k, computation of l is sorted. and for computation of\\n        // i we take help of j. Through this we can compute the answer in O(n^2).\\n        \\n        // Now let\\'s start.\\n        int n = nums.size();\\n        \\n        vector<vector<ll>> before_smaller = calculateBefore(nums);\\n        vector<vector<ll>> after_greater = calculateAfter(nums);\\n        \\n        ll result = 0;\\n        for(int j = 1;j < (n - 2);j++){\\n            for(int k = j + 1;k < n - 1;k++){\\n                if(nums[j] <= nums[k]) continue;\\n                \\n                result += (before_smaller[k][j - 1] * after_greater[j][k + 1]);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3126655,
                "title": "no-dp-pbds-o-n-n-short-and-concise",
                "content": "# Intuition\\nWhenever such type of questions come, try to solve it for some particular index or indices, here I\\'m solving for middle two indices with 2 rules\\n\\n# Approach\\nWe have i < j < k < l && A[i] < A[k] < A[j] < A[l], we can see only positions of j and k changes, so if somehow we can take advantage of this it would be nice.\\nWe find how many elements are smaller than A[k] before index j those are possible i indexes, similarly we find how many elements are larger than A[j] after index k those are possible l indexes. Now we just multiply those and add it to answer.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n * n)$$\\n\\n- Space complexity:\\n$$O(n * n)$$\\n\\n# Code\\n```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\n\\n#define ordered_set tree<int, null_type, less_equal<int>, rb_tree_tag,tree_order_statistics_node_update>\\n#define ordered_set1 tree<int, null_type, greater_equal<int>, rb_tree_tag,tree_order_statistics_node_update>\\n\\nusing namespace __gnu_pbds;\\n\\n\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& A) {\\n        int n = A.size();\\n        long long ans = 0;\\n\\n        vector <int> small_index[n], large_index[n];\\n\\n        for(int j = 0; j < n; j++) {\\n            for(int k = j + 1; k < n; k++) {\\n                if(A[k] < A[j]) {\\n                    small_index[j].push_back(k);\\n                    large_index[k].push_back(j);\\n                }\\n            }\\n        }\\n\\n        vector <vector <int>> small_ans(n, vector <int> (n));\\n        vector <vector <int>> large_ans(n, vector <int> (n));\\n\\n        ordered_set s1;\\n        for(int i = 0; i < n; i++) {\\n            for(auto &j : small_index[i]) {\\n                small_ans[i][j] = s1.order_of_key(A[j]);\\n            }\\n            s1.insert(A[i]);\\n        }\\n\\n        ordered_set1 s2;\\n        for(int i = n - 1; i >= 0; i--) {\\n            for(auto &j : large_index[i]) {\\n                large_ans[i][j] = s2.order_of_key(A[j]);\\n            }\\n            s2.insert(A[i]);\\n        }\\n\\n        for(int j = 0; j < n; j++) {\\n            for(int k = j + 1; k < n; k++) {\\n                if(A[k] < A[j]) {\\n                    ans += small_ans[j][k] * large_ans[k][j];\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\n\\n#define ordered_set tree<int, null_type, less_equal<int>, rb_tree_tag,tree_order_statistics_node_update>\\n#define ordered_set1 tree<int, null_type, greater_equal<int>, rb_tree_tag,tree_order_statistics_node_update>\\n\\nusing namespace __gnu_pbds;\\n\\n\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& A) {\\n        int n = A.size();\\n        long long ans = 0;\\n\\n        vector <int> small_index[n], large_index[n];\\n\\n        for(int j = 0; j < n; j++) {\\n            for(int k = j + 1; k < n; k++) {\\n                if(A[k] < A[j]) {\\n                    small_index[j].push_back(k);\\n                    large_index[k].push_back(j);\\n                }\\n            }\\n        }\\n\\n        vector <vector <int>> small_ans(n, vector <int> (n));\\n        vector <vector <int>> large_ans(n, vector <int> (n));\\n\\n        ordered_set s1;\\n        for(int i = 0; i < n; i++) {\\n            for(auto &j : small_index[i]) {\\n                small_ans[i][j] = s1.order_of_key(A[j]);\\n            }\\n            s1.insert(A[i]);\\n        }\\n\\n        ordered_set1 s2;\\n        for(int i = n - 1; i >= 0; i--) {\\n            for(auto &j : large_index[i]) {\\n                large_ans[i][j] = s2.order_of_key(A[j]);\\n            }\\n            s2.insert(A[i]);\\n        }\\n\\n        for(int j = 0; j < n; j++) {\\n            for(int k = j + 1; k < n; k++) {\\n                if(A[k] < A[j]) {\\n                    ans += small_ans[j][k] * large_ans[k][j];\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3122865,
                "title": "c-dp",
                "content": "**Intuition**\\nWe need to focus on two center elements i.e., `nums[j] > nums[k]`, where `j < k`.\\nThe ans will be: \\n`elements greater than nums[j] after nums[k] * elements smaller than nums[k] before nums[j]`.\\n\\n**Approach**\\nSolution is based upon [RealFan\\'s Solution](https://leetcode.com/problems/count-increasing-quadruplets/solutions/3111829/C++ororJavaororPythonEnumerate-All-(jk)-Pairs-with-O(n)-Complexity/).\\n\\n**Complexity**\\nTime complexity: $$O(n ^ 2)$$\\nSpace complexity: $$O(n ^ 2)$$\\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    long long countQuadruplets(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> suf(n, vector<int> (n + 1, 0));\\n        vector<vector<int>> pre(n, vector<int> (n + 1, 0));\\n        for(int l = n - 2; l >= 0; l--) {\\n            suf[l] = suf[l + 1];\\n            for (int ele = 0; ele < nums[l + 1]; ele++) {\\n                suf[l][ele]++;\\n            }\\n        }      \\n        for(int i = 1; i < n; i++) {\\n            pre[i] = pre[i - 1];\\n            for(int ele = nums[i - 1] + 1; ele <= n; ele++) {\\n                pre[i][ele]++;\\n            }\\n        } \\n        ll ans = 0;\\n        for(int j = 1; j < n - 2; j++) {\\n            for(int k = j + 1; k < n - 1; k++) {\\n                if(nums[j] > nums[k]) {\\n                    ans += (pre[j][nums[k]] * suf[k][nums[j]]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    long long countQuadruplets(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> suf(n, vector<int> (n + 1, 0));\\n        vector<vector<int>> pre(n, vector<int> (n + 1, 0));\\n        for(int l = n - 2; l >= 0; l--) {\\n            suf[l] = suf[l + 1];\\n            for (int ele = 0; ele < nums[l + 1]; ele++) {\\n                suf[l][ele]++;\\n            }\\n        }      \\n        for(int i = 1; i < n; i++) {\\n            pre[i] = pre[i - 1];\\n            for(int ele = nums[i - 1] + 1; ele <= n; ele++) {\\n                pre[i][ele]++;\\n            }\\n        } \\n        ll ans = 0;\\n        for(int j = 1; j < n - 2; j++) {\\n            for(int k = j + 1; k < n - 1; k++) {\\n                if(nums[j] > nums[k]) {\\n                    ans += (pre[j][nums[k]] * suf[k][nums[j]]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3121770,
                "title": "c-find-who-can-become-third-value",
                "content": "# Observation\\n- So for non optimize approach we can use `Backtracking` or simply brute force\\n- But here is some catch in this problem if we able to find pair of three or some perticular index how many time can become third elemnt of tuple so we can easly find some value which is greater than third value and have greater index also\\n\\n# Complexity\\n- Time complexity: $$O(N^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& nums) {\\n        int n=nums.size();\\n\\n        //dp is for counting third value\\n        vector<int> dp(n,0);\\n        long long ans=0;\\n        for(int i=0;i<n;i++){\\n            int prev_small=0;   //for first value and ith is third\\n            for(int j=0;j<i;j++){\\n                if(nums[i]>nums[j]){\\n                    prev_small++;\\n\\n                    //if jth index can able to become third value\\n                    ans+=dp[j];\\n                }\\n                else if(nums[i]<nums[j]){\\n                    //so here i>j and nums[i]<nums[j] so out jth can be third value\\n                    dp[j]+=prev_small;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& nums) {\\n        int n=nums.size();\\n\\n        //dp is for counting third value\\n        vector<int> dp(n,0);\\n        long long ans=0;\\n        for(int i=0;i<n;i++){\\n            int prev_small=0;   //for first value and ith is third\\n            for(int j=0;j<i;j++){\\n                if(nums[i]>nums[j]){\\n                    prev_small++;\\n\\n                    //if jth index can able to become third value\\n                    ans+=dp[j];\\n                }\\n                else if(nums[i]<nums[j]){\\n                    //so here i>j and nums[i]<nums[j] so out jth can be third value\\n                    dp[j]+=prev_small;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3121191,
                "title": "prefix-count-and-suffix-count-o-n-2-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n       vector<vector<int>> left_small(n,vector<int>(n,0)),right_large(n,vector<int>(n,0));\\n        \\n        for(int i=1;i<n-1;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                if(nums[j]<nums[i])\\n                {\\n                    if(j==0){\\n                        left_small[i][j] =1;\\n                      }\\n                    else\\n                    {\\n                        left_small[i][j] = 1+left_small[i][j-1]; \\n                    }\\n                }\\n                else\\n                {\\n                    if(j!=0)\\n                    {\\n                     left_small[i][j] = left_small[i][j-1]; \\n                    }\\n                }\\n            }\\n        }\\n        \\n        for(int i=n-2;i>0;i--)\\n        {\\n            for(int j=n-1;j>i;j--)\\n            {\\n                if(nums[j]>nums[i])\\n                {\\n                    if(j==n-1)\\n                    {\\n                        right_large[i][j] = 1;\\n                    }\\n                    else\\n                    {\\n                        right_large[i][j]= 1+right_large[i][j+1];\\n                    }\\n                }\\n                else\\n                {\\n                    if(j!=n-1)\\n                    {\\n                        right_large[i][j]= right_large[i][j+1];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        \\n        long long res=0;\\n        for(int j=1;j<n-1;j++)\\n        {\\n            for(int k=j+1;k<n-1;k++)\\n            {\\n                if(nums[j] > nums[k])\\n                {\\n                    res = res + left_small[k][j]*right_large[j][k];\\n                }\\n            }\\n        }\\n         return res;  \\n           \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n       vector<vector<int>> left_small(n,vector<int>(n,0)),right_large(n,vector<int>(n,0));\\n        \\n        for(int i=1;i<n-1;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                if(nums[j]<nums[i])\\n                {\\n                    if(j==0){\\n                        left_small[i][j] =1;\\n                      }\\n                    else\\n                    {\\n                        left_small[i][j] = 1+left_small[i][j-1]; \\n                    }\\n                }\\n                else\\n                {\\n                    if(j!=0)\\n                    {\\n                     left_small[i][j] = left_small[i][j-1]; \\n                    }\\n                }\\n            }\\n        }\\n        \\n        for(int i=n-2;i>0;i--)\\n        {\\n            for(int j=n-1;j>i;j--)\\n            {\\n                if(nums[j]>nums[i])\\n                {\\n                    if(j==n-1)\\n                    {\\n                        right_large[i][j] = 1;\\n                    }\\n                    else\\n                    {\\n                        right_large[i][j]= 1+right_large[i][j+1];\\n                    }\\n                }\\n                else\\n                {\\n                    if(j!=n-1)\\n                    {\\n                        right_large[i][j]= right_large[i][j+1];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        \\n        long long res=0;\\n        for(int j=1;j<n-1;j++)\\n        {\\n            for(int k=j+1;k<n-1;k++)\\n            {\\n                if(nums[j] > nums[k])\\n                {\\n                    res = res + left_small[k][j]*right_large[j][k];\\n                }\\n            }\\n        }\\n         return res;  \\n           \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3119306,
                "title": "binary-search-approach",
                "content": "# Approach\\nFixed k and find all the (i,j) pairs on its left . The sorted the array and apply binary search on  right side of k to find all j less than arr[l].\\n\\n# Complexity\\n- Time complexity:\\nO(n^2 * logn)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long bs(vector<pair<int,int>>& v,int n){\\n        int s=0,e=v.size()-1,mid;\\n        while(s<=e){\\n            mid = (s+e)/2;\\n            if(v[mid].first>=n)e=mid-1;\\n            else s=mid+1;\\n        }\\n        if(e<0)return 0;\\n        return v[e].second;\\n        \\n    }\\n    long long countQuadruplets(vector<int>& nums) {\\n        long long ans=0;\\n        int n = nums.size();\\n        for(int k=n-2;k>=2;k--){\\n            vector<pair<int,int>> v;\\n            for(int j=0;j<k;j++){\\n                if(nums[j]>nums[k])\\n                    v.push_back({nums[j],j-v.size()});\\n            }\\n             sort(v.begin(),v.end());\\n            for(int p=1;p<v.size();p++){\\n                v[p].second+=v[p-1].second;\\n            }\\n            for(int l = k+1;l<n;l++){\\n                if(nums[l]>nums[k]){\\n                    ans+=bs(v,nums[l]);\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long bs(vector<pair<int,int>>& v,int n){\\n        int s=0,e=v.size()-1,mid;\\n        while(s<=e){\\n            mid = (s+e)/2;\\n            if(v[mid].first>=n)e=mid-1;\\n            else s=mid+1;\\n        }\\n        if(e<0)return 0;\\n        return v[e].second;\\n        \\n    }\\n    long long countQuadruplets(vector<int>& nums) {\\n        long long ans=0;\\n        int n = nums.size();\\n        for(int k=n-2;k>=2;k--){\\n            vector<pair<int,int>> v;\\n            for(int j=0;j<k;j++){\\n                if(nums[j]>nums[k])\\n                    v.push_back({nums[j],j-v.size()});\\n            }\\n             sort(v.begin(),v.end());\\n            for(int p=1;p<v.size();p++){\\n                v[p].second+=v[p-1].second;\\n            }\\n            for(int l = k+1;l<n;l++){\\n                if(nums[l]>nums[k]){\\n                    ans+=bs(v,nums[l]);\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3119208,
                "title": "java-easy-solution-with-explanation-loop-all-possible-j-and-k-using-binary-search-to-find-l",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor all the combination of the j and k, find how many i and l possibility.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor loop, k is from the second one from last to the third one from left. (That\\'s all the possible cases for k).\\nUsing a sorted list to store all the numbers after current k. Every time when move k to one step left, just use binary search to add the new one to its correct index.\\nInside k\\'s loop, let j from second number to the one just left to k.\\nWe can easily tell how many i\\'s are smaller than k since k won\\'t change when starting looping j.\\nAnd use binary search again to find out how many l\\'s in the sorted list is smaller than j.\\nAdd them together will get the final answer.\\n# Complexity\\n- Time complexity: n * n * log(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long countQuadruplets(int[] nums) {\\n        long count = 0;\\n        int n = nums.length;\\n        List<Integer> l = new ArrayList();\\n        for (int k = n - 2; k >= 2; k--) {\\n        \\tint addIndex = Collections.binarySearch(l, nums[k + 1]);\\n        \\tl.add(-1 - addIndex, nums[k + 1]);\\n        \\tint i = nums[0] < nums[k] ? 1 : 0;\\n        \\tfor (int j = 1; j < k; j++) {\\n        \\t\\tif (nums[j] > nums[k]) {\\n        \\t\\t\\tif (i > 0) {\\n        \\t\\t\\t\\tint index = -1 - Collections.binarySearch(l, nums[j]);\\n        \\t\\t\\t\\tcount += 1L * i * (l.size() - index);\\n        \\t\\t\\t}\\n        \\t\\t} else\\n        \\t\\t\\ti++;\\n        \\t}\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long countQuadruplets(int[] nums) {\\n        long count = 0;\\n        int n = nums.length;\\n        List<Integer> l = new ArrayList();\\n        for (int k = n - 2; k >= 2; k--) {\\n        \\tint addIndex = Collections.binarySearch(l, nums[k + 1]);\\n        \\tl.add(-1 - addIndex, nums[k + 1]);\\n        \\tint i = nums[0] < nums[k] ? 1 : 0;\\n        \\tfor (int j = 1; j < k; j++) {\\n        \\t\\tif (nums[j] > nums[k]) {\\n        \\t\\t\\tif (i > 0) {\\n        \\t\\t\\t\\tint index = -1 - Collections.binarySearch(l, nums[j]);\\n        \\t\\t\\t\\tcount += 1L * i * (l.size() - index);\\n        \\t\\t\\t}\\n        \\t\\t} else\\n        \\t\\t\\ti++;\\n        \\t}\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3117606,
                "title": "easy-to-understand-and-intuitive-c-code",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n      vector<vector<int>>ls(n,vector<int>(n,0));\\nvector<vector<int>>rs(n,vector<int>(n,0));\\n        for(int j=1;j<n;j++)\\n        {\\n           long long int count=0;\\n            for(int i=0;i<j;i++)\\n            {\\n                if(nums[i]<nums[j])\\n                count++;\\n  ls[j][i]=count;//No of elements less than nums[j] and lying from 0 to i\\n            }\\n          \\n        }\\n\\n        for(int k=0;k<n;k++)\\n        {\\n          long long  int count =0;\\n            for(int l=n-1;l>k;l--)\\n            {\\n                if(nums[l]>nums[k])\\n                count++;\\n                rs[k][l]=count;//No of elements greater than nums[k] and lying from l to n-1\\n            }\\n            \\n        }\\nlong long ans=0;\\n        for(int j=1;j<n-2;j++)\\n        {\\n            for(int k=n-2;k>1;k--)\\n            {\\n                if(nums[k]<nums[j])\\n                {\\n                    ans+=ls[k][j-1]*rs[j][k+1];//since nums[j] is placed after nums[k], for nums[j] we need all elements greatr than nums[j] but lyng in range k+1 to n-1, since their indices shld be greater than k.Similarly nums[k] lies before nums[j] and after nums[i], so we need all elements less than nums[k] but in range 0 to j-1, since indices order is i<j<k<l.\\n                }\\n        }\\n        }\\n        return ans;    \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n      vector<vector<int>>ls(n,vector<int>(n,0));\\nvector<vector<int>>rs(n,vector<int>(n,0));\\n        for(int j=1;j<n;j++)\\n        {\\n           long long int count=0;\\n            for(int i=0;i<j;i++)\\n            {\\n                if(nums[i]<nums[j])\\n                count++;\\n  ls[j][i]=count;//No of elements less than nums[j] and lying from 0 to i\\n            }\\n          \\n        }\\n\\n        for(int k=0;k<n;k++)\\n        {\\n          long long  int count =0;\\n            for(int l=n-1;l>k;l--)\\n            {\\n                if(nums[l]>nums[k])\\n                count++;\\n                rs[k][l]=count;//No of elements greater than nums[k] and lying from l to n-1\\n            }\\n            \\n        }\\nlong long ans=0;\\n        for(int j=1;j<n-2;j++)\\n        {\\n            for(int k=n-2;k>1;k--)\\n            {\\n                if(nums[k]<nums[j])\\n                {\\n                    ans+=ls[k][j-1]*rs[j][k+1];//since nums[j] is placed after nums[k], for nums[j] we need all elements greatr than nums[j] but lyng in range k+1 to n-1, since their indices shld be greater than k.Similarly nums[k] lies before nums[j] and after nums[i], so we need all elements less than nums[k] but in range 0 to j-1, since indices order is i<j<k<l.\\n                }\\n        }\\n        }\\n        return ans;    \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3116781,
                "title": "more-intuitive-approach-than-prefix-suffix-o-n-2-time-and-space",
                "content": "# Intuition\\nBy the constraints, it is clear that the time complexity of the solution can\\'t be greater than O(n^2) or O(n^2 logn). In brute force approach, we would use 4 loops leading to a complexity of O(n^4). Can\\'t do that here.\\nAfter observing for a while, we can see that it makes sense to first find all the suitable (j,k) pairs. Basically, j<k should imply nums[j]>nums[k].\\nThe real question is what to do after that..??\\n\\n# Approach\\nAfter finding all such (j,k) pairs, we have to find all i, such that i<j and nums[i]<nums[k] and simultaneously all l, such that l>k and nums[l]>nums[j]. Then we, can multiply count_i and count_l and add the product to the final result.\\n\\nAfter finding suitable (j,k) pair, we would require O(n) time to find count_i and count_l for that particular pair, leading to a Time Complexity of O(n^2) * O(n) which is O(n^3). Can we improve this..??\\n\\nThe answer is yes (using some precomputation and extra space).\\nThe below precomputation would help in finding count_i and count_l for a particular (j,k) pair in O(1), leading to a final Time Complexity of O(n^2) * O(1) = O(n^2).\\n\\n### Precomputation Involved\\n- ```lessThan[x][pos] ```\\nIt stores the count of numbers whose index is less than equal to x and value is less than nums[pos]\\n- ```greaterThan[x][pos]``` \\nIt stores the count of numbers whose index is greater than equal to x and value is greater than nums[pos]\\n\\nWe can clearly compute above two matrices in O(n^2) time.\\n# Complexity\\n## Time Complexity : O(n^2) \\n[Precomputation] + O(n^2) [Solving for each (j,k) pair] = O(n^2)\\n\\n## Space Complexity : O(n^2) \\nDue to storing the precomputation results in ```lessThan[][]``` and ```greaterThan[][]``` matrices\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> lessThan(n,vector<int>(n,0)), greaterThan(n,vector<int>(n,0));\\n        // lessThan[x][pos] stores the count of numbers whose index is less than equal to x and value is less than nums[pos]\\n        // greaterThan[x][pos] stores the count of numbers whose index is greater than equal to x and value is greater than nums[pos]\\n        int cnt;\\n        for(int pos=0;pos<n;pos++) {\\n            cnt = 0;\\n            for(int x=0;x<n;x++) {\\n                if(nums[x] < nums[pos])\\n                    cnt ++;\\n                lessThan[x][pos] = cnt;\\n            }\\n            cnt = 0;\\n            for(int x=n-1;x>=0;x--) {\\n                if(nums[x] > nums[pos])\\n                    cnt ++;\\n                greaterThan[x][pos] = cnt;\\n            }\\n        }\\n        long long res = 0;\\n        for(int j=0;j<n;j++) {\\n            for(int k=j+1;k<n;k++) {\\n                if(nums[k] < nums[j]) {\\n                    if(j-1>=0 && k+1<n)\\n                        res += lessThan[j-1][k] * greaterThan[k+1][j];\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```lessThan[x][pos] ```\n```greaterThan[x][pos]```\n```lessThan[][]```\n```greaterThan[][]```\n```\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> lessThan(n,vector<int>(n,0)), greaterThan(n,vector<int>(n,0));\\n        // lessThan[x][pos] stores the count of numbers whose index is less than equal to x and value is less than nums[pos]\\n        // greaterThan[x][pos] stores the count of numbers whose index is greater than equal to x and value is greater than nums[pos]\\n        int cnt;\\n        for(int pos=0;pos<n;pos++) {\\n            cnt = 0;\\n            for(int x=0;x<n;x++) {\\n                if(nums[x] < nums[pos])\\n                    cnt ++;\\n                lessThan[x][pos] = cnt;\\n            }\\n            cnt = 0;\\n            for(int x=n-1;x>=0;x--) {\\n                if(nums[x] > nums[pos])\\n                    cnt ++;\\n                greaterThan[x][pos] = cnt;\\n            }\\n        }\\n        long long res = 0;\\n        for(int j=0;j<n;j++) {\\n            for(int k=j+1;k<n;k++) {\\n                if(nums[k] < nums[j]) {\\n                    if(j-1>=0 && k+1<n)\\n                        res += lessThan[j-1][k] * greaterThan[k+1][j];\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3115640,
                "title": "brute-force-solution-o-n-2-log-n-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nInitially I sought a more sophisticated approach, but the counting method was wrong. Eventually I settled on this brute force approach.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor each pair j<k with nums[j]>nums[k], the number of correct quadruples is (the number of i<j such that nums[i]<nums[k]) times (the number of l>k such that nums[l]>nums[j]).\\nBoth of these counts can be computed in log n time, if one keeps a suitable list for each j and for each k, using bisection.\\n\\n# Complexity\\n- Time complexity: $O(n^2 \\\\log n)$.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nSince we may have to do the above for each pair j<k and for some positive proportion of the pairs (say one fourth) the binary search can actually take $O(\\\\log n)$ time, this is the total time we get.\\n\\nDoing a few optimizations reduced the time from 5s to 4.35s, still nothing special.\\n\\n- Space complexity: $O(n^2)$, because we keep those lists.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countQuadruplets(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        lst=[nums[0]]\\n        lsts=[()]\\n        for j in range(1, n):\\n            ind=bisect_right(lst, nums[j])\\n            lsts.append(tuple(lst[:ind]))\\n            lst.insert(ind, nums[j])\\n        \\n        lst=[nums[n-1]]\\n        ct2=[0]\\n        lsts2=[()]\\n        for k in range(n-2, -1, -1):\\n            ind=bisect_left(lst, nums[k])\\n            ct2.append(n-1-k-ind)\\n            lsts2.append(tuple(lst[ind:]))\\n            lst.insert(ind, nums[k])\\n        ct2.reverse()\\n        lsts2.reverse()\\n\\n        ans=0       \\n        for k in range(2, n-1):\\n            nk=nums[k]\\n            tmp_ct=ct2[k]\\n            tmp_lst=lsts2[k]\\n            for j in range(1, k):\\n                if nk<nums[j]:\\n                    ans+=bisect_right(lsts[j], nk)*(tmp_ct-bisect_left(tmp_lst, nums[j]))\\n        return ans     \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countQuadruplets(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        lst=[nums[0]]\\n        lsts=[()]\\n        for j in range(1, n):\\n            ind=bisect_right(lst, nums[j])\\n            lsts.append(tuple(lst[:ind]))\\n            lst.insert(ind, nums[j])\\n        \\n        lst=[nums[n-1]]\\n        ct2=[0]\\n        lsts2=[()]\\n        for k in range(n-2, -1, -1):\\n            ind=bisect_left(lst, nums[k])\\n            ct2.append(n-1-k-ind)\\n            lsts2.append(tuple(lst[ind:]))\\n            lst.insert(ind, nums[k])\\n        ct2.reverse()\\n        lsts2.reverse()\\n\\n        ans=0       \\n        for k in range(2, n-1):\\n            nk=nums[k]\\n            tmp_ct=ct2[k]\\n            tmp_lst=lsts2[k]\\n            for j in range(1, k):\\n                if nk<nums[j]:\\n                    ans+=bisect_right(lsts[j], nk)*(tmp_ct-bisect_left(tmp_lst, nums[j]))\\n        return ans     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3115495,
                "title": "rust-binary-indexed-tree",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe use a binary indexed tree to build a two dimensional vector where data[i][k] is the number of elements from 0 .. i - 1 that are <= k.\\nThis process runs in O(N * N *Log N) time. Once we have this information, we will iterate over j, k to find the number of items on j\\'s left, which are < nums[k] and number of items on k\\'s right, which are > nums[j].\\n\\nBy the way, \\n1) the C++ segment tree solution passes all 119 test cases, but TLE, \\n2) the binary indexed tree C++ solution would be accepted\\n3) the rust segment tree solution runs 6 times slower (1756 ms) compared with the binari indexed tree solution (277 ms).         \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N * N * Log N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N * N)\\n# Code\\n```\\nimpl Solution {\\n    pub fn count_quadruplets(nums: Vec<i32>) -> i64 {\\n        let n = nums.len() + 1;\\n        let mut tree = vec![0; n + 1];\\n        let mut data = vec![vec![0; n]; n];\\n\\n        for i in 0 .. n - 1 {\\n            for k in 1 .. n {\\n                data[i][k] = Self::sum(k, &mut tree);\\n            }\\n                \\n            Self::add(nums[i] as usize, &mut tree);\\n        }\\n\\n        let mut ret = 0;\\n        for j in 1 .. n - 2 {\\n            for k in j + 1 .. n - 1 {\\n                if nums[j] < nums[k] { continue }\\n                \\n                // total # of items > nums[j]\\n                let mut t = n as i64 - 1 - nums[j] as i64;\\n                //taking away those that are on k\\'s left \\n                t -= data[k][n - 1] - data[k][nums[j] as usize];\\n                // t is the # of items that are on k\\'s right and > nums[j]   \\n                // data[j][nums[k] is the # of items on j\\'s left and < nums[k]\\n                ret += data[j][nums[k] as usize - 1] * t;    \\n            }\\n        }\\n        \\n        ret\\n    }\\n\\n    fn add(i: usize, tree: &mut Vec<i64>) {\\n        let mut i = i + 1;\\n        \\n        while i < tree.len() {\\n            tree[i] += 1;\\n            i += ((i as i32) & -(i as i32)) as usize; \\n        }\\n    }\\n\\n    fn sum(i: usize, tree: &mut Vec<i64>) -> i64 {\\n        let mut i = i + 1;\\n        let mut ret = 0;\\n\\n        while i > 0 {\\n            ret += tree[i];\\n            i -= ((i as i32) & -(i as i32)) as usize;\\n        }\\n        ret\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn count_quadruplets(nums: Vec<i32>) -> i64 {\\n        let n = nums.len() + 1;\\n        let mut tree = vec![0; n + 1];\\n        let mut data = vec![vec![0; n]; n];\\n\\n        for i in 0 .. n - 1 {\\n            for k in 1 .. n {\\n                data[i][k] = Self::sum(k, &mut tree);\\n            }\\n                \\n            Self::add(nums[i] as usize, &mut tree);\\n        }\\n\\n        let mut ret = 0;\\n        for j in 1 .. n - 2 {\\n            for k in j + 1 .. n - 1 {\\n                if nums[j] < nums[k] { continue }\\n                \\n                // total # of items > nums[j]\\n                let mut t = n as i64 - 1 - nums[j] as i64;\\n                //taking away those that are on k\\'s left \\n                t -= data[k][n - 1] - data[k][nums[j] as usize];\\n                // t is the # of items that are on k\\'s right and > nums[j]   \\n                // data[j][nums[k] is the # of items on j\\'s left and < nums[k]\\n                ret += data[j][nums[k] as usize - 1] * t;    \\n            }\\n        }\\n        \\n        ret\\n    }\\n\\n    fn add(i: usize, tree: &mut Vec<i64>) {\\n        let mut i = i + 1;\\n        \\n        while i < tree.len() {\\n            tree[i] += 1;\\n            i += ((i as i32) & -(i as i32)) as usize; \\n        }\\n    }\\n\\n    fn sum(i: usize, tree: &mut Vec<i64>) -> i64 {\\n        let mut i = i + 1;\\n        let mut ret = 0;\\n\\n        while i > 0 {\\n            ret += tree[i];\\n            i -= ((i as i32) & -(i as i32)) as usize;\\n        }\\n        ret\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3115412,
                "title": "java-dp-using-prevsmaller-and-nextlarger",
                "content": "# Intuition\\nWe have four indices: ```i```, ```j```, ```k```, and ```l```. For every valid pair of middle two indices ```j``` and ```k``` with ```j < k``` and ```nums[j] > nums[k]```, we want to get two counts:\\n- **count1:** count of elements prior to ```j``` and ```< nums[k]```, and\\n- **count2:** count of elements after ```k``` and ```> nums[j]```.\\n\\nThen, ```result += count1 * count2```.\\n\\nFor ```count1``` and ```count2```, we can use ```dp``` to get them.\\n- ```prevSmaller[i][j]```: count of elements prior to ```i``` and ```< nums[j]```\\n- ```nextLarger[i][j]```: count of elements after ```i``` and ```> nums[j]```.\\n\\n# Time Complexity\\nIt takes ```O(n^2)``` to construct ```prevSmaller``` and ```nextLarger```. It takes ```O(n^2)``` to get all pairs of valid ```j``` and ```k``` and takes ```O(1)``` to get the ```count1``` and ```count2``` for every valid pair.\\n\\nOverall, ```O(n^2)```.\\n\\n# Code\\n```\\nclass Solution {\\n    public long countQuadruplets(int[] nums) {\\n        int n = nums.length;\\n        int[][] prevSmaller = new int[n][n], nextLarger = new int[n][n];\\n\\n        for(int i = 0; i < n; i++) {\\n            nextLarger[n - 1][i] = 0;\\n        }\\n\\n        for(int i = 0; i < n; i++) {\\n            for(int j = n - 2; j > i; j--) {\\n                if(nums[j + 1] > nums[i]) nextLarger[j][i] = nextLarger[j + 1][i] + 1;\\n                else nextLarger[j][i] = nextLarger[j + 1][i];\\n            }\\n        } \\n\\n        for(int i = 0; i < n; i++) {\\n            prevSmaller[0][i] = 0;\\n        } \\n\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 1; j < i; j++) {\\n                if(nums[j - 1] < nums[i]) prevSmaller[j][i] = prevSmaller[j - 1][i] + 1;\\n                else prevSmaller[j][i] = prevSmaller[j - 1][i];\\n            }\\n        } \\n\\n        long result = 0;\\n\\n        for(int i = 0; i < n; i++) {\\n            for(int j = i + 1; j < n; j++) {\\n                if(nums[j] < nums[i]) {\\n                    result += prevSmaller[i][j] * nextLarger[j][i];\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n// i j k l\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```i```\n```j```\n```k```\n```l```\n```j```\n```k```\n```j < k```\n```nums[j] > nums[k]```\n```j```\n```< nums[k]```\n```k```\n```> nums[j]```\n```result += count1 * count2```\n```count1```\n```count2```\n```dp```\n```prevSmaller[i][j]```\n```i```\n```< nums[j]```\n```nextLarger[i][j]```\n```i```\n```> nums[j]```\n```O(n^2)```\n```prevSmaller```\n```nextLarger```\n```O(n^2)```\n```j```\n```k```\n```O(1)```\n```count1```\n```count2```\n```O(n^2)```\n```\\nclass Solution {\\n    public long countQuadruplets(int[] nums) {\\n        int n = nums.length;\\n        int[][] prevSmaller = new int[n][n], nextLarger = new int[n][n];\\n\\n        for(int i = 0; i < n; i++) {\\n            nextLarger[n - 1][i] = 0;\\n        }\\n\\n        for(int i = 0; i < n; i++) {\\n            for(int j = n - 2; j > i; j--) {\\n                if(nums[j + 1] > nums[i]) nextLarger[j][i] = nextLarger[j + 1][i] + 1;\\n                else nextLarger[j][i] = nextLarger[j + 1][i];\\n            }\\n        } \\n\\n        for(int i = 0; i < n; i++) {\\n            prevSmaller[0][i] = 0;\\n        } \\n\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 1; j < i; j++) {\\n                if(nums[j - 1] < nums[i]) prevSmaller[j][i] = prevSmaller[j - 1][i] + 1;\\n                else prevSmaller[j][i] = prevSmaller[j - 1][i];\\n            }\\n        } \\n\\n        long result = 0;\\n\\n        for(int i = 0; i < n; i++) {\\n            for(int j = i + 1; j < n; j++) {\\n                if(nums[j] < nums[i]) {\\n                    result += prevSmaller[i][j] * nextLarger[j][i];\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n// i j k l\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3114816,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn count_quadruplets(nums: Vec<i32>) -> i64 {\\n        let n = nums.len();\\n        let mut lessthan = vec![vec![0; n + 1]; n + 1];\\n        for item in lessthan.iter_mut().take(n + 1) {\\n            item[0] = 0;\\n        }\\n        for i in 1..=n {\\n            for (j, item) in lessthan.iter_mut().enumerate().take(n + 1) {\\n                item[i] = item[i - 1] + (nums[i - 1] < j as i32) as i32;\\n            }\\n        }\\n        let mut re = 0;\\n        for i in 0..n {\\n            for j in i + 1..n {\\n                if nums[i] > nums[j] {\\n                    let g = n as i32 - nums[i] - (j as i32 - lessthan[nums[i] as usize][j + 1]);\\n                    let l = lessthan[nums[j] as usize][i + 1];\\n                    re += g as i64 * l as i64;\\n                }\\n            }\\n        }\\n        re\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn count_quadruplets(nums: Vec<i32>) -> i64 {\\n        let n = nums.len();\\n        let mut lessthan = vec![vec![0; n + 1]; n + 1];\\n        for item in lessthan.iter_mut().take(n + 1) {\\n            item[0] = 0;\\n        }\\n        for i in 1..=n {\\n            for (j, item) in lessthan.iter_mut().enumerate().take(n + 1) {\\n                item[i] = item[i - 1] + (nums[i - 1] < j as i32) as i32;\\n            }\\n        }\\n        let mut re = 0;\\n        for i in 0..n {\\n            for j in i + 1..n {\\n                if nums[i] > nums[j] {\\n                    let g = n as i32 - nums[i] - (j as i32 - lessthan[nums[i] as usize][j + 1]);\\n                    let l = lessthan[nums[j] as usize][i + 1];\\n                    re += g as i64 * l as i64;\\n                }\\n            }\\n        }\\n        re\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3114268,
                "title": "o-n-2logn-c-not-the-best-but-passes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPretty much brute force, but it passes\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI iterate over all j, k pairs and try to count the corresponding i, l that fit. \\n\\nFor a fixed (j,k), such that nums[j] > nums[k], we need:\\n\\n1) the number of i\\'s to the left of k such that nums[i] < nums[k] and i < j\\n2) the number of l\\'s to the right of j such that nums[l] > nums[l] and l > k\\n\\nBinary search in the corresponding vector and get the answer\\n# Complexity\\n- Time complexity:\\n $$O(n^2 logn)$$\\n\\n- Space complexity:\\n $$O(n^2)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& nums) {\\n        // unordered_map<int, vector<int>>st;\\n        // unordered_map<int, vector<int>>st2;\\n    \\n        int n = nums.size();\\n        vector<vector<int>>st(n, vector<int>());\\n        vector<vector<int>>st2(n, vector<int>());\\n        for(int i=0; i<n; i++) {\\n            for(int j=i+1; j<n; j++) {\\n                if(nums[i] < nums[j]) {\\n                    st[i].push_back(j);\\n                    st2[j].push_back(i);\\n                }\\n            }\\n        }\\n        long long ans = 0;\\n        for(int j=1; j<n-1; j++) {\\n            for(int k=j+1; k<n; k++) {\\n                if(nums[j] > nums[k]) {\\n                    int v1 = lower_bound(st2[k].begin(), st2[k].end(), j) - st2[k].begin();\\n                    int v2 = st[j].end() - lower_bound(st[j].begin(), st[j].end(), k);\\n                    ans += (v1 * v2);\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& nums) {\\n        // unordered_map<int, vector<int>>st;\\n        // unordered_map<int, vector<int>>st2;\\n    \\n        int n = nums.size();\\n        vector<vector<int>>st(n, vector<int>());\\n        vector<vector<int>>st2(n, vector<int>());\\n        for(int i=0; i<n; i++) {\\n            for(int j=i+1; j<n; j++) {\\n                if(nums[i] < nums[j]) {\\n                    st[i].push_back(j);\\n                    st2[j].push_back(i);\\n                }\\n            }\\n        }\\n        long long ans = 0;\\n        for(int j=1; j<n-1; j++) {\\n            for(int k=j+1; k<n; k++) {\\n                if(nums[j] > nums[k]) {\\n                    int v1 = lower_bound(st2[k].begin(), st2[k].end(), j) - st2[k].begin();\\n                    int v2 = st[j].end() - lower_bound(st[j].begin(), st[j].end(), k);\\n                    ans += (v1 * v2);\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3113979,
                "title": "c-pre-compute-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n        using ll = long long;\\n        ll countQuadruplets(vector<int>& A) {\\n        ll res = 0, N = A.size();\\n        vector<vector<int>> lessThan(N, vector<int>(N, 0)), greaterThan(N, vector<int>(N, 0));\\n        for(int i = 0; i < N; i++) {\\n            for(int j = i-1, count = 0; j >= 0; j--) {\\n                if(A[i] > A[j]) count++;\\n                lessThan[j][i] = count;\\n            }\\n        }\\n        for(int i = 0; i < N; i++) {\\n            for(int j = i+1, count = 0; j < N; j++) {\\n                if(A[j] > A[i]) count++;\\n                greaterThan[i][j] = count;\\n            }\\n        }\\n\\n        for(int i = 0; i < N; i++) {\\n            for(int j = i+1; j < N; j++) {\\n                if(A[j] < A[i]) res += (lessThan[0][j]-lessThan[i][j])*(greaterThan[i][N-1]-greaterThan[i][j]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        using ll = long long;\\n        ll countQuadruplets(vector<int>& A) {\\n        ll res = 0, N = A.size();\\n        vector<vector<int>> lessThan(N, vector<int>(N, 0)), greaterThan(N, vector<int>(N, 0));\\n        for(int i = 0; i < N; i++) {\\n            for(int j = i-1, count = 0; j >= 0; j--) {\\n                if(A[i] > A[j]) count++;\\n                lessThan[j][i] = count;\\n            }\\n        }\\n        for(int i = 0; i < N; i++) {\\n            for(int j = i+1, count = 0; j < N; j++) {\\n                if(A[j] > A[i]) count++;\\n                greaterThan[i][j] = count;\\n            }\\n        }\\n\\n        for(int i = 0; i < N; i++) {\\n            for(int j = i+1; j < N; j++) {\\n                if(A[j] < A[i]) res += (lessThan[0][j]-lessThan[i][j])*(greaterThan[i][N-1]-greaterThan[i][j]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3113905,
                "title": "no-explanation-binary-search-o-n-2logn-2-to-precomputation-optimisation-o-n-2",
                "content": "Have not provided explanations because my approach\\'s logic is similar to already provided solutions by others. But implementation might be different. \\n\\n# Code\\n```\\n#define all(v) begin(v), end(v)\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& nums) {\\n        using ll = long long;\\n        ll n = nums.size() ; \\n        vector<vector<ll>> smaller(n + 1) ;\\n        vector<vector<ll>> greater(n + 1) ;\\n        for (ll i = 0; i<n; i++) {\\n            for (ll j = i + 1 ; j<n ; j++) {\\n                if (nums[i] < nums[j]) {\\n                    smaller[j].push_back(i) ;\\n                    greater[i].push_back(j) ;\\n                }\\n            }\\n        }\\n        ll ans = 0 ;\\n        for (ll j = 0 ; j<n ; j++){\\n            for(ll k = j + 1; k<n ; k++) {\\n                if(nums[j] > nums[k]) {\\n                    // greater than nums[j] whose idx > k\\n                    ll x = greater[j].size() - (lower_bound(all(greater[j]), k) - greater[j].begin()); \\n                    // smaller than nums[k] whose idx < j\\n                    ll y = (lower_bound(all(smaller[k]), j) - smaller[k].begin()); \\n                    ans += x*y ; \\n                }\\n            }\\n        }\\n        return ans ; \\n    }\\n};\\n```\\n\\nAfter Optimizing the Above Solution \\n\\n```\\n#define all(v) begin(v), end(v)\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& nums) {\\n        using ll = long long;\\n        ll n = nums.size() ; \\n        vector<vector<ll>> smaller(n, vector<ll>(n, 0)) ;\\n        vector<vector<ll>> greater(n, vector<ll>(n, 0)) ;\\n        for (ll i = 0; i<n; i++) {\\n            for (ll j = i + 1 ; j<n ; j++) {\\n                if (nums[i] < nums[j]) {\\n                    smaller[j][i] = 1 ;\\n                    greater[i][j] = 1 ; \\n                }\\n            }\\n        }\\n        for(ll i = 0; i < n ; i++) {\\n            for(ll j = 1; j < n ; j++) smaller[i][j] += smaller[i][j - 1]; \\n            for(ll j = n - 2 ; j>= 0 ; j--) greater[i][j] += greater[i][j + 1]; \\n        }\\n        ll ans = 0 ;\\n        for (ll j = 0 ; j<n ; j++){\\n            for(ll k = j + 1; k<n ; k++) {\\n                if(nums[j] > nums[k]) {\\n                    ans += smaller[k][j] * greater[j][k];\\n                }\\n            }\\n        }\\n        return ans ; \\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define all(v) begin(v), end(v)\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& nums) {\\n        using ll = long long;\\n        ll n = nums.size() ; \\n        vector<vector<ll>> smaller(n + 1) ;\\n        vector<vector<ll>> greater(n + 1) ;\\n        for (ll i = 0; i<n; i++) {\\n            for (ll j = i + 1 ; j<n ; j++) {\\n                if (nums[i] < nums[j]) {\\n                    smaller[j].push_back(i) ;\\n                    greater[i].push_back(j) ;\\n                }\\n            }\\n        }\\n        ll ans = 0 ;\\n        for (ll j = 0 ; j<n ; j++){\\n            for(ll k = j + 1; k<n ; k++) {\\n                if(nums[j] > nums[k]) {\\n                    // greater than nums[j] whose idx > k\\n                    ll x = greater[j].size() - (lower_bound(all(greater[j]), k) - greater[j].begin()); \\n                    // smaller than nums[k] whose idx < j\\n                    ll y = (lower_bound(all(smaller[k]), j) - smaller[k].begin()); \\n                    ans += x*y ; \\n                }\\n            }\\n        }\\n        return ans ; \\n    }\\n};\\n```\n```\\n#define all(v) begin(v), end(v)\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& nums) {\\n        using ll = long long;\\n        ll n = nums.size() ; \\n        vector<vector<ll>> smaller(n, vector<ll>(n, 0)) ;\\n        vector<vector<ll>> greater(n, vector<ll>(n, 0)) ;\\n        for (ll i = 0; i<n; i++) {\\n            for (ll j = i + 1 ; j<n ; j++) {\\n                if (nums[i] < nums[j]) {\\n                    smaller[j][i] = 1 ;\\n                    greater[i][j] = 1 ; \\n                }\\n            }\\n        }\\n        for(ll i = 0; i < n ; i++) {\\n            for(ll j = 1; j < n ; j++) smaller[i][j] += smaller[i][j - 1]; \\n            for(ll j = n - 2 ; j>= 0 ; j--) greater[i][j] += greater[i][j + 1]; \\n        }\\n        ll ans = 0 ;\\n        for (ll j = 0 ; j<n ; j++){\\n            for(ll k = j + 1; k<n ; k++) {\\n                if(nums[j] > nums[k]) {\\n                    ans += smaller[k][j] * greater[j][k];\\n                }\\n            }\\n        }\\n        return ans ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3113668,
                "title": "c-one-vector-o-n-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    long long countQuadruplets(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        long long count = 0;\\n        vector<int> i(n);//count nums[i] > nums[k]\\n        for(int j = 0; j < n - 2; j++)\\n        {\\n            int l = 0;//count nums[l] > nums[j]\\n            for(int k = n - 1; k > j; k--)\\n            {\\n                if(nums[j] > nums[k])\\n                {\\n                    count += i[k] * l;\\n                }\\n                l += nums[k] > nums[j];\\n            }\\n            for(int k = j + 2; k < n; k++)\\n            {\\n                i[k] += nums[j] < nums[k];\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    long long countQuadruplets(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        long long count = 0;\\n        vector<int> i(n);//count nums[i] > nums[k]\\n        for(int j = 0; j < n - 2; j++)\\n        {\\n            int l = 0;//count nums[l] > nums[j]\\n            for(int k = n - 1; k > j; k--)\\n            {\\n                if(nums[j] > nums[k])\\n                {\\n                    count += i[k] * l;\\n                }\\n                l += nums[k] > nums[j];\\n            }\\n            for(int k = j + 2; k < n; k++)\\n            {\\n                i[k] += nums[j] < nums[k];\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3113431,
                "title": "java-clean-code",
                "content": "# Intuition\\njust do inversion count with two loops and get small numbers from left using prefix array and large numbers from right using suffix array\\n\\n\\n# Complexity\\n- Time complexity: n^2+n^2+n^2 = O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: n^2+n^2= O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long countQuadruplets(int[] nums) {\\n        int n = nums.length;\\n        int[][]prefix = new int[n+1][n+1];\\n        int[][]sufix = new int[n+1][n+1];\\n        for(int j=0;j<=n;++j){\\n            if(nums[0]<j)\\n                prefix[0][j]++;\\n        }\\n        for(int i=1;i<n;++i){\\n            for(int j=0;j<=n;++j){\\n                prefix[i][j] = prefix[i-1][j];\\n                if(nums[i]<j)\\n                    prefix[i][j]++;\\n            }\\n        }\\n        for(int j=0;j<=n;++j){\\n            if(nums[n-1]>j)\\n                sufix[n-1][j]++;\\n        }\\n        for(int i=n-2;i>=0;--i){\\n            for(int j=0;j<=n;++j){\\n                sufix[i][j] = sufix[i+1][j];\\n                if(nums[i]>j)\\n                    sufix[i][j]++;\\n            }\\n        }\\n        long ans=0;\\n        for(int i=0;i<n;++i)\\n            for(int j=0;j<i;++j){\\n                if(nums[j]>nums[i])\\n                    if(i<n-1 && j>0){\\n                        ans=ans+(prefix[j-1][nums[i]]*sufix[i+1][nums[j]]);\\n                    }\\n            }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long countQuadruplets(int[] nums) {\\n        int n = nums.length;\\n        int[][]prefix = new int[n+1][n+1];\\n        int[][]sufix = new int[n+1][n+1];\\n        for(int j=0;j<=n;++j){\\n            if(nums[0]<j)\\n                prefix[0][j]++;\\n        }\\n        for(int i=1;i<n;++i){\\n            for(int j=0;j<=n;++j){\\n                prefix[i][j] = prefix[i-1][j];\\n                if(nums[i]<j)\\n                    prefix[i][j]++;\\n            }\\n        }\\n        for(int j=0;j<=n;++j){\\n            if(nums[n-1]>j)\\n                sufix[n-1][j]++;\\n        }\\n        for(int i=n-2;i>=0;--i){\\n            for(int j=0;j<=n;++j){\\n                sufix[i][j] = sufix[i+1][j];\\n                if(nums[i]>j)\\n                    sufix[i][j]++;\\n            }\\n        }\\n        long ans=0;\\n        for(int i=0;i<n;++i)\\n            for(int j=0;j<i;++j){\\n                if(nums[j]>nums[i])\\n                    if(i<n-1 && j>0){\\n                        ans=ans+(prefix[j-1][nums[i]]*sufix[i+1][nums[j]]);\\n                    }\\n            }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3113043,
                "title": "racket-solution-and-a-little-hint-to-make-it-easy",
                "content": "# Intuition\\n\\nWe know the condition `nums[k] < nums[j]`\\nis the source of the difficulty.\\n**Hint**: let\\'s only count the pairs that meet `nums[k] < nums[j]` and\\n`j < k`.\\nThen for each pair `(nums[k], nums[j])`, we find how many `i` meet that `i < j` and `nums[i] < nums[k]`, `l` is the same.\\n\\n# Complexity\\n\\n- Time complexity: $O(n^2)$\\n\\n- Space complexity: $O(n^2)$\\n\\n# Code\\n\\n```scheme\\n(require srfi/43)\\n\\n(define (count-quadruplets nums)\\n  (define vec (list->vector nums))\\n  (define n (vector-length vec))\\n\\n  (define (count-pair vec cmp)\\n    (define count-before (make-array n (add1 n) 0))\\n    (for ([i (range 1 n)])\\n      (define last (aref vec (sub1 i)))\\n      (for ([v (range 1 (add1 n))])\\n        (aset! count-before i v\\n               (+ (aref count-before (sub1 i) v)\\n                  (if (cmp last v)\\n                      1\\n                      0)))))\\n    count-before)\\n\\n  (define count-before (count-pair vec <))\\n  (define count-after (vector-reverse-copy\\n                       (count-pair (vector-reverse-copy vec) >)))\\n\\n  (for*/sum ([k n]\\n             [j k]\\n             #:when (< (aref vec k) (aref vec j)))\\n    (define how-many-i (aref count-before j (aref vec k)))\\n    (define how-many-l (aref count-after k (aref vec j)))\\n    (* how-many-i how-many-l)))\\n\\n(define-syntax aset!\\n  (syntax-rules ()\\n    [(_ arr i v)\\n     (vector-set! arr i v)]\\n    [(_ arr i args ... v)\\n     (aset! (vector-ref arr i) args ... v)]))\\n\\n(define-syntax aref\\n  (syntax-rules ()\\n    [(_ arr) arr]\\n    [(_ arr i args ...)\\n     (aref (vector-ref arr i) args ...)]))\\n\\n(define-syntax make-array\\n  (syntax-rules ()\\n    [(_ n init)\\n     (make-vector n init)]\\n    [(_ n args ...)\\n     (build-vector n (lambda _ (make-array args ...)))]))\\n\\n```",
                "solutionTags": [
                    "Racket"
                ],
                "code": "```scheme\\n(require srfi/43)\\n\\n(define (count-quadruplets nums)\\n  (define vec (list->vector nums))\\n  (define n (vector-length vec))\\n\\n  (define (count-pair vec cmp)\\n    (define count-before (make-array n (add1 n) 0))\\n    (for ([i (range 1 n)])\\n      (define last (aref vec (sub1 i)))\\n      (for ([v (range 1 (add1 n))])\\n        (aset! count-before i v\\n               (+ (aref count-before (sub1 i) v)\\n                  (if (cmp last v)\\n                      1\\n                      0)))))\\n    count-before)\\n\\n  (define count-before (count-pair vec <))\\n  (define count-after (vector-reverse-copy\\n                       (count-pair (vector-reverse-copy vec) >)))\\n\\n  (for*/sum ([k n]\\n             [j k]\\n             #:when (< (aref vec k) (aref vec j)))\\n    (define how-many-i (aref count-before j (aref vec k)))\\n    (define how-many-l (aref count-after k (aref vec j)))\\n    (* how-many-i how-many-l)))\\n\\n(define-syntax aset!\\n  (syntax-rules ()\\n    [(_ arr i v)\\n     (vector-set! arr i v)]\\n    [(_ arr i args ... v)\\n     (aset! (vector-ref arr i) args ... v)]))\\n\\n(define-syntax aref\\n  (syntax-rules ()\\n    [(_ arr) arr]\\n    [(_ arr i args ...)\\n     (aref (vector-ref arr i) args ...)]))\\n\\n(define-syntax make-array\\n  (syntax-rules ()\\n    [(_ n init)\\n     (make-vector n init)]\\n    [(_ n args ...)\\n     (build-vector n (lambda _ (make-array args ...)))]))\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3112571,
                "title": "c-using-pbds-and-precomputation",
                "content": "```\\n#include<ext/pb_ds/assoc_container.hpp>\\n#include<ext/pb_ds/tree_policy.hpp>\\nusing namespace std;\\nusing namespace __gnu_pbds;\\n#define pi pair<int , int>\\n#define ppi pair<pi ,int>\\nint mod = 1e9+7;\\ntypedef tree<int,null_type,less_equal<int> ,rb_tree_tag,tree_order_statistics_node_update> pbds;\\nvoid solve(vector<int> &nums, vector<vector<int>> &dp1, vector<vector<int>> &dp2)\\n{\\n    int n = nums.size();\\n    pbds p1, p2;\\n    p1.insert(nums[0]);\\n    // dp1[x][y] --> num of element on left of x less then nums[x].\\n    for(int j=1;j<n;j++)\\n    {\\n        for(int k=j+1;k<n;k++)\\n        {\\n            if(nums[j]>nums[k])\\n            {\\n                dp1[j][k] = p1.order_of_key(nums[k]);                \\n            }\\n        }\\n        p1.insert(nums[j]);\\n    }\\n    p2.insert(nums[n-1]);\\n    map<int,int> mp;\\n    mp[nums[n-1]]++;\\n\\t// dp1[x][y] --> num of element on right of y greater then nums[x].\\n    for(int k=n-2;k>1;k--)\\n    {\\n        for(int j=k-1;j>0;j--)\\n        {\\n            if(nums[j] > nums[k])\\n            {\\n                dp2[j][k] = (n-1-k) - p2.order_of_key(nums[j]) - mp[nums[j]]; \\n            }\\n        }\\n        mp[nums[k]]++;\\n        p2.insert(nums[k]);\\n    }\\n    return;\\n}\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& nums){\\n        long long ans = 0, n = nums.size();\\n        vector<vector<int>> dp1(n, vector<int>(n));\\n        vector<vector<int>> dp2(n, vector<int>(n));\\n        solve(nums, dp1, dp2);\\n        for(int j=1;j<n-2;j++)for(int k=j+1;k<n-1;k++)if(nums[j] > nums[k])ans += (1LL*dp1[j][k]*dp2[j][k]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#include<ext/pb_ds/assoc_container.hpp>\\n#include<ext/pb_ds/tree_policy.hpp>\\nusing namespace std;\\nusing namespace __gnu_pbds;\\n#define pi pair<int , int>\\n#define ppi pair<pi ,int>\\nint mod = 1e9+7;\\ntypedef tree<int,null_type,less_equal<int> ,rb_tree_tag,tree_order_statistics_node_update> pbds;\\nvoid solve(vector<int> &nums, vector<vector<int>> &dp1, vector<vector<int>> &dp2)\\n{\\n    int n = nums.size();\\n    pbds p1, p2;\\n    p1.insert(nums[0]);\\n    // dp1[x][y] --> num of element on left of x less then nums[x].\\n    for(int j=1;j<n;j++)\\n    {\\n        for(int k=j+1;k<n;k++)\\n        {\\n            if(nums[j]>nums[k])\\n            {\\n                dp1[j][k] = p1.order_of_key(nums[k]);                \\n            }\\n        }\\n        p1.insert(nums[j]);\\n    }\\n    p2.insert(nums[n-1]);\\n    map<int,int> mp;\\n    mp[nums[n-1]]++;\\n\\t// dp1[x][y] --> num of element on right of y greater then nums[x].\\n    for(int k=n-2;k>1;k--)\\n    {\\n        for(int j=k-1;j>0;j--)\\n        {\\n            if(nums[j] > nums[k])\\n            {\\n                dp2[j][k] = (n-1-k) - p2.order_of_key(nums[j]) - mp[nums[j]]; \\n            }\\n        }\\n        mp[nums[k]]++;\\n        p2.insert(nums[k]);\\n    }\\n    return;\\n}\\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& nums){\\n        long long ans = 0, n = nums.size();\\n        vector<vector<int>> dp1(n, vector<int>(n));\\n        vector<vector<int>> dp2(n, vector<int>(n));\\n        solve(nums, dp1, dp2);\\n        for(int j=1;j<n-2;j++)for(int k=j+1;k<n-1;k++)if(nums[j] > nums[k])ans += (1LL*dp1[j][k]*dp2[j][k]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3112523,
                "title": "dp-in-java-version-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nThis is a DP problem. The outcome of **index** **x** is based on index **1~(x-1)**.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nLet dp[x] stores the possible numbers of outcome with **index x** being *k* in *(i,j,k,l)*. Therefore,  whenever comes to a nums[l] that is after and larger than nums[x], ans+=dp[x].\\n\\nHowever, how about the numbers smaller than nums[x] that comes after index x? They just provide a multiplicity to dp[x], as they are all possible *j* in *(i,j,k,l)*.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\n    public long countQuadruplets(int[] nums) {\\n        int n=nums.length;\\n        long[] dp=new long[n];\\n        Arrays.fill(dp,0);\\n        long ret=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            int choice=0;\\n            for(int j=0;j<i;j++)\\n            {\\n                if(nums[i]>nums[j])\\n                {\\n                    choice++;\\n                    ret+=dp[j];\\n                }\\n                else if(nums[i]<nums[j])\\n                {\\n                    dp[j]+=choice;\\n                }\\n            }\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public long countQuadruplets(int[] nums) {\\n        int n=nums.length;\\n        long[] dp=new long[n];\\n        Arrays.fill(dp,0);\\n        long ret=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            int choice=0;\\n            for(int j=0;j<i;j++)\\n            {\\n                if(nums[i]>nums[j])\\n                {\\n                    choice++;\\n                    ret+=dp[j];\\n                }\\n                else if(nums[i]<nums[j])\\n                {\\n                    dp[j]+=choice;\\n                }\\n            }\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112047,
                "title": "java-1-d-dp-solution",
                "content": "# Initiative\\nWe can define a $$dp$$ array, where the $$a$$th elements of the array stands for the number of triples (i, j, k) such that $$a$$ is the $$j$$ in the triple.\\nThen the $$a$$th element, assume it is $$nums[l]$$, we can compute the number of quadruplets in this case from $$dp$$ computed from sub array $$(0, a - 1)$$ \\n\\n# Approach\\n1) Iterate over $$nums$$\\n2) For the $$a$$th iteration, we first assume the element is $$nums[l]$$ and compute how many triple $$(i, j, k)$$ exists in the sub array $$(0, a - 1)$$ of $$dp$$\\n3) Then we assume the element is $$nums[k]$$, and update $$dp$$ to include the $$a$$th element, this can be only in $$O(n)$$ by iterating from $$0$$ to $$(a - 1)$$, counting the number of elements smaller than $$nums[a]$$, and updating $$dp[b]$$ with the dynamic count if $$nums[a] < nums[b]$$.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public long countQuadruplets(int[] nums) {\\n        int n = nums.length;\\n        long output = 0;\\n        long[] dp = new long[n];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < i; j++) if (nums[i] > nums[j]) output += dp[j];\\n            for (int c = 0, j = 0; j < i; j++) \\n                if (nums[i] < nums[j]) dp[j] += c;\\n                else c++; \\n        }\\n        return output;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n\\n    public long countQuadruplets(int[] nums) {\\n        int n = nums.length;\\n        long output = 0;\\n        long[] dp = new long[n];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < i; j++) if (nums[i] > nums[j]) output += dp[j];\\n            for (int c = 0, j = 0; j < i; j++) \\n                if (nums[i] < nums[j]) dp[j] += c;\\n                else c++; \\n        }\\n        return output;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111986,
                "title": "c-clean-code-using-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long \\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& nums) {\\n        ll ans  = 0;\\n        int n = nums.size();\\n        vector<vector<int>>dp(n,vector<int>(n,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                if(j>0) dp[i][j] = dp[i][j-1];\\n                if(nums[i]>nums[j]){\\n                    dp[i][j]+=1;\\n                }\\n            }\\n        }\\n        for(int j=0;j<n-2;j++){\\n            ll val = 0;\\n            for(int l = j+1;l<n;l++){\\n                if(nums[l]>nums[j]){\\n                    ans+=val;\\n                }\\n                if(nums[j]>nums[l]){\\n                    val+=dp[l][j];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long \\nclass Solution {\\npublic:\\n    long long countQuadruplets(vector<int>& nums) {\\n        ll ans  = 0;\\n        int n = nums.size();\\n        vector<vector<int>>dp(n,vector<int>(n,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                if(j>0) dp[i][j] = dp[i][j-1];\\n                if(nums[i]>nums[j]){\\n                    dp[i][j]+=1;\\n                }\\n            }\\n        }\\n        for(int j=0;j<n-2;j++){\\n            ll val = 0;\\n            for(int l = j+1;l<n;l++){\\n                if(nums[l]>nums[j]){\\n                    ans+=val;\\n                }\\n                if(nums[j]>nums[l]){\\n                    val+=dp[l][j];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111933,
                "title": "simple-solution-using-pre-computation-and-bisect-python",
                "content": "# Intuition\\nAll the numbers are between 1 and n. So there must be some pre-computation that needs to be done in O(n^2)\\n\\n# Approach\\n- For each j(0<=j<n) precompute the count of numbers that appear to the right of j and are greater than nums[j]\\n- Consider pair j and k (0<=j<k<n and nums[k]<nums[j]). Find the count of numbers to the left of j and less than nums[k]. Similarly find the numbers that are between j and k and are greater than nums[j].\\n\\n- Let l_cnt = count of numbers to the left of j and less than nums[k]\\n- let m_cnt = count of numbers in between j and k and greater than nums[j]\\n- Therefore r_cnt = pre_compute(nums[j]) - m_cnt \\n- Add l_cnt*r_cnt to the result.\\n\\n# Complexity\\n- Time complexity: O(n^2*log(n))\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def countQuadruplets(self, nums):\\n        n = len(nums)\\n        Cnt = [0 for _ in range(n+1)]\\n        \\n        for i in range(n):\\n            for j in range(i+1,n):\\n                if nums[j]>nums[i]:\\n                    Cnt[nums[i]]+=1\\n        \\n        L = []\\n        res = 0\\n        for i,x in enumerate(nums):\\n            curr = Cnt[x]\\n            \\n            for j in range(i+1,n):\\n                if x<nums[j]:\\n                    curr-=1\\n                    continue \\n                l = bisect.bisect_left(L,nums[j])\\n                res+=l*curr\\n            bisect.insort_left(L,x)\\n        return res \\n            \\n            \\n                \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countQuadruplets(self, nums):\\n        n = len(nums)\\n        Cnt = [0 for _ in range(n+1)]\\n        \\n        for i in range(n):\\n            for j in range(i+1,n):\\n                if nums[j]>nums[i]:\\n                    Cnt[nums[i]]+=1\\n        \\n        L = []\\n        res = 0\\n        for i,x in enumerate(nums):\\n            curr = Cnt[x]\\n            \\n            for j in range(i+1,n):\\n                if x<nums[j]:\\n                    curr-=1\\n                    continue \\n                l = bisect.bisect_left(L,nums[j])\\n                res+=l*curr\\n            bisect.insort_left(L,x)\\n        return res \\n            \\n            \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111923,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def countQuadruplets(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        dp=[0]*n\\n        cnt=0\\n        for j in range(n):\\n            prv_small=0\\n            for i in range(j):\\n                if nums[j]>nums[i]:\\n                    prv_small+=1\\n                    cnt+=dp[i]\\n\\n                else:\\n                    if nums[j]<nums[i]:\\n                        dp[i]+=prv_small\\n\\n        return cnt                            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countQuadruplets(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        dp=[0]*n\\n        cnt=0\\n        for j in range(n):\\n            prv_small=0\\n            for i in range(j):\\n                if nums[j]>nums[i]:\\n                    prv_small+=1\\n                    cnt+=dp[i]\\n\\n                else:\\n                    if nums[j]<nums[i]:\\n                        dp[i]+=prv_small\\n\\n        return cnt                            \\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1778581,
                "content": [
                    {
                        "username": "ZongyuWu",
                        "content": "Today is Saturday, I should be in a ski resort, not sitting here google for IQ test."
                    },
                    {
                        "username": "arthur_g",
                        "content": "I strongly believe the time constraints are too tight for this problem. I had two O(n^2) solutions, one passed. The other failed. The only difference is the failing one we do an extra double for loop (additional time: N^2). The same failing solution fails in Python but passes CPP. \n\nI also wrote a memoized solution (also N^2) using maps. This also time limit exceeds in both CPP and Py. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@RealFan](/RealFan) Still,C++ gets accepted but python gets stuck at 117/121.Both have O(n^2logn) time complexity"
                    },
                    {
                        "username": "RealFan",
                        "content": "Maybe LeetCode just want to stuck the $O(n^2 \\log n)$ answers."
                    },
                    {
                        "username": "cecilia5",
                        "content": "Lying problem name >_<"
                    },
                    {
                        "username": "czjnbb",
                        "content": "In Python, SortedList results in TLE but using bisect with array gives pretty good time. Weird."
                    },
                    {
                        "username": "RasecBadguy",
                        "content": "I\\xB4m not able to post a public solution for this problem. Do i need pass some review or have more reputation?"
                    },
                    {
                        "username": "chezzyfries",
                        "content": "My O(n^2 logn) solution passed. I had two variations of it. One passed, one TLEd. But I think O(n^2) was expected?"
                    },
                    {
                        "username": "nisaacdz",
                        "content": "This is harder than it looks"
                    },
                    {
                        "username": "rahulmangla",
                        "content": "Please, help me, why my code not working?\\n\\nclass Solution {\\npublic:\\n    \\n    int cnt=0;\\n    \\n    long long fun(int i, int k, vector<int> &nums , vector<int> &larger) {\\n        if(i>=k) {\\n            return 0;\\n        }\\n        \\n        while(i<k) {\\n            int j = i + (k-i)/2;\\n            if(nums[j]>nums[i] && nums[j]>nums[k]) cnt+=larger[k];\\n            return fun(i,j-1,nums,larger) + fun(j+1,k,nums,larger);\\n        }\\n        return cnt;\\n    }\\n    \\n    long long countQuadruplets(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        vector<int> larger(n,0);\\n        \\n        for(int i=0;i<n;i++) {\\n            for(int j=i+1;j<n;j++) {\\n                if(nums[i] < nums[j]) larger[i]++;\\n            }\\n        }\\n        \\n        return fun(0,n-1,nums,larger);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "haa_bhai__",
                        "content": "Please someone tell me why is this code just passing 117/119 test cases ..\n\n `long long countQuadruplets(vector<int>& nums) {`\n   `int n=(int)(nums.size());`\n   `if(n<=3)return 0ll;`\n   `long long big[n+2][n+2];`\n   `long long small[n+2][n+2];`\n       ` for(int j=0;j<=n+1;j++){`\n        `    for(int i=0;i<=n+1;i++){`\n         `     small[j][i]=0;`\n          `    big[j][i]=0; ` \n           ` }`\n        `}`\n   `for(int j=2;j<n-1;j++){`\n    `for(int i=0;i<j;i++){`\n      `if(nums[i]<nums[j]){`\n        `small[i][nums[j]]+=1;` \n     ` }`\n    `}`\n   `}`\n   `for(int j=n-3;j>=1;j--){`\n    `for(int i=j+1;i<n;i++){`\n      `if(nums[i]>nums[j]){`\n       ` big[i][nums[j]]+=1;`\n      `}`\n    `}`\n   `}`\n   `for(int j=0;j<n;j++){`\n    `for(int i=n-1;i>=0;i--)big[i][nums[j]]+=big[i+1][nums[j]];`\n   `} `    \n   `for(int j=0;j<n;j++){`\n    `for(int i=1;i<=n;i++)small[i][nums[j]]+=small[i-1][nums[j]];`\n   `}`\n   `long long ans=0;`\n   `for(int j=1;j<n-1;j++){`\n    `for(int k=j+1;k<n-1;k++){`\n      `if(nums[k]<nums[j]){`\n      `long long a1=small[j][nums[k]];`\n      `long long a2=big[k][nums[j]];`\n      `ans+=(a1*1ll*a2);`\n     ` } `\n    `}`\n   `} `\n   `return ans;` \n `}`"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "Please, help me, why my code gets TLE?\\n```\\nvar countQuadruplets = function(nums) {\\n    let res = 0\\n    function f(ind, arr) {\\n        if (arr.length === 4) {\\n            if (arr[0] < arr[2] && arr[0] < arr[1] && arr[0] < arr[3] &&\\n            arr[2] < arr[1] && arr[2] < arr[3] && arr[1] < arr[3]) res++\\n            return\\n        }\\n        for (let i = ind; i < nums.length; i++) {\\n            f(i + 1, [...arr, nums[i]])\\n        }\\n    }\\n    f(0, [])\\n    return res\\n};\\n```"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "[@Souvik4133x](/Souvik4133x) \n```\n4 <= nums.length <= 4000\n1 <= nums[i] <= nums.length\nAll the integers of nums are unique. nums is a permutation.\n```\nwhere is it?"
                    },
                    {
                        "username": "Souvik4133x",
                        "content": "check the time constraint ,recursion will take too much time ,thats why tle is given ."
                    }
                ]
            },
            {
                "id": 1778834,
                "content": [
                    {
                        "username": "ZongyuWu",
                        "content": "Today is Saturday, I should be in a ski resort, not sitting here google for IQ test."
                    },
                    {
                        "username": "arthur_g",
                        "content": "I strongly believe the time constraints are too tight for this problem. I had two O(n^2) solutions, one passed. The other failed. The only difference is the failing one we do an extra double for loop (additional time: N^2). The same failing solution fails in Python but passes CPP. \n\nI also wrote a memoized solution (also N^2) using maps. This also time limit exceeds in both CPP and Py. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@RealFan](/RealFan) Still,C++ gets accepted but python gets stuck at 117/121.Both have O(n^2logn) time complexity"
                    },
                    {
                        "username": "RealFan",
                        "content": "Maybe LeetCode just want to stuck the $O(n^2 \\log n)$ answers."
                    },
                    {
                        "username": "cecilia5",
                        "content": "Lying problem name >_<"
                    },
                    {
                        "username": "czjnbb",
                        "content": "In Python, SortedList results in TLE but using bisect with array gives pretty good time. Weird."
                    },
                    {
                        "username": "RasecBadguy",
                        "content": "I\\xB4m not able to post a public solution for this problem. Do i need pass some review or have more reputation?"
                    },
                    {
                        "username": "chezzyfries",
                        "content": "My O(n^2 logn) solution passed. I had two variations of it. One passed, one TLEd. But I think O(n^2) was expected?"
                    },
                    {
                        "username": "nisaacdz",
                        "content": "This is harder than it looks"
                    },
                    {
                        "username": "rahulmangla",
                        "content": "Please, help me, why my code not working?\\n\\nclass Solution {\\npublic:\\n    \\n    int cnt=0;\\n    \\n    long long fun(int i, int k, vector<int> &nums , vector<int> &larger) {\\n        if(i>=k) {\\n            return 0;\\n        }\\n        \\n        while(i<k) {\\n            int j = i + (k-i)/2;\\n            if(nums[j]>nums[i] && nums[j]>nums[k]) cnt+=larger[k];\\n            return fun(i,j-1,nums,larger) + fun(j+1,k,nums,larger);\\n        }\\n        return cnt;\\n    }\\n    \\n    long long countQuadruplets(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        vector<int> larger(n,0);\\n        \\n        for(int i=0;i<n;i++) {\\n            for(int j=i+1;j<n;j++) {\\n                if(nums[i] < nums[j]) larger[i]++;\\n            }\\n        }\\n        \\n        return fun(0,n-1,nums,larger);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "haa_bhai__",
                        "content": "Please someone tell me why is this code just passing 117/119 test cases ..\n\n `long long countQuadruplets(vector<int>& nums) {`\n   `int n=(int)(nums.size());`\n   `if(n<=3)return 0ll;`\n   `long long big[n+2][n+2];`\n   `long long small[n+2][n+2];`\n       ` for(int j=0;j<=n+1;j++){`\n        `    for(int i=0;i<=n+1;i++){`\n         `     small[j][i]=0;`\n          `    big[j][i]=0; ` \n           ` }`\n        `}`\n   `for(int j=2;j<n-1;j++){`\n    `for(int i=0;i<j;i++){`\n      `if(nums[i]<nums[j]){`\n        `small[i][nums[j]]+=1;` \n     ` }`\n    `}`\n   `}`\n   `for(int j=n-3;j>=1;j--){`\n    `for(int i=j+1;i<n;i++){`\n      `if(nums[i]>nums[j]){`\n       ` big[i][nums[j]]+=1;`\n      `}`\n    `}`\n   `}`\n   `for(int j=0;j<n;j++){`\n    `for(int i=n-1;i>=0;i--)big[i][nums[j]]+=big[i+1][nums[j]];`\n   `} `    \n   `for(int j=0;j<n;j++){`\n    `for(int i=1;i<=n;i++)small[i][nums[j]]+=small[i-1][nums[j]];`\n   `}`\n   `long long ans=0;`\n   `for(int j=1;j<n-1;j++){`\n    `for(int k=j+1;k<n-1;k++){`\n      `if(nums[k]<nums[j]){`\n      `long long a1=small[j][nums[k]];`\n      `long long a2=big[k][nums[j]];`\n      `ans+=(a1*1ll*a2);`\n     ` } `\n    `}`\n   `} `\n   `return ans;` \n `}`"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "Please, help me, why my code gets TLE?\\n```\\nvar countQuadruplets = function(nums) {\\n    let res = 0\\n    function f(ind, arr) {\\n        if (arr.length === 4) {\\n            if (arr[0] < arr[2] && arr[0] < arr[1] && arr[0] < arr[3] &&\\n            arr[2] < arr[1] && arr[2] < arr[3] && arr[1] < arr[3]) res++\\n            return\\n        }\\n        for (let i = ind; i < nums.length; i++) {\\n            f(i + 1, [...arr, nums[i]])\\n        }\\n    }\\n    f(0, [])\\n    return res\\n};\\n```"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "[@Souvik4133x](/Souvik4133x) \n```\n4 <= nums.length <= 4000\n1 <= nums[i] <= nums.length\nAll the integers of nums are unique. nums is a permutation.\n```\nwhere is it?"
                    },
                    {
                        "username": "Souvik4133x",
                        "content": "check the time constraint ,recursion will take too much time ,thats why tle is given ."
                    }
                ]
            },
            {
                "id": 1778721,
                "content": [
                    {
                        "username": "ZongyuWu",
                        "content": "Today is Saturday, I should be in a ski resort, not sitting here google for IQ test."
                    },
                    {
                        "username": "arthur_g",
                        "content": "I strongly believe the time constraints are too tight for this problem. I had two O(n^2) solutions, one passed. The other failed. The only difference is the failing one we do an extra double for loop (additional time: N^2). The same failing solution fails in Python but passes CPP. \n\nI also wrote a memoized solution (also N^2) using maps. This also time limit exceeds in both CPP and Py. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@RealFan](/RealFan) Still,C++ gets accepted but python gets stuck at 117/121.Both have O(n^2logn) time complexity"
                    },
                    {
                        "username": "RealFan",
                        "content": "Maybe LeetCode just want to stuck the $O(n^2 \\log n)$ answers."
                    },
                    {
                        "username": "cecilia5",
                        "content": "Lying problem name >_<"
                    },
                    {
                        "username": "czjnbb",
                        "content": "In Python, SortedList results in TLE but using bisect with array gives pretty good time. Weird."
                    },
                    {
                        "username": "RasecBadguy",
                        "content": "I\\xB4m not able to post a public solution for this problem. Do i need pass some review or have more reputation?"
                    },
                    {
                        "username": "chezzyfries",
                        "content": "My O(n^2 logn) solution passed. I had two variations of it. One passed, one TLEd. But I think O(n^2) was expected?"
                    },
                    {
                        "username": "nisaacdz",
                        "content": "This is harder than it looks"
                    },
                    {
                        "username": "rahulmangla",
                        "content": "Please, help me, why my code not working?\\n\\nclass Solution {\\npublic:\\n    \\n    int cnt=0;\\n    \\n    long long fun(int i, int k, vector<int> &nums , vector<int> &larger) {\\n        if(i>=k) {\\n            return 0;\\n        }\\n        \\n        while(i<k) {\\n            int j = i + (k-i)/2;\\n            if(nums[j]>nums[i] && nums[j]>nums[k]) cnt+=larger[k];\\n            return fun(i,j-1,nums,larger) + fun(j+1,k,nums,larger);\\n        }\\n        return cnt;\\n    }\\n    \\n    long long countQuadruplets(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        vector<int> larger(n,0);\\n        \\n        for(int i=0;i<n;i++) {\\n            for(int j=i+1;j<n;j++) {\\n                if(nums[i] < nums[j]) larger[i]++;\\n            }\\n        }\\n        \\n        return fun(0,n-1,nums,larger);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "haa_bhai__",
                        "content": "Please someone tell me why is this code just passing 117/119 test cases ..\n\n `long long countQuadruplets(vector<int>& nums) {`\n   `int n=(int)(nums.size());`\n   `if(n<=3)return 0ll;`\n   `long long big[n+2][n+2];`\n   `long long small[n+2][n+2];`\n       ` for(int j=0;j<=n+1;j++){`\n        `    for(int i=0;i<=n+1;i++){`\n         `     small[j][i]=0;`\n          `    big[j][i]=0; ` \n           ` }`\n        `}`\n   `for(int j=2;j<n-1;j++){`\n    `for(int i=0;i<j;i++){`\n      `if(nums[i]<nums[j]){`\n        `small[i][nums[j]]+=1;` \n     ` }`\n    `}`\n   `}`\n   `for(int j=n-3;j>=1;j--){`\n    `for(int i=j+1;i<n;i++){`\n      `if(nums[i]>nums[j]){`\n       ` big[i][nums[j]]+=1;`\n      `}`\n    `}`\n   `}`\n   `for(int j=0;j<n;j++){`\n    `for(int i=n-1;i>=0;i--)big[i][nums[j]]+=big[i+1][nums[j]];`\n   `} `    \n   `for(int j=0;j<n;j++){`\n    `for(int i=1;i<=n;i++)small[i][nums[j]]+=small[i-1][nums[j]];`\n   `}`\n   `long long ans=0;`\n   `for(int j=1;j<n-1;j++){`\n    `for(int k=j+1;k<n-1;k++){`\n      `if(nums[k]<nums[j]){`\n      `long long a1=small[j][nums[k]];`\n      `long long a2=big[k][nums[j]];`\n      `ans+=(a1*1ll*a2);`\n     ` } `\n    `}`\n   `} `\n   `return ans;` \n `}`"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "Please, help me, why my code gets TLE?\\n```\\nvar countQuadruplets = function(nums) {\\n    let res = 0\\n    function f(ind, arr) {\\n        if (arr.length === 4) {\\n            if (arr[0] < arr[2] && arr[0] < arr[1] && arr[0] < arr[3] &&\\n            arr[2] < arr[1] && arr[2] < arr[3] && arr[1] < arr[3]) res++\\n            return\\n        }\\n        for (let i = ind; i < nums.length; i++) {\\n            f(i + 1, [...arr, nums[i]])\\n        }\\n    }\\n    f(0, [])\\n    return res\\n};\\n```"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "[@Souvik4133x](/Souvik4133x) \n```\n4 <= nums.length <= 4000\n1 <= nums[i] <= nums.length\nAll the integers of nums are unique. nums is a permutation.\n```\nwhere is it?"
                    },
                    {
                        "username": "Souvik4133x",
                        "content": "check the time constraint ,recursion will take too much time ,thats why tle is given ."
                    }
                ]
            },
            {
                "id": 2047308,
                "content": [
                    {
                        "username": "ZongyuWu",
                        "content": "Today is Saturday, I should be in a ski resort, not sitting here google for IQ test."
                    },
                    {
                        "username": "arthur_g",
                        "content": "I strongly believe the time constraints are too tight for this problem. I had two O(n^2) solutions, one passed. The other failed. The only difference is the failing one we do an extra double for loop (additional time: N^2). The same failing solution fails in Python but passes CPP. \n\nI also wrote a memoized solution (also N^2) using maps. This also time limit exceeds in both CPP and Py. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@RealFan](/RealFan) Still,C++ gets accepted but python gets stuck at 117/121.Both have O(n^2logn) time complexity"
                    },
                    {
                        "username": "RealFan",
                        "content": "Maybe LeetCode just want to stuck the $O(n^2 \\log n)$ answers."
                    },
                    {
                        "username": "cecilia5",
                        "content": "Lying problem name >_<"
                    },
                    {
                        "username": "czjnbb",
                        "content": "In Python, SortedList results in TLE but using bisect with array gives pretty good time. Weird."
                    },
                    {
                        "username": "RasecBadguy",
                        "content": "I\\xB4m not able to post a public solution for this problem. Do i need pass some review or have more reputation?"
                    },
                    {
                        "username": "chezzyfries",
                        "content": "My O(n^2 logn) solution passed. I had two variations of it. One passed, one TLEd. But I think O(n^2) was expected?"
                    },
                    {
                        "username": "nisaacdz",
                        "content": "This is harder than it looks"
                    },
                    {
                        "username": "rahulmangla",
                        "content": "Please, help me, why my code not working?\\n\\nclass Solution {\\npublic:\\n    \\n    int cnt=0;\\n    \\n    long long fun(int i, int k, vector<int> &nums , vector<int> &larger) {\\n        if(i>=k) {\\n            return 0;\\n        }\\n        \\n        while(i<k) {\\n            int j = i + (k-i)/2;\\n            if(nums[j]>nums[i] && nums[j]>nums[k]) cnt+=larger[k];\\n            return fun(i,j-1,nums,larger) + fun(j+1,k,nums,larger);\\n        }\\n        return cnt;\\n    }\\n    \\n    long long countQuadruplets(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        vector<int> larger(n,0);\\n        \\n        for(int i=0;i<n;i++) {\\n            for(int j=i+1;j<n;j++) {\\n                if(nums[i] < nums[j]) larger[i]++;\\n            }\\n        }\\n        \\n        return fun(0,n-1,nums,larger);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "haa_bhai__",
                        "content": "Please someone tell me why is this code just passing 117/119 test cases ..\n\n `long long countQuadruplets(vector<int>& nums) {`\n   `int n=(int)(nums.size());`\n   `if(n<=3)return 0ll;`\n   `long long big[n+2][n+2];`\n   `long long small[n+2][n+2];`\n       ` for(int j=0;j<=n+1;j++){`\n        `    for(int i=0;i<=n+1;i++){`\n         `     small[j][i]=0;`\n          `    big[j][i]=0; ` \n           ` }`\n        `}`\n   `for(int j=2;j<n-1;j++){`\n    `for(int i=0;i<j;i++){`\n      `if(nums[i]<nums[j]){`\n        `small[i][nums[j]]+=1;` \n     ` }`\n    `}`\n   `}`\n   `for(int j=n-3;j>=1;j--){`\n    `for(int i=j+1;i<n;i++){`\n      `if(nums[i]>nums[j]){`\n       ` big[i][nums[j]]+=1;`\n      `}`\n    `}`\n   `}`\n   `for(int j=0;j<n;j++){`\n    `for(int i=n-1;i>=0;i--)big[i][nums[j]]+=big[i+1][nums[j]];`\n   `} `    \n   `for(int j=0;j<n;j++){`\n    `for(int i=1;i<=n;i++)small[i][nums[j]]+=small[i-1][nums[j]];`\n   `}`\n   `long long ans=0;`\n   `for(int j=1;j<n-1;j++){`\n    `for(int k=j+1;k<n-1;k++){`\n      `if(nums[k]<nums[j]){`\n      `long long a1=small[j][nums[k]];`\n      `long long a2=big[k][nums[j]];`\n      `ans+=(a1*1ll*a2);`\n     ` } `\n    `}`\n   `} `\n   `return ans;` \n `}`"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "Please, help me, why my code gets TLE?\\n```\\nvar countQuadruplets = function(nums) {\\n    let res = 0\\n    function f(ind, arr) {\\n        if (arr.length === 4) {\\n            if (arr[0] < arr[2] && arr[0] < arr[1] && arr[0] < arr[3] &&\\n            arr[2] < arr[1] && arr[2] < arr[3] && arr[1] < arr[3]) res++\\n            return\\n        }\\n        for (let i = ind; i < nums.length; i++) {\\n            f(i + 1, [...arr, nums[i]])\\n        }\\n    }\\n    f(0, [])\\n    return res\\n};\\n```"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "[@Souvik4133x](/Souvik4133x) \n```\n4 <= nums.length <= 4000\n1 <= nums[i] <= nums.length\nAll the integers of nums are unique. nums is a permutation.\n```\nwhere is it?"
                    },
                    {
                        "username": "Souvik4133x",
                        "content": "check the time constraint ,recursion will take too much time ,thats why tle is given ."
                    }
                ]
            },
            {
                "id": 1783936,
                "content": [
                    {
                        "username": "ZongyuWu",
                        "content": "Today is Saturday, I should be in a ski resort, not sitting here google for IQ test."
                    },
                    {
                        "username": "arthur_g",
                        "content": "I strongly believe the time constraints are too tight for this problem. I had two O(n^2) solutions, one passed. The other failed. The only difference is the failing one we do an extra double for loop (additional time: N^2). The same failing solution fails in Python but passes CPP. \n\nI also wrote a memoized solution (also N^2) using maps. This also time limit exceeds in both CPP and Py. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@RealFan](/RealFan) Still,C++ gets accepted but python gets stuck at 117/121.Both have O(n^2logn) time complexity"
                    },
                    {
                        "username": "RealFan",
                        "content": "Maybe LeetCode just want to stuck the $O(n^2 \\log n)$ answers."
                    },
                    {
                        "username": "cecilia5",
                        "content": "Lying problem name >_<"
                    },
                    {
                        "username": "czjnbb",
                        "content": "In Python, SortedList results in TLE but using bisect with array gives pretty good time. Weird."
                    },
                    {
                        "username": "RasecBadguy",
                        "content": "I\\xB4m not able to post a public solution for this problem. Do i need pass some review or have more reputation?"
                    },
                    {
                        "username": "chezzyfries",
                        "content": "My O(n^2 logn) solution passed. I had two variations of it. One passed, one TLEd. But I think O(n^2) was expected?"
                    },
                    {
                        "username": "nisaacdz",
                        "content": "This is harder than it looks"
                    },
                    {
                        "username": "rahulmangla",
                        "content": "Please, help me, why my code not working?\\n\\nclass Solution {\\npublic:\\n    \\n    int cnt=0;\\n    \\n    long long fun(int i, int k, vector<int> &nums , vector<int> &larger) {\\n        if(i>=k) {\\n            return 0;\\n        }\\n        \\n        while(i<k) {\\n            int j = i + (k-i)/2;\\n            if(nums[j]>nums[i] && nums[j]>nums[k]) cnt+=larger[k];\\n            return fun(i,j-1,nums,larger) + fun(j+1,k,nums,larger);\\n        }\\n        return cnt;\\n    }\\n    \\n    long long countQuadruplets(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        vector<int> larger(n,0);\\n        \\n        for(int i=0;i<n;i++) {\\n            for(int j=i+1;j<n;j++) {\\n                if(nums[i] < nums[j]) larger[i]++;\\n            }\\n        }\\n        \\n        return fun(0,n-1,nums,larger);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "haa_bhai__",
                        "content": "Please someone tell me why is this code just passing 117/119 test cases ..\n\n `long long countQuadruplets(vector<int>& nums) {`\n   `int n=(int)(nums.size());`\n   `if(n<=3)return 0ll;`\n   `long long big[n+2][n+2];`\n   `long long small[n+2][n+2];`\n       ` for(int j=0;j<=n+1;j++){`\n        `    for(int i=0;i<=n+1;i++){`\n         `     small[j][i]=0;`\n          `    big[j][i]=0; ` \n           ` }`\n        `}`\n   `for(int j=2;j<n-1;j++){`\n    `for(int i=0;i<j;i++){`\n      `if(nums[i]<nums[j]){`\n        `small[i][nums[j]]+=1;` \n     ` }`\n    `}`\n   `}`\n   `for(int j=n-3;j>=1;j--){`\n    `for(int i=j+1;i<n;i++){`\n      `if(nums[i]>nums[j]){`\n       ` big[i][nums[j]]+=1;`\n      `}`\n    `}`\n   `}`\n   `for(int j=0;j<n;j++){`\n    `for(int i=n-1;i>=0;i--)big[i][nums[j]]+=big[i+1][nums[j]];`\n   `} `    \n   `for(int j=0;j<n;j++){`\n    `for(int i=1;i<=n;i++)small[i][nums[j]]+=small[i-1][nums[j]];`\n   `}`\n   `long long ans=0;`\n   `for(int j=1;j<n-1;j++){`\n    `for(int k=j+1;k<n-1;k++){`\n      `if(nums[k]<nums[j]){`\n      `long long a1=small[j][nums[k]];`\n      `long long a2=big[k][nums[j]];`\n      `ans+=(a1*1ll*a2);`\n     ` } `\n    `}`\n   `} `\n   `return ans;` \n `}`"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "Please, help me, why my code gets TLE?\\n```\\nvar countQuadruplets = function(nums) {\\n    let res = 0\\n    function f(ind, arr) {\\n        if (arr.length === 4) {\\n            if (arr[0] < arr[2] && arr[0] < arr[1] && arr[0] < arr[3] &&\\n            arr[2] < arr[1] && arr[2] < arr[3] && arr[1] < arr[3]) res++\\n            return\\n        }\\n        for (let i = ind; i < nums.length; i++) {\\n            f(i + 1, [...arr, nums[i]])\\n        }\\n    }\\n    f(0, [])\\n    return res\\n};\\n```"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "[@Souvik4133x](/Souvik4133x) \n```\n4 <= nums.length <= 4000\n1 <= nums[i] <= nums.length\nAll the integers of nums are unique. nums is a permutation.\n```\nwhere is it?"
                    },
                    {
                        "username": "Souvik4133x",
                        "content": "check the time constraint ,recursion will take too much time ,thats why tle is given ."
                    }
                ]
            },
            {
                "id": 1779493,
                "content": [
                    {
                        "username": "ZongyuWu",
                        "content": "Today is Saturday, I should be in a ski resort, not sitting here google for IQ test."
                    },
                    {
                        "username": "arthur_g",
                        "content": "I strongly believe the time constraints are too tight for this problem. I had two O(n^2) solutions, one passed. The other failed. The only difference is the failing one we do an extra double for loop (additional time: N^2). The same failing solution fails in Python but passes CPP. \n\nI also wrote a memoized solution (also N^2) using maps. This also time limit exceeds in both CPP and Py. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@RealFan](/RealFan) Still,C++ gets accepted but python gets stuck at 117/121.Both have O(n^2logn) time complexity"
                    },
                    {
                        "username": "RealFan",
                        "content": "Maybe LeetCode just want to stuck the $O(n^2 \\log n)$ answers."
                    },
                    {
                        "username": "cecilia5",
                        "content": "Lying problem name >_<"
                    },
                    {
                        "username": "czjnbb",
                        "content": "In Python, SortedList results in TLE but using bisect with array gives pretty good time. Weird."
                    },
                    {
                        "username": "RasecBadguy",
                        "content": "I\\xB4m not able to post a public solution for this problem. Do i need pass some review or have more reputation?"
                    },
                    {
                        "username": "chezzyfries",
                        "content": "My O(n^2 logn) solution passed. I had two variations of it. One passed, one TLEd. But I think O(n^2) was expected?"
                    },
                    {
                        "username": "nisaacdz",
                        "content": "This is harder than it looks"
                    },
                    {
                        "username": "rahulmangla",
                        "content": "Please, help me, why my code not working?\\n\\nclass Solution {\\npublic:\\n    \\n    int cnt=0;\\n    \\n    long long fun(int i, int k, vector<int> &nums , vector<int> &larger) {\\n        if(i>=k) {\\n            return 0;\\n        }\\n        \\n        while(i<k) {\\n            int j = i + (k-i)/2;\\n            if(nums[j]>nums[i] && nums[j]>nums[k]) cnt+=larger[k];\\n            return fun(i,j-1,nums,larger) + fun(j+1,k,nums,larger);\\n        }\\n        return cnt;\\n    }\\n    \\n    long long countQuadruplets(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        vector<int> larger(n,0);\\n        \\n        for(int i=0;i<n;i++) {\\n            for(int j=i+1;j<n;j++) {\\n                if(nums[i] < nums[j]) larger[i]++;\\n            }\\n        }\\n        \\n        return fun(0,n-1,nums,larger);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "haa_bhai__",
                        "content": "Please someone tell me why is this code just passing 117/119 test cases ..\n\n `long long countQuadruplets(vector<int>& nums) {`\n   `int n=(int)(nums.size());`\n   `if(n<=3)return 0ll;`\n   `long long big[n+2][n+2];`\n   `long long small[n+2][n+2];`\n       ` for(int j=0;j<=n+1;j++){`\n        `    for(int i=0;i<=n+1;i++){`\n         `     small[j][i]=0;`\n          `    big[j][i]=0; ` \n           ` }`\n        `}`\n   `for(int j=2;j<n-1;j++){`\n    `for(int i=0;i<j;i++){`\n      `if(nums[i]<nums[j]){`\n        `small[i][nums[j]]+=1;` \n     ` }`\n    `}`\n   `}`\n   `for(int j=n-3;j>=1;j--){`\n    `for(int i=j+1;i<n;i++){`\n      `if(nums[i]>nums[j]){`\n       ` big[i][nums[j]]+=1;`\n      `}`\n    `}`\n   `}`\n   `for(int j=0;j<n;j++){`\n    `for(int i=n-1;i>=0;i--)big[i][nums[j]]+=big[i+1][nums[j]];`\n   `} `    \n   `for(int j=0;j<n;j++){`\n    `for(int i=1;i<=n;i++)small[i][nums[j]]+=small[i-1][nums[j]];`\n   `}`\n   `long long ans=0;`\n   `for(int j=1;j<n-1;j++){`\n    `for(int k=j+1;k<n-1;k++){`\n      `if(nums[k]<nums[j]){`\n      `long long a1=small[j][nums[k]];`\n      `long long a2=big[k][nums[j]];`\n      `ans+=(a1*1ll*a2);`\n     ` } `\n    `}`\n   `} `\n   `return ans;` \n `}`"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "Please, help me, why my code gets TLE?\\n```\\nvar countQuadruplets = function(nums) {\\n    let res = 0\\n    function f(ind, arr) {\\n        if (arr.length === 4) {\\n            if (arr[0] < arr[2] && arr[0] < arr[1] && arr[0] < arr[3] &&\\n            arr[2] < arr[1] && arr[2] < arr[3] && arr[1] < arr[3]) res++\\n            return\\n        }\\n        for (let i = ind; i < nums.length; i++) {\\n            f(i + 1, [...arr, nums[i]])\\n        }\\n    }\\n    f(0, [])\\n    return res\\n};\\n```"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "[@Souvik4133x](/Souvik4133x) \n```\n4 <= nums.length <= 4000\n1 <= nums[i] <= nums.length\nAll the integers of nums are unique. nums is a permutation.\n```\nwhere is it?"
                    },
                    {
                        "username": "Souvik4133x",
                        "content": "check the time constraint ,recursion will take too much time ,thats why tle is given ."
                    }
                ]
            },
            {
                "id": 1779397,
                "content": [
                    {
                        "username": "ZongyuWu",
                        "content": "Today is Saturday, I should be in a ski resort, not sitting here google for IQ test."
                    },
                    {
                        "username": "arthur_g",
                        "content": "I strongly believe the time constraints are too tight for this problem. I had two O(n^2) solutions, one passed. The other failed. The only difference is the failing one we do an extra double for loop (additional time: N^2). The same failing solution fails in Python but passes CPP. \n\nI also wrote a memoized solution (also N^2) using maps. This also time limit exceeds in both CPP and Py. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@RealFan](/RealFan) Still,C++ gets accepted but python gets stuck at 117/121.Both have O(n^2logn) time complexity"
                    },
                    {
                        "username": "RealFan",
                        "content": "Maybe LeetCode just want to stuck the $O(n^2 \\log n)$ answers."
                    },
                    {
                        "username": "cecilia5",
                        "content": "Lying problem name >_<"
                    },
                    {
                        "username": "czjnbb",
                        "content": "In Python, SortedList results in TLE but using bisect with array gives pretty good time. Weird."
                    },
                    {
                        "username": "RasecBadguy",
                        "content": "I\\xB4m not able to post a public solution for this problem. Do i need pass some review or have more reputation?"
                    },
                    {
                        "username": "chezzyfries",
                        "content": "My O(n^2 logn) solution passed. I had two variations of it. One passed, one TLEd. But I think O(n^2) was expected?"
                    },
                    {
                        "username": "nisaacdz",
                        "content": "This is harder than it looks"
                    },
                    {
                        "username": "rahulmangla",
                        "content": "Please, help me, why my code not working?\\n\\nclass Solution {\\npublic:\\n    \\n    int cnt=0;\\n    \\n    long long fun(int i, int k, vector<int> &nums , vector<int> &larger) {\\n        if(i>=k) {\\n            return 0;\\n        }\\n        \\n        while(i<k) {\\n            int j = i + (k-i)/2;\\n            if(nums[j]>nums[i] && nums[j]>nums[k]) cnt+=larger[k];\\n            return fun(i,j-1,nums,larger) + fun(j+1,k,nums,larger);\\n        }\\n        return cnt;\\n    }\\n    \\n    long long countQuadruplets(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        vector<int> larger(n,0);\\n        \\n        for(int i=0;i<n;i++) {\\n            for(int j=i+1;j<n;j++) {\\n                if(nums[i] < nums[j]) larger[i]++;\\n            }\\n        }\\n        \\n        return fun(0,n-1,nums,larger);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "haa_bhai__",
                        "content": "Please someone tell me why is this code just passing 117/119 test cases ..\n\n `long long countQuadruplets(vector<int>& nums) {`\n   `int n=(int)(nums.size());`\n   `if(n<=3)return 0ll;`\n   `long long big[n+2][n+2];`\n   `long long small[n+2][n+2];`\n       ` for(int j=0;j<=n+1;j++){`\n        `    for(int i=0;i<=n+1;i++){`\n         `     small[j][i]=0;`\n          `    big[j][i]=0; ` \n           ` }`\n        `}`\n   `for(int j=2;j<n-1;j++){`\n    `for(int i=0;i<j;i++){`\n      `if(nums[i]<nums[j]){`\n        `small[i][nums[j]]+=1;` \n     ` }`\n    `}`\n   `}`\n   `for(int j=n-3;j>=1;j--){`\n    `for(int i=j+1;i<n;i++){`\n      `if(nums[i]>nums[j]){`\n       ` big[i][nums[j]]+=1;`\n      `}`\n    `}`\n   `}`\n   `for(int j=0;j<n;j++){`\n    `for(int i=n-1;i>=0;i--)big[i][nums[j]]+=big[i+1][nums[j]];`\n   `} `    \n   `for(int j=0;j<n;j++){`\n    `for(int i=1;i<=n;i++)small[i][nums[j]]+=small[i-1][nums[j]];`\n   `}`\n   `long long ans=0;`\n   `for(int j=1;j<n-1;j++){`\n    `for(int k=j+1;k<n-1;k++){`\n      `if(nums[k]<nums[j]){`\n      `long long a1=small[j][nums[k]];`\n      `long long a2=big[k][nums[j]];`\n      `ans+=(a1*1ll*a2);`\n     ` } `\n    `}`\n   `} `\n   `return ans;` \n `}`"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "Please, help me, why my code gets TLE?\\n```\\nvar countQuadruplets = function(nums) {\\n    let res = 0\\n    function f(ind, arr) {\\n        if (arr.length === 4) {\\n            if (arr[0] < arr[2] && arr[0] < arr[1] && arr[0] < arr[3] &&\\n            arr[2] < arr[1] && arr[2] < arr[3] && arr[1] < arr[3]) res++\\n            return\\n        }\\n        for (let i = ind; i < nums.length; i++) {\\n            f(i + 1, [...arr, nums[i]])\\n        }\\n    }\\n    f(0, [])\\n    return res\\n};\\n```"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "[@Souvik4133x](/Souvik4133x) \n```\n4 <= nums.length <= 4000\n1 <= nums[i] <= nums.length\nAll the integers of nums are unique. nums is a permutation.\n```\nwhere is it?"
                    },
                    {
                        "username": "Souvik4133x",
                        "content": "check the time constraint ,recursion will take too much time ,thats why tle is given ."
                    }
                ]
            },
            {
                "id": 1778744,
                "content": [
                    {
                        "username": "ZongyuWu",
                        "content": "Today is Saturday, I should be in a ski resort, not sitting here google for IQ test."
                    },
                    {
                        "username": "arthur_g",
                        "content": "I strongly believe the time constraints are too tight for this problem. I had two O(n^2) solutions, one passed. The other failed. The only difference is the failing one we do an extra double for loop (additional time: N^2). The same failing solution fails in Python but passes CPP. \n\nI also wrote a memoized solution (also N^2) using maps. This also time limit exceeds in both CPP and Py. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@RealFan](/RealFan) Still,C++ gets accepted but python gets stuck at 117/121.Both have O(n^2logn) time complexity"
                    },
                    {
                        "username": "RealFan",
                        "content": "Maybe LeetCode just want to stuck the $O(n^2 \\log n)$ answers."
                    },
                    {
                        "username": "cecilia5",
                        "content": "Lying problem name >_<"
                    },
                    {
                        "username": "czjnbb",
                        "content": "In Python, SortedList results in TLE but using bisect with array gives pretty good time. Weird."
                    },
                    {
                        "username": "RasecBadguy",
                        "content": "I\\xB4m not able to post a public solution for this problem. Do i need pass some review or have more reputation?"
                    },
                    {
                        "username": "chezzyfries",
                        "content": "My O(n^2 logn) solution passed. I had two variations of it. One passed, one TLEd. But I think O(n^2) was expected?"
                    },
                    {
                        "username": "nisaacdz",
                        "content": "This is harder than it looks"
                    },
                    {
                        "username": "rahulmangla",
                        "content": "Please, help me, why my code not working?\\n\\nclass Solution {\\npublic:\\n    \\n    int cnt=0;\\n    \\n    long long fun(int i, int k, vector<int> &nums , vector<int> &larger) {\\n        if(i>=k) {\\n            return 0;\\n        }\\n        \\n        while(i<k) {\\n            int j = i + (k-i)/2;\\n            if(nums[j]>nums[i] && nums[j]>nums[k]) cnt+=larger[k];\\n            return fun(i,j-1,nums,larger) + fun(j+1,k,nums,larger);\\n        }\\n        return cnt;\\n    }\\n    \\n    long long countQuadruplets(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        vector<int> larger(n,0);\\n        \\n        for(int i=0;i<n;i++) {\\n            for(int j=i+1;j<n;j++) {\\n                if(nums[i] < nums[j]) larger[i]++;\\n            }\\n        }\\n        \\n        return fun(0,n-1,nums,larger);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "haa_bhai__",
                        "content": "Please someone tell me why is this code just passing 117/119 test cases ..\n\n `long long countQuadruplets(vector<int>& nums) {`\n   `int n=(int)(nums.size());`\n   `if(n<=3)return 0ll;`\n   `long long big[n+2][n+2];`\n   `long long small[n+2][n+2];`\n       ` for(int j=0;j<=n+1;j++){`\n        `    for(int i=0;i<=n+1;i++){`\n         `     small[j][i]=0;`\n          `    big[j][i]=0; ` \n           ` }`\n        `}`\n   `for(int j=2;j<n-1;j++){`\n    `for(int i=0;i<j;i++){`\n      `if(nums[i]<nums[j]){`\n        `small[i][nums[j]]+=1;` \n     ` }`\n    `}`\n   `}`\n   `for(int j=n-3;j>=1;j--){`\n    `for(int i=j+1;i<n;i++){`\n      `if(nums[i]>nums[j]){`\n       ` big[i][nums[j]]+=1;`\n      `}`\n    `}`\n   `}`\n   `for(int j=0;j<n;j++){`\n    `for(int i=n-1;i>=0;i--)big[i][nums[j]]+=big[i+1][nums[j]];`\n   `} `    \n   `for(int j=0;j<n;j++){`\n    `for(int i=1;i<=n;i++)small[i][nums[j]]+=small[i-1][nums[j]];`\n   `}`\n   `long long ans=0;`\n   `for(int j=1;j<n-1;j++){`\n    `for(int k=j+1;k<n-1;k++){`\n      `if(nums[k]<nums[j]){`\n      `long long a1=small[j][nums[k]];`\n      `long long a2=big[k][nums[j]];`\n      `ans+=(a1*1ll*a2);`\n     ` } `\n    `}`\n   `} `\n   `return ans;` \n `}`"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "Please, help me, why my code gets TLE?\\n```\\nvar countQuadruplets = function(nums) {\\n    let res = 0\\n    function f(ind, arr) {\\n        if (arr.length === 4) {\\n            if (arr[0] < arr[2] && arr[0] < arr[1] && arr[0] < arr[3] &&\\n            arr[2] < arr[1] && arr[2] < arr[3] && arr[1] < arr[3]) res++\\n            return\\n        }\\n        for (let i = ind; i < nums.length; i++) {\\n            f(i + 1, [...arr, nums[i]])\\n        }\\n    }\\n    f(0, [])\\n    return res\\n};\\n```"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "[@Souvik4133x](/Souvik4133x) \n```\n4 <= nums.length <= 4000\n1 <= nums[i] <= nums.length\nAll the integers of nums are unique. nums is a permutation.\n```\nwhere is it?"
                    },
                    {
                        "username": "Souvik4133x",
                        "content": "check the time constraint ,recursion will take too much time ,thats why tle is given ."
                    }
                ]
            },
            {
                "id": 1778561,
                "content": [
                    {
                        "username": "ZongyuWu",
                        "content": "Today is Saturday, I should be in a ski resort, not sitting here google for IQ test."
                    },
                    {
                        "username": "arthur_g",
                        "content": "I strongly believe the time constraints are too tight for this problem. I had two O(n^2) solutions, one passed. The other failed. The only difference is the failing one we do an extra double for loop (additional time: N^2). The same failing solution fails in Python but passes CPP. \n\nI also wrote a memoized solution (also N^2) using maps. This also time limit exceeds in both CPP and Py. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@RealFan](/RealFan) Still,C++ gets accepted but python gets stuck at 117/121.Both have O(n^2logn) time complexity"
                    },
                    {
                        "username": "RealFan",
                        "content": "Maybe LeetCode just want to stuck the $O(n^2 \\log n)$ answers."
                    },
                    {
                        "username": "cecilia5",
                        "content": "Lying problem name >_<"
                    },
                    {
                        "username": "czjnbb",
                        "content": "In Python, SortedList results in TLE but using bisect with array gives pretty good time. Weird."
                    },
                    {
                        "username": "RasecBadguy",
                        "content": "I\\xB4m not able to post a public solution for this problem. Do i need pass some review or have more reputation?"
                    },
                    {
                        "username": "chezzyfries",
                        "content": "My O(n^2 logn) solution passed. I had two variations of it. One passed, one TLEd. But I think O(n^2) was expected?"
                    },
                    {
                        "username": "nisaacdz",
                        "content": "This is harder than it looks"
                    },
                    {
                        "username": "rahulmangla",
                        "content": "Please, help me, why my code not working?\\n\\nclass Solution {\\npublic:\\n    \\n    int cnt=0;\\n    \\n    long long fun(int i, int k, vector<int> &nums , vector<int> &larger) {\\n        if(i>=k) {\\n            return 0;\\n        }\\n        \\n        while(i<k) {\\n            int j = i + (k-i)/2;\\n            if(nums[j]>nums[i] && nums[j]>nums[k]) cnt+=larger[k];\\n            return fun(i,j-1,nums,larger) + fun(j+1,k,nums,larger);\\n        }\\n        return cnt;\\n    }\\n    \\n    long long countQuadruplets(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        vector<int> larger(n,0);\\n        \\n        for(int i=0;i<n;i++) {\\n            for(int j=i+1;j<n;j++) {\\n                if(nums[i] < nums[j]) larger[i]++;\\n            }\\n        }\\n        \\n        return fun(0,n-1,nums,larger);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "haa_bhai__",
                        "content": "Please someone tell me why is this code just passing 117/119 test cases ..\n\n `long long countQuadruplets(vector<int>& nums) {`\n   `int n=(int)(nums.size());`\n   `if(n<=3)return 0ll;`\n   `long long big[n+2][n+2];`\n   `long long small[n+2][n+2];`\n       ` for(int j=0;j<=n+1;j++){`\n        `    for(int i=0;i<=n+1;i++){`\n         `     small[j][i]=0;`\n          `    big[j][i]=0; ` \n           ` }`\n        `}`\n   `for(int j=2;j<n-1;j++){`\n    `for(int i=0;i<j;i++){`\n      `if(nums[i]<nums[j]){`\n        `small[i][nums[j]]+=1;` \n     ` }`\n    `}`\n   `}`\n   `for(int j=n-3;j>=1;j--){`\n    `for(int i=j+1;i<n;i++){`\n      `if(nums[i]>nums[j]){`\n       ` big[i][nums[j]]+=1;`\n      `}`\n    `}`\n   `}`\n   `for(int j=0;j<n;j++){`\n    `for(int i=n-1;i>=0;i--)big[i][nums[j]]+=big[i+1][nums[j]];`\n   `} `    \n   `for(int j=0;j<n;j++){`\n    `for(int i=1;i<=n;i++)small[i][nums[j]]+=small[i-1][nums[j]];`\n   `}`\n   `long long ans=0;`\n   `for(int j=1;j<n-1;j++){`\n    `for(int k=j+1;k<n-1;k++){`\n      `if(nums[k]<nums[j]){`\n      `long long a1=small[j][nums[k]];`\n      `long long a2=big[k][nums[j]];`\n      `ans+=(a1*1ll*a2);`\n     ` } `\n    `}`\n   `} `\n   `return ans;` \n `}`"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "Please, help me, why my code gets TLE?\\n```\\nvar countQuadruplets = function(nums) {\\n    let res = 0\\n    function f(ind, arr) {\\n        if (arr.length === 4) {\\n            if (arr[0] < arr[2] && arr[0] < arr[1] && arr[0] < arr[3] &&\\n            arr[2] < arr[1] && arr[2] < arr[3] && arr[1] < arr[3]) res++\\n            return\\n        }\\n        for (let i = ind; i < nums.length; i++) {\\n            f(i + 1, [...arr, nums[i]])\\n        }\\n    }\\n    f(0, [])\\n    return res\\n};\\n```"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "[@Souvik4133x](/Souvik4133x) \n```\n4 <= nums.length <= 4000\n1 <= nums[i] <= nums.length\nAll the integers of nums are unique. nums is a permutation.\n```\nwhere is it?"
                    },
                    {
                        "username": "Souvik4133x",
                        "content": "check the time constraint ,recursion will take too much time ,thats why tle is given ."
                    }
                ]
            },
            {
                "id": 1778526,
                "content": [
                    {
                        "username": "ZongyuWu",
                        "content": "Today is Saturday, I should be in a ski resort, not sitting here google for IQ test."
                    },
                    {
                        "username": "arthur_g",
                        "content": "I strongly believe the time constraints are too tight for this problem. I had two O(n^2) solutions, one passed. The other failed. The only difference is the failing one we do an extra double for loop (additional time: N^2). The same failing solution fails in Python but passes CPP. \n\nI also wrote a memoized solution (also N^2) using maps. This also time limit exceeds in both CPP and Py. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@RealFan](/RealFan) Still,C++ gets accepted but python gets stuck at 117/121.Both have O(n^2logn) time complexity"
                    },
                    {
                        "username": "RealFan",
                        "content": "Maybe LeetCode just want to stuck the $O(n^2 \\log n)$ answers."
                    },
                    {
                        "username": "cecilia5",
                        "content": "Lying problem name >_<"
                    },
                    {
                        "username": "czjnbb",
                        "content": "In Python, SortedList results in TLE but using bisect with array gives pretty good time. Weird."
                    },
                    {
                        "username": "RasecBadguy",
                        "content": "I\\xB4m not able to post a public solution for this problem. Do i need pass some review or have more reputation?"
                    },
                    {
                        "username": "chezzyfries",
                        "content": "My O(n^2 logn) solution passed. I had two variations of it. One passed, one TLEd. But I think O(n^2) was expected?"
                    },
                    {
                        "username": "nisaacdz",
                        "content": "This is harder than it looks"
                    },
                    {
                        "username": "rahulmangla",
                        "content": "Please, help me, why my code not working?\\n\\nclass Solution {\\npublic:\\n    \\n    int cnt=0;\\n    \\n    long long fun(int i, int k, vector<int> &nums , vector<int> &larger) {\\n        if(i>=k) {\\n            return 0;\\n        }\\n        \\n        while(i<k) {\\n            int j = i + (k-i)/2;\\n            if(nums[j]>nums[i] && nums[j]>nums[k]) cnt+=larger[k];\\n            return fun(i,j-1,nums,larger) + fun(j+1,k,nums,larger);\\n        }\\n        return cnt;\\n    }\\n    \\n    long long countQuadruplets(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        vector<int> larger(n,0);\\n        \\n        for(int i=0;i<n;i++) {\\n            for(int j=i+1;j<n;j++) {\\n                if(nums[i] < nums[j]) larger[i]++;\\n            }\\n        }\\n        \\n        return fun(0,n-1,nums,larger);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "haa_bhai__",
                        "content": "Please someone tell me why is this code just passing 117/119 test cases ..\n\n `long long countQuadruplets(vector<int>& nums) {`\n   `int n=(int)(nums.size());`\n   `if(n<=3)return 0ll;`\n   `long long big[n+2][n+2];`\n   `long long small[n+2][n+2];`\n       ` for(int j=0;j<=n+1;j++){`\n        `    for(int i=0;i<=n+1;i++){`\n         `     small[j][i]=0;`\n          `    big[j][i]=0; ` \n           ` }`\n        `}`\n   `for(int j=2;j<n-1;j++){`\n    `for(int i=0;i<j;i++){`\n      `if(nums[i]<nums[j]){`\n        `small[i][nums[j]]+=1;` \n     ` }`\n    `}`\n   `}`\n   `for(int j=n-3;j>=1;j--){`\n    `for(int i=j+1;i<n;i++){`\n      `if(nums[i]>nums[j]){`\n       ` big[i][nums[j]]+=1;`\n      `}`\n    `}`\n   `}`\n   `for(int j=0;j<n;j++){`\n    `for(int i=n-1;i>=0;i--)big[i][nums[j]]+=big[i+1][nums[j]];`\n   `} `    \n   `for(int j=0;j<n;j++){`\n    `for(int i=1;i<=n;i++)small[i][nums[j]]+=small[i-1][nums[j]];`\n   `}`\n   `long long ans=0;`\n   `for(int j=1;j<n-1;j++){`\n    `for(int k=j+1;k<n-1;k++){`\n      `if(nums[k]<nums[j]){`\n      `long long a1=small[j][nums[k]];`\n      `long long a2=big[k][nums[j]];`\n      `ans+=(a1*1ll*a2);`\n     ` } `\n    `}`\n   `} `\n   `return ans;` \n `}`"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "Please, help me, why my code gets TLE?\\n```\\nvar countQuadruplets = function(nums) {\\n    let res = 0\\n    function f(ind, arr) {\\n        if (arr.length === 4) {\\n            if (arr[0] < arr[2] && arr[0] < arr[1] && arr[0] < arr[3] &&\\n            arr[2] < arr[1] && arr[2] < arr[3] && arr[1] < arr[3]) res++\\n            return\\n        }\\n        for (let i = ind; i < nums.length; i++) {\\n            f(i + 1, [...arr, nums[i]])\\n        }\\n    }\\n    f(0, [])\\n    return res\\n};\\n```"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "[@Souvik4133x](/Souvik4133x) \n```\n4 <= nums.length <= 4000\n1 <= nums[i] <= nums.length\nAll the integers of nums are unique. nums is a permutation.\n```\nwhere is it?"
                    },
                    {
                        "username": "Souvik4133x",
                        "content": "check the time constraint ,recursion will take too much time ,thats why tle is given ."
                    }
                ]
            },
            {
                "id": 1778581,
                "content": [
                    {
                        "username": "ZongyuWu",
                        "content": "Today is Saturday, I should be in a ski resort, not sitting here google for IQ test."
                    },
                    {
                        "username": "arthur_g",
                        "content": "I strongly believe the time constraints are too tight for this problem. I had two O(n^2) solutions, one passed. The other failed. The only difference is the failing one we do an extra double for loop (additional time: N^2). The same failing solution fails in Python but passes CPP. \n\nI also wrote a memoized solution (also N^2) using maps. This also time limit exceeds in both CPP and Py. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@RealFan](/RealFan) Still,C++ gets accepted but python gets stuck at 117/121.Both have O(n^2logn) time complexity"
                    },
                    {
                        "username": "RealFan",
                        "content": "Maybe LeetCode just want to stuck the $O(n^2 \\log n)$ answers."
                    },
                    {
                        "username": "cecilia5",
                        "content": "Lying problem name >_<"
                    },
                    {
                        "username": "czjnbb",
                        "content": "In Python, SortedList results in TLE but using bisect with array gives pretty good time. Weird."
                    },
                    {
                        "username": "RasecBadguy",
                        "content": "I\\xB4m not able to post a public solution for this problem. Do i need pass some review or have more reputation?"
                    },
                    {
                        "username": "chezzyfries",
                        "content": "My O(n^2 logn) solution passed. I had two variations of it. One passed, one TLEd. But I think O(n^2) was expected?"
                    },
                    {
                        "username": "nisaacdz",
                        "content": "This is harder than it looks"
                    },
                    {
                        "username": "rahulmangla",
                        "content": "Please, help me, why my code not working?\\n\\nclass Solution {\\npublic:\\n    \\n    int cnt=0;\\n    \\n    long long fun(int i, int k, vector<int> &nums , vector<int> &larger) {\\n        if(i>=k) {\\n            return 0;\\n        }\\n        \\n        while(i<k) {\\n            int j = i + (k-i)/2;\\n            if(nums[j]>nums[i] && nums[j]>nums[k]) cnt+=larger[k];\\n            return fun(i,j-1,nums,larger) + fun(j+1,k,nums,larger);\\n        }\\n        return cnt;\\n    }\\n    \\n    long long countQuadruplets(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        vector<int> larger(n,0);\\n        \\n        for(int i=0;i<n;i++) {\\n            for(int j=i+1;j<n;j++) {\\n                if(nums[i] < nums[j]) larger[i]++;\\n            }\\n        }\\n        \\n        return fun(0,n-1,nums,larger);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "haa_bhai__",
                        "content": "Please someone tell me why is this code just passing 117/119 test cases ..\n\n `long long countQuadruplets(vector<int>& nums) {`\n   `int n=(int)(nums.size());`\n   `if(n<=3)return 0ll;`\n   `long long big[n+2][n+2];`\n   `long long small[n+2][n+2];`\n       ` for(int j=0;j<=n+1;j++){`\n        `    for(int i=0;i<=n+1;i++){`\n         `     small[j][i]=0;`\n          `    big[j][i]=0; ` \n           ` }`\n        `}`\n   `for(int j=2;j<n-1;j++){`\n    `for(int i=0;i<j;i++){`\n      `if(nums[i]<nums[j]){`\n        `small[i][nums[j]]+=1;` \n     ` }`\n    `}`\n   `}`\n   `for(int j=n-3;j>=1;j--){`\n    `for(int i=j+1;i<n;i++){`\n      `if(nums[i]>nums[j]){`\n       ` big[i][nums[j]]+=1;`\n      `}`\n    `}`\n   `}`\n   `for(int j=0;j<n;j++){`\n    `for(int i=n-1;i>=0;i--)big[i][nums[j]]+=big[i+1][nums[j]];`\n   `} `    \n   `for(int j=0;j<n;j++){`\n    `for(int i=1;i<=n;i++)small[i][nums[j]]+=small[i-1][nums[j]];`\n   `}`\n   `long long ans=0;`\n   `for(int j=1;j<n-1;j++){`\n    `for(int k=j+1;k<n-1;k++){`\n      `if(nums[k]<nums[j]){`\n      `long long a1=small[j][nums[k]];`\n      `long long a2=big[k][nums[j]];`\n      `ans+=(a1*1ll*a2);`\n     ` } `\n    `}`\n   `} `\n   `return ans;` \n `}`"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "Please, help me, why my code gets TLE?\\n```\\nvar countQuadruplets = function(nums) {\\n    let res = 0\\n    function f(ind, arr) {\\n        if (arr.length === 4) {\\n            if (arr[0] < arr[2] && arr[0] < arr[1] && arr[0] < arr[3] &&\\n            arr[2] < arr[1] && arr[2] < arr[3] && arr[1] < arr[3]) res++\\n            return\\n        }\\n        for (let i = ind; i < nums.length; i++) {\\n            f(i + 1, [...arr, nums[i]])\\n        }\\n    }\\n    f(0, [])\\n    return res\\n};\\n```"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "[@Souvik4133x](/Souvik4133x) \n```\n4 <= nums.length <= 4000\n1 <= nums[i] <= nums.length\nAll the integers of nums are unique. nums is a permutation.\n```\nwhere is it?"
                    },
                    {
                        "username": "Souvik4133x",
                        "content": "check the time constraint ,recursion will take too much time ,thats why tle is given ."
                    }
                ]
            },
            {
                "id": 1778834,
                "content": [
                    {
                        "username": "ZongyuWu",
                        "content": "Today is Saturday, I should be in a ski resort, not sitting here google for IQ test."
                    },
                    {
                        "username": "arthur_g",
                        "content": "I strongly believe the time constraints are too tight for this problem. I had two O(n^2) solutions, one passed. The other failed. The only difference is the failing one we do an extra double for loop (additional time: N^2). The same failing solution fails in Python but passes CPP. \n\nI also wrote a memoized solution (also N^2) using maps. This also time limit exceeds in both CPP and Py. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@RealFan](/RealFan) Still,C++ gets accepted but python gets stuck at 117/121.Both have O(n^2logn) time complexity"
                    },
                    {
                        "username": "RealFan",
                        "content": "Maybe LeetCode just want to stuck the $O(n^2 \\log n)$ answers."
                    },
                    {
                        "username": "cecilia5",
                        "content": "Lying problem name >_<"
                    },
                    {
                        "username": "czjnbb",
                        "content": "In Python, SortedList results in TLE but using bisect with array gives pretty good time. Weird."
                    },
                    {
                        "username": "RasecBadguy",
                        "content": "I\\xB4m not able to post a public solution for this problem. Do i need pass some review or have more reputation?"
                    },
                    {
                        "username": "chezzyfries",
                        "content": "My O(n^2 logn) solution passed. I had two variations of it. One passed, one TLEd. But I think O(n^2) was expected?"
                    },
                    {
                        "username": "nisaacdz",
                        "content": "This is harder than it looks"
                    },
                    {
                        "username": "rahulmangla",
                        "content": "Please, help me, why my code not working?\\n\\nclass Solution {\\npublic:\\n    \\n    int cnt=0;\\n    \\n    long long fun(int i, int k, vector<int> &nums , vector<int> &larger) {\\n        if(i>=k) {\\n            return 0;\\n        }\\n        \\n        while(i<k) {\\n            int j = i + (k-i)/2;\\n            if(nums[j]>nums[i] && nums[j]>nums[k]) cnt+=larger[k];\\n            return fun(i,j-1,nums,larger) + fun(j+1,k,nums,larger);\\n        }\\n        return cnt;\\n    }\\n    \\n    long long countQuadruplets(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        vector<int> larger(n,0);\\n        \\n        for(int i=0;i<n;i++) {\\n            for(int j=i+1;j<n;j++) {\\n                if(nums[i] < nums[j]) larger[i]++;\\n            }\\n        }\\n        \\n        return fun(0,n-1,nums,larger);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "haa_bhai__",
                        "content": "Please someone tell me why is this code just passing 117/119 test cases ..\n\n `long long countQuadruplets(vector<int>& nums) {`\n   `int n=(int)(nums.size());`\n   `if(n<=3)return 0ll;`\n   `long long big[n+2][n+2];`\n   `long long small[n+2][n+2];`\n       ` for(int j=0;j<=n+1;j++){`\n        `    for(int i=0;i<=n+1;i++){`\n         `     small[j][i]=0;`\n          `    big[j][i]=0; ` \n           ` }`\n        `}`\n   `for(int j=2;j<n-1;j++){`\n    `for(int i=0;i<j;i++){`\n      `if(nums[i]<nums[j]){`\n        `small[i][nums[j]]+=1;` \n     ` }`\n    `}`\n   `}`\n   `for(int j=n-3;j>=1;j--){`\n    `for(int i=j+1;i<n;i++){`\n      `if(nums[i]>nums[j]){`\n       ` big[i][nums[j]]+=1;`\n      `}`\n    `}`\n   `}`\n   `for(int j=0;j<n;j++){`\n    `for(int i=n-1;i>=0;i--)big[i][nums[j]]+=big[i+1][nums[j]];`\n   `} `    \n   `for(int j=0;j<n;j++){`\n    `for(int i=1;i<=n;i++)small[i][nums[j]]+=small[i-1][nums[j]];`\n   `}`\n   `long long ans=0;`\n   `for(int j=1;j<n-1;j++){`\n    `for(int k=j+1;k<n-1;k++){`\n      `if(nums[k]<nums[j]){`\n      `long long a1=small[j][nums[k]];`\n      `long long a2=big[k][nums[j]];`\n      `ans+=(a1*1ll*a2);`\n     ` } `\n    `}`\n   `} `\n   `return ans;` \n `}`"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "Please, help me, why my code gets TLE?\\n```\\nvar countQuadruplets = function(nums) {\\n    let res = 0\\n    function f(ind, arr) {\\n        if (arr.length === 4) {\\n            if (arr[0] < arr[2] && arr[0] < arr[1] && arr[0] < arr[3] &&\\n            arr[2] < arr[1] && arr[2] < arr[3] && arr[1] < arr[3]) res++\\n            return\\n        }\\n        for (let i = ind; i < nums.length; i++) {\\n            f(i + 1, [...arr, nums[i]])\\n        }\\n    }\\n    f(0, [])\\n    return res\\n};\\n```"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "[@Souvik4133x](/Souvik4133x) \n```\n4 <= nums.length <= 4000\n1 <= nums[i] <= nums.length\nAll the integers of nums are unique. nums is a permutation.\n```\nwhere is it?"
                    },
                    {
                        "username": "Souvik4133x",
                        "content": "check the time constraint ,recursion will take too much time ,thats why tle is given ."
                    }
                ]
            },
            {
                "id": 1778721,
                "content": [
                    {
                        "username": "ZongyuWu",
                        "content": "Today is Saturday, I should be in a ski resort, not sitting here google for IQ test."
                    },
                    {
                        "username": "arthur_g",
                        "content": "I strongly believe the time constraints are too tight for this problem. I had two O(n^2) solutions, one passed. The other failed. The only difference is the failing one we do an extra double for loop (additional time: N^2). The same failing solution fails in Python but passes CPP. \n\nI also wrote a memoized solution (also N^2) using maps. This also time limit exceeds in both CPP and Py. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@RealFan](/RealFan) Still,C++ gets accepted but python gets stuck at 117/121.Both have O(n^2logn) time complexity"
                    },
                    {
                        "username": "RealFan",
                        "content": "Maybe LeetCode just want to stuck the $O(n^2 \\log n)$ answers."
                    },
                    {
                        "username": "cecilia5",
                        "content": "Lying problem name >_<"
                    },
                    {
                        "username": "czjnbb",
                        "content": "In Python, SortedList results in TLE but using bisect with array gives pretty good time. Weird."
                    },
                    {
                        "username": "RasecBadguy",
                        "content": "I\\xB4m not able to post a public solution for this problem. Do i need pass some review or have more reputation?"
                    },
                    {
                        "username": "chezzyfries",
                        "content": "My O(n^2 logn) solution passed. I had two variations of it. One passed, one TLEd. But I think O(n^2) was expected?"
                    },
                    {
                        "username": "nisaacdz",
                        "content": "This is harder than it looks"
                    },
                    {
                        "username": "rahulmangla",
                        "content": "Please, help me, why my code not working?\\n\\nclass Solution {\\npublic:\\n    \\n    int cnt=0;\\n    \\n    long long fun(int i, int k, vector<int> &nums , vector<int> &larger) {\\n        if(i>=k) {\\n            return 0;\\n        }\\n        \\n        while(i<k) {\\n            int j = i + (k-i)/2;\\n            if(nums[j]>nums[i] && nums[j]>nums[k]) cnt+=larger[k];\\n            return fun(i,j-1,nums,larger) + fun(j+1,k,nums,larger);\\n        }\\n        return cnt;\\n    }\\n    \\n    long long countQuadruplets(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        vector<int> larger(n,0);\\n        \\n        for(int i=0;i<n;i++) {\\n            for(int j=i+1;j<n;j++) {\\n                if(nums[i] < nums[j]) larger[i]++;\\n            }\\n        }\\n        \\n        return fun(0,n-1,nums,larger);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "haa_bhai__",
                        "content": "Please someone tell me why is this code just passing 117/119 test cases ..\n\n `long long countQuadruplets(vector<int>& nums) {`\n   `int n=(int)(nums.size());`\n   `if(n<=3)return 0ll;`\n   `long long big[n+2][n+2];`\n   `long long small[n+2][n+2];`\n       ` for(int j=0;j<=n+1;j++){`\n        `    for(int i=0;i<=n+1;i++){`\n         `     small[j][i]=0;`\n          `    big[j][i]=0; ` \n           ` }`\n        `}`\n   `for(int j=2;j<n-1;j++){`\n    `for(int i=0;i<j;i++){`\n      `if(nums[i]<nums[j]){`\n        `small[i][nums[j]]+=1;` \n     ` }`\n    `}`\n   `}`\n   `for(int j=n-3;j>=1;j--){`\n    `for(int i=j+1;i<n;i++){`\n      `if(nums[i]>nums[j]){`\n       ` big[i][nums[j]]+=1;`\n      `}`\n    `}`\n   `}`\n   `for(int j=0;j<n;j++){`\n    `for(int i=n-1;i>=0;i--)big[i][nums[j]]+=big[i+1][nums[j]];`\n   `} `    \n   `for(int j=0;j<n;j++){`\n    `for(int i=1;i<=n;i++)small[i][nums[j]]+=small[i-1][nums[j]];`\n   `}`\n   `long long ans=0;`\n   `for(int j=1;j<n-1;j++){`\n    `for(int k=j+1;k<n-1;k++){`\n      `if(nums[k]<nums[j]){`\n      `long long a1=small[j][nums[k]];`\n      `long long a2=big[k][nums[j]];`\n      `ans+=(a1*1ll*a2);`\n     ` } `\n    `}`\n   `} `\n   `return ans;` \n `}`"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "Please, help me, why my code gets TLE?\\n```\\nvar countQuadruplets = function(nums) {\\n    let res = 0\\n    function f(ind, arr) {\\n        if (arr.length === 4) {\\n            if (arr[0] < arr[2] && arr[0] < arr[1] && arr[0] < arr[3] &&\\n            arr[2] < arr[1] && arr[2] < arr[3] && arr[1] < arr[3]) res++\\n            return\\n        }\\n        for (let i = ind; i < nums.length; i++) {\\n            f(i + 1, [...arr, nums[i]])\\n        }\\n    }\\n    f(0, [])\\n    return res\\n};\\n```"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "[@Souvik4133x](/Souvik4133x) \n```\n4 <= nums.length <= 4000\n1 <= nums[i] <= nums.length\nAll the integers of nums are unique. nums is a permutation.\n```\nwhere is it?"
                    },
                    {
                        "username": "Souvik4133x",
                        "content": "check the time constraint ,recursion will take too much time ,thats why tle is given ."
                    }
                ]
            },
            {
                "id": 2047308,
                "content": [
                    {
                        "username": "ZongyuWu",
                        "content": "Today is Saturday, I should be in a ski resort, not sitting here google for IQ test."
                    },
                    {
                        "username": "arthur_g",
                        "content": "I strongly believe the time constraints are too tight for this problem. I had two O(n^2) solutions, one passed. The other failed. The only difference is the failing one we do an extra double for loop (additional time: N^2). The same failing solution fails in Python but passes CPP. \n\nI also wrote a memoized solution (also N^2) using maps. This also time limit exceeds in both CPP and Py. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@RealFan](/RealFan) Still,C++ gets accepted but python gets stuck at 117/121.Both have O(n^2logn) time complexity"
                    },
                    {
                        "username": "RealFan",
                        "content": "Maybe LeetCode just want to stuck the $O(n^2 \\log n)$ answers."
                    },
                    {
                        "username": "cecilia5",
                        "content": "Lying problem name >_<"
                    },
                    {
                        "username": "czjnbb",
                        "content": "In Python, SortedList results in TLE but using bisect with array gives pretty good time. Weird."
                    },
                    {
                        "username": "RasecBadguy",
                        "content": "I\\xB4m not able to post a public solution for this problem. Do i need pass some review or have more reputation?"
                    },
                    {
                        "username": "chezzyfries",
                        "content": "My O(n^2 logn) solution passed. I had two variations of it. One passed, one TLEd. But I think O(n^2) was expected?"
                    },
                    {
                        "username": "nisaacdz",
                        "content": "This is harder than it looks"
                    },
                    {
                        "username": "rahulmangla",
                        "content": "Please, help me, why my code not working?\\n\\nclass Solution {\\npublic:\\n    \\n    int cnt=0;\\n    \\n    long long fun(int i, int k, vector<int> &nums , vector<int> &larger) {\\n        if(i>=k) {\\n            return 0;\\n        }\\n        \\n        while(i<k) {\\n            int j = i + (k-i)/2;\\n            if(nums[j]>nums[i] && nums[j]>nums[k]) cnt+=larger[k];\\n            return fun(i,j-1,nums,larger) + fun(j+1,k,nums,larger);\\n        }\\n        return cnt;\\n    }\\n    \\n    long long countQuadruplets(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        vector<int> larger(n,0);\\n        \\n        for(int i=0;i<n;i++) {\\n            for(int j=i+1;j<n;j++) {\\n                if(nums[i] < nums[j]) larger[i]++;\\n            }\\n        }\\n        \\n        return fun(0,n-1,nums,larger);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "haa_bhai__",
                        "content": "Please someone tell me why is this code just passing 117/119 test cases ..\n\n `long long countQuadruplets(vector<int>& nums) {`\n   `int n=(int)(nums.size());`\n   `if(n<=3)return 0ll;`\n   `long long big[n+2][n+2];`\n   `long long small[n+2][n+2];`\n       ` for(int j=0;j<=n+1;j++){`\n        `    for(int i=0;i<=n+1;i++){`\n         `     small[j][i]=0;`\n          `    big[j][i]=0; ` \n           ` }`\n        `}`\n   `for(int j=2;j<n-1;j++){`\n    `for(int i=0;i<j;i++){`\n      `if(nums[i]<nums[j]){`\n        `small[i][nums[j]]+=1;` \n     ` }`\n    `}`\n   `}`\n   `for(int j=n-3;j>=1;j--){`\n    `for(int i=j+1;i<n;i++){`\n      `if(nums[i]>nums[j]){`\n       ` big[i][nums[j]]+=1;`\n      `}`\n    `}`\n   `}`\n   `for(int j=0;j<n;j++){`\n    `for(int i=n-1;i>=0;i--)big[i][nums[j]]+=big[i+1][nums[j]];`\n   `} `    \n   `for(int j=0;j<n;j++){`\n    `for(int i=1;i<=n;i++)small[i][nums[j]]+=small[i-1][nums[j]];`\n   `}`\n   `long long ans=0;`\n   `for(int j=1;j<n-1;j++){`\n    `for(int k=j+1;k<n-1;k++){`\n      `if(nums[k]<nums[j]){`\n      `long long a1=small[j][nums[k]];`\n      `long long a2=big[k][nums[j]];`\n      `ans+=(a1*1ll*a2);`\n     ` } `\n    `}`\n   `} `\n   `return ans;` \n `}`"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "Please, help me, why my code gets TLE?\\n```\\nvar countQuadruplets = function(nums) {\\n    let res = 0\\n    function f(ind, arr) {\\n        if (arr.length === 4) {\\n            if (arr[0] < arr[2] && arr[0] < arr[1] && arr[0] < arr[3] &&\\n            arr[2] < arr[1] && arr[2] < arr[3] && arr[1] < arr[3]) res++\\n            return\\n        }\\n        for (let i = ind; i < nums.length; i++) {\\n            f(i + 1, [...arr, nums[i]])\\n        }\\n    }\\n    f(0, [])\\n    return res\\n};\\n```"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "[@Souvik4133x](/Souvik4133x) \n```\n4 <= nums.length <= 4000\n1 <= nums[i] <= nums.length\nAll the integers of nums are unique. nums is a permutation.\n```\nwhere is it?"
                    },
                    {
                        "username": "Souvik4133x",
                        "content": "check the time constraint ,recursion will take too much time ,thats why tle is given ."
                    }
                ]
            },
            {
                "id": 1783936,
                "content": [
                    {
                        "username": "ZongyuWu",
                        "content": "Today is Saturday, I should be in a ski resort, not sitting here google for IQ test."
                    },
                    {
                        "username": "arthur_g",
                        "content": "I strongly believe the time constraints are too tight for this problem. I had two O(n^2) solutions, one passed. The other failed. The only difference is the failing one we do an extra double for loop (additional time: N^2). The same failing solution fails in Python but passes CPP. \n\nI also wrote a memoized solution (also N^2) using maps. This also time limit exceeds in both CPP and Py. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@RealFan](/RealFan) Still,C++ gets accepted but python gets stuck at 117/121.Both have O(n^2logn) time complexity"
                    },
                    {
                        "username": "RealFan",
                        "content": "Maybe LeetCode just want to stuck the $O(n^2 \\log n)$ answers."
                    },
                    {
                        "username": "cecilia5",
                        "content": "Lying problem name >_<"
                    },
                    {
                        "username": "czjnbb",
                        "content": "In Python, SortedList results in TLE but using bisect with array gives pretty good time. Weird."
                    },
                    {
                        "username": "RasecBadguy",
                        "content": "I\\xB4m not able to post a public solution for this problem. Do i need pass some review or have more reputation?"
                    },
                    {
                        "username": "chezzyfries",
                        "content": "My O(n^2 logn) solution passed. I had two variations of it. One passed, one TLEd. But I think O(n^2) was expected?"
                    },
                    {
                        "username": "nisaacdz",
                        "content": "This is harder than it looks"
                    },
                    {
                        "username": "rahulmangla",
                        "content": "Please, help me, why my code not working?\\n\\nclass Solution {\\npublic:\\n    \\n    int cnt=0;\\n    \\n    long long fun(int i, int k, vector<int> &nums , vector<int> &larger) {\\n        if(i>=k) {\\n            return 0;\\n        }\\n        \\n        while(i<k) {\\n            int j = i + (k-i)/2;\\n            if(nums[j]>nums[i] && nums[j]>nums[k]) cnt+=larger[k];\\n            return fun(i,j-1,nums,larger) + fun(j+1,k,nums,larger);\\n        }\\n        return cnt;\\n    }\\n    \\n    long long countQuadruplets(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        vector<int> larger(n,0);\\n        \\n        for(int i=0;i<n;i++) {\\n            for(int j=i+1;j<n;j++) {\\n                if(nums[i] < nums[j]) larger[i]++;\\n            }\\n        }\\n        \\n        return fun(0,n-1,nums,larger);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "haa_bhai__",
                        "content": "Please someone tell me why is this code just passing 117/119 test cases ..\n\n `long long countQuadruplets(vector<int>& nums) {`\n   `int n=(int)(nums.size());`\n   `if(n<=3)return 0ll;`\n   `long long big[n+2][n+2];`\n   `long long small[n+2][n+2];`\n       ` for(int j=0;j<=n+1;j++){`\n        `    for(int i=0;i<=n+1;i++){`\n         `     small[j][i]=0;`\n          `    big[j][i]=0; ` \n           ` }`\n        `}`\n   `for(int j=2;j<n-1;j++){`\n    `for(int i=0;i<j;i++){`\n      `if(nums[i]<nums[j]){`\n        `small[i][nums[j]]+=1;` \n     ` }`\n    `}`\n   `}`\n   `for(int j=n-3;j>=1;j--){`\n    `for(int i=j+1;i<n;i++){`\n      `if(nums[i]>nums[j]){`\n       ` big[i][nums[j]]+=1;`\n      `}`\n    `}`\n   `}`\n   `for(int j=0;j<n;j++){`\n    `for(int i=n-1;i>=0;i--)big[i][nums[j]]+=big[i+1][nums[j]];`\n   `} `    \n   `for(int j=0;j<n;j++){`\n    `for(int i=1;i<=n;i++)small[i][nums[j]]+=small[i-1][nums[j]];`\n   `}`\n   `long long ans=0;`\n   `for(int j=1;j<n-1;j++){`\n    `for(int k=j+1;k<n-1;k++){`\n      `if(nums[k]<nums[j]){`\n      `long long a1=small[j][nums[k]];`\n      `long long a2=big[k][nums[j]];`\n      `ans+=(a1*1ll*a2);`\n     ` } `\n    `}`\n   `} `\n   `return ans;` \n `}`"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "Please, help me, why my code gets TLE?\\n```\\nvar countQuadruplets = function(nums) {\\n    let res = 0\\n    function f(ind, arr) {\\n        if (arr.length === 4) {\\n            if (arr[0] < arr[2] && arr[0] < arr[1] && arr[0] < arr[3] &&\\n            arr[2] < arr[1] && arr[2] < arr[3] && arr[1] < arr[3]) res++\\n            return\\n        }\\n        for (let i = ind; i < nums.length; i++) {\\n            f(i + 1, [...arr, nums[i]])\\n        }\\n    }\\n    f(0, [])\\n    return res\\n};\\n```"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "[@Souvik4133x](/Souvik4133x) \n```\n4 <= nums.length <= 4000\n1 <= nums[i] <= nums.length\nAll the integers of nums are unique. nums is a permutation.\n```\nwhere is it?"
                    },
                    {
                        "username": "Souvik4133x",
                        "content": "check the time constraint ,recursion will take too much time ,thats why tle is given ."
                    }
                ]
            },
            {
                "id": 1779493,
                "content": [
                    {
                        "username": "ZongyuWu",
                        "content": "Today is Saturday, I should be in a ski resort, not sitting here google for IQ test."
                    },
                    {
                        "username": "arthur_g",
                        "content": "I strongly believe the time constraints are too tight for this problem. I had two O(n^2) solutions, one passed. The other failed. The only difference is the failing one we do an extra double for loop (additional time: N^2). The same failing solution fails in Python but passes CPP. \n\nI also wrote a memoized solution (also N^2) using maps. This also time limit exceeds in both CPP and Py. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@RealFan](/RealFan) Still,C++ gets accepted but python gets stuck at 117/121.Both have O(n^2logn) time complexity"
                    },
                    {
                        "username": "RealFan",
                        "content": "Maybe LeetCode just want to stuck the $O(n^2 \\log n)$ answers."
                    },
                    {
                        "username": "cecilia5",
                        "content": "Lying problem name >_<"
                    },
                    {
                        "username": "czjnbb",
                        "content": "In Python, SortedList results in TLE but using bisect with array gives pretty good time. Weird."
                    },
                    {
                        "username": "RasecBadguy",
                        "content": "I\\xB4m not able to post a public solution for this problem. Do i need pass some review or have more reputation?"
                    },
                    {
                        "username": "chezzyfries",
                        "content": "My O(n^2 logn) solution passed. I had two variations of it. One passed, one TLEd. But I think O(n^2) was expected?"
                    },
                    {
                        "username": "nisaacdz",
                        "content": "This is harder than it looks"
                    },
                    {
                        "username": "rahulmangla",
                        "content": "Please, help me, why my code not working?\\n\\nclass Solution {\\npublic:\\n    \\n    int cnt=0;\\n    \\n    long long fun(int i, int k, vector<int> &nums , vector<int> &larger) {\\n        if(i>=k) {\\n            return 0;\\n        }\\n        \\n        while(i<k) {\\n            int j = i + (k-i)/2;\\n            if(nums[j]>nums[i] && nums[j]>nums[k]) cnt+=larger[k];\\n            return fun(i,j-1,nums,larger) + fun(j+1,k,nums,larger);\\n        }\\n        return cnt;\\n    }\\n    \\n    long long countQuadruplets(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        vector<int> larger(n,0);\\n        \\n        for(int i=0;i<n;i++) {\\n            for(int j=i+1;j<n;j++) {\\n                if(nums[i] < nums[j]) larger[i]++;\\n            }\\n        }\\n        \\n        return fun(0,n-1,nums,larger);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "haa_bhai__",
                        "content": "Please someone tell me why is this code just passing 117/119 test cases ..\n\n `long long countQuadruplets(vector<int>& nums) {`\n   `int n=(int)(nums.size());`\n   `if(n<=3)return 0ll;`\n   `long long big[n+2][n+2];`\n   `long long small[n+2][n+2];`\n       ` for(int j=0;j<=n+1;j++){`\n        `    for(int i=0;i<=n+1;i++){`\n         `     small[j][i]=0;`\n          `    big[j][i]=0; ` \n           ` }`\n        `}`\n   `for(int j=2;j<n-1;j++){`\n    `for(int i=0;i<j;i++){`\n      `if(nums[i]<nums[j]){`\n        `small[i][nums[j]]+=1;` \n     ` }`\n    `}`\n   `}`\n   `for(int j=n-3;j>=1;j--){`\n    `for(int i=j+1;i<n;i++){`\n      `if(nums[i]>nums[j]){`\n       ` big[i][nums[j]]+=1;`\n      `}`\n    `}`\n   `}`\n   `for(int j=0;j<n;j++){`\n    `for(int i=n-1;i>=0;i--)big[i][nums[j]]+=big[i+1][nums[j]];`\n   `} `    \n   `for(int j=0;j<n;j++){`\n    `for(int i=1;i<=n;i++)small[i][nums[j]]+=small[i-1][nums[j]];`\n   `}`\n   `long long ans=0;`\n   `for(int j=1;j<n-1;j++){`\n    `for(int k=j+1;k<n-1;k++){`\n      `if(nums[k]<nums[j]){`\n      `long long a1=small[j][nums[k]];`\n      `long long a2=big[k][nums[j]];`\n      `ans+=(a1*1ll*a2);`\n     ` } `\n    `}`\n   `} `\n   `return ans;` \n `}`"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "Please, help me, why my code gets TLE?\\n```\\nvar countQuadruplets = function(nums) {\\n    let res = 0\\n    function f(ind, arr) {\\n        if (arr.length === 4) {\\n            if (arr[0] < arr[2] && arr[0] < arr[1] && arr[0] < arr[3] &&\\n            arr[2] < arr[1] && arr[2] < arr[3] && arr[1] < arr[3]) res++\\n            return\\n        }\\n        for (let i = ind; i < nums.length; i++) {\\n            f(i + 1, [...arr, nums[i]])\\n        }\\n    }\\n    f(0, [])\\n    return res\\n};\\n```"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "[@Souvik4133x](/Souvik4133x) \n```\n4 <= nums.length <= 4000\n1 <= nums[i] <= nums.length\nAll the integers of nums are unique. nums is a permutation.\n```\nwhere is it?"
                    },
                    {
                        "username": "Souvik4133x",
                        "content": "check the time constraint ,recursion will take too much time ,thats why tle is given ."
                    }
                ]
            },
            {
                "id": 1779397,
                "content": [
                    {
                        "username": "ZongyuWu",
                        "content": "Today is Saturday, I should be in a ski resort, not sitting here google for IQ test."
                    },
                    {
                        "username": "arthur_g",
                        "content": "I strongly believe the time constraints are too tight for this problem. I had two O(n^2) solutions, one passed. The other failed. The only difference is the failing one we do an extra double for loop (additional time: N^2). The same failing solution fails in Python but passes CPP. \n\nI also wrote a memoized solution (also N^2) using maps. This also time limit exceeds in both CPP and Py. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@RealFan](/RealFan) Still,C++ gets accepted but python gets stuck at 117/121.Both have O(n^2logn) time complexity"
                    },
                    {
                        "username": "RealFan",
                        "content": "Maybe LeetCode just want to stuck the $O(n^2 \\log n)$ answers."
                    },
                    {
                        "username": "cecilia5",
                        "content": "Lying problem name >_<"
                    },
                    {
                        "username": "czjnbb",
                        "content": "In Python, SortedList results in TLE but using bisect with array gives pretty good time. Weird."
                    },
                    {
                        "username": "RasecBadguy",
                        "content": "I\\xB4m not able to post a public solution for this problem. Do i need pass some review or have more reputation?"
                    },
                    {
                        "username": "chezzyfries",
                        "content": "My O(n^2 logn) solution passed. I had two variations of it. One passed, one TLEd. But I think O(n^2) was expected?"
                    },
                    {
                        "username": "nisaacdz",
                        "content": "This is harder than it looks"
                    },
                    {
                        "username": "rahulmangla",
                        "content": "Please, help me, why my code not working?\\n\\nclass Solution {\\npublic:\\n    \\n    int cnt=0;\\n    \\n    long long fun(int i, int k, vector<int> &nums , vector<int> &larger) {\\n        if(i>=k) {\\n            return 0;\\n        }\\n        \\n        while(i<k) {\\n            int j = i + (k-i)/2;\\n            if(nums[j]>nums[i] && nums[j]>nums[k]) cnt+=larger[k];\\n            return fun(i,j-1,nums,larger) + fun(j+1,k,nums,larger);\\n        }\\n        return cnt;\\n    }\\n    \\n    long long countQuadruplets(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        vector<int> larger(n,0);\\n        \\n        for(int i=0;i<n;i++) {\\n            for(int j=i+1;j<n;j++) {\\n                if(nums[i] < nums[j]) larger[i]++;\\n            }\\n        }\\n        \\n        return fun(0,n-1,nums,larger);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "haa_bhai__",
                        "content": "Please someone tell me why is this code just passing 117/119 test cases ..\n\n `long long countQuadruplets(vector<int>& nums) {`\n   `int n=(int)(nums.size());`\n   `if(n<=3)return 0ll;`\n   `long long big[n+2][n+2];`\n   `long long small[n+2][n+2];`\n       ` for(int j=0;j<=n+1;j++){`\n        `    for(int i=0;i<=n+1;i++){`\n         `     small[j][i]=0;`\n          `    big[j][i]=0; ` \n           ` }`\n        `}`\n   `for(int j=2;j<n-1;j++){`\n    `for(int i=0;i<j;i++){`\n      `if(nums[i]<nums[j]){`\n        `small[i][nums[j]]+=1;` \n     ` }`\n    `}`\n   `}`\n   `for(int j=n-3;j>=1;j--){`\n    `for(int i=j+1;i<n;i++){`\n      `if(nums[i]>nums[j]){`\n       ` big[i][nums[j]]+=1;`\n      `}`\n    `}`\n   `}`\n   `for(int j=0;j<n;j++){`\n    `for(int i=n-1;i>=0;i--)big[i][nums[j]]+=big[i+1][nums[j]];`\n   `} `    \n   `for(int j=0;j<n;j++){`\n    `for(int i=1;i<=n;i++)small[i][nums[j]]+=small[i-1][nums[j]];`\n   `}`\n   `long long ans=0;`\n   `for(int j=1;j<n-1;j++){`\n    `for(int k=j+1;k<n-1;k++){`\n      `if(nums[k]<nums[j]){`\n      `long long a1=small[j][nums[k]];`\n      `long long a2=big[k][nums[j]];`\n      `ans+=(a1*1ll*a2);`\n     ` } `\n    `}`\n   `} `\n   `return ans;` \n `}`"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "Please, help me, why my code gets TLE?\\n```\\nvar countQuadruplets = function(nums) {\\n    let res = 0\\n    function f(ind, arr) {\\n        if (arr.length === 4) {\\n            if (arr[0] < arr[2] && arr[0] < arr[1] && arr[0] < arr[3] &&\\n            arr[2] < arr[1] && arr[2] < arr[3] && arr[1] < arr[3]) res++\\n            return\\n        }\\n        for (let i = ind; i < nums.length; i++) {\\n            f(i + 1, [...arr, nums[i]])\\n        }\\n    }\\n    f(0, [])\\n    return res\\n};\\n```"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "[@Souvik4133x](/Souvik4133x) \n```\n4 <= nums.length <= 4000\n1 <= nums[i] <= nums.length\nAll the integers of nums are unique. nums is a permutation.\n```\nwhere is it?"
                    },
                    {
                        "username": "Souvik4133x",
                        "content": "check the time constraint ,recursion will take too much time ,thats why tle is given ."
                    }
                ]
            },
            {
                "id": 1778744,
                "content": [
                    {
                        "username": "ZongyuWu",
                        "content": "Today is Saturday, I should be in a ski resort, not sitting here google for IQ test."
                    },
                    {
                        "username": "arthur_g",
                        "content": "I strongly believe the time constraints are too tight for this problem. I had two O(n^2) solutions, one passed. The other failed. The only difference is the failing one we do an extra double for loop (additional time: N^2). The same failing solution fails in Python but passes CPP. \n\nI also wrote a memoized solution (also N^2) using maps. This also time limit exceeds in both CPP and Py. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@RealFan](/RealFan) Still,C++ gets accepted but python gets stuck at 117/121.Both have O(n^2logn) time complexity"
                    },
                    {
                        "username": "RealFan",
                        "content": "Maybe LeetCode just want to stuck the $O(n^2 \\log n)$ answers."
                    },
                    {
                        "username": "cecilia5",
                        "content": "Lying problem name >_<"
                    },
                    {
                        "username": "czjnbb",
                        "content": "In Python, SortedList results in TLE but using bisect with array gives pretty good time. Weird."
                    },
                    {
                        "username": "RasecBadguy",
                        "content": "I\\xB4m not able to post a public solution for this problem. Do i need pass some review or have more reputation?"
                    },
                    {
                        "username": "chezzyfries",
                        "content": "My O(n^2 logn) solution passed. I had two variations of it. One passed, one TLEd. But I think O(n^2) was expected?"
                    },
                    {
                        "username": "nisaacdz",
                        "content": "This is harder than it looks"
                    },
                    {
                        "username": "rahulmangla",
                        "content": "Please, help me, why my code not working?\\n\\nclass Solution {\\npublic:\\n    \\n    int cnt=0;\\n    \\n    long long fun(int i, int k, vector<int> &nums , vector<int> &larger) {\\n        if(i>=k) {\\n            return 0;\\n        }\\n        \\n        while(i<k) {\\n            int j = i + (k-i)/2;\\n            if(nums[j]>nums[i] && nums[j]>nums[k]) cnt+=larger[k];\\n            return fun(i,j-1,nums,larger) + fun(j+1,k,nums,larger);\\n        }\\n        return cnt;\\n    }\\n    \\n    long long countQuadruplets(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        vector<int> larger(n,0);\\n        \\n        for(int i=0;i<n;i++) {\\n            for(int j=i+1;j<n;j++) {\\n                if(nums[i] < nums[j]) larger[i]++;\\n            }\\n        }\\n        \\n        return fun(0,n-1,nums,larger);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "haa_bhai__",
                        "content": "Please someone tell me why is this code just passing 117/119 test cases ..\n\n `long long countQuadruplets(vector<int>& nums) {`\n   `int n=(int)(nums.size());`\n   `if(n<=3)return 0ll;`\n   `long long big[n+2][n+2];`\n   `long long small[n+2][n+2];`\n       ` for(int j=0;j<=n+1;j++){`\n        `    for(int i=0;i<=n+1;i++){`\n         `     small[j][i]=0;`\n          `    big[j][i]=0; ` \n           ` }`\n        `}`\n   `for(int j=2;j<n-1;j++){`\n    `for(int i=0;i<j;i++){`\n      `if(nums[i]<nums[j]){`\n        `small[i][nums[j]]+=1;` \n     ` }`\n    `}`\n   `}`\n   `for(int j=n-3;j>=1;j--){`\n    `for(int i=j+1;i<n;i++){`\n      `if(nums[i]>nums[j]){`\n       ` big[i][nums[j]]+=1;`\n      `}`\n    `}`\n   `}`\n   `for(int j=0;j<n;j++){`\n    `for(int i=n-1;i>=0;i--)big[i][nums[j]]+=big[i+1][nums[j]];`\n   `} `    \n   `for(int j=0;j<n;j++){`\n    `for(int i=1;i<=n;i++)small[i][nums[j]]+=small[i-1][nums[j]];`\n   `}`\n   `long long ans=0;`\n   `for(int j=1;j<n-1;j++){`\n    `for(int k=j+1;k<n-1;k++){`\n      `if(nums[k]<nums[j]){`\n      `long long a1=small[j][nums[k]];`\n      `long long a2=big[k][nums[j]];`\n      `ans+=(a1*1ll*a2);`\n     ` } `\n    `}`\n   `} `\n   `return ans;` \n `}`"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "Please, help me, why my code gets TLE?\\n```\\nvar countQuadruplets = function(nums) {\\n    let res = 0\\n    function f(ind, arr) {\\n        if (arr.length === 4) {\\n            if (arr[0] < arr[2] && arr[0] < arr[1] && arr[0] < arr[3] &&\\n            arr[2] < arr[1] && arr[2] < arr[3] && arr[1] < arr[3]) res++\\n            return\\n        }\\n        for (let i = ind; i < nums.length; i++) {\\n            f(i + 1, [...arr, nums[i]])\\n        }\\n    }\\n    f(0, [])\\n    return res\\n};\\n```"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "[@Souvik4133x](/Souvik4133x) \n```\n4 <= nums.length <= 4000\n1 <= nums[i] <= nums.length\nAll the integers of nums are unique. nums is a permutation.\n```\nwhere is it?"
                    },
                    {
                        "username": "Souvik4133x",
                        "content": "check the time constraint ,recursion will take too much time ,thats why tle is given ."
                    }
                ]
            },
            {
                "id": 1778561,
                "content": [
                    {
                        "username": "ZongyuWu",
                        "content": "Today is Saturday, I should be in a ski resort, not sitting here google for IQ test."
                    },
                    {
                        "username": "arthur_g",
                        "content": "I strongly believe the time constraints are too tight for this problem. I had two O(n^2) solutions, one passed. The other failed. The only difference is the failing one we do an extra double for loop (additional time: N^2). The same failing solution fails in Python but passes CPP. \n\nI also wrote a memoized solution (also N^2) using maps. This also time limit exceeds in both CPP and Py. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@RealFan](/RealFan) Still,C++ gets accepted but python gets stuck at 117/121.Both have O(n^2logn) time complexity"
                    },
                    {
                        "username": "RealFan",
                        "content": "Maybe LeetCode just want to stuck the $O(n^2 \\log n)$ answers."
                    },
                    {
                        "username": "cecilia5",
                        "content": "Lying problem name >_<"
                    },
                    {
                        "username": "czjnbb",
                        "content": "In Python, SortedList results in TLE but using bisect with array gives pretty good time. Weird."
                    },
                    {
                        "username": "RasecBadguy",
                        "content": "I\\xB4m not able to post a public solution for this problem. Do i need pass some review or have more reputation?"
                    },
                    {
                        "username": "chezzyfries",
                        "content": "My O(n^2 logn) solution passed. I had two variations of it. One passed, one TLEd. But I think O(n^2) was expected?"
                    },
                    {
                        "username": "nisaacdz",
                        "content": "This is harder than it looks"
                    },
                    {
                        "username": "rahulmangla",
                        "content": "Please, help me, why my code not working?\\n\\nclass Solution {\\npublic:\\n    \\n    int cnt=0;\\n    \\n    long long fun(int i, int k, vector<int> &nums , vector<int> &larger) {\\n        if(i>=k) {\\n            return 0;\\n        }\\n        \\n        while(i<k) {\\n            int j = i + (k-i)/2;\\n            if(nums[j]>nums[i] && nums[j]>nums[k]) cnt+=larger[k];\\n            return fun(i,j-1,nums,larger) + fun(j+1,k,nums,larger);\\n        }\\n        return cnt;\\n    }\\n    \\n    long long countQuadruplets(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        vector<int> larger(n,0);\\n        \\n        for(int i=0;i<n;i++) {\\n            for(int j=i+1;j<n;j++) {\\n                if(nums[i] < nums[j]) larger[i]++;\\n            }\\n        }\\n        \\n        return fun(0,n-1,nums,larger);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "haa_bhai__",
                        "content": "Please someone tell me why is this code just passing 117/119 test cases ..\n\n `long long countQuadruplets(vector<int>& nums) {`\n   `int n=(int)(nums.size());`\n   `if(n<=3)return 0ll;`\n   `long long big[n+2][n+2];`\n   `long long small[n+2][n+2];`\n       ` for(int j=0;j<=n+1;j++){`\n        `    for(int i=0;i<=n+1;i++){`\n         `     small[j][i]=0;`\n          `    big[j][i]=0; ` \n           ` }`\n        `}`\n   `for(int j=2;j<n-1;j++){`\n    `for(int i=0;i<j;i++){`\n      `if(nums[i]<nums[j]){`\n        `small[i][nums[j]]+=1;` \n     ` }`\n    `}`\n   `}`\n   `for(int j=n-3;j>=1;j--){`\n    `for(int i=j+1;i<n;i++){`\n      `if(nums[i]>nums[j]){`\n       ` big[i][nums[j]]+=1;`\n      `}`\n    `}`\n   `}`\n   `for(int j=0;j<n;j++){`\n    `for(int i=n-1;i>=0;i--)big[i][nums[j]]+=big[i+1][nums[j]];`\n   `} `    \n   `for(int j=0;j<n;j++){`\n    `for(int i=1;i<=n;i++)small[i][nums[j]]+=small[i-1][nums[j]];`\n   `}`\n   `long long ans=0;`\n   `for(int j=1;j<n-1;j++){`\n    `for(int k=j+1;k<n-1;k++){`\n      `if(nums[k]<nums[j]){`\n      `long long a1=small[j][nums[k]];`\n      `long long a2=big[k][nums[j]];`\n      `ans+=(a1*1ll*a2);`\n     ` } `\n    `}`\n   `} `\n   `return ans;` \n `}`"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "Please, help me, why my code gets TLE?\\n```\\nvar countQuadruplets = function(nums) {\\n    let res = 0\\n    function f(ind, arr) {\\n        if (arr.length === 4) {\\n            if (arr[0] < arr[2] && arr[0] < arr[1] && arr[0] < arr[3] &&\\n            arr[2] < arr[1] && arr[2] < arr[3] && arr[1] < arr[3]) res++\\n            return\\n        }\\n        for (let i = ind; i < nums.length; i++) {\\n            f(i + 1, [...arr, nums[i]])\\n        }\\n    }\\n    f(0, [])\\n    return res\\n};\\n```"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "[@Souvik4133x](/Souvik4133x) \n```\n4 <= nums.length <= 4000\n1 <= nums[i] <= nums.length\nAll the integers of nums are unique. nums is a permutation.\n```\nwhere is it?"
                    },
                    {
                        "username": "Souvik4133x",
                        "content": "check the time constraint ,recursion will take too much time ,thats why tle is given ."
                    }
                ]
            },
            {
                "id": 1778526,
                "content": [
                    {
                        "username": "ZongyuWu",
                        "content": "Today is Saturday, I should be in a ski resort, not sitting here google for IQ test."
                    },
                    {
                        "username": "arthur_g",
                        "content": "I strongly believe the time constraints are too tight for this problem. I had two O(n^2) solutions, one passed. The other failed. The only difference is the failing one we do an extra double for loop (additional time: N^2). The same failing solution fails in Python but passes CPP. \n\nI also wrote a memoized solution (also N^2) using maps. This also time limit exceeds in both CPP and Py. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@RealFan](/RealFan) Still,C++ gets accepted but python gets stuck at 117/121.Both have O(n^2logn) time complexity"
                    },
                    {
                        "username": "RealFan",
                        "content": "Maybe LeetCode just want to stuck the $O(n^2 \\log n)$ answers."
                    },
                    {
                        "username": "cecilia5",
                        "content": "Lying problem name >_<"
                    },
                    {
                        "username": "czjnbb",
                        "content": "In Python, SortedList results in TLE but using bisect with array gives pretty good time. Weird."
                    },
                    {
                        "username": "RasecBadguy",
                        "content": "I\\xB4m not able to post a public solution for this problem. Do i need pass some review or have more reputation?"
                    },
                    {
                        "username": "chezzyfries",
                        "content": "My O(n^2 logn) solution passed. I had two variations of it. One passed, one TLEd. But I think O(n^2) was expected?"
                    },
                    {
                        "username": "nisaacdz",
                        "content": "This is harder than it looks"
                    },
                    {
                        "username": "rahulmangla",
                        "content": "Please, help me, why my code not working?\\n\\nclass Solution {\\npublic:\\n    \\n    int cnt=0;\\n    \\n    long long fun(int i, int k, vector<int> &nums , vector<int> &larger) {\\n        if(i>=k) {\\n            return 0;\\n        }\\n        \\n        while(i<k) {\\n            int j = i + (k-i)/2;\\n            if(nums[j]>nums[i] && nums[j]>nums[k]) cnt+=larger[k];\\n            return fun(i,j-1,nums,larger) + fun(j+1,k,nums,larger);\\n        }\\n        return cnt;\\n    }\\n    \\n    long long countQuadruplets(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        vector<int> larger(n,0);\\n        \\n        for(int i=0;i<n;i++) {\\n            for(int j=i+1;j<n;j++) {\\n                if(nums[i] < nums[j]) larger[i]++;\\n            }\\n        }\\n        \\n        return fun(0,n-1,nums,larger);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "haa_bhai__",
                        "content": "Please someone tell me why is this code just passing 117/119 test cases ..\n\n `long long countQuadruplets(vector<int>& nums) {`\n   `int n=(int)(nums.size());`\n   `if(n<=3)return 0ll;`\n   `long long big[n+2][n+2];`\n   `long long small[n+2][n+2];`\n       ` for(int j=0;j<=n+1;j++){`\n        `    for(int i=0;i<=n+1;i++){`\n         `     small[j][i]=0;`\n          `    big[j][i]=0; ` \n           ` }`\n        `}`\n   `for(int j=2;j<n-1;j++){`\n    `for(int i=0;i<j;i++){`\n      `if(nums[i]<nums[j]){`\n        `small[i][nums[j]]+=1;` \n     ` }`\n    `}`\n   `}`\n   `for(int j=n-3;j>=1;j--){`\n    `for(int i=j+1;i<n;i++){`\n      `if(nums[i]>nums[j]){`\n       ` big[i][nums[j]]+=1;`\n      `}`\n    `}`\n   `}`\n   `for(int j=0;j<n;j++){`\n    `for(int i=n-1;i>=0;i--)big[i][nums[j]]+=big[i+1][nums[j]];`\n   `} `    \n   `for(int j=0;j<n;j++){`\n    `for(int i=1;i<=n;i++)small[i][nums[j]]+=small[i-1][nums[j]];`\n   `}`\n   `long long ans=0;`\n   `for(int j=1;j<n-1;j++){`\n    `for(int k=j+1;k<n-1;k++){`\n      `if(nums[k]<nums[j]){`\n      `long long a1=small[j][nums[k]];`\n      `long long a2=big[k][nums[j]];`\n      `ans+=(a1*1ll*a2);`\n     ` } `\n    `}`\n   `} `\n   `return ans;` \n `}`"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "Please, help me, why my code gets TLE?\\n```\\nvar countQuadruplets = function(nums) {\\n    let res = 0\\n    function f(ind, arr) {\\n        if (arr.length === 4) {\\n            if (arr[0] < arr[2] && arr[0] < arr[1] && arr[0] < arr[3] &&\\n            arr[2] < arr[1] && arr[2] < arr[3] && arr[1] < arr[3]) res++\\n            return\\n        }\\n        for (let i = ind; i < nums.length; i++) {\\n            f(i + 1, [...arr, nums[i]])\\n        }\\n    }\\n    f(0, [])\\n    return res\\n};\\n```"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "[@Souvik4133x](/Souvik4133x) \n```\n4 <= nums.length <= 4000\n1 <= nums[i] <= nums.length\nAll the integers of nums are unique. nums is a permutation.\n```\nwhere is it?"
                    },
                    {
                        "username": "Souvik4133x",
                        "content": "check the time constraint ,recursion will take too much time ,thats why tle is given ."
                    }
                ]
            }
        ]
    }
]