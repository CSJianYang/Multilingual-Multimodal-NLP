[
    {
        "title": "Maximum Sum of Two Non-Overlapping Subarrays",
        "question_content": "Given an integer array nums and two integers firstLen and secondLen, return the maximum sum of elements in two non-overlapping subarrays with lengths firstLen and secondLen.\nThe array with length firstLen could occur before or after the array with length secondLen, but they have to be non-overlapping.\nA subarray is a contiguous part of an array.\n&nbsp;\nExample 1:\n\nInput: nums = [0,6,5,2,2,5,1,9,4], firstLen = 1, secondLen = 2\nOutput: 20\nExplanation: One choice of subarrays is [9] with length 1, and [6,5] with length 2.\n\nExample 2:\n\nInput: nums = [3,8,1,3,2,1,8,9,0], firstLen = 3, secondLen = 2\nOutput: 29\nExplanation: One choice of subarrays is [3,8,1] with length 3, and [8,9] with length 2.\n\nExample 3:\n\nInput: nums = [2,1,5,6,0,9,5,0,3,8], firstLen = 4, secondLen = 3\nOutput: 31\nExplanation: One choice of subarrays is [5,6,0,9] with length 4, and [0,3,8] with length 3.\n\n&nbsp;\nConstraints:\n\n\t1 <= firstLen, secondLen <= 1000\n\t2 <= firstLen + secondLen <= 1000\n\tfirstLen + secondLen <= nums.length <= 1000\n\t0 <= nums[i] <= 1000",
        "solutions": [
            {
                "id": 279221,
                "title": "java-python-3-two-easy-dp-codes-w-comment-time-o-n-no-change-of-input",
                "content": "**Q & A**\\n\\nQ1: How do you guarantee the two subarrays are not overlapping in your code?\\nA1: During traversal, the upper bound of the `L-length` left subarray is `i - M` inclusively, and the lower bound of the `M-length` right subarray is also `i - M` exclusively. Therefore, the two subarrays will never overlap.\\n\\nQ2: Why the roles of L and M has been swapped i.e 1st time number of L elements were before and followed by M and 2nd time its vice versa?\\nA2: Because there are two cases: L is ahead of M and M is ahead L; either could be the maximum. Therefore, we need to check both to find the maximum.\\n\\nQ3: Can\\'t we just use the input(given) array for storing prefix sum array so that solution 1 will be O(1) space solution?\\nA3: In most cases it is preferable to keep input array unchanged. Also, in strict sense, we should count into space cost the modified input array, so it actually cost space `O(n)`, which is often called **extra** space `O(1)`.\\n\\nQ4:  Why you use the `maxL` and `sumM` to calculate the `ans` and not `maxM` as well?\\nA4: That will result overlap of L-subarray and M-subarray. We traverse input array `A` from left to right, and the value of maxM could occur at part or whole of current L-subarray. E.g., \\n`A = [1,1,3,2,1], L = 2, M = 1`\\nWhen L-subarray = [3,2] and M-subarray = [1], then `maxM = 3`, and the `3` is from L-subarray [3,2].\\n\\nIn contrast, `maxL` will never occur at part or whole of **current** M-subarray hence will **NOT** cause overlap, because L-subarray has not included any element in M-subarray yet.\\n\\n**End of Q & A**\\n\\n----\\n\\nPlease refer to **@lionkingeatapple**\\'s diagram as follows:\\n![image](https://assets.leetcode.com/users/images/2eafddf3-c5d9-4fa3-8145-966f0a2cd63e_1605434988.6631174.png)\\n\\n\\n1. Scan the prefix sum array from index `L + M`, which is the first possible position;\\n2. update the max value of the `L-length` subarray; then update max value of the sum of the both;\\n3. we need to swap `L` and `M` to scan twice, since either subarray can occur before the other.\\n4. In private method, prefix sum difference `p[i - M] - p[i - M - L]` is `L-length` subarray from index `i - M - L` to `i - M - 1`, and `p[i] - p[i - M]` is `M-length` subarray from index `i - M` to `i - 1`. \\n\\n**Solution 1: Prefix Sum**\\n\\n```java\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        int[] prefixSum = new int[A.length + 1];\\n        for (int i = 0; i < A.length; ++i) {\\n            prefixSum[i + 1] = prefixSum[i] + A[i];\\n        }\\n        return Math.max(maxSum(prefixSum, L, M), maxSum(prefixSum, M, L));\\n    }\\n    private int maxSum(int[] p, int L, int M) {\\n        int ans = 0;\\n        for (int i = L + M, maxL = 0; i < p.length; ++i) {\\n            maxL = Math.max(maxL, p[i - M] - p[i - M - L]); // update max of L-length subarray.\\n            ans = Math.max(ans, maxL + p[i] - p[i - M]); // update max of the sum of L-length & M-length subarrays.\\n        }\\n        return ans;\\n    }\\n```\\n```python\\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n        \\n        def maxSum(L:int, M:int) -> int:\\n            maxL = ans = 0\\n            for i in range(L + M, len(prefixSum)):\\n                maxL = max(maxL, prefixSum[i - M] - prefixSum[i - L - M])\\n                ans = max(ans, maxL + prefixSum[i] - prefixSum[i - M])\\n            return ans\\n        \\n        prefixSum = [0] * (len(A) + 1)\\n        for i, a in enumerate(A):\\n            prefixSum[i + 1] = prefixSum[i] + a\\n        return max(maxSum(L, M), maxSum(M, L))\\n```\\n\\n**Analysis:**\\n\\nTime & space: `O(n)`, where `n = A.length`.\\n\\n----\\n\\n**Solution 2: Sliding Window**\\n\\nBased on **Solution 1**, we can further get rid of prefix sum array to implement the following space `O(1)` code. \\n\\n**Unfortunately, the boundary conditions are headache and fallible, please let me know if you can improve the readability, or at least make it concise.**\\n\\n```java\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        return Math.max(maxSum(A, L, M), maxSum(A, M, L));\\n    }\\n    private int maxSum(int[] A, int L, int M) {\\n        int ans = 0; \\n        for (int i = 0, maxL = 0, sumL = 0, sumM = 0; i < A.length; ++i) {\\n            if (i < L || i >= L + M) { sumL += i < L ? A[i] : A[i - M]; } // first L-length subarray at index [0...L - 1], no update between index [L...L + M - 1].\\n            if (i >= L) { sumM += A[i]; } // first M-length subarray starts from index L to L + M - 1.\\n            if (i >= L + M) { sumL -= A[i - L - M]; } // deduct first item from current L-length subarray.\\n            if (i >= L + M) { sumM -= A[i - M]; } // deduct first item from current  M-length subarray.\\n            if (i >= L + M - 1) { maxL = Math.max(maxL, sumL); } // update max of L-length subarray.\\n            if (i >= L + M - 1) { ans = Math.max(ans, maxL + sumM); } // update max of L-length & M-length subarrays.\\n        }\\n        return ans;\\n    }\\n```\\n**Update with a more readable version:**\\n```java\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        return Math.max(maxSum(A, L, M), maxSum(A, M, L));\\n    }\\n    private int maxSum(int[] A, int L, int M) {\\n        int sumL = 0, sumM = 0;\\n        for (int i = 0; i < L + M; ++i) { // compute the initial values of L & M length subarrays.\\n            if (i < L) sumL += A[i];\\n            else sumM += A[i];\\n        }\\n        int ans = sumM + sumL; // sum of sumL and sumM.\\n        for (int i = L + M, maxL = sumL; i < A.length; ++i) {\\n            sumL += A[i - M] - A[i - L - M]; // update sumL.\\n            sumM += A[i] - A[i - M]; // update sumM.\\n            maxL = Math.max(maxL, sumL); // update max value of L-length subarray.\\n            ans = Math.max(ans, maxL + sumM); // update max value of sum of L & M-length subarrays.\\n        }\\n        return ans;\\n    }\\n```\\n```python\\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n        \\n        def maxSum(L:int, M:int) -> int:\\n            sumL = sumM = 0\\n            for i in range(0, L + M):\\n                if i < L:\\n                    sumL += A[i]\\n                else:\\n                    sumM += A[i]    \\n            maxL, ans = sumL, sumL + sumM\\n            for i in range(L + M, len(A)):\\n                sumL += A[i - M] - A[i - L - M]\\n                maxL = max(maxL, sumL)\\n                sumM += A[i] - A[i - M]\\n                ans = max(ans, maxL + sumM)\\n            return ans\\n        \\n        return max(maxSum(L, M), maxSum(M, L)) \\n```\\n**Analysis:**\\n\\nTime: `O(n)`, space: `O(1)`, where `n = A.length`.\\n\\n",
                "solutionTags": [],
                "code": "```java\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        int[] prefixSum = new int[A.length + 1];\\n        for (int i = 0; i < A.length; ++i) {\\n            prefixSum[i + 1] = prefixSum[i] + A[i];\\n        }\\n        return Math.max(maxSum(prefixSum, L, M), maxSum(prefixSum, M, L));\\n    }\\n    private int maxSum(int[] p, int L, int M) {\\n        int ans = 0;\\n        for (int i = L + M, maxL = 0; i < p.length; ++i) {\\n            maxL = Math.max(maxL, p[i - M] - p[i - M - L]); // update max of L-length subarray.\\n            ans = Math.max(ans, maxL + p[i] - p[i - M]); // update max of the sum of L-length & M-length subarrays.\\n        }\\n        return ans;\\n    }\\n```\n```python\\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n        \\n        def maxSum(L:int, M:int) -> int:\\n            maxL = ans = 0\\n            for i in range(L + M, len(prefixSum)):\\n                maxL = max(maxL, prefixSum[i - M] - prefixSum[i - L - M])\\n                ans = max(ans, maxL + prefixSum[i] - prefixSum[i - M])\\n            return ans\\n        \\n        prefixSum = [0] * (len(A) + 1)\\n        for i, a in enumerate(A):\\n            prefixSum[i + 1] = prefixSum[i] + a\\n        return max(maxSum(L, M), maxSum(M, L))\\n```\n```java\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        return Math.max(maxSum(A, L, M), maxSum(A, M, L));\\n    }\\n    private int maxSum(int[] A, int L, int M) {\\n        int ans = 0; \\n        for (int i = 0, maxL = 0, sumL = 0, sumM = 0; i < A.length; ++i) {\\n            if (i < L || i >= L + M) { sumL += i < L ? A[i] : A[i - M]; } // first L-length subarray at index [0...L - 1], no update between index [L...L + M - 1].\\n            if (i >= L) { sumM += A[i]; } // first M-length subarray starts from index L to L + M - 1.\\n            if (i >= L + M) { sumL -= A[i - L - M]; } // deduct first item from current L-length subarray.\\n            if (i >= L + M) { sumM -= A[i - M]; } // deduct first item from current  M-length subarray.\\n            if (i >= L + M - 1) { maxL = Math.max(maxL, sumL); } // update max of L-length subarray.\\n            if (i >= L + M - 1) { ans = Math.max(ans, maxL + sumM); } // update max of L-length & M-length subarrays.\\n        }\\n        return ans;\\n    }\\n```\n```java\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        return Math.max(maxSum(A, L, M), maxSum(A, M, L));\\n    }\\n    private int maxSum(int[] A, int L, int M) {\\n        int sumL = 0, sumM = 0;\\n        for (int i = 0; i < L + M; ++i) { // compute the initial values of L & M length subarrays.\\n            if (i < L) sumL += A[i];\\n            else sumM += A[i];\\n        }\\n        int ans = sumM + sumL; // sum of sumL and sumM.\\n        for (int i = L + M, maxL = sumL; i < A.length; ++i) {\\n            sumL += A[i - M] - A[i - L - M]; // update sumL.\\n            sumM += A[i] - A[i - M]; // update sumM.\\n            maxL = Math.max(maxL, sumL); // update max value of L-length subarray.\\n            ans = Math.max(ans, maxL + sumM); // update max value of sum of L & M-length subarrays.\\n        }\\n        return ans;\\n    }\\n```\n```python\\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n        \\n        def maxSum(L:int, M:int) -> int:\\n            sumL = sumM = 0\\n            for i in range(0, L + M):\\n                if i < L:\\n                    sumL += A[i]\\n                else:\\n                    sumM += A[i]    \\n            maxL, ans = sumL, sumL + sumM\\n            for i in range(L + M, len(A)):\\n                sumL += A[i - M] - A[i - L - M]\\n                maxL = max(maxL, sumL)\\n                sumM += A[i] - A[i - M]\\n                ans = max(ans, maxL + sumM)\\n            return ans\\n        \\n        return max(maxSum(L, M), maxSum(M, L)) \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 278727,
                "title": "c-o-n-buy-sell-stock-2-times",
                "content": "Similar to [Best Time to Buy and Sell Stock III](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/), but instead of maximum profit, we track maximum sum of ```N``` elements.\\n\\nLeft-to-right, track the maximum sum of ```L``` elements in ```left```. Right-to-left, track the maximum sum of ```M``` elements in ```right```.\\n\\nThen, find the split point where ```left[i] + right[i]``` gives us the maximum sum.\\n\\n**Note:** we need to do it twice for (L, M) and (M, L).\\n```\\nint maxTwoNoOverlap(vector<int>& A, int L, int M, int sz, int res = 0) {\\n  vector<int> left(sz + 1), right(sz + 1);\\n  for (int i = 0, j = sz - 1, s_r = 0, s_l = 0; i < sz; ++i, --j) {\\n    s_l += A[i], s_r += A[j];\\n    left[i + 1] = max(left[i], s_l);\\n    right[j] = max(right[j + 1], s_r);\\n    if (i + 1 >= L) s_l -= A[i + 1 - L];\\n    if (i + 1 >= M) s_r -= A[j + M - 1];\\n  }\\n  for (auto i = 0; i < A.size(); ++i) {\\n    res = max(res, left[i] + right[i]);\\n  }\\n  return res;\\n}\\nint maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n  return max(maxTwoNoOverlap(A, L, M, A.size()), maxTwoNoOverlap(A, M, L, A.size()));\\n}\\n```",
                "solutionTags": [],
                "code": "```N```\n```L```\n```left```\n```M```\n```right```\n```left[i] + right[i]```\n```\\nint maxTwoNoOverlap(vector<int>& A, int L, int M, int sz, int res = 0) {\\n  vector<int> left(sz + 1), right(sz + 1);\\n  for (int i = 0, j = sz - 1, s_r = 0, s_l = 0; i < sz; ++i, --j) {\\n    s_l += A[i], s_r += A[j];\\n    left[i + 1] = max(left[i], s_l);\\n    right[j] = max(right[j + 1], s_r);\\n    if (i + 1 >= L) s_l -= A[i + 1 - L];\\n    if (i + 1 >= M) s_r -= A[j + M - 1];\\n  }\\n  for (auto i = 0; i < A.size(); ++i) {\\n    res = max(res, left[i] + right[i]);\\n  }\\n  return res;\\n}\\nint maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n  return max(maxTwoNoOverlap(A, L, M, A.size()), maxTwoNoOverlap(A, M, L, A.size()));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 300029,
                "title": "python-breaking-down-lee215-s-solution",
                "content": "So the problem is essentially 2 separate cases.\\n\\nBut it\\'s important to keep in mind that the L+M maximum could be reached before L & M separate from each other\\nSo you cannot divide each case into simply 2 steps:\\n1. find the global maximum of the window on the left\\n2. find the maximum of the second window in the region to the right of the first window\\n\\n\\n\\ncase 1:      L-window comes before M-windows\\nOnce L-window reaches it\\'s global maximum, it will stop sliding but M window can keep going on\\n\\ncase 2:      M-window comes before L-windows\\nOnce M-window reaches it\\'s global maximum, it will stop sliding but L window can keep going on\\n\\n```\\n\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n\\n\\n        # do a CDF so that range sum can easily be calculated\\n        for i in range(1, len(A)):\\n            A[i] += A[i - 1]\\n\\n\\n        res, Lmax, Mmax = A[L + M - 1], A[L - 1], A[M - 1]\\n\\n\\n        # window  | --- L --- | --- M --- |\\n        for i in range(L + M, len(A)):\\n            Lmax = max(Lmax, A[i - M] - A[i - L - M])\\n            res = max(res, Lmax + A[i] - A[i - M])\\n\\n        # window  | --- M --- | --- L --- |\\n        for i in range(L + M, len(A)):\\n            Mmax = max(Mmax, A[i - L] - A[i - L - M])\\n            res = max(res, Mmax + A[i] - A[i - L])\\n\\n        return res\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n\\n\\n        # do a CDF so that range sum can easily be calculated\\n        for i in range(1, len(A)):\\n            A[i] += A[i - 1]\\n\\n\\n        res, Lmax, Mmax = A[L + M - 1], A[L - 1], A[M - 1]\\n\\n\\n        # window  | --- L --- | --- M --- |\\n        for i in range(L + M, len(A)):\\n            Lmax = max(Lmax, A[i - M] - A[i - L - M])\\n            res = max(res, Lmax + A[i] - A[i - M])\\n\\n        # window  | --- M --- | --- L --- |\\n        for i in range(L + M, len(A)):\\n            Mmax = max(Mmax, A[i - L] - A[i - L - M])\\n            res = max(res, Mmax + A[i] - A[i - L])\\n\\n        return res\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 581060,
                "title": "python-prefix-sum-with-diagram-explanation",
                "content": "![image](https://assets.leetcode.com/users/codingasiangirll/image_1586963971.png)\\n\\n\\n**Explanation**: Suppose we already have array of prefix sum, and we are at index `i`-th of `prefix_sum`. There are two possible ways to find maximum result:\\n(1) `maxL` + the last sum of `A`\\'s subarray of length == `M`. `maxL`:= maximum sum of `A`\\'s subarray of length == `L`, before the ending at `i`, and the last subarray with length == `M`. (In the diagram, possible result (1))\\n\\n(2) `maxM` + the last sum of `A`\\'s subarray of length == `L`. `maxM`:= maximum sum of `A`\\'s subarray of length == `M`, before the ending at `i`, and the last subarray with length == `L`. (In the diagram, possible result (2))\\n\\n**Complexity**: Time O(N), N is `len(A)`. Space O(1)\\n```\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n        if len(A) < L + M: return 0\\n        for i in range(1, len(A)):\\n            A[i] += A[i - 1]\\n        res, maxL, maxM = A[L + M - 1], A[L - 1], A[M - 1]\\n        for i in range(L + M, len(A)):\\n            maxL = max(maxL, A[i - M] - A[i - M - L])\\n            maxM = max(maxM, A[i - L] - A[i - L - M])\\n            res = max(res, maxL + A[i] - A[i - M], maxM + A[i] - A[i - L])\\n        return res\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n        if len(A) < L + M: return 0\\n        for i in range(1, len(A)):\\n            A[i] += A[i - 1]\\n        res, maxL, maxM = A[L + M - 1], A[L - 1], A[M - 1]\\n        for i in range(L + M, len(A)):\\n            maxL = max(maxL, A[i - M] - A[i - M - L])\\n            maxM = max(maxM, A[i - L] - A[i - L - M])\\n            res = max(res, maxL + A[i] - A[i - M], maxM + A[i] - A[i - L])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 616171,
                "title": "readable-java-solution-with-o-n-time-and-o-n-space",
                "content": "The solution is not the most concise one, but it\\'s highly readable and easy to understand.\\nYou really have to calculate the indices very carefully to avoid array out of bound and to get correct result.\\n\\n```java\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        // L and M could be at left or right\\n        // so we need to calculate the both to get the max non-overlapping sum of entire array\\n        return Math.max(calculate(A, L, M), calculate(A, M, L));\\n    }\\n    \\n    private int calculate(int[] A, int L, int M) {\\n        int sum = 0;\\n        int len = A.length;\\n        \\n        // calculate the prefix sum from A[0] to A[i]\\n        int[] prefixSum = new int[len];\\n        prefixSum[0] = A[0];\\n        for(int i = 1; i < len; i++) {\\n            prefixSum[i] = prefixSum[i-1] + A[i];\\n        }\\n        \\n        // calculate the maximum sum with length L with rightmost position at A[i], A[i] doesn\\'t have to be included\\n        int[] leftSum = new int[len];\\n        leftSum[L-1] = prefixSum[L-1];\\n        for(int i = L; i < len; i++) {\\n            leftSum[i] = Math.max(leftSum[i-1], prefixSum[i] - prefixSum[i-L]);\\n        }\\n        \\n        // calculate the suffix sum from A[i] to A[len-1]\\n        int[] suffixSum = new int[len];\\n        suffixSum[len-1] = A[len-1];\\n        for(int i = len-2; i >= 0; i--) {\\n            suffixSum[i] = suffixSum[i+1] + A[i];\\n        }\\n        \\n        // calcualte the maxisum sum with length M with leftmost position at A[i], A[i] doesn\\'t have to be included\\n        int[] rightSum = new int[len];\\n        rightSum[len-M] = suffixSum[len-M];\\n        for(int i = len-M-1; i >= 0; i--) {\\n            rightSum[i] = Math.max(rightSum[i+1], suffixSum[i] - suffixSum[i+M]);\\n        }\\n        \\n        // now we have all the data for max sum with length L from the left\\n        // and max sum with length M from the right\\n        // just iterate and add them up to find the max non-overlapping sum \\n        // note the i+1 index is for non-overlapping\\n        int res = Integer.MIN_VALUE;\\n        for(int i = L-1; i <= len-M-1; i++) {\\n            res = Math.max(leftSum[i] + rightSum[i+1], res);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        // L and M could be at left or right\\n        // so we need to calculate the both to get the max non-overlapping sum of entire array\\n        return Math.max(calculate(A, L, M), calculate(A, M, L));\\n    }\\n    \\n    private int calculate(int[] A, int L, int M) {\\n        int sum = 0;\\n        int len = A.length;\\n        \\n        // calculate the prefix sum from A[0] to A[i]\\n        int[] prefixSum = new int[len];\\n        prefixSum[0] = A[0];\\n        for(int i = 1; i < len; i++) {\\n            prefixSum[i] = prefixSum[i-1] + A[i];\\n        }\\n        \\n        // calculate the maximum sum with length L with rightmost position at A[i], A[i] doesn\\'t have to be included\\n        int[] leftSum = new int[len];\\n        leftSum[L-1] = prefixSum[L-1];\\n        for(int i = L; i < len; i++) {\\n            leftSum[i] = Math.max(leftSum[i-1], prefixSum[i] - prefixSum[i-L]);\\n        }\\n        \\n        // calculate the suffix sum from A[i] to A[len-1]\\n        int[] suffixSum = new int[len];\\n        suffixSum[len-1] = A[len-1];\\n        for(int i = len-2; i >= 0; i--) {\\n            suffixSum[i] = suffixSum[i+1] + A[i];\\n        }\\n        \\n        // calcualte the maxisum sum with length M with leftmost position at A[i], A[i] doesn\\'t have to be included\\n        int[] rightSum = new int[len];\\n        rightSum[len-M] = suffixSum[len-M];\\n        for(int i = len-M-1; i >= 0; i--) {\\n            rightSum[i] = Math.max(rightSum[i+1], suffixSum[i] - suffixSum[i+M]);\\n        }\\n        \\n        // now we have all the data for max sum with length L from the left\\n        // and max sum with length M from the right\\n        // just iterate and add them up to find the max non-overlapping sum \\n        // note the i+1 index is for non-overlapping\\n        int res = Integer.MIN_VALUE;\\n        for(int i = L-1; i <= len-M-1; i++) {\\n            res = Math.max(leftSum[i] + rightSum[i+1], res);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1365435,
                "title": "100-faster-solution-with-explaination",
                "content": "The idea is to find the max sum subbary of given size firstlen and seconlen seperately \\nFind prefix sum for firstlen and suffix sum for secondLen and vice-versa\\nDp1-> it will store the max sum of the subarray of size firstlen from 0th to ith index.\\nDp2-> it will store the max sum of the subarray from last index to ith index\\nand then check from a window of fisrstlen-1 to nums.size()- secondlen\\nwhich ever has the max sum will be our result\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int helper(vector<int>&nums,int x,int y){\\n        int n=nums.size();\\n        vector<int>dp1(n,0),dp2(n,0);\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            if(i<x){//when we haven\\'t considered x-size array\\n                sum+=nums[i]; \\n                dp1[i]=sum;\\n            }\\n            else{ //when we have a window of size x\\n                sum=sum+nums[i]-nums[i-x];\\n                dp1[i]=max(dp1[i-1],sum);\\n            }\\n        }\\n        sum=0;\\n        //check from right to left for Secondlen window and store maximum sum from ith index to last index keep updating at every point if the current window of size secondLen is max or dp2[i+1] has max whichever is max add that to dp[i]\\n        \\n        for(int i=n-1;i>=0;i--){\\n            if(i+y>n-1) { //case when we haven\\'t encountered a window of size secondlen ie. y\\n                sum+=nums[i];\\n                dp2[i]=sum;\\n            }\\n            else{//when we have a window of size secondLen\\n                sum=sum+nums[i]-nums[i+y];\\n                dp2[i]=max(dp2[i+1],sum);\\n            }\\n        }\\n        int ans=0;\\n        //our ans window will be from x-1 to n-y\\n        for(int i=x-1;i<n-y;i++){\\n            ans=max(ans,dp1[i]+dp2[i+1]);\\n        }\\n        return ans;\\n    }\\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen){\\n        return max(helper(nums, firstLen, secondLen),helper(nums, secondLen, firstLen));\\n    }\\n};\\n```\\n**comment if have doubts and do upvote**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(vector<int>&nums,int x,int y){\\n        int n=nums.size();\\n        vector<int>dp1(n,0),dp2(n,0);\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            if(i<x){//when we haven\\'t considered x-size array\\n                sum+=nums[i]; \\n                dp1[i]=sum;\\n            }\\n            else{ //when we have a window of size x\\n                sum=sum+nums[i]-nums[i-x];\\n                dp1[i]=max(dp1[i-1],sum);\\n            }\\n        }\\n        sum=0;\\n        //check from right to left for Secondlen window and store maximum sum from ith index to last index keep updating at every point if the current window of size secondLen is max or dp2[i+1] has max whichever is max add that to dp[i]\\n        \\n        for(int i=n-1;i>=0;i--){\\n            if(i+y>n-1) { //case when we haven\\'t encountered a window of size secondlen ie. y\\n                sum+=nums[i];\\n                dp2[i]=sum;\\n            }\\n            else{//when we have a window of size secondLen\\n                sum=sum+nums[i]-nums[i+y];\\n                dp2[i]=max(dp2[i+1],sum);\\n            }\\n        }\\n        int ans=0;\\n        //our ans window will be from x-1 to n-y\\n        for(int i=x-1;i<n-y;i++){\\n            ans=max(ans,dp1[i]+dp2[i+1]);\\n        }\\n        return ans;\\n    }\\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen){\\n        return max(helper(nums, firstLen, secondLen),helper(nums, secondLen, firstLen));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 278723,
                "title": "analysis-maximum-sum-of-two-non-overlapping-subarrays",
                "content": "**Intuition and Algorithm**\\n\\n**Approach 1 (Brute Force)**\\nSimulate, check all the posibilites and get the maximum.\\n<code>\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint f(vector<int>v, int a,int b){\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tfor(int i=0;i<v.size();i++)\\n\\t\\t\\t\\tfor(int j=i+a;j+b-1<v.size();j++){\\n\\t\\t\\t\\t\\tint sum1= accumulate(v.begin()+i,v.begin()+i+a,0);\\n\\t\\t\\t\\t\\tint sum2= accumulate(v.begin()+j,v.begin()+j+b,0);\\n\\t\\t\\t\\t\\tans = max(ans,sum1+sum2);\\n\\t\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t\\t\\n\\t\\tint maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n\\t\\t\\treturn max(f(A,L,M),f(A,M,L));\\n\\t\\t}\\n\\t};\\n</code>\\n\\n<b>Complexity time </b>\\n* O(n^3) where n is the length of A\\n\\n**Approach 2 (Preprocess accumulate)**\\nWe can optimize the previous algorithm, preprocessing sum between two index.\\nSUM(v[i]....v[j] ) =  ac[j+1]-ac[i]\\n<code>\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint f(vector<int>v, int a,int b){\\n\\t\\t\\tint ans=0;\\n\\t\\t\\t\\n\\t\\t\\tint ac[v.size()+1];\\n\\t\\t\\tmemset(ac,0,sizeof(ac));\\n\\t\\t\\tfor(int i=1;i<=v.size();i++)\\n\\t\\t\\t\\tac[i]= ac[i-1]+v[i-1];\\n\\t\\t\\t\\n\\t\\t\\tfor(int i=0;i<v.size();i++)\\n\\t\\t\\t\\tfor(int j=i+a;j+b-1<v.size();j++){\\n\\t\\t\\t\\t\\tint sum1= ac[i+a]-ac[i];\\n\\t\\t\\t\\t\\tint sum2= ac[j+b]-ac[j];\\n\\t\\t\\t\\t\\tans = max(ans,sum1+sum2);\\n\\t\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t\\t\\n\\t\\tint maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n\\t\\t\\treturn max(f(A,L,M),f(A,M,L));\\n\\t\\t}\\n\\t};\\n</code>\\n\\n<b>Complexity time </b>\\n* O(n^2) where n is the length of A\\n\\n**Approach 3 (Preprocess max prefix and max suffix)**\\nNow, we are going to get preprocess max prefix and max suffix.\\nFor example:  \\nGiven a function  f(v, 3,5)\\nwhere v= [3,4,2,5,7,8,1,2]\\n**check all prefix with length 3**\\nPrefix [3,4,2]-> sum 9 , index 2 \\n          [4,2,5]-> sum 11, index 3\\n\\t\\t  [2,5,7]-> sum 15 , index 4\\n\\t\\t  [5,7,8]-> sum 20 , index 5\\n\\t\\t  [7,8,1]-> sum 16 , index 6\\n\\t\\t  [8,1,2]-> sum 11 , index 7\\nOur prefix array with length 3 will be\\n<code> prefix [] = {-1,-1,9 ,11,15,20,16,11  } </code> \\nOur max prefix array with length 3 will be\\n<code> maxPrefix [] = {-1,-1,9 ,11,15,20,20,20  } </code>\\n\\nWe will do the same with suffix\\nGiven a function  f(v, 3,5)\\nwhere v= [3,4,2,5,7,8,1,2]\\n**check all suffix with length 5**\\nSuffix [5,7,8,1,2]-> sum 23 , index 3  (start index) \\n          [2,5,7,8,1]-> sum 23, index 2\\n\\t\\t  [4,2,5,7,8]-> sum 26 , index 1\\n\\t\\t  [3,4,2,5,7]-> sum 21 , index 0\\n\\nOur suffix array with length 5 will be\\n<code> suffix [] = {21,26,23,23, ..... } </code> \\nOur max suffix array with length 5 will be\\n<code> maxSuffix [] = {21,26,26,26, ....  } </code>\\n\\nWe can build suffix and preffix array in O(n)\\nThe solution of the problem will be  MAX(maxPrefix[i]+ maxSuffix[i+1] )\\nI did that in Contest :). \\n\\n**C++**\\n<code>\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint f(vector<int>v, int a,int b){\\n\\t\\t\\tint max1[v.size()];\\n\\t\\t\\tmemset(max1,-1,sizeof(max1));\\n\\t\\t\\tint sum=0;\\n\\t\\t\\tfor(int i=0;i<a-1;i++)\\n\\t\\t\\t\\tsum+=v[i];\\n\\t\\t\\t\\n\\t\\t\\tfor(int i=a-1;i<v.size();i++){\\n\\t\\t\\t\\tsum+=v[i];\\n\\t\\t\\t\\tif(i-1>=0)\\n\\t\\t\\t\\t\\tmax1[i]=max(max1[i-1],sum);\\n\\t\\t\\t\\telse \\n\\t\\t\\t\\t\\tmax1[i]=sum;\\n\\t\\t\\t\\tsum-=v[i-(a-1)];\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tsum=0;\\n\\t\\t\\tfor(int i=v.size()-1;i>(int)v.size()-b;i--){\\n\\t\\t\\t\\tsum+=v[i];\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tint suf=-1;\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tfor(int i=(int)v.size()-b;i>0;i--){\\n\\t\\t\\t\\tsum+=v[i];    \\n\\t\\t\\t\\tsuf=max(sum,suf);\\n\\t\\t\\t\\tif(max1[i-1]!=-1){\\n\\t\\t\\t\\t\\tans=max(ans,max1[i-1]+suf);\\n\\t\\t\\t\\t}\\t\\n\\t\\t\\t\\tsum-=v[i+(b-1)];\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t\\t\\n\\t\\tint maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n\\t\\t\\treturn max(f(A,L,M),f(A,M,L));\\n\\t\\t}\\n\\t};\\n</code>\\n\\n<b>Complexity time </b>\\n* O(n) where n is the length of A",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint f(vector<int>v, int a,int b){\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tfor(int i=0;i<v.size();i++)\\n\\t\\t\\t\\tfor(int j=i+a;j+b-1<v.size();j++){\\n\\t\\t\\t\\t\\tint sum1= accumulate(v.begin()+i,v.begin()+i+a,0);\\n\\t\\t\\t\\t\\tint sum2= accumulate(v.begin()+j,v.begin()+j+b,0);\\n\\t\\t\\t\\t\\tans = max(ans,sum1+sum2);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 355352,
                "title": "full-explanation-and-idea-formation-java-beat-99",
                "content": "# Idea 1; Simple and intutive \\n<details>\\n\\n```\\n\\n\\n /**\\n     * This is really a mind twister for me at least.\\n     * the biggest problem here is \"L\" and \"M\" can be interchange in terms of sub-array position.\\n     * <p>\\n     * Let\\'s for a while forget about their interchangeability, as we can always run algorithm bi-directional [2\\'s ].\\n     * <p>\\n     * Now Lets first concentrate what would be the outcome when L comes first then M.\\n     * [0,6,5,2,2,5,1,9,4]\\n     * <p>\\n     * * if L array comes first of \"L\" size, we can simply build a pre-sum array using which we can easily find what is the sum of the current sub-array of L size.\\n     * * Similarly we can build the \"M\" size array from Back using pre-sum ( from back ).\\n     * * Since we need to make sure that choosing any them should not be overlap.\\n     * * as It can be seen that by building pre-Sum for L (from Left) and pre-Sum for M (from back) will make sure that at any index i, the value at LpreSum is a sub-array which is\\n     * not overlapping with a sub-array given by Mpre-Sum, assuming right boundary as 0.\\n     * <p>\\n     * Now, Once we know that, we can easily build the final sum, by joining both arrays.\\n     * <p>\\n     * Do it similarly for M come first then L. finally take the maximum of both.\\n     * <p>\\n     * If you look closely, it is similar to Buy-Sell stocks two times {@link Java.LeetCode.stockPrices.MaxProfitTwoTransaction}\\n     * Here we just change how we build the array.\\n     * <p>\\n     * Example:  [0,6,5,2,2,5,1,9,4] L=1, M=2\\n     * When L First and M next\\n     * LPreSum[i] =  Max ( LpreSum[i-1], LpreSum[i] - LPreSum[i-L] )\\n     * * [ 0 , 6, 6, 6 , 6, 6, 6, 9 , 9 ] L=1\\n     * *\\n     * MPreSum[i] =  Max ( MPreSum[i+1], MPreSum[i] - MPreSum[i+M] )\\n     * * [ 13 ,13, 13 , 13, 13 , 13, 13 , 4, 0 ] M=2\\n     * <p>\\n     * Max = 19\\n     * <p>\\n     * When M First and L next\\n     * MPreSum[i] =  Max ( MPreSum[i+1], MPreSum[i] - MPreSum[i+L] )\\n     * * [ 0 , 6, 11, 11 , 11, 11, 11, 11 , 13 ] M=2\\n     * *\\n     * LPreSum[i] =  Max ( LPreSum[i-1], LPreSum[i] - LPreSum[i-M] )\\n     * * [ 9 ,9, 9 , 9, 9 , 9, 9 , 4, 0 ] L=1\\n     * *\\n     * Max = 20\\n     * <p>\\n     * Overall Max = 20\\n     *\\n     * @return Runtime: 2 ms, faster than 46.94% of Java online submissions for Maximum Sum of Two Non-Overlapping Subarrays.\\n     * Memory Usage: 38.6 MB, less than 8.70% of Java online submissions for Maximum Sum of Two Non-Overlapping Subarrays.\\n     * <p>\\n     * https://leetcode.com/problems/maximum-sum-of-two-non-overlapping-subarrays/discuss/278727/C%2B%2B-O(N)-buysell-stock-2-times\\n     *\\n     *\\n     */\\n\\n    static class MaximumSumTwoNonOverlapUsingBuySellStocksIdea {\\n\\n        public static int maxSumTwoNoOverlap(int[] nums, int L, int M) {\\n\\n            if (null == nums || nums.length == 0 || nums.length < L + M)\\n                return -1;\\n\\n\\n            return Math.max(maxSum(nums, L, M), maxSum(nums, M, L));\\n\\n        }\\n\\n\\n        private static int maxSum(int nums[], int L, int M) {\\n\\n            int max = 0;\\n            int n = nums.length;\\n            int LPreSum[] = new int[n];\\n            int MPreSum[] = new int[n];\\n\\n\\n            int leftSum = nums[0];\\n            LPreSum[0] = nums[0];\\n\\n\\n            int rightSum = 0;\\n            MPreSum[n - 1] = 0; //right boundary as 0\\n\\n            for (int i = 1, j = n - 2; i < n && j >= 0; i++, j--) {\\n\\n\\n                leftSum += nums[i];\\n\\n\\n                if (i >= L)\\n                    leftSum -= nums[i - L];\\n\\n                LPreSum[i] = Math.max(LPreSum[i - 1], leftSum);\\n\\n\\n                rightSum += nums[j + 1];\\n                if (j + M + 1 < n) //outside of M window\\n                    rightSum -= nums[j + M + 1];\\n\\n                MPreSum[j] = Math.max(MPreSum[j + 1], rightSum);\\n\\n            }\\n\\n            for (int i = 0; i < n; i++)\\n                max = Math.max(max, LPreSum[i] + MPreSum[i]);\\n\\n            return max;\\n        }\\n\\n    }\\n```\\n\\n\\n</details>\\n\\n# Idea 2: Complex but efficient\\n![image](https://assets.leetcode.com/users/nits2010/image_1565450311.png)\\n\\nThe whole trick is to manipulate the whole array as contiguous L or M elements after M or L elements [ bit confusing i know] .\\n\\nNow since we have two things to do;\\nEither we take first L elements then M elements\\nOr we take first M elements then L elements;\\n\\nFor example;\\n3, 8, 1 ,4, 2, 7 and L = 3 & M=2\\n\\nso configuration is\\nEither we take first L elements then M elements => L[3,8,1] & M[2,7]\\nOr we take first M elements then L elements; => M[3,8] & L[1,4,2]\\nThis way we can avoid overlapping arrays.\\n\\nWe choose whatever configuration gives us the maximum Sum.\\n\\nNow, Here is a sample run of the idea;\\n8, 1, 4, 2, 7, 22, 9} L=3, M=2\\n\\n0\\t1\\t2\\t3\\t4\\t5\\t6\\t7\\n3\\t8\\t1\\t4\\t2\\t7\\t22\\t9\\n\\nCumulative Sum (CM)\\n\\n0\\t1\\t2\\t3\\t4\\t5\\t6\\t7\\n3\\t8\\t1\\t4\\t2\\t7\\t22\\t9\\n3\\t11\\t12\\t16\\t18\\t25\\t47\\t56 . -------> CM\\n\\nLMax : L contagious elements taken first\\nMMax: M contagious element taken first\\n\\nMax: Maximum sum for two non-overlapping sub-array\\n\\ni=0 {Here if you see Lmax and Mmax they will look overlapping but Max is already been make sure that they are not overlapping}\\nLMAx = CM[L-1] = CM[2] = 12 [ 3,8,1] ->\\nMMax = CM[M-1] = CM[1] = 11 [3,8]\\nMax = CM[L+M-1] = CM[4] = 18 { [3,8,1] & [4,2] }\\n\\nI=5\\nNext L Elements are [8,1,4]=13 and earlier [3,8,1] = 12 => 13\\nNext M elements are [8,1]= 9 and earlier [3,8] = 11 => 11\\nMax = {L elements + M elements , M elements + L elements } = {13 + {25-16}, 11+{25-12} } \\nAs {8,1,4} + [2,7] + {3,8} +[4,2,7]\\n={21, 24 } = 24\\nSince [8,1,4]=13 Gave maximum as compare to old [3,8,1]\\nAnd [3,8]=11 Gave maximum as compare to new [8,1].\\n\\nNow M elements after [8,1,4] are [2,7]=9\\nAnd Next L elements after [8,1] are [4,2,7]=13\\n\\nI=6\\nNext L elements are [1,4,2] = 8 and earlier [8,1,4] = 13 => 13\\nNext M elements are [1,4] = 5 and earlier [3,8] = 11 => 11\\n\\nNow M elements after [1,4,2] are [7,22]= 29\\nAnd L elements after [1,4] are [2,7,22]=31\\nMax = {L elements + M elements , M elements + L elements } = {13 + {47-18}, 11 + {47-16} } = = {13 + 29, 11 + 31 } = 42\\n\\nSince [1,4,2]=8 did not give maximum sum as compare to old [8,1,4]=13\\nAnd [1,4]=5 did not give maximum sum as compare to old [3,8]=11\\n\\nI =7\\nL-> [4,2,7]=13 ; old [8,1,4]=13 => 13\\nM -> [4,2]=7 , old [3,8]=11 => 11\\nMax = { 13 + 31, 11 + 38 } = 49\\nL-> Next M Elements [22,9]\\nM-> Next L elements [7,22,9]\\n\\u2026.\\nAns= 49\\n\\nCode \\n\\n<details>\\n\\n```\\n public static int maxSumTwoNoOverlap(int[] nums, int L, int M) {\\n\\n            if (null == nums || nums.length == 0 || nums.length < L + M)\\n                return -1;\\n\\n\\n            return maxSum(nums, L, M);\\n\\n        }\\n\\n        private static int maxSum(int[] nums, int L, int M) {\\n\\n            for (int i = 1; i < nums.length; ++i)\\n                nums[i] += nums[i - 1];\\n\\n            int res = nums[L + M - 1], Lmax = nums[L - 1], Mmax = nums[M - 1];\\n\\n            for (int i = L + M; i < nums.length; ++i) {\\n  \\n                //Lmax is the case when L contiguous elements are taken first\\n                Lmax = Math.max(Lmax, nums[i - M] - nums[i - L - M]);\\n  \\n                //Mmax is the case when M contiguous elements are taken first\\n                Mmax = Math.max(Mmax, nums[i - L] - nums[i - L - M]);\\n                int x = Lmax + nums[i] - nums[i - M];\\n                int y = Mmax + nums[i] - nums[i - L];\\n  \\n                res = Math.max(res, Math.max(x, y));\\n            }\\n            return res;\\n        }\\n```\\n</details>",
                "solutionTags": [],
                "code": "```\\n\\n\\n /**\\n     * This is really a mind twister for me at least.\\n     * the biggest problem here is \"L\" and \"M\" can be interchange in terms of sub-array position.\\n     * <p>\\n     * Let\\'s for a while forget about their interchangeability, as we can always run algorithm bi-directional [2\\'s ].\\n     * <p>\\n     * Now Lets first concentrate what would be the outcome when L comes first then M.\\n     * [0,6,5,2,2,5,1,9,4]\\n     * <p>\\n     * * if L array comes first of \"L\" size, we can simply build a pre-sum array using which we can easily find what is the sum of the current sub-array of L size.\\n     * * Similarly we can build the \"M\" size array from Back using pre-sum ( from back ).\\n     * * Since we need to make sure that choosing any them should not be overlap.\\n     * * as It can be seen that by building pre-Sum for L (from Left) and pre-Sum for M (from back) will make sure that at any index i, the value at LpreSum is a sub-array which is\\n     * not overlapping with a sub-array given by Mpre-Sum, assuming right boundary as 0.\\n     * <p>\\n     * Now, Once we know that, we can easily build the final sum, by joining both arrays.\\n     * <p>\\n     * Do it similarly for M come first then L. finally take the maximum of both.\\n     * <p>\\n     * If you look closely, it is similar to Buy-Sell stocks two times {@link Java.LeetCode.stockPrices.MaxProfitTwoTransaction}\\n     * Here we just change how we build the array.\\n     * <p>\\n     * Example:  [0,6,5,2,2,5,1,9,4] L=1, M=2\\n     * When L First and M next\\n     * LPreSum[i] =  Max ( LpreSum[i-1], LpreSum[i] - LPreSum[i-L] )\\n     * * [ 0 , 6, 6, 6 , 6, 6, 6, 9 , 9 ] L=1\\n     * *\\n     * MPreSum[i] =  Max ( MPreSum[i+1], MPreSum[i] - MPreSum[i+M] )\\n     * * [ 13 ,13, 13 , 13, 13 , 13, 13 , 4, 0 ] M=2\\n     * <p>\\n     * Max = 19\\n     * <p>\\n     * When M First and L next\\n     * MPreSum[i] =  Max ( MPreSum[i+1], MPreSum[i] - MPreSum[i+L] )\\n     * * [ 0 , 6, 11, 11 , 11, 11, 11, 11 , 13 ] M=2\\n     * *\\n     * LPreSum[i] =  Max ( LPreSum[i-1], LPreSum[i] - LPreSum[i-M] )\\n     * * [ 9 ,9, 9 , 9, 9 , 9, 9 , 4, 0 ] L=1\\n     * *\\n     * Max = 20\\n     * <p>\\n     * Overall Max = 20\\n     *\\n     * @return Runtime: 2 ms, faster than 46.94% of Java online submissions for Maximum Sum of Two Non-Overlapping Subarrays.\\n     * Memory Usage: 38.6 MB, less than 8.70% of Java online submissions for Maximum Sum of Two Non-Overlapping Subarrays.\\n     * <p>\\n     * https://leetcode.com/problems/maximum-sum-of-two-non-overlapping-subarrays/discuss/278727/C%2B%2B-O(N)-buysell-stock-2-times\\n     *\\n     *\\n     */\\n\\n    static class MaximumSumTwoNonOverlapUsingBuySellStocksIdea {\\n\\n        public static int maxSumTwoNoOverlap(int[] nums, int L, int M) {\\n\\n            if (null == nums || nums.length == 0 || nums.length < L + M)\\n                return -1;\\n\\n\\n            return Math.max(maxSum(nums, L, M), maxSum(nums, M, L));\\n\\n        }\\n\\n\\n        private static int maxSum(int nums[], int L, int M) {\\n\\n            int max = 0;\\n            int n = nums.length;\\n            int LPreSum[] = new int[n];\\n            int MPreSum[] = new int[n];\\n\\n\\n            int leftSum = nums[0];\\n            LPreSum[0] = nums[0];\\n\\n\\n            int rightSum = 0;\\n            MPreSum[n - 1] = 0; //right boundary as 0\\n\\n            for (int i = 1, j = n - 2; i < n && j >= 0; i++, j--) {\\n\\n\\n                leftSum += nums[i];\\n\\n\\n                if (i >= L)\\n                    leftSum -= nums[i - L];\\n\\n                LPreSum[i] = Math.max(LPreSum[i - 1], leftSum);\\n\\n\\n                rightSum += nums[j + 1];\\n                if (j + M + 1 < n) //outside of M window\\n                    rightSum -= nums[j + M + 1];\\n\\n                MPreSum[j] = Math.max(MPreSum[j + 1], rightSum);\\n\\n            }\\n\\n            for (int i = 0; i < n; i++)\\n                max = Math.max(max, LPreSum[i] + MPreSum[i]);\\n\\n            return max;\\n        }\\n\\n    }\\n```\n```\\n public static int maxSumTwoNoOverlap(int[] nums, int L, int M) {\\n\\n            if (null == nums || nums.length == 0 || nums.length < L + M)\\n                return -1;\\n\\n\\n            return maxSum(nums, L, M);\\n\\n        }\\n\\n        private static int maxSum(int[] nums, int L, int M) {\\n\\n            for (int i = 1; i < nums.length; ++i)\\n                nums[i] += nums[i - 1];\\n\\n            int res = nums[L + M - 1], Lmax = nums[L - 1], Mmax = nums[M - 1];\\n\\n            for (int i = L + M; i < nums.length; ++i) {\\n  \\n                //Lmax is the case when L contiguous elements are taken first\\n                Lmax = Math.max(Lmax, nums[i - M] - nums[i - L - M]);\\n  \\n                //Mmax is the case when M contiguous elements are taken first\\n                Mmax = Math.max(Mmax, nums[i - L] - nums[i - L - M]);\\n                int x = Lmax + nums[i] - nums[i - M];\\n                int y = Mmax + nums[i] - nums[i - L];\\n  \\n                res = Math.max(res, Math.max(x, y));\\n            }\\n            return res;\\n        }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 784911,
                "title": "c-faster-than-100-0-ms-o-n-time-and-o-1-space-improve-from-dp-approach",
                "content": "Without loss of generality, consider M before L: (M= firstlength, L = secondLength)\\n1. DP approach:\\n\\tLet call:\\n\\t- sumL[i] is the sum of subarray length L and end in i so :\\n\\t\\t\\t\\t\\t\\t\\t\\t`sumL[i] = A[i-L+1] +....+A[i] = sumL[i-1] + A[i] - A[i-L];`\\n\\t- sumM is the same with sumL but length M.\\n\\t- dpM [i] is the largest sum subarray of length M in the segment 0 -> i, so :\\n\\t`dpM[i] = max (sumM[i], dpM [i-1]);`\\n\\n\\tthen for each position i the result can be  sumL[i] + dpM [i-L]:\\n\\t`res = max(res, sumL[i] + dpM[i-L]);`\\n2. Reduce memory:\\n\\tWe can combine all of DP  function by using one loop for all of them, and you can see that the dpM[i] update from dpM[i-1], sumL[i] and sumM[i] also update from previous (sumL[i-1] and sumM[i-1]), so we can use one variable for each of those instead using vector. \\n\\n\\t\\n```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        return max(help(A, L, M), help(A, M, L));\\n    }\\n    \\n    int help(vector<int>& A, int L, int M) {\\n        int n = A.size();\\n        int sMMax = 0;\\n        int sL = 0, sM = 0;\\n        int res = 0;\\n        for(int i = 0; i < n; i++) {\\n            sL += A[i];\\n            if(i >= L) {\\n                sL -= A[i-L];\\n                sM += A[i-L];\\n            }\\n            if(i-L >= M) {\\n                sM -= A[i-L-M];\\n            }\\n            sMMax = max(sMMax, sM);\\n            res = max(res, sL + sMMax);      \\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        return max(help(A, L, M), help(A, M, L));\\n    }\\n    \\n    int help(vector<int>& A, int L, int M) {\\n        int n = A.size();\\n        int sMMax = 0;\\n        int sL = 0, sM = 0;\\n        int res = 0;\\n        for(int i = 0; i < n; i++) {\\n            sL += A[i];\\n            if(i >= L) {\\n                sL -= A[i-L];\\n                sM += A[i-L];\\n            }\\n            if(i-L >= M) {\\n                sM -= A[i-L-M];\\n            }\\n            sMMax = max(sMMax, sM);\\n            res = max(res, sL + sMMax);      \\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 760194,
                "title": "python-clean-o-n-98",
                "content": "We have to check two scenarious, subarray M is before L, or after. To be able to compute sums of subarrays faster we calculate prefix sum first:\\n```\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n        prefix = [0]\\n        maxl = maxm = summ = 0\\n        for x in A:\\n            prefix.append(prefix[-1] + x)\\n        \\n        for x in range(M, len(prefix) - L):\\n            maxm = max(maxm, prefix[x] - prefix[x - M])\\n            summ = max(summ, maxm + prefix[x + L] - prefix[x])\\n        \\n        for x in range(L, len(prefix) - M):\\n            maxl = max(maxl, prefix[x] - prefix[x - L])\\n            summ = max(summ, maxl + prefix[x + M] - prefix[x])\\n        \\n        return summ\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n        prefix = [0]\\n        maxl = maxm = summ = 0\\n        for x in A:\\n            prefix.append(prefix[-1] + x)\\n        \\n        for x in range(M, len(prefix) - L):\\n            maxm = max(maxm, prefix[x] - prefix[x - M])\\n            summ = max(summ, maxm + prefix[x + L] - prefix[x])\\n        \\n        for x in range(L, len(prefix) - M):\\n            maxl = max(maxl, prefix[x] - prefix[x - L])\\n            summ = max(summ, maxl + prefix[x + M] - prefix[x])\\n        \\n        return summ\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1225993,
                "title": "very-very-easy-to-understand-explanation-javascript-o-n-prefix-sum-sliding-window",
                "content": "Been struggling with this question for almost whole day (yes I\\'m stupid)\\nI\\'m not smart enough to understand those code posted in discuss (They are good! It\\'s not their problem, it\\'s my level isn\\'t there yet)\\nFinally managed to solve this question.\\n### Key point:\\n1. Calculate prefix sum of input\\n2. Maintain 2 sliding window, 1 for L sized subarray, 1 for M sized subarray\\n3. There are 2 cases, L subarray is before M subarray, and M subarray is before L subarray\\n4. Traverse through array, ***L before M***, find maxium value of L subarray and fix to it, add this value to M subarray, compare with result to find max\\n5. Traverse through array, ***M before L***, find maxium value of M subarray and fix to it, add this value to L subarray, compare with result to find max\\n\\nIf you found this useful, please upvote or comment, thank you!\\n\\nCode are documented:\\n```\\nvar maxSumTwoNoOverlap = function(A, L, M) {\\n    \\n    let prefixSum = []\\n    let result = 0\\n    \\n    for (let i=0; i<=A.length - 1; i++) {\\n        if (prefixSum.length == 0) {\\n            prefixSum.push(A[i])\\n        } else {\\n            prefixSum.push(A[i] + prefixSum[i - 1])\\n        }\\n    }\\n    /*\\n    Add a zero to first of prefix sum to conveniently calculate first appeared prefix sum\\n    For example: nums = [1,2,3,4,5,6,7], L=3, M=2\\n    normal prefix sum:  [1,3,6,10,15,21,28]\\n    If we want to calculate L subarray 1+2+3=6 \\n    According to the algorithm is: prefixSum[i - M] - prefixSum[i - M - L] which will be 10-1=9 which is incorrect\\n    But if we add 0 to prefix sum:  [0,1,3,6,10,15,21,28], it\\'ll be 6-0 = 6\\n    */\\n    prefixSum.unshift(0)\\n    \\n    let lMax = 0\\n    \\n    // 1. Maintain sliding window, L subarray before M subarray, it is guaranteed that two subarray won\\'t overlap\\n    for (let i=L+M; i<= prefixSum.length -1; i++) {\\n        // 2. Calculate L & M subarray sum\\n        const rangeLSum = prefixSum[i - M] - prefixSum[i - M - L]\\n        const rangeMSum = prefixSum[i] - prefixSum[i - M]\\n        \\n        // 3. Maintain current maxiumn of L sub-array in order to maximize the result the M sub-array\\n        lMax = Math.max(lMax, rangeLSum)\\n        result = Math.max(result, lMax + rangeMSum)\\n    }\\n    \\n    // Same as previous, just M sub-array appear before L subarray\\n    let mMax = 0 \\n    for (let i=L+M; i<= prefixSum.length -1; i++) {\\n        const rangeMSum = prefixSum[i - L] - prefixSum[i - M - L]\\n        const rangeLSum = prefixSum[i] - prefixSum[i - L]\\n        mMax = Math.max(mMax, rangeMSum)\\n        result = Math.max(result, mMax + rangeLSum)\\n    }\\n    \\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar maxSumTwoNoOverlap = function(A, L, M) {\\n    \\n    let prefixSum = []\\n    let result = 0\\n    \\n    for (let i=0; i<=A.length - 1; i++) {\\n        if (prefixSum.length == 0) {\\n            prefixSum.push(A[i])\\n        } else {\\n            prefixSum.push(A[i] + prefixSum[i - 1])\\n        }\\n    }\\n    /*\\n    Add a zero to first of prefix sum to conveniently calculate first appeared prefix sum\\n    For example: nums = [1,2,3,4,5,6,7], L=3, M=2\\n    normal prefix sum:  [1,3,6,10,15,21,28]\\n    If we want to calculate L subarray 1+2+3=6 \\n    According to the algorithm is: prefixSum[i - M] - prefixSum[i - M - L] which will be 10-1=9 which is incorrect\\n    But if we add 0 to prefix sum:  [0,1,3,6,10,15,21,28], it\\'ll be 6-0 = 6\\n    */\\n    prefixSum.unshift(0)\\n    \\n    let lMax = 0\\n    \\n    // 1. Maintain sliding window, L subarray before M subarray, it is guaranteed that two subarray won\\'t overlap\\n    for (let i=L+M; i<= prefixSum.length -1; i++) {\\n        // 2. Calculate L & M subarray sum\\n        const rangeLSum = prefixSum[i - M] - prefixSum[i - M - L]\\n        const rangeMSum = prefixSum[i] - prefixSum[i - M]\\n        \\n        // 3. Maintain current maxiumn of L sub-array in order to maximize the result the M sub-array\\n        lMax = Math.max(lMax, rangeLSum)\\n        result = Math.max(result, lMax + rangeMSum)\\n    }\\n    \\n    // Same as previous, just M sub-array appear before L subarray\\n    let mMax = 0 \\n    for (let i=L+M; i<= prefixSum.length -1; i++) {\\n        const rangeMSum = prefixSum[i - L] - prefixSum[i - M - L]\\n        const rangeLSum = prefixSum[i] - prefixSum[i - L]\\n        mMax = Math.max(mMax, rangeMSum)\\n        result = Math.max(result, mMax + rangeLSum)\\n    }\\n    \\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 287238,
                "title": "c-11l-ine",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        vector<int> sum = {0};\\n        for(auto x:A) sum.push_back(sum.back()+x);\\n        return max(help(sum, L, M), help(sum, M,L));\\n    }\\n    \\n    int help(const vector<int>& sum, int L, int M) {\\n        int maxSumL = sum[L], maxSumLM = sum[L+M];\\n        for(int i=L+M+1;i<sum.size();i++){\\n            int curSumL = sum[i-M] - sum[i-M-L];\\n            int curSumM = sum[i]-sum[i-M];\\n            maxSumL = max(maxSumL, curSumL);\\n            maxSumLM = max(maxSumLM, maxSumL + curSumM);\\n        }\\n        return maxSumLM;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        vector<int> sum = {0}",
                "codeTag": "Java"
            },
            {
                "id": 279433,
                "title": "java-two-pass",
                "content": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        int len = A.length;\\n        int[] sum = new int[len];\\n        sum[0] = A[0];\\n        \\n        for (int i = 1; i < len; ++i) {\\n            sum[i] = sum[i - 1] + A[i];\\n        }\\n        \\n        int res = 0;\\n        int Lmax = sum[L - 1], Mmax = sum[M - 1];\\n        for (int i = 0; i < len; ++i) {\\n            if (i >= L && i + M - 1 < len) {\\n                res = Math.max(res, Lmax + sum[i + M - 1] - sum[i - 1]);\\n            }\\n            \\n            if (i >= M && i + L - 1 < len) {\\n                res = Math.max(res, Mmax + sum[i + L - 1] - sum[i - 1]);\\n            }\\n            \\n            if (i >= L) {\\n                Lmax = Math.max(Lmax, sum[i] - sum[i - L]);\\n            }\\n            \\n            if (i >= M) {\\n                Mmax = Math.max(Mmax, sum[i] - sum[i - M]);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        int len = A.length;\\n        int[] sum = new int[len];\\n        sum[0] = A[0];\\n        \\n        for (int i = 1; i < len; ++i) {\\n            sum[i] = sum[i - 1] + A[i];\\n        }\\n        \\n        int res = 0;\\n        int Lmax = sum[L - 1], Mmax = sum[M - 1];\\n        for (int i = 0; i < len; ++i) {\\n            if (i >= L && i + M - 1 < len) {\\n                res = Math.max(res, Lmax + sum[i + M - 1] - sum[i - 1]);\\n            }\\n            \\n            if (i >= M && i + L - 1 < len) {\\n                res = Math.max(res, Mmax + sum[i + L - 1] - sum[i - 1]);\\n            }\\n            \\n            if (i >= L) {\\n                Lmax = Math.max(Lmax, sum[i] - sum[i - L]);\\n            }\\n            \\n            if (i >= M) {\\n                Mmax = Math.max(Mmax, sum[i] - sum[i - M]);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1541977,
                "title": "easy-c-solution-with-o-n-time-and-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int Max_Sum(vector<int>& nums, int firstLen, int secondLen) {\\n        \\n        \\n        // Just a Sliding Window thing of fixed window size\\n        \\n        int Left_Sum = 0, Right_Sum = 0;\\n        \\n        for(int i = 0; i < firstLen ; i++) Left_Sum += nums[i];\\n        for(int i = firstLen ; i < firstLen + secondLen ; i++) Right_Sum += nums[i];\\n        \\n        int Left_Max_Till = Left_Sum;\\n        \\n        int  ans = Left_Sum + Right_Sum; // answer\\n        \\n        int i = 0 , j = firstLen , k = firstLen + secondLen;\\n        \\n    \\n        \\n        while(k < nums.size()) {\\n            \\n            Left_Sum -= nums[i];\\n            Left_Sum += nums[j];\\n            \\n            Right_Sum -= nums[j];\\n            Right_Sum += nums[k];\\n            \\n           // All previous left subarrays before and including the current one\\n          // will never overlap with the current right subarray so we will be taking \\n          //the maximum value of sum among all left subarrys then will look for the \\n          // right subarry which will maximize the current total sum\\n\\n            Left_Max_Till = max(Left_Max_Till , Left_Sum);\\n            \\n            ans = max(ans , Left_Max_Till + Right_Sum);\\n            \\n            i++;\\n            j++;\\n            k++;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        \\n        // As there are two possibilities \\n        // First, The subarray having size firstLen will be the left subarry\\n        // Second, The subarray having size secondLen will be the right subarray\\n        \\n        return max(Max_Sum(nums , firstLen , secondLen) , Max_Sum(nums , secondLen , firstLen));\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int Max_Sum(vector<int>& nums, int firstLen, int secondLen) {\\n        \\n        \\n        // Just a Sliding Window thing of fixed window size\\n        \\n        int Left_Sum = 0, Right_Sum = 0;\\n        \\n        for(int i = 0; i < firstLen ; i++) Left_Sum += nums[i];\\n        for(int i = firstLen ; i < firstLen + secondLen ; i++) Right_Sum += nums[i];\\n        \\n        int Left_Max_Till = Left_Sum;\\n        \\n        int  ans = Left_Sum + Right_Sum; // answer\\n        \\n        int i = 0 , j = firstLen , k = firstLen + secondLen;\\n        \\n    \\n        \\n        while(k < nums.size()) {\\n            \\n            Left_Sum -= nums[i];\\n            Left_Sum += nums[j];\\n            \\n            Right_Sum -= nums[j];\\n            Right_Sum += nums[k];\\n            \\n           // All previous left subarrays before and including the current one\\n          // will never overlap with the current right subarray so we will be taking \\n          //the maximum value of sum among all left subarrys then will look for the \\n          // right subarry which will maximize the current total sum\\n\\n            Left_Max_Till = max(Left_Max_Till , Left_Sum);\\n            \\n            ans = max(ans , Left_Max_Till + Right_Sum);\\n            \\n            i++;\\n            j++;\\n            k++;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        \\n        // As there are two possibilities \\n        // First, The subarray having size firstLen will be the left subarry\\n        // Second, The subarray having size secondLen will be the right subarray\\n        \\n        return max(Max_Sum(nums , firstLen , secondLen) , Max_Sum(nums , secondLen , firstLen));\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 913234,
                "title": "o-n-thought-process-java",
                "content": "The below documents a thought process to arrive at a solution with `~O(N)` time and `~O(N)` space where `N` is the length if the input array.\\n\\nA brute force approach would be:\\n\\n* pick a starting position for L, calculate the sum\\n* pick a starting position for M, calculate the sum\\n* calculate the sum of the sums. Keep track of the maximum thus far.\\n* Repeat by picking other starting positions\\n\\nHow can we do better? One bottleneck is that to calculate the sum of subarray with a length `M`, it takes `M` array access, and we have to repeat the process multiple times. We can get around it by doing using a previously calculated sum to calculate a new sum. The idea is similar to rolling hash in Rabin-Karp substring matching algorithm.\\n\\nLet\\'s define two arrays `Ls` and `Ms`, where `i`th value is the sum of the subarray of size `L` and `M`, respectively, that begins at `i`.\\n\\nFor an input of `[3,8,1,3,2,1,8,9,0]`, `L=3`, `M=2`,  let\\'s consider `Ls` and `Ms`.\\n\\n| A | 3| 8  | 1  | 3  | 2  | 1  | 8  | 9  | 0  |  \\n|---|---|---|---|---|---|---|---|---|---|\\n| Ls | 12  | 12  |6   | 6  | 11  | 18  | 17  | 0  | 0  |\\n| Ms |  11 | 9  | 4  | 5  | 3  | 9  | 17  |9   |0   |\\n\\nHow can we calculate those entries efficiently? If we know the current entry at `Ls[i]`, the next entry is `Ls[i] - A[i-1] + A[i+L-1]`. We discard the leading value, and add the new value at the tail.\\n\\nGiven `Ls` and `Ms`, we can find our answer by the following process\\n\\n* Pick a position in `Ls[i]`, and find the maximum value in `Ms[i+L ... end]`. Add values.\\n* Pick a position in `Ms[i]`, and find the maximum value in `Ls[i+L ... end]`. Add values.\\n\\nWhat is the bottleneck? The bottleneck is that, to find the maximum value in the remaining eligible subarrays, we need to keep iterating. How can we do better?\\n\\nLet\\'s simply keep track of the maximum `Ms` and `Ls` in `Ms[i...end]` and `Ls[i...end]`. We can use an array to keep track of these values. Let\\'s call them `mmax` and `lmax`.\\n\\n| A | 3| 8  | 1  | 3  | 2  | 1  | 8  | 9  | 0  |  \\n|---|---|---|---|---|---|---|---|---|---|\\n| Ls | 12  | 12  |6   | 6  | 11  | 18  | 17  | 0  | 0  |\\n| Ms |  11 | 9  | 4  | 5  | 3  | 9  | 17  |9   |0   |\\n| lmax |  18 | 18  | 18  | 18  | 18  | 17  | 0  | 0   |0   |\\n| mmax |  17 | 17  | 17  | 17  | 17  |17  | 9  |0   |0   |\\n\\nNow, we can pick a starting position of subarray with length `L`, and instantly locate two things that we need to calculate the possible answer:\\n\\n* the sum of the subarray of length `L`, that begins at the chosen position\\n* the maximum subarray sum for the eligible subarray with length `M`.\\n\\nWe can apply the same logic by for fixing a starting position of subarray with length `M`.\\n\\nBelow is an implementation of this idea.\\n\\n```java\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        int n = A.length;\\n        if (n == 0) {\\n            return 0;\\n        }\\n        if (L + M > n) {\\n            throw new IllegalArgumentException();\\n        }\\n        \\n        int[] Ls = new int[n];\\n        int[] Ms = new int[n];\\n        \\n        int lSum = 0;\\n        int mSum = 0;\\n        \\n        for (int i = 0; i <= n - L; i++) {\\n            if (i == 0) {\\n                for (int j = 0; j < L; j++) {\\n                    lSum += A[j];\\n                }\\n            } else {\\n                lSum = lSum - A[i-1] + A[i+L-1];\\n            }\\n            \\n            Ls[i] = lSum;\\n        }\\n        \\n        for (int i = 0; i <= n - M; i++) {\\n            if (i == 0) {\\n                for (int j = 0; j < M; j++) {\\n                    mSum += A[j];\\n                }\\n            } else {\\n                mSum = mSum - A[i-1] + A[i+M-1];\\n            }\\n            \\n            Ms[i] = mSum;\\n        }\\n        \\n        int[] lmax = new int[n+1];\\n        int[] mmax = new int[n+1];\\n        \\n        for (int i = n - 1; i >= 0; i--) {\\n            lmax[i] = Math.max(lmax[i+1], Ls[i]);\\n            mmax[i] = Math.max(mmax[i+1], Ms[i]);\\n        }\\n\\n        int ans = 0;\\n        for (int i = 0; i <= n - L - 1; i++) {\\n            ans = Math.max(ans, Ls[i] + mmax[i+L]);\\n        }\\n        for (int i = 0; i <= n - M - 1; i++) {\\n            ans = Math.max(ans, Ms[i] + lmax[i+M]);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```\\n\\nLet `N` be the length of `A`, then the code above takes `~O(N)` time and `~O(N)` space.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        int n = A.length;\\n        if (n == 0) {\\n            return 0;\\n        }\\n        if (L + M > n) {\\n            throw new IllegalArgumentException();\\n        }\\n        \\n        int[] Ls = new int[n];\\n        int[] Ms = new int[n];\\n        \\n        int lSum = 0;\\n        int mSum = 0;\\n        \\n        for (int i = 0; i <= n - L; i++) {\\n            if (i == 0) {\\n                for (int j = 0; j < L; j++) {\\n                    lSum += A[j];\\n                }\\n            } else {\\n                lSum = lSum - A[i-1] + A[i+L-1];\\n            }\\n            \\n            Ls[i] = lSum;\\n        }\\n        \\n        for (int i = 0; i <= n - M; i++) {\\n            if (i == 0) {\\n                for (int j = 0; j < M; j++) {\\n                    mSum += A[j];\\n                }\\n            } else {\\n                mSum = mSum - A[i-1] + A[i+M-1];\\n            }\\n            \\n            Ms[i] = mSum;\\n        }\\n        \\n        int[] lmax = new int[n+1];\\n        int[] mmax = new int[n+1];\\n        \\n        for (int i = n - 1; i >= 0; i--) {\\n            lmax[i] = Math.max(lmax[i+1], Ls[i]);\\n            mmax[i] = Math.max(mmax[i+1], Ms[i]);\\n        }\\n\\n        int ans = 0;\\n        for (int i = 0; i <= n - L - 1; i++) {\\n            ans = Math.max(ans, Ls[i] + mmax[i+L]);\\n        }\\n        for (int i = 0; i <= n - M - 1; i++) {\\n            ans = Math.max(ans, Ms[i] + lmax[i+M]);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1489581,
                "title": "java-easy-to-understand-prefix-sum",
                "content": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        int sums[] = new int[A.length+1];\\n        \\n        for(int i=1;i<=A.length;i++)\\n            sums[i] = A[i-1]+sums[i-1];\\n        \\n        int maxLval = 0;\\n        int ans=0;\\n        for(int i=L;i<=A.length-M;i++)\\n        {\\n            maxLval = Math.max(maxLval,sums[i]-sums[i-L]);\\n            ans = Math.max(ans,sums[i+M]-sums[i]+maxLval);\\n        }\\n        int maxRval = 0 ;\\n        for(int i=M;i<=A.length-L;i++)\\n        {\\n            maxRval = Math.max(maxRval,sums[i]-sums[i-M]);\\n            ans = Math.max(ans,sums[i+L]-sums[i]+maxRval);\\n        }\\n        return ans;\\n    }\\n}\\n```\\nPlease upvote if u find my code easy to understand",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        int sums[] = new int[A.length+1];\\n        \\n        for(int i=1;i<=A.length;i++)\\n            sums[i] = A[i-1]+sums[i-1];\\n        \\n        int maxLval = 0;\\n        int ans=0;\\n        for(int i=L;i<=A.length-M;i++)\\n        {\\n            maxLval = Math.max(maxLval,sums[i]-sums[i-L]);\\n            ans = Math.max(ans,sums[i+M]-sums[i]+maxLval);\\n        }\\n        int maxRval = 0 ;\\n        for(int i=M;i<=A.length-L;i++)\\n        {\\n            maxRval = Math.max(maxRval,sums[i]-sums[i-M]);\\n            ans = Math.max(ans,sums[i+L]-sums[i]+maxRval);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1291528,
                "title": "c-prefix-sum-and-then-trying-all-combinations",
                "content": "## Approach\\nThis question in itself is very easy to solve naively, but the bottleneck lies in the operation of calculating the sum of the subarrays.\\nThis O(n) operation can be made O(1) by using a prefix sum array.\\nPrefix sum is a common approach which makes taking sum of subarrays very easy and fast. There are n+1 elements in the array, each corresponding to the sum of all the elements coming before that index in the array.\\n\\nAny element of the prefix sum array follows this recurrence relation:\\n```prefixSum[i] = prefixSum[i-1] + nums[i-1], prefixSum[0] = 0```\\n\\nNow any subarray sum can be calculated in O(1).\\nLet the subarray be from index i to j (inclusive). Then the subarray sum is given as ```sum  = prefixSum[j+1] - prefixSum[i+1]```.\\n\\nNow we iterate over the array and choose our l-length subarray first. Then we search for the maximum sum of any m-length subarray to the left or to the right of the current l-subarray. Then we take the maximum of lsum + rsum over these cases, and return the answer.\\n<br />\\n\\n## Code\\nThe code for the above approach is given as follows:\\n```\\nint maxSumTwoNoOverlap(vector<int>& nums, int l, int m) {\\n\\tint n = nums.size();\\n\\tvector<int> prefixSum(n+1, 0);\\n\\tint maxSum = 0;\\n\\t\\n\\t//building the prefix sums\\n\\tprefixSum[0] = 0;\\n\\tfor(int i = 1; i<=n; i++) {\\n\\t\\tprefixSum[i] = prefixSum[i-1] + nums[i-1];\\n\\t}\\n\\t\\n\\t//selecting the l length subarray\\n\\tfor(int i = 0; i<=n-l; i++) {\\n\\t\\tint lsum = prefixSum[i+l] - prefixSum[i];\\n\\t\\t\\n\\t\\t//looking left\\n\\t\\tfor(int j = 0; j<=i-m; j++) {\\n\\t\\t\\tint msum = prefixSum[j+m] - prefixSum[j];\\n\\t\\t\\tmaxSum = max(maxSum, lsum + msum);\\n\\t\\t}\\n\\t\\t\\n\\t\\t//looking right \\n\\t\\tfor(int j = i+l; j<=n-m; j++) {\\n\\t\\t\\tint msum = prefixSum[j+m] - prefixSum[j];\\n\\t\\t\\tmaxSum = max(maxSum, lsum + msum);\\n\\t\\t}\\n\\t}\\n\\treturn maxSum;\\n}\\n```\\n\\nFeel free to ask any doubts or suggest any corrections/improvements in the comments. Please upvote if you liked this post.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```prefixSum[i] = prefixSum[i-1] + nums[i-1], prefixSum[0] = 0```\n```sum  = prefixSum[j+1] - prefixSum[i+1]```\n```\\nint maxSumTwoNoOverlap(vector<int>& nums, int l, int m) {\\n\\tint n = nums.size();\\n\\tvector<int> prefixSum(n+1, 0);\\n\\tint maxSum = 0;\\n\\t\\n\\t//building the prefix sums\\n\\tprefixSum[0] = 0;\\n\\tfor(int i = 1; i<=n; i++) {\\n\\t\\tprefixSum[i] = prefixSum[i-1] + nums[i-1];\\n\\t}\\n\\t\\n\\t//selecting the l length subarray\\n\\tfor(int i = 0; i<=n-l; i++) {\\n\\t\\tint lsum = prefixSum[i+l] - prefixSum[i];\\n\\t\\t\\n\\t\\t//looking left\\n\\t\\tfor(int j = 0; j<=i-m; j++) {\\n\\t\\t\\tint msum = prefixSum[j+m] - prefixSum[j];\\n\\t\\t\\tmaxSum = max(maxSum, lsum + msum);\\n\\t\\t}\\n\\t\\t\\n\\t\\t//looking right \\n\\t\\tfor(int j = i+l; j<=n-m; j++) {\\n\\t\\t\\tint msum = prefixSum[j+m] - prefixSum[j];\\n\\t\\t\\tmaxSum = max(maxSum, lsum + msum);\\n\\t\\t}\\n\\t}\\n\\treturn maxSum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 288993,
                "title": "java-dp-solution",
                "content": "Extend Kadane\\'s algorithm for two non-overlapping subarrays with L & M in length\\n```\\n    /*\\n          |---L--| <- prior maxL\\n\\t\\t     |---L--| <- sum[i-M]-sum[i-M-L]\\n                    |---M----| \\n--------------------|--------i\\n\\n\\n         |--M---| <- maxM  at i-L position \\n                    |---L----| \\n--------------------|--------i\\n    */\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n     if (A==null || A.length < L+M) return 0;   \\n     int []sum = new int[A.length];\\n    \\n     // leetcode 53, Maximum Subarray (Kadane\\'s Algorithm) \\n     sum[0]=A[0];    \\n     for(int i=1; i< A.length;i++){\\n        sum[i] = Math.max(A[i],sum[i-1] + A[i]);  \\n     }\\n\\n     int maxL = sum[L-1]; // initial value\\n     int maxM = sum[M-1]; // initial value\\n     int res = sum[L+M-1];  // initial value\\n     for(int i=L+M; i < sum.length; i++){\\n        maxL = Math.max(maxL, sum[i-M]-sum[i-M-L]); // maxL at i-M position\\n        maxM = Math.max(maxM, sum[i-L]-sum[i-M-L]); //maxM at i-L position  \\n        res = Math.max(res, Math.max(maxL + sum[i] - sum[i-M],\\n                                     maxM + sum[i] - sum[i-L]));\\n     }   \\n     return res;   \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    /*\\n          |---L--| <- prior maxL\\n\\t\\t     |---L--| <- sum[i-M]-sum[i-M-L]\\n                    |---M----| \\n--------------------|--------i\\n\\n\\n         |--M---| <- maxM  at i-L position \\n                    |---L----| \\n--------------------|--------i\\n    */\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n     if (A==null || A.length < L+M) return 0;   \\n     int []sum = new int[A.length];\\n    \\n     // leetcode 53, Maximum Subarray (Kadane\\'s Algorithm) \\n     sum[0]=A[0];    \\n     for(int i=1; i< A.length;i++){\\n        sum[i] = Math.max(A[i],sum[i-1] + A[i]);  \\n     }\\n\\n     int maxL = sum[L-1]; // initial value\\n     int maxM = sum[M-1]; // initial value\\n     int res = sum[L+M-1];  // initial value\\n     for(int i=L+M; i < sum.length; i++){\\n        maxL = Math.max(maxL, sum[i-M]-sum[i-M-L]); // maxL at i-M position\\n        maxM = Math.max(maxM, sum[i-L]-sum[i-M-L]); //maxM at i-L position  \\n        res = Math.max(res, Math.max(maxL + sum[i] - sum[i-M],\\n                                     maxM + sum[i] - sum[i-L]));\\n     }   \\n     return res;   \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2079844,
                "title": "c-single-pass-o-n-constant-memory-o-1-sliding-window-easy-to-understand-solution",
                "content": "I read a bunch of solutions here and came up with this idea. It\\'s easy to understand. Have to say though that this was a tough nut to crack :) Kudos to people who figured this out on their own.\\n\\nThe basic idea is that the solution to a given input can be either of the following two case:\\n1. The first length subarray could be on the left side and the second length subarray on the right side.\\n\\n......|firstLength|....|secondLength|....\\n\\n2. The first length subarray could be on the right side and the second length subarray on the left side.\\n\\n.....|secondLength|....|firstLength|....\\n\\nWe have to check both of these cases as the answer could be one of these. To check either of these cases, what we can do is to slide the two windows together. Suppose L1 is the firstLength window on the left and M1 is the secondLength window on the right.\\n\\nThen it is possible to find the max L1 + M1  subarrays in linear time. We just have to keep track of the maximum window to the left and every time we update the right most window, we just have to add the M1 subarray to the max L1 window we have seen so far.\\n\\nNow, checking both the cases. First case where first length subarray is on the left and the second length subarray is on the right as well as the second case where first length subarray is on the right and second length subarray is on the left, can be done simultaneously. Meaning the whole problem can be solved in linear time.\\n\\nCode:\\n```\\nint maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        int L1 = 0, M1 = 0, M2 = 0, L2 = 0;        \\n        int n = nums.size();\\n\\n       // This is our initial setup.\\n      // |firstLen||secondLen|...................|secondLen||firstLen|\\n\\n\\t\\t// Add up the left most window first.\\n       // |firstLen|.................................\\n        for(int i = 0; i < firstLen; i++) {\\n            L1 += nums[i];\\n        }\\n        // Next we add up the first right window.\\n\\t\\t// .......|secondLen|......................\\n        for(int i = firstLen; i < firstLen + secondLen; i++) {\\n            M1 += nums[i];\\n        }\\n        \\n\\t\\t// Next we add up the right most window.\\n\\t\\t//........................................|firstLen|\\n        for(int i = n - firstLen; i < n; i++) {\\n            L2 += nums[i];\\n        }\\n        \\n\\t\\t// Finally, we add up the second right window. \\n\\t\\t// ............................|secondLen|..............\\n        for(int i = n - firstLen - secondLen; i < n - firstLen; i++) {\\n            M2 += nums[i];\\n        }\\n        \\n        int lmax = L1, rmax = L2, res = max(L1 + M1, L2 + M2);\\n        for(int i = firstLen + secondLen; i < n; i++) {\\n\\t\\t   // we have moved one element to the right.\\n\\t\\t   // |oldElement||firstLen||secondLen||nextElement|.............................\\n\\t\\t   // we have to update our slidding windows accordingly.\\n           // Each of these windows need to add an element to the right and remove an element from the left.\\n            L1 += nums[i - secondLen] - nums[i - secondLen - firstLen];\\n            M1 += nums[i] - nums[i - secondLen];\\n            \\n            \\n            lmax = max(L1, lmax);\\n            res = max(res, lmax + M1);\\n            \\n\\t\\t\\t// As we have moved one element to the right, we can use the same i to say that our second case has also moved one element to the left.\\n\\t\\t\\t// ...................|nextElement||secondLen||firstLen||oldElement|\\t\\t\\t\\n\\t\\t   // we have to update our slidding windows accordingly.\\n\\t\\t   // Each of these windows need to add an element to the left and remove an element from the right.\\n            L2 += nums[n - i - 1 + secondLen] - nums[n - i + firstLen + secondLen - 1];\\n            M2 += nums[n - i - 1] - nums[n - i + secondLen - 1];\\n            \\n            rmax = max(L2, rmax);\\n            res = max(res, rmax + M2);\\n        }\\n        return res;  \\n    }\\n```\\n\\nThat\\'s it. Simple solution :) Wish I could take credit for it.",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nint maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        int L1 = 0, M1 = 0, M2 = 0, L2 = 0;        \\n        int n = nums.size();\\n\\n       // This is our initial setup.\\n      // |firstLen||secondLen|...................|secondLen||firstLen|\\n\\n\\t\\t// Add up the left most window first.\\n       // |firstLen|.................................\\n        for(int i = 0; i < firstLen; i++) {\\n            L1 += nums[i];\\n        }\\n        // Next we add up the first right window.\\n\\t\\t// .......|secondLen|......................\\n        for(int i = firstLen; i < firstLen + secondLen; i++) {\\n            M1 += nums[i];\\n        }\\n        \\n\\t\\t// Next we add up the right most window.\\n\\t\\t//........................................|firstLen|\\n        for(int i = n - firstLen; i < n; i++) {\\n            L2 += nums[i];\\n        }\\n        \\n\\t\\t// Finally, we add up the second right window. \\n\\t\\t// ............................|secondLen|..............\\n        for(int i = n - firstLen - secondLen; i < n - firstLen; i++) {\\n            M2 += nums[i];\\n        }\\n        \\n        int lmax = L1, rmax = L2, res = max(L1 + M1, L2 + M2);\\n        for(int i = firstLen + secondLen; i < n; i++) {\\n\\t\\t   // we have moved one element to the right.\\n\\t\\t   // |oldElement||firstLen||secondLen||nextElement|.............................\\n\\t\\t   // we have to update our slidding windows accordingly.\\n           // Each of these windows need to add an element to the right and remove an element from the left.\\n            L1 += nums[i - secondLen] - nums[i - secondLen - firstLen];\\n            M1 += nums[i] - nums[i - secondLen];\\n            \\n            \\n            lmax = max(L1, lmax);\\n            res = max(res, lmax + M1);\\n            \\n\\t\\t\\t// As we have moved one element to the right, we can use the same i to say that our second case has also moved one element to the left.\\n\\t\\t\\t// ...................|nextElement||secondLen||firstLen||oldElement|\\t\\t\\t\\n\\t\\t   // we have to update our slidding windows accordingly.\\n\\t\\t   // Each of these windows need to add an element to the left and remove an element from the right.\\n            L2 += nums[n - i - 1 + secondLen] - nums[n - i + firstLen + secondLen - 1];\\n            M2 += nums[n - i - 1] - nums[n - i + secondLen - 1];\\n            \\n            rmax = max(L2, rmax);\\n            res = max(res, rmax + M2);\\n        }\\n        return res;  \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 402171,
                "title": "c-0ms-o-n-solution-for-1031-maximum-sum-of-two-non-overlapping-subarrays",
                "content": "This is a nice problem but it is nicer when we try to do it in O(n). \\n\\nIt can be confusing to some who are trying to achieve O(n). So, I am going to explain my code a bit.\\n\\nWe make sure L < M. If not, we swap them. Next, we store the following in the arrays:\\n  \\n  mtms[i] - sum of M window i.e { p[ i - M - 1 ] ... p[ i ] }\\n  ltms[i] - sum of L window i.e { p[ i - L - 1 ] ... p[ i ] }\\n  mtmx[i] - maximum sum of M window seen so far till index i\\n  ltmx[i] - maximum sum of L window seen so far till index i\\n  \\n  \\n For every iteration, in the line:\\n \\n ```\\n mx = max(mx, max(mtms[i] + ltmx[i - M], ltms[i] + mtmx[i - L]));\\n ```\\n \\nwe simply compute the max of:\\n\\n  * sum of current M window + max sum of L window seen before start of M window\\n  * sum of current L window + max sum of M window seen before start of L window\\n\\nand store that in mx. The max mx becomes the answer. \\n\\nNote that we could make the arrays smaller i.e to size M+1 and use modulo - making space complexity O(M+1).\\n\\nAs an example, let\\'s take the test case:\\n\\n```\\n[2,1,5,6,0,9,5,0,3,8]\\n4\\n3\\n```\\n\\nand uncomment the cout in the code. We will see the columns i, mtms[i], ltms[i], mtmx[i] and ltmx[i] printed as follows:\\n\\n```\\n0  0  0  0  0\\n1  0  0  0  0\\n2  0  8  0  8\\n3 14 12 14 12\\n4 12 11 14 12\\n5 20 15 20 15x\\n6 20 14 20y15\\n7 14 14 20 15\\n8 17  8 20 15\\n9 16x11y20 15\\n```\\n\\nI have marked two pairs - x and y in the cout output. (mtms[9] =) 16 + (ltmx[9-M] =) 15 OR (ltms[9]=) 11 + (mtmx[9-L]=) 20. They are the following two pairs ending at index 9 & 5 and 9 & 6 that yield 31 which is the answer.\\n\\n```\\n[2, 1, 5, 6, 0, 9, 5, 0, 3, 8]\\n          --15---  ----16----\\n            L          M\\n\\n[2, 1, 5, 6, 0, 9, 5, 0, 3, 8]\\n          -20-------  --11---\\n           M            L\\n```\\n\\nHopefully it helps some folks. Rock on!\\n\\n```\\n/* LeetCode: tktripathy */\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& p, int L, int M) {\\n        int sz = p.size(), lt = 0, ltm = 0, mt = 0, mtm = 0, res = 0, mx = 0;\\n        if (L > M) { int t = M; M = L; L = t; }\\n        int mtmx[sz], ltmx[sz], mtms[sz], ltms[sz];\\n        for (int i = 0; i < sz; i++) {\\n            p[i] = p[i] + (i ? p[i - 1] : 0);\\n            if (i >= M - 1) { mt = p[i] - (i < M ? 0 : p[i - M]); mtm = max(mtm, mt); }\\n            if (i >= L - 1) { lt = p[i] - (i < L ? 0 : p[i - L]); ltm = max(ltm, lt); }\\n            mtms[i] = mt; ltms[i] = lt; mtmx[i] = mtm; ltmx[i] = ltm;\\n            // cout << i << \" \" << mt << \" \" << lt << \" \" << mtm << \" \" << ltm << endl;\\n            if (i >= M) {\\n                mx = max(mx, max(mtms[i] + ltmx[i - M], ltms[i] + mtmx[i - L]));\\n            }\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n mx = max(mx, max(mtms[i] + ltmx[i - M], ltms[i] + mtmx[i - L]));\\n ```\n```\\n[2,1,5,6,0,9,5,0,3,8]\\n4\\n3\\n```\n```\\n0  0  0  0  0\\n1  0  0  0  0\\n2  0  8  0  8\\n3 14 12 14 12\\n4 12 11 14 12\\n5 20 15 20 15x\\n6 20 14 20y15\\n7 14 14 20 15\\n8 17  8 20 15\\n9 16x11y20 15\\n```\n```\\n[2, 1, 5, 6, 0, 9, 5, 0, 3, 8]\\n          --15---  ----16----\\n            L          M\\n\\n[2, 1, 5, 6, 0, 9, 5, 0, 3, 8]\\n          -20-------  --11---\\n           M            L\\n```\n```\\n/* LeetCode: tktripathy */\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& p, int L, int M) {\\n        int sz = p.size(), lt = 0, ltm = 0, mt = 0, mtm = 0, res = 0, mx = 0;\\n        if (L > M) { int t = M; M = L; L = t; }\\n        int mtmx[sz], ltmx[sz], mtms[sz], ltms[sz];\\n        for (int i = 0; i < sz; i++) {\\n            p[i] = p[i] + (i ? p[i - 1] : 0);\\n            if (i >= M - 1) { mt = p[i] - (i < M ? 0 : p[i - M]); mtm = max(mtm, mt); }\\n            if (i >= L - 1) { lt = p[i] - (i < L ? 0 : p[i - L]); ltm = max(ltm, lt); }\\n            mtms[i] = mt; ltms[i] = lt; mtmx[i] = mtm; ltmx[i] = ltm;\\n            // cout << i << \" \" << mt << \" \" << lt << \" \" << mtm << \" \" << ltm << endl;\\n            if (i >= M) {\\n                mx = max(mx, max(mtms[i] + ltmx[i - M], ltms[i] + mtmx[i - L]));\\n            }\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 951563,
                "title": "c-easy-implementation-using-prefix-sum",
                "content": "Two Cases :\\n  1.) lMax is the case when L contiguous elements are taken first\\n  2.) mMax is the case when M contiguous elements are taken first\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        int n = A.size();\\n        for(int i = 1; i < n; i++)\\n            A[i] += A[i-1];\\n        int res = A[L+M-1], lMax = A[L-1], mMax = A[M-1];\\n        for(int i = L+M; i < n; i++){\\n            lMax = max(lMax, A[i-M] - A[i - (L+M)]);\\n            mMax = max(mMax, A[i-L] - A[i - (L+M)]);\\n            res = max(res, max(lMax + A[i] - A[i-M], mMax + A[i] - A[i-L]));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        int n = A.size();\\n        for(int i = 1; i < n; i++)\\n            A[i] += A[i-1];\\n        int res = A[L+M-1], lMax = A[L-1], mMax = A[M-1];\\n        for(int i = L+M; i < n; i++){\\n            lMax = max(lMax, A[i-M] - A[i - (L+M)]);\\n            mMax = max(mMax, A[i-L] - A[i - (L+M)]);\\n            res = max(res, max(lMax + A[i] - A[i-M], mMax + A[i] - A[i-L]));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 863374,
                "title": "simple-easy-to-understand-verbose-python-code-with-comments",
                "content": "```\\nclass Solution(object):\\n    def maxSumTwoNoOverlap(self, A, L, M):\\n        \"\"\"\\n        :type A: List[int]\\n        :type L: int\\n        :type M: int\\n        :rtype: int\\n        \"\"\"\\n        nums = A[:] # We don\\'t really need to deepcopy here, we can use A instead of nums.\\n        for i in range(1,len(A)):\\n            nums[i]+=nums[i-1] # nums value at index i is the total sum from beginning to index i\\n        # initializing the variables\\n        lmax, mmax,res = 0,0,0\\n        nums.insert(0,0) # adding a dummy 0 value at the beginning of the list to make boundary coding simpler\\n        # L before M. We keep on moving the M sized window and for each position check the max sum valued L window till now and update the total value for each move\\n        for i in range(L+1, len(nums)-M+1): # check the boundaries by drawing array diag on paper with some example\\n            msum = nums[i+M-1] - nums[i-1]\\n            lmax = max(lmax, nums[i-1]-nums[i-1-L])\\n            res = max(res,msum+lmax)\\n        # M before L. We keep on moving L sized window at each step and calculate the max sum val of M sized windows lying before it.and update the total value for each move\\n        for i in range(M+1, len(nums)-L+1): # check the boundaries by drawing array diag on paper with some example\\n            lsum = nums[i+L-1] - nums[i-1]\\n            mmax = max(mmax, nums[i-1]-nums[i-1-M])\\n            res = max(res,lsum+mmax)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxSumTwoNoOverlap(self, A, L, M):\\n        \"\"\"\\n        :type A: List[int]\\n        :type L: int\\n        :type M: int\\n        :rtype: int\\n        \"\"\"\\n        nums = A[:] # We don\\'t really need to deepcopy here, we can use A instead of nums.\\n        for i in range(1,len(A)):\\n            nums[i]+=nums[i-1] # nums value at index i is the total sum from beginning to index i\\n        # initializing the variables\\n        lmax, mmax,res = 0,0,0\\n        nums.insert(0,0) # adding a dummy 0 value at the beginning of the list to make boundary coding simpler\\n        # L before M. We keep on moving the M sized window and for each position check the max sum valued L window till now and update the total value for each move\\n        for i in range(L+1, len(nums)-M+1): # check the boundaries by drawing array diag on paper with some example\\n            msum = nums[i+M-1] - nums[i-1]\\n            lmax = max(lmax, nums[i-1]-nums[i-1-L])\\n            res = max(res,msum+lmax)\\n        # M before L. We keep on moving L sized window at each step and calculate the max sum val of M sized windows lying before it.and update the total value for each move\\n        for i in range(M+1, len(nums)-L+1): # check the boundaries by drawing array diag on paper with some example\\n            lsum = nums[i+L-1] - nums[i-1]\\n            mmax = max(mmax, nums[i-1]-nums[i-1-M])\\n            res = max(res,lsum+mmax)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 596595,
                "title": "c-o-n-solution-using-prefix-sum",
                "content": "The approach here is based on sliding a window by fixing L sized and M sized subarrays. \\n1. Keep a **prefix sum** array to get the sums in O(1) when answer is calculated. \\n2. Loop from **i = (L + M) to Array.size()**\\n\\t * Fix an **M** sized subarray at index **i - 1**. Find the maximum sized **L** sized subarray before the fixed subarray.\\n\\t * Fix an **L** sized subarray at index **i - 1**. Find the maximum sized **M** sized subarray before the fixed subarray.\\n\\t * Update result with maximum sum of **L** and **M** sized subarray uptil now.\\n```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n\\t\\t// maximum sum of L sized, maximum sum of M sized, maximum of (L sized + M sized) \\n        int lMax, mMax, result;\\n        vector<int> prefixSum(A.size());\\n        \\n\\t\\t// fill the prefix sum array\\n        for(int i = 0; i < A.size(); i++) {\\n            prefixSum[i] = (i == 0) ? A[i] : prefixSum[i - 1] + A[i];\\n        }\\n        \\n        lMax = mMax = result = INT_MIN;\\n        \\n        for(int i = (L + M); i <= A.size(); i++) {\\n\\t\\t\\t// fix M sized subarray, and find maximum sum of L sized subarray uptil now\\n            lMax = (i == (L + M)) ? prefixSum[L - 1] : max(lMax, prefixSum[i - M - 1] - prefixSum[i - L - M - 1]);\\n\\t\\t\\t// fix L sized subarray, and find maximum sum of M sized subarray uptil now\\n            mMax = (i == (L + M)) ? prefixSum[M - 1] : max(mMax, prefixSum[i - L - 1] - prefixSum[i - L - M - 1]);\\n            \\n\\t\\t\\t// update maximum of (L sized + M sized) uptil now\\n            result = max({result, \\n                          prefixSum[i - 1] - prefixSum[i - L - 1] + mMax,\\n                          prefixSum[i - 1] - prefixSum[i - M - 1] + lMax\\n                         });\\n        }\\n        \\n        return result;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n\\t\\t// maximum sum of L sized, maximum sum of M sized, maximum of (L sized + M sized) \\n        int lMax, mMax, result;\\n        vector<int> prefixSum(A.size());\\n        \\n\\t\\t// fill the prefix sum array\\n        for(int i = 0; i < A.size(); i++) {\\n            prefixSum[i] = (i == 0) ? A[i] : prefixSum[i - 1] + A[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 736925,
                "title": "clean-python-high-speed-o-n-time-o-1-space",
                "content": "**Clean Python | High Speed | O(n) time, O(1) space**\\n\\n**A) High Speed Version: O(n) time, O(1) space**\\n\\nThis Solution is based on the auxiliary function \"Trail\", which simulates two sliding windows (a,b) running one after the other. The best sum (for the configuration considered) is found in O(n) time and O(1) space by remembering the best result for the sliding window \"A\", and adding this to the current result for the sliding window \"b\".\\n\\nThe global answer is the maximum value after considering the configurations Trail(L,M) and Trail(M,L).\\n\\n```\\nclass Solution:\\n    def trail(self,A,a,b):\\n        sa = ba = sum(A[:a]) # sum from beggining\\n        sb = sum(A[a:b+a])   # sum right after \"sa\"\\n        best = ba+sb\\n        for i in range(b+a,len(A)):\\n            sb += A[i]  - A[i-b]\\n            sa += A[i-b]- A[i-b-a]\\n            ba = max( ba, sa ) # window sum of sb runs with best from \"sa\"\\n            if ba+sb > best:\\n                best = ba+sb\\n        return best\\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n        trail = self.trail\\n        return max( trail(A,L,M) , trail(A,M,L) )\\n```\\n\\n**B) Modularized Code: O(n) time/space**\\n\\nThis is an early attempt that I made for this problem. It assumes that the array is split in two pieces, and we wish to find the best sums for siliding windows of sizes \"a\" and \"b\" at each side. This process uses 4 auxiliar arrays, but it manages to run in linear time :). The sizes of the sliding windows (a,b) are flipped as before between (L,M) and (M,L).\\n\\nDespite the extra space usage, it achieves a High Speed rating on LeetCode. It also includes a nice Poem to understand the indexing. I hope the code is helpful. Cheers,\\n```\\ndef winsum(A,k):\\n    s   = sum(A[:k])\\n    arr = [s]\\n    for i in range(k,len(A)):\\n        s += A[i] - A[i-k]\\n        arr.append(s)\\n    return arr\\n#\\ndef maxleft(arr):\\n    best = [arr[0]]\\n    for x in arr[1:]:\\n        best.append( max(x,best[-1]) )\\n    return best\\n#\\ndef maxright(arr):\\n    return maxleft(arr[::-1])[::-1]\\n#\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n        # \\n        aL= winsum(A,L)\\n        aM= winsum(A,M)\\n        #\\n        best = 0\\n        #\\n        arr1,a = aL,L\\n        arr2,b = aM,M\\n        #\\n        for _ in range(2):\\n            best1,best2 = maxleft(arr1),maxright(arr2)\\n            for i,s1 in enumerate(best1):\\n                # ******** Poem ********\\n                # The first sums at all are [0,a-1], and [0,b-1]\\n                # To get stated with sum = [0,a-1], we would need a second sum [a,a+b-1]\\n                # for the current sum [i,i+a-1], we would need [i+a,i+a+b-1]\\n                # so we need arr2[i+a]\\n                if i+a < len(best2):\\n                    s2 = best2[ i + a ]\\n                    if s1+s2 > best:\\n                        best = s1+s2\\n                else:\\n                    break\\n            # Now flip order\\n            arr1, arr2 = arr2, arr1\\n            a   , b    = b   , a\\n        return best\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def trail(self,A,a,b):\\n        sa = ba = sum(A[:a]) # sum from beggining\\n        sb = sum(A[a:b+a])   # sum right after \"sa\"\\n        best = ba+sb\\n        for i in range(b+a,len(A)):\\n            sb += A[i]  - A[i-b]\\n            sa += A[i-b]- A[i-b-a]\\n            ba = max( ba, sa ) # window sum of sb runs with best from \"sa\"\\n            if ba+sb > best:\\n                best = ba+sb\\n        return best\\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n        trail = self.trail\\n        return max( trail(A,L,M) , trail(A,M,L) )\\n```\n```\\ndef winsum(A,k):\\n    s   = sum(A[:k])\\n    arr = [s]\\n    for i in range(k,len(A)):\\n        s += A[i] - A[i-k]\\n        arr.append(s)\\n    return arr\\n#\\ndef maxleft(arr):\\n    best = [arr[0]]\\n    for x in arr[1:]:\\n        best.append( max(x,best[-1]) )\\n    return best\\n#\\ndef maxright(arr):\\n    return maxleft(arr[::-1])[::-1]\\n#\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n        # \\n        aL= winsum(A,L)\\n        aM= winsum(A,M)\\n        #\\n        best = 0\\n        #\\n        arr1,a = aL,L\\n        arr2,b = aM,M\\n        #\\n        for _ in range(2):\\n            best1,best2 = maxleft(arr1),maxright(arr2)\\n            for i,s1 in enumerate(best1):\\n                # ******** Poem ********\\n                # The first sums at all are [0,a-1], and [0,b-1]\\n                # To get stated with sum = [0,a-1], we would need a second sum [a,a+b-1]\\n                # for the current sum [i,i+a-1], we would need [i+a,i+a+b-1]\\n                # so we need arr2[i+a]\\n                if i+a < len(best2):\\n                    s2 = best2[ i + a ]\\n                    if s1+s2 > best:\\n                        best = s1+s2\\n                else:\\n                    break\\n            # Now flip order\\n            arr1, arr2 = arr2, arr1\\n            a   , b    = b   , a\\n        return best\\n```",
                "codeTag": "Java"
            },
            {
                "id": 426096,
                "title": "python-simple-solution-w-explanation",
                "content": "Simple easy to understand solution based on the hint, but inefficient runtime (very efficient memory usage though, at 12.8MB beating 100% of Python submissions).\\n\\nSliding window implementation.\\nouter loop:  `[|  L  | -->           ]`\\ninner loop: `[|  L  | | M | ->    ]`\\nSum each interval as you slide both through the array.\\nCompare against current max, and update it if needed.\\nThen repeat in the reverse direction.\\n\\n```\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n        def findMaxSum(A: List[int], L: int, M: int) -> int:\\n            max_num = 0\\n            for i in range(len(A)-L):\\n                L_slice = A[i:L+i]\\n                L_sum = sum(L_slice)\\n                for j in range(L+i,len(A)-M+1):\\n                    M_slice = A[j:M+j]\\n                    M_sum = sum(M_slice)\\n                    max_num = max(L_sum + M_sum, max_num)\\n            return max_num\\n        \\n        forwards_sum = findMaxSum(A,L,M)\\n        A.reverse()\\n        backwards_sum = findMaxSum(A,L,M)\\n        return max(forwards_sum,backwards_sum)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n        def findMaxSum(A: List[int], L: int, M: int) -> int:\\n            max_num = 0\\n            for i in range(len(A)-L):\\n                L_slice = A[i:L+i]\\n                L_sum = sum(L_slice)\\n                for j in range(L+i,len(A)-M+1):\\n                    M_slice = A[j:M+j]\\n                    M_sum = sum(M_slice)\\n                    max_num = max(L_sum + M_sum, max_num)\\n            return max_num\\n        \\n        forwards_sum = findMaxSum(A,L,M)\\n        A.reverse()\\n        backwards_sum = findMaxSum(A,L,M)\\n        return max(forwards_sum,backwards_sum)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2019495,
                "title": "python-sol-very-simple-explained-sliding-window",
                "content": "\\n# EXPLANATION\\n```\\nFor every firstLen subarray find the maximum sum secondLen size subarray\\n\\nSay we have arr = [1,2,3,4,5,6,7,8,9,10] firstLen = 3 , secondLen = 4\\n\\nWe took the subarray with firstLen : [5,6,7]\\nNow the secondLen subarray with max sum can be in\\n1. [1,2,3,4]\\n2. [8,9,10]\\n\\n\\n\\n```\\n\\n# CODE\\n```\\nclass Solution:\\n    def getMaxSubarraySum(self,arr,size):\\n        n = len(arr)\\n        if n < size: return 0\\n        best = tmp = sum(arr[:size])\\n        for i in range(1,n-size+1):\\n            tmp = tmp + arr[i+size-1] - arr[i-1]\\n            if tmp > best:best = tmp\\n        return best\\n    def maxSumTwoNoOverlap(self, nums: List[int], firstLen: int, secondLen: int) -> int:\\n        n = len(nums)\\n        summ = sum(nums[:firstLen])\\n        ans = summ  + self.getMaxSubarraySum(nums[firstLen:],secondLen)   \\n        for i in range(1,n-firstLen+1):\\n            summ = summ + nums[i+firstLen-1] - nums[i-1]\\n            a = self.getMaxSubarraySum(nums[:i],secondLen)\\n            b = self.getMaxSubarraySum(nums[i+firstLen:],secondLen)\\n            m = a if a > b else b\\n            if summ + m > ans: ans = summ + m\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nFor every firstLen subarray find the maximum sum secondLen size subarray\\n\\nSay we have arr = [1,2,3,4,5,6,7,8,9,10] firstLen = 3 , secondLen = 4\\n\\nWe took the subarray with firstLen : [5,6,7]\\nNow the secondLen subarray with max sum can be in\\n1. [1,2,3,4]\\n2. [8,9,10]\\n\\n\\n\\n```\n```\\nclass Solution:\\n    def getMaxSubarraySum(self,arr,size):\\n        n = len(arr)\\n        if n < size: return 0\\n        best = tmp = sum(arr[:size])\\n        for i in range(1,n-size+1):\\n            tmp = tmp + arr[i+size-1] - arr[i-1]\\n            if tmp > best:best = tmp\\n        return best\\n    def maxSumTwoNoOverlap(self, nums: List[int], firstLen: int, secondLen: int) -> int:\\n        n = len(nums)\\n        summ = sum(nums[:firstLen])\\n        ans = summ  + self.getMaxSubarraySum(nums[firstLen:],secondLen)   \\n        for i in range(1,n-firstLen+1):\\n            summ = summ + nums[i+firstLen-1] - nums[i-1]\\n            a = self.getMaxSubarraySum(nums[:i],secondLen)\\n            b = self.getMaxSubarraySum(nums[i+firstLen:],secondLen)\\n            m = a if a > b else b\\n            if summ + m > ans: ans = summ + m\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1678961,
                "title": "c-easy-to-understand-dynamic-programming-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int helper(vector<int> &nums,int x,int y)\\n    {\\n        int n=nums.size();\\n        vector<int> dp1(n,0),dp2(n,0);\\n        int sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n           if(i<x)\\n           {\\n               sum+=nums[i];\\n               dp1[i]=sum;\\n           }\\n           else\\n           {\\n               sum+=nums[i]-nums[i-x];\\n               dp1[i]=max(sum,dp1[i-1]);\\n           }\\n        }\\n        sum=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(i+y>=n)\\n            {\\n                sum+=nums[i];\\n                dp2[i]=sum;\\n            }\\n            else\\n            {\\n                 sum+=nums[i]-nums[i+y];\\n                 dp2[i]=max(sum,dp2[i+1]);\\n            }\\n        }\\n        int ans=0;\\n        for(int i=x-1;i<n-y;i++)\\n        {\\n           ans=max(ans,dp1[i]+dp2[i+1]); \\n        }\\n        return ans;\\n    }\\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        return max(helper(nums,firstLen,secondLen),helper(nums,secondLen,firstLen));\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(vector<int> &nums,int x,int y)\\n    {\\n        int n=nums.size();\\n        vector<int> dp1(n,0),dp2(n,0);\\n        int sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n           if(i<x)\\n           {\\n               sum+=nums[i];\\n               dp1[i]=sum;\\n           }\\n           else\\n           {\\n               sum+=nums[i]-nums[i-x];\\n               dp1[i]=max(sum,dp1[i-1]);\\n           }\\n        }\\n        sum=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(i+y>=n)\\n            {\\n                sum+=nums[i];\\n                dp2[i]=sum;\\n            }\\n            else\\n            {\\n                 sum+=nums[i]-nums[i+y];\\n                 dp2[i]=max(sum,dp2[i+1]);\\n            }\\n        }\\n        int ans=0;\\n        for(int i=x-1;i<n-y;i++)\\n        {\\n           ans=max(ans,dp1[i]+dp2[i+1]); \\n        }\\n        return ans;\\n    }\\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        return max(helper(nums,firstLen,secondLen),helper(nums,secondLen,firstLen));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 788895,
                "title": "java-prefix-sum-o-n",
                "content": "prefix sum tc =O(n), sc=O(n)\\n```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] a, int l, int m) {\\n        int n = a.length;\\n        int[] prefix = new int[n];\\n        prefix[0]=a[0];\\n        for(int i =1;i<n;i++) \\n            prefix[i]=a[i]+prefix[i-1];\\n        \\n        return Math.max(maxSum(prefix,l,m),maxSum(prefix,m,l));\\n    }\\n    \\n    private int maxSum(int[] prefix,int l,int m) {\\n        int max_sum=subArraySum(prefix,0,l-1)+subArraySum(prefix,l,l+m-1);\\n        int max_first=subArraySum(prefix,0,l-1);\\n        //[0..l-1][l,l+m-1]\\n        for(int i=l+m-1;i<prefix.length;i++) {\\n            int first = subArraySum(prefix,i-l-m+1,i-m);\\n            max_first = Math.max(max_first,first);\\n\\n            int sum= max_first + subArraySum(prefix,i-m+1,i);\\n            max_sum = Math.max(max_sum,sum);\\n        }\\n        \\n        return max_sum;  \\n    }\\n    \\n    //a[3]+a[4]+a[5]=prefix[5]-prefix[2]\\n    private int subArraySum(int[] prefix,int from, int to) {\\n        if (from ==0) return prefix[to];\\n        else return prefix[to]-prefix[from-1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] a, int l, int m) {\\n        int n = a.length;\\n        int[] prefix = new int[n];\\n        prefix[0]=a[0];\\n        for(int i =1;i<n;i++) \\n            prefix[i]=a[i]+prefix[i-1];\\n        \\n        return Math.max(maxSum(prefix,l,m),maxSum(prefix,m,l));\\n    }\\n    \\n    private int maxSum(int[] prefix,int l,int m) {\\n        int max_sum=subArraySum(prefix,0,l-1)+subArraySum(prefix,l,l+m-1);\\n        int max_first=subArraySum(prefix,0,l-1);\\n        //[0..l-1][l,l+m-1]\\n        for(int i=l+m-1;i<prefix.length;i++) {\\n            int first = subArraySum(prefix,i-l-m+1,i-m);\\n            max_first = Math.max(max_first,first);\\n\\n            int sum= max_first + subArraySum(prefix,i-m+1,i);\\n            max_sum = Math.max(max_sum,sum);\\n        }\\n        \\n        return max_sum;  \\n    }\\n    \\n    //a[3]+a[4]+a[5]=prefix[5]-prefix[2]\\n    private int subArraySum(int[] prefix,int from, int to) {\\n        if (from ==0) return prefix[to];\\n        else return prefix[to]-prefix[from-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 716063,
                "title": "two-solutions-with-full-explanation-optimized-one-after-another",
                "content": "**Solution-1**\\nTime: `O(n^2)`\\nSpace: `O(n)`\\n\\n**Idea:**\\n* This problem includes a \"sum\" and a \"contiguous subarray\", hence, maintain a prefixSum array to quickly get the sum of the numbers of the subarray.\\n* We can define the `lEnd` - indicating the end idx of the subarray of length `L`\\n* and `mStart` - indicating the start idx of the subarray of length `M`\\n* `lEnd` can go from `l-1` to `n-m-1` (both inclusive)\\n* `mStart` can go from `lEnd + 1` to `n-m` (both inclusive)\\n* Calculate the sum of both subarrays for each combination of `lEnd` and `mStart` and return the max result.\\n* At last, let\\'s take into consideration that subarray of length `L` can also be on the right side of `M`. So, we will run our function twice and return the max of both the permutations of `L` and `M`.\\n\\n```\\npublic int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n\\tint n = A.length;\\n\\tint[] prefix = new int[n];\\n\\tint runningSum = 0;\\n\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\trunningSum += A[i];\\n\\t\\tprefix[i] = runningSum;\\n\\t}\\n\\n\\treturn Math.max(helper(A, L, M, prefix), helper(A, M, L, prefix));\\n}\\n\\nprivate int helper(int[] A, int l, int m, int[] prefix) { \\n\\tint n = A.length,\\n\\t\\tans = Integer.MIN_VALUE; \\n\\n\\tfor (int lEnd = l-1; lEnd <= n - m - 1; lEnd++) {\\n\\t\\tfor (int mStart = n-m; mStart >= lEnd + 1; mStart--) { \\n\\t\\t\\tint sum1 = lEnd > l-1\\n\\t\\t\\t\\t\\t? prefix[lEnd] - prefix[lEnd - l]\\n\\t\\t\\t\\t\\t: prefix[lEnd],\\n\\n\\t\\t\\t\\tsum2 = prefix[mStart + m - 1] - prefix[mStart - 1];\\n\\n\\t\\t\\tans = Math.max(ans, sum1 + sum2);\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```\\n\\n**Solution-2**\\nTime: `O(n)`\\nSpace: `O(n)`\\n\\n**Idea:**\\n* Treat the problem similar to buy and sell stock 2 times.\\n* Maintain a prefix sum (same as solution-1)\\n* `lMaxTill` - an array where `lMaxTill[i]` indicates max subarray sum of length `L` till index `i`\\n* `mMaxFrom` - an array where `mMaxFrom[j]` indicates max subarray sum of length `M` starting from idx `j`\\n* Iterate over above two arrays to find the maximum result. \\n\\n```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        int n = A.length;\\n        int[] prefix = new int[n];\\n        int runningSum = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            runningSum += A[i];\\n            prefix[i] = runningSum;\\n        }\\n        \\n        return Math.max(helper(A, L, M, prefix), helper(A, M, L, prefix));\\n    }\\n    \\n    private int helper(int[] A, int l, int m, int[] prefix) { \\n        int n = A.length, // 9\\n            ans = Integer.MIN_VALUE; // 13\\n        \\n        int[] lMaxTill = new int[n],\\n            mMaxFrom = new int[n]; // we don\\'t need to initialize these arrays with integer.min_value because the input numbers in the array are \"non-negative\" so, it\\'s okay to let the default values as 0.\\n        \\n        for (int i = l - 1; i < n - m; i++) { // i = 4\\n            lMaxTill[i] = i == l-1\\n                ? prefix[i]\\n                : Math.max(lMaxTill[i-1], prefix[i] - prefix[i - l]);\\n        }\\n        \\n        for (int j = n - m; j >= l; j--) {\\n            mMaxFrom[j] = j == n-m\\n                ? prefix[j+m-1] - prefix[j-1]\\n                : Math.max(mMaxFrom[j+1], prefix[j+m-1] - prefix[j-1]); \\n        }\\n        \\n        for (int i = 0; i < n-1; i++) {\\n            ans = Math.max(ans, lMaxTill[i] + mMaxFrom[i+1]);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n\\tint n = A.length;\\n\\tint[] prefix = new int[n];\\n\\tint runningSum = 0;\\n\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\trunningSum += A[i];\\n\\t\\tprefix[i] = runningSum;\\n\\t}\\n\\n\\treturn Math.max(helper(A, L, M, prefix), helper(A, M, L, prefix));\\n}\\n\\nprivate int helper(int[] A, int l, int m, int[] prefix) { \\n\\tint n = A.length,\\n\\t\\tans = Integer.MIN_VALUE; \\n\\n\\tfor (int lEnd = l-1; lEnd <= n - m - 1; lEnd++) {\\n\\t\\tfor (int mStart = n-m; mStart >= lEnd + 1; mStart--) { \\n\\t\\t\\tint sum1 = lEnd > l-1\\n\\t\\t\\t\\t\\t? prefix[lEnd] - prefix[lEnd - l]\\n\\t\\t\\t\\t\\t: prefix[lEnd],\\n\\n\\t\\t\\t\\tsum2 = prefix[mStart + m - 1] - prefix[mStart - 1];\\n\\n\\t\\t\\tans = Math.max(ans, sum1 + sum2);\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```\n```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        int n = A.length;\\n        int[] prefix = new int[n];\\n        int runningSum = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            runningSum += A[i];\\n            prefix[i] = runningSum;\\n        }\\n        \\n        return Math.max(helper(A, L, M, prefix), helper(A, M, L, prefix));\\n    }\\n    \\n    private int helper(int[] A, int l, int m, int[] prefix) { \\n        int n = A.length, // 9\\n            ans = Integer.MIN_VALUE; // 13\\n        \\n        int[] lMaxTill = new int[n],\\n            mMaxFrom = new int[n]; // we don\\'t need to initialize these arrays with integer.min_value because the input numbers in the array are \"non-negative\" so, it\\'s okay to let the default values as 0.\\n        \\n        for (int i = l - 1; i < n - m; i++) { // i = 4\\n            lMaxTill[i] = i == l-1\\n                ? prefix[i]\\n                : Math.max(lMaxTill[i-1], prefix[i] - prefix[i - l]);\\n        }\\n        \\n        for (int j = n - m; j >= l; j--) {\\n            mMaxFrom[j] = j == n-m\\n                ? prefix[j+m-1] - prefix[j-1]\\n                : Math.max(mMaxFrom[j+1], prefix[j+m-1] - prefix[j-1]); \\n        }\\n        \\n        for (int i = 0; i < n-1; i++) {\\n            ans = Math.max(ans, lMaxTill[i] + mMaxFrom[i+1]);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 278862,
                "title": "easy-python-o-n",
                "content": "```\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n        def solve(l,m):\\n            left = p = sum(A[:l]) \\n            c = sum(A[l:l+m])\\n            ans = left + c\\n            for i in range(l, len(A) - m):\\n                p += A[i] - A[i-l]\\n                c += A[i+m] - A[i]\\n                left = max(left, p)\\n                ans = max(c + left, ans) \\n            return ans \\n        return max(solve(L,M), solve(M, L))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n        def solve(l,m):\\n            left = p = sum(A[:l]) \\n            c = sum(A[l:l+m])\\n            ans = left + c\\n            for i in range(l, len(A) - m):\\n                p += A[i] - A[i-l]\\n                c += A[i+m] - A[i]\\n                left = max(left, p)\\n                ans = max(c + left, ans) \\n            return ans \\n        return max(solve(L,M), solve(M, L))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649604,
                "title": "python-3-7-lines-sliding-ptrs-t-m-83-56",
                "content": "```\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, nums: List[int], firstLen: int, secondLen: int) -> int:\\n\\n        nums = list(accumulate(nums, initial = 0))\\n        mx1 = mx2 = mx3 = 0\\n        \\n        for sm0,sm1,sm2,sm3 in zip(nums, \\n                                   nums[firstLen:],\\n                                   nums[secondLen:],\\n                                   nums[firstLen+secondLen:]):\\n\\n            mx1 = max(mx1, sm1 - sm0)\\n            mx2 = max(mx2, sm2 - sm0)\\n            mx3 = max(mx3, max(mx1 + sm3-sm1, mx2 + sm3-sm2))\\n            \\n        return mx3\\n```\\n[https://leetcode.com/problems/maximum-sum-of-two-non-overlapping-subarrays/submissions/973518314/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*N*), in which *N* ~`len(nums)`.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, nums: List[int], firstLen: int, secondLen: int) -> int:\\n\\n        nums = list(accumulate(nums, initial = 0))\\n        mx1 = mx2 = mx3 = 0\\n        \\n        for sm0,sm1,sm2,sm3 in zip(nums, \\n                                   nums[firstLen:],\\n                                   nums[secondLen:],\\n                                   nums[firstLen+secondLen:]):\\n\\n            mx1 = max(mx1, sm1 - sm0)\\n            mx2 = max(mx2, sm2 - sm0)\\n            mx3 = max(mx3, max(mx1 + sm3-sm1, mx2 + sm3-sm2))\\n            \\n        return mx3\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2576216,
                "title": "java-sliding-window-prefix-sum-with-explanation",
                "content": "```\\n/*\\n1) Initially we are creating a prefixSum array, storing all the prefix sums\\n2) We stored the initial result as sum of (firstLen+secondLen-1) as it represents the first n+p\\nelements\\n3) After that we are moving the window and at each time we are checking new sum of firstlen and\\nsecondlen and comparing it with the already stored result\\n4) We applied FindMaxSum method twice because first time we are looking for combination where\\nfirst len is element is before second len element and 2nd time for the combinations where\\nsecond len element is before first len element\\n\\n*/\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] nums, int firstLen, int secondLen) {\\n        int[] prefixSums = new int[nums.length];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(i==0)\\n                prefixSums[i] = nums[i];\\n            else\\n                prefixSums[i] = prefixSums[i-1]+nums[i];\\n        }\\n        \\n        int max1 = FindMaxSum(prefixSums, firstLen, secondLen);\\n        int max2 = FindMaxSum(prefixSums, secondLen, firstLen);\\n        \\n        return Math.max(max1, max2);\\n    }\\n    \\n    int FindMaxSum(int[] prefixSums, int firstLen, int secondLen)\\n    {\\n        int globalMax = prefixSums[firstLen+secondLen-1];\\n        int max1 = prefixSums[firstLen-1];\\n        for(int i=0;i<prefixSums.length-firstLen-secondLen;i++)\\n        {\\n            int sum1 = prefixSums[i+firstLen]-prefixSums[i];\\n            int sum2 = prefixSums[i+firstLen+secondLen] - prefixSums[i+firstLen];\\n            max1 = Math.max(max1,sum1);\\n            globalMax = Math.max(globalMax, max1+sum2);\\n        }\\n        return globalMax;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\n/*\\n1) Initially we are creating a prefixSum array, storing all the prefix sums\\n2) We stored the initial result as sum of (firstLen+secondLen-1) as it represents the first n+p\\nelements\\n3) After that we are moving the window and at each time we are checking new sum of firstlen and\\nsecondlen and comparing it with the already stored result\\n4) We applied FindMaxSum method twice because first time we are looking for combination where\\nfirst len is element is before second len element and 2nd time for the combinations where\\nsecond len element is before first len element\\n\\n*/\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] nums, int firstLen, int secondLen) {\\n        int[] prefixSums = new int[nums.length];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(i==0)\\n                prefixSums[i] = nums[i];\\n            else\\n                prefixSums[i] = prefixSums[i-1]+nums[i];\\n        }\\n        \\n        int max1 = FindMaxSum(prefixSums, firstLen, secondLen);\\n        int max2 = FindMaxSum(prefixSums, secondLen, firstLen);\\n        \\n        return Math.max(max1, max2);\\n    }\\n    \\n    int FindMaxSum(int[] prefixSums, int firstLen, int secondLen)\\n    {\\n        int globalMax = prefixSums[firstLen+secondLen-1];\\n        int max1 = prefixSums[firstLen-1];\\n        for(int i=0;i<prefixSums.length-firstLen-secondLen;i++)\\n        {\\n            int sum1 = prefixSums[i+firstLen]-prefixSums[i];\\n            int sum2 = prefixSums[i+firstLen+secondLen] - prefixSums[i+firstLen];\\n            max1 = Math.max(max1,sum1);\\n            globalMax = Math.max(globalMax, max1+sum2);\\n        }\\n        return globalMax;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2135468,
                "title": "c-o-n-suffix-sum-3ms-beats-91",
                "content": "![image](https://assets.leetcode.com/users/images/136c7016-425e-42e7-b95f-a788d21339f2_1654874400.370137.png)\\nWe need to meet 2 conditions :\\n1. **Non-overlapping subarrays**\\n2. **Max Sum**\\n\\n***For condition 1:***\\n\\t\\t\\tWhile traversal subarrays considered are adjacent to each other, so they don\\'t overlap.\\n***For condition 2:***\\n Firstly, there can be **two situations**, firstLen subarray placed before secondLen subarray in the original array, and the opposite i.e. secondLen subarray placed before firstLen subarray. \\n * To deal with this we can simply check maxsum for both cases parallely, and return maximum of the 2 sums.\\n * As the logic remains the same for both the cases, without loss of generality, we can consider either case (let\\'s consider first):\\n\\n\\t\\tWhile traversal we maintain 2 variants, (maxfirstLen) maximum suffix sum of firstLen subarray from the current index  and,\\n\\t\\t(max1) maximum total sum of maxfirstLen and current suffix sum of secondLen subarray (stored in s2).\\n\\t\\t\\n**Explanation:**\\n*This works because for a given element of s2 (which is suffix sum of secondLen subarray from the current index), maximum firstLen subarray sum maximizes the total sum for the current s2. \\nAND while traversing we find the maximum of these total sums with respect to every s2.\\nSimilarly for every element in s1.*\\n\\n**Code:**\\n```\\nint maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        int ret=0, n=nums.size();\\n        //suffix sum upto next firstLen and secondLen elements respectively\\n        vector<int> s1(n-firstLen+1,0), s2(n-secondLen+1,0);\\n        s1[0], s2[0]=0;\\n        for(int j=0; j<firstLen; j++) s1[0]+=nums[j];\\n        for(int i=0; i<n-firstLen; i++){\\n            s1[i+1] = s1[i] - nums[i];\\n            s1[i+1] += nums[i+firstLen];\\n        }//filled suffix sum of firstLen elements from each index\\n        for(int j=0; j<secondLen; j++) s2[0]+=nums[j];\\n        for(int k=0; k<n-secondLen; k++){\\n            s2[k+1] = s2[k] - nums[k];\\n            s2[k+1] += nums[k+secondLen];\\n        }//filled suffix sum of secondLen elements from each index\\n        int max1=0, max2=0, maxfirstLen=0, maxsecondLen=0;\\n        for(int i=0; i<=n - firstLen - secondLen; i++){\\n            maxfirstLen = max(maxfirstLen, s1[i]);//maxsum of firstLen subarray\\n            max1 = max(max1, maxfirstLen + s2[i+firstLen]);//maxsum when firstLen subarray is before secondLen subarray\\n            maxsecondLen = max(maxsecondLen, s2[i]);//maxsum of secondLen subarray\\n            max2 = max(max2, maxsecondLen + s1[i+secondLen]);//maxsum when secondLen subarray is before firstLen subarray\\n        }\\n        return max(max1, max2);\\n}\\n```\\n\\nThanks \\u270C",
                "solutionTags": [],
                "code": "```\\nint maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        int ret=0, n=nums.size();\\n        //suffix sum upto next firstLen and secondLen elements respectively\\n        vector<int> s1(n-firstLen+1,0), s2(n-secondLen+1,0);\\n        s1[0], s2[0]=0;\\n        for(int j=0; j<firstLen; j++) s1[0]+=nums[j];\\n        for(int i=0; i<n-firstLen; i++){\\n            s1[i+1] = s1[i] - nums[i];\\n            s1[i+1] += nums[i+firstLen];\\n        }//filled suffix sum of firstLen elements from each index\\n        for(int j=0; j<secondLen; j++) s2[0]+=nums[j];\\n        for(int k=0; k<n-secondLen; k++){\\n            s2[k+1] = s2[k] - nums[k];\\n            s2[k+1] += nums[k+secondLen];\\n        }//filled suffix sum of secondLen elements from each index\\n        int max1=0, max2=0, maxfirstLen=0, maxsecondLen=0;\\n        for(int i=0; i<=n - firstLen - secondLen; i++){\\n            maxfirstLen = max(maxfirstLen, s1[i]);//maxsum of firstLen subarray\\n            max1 = max(max1, maxfirstLen + s2[i+firstLen]);//maxsum when firstLen subarray is before secondLen subarray\\n            maxsecondLen = max(maxsecondLen, s2[i]);//maxsum of secondLen subarray\\n            max2 = max(max2, maxsecondLen + s1[i+secondLen]);//maxsum when secondLen subarray is before firstLen subarray\\n        }\\n        return max(max1, max2);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1494050,
                "title": "c-solution-with-intuition-and-optimization-0ms-time-whiteboard-and-code",
                "content": "**Intuition :** Since we have to find the maximum sum of 2 non overlapping subarrays why not iteratively divide the array into 2 halfs (left and right) in search of the maximum sum subarray(MSS) of len1 and len2. There can be 2 cases :\\n\\n\\t1. The MSS of length len1 is on the left (0 to i) and  MSS of length len2 is on the right. (i+1 to n-1)\\n\\t2. The MSS of lenght len2 is on the left (0 to i) and MSS of length len1 is on the right. (i+1 to n-1)\\n\\nLets understand this by an example where :\\narr : [0 6 5 2 2 5 1 9 4]     \\nlen1 = 1    \\nlen2 = 2\\n\\n**Case 1 : Find the MSS of size 1 on the left and MSS of size 2 on the right.**\\n\\n![image](https://assets.leetcode.com/users/images/3d5b2ed7-d07b-4b33-8b52-1be09875fefc_1632943857.606115.png)\\n\\n**Case 2 : Find the MSS of size 2 on the left and MSS of size 1 on the right.**\\n\\n![image](https://assets.leetcode.com/users/images/46528a55-2591-4598-835a-d6d3bde5e4f5_1632944018.0631604.png)\\n\\nThe answer is max(Case1 and Case2)\\n\\n**BRUTE FORCE : (Quadratic Time)**\\n\\n![image](https://assets.leetcode.com/users/images/0c7bd99b-3807-45e0-a15c-de7f7b63cc04_1632944213.8682492.png)\\n\\n**OPTIMIZATION : (Linear TIme)**\\n\\n![image](https://assets.leetcode.com/users/images/8f0a5d95-05a0-4c14-af3e-d9d92dde8512_1632944292.354702.png)\\n\\n**Code :**\\n\\n```\\npublic:\\n    int F(vector<int>& arr, int a, int b)\\n    {\\n        int n = arr.size();\\n        vector<int> left(n);\\n        vector<int> right(n);\\n       \\n        // sliding window to populate left array where left[i] stores the max subarray sum of len \\'a\\' from 0 to i\\n       int i = 0, j = 0, sum = 0;\\n       while(a--)\\n            sum += arr[i++];\\n        left[i-1] = sum;\\n        while(i < n)\\n        {\\n            sum -= arr[j++];\\n            sum += arr[i];\\n            left[i] = max(left[i-1], sum);\\n            i++;\\n        }\\n        \\n        // sliding window to populate left array where right[i] stores the max subarray sum of len \\'b\\' from i+1 to n-1.\\n        i = n-1; j = n-1; sum = 0;\\n        while(b--)\\n            sum += arr[i--];\\n        right[i+1] = sum;\\n        while(i >= 0)\\n        {\\n            sum -= arr[j--];\\n            sum += arr[i];\\n            right[i] = max(right[i+1], sum);\\n            i--;\\n        }\\n        \\n        // sum of non overlapping left and right subarrays.\\n        int max_sum = 0;\\n        for(int x = 0; x<n-1; x++)\\n            max_sum = max(max_sum, left[x] + right[x+1]);        \\n        \\n        return max_sum;\\n        \\n    }\\n    int maxSumTwoNoOverlap(vector<int>& arr, int len1, int len2) {\\n        /*\\n            Case 1: max subarray sum of len1 left\\n                    max subarray sum of len2 right\\n                    \\n            Case 2: max subarray sum of len2 left\\n                    max subarray sum of len1 right\\n        */\\n        int case1 = F(arr, len1, len2);\\n        int case2 = F(arr, len2, len1);\\n        return max(case1, case2);\\n    }\\n};\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "Two Pointers",
                    "Dynamic Programming",
                    "Sliding Window"
                ],
                "code": "```\\npublic:\\n    int F(vector<int>& arr, int a, int b)\\n    {\\n        int n = arr.size();\\n        vector<int> left(n);\\n        vector<int> right(n);\\n       \\n        // sliding window to populate left array where left[i] stores the max subarray sum of len \\'a\\' from 0 to i\\n       int i = 0, j = 0, sum = 0;\\n       while(a--)\\n            sum += arr[i++];\\n        left[i-1] = sum;\\n        while(i < n)\\n        {\\n            sum -= arr[j++];\\n            sum += arr[i];\\n            left[i] = max(left[i-1], sum);\\n            i++;\\n        }\\n        \\n        // sliding window to populate left array where right[i] stores the max subarray sum of len \\'b\\' from i+1 to n-1.\\n        i = n-1; j = n-1; sum = 0;\\n        while(b--)\\n            sum += arr[i--];\\n        right[i+1] = sum;\\n        while(i >= 0)\\n        {\\n            sum -= arr[j--];\\n            sum += arr[i];\\n            right[i] = max(right[i+1], sum);\\n            i--;\\n        }\\n        \\n        // sum of non overlapping left and right subarrays.\\n        int max_sum = 0;\\n        for(int x = 0; x<n-1; x++)\\n            max_sum = max(max_sum, left[x] + right[x+1]);        \\n        \\n        return max_sum;\\n        \\n    }\\n    int maxSumTwoNoOverlap(vector<int>& arr, int len1, int len2) {\\n        /*\\n            Case 1: max subarray sum of len1 left\\n                    max subarray sum of len2 right\\n                    \\n            Case 2: max subarray sum of len2 left\\n                    max subarray sum of len1 right\\n        */\\n        int case1 = F(arr, len1, len2);\\n        int case2 = F(arr, len2, len1);\\n        return max(case1, case2);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1433466,
                "title": "c-o-n-100-faster-prefixes-with-comments-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& nums, int f, int s) {\\n        int n =nums.size();\\n        vector<int> pre(n),pre1(n,0),pre2(n,0);\\n        \\n        //prefix sum\\n        pre[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            pre[i]=pre[i-1]+nums[i];\\n        }\\n        \\n        //pre1[i] = maximum contiguous sum of length f until ith index\\n        pre1[f-1]=pre[f-1];\\n        for(int i=f;i<n;i++){\\n            pre1[i]=max(pre1[i-1],pre[i]-pre[i-f]);\\n        }\\n        \\n        //pre2[i] = maximum contiguous sum of length s until ith index\\n        pre2[s-1]=pre[s-1];\\n        for(int i=s;i<n;i++){\\n            pre2[i]=max(pre2[i-1],pre[i]-pre[i-s]);\\n        }\\n        \\n        \\n        int res=INT_MIN;\\n        for(int i=f+s-1;i<n;i++){\\n            //take maximum(contiguous sum of length s ending at i + pre1[i-s] , contiguous sum of length f ending at i + pre1[i-f])\\n            res=max(res,max((pre[i]-pre[i-s])+pre1[i-s],(pre[i]-pre[i-f])+pre2[i-f]));\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& nums, int f, int s) {\\n        int n =nums.size();\\n        vector<int> pre(n),pre1(n,0),pre2(n,0);\\n        \\n        //prefix sum\\n        pre[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            pre[i]=pre[i-1]+nums[i];\\n        }\\n        \\n        //pre1[i] = maximum contiguous sum of length f until ith index\\n        pre1[f-1]=pre[f-1];\\n        for(int i=f;i<n;i++){\\n            pre1[i]=max(pre1[i-1],pre[i]-pre[i-f]);\\n        }\\n        \\n        //pre2[i] = maximum contiguous sum of length s until ith index\\n        pre2[s-1]=pre[s-1];\\n        for(int i=s;i<n;i++){\\n            pre2[i]=max(pre2[i-1],pre[i]-pre[i-s]);\\n        }\\n        \\n        \\n        int res=INT_MIN;\\n        for(int i=f+s-1;i<n;i++){\\n            //take maximum(contiguous sum of length s ending at i + pre1[i-s] , contiguous sum of length f ending at i + pre1[i-f])\\n            res=max(res,max((pre[i]-pre[i-s])+pre1[i-s],(pre[i]-pre[i-f])+pre2[i-f]));\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1104144,
                "title": "java-prefix-sum-dp-0ms-beats-100-t-c-o-a-length-s-c-o-a-length",
                "content": "\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        int omax = Integer.MIN_VALUE, len = A.length, lmax = 0, mmax = 0, sum = 0;\\n\\t\\tint[] prefix = new int[len];\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tsum += A[i];\\n\\t\\t\\tprefix[i] = sum;\\n\\t\\t}\\n\\n\\t\\tlmax = prefix[L - 1];\\n\\t\\tmmax = prefix[M - 1];\\n                \\n\\t\\tomax = prefix[L + M - 1];\\n\\n\\t\\tfor (int i = L + M; i < len; i++) {\\n\\t\\t\\tmmax = Math.max(mmax, prefix[i - L] - prefix[i - L - M]);\\n\\t\\t\\tlmax = Math.max(lmax, prefix[i - M] - prefix[i - M - L]);\\n\\t\\t\\tomax = Math.max(omax, prefix[i] - prefix[i - L] + mmax);\\n\\t\\t\\tomax = Math.max(omax, prefix[i] - prefix[i - M] + lmax);\\n\\t\\t}\\n\\n\\t\\treturn omax;\\n    }\\n",
                "solutionTags": [],
                "code": "\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        int omax = Integer.MIN_VALUE, len = A.length, lmax = 0, mmax = 0, sum = 0;\\n\\t\\tint[] prefix = new int[len];\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tsum += A[i];\\n\\t\\t\\tprefix[i] = sum;\\n\\t\\t}\\n\\n\\t\\tlmax = prefix[L - 1];\\n\\t\\tmmax = prefix[M - 1];\\n                \\n\\t\\tomax = prefix[L + M - 1];\\n\\n\\t\\tfor (int i = L + M; i < len; i++) {\\n\\t\\t\\tmmax = Math.max(mmax, prefix[i - L] - prefix[i - L - M]);\\n\\t\\t\\tlmax = Math.max(lmax, prefix[i - M] - prefix[i - M - L]);\\n\\t\\t\\tomax = Math.max(omax, prefix[i] - prefix[i - L] + mmax);\\n\\t\\t\\tomax = Math.max(omax, prefix[i] - prefix[i - M] + lmax);\\n\\t\\t}\\n\\n\\t\\treturn omax;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 923574,
                "title": "python-4-simple-steps-using-presum-arrays",
                "content": "```python\\ndef maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n\\n\\t# 1. Build a presum array from A to find the sum of a range in O(1) time\\n\\tA = [0] + A + [0]\\n\\tfor i in range(1, len(A)):\\n\\t\\tA[i] += A[i-1]\\n\\n\\t# 2. For each index i, record the largest array of size L or M that is to the LEFT of index i (NOT including i)\\n\\tl_left = [0]\\n\\tm_left = [0]\\n\\tfor i in range(1, len(A)):\\n\\t\\tl_left.append(max(l_left[-1], A[i] - A[i-L]) if i >= L else 0)\\n\\t\\tm_left.append(max(m_left[-1], A[i] - A[i-M]) if i >= M else 0)\\n\\n\\t# 3. For each index i, record the largest array of size L or M that is to the RIGHT of index i (including i)\\n\\tl_right = [0]*len(A)\\n\\tm_right = [0]*len(A)\\n\\tfor i in range(len(A) - 2, -1, -1):\\n\\t\\tl_right[i] = max(l_right[i+1], A[i+L] - A[i] if i + L < len(A) else 0)\\n\\t\\tm_right[i] = max(m_right[i+1], A[i+M] - A[i] if i + M < len(A) else 0)\\n\\n\\t# 4. Return the largest combination of (l_left[i] and m_right[i]) OR (l_right[i] and m_left[i])\\n\\treturn max(max(l_left[i] + m_right[i], l_right[i] + m_left[i]) for i in range(1, len(A) - 1))\\n```",
                "solutionTags": [],
                "code": "```python\\ndef maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n\\n\\t# 1. Build a presum array from A to find the sum of a range in O(1) time\\n\\tA = [0] + A + [0]\\n\\tfor i in range(1, len(A)):\\n\\t\\tA[i] += A[i-1]\\n\\n\\t# 2. For each index i, record the largest array of size L or M that is to the LEFT of index i (NOT including i)\\n\\tl_left = [0]\\n\\tm_left = [0]\\n\\tfor i in range(1, len(A)):\\n\\t\\tl_left.append(max(l_left[-1], A[i] - A[i-L]) if i >= L else 0)\\n\\t\\tm_left.append(max(m_left[-1], A[i] - A[i-M]) if i >= M else 0)\\n\\n\\t# 3. For each index i, record the largest array of size L or M that is to the RIGHT of index i (including i)\\n\\tl_right = [0]*len(A)\\n\\tm_right = [0]*len(A)\\n\\tfor i in range(len(A) - 2, -1, -1):\\n\\t\\tl_right[i] = max(l_right[i+1], A[i+L] - A[i] if i + L < len(A) else 0)\\n\\t\\tm_right[i] = max(m_right[i+1], A[i+M] - A[i] if i + M < len(A) else 0)\\n\\n\\t# 4. Return the largest combination of (l_left[i] and m_right[i]) OR (l_right[i] and m_left[i])\\n\\treturn max(max(l_left[i] + m_right[i], l_right[i] + m_left[i]) for i in range(1, len(A) - 1))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 288665,
                "title": "java-running-sum",
                "content": "```java\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        // L .. M ..\\n        // M ... L ...\\n        int[] runningSum = getRunningSum(A);\\n        return Math.max(find(runningSum, L, M), find(runningSum, M, L));\\n    }\\n\\n    private int find(int[] runningSum, int L, int M) {\\n        int ans = runningSum[L + M - 1];\\n        int maxL = runningSum[L - 1];\\n        for (int i = L + M; i < runningSum.length; i++) {\\n            maxL = Math.max(maxL, runningSum[i - M] - runningSum[i - M - L]);\\n            int sumM = runningSum[i] - runningSum[i - M];\\n            ans = Math.max(ans, maxL + sumM);\\n        }\\n        return ans;\\n    }\\n\\n    private int[] getRunningSum(int[] arr) {\\n        for (int i = 1; i < arr.length; i++) {\\n            arr[i] += arr[i - 1];\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        // L .. M ..\\n        // M ... L ...\\n        int[] runningSum = getRunningSum(A);\\n        return Math.max(find(runningSum, L, M), find(runningSum, M, L));\\n    }\\n\\n    private int find(int[] runningSum, int L, int M) {\\n        int ans = runningSum[L + M - 1];\\n        int maxL = runningSum[L - 1];\\n        for (int i = L + M; i < runningSum.length; i++) {\\n            maxL = Math.max(maxL, runningSum[i - M] - runningSum[i - M - L]);\\n            int sumM = runningSum[i] - runningSum[i - M];\\n            ans = Math.max(ans, maxL + sumM);\\n        }\\n        return ans;\\n    }\\n\\n    private int[] getRunningSum(int[] arr) {\\n        for (int i = 1; i < arr.length; i++) {\\n            arr[i] += arr[i - 1];\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2634482,
                "title": "easy-pythonic-solution-sliding-window",
                "content": "```\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, nums, firstLen: int, secondLen: int) -> int:\\n        maxSum = 0\\n        i, j = 0, 0\\n        max1, max2 = 0, 0\\n        while i < len(nums) - firstLen + 1:\\n            max1 = sum(nums[i:i + firstLen])\\n            if secondLen <= i:\\n                j = 0\\n                while j + secondLen <= i:\\n                    max2 = sum(nums[j:j + secondLen])\\n                    maxSum = max(maxSum, max1 + max2)\\n                    j += 1\\n\\n            if len(nums) - (i + 1) >= secondLen:\\n                j = 0\\n                while j + i + secondLen <= len(nums):\\n                    max2 = sum(nums[i + j + firstLen:i + j + firstLen + secondLen])\\n                    maxSum = max(maxSum, max1 + max2)\\n                    j += 1\\n            i += 1\\n        return maxSum\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, nums, firstLen: int, secondLen: int) -> int:\\n        maxSum = 0\\n        i, j = 0, 0\\n        max1, max2 = 0, 0\\n        while i < len(nums) - firstLen + 1:\\n            max1 = sum(nums[i:i + firstLen])\\n            if secondLen <= i:\\n                j = 0\\n                while j + secondLen <= i:\\n                    max2 = sum(nums[j:j + secondLen])\\n                    maxSum = max(maxSum, max1 + max2)\\n                    j += 1\\n\\n            if len(nums) - (i + 1) >= secondLen:\\n                j = 0\\n                while j + i + secondLen <= len(nums):\\n                    max2 = sum(nums[i + j + firstLen:i + j + firstLen + secondLen])\\n                    maxSum = max(maxSum, max1 + max2)\\n                    j += 1\\n            i += 1\\n        return maxSum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2480494,
                "title": "c-easy-to-understand-solution",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int helper(vector<int>& nums, int firstLen, int secondLen){\\n        int fi = 0 , fj = 0 , currSum = 0 , ans = 0;\\n        while(fj != firstLen){\\n            currSum+=nums[fj++];\\n        }\\n        fj--;\\n        while(fj != nums.size()-secondLen){\\n            int sum = 0 , si = fj+1 , sj = fj+1 , secSum = 0;\\n            while(sj != nums.size()){\\n                secSum+=nums[sj];\\n                if(sj-si+1 != secondLen) sj++;\\n                else{\\n                    sum = max(secSum , sum);\\n                    secSum-=nums[si++];\\n                    sj++;\\n                }\\n            }\\n            ans = max(ans , (sum+currSum));\\n            currSum-=nums[fi++];\\n            currSum+=nums[++fj];\\n        }\\n        return ans;\\n    }\\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        cout<<helper(nums , firstLen , secondLen)<<\" \"<< helper(nums , secondLen , firstLen)<<endl;\\n        return max(helper(nums , firstLen , secondLen) , helper(nums , secondLen , firstLen));\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n    int helper(vector<int>& nums, int firstLen, int secondLen){\\n        int fi = 0 , fj = 0 , currSum = 0 , ans = 0;\\n        while(fj != firstLen){\\n            currSum+=nums[fj++];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1894571,
                "title": "java-intuitive-o-n-prefix-max-sliding-window",
                "content": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n      \\n  //Intution - 3 step Solution --> Lengthy But Easy To Get --> Just 3 iterations\\n        \\n  // 1 Find prefix max value array for any given length L (with help of sliding window)\\n  //2 similarly find sufix max value array for the same length. \\n //Max value means at any index i, the maximum sum till now of the subarray of length L\\n   \\n   // 3 After this just iterate over given array and take a sliding window of size M \\n   // For that particular window, chk for prefixMax value in i-1 index \\n   // and sufixMax value in i+1 index.. Now just store your result..\\uD83D\\uDCAF \\n        \\n        int n = A.length;\\n        int[] prefixMax = new int[n];\\n        int i = 0, j = 0, sum = 0;\\n        while(j < n) {  \\n             sum += A[j];\\n             if(j == L -1) {\\n                prefixMax[j] = sum;\\n            }\\n            else if(j > L-1) {\\n                sum = sum - A[i];  //subtracting previous value from sliding window\\n                prefixMax[j] = Math.max(prefixMax[j-1], sum);\\n                i++;\\n            }\\n            j++;\\n        }\\n\\t\\t\\n        int[] sufixMax = new int[n];\\n        j = i = n-1;\\n        sum = 0;\\n        while(j >=0) {  //For sufix max, iterate in reverse direction\\n             sum += A[j];\\n             if(j == n- L) {\\n                sufixMax[j] = sum;\\n            }\\n            else if(j < n-L) {\\n                sum = sum - A[i];\\n                sufixMax[j] = Math.max(sufixMax[j+1], sum);\\n                i--;\\n            }\\n            j--;\\n        }   \\n   \\n       int res = Integer.MIN_VALUE;  //result\\n       i = j = sum = 0;\\n        while(j < n) {\\n            sum += A[j];\\n            if(j == M-1) {\\n                res = Math.max(res, sum + sufixMax[j+1]);\\n            }\\n            else if(j > M-1) {\\n                sum = sum - A[i];\\n                int op1 = sum + prefixMax[i];\\n                int op2 = sum + (j != n-1 ? sufixMax[j+1] : 0);\\n                res = Math.max(res, Math.max(op1, op2));\\n                i++;\\n            }\\n               j++;\\n        }\\n    \\n               return res;   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n      \\n  //Intution - 3 step Solution --> Lengthy But Easy To Get --> Just 3 iterations\\n        \\n  // 1 Find prefix max value array for any given length L (with help of sliding window)\\n  //2 similarly find sufix max value array for the same length. \\n //Max value means at any index i, the maximum sum till now of the subarray of length L\\n   \\n   // 3 After this just iterate over given array and take a sliding window of size M \\n   // For that particular window, chk for prefixMax value in i-1 index \\n   // and sufixMax value in i+1 index.. Now just store your result..\\uD83D\\uDCAF \\n        \\n        int n = A.length;\\n        int[] prefixMax = new int[n];\\n        int i = 0, j = 0, sum = 0;\\n        while(j < n) {  \\n             sum += A[j];\\n             if(j == L -1) {\\n                prefixMax[j] = sum;\\n            }\\n            else if(j > L-1) {\\n                sum = sum - A[i];  //subtracting previous value from sliding window\\n                prefixMax[j] = Math.max(prefixMax[j-1], sum);\\n                i++;\\n            }\\n            j++;\\n        }\\n\\t\\t\\n        int[] sufixMax = new int[n];\\n        j = i = n-1;\\n        sum = 0;\\n        while(j >=0) {  //For sufix max, iterate in reverse direction\\n             sum += A[j];\\n             if(j == n- L) {\\n                sufixMax[j] = sum;\\n            }\\n            else if(j < n-L) {\\n                sum = sum - A[i];\\n                sufixMax[j] = Math.max(sufixMax[j+1], sum);\\n                i--;\\n            }\\n            j--;\\n        }   \\n   \\n       int res = Integer.MIN_VALUE;  //result\\n       i = j = sum = 0;\\n        while(j < n) {\\n            sum += A[j];\\n            if(j == M-1) {\\n                res = Math.max(res, sum + sufixMax[j+1]);\\n            }\\n            else if(j > M-1) {\\n                sum = sum - A[i];\\n                int op1 = sum + prefixMax[i];\\n                int op2 = sum + (j != n-1 ? sufixMax[j+1] : 0);\\n                res = Math.max(res, Math.max(op1, op2));\\n                i++;\\n            }\\n               j++;\\n        }\\n    \\n               return res;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1867188,
                "title": "2-o-n",
                "content": "<pre><code>class Solution {\\npublic:\\n    int helper(vector<int>&nums,int x,int y){\\n        int n=nums.size();\\n        \\n        vector<int>dp1(n,-1),dp2(n,-1);\\n        \\n        int sum=0;\\n        \\n        for(int i=0;i<n;i++){\\n            if(i<x){\\n                sum+=nums[i];\\n                dp1[i]=sum;\\n            }\\n            else{\\n                sum+=nums[i]-nums[i-x];\\n                dp1[i]=max(dp1[i-1],sum);\\n            }\\n        }\\n        \\n        sum=0;\\n        \\n        for(int i=n-1;i>=0;i--){\\n            if(i+y>=n){\\n                sum+=nums[i];\\n                dp2[i]=sum;\\n            }\\n            else{\\n                sum+=nums[i]-nums[i+y];\\n                dp2[i]=max(dp2[i+1],sum);\\n            }\\n        }\\n        \\n        int ans=0;\\n        \\n        for(int i=x;i+y<n;i++){\\n            ans=max(ans,dp1[i]+dp2[i+1]);\\n        }\\n        return ans;\\n        \\n    }\\n    int maxSumTwoNoOverlap(vector<int>& nums, int x, int y) {\\n        \\n       return max(helper(nums,x,y),helper(nums,y,x));\\n    }\\n};</code></pre>",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int helper(vector<int>&nums,int x,int y){\\n        int n=nums.size();\\n        \\n        vector<int>dp1(n,-1),dp2(n,-1);\\n        \\n        int sum=0;\\n        \\n        for(int i=0;i<n;i++){\\n            if(i<x){\\n                sum+=nums[i];\\n                dp1[i]=sum;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1827427,
                "title": "c-solution-clean-code-intutions-explained",
                "content": "\\n  \\n            \\n            \\n\\t\\t\\t// Intutition :-\\n        //We will use 2 array for storing the f-length window sum for left to right\\n            // for firstlen\\n\\t\\t\\t// for secondlen we will store the sum of window size s from right to left\\n            // while storing check for max sum previously occured \\n            \\n            // for firstlen  dp1[i]=max(dp1[i-1],currsum);\\n            // for second len dp2[i]=max(dp2[i+1],currsum);\\n            \\n            // finally we will iterate from f-1 to n-s-1 ans =max(ans , dp1[i]+dp2[i+1]);\\n        int func(vector<int>& nums, int f, int s)\\n        {\\n                  int n=nums.size();\\n            \\n            vector<int> dp1(n,0),dp2(n,0);\\n            int currsum=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                    if(i<f)\\n                    {\\n                            currsum+=nums[i];\\n                            dp1[i]=currsum;\\n                    }\\n                    else\\n                    {\\n                            currsum=currsum-nums[i-f]+nums[i];\\n                            dp1[i]=max(dp1[i-1],currsum);\\n                    }\\n            }\\n            currsum=0;\\n            for(int i=n-1;i>=0;i--)\\n            {\\n                    if(i+s>n-1)\\n                    {\\n                            currsum+=nums[i];\\n                            dp2[i]=currsum;\\n                    }\\n                    else\\n                    {\\n                            currsum=currsum-nums[i+s]+nums[i];\\n                            dp2[i]=max(dp2[i+1],currsum);\\n                    }\\n            }\\n            \\n            int ans=0;\\n            for(int i=f-1;i<n-s;i++)\\n            {\\n                    ans=max(ans , dp1[i]+dp2[i+1]);\\n            }\\n            return ans;\\n        }\\n    int maxSumTwoNoOverlap(vector<int>& nums, int f, int s) {\\n           \\n        return max(func(nums , f,s),func(nums , s,f));\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "\\n  \\n            \\n            \\n\\t\\t\\t// Intutition :-\\n        //We will use 2 array for storing the f-length window sum for left to right\\n            // for firstlen\\n\\t\\t\\t// for secondlen we will store the sum of window size s from right to left\\n            // while storing check for max sum previously occured \\n            \\n            // for firstlen  dp1[i]=max(dp1[i-1],currsum);\\n            // for second len dp2[i]=max(dp2[i+1],currsum);\\n            \\n            // finally we will iterate from f-1 to n-s-1 ans =max(ans , dp1[i]+dp2[i+1]);\\n        int func(vector<int>& nums, int f, int s)\\n        {\\n                  int n=nums.size();\\n            \\n            vector<int> dp1(n,0),dp2(n,0);\\n            int currsum=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                    if(i<f)\\n                    {\\n                            currsum+=nums[i];\\n                            dp1[i]=currsum;\\n                    }\\n                    else\\n                    {\\n                            currsum=currsum-nums[i-f]+nums[i];\\n                            dp1[i]=max(dp1[i-1],currsum);\\n                    }\\n            }\\n            currsum=0;\\n            for(int i=n-1;i>=0;i--)\\n            {\\n                    if(i+s>n-1)\\n                    {\\n                            currsum+=nums[i];\\n                            dp2[i]=currsum;\\n                    }\\n                    else\\n                    {\\n                            currsum=currsum-nums[i+s]+nums[i];\\n                            dp2[i]=max(dp2[i+1],currsum);\\n                    }\\n            }\\n            \\n            int ans=0;\\n            for(int i=f-1;i<n-s;i++)\\n            {\\n                    ans=max(ans , dp1[i]+dp2[i+1]);\\n            }\\n            return ans;\\n        }\\n    int maxSumTwoNoOverlap(vector<int>& nums, int f, int s) {\\n           \\n        return max(func(nums , f,s),func(nums , s,f));\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1675031,
                "title": "o-n-time-o-1-space-no-modification-of-original-array",
                "content": "Here we have two cases-: \\n1. I am moving secondLen subArray and maintaining max value of firstLen subarray.\\n2. I am moving firstLen subArray and maintaining max value of secondLen subarray.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        int i=0, j = firstLen;\\n        int n = nums.size();\\n        int sum1=0,sum2=0,summax=0,fmax=0,smax=0;\\n        for(; i<n && j<n;) {\\n            if(i< firstLen) {\\n                sum1 += nums[i];\\n                i++;\\n            }\\n            else if(j < firstLen + secondLen) {\\n                sum2 += nums[j];\\n                j++;\\n            }\\n            else {\\n                sum1 -= nums[i-firstLen];\\n                sum1 += nums[i];\\n                sum2 -= nums[j-secondLen];\\n                sum2 += nums[j];\\n                i++; \\n                j++;\\n            }\\n            summax = max(sum1, summax);\\n            fmax = max(summax+sum2, fmax);\\n        }\\n        i=0; j = secondLen;\\n        sum1=0; sum2 =0; summax=0;\\n        for(; i<n && j<n;) {\\n            if(i< secondLen) {\\n                sum1 += nums[i];\\n                i++;\\n            }\\n            else if(j < firstLen + secondLen) {\\n                sum2 += nums[j];\\n                j++;\\n            }\\n            else {\\n                sum1 -= nums[i-secondLen];\\n                sum1 += nums[i];\\n                sum2 -= nums[j-firstLen];\\n                sum2 += nums[j];\\n                i++;\\n                j++;\\n            }\\n            summax = max(sum1, summax);\\n            smax = max(summax+sum2, smax);\\n        }\\n        return fmax> smax ? fmax:smax;\\n    }\\n};\\n```\\n\\nPlease upvote if found useful.",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        int i=0, j = firstLen;\\n        int n = nums.size();\\n        int sum1=0,sum2=0,summax=0,fmax=0,smax=0;\\n        for(; i<n && j<n;) {\\n            if(i< firstLen) {\\n                sum1 += nums[i];\\n                i++;\\n            }\\n            else if(j < firstLen + secondLen) {\\n                sum2 += nums[j];\\n                j++;\\n            }\\n            else {\\n                sum1 -= nums[i-firstLen];\\n                sum1 += nums[i];\\n                sum2 -= nums[j-secondLen];\\n                sum2 += nums[j];\\n                i++; \\n                j++;\\n            }\\n            summax = max(sum1, summax);\\n            fmax = max(summax+sum2, fmax);\\n        }\\n        i=0; j = secondLen;\\n        sum1=0; sum2 =0; summax=0;\\n        for(; i<n && j<n;) {\\n            if(i< secondLen) {\\n                sum1 += nums[i];\\n                i++;\\n            }\\n            else if(j < firstLen + secondLen) {\\n                sum2 += nums[j];\\n                j++;\\n            }\\n            else {\\n                sum1 -= nums[i-secondLen];\\n                sum1 += nums[i];\\n                sum2 -= nums[j-firstLen];\\n                sum2 += nums[j];\\n                i++;\\n                j++;\\n            }\\n            summax = max(sum1, summax);\\n            smax = max(summax+sum2, smax);\\n        }\\n        return fmax> smax ? fmax:smax;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1294583,
                "title": "python-simple-sliding-window-99",
                "content": "```\\nclass Solution:\\n    def trail(self, A, a, b):\\n        # We want to find the largest value of sa, \\n        # and then the corresponding sb that gives largest result\\n        \\n        sa = ba = sum(A[:a]) # sum from beggining\\n        sb = sum(A[a:b+a])   # sum right after \"sa\"\\n        \\n        best = ba+sb\\n        \\n        for i in range(b+a,len(A)):\\n            sa += A[i-b]- A[i-b-a] # Sum of sa\\n            sb += A[i]  - A[i-b] # Sum of sb\\n            \\n            ba = max( ba, sa ) # This will retain the best sa window\\n            \\n            best = max( best, ba+sb) # Next, we just have to find the largest sb with that best sa\\n\\n        return best\\n    \\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n        max_LM_sum = self.trail(A,L,M) # when L is first, followed by M\\n        max_ML_sum = self.trail(A,M,L) # when M is first, followed by L\\n        return max(max_LM_sum, max_ML_sum)\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def trail(self, A, a, b):\\n        # We want to find the largest value of sa, \\n        # and then the corresponding sb that gives largest result\\n        \\n        sa = ba = sum(A[:a]) # sum from beggining\\n        sb = sum(A[a:b+a])   # sum right after \"sa\"\\n        \\n        best = ba+sb\\n        \\n        for i in range(b+a,len(A)):\\n            sa += A[i-b]- A[i-b-a] # Sum of sa\\n            sb += A[i]  - A[i-b] # Sum of sb\\n            \\n            ba = max( ba, sa ) # This will retain the best sa window\\n            \\n            best = max( best, ba+sb) # Next, we just have to find the largest sb with that best sa\\n\\n        return best\\n    \\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n        max_LM_sum = self.trail(A,L,M) # when L is first, followed by M\\n        max_ML_sum = self.trail(A,M,L) # when M is first, followed by L\\n        return max(max_LM_sum, max_ML_sum)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1287923,
                "title": "easy-solution-prefixsum-java",
                "content": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] n, int f, int s) {\\n        int[] p=new int[n.length+1];\\n        for (int i=0;i<n.length;i++){\\n            p[i+1]=p[i]+n[i];\\n        }\\n        return Math.max(maxSum(p,f,s),maxSum(p,s,f));\\n    }\\n    public int maxSum(int[] p,int f,int s){\\n        int ans=0;\\n        int temp=0;\\n        for (int i=f+s; i<p.length;i++){\\n            temp=Math.max(temp, p[i-f]-p[i-f-s]);\\n            ans=Math.max(ans, temp+p[i]-p[i-f]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] n, int f, int s) {\\n        int[] p=new int[n.length+1];\\n        for (int i=0;i<n.length;i++){\\n            p[i+1]=p[i]+n[i];\\n        }\\n        return Math.max(maxSum(p,f,s),maxSum(p,s,f));\\n    }\\n    public int maxSum(int[] p,int f,int s){\\n        int ans=0;\\n        int temp=0;\\n        for (int i=f+s; i<p.length;i++){\\n            temp=Math.max(temp, p[i-f]-p[i-f-s]);\\n            ans=Math.max(ans, temp+p[i]-p[i-f]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1012572,
                "title": "python3-dp-prefix-sum",
                "content": "**Algo**\\nKeep track of max of `M`-sum and `L-sum` so far, and update `ans` with maximum of `M`-sum and current `L`-sum and maximum of `L`-sum and current `M`-sum if larger than existing. \\n\\n**Implementation** \\n```\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n        prefix = [0]\\n        for x in A: prefix.append(prefix[-1] + x) # prefix sum w/ leading 0\\n        ans = lmx = mmx = -inf \\n        for i in range(M+L, len(A)+1): \\n            lmx = max(lmx, prefix[i-M] - prefix[i-L-M])\\n            mmx = max(mmx, prefix[i-L] - prefix[i-L-M])\\n            ans = max(ans, lmx + prefix[i] - prefix[i-M], mmx + prefix[i] - prefix[i-L])\\n        return ans \\n```\\n\\n**Analysis**\\nTime complexity `O(N)`\\nSpace complexity `O(1)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n        prefix = [0]\\n        for x in A: prefix.append(prefix[-1] + x) # prefix sum w/ leading 0\\n        ans = lmx = mmx = -inf \\n        for i in range(M+L, len(A)+1): \\n            lmx = max(lmx, prefix[i-M] - prefix[i-L-M])\\n            mmx = max(mmx, prefix[i-L] - prefix[i-L-M])\\n            ans = max(ans, lmx + prefix[i] - prefix[i-M], mmx + prefix[i] - prefix[i-L])\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 898385,
                "title": "java-sliding-window",
                "content": "```java\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        int len = A.length;\\n        int[][] lss = slideSum(A, L);\\n        int[][] mss = slideSum(A, M);\\n        \\n        int res = 0;\\n        for (int i = 0; i < A.length-L-M+1; i++) {\\n            res = Math.max(res, Math.max(lss[0][i] + mss[1][i+L], mss[0][i] + lss[1][i+M]));\\n        }\\n        \\n        return res;\\n    }\\n    \\n    // slideSum[0][i] is the sliding window sum arr[i] + ... + arr[i+num-1]\\n    // slideSum[1][i] is the max sliding window sum with length of num start from arr[i]\\n    private int[][] slideSum(int[] arr, int num) {\\n        int len = arr.length;\\n        int[][] res = new int[2][len];\\n    \\n        for (int i = len-1; i >= len-num; i--) {\\n            res[0][len-num] += arr[i];\\n            res[1][len-num] += arr[i];\\n        }\\n        \\n        for (int i = len-num-1; i >= 0; i--) {\\n            res[0][i] = res[0][i+1] + arr[i] - arr[i+num];\\n            res[1][i] = Math.max(res[0][i], res[1][i+1]);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```java\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        int len = A.length;\\n        int[][] lss = slideSum(A, L);\\n        int[][] mss = slideSum(A, M);\\n        \\n        int res = 0;\\n        for (int i = 0; i < A.length-L-M+1; i++) {\\n            res = Math.max(res, Math.max(lss[0][i] + mss[1][i+L], mss[0][i] + lss[1][i+M]));\\n        }\\n        \\n        return res;\\n    }\\n    \\n    // slideSum[0][i] is the sliding window sum arr[i] + ... + arr[i+num-1]\\n    // slideSum[1][i] is the max sliding window sum with length of num start from arr[i]\\n    private int[][] slideSum(int[] arr, int num) {\\n        int len = arr.length;\\n        int[][] res = new int[2][len];\\n    \\n        for (int i = len-1; i >= len-num; i--) {\\n            res[0][len-num] += arr[i];\\n            res[1][len-num] += arr[i];\\n        }\\n        \\n        for (int i = len-num-1; i >= 0; i--) {\\n            res[0][i] = res[0][i+1] + arr[i] - arr[i+num];\\n            res[1][i] = Math.max(res[0][i], res[1][i+1]);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 882633,
                "title": "easy-step-by-step-solution-with-whiteboard-pictures-o-n",
                "content": "```\\n/*\\n* Really tricky problem but not too hard once you see the method\\n* here is how I see it lets say you have the following array\\n*       [2 , 1 , 5 , 6 , 0 , 9 , 5 , 0 , 3 , 8] with L = 3 M 2\\n* now lets look for our answer when M comes before L we will need to iterate the array like this\\n*       [2 , 1 , 5 , 6 , 0 , 9 , 5 , 0 , 3 ]\\n*       [   M  ][    L     ]\\n*           [   M   ][     L   ]\\n*               [   M  ][    L   ] \\n*                   [   M  ][    L   ]\\n*                      [   M  ][    L   ] \\n* \\n*   where we keep track of the MMax and at every iteration we sum up the mMax and the current L and keep track of the maxValue\\n*   the reasoning behind this is that since the arrays cant intercept mMax will keep track of greatest value of M before our current L\\n* \\n* once we do it one way we now run the algorithm with M and L reversed \\n* \\n* */\\nfun maxSumTwoNoOverlap(A: IntArray, L: Int, M: Int): Int {\\n    val pfsArr = Array(A.size){0}\\n    /*\\n    * We first create a prefix sum array it helps us find the sum between ranges with just a look up\\n    * */\\n    A.forEachIndexed { i, value ->\\n        if(i == 0) pfsArr[i] = value\\n        else{\\n            pfsArr[i] = pfsArr[i-1]+value\\n        }\\n    }\\n    //we call our getMaxVal twice once with M leading and once with M behind\\n    return Math.max(getMaxVal(pfsArr, M , L), getMaxVal(pfsArr, L, M))\\n\\n}\\n\\nfun getMaxVal(pfsArray: Array<Int>, leftSize:Int, rightSize:Int):Int{\\n    val totalLength = leftSize + rightSize\\n    var maxLeft = 0\\n    var rightVal = 0\\n    var maxVal = 0\\n    for(index in leftSize + rightSize - 1 until pfsArray.size){\\n        //keep track of the maxLeft value \\n        maxLeft = Math.max(maxLeft, getRangePfs(pfsArray, index - (totalLength - 1), index - rightSize))\\n        // our current rightValue \\n        rightVal = getRangePfs(pfsArray, index - (rightSize - 1), index)\\n        maxVal = Math.max(maxVal, maxLeft+rightVal)\\n    }\\n    return maxVal\\n}\\n\\n//Helper function to get the sum between ranges \\nfun getRangePfs(pfsArray: Array<Int>, start: Int, end:Int): Int {\\n    if(start == 0) return pfsArray[end]\\n    return pfsArray[end] - pfsArray[start - 1]\\n}\\n\\n//PS. In an interview draw it out its really easy to mess up indexes but its much easier to figure them our when you can see them\\n```\\n\\n![image](https://assets.leetcode.com/users/images/782b5dbe-b205-425a-8be4-a248fac7bebc_1602026927.4240017.png)\\n",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\n/*\\n* Really tricky problem but not too hard once you see the method\\n* here is how I see it lets say you have the following array\\n*       [2 , 1 , 5 , 6 , 0 , 9 , 5 , 0 , 3 , 8] with L = 3 M 2\\n* now lets look for our answer when M comes before L we will need to iterate the array like this\\n*       [2 , 1 , 5 , 6 , 0 , 9 , 5 , 0 , 3 ]\\n*       [   M  ][    L     ]\\n*           [   M   ][     L   ]\\n*               [   M  ][    L   ] \\n*                   [   M  ][    L   ]\\n*                      [   M  ][    L   ] \\n* \\n*   where we keep track of the MMax and at every iteration we sum up the mMax and the current L and keep track of the maxValue\\n*   the reasoning behind this is that since the arrays cant intercept mMax will keep track of greatest value of M before our current L\\n* \\n* once we do it one way we now run the algorithm with M and L reversed \\n* \\n* */\\nfun maxSumTwoNoOverlap(A: IntArray, L: Int, M: Int): Int {\\n    val pfsArr = Array(A.size){0}\\n    /*\\n    * We first create a prefix sum array it helps us find the sum between ranges with just a look up\\n    * */\\n    A.forEachIndexed { i, value ->\\n        if(i == 0) pfsArr[i] = value\\n        else{\\n            pfsArr[i] = pfsArr[i-1]+value\\n        }\\n    }\\n    //we call our getMaxVal twice once with M leading and once with M behind\\n    return Math.max(getMaxVal(pfsArr, M , L), getMaxVal(pfsArr, L, M))\\n\\n}\\n\\nfun getMaxVal(pfsArray: Array<Int>, leftSize:Int, rightSize:Int):Int{\\n    val totalLength = leftSize + rightSize\\n    var maxLeft = 0\\n    var rightVal = 0\\n    var maxVal = 0\\n    for(index in leftSize + rightSize - 1 until pfsArray.size){\\n        //keep track of the maxLeft value \\n        maxLeft = Math.max(maxLeft, getRangePfs(pfsArray, index - (totalLength - 1), index - rightSize))\\n        // our current rightValue \\n        rightVal = getRangePfs(pfsArray, index - (rightSize - 1), index)\\n        maxVal = Math.max(maxVal, maxLeft+rightVal)\\n    }\\n    return maxVal\\n}\\n\\n//Helper function to get the sum between ranges \\nfun getRangePfs(pfsArray: Array<Int>, start: Int, end:Int): Int {\\n    if(start == 0) return pfsArray[end]\\n    return pfsArray[end] - pfsArray[start - 1]\\n}\\n\\n//PS. In an interview draw it out its really easy to mess up indexes but its much easier to figure them our when you can see them\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 846478,
                "title": "o-n-time-and-space-complexity-prefixsum-explanation",
                "content": "We need 2 subarrays which are non-overlapping with size M and L. \\nLets Suppose the 2 subarrays are **\\'A\\' and \\'B\\'** with window size M and L respectively.\\n\\nThere can only be 2 cases possible **A starts and completes before B** (that is, A = [i, i+M] , B = [j, j+L] where i+M < j )\\nor **A start and end after B** (that is, A = [i, i+M] , B = [j, j+L] where j+L < i ).\\nCalculate prefixSum in both the directions, namely prefixSum and prefixSumReverse. \\n\\n**For Case1.**\\nIn the solution we will only use these 2 facts, first we will consider **A is the subarray with smaller size -> min(M,L)** and **B is the subarray with bigger size -> max(M, L)**. \\n\\nTake i from L+M-1 till size of array. (We took i as L+M-1 so that both B and A subarray can fit in < i. ). B size subarray sum will be  **[i-max(L-1,M-1),i]** and we will add it with the max Sum we have find for **A subarray** before i of size min(M-1, L-1). \\n\\n**Similarly for case 2, loop in opposite direction,**\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        int n = A.size();\\n        vector<int> prefixSum(n, 0);\\n        prefixSum[0] = A[0];\\n        \\n        for(int i=1; i<n; i++) {\\n            prefixSum[i] = prefixSum[i-1] + A[i];\\n        }\\n        \\n        vector<int> prefixSumReverse(n, 0);\\n        prefixSumReverse[n-1] = A[n-1];\\n        for(int i=n-2; i>=0; i--) {\\n            prefixSumReverse[i] = prefixSumReverse[i+1] + A[i];\\n        }\\n        \\n        int maxAns = 0;\\n        \\n        int i = M+L-1;\\n        int j = min(M-1, L-1);\\n        int maxSecond = prefixSum[j];\\n        \\n        for(; i<n; i++) {\\n            maxAns = max(prefixSum[i] - prefixSum[j] + maxSecond, maxAns);\\n            j++;\\n            maxSecond = max(maxSecond, prefixSum[j] - prefixSum[j - min(M, L)]);\\n        }\\n        \\n        i = (n-1) - (M+L-1);\\n        j = (n-1) - min(M-1, L-1);\\n        maxSecond = prefixSumReverse[j];\\n        for(; i>=0; i--) {\\n            maxAns = max(prefixSumReverse[i] - prefixSumReverse[j] + maxSecond, maxAns);\\n            j--;\\n            maxSecond = max(maxSecond, prefixSumReverse[j] - prefixSumReverse[j + min(M, L)]);\\n        }\\n        return maxAns;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        int n = A.size();\\n        vector<int> prefixSum(n, 0);\\n        prefixSum[0] = A[0];\\n        \\n        for(int i=1; i<n; i++) {\\n            prefixSum[i] = prefixSum[i-1] + A[i];\\n        }\\n        \\n        vector<int> prefixSumReverse(n, 0);\\n        prefixSumReverse[n-1] = A[n-1];\\n        for(int i=n-2; i>=0; i--) {\\n            prefixSumReverse[i] = prefixSumReverse[i+1] + A[i];\\n        }\\n        \\n        int maxAns = 0;\\n        \\n        int i = M+L-1;\\n        int j = min(M-1, L-1);\\n        int maxSecond = prefixSum[j];\\n        \\n        for(; i<n; i++) {\\n            maxAns = max(prefixSum[i] - prefixSum[j] + maxSecond, maxAns);\\n            j++;\\n            maxSecond = max(maxSecond, prefixSum[j] - prefixSum[j - min(M, L)]);\\n        }\\n        \\n        i = (n-1) - (M+L-1);\\n        j = (n-1) - min(M-1, L-1);\\n        maxSecond = prefixSumReverse[j];\\n        for(; i>=0; i--) {\\n            maxAns = max(prefixSumReverse[i] - prefixSumReverse[j] + maxSecond, maxAns);\\n            j--;\\n            maxSecond = max(maxSecond, prefixSumReverse[j] - prefixSumReverse[j + min(M, L)]);\\n        }\\n        return maxAns;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 687930,
                "title": "python3-one-pass-o-1-space-o-n-time",
                "content": "```\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n\\t\\t# 1 is the case that L precedes M\\n\\t\\t# 2 is the case that M precedes L\\n        total1L, total1M, total2M, total2L = 0, 0, 0, 0\\n        N = len(A)\\n        total = 0\\n\\t\\t# For initial L + M elements, find the total\\n        for i in range(L + M):\\n            total += A[i]\\n            if i == L - 1:\\n                total1L = total\\n            if i == M - 1:\\n                total2M = total\\n        total1M, total2L = total - total1L, total - total2M\\n\\t\\t# res1 is the maximum sum of L subarry before the last M elements\\n\\t\\t# res2 is the maximum sum of M subarry before the last L elements\\n        res1, res2 = total1L, total2M\\n\\t\\t# res is the final result, initially it is the sum of the first L + M elements\\n        res = total\\n        for i in range(L + M, N):\\n            total1M += A[i] - A[i-M]\\n            total2L += A[i] - A[i-L]\\n            total1L += A[i-M] - A[i-L-M]\\n            res1 = max(res1, total1L)\\n            total2M += A[i-L] - A[i-L-M]\\n            res2 = max(res2, total2M)\\n            res = max(res, total1M + res1, total2L + res2)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n\\t\\t# 1 is the case that L precedes M\\n\\t\\t# 2 is the case that M precedes L\\n        total1L, total1M, total2M, total2L = 0, 0, 0, 0\\n        N = len(A)\\n        total = 0\\n\\t\\t# For initial L + M elements, find the total\\n        for i in range(L + M):\\n            total += A[i]\\n            if i == L - 1:\\n                total1L = total\\n            if i == M - 1:\\n                total2M = total\\n        total1M, total2L = total - total1L, total - total2M\\n\\t\\t# res1 is the maximum sum of L subarry before the last M elements\\n\\t\\t# res2 is the maximum sum of M subarry before the last L elements\\n        res1, res2 = total1L, total2M\\n\\t\\t# res is the final result, initially it is the sum of the first L + M elements\\n        res = total\\n        for i in range(L + M, N):\\n            total1M += A[i] - A[i-M]\\n            total2L += A[i] - A[i-L]\\n            total1L += A[i-M] - A[i-L-M]\\n            res1 = max(res1, total1L)\\n            total2M += A[i-L] - A[i-L-M]\\n            res2 = max(res2, total2M)\\n            res = max(res, total1M + res1, total2L + res2)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 683082,
                "title": "c-o-1-space-o-n-time",
                "content": "```\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n     \\n     //Create a prefix sum array\\n     for(int i=1; i<A.size(); i++)\\n         A[i] += A[i-1];\\n        \\n     //We\\'ll start from left and see what is the maximum sum window of length L, Lmax\\n     //also starting from left and see what is the maximum sum window of length M, Mmax\\n     //Now we have two candidates that can form max sum :\\n     //   1.  Lmax + (maximum sum window of length M to right of Lmax)\\n     //   2.  Mmax + (maximum sum window of length L to right of Mmax)\\n     //  (remember Lmax and Mmax are independent and have nothing to do with each other)\\n     //   \\n     //Why we formed prefix sum array ?\\n     //-> so that we can get these sums like, A[L-1], A[M-1], etc. in O(1) time\\n        \\n     int Lmax = A[L-1];         //initially we keep, Lmax = sum of L length window from [0, L-1]\\n     int Mmax = A[M-1];         //initially we keep, Mmax = sum of M length window from [0, M-1] \\n     int maxSum = A[L+M-1];     //for convenience we are initially keeping maxSum = sum of window from [0, L+M-1]\\n        \\n     for(int i=L+M; i<A.size(); i++) {\\n        //Now we are sliding windows to right \\n        Lmax = max(Lmax, A[i-M] - A[i-L-M]);\\n        Mmax = max(Mmax, A[i-L] - A[i-L-M]); \\n       \\n       maxSum = max(maxSum, max(Lmax + A[i] - A[i-M], Mmax + A[i] - A[i-L]));  \\n     }   \\n    return maxSum;\\n    }\\n\\t\\n\\t//this solution is referenced from Lee\\'s solution",
                "solutionTags": [],
                "code": "```\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n     \\n     //Create a prefix sum array\\n     for(int i=1; i<A.size(); i++)\\n         A[i] += A[i-1];\\n        \\n     //We\\'ll start from left and see what is the maximum sum window of length L, Lmax\\n     //also starting from left and see what is the maximum sum window of length M, Mmax\\n     //Now we have two candidates that can form max sum :\\n     //   1.  Lmax + (maximum sum window of length M to right of Lmax)\\n     //   2.  Mmax + (maximum sum window of length L to right of Mmax)\\n     //  (remember Lmax and Mmax are independent and have nothing to do with each other)\\n     //   \\n     //Why we formed prefix sum array ?\\n     //-> so that we can get these sums like, A[L-1], A[M-1], etc. in O(1) time\\n        \\n     int Lmax = A[L-1];         //initially we keep, Lmax = sum of L length window from [0, L-1]\\n     int Mmax = A[M-1];         //initially we keep, Mmax = sum of M length window from [0, M-1] \\n     int maxSum = A[L+M-1];     //for convenience we are initially keeping maxSum = sum of window from [0, L+M-1]\\n        \\n     for(int i=L+M; i<A.size(); i++) {\\n        //Now we are sliding windows to right \\n        Lmax = max(Lmax, A[i-M] - A[i-L-M]);\\n        Mmax = max(Mmax, A[i-L] - A[i-L-M]); \\n       \\n       maxSum = max(maxSum, max(Lmax + A[i] - A[i-M], Mmax + A[i] - A[i-L]));  \\n     }   \\n    return maxSum;\\n    }\\n\\t\\n\\t//this solution is referenced from Lee\\'s solution",
                "codeTag": "Unknown"
            },
            {
                "id": 632215,
                "title": "simple-java-solution-beats-100-o-n-and-o-n-with-comments",
                "content": "```\\n// prefix sum array for quick lookup\\n// two cases: case 1 - M before L; case 2 - L before M. \\n// take L before M as an example: maintain max L length subarray sum, and enumerate all the non-overlapping M length subarray sum, and \\n// calculate the max sum.\\npublic int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        int n = A.length;\\n        int[] prefix = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            if (i == 0) {\\n                prefix[i] = A[i];\\n                continue;\\n            }\\n            prefix[i] = prefix[i - 1] + A[i];\\n        }\\n\\t\\t// initialize max sum for L length and M length subarrays respectively\\n        int lmax = prefix[L - 1], mmax = prefix[M - 1];\\n\\t\\t//initialize max sum for case 1 and case 2\\n        int max1 = 0, max2 = 0;\\n\\t\\t//L before M. enumerate all the M length subarray sums, while maintaining max L length subarray sum\\n        for (int i = L; i <= n - M; i++) {\\n            int mSum = prefix[i + M - 1] - prefix[i] + A[i];\\n            max1 = Math.max(max1, mSum + lmax);\\n            lmax = Math.max(lmax, prefix[i] - prefix[i - L]);\\n        }\\n\\t\\t//M before L. enumerate all the L length subarray sums, while maintaining max M length subarray sum\\n        for (int i = M; i <= n - L; i++) {\\n            int lSum = prefix[i + L - 1] - prefix[i] + A[i];\\n            max2 = Math.max(max2, lSum + mmax);\\n            mmax = Math.max(mmax, prefix[i] - prefix[i - M]);\\n        }\\n        return Math.max(max1, max2);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n// prefix sum array for quick lookup\\n// two cases: case 1 - M before L; case 2 - L before M. \\n// take L before M as an example: maintain max L length subarray sum, and enumerate all the non-overlapping M length subarray sum, and \\n// calculate the max sum.\\npublic int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        int n = A.length;\\n        int[] prefix = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            if (i == 0) {\\n                prefix[i] = A[i];\\n                continue;\\n            }\\n            prefix[i] = prefix[i - 1] + A[i];\\n        }\\n\\t\\t// initialize max sum for L length and M length subarrays respectively\\n        int lmax = prefix[L - 1], mmax = prefix[M - 1];\\n\\t\\t//initialize max sum for case 1 and case 2\\n        int max1 = 0, max2 = 0;\\n\\t\\t//L before M. enumerate all the M length subarray sums, while maintaining max L length subarray sum\\n        for (int i = L; i <= n - M; i++) {\\n            int mSum = prefix[i + M - 1] - prefix[i] + A[i];\\n            max1 = Math.max(max1, mSum + lmax);\\n            lmax = Math.max(lmax, prefix[i] - prefix[i - L]);\\n        }\\n\\t\\t//M before L. enumerate all the L length subarray sums, while maintaining max M length subarray sum\\n        for (int i = M; i <= n - L; i++) {\\n            int lSum = prefix[i + L - 1] - prefix[i] + A[i];\\n            max2 = Math.max(max2, lSum + mmax);\\n            mmax = Math.max(mmax, prefix[i] - prefix[i - M]);\\n        }\\n        return Math.max(max1, max2);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 540693,
                "title": "c-use-prefix-sum-array-to-facilitate-sliding-window-analysis-91-speed-100-memory",
                "content": "Pre-calculate a prefix sum array to enable access to the sum of all elements before any position i in the original vector. Iterate over all possible L-length, continuous sub-array sums; at each iteration, iterate over all possible M-length sub-arrays located before and after the current L array (such that there is no overlap), store the maximum L+M sum found.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        \\n        vector<int> prefixSum(A.size()+1, 0);         //at position i, sum of all numbers before i\\n        int max = -1;\\n        \\n        for (int i = 1; i < prefixSum.size(); ++i) {  //precalculate prefix sums, to speed up sliding\\n            prefixSum[i] = prefixSum[i-1]+A[i-1];     //window calcs\\n        }\\n        \\n        for (int i = L; i < prefixSum.size(); ++i) {   //Iterating over all possible L subarrays\\n            int lSum = prefixSum[i]-prefixSum[i-L];    //Get the LSum\\n            \\n            for (int j = M; j < i-L; ++j) {            //Iterate over all possible M\\'s before the current L\\n                int mSum = prefixSum[j]-prefixSum[j-M];\\n                if (lSum + mSum > max) {               //If we found a new max L+M, store it\\n                    max = lSum + mSum;\\n                }\\n            }\\n            \\n            for (int j = i + M; j < prefixSum.size(); ++j) { //Iterate over all possible M\\'s after the L\\n                int mSum = prefixSum[j] - prefixSum[j-M];\\n                if (lSum + mSum > max) {              //If we found a new max L+M, store it\\n                    max = lSum + mSum;\\n                }\\n            }\\n        }\\n        \\n        return max;                         //return the max\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        \\n        vector<int> prefixSum(A.size()+1, 0);         //at position i, sum of all numbers before i\\n        int max = -1;\\n        \\n        for (int i = 1; i < prefixSum.size(); ++i) {  //precalculate prefix sums, to speed up sliding\\n            prefixSum[i] = prefixSum[i-1]+A[i-1];     //window calcs\\n        }\\n        \\n        for (int i = L; i < prefixSum.size(); ++i) {   //Iterating over all possible L subarrays\\n            int lSum = prefixSum[i]-prefixSum[i-L];    //Get the LSum\\n            \\n            for (int j = M; j < i-L; ++j) {            //Iterate over all possible M\\'s before the current L\\n                int mSum = prefixSum[j]-prefixSum[j-M];\\n                if (lSum + mSum > max) {               //If we found a new max L+M, store it\\n                    max = lSum + mSum;\\n                }\\n            }\\n            \\n            for (int j = i + M; j < prefixSum.size(); ++j) { //Iterate over all possible M\\'s after the L\\n                int mSum = prefixSum[j] - prefixSum[j-M];\\n                if (lSum + mSum > max) {              //If we found a new max L+M, store it\\n                    max = lSum + mSum;\\n                }\\n            }\\n        }\\n        \\n        return max;                         //return the max\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 534911,
                "title": "faster-than-100-prefix-sum-o-n",
                "content": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        int[] p = getPresum(A);\\n        return Math.max(findMaxSumOfSubarraysInSequence(p,A,L,M),                                             findMaxSumOfSubarraysInSequence(p,A,M,L));\\n    }\\n    \\n    //first select L and then M on right of L\\n    private int findMaxSumOfSubarraysInSequence(int[] p, int[] A, int L, int M){\\n        int max = p[L+M-1]; //first case will be L starting at 0 and then M\\n        int lsum = p[L-1];\\n        for(int i=L+M; i<A.length; i++){\\n            lsum = Math.max(lsum, p[i-M]-p[i-L-M]); //take max lsum till now\\n            max = Math.max(max, lsum+p[i]-p[i-M]);\\n        }\\n        return max;\\n    }\\n    \\n    private int[] getPresum(int[] arr){\\n        int[] p = new int[arr.length];\\n        int sum = 0;\\n        for(int i=0; i<arr.length; i++){\\n            sum+=arr[i];\\n            p[i] = sum;\\n        }\\n        return p;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        int[] p = getPresum(A);\\n        return Math.max(findMaxSumOfSubarraysInSequence(p,A,L,M),                                             findMaxSumOfSubarraysInSequence(p,A,M,L));\\n    }\\n    \\n    //first select L and then M on right of L\\n    private int findMaxSumOfSubarraysInSequence(int[] p, int[] A, int L, int M){\\n        int max = p[L+M-1]; //first case will be L starting at 0 and then M\\n        int lsum = p[L-1];\\n        for(int i=L+M; i<A.length; i++){\\n            lsum = Math.max(lsum, p[i-M]-p[i-L-M]); //take max lsum till now\\n            max = Math.max(max, lsum+p[i]-p[i-M]);\\n        }\\n        return max;\\n    }\\n    \\n    private int[] getPresum(int[] arr){\\n        int[] p = new int[arr.length];\\n        int sum = 0;\\n        for(int i=0; i<arr.length; i++){\\n            sum+=arr[i];\\n            p[i] = sum;\\n        }\\n        return p;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 290299,
                "title": "java-o-n-very-easy-to-understand-solution",
                "content": "1, build a prefixSum table for easy calculation of regional sum \\n2, build regional sum max table, from left, from right \\n3, calculate the max from two direction \\n\\n```\\nclass Solution {\\n    public  int maxSumTwoNoOverlap(int[] a, int l, int m) {\\n\\n        int len = a.length;\\n        int[] ps = new int[len];\\n        ps[0] = a[0];\\n        for (int i = 1; i < len; i++) {\\n            ps[i] = ps[i - 1] + a[i];\\n        }\\n\\n        if (l + m == len) return ps[len - 1];\\n        return Math.max(h(a, ps, l, m, len), h(a, ps, m, l, len));\\n    }\\n\\n    private  int h(int[] a, int[] ps, int left, int right, int len) {\\n\\n        int[] leftMax = new int[len];\\n        int[] rightMax = new int[len];\\n\\n        for (int i = left - 1; i < len; i++) {\\n            int tmp = ps[i] - ps[i - left + 1] + a[i - left + 1];\\n            if (i == left - 1) {\\n                leftMax[i] = tmp;\\n            } else {\\n                leftMax[i] = Math.max(leftMax[i - 1], tmp);\\n            }\\n        }\\n\\n        for (int i = len - right; i >= 0; i--) {\\n            int tmp = ps[i + right - 1] - ps[i] + a[i];\\n            if (i == len - right) {\\n                rightMax[i] = tmp;\\n            } else {\\n                rightMax[i] = Math.max(rightMax[i + 1], tmp);\\n            }\\n        }\\n\\n        int sum = Integer.MIN_VALUE;\\n\\n        for (int i = left - 1; i < len - right; i++) {\\n            sum = Math.max(sum, leftMax[i] + rightMax[i + 1]);\\n        }\\n\\n        return sum;\\n\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public  int maxSumTwoNoOverlap(int[] a, int l, int m) {\\n\\n        int len = a.length;\\n        int[] ps = new int[len];\\n        ps[0] = a[0];\\n        for (int i = 1; i < len; i++) {\\n            ps[i] = ps[i - 1] + a[i];\\n        }\\n\\n        if (l + m == len) return ps[len - 1];\\n        return Math.max(h(a, ps, l, m, len), h(a, ps, m, l, len));\\n    }\\n\\n    private  int h(int[] a, int[] ps, int left, int right, int len) {\\n\\n        int[] leftMax = new int[len];\\n        int[] rightMax = new int[len];\\n\\n        for (int i = left - 1; i < len; i++) {\\n            int tmp = ps[i] - ps[i - left + 1] + a[i - left + 1];\\n            if (i == left - 1) {\\n                leftMax[i] = tmp;\\n            } else {\\n                leftMax[i] = Math.max(leftMax[i - 1], tmp);\\n            }\\n        }\\n\\n        for (int i = len - right; i >= 0; i--) {\\n            int tmp = ps[i + right - 1] - ps[i] + a[i];\\n            if (i == len - right) {\\n                rightMax[i] = tmp;\\n            } else {\\n                rightMax[i] = Math.max(rightMax[i + 1], tmp);\\n            }\\n        }\\n\\n        int sum = Integer.MIN_VALUE;\\n\\n        for (int i = left - 1; i < len - right; i++) {\\n            sum = Math.max(sum, leftMax[i] + rightMax[i + 1]);\\n        }\\n\\n        return sum;\\n\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 282773,
                "title": "straightforward-o-n-max-contagious-array-solution-with-comments",
                "content": "```\\n//         Lmax, max sum of contiguous L elements before the last M elements.\\n// Mmax, max sum of contiguous M elements before the last L elements/\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        //get the presum array\\n        int preSum[] = new int[A.length];\\n        preSum[0] = A[0];\\n        for(int i = 1; i < A.length; i++) {\\n            preSum[i] = preSum[i - 1] + A[i];\\n        }\\n        int result = preSum[L+M - 1];\\n        int LMax = preSum[L - 1];\\n        int MMax = preSum[M - 1];\\n       // System.out.println()\\n        for(int i = L + M; i < A.length; i++) {\\n           LMax = Math.max(LMax, preSum[i - M] - preSum[i - M - L]);\\n           MMax = Math.max(MMax, preSum[i - L] - preSum[i - L - M]);\\n           result = Math.max(result, Math.max(preSum[i] - preSum[i - M] + LMax, preSum[i] - preSum[i - L] + MMax));\\n\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n//         Lmax, max sum of contiguous L elements before the last M elements.\\n// Mmax, max sum of contiguous M elements before the last L elements/\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        //get the presum array\\n        int preSum[] = new int[A.length];\\n        preSum[0] = A[0];\\n        for(int i = 1; i < A.length; i++) {\\n            preSum[i] = preSum[i - 1] + A[i];\\n        }\\n        int result = preSum[L+M - 1];\\n        int LMax = preSum[L - 1];\\n        int MMax = preSum[M - 1];\\n       // System.out.println()\\n        for(int i = L + M; i < A.length; i++) {\\n           LMax = Math.max(LMax, preSum[i - M] - preSum[i - M - L]);\\n           MMax = Math.max(MMax, preSum[i - L] - preSum[i - L - M]);\\n           result = Math.max(result, Math.max(preSum[i] - preSum[i - M] + LMax, preSum[i] - preSum[i - L] + MMax));\\n\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 278791,
                "title": "use-two-sliding-windows",
                "content": "```\\n public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        int max=0;\\n        int sum1=0,sum2=0;\\n        int n =A.length;\\n\\n        for (int i=0;i<L;i++)\\n            sum1+= A[i];\\n        int temp1=sum1;\\n        for (int i=0;i<M;i++)\\n            sum2+= A[i];\\n        int temp2=sum2;\\n        for (int i= L-1;i<n;i++){\\n            if (i!=L-1)\\n            sum1=sum1+A[i]-A[i-L];\\n            for (int j=M-1;j<n;j++){\\n                if (j!=M-1)\\n                sum2=sum2+A[j]-A[j-M];\\n                if (j<i-L+1||j-M+1>i){\\n                    max=Math.max(max,(i==L-1?temp1:sum1)+(j==M-1?temp2:sum2));}\\n            }\\n            sum2=temp2;\\n        }\\n        return max;\\n    }",
                "solutionTags": [],
                "code": "```\\n public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        int max=0;\\n        int sum1=0,sum2=0;\\n        int n =A.length;\\n\\n        for (int i=0;i<L;i++)\\n            sum1+= A[i];\\n        int temp1=sum1;\\n        for (int i=0;i<M;i++)\\n            sum2+= A[i];\\n        int temp2=sum2;\\n        for (int i= L-1;i<n;i++){\\n            if (i!=L-1)\\n            sum1=sum1+A[i]-A[i-L];\\n            for (int j=M-1;j<n;j++){\\n                if (j!=M-1)\\n                sum2=sum2+A[j]-A[j-M];\\n                if (j<i-L+1||j-M+1>i){\\n                    max=Math.max(max,(i==L-1?temp1:sum1)+(j==M-1?temp2:sum2));}\\n            }\\n            sum2=temp2;\\n        }\\n        return max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2652494,
                "title": "c-solution-with-explanation",
                "content": "**Explanation**\\nYou can either have firstLen elements on the left and secondLen elements on the right or vice versa.\\n\\nUse two vectors to calculate the results of both sliding windows with the index of the vector indicating the start location of the sliding window.\\n\\nThe max sum is then trivially computable by considering either firstLen first or secondLen first.\\n\\n**Code**\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(const vector<int>& nums, int firstLen, int secondLen) {\\n        const auto get_possibilities = [&nums](const int length){\\n            std::vector<int> possibilities;\\n            int window_sum{0};\\n            for(int i = 0; i < length; ++i) {\\n                window_sum += nums[i];\\n            }\\n            possibilities.push_back(window_sum);\\n            for(int i = length; i < nums.size(); ++i) {\\n                window_sum = window_sum - nums[i - length] + nums[i];\\n                possibilities.push_back(window_sum);\\n            }   \\n            return possibilities;\\n        };\\n        \\n        const auto first_possibilities = get_possibilities(firstLen);\\n        const auto second_possibilities = get_possibilities(secondLen);\\n        \\n        const auto get_max_sum = [&nums](const std::vector<int>& first, const int firstLen, const std::vector<int>& second) {\\n            int max_sum = std::numeric_limits<int>::min();\\n            for(int i = 0; i < first.size(); ++i) {\\n                for(int j = i + firstLen; j < second.size(); ++j) {\\n                    int sum = first[i] + second[j];\\n                    max_sum = std::max(max_sum, sum);\\n                }\\n            }\\n            return max_sum;\\n        };\\n        \\n        const auto left_first = get_max_sum(first_possibilities, firstLen, second_possibilities);\\n        const auto left_second = get_max_sum(second_possibilities, secondLen, first_possibilities);\\n        \\n        return std::max(left_first, left_second); \\n\\t}\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int maxSumTwoNoOverlap(const vector<int>& nums, int firstLen, int secondLen) {\\n        const auto get_possibilities = [&nums](const int length){\\n            std::vector<int> possibilities;\\n            int window_sum{0}",
                "codeTag": "Java"
            },
            {
                "id": 2225496,
                "title": "python-easy-to-understand",
                "content": "```\\n def maxSumTwoNoOverlap(self, nums: List[int], firstLen: int, secondLen: int) -> int:\\n        \\n        n=len(nums)\\n        \\n        firstPrefix=[0]*n\\n        secondPrefix=[0]*n\\n        p1=p2=0\\n        mx1=mx2=0\\n        \\n        firstSufix=[0]*n\\n        secondSufix=[0]*n\\n        s1=s2=0\\n        smx1=smx2=0\\n        \\n        ans=0\\n        \\n        #prefix sum of firstlen\\n        for i in range(n):\\n            if i<firstLen:\\n                p1+=nums[i]\\n                firstPrefix[i]=p1\\n            else:\\n                p1=nums[i]+p1-nums[i-firstLen]\\n                #print(p1,p1,nums[i],nums[i-firstLen])\\n                mx1=max(p1,mx1)\\n                firstPrefix[i]=mx1\\n        #print(firstPrefix)\\n        \\n        #Sufix sum of Secondtlen\\n        for i in range(n-1,-1,-1):\\n            if i>=n-secondLen:\\n                s2+=nums[i]\\n                secondSufix[i]=s2\\n                #print(s2)\\n                smx2=s2\\n            else:\\n                s2=nums[i]+s2-nums[i+secondLen]\\n                #print(p1,p1,nums[i],nums[i-firstLen])\\n                smx2=max(s2,smx2)\\n                secondSufix[i]=smx2\\n        #print(secondSufix)\\n        \\n        #Sufix sum of firstlen\\n        for i in range(n-1,-1,-1):\\n            if i>=n-firstLen:\\n                s1+=nums[i]\\n                firstSufix[i]=s1\\n                smx1=s1\\n            else:\\n                s1=nums[i]+s1-nums[i+firstLen]\\n                #print(p1,p1,nums[i],nums[i-firstLen])\\n                smx1=max(s1,smx1)\\n                firstSufix[i]=smx1\\n        #print(firstSufix)\\n        \\n        #prefix sum of secondlen\\n        for i in range(n):\\n            if i<secondLen:\\n                p2+=nums[i]\\n                secondPrefix[i]=p2\\n            else:\\n                p2=nums[i]+p2-nums[i-secondLen]\\n                #print(p1,p1,nums[i],nums[i-secondLen])\\n                mx2=max(p2,mx2)\\n                secondPrefix[i]=mx2\\n        #print(secondPrefix)\\n        \\n        #maximum sum\\n        for i in range(n-1):\\n            ans=max(ans,firstPrefix[i]+secondSufix[i+1],secondPrefix[i]+firstSufix[i+1])\\n            \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\n def maxSumTwoNoOverlap(self, nums: List[int], firstLen: int, secondLen: int) -> int:\\n        \\n        n=len(nums)\\n        \\n        firstPrefix=[0]*n\\n        secondPrefix=[0]*n\\n        p1=p2=0\\n        mx1=mx2=0\\n        \\n        firstSufix=[0]*n\\n        secondSufix=[0]*n\\n        s1=s2=0\\n        smx1=smx2=0\\n        \\n        ans=0\\n        \\n        #prefix sum of firstlen\\n        for i in range(n):\\n            if i<firstLen:\\n                p1+=nums[i]\\n                firstPrefix[i]=p1\\n            else:\\n                p1=nums[i]+p1-nums[i-firstLen]\\n                #print(p1,p1,nums[i],nums[i-firstLen])\\n                mx1=max(p1,mx1)\\n                firstPrefix[i]=mx1\\n        #print(firstPrefix)\\n        \\n        #Sufix sum of Secondtlen\\n        for i in range(n-1,-1,-1):\\n            if i>=n-secondLen:\\n                s2+=nums[i]\\n                secondSufix[i]=s2\\n                #print(s2)\\n                smx2=s2\\n            else:\\n                s2=nums[i]+s2-nums[i+secondLen]\\n                #print(p1,p1,nums[i],nums[i-firstLen])\\n                smx2=max(s2,smx2)\\n                secondSufix[i]=smx2\\n        #print(secondSufix)\\n        \\n        #Sufix sum of firstlen\\n        for i in range(n-1,-1,-1):\\n            if i>=n-firstLen:\\n                s1+=nums[i]\\n                firstSufix[i]=s1\\n                smx1=s1\\n            else:\\n                s1=nums[i]+s1-nums[i+firstLen]\\n                #print(p1,p1,nums[i],nums[i-firstLen])\\n                smx1=max(s1,smx1)\\n                firstSufix[i]=smx1\\n        #print(firstSufix)\\n        \\n        #prefix sum of secondlen\\n        for i in range(n):\\n            if i<secondLen:\\n                p2+=nums[i]\\n                secondPrefix[i]=p2\\n            else:\\n                p2=nums[i]+p2-nums[i-secondLen]\\n                #print(p1,p1,nums[i],nums[i-secondLen])\\n                mx2=max(p2,mx2)\\n                secondPrefix[i]=mx2\\n        #print(secondPrefix)\\n        \\n        #maximum sum\\n        for i in range(n-1):\\n            ans=max(ans,firstPrefix[i]+secondSufix[i+1],secondPrefix[i]+firstSufix[i+1])\\n            \\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1966972,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Sliding Window***\\n\\n* ***Time Complexity : O(N)***\\n* ***Space Complexity : O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int helper(vector<int>& nums, int x, int y)\\n    {\\n        int n = nums.size();\\n        \\n        vector<int> dp_left_max(n, 0);\\n        \\n        vector<int> dp_right_max(n, 0);\\n        \\n        int sum = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(i < x)\\n            {\\n                sum += nums[i];\\n                \\n                dp_left_max[i] = sum;\\n            }\\n            else if(i >= x)\\n            {\\n                sum += nums[i] - nums[i - x];\\n                \\n                dp_left_max[i] = max(dp_left_max[i - 1], sum);\\n            }\\n        }\\n        \\n        sum = 0;\\n        \\n        for(int i = n - 1; i >= 0; i--)\\n        {\\n            if(i >= n - y)\\n            {\\n                sum += nums[i];\\n                \\n                dp_right_max[i] = sum;\\n            }\\n            else\\n            {\\n                sum += nums[i] - nums[i + y];\\n                \\n                dp_right_max[i] = max(dp_right_max[i + 1], sum);\\n            }\\n        }\\n        \\n        int ans = INT_MIN;\\n        \\n        for(int i = x - 1; i < n - y; i++)\\n        {\\n            ans = max(ans, dp_left_max[i] + dp_right_max[i + 1]);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    int maxSumTwoNoOverlap(vector<int>& nums, int x, int y) {\\n        \\n        int n = nums.size();\\n        \\n        int max1 = helper(nums, x, y);\\n        \\n        int max2 = helper(nums, y, x);\\n        \\n        return max(max1, max2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int helper(vector<int>& nums, int x, int y)\\n    {\\n        int n = nums.size();\\n        \\n        vector<int> dp_left_max(n, 0);\\n        \\n        vector<int> dp_right_max(n, 0);\\n        \\n        int sum = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(i < x)\\n            {\\n                sum += nums[i];\\n                \\n                dp_left_max[i] = sum;\\n            }\\n            else if(i >= x)\\n            {\\n                sum += nums[i] - nums[i - x];\\n                \\n                dp_left_max[i] = max(dp_left_max[i - 1], sum);\\n            }\\n        }\\n        \\n        sum = 0;\\n        \\n        for(int i = n - 1; i >= 0; i--)\\n        {\\n            if(i >= n - y)\\n            {\\n                sum += nums[i];\\n                \\n                dp_right_max[i] = sum;\\n            }\\n            else\\n            {\\n                sum += nums[i] - nums[i + y];\\n                \\n                dp_right_max[i] = max(dp_right_max[i + 1], sum);\\n            }\\n        }\\n        \\n        int ans = INT_MIN;\\n        \\n        for(int i = x - 1; i < n - y; i++)\\n        {\\n            ans = max(ans, dp_left_max[i] + dp_right_max[i + 1]);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    int maxSumTwoNoOverlap(vector<int>& nums, int x, int y) {\\n        \\n        int n = nums.size();\\n        \\n        int max1 = helper(nums, x, y);\\n        \\n        int max2 = helper(nums, y, x);\\n        \\n        return max(max1, max2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911608,
                "title": "python-simple-clean-solution-with-a-single-loop-o-n-40ms-easy-to-understand",
                "content": "**Simple and clean solution with a single loop**\\n\\nTime complexity: O(N)\\n\\n```\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, nums: List[int], firstLen: int, secondLen: int) -> int:\\n        acc_sum = [0] * (len(nums) + 1)\\n        max_1st, max_2nd, mx_ans = -1, -1, -1\\n\\n        for index in range(1, len(acc_sum)):\\n            acc_sum[index] = acc_sum[index - 1] + nums[index - 1]\\n\\n            if index >= firstLen + secondLen:\\n                max_1st = max(max_1st, acc_sum[index - secondLen] - acc_sum[index - secondLen - firstLen])\\n                max_2nd = max(max_2nd, acc_sum[index - firstLen] - acc_sum[index - firstLen - secondLen])\\n\\n                first_second = max_1st + acc_sum[index] - acc_sum[index - secondLen]\\n                second_first = max_2nd + acc_sum[index] - acc_sum[index - firstLen]\\n                mx_ans = max(mx_ans, first_second, second_first)\\n\\n        return mx_ans\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, nums: List[int], firstLen: int, secondLen: int) -> int:\\n        acc_sum = [0] * (len(nums) + 1)\\n        max_1st, max_2nd, mx_ans = -1, -1, -1\\n\\n        for index in range(1, len(acc_sum)):\\n            acc_sum[index] = acc_sum[index - 1] + nums[index - 1]\\n\\n            if index >= firstLen + secondLen:\\n                max_1st = max(max_1st, acc_sum[index - secondLen] - acc_sum[index - secondLen - firstLen])\\n                max_2nd = max(max_2nd, acc_sum[index - firstLen] - acc_sum[index - firstLen - secondLen])\\n\\n                first_second = max_1st + acc_sum[index] - acc_sum[index - secondLen]\\n                second_first = max_2nd + acc_sum[index] - acc_sum[index - firstLen]\\n                mx_ans = max(mx_ans, first_second, second_first)\\n\\n        return mx_ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1668230,
                "title": "java-o-n-time-complexity-dynamic-programming-explanation-in-detail-easy-to-understand",
                "content": "We need to find the 2 subarrays, so two cases are possible-\\n   1. first subArray appear before the second subArray\\n   2. second subArray appear before first subArray\\nand so, I will be solving this problem using dynamic programming and also using prefix and suffix sum concept to reduce the complexity.\\nand I will define 2 arrays for each case\\n--> Evaluate the prefix sum and suffix sum of the given array.       // you can also use 2 pointer instead of prefix and suffix to save space/memory.\\n    EXAMPLE:  nums = [0,6,5,2,2,5,1,9,4], firstLen = 1, secondLen = 2\\n               prefixSum=[0, 6, 11, 13, 15, 20, 21, 30, 34]\\n               suffixSum=[34, 34, 28, 23, 21, 19, 14, 13, 4]\\n\\nConsidering case 1 - first subArray appear before the second subArray \\n                     Create two arrays ,\\n                       leftSubarraymax=[0, 6, 6, 6, 6, 6, 6, 9, 9]    // stores the maximum sum of first subarray with length firstLen using prefixSum array.\\n                                             // ith position represents the maximum first subarray sum from 0 till ith index.\\n                       rightSubarraymax=[13, 13, 13, 13, 13, 13, 13, 13, 0]\\n   // stores the maximum sum of second subarray with length secondLen using suffixSum array.\\n                                             // ith position represents the maximum second subarray sum from ith index till last index.\\n\\nnow iterate and find the maximum of  ( leftSubarraymax[i] + rightSubarraymax[i+1] ) , max1. \\n\\nSimillarly do it for the case 2 and find the max2\\nfinally the answer is maximum of max1 and max2.\\n   \\n\\n   \\n```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] nums, int firstLen, int secondLen) {\\n        int[] prefixSum=new int[nums.length];\\n        int[] suffixSum=new int[nums.length];\\n    \\n        for(int i=0;i<prefixSum.length;i++){\\n            if(i==0){\\n                prefixSum[0]=nums[0];\\n            }else{\\n                prefixSum[i]=prefixSum[i-1]+nums[i];\\n            }\\n        }\\n        for(int i=suffixSum.length-1;i>=0;i--){\\n            if(i==suffixSum.length-1){\\n                suffixSum[i]=nums[i];\\n            }else{\\n                suffixSum[i]=suffixSum[i+1]+nums[i];\\n            }\\n        }   \\n        // case 1 :\\n        int[] leftSubarrayMax=new int[nums.length];\\n        int[] rightSubarrayMax=new int[nums.length];\\n        for(int i=0;i<leftSubarrayMax.length;i++){\\n            if(i<firstLen-1){\\n                leftSubarrayMax[i]=0;\\n            }else if(i==firstLen-1){\\n                leftSubarrayMax[i]=prefixSum[i];\\n            }else{\\n                 leftSubarrayMax[i]=Math.max(leftSubarrayMax[i-1],prefixSum[i]-prefixSum[i-firstLen]);\\n            }\\n        }\\n         for(int i=rightSubarrayMax.length-1;i>=0;i--){\\n            if(i>rightSubarrayMax.length-secondLen){\\n                rightSubarrayMax[i]=0;\\n            }else if(i==rightSubarrayMax.length-secondLen){\\n                rightSubarrayMax[i]=suffixSum[i];\\n            }else{\\n                 rightSubarrayMax[i]=Math.max(rightSubarrayMax[i+1],suffixSum[i]-suffixSum[i+secondLen]);\\n            }\\n        }\\n        \\n        int max1=0;\\n        for(int i=firstLen-1;i<nums.length-secondLen;i++){\\n            int val=leftSubarrayMax[i]+rightSubarrayMax[i+1];\\n            if(val>max1) max1=val;\\n        }\\n        \\n         // case 2 :\\n        leftSubarrayMax=new int[nums.length];\\n        rightSubarrayMax=new int[nums.length];\\n        for(int i=0;i<leftSubarrayMax.length;i++){\\n            if(i<secondLen-1){\\n                leftSubarrayMax[i]=0;\\n            }else if(i==secondLen-1){\\n                leftSubarrayMax[i]=prefixSum[i];\\n            }else{\\n                 leftSubarrayMax[i]=Math.max(leftSubarrayMax[i-1],prefixSum[i]-prefixSum[i-secondLen]);\\n            }\\n        }\\n         for(int i=rightSubarrayMax.length-1;i>=0;i--){\\n            if(i>rightSubarrayMax.length-firstLen){\\n                rightSubarrayMax[i]=0;\\n            }else if(i==rightSubarrayMax.length-firstLen){\\n                rightSubarrayMax[i]=suffixSum[i];\\n            }else{\\n                 rightSubarrayMax[i]=Math.max(rightSubarrayMax[i+1],suffixSum[i]-suffixSum[i+firstLen]);\\n            }\\n        }\\n        int max2=0;\\n        for(int i=secondLen-1;i<nums.length-firstLen;i++){\\n            int val=leftSubarrayMax[i]+rightSubarrayMax[i+1];\\n            if(val>max2) max2=val;\\n        }\\n        return Math.max(max1,max2);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] nums, int firstLen, int secondLen) {\\n        int[] prefixSum=new int[nums.length];\\n        int[] suffixSum=new int[nums.length];\\n    \\n        for(int i=0;i<prefixSum.length;i++){\\n            if(i==0){\\n                prefixSum[0]=nums[0];\\n            }else{\\n                prefixSum[i]=prefixSum[i-1]+nums[i];\\n            }\\n        }\\n        for(int i=suffixSum.length-1;i>=0;i--){\\n            if(i==suffixSum.length-1){\\n                suffixSum[i]=nums[i];\\n            }else{\\n                suffixSum[i]=suffixSum[i+1]+nums[i];\\n            }\\n        }   \\n        // case 1 :\\n        int[] leftSubarrayMax=new int[nums.length];\\n        int[] rightSubarrayMax=new int[nums.length];\\n        for(int i=0;i<leftSubarrayMax.length;i++){\\n            if(i<firstLen-1){\\n                leftSubarrayMax[i]=0;\\n            }else if(i==firstLen-1){\\n                leftSubarrayMax[i]=prefixSum[i];\\n            }else{\\n                 leftSubarrayMax[i]=Math.max(leftSubarrayMax[i-1],prefixSum[i]-prefixSum[i-firstLen]);\\n            }\\n        }\\n         for(int i=rightSubarrayMax.length-1;i>=0;i--){\\n            if(i>rightSubarrayMax.length-secondLen){\\n                rightSubarrayMax[i]=0;\\n            }else if(i==rightSubarrayMax.length-secondLen){\\n                rightSubarrayMax[i]=suffixSum[i];\\n            }else{\\n                 rightSubarrayMax[i]=Math.max(rightSubarrayMax[i+1],suffixSum[i]-suffixSum[i+secondLen]);\\n            }\\n        }\\n        \\n        int max1=0;\\n        for(int i=firstLen-1;i<nums.length-secondLen;i++){\\n            int val=leftSubarrayMax[i]+rightSubarrayMax[i+1];\\n            if(val>max1) max1=val;\\n        }\\n        \\n         // case 2 :\\n        leftSubarrayMax=new int[nums.length];\\n        rightSubarrayMax=new int[nums.length];\\n        for(int i=0;i<leftSubarrayMax.length;i++){\\n            if(i<secondLen-1){\\n                leftSubarrayMax[i]=0;\\n            }else if(i==secondLen-1){\\n                leftSubarrayMax[i]=prefixSum[i];\\n            }else{\\n                 leftSubarrayMax[i]=Math.max(leftSubarrayMax[i-1],prefixSum[i]-prefixSum[i-secondLen]);\\n            }\\n        }\\n         for(int i=rightSubarrayMax.length-1;i>=0;i--){\\n            if(i>rightSubarrayMax.length-firstLen){\\n                rightSubarrayMax[i]=0;\\n            }else if(i==rightSubarrayMax.length-firstLen){\\n                rightSubarrayMax[i]=suffixSum[i];\\n            }else{\\n                 rightSubarrayMax[i]=Math.max(rightSubarrayMax[i+1],suffixSum[i]-suffixSum[i+firstLen]);\\n            }\\n        }\\n        int max2=0;\\n        for(int i=secondLen-1;i<nums.length-firstLen;i++){\\n            int val=leftSubarrayMax[i]+rightSubarrayMax[i+1];\\n            if(val>max2) max2=val;\\n        }\\n        return Math.max(max1,max2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1467794,
                "title": "java-concise-solution-using-prefix-sum",
                "content": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] nums, int firstLen, int secondLen) {\\n        int[] prefixSum = new int[nums.length + 1];\\n        prefixSum[0] = 0;\\n        for (int i = 1; i <= nums.length; i++)\\n            prefixSum[i] = prefixSum[i-1] + nums[i-1];\\n        int maxBefore = 0;\\n        int sum = 0;\\n        for (int i = secondLen + firstLen; i < prefixSum.length; i++){\\n            int curNum = prefixSum[i] - prefixSum[i-secondLen];\\n            maxBefore = Math.max(maxBefore, prefixSum[i-secondLen] - prefixSum[i-secondLen-firstLen]);\\n            sum = Math.max(sum, curNum + maxBefore);\\n        }\\n        int maxAfter = 0;\\n        for (int i = prefixSum.length - secondLen - firstLen; i >= 1; i--){\\n            int curNum = prefixSum[i+secondLen-1] - prefixSum[i-1];\\n            maxAfter = Math.max(maxAfter, prefixSum[i+secondLen+firstLen - 1] - prefixSum[i+secondLen-1]);\\n            sum = Math.max(sum, curNum + maxAfter);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] nums, int firstLen, int secondLen) {\\n        int[] prefixSum = new int[nums.length + 1];\\n        prefixSum[0] = 0;\\n        for (int i = 1; i <= nums.length; i++)\\n            prefixSum[i] = prefixSum[i-1] + nums[i-1];\\n        int maxBefore = 0;\\n        int sum = 0;\\n        for (int i = secondLen + firstLen; i < prefixSum.length; i++){\\n            int curNum = prefixSum[i] - prefixSum[i-secondLen];\\n            maxBefore = Math.max(maxBefore, prefixSum[i-secondLen] - prefixSum[i-secondLen-firstLen]);\\n            sum = Math.max(sum, curNum + maxBefore);\\n        }\\n        int maxAfter = 0;\\n        for (int i = prefixSum.length - secondLen - firstLen; i >= 1; i--){\\n            int curNum = prefixSum[i+secondLen-1] - prefixSum[i-1];\\n            maxAfter = Math.max(maxAfter, prefixSum[i+secondLen+firstLen - 1] - prefixSum[i+secondLen-1]);\\n            sum = Math.max(sum, curNum + maxAfter);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1451292,
                "title": "simple-approach-in-c-using-prefix-sliding-window-easiest-way",
                "content": "class Solution {\\npublic:\\n\\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstlen, int secondlen) \\n    {\\n        int n=nums.size(),pre[n+1],ans=0;\\n        pre[0]=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            pre[i+1]=pre[i]+nums[i];\\n        }\\n        int left=0;\\n       for(int i=firstlen;i+secondlen<=n;i++)//firstlen ,secondlen\\n       {\\n            left=max(left,pre[i]-pre[i-firstlen]);\\n           ans=max(ans,left+pre[i+secondlen]-pre[i]);\\n       }\\n        left=0;\\n       for(int i=secondlen;i+firstlen<=n;i++)//secondlen ,firstlen\\n       {\\n            left=max(left,pre[i]-pre[i-secondlen]);\\n           ans=max(ans,left+pre[i+firstlen]-pre[i]);\\n       }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstlen, int secondlen) \\n    {\\n        int n=nums.size(),pre[n+1],ans=0;\\n        pre[0]=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            pre[i+1]=pre[i]+nums[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1162902,
                "title": "java-o-n-time-easy-to-understand",
                "content": "```\\n\\npublic int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n\\t\\t//for any sum of subarray question, we must get prefix Sum array first\\n        int[] sums = new int[A.length + 1];\\n        for(int i = 1; i <= A.length; i++) sums[i] = A[i - 1] + sums[i - 1];\\n        \\n        int ans = 0;\\n        \\n        //If array L is on the left side of M\\n        int maxLVal = 0;\\n        for(int i = L; i <= A.length - M; i++) {\\n            maxLVal = Math.max(maxLVal, sums[i] - sums[i - L]);\\n            ans = Math.max(ans, sums[i + M] - sums[i] + maxLVal);\\n        }\\n\\n        //If array M is on the left side of L  <=> array L is on the right side of M\\n        int maxMVal = 0;\\n        for(int i = M; i <= A.length - L; i++) {\\n            maxMVal = Math.max(maxMVal, sums[i] - sums[i - M]);\\n            ans = Math.max(ans, sums[i + L] - sums[i] + maxMVal);\\n        }\\n\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\npublic int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n\\t\\t//for any sum of subarray question, we must get prefix Sum array first\\n        int[] sums = new int[A.length + 1];\\n        for(int i = 1; i <= A.length; i++) sums[i] = A[i - 1] + sums[i - 1];\\n        \\n        int ans = 0;\\n        \\n        //If array L is on the left side of M\\n        int maxLVal = 0;\\n        for(int i = L; i <= A.length - M; i++) {\\n            maxLVal = Math.max(maxLVal, sums[i] - sums[i - L]);\\n            ans = Math.max(ans, sums[i + M] - sums[i] + maxLVal);\\n        }\\n\\n        //If array M is on the left side of L  <=> array L is on the right side of M\\n        int maxMVal = 0;\\n        for(int i = M; i <= A.length - L; i++) {\\n            maxMVal = Math.max(maxMVal, sums[i] - sums[i - M]);\\n            ans = Math.max(ans, sums[i + L] - sums[i] + maxMVal);\\n        }\\n\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 991183,
                "title": "python3-simple-greedy-solution-99-speed-and-o-1-memory",
                "content": "```\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n        A.insert(0,0)\\n        for i in range(1, len(A)):\\n            A[i] += A[i-1]\\n    \\n        lmax, mmax = 0,0\\n        ans = 0\\n        \\n        ## L -> M\\n        n = len(A)\\n        for i in range(L + M, n):\\n            m = 0\\n            lmax = max(lmax, A[i - M] - A[i - L - M])\\n            ans = max(ans, lmax + A[i] - A[i-M])\\n        \\n        ## M -> L\\n        for i in range(L+M, n):\\n            l = 0\\n            mmax = max(mmax, A[i - L] - A[i - L - M])\\n            ans = max(ans, mmax + A[i] - A[i-L])\\n            \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n        A.insert(0,0)\\n        for i in range(1, len(A)):\\n            A[i] += A[i-1]\\n    \\n        lmax, mmax = 0,0\\n        ans = 0\\n        \\n        ## L -> M\\n        n = len(A)\\n        for i in range(L + M, n):\\n            m = 0\\n            lmax = max(lmax, A[i - M] - A[i - L - M])\\n            ans = max(ans, lmax + A[i] - A[i-M])\\n        \\n        ## M -> L\\n        for i in range(L+M, n):\\n            l = 0\\n            mmax = max(mmax, A[i - L] - A[i - L - M])\\n            ans = max(ans, mmax + A[i] - A[i-L])\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 923374,
                "title": "java-o-n-o-1-space-faster-than-100-step-by-step-explained",
                "content": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] nums, int L, int M) {\\n        // case 1 -> L before M , case 2 -> M before L \\n        // for every 2nd(R) subarray find the subarray to its left with maximum sum( the best candidate )\\n        // and the ans is -> for every R subarray with sumR : max(maxTotal , sumR + maxL)\\n        return Math.max(helper(nums , L , M), helper(nums , M , L));\\n    }\\n    private static int helper(int [] nums , int L , int M){\\n        \\n        int sumR = 0 ,sumL = 0 ;\\n        int maxSum = 0 ;\\n        int maxL = 0 ;\\n        \\n        // limiters of the initial windows\\n        int lStart = 0 ,lEnd = L - 1;\\n        int rStart = lEnd + 1 , rEnd = rStart + M - 1;\\n        \\n        // create the first windows , in a way that they do not overlap [l],[r],[rest of the array]\\n        for(int i = 0 ; i <= lEnd ;  i++)\\n            sumL += nums[i];\\n        for(int i = rStart ; i <= rEnd; i++)\\n            sumR += nums[i];\\n        \\n        maxL = sumL; // maximum sum of the first left subarray  \\n        maxSum = sumL + sumR; // when L + M == nums.length , OR when the sum of 1st windows has the desired ans \\n        \\n        // begin sliding both of them , and for every Right subarray get the max sum of the subarray to its left \\n        // ie - the best possible candidate for the right subarray and sum them up and record the global max \\n        // among all such right subarrays \\n        \\n        // and since we are using sliding window technique , sliding both by 1 elt at a time we will stop \\n        // when we cannot slide the right window anymore , thus ensuring L and R never overlap \\n        \\n        for(int i = rEnd + 1 ; i < nums.length ; i++){\\n            sumL = sumL - nums[lStart++] + nums[rStart];\\n            sumR = sumR - nums[rStart++] + nums[i];\\n            maxL = Math.max(maxL , sumL);  // kepp updating the maximum sum of left subarray seen till now \\n            maxSum = Math.max(maxSum , sumR + maxL);\\n        }\\n        return maxSum ; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] nums, int L, int M) {\\n        // case 1 -> L before M , case 2 -> M before L \\n        // for every 2nd(R) subarray find the subarray to its left with maximum sum( the best candidate )\\n        // and the ans is -> for every R subarray with sumR : max(maxTotal , sumR + maxL)\\n        return Math.max(helper(nums , L , M), helper(nums , M , L));\\n    }\\n    private static int helper(int [] nums , int L , int M){\\n        \\n        int sumR = 0 ,sumL = 0 ;\\n        int maxSum = 0 ;\\n        int maxL = 0 ;\\n        \\n        // limiters of the initial windows\\n        int lStart = 0 ,lEnd = L - 1;\\n        int rStart = lEnd + 1 , rEnd = rStart + M - 1;\\n        \\n        // create the first windows , in a way that they do not overlap [l],[r],[rest of the array]\\n        for(int i = 0 ; i <= lEnd ;  i++)\\n            sumL += nums[i];\\n        for(int i = rStart ; i <= rEnd; i++)\\n            sumR += nums[i];\\n        \\n        maxL = sumL; // maximum sum of the first left subarray  \\n        maxSum = sumL + sumR; // when L + M == nums.length , OR when the sum of 1st windows has the desired ans \\n        \\n        // begin sliding both of them , and for every Right subarray get the max sum of the subarray to its left \\n        // ie - the best possible candidate for the right subarray and sum them up and record the global max \\n        // among all such right subarrays \\n        \\n        // and since we are using sliding window technique , sliding both by 1 elt at a time we will stop \\n        // when we cannot slide the right window anymore , thus ensuring L and R never overlap \\n        \\n        for(int i = rEnd + 1 ; i < nums.length ; i++){\\n            sumL = sumL - nums[lStart++] + nums[rStart];\\n            sumR = sumR - nums[rStart++] + nums[i];\\n            maxL = Math.max(maxL , sumL);  // kepp updating the maximum sum of left subarray seen till now \\n            maxSum = Math.max(maxSum , sumR + maxL);\\n        }\\n        return maxSum ; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 773645,
                "title": "explanation-simple-sliding-window-o-n-time-o-1-space-c",
                "content": "\\n1st Loop: Slide from right to left:\\n* \\t(Sliding Window of length M) ... (Sliding Window of length L)\\n* \\tsum1 = sum of window M\\n* \\tsum2 = sum of window L\\n* \\tmax_sum2 = max(max_sum2, sum2)\\n* \\tres = max(res, sum1+max_sum2)\\n\\n\\n2nd Loop: Slide from left to right\\n* \\t(Sliding Window of length L) ... (Sliding Window of length M)\\n* \\tsum1 = sum of window M\\n* \\tsum2 = sum of window L\\n* \\tmax_sum2 = max(max_sum2, sum2)\\n* \\tres = max(res, sum1+max_sum2)\\n\\nreturn res\\n\\n```\\nint maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        int n = A.size();\\n        if(n == 0 || L+M > n) return 0;\\n        if(L > M) swap(L, M);\\n        \\n        int leftMax = 0, res = 0, right = 0;                \\n        for(int i = n-1; i >= n-L; i--) leftMax += A[i];\\n        for(int i = n-L-1; i >= n-L-M; i--) right += A[i];\\n        int left = leftMax;\\n        res = right+leftMax;\\n        int i = n-L-M, j =  n-L-1;\\n        int l = n-L, r = n-1;\\n        while(i > 0) {\\n            i--;\\n            j--;\\n            l--;\\n            r--;\\n            right = right-A[j+1]+A[i];\\n            left = left+A[l]-A[r+1];\\n            leftMax = max(leftMax, left);\\n            res = max(res, right+leftMax);\\n        }\\n        leftMax = 0, right = 0;                \\n        for(int i = 0; i < L; i++) leftMax += A[i];\\n        for(int i = L; i < L+M; i++) right += A[i];\\n        left = leftMax;\\n        res = max(res, right+leftMax);\\n        i = L, j =  L+M-1;\\n        l = 0, r = L-1;\\n        while(j < n-1) {\\n            i++;\\n            j++;\\n            l++;\\n            r++;\\n            right = right+A[j]-A[i-1];\\n            left = left-A[l-1]+A[r];\\n            leftMax = max(leftMax, left);\\n            res = max(res, right+leftMax);\\n        }\\n        return res;\\n    }  \\n```",
                "solutionTags": [],
                "code": "```\\nint maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        int n = A.size();\\n        if(n == 0 || L+M > n) return 0;\\n        if(L > M) swap(L, M);\\n        \\n        int leftMax = 0, res = 0, right = 0;                \\n        for(int i = n-1; i >= n-L; i--) leftMax += A[i];\\n        for(int i = n-L-1; i >= n-L-M; i--) right += A[i];\\n        int left = leftMax;\\n        res = right+leftMax;\\n        int i = n-L-M, j =  n-L-1;\\n        int l = n-L, r = n-1;\\n        while(i > 0) {\\n            i--;\\n            j--;\\n            l--;\\n            r--;\\n            right = right-A[j+1]+A[i];\\n            left = left+A[l]-A[r+1];\\n            leftMax = max(leftMax, left);\\n            res = max(res, right+leftMax);\\n        }\\n        leftMax = 0, right = 0;                \\n        for(int i = 0; i < L; i++) leftMax += A[i];\\n        for(int i = L; i < L+M; i++) right += A[i];\\n        left = leftMax;\\n        res = max(res, right+leftMax);\\n        i = L, j =  L+M-1;\\n        l = 0, r = L-1;\\n        while(j < n-1) {\\n            i++;\\n            j++;\\n            l++;\\n            r++;\\n            right = right+A[j]-A[i-1];\\n            left = left-A[l-1]+A[r];\\n            leftMax = max(leftMax, left);\\n            res = max(res, right+leftMax);\\n        }\\n        return res;\\n    }  \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 678868,
                "title": "java-simple-two-pass",
                "content": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        \\n        int n = A.length;\\n        for(int i = 1 ; i < n ; i++)\\n            A[i] += A[i-1];\\n        \\n        int res = 0;\\n        \\n        int l_max = A[L-1];\\n        int m_max = A[M-1];\\n        \\n        for(int i = L ; i + M - 1 < n ; i++) {\\n            res = Math.max(res, l_max + A[i+M-1] - A[i-1]);\\n            l_max = Math.max(l_max, A[i] - A[i-L]);\\n        }\\n        \\n        l_max = A[L-1];\\n        m_max = A[M-1];\\n        \\n        for(int i = M ; i + L - 1 < n ; i++) {\\n            res = Math.max(res, m_max + A[i+L-1] - A[i-1]);\\n            m_max = Math.max(m_max, A[i] - A[i-M]);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\nRef https://leetcode.com/problems/maximum-sum-of-two-non-overlapping-subarrays/discuss/279433/Java-Two-pass",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        \\n        int n = A.length;\\n        for(int i = 1 ; i < n ; i++)\\n            A[i] += A[i-1];\\n        \\n        int res = 0;\\n        \\n        int l_max = A[L-1];\\n        int m_max = A[M-1];\\n        \\n        for(int i = L ; i + M - 1 < n ; i++) {\\n            res = Math.max(res, l_max + A[i+M-1] - A[i-1]);\\n            l_max = Math.max(l_max, A[i] - A[i-L]);\\n        }\\n        \\n        l_max = A[L-1];\\n        m_max = A[M-1];\\n        \\n        for(int i = M ; i + L - 1 < n ; i++) {\\n            res = Math.max(res, m_max + A[i+L-1] - A[i-1]);\\n            m_max = Math.max(m_max, A[i] - A[i-M]);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 613723,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        return Math.max (calculate(A, L, M), calculate(A, M, L));\\n    }\\n    \\n    public int calculate(int[] A, int L, int M) {\\n        \\n        int[] left = new int[A.length+1];\\n        int[] right = new int[A.length+1];\\n        int res = 0;\\n        \\n        int sum_l =0, sum_r=0;\\n        for(int i=0,j=A.length-1;i<A.length;i++,j--) {\\n            \\n            sum_l += A[i];\\n            sum_r += A[j];\\n            \\n            left[i+1] = Math.max(left[i], sum_l);\\n            right[j] = Math.max(right[j+1], sum_r);\\n            \\n            if(i+1 >= L)\\n                sum_l -= A[i+1-L];\\n            if(i+1 >= M)\\n                sum_r  -= A[j+M-1];\\n            \\n        }\\n        \\n        for(int i=1;i<A.length;i++) {\\n            \\n            res = Math.max(res, left[i]+right[i]);\\n        }\\n        return res;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        return Math.max (calculate(A, L, M), calculate(A, M, L));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 600728,
                "title": "python-3-o-n-solution-with-clear-comments",
                "content": "```\\nclass Solution:\\n    \\'\\'\\'\\n    L length subarray. Suppose it starts at index i. Then it ends at index i + L - 1\\n    prefixSum[i + L - 1] - prefixSum[i] + A[i] gives the sum of L subarray\\n    \\n    DP1[i] := maximum sum of M subarray to the right of i (including i)\\n    DP1[i] := max(A[i:i+M], DP1[i+1])\\n    \\n    DP2[i] := maximum sum of M subarray to the left of i (including i)\\n    DP2[i] := max(sum(A[i-M+1:i+1]), DP2[i-1])\\n\\n    A[i:i+M] = prefixSum[i + M - 1] - prefixSum[i] + A[i]\\n    A[i-M+1:i+1] = prefixSum[i] - prefixSum[i - M + 1] + A[i - M + 1]\\n    \\n    DP1[i] => 0 <= i <= len(A) - M\\n    DP2[i] => M - 1 <= i <= len(A) - 1\\n    \\n    Base cases:\\n    DP1[len(A) - M] = prefixSum[len(A) - 1] - prefixSum[len(A) - M] + A[len(A) - M]\\n    DP2[M - 1] = prefixSum[M - 1]\\n    \\n    \\'\\'\\'\\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n        prefixSum = []\\n        total = 0\\n        maxSum = float(\\'-inf\\')\\n        DP1, DP2 = {}, {}\\n        \\n        for i in range(len(A)):\\n            total += A[i]\\n            prefixSum.append(total)\\n        \\n        DP1[len(A) - M] = prefixSum[len(A) - 1] - prefixSum[len(A) - M] + A[len(A) - M]\\n        DP2[M - 1] = prefixSum[M - 1]\\n        \\n        for i in range(len(A) - M - 1, -1, -1):\\n            DP1[i] = max(DP1[i + 1], prefixSum[i + M - 1] - prefixSum[i] + A[i])\\n            \\n        for i in range(M, len(A)):\\n            DP2[i] = max(DP2[i - 1], prefixSum[i] - prefixSum[i - M + 1] + A[i - M + 1])\\n            \\n        \\n        for i in range(len(A) - L + 1):\\n            L_sum = prefixSum[i + L - 1] - prefixSum[i] + A[i]\\n            right = DP1[i + L] if i + L in DP1 else float(\\'-inf\\')\\n            left = DP2[i - 1] if i - 1 in DP2 else float(\\'-inf\\')\\n            maxSum = max(maxSum, L_sum + max(left, right))\\n        \\n        return maxSum\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\'\\'\\'\\n    L length subarray. Suppose it starts at index i. Then it ends at index i + L - 1\\n    prefixSum[i + L - 1] - prefixSum[i] + A[i] gives the sum of L subarray\\n    \\n    DP1[i] := maximum sum of M subarray to the right of i (including i)\\n    DP1[i] := max(A[i:i+M], DP1[i+1])\\n    \\n    DP2[i] := maximum sum of M subarray to the left of i (including i)\\n    DP2[i] := max(sum(A[i-M+1:i+1]), DP2[i-1])\\n\\n    A[i:i+M] = prefixSum[i + M - 1] - prefixSum[i] + A[i]\\n    A[i-M+1:i+1] = prefixSum[i] - prefixSum[i - M + 1] + A[i - M + 1]\\n    \\n    DP1[i] => 0 <= i <= len(A) - M\\n    DP2[i] => M - 1 <= i <= len(A) - 1\\n    \\n    Base cases:\\n    DP1[len(A) - M] = prefixSum[len(A) - 1] - prefixSum[len(A) - M] + A[len(A) - M]\\n    DP2[M - 1] = prefixSum[M - 1]\\n    \\n    \\'\\'\\'\\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n        prefixSum = []\\n        total = 0\\n        maxSum = float(\\'-inf\\')\\n        DP1, DP2 = {}, {}\\n        \\n        for i in range(len(A)):\\n            total += A[i]\\n            prefixSum.append(total)\\n        \\n        DP1[len(A) - M] = prefixSum[len(A) - 1] - prefixSum[len(A) - M] + A[len(A) - M]\\n        DP2[M - 1] = prefixSum[M - 1]\\n        \\n        for i in range(len(A) - M - 1, -1, -1):\\n            DP1[i] = max(DP1[i + 1], prefixSum[i + M - 1] - prefixSum[i] + A[i])\\n            \\n        for i in range(M, len(A)):\\n            DP2[i] = max(DP2[i - 1], prefixSum[i] - prefixSum[i - M + 1] + A[i - M + 1])\\n            \\n        \\n        for i in range(len(A) - L + 1):\\n            L_sum = prefixSum[i + L - 1] - prefixSum[i] + A[i]\\n            right = DP1[i + L] if i + L in DP1 else float(\\'-inf\\')\\n            left = DP2[i - 1] if i - 1 in DP2 else float(\\'-inf\\')\\n            maxSum = max(maxSum, L_sum + max(left, right))\\n        \\n        return maxSum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 515807,
                "title": "python-sliding-windows-with-double-ended-queue-o-n-and-commented",
                "content": "The methodology here is to use two sliding windows, one on the left (l) and one on the right (m), to cover the array provided, and keep track of the highest sum under the left window, and the highest sum total. Note that we can\\'t keep track of the highest sum under the right window, because with each slide the left window will take an item from the right window, so if we kept both sum maxes instead of the left sum max and the overall sum max, we could be double dipping.\\n\\nBy the time we\\'ve advanced each window all the way to the right, we\\'ve got the maximum sums for each as if we\\'d stopped advancing each window when it was over the ideal subarray.\\n\\nEach window is represented as a double-ended queue (Python\\'s `deque` implementation under `collections`). Time complexity is O(n) though we run through `A` twice, and space complexity is O(n+l+m) accounting for both the input and the two double-ended queues.\\n\\nFinal important point before we get into the code: **the two windows could appear in either order (l then m or m then l), but our algorithm assumes l is to the left, so we run it twice with l and m switched the second time**.\\n\\nCode time:\\n```\\nfrom collections import deque\\n\\nclass Solution:\\n    def slidingWindows(self, A: List[int], L: int, M: int) -> int:\\n        # Create deques and starting sums for the \\'l\\' and \\'m\\' sliding windows\\n        lQ = deque(maxlen=L)\\n        mQ = deque(maxlen=M)\\n        lSum = 0\\n        mSum = 0\\n        \\n        # Fill deques and sums with their appropriate starter values, l then m\\n        for i in range(L):\\n            lQ.append(A[i])\\n            lSum += A[i]\\n            \\n        for j in range(i+1, i+1+M):\\n            mQ.append(A[j])\\n            mSum += A[j]\\n            \\n        # Slide windows, retaining the max sums for the left (l) deque and overall\\n        maxLSum = lSum\\n        maxOverall = maxLSum + mSum\\n        for k in range(j+1, len(A)):\\n            # Shift the leftmost elem from mQ into lQ and the next elem into mQ\\n            shiftedFromM = mQ.popleft()\\n            shiftedFromL = lQ.popleft()\\n            lQ.append(shiftedFromM)\\n            mQ.append(A[k])\\n            \\n            # Update the deque sums to account for the shifts in and out\\n            lSum = lSum - shiftedFromL + shiftedFromM\\n            mSum = mSum - shiftedFromM + A[k]\\n            \\n            # Update the max sums for the left deque and overall\\n            maxLSum = max(maxLSum, lSum)\\n            maxOverall = max(maxOverall, maxLSum + mSum)\\n            \\n        return maxOverall\\n        \\n        \\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n\\t    # Take the best result of the two possible orders for the l and m windows\\n        return max(self.slidingWindows(A, L, M), self.slidingWindows(A, M, L))\\n```\\n\\n*Creds to [jaithrik\\'s Java solution](https://leetcode.com/problems/maximum-sum-of-two-non-overlapping-subarrays/discuss/465172/O(n)-Deque-solution-2-passes), which inspired mine.*",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def slidingWindows(self, A: List[int], L: int, M: int) -> int:\\n        # Create deques and starting sums for the \\'l\\' and \\'m\\' sliding windows\\n        lQ = deque(maxlen=L)\\n        mQ = deque(maxlen=M)\\n        lSum = 0\\n        mSum = 0\\n        \\n        # Fill deques and sums with their appropriate starter values, l then m\\n        for i in range(L):\\n            lQ.append(A[i])\\n            lSum += A[i]\\n            \\n        for j in range(i+1, i+1+M):\\n            mQ.append(A[j])\\n            mSum += A[j]\\n            \\n        # Slide windows, retaining the max sums for the left (l) deque and overall\\n        maxLSum = lSum\\n        maxOverall = maxLSum + mSum\\n        for k in range(j+1, len(A)):\\n            # Shift the leftmost elem from mQ into lQ and the next elem into mQ\\n            shiftedFromM = mQ.popleft()\\n            shiftedFromL = lQ.popleft()\\n            lQ.append(shiftedFromM)\\n            mQ.append(A[k])\\n            \\n            # Update the deque sums to account for the shifts in and out\\n            lSum = lSum - shiftedFromL + shiftedFromM\\n            mSum = mSum - shiftedFromM + A[k]\\n            \\n            # Update the max sums for the left deque and overall\\n            maxLSum = max(maxLSum, lSum)\\n            maxOverall = max(maxOverall, maxLSum + mSum)\\n            \\n        return maxOverall\\n        \\n        \\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n\\t    # Take the best result of the two possible orders for the l and m windows\\n        return max(self.slidingWindows(A, L, M), self.slidingWindows(A, M, L))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 423018,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        return Math.max(inorderMaxSumTowNoOverlap(A, L, M), inorderMaxSumTowNoOverlap(A, M, L));\\n    }\\n    \\n    private int inorderMaxSumTowNoOverlap(int[] A, int L, int M) {\\n        int sum = 0;\\n        int[] leftSum = new int[A.length], rightSum = new int[A.length];\\n        int[] maxLeftL = new int[A.length], maxRightM = new int[A.length];\\n        \\n        for (int i = 0; i < A.length; i++) {\\n            leftSum[i] = i == 0 ? A[i] : A[i] + leftSum[i - 1];\\n        }\\n        \\n        for (int j = A.length - 1; j >= 0; j--) {\\n            rightSum[j] = j == A.length - 1 ? A[j] : A[j] + rightSum[j + 1];\\n        }\\n        \\n        for (int i = L-1; i < A.length; i++) {\\n            int v = leftSum[i] - (i == L-1 ? 0 : leftSum[i - L]);\\n            maxLeftL[i] = i == 0 ? v : Math.max(maxLeftL[i - 1], v);  \\n        }   \\n        \\n        for (int j = A.length - M; j >= 0; j--) {\\n            int v = rightSum[j] - (j == A.length - M ? 0 : rightSum[j + M]);\\n            maxRightM[j] = j == A.length - 1 ? v : Math.max(maxRightM[j + 1], v);  \\n        }    \\n        \\n        int res = 0;\\n        for (int i = L-1; i < A.length - M; i++) {\\n            res = Math.max(res, maxLeftL[i] + maxRightM[i + 1]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        return Math.max(inorderMaxSumTowNoOverlap(A, L, M), inorderMaxSumTowNoOverlap(A, M, L));\\n    }\\n    \\n    private int inorderMaxSumTowNoOverlap(int[] A, int L, int M) {\\n        int sum = 0;\\n        int[] leftSum = new int[A.length], rightSum = new int[A.length];\\n        int[] maxLeftL = new int[A.length], maxRightM = new int[A.length];\\n        \\n        for (int i = 0; i < A.length; i++) {\\n            leftSum[i] = i == 0 ? A[i] : A[i] + leftSum[i - 1];\\n        }\\n        \\n        for (int j = A.length - 1; j >= 0; j--) {\\n            rightSum[j] = j == A.length - 1 ? A[j] : A[j] + rightSum[j + 1];\\n        }\\n        \\n        for (int i = L-1; i < A.length; i++) {\\n            int v = leftSum[i] - (i == L-1 ? 0 : leftSum[i - L]);\\n            maxLeftL[i] = i == 0 ? v : Math.max(maxLeftL[i - 1], v);  \\n        }   \\n        \\n        for (int j = A.length - M; j >= 0; j--) {\\n            int v = rightSum[j] - (j == A.length - M ? 0 : rightSum[j + M]);\\n            maxRightM[j] = j == A.length - 1 ? v : Math.max(maxRightM[j + 1], v);  \\n        }    \\n        \\n        int res = 0;\\n        for (int i = L-1; i < A.length - M; i++) {\\n            res = Math.max(res, maxLeftL[i] + maxRightM[i + 1]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 354821,
                "title": "cpp-o-n-solution-with-partitial-sums",
                "content": "**Solution 1**\\nThe same idea as in the https://leetcode.com/problems/best-time-to-buy-and-sell-stock/ task. Main idea here is to calculate partitial sums O(n), to get sum on interval in O(1) time. \\n\\nThen we  assume that L-size interval is the first one, store maximal L-size interval sum and calculate result as maximal (maximal L-size interval sum + current right M-size interval sum). Then we do the same trick with M-size interval on the left.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int maxSumTwoNoOverlap(vector<int>& a, int L, int M) {\\n        vector<int> sums(a.size()+1, 0);\\n        partial_sum(a.begin(), a.end(), sums.begin()+1);\\n        \\n        auto get_sum = [&sums](int i, int size) { \\n            if (i < 0) i = sums.size() - 1 + i;\\n            return sums[i+1] - sums[i + 1 - size]; \\n        };\\n    \\n        int result = 0;\\n        int maxleft = 0;\\n        for (int i = L - 1; i < a.size() - M; ++i) {\\n            maxleft = max(maxleft, get_sum(i, L));\\n            if (maxleft + get_sum(i+M, M) > result) {\\n                result = maxleft + get_sum(i+M, M);\\n            }\\n        }\\n        \\n        maxleft = 0;\\n        for (int i = M-1; i < a.size() - L; ++i) {\\n            maxleft = max(maxleft, get_sum(i,M));\\n            if (maxleft + get_sum(i+L,L) > result) {\\n                result = maxleft + get_sum(i+L,L);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int maxSumTwoNoOverlap(vector<int>& a, int L, int M) {\\n        vector<int> sums(a.size()+1, 0);\\n        partial_sum(a.begin(), a.end(), sums.begin()+1);\\n        \\n        auto get_sum = [&sums](int i, int size) { \\n            if (i < 0) i = sums.size() - 1 + i;\\n            return sums[i+1] - sums[i + 1 - size]; \\n        };\\n    \\n        int result = 0;\\n        int maxleft = 0;\\n        for (int i = L - 1; i < a.size() - M; ++i) {\\n            maxleft = max(maxleft, get_sum(i, L));\\n            if (maxleft + get_sum(i+M, M) > result) {\\n                result = maxleft + get_sum(i+M, M);\\n            }\\n        }\\n        \\n        maxleft = 0;\\n        for (int i = M-1; i < a.size() - L; ++i) {\\n            maxleft = max(maxleft, get_sum(i,M));\\n            if (maxleft + get_sum(i+L,L) > result) {\\n                result = maxleft + get_sum(i+L,L);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 279447,
                "title": "c-o-n-solution",
                "content": "class Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        int ans = 0;\\n        int k = 0;\\n        int nums[1005] = {0};\\n        for(int i = 0; i < A.size(); i++){\\n            nums[i+1] = nums[i] + A[i];\\n        }\\n        int length = A.size();\\n        for(int i = M; i + L <= length; i++){\\n            k = max(k, nums[i] - nums[i-M]);\\n            ans = max(ans, k + nums[i+L] - nums[i]);\\n        }\\n        k = 0;\\n        for(int i = L; i + M <= length; i++){\\n            k = max(k, nums[i] - nums[i-L]);\\n            ans = max(ans, k + nums[i+M] - nums[i]); \\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        int ans = 0;\\n        int k = 0;\\n        int nums[1005] = {0}",
                "codeTag": "Java"
            },
            {
                "id": 279207,
                "title": "java-brute-force-while-easy-to-understand",
                "content": "```\\n\\tpublic int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n\\t\\tint N = A.length;\\n\\t\\tint[] sums = new int[N + 1];\\n\\t\\tfor (int i = 1; i <= N; i++) {\\n\\t\\t\\tsums[i] = sums[i - 1] + A[i - 1];\\n\\t\\t}\\n\\t\\tint sumL = 0, sum = 0;\\n\\t\\tfor (int i = 0; i < N + 1 - L; ++i) {\\n\\t\\t\\tsumL = sums[i + L] - sums[i];\\n\\t\\t\\tfor (int j = 0; j < N + 1 - M; ++j) {\\n\\t\\t\\t\\tif (j + M <= i || i + L <= j) {\\n\\t\\t\\t\\t\\tint sumM = sums[j + M] - sums[j];\\n\\t\\t\\t\\t\\tif (sumM + sumL > sum) {\\n\\t\\t\\t\\t\\t\\tsum = sumM + sumL;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn sum;\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n\\t\\tint N = A.length;\\n\\t\\tint[] sums = new int[N + 1];\\n\\t\\tfor (int i = 1; i <= N; i++) {\\n\\t\\t\\tsums[i] = sums[i - 1] + A[i - 1];\\n\\t\\t}\\n\\t\\tint sumL = 0, sum = 0;\\n\\t\\tfor (int i = 0; i < N + 1 - L; ++i) {\\n\\t\\t\\tsumL = sums[i + L] - sums[i];\\n\\t\\t\\tfor (int j = 0; j < N + 1 - M; ++j) {\\n\\t\\t\\t\\tif (j + M <= i || i + L <= j) {\\n\\t\\t\\t\\t\\tint sumM = sums[j + M] - sums[j];\\n\\t\\t\\t\\t\\tif (sumM + sumL > sum) {\\n\\t\\t\\t\\t\\t\\tsum = sumM + sumL;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn sum;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 278710,
                "title": "java-solution-o-n",
                "content": "leftM[i] as of 0..i, the max subarray sum with size M\\nrightM[i], as of N-1...i, the max subarray sum with size M\\n\\nSo, the answer is the maximum of all subarrays with size L plus the max M array before or after it.\\n\\n\\n```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        int N = A.length;\\n        int[] preSum = new int[N + 1];\\n        for (int i = 1; i <= N; i++) {\\n            preSum[i] = preSum[i - 1] + A[i - 1];\\n        }\\n        \\n        int[] leftM = new int[N];\\n        int[] rightM = new int[N];\\n        \\n\\n        int curM = Integer.MIN_VALUE;\\n        for (int i = 0; i < N; i++) {\\n            leftM[i] = Integer.MIN_VALUE;\\n            \\n            if (i >= M - 1) {\\n                leftM[i] = Math.max(curM, preSum[i + 1] - preSum[i + 1 - M]);\\n                curM = Math.max(curM, leftM[i]);\\n            }\\n        }\\n        \\n        curM = Integer.MIN_VALUE;\\n        \\n        for (int i = N - 1; i >= 0; i--) {\\n            rightM[i] = Integer.MIN_VALUE;\\n            \\n            if (i <= N - M) {\\n                rightM[i] = Math.max(curM, preSum[i + M] - preSum[i]);\\n                curM = Math.max(curM, rightM[i]);\\n            }\\n        }\\n        \\n        int res = Integer.MIN_VALUE;\\n        for (int i = L - 1; i < N; i++) {\\n            int tempL = preSum[i + 1] - preSum[i + 1 - L];            \\n            \\n            int pl = i - L;\\n            int pM = pl >= 0 ? leftM[pl] : Integer.MIN_VALUE;\\n            \\n            int nl = i + 1;\\n            int nM = nl < N ? rightM[nl] : Integer.MIN_VALUE;\\n            \\n            res = Math.max(res, Math.max(pM, nM) + tempL);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        int N = A.length;\\n        int[] preSum = new int[N + 1];\\n        for (int i = 1; i <= N; i++) {\\n            preSum[i] = preSum[i - 1] + A[i - 1];\\n        }\\n        \\n        int[] leftM = new int[N];\\n        int[] rightM = new int[N];\\n        \\n\\n        int curM = Integer.MIN_VALUE;\\n        for (int i = 0; i < N; i++) {\\n            leftM[i] = Integer.MIN_VALUE;\\n            \\n            if (i >= M - 1) {\\n                leftM[i] = Math.max(curM, preSum[i + 1] - preSum[i + 1 - M]);\\n                curM = Math.max(curM, leftM[i]);\\n            }\\n        }\\n        \\n        curM = Integer.MIN_VALUE;\\n        \\n        for (int i = N - 1; i >= 0; i--) {\\n            rightM[i] = Integer.MIN_VALUE;\\n            \\n            if (i <= N - M) {\\n                rightM[i] = Math.max(curM, preSum[i + M] - preSum[i]);\\n                curM = Math.max(curM, rightM[i]);\\n            }\\n        }\\n        \\n        int res = Integer.MIN_VALUE;\\n        for (int i = L - 1; i < N; i++) {\\n            int tempL = preSum[i + 1] - preSum[i + 1 - L];            \\n            \\n            int pl = i - L;\\n            int pM = pl >= 0 ? leftM[pl] : Integer.MIN_VALUE;\\n            \\n            int nl = i + 1;\\n            int nM = nl < N ? rightM[nl] : Integer.MIN_VALUE;\\n            \\n            res = Math.max(res, Math.max(pM, nM) + tempL);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454067,
                "title": "o-n-using-prefix-and-dp",
                "content": "# Intuition\\nwhile reading the problem we get two know 2 things->\\n1) subarrays needs to be overlapping , so it means if first subarray ends at ith index, then second subarray can start at i+1 th index.\\n2) occurence of firstLen subarray can be after secondLen subarray.\\n\\n\\nNow as we get to know about these 2 things we can proceed further.\\nconstraints->length of nums<=10^4, so our program time complexity can be only be o(n). By above all conditions I deviced the approach given below\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1) First we build a prefix array called pre. This will save us time to calculate sum of subarray from ith index to jth index.\\n2) Now we make a dp vector, in which ith index gives the maximum subarray of secondLen starting from ith or any other index after ith index. By using this array we can get greatest subbaarray sum of SecondLen after or at a particular index.\\n3) Now we again travese again through nums and starting at evey index i we take sum of firstLen subbarray. Now since we want secondLen subbary which is not overlapping ,it is given by dp[i+firstLen]. we take max sum of both and store it in answer.\\n4) Now as we know firstLen subbarray can occur after seconLen subarray we, again do we process but values of secondLen,firstLen swapped. \\n5)WE GET OUR FINAL ANSWER.\\n\\nNOTE-> we can a make a function which can take nums vector both lengths.\\nwe can do step 3 in that fuction.\\nand for step  we can swap values. This will save a lot of space.\\n\\n\\n# Complexity\\n- Time complexity:\\n- O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- o(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        vector<int>pre;\\n        pre.push_back(0);\\n        for(int i=1;i<=nums.size();i++)\\n          pre.push_back(pre[i-1]+nums[i-1]);\\n          int n=nums.size();\\n          vector<int>dp(n,0);\\n          int m=0;\\n//constructing a dp array to store max subarray of len after or ith index\\n          for(int i=n-secondLen;i>=0;i--)\\n          {\\n              m=max(pre[i+secondLen]-pre[i],m);\\n              dp[i]=m;\\n\\n          }\\n          int ans=0;\\n          for(int i=0;i+firstLen-1<n;i++)\\n          {\\n              if(i+firstLen<=n-secondLen)\\n              {\\n                  ans=max(ans,pre[i+firstLen]-pre[i]+dp[i+firstLen]);\\n                  \\n                  \\n              }\\n\\n          }\\n/* Now we do above process gain with swapped values. This is done firstLen subbarry can come after also*/\\n          vector<int>dp1(n,0);\\n          m=0;\\n           for(int i=n-firstLen;i>=0;i--)\\n          {\\n              m=max(pre[i+firstLen]-pre[i],m);\\n              dp1[i]=m;\\n\\n          }\\n        \\n          for(int i=0;i+secondLen-1<n;i++)\\n          {\\n              if(i+secondLen<=n-firstLen)\\n              {\\n                  ans=max(ans,pre[i+secondLen]-pre[i]+dp1[i+secondLen]);\\n                  \\n                  \\n              }\\n\\n          }\\n      \\n          return(ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        vector<int>pre;\\n        pre.push_back(0);\\n        for(int i=1;i<=nums.size();i++)\\n          pre.push_back(pre[i-1]+nums[i-1]);\\n          int n=nums.size();\\n          vector<int>dp(n,0);\\n          int m=0;\\n//constructing a dp array to store max subarray of len after or ith index\\n          for(int i=n-secondLen;i>=0;i--)\\n          {\\n              m=max(pre[i+secondLen]-pre[i],m);\\n              dp[i]=m;\\n\\n          }\\n          int ans=0;\\n          for(int i=0;i+firstLen-1<n;i++)\\n          {\\n              if(i+firstLen<=n-secondLen)\\n              {\\n                  ans=max(ans,pre[i+firstLen]-pre[i]+dp[i+firstLen]);\\n                  \\n                  \\n              }\\n\\n          }\\n/* Now we do above process gain with swapped values. This is done firstLen subbarry can come after also*/\\n          vector<int>dp1(n,0);\\n          m=0;\\n           for(int i=n-firstLen;i>=0;i--)\\n          {\\n              m=max(pre[i+firstLen]-pre[i],m);\\n              dp1[i]=m;\\n\\n          }\\n        \\n          for(int i=0;i+secondLen-1<n;i++)\\n          {\\n              if(i+secondLen<=n-firstLen)\\n              {\\n                  ans=max(ans,pre[i+secondLen]-pre[i]+dp1[i+secondLen]);\\n                  \\n                  \\n              }\\n\\n          }\\n      \\n          return(ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3416769,
                "title": "sliding-window-brute-force-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        int n = nums.size();\\n        vector<pair<int, int>> first, second;\\n\\n        int s = 0, x = 0, ans1 = 0, ans2 = 0;\\n        for(int i=0; i<n; i++) {\\n            s += nums[i];\\n            if(i - x + 1 == firstLen) first.push_back({s, i}), s -= nums[x++];\\n        }\\n        s = 0, x = 0;\\n        for(int i=0; i<n; i++) {\\n            s += nums[i];\\n            if(i - x + 1 == secondLen) second.push_back({s, i}), s -= nums[x++];\\n        }\\n        \\n        for(int i=0; i<first.size(); i++) {\\n            int val = first[i].first, end = first[i].second;\\n            for(int j=0; j<second.size(); j++) {\\n                if(end < second[j].second - secondLen + 1) ans1 = max(ans1, val + second[j].first);\\n            }\\n        }\\n        for(int i=0; i<second.size(); i++) {\\n            int val = second[i].first, end = second[i].second;\\n            for(int j=0; j<first.size(); j++) {\\n                if(end < first[j].second - firstLen + 1) ans2 = max(ans2, val + first[j].first);\\n            }\\n        }\\n        return max(ans1, ans2);\\n    }\\n    // (0,0) (6,1) (5,2) (2,3) (2,4) (5,5) (1,6) (9,7) (4,8)\\n    // (6,1) (11,2) (7,3) (4,4) (7,5) (6,6) (10,7) (13,8)\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        int n = nums.size();\\n        vector<pair<int, int>> first, second;\\n\\n        int s = 0, x = 0, ans1 = 0, ans2 = 0;\\n        for(int i=0; i<n; i++) {\\n            s += nums[i];\\n            if(i - x + 1 == firstLen) first.push_back({s, i}), s -= nums[x++];\\n        }\\n        s = 0, x = 0;\\n        for(int i=0; i<n; i++) {\\n            s += nums[i];\\n            if(i - x + 1 == secondLen) second.push_back({s, i}), s -= nums[x++];\\n        }\\n        \\n        for(int i=0; i<first.size(); i++) {\\n            int val = first[i].first, end = first[i].second;\\n            for(int j=0; j<second.size(); j++) {\\n                if(end < second[j].second - secondLen + 1) ans1 = max(ans1, val + second[j].first);\\n            }\\n        }\\n        for(int i=0; i<second.size(); i++) {\\n            int val = second[i].first, end = second[i].second;\\n            for(int j=0; j<first.size(); j++) {\\n                if(end < first[j].second - firstLen + 1) ans2 = max(ans2, val + first[j].first);\\n            }\\n        }\\n        return max(ans1, ans2);\\n    }\\n    // (0,0) (6,1) (5,2) (2,3) (2,4) (5,5) (1,6) (9,7) (4,8)\\n    // (6,1) (11,2) (7,3) (4,4) (7,5) (6,6) (10,7) (13,8)\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3032509,
                "title": "c-brute-force-in-one-go",
                "content": "# Intuition\\nWhen first f length subarray formed then search for second using same s size subarray with maximum sum\\n\\n\\n# Approach\\nBrute Force\\n\\n# Complexity\\n- Time complexity:\\nO(n2)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint solve(vector<int>& nums, int p, int q)\\n{\\n    int k=p;\\n    int sum1=0;\\n    int maxi=0,total=0;\\n    int i=0,j=0;\\n    while(j<nums.size())\\n    {\\n         sum1+=nums[j];\\n         if(j-i+1<k)\\n        {\\n            \\n            j++;\\n        }\\n        else\\n        {\\n            // cout<<j<<\" \";\\n            int smax=0;\\n            int sum2=0;\\n            int x=j+1,y=j+1;\\n            while(y<nums.size())\\n            {\\n                sum2+=nums[y];\\n                if(y-x+1<q)\\n                {\\n                    y++;\\n                }\\n                else\\n                {\\n                    smax=max(smax,sum2);\\n                    sum2-=nums[x];\\n                    x++;\\n                    y++;\\n                }\\n            }\\n            // if(j==0)\\n            maxi=max(maxi,smax+sum1);\\n            sum1-=nums[i];\\n            i++;\\n            j++;\\n        }\\n    }\\n    return maxi;\\n}\\n    int maxSumTwoNoOverlap(vector<int>& nums, int p, int q) {\\n        int ans=solve(nums,p,q);\\n        int sol=solve(nums,q,p);\\n        return max(sol,ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint solve(vector<int>& nums, int p, int q)\\n{\\n    int k=p;\\n    int sum1=0;\\n    int maxi=0,total=0;\\n    int i=0,j=0;\\n    while(j<nums.size())\\n    {\\n         sum1+=nums[j];\\n         if(j-i+1<k)\\n        {\\n            \\n            j++;\\n        }\\n        else\\n        {\\n            // cout<<j<<\" \";\\n            int smax=0;\\n            int sum2=0;\\n            int x=j+1,y=j+1;\\n            while(y<nums.size())\\n            {\\n                sum2+=nums[y];\\n                if(y-x+1<q)\\n                {\\n                    y++;\\n                }\\n                else\\n                {\\n                    smax=max(smax,sum2);\\n                    sum2-=nums[x];\\n                    x++;\\n                    y++;\\n                }\\n            }\\n            // if(j==0)\\n            maxi=max(maxi,smax+sum1);\\n            sum1-=nums[i];\\n            i++;\\n            j++;\\n        }\\n    }\\n    return maxi;\\n}\\n    int maxSumTwoNoOverlap(vector<int>& nums, int p, int q) {\\n        int ans=solve(nums,p,q);\\n        int sol=solve(nums,q,p);\\n        return max(sol,ans);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2769012,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n int n;\\n    vector<int> st;\\n    \\n    void build(vector<int> &nums){\\n        st=vector<int> (2*n,0);\\n        for(int i=n;i<2*n;i++){\\n            st[i]=nums[i-n];\\n        }\\n        for(int i=n-1;i>0;--i){\\n            st[i]=st[i<<1]+st[i<<1|1];\\n        }\\n    }\\n    \\n    int getSum(int l,int r){\\n        int res=0;\\n        for(l+=n,r+=n;l<r;l>>=1,r>>=1){\\n            if(l&1) res+=st[l++];\\n            if(r&1) res+=st[--r];\\n        }\\n        return res;\\n    }\\n    \\n    \\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& nums, int fl, int sl) {\\n        n=nums.size();\\n       \\n        build(nums);\\n        int ans=0;\\n        for(int i=0;i<n-fl;i++){\\n            for(int j=i+fl;j<=n-sl;j++){\\n                ans=max(ans,getSum(i,i+fl)+getSum(j,j+sl));\\n            }\\n        }\\n        swap(fl,sl);\\n        for(int i=0;i<n-fl;i++){\\n            for(int j=i+fl;j<=n-sl;j++){\\n                ans=max(ans,getSum(i,i+fl)+getSum(j,j+sl));\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n int n;\\n    vector<int> st;\\n    \\n    void build(vector<int> &nums){\\n        st=vector<int> (2*n,0);\\n        for(int i=n;i<2*n;i++){\\n            st[i]=nums[i-n];\\n        }\\n        for(int i=n-1;i>0;--i){\\n            st[i]=st[i<<1]+st[i<<1|1];\\n        }\\n    }\\n    \\n    int getSum(int l,int r){\\n        int res=0;\\n        for(l+=n,r+=n;l<r;l>>=1,r>>=1){\\n            if(l&1) res+=st[l++];\\n            if(r&1) res+=st[--r];\\n        }\\n        return res;\\n    }\\n    \\n    \\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& nums, int fl, int sl) {\\n        n=nums.size();\\n       \\n        build(nums);\\n        int ans=0;\\n        for(int i=0;i<n-fl;i++){\\n            for(int j=i+fl;j<=n-sl;j++){\\n                ans=max(ans,getSum(i,i+fl)+getSum(j,j+sl));\\n            }\\n        }\\n        swap(fl,sl);\\n        for(int i=0;i<n-fl;i++){\\n            for(int j=i+fl;j<=n-sl;j++){\\n                ans=max(ans,getSum(i,i+fl)+getSum(j,j+sl));\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2686460,
                "title": "simple-c-solution-using-segment-tree",
                "content": "\\n\\n```\\nclass Solution {\\n    \\n    int n;\\n    vector<int> st;\\n    \\n    void build(vector<int> &nums){\\n        st=vector<int> (2*n,0);\\n        for(int i=n;i<2*n;i++){\\n            st[i]=nums[i-n];\\n        }\\n        for(int i=n-1;i>0;--i){\\n            st[i]=st[i<<1]+st[i<<1|1];\\n        }\\n    }\\n    \\n    int getSum(int l,int r){\\n        int res=0;\\n        for(l+=n,r+=n;l<r;l>>=1,r>>=1){\\n            if(l&1) res+=st[l++];\\n            if(r&1) res+=st[--r];\\n        }\\n        return res;\\n    }\\n    \\n    \\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& nums, int fl, int sl) {\\n        n=nums.size();\\n       \\n        build(nums);\\n        int ans=0;\\n        for(int i=0;i<n-fl;i++){\\n            for(int j=i+fl;j<=n-sl;j++){\\n                ans=max(ans,getSum(i,i+fl)+getSum(j,j+sl));\\n            }\\n        }\\n        swap(fl,sl);\\n        for(int i=0;i<n-fl;i++){\\n            for(int j=i+fl;j<=n-sl;j++){\\n                ans=max(ans,getSum(i,i+fl)+getSum(j,j+sl));\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int n;\\n    vector<int> st;\\n    \\n    void build(vector<int> &nums){\\n        st=vector<int> (2*n,0);\\n        for(int i=n;i<2*n;i++){\\n            st[i]=nums[i-n];\\n        }\\n        for(int i=n-1;i>0;--i){\\n            st[i]=st[i<<1]+st[i<<1|1];\\n        }\\n    }\\n    \\n    int getSum(int l,int r){\\n        int res=0;\\n        for(l+=n,r+=n;l<r;l>>=1,r>>=1){\\n            if(l&1) res+=st[l++];\\n            if(r&1) res+=st[--r];\\n        }\\n        return res;\\n    }\\n    \\n    \\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& nums, int fl, int sl) {\\n        n=nums.size();\\n       \\n        build(nums);\\n        int ans=0;\\n        for(int i=0;i<n-fl;i++){\\n            for(int j=i+fl;j<=n-sl;j++){\\n                ans=max(ans,getSum(i,i+fl)+getSum(j,j+sl));\\n            }\\n        }\\n        swap(fl,sl);\\n        for(int i=0;i<n-fl;i++){\\n            for(int j=i+fl;j<=n-sl;j++){\\n                ans=max(ans,getSum(i,i+fl)+getSum(j,j+sl));\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2654851,
                "title": "super-long-c-solution-very-readable-o-n",
                "content": "```\\nclass Solution {\\npublic:\\nint maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        int n=nums.size();\\n        vector<int> a(n,-1), b(n,-1), c(n+1,-1), d(n+1,-1);\\n        int i=0, j=0, sum=0, len=0, mxSum=0;\\n        while(i<n){\\n            sum+=nums[i]; len++;\\n            if(len>firstLen){ sum-=nums[j++]; len--; }\\n            if(len==firstLen){\\n                mxSum=max(mxSum,sum);\\n            }\\n            a[i]=(len==firstLen)?mxSum:-1;\\n            i++;\\n        }\\n        i=0, j=0, sum=0, len=0, mxSum=0;\\n        while(i<n){\\n            sum+=nums[i]; len++;\\n            if(len>secondLen){ sum-=nums[j++]; len--; }\\n            if(len==secondLen){\\n                mxSum=max(mxSum,sum);\\n            }\\n            b[i]=(len==secondLen)?mxSum:-1;\\n            i++;\\n        }\\n        i=n-1, j=n-1, sum=0, len=0, mxSum=0;\\n        while(i>=0){\\n            sum+=nums[i]; len++;\\n            if(len>firstLen){ sum-=nums[j--]; len--; }\\n            if(len==firstLen){\\n                mxSum=max(mxSum,sum);\\n            }\\n            c[i]=(len==firstLen)?mxSum:-1;\\n            i--;\\n        }\\n        i=n-1, j=n-1, sum=0, len=0, mxSum=0;\\n        while(i>=0){\\n            sum+=nums[i]; len++;\\n            if(len>secondLen){ sum-=nums[j--]; len--; }\\n            if(len==secondLen){\\n                mxSum=max(mxSum,sum);\\n            }\\n            d[i]=(len==secondLen)?mxSum:-1;\\n            i--;\\n        }\\n\\n\\t\\tint ans=0;\\n        for(int i=0; i<n; i++){\\n            if(a[i]!=-1 && d[i+1]!=-1){ ans=max(ans,a[i]+d[i+1]); }\\n            if(b[i]!=-1 && c[i+1]!=-1){ ans=max(ans,b[i]+c[i+1]); }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        int n=nums.size();\\n        vector<int> a(n,-1), b(n,-1), c(n+1,-1), d(n+1,-1);\\n        int i=0, j=0, sum=0, len=0, mxSum=0;\\n        while(i<n){\\n            sum+=nums[i]; len++;\\n            if(len>firstLen){ sum-=nums[j++]; len--; }\\n            if(len==firstLen){\\n                mxSum=max(mxSum,sum);\\n            }\\n            a[i]=(len==firstLen)?mxSum:-1;\\n            i++;\\n        }\\n        i=0, j=0, sum=0, len=0, mxSum=0;\\n        while(i<n){\\n            sum+=nums[i]; len++;\\n            if(len>secondLen){ sum-=nums[j++]; len--; }\\n            if(len==secondLen){\\n                mxSum=max(mxSum,sum);\\n            }\\n            b[i]=(len==secondLen)?mxSum:-1;\\n            i++;\\n        }\\n        i=n-1, j=n-1, sum=0, len=0, mxSum=0;\\n        while(i>=0){\\n            sum+=nums[i]; len++;\\n            if(len>firstLen){ sum-=nums[j--]; len--; }\\n            if(len==firstLen){\\n                mxSum=max(mxSum,sum);\\n            }\\n            c[i]=(len==firstLen)?mxSum:-1;\\n            i--;\\n        }\\n        i=n-1, j=n-1, sum=0, len=0, mxSum=0;\\n        while(i>=0){\\n            sum+=nums[i]; len++;\\n            if(len>secondLen){ sum-=nums[j--]; len--; }\\n            if(len==secondLen){\\n                mxSum=max(mxSum,sum);\\n            }\\n            d[i]=(len==secondLen)?mxSum:-1;\\n            i--;\\n        }\\n\\n\\t\\tint ans=0;\\n        for(int i=0; i<n; i++){\\n            if(a[i]!=-1 && d[i+1]!=-1){ ans=max(ans,a[i]+d[i+1]); }\\n            if(b[i]!=-1 && c[i+1]!=-1){ ans=max(ans,b[i]+c[i+1]); }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2640066,
                "title": "sliding-window-prefix-sum-python3-solution-o-1-space",
                "content": "```\\nclass Solution:\\n    # O(n^2) time,\\n    # O(1) space,\\n    # Approach: prefix sum\\n    def maxSumTwoNoOverlap(self, nums: List[int], firstLen: int, secondLen: int) -> int:\\n        n = len(nums)\\n        max_sum = 0\\n        \\n        for i in range(1, n):\\n            nums[i] += nums[i-1]\\n            \\n        def findSubarraySum(l: int, r: int) -> int:\\n            if l == 0:\\n                return nums[r]\\n            \\n            return nums[r] - nums[l-1]\\n        \\n        for i in range(0, n-firstLen+1):\\n            first_tot = findSubarraySum(i, i+firstLen-1)\\n            for j in range(0, i-secondLen+1):\\n                second_tot = findSubarraySum(j, j+secondLen-1)\\n                max_sum = max(max_sum, second_tot + first_tot)\\n                \\n            for j in range(i+firstLen, n-secondLen+1):\\n                second_tot = findSubarraySum(j, j+secondLen-1)\\n                max_sum = max(max_sum, second_tot + first_tot)\\n                \\n        return max_sum\\n```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    # O(n^2) time,\\n    # O(1) space,\\n    # Approach: prefix sum\\n    def maxSumTwoNoOverlap(self, nums: List[int], firstLen: int, secondLen: int) -> int:\\n        n = len(nums)\\n        max_sum = 0\\n        \\n        for i in range(1, n):\\n            nums[i] += nums[i-1]\\n            \\n        def findSubarraySum(l: int, r: int) -> int:\\n            if l == 0:\\n                return nums[r]\\n            \\n            return nums[r] - nums[l-1]\\n        \\n        for i in range(0, n-firstLen+1):\\n            first_tot = findSubarraySum(i, i+firstLen-1)\\n            for j in range(0, i-secondLen+1):\\n                second_tot = findSubarraySum(j, j+secondLen-1)\\n                max_sum = max(max_sum, second_tot + first_tot)\\n                \\n            for j in range(i+firstLen, n-secondLen+1):\\n                second_tot = findSubarraySum(j, j+secondLen-1)\\n                max_sum = max(max_sum, second_tot + first_tot)\\n                \\n        return max_sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2449594,
                "title": "1031-maximum-sum-of-two-non-overlapping-subarrays-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        \\n        \\n        vector<int>prefix(nums.size(),0);\\n        int temp = 0;\\n        for(int i = 0 ; i < firstLen ; i++)\\n            temp+=nums[i];\\n        \\n        prefix[firstLen-1] = temp;\\n        int  k = 0;\\n        int curr_max = temp;\\n        int idx1 = firstLen -1;\\n      \\n        for(int i = firstLen ; i < nums.size() ; i++ ){\\n            int temp_sum = prefix[i-1] +  nums[i] - nums[k++];\\n            if(curr_max < temp_sum){\\n                curr_max = temp_sum;\\n                idx1 = i;\\n            }\\n            \\n            prefix[i] =  temp_sum;\\n        }\\n   \\n        //second part\\n        reverse(nums.begin(),nums.end());\\n        vector<int>prefix2(nums.size(),0);\\n        temp = 0;\\n        for(int i = 0 ; i < secondLen ; i++)\\n            temp+=nums[i];\\n        \\n        prefix2[secondLen-1] = temp;\\n        k = 0;\\n        int curr_max2 = temp;\\n        int idx2 = firstLen -1;\\n        \\n        \\n        for(int i = secondLen ; i < nums.size() ; i++ ){\\n            int temp_sum = prefix2[i-1] +  nums[i] - nums[k++];\\n            if(curr_max2< temp_sum ){\\n                curr_max2 = temp_sum;\\n                idx2 = i;\\n            }\\n            prefix2[i] =  temp_sum;\\n        }\\n        \\n        //main logic\\n        reverse(prefix2.begin(),prefix2.end());\\n        int cur=0;\\n        int res=0;\\n        for(int i=firstLen-1;i<nums.size();i++){\\n            for(int j=0;j<=i-firstLen-secondLen+1;j++){\\n                cur=prefix[i]+prefix2[j];\\n                if(cur>res){\\n                    res=cur;\\n                 }\\n            }\\n            for(int j=i+1;j<nums.size();j++){\\n                cur=prefix[i]+prefix2[j];\\n                if(cur>res){\\n                    res=cur;\\n                }\\n            }\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        \\n        \\n        vector<int>prefix(nums.size(),0);\\n        int temp = 0;\\n        for(int i = 0 ; i < firstLen ; i++)\\n            temp+=nums[i];\\n        \\n        prefix[firstLen-1] = temp;\\n        int  k = 0;\\n        int curr_max = temp;\\n        int idx1 = firstLen -1;\\n      \\n        for(int i = firstLen ; i < nums.size() ; i++ ){\\n            int temp_sum = prefix[i-1] +  nums[i] - nums[k++];\\n            if(curr_max < temp_sum){\\n                curr_max = temp_sum;\\n                idx1 = i;\\n            }\\n            \\n            prefix[i] =  temp_sum;\\n        }\\n   \\n        //second part\\n        reverse(nums.begin(),nums.end());\\n        vector<int>prefix2(nums.size(),0);\\n        temp = 0;\\n        for(int i = 0 ; i < secondLen ; i++)\\n            temp+=nums[i];\\n        \\n        prefix2[secondLen-1] = temp;\\n        k = 0;\\n        int curr_max2 = temp;\\n        int idx2 = firstLen -1;\\n        \\n        \\n        for(int i = secondLen ; i < nums.size() ; i++ ){\\n            int temp_sum = prefix2[i-1] +  nums[i] - nums[k++];\\n            if(curr_max2< temp_sum ){\\n                curr_max2 = temp_sum;\\n                idx2 = i;\\n            }\\n            prefix2[i] =  temp_sum;\\n        }\\n        \\n        //main logic\\n        reverse(prefix2.begin(),prefix2.end());\\n        int cur=0;\\n        int res=0;\\n        for(int i=firstLen-1;i<nums.size();i++){\\n            for(int j=0;j<=i-firstLen-secondLen+1;j++){\\n                cur=prefix[i]+prefix2[j];\\n                if(cur>res){\\n                    res=cur;\\n                 }\\n            }\\n            for(int j=i+1;j<nums.size();j++){\\n                cur=prefix[i]+prefix2[j];\\n                if(cur>res){\\n                    res=cur;\\n                }\\n            }\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2448562,
                "title": "java-leftmax-and-rightmax-array-approach-clean-code-5-m-s",
                "content": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] nums, int firstLen, int secondLen) {\\n        int max1 = getMax(nums,firstLen,secondLen);\\n        int max2 = getMax(nums,secondLen,firstLen);\\n        return Math.max(max1,max2);\\n    }\\n    \\n    public int getMax(int[]nums,int fl,int sl){\\n        int []left = new int[nums.length];\\n        int sum = 0;\\n        for(int i=0;i<nums.length;i++){\\n            sum += nums[i];\\n            \\n            if(i == fl - 1){\\n                left[i] = sum;\\n            }else if(i >= fl){\\n                sum -=  nums[i - fl];\\n                left[i] = Math.max(sum,left[i-1]);\\n            }\\n        }\\n        \\n        int[]right = new int[nums.length];\\n        sum = 0;\\n        for(int i=nums.length-1;i>=0;i--){\\n            sum += nums[i];\\n             \\n            if(i == nums.length - sl){\\n                right[i] = sum;\\n            }else if(i <= nums.length - sl){\\n                sum -= nums[i + sl];\\n                right[i] = Math.max(sum,right[i+1]);\\n            }\\n        }\\n        \\n        \\n        int max = Integer.MIN_VALUE;\\n        for(int i=fl-1;i<nums.length-sl;i++){\\n            max = Math.max(max,left[i] + right[i+1]);\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] nums, int firstLen, int secondLen) {\\n        int max1 = getMax(nums,firstLen,secondLen);\\n        int max2 = getMax(nums,secondLen,firstLen);\\n        return Math.max(max1,max2);\\n    }\\n    \\n    public int getMax(int[]nums,int fl,int sl){\\n        int []left = new int[nums.length];\\n        int sum = 0;\\n        for(int i=0;i<nums.length;i++){\\n            sum += nums[i];\\n            \\n            if(i == fl - 1){\\n                left[i] = sum;\\n            }else if(i >= fl){\\n                sum -=  nums[i - fl];\\n                left[i] = Math.max(sum,left[i-1]);\\n            }\\n        }\\n        \\n        int[]right = new int[nums.length];\\n        sum = 0;\\n        for(int i=nums.length-1;i>=0;i--){\\n            sum += nums[i];\\n             \\n            if(i == nums.length - sl){\\n                right[i] = sum;\\n            }else if(i <= nums.length - sl){\\n                sum -= nums[i + sl];\\n                right[i] = Math.max(sum,right[i+1]);\\n            }\\n        }\\n        \\n        \\n        int max = Integer.MIN_VALUE;\\n        for(int i=fl-1;i<nums.length-sl;i++){\\n            max = Math.max(max,left[i] + right[i+1]);\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2426862,
                "title": "java-sliding-window-one-loop-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] nums, int firstLen, int secondLen) {\\n        int firstLeft=0;\\n        int secLeft=0;\\n        int firstRight=0;\\n        int secRight=0;\\n        \\n        for(int i=0;i<Math.max(firstLen,secondLen);i++){\\n            if(i<firstLen){\\n                firstLeft+=nums[i];\\n            }\\n            if(i<secondLen){\\n                secLeft+=nums[i];\\n            }\\n        }\\n        \\n        for(int i=Math.min(firstLen,secondLen);i<secondLen+firstLen;i++){\\n            if(i>=secondLen){\\n                firstRight+=nums[i];\\n            }\\n            if(i>=firstLen){\\n                secRight+=nums[i];\\n            }\\n        }\\n        \\n        int end=firstLen+secondLen;\\n        int res=firstRight+secLeft;\\n        int firstLmax=firstLeft; //max left sum of size firstlen\\n        int secLmax=secLeft;    //max left sum of size seclen\\n        //mainitain running left(firstLeft and  secLeft) sum and max lefts both separatley, since while computing we will use max lefts but to find max we need running ones\\n        \\n        while(end<nums.length){\\n            firstRight+=nums[end]-nums[end-firstLen];\\n            secRight+=nums[end]-nums[end-secondLen];\\n            \\n            \\n            firstLeft=firstLeft+nums[end-secondLen]-nums[end-secondLen-firstLen];\\n            firstLmax=Math.max(firstLmax,firstLeft);\\n            \\n            secLeft=secLeft+nums[end-firstLen]-nums[end-firstLen-secondLen];\\n            secLmax=Math.max(secLeft,secLmax);\\n            \\n            res=Math.max(res,firstLmax+secRight);\\n            res=Math.max(res,secLmax+firstRight);\\n            \\n            end++;\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxSumTwoNoOverlap(int[] nums, int firstLen, int secondLen) {\\n        int firstLeft=0;\\n        int secLeft=0;\\n        int firstRight=0;\\n        int secRight=0;\\n        \\n        for(int i=0;i<Math.max(firstLen,secondLen);i++){\\n            if(i<firstLen){\\n                firstLeft+=nums[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2414686,
                "title": "sliding-window-array-reversal-simple-logic-clean-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int fun(vector<int>& nums, int firstLen, int secondLen){\\n        int sumf = 0;\\n        int maxi = INT_MIN;\\n\\n        for(int i=0; i<firstLen; i++){\\n            sumf += nums[i];\\n        }\\n\\n        for(int i=firstLen; i<nums.size(); i++){\\n            int curr_win_sum = 0;\\n            int j = i;\\n            int val = j + secondLen;\\n            while(j < val && j < nums.size()){\\n                curr_win_sum += nums[j++];\\n            }\\n            maxi = max(maxi, sumf + curr_win_sum);\\n            while(j < nums.size()){\\n                curr_win_sum += nums[j];\\n                curr_win_sum -= nums[j-secondLen];\\n                maxi = max(maxi, sumf + curr_win_sum);\\n                j++;\\n            }\\n            sumf += nums[i];\\n            sumf -= nums[i - firstLen];\\n        }\\n        return maxi;\\n    }\\n    \\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        int f = fun(nums, firstLen, secondLen);\\n        reverse(nums.begin(), nums.end());\\n        int s = fun(nums, firstLen, secondLen);\\n        return max(f, s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int fun(vector<int>& nums, int firstLen, int secondLen){\\n        int sumf = 0;\\n        int maxi = INT_MIN;\\n\\n        for(int i=0; i<firstLen; i++){\\n            sumf += nums[i];\\n        }\\n\\n        for(int i=firstLen; i<nums.size(); i++){\\n            int curr_win_sum = 0;\\n            int j = i;\\n            int val = j + secondLen;\\n            while(j < val && j < nums.size()){\\n                curr_win_sum += nums[j++];\\n            }\\n            maxi = max(maxi, sumf + curr_win_sum);\\n            while(j < nums.size()){\\n                curr_win_sum += nums[j];\\n                curr_win_sum -= nums[j-secondLen];\\n                maxi = max(maxi, sumf + curr_win_sum);\\n                j++;\\n            }\\n            sumf += nums[i];\\n            sumf -= nums[i - firstLen];\\n        }\\n        return maxi;\\n    }\\n    \\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        int f = fun(nums, firstLen, secondLen);\\n        reverse(nums.begin(), nums.end());\\n        int s = fun(nums, firstLen, secondLen);\\n        return max(f, s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2406747,
                "title": "python-similar-to-buy-sell-stock-iii-easy-explaination-o-n",
                "content": "\\tclass Solution:\\n\\t\\tdef maxSumTwoNoOverlap(self, nums: List[int], firstLen: int, secondLen: int) -> int:\\n\\t\\t\\tn=len(nums)\\n\\n\\t\\t\\tdef fir_sum(l,r):\\n\\t\\t\\t\\tfirst_sum=[0]*n #store the maximum prefix sum at an index i of subarray of length firstlen\\n\\t\\t\\t\\tfirst_sum[r]=sum(nums[:r+1])\\n\\t\\t\\t\\tcur_sum=sum(nums[:r+1])\\n\\t\\t\\t\\twhile r<n:\\n\\t\\t\\t\\t\\tr+=1\\n\\t\\t\\t\\t\\tif r<n:\\n\\t\\t\\t\\t\\t\\tcur_sum+=nums[r]-nums[l]\\n\\t\\t\\t\\t\\t\\tfirst_sum[r]=max(first_sum[r-1],cur_sum)\\n\\t\\t\\t\\t\\tl+=1\\n\\t\\t\\t\\treturn first_sum\\n\\n\\t\\t\\tdef second_sum(l,r):\\n\\t\\t\\t\\tsec_sum=[0]*n #store the maximum suffix sum at an index i till i+secondlen\\n\\t\\t\\t\\tsec_sum[l]=sum(nums[l:])\\n\\t\\t\\t\\tcur_sum=sum(nums[l:])\\n\\t\\t\\t\\twhile l>=0:\\n\\t\\t\\t\\t\\tl-=1\\n\\t\\t\\t\\t\\tif l>=0:\\n\\t\\t\\t\\t\\t\\tcur_sum+=nums[l]-nums[r]\\n\\t\\t\\t\\t\\t\\tsec_sum[l]=max(sec_sum[l+1],cur_sum)\\n\\t\\t\\t\\t\\tr-=1\\n\\t\\t\\t\\treturn sec_sum\\n\\n\\t\\t\\tfirst_sum=fir_sum(0,firstLen-1)\\n\\t\\t\\tsec_sum=second_sum(n-secondLen,n-1)\\n\\n\\t\\t\\tmax_val=float(\"-inf\")\\n\\n\\t\\t\\tfor r in range(firstLen-1,n-secondLen):\\n\\t\\t\\t\\tmax_val=max(max_val,first_sum[r]+sec_sum[r+1])\\n\\n\\t\\t\\tfirst_sum=fir_sum(0,secondLen-1)\\n\\t\\t\\tsec_sum=second_sum(n-firstLen,n-1)\\n\\n\\n\\t\\t\\tfor r in range(secondLen-1,n-firstLen):\\n\\t\\t\\t\\tmax_val=max(max_val,first_sum[r]+sec_sum[r+1])\\n\\n\\t\\t\\treturn max_val\\n\\n\\n",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef maxSumTwoNoOverlap(self, nums: List[int], firstLen: int, secondLen: int) -> int:\\n\\t\\t\\tn=len(nums)\\n\\n\\t\\t\\tdef fir_sum(l,r):\\n\\t\\t\\t\\tfirst_sum=[0]*n #store the maximum prefix sum at an index i of subarray of length firstlen\\n\\t\\t\\t\\tfirst_sum[r]=sum(nums[:r+1])\\n\\t\\t\\t\\tcur_sum=sum(nums[:r+1])\\n\\t\\t\\t\\twhile r<n:\\n\\t\\t\\t\\t\\tr+=1\\n\\t\\t\\t\\t\\tif r<n:\\n\\t\\t\\t\\t\\t\\tcur_sum+=nums[r]-nums[l]\\n\\t\\t\\t\\t\\t\\tfirst_sum[r]=max(first_sum[r-1],cur_sum)\\n\\t\\t\\t\\t\\tl+=1\\n\\t\\t\\t\\treturn first_sum\\n\\n\\t\\t\\tdef second_sum(l,r):\\n\\t\\t\\t\\tsec_sum=[0]*n #store the maximum suffix sum at an index i till i+secondlen\\n\\t\\t\\t\\tsec_sum[l]=sum(nums[l:])\\n\\t\\t\\t\\tcur_sum=sum(nums[l:])\\n\\t\\t\\t\\twhile l>=0:\\n\\t\\t\\t\\t\\tl-=1\\n\\t\\t\\t\\t\\tif l>=0:\\n\\t\\t\\t\\t\\t\\tcur_sum+=nums[l]-nums[r]\\n\\t\\t\\t\\t\\t\\tsec_sum[l]=max(sec_sum[l+1],cur_sum)\\n\\t\\t\\t\\t\\tr-=1\\n\\t\\t\\t\\treturn sec_sum\\n\\n\\t\\t\\tfirst_sum=fir_sum(0,firstLen-1)\\n\\t\\t\\tsec_sum=second_sum(n-secondLen,n-1)\\n\\n\\t\\t\\tmax_val=float(\"-inf\")\\n\\n\\t\\t\\tfor r in range(firstLen-1,n-secondLen):\\n\\t\\t\\t\\tmax_val=max(max_val,first_sum[r]+sec_sum[r+1])\\n\\n\\t\\t\\tfirst_sum=fir_sum(0,secondLen-1)\\n\\t\\t\\tsec_sum=second_sum(n-firstLen,n-1)\\n\\n\\n\\t\\t\\tfor r in range(secondLen-1,n-firstLen):\\n\\t\\t\\t\\tmax_val=max(max_val,first_sum[r]+sec_sum[r+1])\\n\\n\\t\\t\\treturn max_val\\n\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 2317955,
                "title": "c-sliding-window-array-partition-easy-to-follow",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        int res=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            // choosing first in left and second in right subarray\\n            int p=fun(nums,0,i,firstLen);// left subarray ( 0 to i-1 ) \\n            int q=fun(nums,i,nums.size(),secondLen);// right subarray ( i to num.length -1)\\n            \\n            // choosing first in right and second in left subarray\\n            int r=fun(nums,0,i,secondLen);// left subarray ( 0 to i-1 )\\n            int s=fun(nums,i,nums.size(),firstLen);// right subarray ( i to num.length -1)\\n            \\n            res=max(res,p+q);// left,right\\n            res=max(res,r+s);// right,left\\n        }\\n        return res;\\n    }\\n    int fun(vector<int>& nums,int i,int j,int len)\\n    {\\n        if(j-i<len)// in-sufficient size\\n            return 0;\\n        \\n        int res=0;\\n        int sum=0;\\n        int k=i;\\n        while(len--)\\n        {\\n            sum+=nums[i];\\n            i++;\\n        }\\n        while(i<j)\\n        {\\n            res=max(res,sum);\\n            sum+=nums[i++];\\n            sum-=nums[k++];\\n        }\\n        res=max(res,sum);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        int res=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            // choosing first in left and second in right subarray\\n            int p=fun(nums,0,i,firstLen);// left subarray ( 0 to i-1 ) \\n            int q=fun(nums,i,nums.size(),secondLen);// right subarray ( i to num.length -1)\\n            \\n            // choosing first in right and second in left subarray\\n            int r=fun(nums,0,i,secondLen);// left subarray ( 0 to i-1 )\\n            int s=fun(nums,i,nums.size(),firstLen);// right subarray ( i to num.length -1)\\n            \\n            res=max(res,p+q);// left,right\\n            res=max(res,r+s);// right,left\\n        }\\n        return res;\\n    }\\n    int fun(vector<int>& nums,int i,int j,int len)\\n    {\\n        if(j-i<len)// in-sufficient size\\n            return 0;\\n        \\n        int res=0;\\n        int sum=0;\\n        int k=i;\\n        while(len--)\\n        {\\n            sum+=nums[i];\\n            i++;\\n        }\\n        while(i<j)\\n        {\\n            res=max(res,sum);\\n            sum+=nums[i++];\\n            sum-=nums[k++];\\n        }\\n        res=max(res,sum);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2286248,
                "title": "c-easy-code-sliding-window-with-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int fan(vector<int>&nums,int A,int B)\\n    {\\n        int n=nums.size();\\n        vector<int>x(n,0),y(n,0);\\n        int sum=0;\\n       for(int i=0;i<n;i++)                 //for initialize dp x left to right with A size window  \\n       {\\n           if(i<A)\\n           {\\n              sum+=nums[i];\\n              x[i]=sum;\\n           } \\n           else\\n           {\\n               sum+=nums[i]-nums[i-A];\\n               x[i]=max(x[i-1],sum);\\n           }\\n       }\\n        sum=0;\\n       for(int i=n-1;i>=0;i--)               //for initialize dp y right to left with B size window\\n        {\\n            if(n-i<=B)\\n            {\\n                sum+=nums[i];\\n                y[i]=sum;\\n            }\\n            else\\n            {\\n               sum+=nums[i]-nums[i+B];\\n               y[i]=max(y[i+1],sum); \\n            }\\n        }\\n        int ans=0,maxj=0;\\n        \\n       for(int j=A-1;j<n-B;j++)             //add the max left dp with max right dp \\n       {\\n            maxj=x[j]+y[j+1];\\n            ans=max(ans,maxj);              //find Maximum sum\\n       }\\n        return ans;\\n    }\\n    \\n    int maxSumTwoNoOverlap(vector<int>& nums, int first, int second)\\n    {\\n       return max(fan(nums,first,second),fan(nums,second,first));\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n    int fan(vector<int>&nums,int A,int B)\\n    {\\n        int n=nums.size();\\n        vector<int>x(n,0),y(n,0);\\n        int sum=0;\\n       for(int i=0;i<n;i++)                 //for initialize dp x left to right with A size window  \\n       {\\n           if(i<A)\\n           {\\n              sum+=nums[i];\\n              x[i]=sum;\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 2239725,
                "title": "c-solution-o-n-n-s-n",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) \\n    {\\n        std::vector<int> sum(nums.begin(), nums.end());\\n        for (int i = 1; i < sum.size(); i++)\\n        {\\n            sum[i] += sum[i - 1];\\n        }\\n        \\n        if (firstLen + secondLen == nums.size())\\n            return sum.back();\\n        \\n        int res = 0;\\n        \\n        for (int i = 0; i <= nums.size() - firstLen - secondLen; i++)\\n        {\\n            for (int j = i + firstLen; j <= nums.size() - secondLen; j++)\\n            {\\n                res = std::max(\\n                    res, \\n                    (sum[i + firstLen - 1] - sum[i] + nums[i]) + (sum[j + secondLen - 1] - sum[j] + nums[j])\\n                );\\n            }\\n        }\\n        \\n        if (firstLen == secondLen)\\n            return res;\\n        \\n        std::swap(firstLen, secondLen);\\n        for (int i = 0; i <= nums.size() - firstLen - secondLen; i++)\\n        {\\n            for (int j = i + firstLen; j <= nums.size() - secondLen; j++)\\n            {\\n                res = std::max(\\n                    res, \\n                    (sum[i + firstLen - 1] - sum[i] + nums[i]) + (sum[j + secondLen - 1] - sum[j] + nums[j])\\n                );\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) \\n    {\\n        std::vector<int> sum(nums.begin(), nums.end());\\n        for (int i = 1; i < sum.size(); i++)\\n        {\\n            sum[i] += sum[i - 1];\\n        }\\n        \\n        if (firstLen + secondLen == nums.size())\\n            return sum.back();\\n        \\n        int res = 0;\\n        \\n        for (int i = 0; i <= nums.size() - firstLen - secondLen; i++)\\n        {\\n            for (int j = i + firstLen; j <= nums.size() - secondLen; j++)\\n            {\\n                res = std::max(\\n                    res, \\n                    (sum[i + firstLen - 1] - sum[i] + nums[i]) + (sum[j + secondLen - 1] - sum[j] + nums[j])\\n                );\\n            }\\n        }\\n        \\n        if (firstLen == secondLen)\\n            return res;\\n        \\n        std::swap(firstLen, secondLen);\\n        for (int i = 0; i <= nums.size() - firstLen - secondLen; i++)\\n        {\\n            for (int j = i + firstLen; j <= nums.size() - secondLen; j++)\\n            {\\n                res = std::max(\\n                    res, \\n                    (sum[i + firstLen - 1] - sum[i] + nums[i]) + (sum[j + secondLen - 1] - sum[j] + nums[j])\\n                );\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2205777,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        vector<int> sumvect;int sum=0;\\n        for(int i=0;i<nums.size();i++)\\n        {sum+=nums[i]; sumvect.push_back(sum);}\\n        if(firstLen+secondLen==nums.size())\\n            return sum;\\n        int res=0;\\n        for(int i=firstLen-1;i<nums.size();i++)\\n        {int temp=0,temp2=0,maxsum=0;\\n            if(i==firstLen-1)\\n                temp=sumvect[i];\\n         else\\n             temp=sumvect[i]-sumvect[i-firstLen];\\n            if(secondLen+firstLen<=i)\\n            {\\n                for(int j=secondLen-1;j<=i-firstLen;j++)\\n                {  if(j==secondLen-1)\\n                temp2=sumvect[j];\\n         else\\n             temp2=sumvect[j]-sumvect[j-secondLen];\\n                 maxsum=max(temp+temp2,maxsum);\\n                }   \\n            }\\n         for(int j=i+secondLen;j<nums.size();j++)\\n         {\\n             if(j-secondLen>=0)\\n                 maxsum=max(maxsum,temp+sumvect[j]-sumvect[j-secondLen]);\\n         }\\n         res=max(maxsum,res);\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "Array",
                    "Dynamic Programming",
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        vector<int> sumvect;int sum=0;\\n        for(int i=0;i<nums.size();i++)\\n        {sum+=nums[i]; sumvect.push_back(sum);}",
                "codeTag": "Java"
            },
            {
                "id": 2161169,
                "title": "c-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        \\n        int n=A.size();\\n        vector<int>first(n-L+1),second(n-M+1);\\n         int k=0,p=0;\\n        int f=n-L+1,s=n-M+1;\\n        int fmaxi = INT_MIN,smaxi = INT_MIN,ind1=0,ind2=0;\\n        if(L==1)\\n        {\\n           first[0]=A[0];\\n            fmaxi = A[0];\\n            k++;\\n        }\\n        if(M==1)\\n        {\\n            second[0]=A[0];\\n            smaxi = A[0];\\n            p++;\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n             A[i]+=A[i-1];\\n            if(i>=(L-1))\\n            {\\n                if((i-L)>=0)\\n                    first[k]= A[i]-A[i-L];\\n                else\\n                    first[k]=A[i];\\n                if(fmaxi <= first[k])\\n                {\\n                    fmaxi = first[k]; \\n                    ind1 = k;\\n                }\\n                k++;\\n            }\\n            if(i>=(M-1))\\n            {\\n                if((i-M)>=0)\\n                    second[p]=A[i]-A[i-M];\\n                else\\n                  second[p]=A[i]; \\n                if(smaxi <= second[p])\\n                {\\n                    smaxi = second[p]; \\n                    ind2 = p;\\n                }\\n                p++;\\n            }            \\n        }\\n        int x=-1,ans=INT_MIN;\\n        for(int i=0;i<(f-M);i++)\\n        {\\n            if(ind2 >= (i+L))\\n            {\\n                    ans = max(ans,smaxi+first[i]);\\n            }\\n            else\\n            {\\n                smaxi=-1;\\n               for(int j=(i+L);j<(n-M+1);j++)\\n                {\\n\\n                    if(smaxi<=second[j])\\n                    {\\n                        smaxi=second[j];\\n                        ind2=j;\\n                    }                   \\n                }\\n                ans = max(ans,smaxi+first[i]);\\n            }\\n        }\\n         for(int i=0;i<(s-L);i++)\\n        {\\n            if(ind1 >= (i+M))\\n            {\\n                    ans = max(ans,fmaxi+second[i]);\\n            }\\n            else\\n            {\\n                fmaxi=-1;\\n               for(int j=(i+M);j<(n-L+1);j++)\\n                {\\n\\n                    if(fmaxi<=first[j])\\n                    {\\n                        fmaxi=first[j];\\n                        ind1=j;\\n                    }                   \\n                }\\n                ans = max(ans,fmaxi+second[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        \\n        int n=A.size();\\n        vector<int>first(n-L+1),second(n-M+1);\\n         int k=0,p=0;\\n        int f=n-L+1,s=n-M+1;\\n        int fmaxi = INT_MIN,smaxi = INT_MIN,ind1=0,ind2=0;\\n        if(L==1)\\n        {\\n           first[0]=A[0];\\n            fmaxi = A[0];\\n            k++;\\n        }\\n        if(M==1)\\n        {\\n            second[0]=A[0];\\n            smaxi = A[0];\\n            p++;\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n             A[i]+=A[i-1];\\n            if(i>=(L-1))\\n            {\\n                if((i-L)>=0)\\n                    first[k]= A[i]-A[i-L];\\n                else\\n                    first[k]=A[i];\\n                if(fmaxi <= first[k])\\n                {\\n                    fmaxi = first[k]; \\n                    ind1 = k;\\n                }\\n                k++;\\n            }\\n            if(i>=(M-1))\\n            {\\n                if((i-M)>=0)\\n                    second[p]=A[i]-A[i-M];\\n                else\\n                  second[p]=A[i]; \\n                if(smaxi <= second[p])\\n                {\\n                    smaxi = second[p]; \\n                    ind2 = p;\\n                }\\n                p++;\\n            }            \\n        }\\n        int x=-1,ans=INT_MIN;\\n        for(int i=0;i<(f-M);i++)\\n        {\\n            if(ind2 >= (i+L))\\n            {\\n                    ans = max(ans,smaxi+first[i]);\\n            }\\n            else\\n            {\\n                smaxi=-1;\\n               for(int j=(i+L);j<(n-M+1);j++)\\n                {\\n\\n                    if(smaxi<=second[j])\\n                    {\\n                        smaxi=second[j];\\n                        ind2=j;\\n                    }                   \\n                }\\n                ans = max(ans,smaxi+first[i]);\\n            }\\n        }\\n         for(int i=0;i<(s-L);i++)\\n        {\\n            if(ind1 >= (i+M))\\n            {\\n                    ans = max(ans,fmaxi+second[i]);\\n            }\\n            else\\n            {\\n                fmaxi=-1;\\n               for(int j=(i+M);j<(n-L+1);j++)\\n                {\\n\\n                    if(fmaxi<=first[j])\\n                    {\\n                        fmaxi=first[j];\\n                        ind1=j;\\n                    }                   \\n                }\\n                ans = max(ans,fmaxi+second[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2156643,
                "title": "easy-one-pass-dp-solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& nums, int l1, int l2) {\\n        int n = nums.size(), res = 0;\\n        vector <int> dp1(n, 0), dp2(n, 0);\\n\\t\\t\\n\\t\\t// dp1[i] stores the maximum sub-array sum of len l1 until i\\n\\t\\t// dp2[i] stores the maximum sub-array sum of len l2 until i\\n        \\n        if(l1 == 1) {\\n            dp1[0] = nums[0];\\n        }\\n        if(l2 == 1) {\\n            dp2[0] = nums[0];\\n        }\\n        \\n        for(int i = 1; i < nums.size(); i++) {\\n            nums[i] += nums[i - 1];\\n            \\n            if(i >= l1 - 1) {\\n                int r1 = nums[i], r2 = (i - l1) >= 0 ? nums[i - l1] : 0;\\n                dp1[i] = max(dp1[i - 1], r1 - r2);\\n            }\\n            \\n            if(i >= l2 - 1) {\\n                int r1 = nums[i], r2 = (i - l2) >= 0 ? nums[i - l2] : 0;\\n                dp2[i] = max(dp2[i - 1], r1 - r2);\\n            }\\n            \\n\\t\\t\\t// Actual answer is max of Case1 and Case2 as shown in the image below:\\n            if(i >= l1 + l2 - 1) {\\n                int m1 = (nums[i] - nums[i - l1]) + dp2[i - l1];\\n                int m2 = (nums[i] - nums[i - l2]) + dp1[i - l2];\\n                \\n                res = max(res, max(m1, m2));\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/45f1248b-75c3-44d9-8b7d-1a1991cf07c9_1655338484.914251.png)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& nums, int l1, int l2) {\\n        int n = nums.size(), res = 0;\\n        vector <int> dp1(n, 0), dp2(n, 0);\\n\\t\\t\\n\\t\\t// dp1[i] stores the maximum sub-array sum of len l1 until i\\n\\t\\t// dp2[i] stores the maximum sub-array sum of len l2 until i\\n        \\n        if(l1 == 1) {\\n            dp1[0] = nums[0];\\n        }\\n        if(l2 == 1) {\\n            dp2[0] = nums[0];\\n        }\\n        \\n        for(int i = 1; i < nums.size(); i++) {\\n            nums[i] += nums[i - 1];\\n            \\n            if(i >= l1 - 1) {\\n                int r1 = nums[i], r2 = (i - l1) >= 0 ? nums[i - l1] : 0;\\n                dp1[i] = max(dp1[i - 1], r1 - r2);\\n            }\\n            \\n            if(i >= l2 - 1) {\\n                int r1 = nums[i], r2 = (i - l2) >= 0 ? nums[i - l2] : 0;\\n                dp2[i] = max(dp2[i - 1], r1 - r2);\\n            }\\n            \\n\\t\\t\\t// Actual answer is max of Case1 and Case2 as shown in the image below:\\n            if(i >= l1 + l2 - 1) {\\n                int m1 = (nums[i] - nums[i - l1]) + dp2[i - l1];\\n                int m2 = (nums[i] - nums[i - l2]) + dp1[i - l2];\\n                \\n                res = max(res, max(m1, m2));\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2109360,
                "title": "c-o-n-2-no-need-to-use-brain-just-for-openning-mind",
                "content": "--[BBBB----------AAA]--\\n----[AAA-----BBBB]-----\\nAAA: means the first part\\nBBBB: means the second part\\nwe can see both two parts and its innner part as a whole subarray\\nso, two cases:\\n1. ... first .... second ...\\n2. ... second .... first ...\\n\\ntime complexity: O(n^2)\\n\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        int n = nums.size();\\n        vector<int> presum(n+1, 0);\\n        for(int i = 1; i <= n; i++){\\n            presum[i] = presum[i-1] + nums[i-1]; // presum[i]: sum of nums[0...i-1]\\n        }\\n        \\n        int ans = 0;\\n        // num[i...j] -- [first...second]\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                if(j - i + 1 >= firstLen + secondLen){\\n                    // sum1 = [i...i+firstLen - 1]  sum2 = [j-secondLen+1...j]\\n                    ans = max(ans, presum[i+firstLen] - presum[i] + presum[j+1] - presum[j-secondLen + 1]);\\n                    ans = max(ans, presum[i+secondLen] - presum[i] + presum[j+1] - presum[j-firstLen + 1]);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\nAnd it\\'s time to learn others\\' O(n) solution",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        int n = nums.size();\\n        vector<int> presum(n+1, 0);\\n        for(int i = 1; i <= n; i++){\\n            presum[i] = presum[i-1] + nums[i-1]; // presum[i]: sum of nums[0...i-1]\\n        }\\n        \\n        int ans = 0;\\n        // num[i...j] -- [first...second]\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                if(j - i + 1 >= firstLen + secondLen){\\n                    // sum1 = [i...i+firstLen - 1]  sum2 = [j-secondLen+1...j]\\n                    ans = max(ans, presum[i+firstLen] - presum[i] + presum[j+1] - presum[j-secondLen + 1]);\\n                    ans = max(ans, presum[i+secondLen] - presum[i] + presum[j+1] - presum[j-firstLen + 1]);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2003024,
                "title": "java-1-ms-beats-95-with-comments",
                "content": "First we\\'ll calculate prefix sum.\\n\\nThen calculate LMax value by considering L at leftmost, M at rightmost and in the next pass vice versa.\\n\\n**By keeping L and M at the ends of the array is what makes the sub-arrays non-overlapping.**\\n\\n```\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        int sums[] = new int[A.length+1];\\n        int maxLval = 0;\\n        int maxRval = 0;\\n        int result = 0;\\n        \\n        for(int i=1;i<=A.length;i++)\\n            sums[i] = A[i-1]+sums[i-1];\\n        \\n        //L is at Leftmost, M is at RightMost\\n        for(int i=L;i<=A.length-M;i++)\\n        {\\n            int currLVal = sums[i]-sums[i-L];\\n            int currMVal = sums[i+M]-sums[i];\\n            maxLval = Math.max(maxLval,currLVal);\\n            result = Math.max(result,currMVal+maxLval);\\n        }\\n\\n        //M is at LeftMost, L is at RightMost\\n        for(int i=M;i<=A.length-L;i++)\\n        {\\n            int currMVal = sums[i]-sums[i-M];\\n            int currLVal = sums[i+L]-sums[i];\\n            maxRval = Math.max(maxRval,currMVal);\\n            result = Math.max(result,currLVal+maxRval);\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        int sums[] = new int[A.length+1];\\n        int maxLval = 0;\\n        int maxRval = 0;\\n        int result = 0;\\n        \\n        for(int i=1;i<=A.length;i++)\\n            sums[i] = A[i-1]+sums[i-1];\\n        \\n        //L is at Leftmost, M is at RightMost\\n        for(int i=L;i<=A.length-M;i++)\\n        {\\n            int currLVal = sums[i]-sums[i-L];\\n            int currMVal = sums[i+M]-sums[i];\\n            maxLval = Math.max(maxLval,currLVal);\\n            result = Math.max(result,currMVal+maxLval);\\n        }\\n\\n        //M is at LeftMost, L is at RightMost\\n        for(int i=M;i<=A.length-L;i++)\\n        {\\n            int currMVal = sums[i]-sums[i-M];\\n            int currLVal = sums[i+L]-sums[i];\\n            maxRval = Math.max(maxRval,currMVal);\\n            result = Math.max(result,currLVal+maxRval);\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1933459,
                "title": "easy-c-83-space",
                "content": "```\\nint maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n    int i,j,result=0,first,second;\\n    cout<<nums.size();\\n    vector<int> nums_sum(nums.size()+1,0);\\n    for(i=0;i<nums.size();++i) nums_sum[i+1] = nums_sum[i]+nums[i];\\n    int n = nums_sum.size();\\n    --firstLen, --secondLen;\\n    for(i=1; i+firstLen+secondLen+1<n ;++i){\\n\\n        first = nums_sum[i+firstLen]-nums_sum[i-1];\\n        second = 0;\\n        for(j=i+firstLen+1;j<n-secondLen;++j)\\n            second = max(second,nums_sum[j+secondLen]-nums_sum[j-1]);\\n        result = max(result, first+second);\\n        \\n        second = nums_sum[i+secondLen]-nums_sum[i-1];\\n        first = 0;\\n        for(j=i+secondLen+1;j<n-firstLen;++j)\\n            first = max(first,nums_sum[j+firstLen]-nums_sum[j-1]);\\n        result = max(result, first+second);\\n    }\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Sliding Window"
                ],
                "code": "```\\nint maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n    int i,j,result=0,first,second;\\n    cout<<nums.size();\\n    vector<int> nums_sum(nums.size()+1,0);\\n    for(i=0;i<nums.size();++i) nums_sum[i+1] = nums_sum[i]+nums[i];\\n    int n = nums_sum.size();\\n    --firstLen, --secondLen;\\n    for(i=1; i+firstLen+secondLen+1<n ;++i){\\n\\n        first = nums_sum[i+firstLen]-nums_sum[i-1];\\n        second = 0;\\n        for(j=i+firstLen+1;j<n-secondLen;++j)\\n            second = max(second,nums_sum[j+secondLen]-nums_sum[j-1]);\\n        result = max(result, first+second);\\n        \\n        second = nums_sum[i+secondLen]-nums_sum[i-1];\\n        first = 0;\\n        for(j=i+secondLen+1;j<n-firstLen;++j)\\n            first = max(first,nums_sum[j+firstLen]-nums_sum[j-1]);\\n        result = max(result, first+second);\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1903590,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Time Complexity : O(N)***\\n* ***Space Complexity : O(N)***\\n\\n```\\n    int helper(vector<int>& nums, int x, int y)\\n    {\\n        int n = nums.size();\\n        \\n        vector<int> dp1(n, 0);\\n        \\n        vector<int> dp2(n, 0);\\n        \\n        int sum = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(i < x)\\n            {\\n                sum += nums[i];\\n                \\n                dp1[i] = sum;\\n            }\\n            else\\n            {\\n                sum += nums[i] - nums[i - x];\\n                \\n                dp1[i] = max(dp1[i - 1], sum);\\n            }\\n        }\\n        \\n        sum = 0;\\n        \\n        for(int i = n - 1; i >= 0; i--)\\n        {\\n            if(i >= n - y)\\n            {\\n                sum += nums[i];\\n                \\n                dp2[i] = sum;\\n            }\\n            else\\n            {\\n                sum += nums[i] - nums[i + y];\\n                \\n                dp2[i] = max(dp2[i + 1], sum);\\n            }\\n        }\\n        \\n        int ans = INT_MIN;\\n        \\n        for(int i = x - 1; i < n - y; i++)\\n        {\\n            ans = max(ans, dp1[i] + dp2[i + 1]);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    int maxSumTwoNoOverlap(vector<int>& nums, int x, int y) {\\n        \\n        int n = nums.size();\\n        \\n        int max1 = helper(nums, x, y);\\n        \\n        int max2 = helper(nums, y, x);\\n        \\n        return max(max1, max2);\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Sliding Window"
                ],
                "code": "```\\n    int helper(vector<int>& nums, int x, int y)\\n    {\\n        int n = nums.size();\\n        \\n        vector<int> dp1(n, 0);\\n        \\n        vector<int> dp2(n, 0);\\n        \\n        int sum = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(i < x)\\n            {\\n                sum += nums[i];\\n                \\n                dp1[i] = sum;\\n            }\\n            else\\n            {\\n                sum += nums[i] - nums[i - x];\\n                \\n                dp1[i] = max(dp1[i - 1], sum);\\n            }\\n        }\\n        \\n        sum = 0;\\n        \\n        for(int i = n - 1; i >= 0; i--)\\n        {\\n            if(i >= n - y)\\n            {\\n                sum += nums[i];\\n                \\n                dp2[i] = sum;\\n            }\\n            else\\n            {\\n                sum += nums[i] - nums[i + y];\\n                \\n                dp2[i] = max(dp2[i + 1], sum);\\n            }\\n        }\\n        \\n        int ans = INT_MIN;\\n        \\n        for(int i = x - 1; i < n - y; i++)\\n        {\\n            ans = max(ans, dp1[i] + dp2[i + 1]);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    int maxSumTwoNoOverlap(vector<int>& nums, int x, int y) {\\n        \\n        int n = nums.size();\\n        \\n        int max1 = helper(nums, x, y);\\n        \\n        int max2 = helper(nums, y, x);\\n        \\n        return max(max1, max2);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1742418,
                "title": "c-concise-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        int len = nums.size();\\n        for (int i = 1; i < len; i++) {\\n            nums[i] += nums[i - 1];\\n        }\\n        int A = getMaxSum(nums, len, firstLen, secondLen);\\n        int B = getMaxSum(nums, len, secondLen, firstLen);\\n        return max(A, B);\\n    }\\n    \\n    int getMaxSum(vector<int> &nums, int &len, int f, int s) {\\n        int maxFirstWindowSum = 0, maxSum = 0;\\n        for (int i = 0; (i + f + s - 1) < len; i++) {\\n            maxFirstWindowSum = max(maxFirstWindowSum, nums[i + f - 1] - (i - 1 >= 0 ? nums[i - 1] : 0));\\n            int secondWindowCurSum = nums[i + f + s - 1] - ((i + f - 1) >= 0 ? nums[i + f - 1] : 0);\\n            maxSum = max(maxSum, maxFirstWindowSum + secondWindowCurSum);\\n        }\\n        return maxSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        int len = nums.size();\\n        for (int i = 1; i < len; i++) {\\n            nums[i] += nums[i - 1];\\n        }\\n        int A = getMaxSum(nums, len, firstLen, secondLen);\\n        int B = getMaxSum(nums, len, secondLen, firstLen);\\n        return max(A, B);\\n    }\\n    \\n    int getMaxSum(vector<int> &nums, int &len, int f, int s) {\\n        int maxFirstWindowSum = 0, maxSum = 0;\\n        for (int i = 0; (i + f + s - 1) < len; i++) {\\n            maxFirstWindowSum = max(maxFirstWindowSum, nums[i + f - 1] - (i - 1 >= 0 ? nums[i - 1] : 0));\\n            int secondWindowCurSum = nums[i + f + s - 1] - ((i + f - 1) >= 0 ? nums[i + f - 1] : 0);\\n            maxSum = max(maxSum, maxFirstWindowSum + secondWindowCurSum);\\n        }\\n        return maxSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1716710,
                "title": "100-faster-solution-with-explaination",
                "content": "```\\nclass Solution {\\npublic:\\n    int checker(vector<int>& nums, int f, int s){\\n        int n=nums.size();\\n        vector<int>dp1(n);\\n        vector<int>dp2(n);\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            if(i<f){\\n                sum+=nums[i];\\n                dp1[i]=sum;\\n            }else{\\n                sum+=nums[i]-nums[i-f];\\n                dp1[i]=max(sum,dp1[i-1]);\\n            }\\n        }\\n        sum=0;\\n        for(int i=n-1;i>=0;i--){\\n            if(i+s>=n){\\n                sum+=nums[i];\\n                dp2[i]=sum;\\n            }else{\\n                sum+=nums[i]-nums[i+s];\\n                dp2[i]=max(sum,dp2[i+1]);\\n            }\\n        }\\n        int ans=0;\\n        for(int i=f-1;i<n-s;i++){\\n            ans=max(ans,dp1[i]+dp2[i+1]);\\n        }\\n        return ans;\\n    }\\n    int maxSumTwoNoOverlap(vector<int>& nums, int f, int s) {\\n        return max(checker(nums,f,s),checker(nums,s,f));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int checker(vector<int>& nums, int f, int s){\\n        int n=nums.size();\\n        vector<int>dp1(n);\\n        vector<int>dp2(n);\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            if(i<f){\\n                sum+=nums[i];\\n                dp1[i]=sum;\\n            }else{\\n                sum+=nums[i]-nums[i-f];\\n                dp1[i]=max(sum,dp1[i-1]);\\n            }\\n        }\\n        sum=0;\\n        for(int i=n-1;i>=0;i--){\\n            if(i+s>=n){\\n                sum+=nums[i];\\n                dp2[i]=sum;\\n            }else{\\n                sum+=nums[i]-nums[i+s];\\n                dp2[i]=max(sum,dp2[i+1]);\\n            }\\n        }\\n        int ans=0;\\n        for(int i=f-1;i<n-s;i++){\\n            ans=max(ans,dp1[i]+dp2[i+1]);\\n        }\\n        return ans;\\n    }\\n    int maxSumTwoNoOverlap(vector<int>& nums, int f, int s) {\\n        return max(checker(nums,f,s),checker(nums,s,f));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1621533,
                "title": "python-simple-time-o-n-space-o-1-84-06",
                "content": "Success\\nRuntime: 48 ms, faster than 84.06% of Python3 online submissions for Maximum Sum of Two Non-Overlapping Subarrays.\\nMemory Usage: 14.4 MB, less than 77.76% of Python3 online submissions for Maximum Sum of Two Non-Overlapping Subarrays.\\n\\n```\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, nums: List[int], firstLen: int, secondLen: int) -> int:\\n        # calculate prefix sum\\n        for i in range(1, len(nums)):\\n            nums[i] += nums[i-1]\\n        \\n        # for simplicity\\n        f,s = firstLen, secondLen\\n        \\n        # initialization: maxfirst, maxsecond, maxtotal\\n        maxf, maxs, maxt = nums[f-1], nums[s-1], nums[f+s-1]\\n        \\n        for i in range(f+s, len(nums)):\\n            # find the maximum subarray of length f\\n            maxf = max(maxf, nums[i-s] - nums[i-s-f])\\n            # find the maximum subarray of length s\\n            maxs = max(maxs, nums[i-f] - nums[i-f-s])\\n            # find the maximum subarray of length f+s\\n            maxt = max(maxt, \\n                      max(maxf + nums[i]-nums[i-s], maxs + nums[i]-nums[i-f]))\\n        return maxt\\n```",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, nums: List[int], firstLen: int, secondLen: int) -> int:\\n        # calculate prefix sum\\n        for i in range(1, len(nums)):\\n            nums[i] += nums[i-1]\\n        \\n        # for simplicity\\n        f,s = firstLen, secondLen\\n        \\n        # initialization: maxfirst, maxsecond, maxtotal\\n        maxf, maxs, maxt = nums[f-1], nums[s-1], nums[f+s-1]\\n        \\n        for i in range(f+s, len(nums)):\\n            # find the maximum subarray of length f\\n            maxf = max(maxf, nums[i-s] - nums[i-s-f])\\n            # find the maximum subarray of length s\\n            maxs = max(maxs, nums[i-f] - nums[i-f-s])\\n            # find the maximum subarray of length f+s\\n            maxt = max(maxt, \\n                      max(maxf + nums[i]-nums[i-s], maxs + nums[i]-nums[i-f]))\\n        return maxt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1586003,
                "title": "using-sliding-window-prefix-sum",
                "content": "```\\n\\nint n=a.size(),sum=0;\\n        int dp1[n],dp2[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i<f){\\n                sum+=a[i];\\n                dp1[i]=sum;\\n            }\\n            else\\n            {\\n                sum+=a[i]-a[i-f];\\n                dp1[i]=max(sum,dp1[i-1]);\\n            }\\n        }\\n        sum=0;\\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(i+s>=n)\\n            {\\n                sum+=a[i];\\n                dp2[i]=sum;\\n            }\\n            else\\n            {\\n                sum+=a[i]-a[i+s];\\n                dp2[i]=max(sum,dp2[i+1]);\\n            }\\n        }\\n        \\n        int ans=INT_MIN;\\n        for(int i=f-1;i<n-s;i++)\\n        {\\n            ans=max(ans,dp1[i]+dp2[i+1]);\\n        }\\n        //Case 2.\\n        sum=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(i<s){\\n                sum+=a[i];\\n                dp1[i]=sum;\\n            }\\n            else\\n            {\\n                sum+=a[i]-a[i-s];\\n                dp1[i]=max(sum,dp1[i-1]);\\n            }\\n        }\\n        sum=0;\\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(i+f>=n)\\n            {\\n                sum+=a[i];\\n                dp2[i]=sum;\\n            }\\n            else\\n            {\\n                sum+=a[i]-a[i+f];\\n                dp2[i]=max(sum,dp2[i+1]);\\n            }\\n        }\\n        \\n        \\n        for(int i=s-1;i<n-f;i++)\\n        {\\n            ans=max(ans,dp1[i]+dp2[i+1]);\\n        }\\n        \\n        return ans;",
                "solutionTags": [],
                "code": "```\\n\\nint n=a.size(),sum=0;\\n        int dp1[n],dp2[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i<f){\\n                sum+=a[i];\\n                dp1[i]=sum;\\n            }\\n            else\\n            {\\n                sum+=a[i]-a[i-f];\\n                dp1[i]=max(sum,dp1[i-1]);\\n            }\\n        }\\n        sum=0;\\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(i+s>=n)\\n            {\\n                sum+=a[i];\\n                dp2[i]=sum;\\n            }\\n            else\\n            {\\n                sum+=a[i]-a[i+s];\\n                dp2[i]=max(sum,dp2[i+1]);\\n            }\\n        }\\n        \\n        int ans=INT_MIN;\\n        for(int i=f-1;i<n-s;i++)\\n        {\\n            ans=max(ans,dp1[i]+dp2[i+1]);\\n        }\\n        //Case 2.\\n        sum=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(i<s){\\n                sum+=a[i];\\n                dp1[i]=sum;\\n            }\\n            else\\n            {\\n                sum+=a[i]-a[i-s];\\n                dp1[i]=max(sum,dp1[i-1]);\\n            }\\n        }\\n        sum=0;\\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(i+f>=n)\\n            {\\n                sum+=a[i];\\n                dp2[i]=sum;\\n            }\\n            else\\n            {\\n                sum+=a[i]-a[i+f];\\n                dp2[i]=max(sum,dp2[i+1]);\\n            }\\n        }\\n        \\n        \\n        for(int i=s-1;i<n-f;i++)\\n        {\\n            ans=max(ans,dp1[i]+dp2[i+1]);\\n        }\\n        \\n        return ans;",
                "codeTag": "Unknown"
            },
            {
                "id": 1443913,
                "title": "python-o-n-beginner-friendly-solution-with-detail-explanation",
                "content": "There\\'re only 2 case:\\n* The First sub-array is on the **left** of the Second sub-array\\n* The First sub-array is on the **right** of the Second sub-array\\n\\nThe idea is to keep track of the maximum of sub_array in the left (from 0 -> i) and in the right (from i to n)\\nFor example: 0  6  5  2  2  5  1  9  4 \\n\\n![image](https://assets.leetcode.com/users/images/e4f01a22-55a0-4855-80ea-c3e9a933dc93_1630762997.5839343.png)\\n\\n\\n\\n* X is on the left of Y\\nResult = **maximum** of (index **i** -> **first_max_left**[i] + **second_max_right**[i+1])\\n* X is on the right of Y\\nResult = **maximum** of (index **i** -> **second_max_left**[i] +  **first_max_right**[i+1])\\n\\n\\n```\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, nums: List[int], firstLen: int, secondLen: int) -> int:\\n        first_max_left = self.sumSubArray(nums, firstLen)\\n        first_max_right = self.sumSubArray(nums, firstLen, reverse=True)\\n        second_max_left = self.sumSubArray(nums, secondLen)\\n        second_max_right = self.sumSubArray(nums, secondLen, reverse=True)\\n        \\n        result = float(\"-inf\")\\n        for i in range(0, len(nums)-1):\\n            result = max(result, first_max_left[i] + second_max_right[i+1], second_max_left[i] + first_max_right[i+1])\\n        return result\\n    \\n    def sumSubArray(self, nums: List[int], k: int, reverse=False):\\n        sum_arr = [float(\"-inf\")] * (k - 1)\\n        arr = nums if not reverse else list(reversed(nums))\\n        cur_sum = sum(arr[:k-1])\\n        max_sum = float(\"-inf\")\\n        i = k - 1\\n        while i < len(arr):\\n            cur_sum += arr[i]\\n            max_sum = max(max_sum, cur_sum)\\n            sum_arr.append(max_sum)\\n            i += 1\\n            cur_sum -= arr[i-k]\\n        return sum_arr if not reverse else list(reversed(sum_arr))\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, nums: List[int], firstLen: int, secondLen: int) -> int:\\n        first_max_left = self.sumSubArray(nums, firstLen)\\n        first_max_right = self.sumSubArray(nums, firstLen, reverse=True)\\n        second_max_left = self.sumSubArray(nums, secondLen)\\n        second_max_right = self.sumSubArray(nums, secondLen, reverse=True)\\n        \\n        result = float(\"-inf\")\\n        for i in range(0, len(nums)-1):\\n            result = max(result, first_max_left[i] + second_max_right[i+1], second_max_left[i] + first_max_right[i+1])\\n        return result\\n    \\n    def sumSubArray(self, nums: List[int], k: int, reverse=False):\\n        sum_arr = [float(\"-inf\")] * (k - 1)\\n        arr = nums if not reverse else list(reversed(nums))\\n        cur_sum = sum(arr[:k-1])\\n        max_sum = float(\"-inf\")\\n        i = k - 1\\n        while i < len(arr):\\n            cur_sum += arr[i]\\n            max_sum = max(max_sum, cur_sum)\\n            sum_arr.append(max_sum)\\n            i += 1\\n            cur_sum -= arr[i-k]\\n        return sum_arr if not reverse else list(reversed(sum_arr))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1440046,
                "title": "c-easy-to-understand-faster-than-100",
                "content": "class Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& nums, int x, int y) {\\n        \\n        int n=nums.size();\\n        \\n        int sum=0;\\n        \\n        vector<int>dp1(n,0);\\n        vector<int>dp2(n,0);\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            if(i<x){\\n                sum+=nums[i];\\n                dp1[i]=sum;\\n            }\\n            \\n            else{\\n                sum+=(nums[i]-nums[i-x]);\\n                dp1[i]=max(dp1[i-1],sum);\\n            }\\n            \\n        }\\n        \\n        sum=0;\\n        \\n        for(int i=n-1;i>=0;i--){\\n            \\n            if(i+y>=n){\\n                sum+=nums[i];\\n                dp2[i]=sum;\\n            }\\n            \\n            else{\\n                sum+=(nums[i]-nums[i+y]);\\n                dp2[i]=max(dp2[i+1],sum);\\n            }\\n            \\n        }\\n        \\n        int maxx1=0;\\n        \\n        for(int i=x-1;i<n-y;i++){\\n            maxx1=max(maxx1,dp1[i]+dp2[i+1]);\\n        }\\n        \\n       \\n        \\n        sum=0;\\n        \\n        vector<int>dp3(n,0);\\n        vector<int>dp4(n,0);\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            if(i<y){\\n                sum+=nums[i];\\n                dp3[i]=sum;\\n            }\\n            \\n            else{\\n                sum+=(nums[i]-nums[i-y]);\\n                dp3[i]=max(dp3[i-1],sum);\\n            }\\n            \\n        }\\n        \\n        sum=0;\\n        \\n        for(int i=n-1;i>=0;i--){\\n            \\n            if(i+x>=n){\\n                sum+=nums[i];\\n                dp4[i]=sum;\\n            }\\n            \\n            else{\\n                sum+=(nums[i]-nums[i+x]);\\n                dp4[i]=max(dp4[i+1],sum);\\n            }\\n            \\n        }\\n        \\n        int maxx2=0;\\n        \\n        for(int i=y-1;i<n-x;i++){\\n            maxx2=max(maxx2,dp3[i]+dp4[i+1]);\\n        }\\n        \\n        return max(maxx1,maxx2);\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& nums, int x, int y) {\\n        \\n        int n=nums.size();\\n        \\n        int sum=0;\\n        \\n        vector<int>dp1(n,0);\\n        vector<int>dp2(n,0);\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            if(i<x){\\n                sum+=nums[i];\\n                dp1[i]=sum;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1439956,
                "title": "c-easy-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& nums, int a, int b){\\n        int n=nums.size();\\n        vector<int>va(n,0),vb(n,0);\\n        //va[i] stores the maximum sum of subarray of size a till index i (from start)\\n        //vb[i] stores the maximum sum of subarray of size b till index i (from end)\\n        //ans will be the maximum of va[i]+vb[i+1]\\n        int sum=0;\\n        for(int i=0;i<a;i++){\\n            sum+=nums[i];\\n        }\\n        va[a-1]=sum;\\n        for(int i=a;i<n;i++){\\n            sum-=nums[i-a];\\n            sum+=nums[i];\\n            va[i]=max(va[i-1],sum);\\n        }\\n        \\n        sum=0;\\n        for(int i=n-1;i>=n-b;i--){\\n            sum+=nums[i];\\n        }\\n        vb[n-b]=sum;\\n        for(int i=n-b-1;i>=0;i--){\\n            sum-=nums[i+b];\\n            sum+=nums[i];\\n            vb[i]=max(vb[i+1],sum);\\n        }\\n        int ans=0;\\n        for(int i=a-1;i<n-b;i++){\\n            ans=max(ans,va[i]+vb[i+1]);\\n        }\\n        return ans;\\n    }\\n    int maxSumTwoNoOverlap(vector<int>& nums, int a, int b) {\\n        int ans=max(solve(nums,a,b),solve(nums,b,a));\\n        return ans; \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& nums, int a, int b){\\n        int n=nums.size();\\n        vector<int>va(n,0),vb(n,0);\\n        //va[i] stores the maximum sum of subarray of size a till index i (from start)\\n        //vb[i] stores the maximum sum of subarray of size b till index i (from end)\\n        //ans will be the maximum of va[i]+vb[i+1]\\n        int sum=0;\\n        for(int i=0;i<a;i++){\\n            sum+=nums[i];\\n        }\\n        va[a-1]=sum;\\n        for(int i=a;i<n;i++){\\n            sum-=nums[i-a];\\n            sum+=nums[i];\\n            va[i]=max(va[i-1],sum);\\n        }\\n        \\n        sum=0;\\n        for(int i=n-1;i>=n-b;i--){\\n            sum+=nums[i];\\n        }\\n        vb[n-b]=sum;\\n        for(int i=n-b-1;i>=0;i--){\\n            sum-=nums[i+b];\\n            sum+=nums[i];\\n            vb[i]=max(vb[i+1],sum);\\n        }\\n        int ans=0;\\n        for(int i=a-1;i<n-b;i++){\\n            ans=max(ans,va[i]+vb[i+1]);\\n        }\\n        return ans;\\n    }\\n    int maxSumTwoNoOverlap(vector<int>& nums, int a, int b) {\\n        int ans=max(solve(nums,a,b),solve(nums,b,a));\\n        return ans; \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1421606,
                "title": "javascript-window-with-comments",
                "content": "*** an outer while loop to find sum of values for firstLen - once that length is found slice the nums array and feed that new array into a nested while loop to find the sum of values for secondLen. Combine those values to find largest sum with no overlap\\n\\n```\\nvar maxSumTwoNoOverlap = function(nums, firstLen, secondLen) {\\n\\n    return helper(nums, firstLen, secondLen);\\n\\n};\\n\\nlet helper = function(nums, firstLen, secondLen){\\n\\n    let outerLeft = 0;\\n    \\n    let outerRight  = 0;\\n    \\n    let outerLoopSum = 0;\\n    \\n    let combinedSum = 0;\\n    \\n    while(outerRight < nums.length){\\n        \\n        outerLoopSum += nums[outerRight];\\n        \\n        if(outerRight - outerLeft + 1 === firstLen){\\n            \\n            let firstNum = nums.slice(0, outerLeft);\\n            let secondNum = nums.slice(outerRight + 1);\\n            let combinedNum = firstNum.concat(secondNum);\\n            \\n            let innerLeft = 0;\\n    \\n            let innerRight = 0;\\n            \\n            let innerLoopSum = 0;\\n            \\n            while(innerRight < combinedNum.length) {\\n                \\n                innerLoopSum += combinedNum[innerRight];\\n                \\n                if(innerRight - innerLeft + 1 === secondLen){\\n                    \\n                    combinedSum = Math.max(combinedSum, outerLoopSum + innerLoopSum);\\n                    \\n                    innerLoopSum-= combinedNum[innerLeft];\\n                    \\n                    innerLeft++;\\n                }\\n                \\n                innerRight++;\\n             }\\n    \\n            outerLoopSum -= nums[outerLeft];\\n            \\n            outerLeft++;\\n        }\\n        outerRight++;\\n    }\\n    \\n    return combinedSum;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar maxSumTwoNoOverlap = function(nums, firstLen, secondLen) {\\n\\n    return helper(nums, firstLen, secondLen);\\n\\n};\\n\\nlet helper = function(nums, firstLen, secondLen){\\n\\n    let outerLeft = 0;\\n    \\n    let outerRight  = 0;\\n    \\n    let outerLoopSum = 0;\\n    \\n    let combinedSum = 0;\\n    \\n    while(outerRight < nums.length){\\n        \\n        outerLoopSum += nums[outerRight];\\n        \\n        if(outerRight - outerLeft + 1 === firstLen){\\n            \\n            let firstNum = nums.slice(0, outerLeft);\\n            let secondNum = nums.slice(outerRight + 1);\\n            let combinedNum = firstNum.concat(secondNum);\\n            \\n            let innerLeft = 0;\\n    \\n            let innerRight = 0;\\n            \\n            let innerLoopSum = 0;\\n            \\n            while(innerRight < combinedNum.length) {\\n                \\n                innerLoopSum += combinedNum[innerRight];\\n                \\n                if(innerRight - innerLeft + 1 === secondLen){\\n                    \\n                    combinedSum = Math.max(combinedSum, outerLoopSum + innerLoopSum);\\n                    \\n                    innerLoopSum-= combinedNum[innerLeft];\\n                    \\n                    innerLeft++;\\n                }\\n                \\n                innerRight++;\\n             }\\n    \\n            outerLoopSum -= nums[outerLeft];\\n            \\n            outerLeft++;\\n        }\\n        outerRight++;\\n    }\\n    \\n    return combinedSum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1309475,
                "title": "c-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(int x1, int x2, int y1, int y2) {\\n  return (x1 >= y1 && x1 <= y2) ||\\n         (x2 >= y1 && x2 <= y2) ||\\n         (y1 >= x1 && y1 <= x2) ||\\n         (y2 >= x1 && y2 <= x2);\\n}\\n    int maxSumTwoNoOverlap(vector<int>& a, int f, int s) {\\n        int n = a.size();\\n        vector<int>pre1(n-f+1 , 0 ) ;\\n        vector<int>pre2(n-s+1 , 0) ; \\n        \\n        int sum = 0;\\n        for(int i = 0; i < f;i++)\\n         sum+=a[i];\\n        pre1[0] = sum;\\n        \\n        // fill the prefix sum\\n        int k = 1 ;\\n        for(int i = f , j = 0 ; i < n ;i++,j++)\\n        {\\n            \\n            pre1[k] = pre1[k-1] + a[i] - a[j];\\n            k++;\\n        }\\n        // fill the prefix array for len second\\n        sum = 0 ; k = 1 ;\\n        for(int i = 0 ; i < s;i++)\\n            sum+=a[i];\\n        pre2[0]  = sum ;\\n        \\n        for(int i = s , j = 0 ; i < n ; i++,j++)\\n        {\\n            \\n            pre2[k] = pre2[k-1] + a[i] - a[j];\\n            k++;\\n        }\\n        \\n        // now iterate in o(n^2)\\n        int ans = 0 ;\\n        for(int i = 0 ; i < pre1.size();i++)\\n        {\\n            int f1 = i ;\\n            int f2 = i + f - 1;\\n            for(int j = 0 ;j < pre2.size() ;j++)\\n            {\\n                int s1 = j ;\\n                int s2 = j + s - 1;\\n                if(check(f1 , f2 , s1 , s2) == false)\\n                {\\n                    int r = pre1[i] + pre2[j];\\n                    ans  =  max(ans , r);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool check(int x1, int x2, int y1, int y2) {\\n  return (x1 >= y1 && x1 <= y2) ||\\n         (x2 >= y1 && x2 <= y2) ||\\n         (y1 >= x1 && y1 <= x2) ||\\n         (y2 >= x1 && y2 <= x2);\\n}",
                "codeTag": "Java"
            },
            {
                "id": 1259484,
                "title": "c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n   \\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n     \\n      int n=A.size();\\n      int pre[n];\\n      pre[0]=A[0];\\n      //prefix sum\\n      for(int i=1;i<n;i++){\\n        pre[i]=pre[i-1]+A[i];\\n      }\\n      int ans=0;\\n      pair<int,int> dp[n];\\n      \\n      \\n      for(int i=0;i<n;i++){\\n        // for each index check left subarrays with len= L and len=M\\n        if(i+1>=L){\\n          if(i+1==L){\\n           dp[i].first= pre[i];\\n            }else{\\n            dp[i].first= pre[i]-pre[i-L];\\n          }\\n          //calculating answer\\n          if(i+1>L){\\n          ans =max(ans, pre[i]-pre[i-L]+ dp[i-L].second);\\n            }\\n        }\\n        \\n        if(i+1>=M){\\n          \\n           if(i+1==M){\\n            dp[i].second= pre[i];\\n            }else{\\n            dp[i].second= pre[i]-pre[i-M];\\n          }\\n          \\n          if(i+1>M){\\n            ans =max( ans,pre[i]-pre[i-M]+ dp[i-M].first);\\n          } \\n        }\\n        \\n        if(i>0){\\n          \\n         dp[i].first= max(dp[i-1].first,dp[i].first);\\n         dp[i].second= max(dp[i-1].second,dp[i].second);\\n        \\n          }\\n        \\n      }\\n      \\n      return ans;\\n      \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n     \\n      int n=A.size();\\n      int pre[n];\\n      pre[0]=A[0];\\n      //prefix sum\\n      for(int i=1;i<n;i++){\\n        pre[i]=pre[i-1]+A[i];\\n      }\\n      int ans=0;\\n      pair<int,int> dp[n];\\n      \\n      \\n      for(int i=0;i<n;i++){\\n        // for each index check left subarrays with len= L and len=M\\n        if(i+1>=L){\\n          if(i+1==L){\\n           dp[i].first= pre[i];\\n            }else{\\n            dp[i].first= pre[i]-pre[i-L];\\n          }\\n          //calculating answer\\n          if(i+1>L){\\n          ans =max(ans, pre[i]-pre[i-L]+ dp[i-L].second);\\n            }\\n        }\\n        \\n        if(i+1>=M){\\n          \\n           if(i+1==M){\\n            dp[i].second= pre[i];\\n            }else{\\n            dp[i].second= pre[i]-pre[i-M];\\n          }\\n          \\n          if(i+1>M){\\n            ans =max( ans,pre[i]-pre[i-M]+ dp[i-M].first);\\n          } \\n        }\\n        \\n        if(i>0){\\n          \\n         dp[i].first= max(dp[i-1].first,dp[i].first);\\n         dp[i].second= max(dp[i-1].second,dp[i].second);\\n        \\n          }\\n        \\n      }\\n      \\n      return ans;\\n      \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186455,
                "title": "c-o-n-complexity",
                "content": "```\\n//we always considering Lmax is left on Mmax in maxsum func.\\n//but in case of maxSumTwoNoOverlap we find the values via interchanging L and M this will help us to calculate the max sum wheater the L-length subarray could occur before or after the M-length subarray.\\n\\n//the initution behind this quetion is little bit of tricky ;)\\n\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        int n=A.size();\\n        vector<int> psum(n+1,0);\\n        for(int i=0;i<n;i++)\\n            psum[i+1]=psum[i]+A[i];\\n        return max(maxsum(psum,L,M),maxsum(psum,M,L) );\\n    }\\n    int maxsum(vector<int>& pre,int L ,int M){\\n        int sumL=0,ans=0;\\n        for(int i=L+M;i<pre.size();i++){\\n            sumL=max(sumL,pre[i-M]-pre[i-L-M]);\\n            ans=max(ans,sumL+pre[i]-pre[i-M]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n//we always considering Lmax is left on Mmax in maxsum func.\\n//but in case of maxSumTwoNoOverlap we find the values via interchanging L and M this will help us to calculate the max sum wheater the L-length subarray could occur before or after the M-length subarray.\\n\\n//the initution behind this quetion is little bit of tricky ;)\\n\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        int n=A.size();\\n        vector<int> psum(n+1,0);\\n        for(int i=0;i<n;i++)\\n            psum[i+1]=psum[i]+A[i];\\n        return max(maxsum(psum,L,M),maxsum(psum,M,L) );\\n    }\\n    int maxsum(vector<int>& pre,int L ,int M){\\n        int sumL=0,ans=0;\\n        for(int i=L+M;i<pre.size();i++){\\n            sumL=max(sumL,pre[i-M]-pre[i-L-M]);\\n            ans=max(ans,sumL+pre[i]-pre[i-M]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1156926,
                "title": "c-recursive-dp-approach",
                "content": "**There is a better iterative solution , But why not try this recursively. Code is lengthy but easy\\nRuntime : 0-4 ms**\\n//Mtaken - true means we\\'ve got a subarray of length m\\n//Ltaken - true means we\\'ve got a subarray of length l\\n```\\nclass Solution {\\npublic:\\n    int dp[1001][2][2];\\n    int solve(vector<int> &ar, int i, bool Ltaken, bool Mtaken, int l, int m) {\\n        if(Ltaken && Mtaken) return 0;\\n\\n        if(i >= ar.size() || i+l >= ar.size() && !Ltaken || i+m >= ar.size() && !Mtaken) return -10e4;\\n\\n        if(dp[i][Ltaken][Mtaken]!=-1) return dp[i][Ltaken][Mtaken];\\n        \\n        if(Ltaken && i+m < ar.size())\\n        return dp[i][Ltaken][Mtaken] = max(solve(ar,i+m+1,Ltaken,true,l,m)+(ar[i+m]-ar[i-1]), solve(ar, i+1, Ltaken,Mtaken,l, m));\\n        else if(Mtaken && i+l < ar.size())\\n        return dp[i][Ltaken][Mtaken] = max(solve(ar,i+l+1,true,Mtaken,l, m)+(ar[i+l]-ar[i-1]), solve(ar, i+1,Ltaken,Mtaken, l, m));\\n        else\\n        return dp[i][Ltaken][Mtaken] = max({\\n            solve(ar, i+l+1,true,Mtaken, l, m)+(ar[i+l]-ar[i-1]),\\n            solve(ar, i+m+1,Ltaken,true, l, m)+(ar[i+m]-ar[i-1]),\\n            solve(ar,i+1,Ltaken,Mtaken,l,m)});\\n    }\\n    \\n    int maxSumTwoNoOverlap(vector<int>& ar, int l, int m) {\\n        vector<int> prefix{0};\\n        int sum=0;\\n        for(int i:ar) sum+=i, prefix.push_back(sum);\\n\\n        memset(dp,-1,sizeof dp);\\n        return solve(prefix,1,false,false,l-1,m-1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1001][2][2];\\n    int solve(vector<int> &ar, int i, bool Ltaken, bool Mtaken, int l, int m) {\\n        if(Ltaken && Mtaken) return 0;\\n\\n        if(i >= ar.size() || i+l >= ar.size() && !Ltaken || i+m >= ar.size() && !Mtaken) return -10e4;\\n\\n        if(dp[i][Ltaken][Mtaken]!=-1) return dp[i][Ltaken][Mtaken];\\n        \\n        if(Ltaken && i+m < ar.size())\\n        return dp[i][Ltaken][Mtaken] = max(solve(ar,i+m+1,Ltaken,true,l,m)+(ar[i+m]-ar[i-1]), solve(ar, i+1, Ltaken,Mtaken,l, m));\\n        else if(Mtaken && i+l < ar.size())\\n        return dp[i][Ltaken][Mtaken] = max(solve(ar,i+l+1,true,Mtaken,l, m)+(ar[i+l]-ar[i-1]), solve(ar, i+1,Ltaken,Mtaken, l, m));\\n        else\\n        return dp[i][Ltaken][Mtaken] = max({\\n            solve(ar, i+l+1,true,Mtaken, l, m)+(ar[i+l]-ar[i-1]),\\n            solve(ar, i+m+1,Ltaken,true, l, m)+(ar[i+m]-ar[i-1]),\\n            solve(ar,i+1,Ltaken,Mtaken,l,m)});\\n    }\\n    \\n    int maxSumTwoNoOverlap(vector<int>& ar, int l, int m) {\\n        vector<int> prefix{0};\\n        int sum=0;\\n        for(int i:ar) sum+=i, prefix.push_back(sum);\\n\\n        memset(dp,-1,sizeof dp);\\n        return solve(prefix,1,false,false,l-1,m-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1085686,
                "title": "c-greedy-algorithm-solution-using-sliding-window",
                "content": "1. Setup a accumulative sum array (accum[i]):\\n - The problem is asking for the maximum sum of two non-overlapping subarray that each has a fixed length. This means we will need to frequently calculate the sum for given range of a subarray.\\nTherefore a accumulative sum array can reduce time complexity when calculating subarray sum, and also, we reuse the input array to store accumulative sum to reduce space complexity.\\n\\n2. Apply L+M-Length Sliding Windows:\\nInitaily, we spilt the sliding window into two subwindow:\\n- \"L -length left window\"\\n- \"M-length right window\"\\n\\n3. Greedy Algoruthm\\nWhen the sliding window run through the \"accum\" array, we always keep track of the maximum sum of left window and add it with the sum of right windows which ends at current index i.\\n\\n- Above operation guarantees left window  with maximum sum doesn\\'t overlapp with right window.\\n- But it only calculates the result in the case of left window size is L.\\n\\n4. Back to Step #2, this time, we swap the window size, that is, left window size is M, right window size is L, to get the result when left window size is M.\\n\\nKeep track of the maximum sum in step #2 & #4 which would is the answer.\\n\\n\\n```\\nfor(int i = 1 ; i < A.size(); i++)\\n            A[i] += A[i - 1];\\n        int L_max = INT_MIN;\\n        int M_max = INT_MIN;\\n        int ret = INT_MIN;\\n        \\n        for(int i = L + M - 1; i < A.size(); i++) {\\n            int L_sum = (i == L + M - 1) ? (A[i - M]) : ( A[i - M] - A[i - L - M]);\\n            L_max = max(L_max, L_sum);\\n            ret = max(ret, L_max + A[i] - A[i - M]);\\n            \\n            int M_sum = (i == L + M - 1) ? (A[i - L]) : ( A[i - L] - A[i - L - M]);\\n            M_max = max(M_max, M_sum);\\n            ret = max(ret, M_max + A[i] - A[i - L]);\\n        }\\n        return ret;\\n```",
                "solutionTags": [],
                "code": "```\\nfor(int i = 1 ; i < A.size(); i++)\\n            A[i] += A[i - 1];\\n        int L_max = INT_MIN;\\n        int M_max = INT_MIN;\\n        int ret = INT_MIN;\\n        \\n        for(int i = L + M - 1; i < A.size(); i++) {\\n            int L_sum = (i == L + M - 1) ? (A[i - M]) : ( A[i - M] - A[i - L - M]);\\n            L_max = max(L_max, L_sum);\\n            ret = max(ret, L_max + A[i] - A[i - M]);\\n            \\n            int M_sum = (i == L + M - 1) ? (A[i - L]) : ( A[i - L] - A[i - L - M]);\\n            M_max = max(M_max, M_sum);\\n            ret = max(ret, M_max + A[i] - A[i - L]);\\n        }\\n        return ret;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1036499,
                "title": "c-dp-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        // DP: let dpl[i] be the maximum sum of length L for the subarray ending at i,\\n        // and dpm[i] be the maximum sum of length M for the subarray ending at index i,\\n        // dp[i] be the maximum sum of considering both L and M for the subarray ending at i.\\n        // We need to calculate dpl and dpm first in order to get dp[i].\\n        int size = A.size();\\n        vector<int> dpl(size + 1, 0), dpm(size + 1, 0), dp(size + 1, 0);\\n        \\n        // calculate dpl\\n        for (int i = L - 1; i < size; ++i)\\n        {\\n            int sum = accumulate(A.begin() + i - L + 1, A.begin() + i + 1, 0);\\n            dpl[i + 1] = sum > dpl[i] ? sum : dpl[i];\\n        }\\n        \\n        // calculate dpm\\n        for (int i = M - 1; i < size; ++i)\\n        {\\n\\n            int sum = accumulate(A.begin() + i - M + 1, A.begin() + i + 1, 0);\\n            dpm[i + 1] = sum > dpm[i] ? sum : dpm[i];\\n        }\\n        \\n        // calculate dp\\n        for (int i = L + M - 1; i < size; ++i)\\n        {\\n            int sum1 = accumulate(A.begin() + i - L + 1, A.begin() + i + 1, 0) + dpm[i - L + 1];\\n            int sum2 = accumulate(A.begin() + i - M + 1, A.begin() + i + 1, 0) + dpl[i - M + 1];\\n            dp[i + 1] = sum1 > sum2 ? sum1 : sum2;\\n            dp[i + 1] = dp[i + 1] > dp[i] ? dp[i + 1] : dp[i];\\n        }\\n        \\n        return dp[size];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        // DP: let dpl[i] be the maximum sum of length L for the subarray ending at i,\\n        // and dpm[i] be the maximum sum of length M for the subarray ending at index i,\\n        // dp[i] be the maximum sum of considering both L and M for the subarray ending at i.\\n        // We need to calculate dpl and dpm first in order to get dp[i].\\n        int size = A.size();\\n        vector<int> dpl(size + 1, 0), dpm(size + 1, 0), dp(size + 1, 0);\\n        \\n        // calculate dpl\\n        for (int i = L - 1; i < size; ++i)\\n        {\\n            int sum = accumulate(A.begin() + i - L + 1, A.begin() + i + 1, 0);\\n            dpl[i + 1] = sum > dpl[i] ? sum : dpl[i];\\n        }\\n        \\n        // calculate dpm\\n        for (int i = M - 1; i < size; ++i)\\n        {\\n\\n            int sum = accumulate(A.begin() + i - M + 1, A.begin() + i + 1, 0);\\n            dpm[i + 1] = sum > dpm[i] ? sum : dpm[i];\\n        }\\n        \\n        // calculate dp\\n        for (int i = L + M - 1; i < size; ++i)\\n        {\\n            int sum1 = accumulate(A.begin() + i - L + 1, A.begin() + i + 1, 0) + dpm[i - L + 1];\\n            int sum2 = accumulate(A.begin() + i - M + 1, A.begin() + i + 1, 0) + dpl[i - M + 1];\\n            dp[i + 1] = sum1 > sum2 ? sum1 : sum2;\\n            dp[i + 1] = dp[i + 1] > dp[i] ? dp[i + 1] : dp[i];\\n        }\\n        \\n        return dp[size];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867712,
                "title": "easy-o-n-js-solution",
                "content": "```\\nvar maxSumTwoNoOverlap = function(A, L, M) {\\n    return Math.max(traverse(L,M), traverse(M,L));\\n    \\n    function traverse(a, b) {\\n        let res = 0;\\n        for (let i = 0; i <= A.length-a-b; i++) {\\n            let sum = A.slice(i,i+a+b).reduce((acc,cur) => acc+cur);\\n            let l = i+a, r = l+b;\\n            res = Math.max(res, sum);\\n            while (r < A.length) {\\n                sum = sum-A[l]+A[r];\\n                res = Math.max(res, sum)\\n                l++, r++;\\n            }\\n        }\\n        return res;\\n    }\\n    // Time Complexity: O(n)\\n    // Space Complexity: O(1)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxSumTwoNoOverlap = function(A, L, M) {\\n    return Math.max(traverse(L,M), traverse(M,L));\\n    \\n    function traverse(a, b) {\\n        let res = 0;\\n        for (let i = 0; i <= A.length-a-b; i++) {\\n            let sum = A.slice(i,i+a+b).reduce((acc,cur) => acc+cur);\\n            let l = i+a, r = l+b;\\n            res = Math.max(res, sum);\\n            while (r < A.length) {\\n                sum = sum-A[l]+A[r];\\n                res = Math.max(res, sum)\\n                l++, r++;\\n            }\\n        }\\n        return res;\\n    }\\n    // Time Complexity: O(n)\\n    // Space Complexity: O(1)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 780707,
                "title": "c-faster-than-99-12-less-then-99-12-mem-o-n",
                "content": "Runtime: 88 ms\\nMemory Usage: 24.4 MB\\n```\\n    public int MaxSumTwoNoOverlap(int[] A, int L, int M) {\\n        \\n        return Math.Max(MaxValue(A, L, M), MaxValue(A, M, L));\\n    }\\n    \\n    private int MaxValue(int[] A, int L, int M)\\n    {\\n        int[] dpL = MaxSumLeftToRight(A, L);\\n        int[] dpM = MaxSumRightToLeft(A, M);\\n        \\n        int result = 0;\\n        \\n        for(int i=L-1; i < A.Length-M; i++)\\n        {\\n            if (result < dpL[i] + dpM[i+1])\\n            {\\n                result = dpL[i] + dpM[i+1];\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private int[] MaxSumLeftToRight(int[] A, int L)\\n    {\\n        int[] dp = new int[A.Length];\\n        int count = 0;\\n        \\n        for(int i=0; i< L-1; i++)\\n        {\\n            count += A[i];            \\n        }\\n        \\n        for(int i=L-1; i < A.Length; i++)\\n        {\\n            count += A[i];\\n            dp[i] = (i>0)? Math.Max(dp[i-1], count): count;\\n            count -= A[i-L+1];            \\n        }\\n        return dp;\\n    }\\n    \\n    private int[] MaxSumRightToLeft(int[] A, int L)\\n    {\\n        int[] dp = new int[A.Length];\\n        int count = 0;\\n        \\n        for(int i=A.Length-1; i > A.Length-L; i--)\\n        {\\n            count += A[i];            \\n        }\\n        \\n        for(int i=A.Length-L; i >=0; i--)\\n        {\\n            count += A[i];\\n            dp[i] = (i < A.Length-1)? Math.Max(dp[i+1], count): count;\\n            count -= A[i+L-1];            \\n        }\\n        return dp;\\n    }",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "Runtime: 88 ms\\nMemory Usage: 24.4 MB\\n```\\n    public int MaxSumTwoNoOverlap(int[] A, int L, int M) {\\n        \\n        return Math.Max(MaxValue(A, L, M), MaxValue(A, M, L));\\n    }\\n    \\n    private int MaxValue(int[] A, int L, int M)\\n    {\\n        int[] dpL = MaxSumLeftToRight(A, L);\\n        int[] dpM = MaxSumRightToLeft(A, M);\\n        \\n        int result = 0;\\n        \\n        for(int i=L-1; i < A.Length-M; i++)\\n        {\\n            if (result < dpL[i] + dpM[i+1])\\n            {\\n                result = dpL[i] + dpM[i+1];\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private int[] MaxSumLeftToRight(int[] A, int L)\\n    {\\n        int[] dp = new int[A.Length];\\n        int count = 0;\\n        \\n        for(int i=0; i< L-1; i++)\\n        {\\n            count += A[i];            \\n        }\\n        \\n        for(int i=L-1; i < A.Length; i++)\\n        {\\n            count += A[i];\\n            dp[i] = (i>0)? Math.Max(dp[i-1], count): count;\\n            count -= A[i-L+1];            \\n        }\\n        return dp;\\n    }\\n    \\n    private int[] MaxSumRightToLeft(int[] A, int L)\\n    {\\n        int[] dp = new int[A.Length];\\n        int count = 0;\\n        \\n        for(int i=A.Length-1; i > A.Length-L; i--)\\n        {\\n            count += A[i];            \\n        }\\n        \\n        for(int i=A.Length-L; i >=0; i--)\\n        {\\n            count += A[i];\\n            dp[i] = (i < A.Length-1)? Math.Max(dp[i+1], count): count;\\n            count -= A[i+L-1];            \\n        }\\n        return dp;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 766097,
                "title": "c-simple-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void f(vector<int>&ll, vector<int>& lr, int L, const vector<int>& sum) {\\n        ll[L-1] = sum[L-1];\\n        for(int i = L;i<sum.size();i++) {\\n            ll[i] = sum[i] - sum[i-L];\\n            ll[i] = max(ll[i],ll[i-1]);\\n        }\\n        lr[sum.size()-L] = sum.back() - ((sum.size()>L)?sum[sum.size()-L-1]:0);\\n        for(int i = sum.size()-L-1;i>=0;i--){\\n            lr[i] = sum[i+L-1] - ((i-1>=0)?sum[i-1]:0);\\n            lr[i] = max(lr[i],lr[i+1]);\\n        }\\n    } \\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        vector<int> sum(A.size(),0);\\n        sum[0] = A[0];\\n        for(int i = 1;i < A.size();i++) {\\n            sum[i] = sum[i-1] + A[i];\\n        }\\n        vector<int> ll(A.size(),0), lr(A.size(),0),ml(A.size(),0),mr(A.size(),0);\\n        f(ll,lr,L,sum);\\n        f(ml,mr,M,sum);\\n        int ret = 0;\\n        for(int i = 0;i<A.size()-1;i++) {\\n            ret = max(ret,ll[i] + mr[i+1]);\\n            ret = max(ret,ml[i] + lr[i+1]);\\n        }\\n        return ret; \\n        \\n       \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void f(vector<int>&ll, vector<int>& lr, int L, const vector<int>& sum) {\\n        ll[L-1] = sum[L-1];\\n        for(int i = L;i<sum.size();i++) {\\n            ll[i] = sum[i] - sum[i-L];\\n            ll[i] = max(ll[i],ll[i-1]);\\n        }\\n        lr[sum.size()-L] = sum.back() - ((sum.size()>L)?sum[sum.size()-L-1]:0);\\n        for(int i = sum.size()-L-1;i>=0;i--){\\n            lr[i] = sum[i+L-1] - ((i-1>=0)?sum[i-1]:0);\\n            lr[i] = max(lr[i],lr[i+1]);\\n        }\\n    } \\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        vector<int> sum(A.size(),0);\\n        sum[0] = A[0];\\n        for(int i = 1;i < A.size();i++) {\\n            sum[i] = sum[i-1] + A[i];\\n        }\\n        vector<int> ll(A.size(),0), lr(A.size(),0),ml(A.size(),0),mr(A.size(),0);\\n        f(ll,lr,L,sum);\\n        f(ml,mr,M,sum);\\n        int ret = 0;\\n        for(int i = 0;i<A.size()-1;i++) {\\n            ret = max(ret,ll[i] + mr[i+1]);\\n            ret = max(ret,ml[i] + lr[i+1]);\\n        }\\n        return ret; \\n        \\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 761119,
                "title": "java-o-n-solution",
                "content": "Solution below uses these steps:\\n1. Calculate the sums for L and M and save them in array\\n2. Find max sum such that max L sum is on the left side and max R sum is on the right side of the orig array\\n3. Find max sum such that max R sum is on the left side and max L sum is on the right side of the orig array\\n\\n```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        // calculate L sums and M sums\\n        int n = A.length, lSum = 0, mSum = 0;\\n        int[] lSumArr = new int[n];\\n        int[] mSumArr = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            lSum += A[i];\\n            if (i == L - 1) {\\n                lSumArr[i] = lSum;\\n            } else if (i >= L) {\\n                lSum -= A[i - L];\\n                lSumArr[i] = lSum;\\n            }\\n            \\n            mSum += A[i];\\n            if (i == M - 1) {\\n                mSumArr[i] = mSum;\\n            } else if (i >= M) {\\n                mSum -= A[i - M];\\n                mSumArr[i] = mSum;\\n            }\\n        }\\n        \\n        // keep a max-stack for M\\n        Deque<Integer> maxStack = new ArrayDeque<>();\\n        for (int i = n - 1; i >= L + M - 1; i--) {\\n            if (maxStack.isEmpty() || maxStack.peekFirst() <= mSumArr[i]) {\\n                maxStack.offerFirst(mSumArr[i]);\\n            }\\n        }\\n        \\n        // L goes left -> right and M goes left <- right\\n        int max = 0, maxL = 0, maxM = 0;\\n        for (int i = L - 1; i < n - M; i++) {\\n            maxL = Math.max(maxL, lSumArr[i]);\\n            maxM = maxStack.peekFirst();\\n            max = Math.max(max, maxL + maxM);\\n            if (mSumArr[i + M] == maxStack.peekFirst()) {\\n                maxStack.pollFirst();\\n            }\\n        }\\n        \\n        // keep a max-stack for L\\n        for (int i = n - 1; i >= L + M - 1; i--) {\\n            if (maxStack.isEmpty() || maxStack.peekFirst() <= lSumArr[i]) {\\n                maxStack.offerFirst(lSumArr[i]);\\n            }\\n        }\\n        \\n        // M goes left -> right and L goes left <- right\\n        maxL = 0;\\n        maxM = 0;\\n        for (int i = M - 1; i < n - L; i++) {\\n            maxL = maxStack.peekFirst();\\n            maxM = Math.max(maxM, mSumArr[i]);\\n            max = Math.max(max, maxL + maxM);\\n            if (lSumArr[i + L] == maxStack.peekFirst()) {\\n                maxStack.pollFirst();\\n            }\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        // calculate L sums and M sums\\n        int n = A.length, lSum = 0, mSum = 0;\\n        int[] lSumArr = new int[n];\\n        int[] mSumArr = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            lSum += A[i];\\n            if (i == L - 1) {\\n                lSumArr[i] = lSum;\\n            } else if (i >= L) {\\n                lSum -= A[i - L];\\n                lSumArr[i] = lSum;\\n            }\\n            \\n            mSum += A[i];\\n            if (i == M - 1) {\\n                mSumArr[i] = mSum;\\n            } else if (i >= M) {\\n                mSum -= A[i - M];\\n                mSumArr[i] = mSum;\\n            }\\n        }\\n        \\n        // keep a max-stack for M\\n        Deque<Integer> maxStack = new ArrayDeque<>();\\n        for (int i = n - 1; i >= L + M - 1; i--) {\\n            if (maxStack.isEmpty() || maxStack.peekFirst() <= mSumArr[i]) {\\n                maxStack.offerFirst(mSumArr[i]);\\n            }\\n        }\\n        \\n        // L goes left -> right and M goes left <- right\\n        int max = 0, maxL = 0, maxM = 0;\\n        for (int i = L - 1; i < n - M; i++) {\\n            maxL = Math.max(maxL, lSumArr[i]);\\n            maxM = maxStack.peekFirst();\\n            max = Math.max(max, maxL + maxM);\\n            if (mSumArr[i + M] == maxStack.peekFirst()) {\\n                maxStack.pollFirst();\\n            }\\n        }\\n        \\n        // keep a max-stack for L\\n        for (int i = n - 1; i >= L + M - 1; i--) {\\n            if (maxStack.isEmpty() || maxStack.peekFirst() <= lSumArr[i]) {\\n                maxStack.offerFirst(lSumArr[i]);\\n            }\\n        }\\n        \\n        // M goes left -> right and L goes left <- right\\n        maxL = 0;\\n        maxM = 0;\\n        for (int i = M - 1; i < n - L; i++) {\\n            maxL = maxStack.peekFirst();\\n            maxM = Math.max(maxM, mSumArr[i]);\\n            max = Math.max(max, maxL + maxM);\\n            if (lSumArr[i + L] == maxStack.peekFirst()) {\\n                maxStack.pollFirst();\\n            }\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 718148,
                "title": "python-brute-force",
                "content": "```\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n        res = float(\\'-inf\\')\\n        \\n        currMaxL, currMaxM = 0, 0\\n        i = 0\\n        max_M_For_CurrL = float(\\'-inf\\')\\n        while i < len(A):\\n            if i >= L:  # if subarray size is bigger than L, slide window to right\\n                currMaxL -= A[i-L] \\n            currMaxL += A[i] # add current item\\n            \\n            j = i - L # start subArray of size M only after considering first L items\\n            if j >= 0:\\n                currMaxM += A[j]\\n            \\n            if j >= M-1: \\n                max_M_For_CurrL = max(max_M_For_CurrL, currMaxM)\\n                currMaxM -= A[j-M+1] # slide window\\n                \\n                res = max(res, currMaxL + max_M_For_CurrL)\\n            \\n            i += 1\\n        \\n        currMaxL, currMaxM = 0, 0\\n        max_L_For_CurrM = float(\\'-inf\\')\\n        i = 0\\n        while i < len(A):\\n            if i >= M:     # if subarray size is bigger than M, slide window to right\\n                currMaxM -= A[i-M]\\n            currMaxM += A[i] # add current item\\n            \\n            j = i - M # start subArray of size L only after considering first M items\\n            if j >= 0:\\n                currMaxL += A[j]\\n            \\n            if j >= L-1: \\n                max_L_For_CurrM = max(max_L_For_CurrM, currMaxL)\\n                currMaxL -= A[j-L+1] # slide window\\n                \\n                res = max(res, currMaxM + max_L_For_CurrM)\\n            \\n            i += 1\\n        \\n        return res\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n        res = float(\\'-inf\\')\\n        \\n        currMaxL, currMaxM = 0, 0\\n        i = 0\\n        max_M_For_CurrL = float(\\'-inf\\')\\n        while i < len(A):\\n            if i >= L:  # if subarray size is bigger than L, slide window to right\\n                currMaxL -= A[i-L] \\n            currMaxL += A[i] # add current item\\n            \\n            j = i - L # start subArray of size M only after considering first L items\\n            if j >= 0:\\n                currMaxM += A[j]\\n            \\n            if j >= M-1: \\n                max_M_For_CurrL = max(max_M_For_CurrL, currMaxM)\\n                currMaxM -= A[j-M+1] # slide window\\n                \\n                res = max(res, currMaxL + max_M_For_CurrL)\\n            \\n            i += 1\\n        \\n        currMaxL, currMaxM = 0, 0\\n        max_L_For_CurrM = float(\\'-inf\\')\\n        i = 0\\n        while i < len(A):\\n            if i >= M:     # if subarray size is bigger than M, slide window to right\\n                currMaxM -= A[i-M]\\n            currMaxM += A[i] # add current item\\n            \\n            j = i - M # start subArray of size L only after considering first M items\\n            if j >= 0:\\n                currMaxL += A[j]\\n            \\n            if j >= L-1: \\n                max_L_For_CurrM = max(max_L_For_CurrM, currMaxL)\\n                currMaxL -= A[j-L+1] # slide window\\n                \\n                res = max(res, currMaxM + max_L_For_CurrM)\\n            \\n            i += 1\\n        \\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 708608,
                "title": "python-brute-force-solution",
                "content": "```python\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n        m = 0\\n        \\n        for i in range(0, len(A) - L - M + 1):\\n            sub1 = sum(A[i:i+L])\\n            for j in range(i + L, len(A) - M + 1):\\n                tot = sum(A[j:j+M]) + sub1\\n                if tot > m: \\n                    m = tot\\n                    \\n        A.reverse()\\n        \\n        for i in range(0, len(A) - L - M + 1):\\n            sub1 = sum(A[i:i+L])\\n            for j in range(i + L, len(A) - M + 1):\\n                tot = sum(A[j:j+M]) + sub1\\n                if tot > m: \\n                    m = tot           \\n        \\n        return m\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n        m = 0\\n        \\n        for i in range(0, len(A) - L - M + 1):\\n            sub1 = sum(A[i:i+L])\\n            for j in range(i + L, len(A) - M + 1):\\n                tot = sum(A[j:j+M]) + sub1\\n                if tot > m: \\n                    m = tot\\n                    \\n        A.reverse()\\n        \\n        for i in range(0, len(A) - L - M + 1):\\n            sub1 = sum(A[i:i+L])\\n            for j in range(i + L, len(A) - M + 1):\\n                tot = sum(A[j:j+M]) + sub1\\n                if tot > m: \\n                    m = tot           \\n        \\n        return m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 695208,
                "title": "c-o-n-time-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        //time complexity: O(n); space: O(n)\\n        //two non-overlapping contiguous arrays where L comes first and then M\\n        int LthenM = maxSum(A, L, M);\\n        //two non-overlapping contiguous arrays where M comes first and then L\\n        int MthenL = maxSum(A, M, L);\\n        int result = max(LthenM, MthenL);\\n        return result;\\n    }\\n    int maxSum(vector<int>& A, int L, int M) {\\n        //left[0] = 0 && and right[A.size() - 1] = 0 to calculate non-overlapping sums when\\n        //adding left[i] + right[i]\\n        vector<int> left(A.size() + 1, 0);\\n        vector<int> right(A.size() + 1, 0);\\n        int sumleft = 0, sumright = 0, result = 0;\\n        //calculare sum values from left for size L\\n        for(int i = 0; i < A.size(); ++i) {\\n            sumleft += A[i];\\n            //store only max sliding window sum of length L, in every i upto i\\n            left[i+1] = max(left[i], sumleft);\\n            if(i + 1 >= L) {\\n                //you have L size values of sum, now remove the first element\\n                //from the sliding window\\n                sumleft -= A[i + 1 - L];\\n            }\\n        }\\n        //calculate sum values from right for size M\\n        for(int j = A.size() - 1; j >= 0; --j) {\\n            sumright += A[j];\\n            right[j] = max(right[j + 1], sumright);\\n            int val = (A.size() - 1) - (j - 1);\\n            if(val >= M) {\\n                sumright -= A[j - 1 + M];\\n            }\\n        }\\n        //we don\\'t care about the sum values that are less than the size of\\n        //L or M. So start from smallest of (L, M)\\n        int val = min(L, M); \\n        for(int i = val; i < A.size(); ++i) {\\n            result = max(result, left[i] + right[i]);\\n        }\\n        return result;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        //time complexity: O(n); space: O(n)\\n        //two non-overlapping contiguous arrays where L comes first and then M\\n        int LthenM = maxSum(A, L, M);\\n        //two non-overlapping contiguous arrays where M comes first and then L\\n        int MthenL = maxSum(A, M, L);\\n        int result = max(LthenM, MthenL);\\n        return result;\\n    }\\n    int maxSum(vector<int>& A, int L, int M) {\\n        //left[0] = 0 && and right[A.size() - 1] = 0 to calculate non-overlapping sums when\\n        //adding left[i] + right[i]\\n        vector<int> left(A.size() + 1, 0);\\n        vector<int> right(A.size() + 1, 0);\\n        int sumleft = 0, sumright = 0, result = 0;\\n        //calculare sum values from left for size L\\n        for(int i = 0; i < A.size(); ++i) {\\n            sumleft += A[i];\\n            //store only max sliding window sum of length L, in every i upto i\\n            left[i+1] = max(left[i], sumleft);\\n            if(i + 1 >= L) {\\n                //you have L size values of sum, now remove the first element\\n                //from the sliding window\\n                sumleft -= A[i + 1 - L];\\n            }\\n        }\\n        //calculate sum values from right for size M\\n        for(int j = A.size() - 1; j >= 0; --j) {\\n            sumright += A[j];\\n            right[j] = max(right[j + 1], sumright);\\n            int val = (A.size() - 1) - (j - 1);\\n            if(val >= M) {\\n                sumright -= A[j - 1 + M];\\n            }\\n        }\\n        //we don\\'t care about the sum values that are less than the size of\\n        //L or M. So start from smallest of (L, M)\\n        int val = min(L, M); \\n        for(int i = val; i < A.size(); ++i) {\\n            result = max(result, left[i] + right[i]);\\n        }\\n        return result;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 640723,
                "title": "simple-c-solution-o-n-time-o-1-space",
                "content": "the code is self explanatory.\\n```\\nint findMaxSum3(vector<int>& A,int n,int L,int M,int start,int end){\\n    int maxSum = INT_MIN;\\n    int left = start-1;\\n    for(int i=M-1+start;i<=end;i++){\\n        int temp = 0;\\n        temp = A[i] - A[left];\\n        left++;\\n        if(temp > maxSum){\\n            maxSum = temp;\\n        }\\n    }\\n    return maxSum;\\n}\\n\\nint findMaxSum(vector<int>& A,int n,int L,int M){\\n    //care about the bound also\\n    int left = -1;\\n    int maxSum = INT_MIN;\\n    for(int i=L-1;i<n;i++){\\n        int temp = 0;\\n        if(left != -1){\\n            temp = A[i] - A[left]; \\n        }else{\\n            temp = A[i];\\n        }\\n        left++;\\n        \\n        int opt = findMaxSum3(A,n,L,M,i+1,n-1);\\n        if(opt == INT_MIN)  break;\\n        maxSum = max(maxSum,temp+opt);\\n    }\\n    return maxSum;\\n}\\n\\n\\n\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        int n = A.size();\\n        \\n        for(int i=1;i<n;i++){\\n            A[i] += A[i-1];\\n        }\\n        return max(findMaxSum(A,n,L,M),findMaxSum(A,n,M,L));\\n    }\\n};\\n```\\nhope it helps!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint findMaxSum3(vector<int>& A,int n,int L,int M,int start,int end){\\n    int maxSum = INT_MIN;\\n    int left = start-1;\\n    for(int i=M-1+start;i<=end;i++){\\n        int temp = 0;\\n        temp = A[i] - A[left];\\n        left++;\\n        if(temp > maxSum){\\n            maxSum = temp;\\n        }\\n    }\\n    return maxSum;\\n}\\n\\nint findMaxSum(vector<int>& A,int n,int L,int M){\\n    //care about the bound also\\n    int left = -1;\\n    int maxSum = INT_MIN;\\n    for(int i=L-1;i<n;i++){\\n        int temp = 0;\\n        if(left != -1){\\n            temp = A[i] - A[left]; \\n        }else{\\n            temp = A[i];\\n        }\\n        left++;\\n        \\n        int opt = findMaxSum3(A,n,L,M,i+1,n-1);\\n        if(opt == INT_MIN)  break;\\n        maxSum = max(maxSum,temp+opt);\\n    }\\n    return maxSum;\\n}\\n\\n\\n\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        int n = A.size();\\n        \\n        for(int i=1;i<n;i++){\\n            A[i] += A[i-1];\\n        }\\n        return max(findMaxSum(A,n,L,M),findMaxSum(A,n,M,L));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 592472,
                "title": "java-simple-two-pointers-sum-array-solution-with-comments",
                "content": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        if (L + M > A.length) {\\n            return -1;\\n        }\\n\\n        return Math.max(calcMaxSumTwoNoOverlap(A, L, M), calcMaxSumTwoNoOverlap(A, M, L));\\n    }\\n\\n    private int calcMaxSumTwoNoOverlap(int[] A, int window1, int window2) {\\n        int totalSum = Integer.MIN_VALUE;\\n        List<Integer> bucket1Sum = new ArrayList<>();\\n        List<Integer> bucket2Sum = new ArrayList<>();\\n\\n        // Construct sum array for L and M\\n        for (int i = 0; i <= A.length - window1 - window2; ++i) {\\n            int window1Left = i;\\n            int window1Right = i + window1;\\n\\n            int window2Left = i + window1;\\n            int window2Right = (i + window1) + window2;\\n\\n            int sum1 = calcSum(A, window1Left, window1Right);\\n            int sum2 = calcSum(A, window2Left, window2Right);\\n\\n            bucket1Sum.add(sum1);\\n            bucket2Sum.add(sum2);\\n        }\\n\\n        // Get best sum for L and M\\n        for (int i = 0; i < bucket1Sum.size(); ++i) {\\n            for (int j = i; j < bucket2Sum.size(); ++j) {\\n                if (totalSum < (bucket1Sum.get(i) + bucket2Sum.get(j))) {\\n                    totalSum = bucket1Sum.get(i) + bucket2Sum.get(j);\\n                }\\n            }\\n        }\\n\\n        return totalSum;\\n    }\\n\\n    private int calcSum(int[] A, int from, int to) {\\n        int sum = 0;\\n\\n        for (int i = from; i < to; ++i) {\\n            sum += A[i];\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        if (L + M > A.length) {\\n            return -1;\\n        }\\n\\n        return Math.max(calcMaxSumTwoNoOverlap(A, L, M), calcMaxSumTwoNoOverlap(A, M, L));\\n    }\\n\\n    private int calcMaxSumTwoNoOverlap(int[] A, int window1, int window2) {\\n        int totalSum = Integer.MIN_VALUE;\\n        List<Integer> bucket1Sum = new ArrayList<>();\\n        List<Integer> bucket2Sum = new ArrayList<>();\\n\\n        // Construct sum array for L and M\\n        for (int i = 0; i <= A.length - window1 - window2; ++i) {\\n            int window1Left = i;\\n            int window1Right = i + window1;\\n\\n            int window2Left = i + window1;\\n            int window2Right = (i + window1) + window2;\\n\\n            int sum1 = calcSum(A, window1Left, window1Right);\\n            int sum2 = calcSum(A, window2Left, window2Right);\\n\\n            bucket1Sum.add(sum1);\\n            bucket2Sum.add(sum2);\\n        }\\n\\n        // Get best sum for L and M\\n        for (int i = 0; i < bucket1Sum.size(); ++i) {\\n            for (int j = i; j < bucket2Sum.size(); ++j) {\\n                if (totalSum < (bucket1Sum.get(i) + bucket2Sum.get(j))) {\\n                    totalSum = bucket1Sum.get(i) + bucket2Sum.get(j);\\n                }\\n            }\\n        }\\n\\n        return totalSum;\\n    }\\n\\n    private int calcSum(int[] A, int from, int to) {\\n        int sum = 0;\\n\\n        for (int i = from; i < to; ++i) {\\n            sum += A[i];\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 590486,
                "title": "cpp-presum-simple-dp-beat-100-submission",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) { // o(n) o(n)\\n        int ret = 0;\\n        int m = A.size();\\n        if(m < L || m < M) return 0;\\n        vector<int> sum(m, 0); sum[0] = A[0];\\n        for(int i = 1; i < A.size(); i++) sum[i] = sum[i - 1] + A[i];\\n        vector<int> dpL(m, 0); dpL[L - 1] = sum[L - 1];\\n        vector<int> dpM(m, 0); dpM[M - 1] = sum[M - 1];\\n        for(int i = 0; i < m; i++) {\\n            if(i > L - 1) dpL[i] = max(dpL[i - 1], sum[i] - sum[i - L]);\\n            if(i > M - 1) dpM[i] = max(dpM[i - 1], sum[i] - sum[i - M]);\\n        }\\n        for(int i = L + M - 1; i < m; i++) {\\n            ret = max(ret, sum[i] - sum[i - L] + dpM[i - L]);\\n            ret = max(ret, sum[i] - sum[i - M] + dpL[i - M]);\\n        }\\n        return ret;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) { // o(n) o(n)\\n        int ret = 0;\\n        int m = A.size();\\n        if(m < L || m < M) return 0;\\n        vector<int> sum(m, 0); sum[0] = A[0];\\n        for(int i = 1; i < A.size(); i++) sum[i] = sum[i - 1] + A[i];\\n        vector<int> dpL(m, 0); dpL[L - 1] = sum[L - 1];\\n        vector<int> dpM(m, 0); dpM[M - 1] = sum[M - 1];\\n        for(int i = 0; i < m; i++) {\\n            if(i > L - 1) dpL[i] = max(dpL[i - 1], sum[i] - sum[i - L]);\\n            if(i > M - 1) dpM[i] = max(dpM[i - 1], sum[i] - sum[i - M]);\\n        }\\n        for(int i = L + M - 1; i < m; i++) {\\n            ret = max(ret, sum[i] - sum[i - L] + dpM[i - L]);\\n            ret = max(ret, sum[i] - sum[i - M] + dpL[i - M]);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 567891,
                "title": "o-n-space-o-n-time-solution-with-readable-code",
                "content": "```c++\\nclass Solution {\\n public:\\n  int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n    // sumL[a] = sum(A[a:a+L])\\n    // maxL[a] = max(sumL[a::])\\n    // sumM[a] = sum(A[a:a+M])\\n    // maxM[a] = max(sumM[a::])\\n    // tsum[a] = max(sumL[a] + maxM[a+L], sumM[a] + maxL[a+M]) \\n    // res = max(tsum[::])\\n    auto sumL = initSumv(A, L);\\n    auto sumM = initSumv(A, M);\\n    auto maxL = initMaxv(sumL);\\n    auto maxM = initMaxv(sumM);\\n    int res = 0;\\n    for (int i = 0; i+L+M <= A.size(); ++i) {\\n      res = max(res, sumL[i]+maxM[i+L]);\\n      res = max(res, sumM[i]+maxL[i+M]);\\n    }\\n    return res;\\n  }\\n \\n private:\\n  vector<int> initSumv(const vector<int>& A, int l) {\\n    vector<int> sumv(A.size()+1, 0);\\n    for (int i = 0; i < l; ++i)\\n      sumv[0] += A[i];\\n    for (int i = 1; i <= A.size()-l; ++i)\\n      sumv[i] = sumv[i-1] - A[i-1] + A[i+l-1];\\n    return sumv;\\n  }\\n\\n  vector<int> initMaxv(const vector<int>& S) {\\n    vector<int> maxv(S.size()+1, 0);\\n    for (int i = S.size()-1; i >= 0; --i) \\n      maxv[i] = max(maxv[i+1], S[i]);\\n    return maxv;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\n public:\\n  int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n    // sumL[a] = sum(A[a:a+L])\\n    // maxL[a] = max(sumL[a::])\\n    // sumM[a] = sum(A[a:a+M])\\n    // maxM[a] = max(sumM[a::])\\n    // tsum[a] = max(sumL[a] + maxM[a+L], sumM[a] + maxL[a+M]) \\n    // res = max(tsum[::])\\n    auto sumL = initSumv(A, L);\\n    auto sumM = initSumv(A, M);\\n    auto maxL = initMaxv(sumL);\\n    auto maxM = initMaxv(sumM);\\n    int res = 0;\\n    for (int i = 0; i+L+M <= A.size(); ++i) {\\n      res = max(res, sumL[i]+maxM[i+L]);\\n      res = max(res, sumM[i]+maxL[i+M]);\\n    }\\n    return res;\\n  }\\n \\n private:\\n  vector<int> initSumv(const vector<int>& A, int l) {\\n    vector<int> sumv(A.size()+1, 0);\\n    for (int i = 0; i < l; ++i)\\n      sumv[0] += A[i];\\n    for (int i = 1; i <= A.size()-l; ++i)\\n      sumv[i] = sumv[i-1] - A[i-1] + A[i+l-1];\\n    return sumv;\\n  }\\n\\n  vector<int> initMaxv(const vector<int>& S) {\\n    vector<int> maxv(S.size()+1, 0);\\n    for (int i = S.size()-1; i >= 0; --i) \\n      maxv[i] = max(maxv[i+1], S[i]);\\n    return maxv;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 508984,
                "title": "c-short-solution",
                "content": "```\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        for(int i = 1; i < A.size(); i++) A[i] += A[i-1];\\n        int res = A[L+M-1], Lmax = A[L-1], Mmax = A[M-1];\\n        for(int i = L + M; i < A.size(); i++) {\\n            Lmax = max(Lmax, A[i-M]-A[i-M-L]);\\n            Mmax = max(Mmax, A[i-L]-A[i-M-L]);\\n            res = max(res, A[i]-A[i-M] + Lmax);\\n            res = max(res, A[i]-A[i-L] + Mmax);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        for(int i = 1; i < A.size(); i++) A[i] += A[i-1];\\n        int res = A[L+M-1], Lmax = A[L-1], Mmax = A[M-1];\\n        for(int i = L + M; i < A.size(); i++) {\\n            Lmax = max(Lmax, A[i-M]-A[i-M-L]);\\n            Mmax = max(Mmax, A[i-L]-A[i-M-L]);\\n            res = max(res, A[i]-A[i-M] + Lmax);\\n            res = max(res, A[i]-A[i-L] + Mmax);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 506654,
                "title": "java-sliding-window-easy-to-understand-with-example-o-1-space-o-n-time",
                "content": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int R) {\\n        /*\\n        note that not overlap means index overlap, not value\\n        (can use prefix sum)\\n        solution: sliding windows 2 passes: l -> r then r -> l\\n        each pass: keep track of the main window and the max sub window\\n        ex: [0, 6, 5, 2, 9, 1], L = 1, R = 2\\n        start with index L + R\\n        -> [(0), (6, 5), 2, 9, 1] -> maxL = 0, R = 11 -> res = 11\\n        -> [0, (6), (5, 2), 9, 1] -> maxL = 6, R = 7  -> res = 13\\n        -> [0, 6, (5), (2, 9), 1] -> maxL = 6, R = 11 -> res = 17\\n        -> [0, 6, 5, (2), (9, 1)] -> maxL = 6, R = 10 -> res = 17 (17 > 16)\\n        -> first pass: 17\\n        second pass: go the opposite way or flip L & R;\\n        */\\n        return Math.max(maxSumLR(A, L, R), maxSumLR(A, R, L));\\n    }\\n    \\n    // helper funtion sliding window left to right\\n    private int maxSumLR(int[] A, int L, int R) {\\n        // start with L + R\\n        int i = 0;\\n        int sumL = 0, sumR = 0;\\n        // start with i = L + R\\n        while (i < L) sumL += A[i++];\\n        while (i < L + R) sumR += A[i++];\\n        int maxL = sumL, res = maxL + sumR;\\n        for (; i < A.length; i++) {\\n            // update the windows\\n            sumR += A[i] - A[i-R]; \\n            sumL += A[i-R] - A[i - L - R];\\n            maxL = Math.max(maxL, sumL);\\n            res = Math.max(res, maxL + sumR);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int R) {\\n        /*\\n        note that not overlap means index overlap, not value\\n        (can use prefix sum)\\n        solution: sliding windows 2 passes: l -> r then r -> l\\n        each pass: keep track of the main window and the max sub window\\n        ex: [0, 6, 5, 2, 9, 1], L = 1, R = 2\\n        start with index L + R\\n        -> [(0), (6, 5), 2, 9, 1] -> maxL = 0, R = 11 -> res = 11\\n        -> [0, (6), (5, 2), 9, 1] -> maxL = 6, R = 7  -> res = 13\\n        -> [0, 6, (5), (2, 9), 1] -> maxL = 6, R = 11 -> res = 17\\n        -> [0, 6, 5, (2), (9, 1)] -> maxL = 6, R = 10 -> res = 17 (17 > 16)\\n        -> first pass: 17\\n        second pass: go the opposite way or flip L & R;\\n        */\\n        return Math.max(maxSumLR(A, L, R), maxSumLR(A, R, L));\\n    }\\n    \\n    // helper funtion sliding window left to right\\n    private int maxSumLR(int[] A, int L, int R) {\\n        // start with L + R\\n        int i = 0;\\n        int sumL = 0, sumR = 0;\\n        // start with i = L + R\\n        while (i < L) sumL += A[i++];\\n        while (i < L + R) sumR += A[i++];\\n        int maxL = sumL, res = maxL + sumR;\\n        for (; i < A.length; i++) {\\n            // update the windows\\n            sumR += A[i] - A[i-R]; \\n            sumL += A[i-R] - A[i - L - R];\\n            maxL = Math.max(maxL, sumL);\\n            res = Math.max(res, maxL + sumR);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 497983,
                "title": "java-easy-understand-o-n-solution",
                "content": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] nums, int L, int M) {\\n        int leftsums[]=new int[nums.length];\\n        int rightsums[]=new int[nums.length];\\n        int sum=0;int ans=0;\\n        int leftmax[]=new int[nums.length];\\n        int rightmax[]=new int[nums.length];\\n        int max=-1;\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            leftsums[i]=sum;\\n        }\\n        sum=0;\\n        for(int i=nums.length-1;i>=0;i--){\\n            sum+=nums[i];\\n            rightsums[i]=sum;\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(i+1<M){\\n                continue;\\n            }\\n            if(i-M<0){\\n                max=Math.max(max,leftsums[i]);\\n            }else{\\n                max=Math.max(max,leftsums[i]-leftsums[i-M]);\\n            }\\n            leftmax[i]=max;\\n        }\\n        max=-1;\\n        for(int i=nums.length-1;i>=0;i--){\\n            if(nums.length-i<M){\\n                continue;\\n            }\\n            if(i+M>=nums.length){\\n                max=Math.max(max,rightsums[i]);\\n            }else{\\n                max=Math.max(max,rightsums[i]-rightsums[i+M]);\\n            }\\n            rightmax[i]=max;\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(i+1<L){\\n                continue;\\n            }\\n            if(i-L+1==0){\\n                ans=Math.max(ans,leftsums[i]+rightmax[i+1]);\\n                continue;\\n            }\\n            if(i==nums.length-1){\\n                ans=Math.max(ans,leftsums[i]-leftsums[i-L]+leftmax[i-L]);\\n                continue;\\n            }\\n            ans=Math.max(ans,leftsums[i]-leftsums[i-L]+leftmax[i-L]);\\n            ans=Math.max(ans,leftsums[i]-leftsums[i-L]+rightmax[i+1]);   \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] nums, int L, int M) {\\n        int leftsums[]=new int[nums.length];\\n        int rightsums[]=new int[nums.length];\\n        int sum=0;int ans=0;\\n        int leftmax[]=new int[nums.length];\\n        int rightmax[]=new int[nums.length];\\n        int max=-1;\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            leftsums[i]=sum;\\n        }\\n        sum=0;\\n        for(int i=nums.length-1;i>=0;i--){\\n            sum+=nums[i];\\n            rightsums[i]=sum;\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(i+1<M){\\n                continue;\\n            }\\n            if(i-M<0){\\n                max=Math.max(max,leftsums[i]);\\n            }else{\\n                max=Math.max(max,leftsums[i]-leftsums[i-M]);\\n            }\\n            leftmax[i]=max;\\n        }\\n        max=-1;\\n        for(int i=nums.length-1;i>=0;i--){\\n            if(nums.length-i<M){\\n                continue;\\n            }\\n            if(i+M>=nums.length){\\n                max=Math.max(max,rightsums[i]);\\n            }else{\\n                max=Math.max(max,rightsums[i]-rightsums[i+M]);\\n            }\\n            rightmax[i]=max;\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(i+1<L){\\n                continue;\\n            }\\n            if(i-L+1==0){\\n                ans=Math.max(ans,leftsums[i]+rightmax[i+1]);\\n                continue;\\n            }\\n            if(i==nums.length-1){\\n                ans=Math.max(ans,leftsums[i]-leftsums[i-L]+leftmax[i-L]);\\n                continue;\\n            }\\n            ans=Math.max(ans,leftsums[i]-leftsums[i-L]+leftmax[i-L]);\\n            ans=Math.max(ans,leftsums[i]-leftsums[i-L]+rightmax[i+1]);   \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 479199,
                "title": "c",
                "content": "```\\npublic int MaxSumTwoNoOverlap(int[] A, int L, int M) {\\n\\tvar n = A.Length;\\n\\tint lMax = 0, mMax = 0, lSum = 0, mSum = 0;\\n\\tvar ls = new int[n]; var ms = new int[n];\\n\\tvar le = new int[n]; var me = new int[n];\\n\\tfor (var i = 0; i < L; i++) lSum += A[i];\\n\\tfor (var i = 0; i < M; i++) mSum += A[i];\\n\\tfor (var i = 0; i < n - L; i++) { ls[i] = lSum; lSum += A[i + L] - A[i]; }\\n\\tfor (var i = 0; i < n - M; i++) { ms[i] = mSum; mSum += A[i + M] - A[i]; }\\n\\tls[n - L] = lSum; ms[n - M] = mSum;\\n\\tfor (var i = n - 1; i >= L; i--) { le[i] = lSum; lSum -= A[i] - A[i - L]; }\\n\\tfor (var i = n - 1; i >= M; i--) { me[i] = mSum; mSum -= A[i] - A[i - M]; }\\n\\tle[L - 1] = lSum; me[M - 1] = mSum;\\n\\tfor (var i = n - 1; i >= 0; i--) { if (ls[i] > lMax) lMax = ls[i]; ls[i] = lMax; }\\n\\tfor (var i = n - 1; i >= 0; i--) { if (ms[i] > mMax) mMax = ms[i]; ms[i] = mMax; }\\n\\tlMax = mMax = 0;\\n\\tfor (var i = 0; i < n; i++) { if (le[i] > lMax) lMax = le[i]; le[i] = lMax; }\\n\\tfor (var i = 0; i < n; i++) { if (me[i] > mMax) mMax = me[i]; me[i] = mMax; }\\n\\tlMax = mMax = 0;\\n\\tfor (var i = 0; i < n - 1; i++) { var l = le[i] + ms[i + 1]; if (l > lMax) lMax = l; }\\n\\tfor (var i = 0; i < n - 1; i++) { var m = me[i] + ls[i + 1]; if (m > mMax) mMax = m; }\\n\\treturn lMax > mMax ? lMax : mMax;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int MaxSumTwoNoOverlap(int[] A, int L, int M) {\\n\\tvar n = A.Length;\\n\\tint lMax = 0, mMax = 0, lSum = 0, mSum = 0;\\n\\tvar ls = new int[n]; var ms = new int[n];\\n\\tvar le = new int[n]; var me = new int[n];\\n\\tfor (var i = 0; i < L; i++) lSum += A[i];\\n\\tfor (var i = 0; i < M; i++) mSum += A[i];\\n\\tfor (var i = 0; i < n - L; i++) { ls[i] = lSum; lSum += A[i + L] - A[i]; }\\n\\tfor (var i = 0; i < n - M; i++) { ms[i] = mSum; mSum += A[i + M] - A[i]; }\\n\\tls[n - L] = lSum; ms[n - M] = mSum;\\n\\tfor (var i = n - 1; i >= L; i--) { le[i] = lSum; lSum -= A[i] - A[i - L]; }\\n\\tfor (var i = n - 1; i >= M; i--) { me[i] = mSum; mSum -= A[i] - A[i - M]; }\\n\\tle[L - 1] = lSum; me[M - 1] = mSum;\\n\\tfor (var i = n - 1; i >= 0; i--) { if (ls[i] > lMax) lMax = ls[i]; ls[i] = lMax; }\\n\\tfor (var i = n - 1; i >= 0; i--) { if (ms[i] > mMax) mMax = ms[i]; ms[i] = mMax; }\\n\\tlMax = mMax = 0;\\n\\tfor (var i = 0; i < n; i++) { if (le[i] > lMax) lMax = le[i]; le[i] = lMax; }\\n\\tfor (var i = 0; i < n; i++) { if (me[i] > mMax) mMax = me[i]; me[i] = mMax; }\\n\\tlMax = mMax = 0;\\n\\tfor (var i = 0; i < n - 1; i++) { var l = le[i] + ms[i + 1]; if (l > lMax) lMax = l; }\\n\\tfor (var i = 0; i < n - 1; i++) { var m = me[i] + ls[i + 1]; if (m > mMax) mMax = m; }\\n\\treturn lMax > mMax ? lMax : mMax;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 478809,
                "title": "java-sliding-window-14-lines-0ms",
                "content": "For each M elements on the right, take the maximum of L elements on the left.\\nRepeat after swapping L and M.\\n```\\n\\tpublic int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        int n = A.length;\\n        for(int i = 1; i < n; ++i) {\\n            A[i] += A[i-1];\\n        }\\n        int result = A[L + M - 1];\\n        int lmax = A[L - 1];\\n        int mmax = A[M - 1];\\n        for(int i = 0, j = L + M; j < n; ++i, ++j) {\\n            lmax = Math.max(lmax, A[i + L] - A[i]);\\n            mmax = Math.max(mmax, A[i + M] - A[i]);\\n            result = Math.max(result, lmax + A[j] - A[i + L]);\\n            result = Math.max(result, mmax + A[j] - A[i + M]);\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        int n = A.length;\\n        for(int i = 1; i < n; ++i) {\\n            A[i] += A[i-1];\\n        }\\n        int result = A[L + M - 1];\\n        int lmax = A[L - 1];\\n        int mmax = A[M - 1];\\n        for(int i = 0, j = L + M; j < n; ++i, ++j) {\\n            lmax = Math.max(lmax, A[i + L] - A[i]);\\n            mmax = Math.max(mmax, A[i + M] - A[i]);\\n            result = Math.max(result, lmax + A[j] - A[i + L]);\\n            result = Math.max(result, mmax + A[j] - A[i + M]);\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 465172,
                "title": "o-n-deque-solution-2-passes",
                "content": "```\\nclass Solution \\n{\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) \\n    {\\n        return Math.max(compute(A, L, M), compute(reverse(A), L, M));\\n    }\\n    \\n    private int compute(int[] A, int l, int m)\\n    {\\n        Deque<Integer> mq = new LinkedList<Integer>();\\n        Deque<Integer> lq = new LinkedList<Integer>();\\n        \\n        int i=0, msum=0, lsum=0;\\n        \\n        while(i<A.length && i<l+m)\\n        {\\n            if(i<m)\\n            {\\n                msum += A[i];\\n                mq.offer(A[i]);\\n            }\\n            else\\n            {\\n                lsum += A[i];\\n                lq.offer(A[i]);\\n            }\\n            \\n            i++;\\n        }\\n        \\n        int mmax = msum;        \\n        int ans = mmax + lsum;\\n        \\n        while(i<A.length)\\n        {\\n            int mpoll = mq.pollFirst();\\n            int lpoll = lq.pollFirst();\\n            \\n            mq.offerLast(lpoll);\\n            lq.offerLast(A[i]);\\n            \\n            msum = msum - mpoll + lpoll;\\n            lsum = lsum - lpoll + A[i];\\n            \\n            mmax = Math.max(mmax, msum);\\n            ans = Math.max(ans, mmax + lsum);\\n            \\n            i++;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private int[] reverse(int[] a)\\n    {\\n        for(int i=0; i<a.length/2; i++)\\n        {\\n            int temp = a[a.length-1-i];\\n            a[a.length-1-i] = a[i];\\n            a[i] = temp;\\n        }\\n        \\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) \\n    {\\n        return Math.max(compute(A, L, M), compute(reverse(A), L, M));\\n    }\\n    \\n    private int compute(int[] A, int l, int m)\\n    {\\n        Deque<Integer> mq = new LinkedList<Integer>();\\n        Deque<Integer> lq = new LinkedList<Integer>();\\n        \\n        int i=0, msum=0, lsum=0;\\n        \\n        while(i<A.length && i<l+m)\\n        {\\n            if(i<m)\\n            {\\n                msum += A[i];\\n                mq.offer(A[i]);\\n            }\\n            else\\n            {\\n                lsum += A[i];\\n                lq.offer(A[i]);\\n            }\\n            \\n            i++;\\n        }\\n        \\n        int mmax = msum;        \\n        int ans = mmax + lsum;\\n        \\n        while(i<A.length)\\n        {\\n            int mpoll = mq.pollFirst();\\n            int lpoll = lq.pollFirst();\\n            \\n            mq.offerLast(lpoll);\\n            lq.offerLast(A[i]);\\n            \\n            msum = msum - mpoll + lpoll;\\n            lsum = lsum - lpoll + A[i];\\n            \\n            mmax = Math.max(mmax, msum);\\n            ans = Math.max(ans, mmax + lsum);\\n            \\n            i++;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private int[] reverse(int[] a)\\n    {\\n        for(int i=0; i<a.length/2; i++)\\n        {\\n            int temp = a[a.length-1-i];\\n            a[a.length-1-i] = a[i];\\n            a[i] = temp;\\n        }\\n        \\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 446258,
                "title": "share-my-solution-clean-java",
                "content": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        int N = A.length;\\n        int[] preSum = new int[N];\\n        int[] postSum = new int[N];\\n        preSum[0] = A[0];\\n        for (int i = 1; i < N; i++) {\\n            preSum[i] = preSum[i - 1] + A[i];\\n        }\\n        postSum[N - 1] = A[N - 1];\\n        for (int i = N - 2; i >= 0; i--) {\\n            postSum[i] = postSum[i + 1] + A[i];\\n        }\\n        return Math.max(findMax(preSum, postSum, L, M), findMax(preSum, postSum, M, L));\\n    }\\n    \\n    public int findMax(int[] preSum, int[] postSum, int L, int M) {\\n        int N = preSum.length;\\n        int[] dp1 = new int[N];\\n        int[] dp2 = new int[N];\\n        dp1[L - 1] = preSum[L - 1];\\n        for (int i = L; i < N; i++) {\\n            dp1[i] = Math.max(dp1[i - 1], preSum[i] - preSum[i - L]);\\n        }\\n        dp2[N - M] = postSum[N - M];\\n        for (int i = N - M - 1; i >= 0; i--) {\\n            dp2[i] = Math.max(dp2[i + 1], postSum[i] - postSum[i + M]);\\n        }\\n        int max = 0;\\n        for (int i = L - 1; i < N - M; i++) {\\n            max = Math.max(dp1[i] + dp2[i + 1], max);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        int N = A.length;\\n        int[] preSum = new int[N];\\n        int[] postSum = new int[N];\\n        preSum[0] = A[0];\\n        for (int i = 1; i < N; i++) {\\n            preSum[i] = preSum[i - 1] + A[i];\\n        }\\n        postSum[N - 1] = A[N - 1];\\n        for (int i = N - 2; i >= 0; i--) {\\n            postSum[i] = postSum[i + 1] + A[i];\\n        }\\n        return Math.max(findMax(preSum, postSum, L, M), findMax(preSum, postSum, M, L));\\n    }\\n    \\n    public int findMax(int[] preSum, int[] postSum, int L, int M) {\\n        int N = preSum.length;\\n        int[] dp1 = new int[N];\\n        int[] dp2 = new int[N];\\n        dp1[L - 1] = preSum[L - 1];\\n        for (int i = L; i < N; i++) {\\n            dp1[i] = Math.max(dp1[i - 1], preSum[i] - preSum[i - L]);\\n        }\\n        dp2[N - M] = postSum[N - M];\\n        for (int i = N - M - 1; i >= 0; i--) {\\n            dp2[i] = Math.max(dp2[i + 1], postSum[i] - postSum[i + M]);\\n        }\\n        int max = 0;\\n        for (int i = L - 1; i < N - M; i++) {\\n            max = Math.max(dp1[i] + dp2[i + 1], max);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 400935,
                "title": "c-dp-solution-o-n-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        int n = A.size();\\n        vector<int> Asum(n+1, 0), maxL(n+1, 0), maxM(n+1, 0), sum(n+1, 0);\\n        for(int i=0; i<n; ++i){\\n            Asum[i+1] = A[i] + Asum[i];\\n            if(i+1 >= L) maxL[i+1] = max(maxL[i], Asum[i+1] - Asum[i+1-L]);\\n            if(i+1 >= M) maxM[i+1] = max(maxM[i], Asum[i+1] - Asum[i+1-M]);\\n            if(i+1 >= L+M) sum[i+1] = max(sum[i], \\n                    max(maxL[i+1-M]+Asum[i+1]-Asum[i+1-M], maxM[i+1-L]+Asum[i+1]-Asum[i+1-L]));\\n        }\\n        return sum[n];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        int n = A.size();\\n        vector<int> Asum(n+1, 0), maxL(n+1, 0), maxM(n+1, 0), sum(n+1, 0);\\n        for(int i=0; i<n; ++i){\\n            Asum[i+1] = A[i] + Asum[i];\\n            if(i+1 >= L) maxL[i+1] = max(maxL[i], Asum[i+1] - Asum[i+1-L]);\\n            if(i+1 >= M) maxM[i+1] = max(maxM[i], Asum[i+1] - Asum[i+1-M]);\\n            if(i+1 >= L+M) sum[i+1] = max(sum[i], \\n                    max(maxL[i+1-M]+Asum[i+1]-Asum[i+1-M], maxM[i+1-L]+Asum[i+1]-Asum[i+1-L]));\\n        }\\n        return sum[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 373345,
                "title": "python-o-n-30ms-solution-with-explaination",
                "content": "```\\nclass Solution(object):\\n    def maxSumTwoNoOverlap(self, A, L, M):\\n        \"\"\"\\n        :type A: List[int]\\n        :type L: int\\n        :type M: int\\n        :rtype: int\\n        \"\"\"\\n        length = len(A)\\n\\t\\t\\n\\t\\t### Case 1: Array L on left, Array M on right  \\n\\t\\t\\n\\t\\t### Find maximum sum of M size array starting from right and store in DP\\n        dp,mysum = [0]*length,sum(A[-M:])\\n        mymax,dp[-M] = mysum,mysum\\n        for i in range(length-M-1,-1,-1):\\n            mysum += A[i]-A[i+M] \\n            mymax = max(mymax,mysum)\\n            dp[i] = mymax              \\n\\t\\t\\t\\n\\t\\t### Find maximum sum of L size array starting from left.\\n\\t\\t### Add maxL+ maxM(from dp) and track the maximum result.\\n        mysum = sum(A[:L])\\n        mymax,result = mysum,mysum+dp[L]\\n        for i in range(L,length-M):\\n            mysum += A[i]-A[i-L]\\n            mymax = max(mymax,mysum)\\n            result = max(result,mymax+dp[i+1])\\n\\n        ### Case 2: Array L on right, Array M on left. Repeat above logic \\n\\n        ### Find maximum sum of L size array starting from right and store in DP\\n        dp,mysum = [0]*length,sum(A[-L:])\\n        mymax,dp[-L] = mysum,mysum\\n        for i in range(length-L-1,-1,-1):\\n            mysum += A[i]-A[i+L]\\n            mymax = max(mymax,mysum)\\n            dp[i] = mymax\\n\\t\\t\\t\\n\\t\\t### Find maximum sum of M size array starting from left.\\n\\t\\t### Add maxM+ maxL(from dp) and track the maximum result.\\n        mysum = sum(A[:M])\\n        mymax,result = mysum,max(result,mysum+dp[M]) \\n        for i in range(M,length-L):\\n            mysum += A[i]-A[i-M]\\n            mymax = max(mymax,mysum)\\n            result = max(result,mymax+dp[i+1])\\n        return result\\n```\\n            \\n\\t\\t\\t",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxSumTwoNoOverlap(self, A, L, M):\\n        \"\"\"\\n        :type A: List[int]\\n        :type L: int\\n        :type M: int\\n        :rtype: int\\n        \"\"\"\\n        length = len(A)\\n\\t\\t\\n\\t\\t### Case 1: Array L on left, Array M on right  \\n\\t\\t\\n\\t\\t### Find maximum sum of M size array starting from right and store in DP\\n        dp,mysum = [0]*length,sum(A[-M:])\\n        mymax,dp[-M] = mysum,mysum\\n        for i in range(length-M-1,-1,-1):\\n            mysum += A[i]-A[i+M] \\n            mymax = max(mymax,mysum)\\n            dp[i] = mymax              \\n\\t\\t\\t\\n\\t\\t### Find maximum sum of L size array starting from left.\\n\\t\\t### Add maxL+ maxM(from dp) and track the maximum result.\\n        mysum = sum(A[:L])\\n        mymax,result = mysum,mysum+dp[L]\\n        for i in range(L,length-M):\\n            mysum += A[i]-A[i-L]\\n            mymax = max(mymax,mysum)\\n            result = max(result,mymax+dp[i+1])\\n\\n        ### Case 2: Array L on right, Array M on left. Repeat above logic \\n\\n        ### Find maximum sum of L size array starting from right and store in DP\\n        dp,mysum = [0]*length,sum(A[-L:])\\n        mymax,dp[-L] = mysum,mysum\\n        for i in range(length-L-1,-1,-1):\\n            mysum += A[i]-A[i+L]\\n            mymax = max(mymax,mysum)\\n            dp[i] = mymax\\n\\t\\t\\t\\n\\t\\t### Find maximum sum of M size array starting from left.\\n\\t\\t### Add maxM+ maxL(from dp) and track the maximum result.\\n        mysum = sum(A[:M])\\n        mymax,result = mysum,max(result,mysum+dp[M]) \\n        for i in range(M,length-L):\\n            mysum += A[i]-A[i-M]\\n            mymax = max(mymax,mysum)\\n            result = max(result,mymax+dp[i+1])\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 300929,
                "title": "java-beat-99-brute-force",
                "content": "```\\npublic int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n    int len = A.length, maxSum = -2147483648;\\n    if(L < M){\\n        int temp = L; L = M; M = temp;\\n    }\\n    int sum = 0;\\n    for(int i = 0; i < L; ++i){\\n        sum += A[i];\\n    }\\n    for(int i = L - 1; i < len; ++i){\\n        if(i >= L){\\n            sum = sum - A[i - L] + A[i];\\n        }\\n        int twoSum = sum + Math.max(maxSumHelper(A, 0, i - L, M), maxSumHelper(A, i + 1, len, M));\\n        if(twoSum > maxSum){\\n            maxSum = twoSum;\\n        }\\n    }\\n    return maxSum;\\n}\\n    \\nprivate int maxSumHelper(int[] A, int begin, int end, int L){\\n    if(end - begin < L){\\n        return -2147483648;\\n    }\\n    int sum = 0;\\n    int nextBegin = begin + L;\\n    for(int i = begin; i < nextBegin; ++i){\\n        sum += A[i];\\n    }\\n    int maxSum = sum;\\n    for(int i = nextBegin; i < end; ++i){\\n        sum = sum + A[i] - A[i - L];\\n        if(sum > maxSum){\\n            maxSum = sum;\\n        }\\n    }\\n    return maxSum;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n    int len = A.length, maxSum = -2147483648;\\n    if(L < M){\\n        int temp = L; L = M; M = temp;\\n    }\\n    int sum = 0;\\n    for(int i = 0; i < L; ++i){\\n        sum += A[i];\\n    }\\n    for(int i = L - 1; i < len; ++i){\\n        if(i >= L){\\n            sum = sum - A[i - L] + A[i];\\n        }\\n        int twoSum = sum + Math.max(maxSumHelper(A, 0, i - L, M), maxSumHelper(A, i + 1, len, M));\\n        if(twoSum > maxSum){\\n            maxSum = twoSum;\\n        }\\n    }\\n    return maxSum;\\n}\\n    \\nprivate int maxSumHelper(int[] A, int begin, int end, int L){\\n    if(end - begin < L){\\n        return -2147483648;\\n    }\\n    int sum = 0;\\n    int nextBegin = begin + L;\\n    for(int i = begin; i < nextBegin; ++i){\\n        sum += A[i];\\n    }\\n    int maxSum = sum;\\n    for(int i = nextBegin; i < end; ++i){\\n        sum = sum + A[i] - A[i - L];\\n        if(sum > maxSum){\\n            maxSum = sum;\\n        }\\n    }\\n    return maxSum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 293027,
                "title": "retweet-if-golang-makes-you-hate-heaps-too",
                "content": "This beats 100 percent. I\\'m not saying I\\'m \"like\" a big deal, \\nI\\'m saying I\\'m a big deal. \\n#stayHumble\\n\\n```\\nimport (\\n    \"container/heap\"\\n)\\n\\ntype Heap []int\\n\\nfunc (h Heap) Len() int { \\n    return len(h) \\n}\\nfunc (h Heap) Less(i, j int) bool {\\n    return h[i] > h[j]\\n}\\n\\nfunc (h Heap) Swap(i, j int) {\\n    h[i], h[j] = h[j], h[i]\\n}\\n\\nfunc (h *Heap) Push(x interface{}) {\\n    *h = append(*h, x.(int))\\n}\\n\\nfunc (h *Heap) Pop() interface{} {\\n    poo := *h\\n    item := poo[len(poo) - 1]\\n    *h = poo[0: len(poo) - 1]\\n    return item\\n}\\n\\nfunc maxSumTwoNoOverlap(A []int, L int, M int) int {\\n    L_sums, M_sums := []int{}, []int{}\\n    for i, num := range A {\\n        if i == 0 {\\n            L_sums = append(L_sums, num)\\n            M_sums = append(M_sums, num)\\n        } else {\\n            L_new := L_sums[i - 1] + num\\n            M_new := M_sums[i - 1] + num\\n            if i >= L {\\n                L_new -= A[i - L]\\n            }\\n            if i >= M {\\n                M_new -= A[i - M]\\n            }\\n            L_sums = append(L_sums, L_new)\\n            M_sums = append(M_sums, M_new)\\n        }\\n    }\\n    L_sums, M_sums = L_sums[L - 1:], M_sums[M - 1:]\\n    arrs := [][]int{L_sums, M_sums}\\n    lens := []int{L, M} \\n    res := 0\\n    for i, arr := range arrs {\\n        var others Heap\\n        heap.Init(&others)\\n        for j, sum := range arrs[1 - i] {\\n            if j + lens[1 - i] >= len(arr) {\\n                break\\n            }\\n            heap.Push(&others, sum)\\n            poss := others[0] + arr[j + lens[1 - i]]\\n            if poss > res {\\n                res = poss\\n            }   \\n        }        \\n    }\\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport (\\n    \"container/heap\"\\n)\\n\\ntype Heap []int\\n\\nfunc (h Heap) Len() int { \\n    return len(h) \\n}\\nfunc (h Heap) Less(i, j int) bool {\\n    return h[i] > h[j]\\n}\\n\\nfunc (h Heap) Swap(i, j int) {\\n    h[i], h[j] = h[j], h[i]\\n}\\n\\nfunc (h *Heap) Push(x interface{}) {\\n    *h = append(*h, x.(int))\\n}\\n\\nfunc (h *Heap) Pop() interface{} {\\n    poo := *h\\n    item := poo[len(poo) - 1]\\n    *h = poo[0: len(poo) - 1]\\n    return item\\n}\\n\\nfunc maxSumTwoNoOverlap(A []int, L int, M int) int {\\n    L_sums, M_sums := []int{}, []int{}\\n    for i, num := range A {\\n        if i == 0 {\\n            L_sums = append(L_sums, num)\\n            M_sums = append(M_sums, num)\\n        } else {\\n            L_new := L_sums[i - 1] + num\\n            M_new := M_sums[i - 1] + num\\n            if i >= L {\\n                L_new -= A[i - L]\\n            }\\n            if i >= M {\\n                M_new -= A[i - M]\\n            }\\n            L_sums = append(L_sums, L_new)\\n            M_sums = append(M_sums, M_new)\\n        }\\n    }\\n    L_sums, M_sums = L_sums[L - 1:], M_sums[M - 1:]\\n    arrs := [][]int{L_sums, M_sums}\\n    lens := []int{L, M} \\n    res := 0\\n    for i, arr := range arrs {\\n        var others Heap\\n        heap.Init(&others)\\n        for j, sum := range arrs[1 - i] {\\n            if j + lens[1 - i] >= len(arr) {\\n                break\\n            }\\n            heap.Push(&others, sum)\\n            poss := others[0] + arr[j + lens[1 - i]]\\n            if poss > res {\\n                res = poss\\n            }   \\n        }        \\n    }\\n    return res\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 287988,
                "title": "straight-forward-sliding-window-java-solution",
                "content": "```\\n\\nclass Solution {\\n    class Window {\\n        int start, end;\\n        int sum;\\n        int len;\\n        public Window(int s, int e, int sum) {\\n            start = s;\\n            end = e;\\n            this.sum = sum;\\n            this.len = end - start + 1;\\n        }\\n    }\\n\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        List<Window> Ls = getWindows(A, L);\\n        List<Window> Ms = getWindows(A, M);\\n        int res = 0;\\n        for (int i = 0; i < Ls.size(); i++) {\\n            for (int j = 0; j < Ms.size(); j++) {\\n                if (notIntersacte(Ls.get(i), Ms.get(j))) {\\n                    res = Math.max(res, Ls.get(i).sum + Ms.get(j).sum);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private List<Window> getWindows(int[] A, int len) {\\n        List<Window> windows = new ArrayList<>();\\n        int start = 0, end = 0, sum = 0;\\n        while (end < len) {\\n            sum += A[end];\\n            end++;\\n        }\\n        end--;\\n        while (end < A.length) {\\n            windows.add(new Window(start, end, sum));\\n            // System.out.println(len + \",\" + sum);\\n            sum -= A[start];\\n            start++;\\n            end++;\\n            if (end == A.length) break;\\n            sum += A[end];\\n        }\\n        Collections.sort(windows, (a, b) -> b.sum - a.sum);\\n        return windows;\\n    }\\n    \\n    private boolean notIntersacte(Window w1, Window w2) {\\n        int s = Math.max(w1.start, w2.start);\\n        int e = Math.min(w1.end, w2.end);\\n        // System.out.println(w1.start + \" \" + w2.start + \" \" + w1.end + \" \" + w2.end);\\n        return e < s;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    class Window {\\n        int start, end;\\n        int sum;\\n        int len;\\n        public Window(int s, int e, int sum) {\\n            start = s;\\n            end = e;\\n            this.sum = sum;\\n            this.len = end - start + 1;\\n        }\\n    }\\n\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        List<Window> Ls = getWindows(A, L);\\n        List<Window> Ms = getWindows(A, M);\\n        int res = 0;\\n        for (int i = 0; i < Ls.size(); i++) {\\n            for (int j = 0; j < Ms.size(); j++) {\\n                if (notIntersacte(Ls.get(i), Ms.get(j))) {\\n                    res = Math.max(res, Ls.get(i).sum + Ms.get(j).sum);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private List<Window> getWindows(int[] A, int len) {\\n        List<Window> windows = new ArrayList<>();\\n        int start = 0, end = 0, sum = 0;\\n        while (end < len) {\\n            sum += A[end];\\n            end++;\\n        }\\n        end--;\\n        while (end < A.length) {\\n            windows.add(new Window(start, end, sum));\\n            // System.out.println(len + \",\" + sum);\\n            sum -= A[start];\\n            start++;\\n            end++;\\n            if (end == A.length) break;\\n            sum += A[end];\\n        }\\n        Collections.sort(windows, (a, b) -> b.sum - a.sum);\\n        return windows;\\n    }\\n    \\n    private boolean notIntersacte(Window w1, Window w2) {\\n        int s = Math.max(w1.start, w2.start);\\n        int e = Math.min(w1.end, w2.end);\\n        // System.out.println(w1.start + \" \" + w2.start + \" \" + w1.end + \" \" + w2.end);\\n        return e < s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 287427,
                "title": "java-time-o-n-space-o-1-with-brain-storming-process-and-comments",
                "content": "```\\nclass Solution {\\n    /**\\n    Brain storming:\\n        - Prefix sum: to calculate n-length continuous sub array easily\\n        - We can seperate this problem to 2 small sub problems. This solution basically combine 2 sub problems into one. Formula: Max(Max(c, a), Max(c, b)) = Max(c, Max(a, b))\\n            - L before M\\n            - M before L\\n            Then get the max result\\n        - Find max L-length sub array, find M-length sub array, then get the max result (resultA)\\n        - Find max M-length sub array, find L-length sub array, then get the max result (resultB)\\n        - Then get max of resultA and resultB\\n    */\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        // Construct prefix sum\\n        for (int i = 1; i < A.length; i++) {\\n            A[i] = A[i - 1] + A[i];\\n        }\\n        \\n        // Assign initial values so we can skip 1st run in below for loop\\n        int res = A[L + M - 1], maxL = A[L - 1], maxM = A[M - 1];\\n        \\n        // Either L before M or M before L, start this loop at index L + M\\n        for (int i = L + M; i < A.length; i++) {\\n            // Keep track maxL so far\\n            // L before M: A[i - M] - A[i - M - L] is sum of L-length sub array\\n            maxL = Math.max(maxL, A[i - M] - A[i - M - L]);\\n            // Keep track maxM so far\\n            // M before L: A[i - M] - A[i - L - M] is sum of M-length sub array\\n            maxM = Math.max(maxM, A[i - L] - A[i - L - M]);\\n            // Keep track res so far\\n            // maxL + (A[i] - A[i - M]): Sum of max L-length sub array and current M-length sub array\\n            // maxM + (A[i] - A[i - L]): Sum of max M-length sub array and current L-length sub array\\n            res = Math.max(res, Math.max(maxL + (A[i] - A[i - M]), maxM + (A[i] - A[i - L])));\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    /**\\n    Brain storming:\\n        - Prefix sum: to calculate n-length continuous sub array easily\\n        - We can seperate this problem to 2 small sub problems. This solution basically combine 2 sub problems into one. Formula: Max(Max(c, a), Max(c, b)) = Max(c, Max(a, b))\\n            - L before M\\n            - M before L\\n            Then get the max result\\n        - Find max L-length sub array, find M-length sub array, then get the max result (resultA)\\n        - Find max M-length sub array, find L-length sub array, then get the max result (resultB)\\n        - Then get max of resultA and resultB\\n    */\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        // Construct prefix sum\\n        for (int i = 1; i < A.length; i++) {\\n            A[i] = A[i - 1] + A[i];\\n        }\\n        \\n        // Assign initial values so we can skip 1st run in below for loop\\n        int res = A[L + M - 1], maxL = A[L - 1], maxM = A[M - 1];\\n        \\n        // Either L before M or M before L, start this loop at index L + M\\n        for (int i = L + M; i < A.length; i++) {\\n            // Keep track maxL so far\\n            // L before M: A[i - M] - A[i - M - L] is sum of L-length sub array\\n            maxL = Math.max(maxL, A[i - M] - A[i - M - L]);\\n            // Keep track maxM so far\\n            // M before L: A[i - M] - A[i - L - M] is sum of M-length sub array\\n            maxM = Math.max(maxM, A[i - L] - A[i - L - M]);\\n            // Keep track res so far\\n            // maxL + (A[i] - A[i - M]): Sum of max L-length sub array and current M-length sub array\\n            // maxM + (A[i] - A[i - L]): Sum of max M-length sub array and current L-length sub array\\n            res = Math.max(res, Math.max(maxL + (A[i] - A[i - M]), maxM + (A[i] - A[i - L])));\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 283759,
                "title": "javascript-o-n",
                "content": "```\\nvar maxSumTwoNoOverlap = function(A, L, M) {\\n    let len = A.length;\\n    for(let i = 1; i < len; i++) {\\n        A[i] += A[i - 1];\\n    }\\n    \\n    let LMax = A[L - 1], MMax = A[M-1];\\n    let res = A[M + L - 1];\\n    for(let i = M + L ; i< len ; i++) {\\n        // update LMax to i - M; \\n        LMax = Math.max(LMax, A[i - M ] - A[i - M - L]);\\n        MMax = Math.max(MMax, A[i - L ] - A[i - M - L]);\\n        res = Math.max(res,\\n            LMax + A[i] - A[i - M],\\n            MMax + A[i] - A[i - L]\\n        )\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar maxSumTwoNoOverlap = function(A, L, M) {\\n    let len = A.length;\\n    for(let i = 1; i < len; i++) {\\n        A[i] += A[i - 1];\\n    }\\n    \\n    let LMax = A[L - 1], MMax = A[M-1];\\n    let res = A[M + L - 1];\\n    for(let i = M + L ; i< len ; i++) {\\n        // update LMax to i - M; \\n        LMax = Math.max(LMax, A[i - M ] - A[i - M - L]);\\n        MMax = Math.max(MMax, A[i - L ] - A[i - M - L]);\\n        res = Math.max(res,\\n            LMax + A[i] - A[i - M],\\n            MMax + A[i] - A[i - L]\\n        )\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 282720,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n        \\n        cumsums = []\\n        cumsum = 0\\n        cumsums.append(cumsum)\\n        for num in A:\\n            cumsum += num\\n            cumsums.append(cumsum)\\n        n = len(A)\\n        ans = -float(\\'inf\\')\\n        print(cumsums)\\n        for i in range(0, n - L - M + 1):\\n            for j in range(i + L, n - M + 1):\\n                ans = max(ans, cumsums[i + L] - cumsums[i] + cumsums[j + M] - cumsums[j])\\n        for i in range(0, n - M - L + 1):\\n            for j in range(i + M, n - L + 1):\\n                ans = max(ans, cumsums[i + M] - cumsums[i] + cumsums[j + L] - cumsums[j])\\n        return ans\\n\\t\\t\\n\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n        \\n        cumsums = []\\n        cumsum = 0\\n        cumsums.append(cumsum)\\n        for num in A:\\n            cumsum += num\\n            cumsums.append(cumsum)\\n        n = len(A)\\n        ans = -float(\\'inf\\')\\n        print(cumsums)\\n        for i in range(0, n - L - M + 1):\\n            for j in range(i + L, n - M + 1):\\n                ans = max(ans, cumsums[i + L] - cumsums[i] + cumsums[j + M] - cumsums[j])\\n        for i in range(0, n - M - L + 1):\\n            for j in range(i + M, n - L + 1):\\n                ans = max(ans, cumsums[i + M] - cumsums[i] + cumsums[j + L] - cumsums[j])\\n        return ans\\n\\t\\t\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 281514,
                "title": "c-solution-beats-100",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        // Size of array\\n        int size = A.size();\\n        \\n        // Partial sum\\n        vector<int> psum(size);\\n        partial_sum(A.begin(), A.end(), psum.begin());\\n        \\n        // Best L sum on LHS\\n        vector<int> llsum(size, 0);\\n        for (int i = L - 1; i < size; ++i) {\\n            llsum[i] = max(psum[i] - (i >= L ? psum[i - L] : 0), i ? llsum[i - 1] : 0);\\n        }\\n        \\n        // Best L sum on RHS\\n        vector<int> lrsum(size, 0);\\n        for (int i = size - L; i >= 0; --i) {\\n            lrsum[i] = max(psum[i + L - 1] - (i ? psum[i - 1] : 0), i < size - 1 ? lrsum[i + 1] : 0);\\n        }\\n        \\n        // Compute L and M sums\\n        int maxSum = psum[M - 1] + lrsum[M];\\n        for (int i = M; i < size; ++i) {\\n            int otherSum = max(i - M > L - 1 ? llsum[i - M] : 0, i < size - L ? lrsum[i + 1] : 0);\\n            \\n            if (otherSum == 0) {\\n                continue;\\n            }\\n            \\n            maxSum = max(maxSum, otherSum + psum[i] - psum[i - M]);\\n        }\\n        \\n        return maxSum;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        // Size of array\\n        int size = A.size();\\n        \\n        // Partial sum\\n        vector<int> psum(size);\\n        partial_sum(A.begin(), A.end(), psum.begin());\\n        \\n        // Best L sum on LHS\\n        vector<int> llsum(size, 0);\\n        for (int i = L - 1; i < size; ++i) {\\n            llsum[i] = max(psum[i] - (i >= L ? psum[i - L] : 0), i ? llsum[i - 1] : 0);\\n        }\\n        \\n        // Best L sum on RHS\\n        vector<int> lrsum(size, 0);\\n        for (int i = size - L; i >= 0; --i) {\\n            lrsum[i] = max(psum[i + L - 1] - (i ? psum[i - 1] : 0), i < size - 1 ? lrsum[i + 1] : 0);\\n        }\\n        \\n        // Compute L and M sums\\n        int maxSum = psum[M - 1] + lrsum[M];\\n        for (int i = M; i < size; ++i) {\\n            int otherSum = max(i - M > L - 1 ? llsum[i - M] : 0, i < size - L ? lrsum[i + 1] : 0);\\n            \\n            if (otherSum == 0) {\\n                continue;\\n            }\\n            \\n            maxSum = max(maxSum, otherSum + psum[i] - psum[i - M]);\\n        }\\n        \\n        return maxSum;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 281078,
                "title": "python-two-pointer-ish-solution",
                "content": "Assume the sub-array with length L is in front of the one with length M (call them `front` and `back`).  Have a pointer `i` at the end of `back`. Iterate all possible `i`,  use variable `front_best`  to hold the max value of sum of the `front` sub-array at each step. \\n\\n```\\nclass Solution(object):\\n    def maxSumTwoNoOverlap(self, A, L, M):\\n        \"\"\"\\n        :type A: List[int]\\n        :type L: int\\n        :type M: int\\n        :rtype: int\\n        \"\"\"\\n        A2 = [0] + A[:]\\n        for i in range(1, len(A2)):\\n            A2[i] = A2[i] + A2[i-1]\\n            \\n        def run(L, M):\\n            front_best = 0\\n            ans = 0\\n            for i in range(L+M, len(A2)):\\n                front = A2[i-M] - A2[i-M-L]\\n                back = A2[i] - A2[i-M]\\n                \\n                front_best = max(front, front_best)\\n                ans = max(back + front_best, ans)\\n            return ans\\n        \\n        return max(run(L, M), run(M, L))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxSumTwoNoOverlap(self, A, L, M):\\n        \"\"\"\\n        :type A: List[int]\\n        :type L: int\\n        :type M: int\\n        :rtype: int\\n        \"\"\"\\n        A2 = [0] + A[:]\\n        for i in range(1, len(A2)):\\n            A2[i] = A2[i] + A2[i-1]\\n            \\n        def run(L, M):\\n            front_best = 0\\n            ans = 0\\n            for i in range(L+M, len(A2)):\\n                front = A2[i-M] - A2[i-M-L]\\n                back = A2[i] - A2[i-M]\\n                \\n                front_best = max(front, front_best)\\n                ans = max(back + front_best, ans)\\n            return ans\\n        \\n        return max(run(L, M), run(M, L))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 279537,
                "title": "c-clean-soln-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        vector<int> prefixSums;\\n        int sum = 0;\\n        prefixSums.push_back(sum);\\n        for (auto i : A) {\\n            sum += i;\\n            prefixSums.push_back(sum);\\n        }\\n        \\n        int result = -1;\\n        for (int i = L; i < prefixSums.size(); i++) {\\n            // subarray sum of len L:\\n            auto lsum = prefixSums[i] - prefixSums[i-L];\\n            // for this prefix array of [i,i+L-1], find the prefix array of size\\n            // [j,j+M-1] where j is before and after i without overlap\\n            \\n            // 1. after:\\n            int msum = -1;\\n            for (int j = i + M; j < prefixSums.size(); j++) {\\n                // add subarray sum of len M to sum:\\n                msum = max(msum, prefixSums[j] - prefixSums[j-M]);\\n            }\\n            \\n            // 2. before:\\n            for (int j = M; j < i - L + 1; j++) {\\n                // add subarray sum of len M to sum:\\n                msum = max(msum, prefixSums[j] - prefixSums[j-M]);\\n            }\\n            result = max(result, lsum + msum);\\n        }\\n        \\n        return result;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        vector<int> prefixSums;\\n        int sum = 0;\\n        prefixSums.push_back(sum);\\n        for (auto i : A) {\\n            sum += i;\\n            prefixSums.push_back(sum);\\n        }\\n        \\n        int result = -1;\\n        for (int i = L; i < prefixSums.size(); i++) {\\n            // subarray sum of len L:\\n            auto lsum = prefixSums[i] - prefixSums[i-L];\\n            // for this prefix array of [i,i+L-1], find the prefix array of size\\n            // [j,j+M-1] where j is before and after i without overlap\\n            \\n            // 1. after:\\n            int msum = -1;\\n            for (int j = i + M; j < prefixSums.size(); j++) {\\n                // add subarray sum of len M to sum:\\n                msum = max(msum, prefixSums[j] - prefixSums[j-M]);\\n            }\\n            \\n            // 2. before:\\n            for (int j = M; j < i - L + 1; j++) {\\n                // add subarray sum of len M to sum:\\n                msum = max(msum, prefixSums[j] - prefixSums[j-M]);\\n            }\\n            result = max(result, lsum + msum);\\n        }\\n        \\n        return result;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 278962,
                "title": "c-solutoin-o-n-with-explanation",
                "content": "### z-array (technical name=partial sum array):- array containing sum of all previous + current elements;\\n\\n* there is a function called \"partial_sum\" in c++ with the help of this you can make partial sum array in O(n) time complexity.\\n* syntax for partial_sum\\n```\\npartial_sum( v1.begin(),v1.end(),v2.begin() ); // this will make partial sum array of v1 and store the resulting array in v2\\n```\\n```\\nclass Solution {\\npublic:   \\n    int maxSumTwoNoOverlap(vector<int>& ar, int l, int m) {\\n    vector<int> zarray;\\n\\tint sum=0;\\n\\tfor(int x:ar)\\n\\t{\\n\\t\\tsum+=x;\\n\\t\\tzarray.push_back(sum);\\t\\t\\t\\t//making z-array\\n\\t}\\n\\t\\t/*\\n\\t\\t\\t or i can simple use partial_sum to make zarray as follow-\\n\\t\\t\\t partial_sum(ar.begin(),ar.end(),zarray.begin());\\n\\t\\t*/\\n\\t\\n\\tint lmax,mmax,res;\\n\\tres = zarray[m+l-1];\\t\\t\\t\\t\\t// first ans will be 0 - l and l+1 to m+l-1 or 0 - m and m+1 to m+l -1 as for the first ans order doesn\\'t matter \\n\\tlmax = zarray[l-1];\\t\\t\\t\\t\\t\\t// lmax if we start with 0th element\\n\\tmmax = zarray[m-1];\\t\\t\\t\\t\\t\\t// mmax if we start with 0th element\\n\\tfor(int i =l+m;i<zarray.size();i++)\\n\\t{\\n\\t\\tlmax = max(lmax,zarray[i-m]- zarray[i-m-l]);// finding lmax (comparing lmax with lmax(1,2,3,4) i,e,. with lmax value if we start with 1th ,2nd..element \\n\\t\\tmmax = max(mmax,zarray[i-l]-zarray[i-m-l]);//doing same as above\\n\\t\\tres = max (res,max(lmax + zarray[i]-zarray[i-m],mmax + zarray[i]-zarray[i-l]));\\t// comparing res(max value) with result obtain when \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//\"l is before m\" and result obtain when \"m is before l\"\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//i,e,.  in other word we assume \"m\\'s subarray\" to be at end of resultant subarray and choose lmax then find the resultant sum\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// then do the same with assuming \"l\\'s subarray\" at the end.. and finally compare these two results with the current max res.\\n\\n\\t}\\n\\treturn res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\npartial_sum( v1.begin(),v1.end(),v2.begin() ); // this will make partial sum array of v1 and store the resulting array in v2\\n```\n```\\nclass Solution {\\npublic:   \\n    int maxSumTwoNoOverlap(vector<int>& ar, int l, int m) {\\n    vector<int> zarray;\\n\\tint sum=0;\\n\\tfor(int x:ar)\\n\\t{\\n\\t\\tsum+=x;\\n\\t\\tzarray.push_back(sum);\\t\\t\\t\\t//making z-array\\n\\t}\\n\\t\\t/*\\n\\t\\t\\t or i can simple use partial_sum to make zarray as follow-\\n\\t\\t\\t partial_sum(ar.begin(),ar.end(),zarray.begin());\\n\\t\\t*/\\n\\t\\n\\tint lmax,mmax,res;\\n\\tres = zarray[m+l-1];\\t\\t\\t\\t\\t// first ans will be 0 - l and l+1 to m+l-1 or 0 - m and m+1 to m+l -1 as for the first ans order doesn\\'t matter \\n\\tlmax = zarray[l-1];\\t\\t\\t\\t\\t\\t// lmax if we start with 0th element\\n\\tmmax = zarray[m-1];\\t\\t\\t\\t\\t\\t// mmax if we start with 0th element\\n\\tfor(int i =l+m;i<zarray.size();i++)\\n\\t{\\n\\t\\tlmax = max(lmax,zarray[i-m]- zarray[i-m-l]);// finding lmax (comparing lmax with lmax(1,2,3,4) i,e,. with lmax value if we start with 1th ,2nd..element \\n\\t\\tmmax = max(mmax,zarray[i-l]-zarray[i-m-l]);//doing same as above\\n\\t\\tres = max (res,max(lmax + zarray[i]-zarray[i-m],mmax + zarray[i]-zarray[i-l]));\\t// comparing res(max value) with result obtain when \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//\"l is before m\" and result obtain when \"m is before l\"\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//i,e,.  in other word we assume \"m\\'s subarray\" to be at end of resultant subarray and choose lmax then find the resultant sum\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// then do the same with assuming \"l\\'s subarray\" at the end.. and finally compare these two results with the current max res.\\n\\n\\t}\\n\\treturn res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 278757,
                "title": "c-8-line-solution",
                "content": "1. parial_sum gives us the ability to get the sum of a range form index i to j in O(1) time (by subtract p[i] - p[j])\\n2. Then we can just brute force in quadratic time all the different combinations of ranges (seeing as the length of array is only 10^3)\\n\\nVideo eplanation std::partial_sum here: https://youtu.be/Mf90cdF2N-o\\n```\\nint maxSumTwoNoOverlap(vector<int>& v, int L, int M) {\\n    int n = v.size(), ans = 0;\\n    vector<int> p(n+1, 0);\\n    partial_sum(v.begin(), v.end(), p.begin()+1); // partial sum give us O(1) sum of range\\n    for (int i = L, j = 0; i < n+1; ++i, ++j)\\n        for (int x = M, y = 0; x < n+1; ++x, ++y)\\n            if (x <= j || y >= i) // avoid overlap\\n                ans = max(ans, p[i] - p[j] + p[x] - p[y]); \\n    return ans;\\n};",
                "solutionTags": [],
                "code": "1. parial_sum gives us the ability to get the sum of a range form index i to j in O(1) time (by subtract p[i] - p[j])\\n2. Then we can just brute force in quadratic time all the different combinations of ranges (seeing as the length of array is only 10^3)\\n\\nVideo eplanation std::partial_sum here: https://youtu.be/Mf90cdF2N-o\\n```\\nint maxSumTwoNoOverlap(vector<int>& v, int L, int M) {\\n    int n = v.size(), ans = 0;\\n    vector<int> p(n+1, 0);\\n    partial_sum(v.begin(), v.end(), p.begin()+1); // partial sum give us O(1) sum of range\\n    for (int i = L, j = 0; i < n+1; ++i, ++j)\\n        for (int x = M, y = 0; x < n+1; ++x, ++y)\\n            if (x <= j || y >= i) // avoid overlap\\n                ans = max(ans, p[i] - p[j] + p[x] - p[y]); \\n    return ans;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 4099861,
                "title": "easy-understanding-dp-prefix-sum-memoization-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int fun(int i,int k,int prev,int l1,int l2,vector<int> &nums, vector<vector<vector<int>>> &dp,vector<int> &prefix)\\n    {\\n        int n = nums.size();\\n        if (k == 0 || i == n)\\n        {\\n            return 0;\\n        }\\n\\n        if (dp[i][k][prev+1] != -1)\\n        {\\n            return dp[i][k][prev+1];\\n        }\\n\\n        int sum1 = 0;\\n        int maxi = 0;\\n        if ((prev == -1 || prev == 1) && i+l1<=n)\\n        {\\n\\n            sum1 = prefix[i+l1]-prefix[i];\\n\\n    \\n\\n            int pick = sum1 + fun(i+l1,k-1,2,l1,l2,nums,dp,prefix);\\n            maxi = max(maxi,pick);\\n        }\\n\\n        int sum2 = 0;\\n        if ((prev == 2 || prev == -1) && i+l2<=n)\\n        {\\n            \\n            sum2 = prefix[i+l2]-prefix[i];\\n\\n\\n            int pick = sum2 + fun(i+l2,k-1,1,l1,l2,nums,dp,prefix);\\n            maxi = max(maxi,pick);\\n        }\\n        int notpick = fun(i+1,k,prev,l1,l2,nums,dp,prefix);\\n\\n        maxi = max(maxi,notpick);\\n        return dp[i][k][prev+1]=maxi;\\n    }\\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        vector<vector<vector<int>>> dp(nums.size()+1,vector<vector<int>>(3,vector<int>(4,-1)));\\n        int n = nums.size();\\n        vector<int> prefix(n+1,0);\\n        prefix[0] = 0;\\n        for (int i = 1;i<=n;i++)\\n        {\\n            prefix[i] = prefix[i-1] + nums[i-1];\\n        }\\n        return fun(0,2,-1,firstLen,secondLen,nums,dp,prefix);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fun(int i,int k,int prev,int l1,int l2,vector<int> &nums, vector<vector<vector<int>>> &dp,vector<int> &prefix)\\n    {\\n        int n = nums.size();\\n        if (k == 0 || i == n)\\n        {\\n            return 0;\\n        }\\n\\n        if (dp[i][k][prev+1] != -1)\\n        {\\n            return dp[i][k][prev+1];\\n        }\\n\\n        int sum1 = 0;\\n        int maxi = 0;\\n        if ((prev == -1 || prev == 1) && i+l1<=n)\\n        {\\n\\n            sum1 = prefix[i+l1]-prefix[i];\\n\\n    \\n\\n            int pick = sum1 + fun(i+l1,k-1,2,l1,l2,nums,dp,prefix);\\n            maxi = max(maxi,pick);\\n        }\\n\\n        int sum2 = 0;\\n        if ((prev == 2 || prev == -1) && i+l2<=n)\\n        {\\n            \\n            sum2 = prefix[i+l2]-prefix[i];\\n\\n\\n            int pick = sum2 + fun(i+l2,k-1,1,l1,l2,nums,dp,prefix);\\n            maxi = max(maxi,pick);\\n        }\\n        int notpick = fun(i+1,k,prev,l1,l2,nums,dp,prefix);\\n\\n        maxi = max(maxi,notpick);\\n        return dp[i][k][prev+1]=maxi;\\n    }\\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        vector<vector<vector<int>>> dp(nums.size()+1,vector<vector<int>>(3,vector<int>(4,-1)));\\n        int n = nums.size();\\n        vector<int> prefix(n+1,0);\\n        prefix[0] = 0;\\n        for (int i = 1;i<=n;i++)\\n        {\\n            prefix[i] = prefix[i-1] + nums[i-1];\\n        }\\n        return fun(0,2,-1,firstLen,secondLen,nums,dp,prefix);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4091034,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    void subArray(vector<int>& nums,int l,vector<int>&arr){\\n        int sum = 0;\\n        int j = 0;\\n        for(int i = 0;i < l && i < n;i++)\\n            sum += nums[i];\\n        arr[j++] = sum;\\n        for(int i = l;i<n;i++){\\n            sum += nums[i];\\n            sum -= nums[i - l];\\n            arr[j++] = sum;\\n        }\\n    }\\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        n = nums.size();\\n        vector<int>arr1(n-firstLen+1,0);\\n        vector<int>arr2(n-secondLen+1,0);\\n        subArray(nums,firstLen,arr1);\\n        subArray(nums,secondLen,arr2);\\n        int ans = 0;\\n        for(int i = 0;i <= n-firstLen;i++){\\n            int sum = arr1[i];\\n            for(int j = 0; j < i;j++)\\n                if(i > j + secondLen-1 )\\n                    ans = max(ans,sum+arr2[j]);\\n            for(int j = i + firstLen;j <= n - secondLen;j++)\\n                ans = max(ans,sum+arr2[j]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    void subArray(vector<int>& nums,int l,vector<int>&arr){\\n        int sum = 0;\\n        int j = 0;\\n        for(int i = 0;i < l && i < n;i++)\\n            sum += nums[i];\\n        arr[j++] = sum;\\n        for(int i = l;i<n;i++){\\n            sum += nums[i];\\n            sum -= nums[i - l];\\n            arr[j++] = sum;\\n        }\\n    }\\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        n = nums.size();\\n        vector<int>arr1(n-firstLen+1,0);\\n        vector<int>arr2(n-secondLen+1,0);\\n        subArray(nums,firstLen,arr1);\\n        subArray(nums,secondLen,arr2);\\n        int ans = 0;\\n        for(int i = 0;i <= n-firstLen;i++){\\n            int sum = arr1[i];\\n            for(int j = 0; j < i;j++)\\n                if(i > j + secondLen-1 )\\n                    ans = max(ans,sum+arr2[j]);\\n            for(int j = i + firstLen;j <= n - secondLen;j++)\\n                ans = max(ans,sum+arr2[j]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4051624,
                "title": "java-o-n",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] nums, int firstLen, int secondLen) {\\n        \\n        int first[] = new int[nums.length+1] , second[] = new int[nums.length+1] ;\\n        int n = nums.length  , sum1 = 0 ,sum2 = 0 ;\\n        for( int i = n-1 ; i > -1 ; i--){\\n            sum1 += nums[i];\\n            sum2 += nums[i];\\n            if( n - i  >= firstLen){\\n                sum1-= ( n-i == firstLen ? 0 :  nums[i+firstLen]);\\n                first[i] = Math.max( first[i+1] , sum1);\\n            }\\n            if( n-i >= secondLen){\\n                sum2-= ( n-i == secondLen ? 0 :  nums[i+secondLen]);\\n                second[i] = Math.max( second[i+1] , sum2);\\n            }\\n        }\\n\\n        return Math.max( algo(firstLen , nums , second) , algo( secondLen ,nums ,first));\\n    \\n    }\\n    public int algo( int len , int nums[],int arr[]){\\n        int res = 0  , sumd = 0;\\n        for( int i = 0 ; i <nums.length ; i++ ){\\n            sumd += nums[i];\\n            if( i >= len-1){\\n                int l = ( i == len-1 ? 0 : nums[i-len]);\\n                sumd -= l ;\\n                res = Math.max( res , sumd + arr[i+1]);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] nums, int firstLen, int secondLen) {\\n        \\n        int first[] = new int[nums.length+1] , second[] = new int[nums.length+1] ;\\n        int n = nums.length  , sum1 = 0 ,sum2 = 0 ;\\n        for( int i = n-1 ; i > -1 ; i--){\\n            sum1 += nums[i];\\n            sum2 += nums[i];\\n            if( n - i  >= firstLen){\\n                sum1-= ( n-i == firstLen ? 0 :  nums[i+firstLen]);\\n                first[i] = Math.max( first[i+1] , sum1);\\n            }\\n            if( n-i >= secondLen){\\n                sum2-= ( n-i == secondLen ? 0 :  nums[i+secondLen]);\\n                second[i] = Math.max( second[i+1] , sum2);\\n            }\\n        }\\n\\n        return Math.max( algo(firstLen , nums , second) , algo( secondLen ,nums ,first));\\n    \\n    }\\n    public int algo( int len , int nums[],int arr[]){\\n        int res = 0  , sumd = 0;\\n        for( int i = 0 ; i <nums.length ; i++ ){\\n            sumd += nums[i];\\n            if( i >= len-1){\\n                int l = ( i == len-1 ? 0 : nums[i-len]);\\n                sumd -= l ;\\n                res = Math.max( res , sumd + arr[i+1]);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038099,
                "title": "go-sliding-window-o-n2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc maxSumTwoNoOverlap(nums []int, firstLen int, secondLen int) int {\\n  \\n\\n    return max(findMaxSum(nums, firstLen, secondLen), findMaxSum(nums, secondLen, firstLen))\\n}\\n\\nfunc findMaxSum(nums []int, firstLen int, secondLen int) int{\\n  n := len(nums)\\n    fs := 0 \\n    fe := 0 \\n  \\n    maxSum := 0 \\n    sum := 0 \\n\\n    for fe < n - secondLen  {\\n      sum += nums[fe]\\n\\n      if fe - fs + 1 == firstLen {\\n\\n          ss := fe + 1\\n          se := fe + 1\\n          secondSum := 0\\n\\n          for se < n {\\n            secondSum += nums[se]\\n\\n            if se - ss + 1 == secondLen {\\n              if sum + secondSum > maxSum {\\n                maxSum = sum + secondSum\\n              }\\n\\n              // Slide the second subarray window by one. \\n              secondSum -= nums[ss]\\n              ss++\\n              se++\\n            }else {\\n              se++\\n            }\\n          }\\n\\n          // Now slide the first window \\n          sum -= nums[fs]\\n          fs++\\n          fe++\\n\\n      }else {\\n        fe++\\n      }\\n    }\\n\\n    return maxSum\\n}\\n\\nfunc max(a int, b int) int {\\n  if a > b {\\n    return a\\n  }else {\\n    return b\\n  }\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maxSumTwoNoOverlap(nums []int, firstLen int, secondLen int) int {\\n  \\n\\n    return max(findMaxSum(nums, firstLen, secondLen), findMaxSum(nums, secondLen, firstLen))\\n}\\n\\nfunc findMaxSum(nums []int, firstLen int, secondLen int) int{\\n  n := len(nums)\\n    fs := 0 \\n    fe := 0 \\n  \\n    maxSum := 0 \\n    sum := 0 \\n\\n    for fe < n - secondLen  {\\n      sum += nums[fe]\\n\\n      if fe - fs + 1 == firstLen {\\n\\n          ss := fe + 1\\n          se := fe + 1\\n          secondSum := 0\\n\\n          for se < n {\\n            secondSum += nums[se]\\n\\n            if se - ss + 1 == secondLen {\\n              if sum + secondSum > maxSum {\\n                maxSum = sum + secondSum\\n              }\\n\\n              // Slide the second subarray window by one. \\n              secondSum -= nums[ss]\\n              ss++\\n              se++\\n            }else {\\n              se++\\n            }\\n          }\\n\\n          // Now slide the first window \\n          sum -= nums[fs]\\n          fs++\\n          fe++\\n\\n      }else {\\n        fe++\\n      }\\n    }\\n\\n    return maxSum\\n}\\n\\nfunc max(a int, b int) int {\\n  if a > b {\\n    return a\\n  }else {\\n    return b\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3982077,
                "title": "java-o-n-easy-to-understand-commented-explanation-1ms",
                "content": "\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public int maxSumTwoNoOverlap(int[] nums, int firstLen, int secondLen) {\\n        int prefix[]=new int[nums.length];\\n        int sum=0;\\n        int ans=0;\\n    // creating prefix sum array\\n        for(int i =0;i<nums.length;i++)\\n            {prefix[i]=sum+nums[i];\\n            sum=sum+nums[i];}\\n            \\n         int f=firstLen;\\n         int s=secondLen;\\n\\n        //first firstlen and then secondlen\\n        //what happens in this loop is \\n        //considering nums[i] in s length sub-array\\n        //what is max value of f length sub-array in nums[i-s]\\n         int maxf=prefix[f-1];\\n         int maxs=prefix[(s+f)-1]-prefix[f-1];\\n         int ans_fs=maxf+maxs;\\n         for(int i =(f+s);i<prefix.length;i++)\\n         {    maxf=Math.max(maxf,prefix[i-s]-prefix[i-(s+f)]);\\n              maxs=prefix[i]-prefix[i-s];\\n              ans_fs=Math.max(ans_fs,maxf+maxs);\\n         }\\n\\n         //first secondlen and then firstlen\\n         //what happens in this loop is \\n         //considering nums[i] in f length sub-array\\n         //what is max value of s length sub-array in nums[i-f]\\n         maxs=prefix[s-1];\\n         maxf=prefix[(s+f)-1]-prefix[s-1];\\n         int ans_sf=maxs+maxf;\\n         for(int i=(f+s);i<prefix.length;i++)\\n         { maxs=Math.max(maxs,prefix[i-f]-prefix[i-(s+f)]);\\n           maxf=prefix[i]-prefix[i-f];\\n           ans_sf=Math.max(ans_sf,maxs+maxf);\\n         }\\n        \\n         ans=Math.max(ans_sf,ans_fs);\\n         return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int maxSumTwoNoOverlap(int[] nums, int firstLen, int secondLen) {\\n        int prefix[]=new int[nums.length];\\n        int sum=0;\\n        int ans=0;\\n    // creating prefix sum array\\n        for(int i =0;i<nums.length;i++)\\n            {prefix[i]=sum+nums[i];\\n            sum=sum+nums[i];}\\n            \\n         int f=firstLen;\\n         int s=secondLen;\\n\\n        //first firstlen and then secondlen\\n        //what happens in this loop is \\n        //considering nums[i] in s length sub-array\\n        //what is max value of f length sub-array in nums[i-s]\\n         int maxf=prefix[f-1];\\n         int maxs=prefix[(s+f)-1]-prefix[f-1];\\n         int ans_fs=maxf+maxs;\\n         for(int i =(f+s);i<prefix.length;i++)\\n         {    maxf=Math.max(maxf,prefix[i-s]-prefix[i-(s+f)]);\\n              maxs=prefix[i]-prefix[i-s];\\n              ans_fs=Math.max(ans_fs,maxf+maxs);\\n         }\\n\\n         //first secondlen and then firstlen\\n         //what happens in this loop is \\n         //considering nums[i] in f length sub-array\\n         //what is max value of s length sub-array in nums[i-f]\\n         maxs=prefix[s-1];\\n         maxf=prefix[(s+f)-1]-prefix[s-1];\\n         int ans_sf=maxs+maxf;\\n         for(int i=(f+s);i<prefix.length;i++)\\n         { maxs=Math.max(maxs,prefix[i-f]-prefix[i-(s+f)]);\\n           maxf=prefix[i]-prefix[i-f];\\n           ans_sf=Math.max(ans_sf,maxs+maxf);\\n         }\\n        \\n         ans=Math.max(ans_sf,ans_fs);\\n         return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1799476,
                "content": [
                    {
                        "username": "raghavrathore7415",
                        "content": "Man this question is hard"
                    },
                    {
                        "username": "the_arc_knight_24",
                        "content": "[8,20,6,2,20,17,6,3,20,8,12]\\nfirstLen=5 secondLen=4\\n\\nNot able to understand how thtis question is returning 108 as per the logic it should give 102. 66 for subarray of length 5 and 36 from subarray of length 4.\\n"
                    },
                    {
                        "username": "yash161220",
                        "content": "Right ans is 108 bec.. 5 length subarray sum is 65 (20+6+2+20+17) and 4 length sum is 43 (3+20+8+12) so total = 108"
                    },
                    {
                        "username": "mycoolhairison",
                        "content": "The subarray of length 5 starting at the first \"20\" has sum 65, and the subarray of length 4 ending at \"12\" has sum 43. "
                    },
                    {
                        "username": "guptadipanshu0001",
                        "content": "same doubt how is 108 coming max to max 102 will come\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This question is pretty tricky on the thinking part only - how you approach to a solution. Once you are there and figure out the very first point, the ride is a lot smooth down the next instant. Keep on thinking! You will definitely get a lot of positive energy solving this one."
                    },
                    {
                        "username": "prakhar__dixit",
                        "content": "Think about fixed length sliding window. \\nFix one window and move another window until the end is reached.\\n\\nThen slide the first window and repeat step 1."
                    }
                ]
            },
            {
                "id": 1835365,
                "content": [
                    {
                        "username": "raghavrathore7415",
                        "content": "Man this question is hard"
                    },
                    {
                        "username": "the_arc_knight_24",
                        "content": "[8,20,6,2,20,17,6,3,20,8,12]\\nfirstLen=5 secondLen=4\\n\\nNot able to understand how thtis question is returning 108 as per the logic it should give 102. 66 for subarray of length 5 and 36 from subarray of length 4.\\n"
                    },
                    {
                        "username": "yash161220",
                        "content": "Right ans is 108 bec.. 5 length subarray sum is 65 (20+6+2+20+17) and 4 length sum is 43 (3+20+8+12) so total = 108"
                    },
                    {
                        "username": "mycoolhairison",
                        "content": "The subarray of length 5 starting at the first \"20\" has sum 65, and the subarray of length 4 ending at \"12\" has sum 43. "
                    },
                    {
                        "username": "guptadipanshu0001",
                        "content": "same doubt how is 108 coming max to max 102 will come\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This question is pretty tricky on the thinking part only - how you approach to a solution. Once you are there and figure out the very first point, the ride is a lot smooth down the next instant. Keep on thinking! You will definitely get a lot of positive energy solving this one."
                    },
                    {
                        "username": "prakhar__dixit",
                        "content": "Think about fixed length sliding window. \\nFix one window and move another window until the end is reached.\\n\\nThen slide the first window and repeat step 1."
                    }
                ]
            },
            {
                "id": 1927453,
                "content": [
                    {
                        "username": "raghavrathore7415",
                        "content": "Man this question is hard"
                    },
                    {
                        "username": "the_arc_knight_24",
                        "content": "[8,20,6,2,20,17,6,3,20,8,12]\\nfirstLen=5 secondLen=4\\n\\nNot able to understand how thtis question is returning 108 as per the logic it should give 102. 66 for subarray of length 5 and 36 from subarray of length 4.\\n"
                    },
                    {
                        "username": "yash161220",
                        "content": "Right ans is 108 bec.. 5 length subarray sum is 65 (20+6+2+20+17) and 4 length sum is 43 (3+20+8+12) so total = 108"
                    },
                    {
                        "username": "mycoolhairison",
                        "content": "The subarray of length 5 starting at the first \"20\" has sum 65, and the subarray of length 4 ending at \"12\" has sum 43. "
                    },
                    {
                        "username": "guptadipanshu0001",
                        "content": "same doubt how is 108 coming max to max 102 will come\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This question is pretty tricky on the thinking part only - how you approach to a solution. Once you are there and figure out the very first point, the ride is a lot smooth down the next instant. Keep on thinking! You will definitely get a lot of positive energy solving this one."
                    },
                    {
                        "username": "prakhar__dixit",
                        "content": "Think about fixed length sliding window. \\nFix one window and move another window until the end is reached.\\n\\nThen slide the first window and repeat step 1."
                    }
                ]
            },
            {
                "id": 2055487,
                "content": [
                    {
                        "username": "raghavrathore7415",
                        "content": "Man this question is hard"
                    },
                    {
                        "username": "the_arc_knight_24",
                        "content": "[8,20,6,2,20,17,6,3,20,8,12]\\nfirstLen=5 secondLen=4\\n\\nNot able to understand how thtis question is returning 108 as per the logic it should give 102. 66 for subarray of length 5 and 36 from subarray of length 4.\\n"
                    },
                    {
                        "username": "yash161220",
                        "content": "Right ans is 108 bec.. 5 length subarray sum is 65 (20+6+2+20+17) and 4 length sum is 43 (3+20+8+12) so total = 108"
                    },
                    {
                        "username": "mycoolhairison",
                        "content": "The subarray of length 5 starting at the first \"20\" has sum 65, and the subarray of length 4 ending at \"12\" has sum 43. "
                    },
                    {
                        "username": "guptadipanshu0001",
                        "content": "same doubt how is 108 coming max to max 102 will come\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This question is pretty tricky on the thinking part only - how you approach to a solution. Once you are there and figure out the very first point, the ride is a lot smooth down the next instant. Keep on thinking! You will definitely get a lot of positive energy solving this one."
                    },
                    {
                        "username": "prakhar__dixit",
                        "content": "Think about fixed length sliding window. \\nFix one window and move another window until the end is reached.\\n\\nThen slide the first window and repeat step 1."
                    }
                ]
            }
        ]
    },
    {
        "title": "Parallel Courses II",
        "question_content": "<p>You are given an integer <code>n</code>, which indicates that there are <code>n</code> courses labeled from <code>1</code> to <code>n</code>. You are also given an array <code>relations</code> where <code>relations[i] = [prevCourse<sub>i</sub>, nextCourse<sub>i</sub>]</code>, representing a prerequisite relationship between course <code>prevCourse<sub>i</sub></code> and course <code>nextCourse<sub>i</sub></code>: course <code>prevCourse<sub>i</sub></code> has to be taken before course <code>nextCourse<sub>i</sub></code>. Also, you are given the integer <code>k</code>.</p>\n\n<p>In one semester, you can take <strong>at most</strong> <code>k</code> courses as long as you have taken all the prerequisites in the <strong>previous</strong> semesters for the courses you are taking.</p>\n\n<p>Return <em>the <strong>minimum</strong> number of semesters needed to take all courses</em>. The testcases will be generated such that it is possible to take every course.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/05/22/leetcode_parallel_courses_1.png\" style=\"width: 269px; height: 147px;\" />\n<pre>\n<strong>Input:</strong> n = 4, relations = [[2,1],[3,1],[1,4]], k = 2\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The figure above represents the given graph.\nIn the first semester, you can take courses 2 and 3.\nIn the second semester, you can take course 1.\nIn the third semester, you can take course 4.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/05/22/leetcode_parallel_courses_2.png\" style=\"width: 271px; height: 211px;\" />\n<pre>\n<strong>Input:</strong> n = 5, relations = [[2,1],[3,1],[4,1],[1,5]], k = 2\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> The figure above represents the given graph.\nIn the first semester, you can only take courses 2 and 3 since you cannot take more than two per semester.\nIn the second semester, you can take course 4.\nIn the third semester, you can take course 1.\nIn the fourth semester, you can take course 5.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 15</code></li>\n\t<li><code>1 &lt;= k &lt;= n</code></li>\n\t<li><code>0 &lt;= relations.length &lt;= n * (n-1) / 2</code></li>\n\t<li><code>relations[i].length == 2</code></li>\n\t<li><code>1 &lt;= prevCourse<sub>i</sub>, nextCourse<sub>i</sub> &lt;= n</code></li>\n\t<li><code>prevCourse<sub>i</sub> != nextCourse<sub>i</sub></code></li>\n\t<li>All the pairs <code>[prevCourse<sub>i</sub>, nextCourse<sub>i</sub>]</code> are <strong>unique</strong>.</li>\n\t<li>The given graph is a directed acyclic graph.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1373540,
                "title": "detailed-explanations-diagrams-annotated-code",
                "content": "## 0. Preface\\nThis is a *really* good problem. However, the solutions I found were either too complex or just did not make any sense. In this post, I\\'ll attempt to explain everything from top to bottom.\\n\\n## 1. Understading the Problem\\n**Given**:\\n- There are courses from `1 to n`, both inclusive.\\n- There are relations between the courses, given by a list of items: `[prev_course, next_course]`. This essentially means the following.\\n\\n![](https://i.imgur.com/40viwl5.png)\\n\\nThere\\'s one last thing, that gives this problem all the flavour. The value `k` is given to you. This represents the maximum number of nodes, \"courses\", you can select at a given time instant, \"sememter\", in this problem.\\n\\n**Goal**:\\nAs a college student, find the least numbers of semesters possible to complete all the courses ~~and escape the hell hole~~.\\n\\nNote how without the condition of `k`, this problem would just be a topological sorting problem.\\n\\n## 2. Examples\\nI\\'ll mention the examples mentioned in the question itself below, for the sake of completeness.\\n\\n**Example 1 (from question)**\\n![](https://i.imgur.com/PKmlSwG.png)\\n\\n```\\nInput: n = 4, dependencies = [[2,1],[3,1],[1,4]], k = 2\\nOutput: 3 \\nExplanation: The figure above represents the given graph.\\nIn the first semester, you can take courses 2 and 3.\\nIn the second semester, you can take course 1.\\nIn the third semester, you can take course 4.\\n```\\n\\n**Example 2 (from question)**\\n![](https://i.imgur.com/OR0xFHg.png)\\n```\\nInput: n = 5, dependencies = [[2,1],[3,1],[4,1],[1,5]], k = 2\\nOutput: 4 \\nExplanation: The figure above represents the given graph.\\nIn the first semester, you can take courses 2 and 3 only since you cannot take more than two per semester.\\nIn the second semester, you can take course 4.\\nIn the third semester, you can take course 1.\\nIn the fourth semester, you can take course 5.\\n```\\n\\n**Example 3 (from question)**\\n```\\nInput: n = 11, dependencies = [], k = 2\\nOutput: 6\\n```\\n\\n**Try it yourself**\\nIn my opinion, all of the above are *sneaky* examples. I ended up wasting hours on a wrong solution, because I missed a test case like the one below. Try if you can find the most optimal solution for `k = 2`. (Quick note: labels are immaterial)\\n\\n![](https://i.imgur.com/W6HZORP.png)\\n\\nTake a look at two such cases for this question.\\n![](https://i.imgur.com/NoIIpTd.png)\\n\\nWhat\\'s happening? Each semester\\'s worth of courses are enclosed in green, and enumerated in order. What do you observe?\\n- The selection of what you choose to be the first two (since `k = 2`) has a *drastic* impact on how you select the rest - and thus the answer. Think of it like the **butterfly effect**.\\n- There is no way to tell who is what, and which particular combination is any good. We may not know anything till the very end.\\n\\n## 3. The Approach\\n**Data Structures**\\n1. We need to know the layout of the graph, who points to what. Let\\'s keep a structure like `graph = {node: [children]}`\\n2. We also need to encode the information of how may in-edges are there for each node. We store that in a list like: `in_degrees = [values]`. We keep the `in_degrees` and `graph` separate for implementation reasons.\\n3. Implementation detail: the inputs are 1 indexed, we make everything 0-indexed for easier implementations.\\n\\n**Nodes**\\nThere are two types of nodes:\\n- There are nodes which have been already considered. Let\\'s label them with `0`.\\n- There are nodes which have not been taken yet. Let\\'s label them with `1`.\\n\\nNote that even if a node is marked `1`, it *does not* mean its `in_degree[node]` is `0`. It only means it needs to be taken - either in the present or in the future.  \\n\\nMoreover, labelling a node either `0` or `1` allows us to represent the status of the problem in a neat format. What we have done here is called **bit masking**. `mask = 10110` represents the nodes `1, 2, 4` are yet to be considered (aka the course is yet to be taken), and the rest have already been taken.\\n\\n**Recursion**\\nWe know that decisions taken now can produce different results later on. This makes the recursive approach favourable. For each particular iteration, we consider **all** the possible **combinations** of the **currently available nodes** - `in_degree[node] == 0 and mask & 1 << node`. The second part is checking if the `node`th bit is set in `mask`.\\n\\n\\n## 4. Annotated Code\\n```\\nfrom itertools import combinations # for picking k of n\\nclass Solution:\\n    @lru_cache(None) # caching for faster lookups\\n    def recurse(self, mask, in_degrees):\\n        # if all the bits are 0, we have taken all the courses\\n        if not mask: return 0\\n        \\n        # all the nodes that *can* be taken now, following both the properties\\n        nodes = [i for i in range(self.n) if mask & 1 << i and in_degrees[i] == 0]\\n        \\n        ans = float(\\'inf\\')\\n        # enumerating all the possible combinations\\n        for k_nodes in combinations(nodes, min(self.k, len(nodes))):\\n            new_mask, new_in_degrees = mask, list(in_degrees)\\n            \\n            # updating what would happen to new_mask and new_in_degrees \\n            # if we considered the nodes in k_nodes\\n            for node in k_nodes:\\n                # since we know the bit is set, we un-set this bit, to mark it \"considered\"\\n                new_mask ^= 1 << node\\n                # updating each of the in-degrees, since the \"parents\" have been taken away\\n                for child in self.graph[node]:\\n                    new_in_degrees[child] -= 1\\n            \\n            # the heart of recursion\\n            # note the +1!\\n            ans = min(ans, 1+self.recurse(new_mask, tuple(new_in_degrees)))\\n        return ans\\n    \\n    def minNumberOfSemesters(self, n: int, relations: List[List[int]], k: int) -> int:\\n        # saving n and k for later use\\n        self.n = n\\n        self.k = k\\n        in_degrees = [0]*self.n\\n        # graph layout remains the same, although the in_degrees change. \\n        # This allows us to keep graph as self.graph \\n        # instead of passing it over and over.\\n        self.graph = defaultdict(list)\\n        for prev_course, next_course in relations:\\n            # remember, its 0-indexed now!\\n            in_degrees[next_course - 1] += 1\\n            self.graph[prev_course - 1].append(next_course - 1)\\n        \\n        # start with all the bits set\\n        return self.recurse((1 << self.n) - 1, tuple(in_degrees))\\n```\\n\\n## 5. References\\n- https://leetcode.com/problems/parallel-courses-ii/discuss/710229/Python-Short-DP-with-Binary-Masks-O(n2*2n)-explained\\n- https://leetcode.com/problems/parallel-courses-ii/discuss/710229/Python-Short-DP-with-Binary-Masks-O(n2*2n)-explained/830096 < I took the code from this guy.\\n\\nAnyways, this wraps up the solution. If you found it helpful, upvote. More feedback or comments/criticisms? Let me know!",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nInput: n = 4, dependencies = [[2,1],[3,1],[1,4]], k = 2\\nOutput: 3 \\nExplanation: The figure above represents the given graph.\\nIn the first semester, you can take courses 2 and 3.\\nIn the second semester, you can take course 1.\\nIn the third semester, you can take course 4.\\n```\n```\\nInput: n = 5, dependencies = [[2,1],[3,1],[4,1],[1,5]], k = 2\\nOutput: 4 \\nExplanation: The figure above represents the given graph.\\nIn the first semester, you can take courses 2 and 3 only since you cannot take more than two per semester.\\nIn the second semester, you can take course 4.\\nIn the third semester, you can take course 1.\\nIn the fourth semester, you can take course 5.\\n```\n```\\nInput: n = 11, dependencies = [], k = 2\\nOutput: 6\\n```\n```\\nfrom itertools import combinations # for picking k of n\\nclass Solution:\\n    @lru_cache(None) # caching for faster lookups\\n    def recurse(self, mask, in_degrees):\\n        # if all the bits are 0, we have taken all the courses\\n        if not mask: return 0\\n        \\n        # all the nodes that *can* be taken now, following both the properties\\n        nodes = [i for i in range(self.n) if mask & 1 << i and in_degrees[i] == 0]\\n        \\n        ans = float(\\'inf\\')\\n        # enumerating all the possible combinations\\n        for k_nodes in combinations(nodes, min(self.k, len(nodes))):\\n            new_mask, new_in_degrees = mask, list(in_degrees)\\n            \\n            # updating what would happen to new_mask and new_in_degrees \\n            # if we considered the nodes in k_nodes\\n            for node in k_nodes:\\n                # since we know the bit is set, we un-set this bit, to mark it \"considered\"\\n                new_mask ^= 1 << node\\n                # updating each of the in-degrees, since the \"parents\" have been taken away\\n                for child in self.graph[node]:\\n                    new_in_degrees[child] -= 1\\n            \\n            # the heart of recursion\\n            # note the +1!\\n            ans = min(ans, 1+self.recurse(new_mask, tuple(new_in_degrees)))\\n        return ans\\n    \\n    def minNumberOfSemesters(self, n: int, relations: List[List[int]], k: int) -> int:\\n        # saving n and k for later use\\n        self.n = n\\n        self.k = k\\n        in_degrees = [0]*self.n\\n        # graph layout remains the same, although the in_degrees change. \\n        # This allows us to keep graph as self.graph \\n        # instead of passing it over and over.\\n        self.graph = defaultdict(list)\\n        for prev_course, next_course in relations:\\n            # remember, its 0-indexed now!\\n            in_degrees[next_course - 1] += 1\\n            self.graph[prev_course - 1].append(next_course - 1)\\n        \\n        # start with all the bits set\\n        return self.recurse((1 << self.n) - 1, tuple(in_degrees))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 709382,
                "title": "c-o-3-n-bitmask-dynamic-programming-code-with-comments-and-tutorial",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int minNumberOfSemesters(int n, vector<vector<int>>& dependencies, int k) {\\n        // dependency[i]: dependency mask of course i, the set bits is dependent\\n        vector<int> dependency(n, 0);\\n        for (size_t i = 0; i < dependencies.size(); ++i) {\\n            int course = dependencies[i][1] - 1;\\n            int prerequisite = dependencies[i][0] - 1;\\n            dependency[course] |= 1 << prerequisite;\\n        }\\n\\n        // prerequisites[i]: prerequisites mask of mask i, the set bits is prerequisites\\n        vector<int> prerequisites(1 << n, 0);\\n        // iterate all mask and generate prerequisites mask of each mask\\n        for (int i = 0; i < (1 << n); ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (i & (1 << j)) {\\n                    prerequisites[i] |= dependency[j];\\n                }\\n            }\\n        }\\n\\n        // dp[i]: minimum number of semesters of mask i, the set bits are courses that have not been taken\\n        vector<int> dp(1 << n, n + 1);\\n        dp[0] = 0;\\n        for (int i = 1; i < (1 << n); ++i) {\\n            // iterate all submask of mask i, and this mask is the mask of last semester\\n            // see: https://cp-algorithms.com/algebra/all-submasks.html\\n            for (int j = i; j; j = (j - 1) & i) {\\n                if (count_setbit(j) > k) {\\n                    continue;\\n                }\\n\\n                int already_taken = i ^ ((1 << n) - 1);\\n                if ((already_taken & prerequisites[j]) == prerequisites[j]) {\\n                    dp[i] = min(dp[i], dp[i ^ j] + 1);\\n                }\\n            }\\n        }\\n\\n        return dp[(1 << n) - 1];\\n    }\\n\\nprivate:\\n    int count_setbit(int mask) {\\n        if (mask == 0) {\\n            return 0;\\n        }\\n        return 1 + count_setbit(mask & (mask - 1));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minNumberOfSemesters(int n, vector<vector<int>>& dependencies, int k) {\\n        // dependency[i]: dependency mask of course i, the set bits is dependent\\n        vector<int> dependency(n, 0);\\n        for (size_t i = 0; i < dependencies.size(); ++i) {\\n            int course = dependencies[i][1] - 1;\\n            int prerequisite = dependencies[i][0] - 1;\\n            dependency[course] |= 1 << prerequisite;\\n        }\\n\\n        // prerequisites[i]: prerequisites mask of mask i, the set bits is prerequisites\\n        vector<int> prerequisites(1 << n, 0);\\n        // iterate all mask and generate prerequisites mask of each mask\\n        for (int i = 0; i < (1 << n); ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (i & (1 << j)) {\\n                    prerequisites[i] |= dependency[j];\\n                }\\n            }\\n        }\\n\\n        // dp[i]: minimum number of semesters of mask i, the set bits are courses that have not been taken\\n        vector<int> dp(1 << n, n + 1);\\n        dp[0] = 0;\\n        for (int i = 1; i < (1 << n); ++i) {\\n            // iterate all submask of mask i, and this mask is the mask of last semester\\n            // see: https://cp-algorithms.com/algebra/all-submasks.html\\n            for (int j = i; j; j = (j - 1) & i) {\\n                if (count_setbit(j) > k) {\\n                    continue;\\n                }\\n\\n                int already_taken = i ^ ((1 << n) - 1);\\n                if ((already_taken & prerequisites[j]) == prerequisites[j]) {\\n                    dp[i] = min(dp[i], dp[i ^ j] + 1);\\n                }\\n            }\\n        }\\n\\n        return dp[(1 << n) - 1];\\n    }\\n\\nprivate:\\n    int count_setbit(int mask) {\\n        if (mask == 0) {\\n            return 0;\\n        }\\n        return 1 + count_setbit(mask & (mask - 1));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 719159,
                "title": "dp-solution-with-memoization-and-bitmasks-with-c-code-20-ms-runtime",
                "content": "# **Approach**\\n- Use masks to represent the set of courses (nodes) taken, till now. If a bit in mask is 1, it means that course is taken.\\n- For a particular mask, calculate the indegree (pre-requesite) of each node, without including the edges from the nodes that are already taken. \\n- Now, at any stage, we can only chose any *subset* (submask) of the nodes with indegree as 0. This generates *overlapping subproblems*, which can be easily handled using DP with bitmasking.\\n\\n**For optimisation**\\nObserve that there are 2 cases :\\nLet p = number of nodes with indegree 0 at any stage\\n\\nCase I.  p > k \\nIn this case, it is optimal to take a subset of nodes having exactly k nodes.\\n\\nCase II.  p < k \\nIn this case, it is optimal to take all the p nodes.\\n\\n# **C++ Code**\\n```\\nclass Solution {\\n    vector<vector<int> > adj;  // adjacency list\\n    int n;\\n    int k;\\n    vector<int> dp;\\n    int solve(int mask)\\n    {\\n        if(mask==((1<<n)-1))\\n        {  // All courses are taken\\n            return 0;\\n        }\\n        if(dp[mask]!=-1)   // memoization\\n            return dp[mask];\\n        vector<int> indeg(n,0);\\n        for(int i=0; i<n; i++)\\n        {\\n            if(mask&(1<<i))\\n                continue;\\n            for(auto it: adj[i])\\n            {\\n                indeg[it]++;\\n            }\\n        }\\n        int temp=0;  // For a mask of all nodes with 0-indegree\\n        for(int i=0; i<n; i++)\\n        {\\n            if(indeg[i]==0&&!(mask&(1<<i)))\\n            {\\n                temp=temp|(1<<i);\\n            }\\n        }\\n        int j=temp;\\n        int cnt=__builtin_popcount(j);  // count of nodes with 0-indegree\\n\\n        int ans=n+1;  // ans will be \\'n\\' in the worst case, so take (n+1) as infinity \\n        if(cnt>k)\\n        {\\n            for( ; j ; j=(j-1)&temp )  // iterate through all submasks of temp\\n            {\\n                cnt=__builtin_popcount(j);  \\n                if(cnt!=k)   \\n                    continue;\\n                ans=min(ans,1+solve(mask|j));                   \\n            }\\n        }\\n        else\\n        {\\n            ans=min(ans,1+solve(mask|j));\\n        }\\n        return dp[mask]=ans;\\n    }\\n    \\n    public:\\n    int minNumberOfSemesters(int N, vector<vector<int>>& d, int K) {\\n        n=N;\\n        k=K;\\n        dp.assign(1<<n,-1);\\n        adj.clear();\\n        adj.resize(n);\\n        for(int i=0; i<d.size(); i++)\\n        {\\n            d[i][0]--;\\n            d[i][1]--;\\n            adj[d[i][0]].push_back(d[i][1]);\\n        }\\n        return solve(0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    vector<vector<int> > adj;  // adjacency list\\n    int n;\\n    int k;\\n    vector<int> dp;\\n    int solve(int mask)\\n    {\\n        if(mask==((1<<n)-1))\\n        {  // All courses are taken\\n            return 0;\\n        }\\n        if(dp[mask]!=-1)   // memoization\\n            return dp[mask];\\n        vector<int> indeg(n,0);\\n        for(int i=0; i<n; i++)\\n        {\\n            if(mask&(1<<i))\\n                continue;\\n            for(auto it: adj[i])\\n            {\\n                indeg[it]++;\\n            }\\n        }\\n        int temp=0;  // For a mask of all nodes with 0-indegree\\n        for(int i=0; i<n; i++)\\n        {\\n            if(indeg[i]==0&&!(mask&(1<<i)))\\n            {\\n                temp=temp|(1<<i);\\n            }\\n        }\\n        int j=temp;\\n        int cnt=__builtin_popcount(j);  // count of nodes with 0-indegree\\n\\n        int ans=n+1;  // ans will be \\'n\\' in the worst case, so take (n+1) as infinity \\n        if(cnt>k)\\n        {\\n            for( ; j ; j=(j-1)&temp )  // iterate through all submasks of temp\\n            {\\n                cnt=__builtin_popcount(j);  \\n                if(cnt!=k)   \\n                    continue;\\n                ans=min(ans,1+solve(mask|j));                   \\n            }\\n        }\\n        else\\n        {\\n            ans=min(ans,1+solve(mask|j));\\n        }\\n        return dp[mask]=ans;\\n    }\\n    \\n    public:\\n    int minNumberOfSemesters(int N, vector<vector<int>>& d, int K) {\\n        n=N;\\n        k=K;\\n        dp.assign(1<<n,-1);\\n        adj.clear();\\n        adj.resize(n);\\n        for(int i=0; i<d.size(); i++)\\n        {\\n            d[i][0]--;\\n            d[i][1]--;\\n            adj[d[i][0]].push_back(d[i][1]);\\n        }\\n        return solve(0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 708359,
                "title": "python-bitmask-and-bfs",
                "content": "Since there are at most 15 courses,  the total state is at most 32768, and it can be accomplished by using BFS\\nWe can use bitmask to acclerate the procedure.  The case number 19=10011 means the case we have already studied the first, fourth and fifth courses.\\nThus, we can use a array to store the prerequisite courses each course have,  for example, if course 1 prerequisite is 2 and 3,  the prerequisite course number will be 2^1+2^2=6.\\nSo how do we judge if any courses i that can be study base on the current case?  If i-th course prerequisite number pre[i]&(1<<i)==pre[i], it means we have already studied the prerequisite course, and the case number && (1<<i) must be 0 to ensure we have not studied the course. \\nMake all courses that can be studied based on the current case a list,  if the length is smaller than k,  we will study all, or else, we can pick k of them.  For example, If the length is 5 and k=2, there will be 10 combinations that can be followed after this case.\\nBy using itertools.combinations, we can realize this.\\n```\\nfrom collections import deque\\nfrom itertools import combinations\\nclass Solution(object):\\n    def minNumberOfSemesters(self, n, dependencies, k):\\n        \"\"\"\\n        :type n: int\\n        :type dependencies: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        pre = [0]*n\\n        occupy = [20]*(1<<(n))\\n        for dep in dependencies:\\n            pre[dep[1]-1] += 1<<(dep[0]-1)\\n        queue = deque([[0,0]])\\n        while queue:\\n            [num,step] = queue.popleft()\\n            nextlist = []\\n            for i in range(n):\\n                if pre[i]&num != pre[i]: continue\\n                if (1<<i)&num: continue\\n                nextlist.append(i)     \\n            if len(nextlist)<=k:\\n                for ele in nextlist: num += 1<<ele\\n                if num+1==1<<n: return step+1\\n                if occupy[num]>step+1: \\n                    queue.append([num,step+1])\\n                    occupy[num] = step+1\\n            else:\\n                thelist = combinations(nextlist,k)\\n                for seq in thelist:\\n                    temp = num\\n                    for ele in list(seq): temp += 1<<ele\\n                    if occupy[temp]>step+1:\\n                        queue.append([temp,step+1])\\n                        occupy[temp] = step + 1\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque\\nfrom itertools import combinations\\nclass Solution(object):\\n    def minNumberOfSemesters(self, n, dependencies, k):\\n        \"\"\"\\n        :type n: int\\n        :type dependencies: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        pre = [0]*n\\n        occupy = [20]*(1<<(n))\\n        for dep in dependencies:\\n            pre[dep[1]-1] += 1<<(dep[0]-1)\\n        queue = deque([[0,0]])\\n        while queue:\\n            [num,step] = queue.popleft()\\n            nextlist = []\\n            for i in range(n):\\n                if pre[i]&num != pre[i]: continue\\n                if (1<<i)&num: continue\\n                nextlist.append(i)     \\n            if len(nextlist)<=k:\\n                for ele in nextlist: num += 1<<ele\\n                if num+1==1<<n: return step+1\\n                if occupy[num]>step+1: \\n                    queue.append([num,step+1])\\n                    occupy[num] = step+1\\n            else:\\n                thelist = combinations(nextlist,k)\\n                for seq in thelist:\\n                    temp = num\\n                    for ele in list(seq): temp += 1<<ele\\n                    if occupy[temp]>step+1:\\n                        queue.append([temp,step+1])\\n                        occupy[temp] = step + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 710229,
                "title": "python-short-dp-with-binary-masks-o-n-2-2-n-explained",
                "content": "There are a lot of not-working greedy solutions for this problem, but I think the only one truly correct way to solve it is to use binary masks, see similarity with **Travelling Salesman Problem**. (see https://en.wikipedia.org/wiki/Travelling_salesman_problem and https://en.wikipedia.org/wiki/Held%E2%80%93Karp_algorithm)\\n\\nLet us denote by `dp[i][j]` tuple with: \\n1. minumum number of days we need to finish\\n2. number of non-zero bits for binary mask of the last semester\\n3. binary mask of the last semester\\n\\nall courses denoted by binary mask `i` and such that the last course we take is `j`. For example for `dp[13][3]`, `i=13` is represented as `1101`, and it means that we take courses number `0`, `2`, `3` and the last one we take is number `3`. (instead of starting with `1`, let us subtract `1` from all courses and start from `0`).\\n\\nLet us also introduce `bm_dep[i]`: this will be binary mask for all courses we need to take, before we can take course number `i`. For example `bm_dep[3] = 6 = 110` means, that we need to take courses `1` and `2` before we can take course number `3`.\\n\\nNow, let us iterate over all `i in range(1<<n)`. Let us evaluate `n_z_bit`, this will be an array with all places with non-zero bits. For example for `i=13=1101`, `n_z_bit = [0,2,3]`.\\n\\nWhat we need to do next, we:\\n1. First check that we really can take new course number `j`, using `bm_dep[j] & i == bm_dep[j]`.\\n2. Now, we want to update `dp[i][j]`, using `dp[i^(1<<j)][t]`, for example if we want to find answer for `(1,3,4,5)` courses with `3` being the last course, it means that we need to look into `(1,4,5)` courses, where we add course `3`.\\n3. We check how many courses we already take in last semester, using `bits < k`, and also make sure, that we can add new course to last semester. Now we have two candidates: `(cand, bits + 1, mask + (1<<j))` and `dp[i][j]` and we need to choose the best one. In other case, we need to take new semester: so `cands` will be equalt to `cands + 1`, `bits` will be equal to `1` and binary mask for last semester is `1<<j`.\\n\\n**Complexity** is `O(n^2*2^n)`, because we iterate all bitmasks and then we iterate over all pairs of non-zero bit, and we heve `O(n^2)` of them. Memory is `O(2^n * n)`.\\nI think it can be simplified to `O(n*2^n)/O(2^n)` complexity, but I am not sure yet.\\n\\n```\\nclass Solution:\\n    def minNumberOfSemesters(self, n, dependencies, k):\\n        dp = [[(100, 0, 0)] * n for _ in range(1<<n)]\\n        \\n        bm_dep = [0]*(n)\\n        for i,j in dependencies:\\n            bm_dep[j-1]^=(1<<(i-1))\\n\\n        for i in range(n):\\n            if bm_dep[i] == 0: dp[1<<i][i] = (1, 1, 1<<i)\\n        \\n        for i in range(1<<n):\\n            n_z_bits = [len(bin(i))-p-1 for p,c in enumerate(bin(i)) if c==\"1\"]\\n                    \\n            for t, j in permutations(n_z_bits, 2):\\n                if bm_dep[j] & i == bm_dep[j]:\\n                    cand, bits, mask = dp[i^(1<<j)][t]\\n                    if bm_dep[j] & mask == 0 and bits < k:\\n                        dp[i][j] = min(dp[i][j], (cand, bits + 1, mask + (1<<j)))\\n                    else:\\n                        dp[i][j] = min(dp[i][j], (cand+1, 1, 1<<j))\\n                                          \\n        return min([i for i, j, k in dp[-1]])\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minNumberOfSemesters(self, n, dependencies, k):\\n        dp = [[(100, 0, 0)] * n for _ in range(1<<n)]\\n        \\n        bm_dep = [0]*(n)\\n        for i,j in dependencies:\\n            bm_dep[j-1]^=(1<<(i-1))\\n\\n        for i in range(n):\\n            if bm_dep[i] == 0: dp[1<<i][i] = (1, 1, 1<<i)\\n        \\n        for i in range(1<<n):\\n            n_z_bits = [len(bin(i))-p-1 for p,c in enumerate(bin(i)) if c==\"1\"]\\n                    \\n            for t, j in permutations(n_z_bits, 2):\\n                if bm_dep[j] & i == bm_dep[j]:\\n                    cand, bits, mask = dp[i^(1<<j)][t]\\n                    if bm_dep[j] & mask == 0 and bits < k:\\n                        dp[i][j] = min(dp[i][j], (cand, bits + 1, mask + (1<<j)))\\n                    else:\\n                        dp[i][j] = min(dp[i][j], (cand+1, 1, 1<<j))\\n                                          \\n        return min([i for i, j, k in dp[-1]])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 708263,
                "title": "can-anyone-explain-the-bit-mask-method",
                "content": "I saw that bit mask method has been used by some top players\\nCan anyone explain?\\n\\nRank6 \\tHeltion  :\\n```\\nclass Solution {\\npublic:\\n    int minNumberOfSemesters(int n, vector<vector<int>>& dependencies, int k) {\\n        vector<int> pre(n);\\n        for(auto& e : dependencies){\\n            e[0] -= 1;\\n            e[1] -= 1;\\n            pre[e[1]] |= 1 << e[0];\\n        }\\n        vector<int> dp(1 << n, n);\\n        dp[0] = 0;\\n        for(int i = 0; i < (1 << n); i += 1){\\n            int ex = 0;\\n            for(int j = 0; j < n; j += 1) if((i & pre[j]) == pre[j]) ex |= 1 << j;\\n            ex &= ~i;\\n            for(int s = ex; s; s = (s - 1) & ex) if(__builtin_popcount(s) <= k){\\n                dp[i | s] = min(dp[i | s], dp[i] + 1);\\n            }\\n        }\\n        return dp.back();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfSemesters(int n, vector<vector<int>>& dependencies, int k) {\\n        vector<int> pre(n);\\n        for(auto& e : dependencies){\\n            e[0] -= 1;\\n            e[1] -= 1;\\n            pre[e[1]] |= 1 << e[0];\\n        }\\n        vector<int> dp(1 << n, n);\\n        dp[0] = 0;\\n        for(int i = 0; i < (1 << n); i += 1){\\n            int ex = 0;\\n            for(int j = 0; j < n; j += 1) if((i & pre[j]) == pre[j]) ex |= 1 << j;\\n            ex &= ~i;\\n            for(int s = ex; s; s = (s - 1) & ex) if(__builtin_popcount(s) <= k){\\n                dp[i | s] = min(dp[i | s], dp[i] + 1);\\n            }\\n        }\\n        return dp.back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1071068,
                "title": "top-down-dp-with-proper-comments-java-readable-code-bitmasking",
                "content": "class Solution {\\n    int[] prerequisites;\\n    int[] dp;\\n    int k; \\n    public int minNumberOfSemesters(int n, int[][] dependencies, int k) {\\n\\t    prerequisites = new int[n]; // This array contains all the courses required by a destination course.\\n\\t    dp = new int[1 << n];\\n\\t    Arrays.fill(dp, -1);\\n        this.k = k;\\n        \\n        //Setting prerequisites dependencies.\\n        for(int i = 0; i < dependencies.length; i++) {\\n            prerequisites[dependencies[i][1] - 1] |= (1 << dependencies[i][0] - 1); \\n        }\\n        \\n        int maskWhenNoCourseTaken = 0;\\n        //Inititally no course will be taken, so every ith bit as 1.\\n        for (int i = 0; i < n; i++) {\\n            maskWhenNoCourseTaken |= (1 << i);\\n        }\\n        \\n\\t    return findMinSemesters(maskWhenNoCourseTaken);\\n    }\\n\\n    /**\\n    Greedy won\\'t work in this question, because lets say if you two different connected components then\\n\\tthere may be possible combinations\\n    which lead to minimimum team to visit every node. \\n    Try to apply greedy in two different connected components and then try to find solution with different combinations.\\n    \\n    This is top down approach, \\n    you can think about find shortest path from maskWhenNoCourseTaken to 0.\\n    Lets say we have n = 4\\n    so our source will be 1111 and destination will be 0000.\\n    Now you have edges to some other mask ,try to find adjancents mask and iterate over them.\\n    So suppose if k= 2 and mask == 1111 , now you will have adjancents 0011 , 1001, 0101 so on.\\n    To find adjacent of currentMask, you need to go throgh all course from 0 to n and check if ith course is not previously taken \\n\\tand all it prerequisite have been taken successfully. Then put ith available course into bucket.\\n    So create bucket of all available course like above. Now you have to check if available courses(with zero indegree) are greater \\n\\tthan K then find all possible combinations of them, else take greedy approach and select all available courses and made them 0 in mask.\\n    Rest of things you can observe.\\n    it is very good question and you can also use bfs on all possible comibnations think like every single bitmask is a node.\\n    **/\\n    \\n    private int findMinSemesters(int currentMask) {\\n        if(currentMask == 0)\\n            return 0;\\n        else if(dp[currentMask] != -1)\\n            return dp[currentMask];\\n        else {\\n            List<Integer> bucket = new ArrayList<>();\\n            for(int i = 0; i < prerequisites.length; i++) {\\n                //Check if ith course is not previously taken and its prereuqisites are already visited/completed,\\n                //then add ithcousrse into bucket.\\n                if(((1 << i) & currentMask) != 0 && (prerequisites[i] & currentMask) == 0) {\\n                    bucket.add(i);\\n                }\\n            }\\n            \\n            //If bucket with available courses is greater than k then find all possible combination \\n            //and get min number of semesters to complete rest of courses.\\n            if(bucket.size() > k) {\\n                int ans = Integer.MAX_VALUE;\\n                List<Integer> combinations = new ArrayList<>();\\n                getAllCombination(combinations, bucket, k, currentMask, 0);\\n                for(int comb: combinations) {\\n                    ans = Math.min(1 + findMinSemesters(comb), ans);\\n                }\\n                dp[currentMask] = ans;\\n            } //If you can take all avaialble courses in single semeseter.\\n            else {\\n                int temp = currentMask;\\n                //Making bit of to all available courses 0(means course is completed), since order won\\'t matter here.\\n                for(int zeroIndegreeCourse: bucket) \\n                    temp = (1 << zeroIndegreeCourse) ^ temp;\\n                \\n                dp[currentMask] = 1 + findMinSemesters(temp);\\n            }\\n            return dp[currentMask];\\n        }\\n    }\\n    \\n    /**\\n        No need to remember gosper hack, make it intutive.\\n    **/\\n    static void getAllCombination(List<Integer> ans, List<Integer> bucket, int k,\\n                                    int currentMask, int currentCourse) {\\n        \\n        if(k == 0) {\\n            ans.add(currentMask);\\n        }\\n        \\n        for(int i = currentCourse; i < bucket.size(); i++) {\\n            //Making ith course to zero(means completed)\\n            int temp = (1 << bucket.get(i)) ^ currentMask;\\n            getAllCombination(ans, bucket, k - 1, temp, i + 1);\\n        }\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation",
                    "Graph",
                    "Recursion"
                ],
                "code": "class Solution {\\n    int[] prerequisites;\\n    int[] dp;\\n    int k; \\n    public int minNumberOfSemesters(int n, int[][] dependencies, int k) {\\n\\t    prerequisites = new int[n]; // This array contains all the courses required by a destination course.\\n\\t    dp = new int[1 << n];\\n\\t    Arrays.fill(dp, -1);\\n        this.k = k;\\n        \\n        //Setting prerequisites dependencies.\\n        for(int i = 0; i < dependencies.length; i++) {\\n            prerequisites[dependencies[i][1] - 1] |= (1 << dependencies[i][0] - 1); \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 713978,
                "title": "python-intuitive-bit-mask-dp-explained-best",
                "content": "```\\n        Recognise that this cannot be solved by topological sorting\\n            Topological sorting only gives you one order which need not give us the optimal no of semesters.\\n        \\n        Notice the range of n, 15. Therefore n! will be too big.So,we cant choose backtracking or bruteforce.\\n        \\n        So,The next option is 2^n which is bitmask dp.\\n        why dp? Cause we wanna get the min/optimal solution.So,we need to check all possibilities.\\n        \\n        We store the state of no of courses taken vs no of optimal solutions to take those courses into a bitmask.\\n        i.e 0110 represents the courses 2,3\\n        \\n        dp[bitmask] = minimum no of semesters to take the courses stored by the bitmask.\\n\\n```\\n\\n\\nTime : O(2^N) * O(NcK)\\nSpace:O(N)\\n\\n\\n```python\\nclass Solution:\\n    def minNumberOfSemesters(self, n: int, dep, k: int) -> int:\\n        \\n\\n        reqs = [0]*n\\n        for u,v in dep:\\n            reqs[v-1]  |= 1<<(u-1) \\n            \\n        dp = [n] * (1<<n)\\n        dp[0] = 0\\n        \\n        for mask in range(1<<n):\\n#in state of current mask,we should choose extra courses now.\\n#so,check for all the available courses.\\n            avail = []\\n            for v in range(n):\\n                if mask & (1<<v) == 0 and  mask & reqs[v]  == reqs[v]:\\n                    avail.append(v)\\n            \\n# mask & (1<<v) tells which courses are not yet taken in state of mask\\n# mask & reqs[v] tells if reqs[v] is a subset of courses taken.\\n            \\n            for choice in itertools.combinations(avail, min(k,len(avail)) ):\\n                mask2 = mask #courses taken\\n                for u in choice:\\n                    mask2 |= (1<<u)\\n                \\n#now,we have mask2 = (courses taken in mask + available courses) \\n#now do the PUSH-DP work\\n#since we are adding k new courses to the previous courses(mask),we might endup taking a new semester => dp[mask]+1\\n#but dp[mask2] might have been acheived in lesser semessters in another order i.e might have been reached mask2\\n#by another mask. In that case,we dont want to increase the no of semesters we need.\\n#so,we choose the minimum of either.\\n                dp[mask2] = min(dp[mask2],1+dp[mask])\\n\\n#finally return how many min semesters it takes to take all courses i.e dp[(1<<n)-1] which is of form 0b111111\\n        return dp[-1]\\n```",
                "solutionTags": [],
                "code": "```\\n        Recognise that this cannot be solved by topological sorting\\n            Topological sorting only gives you one order which need not give us the optimal no of semesters.\\n        \\n        Notice the range of n, 15. Therefore n! will be too big.So,we cant choose backtracking or bruteforce.\\n        \\n        So,The next option is 2^n which is bitmask dp.\\n        why dp? Cause we wanna get the min/optimal solution.So,we need to check all possibilities.\\n        \\n        We store the state of no of courses taken vs no of optimal solutions to take those courses into a bitmask.\\n        i.e 0110 represents the courses 2,3\\n        \\n        dp[bitmask] = minimum no of semesters to take the courses stored by the bitmask.\\n\\n```\n```python\\nclass Solution:\\n    def minNumberOfSemesters(self, n: int, dep, k: int) -> int:\\n        \\n\\n        reqs = [0]*n\\n        for u,v in dep:\\n            reqs[v-1]  |= 1<<(u-1) \\n            \\n        dp = [n] * (1<<n)\\n        dp[0] = 0\\n        \\n        for mask in range(1<<n):\\n#in state of current mask,we should choose extra courses now.\\n#so,check for all the available courses.\\n            avail = []\\n            for v in range(n):\\n                if mask & (1<<v) == 0 and  mask & reqs[v]  == reqs[v]:\\n                    avail.append(v)\\n            \\n# mask & (1<<v) tells which courses are not yet taken in state of mask\\n# mask & reqs[v] tells if reqs[v] is a subset of courses taken.\\n            \\n            for choice in itertools.combinations(avail, min(k,len(avail)) ):\\n                mask2 = mask #courses taken\\n                for u in choice:\\n                    mask2 |= (1<<u)\\n                \\n#now,we have mask2 = (courses taken in mask + available courses) \\n#now do the PUSH-DP work\\n#since we are adding k new courses to the previous courses(mask),we might endup taking a new semester => dp[mask]+1\\n#but dp[mask2] might have been acheived in lesser semessters in another order i.e might have been reached mask2\\n#by another mask. In that case,we dont want to increase the no of semesters we need.\\n#so,we choose the minimum of either.\\n                dp[mask2] = min(dp[mask2],1+dp[mask])\\n\\n#finally return how many min semesters it takes to take all courses i.e dp[(1<<n)-1] which is of form 0b111111\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 769196,
                "title": "backtracking-topological-sort-with-combinations",
                "content": "**Intuition:**\\n\\nWe can simulate the schedule for each semester. Let\\'s use in-degree to find the courses to start with. Those will be ones with no dependencies (in-degree == 0). We will add them to the initial pool.\\n\\nThen, for each semester, we will schedule some courses (<=k) from this pool. For each of scheduled courses, we update in-degree for it\\'s neigbours. Courses which got in-degree == 0, we add to the pool for the next semester scheduling.  See \"Kahn\\u2019s algorithm for Topological Sorting\" for detailed explanation of this approach.\\n\\nFor each semester we can have two options: \\n\\n**(1) number of courses available for scheduling are <= k**\\n\\nIn this case we simply schedule all of them. We cannot do better than that.\\n\\n**(2)  number of courses available for scheduling are > k**\\n\\nHow do we choose which courses to schedule? \\n\\nAs others have mentioned this problem cannot be solved by simply sorting by out-degree of node, or depth of node, or combination of both. There might be many cases where it actually works but there are counter-examples where it doesn\\'t.\\n \\nSince we cannot decide which courses to schedule based solely on course property we need to try all combinations. It suggests the use of backtracking. We are going to try all of k-length combinations of the available courses.\\n\\nWe can also apply an optimization to avoid unnesessary backtracking cycles in some cases. Consider the first semester of the following example (k=2):\\n\\n![image](https://assets.leetcode.com/uploads/2020/05/22/leetcode_parallel_courses_2.png)\\n\\nCombinations are [2,3], [2,4], [3,4]. We actually don\\'t need to try all of them, we can try only one. The reason for that being that all of them unlock the same next course: 1. Let\\'s use this fact to prune the backtracking tree.\\n\\nSee the code below. I didn\\'t use bit masks but it can be updated to use them. It is actually pretty good as is, giving 44 ms runtime.\\n\\nPython3\\n```\\ndef minNumberOfSemesters(n: int, dependencies: List[List[int]], k: int) -> int:\\n    # compute adjacency list and in-degree for all edges\\n    inc, adj = defaultdict(int), defaultdict(list)\\n    for edge in dependencies:\\n        adj[edge[0]].append(edge[1])\\n        inc[edge[1]] += 1\\n\\n    best = 9999\\n    def findBest(courses, semester):\\n        nonlocal best\\n        # if we have exhausted the pool of courses, find the best (minimum) of semesters\\n        if not courses:\\n            best = min(best, semester)\\n            return\\n        combs = []\\n        # if number of courses available to schedule for this semester \\n        # is less or equal to k schedule all of them\\n        if len(courses) <= k: \\n            combs.append([courses, []])\\n        else:\\n            # ... otherwise try all combinations of k-length\\n            for comb_courses in combinations(courses, k): \\n                left_courses = list(set(courses)-set(comb_courses))\\n                combs.append([comb_courses, left_courses])\\n\\n        # backtrack for courses adjusting in-degree before and after the recursive call\\n        unlocked_courses = set() # tuples of unlocked courses\\n        for comb_courses, left_courses in combs:\\n            next_courses = []\\n            for course in comb_courses:\\n                for nei in adj[course]:\\n                    inc[nei] -= 1\\n                    if inc[nei] == 0: \\n                        next_courses.append(nei)\\n            next_courses_tuple = tuple(sorted(next_courses))\\n            if not next_courses_tuple in unlocked_courses:\\n                unlocked_courses.add(next_courses_tuple)\\n                findBest(left_courses + next_courses, semester+1)\\n            for course in comb_courses:\\n                for nei in adj[course]:\\n                    inc[nei] += 1\\n\\n\\n    start_courses = [c for c in range(1,n+1) if inc[c] == 0]\\n    findBest(start_courses, 0)\\n    return best\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Topological Sort"
                ],
                "code": "```\\ndef minNumberOfSemesters(n: int, dependencies: List[List[int]], k: int) -> int:\\n    # compute adjacency list and in-degree for all edges\\n    inc, adj = defaultdict(int), defaultdict(list)\\n    for edge in dependencies:\\n        adj[edge[0]].append(edge[1])\\n        inc[edge[1]] += 1\\n\\n    best = 9999\\n    def findBest(courses, semester):\\n        nonlocal best\\n        # if we have exhausted the pool of courses, find the best (minimum) of semesters\\n        if not courses:\\n            best = min(best, semester)\\n            return\\n        combs = []\\n        # if number of courses available to schedule for this semester \\n        # is less or equal to k schedule all of them\\n        if len(courses) <= k: \\n            combs.append([courses, []])\\n        else:\\n            # ... otherwise try all combinations of k-length\\n            for comb_courses in combinations(courses, k): \\n                left_courses = list(set(courses)-set(comb_courses))\\n                combs.append([comb_courses, left_courses])\\n\\n        # backtrack for courses adjusting in-degree before and after the recursive call\\n        unlocked_courses = set() # tuples of unlocked courses\\n        for comb_courses, left_courses in combs:\\n            next_courses = []\\n            for course in comb_courses:\\n                for nei in adj[course]:\\n                    inc[nei] -= 1\\n                    if inc[nei] == 0: \\n                        next_courses.append(nei)\\n            next_courses_tuple = tuple(sorted(next_courses))\\n            if not next_courses_tuple in unlocked_courses:\\n                unlocked_courses.add(next_courses_tuple)\\n                findBest(left_courses + next_courses, semester+1)\\n            for course in comb_courses:\\n                for nei in adj[course]:\\n                    inc[nei] += 1\\n\\n\\n    start_courses = [c for c in range(1,n+1) if inc[c] == 0]\\n    findBest(start_courses, 0)\\n    return best\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 709009,
                "title": "c-20ms-dp-state-compression-bit-manipulation-magic-bitwise-subset-iteration",
                "content": "I failed to get up to take the contest in the early morning, and also failed to solve this problem in virtual contest. \\n\\nThen I learned some new tricks from rank1 player @JOHNKRAM \\'s submission. His solution is short and beautiful. I suggest you take a look at it first. I then modified the \"subset iteration\" part which enumerates subsets more efficiently and the side effect is that we no longer need the `o` array in his solution. \\n\\nWhat I did is just combining rank1 player\\'s solution and this trick together. I am very excited that it works really well and want to share this solution with you. The \"bit magic\" in my code is called **Gosper\\'s Hack**, google it if you want to learn more about it.\\n\\nTime Complexity Analysis: In the outer loop, we iterate total `2^n` states, we group these states into categories by the number of bits set in this state. The number of states with `i` bits set is `C(n, i)`. For any state with `i` bits set, number of candidates is at most `n-i`. In the innner loop, we iterate all subsets of candidates with `k` bits set, number of these subsets is `C(n-i, k)`. For each subset, we compute subsetk in `O(n-i)`. Put the above analysis together, the total complexity is: `\\\\sum_{i=0}^{n}C(n, i)*C(n-i, k)*k`. After some calculation this gives `k*C(n, k)*2^(n-k)`. \\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minNumberOfSemesters(int n, vector<vector<int>>& dependencies, int k) {\\n        // All courses numbers are shifted down by 1\\n        // Bit representation and bit manipulation is heavily used.\\n        const int nStates = 1<<n; // All subsets of n courses, bit representation\\n        vector<int> dp(nStates, INT_MAX); // dp[i]: least semesters to finish courses of bit pattern i\\n        vector<int> pre(n); // [TRICK] pre[i]: prerequisites of i-th course, bit representation \\n        // Initialize pre array\\n        for (auto& dep: dependencies) {\\n            pre[dep[1]-1] = pre[dep[1]-1] | (1<<(dep[0]-1));\\n        }\\n        // Dynamic Processing\\n        dp[0] = 0;\\n        vector<int> idx(n); // Candidates indexes\\n        for (int i = 0; i < nStates; i++) { // Enumerate all subsets (courses already taken)\\n            if (dp[i] == INT_MAX) \\n                continue;\\n            int candidates = 0; // Courses that are ready and not taken yet, bit representation\\n            int nCandidates = 0; // Number of these candidate courses.\\n            for (int j = 0; j < n; j++) { // Check all courses\\n                if ((i>>j) & 1) // If course j already taken, ignore it.\\n                    continue;\\n                if ((i & pre[j]) == pre[j]) { // [TRICK] If all of course j\\'s prerequistes are already taken.\\n                    idx[nCandidates] = j;\\n                    nCandidates ++;\\n                    candidates = candidates | (1<<j);\\n                }    \\n            }\\n            if (nCandidates <= k) { \\n                // Take all of these courses in one semester.\\n                dp[i|candidates] = min(dp[i|candidates], dp[i]+1); \\n            } else { \\n                // Enumerate subsets of size k, Gosper\\'s Hack. \\n                for (int s = (1<<k)-1; s < (1<<nCandidates);) {\\n                    // Map bit-pattern \"subsets of candidates\" to bit-pattern \"subsets of all courses\"  \\n                    int subsetk = 0;\\n                    for (int j = 0; j < nCandidates; j++) {\\n                        if ((s >> j) & 1)\\n                            subsetk = subsetk | (1 << idx[j]);\\n                    }\\n                    dp[i|subsetk] = min(dp[i|subsetk], dp[i]+1);\\n                    \\n                    int x = s & -s; // WARNING: bit manipulation magic.\\n                    int y = s + x;  // WARNING: bit manipulation magic.\\n                    s = (((s & ~y) / x) >> 1) | y; // WARNING: bit manipulation magic.\\n                }\\n            }\\n        }\\n        return dp[nStates-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minNumberOfSemesters(int n, vector<vector<int>>& dependencies, int k) {\\n        // All courses numbers are shifted down by 1\\n        // Bit representation and bit manipulation is heavily used.\\n        const int nStates = 1<<n; // All subsets of n courses, bit representation\\n        vector<int> dp(nStates, INT_MAX); // dp[i]: least semesters to finish courses of bit pattern i\\n        vector<int> pre(n); // [TRICK] pre[i]: prerequisites of i-th course, bit representation \\n        // Initialize pre array\\n        for (auto& dep: dependencies) {\\n            pre[dep[1]-1] = pre[dep[1]-1] | (1<<(dep[0]-1));\\n        }\\n        // Dynamic Processing\\n        dp[0] = 0;\\n        vector<int> idx(n); // Candidates indexes\\n        for (int i = 0; i < nStates; i++) { // Enumerate all subsets (courses already taken)\\n            if (dp[i] == INT_MAX) \\n                continue;\\n            int candidates = 0; // Courses that are ready and not taken yet, bit representation\\n            int nCandidates = 0; // Number of these candidate courses.\\n            for (int j = 0; j < n; j++) { // Check all courses\\n                if ((i>>j) & 1) // If course j already taken, ignore it.\\n                    continue;\\n                if ((i & pre[j]) == pre[j]) { // [TRICK] If all of course j\\'s prerequistes are already taken.\\n                    idx[nCandidates] = j;\\n                    nCandidates ++;\\n                    candidates = candidates | (1<<j);\\n                }    \\n            }\\n            if (nCandidates <= k) { \\n                // Take all of these courses in one semester.\\n                dp[i|candidates] = min(dp[i|candidates], dp[i]+1); \\n            } else { \\n                // Enumerate subsets of size k, Gosper\\'s Hack. \\n                for (int s = (1<<k)-1; s < (1<<nCandidates);) {\\n                    // Map bit-pattern \"subsets of candidates\" to bit-pattern \"subsets of all courses\"  \\n                    int subsetk = 0;\\n                    for (int j = 0; j < nCandidates; j++) {\\n                        if ((s >> j) & 1)\\n                            subsetk = subsetk | (1 << idx[j]);\\n                    }\\n                    dp[i|subsetk] = min(dp[i|subsetk], dp[i]+1);\\n                    \\n                    int x = s & -s; // WARNING: bit manipulation magic.\\n                    int y = s + x;  // WARNING: bit manipulation magic.\\n                    s = (((s & ~y) / x) >> 1) | y; // WARNING: bit manipulation magic.\\n                }\\n            }\\n        }\\n        return dp[nStates-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 708239,
                "title": "c-priority-queue-depths",
                "content": "**UPDATE: this \"solution\" is incorrect...**\\n![image](https://assets.leetcode.com/users/images/12b552ed-97a2-45b3-bdbd-3ae43b66f60d_1593280589.6765761.png)\\n\\nFor an example like above with `n=9, k=3`, node \"1\", \"2\", \"3\", \"4\", \"5\" have the same outdegree, the same depth, and indegree 0. Sorting based on outdegree or depth won\\'t prevent it from picking \"2\", \"3\", \"4\", which will then additional 3 steps to finish.\\nOne optimal solution is to pick \"1\", \"2\", \"3\" first, then \"4\", \"5\", \"7\", and then \"6\", \"8\", \"9\".\\n\\n-------------------------------------------------------------\\n\\nMost other answers using outdegree are not correct.\\n```\\n12\\n[[1,2],[1,3],[4,5],[4,6],[7,8],[8,9],[9,10],[10,11],[11,12]]\\n2\\n```\\n![image](https://assets.leetcode.com/users/images/2522d14f-6061-4d3f-b592-b5a2d4a9003a_1593275305.7698224.png)\\nAs you can see, with `k=2`, greedy is not optimal in the above case.\\n\\n\\nInstead of using outdegree, we may use depth.\\n```\\nclass Solution {\\n    struct Cmp {\\n        bool operator() (const vector<int> &a, vector<int> &b) {\\n            return a[1] < b[1];\\n        }\\n    };\\n    \\n    int dfs(vector<vector<int>> &edges, vector<int> &depths, int idx) {\\n        if (depths[idx] == -1) {\\n            int depth = 0;\\n            for (int e: edges[idx])\\n                depth = max(depth, dfs(edges, depths, e));\\n            depths[idx] = depth + 1;\\n        }\\n        return depths[idx];\\n    }\\n    \\npublic:\\n    int minNumberOfSemesters(int n, vector<vector<int>>& dependencies, int k) {\\n        vector<int> degrees(n);\\n        vector<vector<int>> edges(n);\\n        for (auto &dep: dependencies) {\\n            degrees[dep[1]-1]++;\\n            edges[dep[0]-1].push_back(dep[1]-1);\\n        }\\n        vector<int> depths(n, -1);\\n        for (int i=0; i<n; i++)\\n            dfs(edges, depths, i);  // compute depth for each node\\n        \\n        priority_queue<vector<int>, vector<vector<int>>, Cmp> mqueue;  // priority_queue is based on depth of each node\\n        for (int i=0; i<n; i++) {\\n            if (degrees[i] == 0)\\n                mqueue.push({i, depths[i]});   // only put nodes that have indegree 0 in the priority_queue\\n        }\\n        \\n        int step = 0;\\n        while (!mqueue.empty()) {\\n            step++;\\n            vector<vector<int>> next;\\n            for (int i=0, j=mqueue.size(); i<k && j>0; i++, j--) {  // stop the current round when the queue is empty or \"k\" limit is reached\\n                vector<int> top = mqueue.top();\\n                mqueue.pop();\\n                for (int e: edges[top[0]]) {\\n                    if (--degrees[e] == 0) {\\n\\t\\t\\t\\t\\t    // note that, we can\\'t simply put it in the priority_queue, otherwise it may be picked up in the current round\\n                        next.push_back({e, depths[e]});\\n                    }\\n                }\\n            }\\n            for (auto it: next)\\n                mqueue.push(it);\\n        }\\n        \\n        return step;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n12\\n[[1,2],[1,3],[4,5],[4,6],[7,8],[8,9],[9,10],[10,11],[11,12]]\\n2\\n```\n```\\nclass Solution {\\n    struct Cmp {\\n        bool operator() (const vector<int> &a, vector<int> &b) {\\n            return a[1] < b[1];\\n        }\\n    };\\n    \\n    int dfs(vector<vector<int>> &edges, vector<int> &depths, int idx) {\\n        if (depths[idx] == -1) {\\n            int depth = 0;\\n            for (int e: edges[idx])\\n                depth = max(depth, dfs(edges, depths, e));\\n            depths[idx] = depth + 1;\\n        }\\n        return depths[idx];\\n    }\\n    \\npublic:\\n    int minNumberOfSemesters(int n, vector<vector<int>>& dependencies, int k) {\\n        vector<int> degrees(n);\\n        vector<vector<int>> edges(n);\\n        for (auto &dep: dependencies) {\\n            degrees[dep[1]-1]++;\\n            edges[dep[0]-1].push_back(dep[1]-1);\\n        }\\n        vector<int> depths(n, -1);\\n        for (int i=0; i<n; i++)\\n            dfs(edges, depths, i);  // compute depth for each node\\n        \\n        priority_queue<vector<int>, vector<vector<int>>, Cmp> mqueue;  // priority_queue is based on depth of each node\\n        for (int i=0; i<n; i++) {\\n            if (degrees[i] == 0)\\n                mqueue.push({i, depths[i]});   // only put nodes that have indegree 0 in the priority_queue\\n        }\\n        \\n        int step = 0;\\n        while (!mqueue.empty()) {\\n            step++;\\n            vector<vector<int>> next;\\n            for (int i=0, j=mqueue.size(); i<k && j>0; i++, j--) {  // stop the current round when the queue is empty or \"k\" limit is reached\\n                vector<int> top = mqueue.top();\\n                mqueue.pop();\\n                for (int e: edges[top[0]]) {\\n                    if (--degrees[e] == 0) {\\n\\t\\t\\t\\t\\t    // note that, we can\\'t simply put it in the priority_queue, otherwise it may be picked up in the current round\\n                        next.push_back({e, depths[e]});\\n                    }\\n                }\\n            }\\n            for (auto it: next)\\n                mqueue.push(it);\\n        }\\n        \\n        return step;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 708079,
                "title": "screencast-of-leetcode-biweekly-contest-29",
                "content": "https://www.youtube.com/watch?v=XzY7S3VMNYs",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=XzY7S3VMNYs",
                "codeTag": "Unknown"
            },
            {
                "id": 1134231,
                "title": "golang-bitmask-dp-solution-with-explanation",
                "content": "As there are max 15 courses, we can use a bitmask to represent a state, for example : \\n```\\n11100010\\n       0 - course 1 is not taken\\n      1 - course 2 is taken\\n1 - course 8 is taken\\n```\\n\\nThe start state is 000...000, all courses are not yet taken and end state is 111...111, all counrses are taken\\nFor each state, maintain a dp[bitmask] to represent the min semesters to reach this state, and DP[111...111] is the result we are looking for\\n\\nAs one state might have multiple preStates, we would iterate all possible preStates to find out the preState with MIN semesters, + 1 on top of the number will be the semesters to reach state\\n```\\nDP[state] = min(DP[state], DP[preState] + 1)\\n```\\n\\nNext question is : how to link preState to state? There are 3 criteria \\n1. preState has to be the subset of state\\npreState 0 -> state 1, take un-taken course \\npreState 1 -> state 1, taken course remains taken\\n\\n2. preState contains all the prerequisite courses of state\\n\\n3. the difference of number of taken courses (number of 1 bits) has to be <= k\\n\\nwith above 3 constains, we can iterate all states and find out the DP[111...111]\\n\\n```\\n\\nfunc minNumberOfSemesters(n int, dependencies [][]int, k int) int {\\n    //size of dp is 1<<n, start state is 000...000, end state is 111...111\\n    dp := make([]int, 1<<n)\\n    preReq := make(map[int]int) //dict of state : prerequisite\\n    preCourse := make(map[int]int) //dict of course : pre-courses\\n    \\n    \\n    //calculate pre-courses of each course and maintain it as bitmask\\n    for _, val := range dependencies {\\n        //convert idx starting from 1 to 0 \\n        //as the bitmask starts from 0\\n        preCourse[val[1] - 1] += 1<< (val[0] - 1) \\n    } \\n    \\n    //calculate prerequisite\\n    for state := 0; state < (1<<n); state++ {\\n        dp[state] = 2<<32\\n        preReq[state] = 0\\n        for i := 0; i < n; i++ {\\n            if (state>>i) & 1 == 1 { //the i-th digit is 1 means that course is taken in this state\\n                preReq[state] |= preCourse[i] //so this state\\'s preRequisite should contain that course\\'s pre-courses\\n            }\\n        }\\n    }\\n    dp[0] = 0 //need 0 semesters to complete 0 courses\\n\\n    //iterate state from 000...001 to 111...111\\n    for state := 0; state < (1<<n); state++ {\\n        //preState possible values are from state to 0, however we don\\'t have to iterate every single state\\n        //the reason is preState just need to be the subset of state\\n        //(preState - 1) & state is the logic to calculate state\\'s subset\\n        preState := state\\n        for preState > 0 {\\n            preState = (preState - 1) & state \\n            \\n            //criteria 2, preState is superset of state\\'s prerequisite\\n            //criteria 3, calculate number of 1s and compare with k\\n            if preReq[state] == (preState & preReq[state]) && courseDiff(state, preState) <= k {  \\n                dp[state] = min(dp[state], dp[preState] + 1)\\n            }\\n        } \\n    } \\n    \\n    return dp[(1<<n) - 1] //return dp[111...111]\\n}\\n\\nfunc courseDiff(a, b int) int {\\n    res := bits.OnesCount(uint(a)) - bits.OnesCount(uint(b))\\n    return res\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    } else {\\n        return b\\n    }\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\n11100010\\n       0 - course 1 is not taken\\n      1 - course 2 is taken\\n1 - course 8 is taken\\n```\n```\\nDP[state] = min(DP[state], DP[preState] + 1)\\n```\n```\\n\\nfunc minNumberOfSemesters(n int, dependencies [][]int, k int) int {\\n    //size of dp is 1<<n, start state is 000...000, end state is 111...111\\n    dp := make([]int, 1<<n)\\n    preReq := make(map[int]int) //dict of state : prerequisite\\n    preCourse := make(map[int]int) //dict of course : pre-courses\\n    \\n    \\n    //calculate pre-courses of each course and maintain it as bitmask\\n    for _, val := range dependencies {\\n        //convert idx starting from 1 to 0 \\n        //as the bitmask starts from 0\\n        preCourse[val[1] - 1] += 1<< (val[0] - 1) \\n    } \\n    \\n    //calculate prerequisite\\n    for state := 0; state < (1<<n); state++ {\\n        dp[state] = 2<<32\\n        preReq[state] = 0\\n        for i := 0; i < n; i++ {\\n            if (state>>i) & 1 == 1 { //the i-th digit is 1 means that course is taken in this state\\n                preReq[state] |= preCourse[i] //so this state\\'s preRequisite should contain that course\\'s pre-courses\\n            }\\n        }\\n    }\\n    dp[0] = 0 //need 0 semesters to complete 0 courses\\n\\n    //iterate state from 000...001 to 111...111\\n    for state := 0; state < (1<<n); state++ {\\n        //preState possible values are from state to 0, however we don\\'t have to iterate every single state\\n        //the reason is preState just need to be the subset of state\\n        //(preState - 1) & state is the logic to calculate state\\'s subset\\n        preState := state\\n        for preState > 0 {\\n            preState = (preState - 1) & state \\n            \\n            //criteria 2, preState is superset of state\\'s prerequisite\\n            //criteria 3, calculate number of 1s and compare with k\\n            if preReq[state] == (preState & preReq[state]) && courseDiff(state, preState) <= k {  \\n                dp[state] = min(dp[state], dp[preState] + 1)\\n            }\\n        } \\n    } \\n    \\n    return dp[(1<<n) - 1] //return dp[111...111]\\n}\\n\\nfunc courseDiff(a, b int) int {\\n    res := bits.OnesCount(uint(a)) - bits.OnesCount(uint(b))\\n    return res\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    } else {\\n        return b\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2411686,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. If you like it, please give a star and watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way).\\n\\n---\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minNumberOfSemesters(int n, vector<vector<int>>& dependencies, int k) {\\n        // dp[i] : the minimum number of semesters needed to take the courses with the bit set in i\\n        // the worst case is that in each semester we can only take one course, hence initialise with `n`\\n        // at the end, the answer would be dp[(1 << n) - 1], i.e. all bits set\\n        vector<int> dp(1 << n, n);\\n        // if the i-th bit is set in pre[j], \\n        // that means we need to take course i in order to take course j\\n        vector<int> pre(n);\\n        // build the prerequisites\\n        for (auto& x : dependencies) {\\n            // make it 0-based index\\n            --x[0], --x[1];\\n            // set the bit at x[0]-th place\\n            pre[x[1]] |= 1 << x[0];\\n        }\\n        // base case: 0 semester. 0 course.\\n        dp[0] = 0;\\n        // i is a set of courses that we\\'ve already studied\\n        for (int i = 0; i < (1 << n); i++) {\\n            // init can as 0 to record how can courses we can study\\n            int can = 0;\\n            // iterate all courses\\n            for (int j = 0; j < n; j++) {\\n                // check if we\\'ve studied prerequisite courses\\n                if ((pre[j] & i) == pre[j]) {\\n                    // if so, we can study course j\\n                    can |= (1 << j);\\n                }\\n            }\\n            // remove those courses that we\\'ve already studied\\n            can &= ~i;\\n            // enumerate all the bit 1 combinations of `can`\\n            // i.e. all subsets of a bit representation\\n            for (int s = can; s ; s = (s - 1) & can) {\\n                // check if we can take __builtin_popcount(s) courses\\n                if (__builtin_popcount(s) <= k) {\\n                    // if so, we combine the previous results (what\\'ve studied already)\\n                    // or we take a new semester\\n                    dp[i | s] = min(dp[i | s], dp[i] + 1);\\n                }\\n            }\\n        }\\n        // same as dp[(1 << n) - 1]\\n        return dp.back();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minNumberOfSemesters(int n, vector<vector<int>>& dependencies, int k) {\\n        // dp[i] : the minimum number of semesters needed to take the courses with the bit set in i\\n        // the worst case is that in each semester we can only take one course, hence initialise with `n`\\n        // at the end, the answer would be dp[(1 << n) - 1], i.e. all bits set\\n        vector<int> dp(1 << n, n);\\n        // if the i-th bit is set in pre[j], \\n        // that means we need to take course i in order to take course j\\n        vector<int> pre(n);\\n        // build the prerequisites\\n        for (auto& x : dependencies) {\\n            // make it 0-based index\\n            --x[0], --x[1];\\n            // set the bit at x[0]-th place\\n            pre[x[1]] |= 1 << x[0];\\n        }\\n        // base case: 0 semester. 0 course.\\n        dp[0] = 0;\\n        // i is a set of courses that we\\'ve already studied\\n        for (int i = 0; i < (1 << n); i++) {\\n            // init can as 0 to record how can courses we can study\\n            int can = 0;\\n            // iterate all courses\\n            for (int j = 0; j < n; j++) {\\n                // check if we\\'ve studied prerequisite courses\\n                if ((pre[j] & i) == pre[j]) {\\n                    // if so, we can study course j\\n                    can |= (1 << j);\\n                }\\n            }\\n            // remove those courses that we\\'ve already studied\\n            can &= ~i;\\n            // enumerate all the bit 1 combinations of `can`\\n            // i.e. all subsets of a bit representation\\n            for (int s = can; s ; s = (s - 1) & can) {\\n                // check if we can take __builtin_popcount(s) courses\\n                if (__builtin_popcount(s) <= k) {\\n                    // if so, we combine the previous results (what\\'ve studied already)\\n                    // or we take a new semester\\n                    dp[i | s] = min(dp[i | s], dp[i] + 1);\\n                }\\n            }\\n        }\\n        // same as dp[(1 << n) - 1]\\n        return dp.back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2188001,
                "title": "dp-with-memoization-and-bitmasks",
                "content": "* The number of nodes available to take this semester == Number of nodes whose indegree is zero\\n* We need to consider only those courses in a semester, whose indegree is either zero or its pre-requisites are all visited. Also, we need to take only K courses among them. \\n* We are creating a course_mask. In which, a ON Bit represents that course is available. So during initailization start we will make all BIT ON.\\n* We will create a *helper()* funtion for recurssion and then we will memoize it. And will pass this course mask as an argument.\\n* Now in helper() function\\n\\t*  Base case :  *(course_mask = 0) return 0* ;  It means all courses has been taken.\\n\\t*  Now, we need to calculate number of nodes whose indegree is zero and it is not visited.  We  will store this in a available_courses_mask.\\n\\t*  Now, we will count number of nodes whose indegree is zero. \\n\\t\\t*  If it is less than or equal to K, then:\\n\\t\\t\\t*  Mark all nodes visited and do function call.\\n\\t\\t*  If it is more than K, then:\\n\\t\\t\\t*  take all permutation of K elements, by generating submasks and do function call and take mininmum among all, just like MCM. \\n\\n```\\nclass Solution {\\n    \\n    public int minNumberOfSemesters(int n, int[][] relations, int k) {\\n        \\n        //total courses mask\\n        int course_mask = (1<<n) - 1;\\n        \\n        this.dp = new Integer[course_mask+1] ;\\n        \\n        return helper(n, relations, course_mask, k) ;\\n    }\\n    \\n    \\n    Integer dp[] ;\\n    \\n    int helper(int n, int[][] relations, int course_mask, int k) {\\n        \\n        //if all courses are visited\\n        if(course_mask == 0) return 0 ;\\n        \\n        if(dp[course_mask]!= null) return dp[course_mask] ;\\n        \\n        //calculating indegree\\n        int indeg[] = new int[n] ;\\n        for(int rel[] : relations) {\\n            int u = rel[0]-1 ;\\n            int v = rel[1]-1 ;\\n            if(isBitOn(course_mask, u)) indeg[v]++ ;\\n        }\\n        \\n        //mask for total available course to take this semester \\n        int avail_course_mask = 0 ;\\n        for(int i=0 ; i<indeg.length ; i++) {\\n            if(indeg[i] == 0 && isBitOn(course_mask,i)) \\n                avail_course_mask = setKthBit(avail_course_mask, i) ;\\n        }\\n        \\n        //total available course in this semester\\n        int total_available_course_this_sem = countSetBits(avail_course_mask) ;\\n        \\n        if(total_available_course_this_sem <= k) {\\n            int newMask = (course_mask ^ avail_course_mask) ;\\n            return dp[course_mask] = 1 + helper(n, relations, newMask, k) ;\\n        }\\n        \\n        //Generating all permutation of avail_course_mask in which K bit is ON.\\n        int min = n ;\\n        for(int subs = avail_course_mask ; subs > 0 ; subs = (subs-1) & avail_course_mask) {\\n            if(countSetBits(subs) == k) {\\n                int newMask = (course_mask ^ subs) ;\\n                int temp = 1 + helper(n, relations, newMask, k) ;\\n                min = Math.min(min,temp) ;\\n            }\\n        }\\n        \\n        return dp[course_mask] = min ;\\n    }\\n    \\n    boolean isBitOn(int num, int k) {\\n        return (num&(1<<k)) > 0 ;\\n    }\\n    \\n    int setKthBit(int num, int k) {\\n        return (num^(1<<k)) ;\\n    }\\n    \\n    int countSetBits(int num) {\\n        int count = 0 ;\\n        while(num != 0) {\\n            num &= (num-1) ;\\n            count++ ;\\n        } \\n        return count ;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int minNumberOfSemesters(int n, int[][] relations, int k) {\\n        \\n        //total courses mask\\n        int course_mask = (1<<n) - 1;\\n        \\n        this.dp = new Integer[course_mask+1] ;\\n        \\n        return helper(n, relations, course_mask, k) ;\\n    }\\n    \\n    \\n    Integer dp[] ;\\n    \\n    int helper(int n, int[][] relations, int course_mask, int k) {\\n        \\n        //if all courses are visited\\n        if(course_mask == 0) return 0 ;\\n        \\n        if(dp[course_mask]!= null) return dp[course_mask] ;\\n        \\n        //calculating indegree\\n        int indeg[] = new int[n] ;\\n        for(int rel[] : relations) {\\n            int u = rel[0]-1 ;\\n            int v = rel[1]-1 ;\\n            if(isBitOn(course_mask, u)) indeg[v]++ ;\\n        }\\n        \\n        //mask for total available course to take this semester \\n        int avail_course_mask = 0 ;\\n        for(int i=0 ; i<indeg.length ; i++) {\\n            if(indeg[i] == 0 && isBitOn(course_mask,i)) \\n                avail_course_mask = setKthBit(avail_course_mask, i) ;\\n        }\\n        \\n        //total available course in this semester\\n        int total_available_course_this_sem = countSetBits(avail_course_mask) ;\\n        \\n        if(total_available_course_this_sem <= k) {\\n            int newMask = (course_mask ^ avail_course_mask) ;\\n            return dp[course_mask] = 1 + helper(n, relations, newMask, k) ;\\n        }\\n        \\n        //Generating all permutation of avail_course_mask in which K bit is ON.\\n        int min = n ;\\n        for(int subs = avail_course_mask ; subs > 0 ; subs = (subs-1) & avail_course_mask) {\\n            if(countSetBits(subs) == k) {\\n                int newMask = (course_mask ^ subs) ;\\n                int temp = 1 + helper(n, relations, newMask, k) ;\\n                min = Math.min(min,temp) ;\\n            }\\n        }\\n        \\n        return dp[course_mask] = min ;\\n    }\\n    \\n    boolean isBitOn(int num, int k) {\\n        return (num&(1<<k)) > 0 ;\\n    }\\n    \\n    int setKthBit(int num, int k) {\\n        return (num^(1<<k)) ;\\n    }\\n    \\n    int countSetBits(int num) {\\n        int count = 0 ;\\n        while(num != 0) {\\n            num &= (num-1) ;\\n            count++ ;\\n        } \\n        return count ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 708206,
                "title": "dp-with-bitmask-solution-o-n-4-n",
                "content": "`dp[d][mask]` = whether it\\'s possible to take courses represented by mask by day d.\\nAnswer is the minimum d such that `dp[d][(1 << N) - 1]` = true\\nUpper bound on time complexity is `O(N * 4 ^ N)` but that is a very loose upper bound and would unlikely be reached.\\n\\n```\\nclass Solution {\\npublic:\\n    int minNumberOfSemesters(int n, vector<vector<int>>& dep, int k) {\\n        vector<vector<int>> prereq(n);\\n        for(auto& d : dep) {\\n            prereq[d[1]-1].push_back(d[0]-1);\\n        }\\n        vector<vector<bool>> dp(n+1, vector<bool>(1 << n, false));\\n        dp[0][0] = true;\\n        for(int day = 0; day < n; day++) {\\n            for(int mask = 0; mask < (1 << n); mask++) {\\n                if(!dp[day][mask]) {\\n                    continue;\\n                }\\n                dp[day+1][mask] = true;\\n                vector<int> nxtPossible;\\n                // where can i go from here\\n                for(int course = 0; course < n; course++) {\\n                    if(mask & (1 << course)) {\\n                        continue;\\n                    }\\n                    // can i take this course ?\\n                    bool ok = true;\\n                    for(int pre : prereq[course]) {\\n                        ok &= ((mask >> pre) & 1);\\n                    }\\n                    if(ok) {\\n                        nxtPossible.push_back(course);\\n                    }\\n                }\\n                int NP = nxtPossible.size();\\n                for(int take = 1; take < (1 << NP); take++) {\\n                    int takeCnt = __builtin_popcount(take);\\n                    if(takeCnt > k) {\\n                        continue;\\n                    }\\n                    int nxtMask = mask;\\n                    for(int i = 0; i < NP; i++) {\\n                        if(take & (1 << i)) {\\n                            nxtMask |= (1 << nxtPossible[i]);\\n                        }\\n                    }\\n                    dp[day+1][nxtMask] = true;\\n                }\\n            }\\n            if(dp[day+1][(1 << n)-1]) {\\n                return day + 1;\\n            }\\n        }\\n        assert(false);\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfSemesters(int n, vector<vector<int>>& dep, int k) {\\n        vector<vector<int>> prereq(n);\\n        for(auto& d : dep) {\\n            prereq[d[1]-1].push_back(d[0]-1);\\n        }\\n        vector<vector<bool>> dp(n+1, vector<bool>(1 << n, false));\\n        dp[0][0] = true;\\n        for(int day = 0; day < n; day++) {\\n            for(int mask = 0; mask < (1 << n); mask++) {\\n                if(!dp[day][mask]) {\\n                    continue;\\n                }\\n                dp[day+1][mask] = true;\\n                vector<int> nxtPossible;\\n                // where can i go from here\\n                for(int course = 0; course < n; course++) {\\n                    if(mask & (1 << course)) {\\n                        continue;\\n                    }\\n                    // can i take this course ?\\n                    bool ok = true;\\n                    for(int pre : prereq[course]) {\\n                        ok &= ((mask >> pre) & 1);\\n                    }\\n                    if(ok) {\\n                        nxtPossible.push_back(course);\\n                    }\\n                }\\n                int NP = nxtPossible.size();\\n                for(int take = 1; take < (1 << NP); take++) {\\n                    int takeCnt = __builtin_popcount(take);\\n                    if(takeCnt > k) {\\n                        continue;\\n                    }\\n                    int nxtMask = mask;\\n                    for(int i = 0; i < NP; i++) {\\n                        if(take & (1 << i)) {\\n                            nxtMask |= (1 << nxtPossible[i]);\\n                        }\\n                    }\\n                    dp[day+1][nxtMask] = true;\\n                }\\n            }\\n            if(dp[day+1][(1 << n)-1]) {\\n                return day + 1;\\n            }\\n        }\\n        assert(false);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1683840,
                "title": "java-dp-bitmask",
                "content": "~~~java\\n\\nclass Solution {\\n    \\n    public int minNumberOfSemesters(int n, int[][] relations, int k) {\\n        int[] pres = new int[n];\\n        for (int[] r : relations) {\\n            int prev = r[0] - 1;\\n            int next = r[1] - 1;\\n            pres[next] |= (1 << prev);\\n        }\\n        \\n        int[] dp = new int[1 << n];\\n        Arrays.fill(dp, n);\\n        dp[0] = 0;\\n        \\n        for (int mask = 0; mask < dp.length; mask++) {\\n            int canTake = 0;\\n            for (int i = 0; i < n; i++) {\\n                // already taken\\n                if ((mask & (1 << i)) != 0) {\\n                    continue;\\n                }\\n                // satisfy all pres\\n                if ((mask & pres[i]) == pres[i]) {\\n                    canTake |= (1 << i);\\n                }\\n            }\\n            \\n            // loop each sub-masks\\n            for (int take = canTake; take > 0; take = (take - 1) & canTake) {\\n                if (Integer.bitCount(take) > k) {\\n                    continue;\\n                }\\n                dp[take | mask] = Math.min(dp[take | mask], dp[mask] + 1);\\n            }\\n        }\\n        \\n        return dp[(1 << n) - 1];\\n    }\\n}\\n\\n\\n\\n~~~",
                "solutionTags": [
                    "Java",
                    "Bitmask"
                ],
                "code": "class Solution {\\n    \\n    public int minNumberOfSemesters(int n, int[][] relations, int k) {\\n        int[] pres = new int[n];\\n        for (int[] r : relations) {\\n            int prev = r[0] - 1;\\n            int next = r[1] - 1;\\n            pres[next] |= (1 << prev);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1599128,
                "title": "java-dp",
                "content": "Java DP Bitmask. This is a nice problem . There are 3 key things to track here \\n\\n1. The set of already taken courses which is the mask variable\\n2. What are the next set of courses to take? `availableCourses`\\n3. Try all possible combinations of `availableCourses` and take the best one.\\n```\\nfor (int i = 0; i < n; i += 1) {\\n            if ((mask & prereq[i]) == prereq[i]) {\\n                if( (mask & (1<<i))>0 )\\n                    continue;\\n                availableCourses |= 1 << i;\\n            }\\n        }\\n```\\nThe above means if i have taken all the prerequistes for the `ith` course i can take the `ith` course. and for that course exclude the already taken course.\\nOnce we have the available set of courses use the submask enumeration trick from https://cp-algorithms.com/algebra/all-submasks.html and take the best mask.\\n\\n\\n\\n```\\nclass Solution {\\n    public int minNumberOfSemesters(int n, int[][] relations, int k) {\\n        int[] prereq = new int[n];\\n        for (int[] req : relations) {\\n            prereq[req[1] - 1] |= 1 << (req[0] - 1);\\n        }\\n        int[] dp = new int[(1 << n)];\\n        Arrays.fill(dp, -1);\\n        return solve(0, n, k, prereq, dp);\\n    }\\n\\n    private int solve(int mask, int n, int k, int[] prereq, int[] dp) {\\n        if (mask == (1 << n) - 1) {\\n            return 0;\\n        }\\n        if (dp[mask] != -1) {\\n            return dp[mask];\\n        }\\n        int availableCourses = 0;\\n        for (int i = 0; i < n; i += 1) {\\n            if ((mask & prereq[i]) == prereq[i]) {\\n                if( (mask & (1<<i))>0 )\\n                    continue;\\n                availableCourses |= 1 << i;\\n            }\\n        }\\n        int best = Integer.MAX_VALUE / 2;\\n        for (int submask = availableCourses; submask > 0; submask = (submask - 1) & availableCourses) {\\n            if (Integer.bitCount(submask) <= k) {\\n                best = Math.min(best, 1 + solve(mask | submask, n, k, prereq, dp));\\n            }\\n        }\\n        return dp[mask] = best;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nfor (int i = 0; i < n; i += 1) {\\n            if ((mask & prereq[i]) == prereq[i]) {\\n                if( (mask & (1<<i))>0 )\\n                    continue;\\n                availableCourses |= 1 << i;\\n            }\\n        }\\n```\n```\\nclass Solution {\\n    public int minNumberOfSemesters(int n, int[][] relations, int k) {\\n        int[] prereq = new int[n];\\n        for (int[] req : relations) {\\n            prereq[req[1] - 1] |= 1 << (req[0] - 1);\\n        }\\n        int[] dp = new int[(1 << n)];\\n        Arrays.fill(dp, -1);\\n        return solve(0, n, k, prereq, dp);\\n    }\\n\\n    private int solve(int mask, int n, int k, int[] prereq, int[] dp) {\\n        if (mask == (1 << n) - 1) {\\n            return 0;\\n        }\\n        if (dp[mask] != -1) {\\n            return dp[mask];\\n        }\\n        int availableCourses = 0;\\n        for (int i = 0; i < n; i += 1) {\\n            if ((mask & prereq[i]) == prereq[i]) {\\n                if( (mask & (1<<i))>0 )\\n                    continue;\\n                availableCourses |= 1 << i;\\n            }\\n        }\\n        int best = Integer.MAX_VALUE / 2;\\n        for (int submask = availableCourses; submask > 0; submask = (submask - 1) & availableCourses) {\\n            if (Integer.bitCount(submask) <= k) {\\n                best = Math.min(best, 1 + solve(mask | submask, n, k, prereq, dp));\\n            }\\n        }\\n        return dp[mask] = best;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 708346,
                "title": "java-clean-code-dp-with-bitmask",
                "content": "**Dynamic Programming with Bit Mask**\\n\\n```java\\npublic int minNumberOfSemesters(int n, int[][] dependencies, int k) {\\n\\tint[] prerequisites = new int[n]; // This array contains all the courses required by a destination course.\\n\\n\\tint[] dp = new int[1 << n];\\n\\tArrays.fill(dp, -1);\\n\\tfor(int i = 0; i < dependencies.length; i++){\\n\\t\\tint source = dependencies[i][0];\\n\\t\\tint dest = dependencies[i][1];\\n\\t\\tprerequisites[dest - 1] ^= (1 << (source - 1));\\n\\t}\\n\\treturn calculate(prerequisites, dp, k, n, 0);\\n}\\n\\nprivate int calculate(int[] prerequisites, int[] dp, int k, int n, int available) {\\n\\tif(available == ((1 << n) - 1)) return 0;\\n\\tif(dp[available] != -1) return dp[available];\\n\\n\\tint ans = Integer.MAX_VALUE;\\n\\n\\tfor(int i = 0; i < n; i++){\\n\\t\\tint current = available;\\n\\t\\tint counter = 0;\\n\\t\\tint j = i; \\n\\t\\twhile (counter < k && j < n) { // Take atmost k courses from the current index i. \\n\\t\\t\\tif ((available & (1 << j)) == 0 && ((prerequisites[j] & available) == prerequisites[j])) { // If the course is not taken yet and all its prerequisites have been taken.\\n\\t\\t\\t\\tcurrent ^= (1 << j);\\n\\t\\t\\t\\tcounter++;\\n\\t\\t\\t}\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\t\\tif(current != available){ // If current is equal to available couldn\\'t find any courses this semester\\n\\t\\t\\tint val = calculate(prerequisites, dp, k, n, current);\\n\\t\\t\\tif (val != Integer.MAX_VALUE)\\n\\t\\t\\t\\tans = Math.min(ans, 1 + val);\\n\\t\\t}\\n\\t}\\n\\tdp[available] = ans;\\n\\treturn ans;\\n}",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "**Dynamic Programming with Bit Mask**\\n\\n```java\\npublic int minNumberOfSemesters(int n, int[][] dependencies, int k) {\\n\\tint[] prerequisites = new int[n]; // This array contains all the courses required by a destination course.\\n\\n\\tint[] dp = new int[1 << n];\\n\\tArrays.fill(dp, -1);\\n\\tfor(int i = 0; i < dependencies.length; i++){\\n\\t\\tint source = dependencies[i][0];\\n\\t\\tint dest = dependencies[i][1];\\n\\t\\tprerequisites[dest - 1] ^= (1 << (source - 1));\\n\\t}\\n\\treturn calculate(prerequisites, dp, k, n, 0);\\n}\\n\\nprivate int calculate(int[] prerequisites, int[] dp, int k, int n, int available) {\\n\\tif(available == ((1 << n) - 1)) return 0;\\n\\tif(dp[available] != -1) return dp[available];\\n\\n\\tint ans = Integer.MAX_VALUE;\\n\\n\\tfor(int i = 0; i < n; i++){\\n\\t\\tint current = available;\\n\\t\\tint counter = 0;\\n\\t\\tint j = i; \\n\\t\\twhile (counter < k && j < n) { // Take atmost k courses from the current index i. \\n\\t\\t\\tif ((available & (1 << j)) == 0 && ((prerequisites[j] & available) == prerequisites[j])) { // If the course is not taken yet and all its prerequisites have been taken.\\n\\t\\t\\t\\tcurrent ^= (1 << j);\\n\\t\\t\\t\\tcounter++;\\n\\t\\t\\t}\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\t\\tif(current != available){ // If current is equal to available couldn\\'t find any courses this semester\\n\\t\\t\\tint val = calculate(prerequisites, dp, k, n, current);\\n\\t\\t\\tif (val != Integer.MAX_VALUE)\\n\\t\\t\\t\\tans = Math.min(ans, 1 + val);\\n\\t\\t}\\n\\t}\\n\\tdp[available] = ans;\\n\\treturn ans;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2243617,
                "title": "well-commented-28ms-java-very-simple-approach",
                "content": "```\\n    static int min;\\n    static List<Set<Integer>> preReq;\\n    static int minNumberOfSemesters(int n, int[][] relations, int k) {\\n        min = n;\\n        preReq = new ArrayList<>();\\n        for(int i = 0; i <= n; i++){preReq.add(new HashSet<>());}\\n        for(int [] relation : relations){preReq.get(relation[1]).add(relation[0]);}\\n        setResult(n, new ArrayList<>(), k, 0);\\n        return min;\\n    }\\n    \\n    static void setResult(int n, List<Integer> taken, int k, int sem){\\n        if(taken.size() == n){//Completed all courses.\\n            min = Math.min(min, sem);\\n            return;\\n        }\\n        \\n        if(sem + (int)Math.ceil((double)(n - taken.size())/k) >= min) \\n            return;//Can\\'t do better than current min.\\n        \\n        List<Integer> availableCourses = getAvailableCourses(taken);\\n        if(availableCourses.size() <= k){\\n        /* All available courses can be taken next semester.*/\\n            taken.addAll(availableCourses);\\n            setResult(n, taken, k, sem+1);\\n            return;\\n        }\\n        \\n        /* sizeof(availableCourses) > k */\\n        int size = availableCourses.size();\\n        /* Iterating over all possible subsets of size k in the available courses list.*/\\n        for(int mask = 1; mask < (1 << size); mask++){\\n            /* courses to be scheduled next semester. */\\n            List<Integer> kCourses = new ArrayList<>();\\n            \\n            for(int i = 0; i < size; i++){\\n                if( (mask & (1<<i)) != 0){\\n                    kCourses.add(availableCourses.get(i));\\n                }\\n            }\\n            if(kCourses.size() != k) continue;\\n            /* Try taking the current subset and call recursively.*/\\n            kCourses.addAll(taken);\\n            setResult(n, kCourses, k, sem+1);\\n        }\\n    }\\n    \\n    static List<Integer> getAvailableCourses(List<Integer> coursesTaken){\\n        List<Integer> availableCourses = new ArrayList<>();\\n        for(int course = 1; course < preReq.size(); course++){\\n            /* Checking if the course is already taken or if any of its prerequisites hasn\\'t yet been taken.*/\\n            if(coursesTaken.contains(course) || !coursesTaken.containsAll(preReq.get(course))) \\n                continue;\\n            availableCourses.add(course);\\n        }\\n        return availableCourses;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    static int min;\\n    static List<Set<Integer>> preReq;\\n    static int minNumberOfSemesters(int n, int[][] relations, int k) {\\n        min = n;\\n        preReq = new ArrayList<>();\\n        for(int i = 0; i <= n; i++){preReq.add(new HashSet<>());}\\n        for(int [] relation : relations){preReq.get(relation[1]).add(relation[0]);}\\n        setResult(n, new ArrayList<>(), k, 0);\\n        return min;\\n    }\\n    \\n    static void setResult(int n, List<Integer> taken, int k, int sem){\\n        if(taken.size() == n){//Completed all courses.\\n            min = Math.min(min, sem);\\n            return;\\n        }\\n        \\n        if(sem + (int)Math.ceil((double)(n - taken.size())/k) >= min) \\n            return;//Can\\'t do better than current min.\\n        \\n        List<Integer> availableCourses = getAvailableCourses(taken);\\n        if(availableCourses.size() <= k){\\n        /* All available courses can be taken next semester.*/\\n            taken.addAll(availableCourses);\\n            setResult(n, taken, k, sem+1);\\n            return;\\n        }\\n        \\n        /* sizeof(availableCourses) > k */\\n        int size = availableCourses.size();\\n        /* Iterating over all possible subsets of size k in the available courses list.*/\\n        for(int mask = 1; mask < (1 << size); mask++){\\n            /* courses to be scheduled next semester. */\\n            List<Integer> kCourses = new ArrayList<>();\\n            \\n            for(int i = 0; i < size; i++){\\n                if( (mask & (1<<i)) != 0){\\n                    kCourses.add(availableCourses.get(i));\\n                }\\n            }\\n            if(kCourses.size() != k) continue;\\n            /* Try taking the current subset and call recursively.*/\\n            kCourses.addAll(taken);\\n            setResult(n, kCourses, k, sem+1);\\n        }\\n    }\\n    \\n    static List<Integer> getAvailableCourses(List<Integer> coursesTaken){\\n        List<Integer> availableCourses = new ArrayList<>();\\n        for(int course = 1; course < preReq.size(); course++){\\n            /* Checking if the course is already taken or if any of its prerequisites hasn\\'t yet been taken.*/\\n            if(coursesTaken.contains(course) || !coursesTaken.containsAll(preReq.get(course))) \\n                continue;\\n            availableCourses.add(course);\\n        }\\n        return availableCourses;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1294892,
                "title": "dfs-with-memoization-in-python",
                "content": "Main Idea: \\nAt every recursion level, chose courses satisfying 2 conditions:\\n\\t\\t\\t\\t 1. The courses are not yet taken\\n\\t\\t\\t\\t 2. The pre-reqs of the courses are already taken\\nAnd keep recursing until all courses are taken\\n\\n```\\nclass Solution:\\n    \\n    def get_pre_reqs(self, n, dependencies):\\n        \\n        pre_reqs = defaultdict(lambda: set())\\n        \\n        for dep in dependencies:\\n            pre_reqs[dep[1]].add(dep[0])\\n            \\n        return pre_reqs\\n    \\n    def min_sems(self, untaken, pre_reqs, k, memo):\\n        \\n        untaken_tup = tuple(sorted(untaken))\\n        \\n        if untaken_tup in memo:\\n            return memo[untaken_tup] \\n        \\n        elif len(untaken) == 0:\\n            return 0           \\n        \\n        else:\\n            candidates = {c for c in untaken if len(untaken.intersection(pre_reqs[c])) == 0}\\n            \\n            combs = combinations(candidates, min(len(candidates), k))\\n            _min_sems = float(\"+inf\")\\n            for comb in combs:\\n                _min_sems = min(_min_sems, 1 + self.min_sems(untaken - set(comb), pre_reqs, k, memo))\\n            memo[untaken_tup] = _min_sems\\n            return memo[untaken_tup]\\n    \\n    def minNumberOfSemesters(self, n: int, dependencies: List[List[int]], k: int) -> int:\\n        \\n        pre_reqs = self.get_pre_reqs(n, dependencies)        \\n        return self.min_sems(set(range(1, n+1)), pre_reqs, k, dict())\\n                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    def get_pre_reqs(self, n, dependencies):\\n        \\n        pre_reqs = defaultdict(lambda: set())\\n        \\n        for dep in dependencies:\\n            pre_reqs[dep[1]].add(dep[0])\\n            \\n        return pre_reqs\\n    \\n    def min_sems(self, untaken, pre_reqs, k, memo):\\n        \\n        untaken_tup = tuple(sorted(untaken))\\n        \\n        if untaken_tup in memo:\\n            return memo[untaken_tup] \\n        \\n        elif len(untaken) == 0:\\n            return 0           \\n        \\n        else:\\n            candidates = {c for c in untaken if len(untaken.intersection(pre_reqs[c])) == 0}\\n            \\n            combs = combinations(candidates, min(len(candidates), k))\\n            _min_sems = float(\"+inf\")\\n            for comb in combs:\\n                _min_sems = min(_min_sems, 1 + self.min_sems(untaken - set(comb), pre_reqs, k, memo))\\n            memo[untaken_tup] = _min_sems\\n            return memo[untaken_tup]\\n    \\n    def minNumberOfSemesters(self, n: int, dependencies: List[List[int]], k: int) -> int:\\n        \\n        pre_reqs = self.get_pre_reqs(n, dependencies)        \\n        return self.min_sems(set(range(1, n+1)), pre_reqs, k, dict())\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1088716,
                "title": "java-1ms-100-98-memory-topological-sort-bitmask-bfs",
                "content": "A solution derived from Parallel Courses I\\nBrainstorm steps as follow:\\n1. build the graph based an dependencies, each entry index represent a course and the value of the entry represent the information of all prerequisites courses.\\n2. have an outedge degree record for each course.\\n3. take the course that the prerequisites courses all finished, and record the taken courses, semester + 1. However, since we can only take k courses each semester.  we need to \"cleverly\" take the course somehow. An interesting finding is that, as a student, we should plan for future, that is : \"take the courses that can unlock some other courses first\", and \"take the courses that we can take anytime only if we have free spot/s\"\\n4. if the number of courses \"n1\" that can unlock other courses are larger than k, then we need to find all combination (n1, k) of the courses. \\n5. since each of the combination might lead to a different result, and we want to minimum number of semesters to finish all courses. A BFS approach is required.\\n6. Then, think about how we could effciently make sure the prerequisites of a course are finished, and it is a course that has not been taken yet.  **Since we only have a small number of courses  n <= 15, a bitmask can be used! Suppose finished course is represented as 1, and we can use a 15 digit number \"record\" to represent the record of all courses. Bitwise and \"record\" with the prerequisites of a course, will tell you whether the prerequites courses are finished. Similarly, Bitwise and \"record\" with the binary representation of a single course will tell you whether its a course that has not been taken yet.**\\n7. BFS introduce an implicit decision tree, and we do not revisit a node with the same \"record\", then we need to store the visited node information, this requires at most 2 ^ 15 memory slot;\\n8.  Since we traverse the implicit decision tree in a BFS way, and the state that n courses are finished is always \"2 ^ n - 1\", if the node record equals 2 ^ n - 1, we know we have the minimum answer. \\n```\\nclass Solution {\\n    public int minNumberOfSemesters(int n, int[][] dependencies, int k) {\\n        int[] graph = new int[n];\\n        int[] outDegree = new int[n];\\n        // precalculate the power of 2 representation of each course\\n        for (int[] depend : dependencies){\\n            int a = depend[0];\\n            int b = depend[1];\\n            graph[b - 1] += 1 << (a-1);\\n            outDegree[a-1] += 1;\\n        }\\n        int[] p2 = new int[n];\\n        for (int i = 0; i < n; i++){\\n            p2[i] = 1 << i;\\n        }\\n        int start = 0;\\n        int goal = (1 << n) - 1;\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.add(new int[]{start, 0});\\n        boolean[] visited = new boolean[goal + 1];\\n        \\n        // an interesting finding is that, we should only \\n        // take the courses that have no prerequisites that can \\n        // \"UNLOCK\" some courses first!\\n        while (!queue.isEmpty()){\\n            int[] cur = queue.poll();\\n            int node = cur[0];\\n            int steps = cur[1];\\n            // find remaining courses that can unlock, and throw\\n            // the remaining \"can take\" ones into remain.\\n            List<Integer> unlock= new ArrayList<>();\\n            List<Integer> remain = new ArrayList<>();\\n            for (int i = 0; i < n; i++){\\n                if (((node & graph[i]) == graph[i])&& ((node & p2[i]) == 0)){\\n                    if (outDegree[i] > 0){\\n                        unlock.add(p2[i]);\\n                    }\\n                    else {\\n                        remain.add(p2[i]);\\n                    }\\n                }\\n            }\\n            int l1 = unlock.size();\\n            int l2 = remain.size();\\n            if (l1 <= k){\\n                node += sum(unlock, l1) + sum(remain, k - l1);\\n                if (node == goal) return steps + 1;\\n                if (!visited[node]){\\n                    queue.add(new int[]{node, steps + 1});\\n                    visited[node] = true;\\n                }\\n            }\\n            else {\\n                // we have to select k courses from unlock;\\n                List<int[]> comb = new ArrayList<>();\\n                findCombinations(comb, new int[k], 0, 0, unlock);\\n                for (int[] c : comb){\\n                    int sum = 0;\\n                    for (int i = 0; i < c.length; i++){\\n                        sum += c[i];\\n                    }\\n                    sum += node;\\n                    if (sum == goal) return steps + 1;\\n                    if (!visited[sum]){\\n                        queue.add(new int[]{sum, steps + 1});\\n                        visited[sum] = true;\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    private void findCombinations(List<int[]> comb, int[] data, int start,\\n                                 int index, List<Integer> unlock){\\n        if (index == data.length){\\n            comb.add(data.clone());\\n        }\\n        else if (start < unlock.size()) {\\n            data[index] = unlock.get(start);\\n            findCombinations(comb, data, start + 1, index + 1, unlock);\\n            findCombinations(comb, data, start + 1, index, unlock);\\n        }\\n        return;\\n    }\\n    private int sum(List<Integer> l, int n){\\n        int sum = 0;\\n        int size = l.size();\\n        for (int i = 0; i < n && i < size; i++){\\n            sum += l.remove(0);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minNumberOfSemesters(int n, int[][] dependencies, int k) {\\n        int[] graph = new int[n];\\n        int[] outDegree = new int[n];\\n        // precalculate the power of 2 representation of each course\\n        for (int[] depend : dependencies){\\n            int a = depend[0];\\n            int b = depend[1];\\n            graph[b - 1] += 1 << (a-1);\\n            outDegree[a-1] += 1;\\n        }\\n        int[] p2 = new int[n];\\n        for (int i = 0; i < n; i++){\\n            p2[i] = 1 << i;\\n        }\\n        int start = 0;\\n        int goal = (1 << n) - 1;\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.add(new int[]{start, 0});\\n        boolean[] visited = new boolean[goal + 1];\\n        \\n        // an interesting finding is that, we should only \\n        // take the courses that have no prerequisites that can \\n        // \"UNLOCK\" some courses first!\\n        while (!queue.isEmpty()){\\n            int[] cur = queue.poll();\\n            int node = cur[0];\\n            int steps = cur[1];\\n            // find remaining courses that can unlock, and throw\\n            // the remaining \"can take\" ones into remain.\\n            List<Integer> unlock= new ArrayList<>();\\n            List<Integer> remain = new ArrayList<>();\\n            for (int i = 0; i < n; i++){\\n                if (((node & graph[i]) == graph[i])&& ((node & p2[i]) == 0)){\\n                    if (outDegree[i] > 0){\\n                        unlock.add(p2[i]);\\n                    }\\n                    else {\\n                        remain.add(p2[i]);\\n                    }\\n                }\\n            }\\n            int l1 = unlock.size();\\n            int l2 = remain.size();\\n            if (l1 <= k){\\n                node += sum(unlock, l1) + sum(remain, k - l1);\\n                if (node == goal) return steps + 1;\\n                if (!visited[node]){\\n                    queue.add(new int[]{node, steps + 1});\\n                    visited[node] = true;\\n                }\\n            }\\n            else {\\n                // we have to select k courses from unlock;\\n                List<int[]> comb = new ArrayList<>();\\n                findCombinations(comb, new int[k], 0, 0, unlock);\\n                for (int[] c : comb){\\n                    int sum = 0;\\n                    for (int i = 0; i < c.length; i++){\\n                        sum += c[i];\\n                    }\\n                    sum += node;\\n                    if (sum == goal) return steps + 1;\\n                    if (!visited[sum]){\\n                        queue.add(new int[]{sum, steps + 1});\\n                        visited[sum] = true;\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    private void findCombinations(List<int[]> comb, int[] data, int start,\\n                                 int index, List<Integer> unlock){\\n        if (index == data.length){\\n            comb.add(data.clone());\\n        }\\n        else if (start < unlock.size()) {\\n            data[index] = unlock.get(start);\\n            findCombinations(comb, data, start + 1, index + 1, unlock);\\n            findCombinations(comb, data, start + 1, index, unlock);\\n        }\\n        return;\\n    }\\n    private int sum(List<Integer> l, int n){\\n        int sum = 0;\\n        int size = l.size();\\n        for (int i = 0; i < n && i < size; i++){\\n            sum += l.remove(0);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 959845,
                "title": "python-3-brute-force-trying-all-combinations-bfs-328ms-67-faster",
                "content": "```\\nclass Solution:\\n    def minNumberOfSemesters(self, n: int, dependencies: List[List[int]], k: int) -> int:\\n        f= defaultdict(list)\\n        for x, y in dependencies:\\n            f[y].append(x)\\n\\n        cands = [x for x in range(1, n+1) if x not in f]\\n        stack = [(1, list(x)) for x in combinations(cands, min(k, len(cands)))]\\n\\n\\t\\tvis = set()\\n        while stack:\\n            semester, taken = heappop(stack)\\n            if len(taken) == n:\\n                return semester\\n            cands = [x for x in range(1, n+1) if x not in taken and all(y in taken for y in f[x])]\\n            for cand in combinations(cands, min(k, len(cands))):\\n                newtaken = sorted(taken+list(cand))\\n                if (tuple(newtaken), semester+1) not in vis:\\n                    vis.add((tuple(newtaken), semester+1))\\n                    heappush(stack, (semester+1, newtaken))",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minNumberOfSemesters(self, n: int, dependencies: List[List[int]], k: int) -> int:\\n        f= defaultdict(list)\\n        for x, y in dependencies:\\n            f[y].append(x)\\n\\n        cands = [x for x in range(1, n+1) if x not in f]\\n        stack = [(1, list(x)) for x in combinations(cands, min(k, len(cands)))]\\n\\n\\t\\tvis = set()\\n        while stack:\\n            semester, taken = heappop(stack)\\n            if len(taken) == n:\\n                return semester\\n            cands = [x for x in range(1, n+1) if x not in taken and all(y in taken for y in f[x])]\\n            for cand in combinations(cands, min(k, len(cands))):\\n                newtaken = sorted(taken+list(cand))\\n                if (tuple(newtaken), semester+1) not in vis:\\n                    vis.add((tuple(newtaken), semester+1))\\n                    heappush(stack, (semester+1, newtaken))",
                "codeTag": "Java"
            },
            {
                "id": 817291,
                "title": "modular-c-solution-bitmask-recursion-with-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> graph[20];\\n    int dp[(1<<15)+1], N, maxSub;\\n    \\n    vector<int> getIndegFromMask(int mask) {\\n        vector<int> indeg(N, 0);\\n        for(int i=0; i<N; ++i) {\\n            if(!(mask&(1<<i))) {\\n                for(int j=0; j<graph[i].size(); ++j) {\\n                    int v = graph[i][j];\\n                    indeg[v]++;   \\n                }\\n            }\\n        }\\n        return indeg;\\n    }\\n    \\n    int countSetBits(int mask) {\\n        int cnt = 0;\\n        for(int i=0; i<N; ++i) {\\n            if(mask&(1<<i)) {\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n    \\n    int setBitsWithDegZero(vector<int> indeg, int mask) {\\n        int x = 0;\\n        for(int i=0; i<N; ++i) {\\n            if(indeg[i]==0 && !(mask&(1<<i))) {\\n                x |= (1<<i);\\n            }\\n        }\\n        return x;\\n    }\\n    \\n    int solve(int mask) {\\n        if(mask == (1<<N)-1)\\n            return 0;\\n        \\n        if(dp[mask] != -1)\\n            return dp[mask];\\n        \\n        vector<int> indeg = getIndegFromMask(mask);\\n        int eligibleMask = setBitsWithDegZero(indeg, mask);\\n        int validSubjectsCnt = countSetBits(eligibleMask);\\n        \\n        if(validSubjectsCnt <= maxSub) {\\n            return dp[mask] = 1+solve(mask | eligibleMask);\\n        } else {\\n            int ans = N;\\n            // traverse through all sub-masks of mask such that only k subjects are selected\\n            for(int s=eligibleMask; s>0; s=eligibleMask&(s-1)) {\\n                if(maxSub == countSetBits(s)) {\\n                    ans = min(ans, 1+solve(mask | s));\\n                }\\n            }\\n            return dp[mask] = ans;\\n        }\\n    }\\n    \\n    int minNumberOfSemesters(int n, vector<vector<int>>& dependencies, int k) {\\n        N = n;\\n        maxSub = k;\\n        memset(dp, -1, sizeof dp);\\n        for(int i=0; i<dependencies.size(); ++i) {\\n            graph[dependencies[i][0]-1].push_back(dependencies[i][1]-1);\\n        }\\n        return solve(0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> graph[20];\\n    int dp[(1<<15)+1], N, maxSub;\\n    \\n    vector<int> getIndegFromMask(int mask) {\\n        vector<int> indeg(N, 0);\\n        for(int i=0; i<N; ++i) {\\n            if(!(mask&(1<<i))) {\\n                for(int j=0; j<graph[i].size(); ++j) {\\n                    int v = graph[i][j];\\n                    indeg[v]++;   \\n                }\\n            }\\n        }\\n        return indeg;\\n    }\\n    \\n    int countSetBits(int mask) {\\n        int cnt = 0;\\n        for(int i=0; i<N; ++i) {\\n            if(mask&(1<<i)) {\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n    \\n    int setBitsWithDegZero(vector<int> indeg, int mask) {\\n        int x = 0;\\n        for(int i=0; i<N; ++i) {\\n            if(indeg[i]==0 && !(mask&(1<<i))) {\\n                x |= (1<<i);\\n            }\\n        }\\n        return x;\\n    }\\n    \\n    int solve(int mask) {\\n        if(mask == (1<<N)-1)\\n            return 0;\\n        \\n        if(dp[mask] != -1)\\n            return dp[mask];\\n        \\n        vector<int> indeg = getIndegFromMask(mask);\\n        int eligibleMask = setBitsWithDegZero(indeg, mask);\\n        int validSubjectsCnt = countSetBits(eligibleMask);\\n        \\n        if(validSubjectsCnt <= maxSub) {\\n            return dp[mask] = 1+solve(mask | eligibleMask);\\n        } else {\\n            int ans = N;\\n            // traverse through all sub-masks of mask such that only k subjects are selected\\n            for(int s=eligibleMask; s>0; s=eligibleMask&(s-1)) {\\n                if(maxSub == countSetBits(s)) {\\n                    ans = min(ans, 1+solve(mask | s));\\n                }\\n            }\\n            return dp[mask] = ans;\\n        }\\n    }\\n    \\n    int minNumberOfSemesters(int n, vector<vector<int>>& dependencies, int k) {\\n        N = n;\\n        maxSub = k;\\n        memset(dp, -1, sizeof dp);\\n        for(int i=0; i<dependencies.size(); ++i) {\\n            graph[dependencies[i][0]-1].push_back(dependencies[i][1]-1);\\n        }\\n        return solve(0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 719999,
                "title": "java-dynamic-programming-inline-comments",
                "content": "The first YouTube link also goes over why Greedy + Topological Sort does not always work, although it turns out to be good enough for the test cases.\\n\\n```\\n/*\\n ** Credit 1: https://www.youtube.com/watch?v=p0wmkvWY_uE&t=767s\\n ** Credit 2: https://leetcode.com/problems/parallel-courses-ii/discuss/709382/C%2B%2B-O(3n)-bitmask-dynamic-programming-code-with-comments-and-tutorial\\n */\\n\\nclass Solution {\\n    public int minNumberOfSemesters(int n, int[][] dependencies, int k) {\\n        // step 1. save the courses we need to take as integer\\n        // e.x.) if prerequisites for course 2 are courses 0 and 3 store integer value of `1001` to prerequisites[2]\\n        int[] prerequisites = new int[n];\\n        for (int[] dependency: dependencies)\\n            prerequisites[dependency[1] - 1] |= 1 << (dependency[0] - 1);\\n\\n        // step 2. dp[courses] = what is the minimum number of days it takes to finish the course given that we have the `courses` left to take?\\n        int[] dp = new int[1 << n];\\n        Arrays.fill(dp, n + 1); // fill with the dp array with arbitrary values not possible to exceed\\n        dp[0] = 0; // no courses left to take == no more semester necessary\\n\\n        for (int i = 0; i < (1 << n); i++) {\\n            // i = courses we have taken\\n            int availableCourses = 0; // courses we can take in the semester given we took\\n            for (int course = 0; course < n; course++)\\n                if ((prerequisites[course] & i) == prerequisites[course])\\n                    // if `i` courses (the courses we already have taken) contain all prerequisites for `course`, add it to `availableCourses`\\n                    availableCourses |= 1 << course;\\n            availableCourses &= ~i; // remove the courses we have already taken\\n            for (int nextSemester = availableCourses; nextSemester > 0; nextSemester = (nextSemester - 1) & availableCourses) {\\n                // iterate throught the subsets of available courses we can take next\\n                // nextSemester = courses we choose to take next semester;\\n                if (Integer.bitCount(nextSemester) <= k) // # courses must be <= k\\n                    dp[i | nextSemester] = Math.min(dp[i | nextSemester], 1 + dp[i]);\\n            }\\n        }\\n\\n        return dp[(1 << n) - 1]; //  since the problem assumes it is possible, I am not considering a corner case where the courses are impossible to finish\\n    }\\n}\\n\\n```\\n\\nI hope this helps! :)",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\n/*\\n ** Credit 1: https://www.youtube.com/watch?v=p0wmkvWY_uE&t=767s\\n ** Credit 2: https://leetcode.com/problems/parallel-courses-ii/discuss/709382/C%2B%2B-O(3n)-bitmask-dynamic-programming-code-with-comments-and-tutorial\\n */\\n\\nclass Solution {\\n    public int minNumberOfSemesters(int n, int[][] dependencies, int k) {\\n        // step 1. save the courses we need to take as integer\\n        // e.x.) if prerequisites for course 2 are courses 0 and 3 store integer value of `1001` to prerequisites[2]\\n        int[] prerequisites = new int[n];\\n        for (int[] dependency: dependencies)\\n            prerequisites[dependency[1] - 1] |= 1 << (dependency[0] - 1);\\n\\n        // step 2. dp[courses] = what is the minimum number of days it takes to finish the course given that we have the `courses` left to take?\\n        int[] dp = new int[1 << n];\\n        Arrays.fill(dp, n + 1); // fill with the dp array with arbitrary values not possible to exceed\\n        dp[0] = 0; // no courses left to take == no more semester necessary\\n\\n        for (int i = 0; i < (1 << n); i++) {\\n            // i = courses we have taken\\n            int availableCourses = 0; // courses we can take in the semester given we took\\n            for (int course = 0; course < n; course++)\\n                if ((prerequisites[course] & i) == prerequisites[course])\\n                    // if `i` courses (the courses we already have taken) contain all prerequisites for `course`, add it to `availableCourses`\\n                    availableCourses |= 1 << course;\\n            availableCourses &= ~i; // remove the courses we have already taken\\n            for (int nextSemester = availableCourses; nextSemester > 0; nextSemester = (nextSemester - 1) & availableCourses) {\\n                // iterate throught the subsets of available courses we can take next\\n                // nextSemester = courses we choose to take next semester;\\n                if (Integer.bitCount(nextSemester) <= k) // # courses must be <= k\\n                    dp[i | nextSemester] = Math.min(dp[i | nextSemester], 1 + dp[i]);\\n            }\\n        }\\n\\n        return dp[(1 << n) - 1]; //  since the problem assumes it is possible, I am not considering a corner case where the courses are impossible to finish\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 709481,
                "title": "graph-iterative-priority-queue-java",
                "content": "**Intuition** \\nThis is like Graph where one have to take a given course only if it has no prerequisite or all of his prerequisite are taken.\\nEvery vertex have below properties.\\n1. in degree\\n2. out degree\\n\\nAlgo:\\n1. Prepare vertex and its in,out degree based on dependencies\\n2. Every ZERO IN DEGREE VERTEX are eligible to be picked considering below condition\\n\\t2.1 priority based on out degree (suppose we have more than 1 vertex with ZERO IN DEGREE then we will choose those vertex which have more OUT DEGREE below example will make it clear)\\n\\t2.2 within subject limit i.e K\\n3. We will iterate step 2 till we have no ZERO IN DEGREE VERTEX  and on every iteration we will  increment\\n    semester count.\\n\\t\\nN=8, dependencies = [1,6],[2,7],[2,5],[8,7],[3,4], k=3\\nSemester=0\\n![image](https://assets.leetcode.com/users/images/9d8f8ad1-ccb5-48f0-afdd-373a03eeacae_1593326691.8914566.png)\\n\\nNow ZERO IN DEGREE Vertex are 1,2,3,8  and all have same OUT DEGREE so we can choose any 3, \\nsuppose we choose 1,2,3 then udpate table will be like this\\nSemester=1\\n![image](https://assets.leetcode.com/users/images/3ac01707-b005-4309-b93b-0d0db4d4bd7b_1593327062.4623399.png)\\n\\nNow ZERO IN DEGREE Vertex are 8,4,5,6 based on priority (Vertex 8 have 1 out degree hence highest priority)\\nNow we can choose 8,4,5\\nSemester=2  and updated table is shown below\\n![image](https://assets.leetcode.com/users/images/e36b21ae-2df9-472d-9891-de2c912633f5_1593327281.221788.png)\\nNow ZERO IN DEGREE Vertex are 6,7 with k=3 we can choose both of these\\nSemester=3\\n\\n```\\npublic int minNumberOfSemesters(int n, int[][] dependencies, int k) {\\n  // simple array should be enough here we are not using 0th index\\n\\tVertx[] vertex = new Vertx[n + 1];\\n\\tfor (int i = 1; i < vertex.length; i++) {\\n\\t\\tvertex[i] = new Vertx(i);\\n\\t}\\n\\t// preparing vertex and its in,out degree \\n\\tfor (int[] e : dependencies) {\\n\\t\\tvertex[e[0]].out++;\\n\\t\\tvertex[e[0]].outList.add(e[1]);\\n\\t\\tvertex[e[1]].in++;\\n\\t}\\n\\tint sem = 0;\\n\\tList<Vertx> temp = null;\\n\\twhile ((temp = getZeroInDegreeBasedOnPriority(vertex, k)) != null && temp.size() > 0) {\\n\\t\\tfor (Vertx t : temp) {\\n\\t\\t\\tSystem.out.println(t);\\n\\t\\t\\t// we need to decrease the in degree of out\\n\\t\\t\\tfor (int ea : t.outList) {\\n\\t\\t\\t\\tvertex[ea].in--;\\n\\t\\t\\t}\\n\\n\\t\\t\\tt.in = -1;\\n\\t\\t}\\n\\t\\tsem++;\\n\\t}\\n\\treturn sem;\\n}\\n\\nList<Vertx> getZeroInDegreeBasedOnPriority(Vertx[] vertex, int k){\\n\\tList<Vertx> r = new ArrayList<>();\\n\\tPriorityQueue<Vertx> pq = new PriorityQueue<>((Vertx a, Vertx b)->  {return Integer.compare(b.out,a.out);});\\n\\tfor (int i = 1; i < vertex.length ; i++) {\\n\\t\\tif(vertex[i].in == 0) {\\n\\t\\t\\tpq.add(vertex[i]);\\n\\t\\t}\\n\\t}\\n\\t\\n\\twhile(pq.size()!=0 && k-- > 0) {\\n\\t\\tr.add(pq.remove());\\n\\t}\\n\\treturn r;\\n}\\n\\nstatic class Vertx{\\n\\tint index;\\n\\tint in;\\n\\tint out;\\n\\tList<Integer> outList = new ArrayList<>();\\n\\tpublic Vertx(int index) {\\n\\t\\tthis.index = index;\\n\\t}\\n\\t@Override\\n\\tpublic String toString() {\\n\\t\\treturn \"Vertx [index=\" + index + \", in=\" + in + \", out=\" + out + \", outList=\" + outList + \"]\";\\n\\t}\\n}\\n\\n```\\n\\n\\n\\n\\n \\n\\n\\n",
                "solutionTags": [],
                "code": "```\\npublic int minNumberOfSemesters(int n, int[][] dependencies, int k) {\\n  // simple array should be enough here we are not using 0th index\\n\\tVertx[] vertex = new Vertx[n + 1];\\n\\tfor (int i = 1; i < vertex.length; i++) {\\n\\t\\tvertex[i] = new Vertx(i);\\n\\t}\\n\\t// preparing vertex and its in,out degree \\n\\tfor (int[] e : dependencies) {\\n\\t\\tvertex[e[0]].out++;\\n\\t\\tvertex[e[0]].outList.add(e[1]);\\n\\t\\tvertex[e[1]].in++;\\n\\t}\\n\\tint sem = 0;\\n\\tList<Vertx> temp = null;\\n\\twhile ((temp = getZeroInDegreeBasedOnPriority(vertex, k)) != null && temp.size() > 0) {\\n\\t\\tfor (Vertx t : temp) {\\n\\t\\t\\tSystem.out.println(t);\\n\\t\\t\\t// we need to decrease the in degree of out\\n\\t\\t\\tfor (int ea : t.outList) {\\n\\t\\t\\t\\tvertex[ea].in--;\\n\\t\\t\\t}\\n\\n\\t\\t\\tt.in = -1;\\n\\t\\t}\\n\\t\\tsem++;\\n\\t}\\n\\treturn sem;\\n}\\n\\nList<Vertx> getZeroInDegreeBasedOnPriority(Vertx[] vertex, int k){\\n\\tList<Vertx> r = new ArrayList<>();\\n\\tPriorityQueue<Vertx> pq = new PriorityQueue<>((Vertx a, Vertx b)->  {return Integer.compare(b.out,a.out);});\\n\\tfor (int i = 1; i < vertex.length ; i++) {\\n\\t\\tif(vertex[i].in == 0) {\\n\\t\\t\\tpq.add(vertex[i]);\\n\\t\\t}\\n\\t}\\n\\t\\n\\twhile(pq.size()!=0 && k-- > 0) {\\n\\t\\tr.add(pq.remove());\\n\\t}\\n\\treturn r;\\n}\\n\\nstatic class Vertx{\\n\\tint index;\\n\\tint in;\\n\\tint out;\\n\\tList<Integer> outList = new ArrayList<>();\\n\\tpublic Vertx(int index) {\\n\\t\\tthis.index = index;\\n\\t}\\n\\t@Override\\n\\tpublic String toString() {\\n\\t\\treturn \"Vertx [index=\" + index + \", in=\" + in + \", out=\" + out + \", outList=\" + outList + \"]\";\\n\\t}\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2381477,
                "title": "faster-than-100-00-of-python3",
                "content": "![image](https://assets.leetcode.com/users/images/e24fc96e-82bf-45b4-8ea9-aa824f35e354_1659678036.320979.png)\\n\\n```\\nclass Solution:\\n    def minNumberOfSemesters(self, n: int, relations: List[List[int]], k: int) -> int:\\n        graph = [0] * n\\n        out_degree = [0] * n\\n        # -1 to fix 1-based indexing offset from prompt.\\n        for pre_req, course in relations:\\n            graph[course-1] += 1 << (pre_req-1)\\n            out_degree[pre_req-1] += 1\\n        # Just converts course to its shifted value\\n        c2shift = [1<<course for course in range(n)]\\n        start = 0\\n        goal = 2**n-1  # will eq course_total once all have been taken.\\n        queue = collections.deque([(start,0)])\\n        seen = [0] * (2 ** n)\\n\\n        # Similar to Bellman-Ford\\n        while queue:\\n            # course_total is state. Each bit representing a taken course.\\n            course_total, steps = queue.popleft()\\n            available = []\\n            for course_num in range(n):\\n                if (course_total & graph[course_num] == graph[course_num]) \\\\\\n                            and (course_total & c2shift[course_num] == 0):\\n                    available.append(course_num)\\n\\n            # pre_req courses can unlock others.\\n            pre_reqs = [c2shift[course_num] for course_num in available if out_degree[course_num]]\\n            leaves = [c2shift[course_num] for course_num in available if out_degree[course_num] == 0] \\n            \\n            # We only include leaf courses when we have extra space\\n            if len(pre_reqs) <= k:\\n                course_total += sum(pre_reqs) + sum(leaves[:k-len(pre_reqs)])\\n                if course_total == goal:\\n                    return steps + 1\\n                if not seen[course_total]:\\n                    queue.append((course_total,steps+1))\\n                    seen[course_total] = 1\\n            else:\\n                # Trying every combination of the pre_reqs.\\n                # comb is required here because we can\\'t simply take them all (len(pre_reqs) > k)\\n                for batch in itertools.combinations(pre_reqs, k):\\n                    diff = sum(batch)\\n                    t = course_total + diff\\n                    if t == goal:\\n                        return steps + 1\\n                    if not seen[t]:\\n                        queue.append((t, steps+1))\\n                        seen[t] = 1![Uploading file...]()\\n\\n```\\n**success details:**\\n![Uploading file...]()\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumberOfSemesters(self, n: int, relations: List[List[int]], k: int) -> int:\\n        graph = [0] * n\\n        out_degree = [0] * n\\n        # -1 to fix 1-based indexing offset from prompt.\\n        for pre_req, course in relations:\\n            graph[course-1] += 1 << (pre_req-1)\\n            out_degree[pre_req-1] += 1\\n        # Just converts course to its shifted value\\n        c2shift = [1<<course for course in range(n)]\\n        start = 0\\n        goal = 2**n-1  # will eq course_total once all have been taken.\\n        queue = collections.deque([(start,0)])\\n        seen = [0] * (2 ** n)\\n\\n        # Similar to Bellman-Ford\\n        while queue:\\n            # course_total is state. Each bit representing a taken course.\\n            course_total, steps = queue.popleft()\\n            available = []\\n            for course_num in range(n):\\n                if (course_total & graph[course_num] == graph[course_num]) \\\\\\n                            and (course_total & c2shift[course_num] == 0):\\n                    available.append(course_num)\\n\\n            # pre_req courses can unlock others.\\n            pre_reqs = [c2shift[course_num] for course_num in available if out_degree[course_num]]\\n            leaves = [c2shift[course_num] for course_num in available if out_degree[course_num] == 0] \\n            \\n            # We only include leaf courses when we have extra space\\n            if len(pre_reqs) <= k:\\n                course_total += sum(pre_reqs) + sum(leaves[:k-len(pre_reqs)])\\n                if course_total == goal:\\n                    return steps + 1\\n                if not seen[course_total]:\\n                    queue.append((course_total,steps+1))\\n                    seen[course_total] = 1\\n            else:\\n                # Trying every combination of the pre_reqs.\\n                # comb is required here because we can\\'t simply take them all (len(pre_reqs) > k)\\n                for batch in itertools.combinations(pre_reqs, k):\\n                    diff = sum(batch)\\n                    t = course_total + diff\\n                    if t == goal:\\n                        return steps + 1\\n                    if not seen[t]:\\n                        queue.append((t, steps+1))\\n                        seen[t] = 1![Uploading file...]()\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1930003,
                "title": "c-dp-with-bitmask-with-detailed-explanation",
                "content": "```\\n\\n\\n\\tthis is a really good problem !!\\n\\n\\tin one semester we can do at most k courses, and for each course we have picked, we should\\n\\thave completed its prerequisites in the previous semesters\\n\\tso we need to find the minimum semesters in which we can complete all the courses\\n\\n\\tcurrently, we can chose those courses whose indegree is 0 (because its prerequisites have been completed)\\n\\n\\tso this might seem like topological sorting\\n\\n\\tbut it is not the case\\n\\n\\tcurrently in the queue, lets say have M courses (M > k), and the number of semesters required would actually depend\\n\\tupon which k courses we chose to do in this semester, so we need dp for this\\n\\tour dp state will be a single bitMask, which would tell us which all courses have been taken till now\\n\\n\\tfirst job is to identify which all courses are available to us\\n\\n\\tA course i will be available only if :\\n\\t\\t-> the i\\'th bit in the bitMask, is 0 (means this course is not taken before)\\n\\t\\t-> all the prerequisites of this course are done\\n\\n\\thow do we check for the second condition ?\\n\\ta course\\'s prerequisites are complete only if its indegree is 0 (indegree will be calculated, ignoring the\\n\\tedges from those nodes which are already taken). means while calculating the indegree array, we will only\\n\\tconsider those nodes which have not been taken in any of the previous semesters (means i\\'th bit in the bitMask is 0)\\n\\n\\tso now our job is to figure out which courses are available to us (we again make some kind of bitMask for this \\uD83D\\uDE05)\\n\\n\\tfor each node (or course) which has not been taken, visit all its neighbours and do indegree[nbr]++;\\n\\tso all those untouched nodes whose indegree is 0, can be taken now\\n\\n\\tin case the number of available courses are less than k, we take all of them\\n\\t(it is quite obvious, there are some courses all of which we are allowed to take this semester, it would really not make sense not\\n\\tto take all of them)\\n\\n\\tin case the number of available courses, (call it M) are more than k, there are  options McK options and we need to consider all of them\\n\\twe generate all the submasks, and take those who have k set bits\\n\\n\\n\\n\\n```\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint N , K;\\n\\t\\t// vector<int> graph[15];\\n\\t\\tvector<vector<int>> graph;\\n\\t\\tint indegree[15];\\n\\t\\tint finalBitMask;\\n\\t\\tint dp[(1 << 15) + 1];\\n\\n\\t\\tint solve(int bitMask) {\\n\\t\\t\\t// cout << \"something here\" ;\\n\\t\\t\\tif (bitMask == finalBitMask) return 0;\\n\\t\\t\\tif (dp[bitMask] != -1) return dp[bitMask];\\n\\n\\t\\t\\tmemset(indegree, 0, sizeof(indegree));\\n\\n\\t\\t\\tfor (int i = 0; i < N; i++) {\\n\\n\\t\\t\\t// if that guy is not taken till now, then this will contribute to the indegree\\n\\t\\t\\tif (!(bitMask & (1 << i))) {\\n\\t\\t\\t\\tfor (int v : graph[i]) {\\n\\t\\t\\t\\t\\tindegree[v]++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tint availMask = 0;\\n\\n\\t\\tfor (int i = 0; i < N; i++) {\\n\\t\\t\\tif (!(bitMask & (1 << i)) && indegree[i] == 0) availMask |= (1 << i);\\n\\t\\t}\\n\\n\\n\\t\\t// before doing this check for the case where number of available courses are  <= K\\n\\t\\tint curAns = N + 1;\\n\\t\\tif (__builtin_popcount(availMask) < K) {\\n\\t\\t\\tcurAns = min(curAns, 1 + solve(bitMask | availMask));\\n\\t\\t}\\n\\n\\t\\t// else if the number of available courses are greater than k, do this\\n\\t\\telse {\\n\\n\\n\\t\\t\\t// generating the submasks of a given bitMask \\n\\t\\t\\tfor (int subMask = availMask; subMask > 0; subMask = (subMask - 1) & availMask) {\\n\\t\\t\\t\\tif (__builtin_popcount(subMask) == K) {\\n\\t\\t\\t\\t\\tcurAns = min(curAns, 1 + solve(bitMask | subMask));\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn dp[bitMask] = curAns;\\n\\n\\n\\t}\\n\\n\\n\\n\\tint minNumberOfSemesters(int n, vector<vector<int>>& relations, int k) {\\n\\t\\tN = n;\\n\\t\\tK = k;\\n\\t\\tgraph.resize(N);\\n\\n\\t\\tfor (auto &e : relations) {\\n\\t\\t\\te[0]--;\\n\\t\\t\\te[1]--;\\n\\t\\t\\tgraph[e[0]].push_back(e[1]);\\n\\t\\t}\\n\\n\\t\\tmemset(dp, -1, sizeof(dp));\\n\\t\\tfinalBitMask = ((1 << N) - 1);\\n\\t\\treturn solve(0);\\n\\n\\t\\t}\\n\\t};\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\n\\tthis is a really good problem !!\\n\\n\\tin one semester we can do at most k courses, and for each course we have picked, we should\\n\\thave completed its prerequisites in the previous semesters\\n\\tso we need to find the minimum semesters in which we can complete all the courses\\n\\n\\tcurrently, we can chose those courses whose indegree is 0 (because its prerequisites have been completed)\\n\\n\\tso this might seem like topological sorting\\n\\n\\tbut it is not the case\\n\\n\\tcurrently in the queue, lets say have M courses (M > k), and the number of semesters required would actually depend\\n\\tupon which k courses we chose to do in this semester, so we need dp for this\\n\\tour dp state will be a single bitMask, which would tell us which all courses have been taken till now\\n\\n\\tfirst job is to identify which all courses are available to us\\n\\n\\tA course i will be available only if :\\n\\t\\t-> the i\\'th bit in the bitMask, is 0 (means this course is not taken before)\\n\\t\\t-> all the prerequisites of this course are done\\n\\n\\thow do we check for the second condition ?\\n\\ta course\\'s prerequisites are complete only if its indegree is 0 (indegree will be calculated, ignoring the\\n\\tedges from those nodes which are already taken). means while calculating the indegree array, we will only\\n\\tconsider those nodes which have not been taken in any of the previous semesters (means i\\'th bit in the bitMask is 0)\\n\\n\\tso now our job is to figure out which courses are available to us (we again make some kind of bitMask for this \\uD83D\\uDE05)\\n\\n\\tfor each node (or course) which has not been taken, visit all its neighbours and do indegree[nbr]++;\\n\\tso all those untouched nodes whose indegree is 0, can be taken now\\n\\n\\tin case the number of available courses are less than k, we take all of them\\n\\t(it is quite obvious, there are some courses all of which we are allowed to take this semester, it would really not make sense not\\n\\tto take all of them)\\n\\n\\tin case the number of available courses, (call it M) are more than k, there are  options McK options and we need to consider all of them\\n\\twe generate all the submasks, and take those who have k set bits\\n\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1807172,
                "title": "java-o-n-2-n-bitmask-solution",
                "content": "The idea is to use mask for finished courses.\\nFor example, mask=0110 means we finished second and third courses.\\nTo find the minimum number of semesters that we need to finish courses in the current mask, we can take each course in the current mask and check whether we can finish this course from the mask without it.\\nExample from the description:\\n**Input**: n = 4, dependencies = [[2,1],[3,1],[1,4]], k = 2\\nFor mask 0111:\\n* take 1 on the 3rd position (from right), previous mask is 0011 - this mask is unreachable, so continue\\n* take 1 on the 2nd position, previous mask is 0101 - this mask is unreachable as well, continue\\n* take 1 on the 1st position, previous mask is 0110 - this mask is reachable with 1 semester, but we cannot add another course to the same semester. Check if we can add the course #1 - it depends on couses #2 and #3, so we can add #1 course to the next semester\\n\\nTo make dynamic programming calculations, we need to maintain next variables:\\n* **courseDepMasks** - mask of courses that should be finished before the current one (from the example above: courseDepMasks[0]=0110, courseDepMasks[1]=courseDepMasks[2]=0000, courseDepMasks[3]=0001)\\n* **pastSemesters** - number of semesters past for the current mask\\n* **leftCourses** - number of courses we can take in the current semester for the current mask\\n* **lastSemesterCourses** - mask of courses have been taken in the previous semester (we need this if we want to add a new course to the current semester)\\n\\nAlgorythm:\\n1. Take every mask from 1 to (2^n-1)\\n2. Take each 1s in the mask\\n3. Check if we can add the corresponding course to the current semester (all dependency courses were taken in the previous semesters and leftCourses > 0)\\n4. Check if we can add the corresponging to the next semester (all dependency courses were taken in the current semester)\\n5. If the current solution is better then existing, update the *pastSemesters*, *leftCourses* and *lastSemesterCourses* variables (function relax())\\n\\n**Time complexity**: O(n * 2^n)\\nwe have one cycle with 2^n iterations and another internal cycle with n iterations. Cycle to calculate courseDepMasks is just O(n) and can be omitted\\n\\n**Space complexity**: O(2^n)\\nwe have 3 variables with 2^n size\\n\\n```\\nclass Solution {\\n    public int minNumberOfSemesters(int n, int[][] relations, int k) {\\n        int[] courseDepMasks = new int[n];\\n        for (int[] rel : relations) {\\n            courseDepMasks[rel[1] - 1] |= (1 << (rel[0] - 1));\\n        }\\n        \\n        int maxMask = 1 << n;\\n        int[] pastSemesters = new int[maxMask];\\n        Arrays.fill(pastSemesters, n);\\n        pastSemesters[0] = 0;\\n        \\n        int[] leftCourses = new int[maxMask];\\n        Arrays.fill(leftCourses, 0);\\n        leftCourses[0] = k;\\n        \\n        int[] lastSemesterCourses = new int[maxMask];\\n        \\n        for (int mask = 1; mask < maxMask; mask++) {\\n            for (int course = 0; course < n; course++) {\\n                if ((mask & (1 << course)) == 0) {\\n                    continue;\\n                }\\n                \\n                int prevMask = mask ^ (1 << course);\\n                \\n                boolean canDoInThisSemester = (courseDepMasks[course] & lastSemesterCourses[prevMask]) == courseDepMasks[course]\\n                    && leftCourses[prevMask] > 0;\\n                boolean canDoInNextSemester = (courseDepMasks[course] & prevMask) == courseDepMasks[course];\\n                \\n                if (canDoInThisSemester) {\\n                    relax(\\n                        pastSemesters,\\n                        leftCourses,\\n                        lastSemesterCourses,\\n                        mask,\\n                        pastSemesters[prevMask],\\n                        leftCourses[prevMask] - 1,\\n                        lastSemesterCourses[prevMask]\\n                    );\\n                } else if (canDoInNextSemester) {\\n                    relax(\\n                        pastSemesters,\\n                        leftCourses,\\n                        lastSemesterCourses,\\n                        mask,\\n                        pastSemesters[prevMask] + 1,\\n                        k - 1,\\n                        prevMask\\n                    );\\n                }\\n            }\\n        }\\n        \\n        int finalMask = (1 << n) - 1;\\n        return pastSemesters[finalMask] + ((leftCourses[finalMask] < k) ? 1 : 0);\\n    }\\n    \\n    private void relax(\\n        int[] pastSemesters,\\n        int[] leftCourses,\\n        int[] lastSemesterCourses,\\n        int mask,\\n        int pastSemesterCnt,\\n        int leftCoursesCnt,\\n        int lastSemesterMask\\n    ) {\\n        if (pastSemesters[mask] < pastSemesterCnt) {\\n            return;\\n        }\\n        if (pastSemesters[mask] == pastSemesterCnt && leftCourses[mask] >= leftCoursesCnt) {\\n            return;\\n        }\\n        \\n        pastSemesters[mask] = pastSemesterCnt;\\n        leftCourses[mask] = leftCoursesCnt;\\n        lastSemesterCourses[mask] = lastSemesterMask;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumberOfSemesters(int n, int[][] relations, int k) {\\n        int[] courseDepMasks = new int[n];\\n        for (int[] rel : relations) {\\n            courseDepMasks[rel[1] - 1] |= (1 << (rel[0] - 1));\\n        }\\n        \\n        int maxMask = 1 << n;\\n        int[] pastSemesters = new int[maxMask];\\n        Arrays.fill(pastSemesters, n);\\n        pastSemesters[0] = 0;\\n        \\n        int[] leftCourses = new int[maxMask];\\n        Arrays.fill(leftCourses, 0);\\n        leftCourses[0] = k;\\n        \\n        int[] lastSemesterCourses = new int[maxMask];\\n        \\n        for (int mask = 1; mask < maxMask; mask++) {\\n            for (int course = 0; course < n; course++) {\\n                if ((mask & (1 << course)) == 0) {\\n                    continue;\\n                }\\n                \\n                int prevMask = mask ^ (1 << course);\\n                \\n                boolean canDoInThisSemester = (courseDepMasks[course] & lastSemesterCourses[prevMask]) == courseDepMasks[course]\\n                    && leftCourses[prevMask] > 0;\\n                boolean canDoInNextSemester = (courseDepMasks[course] & prevMask) == courseDepMasks[course];\\n                \\n                if (canDoInThisSemester) {\\n                    relax(\\n                        pastSemesters,\\n                        leftCourses,\\n                        lastSemesterCourses,\\n                        mask,\\n                        pastSemesters[prevMask],\\n                        leftCourses[prevMask] - 1,\\n                        lastSemesterCourses[prevMask]\\n                    );\\n                } else if (canDoInNextSemester) {\\n                    relax(\\n                        pastSemesters,\\n                        leftCourses,\\n                        lastSemesterCourses,\\n                        mask,\\n                        pastSemesters[prevMask] + 1,\\n                        k - 1,\\n                        prevMask\\n                    );\\n                }\\n            }\\n        }\\n        \\n        int finalMask = (1 << n) - 1;\\n        return pastSemesters[finalMask] + ((leftCourses[finalMask] < k) ? 1 : 0);\\n    }\\n    \\n    private void relax(\\n        int[] pastSemesters,\\n        int[] leftCourses,\\n        int[] lastSemesterCourses,\\n        int mask,\\n        int pastSemesterCnt,\\n        int leftCoursesCnt,\\n        int lastSemesterMask\\n    ) {\\n        if (pastSemesters[mask] < pastSemesterCnt) {\\n            return;\\n        }\\n        if (pastSemesters[mask] == pastSemesterCnt && leftCourses[mask] >= leftCoursesCnt) {\\n            return;\\n        }\\n        \\n        pastSemesters[mask] = pastSemesterCnt;\\n        leftCourses[mask] = leftCoursesCnt;\\n        lastSemesterCourses[mask] = lastSemesterMask;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1681479,
                "title": "top-down-hashmap-based-solution-no-bitmasking",
                "content": "```\\nclass Solution {\\n    public int minNumberOfSemesters(int n, int[][] relations, int k) {\\n        \\n        if (relations.length == 0) {\\n            int temp = n / k;\\n            \\n            if (n % k != 0) {\\n                temp++;\\n            }\\n            return temp;\\n        }\\n        Map<Integer, List<Integer>> adjMap = new HashMap<>();\\n        int[] incoming = new int[n + 1];\\n        incoming[0] = -1;\\n        //Initializing Adjacency Map and Incrementing incoming edges\\n        for (int[] relation : relations) {\\n            List<Integer> list = adjMap.getOrDefault(relation[0], new ArrayList<>());\\n            list.add(relation[1]);\\n            adjMap.put(relation[0], list);\\n            incoming[relation[1]]++;\\n        }\\n\\t\\t//Map Based Memo\\n        Map<String, Integer> memo = new HashMap<>();\\n        return recur(adjMap, incoming, k, memo);\\n    }\\n    \\n    public int recur(Map<Integer, List<Integer>> adjMap, int[] incoming, int k, Map<String, Integer> memo) {\\n        boolean returnFlag = true;\\n        //Checking to see if no Incoming edges are greater than or equalzero. \\n\\t\\t//In that case everything has been processed so set return flag to return\\n        for (int in : incoming) {\\n            \\n            if (in >= 0) {\\n                returnFlag = false;\\n                break;\\n            }\\n        }\\n        \\n        if (returnFlag) {\\n            return 0;\\n        }\\n\\t\\t//This represent the current state of the Recursion which will be used as key in memo.\\n        String key = Arrays.toString(incoming);\\n        \\n        if (memo.containsKey(key)) {\\n            return memo.get(key);\\n        }\\n        List<Integer> list = new ArrayList<>();\\n        //Checking all the Courses that can be processd or taken in this semester\\n        for (int i = 1; i < incoming.length; i++) {\\n            \\n            if (incoming[i] == 0) {\\n                list.add(i);\\n            }\\n        }\\n        // If the courses can be taken in this current semester. Take all of them\\n        if (list.size() <= k) {\\n\\t\\t\\t//getting new incoming edges as all the courses are taken\\n            int [] newIncoming = getIncoming(adjMap, list, incoming);\\n            int temp = 1 + recur(adjMap, newIncoming, k, memo);\\n            memo.put(key, temp);\\n            return temp;\\n        }\\n\\t\\t//If the courses are greater than the permitted limit get all the combinations of size k which are possible\\n        List<List<Integer>> combinations = new ArrayList<>();\\n        ArrayList<Integer> p = new ArrayList<>();\\n        getCombinations(list, combinations, p, 0, 0, k);\\n        int ans = Integer.MAX_VALUE;\\n        //For all the combinations get new incomings and process\\n        for (List<Integer> combination : combinations) {\\n            int [] newIncoming = getIncoming(adjMap, combination, incoming);\\n            ans = Math.min(ans, 1 + recur(adjMap, newIncoming, k, memo));\\n        }\\n        memo.put(key, ans);\\n        return ans;\\n    }\\n    //Generating all the combinations of permitted length\\n    private void getCombinations(List<Integer> list, List<List<Integer>> combinations, ArrayList<Integer> p, \\n                                int index, int listIndex, int k) {\\n        \\n        if (p.size() == k) {\\n            combinations.add((ArrayList<Integer>)p.clone());\\n            return;\\n        }\\n        \\n        if (index == list.size()) {\\n            return;\\n        }\\n        p.add(list.get(index));\\n        getCombinations(list, combinations, p, index + 1, listIndex, k);\\n        p.remove(p.size() - 1);\\n        getCombinations(list, combinations, p, index + 1, listIndex, k);\\n    }\\n    \\n    private int[] getIncoming(Map<Integer, List<Integer>> adjMap, List<Integer> list, int[] incoming) {\\n        int[] in = incoming.clone();\\n        \\n        for (int elem : list) {\\n            in[elem]--; \\n            List<Integer> adj = adjMap.getOrDefault(elem, new ArrayList<>());\\n            \\n            for (int next : adj) {\\n                in[next]--;\\n            }\\n        }\\n        return in;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumberOfSemesters(int n, int[][] relations, int k) {\\n        \\n        if (relations.length == 0) {\\n            int temp = n / k;\\n            \\n            if (n % k != 0) {\\n                temp++;\\n            }\\n            return temp;\\n        }\\n        Map<Integer, List<Integer>> adjMap = new HashMap<>();\\n        int[] incoming = new int[n + 1];\\n        incoming[0] = -1;\\n        //Initializing Adjacency Map and Incrementing incoming edges\\n        for (int[] relation : relations) {\\n            List<Integer> list = adjMap.getOrDefault(relation[0], new ArrayList<>());\\n            list.add(relation[1]);\\n            adjMap.put(relation[0], list);\\n            incoming[relation[1]]++;\\n        }\\n\\t\\t//Map Based Memo\\n        Map<String, Integer> memo = new HashMap<>();\\n        return recur(adjMap, incoming, k, memo);\\n    }\\n    \\n    public int recur(Map<Integer, List<Integer>> adjMap, int[] incoming, int k, Map<String, Integer> memo) {\\n        boolean returnFlag = true;\\n        //Checking to see if no Incoming edges are greater than or equalzero. \\n\\t\\t//In that case everything has been processed so set return flag to return\\n        for (int in : incoming) {\\n            \\n            if (in >= 0) {\\n                returnFlag = false;\\n                break;\\n            }\\n        }\\n        \\n        if (returnFlag) {\\n            return 0;\\n        }\\n\\t\\t//This represent the current state of the Recursion which will be used as key in memo.\\n        String key = Arrays.toString(incoming);\\n        \\n        if (memo.containsKey(key)) {\\n            return memo.get(key);\\n        }\\n        List<Integer> list = new ArrayList<>();\\n        //Checking all the Courses that can be processd or taken in this semester\\n        for (int i = 1; i < incoming.length; i++) {\\n            \\n            if (incoming[i] == 0) {\\n                list.add(i);\\n            }\\n        }\\n        // If the courses can be taken in this current semester. Take all of them\\n        if (list.size() <= k) {\\n\\t\\t\\t//getting new incoming edges as all the courses are taken\\n            int [] newIncoming = getIncoming(adjMap, list, incoming);\\n            int temp = 1 + recur(adjMap, newIncoming, k, memo);\\n            memo.put(key, temp);\\n            return temp;\\n        }\\n\\t\\t//If the courses are greater than the permitted limit get all the combinations of size k which are possible\\n        List<List<Integer>> combinations = new ArrayList<>();\\n        ArrayList<Integer> p = new ArrayList<>();\\n        getCombinations(list, combinations, p, 0, 0, k);\\n        int ans = Integer.MAX_VALUE;\\n        //For all the combinations get new incomings and process\\n        for (List<Integer> combination : combinations) {\\n            int [] newIncoming = getIncoming(adjMap, combination, incoming);\\n            ans = Math.min(ans, 1 + recur(adjMap, newIncoming, k, memo));\\n        }\\n        memo.put(key, ans);\\n        return ans;\\n    }\\n    //Generating all the combinations of permitted length\\n    private void getCombinations(List<Integer> list, List<List<Integer>> combinations, ArrayList<Integer> p, \\n                                int index, int listIndex, int k) {\\n        \\n        if (p.size() == k) {\\n            combinations.add((ArrayList<Integer>)p.clone());\\n            return;\\n        }\\n        \\n        if (index == list.size()) {\\n            return;\\n        }\\n        p.add(list.get(index));\\n        getCombinations(list, combinations, p, index + 1, listIndex, k);\\n        p.remove(p.size() - 1);\\n        getCombinations(list, combinations, p, index + 1, listIndex, k);\\n    }\\n    \\n    private int[] getIncoming(Map<Integer, List<Integer>> adjMap, List<Integer> list, int[] incoming) {\\n        int[] in = incoming.clone();\\n        \\n        for (int elem : list) {\\n            in[elem]--; \\n            List<Integer> adj = adjMap.getOrDefault(elem, new ArrayList<>());\\n            \\n            for (int next : adj) {\\n                in[next]--;\\n            }\\n        }\\n        return in;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1111255,
                "title": "python3-dp",
                "content": "\\n```\\nclass Solution:\\n    def minNumberOfSemesters(self, n: int, dependencies: List[List[int]], k: int) -> int:\\n        pre = [0]*n # prerequisites \\n        for u, v in dependencies: \\n            pre[v-1] |= 1 << (u-1) \\n            \\n        @cache\\n        def fn(mask): \\n            \"\"\"Return min semesters to take remaining courses.\"\"\"\\n            if mask == (1 << n) - 1: return 0 # all courses taken \\n            can = [] # available courses \\n            for i in range(n): \\n                if not mask & 1 << i and mask & pre[i] == pre[i]: \\n                    can.append(i)\\n            \\n            ans = inf\\n            for courses in combinations(can, min(k, len(can))): \\n                temp = mask | reduce(lambda x, y: x | 1 << y, courses, 0)\\n                ans = min(ans, 1 + fn(temp))\\n            return ans \\n        \\n        return fn(0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumberOfSemesters(self, n: int, dependencies: List[List[int]], k: int) -> int:\\n        pre = [0]*n # prerequisites \\n        for u, v in dependencies: \\n            pre[v-1] |= 1 << (u-1) \\n            \\n        @cache\\n        def fn(mask): \\n            \"\"\"Return min semesters to take remaining courses.\"\"\"\\n            if mask == (1 << n) - 1: return 0 # all courses taken \\n            can = [] # available courses \\n            for i in range(n): \\n                if not mask & 1 << i and mask & pre[i] == pre[i]: \\n                    can.append(i)\\n            \\n            ans = inf\\n            for courses in combinations(can, min(k, len(can))): \\n                temp = mask | reduce(lambda x, y: x | 1 << y, courses, 0)\\n                ans = min(ans, 1 + fn(temp))\\n            return ans \\n        \\n        return fn(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 985064,
                "title": "python-3-24ms-99-30-bfs-optimizations",
                "content": "First of all, here is an unoptimized BFS with bitmasks (144ms, 93.01%):\\n\\n```\\n    def minNumberOfSemesters(self, n: int, dependencies: List[List[int]], k: int) -> int:\\n        G = [0] * n\\n        for x, y in dependencies:\\n            G[y-1] += 1 << (x-1) \\n\\t\\t\\t# node in dependencies are 1-indexed, everything below will be 0-indexed.\\n\\t\\t\\t# G[x] = 0b10001 means the prerequisite of x is 0 and 4 (0th and 4th bit set.)\\n        P2 = [1<<y for y in range(n)]\\n        start = 0\\n        goal = 2**n-1\\n        d = collections.deque([(start,0)])\\n        seen = [0] * (2 ** n)\\n        while d:\\n            s, steps = d.popleft()\\n            available = [P2[y] for y in range(n) if (s & G[y] == G[y]) and (s & P2[y] == 0)]\\n\\t\\t\\t# (s & G[y] == G[y]) means all prerequisite has been taken, \\n\\t\\t\\t# (s & P2[y] == 0) means y itself has not been taken.\\n            if len(available) <= k:\\n\\t\\t\\t    # only \\u2264 k courses are available, take all of them.\\n                s += sum(available)\\n                if s == goal: return steps + 1\\n                if not seen[s]:\\n                    d.append((s,steps+1))\\n\\t\\t\\t\\t\\tseen[s] = 1\\n            else:\\n\\t\\t\\t    # iterate through possible combinations\\n                for batch in itertools.combinations(available, k):\\n                    diff = sum(batch)\\n                    t = s + diff\\n                    if t == goal: return steps + 1\\n                    if not seen[t]:\\n                        d.append((t, steps+1))\\n                        seen[t] = 1\\n```\\n\\nThis is a bit unsatisfactory since we are doing BFS on a graph with a LOT of edges. For example if 15 courses are available, and we are allow to take 6 course each semester, then after visiting 1 node, we will add `math.comb(15,6) = 5005` cases to the queue, which is huge. \\n\\nOne observation is that, if a course doesn\\'t \"unlock\" any other courses, then it doesn\\'t matter when we take it. We only need to care about those courses with possibility of unlocking some other courses. i.e. the courses with non-zero out degree.\\n\\nHere is the optimized code: (24ms, 99.30%)\\n\\n```\\n    def minNumberOfSemesters(self, n: int, dependencies: List[List[int]], k: int) -> int:\\n        G = [0] * n\\n        outDegree = [0] * n\\n        for x, y in dependencies:\\n            G[y-1] += 1 << (x-1)\\n            outDegree[x-1] += 1\\n        P2 = [1<<y for y in range(n)]\\n        start = 0\\n        goal = 2**n-1\\n        d = collections.deque([(start,0)])\\n        seen = [0] * (2 ** n)\\n        while d:\\n            s, steps = d.popleft()\\n            available = [y for y in range(n) if (s & G[y] == G[y]) and (s & P2[y] == 0)]\\n            A1 = [P2[y] for y in available if outDegree[y]] #these courses can unlock others!\\n            A2 = [P2[y] for y in available if outDegree[y] == 0] \\n\\t\\t\\t# we only take courses in A2 when we have spaces!\\n            if len(A1) <= k:\\n                s += sum(A1) + sum(A2[:k-len(A1)])\\n                if s == goal: return steps + 1\\n                if not seen[s]:\\n                    d.append((s,steps+1))\\n\\t\\t\\t\\t\\tseen[s] = 1\\n            else:\\n                for batch in itertools.combinations(A1, k):\\n                    diff = sum(batch)\\n                    t = s + diff\\n                    if t == goal: return steps + 1\\n                    if not seen[t]:\\n                        d.append((t, steps+1))\\n                        seen[t] = 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\n    def minNumberOfSemesters(self, n: int, dependencies: List[List[int]], k: int) -> int:\\n        G = [0] * n\\n        for x, y in dependencies:\\n            G[y-1] += 1 << (x-1) \\n\\t\\t\\t# node in dependencies are 1-indexed, everything below will be 0-indexed.\\n\\t\\t\\t# G[x] = 0b10001 means the prerequisite of x is 0 and 4 (0th and 4th bit set.)\\n        P2 = [1<<y for y in range(n)]\\n        start = 0\\n        goal = 2**n-1\\n        d = collections.deque([(start,0)])\\n        seen = [0] * (2 ** n)\\n        while d:\\n            s, steps = d.popleft()\\n            available = [P2[y] for y in range(n) if (s & G[y] == G[y]) and (s & P2[y] == 0)]\\n\\t\\t\\t# (s & G[y] == G[y]) means all prerequisite has been taken, \\n\\t\\t\\t# (s & P2[y] == 0) means y itself has not been taken.\\n            if len(available) <= k:\\n\\t\\t\\t    # only \\u2264 k courses are available, take all of them.\\n                s += sum(available)\\n                if s == goal: return steps + 1\\n                if not seen[s]:\\n                    d.append((s,steps+1))\\n\\t\\t\\t\\t\\tseen[s] = 1\\n            else:\\n\\t\\t\\t    # iterate through possible combinations\\n                for batch in itertools.combinations(available, k):\\n                    diff = sum(batch)\\n                    t = s + diff\\n                    if t == goal: return steps + 1\\n                    if not seen[t]:\\n                        d.append((t, steps+1))\\n                        seen[t] = 1\\n```\n```\\n    def minNumberOfSemesters(self, n: int, dependencies: List[List[int]], k: int) -> int:\\n        G = [0] * n\\n        outDegree = [0] * n\\n        for x, y in dependencies:\\n            G[y-1] += 1 << (x-1)\\n            outDegree[x-1] += 1\\n        P2 = [1<<y for y in range(n)]\\n        start = 0\\n        goal = 2**n-1\\n        d = collections.deque([(start,0)])\\n        seen = [0] * (2 ** n)\\n        while d:\\n            s, steps = d.popleft()\\n            available = [y for y in range(n) if (s & G[y] == G[y]) and (s & P2[y] == 0)]\\n            A1 = [P2[y] for y in available if outDegree[y]] #these courses can unlock others!\\n            A2 = [P2[y] for y in available if outDegree[y] == 0] \\n\\t\\t\\t# we only take courses in A2 when we have spaces!\\n            if len(A1) <= k:\\n                s += sum(A1) + sum(A2[:k-len(A1)])\\n                if s == goal: return steps + 1\\n                if not seen[s]:\\n                    d.append((s,steps+1))\\n\\t\\t\\t\\t\\tseen[s] = 1\\n            else:\\n                for batch in itertools.combinations(A1, k):\\n                    diff = sum(batch)\\n                    t = s + diff\\n                    if t == goal: return steps + 1\\n                    if not seen[t]:\\n                        d.append((t, steps+1))\\n                        seen[t] = 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 854588,
                "title": "c-o-3-n-bitmask-dp-beats-96-in-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int n,k;\\n    vector<int>preq[15];\\n    vector<int> dp;\\n    int num_sems(int mask)\\n    {\\n        if(mask == (1<<n)-1)\\n        {\\n            return 0;\\n        }\\n        if(dp[mask] != -1)\\n        {\\n            return dp[mask];\\n        }\\n        \\n        vector<int>indeg(n,0);\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            if(mask & (1 << i))\\n            {\\n                continue;\\n            }\\n            for(int j = 0 ; j < preq[i].size() ; j++)\\n            {\\n                indeg[preq[i][j]]++;  // All the courses dependent on i\\n            }\\n        }\\n        \\n        int ok = 0;   // The courses which are avaiable to be taken on the current day , first no curces can be taken\\n        for(int i = 0; i < n ; i++)\\n        {\\n            if(indeg[i] == 0 and !(mask&(1<<i)))\\n            {\\n                ok |= (1<<i);\\n            }\\n        }\\n        \\n        // We have the number of cources available on that perticular day\\n        int num_avail = __builtin_popcount(ok);\\n        int taken = n+1;\\n        // If num_avail > k, then we will have to check all possibilities \\n        int m = ok;\\n        int s;\\n        if(num_avail > k)\\n        {\\n            for(s = m; s ; s = (s-1)&m)\\n            {\\n                if(__builtin_popcount(s) != k)\\n                {\\n                    continue;\\n                }\\n                else\\n                {\\n                    taken = std::min(taken,1 + num_sems(mask|s));\\n                }\\n            }\\n        }\\n        else\\n        {\\n            taken = std::min(taken,1 + num_sems(mask|ok));\\n        }\\n        \\n        return dp[mask] = taken;\\n    }\\n    \\n    \\n    int minNumberOfSemesters(int N, vector<vector<int>>& dependencies, int K) {\\n        n = N;\\n        k = K;\\n        dp.assign(1<<n,-1);\\n        // memset(dp,-1,sizeof(dp));\\n        for(int i = 0 ; i < dependencies.size() ; ++i)\\n        {\\n            dependencies[i][1] --;\\n            dependencies[i][0] --;\\n            preq[dependencies[i][0]].push_back(dependencies[i][1]);\\n        }\\n        \\n        int ans = num_sems(0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int n,k;\\n    vector<int>preq[15];\\n    vector<int> dp;\\n    int num_sems(int mask)\\n    {\\n        if(mask == (1<<n)-1)\\n        {\\n            return 0;\\n        }\\n        if(dp[mask] != -1)\\n        {\\n            return dp[mask];\\n        }\\n        \\n        vector<int>indeg(n,0);\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            if(mask & (1 << i))\\n            {\\n                continue;\\n            }\\n            for(int j = 0 ; j < preq[i].size() ; j++)\\n            {\\n                indeg[preq[i][j]]++;  // All the courses dependent on i\\n            }\\n        }\\n        \\n        int ok = 0;   // The courses which are avaiable to be taken on the current day , first no curces can be taken\\n        for(int i = 0; i < n ; i++)\\n        {\\n            if(indeg[i] == 0 and !(mask&(1<<i)))\\n            {\\n                ok |= (1<<i);\\n            }\\n        }\\n        \\n        // We have the number of cources available on that perticular day\\n        int num_avail = __builtin_popcount(ok);\\n        int taken = n+1;\\n        // If num_avail > k, then we will have to check all possibilities \\n        int m = ok;\\n        int s;\\n        if(num_avail > k)\\n        {\\n            for(s = m; s ; s = (s-1)&m)\\n            {\\n                if(__builtin_popcount(s) != k)\\n                {\\n                    continue;\\n                }\\n                else\\n                {\\n                    taken = std::min(taken,1 + num_sems(mask|s));\\n                }\\n            }\\n        }\\n        else\\n        {\\n            taken = std::min(taken,1 + num_sems(mask|ok));\\n        }\\n        \\n        return dp[mask] = taken;\\n    }\\n    \\n    \\n    int minNumberOfSemesters(int N, vector<vector<int>>& dependencies, int K) {\\n        n = N;\\n        k = K;\\n        dp.assign(1<<n,-1);\\n        // memset(dp,-1,sizeof(dp));\\n        for(int i = 0 ; i < dependencies.size() ; ++i)\\n        {\\n            dependencies[i][1] --;\\n            dependencies[i][0] --;\\n            preq[dependencies[i][0]].push_back(dependencies[i][1]);\\n        }\\n        \\n        int ans = num_sems(0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 804820,
                "title": "java-easy-recursive-solution",
                "content": "```\\nclass Solution {\\n    \\n    private void combinationsHelper(List<List<Integer>> combinations, Integer start, Integer end, Integer index, Integer[] data, List<Integer> arr) {\\n        if (index == data.length) {\\n            Integer[] combination = data.clone();\\n            combinations.add(Arrays.asList(combination));\\n        } else if (start <= end) {\\n            data[index] = arr.get(start);\\n            combinationsHelper(combinations, start + 1, end, index + 1, data, arr);\\n            combinationsHelper(combinations, start + 1, end, index, data, arr);\\n        }\\n    }\\n    \\n    public List<List<Integer>> combinations(List<Integer> courses, Integer k) {\\n        List<List<Integer>> combinations = new ArrayList<>();\\n        Integer[] temp = new Integer[k];\\n        combinationsHelper(combinations, 0, courses.size()-1, 0, temp, courses);\\n        return combinations;\\n    }\\n    \\n    public Integer[] takeCourses(Integer[] inDegrees, Map<Integer, Set<Integer>> unlockedBy, List<Integer> courses) {\\n        Integer[] newInDegrees = inDegrees.clone();\\n        for (Integer course : courses) {\\n            newInDegrees[course-1]--;\\n            if (unlockedBy.containsKey(course)) {\\n                for (Integer unlockedCourse : unlockedBy.get(course)) {\\n                    newInDegrees[unlockedCourse-1]--;\\n                }\\n            }\\n        }\\n        return newInDegrees;\\n    }\\n    \\n    public int findMinSemesters(Integer[] inDegrees, Map<Integer, Set<Integer>> unlockedBy, int k) {\\n        Boolean allCoursesTaken = true;\\n        for (Integer inDeg : inDegrees) {\\n            if (inDeg >= 0) {\\n                allCoursesTaken = false;\\n            }\\n        }\\n        if (allCoursesTaken) {\\n            return 0;\\n        }\\n        \\n        List<Integer> openerCourses = new ArrayList<>();\\n        List<Integer> restCourses = new ArrayList<>();\\n        for (int i = 0; i < inDegrees.length; i++) {\\n            if (inDegrees[i] == 0) {\\n                if (unlockedBy.containsKey(i+1)) {\\n                    openerCourses.add(i+1);\\n                } else {\\n                    restCourses.add(i+1);\\n                }\\n            }\\n        }\\n        \\n        if (k >= openerCourses.size()) {\\n            List<Integer> takenCourses = new ArrayList<>(openerCourses);\\n            if (k - openerCourses.size() > 0) {\\n                takenCourses.addAll(restCourses.subList(0, Math.min(k - openerCourses.size(), restCourses.size())));\\n            }\\n            Integer[] newInDegrees = takeCourses(inDegrees, unlockedBy, takenCourses);\\n            return 1 + findMinSemesters(newInDegrees, unlockedBy, k);\\n        } else {\\n            List<List<Integer>> courseCombinations = combinations(openerCourses, k);\\n            int minSemesters = Integer.MAX_VALUE;\\n            for (List<Integer> courseCombination : courseCombinations) {\\n                Integer[] newInDegrees = takeCourses(inDegrees, unlockedBy, courseCombination);\\n                int result = findMinSemesters(newInDegrees, unlockedBy, k);\\n                if (result < minSemesters) {\\n                    minSemesters = result;\\n                }\\n            }\\n            return 1 + minSemesters;\\n        }\\n        \\n    }\\n    \\n    \\n    public int minNumberOfSemesters(int n, int[][] dependencies, int k) {\\n        Integer[] inDegrees = new Integer[n];\\n        Arrays.fill(inDegrees, 0);\\n        Map<Integer, Set<Integer>> unlockedBy = new HashMap<>();\\n        \\n        for (int i = 0; i < dependencies.length; i++) {\\n            if (unlockedBy.containsKey(dependencies[i][0])) {\\n                unlockedBy.get(dependencies[i][0]).add(dependencies[i][1]);\\n            } else {\\n                unlockedBy.put(dependencies[i][0], new HashSet<>(Arrays.asList(dependencies[i][1])));\\n            }\\n            inDegrees[dependencies[i][1]-1] += 1;\\n        }\\n        return findMinSemesters(inDegrees, unlockedBy, k);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    private void combinationsHelper(List<List<Integer>> combinations, Integer start, Integer end, Integer index, Integer[] data, List<Integer> arr) {\\n        if (index == data.length) {\\n            Integer[] combination = data.clone();\\n            combinations.add(Arrays.asList(combination));\\n        } else if (start <= end) {\\n            data[index] = arr.get(start);\\n            combinationsHelper(combinations, start + 1, end, index + 1, data, arr);\\n            combinationsHelper(combinations, start + 1, end, index, data, arr);\\n        }\\n    }\\n    \\n    public List<List<Integer>> combinations(List<Integer> courses, Integer k) {\\n        List<List<Integer>> combinations = new ArrayList<>();\\n        Integer[] temp = new Integer[k];\\n        combinationsHelper(combinations, 0, courses.size()-1, 0, temp, courses);\\n        return combinations;\\n    }\\n    \\n    public Integer[] takeCourses(Integer[] inDegrees, Map<Integer, Set<Integer>> unlockedBy, List<Integer> courses) {\\n        Integer[] newInDegrees = inDegrees.clone();\\n        for (Integer course : courses) {\\n            newInDegrees[course-1]--;\\n            if (unlockedBy.containsKey(course)) {\\n                for (Integer unlockedCourse : unlockedBy.get(course)) {\\n                    newInDegrees[unlockedCourse-1]--;\\n                }\\n            }\\n        }\\n        return newInDegrees;\\n    }\\n    \\n    public int findMinSemesters(Integer[] inDegrees, Map<Integer, Set<Integer>> unlockedBy, int k) {\\n        Boolean allCoursesTaken = true;\\n        for (Integer inDeg : inDegrees) {\\n            if (inDeg >= 0) {\\n                allCoursesTaken = false;\\n            }\\n        }\\n        if (allCoursesTaken) {\\n            return 0;\\n        }\\n        \\n        List<Integer> openerCourses = new ArrayList<>();\\n        List<Integer> restCourses = new ArrayList<>();\\n        for (int i = 0; i < inDegrees.length; i++) {\\n            if (inDegrees[i] == 0) {\\n                if (unlockedBy.containsKey(i+1)) {\\n                    openerCourses.add(i+1);\\n                } else {\\n                    restCourses.add(i+1);\\n                }\\n            }\\n        }\\n        \\n        if (k >= openerCourses.size()) {\\n            List<Integer> takenCourses = new ArrayList<>(openerCourses);\\n            if (k - openerCourses.size() > 0) {\\n                takenCourses.addAll(restCourses.subList(0, Math.min(k - openerCourses.size(), restCourses.size())));\\n            }\\n            Integer[] newInDegrees = takeCourses(inDegrees, unlockedBy, takenCourses);\\n            return 1 + findMinSemesters(newInDegrees, unlockedBy, k);\\n        } else {\\n            List<List<Integer>> courseCombinations = combinations(openerCourses, k);\\n            int minSemesters = Integer.MAX_VALUE;\\n            for (List<Integer> courseCombination : courseCombinations) {\\n                Integer[] newInDegrees = takeCourses(inDegrees, unlockedBy, courseCombination);\\n                int result = findMinSemesters(newInDegrees, unlockedBy, k);\\n                if (result < minSemesters) {\\n                    minSemesters = result;\\n                }\\n            }\\n            return 1 + minSemesters;\\n        }\\n        \\n    }\\n    \\n    \\n    public int minNumberOfSemesters(int n, int[][] dependencies, int k) {\\n        Integer[] inDegrees = new Integer[n];\\n        Arrays.fill(inDegrees, 0);\\n        Map<Integer, Set<Integer>> unlockedBy = new HashMap<>();\\n        \\n        for (int i = 0; i < dependencies.length; i++) {\\n            if (unlockedBy.containsKey(dependencies[i][0])) {\\n                unlockedBy.get(dependencies[i][0]).add(dependencies[i][1]);\\n            } else {\\n                unlockedBy.put(dependencies[i][0], new HashSet<>(Arrays.asList(dependencies[i][1])));\\n            }\\n            inDegrees[dependencies[i][1]-1] += 1;\\n        }\\n        return findMinSemesters(inDegrees, unlockedBy, k);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 727044,
                "title": "c-32ms-bfs",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int minNumberOfSemesters(int n, vector<vector<int>>& dependencies, int k) {\\n        int N = 1 << n;\\n        int pre[15] = {};\\n        \\n        // Compute binary representation of prerequisites for each course.\\n        for (auto &d : dependencies) {\\n            pre[d[1] - 1] |= 1 << (d[0] - 1);\\n        }\\n        \\n        // Breadth-first search for the completed state.\\n\\t\\t// We start in the zero state, having completed no courses.\\n        deque<int> q = {0};\\n        int dist[1<<15] = {};\\n        int seen[1<<15] = {};\\n        \\n        while (!q.empty()) {\\n            // Binary representation of current state.\\n            int curr = q.front(); q.pop_front();\\n            if (curr == N - 1) {\\n                break;\\n            }\\n            \\n            // The set of all possible courses we can take next.\\n            int s = 0;\\n            for (int i = 0; i < n; i++) {\\n                if ((pre[i] & curr) == pre[i] && !(curr & (1 << i))) {\\n                    s |= 1 << i;\\n                }\\n            }\\n            \\n            // Enumerate subsets of possible next courses.\\n            for (int i = s; i; i = (i - 1) & s) {\\n                if (__builtin_popcount(i) <= k) {\\n                    int next = curr | i;\\n                    if (!seen[next]) {\\n                        seen[next] = true;\\n                        dist[next] = dist[curr] + 1;\\n                        q.push_back(next);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dist[N - 1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int minNumberOfSemesters(int n, vector<vector<int>>& dependencies, int k) {\\n        int N = 1 << n;\\n        int pre[15] = {};\\n        \\n        // Compute binary representation of prerequisites for each course.\\n        for (auto &d : dependencies) {\\n            pre[d[1] - 1] |= 1 << (d[0] - 1);\\n        }\\n        \\n        // Breadth-first search for the completed state.\\n\\t\\t// We start in the zero state, having completed no courses.\\n        deque<int> q = {0};\\n        int dist[1<<15] = {};\\n        int seen[1<<15] = {};\\n        \\n        while (!q.empty()) {\\n            // Binary representation of current state.\\n            int curr = q.front(); q.pop_front();\\n            if (curr == N - 1) {\\n                break;\\n            }\\n            \\n            // The set of all possible courses we can take next.\\n            int s = 0;\\n            for (int i = 0; i < n; i++) {\\n                if ((pre[i] & curr) == pre[i] && !(curr & (1 << i))) {\\n                    s |= 1 << i;\\n                }\\n            }\\n            \\n            // Enumerate subsets of possible next courses.\\n            for (int i = s; i; i = (i - 1) & s) {\\n                if (__builtin_popcount(i) <= k) {\\n                    int next = curr | i;\\n                    if (!seen[next]) {\\n                        seen[next] = true;\\n                        dist[next] = dist[curr] + 1;\\n                        q.push_back(next);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dist[N - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 708870,
                "title": "java-warshall-floyd-modified-topological-sort-o-n-3-greedy-accepted-3ms",
                "content": "**UPDATE:** Fails test case below. Thanks s_tsat!\\n```\\n11\\n[[1,2],[2,3],[3,4],[5,8],[5,9],[5,10],[5,11],[6,8],[6,9],[6,10],[6,11],[7,8],[7,9],[7,10],[7,11]]\\n3\\n```\\n**Step 1:** find the number of recursive dependencies of each class using Warshall-Floyd algorithm O(N^3)\\n**Step 2:** topological sort, but each semester pick k eligible classes (indegree=0) with the highest number of dependents found in step 1 using Priority Queue (Max Heap). \\n```java\\nclass Solution {\\n    public int minNumberOfSemesters(int n, int[][] dependencies, int k) {\\n        List<Integer>[] adj = new ArrayList[n];\\n        for (int i = 0; i < n; i++) {\\n            adj[i] = new ArrayList<>();\\n        }\\n        int[] indegree = new int[n];\\n        boolean[][] conn = new boolean[n][n];\\n        for (int[] dep : dependencies) {\\n            adj[dep[0]-1].add(dep[1]-1);\\n            indegree[dep[1]-1]++;\\n            conn[dep[0]-1][dep[1]-1] = true;\\n        }\\n\\n        // pass 1: find number of dependents based on Floyd-Warshall algorithm O(n^3)\\n        for (int m = 0; m < n; m++)\\n            for (int i = 0; i < n; i++)\\n                for (int j = 0; j < n; j++)\\n                    conn[i][j] = conn[i][j] || (conn[i][m] && conn[m][j]);\\n\\n        int[] numDependents = new int[n];\\n        for (int i = 0; i < n; i++)\\n            for (int j = 0; j < n; j++)\\n                numDependents[i] += conn[i][j] ? 1 : 0;\\n\\n        // pass 2: topological order + pick k classes with the largest number of dependents\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b)->Integer.compare(numDependents[b], numDependents[a]));\\n        for (int i = 0; i < n; ++i) {\\n            if (indegree[i] == 0) {\\n                pq.offer(i);\\n            }\\n        }\\n        List<Integer> nextList = new ArrayList<>();\\n        int res = 0;\\n        while (!pq.isEmpty()) {\\n            for (int i = Math.min(k, pq.size()); i > 0; i--) {\\n                int current = pq.poll();\\n                for (int next : adj[current]) {\\n                    if (--indegree[next] == 0) {\\n                        nextList.add(next);\\n                    }\\n                }\\n            }\\n            pq.addAll(nextList);\\n            nextList.clear();\\n            res++;\\n        }\\n        return res;\\n    }\\n}\\n```\\nSeems to pass all test cases listed in other threads:\\n```\\n4\\n[[2,1],[3,1],[1,4]]\\n2\\n5\\n[[2,1],[3,1],[4,1],[1,5]]\\n2\\n11\\n[]\\n2\\n9\\n[[4,8],[3,6],[6,8],[7,6],[4,2],[4,1],[4,7],[3,7],[5,2],[5,9],[3,4],[6,9],[5,7]]\\n2\\n5\\n[[5,1],[3,1],[5,4],[4,1],[2,3]]\\n3\\n8\\n[[1,6],[2,7],[8,7],[2,5],[3,4]]\\n3\\n9\\n[[6,4],[7,2],[1,3]]\\n3\\n8\\n[[1,3],[1,4],[2,3],[2,4],[5,6],[6,7],[7,8]]\\n2\\n6\\n[[2,5],[1,5],[3,5],[3,4],[3,6]]\\n2\\n10\\n[[1,5],[1,6],[1,7],[2,5],[2,6],[2,7],[9,10],[10,5],[10,6],[10,7],[10,8],[3,5],[3,6],[4,5],[4,6]]\\n2\\n9\\n[[1,4],[1,5],[3,5],[3,6],[2,6],[2,7],[8,4],[8,5],[9,6],[9,7]]\\n3\\n12\\n[[1,2],[2,3],[4,5],[5,6],[7,8],[8,9],[10,11],[11,12]]\\n3\\n12\\n[[1,2],[1,3],[7,5],[7,6],[4,8],[8,9],[9,10],[10,11],[11,12]]\\n2\\n```\\nPlease post a reply if you found a test case which breaks this algorithm.",
                "solutionTags": [],
                "code": "```\\n11\\n[[1,2],[2,3],[3,4],[5,8],[5,9],[5,10],[5,11],[6,8],[6,9],[6,10],[6,11],[7,8],[7,9],[7,10],[7,11]]\\n3\\n```\n```java\\nclass Solution {\\n    public int minNumberOfSemesters(int n, int[][] dependencies, int k) {\\n        List<Integer>[] adj = new ArrayList[n];\\n        for (int i = 0; i < n; i++) {\\n            adj[i] = new ArrayList<>();\\n        }\\n        int[] indegree = new int[n];\\n        boolean[][] conn = new boolean[n][n];\\n        for (int[] dep : dependencies) {\\n            adj[dep[0]-1].add(dep[1]-1);\\n            indegree[dep[1]-1]++;\\n            conn[dep[0]-1][dep[1]-1] = true;\\n        }\\n\\n        // pass 1: find number of dependents based on Floyd-Warshall algorithm O(n^3)\\n        for (int m = 0; m < n; m++)\\n            for (int i = 0; i < n; i++)\\n                for (int j = 0; j < n; j++)\\n                    conn[i][j] = conn[i][j] || (conn[i][m] && conn[m][j]);\\n\\n        int[] numDependents = new int[n];\\n        for (int i = 0; i < n; i++)\\n            for (int j = 0; j < n; j++)\\n                numDependents[i] += conn[i][j] ? 1 : 0;\\n\\n        // pass 2: topological order + pick k classes with the largest number of dependents\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b)->Integer.compare(numDependents[b], numDependents[a]));\\n        for (int i = 0; i < n; ++i) {\\n            if (indegree[i] == 0) {\\n                pq.offer(i);\\n            }\\n        }\\n        List<Integer> nextList = new ArrayList<>();\\n        int res = 0;\\n        while (!pq.isEmpty()) {\\n            for (int i = Math.min(k, pq.size()); i > 0; i--) {\\n                int current = pq.poll();\\n                for (int next : adj[current]) {\\n                    if (--indegree[next] == 0) {\\n                        nextList.add(next);\\n                    }\\n                }\\n            }\\n            pq.addAll(nextList);\\n            nextList.clear();\\n            res++;\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\n4\\n[[2,1],[3,1],[1,4]]\\n2\\n5\\n[[2,1],[3,1],[4,1],[1,5]]\\n2\\n11\\n[]\\n2\\n9\\n[[4,8],[3,6],[6,8],[7,6],[4,2],[4,1],[4,7],[3,7],[5,2],[5,9],[3,4],[6,9],[5,7]]\\n2\\n5\\n[[5,1],[3,1],[5,4],[4,1],[2,3]]\\n3\\n8\\n[[1,6],[2,7],[8,7],[2,5],[3,4]]\\n3\\n9\\n[[6,4],[7,2],[1,3]]\\n3\\n8\\n[[1,3],[1,4],[2,3],[2,4],[5,6],[6,7],[7,8]]\\n2\\n6\\n[[2,5],[1,5],[3,5],[3,4],[3,6]]\\n2\\n10\\n[[1,5],[1,6],[1,7],[2,5],[2,6],[2,7],[9,10],[10,5],[10,6],[10,7],[10,8],[3,5],[3,6],[4,5],[4,6]]\\n2\\n9\\n[[1,4],[1,5],[3,5],[3,6],[2,6],[2,7],[8,4],[8,5],[9,6],[9,7]]\\n3\\n12\\n[[1,2],[2,3],[4,5],[5,6],[7,8],[8,9],[10,11],[11,12]]\\n3\\n12\\n[[1,2],[1,3],[7,5],[7,6],[4,8],[8,9],[9,10],[10,11],[11,12]]\\n2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 708120,
                "title": "java-solution-priority-queue-topological-sort",
                "content": "**Edit - This solution is incorrect. I would update it soon.**\\n```\\nclass Solution {\\n    public int minNumberOfSemesters(int n, int[][] dependencies, int k) {\\n        List<Integer>[] adj = new ArrayList[n];\\n        int[] outdegree = new int[n];\\n        for(int i = 0; i < n; i++){\\n            adj[i] = new ArrayList<>();\\n        }\\n        int[] indegree = new int[n];\\n        for(int[] e: dependencies){\\n            adj[e[0] - 1].add(e[1] - 1);\\n            outdegree[e[0] - 1]++;\\n            indegree[e[1] - 1]++;\\n        }\\n        \\n        // higher outdegree courses should be taken first\\n        PriorityQueue<Integer> q = new PriorityQueue<>((a, b) -> outdegree[b.intValue()] - outdegree[a.intValue()]);\\n        for(int i = 0; i < n; i++){\\n            if(indegree[i] == 0){\\n                q.add(i);\\n            }\\n        }\\n        \\n        int ans = 0;\\n        while(!q.isEmpty()){\\n            // pick courses for current semester\\n            Queue<Integer> temp = new LinkedList<>();\\n            for(int i = Math.min(q.size(), k); i > 0; i--){\\n                temp.add(q.poll());\\n            }\\n            \\n            // remove dependencies \\n            while(!temp.isEmpty()){\\n                int u = temp.poll();\\n                for(int v: adj[u]){\\n                    if(--indegree[v] == 0){\\n                        q.add(v);\\n                    }\\n                }\\n            }\\n            ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumberOfSemesters(int n, int[][] dependencies, int k) {\\n        List<Integer>[] adj = new ArrayList[n];\\n        int[] outdegree = new int[n];\\n        for(int i = 0; i < n; i++){\\n            adj[i] = new ArrayList<>();\\n        }\\n        int[] indegree = new int[n];\\n        for(int[] e: dependencies){\\n            adj[e[0] - 1].add(e[1] - 1);\\n            outdegree[e[0] - 1]++;\\n            indegree[e[1] - 1]++;\\n        }\\n        \\n        // higher outdegree courses should be taken first\\n        PriorityQueue<Integer> q = new PriorityQueue<>((a, b) -> outdegree[b.intValue()] - outdegree[a.intValue()]);\\n        for(int i = 0; i < n; i++){\\n            if(indegree[i] == 0){\\n                q.add(i);\\n            }\\n        }\\n        \\n        int ans = 0;\\n        while(!q.isEmpty()){\\n            // pick courses for current semester\\n            Queue<Integer> temp = new LinkedList<>();\\n            for(int i = Math.min(q.size(), k); i > 0; i--){\\n                temp.add(q.poll());\\n            }\\n            \\n            // remove dependencies \\n            while(!temp.isEmpty()){\\n                int u = temp.poll();\\n                for(int v: adj[u]){\\n                    if(--indegree[v] == 0){\\n                        q.add(v);\\n                    }\\n                }\\n            }\\n            ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2804122,
                "title": "c-bitmasking-dp-topological-sorting-recursion-with-memoisation",
                "content": "\\n\\n```cpp\\nclass Solution {\\npublic:\\n    static const int nax = 16;\\n    vector<int> g[nax];\\n    vector<int> dp;\\n    int n;\\n    int N;\\n    int k;\\n    int dfs(int bitmask, const vector<int> &in) {\\n        if (bitmask == N) {\\n            return 0;\\n        }\\n        if (dp[bitmask] != -1) return dp[bitmask];\\n        vector<int> candidates;\\n        for (int i = 0; i < n; ++i) {\\n            if (bitmask & (1 << i)) continue;\\n            if (in[i] == 0) {\\n                candidates.push_back(i);\\n            }\\n        }\\n        int candidateSize = candidates.size();\\n        int t = INT_MAX;\\n        //this loop is used to choose k \\n        //elements out of x possible candidates\\n        for (int i = 0; i < (1 << candidateSize); ++i) {\\n            int bitCount = __builtin_popcount(i);\\n            if (bitCount == min(k, candidateSize)) {\\n                int p = i;\\n                int idx = 0;\\n                int newBitmask = bitmask;\\n                vector<int> newState(in.begin(), in.end());\\n                while (p) {\\n                    if (p & 1) {\\n                        for (int &v: g[candidates[idx]]) {\\n                            --newState[v];\\n                        }\\n                        newBitmask |= (1 << candidates[idx]);\\n                        //setting this key as INT_MAX so that this key\\n                        //doesn\\'t get picked up in the next iteration\\n                    }\\n                    p = p >> 1;\\n                    ++idx;\\n                }\\n                t = min(t, 1 + dfs(newBitmask, newState));\\n            }\\n        }\\n        return dp[bitmask] = t;\\n    }\\n    \\n    int minNumberOfSemesters(int n, vector<vector<int>>& relations, int k) {\\n        this->n = n;\\n        this->k = k;\\n        vector<int> in(n, 0);\\n        for (int i = 0; i < nax; ++i) {\\n            g[i].clear();\\n        }\\n        for (const auto &entry: relations) {\\n            int u = entry[0] - 1;\\n            int v = entry[1] - 1;\\n            g[u].push_back(v);\\n            ++in[v];\\n        }\\n        int bitmask = 0;\\n        N = (1 << n) - 1;\\n        dp.resize(N, -1);\\n        return dfs(bitmask, in);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    static const int nax = 16;\\n    vector<int> g[nax];\\n    vector<int> dp;\\n    int n;\\n    int N;\\n    int k;\\n    int dfs(int bitmask, const vector<int> &in) {\\n        if (bitmask == N) {\\n            return 0;\\n        }\\n        if (dp[bitmask] != -1) return dp[bitmask];\\n        vector<int> candidates;\\n        for (int i = 0; i < n; ++i) {\\n            if (bitmask & (1 << i)) continue;\\n            if (in[i] == 0) {\\n                candidates.push_back(i);\\n            }\\n        }\\n        int candidateSize = candidates.size();\\n        int t = INT_MAX;\\n        //this loop is used to choose k \\n        //elements out of x possible candidates\\n        for (int i = 0; i < (1 << candidateSize); ++i) {\\n            int bitCount = __builtin_popcount(i);\\n            if (bitCount == min(k, candidateSize)) {\\n                int p = i;\\n                int idx = 0;\\n                int newBitmask = bitmask;\\n                vector<int> newState(in.begin(), in.end());\\n                while (p) {\\n                    if (p & 1) {\\n                        for (int &v: g[candidates[idx]]) {\\n                            --newState[v];\\n                        }\\n                        newBitmask |= (1 << candidates[idx]);\\n                        //setting this key as INT_MAX so that this key\\n                        //doesn\\'t get picked up in the next iteration\\n                    }\\n                    p = p >> 1;\\n                    ++idx;\\n                }\\n                t = min(t, 1 + dfs(newBitmask, newState));\\n            }\\n        }\\n        return dp[bitmask] = t;\\n    }\\n    \\n    int minNumberOfSemesters(int n, vector<vector<int>>& relations, int k) {\\n        this->n = n;\\n        this->k = k;\\n        vector<int> in(n, 0);\\n        for (int i = 0; i < nax; ++i) {\\n            g[i].clear();\\n        }\\n        for (const auto &entry: relations) {\\n            int u = entry[0] - 1;\\n            int v = entry[1] - 1;\\n            g[u].push_back(v);\\n            ++in[v];\\n        }\\n        int bitmask = 0;\\n        N = (1 << n) - 1;\\n        dp.resize(N, -1);\\n        return dfs(bitmask, in);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2558814,
                "title": "c-solution-along-with-explanation",
                "content": "Approach -\\nThe given problem can be formulated as topological graph, where [prerequisite_i, course_i] denotes a directed edge from prerequisite_i to course_i, so inorder to take a course_i, all the incoming edges to that course_i must be zero. \\n\\nLet indegree (indeg) array denotes the indegree, the number of prerequisites to each course(node), if indegree at any time to particular course is 0, then we have the choice of taking that course in that semester. If there is a non-zero indegree, it means that we can take that course until all its prerequisites completed.\\n\\nNow, how to find the minimum number of semesters to complete all courses? During any semester, we are allowed to \\'k\\' courses. So, if the number of courses, having indegree = 0 is <= k, we can take all of them in a single semester, and all of their children indegree/ prerequisite decreased by the number of courses that were taken having edge to them. \\n\\nBut the problem comes when the number of nodes > k, now, we cannot simply take any k courses and proceed as it will depend on the type of graph that we obtained. What we can do is to take all the k - subset nodes with indegree 0 and solve the remaining problem and take the minimum of all of them. As the constraints are small, we can do that. We can get a same subgraph by taking different courses in different order, so to avoid recomputing the minimum again and again, we can use dynamic programing. We can represent a subgraph with the help of mask, where i_th bit mask = 0 denotes that it is in the sub graph(course not taken yet), and 1 means course already taken. \\n\\nSo, dp[mask] reperesents the minimum number of steps required to take all the courses whose bit is set as 1. If courses that are directly available taken <= k, then dp[mask] = 1 + dp[mask | (mask1 with all the courses with indeg == 0 && and are taking in this semester)].\\n\\nelse dp[mask] = min(dp[mask | (mask1 with k courses of indeg == 0 && and are taking in this semester)] for all mask1s with k set bits. \\nWe need to update the indegree of each node based on the new mask. Please see the solution for more explanantion.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> a[16];\\n    int solve(int mask, int n,int k, vector<int> & indeg, vector<int> &dp) {\\n        if (mask == (1<<n)-1) return 0;\\n        if (dp[mask] != -1) return dp[mask];\\n        int available = 0;\\n        // cout << \" ----- start ----- \\\\n -- indeg\" << endl;\\n        \\n        for (int i =0; i < indeg.size();i++) {\\n            if (indeg[i] == 0 && (mask & (1<<i)) == 0) available++;\\n            // cout << indeg[i] << \" \";\\n        }\\n        // cout << endl;\\n        // cout << \"Available \" << available << endl;\\n        int ans  = 10000;\\n        if (available <= k) {\\n            vector<int> new_indeg = indeg;\\n            int new_mask = mask;\\n            \\n            for (int i = 0; i < indeg.size();i++) {\\n                if (indeg[i] == 0 && (new_mask & (1<<i)) == 0) {\\n                    new_mask ^= (1<<i);\\n                    for (auto x: a[i]) if (new_indeg[x] != 0) new_indeg[x]--;\\n                }\\n            }\\n            // cout << new_mask << endl;\\n            ans =  1 + solve (new_mask, n, k,new_indeg, dp);\\n        }\\n        else {\\n            // generating subsets for available number and check with it.\\n            for (int i = 1; i <(1<< available);i++) {\\n                int count = 0;\\n                for (int j = 0;  j < available;j++) {\\n                    if (i &(1<<j)) count++;\\n                }\\n                if (count != k) continue;\\n                int ind = 0;\\n                int new_mask = mask;\\n                vector<int> new_indeg = indeg;\\n                for (int j = 0; j < indeg.size();j++) {\\n                    if (  (new_mask & (1<<j)) == 0 &&indeg[j] == 0) {\\n                        if (i & (1<< ind)) {\\n                        new_mask ^= (1<<j);\\n                        for (auto x: a[j]) if (new_indeg[x] != 0) new_indeg[x]--;\\n                        }\\n                        ind++;\\n                    }\\n                }\\n                // cout << i << \" \" << \"new mask \" << new_mask << endl;\\n                ans = min(ans, 1 +  solve(new_mask, n, k, new_indeg, dp));\\n            }\\n        }\\n        dp[mask] = ans;\\n        return dp[mask];\\n        \\n    }\\n    int minNumberOfSemesters(int n, vector<vector<int>>& relations, int k) {\\n       vector<int> indeg(n,0);\\n        vector<int> dp((1<<n) , -1);\\n        if (relations.size() == 0) return ceil((double)n/k);\\n        for (int i =0; i < relations.size();i++) {\\n            \\n            a[relations[i][0]-1].push_back(relations[i][1]-1);\\n            indeg[relations[i][1]-1]++;\\n        }\\n        // cout << indeg.size() << endl;\\n       int x =  solve(0, n,k, indeg, dp);\\n       return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Topological Sort",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> a[16];\\n    int solve(int mask, int n,int k, vector<int> & indeg, vector<int> &dp) {\\n        if (mask == (1<<n)-1) return 0;\\n        if (dp[mask] != -1) return dp[mask];\\n        int available = 0;\\n        // cout << \" ----- start ----- \\\\n -- indeg\" << endl;\\n        \\n        for (int i =0; i < indeg.size();i++) {\\n            if (indeg[i] == 0 && (mask & (1<<i)) == 0) available++;\\n            // cout << indeg[i] << \" \";\\n        }\\n        // cout << endl;\\n        // cout << \"Available \" << available << endl;\\n        int ans  = 10000;\\n        if (available <= k) {\\n            vector<int> new_indeg = indeg;\\n            int new_mask = mask;\\n            \\n            for (int i = 0; i < indeg.size();i++) {\\n                if (indeg[i] == 0 && (new_mask & (1<<i)) == 0) {\\n                    new_mask ^= (1<<i);\\n                    for (auto x: a[i]) if (new_indeg[x] != 0) new_indeg[x]--;\\n                }\\n            }\\n            // cout << new_mask << endl;\\n            ans =  1 + solve (new_mask, n, k,new_indeg, dp);\\n        }\\n        else {\\n            // generating subsets for available number and check with it.\\n            for (int i = 1; i <(1<< available);i++) {\\n                int count = 0;\\n                for (int j = 0;  j < available;j++) {\\n                    if (i &(1<<j)) count++;\\n                }\\n                if (count != k) continue;\\n                int ind = 0;\\n                int new_mask = mask;\\n                vector<int> new_indeg = indeg;\\n                for (int j = 0; j < indeg.size();j++) {\\n                    if (  (new_mask & (1<<j)) == 0 &&indeg[j] == 0) {\\n                        if (i & (1<< ind)) {\\n                        new_mask ^= (1<<j);\\n                        for (auto x: a[j]) if (new_indeg[x] != 0) new_indeg[x]--;\\n                        }\\n                        ind++;\\n                    }\\n                }\\n                // cout << i << \" \" << \"new mask \" << new_mask << endl;\\n                ans = min(ans, 1 +  solve(new_mask, n, k, new_indeg, dp));\\n            }\\n        }\\n        dp[mask] = ans;\\n        return dp[mask];\\n        \\n    }\\n    int minNumberOfSemesters(int n, vector<vector<int>>& relations, int k) {\\n       vector<int> indeg(n,0);\\n        vector<int> dp((1<<n) , -1);\\n        if (relations.size() == 0) return ceil((double)n/k);\\n        for (int i =0; i < relations.size();i++) {\\n            \\n            a[relations[i][0]-1].push_back(relations[i][1]-1);\\n            indeg[relations[i][1]-1]++;\\n        }\\n        // cout << indeg.size() << endl;\\n       int x =  solve(0, n,k, indeg, dp);\\n       return x;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1859239,
                "title": "python-topological-sort-with-bitmask-and-backtracking",
                "content": "```\\nclass Solution:\\n    def minNumberOfSemesters(self, n: int, relations: List[List[int]], k: int) -> int:\\n        adj = defaultdict(list)\\n        in_deg = [0]*n\\n        \\n        for prev, nxt in relations:\\n            adj[prev-1].append(nxt-1)\\n            in_deg[nxt-1]+=1\\n        \\n        # bit_mask:\\n        # 1 means not taken\\n        # 0 mean taken\\n        # initialize to 1<<n -1\\n        \\n        @cache\\n        def backtrack(bit_mask):\\n            if not bit_mask:\\n                return 0\\n            \\n            catalog = [i for i in range(n) if in_deg[i] == 0 and bit_mask & 1<<i]             \\n            ret = float(\"inf\")\\n            for k_courses in combinations(catalog,min(k,len(catalog))):\\n                nxt_bit_mask = bit_mask                \\n                for course in k_courses:\\n                    nxt_bit_mask ^= 1<<course\\n                    for parent in adj[course]:\\n                        in_deg[parent]-=1\\n                \\n                ret = min( ret, 1 + backtrack( nxt_bit_mask ) )\\n                \\n                for course in k_courses:\\n                    for parent in adj[course]:\\n                        in_deg[parent]+=1                \\n            return ret\\n                \\n        return backtrack((1<<n) -1)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Topological Sort",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def minNumberOfSemesters(self, n: int, relations: List[List[int]], k: int) -> int:\\n        adj = defaultdict(list)\\n        in_deg = [0]*n\\n        \\n        for prev, nxt in relations:\\n            adj[prev-1].append(nxt-1)\\n            in_deg[nxt-1]+=1\\n        \\n        # bit_mask:\\n        # 1 means not taken\\n        # 0 mean taken\\n        # initialize to 1<<n -1\\n        \\n        @cache\\n        def backtrack(bit_mask):\\n            if not bit_mask:\\n                return 0\\n            \\n            catalog = [i for i in range(n) if in_deg[i] == 0 and bit_mask & 1<<i]             \\n            ret = float(\"inf\")\\n            for k_courses in combinations(catalog,min(k,len(catalog))):\\n                nxt_bit_mask = bit_mask                \\n                for course in k_courses:\\n                    nxt_bit_mask ^= 1<<course\\n                    for parent in adj[course]:\\n                        in_deg[parent]-=1\\n                \\n                ret = min( ret, 1 + backtrack( nxt_bit_mask ) )\\n                \\n                for course in k_courses:\\n                    for parent in adj[course]:\\n                        in_deg[parent]+=1                \\n            return ret\\n                \\n        return backtrack((1<<n) -1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1687236,
                "title": "python-bit-dp-memoization-topological-sort",
                "content": "```\\nclass Solution:\\n    def minNumberOfSemesters(self, n: int, relations: List[List[int]], k: int) -> int:\\n        graph=defaultdict(list)\\n        in_degree=[0]*n\\n        @lru_cache(None)\\n        def dp(mask,in_degree):\\n            if not mask: return 0\\n            nodes=[i for i in range(n) if (mask & 1<<i) and in_degree[i]==0]\\n            ans=sys.maxsize\\n            for k_nodes in combinations(nodes,min(k,len(nodes))):\\n                new_mask,new_indegree=mask,list(in_degree)\\n                for node in k_nodes:\\n                    new_mask ^= (1<<node)\\n                    for next_node in graph[node]:\\n                        new_indegree[next_node]-=1\\n                ans=min(ans,1+dp(new_mask,tuple(new_indegree)))\\n            return ans\\n        for u,v in relations:\\n            in_degree[v-1]+=1\\n            graph[u-1].append(v-1)\\n        return dp((1<<n)-1,tuple(in_degree))\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution:\\n    def minNumberOfSemesters(self, n: int, relations: List[List[int]], k: int) -> int:\\n        graph=defaultdict(list)\\n        in_degree=[0]*n\\n        @lru_cache(None)\\n        def dp(mask,in_degree):\\n            if not mask: return 0\\n            nodes=[i for i in range(n) if (mask & 1<<i) and in_degree[i]==0]\\n            ans=sys.maxsize\\n            for k_nodes in combinations(nodes,min(k,len(nodes))):\\n                new_mask,new_indegree=mask,list(in_degree)\\n                for node in k_nodes:\\n                    new_mask ^= (1<<node)\\n                    for next_node in graph[node]:\\n                        new_indegree[next_node]-=1\\n                ans=min(ans,1+dp(new_mask,tuple(new_indegree)))\\n            return ans\\n        for u,v in relations:\\n            in_degree[v-1]+=1\\n            graph[u-1].append(v-1)\\n        return dp((1<<n)-1,tuple(in_degree))\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 817437,
                "title": "python3-a-la-bellman-held-karp",
                "content": "## Approach: Bitmask + Dynamic Programming\\nThis is an NP-complete problem. The proof can be found here\\nhttps://www.sciencedirect.com/science/article/pii/S0022000075800080\\nIf we believe NP!= P, then the only reasonable hope is to  make the brute force search less expoenential. \\nWe will realize that by bitmask + dynamic programming (just like many other algorithms to NP-complete problems). \\n\\nOne might be tempted to topologically sort the classes and greedily take as many classes as possible in one semester as long as we don\\'t more than `k` classes and they don\\'t depends on each other. Suppose\\nwe fix a topological order on the classes (one senario is, your academic advisor gives you the dependencies of the classes and a toplogical order and insists that you must follow this topological order. Luckily, I don\\'t have an advisor like that.) Then, the greedy algorithm listed above works. \\n\\nBut the problem is, given a directed acyclic graph `G`, there are tons of topological orders on it. If we are free to take as many classes as we wish, then any topological order + greedy gives an optimal solution, and this problem is reduced to https://leetcode.com/problems/parallel-courses/\\nGiven the constrain that we can take at most `k` classes per semester, we are left with very little choices other than having to enumerate through all the topological orders, make a greedy schedule for each of them and decide which one yields a global optimal solution. \\n\\nWe use of bitmask and dynamic programming to enumerate through all topological orders. \\nLet `S` be a subset of all classes. We solve the subproblem\\n* Find the optimal schedule for `S` with the same constrain \\n\\nThis is equivalent to ask\\n* What is a topological order on `S` such that the greedy alogrithm gives an optimal solution\\n\\nThink about how Bellman-Held-Karp solves the TSP. \\n\\nLet `C(S)` denote the optimal solution on `S` and `C(S, i)` denote the optimal solution on `S` for any topological order on `S` ends in `i`. \\nThen we have\\n```\\nC(S) = min {\\n\\tC(S, i) for i in S such that i has no out-going edges in S\\n}\\n```\\nThe pathological case is that `S` does not contain all dependencies of `i` imposed by the original \\nproblem. In that case we say \\n```\\nC(S, i) = infinity\\n```\\n\\nTo make it possible to relate to subproblems, we need to cache the classes we take in the last semester following the greedy strategy imposed on the optimal topological order represented by `C(S, i)`. Denote it by `last_batch(S, i)`.\\n\\nThen we can use the following update rule to compute `C(S, i)`\\n\\n```\\nfor j in S - {i} such that j has no outging edges\\n\\t// i.e. no class in j S-{i} depends on j\\n\\tlast_semester <- last_batch(S - {i}, j)\\n\\tif |last_semester | < k and i does not depend on any class in last_semester:\\n\\t\\tif C(S, i) > C(S - {i}, j)\\n\\t\\t\\tlast_batch(S, i) = last_semester + [i]\\n\\t\\t\\tC(S, i) = C(S - {i}, j)\\n\\telse\\n\\t\\tif C(S, i) > C(S - {i} , j ) + 1\\n\\t\\t\\t// then create another semester on top of the existing \\n\\t\\t\\t// optimal strategy of C(S - {i}, j)\\n\\t\\t\\tlast_batch(S, i) = [i]\\n\\t\\t\\tC(S, i) = C(S - {i}, j) + 1 \\n```\\n\\nThe following python code using top-down dynamic programming and momoization to implement the above idea\\n\\n```\\n# helper functions for bit manipulation\\ndef setbit(mask, i):\\n    # turn on i-th bit if it is not there\\n    if mask & (1 << i):\\n        return mask\\n    else:\\n        return mask | (1 << i)\\n    \\ndef unsetbit(mask, i):\\n    # turn off the i-th bit if it is on\\n    if mask & (1 << i):\\n        return mask ^ (1 << i)\\n    else:\\n        return mask\\n    \\ndef hasbit(mask, i):\\n    return mask & (1<<i)\\n    \\ndef count_bits(n):\\n    cnt = 0\\n    while n:\\n        cnt += n&1\\n        n>>=1\\n    return cnt\\n\\n# main function\\ndef optimal_schedule(n, dependencies, k):\\n    \"\"\"top-down dp\"\"\"\\n    # build a graph of courses and use 0-index for \\n    # each course (since we will need shift bit with the course number\\n    # for each course, compute its dependencies\\n    adj, dep, outgoing = defaultdict(list), defaultdict(int), defaultdict(int)\\n    \\n    for x, y in dependencies:\\n        # adj list\\n        adj[x-1].append(y-1)\\n        \\n        # courses y-1 depends on\\n        dep[y-1] = setbit(dep[y-1], x-1)\\n        \\n        # course depends on x-1\\n        outgoing[x-1] = setbit(outgoing[x-1], y-1)\\n        \\n            \\n    # cache C(S, i)\\n    dp = {}\\n\\n    def helper(S, i):\\n        \"\"\"Solve the subproblem C(S, i)\"\"\"\\n        if (S, i) in dp:\\n            return dp[S, i]\\n        \\n        if unsetbit(S, i)==0:\\n            # fuck this bug\\n            #dp[S, i] = (S, i)\\n            \\n            dp[S, i] = (S, 1)\\n            return dp[S, i]\\n      \\n        \\n        submask = unsetbit(S, i)\\n        dp[S, i] = (None, float(\\'inf\\'))\\n        \\n        for j in range(n):\\n            # if j is present in submask \\n            # and j has no outgoing edge in submask\\n    \\n            if dep[j]&submask==dep[j] and hasbit(submask, j) and outgoing[j]&submask==0:\\n                last_batch, time = helper(submask, j)\\n\\n                # if last_batch has no dependencies of i\\n                # and last_batch still have room to fit i\\n                if last_batch&dep[i] == 0 and count_bits(last_batch) < k:\\n                    if dp[S, i][1] > time:\\n                        dp[S, i] = (setbit(last_batch, i), time)\\n                else:\\n                    if dp[S, i][1] > time + 1:\\n                        dp[S, i] = (setbit(0, i), time+1)\\n              \\n        return dp[S, i]\\n    \\n    full_mask = (1<<n) - 1\\n    ans = float(\\'inf\\')\\n    best_last = None\\n    for last in range(n):\\n\\t\\tif outgoing[last]&full_mask==0:\\n            if helper(full_mask, last)[1] < ans:\\n                ans = helper(full_mask, last)[1]\\n                best_last = last\\n            \\n    return ans\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nC(S) = min {\\n\\tC(S, i) for i in S such that i has no out-going edges in S\\n}\\n```\n```\\nC(S, i) = infinity\\n```\n```\\nfor j in S - {i} such that j has no outging edges\\n\\t// i.e. no class in j S-{i} depends on j\\n\\tlast_semester <- last_batch(S - {i}, j)\\n\\tif |last_semester | < k and i does not depend on any class in last_semester:\\n\\t\\tif C(S, i) > C(S - {i}, j)\\n\\t\\t\\tlast_batch(S, i) = last_semester + [i]\\n\\t\\t\\tC(S, i) = C(S - {i}, j)\\n\\telse\\n\\t\\tif C(S, i) > C(S - {i} , j ) + 1\\n\\t\\t\\t// then create another semester on top of the existing \\n\\t\\t\\t// optimal strategy of C(S - {i}, j)\\n\\t\\t\\tlast_batch(S, i) = [i]\\n\\t\\t\\tC(S, i) = C(S - {i}, j) + 1 \\n```\n```\\n# helper functions for bit manipulation\\ndef setbit(mask, i):\\n    # turn on i-th bit if it is not there\\n    if mask & (1 << i):\\n        return mask\\n    else:\\n        return mask | (1 << i)\\n    \\ndef unsetbit(mask, i):\\n    # turn off the i-th bit if it is on\\n    if mask & (1 << i):\\n        return mask ^ (1 << i)\\n    else:\\n        return mask\\n    \\ndef hasbit(mask, i):\\n    return mask & (1<<i)\\n    \\ndef count_bits(n):\\n    cnt = 0\\n    while n:\\n        cnt += n&1\\n        n>>=1\\n    return cnt\\n\\n# main function\\ndef optimal_schedule(n, dependencies, k):\\n    \"\"\"top-down dp\"\"\"\\n    # build a graph of courses and use 0-index for \\n    # each course (since we will need shift bit with the course number\\n    # for each course, compute its dependencies\\n    adj, dep, outgoing = defaultdict(list), defaultdict(int), defaultdict(int)\\n    \\n    for x, y in dependencies:\\n        # adj list\\n        adj[x-1].append(y-1)\\n        \\n        # courses y-1 depends on\\n        dep[y-1] = setbit(dep[y-1], x-1)\\n        \\n        # course depends on x-1\\n        outgoing[x-1] = setbit(outgoing[x-1], y-1)\\n        \\n            \\n    # cache C(S, i)\\n    dp = {}\\n\\n    def helper(S, i):\\n        \"\"\"Solve the subproblem C(S, i)\"\"\"\\n        if (S, i) in dp:\\n            return dp[S, i]\\n        \\n        if unsetbit(S, i)==0:\\n            # fuck this bug\\n            #dp[S, i] = (S, i)\\n            \\n            dp[S, i] = (S, 1)\\n            return dp[S, i]\\n      \\n        \\n        submask = unsetbit(S, i)\\n        dp[S, i] = (None, float(\\'inf\\'))\\n        \\n        for j in range(n):\\n            # if j is present in submask \\n            # and j has no outgoing edge in submask\\n    \\n            if dep[j]&submask==dep[j] and hasbit(submask, j) and outgoing[j]&submask==0:\\n                last_batch, time = helper(submask, j)\\n\\n                # if last_batch has no dependencies of i\\n                # and last_batch still have room to fit i\\n                if last_batch&dep[i] == 0 and count_bits(last_batch) < k:\\n                    if dp[S, i][1] > time:\\n                        dp[S, i] = (setbit(last_batch, i), time)\\n                else:\\n                    if dp[S, i][1] > time + 1:\\n                        dp[S, i] = (setbit(0, i), time+1)\\n              \\n        return dp[S, i]\\n    \\n    full_mask = (1<<n) - 1\\n    ans = float(\\'inf\\')\\n    best_last = None\\n    for last in range(n):\\n\\t\\tif outgoing[last]&full_mask==0:\\n            if helper(full_mask, last)[1] < ans:\\n                ans = helper(full_mask, last)[1]\\n                best_last = last\\n            \\n    return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 708493,
                "title": "python-topological-sort-bitmask-dp-o-2-n-c-n-k-n",
                "content": "1. Use topological sort to compute transitive closures of the courses\\' prerequisites and store them in the form of prerequisite bitmasks: ith bit means whether course i must be taken before. \\n2. Solve the problem by top-down bitmask DP, where ith bit of the state bitmask indicates whether course i has been taken. \\n    1. Read out the available courses that are not taken yet by comparing the state bitmask with the precomputed prerequisite bitmasks (`masks[i] & mask == masks[i]`).\\n    2. If the number of available courses <= k, take all of them. Otherwise, use `itertools.combinations(avail, k)` to iterate through all the possible combinations.\\n    3. Return 0 for the base case `dp(2 ** n - 1)`\\n\\nTime complexity: O(2 ^ n * C(n, k) * n) since there are 2 ^ n possible states, and for each state the upper bound of the time complexity is C(n, k) * n where C is the binomial coefficient (`math.comb(n, k)` in Python 3.8). This is probably a loose bound since only the time complexity of `dp(0)` may reach C(n, k) * n, and as long as n is less than the number of bits of Python\\'s internal integer type we can practically ignore the factor of n.\\n\\n```\\nclass Solution:\\n    def minNumberOfSemesters(self, n: int, dependencies: List[List[int]], k: int) -> int:\\n        backward = {i: set() for i in range(n)}\\n        forward = {i: set() for i in range(n)}\\n        avail = set(range(n))\\n        for pre, post in dependencies:\\n            pre -= 1\\n            post -= 1\\n            backward[post].add(pre)\\n            forward[pre].add(post)\\n            avail.discard(post)\\n        masks = [0] * n\\n        while avail:\\n            new_avail = set()\\n            for i in avail:\\n                for f in forward[i]:\\n                    masks[f] |= masks[i]\\n                    masks[f] |= 2 ** i\\n                    backward[f].remove(i)\\n                    if not backward[f]:\\n                        new_avail.add(f)\\n            avail = new_avail\\n\\n        @functools.lru_cache(None)\\n        def dp(mask):\\n            if mask == 2 ** n - 1:\\n                return 0\\n            avail = {i for i in range(n) if (not 2 ** i & mask) and masks[i] & mask == masks[i]}\\n            if len(avail) <= k:\\n                for i in avail:\\n                    mask |= 2 ** i\\n                return 1 + dp(mask)\\n            ans = math.inf\\n            for comb in itertools.combinations(avail, k):\\n                diff = sum(2 ** i for i in comb)\\n                ans = min(ans, 1 + dp(mask | diff))\\n            return ans\\n            \\n        return dp(0)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def minNumberOfSemesters(self, n: int, dependencies: List[List[int]], k: int) -> int:\\n        backward = {i: set() for i in range(n)}\\n        forward = {i: set() for i in range(n)}\\n        avail = set(range(n))\\n        for pre, post in dependencies:\\n            pre -= 1\\n            post -= 1\\n            backward[post].add(pre)\\n            forward[pre].add(post)\\n            avail.discard(post)\\n        masks = [0] * n\\n        while avail:\\n            new_avail = set()\\n            for i in avail:\\n                for f in forward[i]:\\n                    masks[f] |= masks[i]\\n                    masks[f] |= 2 ** i\\n                    backward[f].remove(i)\\n                    if not backward[f]:\\n                        new_avail.add(f)\\n            avail = new_avail\\n\\n        @functools.lru_cache(None)\\n        def dp(mask):\\n            if mask == 2 ** n - 1:\\n                return 0\\n            avail = {i for i in range(n) if (not 2 ** i & mask) and masks[i] & mask == masks[i]}\\n            if len(avail) <= k:\\n                for i in avail:\\n                    mask |= 2 ** i\\n                return 1 + dp(mask)\\n            ans = math.inf\\n            for comb in itertools.combinations(avail, k):\\n                diff = sum(2 ** i for i in comb)\\n                ans = min(ans, 1 + dp(mask | diff))\\n            return ans\\n            \\n        return dp(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 708434,
                "title": "2-ms-java-topological-sort",
                "content": "```\\n\\tpublic int minNumberOfSemesters(int n, int[][] dependencies, int k) {\\n        // classes are 1 based.\\n        int[] indegree = new int[n + 1];\\n        HashMap<Integer, List<Integer>> graph = new HashMap<Integer, List<Integer>>();\\n        for(int[] pair : dependencies){\\n            int one = pair[0];\\n            int two = pair[1];\\n            if(graph.containsKey(one)) graph.get(one).add(two);\\n            else{\\n                List<Integer> post = new ArrayList<Integer>();\\n                post.add(two);\\n                graph.put(one, post);\\n            }\\n            indegree[two] ++;\\n        }\\n        \\n        List<Integer> list = new ArrayList<Integer>();\\n        for(int i = 1; i <= n; i++){\\n            if(indegree[i] == 0) list.add(i);\\n        }\\n        int count = 0;\\n        while(!list.isEmpty()){\\n            // courses that I am going to take this semester.\\n            int size = Math.min(list.size(), k);\\n            list = sorted(list, indegree, graph);\\n            for(int t = 0; t < size; t++){\\n                int pre = list.remove(0);\\n                if(graph.containsKey(pre)){\\n                    for(int post : graph.get(pre)){\\n                        indegree[post] --;\\n                        if(indegree[post] == 0) list.add(post);\\n                    }\\n                }\\n            }\\n            count ++;\\n        }\\n        return count;\\n    }\\n\\t\\n\\tList<Integer> sorted(List<Integer> list, int[] indegree, HashMap<Integer, List<Integer>> graph){\\n        int[] far = new int[indegree.length];\\n        for(int i : list){\\n            int min = indegree.length;\\n            if(graph.containsKey(i)){\\n                for(int j : graph.get(i)){\\n                    min = Math.min(min, indegree[j]);\\n                }\\n            }\\n            far[i] = min;\\n        }\\n        Collections.sort(list, (a, b) -> far[a] - far[b]);\\n        return list;\\n    }",
                "solutionTags": [],
                "code": "```\\n\\tpublic int minNumberOfSemesters(int n, int[][] dependencies, int k) {\\n        // classes are 1 based.\\n        int[] indegree = new int[n + 1];\\n        HashMap<Integer, List<Integer>> graph = new HashMap<Integer, List<Integer>>();\\n        for(int[] pair : dependencies){\\n            int one = pair[0];\\n            int two = pair[1];\\n            if(graph.containsKey(one)) graph.get(one).add(two);\\n            else{\\n                List<Integer> post = new ArrayList<Integer>();\\n                post.add(two);\\n                graph.put(one, post);\\n            }\\n            indegree[two] ++;\\n        }\\n        \\n        List<Integer> list = new ArrayList<Integer>();\\n        for(int i = 1; i <= n; i++){\\n            if(indegree[i] == 0) list.add(i);\\n        }\\n        int count = 0;\\n        while(!list.isEmpty()){\\n            // courses that I am going to take this semester.\\n            int size = Math.min(list.size(), k);\\n            list = sorted(list, indegree, graph);\\n            for(int t = 0; t < size; t++){\\n                int pre = list.remove(0);\\n                if(graph.containsKey(pre)){\\n                    for(int post : graph.get(pre)){\\n                        indegree[post] --;\\n                        if(indegree[post] == 0) list.add(post);\\n                    }\\n                }\\n            }\\n            count ++;\\n        }\\n        return count;\\n    }\\n\\t\\n\\tList<Integer> sorted(List<Integer> list, int[] indegree, HashMap<Integer, List<Integer>> graph){\\n        int[] far = new int[indegree.length];\\n        for(int i : list){\\n            int min = indegree.length;\\n            if(graph.containsKey(i)){\\n                for(int j : graph.get(i)){\\n                    min = Math.min(min, indegree[j]);\\n                }\\n            }\\n            far[i] = min;\\n        }\\n        Collections.sort(list, (a, b) -> far[a] - far[b]);\\n        return list;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 708376,
                "title": "java-bitmask-method",
                "content": "There are at most `15` nodes, so we can use bitmask solution. It has `2 ^ 15` states, where `i`-th bit means `i`-th node is still active. We can calculate solution for each state.\\nTake a look at given state `graph`. If it has fewer or equal than `k` nodes, we can take all. Otherwise we should take only `k` of them.\\nFor more explanation take a look at the code below:\\n\\n```\\nclass Solution {\\n    public int minNumberOfSemesters(int n, int[][] dependencies, int k) {\\n        int size = (1 << n);\\n        int[] dp = new int[size];\\n        \\n        for (int graph = 1; graph < size; graph++) {\\n            Set<Integer> nodes = new HashSet<>();\\n            for (int j = 0; (1 << j) <= graph; j++) {\\n                if ((graph & (1 << j)) != 0) {\\n                    nodes.add(j);\\n                }\\n            }\\n            \\n            Set<Integer> opened = new HashSet<>(nodes);\\n            for (int[] edge : dependencies) {\\n                if (nodes.contains(edge[1] - 1) && nodes.contains(edge[0] - 1)) {\\n                    opened.remove(edge[1] - 1);\\n                }\\n            }\\n            \\n            if (opened.size() <= k) {\\n                int sum = 0;\\n                \\n                for (int node : opened) {\\n                    sum ^= (1 << node);\\n                }\\n                \\n                dp[graph] = dp[graph ^ sum] + 1;\\n            } else {\\n                dp[graph] = Integer.MAX_VALUE;\\n                Set<Integer> sums = new HashSet<>();\\n                permutations(new ArrayList<>(opened), k, 0, 0, sums);\\n                \\n                for (int sum : sums) {\\n                    dp[graph] = Math.min(dp[graph], dp[graph ^ sum] + 1);\\n                }\\n            }\\n        }\\n        \\n        return dp[size - 1];\\n    }\\n    \\n    private void permutations(List<Integer> nums, int k, int startPosition, int total, Set<Integer> result){\\n        if (k == 0){\\n            result.add(total);\\n            return;\\n        }       \\n        for (int i = startPosition; i <= nums.size() - k; i++){;\\n            permutations(nums, k-1, i+1, total ^ (1 << nums.get(i)), result);\\n        }\\n    }  \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minNumberOfSemesters(int n, int[][] dependencies, int k) {\\n        int size = (1 << n);\\n        int[] dp = new int[size];\\n        \\n        for (int graph = 1; graph < size; graph++) {\\n            Set<Integer> nodes = new HashSet<>();\\n            for (int j = 0; (1 << j) <= graph; j++) {\\n                if ((graph & (1 << j)) != 0) {\\n                    nodes.add(j);\\n                }\\n            }\\n            \\n            Set<Integer> opened = new HashSet<>(nodes);\\n            for (int[] edge : dependencies) {\\n                if (nodes.contains(edge[1] - 1) && nodes.contains(edge[0] - 1)) {\\n                    opened.remove(edge[1] - 1);\\n                }\\n            }\\n            \\n            if (opened.size() <= k) {\\n                int sum = 0;\\n                \\n                for (int node : opened) {\\n                    sum ^= (1 << node);\\n                }\\n                \\n                dp[graph] = dp[graph ^ sum] + 1;\\n            } else {\\n                dp[graph] = Integer.MAX_VALUE;\\n                Set<Integer> sums = new HashSet<>();\\n                permutations(new ArrayList<>(opened), k, 0, 0, sums);\\n                \\n                for (int sum : sums) {\\n                    dp[graph] = Math.min(dp[graph], dp[graph ^ sum] + 1);\\n                }\\n            }\\n        }\\n        \\n        return dp[size - 1];\\n    }\\n    \\n    private void permutations(List<Integer> nums, int k, int startPosition, int total, Set<Integer> result){\\n        if (k == 0){\\n            result.add(total);\\n            return;\\n        }       \\n        for (int i = startPosition; i <= nums.size() - k; i++){;\\n            permutations(nums, k-1, i+1, total ^ (1 << nums.get(i)), result);\\n        }\\n    }  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 708111,
                "title": "python-priority-queue-topological-sort",
                "content": "Only two cases will require you to take one more semester\\n1. all courses without prerequisite has been taken \\n2. you don\\'t have enough credits for the current semester\\n\\nTo deal with 1:\\n- we will use topological sort\\n- course with no prerequisite will be put to the queue (in degree = 0 in this case)\\n- after clearing the queue, we will know we are done with the semester\\n- while taking the course, we will also update the new indegree of each courses in order to know what courses are available for the coming semesters\\n- so we also maintain a queue called next_sem in order to account with courses available for the next sem\\n\\nTo deal with 2:\\n- when the credit reach the limit\\n- we have to study the course in the coming semesters\\n- in order to get the minimum number of semesters required, we will always take the course which \"unlock\" the most of the courses\\n- in this case, we will maintain a heap / priority queue to retrieve the course with greater outdegree\\n- so basically just replacing the ordanary queue to a priority queue will do the problem\\n\\n\\nBelow is my program\\n```\\nclass Solution(object):\\n    def minNumberOfSemesters(self, n, dependencies, k):\\n        indegree = {i:0 for i in range(1, n + 1)}\\n        outdegree = collections.defaultdict(list)\\n        \\n        for dependency in dependencies:\\n            a, b = dependency\\n            outdegree[a].append(b)\\n            indegree[b] += 1\\n            \\n        curr_sem = []\\n\\n        for node in indegree:\\n            if indegree[node] == 0:\\n                curr_sem.append((-len(outdegree[node]), node))\\n        \\n        heapq.heapify(curr_sem)\\n        \\n        next_sem = []\\n        curr_sem_count = 0\\n        total = 0\\n        while(curr_sem):\\n            _, curr = heapq.heappop(curr_sem) # getting the one with greatest outdegree first\\n            curr_sem_count += 1\\n            \\n            if curr_sem_count > k: # exceed quota for current semester\\n                curr_sem_count = 1\\n                total += 1\\n                while(next_sem): # semester has refreshed, push to the current queue\\n                    elem = heapq.heappop(next_sem)\\n                    heapq.heappush(curr_sem, elem)\\n                \\n            for node in outdegree[curr]:\\n                indegree[node] -= 1\\n                if indegree[node] == 0: # the dependency has been cleared, can add from the next semester\\n                    heapq.heappush(next_sem, (-len(outdegree[node]), node))\\n            \\n            if len(curr_sem) == 0: # semester has been refreshed(all available couses has been taken)\\n                total += 1\\n                curr_sem_count = 0\\n                next_sem, curr_sem = curr_sem, next_sem # swap the queue\\n        return total\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minNumberOfSemesters(self, n, dependencies, k):\\n        indegree = {i:0 for i in range(1, n + 1)}\\n        outdegree = collections.defaultdict(list)\\n        \\n        for dependency in dependencies:\\n            a, b = dependency\\n            outdegree[a].append(b)\\n            indegree[b] += 1\\n            \\n        curr_sem = []\\n\\n        for node in indegree:\\n            if indegree[node] == 0:\\n                curr_sem.append((-len(outdegree[node]), node))\\n        \\n        heapq.heapify(curr_sem)\\n        \\n        next_sem = []\\n        curr_sem_count = 0\\n        total = 0\\n        while(curr_sem):\\n            _, curr = heapq.heappop(curr_sem) # getting the one with greatest outdegree first\\n            curr_sem_count += 1\\n            \\n            if curr_sem_count > k: # exceed quota for current semester\\n                curr_sem_count = 1\\n                total += 1\\n                while(next_sem): # semester has refreshed, push to the current queue\\n                    elem = heapq.heappop(next_sem)\\n                    heapq.heappush(curr_sem, elem)\\n                \\n            for node in outdegree[curr]:\\n                indegree[node] -= 1\\n                if indegree[node] == 0: # the dependency has been cleared, can add from the next semester\\n                    heapq.heappush(next_sem, (-len(outdegree[node]), node))\\n            \\n            if len(curr_sem) == 0: # semester has been refreshed(all available couses has been taken)\\n                total += 1\\n                curr_sem_count = 0\\n                next_sem, curr_sem = curr_sem, next_sem # swap the queue\\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3762515,
                "title": "dp-bits-manipulation-topological-sort-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will use n bits number to determine whether ith bit is available or not\\n0 -> not available(already used)\\n1 ->  available irresepective of indegree\\nwe use only those nodes which are available and have indegree equal to 0. \\n\\nIf those number of nodes are less or equal to k we will use all of them simultaneously and if these nodes are more than k at a time we will check all possibilty of creating only k nodes at a time and this can be implemented by creating another mask.\\n\\nSee the solution down below for better understanding.\\nThank You. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    vector<vector<int>> graph;\\n    vector<int> indegree;\\n    vector<int> dp;\\npublic:\\n    int solve(const int n,const int k,int subset)\\n    {\\n        if(subset == 0) return 0;\\n        if(dp[subset] != -1) return dp[subset];\\n        vector<int> v;\\n        for(int i = 0 ; i < n ; ++i)\\n            if(indegree[i] == 0 and (subset&(1<<i))) v.push_back(i);\\n        int m = v.size();\\n        int ans(1e9);\\n        if(m <= k)\\n        {\\n            int mask = subset;\\n            for(int &x : v)\\n            {\\n                mask ^= (1<<x);\\n                for(int &child : graph[x])\\n                    --indegree[child];\\n            }\\n            ans = 1 + solve(n,k,mask);\\n            for(int &x : v)\\n                for(int &child : graph[x])\\n                    ++indegree[child];\\n        }\\n        else\\n        {\\n            int N = (1<<m);\\n            for(int mask = 0 ; mask < N ; ++mask)\\n            {\\n                if(__builtin_popcount(mask) != k) continue;\\n                int mask2 = subset;\\n                for(int i = 0 ; i < m ; ++i)\\n                {\\n                    if((1<<i)&mask)\\n                    {\\n                        mask2 ^= (1<<v[i]);\\n                        for(int &child : graph[v[i]])\\n                            --indegree[child];\\n                    }\\n                }\\n                int op = 1 + solve(n,k,mask2);\\n                ans = min(ans,op);\\n                for(int i = 0 ; i < m ; ++i)\\n                {\\n                    if((1<<i)&mask)\\n                        for(int &child : graph[v[i]])\\n                            ++indegree[child];\\n                }\\n            }\\n        }\\n        return dp[subset] = ans;\\n    }\\n    int minNumberOfSemesters(int n, vector<vector<int>>& relations, int k) {\\n        graph = vector<vector<int>>(n,vector<int>());\\n        indegree = vector<int>(n,0);\\n        for(auto &x : relations)\\n        {\\n            graph[x[0]-1].push_back(x[1]-1);\\n            ++indegree[x[1]-1];\\n        }\\n        int N = (1<<n)-1;\\n        dp = vector<int>(N+1,-1);\\n        return solve(n,k,N);   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Bit Manipulation",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    vector<vector<int>> graph;\\n    vector<int> indegree;\\n    vector<int> dp;\\npublic:\\n    int solve(const int n,const int k,int subset)\\n    {\\n        if(subset == 0) return 0;\\n        if(dp[subset] != -1) return dp[subset];\\n        vector<int> v;\\n        for(int i = 0 ; i < n ; ++i)\\n            if(indegree[i] == 0 and (subset&(1<<i))) v.push_back(i);\\n        int m = v.size();\\n        int ans(1e9);\\n        if(m <= k)\\n        {\\n            int mask = subset;\\n            for(int &x : v)\\n            {\\n                mask ^= (1<<x);\\n                for(int &child : graph[x])\\n                    --indegree[child];\\n            }\\n            ans = 1 + solve(n,k,mask);\\n            for(int &x : v)\\n                for(int &child : graph[x])\\n                    ++indegree[child];\\n        }\\n        else\\n        {\\n            int N = (1<<m);\\n            for(int mask = 0 ; mask < N ; ++mask)\\n            {\\n                if(__builtin_popcount(mask) != k) continue;\\n                int mask2 = subset;\\n                for(int i = 0 ; i < m ; ++i)\\n                {\\n                    if((1<<i)&mask)\\n                    {\\n                        mask2 ^= (1<<v[i]);\\n                        for(int &child : graph[v[i]])\\n                            --indegree[child];\\n                    }\\n                }\\n                int op = 1 + solve(n,k,mask2);\\n                ans = min(ans,op);\\n                for(int i = 0 ; i < m ; ++i)\\n                {\\n                    if((1<<i)&mask)\\n                        for(int &child : graph[v[i]])\\n                            ++indegree[child];\\n                }\\n            }\\n        }\\n        return dp[subset] = ans;\\n    }\\n    int minNumberOfSemesters(int n, vector<vector<int>>& relations, int k) {\\n        graph = vector<vector<int>>(n,vector<int>());\\n        indegree = vector<int>(n,0);\\n        for(auto &x : relations)\\n        {\\n            graph[x[0]-1].push_back(x[1]-1);\\n            ++indegree[x[1]-1];\\n        }\\n        int N = (1<<n)-1;\\n        dp = vector<int>(N+1,-1);\\n        return solve(n,k,N);   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3136600,
                "title": "c-top-down-dp-bitmasking-backtracking-great-question",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    map<int, vector<int>> G;\\n    int dp[100000];\\n    int solve(int mask, vector<int> &degree, int &n, int &k) {\\n        if(mask == ((1 << n) - 1)) {\\n            return 0;\\n        }\\n        // cout << \"mask = \" << mask << endl;\\n        if(dp[mask] != -1) {\\n            return dp[mask];\\n        }\\n        int ans = n + 1;\\n        vector<int> allowedCourses;\\n        for(int i = 0; i < n; i++) {\\n            if(degree[i] == 0 && (mask & (1 << i)) == 0) {\\n                allowedCourses.push_back(i);\\n                // cout << i << \" \"; \\n            }\\n        }\\n        // cout << endl;\\n        if(allowedCourses.size() <= k) {\\n            int newMask = mask;\\n            for(int i = 0; i < allowedCourses.size(); i++) {\\n                newMask = (newMask | (1 << allowedCourses[i]));\\n                for(int child : G[allowedCourses[i]]) {\\n                    degree[child]--;\\n                }\\n            }\\n            ans = min(ans, 1 + solve(newMask, degree, n, k));\\n            for(int i = 0; i < allowedCourses.size(); i++) {\\n                for(int child : G[allowedCourses[i]]) {\\n                    degree[child]++;\\n                }\\n            }\\n        } else {\\n            int sz = allowedCourses.size();\\n            for(int bit = 0; bit < (1 << sz); bit++) {\\n                if(__builtin_popcount(bit) == k) {\\n                    // cout << \"bit = \" << bit << endl;\\n                    int newMask = mask;\\n                    bool invalid = false;\\n                    for(int i = 0; i < sz; i++) {\\n                        if((bit & (1 << i)) && (mask & (1 << allowedCourses[i]))) {\\n                            invalid = true;\\n                            break;\\n                        }\\n                    }\\n                    if(invalid) {\\n                        continue;\\n                    }\\n                    for(int i = 0; i < sz; i++) {\\n                        if(bit & (1 << i)) {\\n                            newMask = (newMask | (1 << allowedCourses[i]));\\n                            for(int child : G[allowedCourses[i]]) {\\n                                degree[child]--;\\n                            }\\n                        }\\n                    }\\n                    ans = min(ans, 1 + solve(newMask, degree, n, k));\\n                    for(int i = 0; i < sz; i++) {\\n                        if((bit & (1 << i))) {\\n                            for(int child : G[allowedCourses[i]]) {\\n                                degree[child]++;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[mask] = ans;\\n    }\\n\\n    int minNumberOfSemesters(int n, vector<vector<int>>& relations, int k) {\\n        memset(dp, -1, sizeof(dp));\\n        vector<int> indegree(n, 0);\\n        for(auto e : relations) {\\n            G[e[0] - 1].push_back(e[1] - 1);\\n            indegree[e[1] - 1]++;\\n        }\\n        return solve(0, indegree, n, k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int, vector<int>> G;\\n    int dp[100000];\\n    int solve(int mask, vector<int> &degree, int &n, int &k) {\\n        if(mask == ((1 << n) - 1)) {\\n            return 0;\\n        }\\n        // cout << \"mask = \" << mask << endl;\\n        if(dp[mask] != -1) {\\n            return dp[mask];\\n        }\\n        int ans = n + 1;\\n        vector<int> allowedCourses;\\n        for(int i = 0; i < n; i++) {\\n            if(degree[i] == 0 && (mask & (1 << i)) == 0) {\\n                allowedCourses.push_back(i);\\n                // cout << i << \" \"; \\n            }\\n        }\\n        // cout << endl;\\n        if(allowedCourses.size() <= k) {\\n            int newMask = mask;\\n            for(int i = 0; i < allowedCourses.size(); i++) {\\n                newMask = (newMask | (1 << allowedCourses[i]));\\n                for(int child : G[allowedCourses[i]]) {\\n                    degree[child]--;\\n                }\\n            }\\n            ans = min(ans, 1 + solve(newMask, degree, n, k));\\n            for(int i = 0; i < allowedCourses.size(); i++) {\\n                for(int child : G[allowedCourses[i]]) {\\n                    degree[child]++;\\n                }\\n            }\\n        } else {\\n            int sz = allowedCourses.size();\\n            for(int bit = 0; bit < (1 << sz); bit++) {\\n                if(__builtin_popcount(bit) == k) {\\n                    // cout << \"bit = \" << bit << endl;\\n                    int newMask = mask;\\n                    bool invalid = false;\\n                    for(int i = 0; i < sz; i++) {\\n                        if((bit & (1 << i)) && (mask & (1 << allowedCourses[i]))) {\\n                            invalid = true;\\n                            break;\\n                        }\\n                    }\\n                    if(invalid) {\\n                        continue;\\n                    }\\n                    for(int i = 0; i < sz; i++) {\\n                        if(bit & (1 << i)) {\\n                            newMask = (newMask | (1 << allowedCourses[i]));\\n                            for(int child : G[allowedCourses[i]]) {\\n                                degree[child]--;\\n                            }\\n                        }\\n                    }\\n                    ans = min(ans, 1 + solve(newMask, degree, n, k));\\n                    for(int i = 0; i < sz; i++) {\\n                        if((bit & (1 << i))) {\\n                            for(int child : G[allowedCourses[i]]) {\\n                                degree[child]++;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[mask] = ans;\\n    }\\n\\n    int minNumberOfSemesters(int n, vector<vector<int>>& relations, int k) {\\n        memset(dp, -1, sizeof(dp));\\n        vector<int> indegree(n, 0);\\n        for(auto e : relations) {\\n            G[e[0] - 1].push_back(e[1] - 1);\\n            indegree[e[1] - 1]++;\\n        }\\n        return solve(0, indegree, n, k);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2694443,
                "title": "python-dfs-top-down-try-all-combinations-of-available-courses-in-current-semester-recuresively",
                "content": "```\\nclass Solution:\\n    def minNumberOfSemesters(self, n: int, relations: List[List[int]], k: int) -> int:\\n        self.k, self.n, self.adj, indegrees = k, n, defaultdict(list), [0] * n\\n        for u,v in relations:\\n            self.adj[u-1].append(v-1)\\n            indegrees[v-1] += 1\\n        mask = (1 << self.n) - 1 # 1(set-bit) means NOT-Taken, so initially all 0 to (n-1) nodes are 1 \\n        return self.dfs(mask, tuple(indegrees))\\n    \\n    @lru_cache(None)\\n    def dfs(self, bitmask, indegrees):\\n        if not bitmask: return 0 # means all courses have been taken - Base Case\\n        nodes = [x for x in range(self.n) if bitmask & (1 << x) and indegrees[x] == 0]\\n        ans = math.inf\\n        for courses_taken in combinations(nodes, min(self.k, len(nodes))):\\n            new_bitmask, new_indegrees = bitmask, list(indegrees)\\n            for c in courses_taken:\\n                new_bitmask ^= (1<<c)\\n                for nei in self.adj[c]:\\n                    new_indegrees[nei] -= 1        \\n            ans = min(ans, 1 + self.dfs(new_bitmask, tuple(new_indegrees)))\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minNumberOfSemesters(self, n: int, relations: List[List[int]], k: int) -> int:\\n        self.k, self.n, self.adj, indegrees = k, n, defaultdict(list), [0] * n\\n        for u,v in relations:\\n            self.adj[u-1].append(v-1)\\n            indegrees[v-1] += 1\\n        mask = (1 << self.n) - 1 # 1(set-bit) means NOT-Taken, so initially all 0 to (n-1) nodes are 1 \\n        return self.dfs(mask, tuple(indegrees))\\n    \\n    @lru_cache(None)\\n    def dfs(self, bitmask, indegrees):\\n        if not bitmask: return 0 # means all courses have been taken - Base Case\\n        nodes = [x for x in range(self.n) if bitmask & (1 << x) and indegrees[x] == 0]\\n        ans = math.inf\\n        for courses_taken in combinations(nodes, min(self.k, len(nodes))):\\n            new_bitmask, new_indegrees = bitmask, list(indegrees)\\n            for c in courses_taken:\\n                new_bitmask ^= (1<<c)\\n                for nei in self.adj[c]:\\n                    new_indegrees[nei] -= 1        \\n            ans = min(ans, 1 + self.dfs(new_bitmask, tuple(new_indegrees)))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322782,
                "title": "python-topological-sort-with-top-down-dp-with-bitmask",
                "content": "```\\nclass Solution:\\n    def minNumberOfSemesters(self, n: int, relations: List[List[int]], k: int) -> int:\\n        self.in_degree = [0]*n\\n        d = collections.defaultdict(set)\\n        self.k = k\\n        \\n        for (a,b) in relations:\\n            self.in_degree[b-1] += 1\\n            d[a-1].add(b-1)\\n        \\n        @lru_cache(None)\\n        def backtrack(mask):\\n            if mask == (1 << n) - 1:\\n                return 0\\n            else:\\n                options = []\\n                result = float(\\'inf\\')\\n                for i in range(0, n):\\n                    if (mask >> i) % 2 == 0 and self.in_degree[i] == 0:\\n                        options.append(i)\\n                for subset in itertools.combinations(options, min(len(options), self.k)):\\n                    newmask = mask\\n                    ind = self.in_degree[:]\\n                    for j in subset:\\n                        newmask |= 2**j\\n                        for k in d[j]:\\n                            self.in_degree[k] -= 1\\n                    result = min(result, 1+backtrack(newmask))\\n                    self.in_degree = ind[:]\\n                return result\\n        \\n        return backtrack(0)\\n```\\n\\nUsing a topological sort as a global array, then a bitmask for tracking which of the courses have already been taken versus not. Then doing a Top-Down DP with memoization to determine the minimum number of rounds of courses that you can take.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minNumberOfSemesters(self, n: int, relations: List[List[int]], k: int) -> int:\\n        self.in_degree = [0]*n\\n        d = collections.defaultdict(set)\\n        self.k = k\\n        \\n        for (a,b) in relations:\\n            self.in_degree[b-1] += 1\\n            d[a-1].add(b-1)\\n        \\n        @lru_cache(None)\\n        def backtrack(mask):\\n            if mask == (1 << n) - 1:\\n                return 0\\n            else:\\n                options = []\\n                result = float(\\'inf\\')\\n                for i in range(0, n):\\n                    if (mask >> i) % 2 == 0 and self.in_degree[i] == 0:\\n                        options.append(i)\\n                for subset in itertools.combinations(options, min(len(options), self.k)):\\n                    newmask = mask\\n                    ind = self.in_degree[:]\\n                    for j in subset:\\n                        newmask |= 2**j\\n                        for k in d[j]:\\n                            self.in_degree[k] -= 1\\n                    result = min(result, 1+backtrack(newmask))\\n                    self.in_degree = ind[:]\\n                return result\\n        \\n        return backtrack(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1739740,
                "title": "c-dp-bit-mask-greedy",
                "content": "```\\nclass Solution {\\n    int dp[1<<16];\\n    int dfs(unordered_map<int, int>& c, int mask, int& k, int &n) {\\n        if(dp[mask] != -1) return dp[mask];\\n        int canJoin = 0, canNotJoin = 0;\\n        vector<int> canJoinVec;\\n        for(auto [key, value]: c) {\\n            if(((value & mask) == value) and !(mask & (1<<key))) {\\n            \\t//get course we can listen\\n                canJoin |= 1<<key;\\n                canJoinVec.push_back(key);\\n            } else if(!(mask & (1<<key))) {\\n           \\t\\t//get courses we can not listen yet\\n                canNotJoin |= 1<<key;\\n            }\\n        }\\n        //if there is no course we can not listen calculate immediatly\\n        if(!canNotJoin) {\\n            int left = n - bitset<16>(mask).count();\\n            return dp[mask] = left / k + (left % k ? 1 : 0);\\n        }\\n        //if there is some courses we can listen now (less then k) and can not listen\\n        //select the courses we can listen now first\\n        if(bitset<16>(canJoin).count() <= k) {\\n            int nMask = mask | canJoin;\\n            int left = k - bitset<16>(canJoin).count();\\n            //if there is some extra slots we can listen in this semester\\n\\t        //pick any thing\\n            for(int i = 0; i < n and left; i++) {\\n                if(!(canNotJoin & (1<<i)) and !(nMask & (1<<i))) {\\n                    nMask |= 1<<i; left--;\\n                }\\n            }\\n            return dp[mask] = 1 + dfs(c, nMask, k, n);\\n        }\\n        //if we can listen more then k courses now, pick K courses from list (check every combinations)\\n        //any idea for pick m element from n array?\\n        sort(canJoinVec.begin(), canJoinVec.end());\\n        int mi = INT_MAX;\\n        do {\\n            int nMask = mask;\\n            for(int i = 0; i < k; i++) nMask |= 1<<canJoinVec[i];\\n            mi = min(mi, dfs(c, nMask, k, n));\\n        }while(next_permutation(canJoinVec.begin(), canJoinVec.end()));\\n        return dp[mask] = 1 + mi;\\n    }\\npublic:\\n    int minNumberOfSemesters(int n, vector<vector<int>>& relations, int k) {\\n        unordered_map<int, int> course;\\n        memset(dp, -1, sizeof(dp));\\n        //initialize courses relational graph\\n        for(auto& r : relations) course[r[1]-1] |= 1<<(r[0]-1), course[r[0]-1] += 0;\\n        dp[(1<<n) - 1] = 0;\\n\\n        return dfs(course, 0, k, n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    int dp[1<<16];\\n    int dfs(unordered_map<int, int>& c, int mask, int& k, int &n) {\\n        if(dp[mask] != -1) return dp[mask];\\n        int canJoin = 0, canNotJoin = 0;\\n        vector<int> canJoinVec;\\n        for(auto [key, value]: c) {\\n            if(((value & mask) == value) and !(mask & (1<<key))) {\\n            \\t//get course we can listen\\n                canJoin |= 1<<key;\\n                canJoinVec.push_back(key);\\n            } else if(!(mask & (1<<key))) {\\n           \\t\\t//get courses we can not listen yet\\n                canNotJoin |= 1<<key;\\n            }\\n        }\\n        //if there is no course we can not listen calculate immediatly\\n        if(!canNotJoin) {\\n            int left = n - bitset<16>(mask).count();\\n            return dp[mask] = left / k + (left % k ? 1 : 0);\\n        }\\n        //if there is some courses we can listen now (less then k) and can not listen\\n        //select the courses we can listen now first\\n        if(bitset<16>(canJoin).count() <= k) {\\n            int nMask = mask | canJoin;\\n            int left = k - bitset<16>(canJoin).count();\\n            //if there is some extra slots we can listen in this semester\\n\\t        //pick any thing\\n            for(int i = 0; i < n and left; i++) {\\n                if(!(canNotJoin & (1<<i)) and !(nMask & (1<<i))) {\\n                    nMask |= 1<<i; left--;\\n                }\\n            }\\n            return dp[mask] = 1 + dfs(c, nMask, k, n);\\n        }\\n        //if we can listen more then k courses now, pick K courses from list (check every combinations)\\n        //any idea for pick m element from n array?\\n        sort(canJoinVec.begin(), canJoinVec.end());\\n        int mi = INT_MAX;\\n        do {\\n            int nMask = mask;\\n            for(int i = 0; i < k; i++) nMask |= 1<<canJoinVec[i];\\n            mi = min(mi, dfs(c, nMask, k, n));\\n        }while(next_permutation(canJoinVec.begin(), canJoinVec.end()));\\n        return dp[mask] = 1 + mi;\\n    }\\npublic:\\n    int minNumberOfSemesters(int n, vector<vector<int>>& relations, int k) {\\n        unordered_map<int, int> course;\\n        memset(dp, -1, sizeof(dp));\\n        //initialize courses relational graph\\n        for(auto& r : relations) course[r[1]-1] |= 1<<(r[0]-1), course[r[0]-1] += 0;\\n        dp[(1<<n) - 1] = 0;\\n\\n        return dfs(course, 0, k, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1700928,
                "title": "python-dfs-with-bit-masks",
                "content": "Say dp[i] denotes the minimum number of semesters needed to finish all courses while courses[j] has already finished if ***j***-th bit of ***i*** is 1, namely ***(i >> j) & 1 == 1***. Then the answer for the problem is dp[0].\\nIf course ***j*** not finished, and the prerequisites courses of courses ***j*** have been finished, then course j can be choosed in current semesters. We just traversal all combinations of at most ***k*** courses from all choosable courses, and find the minimum number of semesters needed for ***dp[i]*** = 1 + min(***dp[i ^ com]*** for combination in combinations(chooseable courses, k)).\\n```\\nclass Solution(object):\\n    def minNumberOfSemesters(self, n, relations, k):\\n        \"\"\"\\n        :type n: int\\n        :type relations: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        if k == 1:\\n            return n\\n        if not relations:\\n            return (n + k - 1) // k\\n        precourse = [0] * (n + 1)\\n        for pre, nx in relations:\\n            precourse[nx - 1] |= 1 << (pre - 1)\\n\\n        def dfs(visited):\\n            if visited == (1 << n) - 1:\\n                return 0\\n            if visited not in memo:\\n                choosable = []\\n                res = n\\n                for i in range(n):\\n                    if (visited >> i) & 1 == 0 and precourse[i] & visited == precourse[i]:\\n                        choosable.append(i)\\n                for com in itertools.combinations(choosable, min(len(choosable), k)):\\n                    nx_visited = visited\\n                    for c in com:\\n                        nx_visited |= 1 << c\\n                    res = min(res, dfs(nx_visited) + 1)\\n                memo[visited] = res\\n            return memo[visited]\\n\\n        memo = collections.defaultdict(int)\\n        return dfs(0)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minNumberOfSemesters(self, n, relations, k):\\n        \"\"\"\\n        :type n: int\\n        :type relations: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        if k == 1:\\n            return n\\n        if not relations:\\n            return (n + k - 1) // k\\n        precourse = [0] * (n + 1)\\n        for pre, nx in relations:\\n            precourse[nx - 1] |= 1 << (pre - 1)\\n\\n        def dfs(visited):\\n            if visited == (1 << n) - 1:\\n                return 0\\n            if visited not in memo:\\n                choosable = []\\n                res = n\\n                for i in range(n):\\n                    if (visited >> i) & 1 == 0 and precourse[i] & visited == precourse[i]:\\n                        choosable.append(i)\\n                for com in itertools.combinations(choosable, min(len(choosable), k)):\\n                    nx_visited = visited\\n                    for c in com:\\n                        nx_visited |= 1 << c\\n                    res = min(res, dfs(nx_visited) + 1)\\n                memo[visited] = res\\n            return memo[visited]\\n\\n        memo = collections.defaultdict(int)\\n        return dfs(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513140,
                "title": "c-o-3-n-3state-recursion-memoziation",
                "content": "```\\nclass Solution {\\npublic:\\n     int bit;\\n    unordered_map<int,int> help;\\n    int dp[16][16][65537];\\n    vector<vector<int> > pre;\\n        vector<vector<int> > rel;\\n        vector<int> can_take;\\n    int findans(int k,int bits,int bcha,int n,int sem,int course){\\n        // if we completed all course return\\n        if(n==course){\\n            return 0;\\n        }\\n        if(dp[sem][bcha][bits]!=-1){\\n            return dp[sem][bcha][bits];\\n        }\\n        int ans=n+1,ans1=n+1;\\n        for(int i=1;i<=n;i++){\\n\\t\\t//if dependecies of this course is 0 and we are not taken previous  \\n            if(can_take[i]==0&&(bits&(1<<i))==0){\\n                bool take=true;\\n\\t\\t\\t\\t\\n                for(int j=0;j<pre[i].size();j++){\\n\\t\\t\\t\\t//if we dependcies is 0 but after this semseter because if we compeleted its all dependcies in this term then we cannot take this course\\n                    if(help[pre[i][j]]>=sem){\\n                        take=false;\\n                        break;\\n                    }\\n                }\\n                if(take){\\n                    \\n                    if(course+1==n){\\n                        // cout<<sem<<endl;\\n                        return 0;\\n                    }\\n                    \\n                    int prev=help[i];\\n                    help[i]=sem;\\n                    for(int j=0;j<rel[i].size();j++){\\n                        can_take[rel[i][j]]--;\\n                    }\\n                    if(bcha==1){\\n\\t\\t\\t\\t\\t//if we left one course for this semster then we will take this course and move to next semseter\\n                        ans=min(ans,1+findans(k,(bits|(1<<i)),k,n,sem+1,course+1));\\n                        \\n                    }\\n                    else{\\n                        if(course+1==0){\\n                            return 0;\\n                        }\\n                        \\n                        ans=min(ans,findans(k,(bits|(1<<i)),bcha-1,n,sem,course+1));\\n                        ans1=min(ans1,1+findans(k,(bits|(1<<i)),k,n,sem+1,course+1));\\n                        \\n                    }\\n                    help[i]=prev;\\n                    for(int j=0;j<rel[i].size();j++){\\n                        can_take[rel[i][j]]++;\\n                    }\\n                }\\n            }\\n        }\\n       \\n        return dp[sem][bcha][bits]=min(ans,ans1);\\n        \\n    }\\n    \\n    \\n    int minNumberOfSemesters(int n, vector<vector<int>>& relations, int k) {\\n        pre.resize(n+1);\\n        rel.resize(n+1);\\n        can_take.resize(n+1);\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<16;i++){\\n            help[i]=INT_MAX;\\n        }\\n        bit=pow(2,n);\\n        for(int i=0;i<relations.size();i++){\\n            pre[relations[i][1]].push_back(relations[i][0]);\\n            rel[relations[i][0]].push_back(relations[i][1]);\\n        }\\n        bool find=true;\\n        for(int i=1;i<pre.size();i++){\\n            can_take[i]=pre[i].size();\\n            if(pre[i].size()){\\n                find=false;\\n            }\\n        }\\n        if(find){\\n            return n%k==0?n/k:n/k+1;\\n        }\\n        // int ans=n%k==0?n/k:n/k+1;\\n       return 1+findans(k,0,k,n,1,0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n     int bit;\\n    unordered_map<int,int> help;\\n    int dp[16][16][65537];\\n    vector<vector<int> > pre;\\n        vector<vector<int> > rel;\\n        vector<int> can_take;\\n    int findans(int k,int bits,int bcha,int n,int sem,int course){\\n        // if we completed all course return\\n        if(n==course){\\n            return 0;\\n        }\\n        if(dp[sem][bcha][bits]!=-1){\\n            return dp[sem][bcha][bits];\\n        }\\n        int ans=n+1,ans1=n+1;\\n        for(int i=1;i<=n;i++){\\n\\t\\t//if dependecies of this course is 0 and we are not taken previous  \\n            if(can_take[i]==0&&(bits&(1<<i))==0){\\n                bool take=true;\\n\\t\\t\\t\\t\\n                for(int j=0;j<pre[i].size();j++){\\n\\t\\t\\t\\t//if we dependcies is 0 but after this semseter because if we compeleted its all dependcies in this term then we cannot take this course\\n                    if(help[pre[i][j]]>=sem){\\n                        take=false;\\n                        break;\\n                    }\\n                }\\n                if(take){\\n                    \\n                    if(course+1==n){\\n                        // cout<<sem<<endl;\\n                        return 0;\\n                    }\\n                    \\n                    int prev=help[i];\\n                    help[i]=sem;\\n                    for(int j=0;j<rel[i].size();j++){\\n                        can_take[rel[i][j]]--;\\n                    }\\n                    if(bcha==1){\\n\\t\\t\\t\\t\\t//if we left one course for this semster then we will take this course and move to next semseter\\n                        ans=min(ans,1+findans(k,(bits|(1<<i)),k,n,sem+1,course+1));\\n                        \\n                    }\\n                    else{\\n                        if(course+1==0){\\n                            return 0;\\n                        }\\n                        \\n                        ans=min(ans,findans(k,(bits|(1<<i)),bcha-1,n,sem,course+1));\\n                        ans1=min(ans1,1+findans(k,(bits|(1<<i)),k,n,sem+1,course+1));\\n                        \\n                    }\\n                    help[i]=prev;\\n                    for(int j=0;j<rel[i].size();j++){\\n                        can_take[rel[i][j]]++;\\n                    }\\n                }\\n            }\\n        }\\n       \\n        return dp[sem][bcha][bits]=min(ans,ans1);\\n        \\n    }\\n    \\n    \\n    int minNumberOfSemesters(int n, vector<vector<int>>& relations, int k) {\\n        pre.resize(n+1);\\n        rel.resize(n+1);\\n        can_take.resize(n+1);\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<16;i++){\\n            help[i]=INT_MAX;\\n        }\\n        bit=pow(2,n);\\n        for(int i=0;i<relations.size();i++){\\n            pre[relations[i][1]].push_back(relations[i][0]);\\n            rel[relations[i][0]].push_back(relations[i][1]);\\n        }\\n        bool find=true;\\n        for(int i=1;i<pre.size();i++){\\n            can_take[i]=pre[i].size();\\n            if(pre[i].size()){\\n                find=false;\\n            }\\n        }\\n        if(find){\\n            return n%k==0?n/k:n/k+1;\\n        }\\n        // int ans=n%k==0?n/k:n/k+1;\\n       return 1+findans(k,0,k,n,1,0);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1451224,
                "title": "c-38-lines-bitmask-faster-than-90",
                "content": "This solution is based on the post written by Huahua (first solution): \\nhttps://zxi.mytechroad.com/blog/dynamic-programming/leetcode-1494-parallel-courses-ii/\\n\\nI just added one optimization -- always add k more courses if possible (`__builtin_popcount(c) == k` instead of `__builtin_popcount(c) <= k` at line 26 in the solution of the original post). Then the runtime reduced from 71 ms to 12 ms. \\n\\nAnother thing worth to be noticed, `tmp` is always initialized to be full of `false` at the beginning of every semester, rather than `dp`, so we won\\'t start from the states we already checked in the previous semesters. \\n\\n```C++\\nclass Solution {\\npublic:\\n    int minNumberOfSemesters(int n, vector<vector<int>>& relations, int k) {\\n        //find dependency mask for each course\\n        vector<int> deps(n, 0); \\n        for(auto& r: relations)\\n            deps[r[1] - 1] |= 1 << (r[0] - 1);\\n        \\n        int S = 1 << n;\\n        vector<bool> dp(S, false); //dp[s] == true means state \"s\" is reachable on the PREVIOUS semester\\n        dp[0] = true;\\n        for(int r = 1; r <= n; r++){ //at most n semesters\\n            vector<bool> tmp(S, false); //tmp[s] == true means state \"s\" is reachable on the CURRENT semester\\n            for(int s = 0; s < S; s++){\\n                if(!dp[s]) continue;\\n                //create a mask containing all possible courses I can take based on current state s\\n                int mask = 0;\\n                for(int i = 0; i < n; i++){\\n                    if((s & (1<<i))) continue; //this course is already in state s\\n                    if((s & deps[i]) != deps[i]) continue; //I haven\\'t taken all the required courses yet\\n                    mask |= (1 << i);\\n                }\\n                //always record the state with the maximal classes taken\\n                if(__builtin_popcount(mask) <= k){ //__builtin_popcount return # of 1 bits in a number\\n                    tmp[s | mask] = true;\\n                }else{\\n                    //choose k courses in this mask\\n                    for(int c = mask; c; c = (c-1)&mask)\\n                        if(__builtin_popcount(c) == k)\\n                            tmp[s | c] = true;\\n                }\\n                if(tmp.back()) return r;\\n            }\\n            dp.swap(tmp);\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\npublic:\\n    int minNumberOfSemesters(int n, vector<vector<int>>& relations, int k) {\\n        //find dependency mask for each course\\n        vector<int> deps(n, 0); \\n        for(auto& r: relations)\\n            deps[r[1] - 1] |= 1 << (r[0] - 1);\\n        \\n        int S = 1 << n;\\n        vector<bool> dp(S, false); //dp[s] == true means state \"s\" is reachable on the PREVIOUS semester\\n        dp[0] = true;\\n        for(int r = 1; r <= n; r++){ //at most n semesters\\n            vector<bool> tmp(S, false); //tmp[s] == true means state \"s\" is reachable on the CURRENT semester\\n            for(int s = 0; s < S; s++){\\n                if(!dp[s]) continue;\\n                //create a mask containing all possible courses I can take based on current state s\\n                int mask = 0;\\n                for(int i = 0; i < n; i++){\\n                    if((s & (1<<i))) continue; //this course is already in state s\\n                    if((s & deps[i]) != deps[i]) continue; //I haven\\'t taken all the required courses yet\\n                    mask |= (1 << i);\\n                }\\n                //always record the state with the maximal classes taken\\n                if(__builtin_popcount(mask) <= k){ //__builtin_popcount return # of 1 bits in a number\\n                    tmp[s | mask] = true;\\n                }else{\\n                    //choose k courses in this mask\\n                    for(int c = mask; c; c = (c-1)&mask)\\n                        if(__builtin_popcount(c) == k)\\n                            tmp[s | c] = true;\\n                }\\n                if(tmp.back()) return r;\\n            }\\n            dp.swap(tmp);\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1371254,
                "title": "c-0ms-pruning-dp-greedy",
                "content": "Other dp bitmask solutions  run a little slow because we consider every state from `0 to (1<<n)-1` some of which are just impossible (like a child being set before its parent) and hence can be pruned.\\nMoreover we can use a greedy approach in assigning classes to a semester so as to completely fill the `k` slots we have in the semester. We can fill the remaining slots (if any) of the semester with the isolated classes which require no parent and also have no child. In this manner we avoid a lot of intermediate states and the code is much faster.\\n\\nWe convert the nodes to 0-indexed from 1-indexed.\\nFor every recursion, we have\\n`state`: an integer with the used nodes set to 0.\\n`numUnconnected`: The number of completely isolated nodes remaining.\\n`allowed`: those subjects which can be used in this semester i.e. the ones whose parents have already been used. We don\\'t consider the specific isolated nodes in this since only the number of isolated nodes is important at any time.\\n\\nWe then take all the combinations of the allowed nodes of size `min(k, numAllowed)` to be used in this round, the max. size makes the approach greedy.\\nIf `numAllowed < k` then we can also use some of the unconnected nodes in this round and again we greedily use as many of them as possible.\\nWe update the `allowed` and `state` bitmasks by unsetting the nodes used in this round and also setting new nodes which became available after this round in `allowed` bitmask.\\nWe then recurse to find the best answer.\\n\\nEven without memoization the solution is very fast(8ms). To memoise it we use the `state` and the number of `unconnected` nodes left. That makes it `0ms`, I sometime get `4ms` for it as well.\\n\\n\\n```\\nclass Solution {\\n    vector<bool> noConnections;\\n    int n, k, numUnconnected;\\n    vector<int> par;\\n    vector<unordered_map<int,int>> dp;\\npublic:\\n    int minNumberOfSemesters(int n, vector<vector<int>>& relations, int k) {\\n        this->n = n;\\n        this->k = k;\\n        noConnections = vector<bool>(n, true);// no connections to anything\\n        dp = vector<unordered_map<int,int>>(n+1);\\n        par = vector<int>(n, 0);// bitmask with all the parent bits set\\n        \\n        int allowed = (1<<n)-1;// only those nodes whose parents have been used already but they themselves haven\\'t been\\n        \\n        for (auto &v: relations) {\\n            noConnections[v[0]-1] = noConnections[v[1]-1] = false;\\n            \\n            par[v[1]-1] |= (1<< (v[0]-1));\\n            \\n            allowed &= ~(1<<(v[1]-1));// if dependent on some node then don\\'t include in allowed initially\\n        }\\n        \\n        for (int i =0;i<n;i++){\\n            bool b = noConnections[i];\\n            if (b) {\\n                allowed &= ~(1<<i);// if no connections then we don\\'t include it in allowed initially\\n                numUnconnected++;\\n            }\\n        }\\n        \\n        return rec((1<<n)-1, allowed);\\n    }\\n    \\n    // the set-bits are the nodes unused in state, the set-bits are the allowed nodes in allowed\\n    int rec(int state, int allowed) {\\n        if (allowed == 0) {// all the dependent ones have been allotted, now greedily allot the remaining no-connection ones\\n            return dp[numUnconnected][state] = ceil((double)numUnconnected/k);\\n        }\\n        \\n        if (dp[numUnconnected].count(state)) {\\n            return dp[numUnconnected][state];\\n        }\\n        \\n        vector<int> toBeUsed;// enumerating all the allowed ones to create the combinations for this round\\n        for (int i = 0;i<n;i++) {\\n            if (allowed & state & (1<<i)) {\\n                toBeUsed.push_back(i);\\n            }\\n        }\\n        \\n        vector<vector<int>> comb;\\n        vector<int> currComb;\\n        createCombinations(currComb, comb, toBeUsed, min(k, (int)toBeUsed.size()), 0);// create all the combinations of size min(k, toBeUsed.size())\\n        \\n        int spaceRemaining = max(k - (int)toBeUsed.size(), 0);// the remaining space in this round after choosing the nodes on this round greedily\\n        \\n        int stateOld = state, allowedOld = allowed, oldNumUnconnected = numUnconnected, ans = 1e9;\\n        \\n        if (numUnconnected > 0) {\\n            numUnconnected  = max(0, numUnconnected - spaceRemaining);// greedily alloting the unconnected ones in this round\\n        }\\n        \\n        \\n        for (auto&v: comb) {// all the combinations\\n            // backtracking for every combination\\n            state = stateOld;\\n            allowed = allowedOld;\\n            for (auto node: v) {\\n                state ^= (1<<node);// unset the node\\n                allowed ^= (1<<node);//unset the node\\n            }\\n            \\n            for (int i = 0;i<n;i++) {\\n                if (!noConnections[i] && (state & (1<<i)) && ((~state) & par[i]) == par[i]) {\\n                    allowed |= (1<<i);// introduce the new node which becomes available after this round\\n                }\\n            }\\n            \\n            ans = min(ans, 1+ rec(state, allowed));\\n        }\\n        \\n        numUnconnected = oldNumUnconnected;\\n        \\n        return ans;\\n        \\n    }\\n    \\n    \\n    // create all k-sized combinations of toBeUsed\\n    void createCombinations(vector<int>& currComb, vector<vector<int>> &comb, vector<int>& toBeUsed, int k, int i) {\\n        if (k == 0) {\\n            comb.push_back(currComb);\\n        } else {\\n            for (int j = i;j < toBeUsed.size() - k + 1;j++) {\\n                currComb.push_back(toBeUsed[j]);\\n                createCombinations(currComb, comb, toBeUsed, k-1, j+1);\\n                currComb.pop_back();\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector<bool> noConnections;\\n    int n, k, numUnconnected;\\n    vector<int> par;\\n    vector<unordered_map<int,int>> dp;\\npublic:\\n    int minNumberOfSemesters(int n, vector<vector<int>>& relations, int k) {\\n        this->n = n;\\n        this->k = k;\\n        noConnections = vector<bool>(n, true);// no connections to anything\\n        dp = vector<unordered_map<int,int>>(n+1);\\n        par = vector<int>(n, 0);// bitmask with all the parent bits set\\n        \\n        int allowed = (1<<n)-1;// only those nodes whose parents have been used already but they themselves haven\\'t been\\n        \\n        for (auto &v: relations) {\\n            noConnections[v[0]-1] = noConnections[v[1]-1] = false;\\n            \\n            par[v[1]-1] |= (1<< (v[0]-1));\\n            \\n            allowed &= ~(1<<(v[1]-1));// if dependent on some node then don\\'t include in allowed initially\\n        }\\n        \\n        for (int i =0;i<n;i++){\\n            bool b = noConnections[i];\\n            if (b) {\\n                allowed &= ~(1<<i);// if no connections then we don\\'t include it in allowed initially\\n                numUnconnected++;\\n            }\\n        }\\n        \\n        return rec((1<<n)-1, allowed);\\n    }\\n    \\n    // the set-bits are the nodes unused in state, the set-bits are the allowed nodes in allowed\\n    int rec(int state, int allowed) {\\n        if (allowed == 0) {// all the dependent ones have been allotted, now greedily allot the remaining no-connection ones\\n            return dp[numUnconnected][state] = ceil((double)numUnconnected/k);\\n        }\\n        \\n        if (dp[numUnconnected].count(state)) {\\n            return dp[numUnconnected][state];\\n        }\\n        \\n        vector<int> toBeUsed;// enumerating all the allowed ones to create the combinations for this round\\n        for (int i = 0;i<n;i++) {\\n            if (allowed & state & (1<<i)) {\\n                toBeUsed.push_back(i);\\n            }\\n        }\\n        \\n        vector<vector<int>> comb;\\n        vector<int> currComb;\\n        createCombinations(currComb, comb, toBeUsed, min(k, (int)toBeUsed.size()), 0);// create all the combinations of size min(k, toBeUsed.size())\\n        \\n        int spaceRemaining = max(k - (int)toBeUsed.size(), 0);// the remaining space in this round after choosing the nodes on this round greedily\\n        \\n        int stateOld = state, allowedOld = allowed, oldNumUnconnected = numUnconnected, ans = 1e9;\\n        \\n        if (numUnconnected > 0) {\\n            numUnconnected  = max(0, numUnconnected - spaceRemaining);// greedily alloting the unconnected ones in this round\\n        }\\n        \\n        \\n        for (auto&v: comb) {// all the combinations\\n            // backtracking for every combination\\n            state = stateOld;\\n            allowed = allowedOld;\\n            for (auto node: v) {\\n                state ^= (1<<node);// unset the node\\n                allowed ^= (1<<node);//unset the node\\n            }\\n            \\n            for (int i = 0;i<n;i++) {\\n                if (!noConnections[i] && (state & (1<<i)) && ((~state) & par[i]) == par[i]) {\\n                    allowed |= (1<<i);// introduce the new node which becomes available after this round\\n                }\\n            }\\n            \\n            ans = min(ans, 1+ rec(state, allowed));\\n        }\\n        \\n        numUnconnected = oldNumUnconnected;\\n        \\n        return ans;\\n        \\n    }\\n    \\n    \\n    // create all k-sized combinations of toBeUsed\\n    void createCombinations(vector<int>& currComb, vector<vector<int>> &comb, vector<int>& toBeUsed, int k, int i) {\\n        if (k == 0) {\\n            comb.push_back(currComb);\\n        } else {\\n            for (int j = i;j < toBeUsed.size() - k + 1;j++) {\\n                currComb.push_back(toBeUsed[j]);\\n                createCombinations(currComb, comb, toBeUsed, k-1, j+1);\\n                currComb.pop_back();\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1349624,
                "title": "bitmask-dp",
                "content": "This is a NP Hard Problem. I have solved it using Bitmask DP, where state of the problem is represented by variable `mask` if a bit is `1` then this course has to be taken, otherwise it is already taken.\\nNext, for any state find courses for which pre-requisites are cleared. If number of courses available to take in a current sem is less than or equal to K, take all of them. Otherwise, consider all possible combination and calculate minimum.\\n\\n```\\nclass Solution {\\npublic:\\n    int recur(int mask, vector<vector<int>> &adj, vector<int> &dp, vector<int> in_degree, int k) {\\n        // base case i.e. all courses has been taken so return 0\\n        if(!mask)\\n            return 0;\\n        // current state is already calculated\\n        if(dp[mask]!=-1)\\n            return dp[mask];\\n        vector<int> next;   // next stores the courses for which all pre-requisites has been taken\\n        for(int i=0; i<(int)in_degree.size(); i++) {\\n            if(!in_degree[i] and ((mask>>i)&1))\\n                next.push_back(i);\\n        }\\n        // If number of courses available to take is less than k take all the courses\\n        if(next.size()<=k) {\\n            int temp = mask;\\n            for(int &u:next) {\\n                for(int &v:adj[u])\\n                    in_degree[v]--;\\n                mask ^= (1<<u);\\n            }\\n            return dp[temp] = 1+recur(mask, adj, dp, in_degree, k);\\n        }\\n        // Now generate all possible combination of k courses and take any of them\\n        string str (k, \\'1\\');\\n        str.resize(next.size(), 0);\\n        int ans = 19;\\n        // this is a iteartive way to get all C(next.size(), k) combination. Google search if you don\\'t understand\\n        do {\\n            int temp1 = mask;\\n            vector<int> temp2 = in_degree;\\n            for(int i=0; i<(int)next.size(); i++) {\\n                if(str[i]==\\'1\\') {\\n                    temp1 ^= (1<<next[i]);\\n                    for(int &u:adj[next[i]])\\n                        temp2[u]--;\\n                }\\n            }\\n            ans = min(ans, recur(temp1, adj, dp, temp2, k));\\n        }while(prev_permutation(str.begin(), str.end()));\\n        return dp[mask] = 1+ans;\\n    }\\n    \\n    int minNumberOfSemesters(int n, vector<vector<int>>& relations, int k) {\\n        vector<int> in_degree(n);\\n        vector<int> dp (1<<n, -1);\\n        vector<vector<int>> adj(n);\\n        for(auto &edge : relations) {\\n            in_degree[edge[1]-1]++;\\n            adj[edge[0]-1].push_back(edge[1]-1);\\n        }\\n        return recur((1<<n)-1, adj, dp, in_degree, k);\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int recur(int mask, vector<vector<int>> &adj, vector<int> &dp, vector<int> in_degree, int k) {\\n        // base case i.e. all courses has been taken so return 0\\n        if(!mask)\\n            return 0;\\n        // current state is already calculated\\n        if(dp[mask]!=-1)\\n            return dp[mask];\\n        vector<int> next;   // next stores the courses for which all pre-requisites has been taken\\n        for(int i=0; i<(int)in_degree.size(); i++) {\\n            if(!in_degree[i] and ((mask>>i)&1))\\n                next.push_back(i);\\n        }\\n        // If number of courses available to take is less than k take all the courses\\n        if(next.size()<=k) {\\n            int temp = mask;\\n            for(int &u:next) {\\n                for(int &v:adj[u])\\n                    in_degree[v]--;\\n                mask ^= (1<<u);\\n            }\\n            return dp[temp] = 1+recur(mask, adj, dp, in_degree, k);\\n        }\\n        // Now generate all possible combination of k courses and take any of them\\n        string str (k, \\'1\\');\\n        str.resize(next.size(), 0);\\n        int ans = 19;\\n        // this is a iteartive way to get all C(next.size(), k) combination. Google search if you don\\'t understand\\n        do {\\n            int temp1 = mask;\\n            vector<int> temp2 = in_degree;\\n            for(int i=0; i<(int)next.size(); i++) {\\n                if(str[i]==\\'1\\') {\\n                    temp1 ^= (1<<next[i]);\\n                    for(int &u:adj[next[i]])\\n                        temp2[u]--;\\n                }\\n            }\\n            ans = min(ans, recur(temp1, adj, dp, temp2, k));\\n        }while(prev_permutation(str.begin(), str.end()));\\n        return dp[mask] = 1+ans;\\n    }\\n    \\n    int minNumberOfSemesters(int n, vector<vector<int>>& relations, int k) {\\n        vector<int> in_degree(n);\\n        vector<int> dp (1<<n, -1);\\n        vector<vector<int>> adj(n);\\n        for(auto &edge : relations) {\\n            in_degree[edge[1]-1]++;\\n            adj[edge[0]-1].push_back(edge[1]-1);\\n        }\\n        return recur((1<<n)-1, adj, dp, in_degree, k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1271173,
                "title": "python3-top-down-bitmask-dp",
                "content": "```\\nclass Solution:\\n    def minNumberOfSemesters(self, n: int, relations: List[List[int]], k: int) -> int:\\n        graph = [[] for _ in range(n)]\\n        indegree = [0] * n\\n        for pre, next in relations:\\n            graph[pre - 1].append(next - 1)\\n            indegree[next - 1] += 1\\n        complete = (1 << n) - 1\\n        dp = [[None] * (k + 1) for _ in range(1 << n)]\\n        def dfs(mask, available, last):\\n            if dp[mask][available] != None:\\n                return dp[mask][available]\\n            if mask == complete:\\n                return 1\\n            res = float(\\'inf\\')\\n            flag = True\\n            for i in range(n):\\n                if (mask >> i) & 1:\\n                    continue\\n                if indegree[i] == 0:\\n                    if i in last: \\n                        continue\\n                    flag = False\\n                    for j in graph[i]:\\n                        indegree[j] -= 1\\n                        if indegree[j] == 0:\\n                            last.add(j)\\n                    if available == 1:\\n                        res = min(res, dfs(mask ^ (1 << i), k, set()) + (1 if mask ^ (1 << i) != complete else 0))\\n                    else:\\n                        res = min(res, dfs(mask ^ (1 << i), available - 1, last))\\n                    for j in graph[i]:\\n                        indegree[j] += 1\\n                        if indegree[j] == 1:\\n                            last.remove(j)\\n            if flag:\\n                for i in range(n):\\n                    if (mask >> i) & 1:\\n                        continue\\n                    if indegree[i] == 0:\\n                        nxt = set()\\n                        for j in graph[i]:\\n                            indegree[j] -= 1\\n                            if indegree[j] == 0:\\n                                nxt.add(j)\\n                        res = min(res, dfs(mask ^ (1 << i), k - 1 if k - 1 else k, nxt) + 1)\\n                        for j in graph[i]:\\n                            indegree[j] += 1\\n            dp[mask][available] = res\\n            return res\\n        return dfs(0, k, set())\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minNumberOfSemesters(self, n: int, relations: List[List[int]], k: int) -> int:\\n        graph = [[] for _ in range(n)]\\n        indegree = [0] * n\\n        for pre, next in relations:\\n            graph[pre - 1].append(next - 1)\\n            indegree[next - 1] += 1\\n        complete = (1 << n) - 1\\n        dp = [[None] * (k + 1) for _ in range(1 << n)]\\n        def dfs(mask, available, last):\\n            if dp[mask][available] != None:\\n                return dp[mask][available]\\n            if mask == complete:\\n                return 1\\n            res = float(\\'inf\\')\\n            flag = True\\n            for i in range(n):\\n                if (mask >> i) & 1:\\n                    continue\\n                if indegree[i] == 0:\\n                    if i in last: \\n                        continue\\n                    flag = False\\n                    for j in graph[i]:\\n                        indegree[j] -= 1\\n                        if indegree[j] == 0:\\n                            last.add(j)\\n                    if available == 1:\\n                        res = min(res, dfs(mask ^ (1 << i), k, set()) + (1 if mask ^ (1 << i) != complete else 0))\\n                    else:\\n                        res = min(res, dfs(mask ^ (1 << i), available - 1, last))\\n                    for j in graph[i]:\\n                        indegree[j] += 1\\n                        if indegree[j] == 1:\\n                            last.remove(j)\\n            if flag:\\n                for i in range(n):\\n                    if (mask >> i) & 1:\\n                        continue\\n                    if indegree[i] == 0:\\n                        nxt = set()\\n                        for j in graph[i]:\\n                            indegree[j] -= 1\\n                            if indegree[j] == 0:\\n                                nxt.add(j)\\n                        res = min(res, dfs(mask ^ (1 << i), k - 1 if k - 1 else k, nxt) + 1)\\n                        for j in graph[i]:\\n                            indegree[j] += 1\\n            dp[mask][available] = res\\n            return res\\n        return dfs(0, k, set())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1198515,
                "title": "javascript-dfs-bitmasks-memoization-snoob",
                "content": "Bit of a tuffie tbh, but this problem is essentially a smart way of bruteforcing. Each state of picked nodes is represented as a bitmask (0 not picked 1 picked).  A node is available, only if its prerequisite nodes are already picked. From that we can build a solution where we try every combination of k nodes out of all the available nodes, while keeping track of the steps taken until every node is picked.\\nSnoob is a subroutine that returns the next higher number with the same count of set bits. This will help us only traverse the states containing k nodes and avoid any other state.\\n\\n```\\n\\n let snoob=x=>{\\n    // right most set bit \\n    let rightOne = x & -x; \\n    \\n    // reset the pattern and set next higher bit \\n    // left part of x will be here \\n    let nextHigherOneBit = x + rightOne; \\n\\n    // nextHigherOneBit is now part [D] of the above explanation. \\n\\n    // isolate the pattern \\n    let rightOnesPattern = x ^ nextHigherOneBit; \\n\\n    // right adjust pattern \\n    rightOnesPattern = (rightOnesPattern)/rightOne; \\n\\n    // correction factor \\n    rightOnesPattern >>= 2; \\n\\n    // rightOnesPattern is now part [A] of the above explanation. \\n\\n    // integrate new pattern (Add [D] and [A]) \\n    let next = nextHigherOneBit | rightOnesPattern; \\n    return next\\n}\\nvar minNumberOfSemesters = function(n, dependencies, k) {\\n    // Create an Adjacency matrix for both ingoing and outgoing\\n    let next=[...Array(n)].map(d=>[]),prev=[...Array(n)].map(d=>[]),\\n        prereq=[...Array(n)]\\n    for(let [x,y] of dependencies)\\n        next[x-1].push(y-1),\\n        prev[y-1].push(x-1)\\n\\n    // Create a mask for each node, that contains its prerequisites\\n    let dfs1=node=>{\\n        if(prereq[node]===undefined){\\n            prereq[node]=0\\n            if(prev[node])\\n                for(let nei of prev[node])\\n                    prereq[node]|=dfs1(nei)|(1<<nei)\\n        }        \\n        return prereq[node]\\n    }\\n    for(let i=0;i<n;i++)\\n        dfs1(i)\\n    \\n    //Traverse each possible scenario through dfs keeping track of the steps used\\n    let memo=[...Array(1<<n)].map(d=>[...Array(n)].map(d=>0)),res=Infinity\\n    let dfs=(picked,step=0)=>{\\n        if(step>=res||step>n+1||memo[picked][step]) //Useless states\\n            return \\n        memo[picked][step]=true\\n        if(picked===((1<<n)-1)) // End result( everything used)\\n            return res=Math.min(step,res)\\n        // Save the available nodes in another bitmask\\n        let avail=0,count=0\\n        for(let i=0;i<n;i++)\\n            //the available nodes have to have their prerequisites already picked\\n            if((prereq[i]&picked)===prereq[i] && ( picked&(1<<i))===0)\\n                avail|=(1<<i),\\n                count++\\n        //start traversing each possible combination of k nodes,out of the available ones\\n        let start=count<=k?avail:( (1<<k)-1)\\n        for(let mask=start;mask<=avail&&mask>0;mask=snoob(mask)){\\n            if( (mask&avail)!==mask) //if this is not a subset of available, continue\\n                continue\\n            dfs(picked|mask,step+1) //try using these k available nodes\\n        }\\n    }\\n    dfs(0)\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Memoization",
                    "Bitmask"
                ],
                "code": "```\\n\\n let snoob=x=>{\\n    // right most set bit \\n    let rightOne = x & -x; \\n    \\n    // reset the pattern and set next higher bit \\n    // left part of x will be here \\n    let nextHigherOneBit = x + rightOne; \\n\\n    // nextHigherOneBit is now part [D] of the above explanation. \\n\\n    // isolate the pattern \\n    let rightOnesPattern = x ^ nextHigherOneBit; \\n\\n    // right adjust pattern \\n    rightOnesPattern = (rightOnesPattern)/rightOne; \\n\\n    // correction factor \\n    rightOnesPattern >>= 2; \\n\\n    // rightOnesPattern is now part [A] of the above explanation. \\n\\n    // integrate new pattern (Add [D] and [A]) \\n    let next = nextHigherOneBit | rightOnesPattern; \\n    return next\\n}\\nvar minNumberOfSemesters = function(n, dependencies, k) {\\n    // Create an Adjacency matrix for both ingoing and outgoing\\n    let next=[...Array(n)].map(d=>[]),prev=[...Array(n)].map(d=>[]),\\n        prereq=[...Array(n)]\\n    for(let [x,y] of dependencies)\\n        next[x-1].push(y-1),\\n        prev[y-1].push(x-1)\\n\\n    // Create a mask for each node, that contains its prerequisites\\n    let dfs1=node=>{\\n        if(prereq[node]===undefined){\\n            prereq[node]=0\\n            if(prev[node])\\n                for(let nei of prev[node])\\n                    prereq[node]|=dfs1(nei)|(1<<nei)\\n        }        \\n        return prereq[node]\\n    }\\n    for(let i=0;i<n;i++)\\n        dfs1(i)\\n    \\n    //Traverse each possible scenario through dfs keeping track of the steps used\\n    let memo=[...Array(1<<n)].map(d=>[...Array(n)].map(d=>0)),res=Infinity\\n    let dfs=(picked,step=0)=>{\\n        if(step>=res||step>n+1||memo[picked][step]) //Useless states\\n            return \\n        memo[picked][step]=true\\n        if(picked===((1<<n)-1)) // End result( everything used)\\n            return res=Math.min(step,res)\\n        // Save the available nodes in another bitmask\\n        let avail=0,count=0\\n        for(let i=0;i<n;i++)\\n            //the available nodes have to have their prerequisites already picked\\n            if((prereq[i]&picked)===prereq[i] && ( picked&(1<<i))===0)\\n                avail|=(1<<i),\\n                count++\\n        //start traversing each possible combination of k nodes,out of the available ones\\n        let start=count<=k?avail:( (1<<k)-1)\\n        for(let mask=start;mask<=avail&&mask>0;mask=snoob(mask)){\\n            if( (mask&avail)!==mask) //if this is not a subset of available, continue\\n                continue\\n            dfs(picked|mask,step+1) //try using these k available nodes\\n        }\\n    }\\n    dfs(0)\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1121323,
                "title": "python-20ms-beats-100-on-time-and-memory",
                "content": "```\\nfrom itertools import combinations\\n\\nclass Solution(object):\\n    def dp(self,bitmask):\\n\\n        # if all courses are already filled, you\\'re done\\n        if bitmask == (1<<self.n)-1: return 0\\n        \\n        # canTake is all courses that aren\\'t already taken and have prereqs met\\n        canTake = []\\n        for i in range(1,self.n+1):\\n            # if course is already taken, skip\\n            if bitmask&(1<<(i-1)): continue\\n            # make sure all prereqs are done\\n            t=True\\n            for c in self.pres[i]:\\n                if bitmask&(1<<(c-1))==0:\\n                    t=False\\n                    break\\n            # append if all prereqs are done (and not already taken)\\n            if t: canTake.append(i)\\n               \\n        # if you can only take <=k courses then it\\'s obvious what to do, take them!\\n        if len(canTake)<=self.k:\\n            self.cache[bitmask] = 1+self.dp(bitmask + sum([1<<(c-1) for c in canTake]))\\n            return self.cache[bitmask]\\n                      \\n        # still here means canTake is longer than k\\n        # canTakeD is everything you can take that also has a dependency\\n        canTakeD = [c for c in canTake if self.hasdeps[c]]\\n\\n        # if there\\'s more than k in canTakeD, go through all possible combinations of k.    \\n        if len(canTakeD)>=self.k:\\n            self.cache[bitmask] = 1+ min([self.dp(bitmask+sum([1<<(c-1) for c in ct])) \\n                        for ct in combinations(canTakeD,self.k)])                    \\n            return self.cache[bitmask]\\n\\n\\n        # if canTakeD has <k, then take all of them plus k-len(canTakeD) others\\n        # it doesn\\'t matter which ones are the others\\n        \\n        others = []\\n        for c in canTake:\\n            if not self.hasdeps[c]:\\n                others.append(c)\\n                if len(others)==self.k-len(canTakeD): break\\n\\n        self.cache[bitmask] = 1+self.dp(bitmask + sum([1<<(c-1) for c in canTakeD+others]))\\n        return self.cache[bitmask]\\n\\n\\n                \\n                    \\n                \\n        \\n    def minNumberOfSemesters(self, n, dependencies, k):\\n        \"\"\"\\n        :type n: int\\n        :type dependencies: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        # store so they are within class\\n        self.n=n\\n        self.k=k\\n        # self.pres[i] is all courses you must take before taking i\\n        self.pres = {i:[] for i in range(1,n+1)}\\n        # self.hasdeps[i] is True/False if the course has any dependencies\\n        self.hasdeps = {i:False for i in range(1,n+1)}\\n        # make self.pres and self.hasdeps\\n        for [a,b] in dependencies:\\n            self.pres[b].append(a)\\n            self.hasdeps[a]=True                \\n\\n        # set up memoization\\n        self.cache = {}\\n        # return value\\n        return self.dp(0)\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nfrom itertools import combinations\\n\\nclass Solution(object):\\n    def dp(self,bitmask):\\n\\n        # if all courses are already filled, you\\'re done\\n        if bitmask == (1<<self.n)-1: return 0\\n        \\n        # canTake is all courses that aren\\'t already taken and have prereqs met\\n        canTake = []\\n        for i in range(1,self.n+1):\\n            # if course is already taken, skip\\n            if bitmask&(1<<(i-1)): continue\\n            # make sure all prereqs are done\\n            t=True\\n            for c in self.pres[i]:\\n                if bitmask&(1<<(c-1))==0:\\n                    t=False\\n                    break\\n            # append if all prereqs are done (and not already taken)\\n            if t: canTake.append(i)\\n               \\n        # if you can only take <=k courses then it\\'s obvious what to do, take them!\\n        if len(canTake)<=self.k:\\n            self.cache[bitmask] = 1+self.dp(bitmask + sum([1<<(c-1) for c in canTake]))\\n            return self.cache[bitmask]\\n                      \\n        # still here means canTake is longer than k\\n        # canTakeD is everything you can take that also has a dependency\\n        canTakeD = [c for c in canTake if self.hasdeps[c]]\\n\\n        # if there\\'s more than k in canTakeD, go through all possible combinations of k.    \\n        if len(canTakeD)>=self.k:\\n            self.cache[bitmask] = 1+ min([self.dp(bitmask+sum([1<<(c-1) for c in ct])) \\n                        for ct in combinations(canTakeD,self.k)])                    \\n            return self.cache[bitmask]\\n\\n\\n        # if canTakeD has <k, then take all of them plus k-len(canTakeD) others\\n        # it doesn\\'t matter which ones are the others\\n        \\n        others = []\\n        for c in canTake:\\n            if not self.hasdeps[c]:\\n                others.append(c)\\n                if len(others)==self.k-len(canTakeD): break\\n\\n        self.cache[bitmask] = 1+self.dp(bitmask + sum([1<<(c-1) for c in canTakeD+others]))\\n        return self.cache[bitmask]\\n\\n\\n                \\n                    \\n                \\n        \\n    def minNumberOfSemesters(self, n, dependencies, k):\\n        \"\"\"\\n        :type n: int\\n        :type dependencies: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        # store so they are within class\\n        self.n=n\\n        self.k=k\\n        # self.pres[i] is all courses you must take before taking i\\n        self.pres = {i:[] for i in range(1,n+1)}\\n        # self.hasdeps[i] is True/False if the course has any dependencies\\n        self.hasdeps = {i:False for i in range(1,n+1)}\\n        # make self.pres and self.hasdeps\\n        for [a,b] in dependencies:\\n            self.pres[b].append(a)\\n            self.hasdeps[a]=True                \\n\\n        # set up memoization\\n        self.cache = {}\\n        # return value\\n        return self.dp(0)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 840686,
                "title": "c-bitmask-and-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n  int minNumberOfSemesters(int n, vector<vector<int>> &dependencies, int k) {\\n    init(n, dependencies);\\n    const int finalState = (1 << n) - 1;\\n    queue<pair<int, int>> q; //{state, step};\\n    q.push(pair(0, 0));\\n    unordered_set<int> visited = {0}; // visited state\\n    while (!q.empty()) {\\n      auto [state, step] = q.front();\\n      q.pop();\\n      for (auto nextState : getAllNextState(state, k)) {\\n        if (nextState == finalState) return step + 1;\\n        if (visited.count(nextState)) continue;\\n        visited.insert(nextState);\\n        q.push(pair(nextState, step + 1));\\n      }\\n    }\\n    return -1;\\n  }\\n\\n  void init(int n1, const vector<vector<int>> &edges) {\\n    n = n1;\\n    vdep.resize(n);\\n    for (auto &e : edges) vdep[e[1] - 1] |= (1 << (e[0] - 1));\\n  }\\n\\n  bool isAbleToTake(int i, int state) const {\\n    return (state & vdep[i]) == vdep[i];\\n  }\\n\\n  bool haveNotTake(int i, int state) const { return ((1 << i) & state) == 0; }\\n\\n  vector<int> getAllNextState(int state, const int k) const {\\n    vector<int> courses;\\n    for (int i = 0; i < n; i++) \\n      if (haveNotTake(i, state) && isAbleToTake(i, state))\\n        courses.push_back(i);\\n\\n    if (courses.size() <= k) {\\n      for (int course : courses) state |= (1 << course);\\n      return vector<int>{state};\\n    }\\n\\n    vector<int> states;\\n    getCombination(states, courses, state, 0, k);\\n    return states;\\n  }\\n\\n  void getCombination(vector<int> &states, const vector<int> &courses, int state, int i, int k) const {\\n    if (k == 0) {\\n      states.push_back(state);\\n      return;\\n    }\\n    for (int j = i; j + k <= courses.size(); j++) \\n      getCombination(states, courses, state | (1 << courses[j]), j + 1, k - 1);\\n  }\\n\\n  int n;\\n  vector<int> vdep; // store the bitmask of dependency, eg 0X00101 means depend on 1st and 3rd courses\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n  int minNumberOfSemesters(int n, vector<vector<int>> &dependencies, int k) {\\n    init(n, dependencies);\\n    const int finalState = (1 << n) - 1;\\n    queue<pair<int, int>> q; //{state, step}",
                "codeTag": "Java"
            },
            {
                "id": 763621,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minNumberOfSemesters(int n, vector<vector<int>>& dep, int k) {\\n        vector<int> pre(n);\\n        \\n        for(int i=0;i<dep.size();i++){\\n            int x=dep[i][0]-1;\\n            int y=dep[i][1]-1;\\n            \\n            pre[y]|=(1<<x);\\n        }\\n        \\n        vector<int> dp(1<<n,n);\\n        \\n        dp[0]=0;\\n        \\n        for(int i=0;i<(1<<n);i++){\\n            int ex=0;\\n            \\n            for(int j=0;j<n;j++){\\n                if((pre[j]&i)==pre[j]){\\n                    ex|=(1<<j);\\n                }\\n            }\\n            \\n            ex&=(~i);\\n            \\n            // enumerate all subset of ex which have size less than k\\n            // https://cp-algorithms.com/algebra/all-submasks.html\\n            for(int s=ex;s;s=(s-1)&ex){\\n                if(__builtin_popcount(s)<=k){\\n                    dp[i|s]=min(dp[i|s],dp[i]+1);\\n                }\\n            }\\n        }\\n        \\n        return dp.back();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfSemesters(int n, vector<vector<int>>& dep, int k) {\\n        vector<int> pre(n);\\n        \\n        for(int i=0;i<dep.size();i++){\\n            int x=dep[i][0]-1;\\n            int y=dep[i][1]-1;\\n            \\n            pre[y]|=(1<<x);\\n        }\\n        \\n        vector<int> dp(1<<n,n);\\n        \\n        dp[0]=0;\\n        \\n        for(int i=0;i<(1<<n);i++){\\n            int ex=0;\\n            \\n            for(int j=0;j<n;j++){\\n                if((pre[j]&i)==pre[j]){\\n                    ex|=(1<<j);\\n                }\\n            }\\n            \\n            ex&=(~i);\\n            \\n            // enumerate all subset of ex which have size less than k\\n            // https://cp-algorithms.com/algebra/all-submasks.html\\n            for(int s=ex;s;s=(s-1)&ex){\\n                if(__builtin_popcount(s)<=k){\\n                    dp[i|s]=min(dp[i|s],dp[i]+1);\\n                }\\n            }\\n        }\\n        \\n        return dp.back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 719428,
                "title": "clear-and-easy-c-dp-solution-with-brief-but-effective-commenting",
                "content": "```\\nclass Solution {\\n\\t#define LM 15\\n    int prerequisite[LM];\\n    int n,k;\\n    int dp[1<<LM];\\n\\n    int sol(int mask) {\\n        if(mask == (1<<n) - 1) {\\n            return 0;\\n        }\\n\\n        int &ret = dp[mask];\\n        if(~ret) {\\n            return ret;\\n        }\\n\\n        ret = 15;\\n\\n        int candidate = 0;\\n\\n        //mask for courses which can be taken in current semester.\\n        for(int course = 0; course<n; ++course) {\\n            if(((mask&(1<<course)) == 0 && (prerequisite[course]&mask) == prerequisite[course])) {\\n                candidate |= (1<<course);\\n            }\\n        }\\n\\n        //trying all possible way (sum mask) of the candidate mask.\\n        //sub masking [https://cp-algorithms.com/algebra/all-submasks.html]\\n        for(int subMask = candidate; subMask>0; subMask = (subMask-1)&candidate) {\\n            if(__builtin_popcount(subMask)<=k) {\\n                ret = min(ret,sol(subMask|mask)+1);\\n            }\\n        }\\n\\n        return ret;\\n    }\\n\\npublic:\\n    int minNumberOfSemesters(int n, vector<vector<int>>& dependencies, int k) {\\n        memset(dp,-1,sizeof(dp));\\n        for(auto edge: dependencies) {\\n            prerequisite[edge.back()-1] |= (1 << (edge.front()-1));\\n        }\\n        this->n = n, this->k = k;\\n        return sol(0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\t#define LM 15\\n    int prerequisite[LM];\\n    int n,k;\\n    int dp[1<<LM];\\n\\n    int sol(int mask) {\\n        if(mask == (1<<n) - 1) {\\n            return 0;\\n        }\\n\\n        int &ret = dp[mask];\\n        if(~ret) {\\n            return ret;\\n        }\\n\\n        ret = 15;\\n\\n        int candidate = 0;\\n\\n        //mask for courses which can be taken in current semester.\\n        for(int course = 0; course<n; ++course) {\\n            if(((mask&(1<<course)) == 0 && (prerequisite[course]&mask) == prerequisite[course])) {\\n                candidate |= (1<<course);\\n            }\\n        }\\n\\n        //trying all possible way (sum mask) of the candidate mask.\\n        //sub masking [https://cp-algorithms.com/algebra/all-submasks.html]\\n        for(int subMask = candidate; subMask>0; subMask = (subMask-1)&candidate) {\\n            if(__builtin_popcount(subMask)<=k) {\\n                ret = min(ret,sol(subMask|mask)+1);\\n            }\\n        }\\n\\n        return ret;\\n    }\\n\\npublic:\\n    int minNumberOfSemesters(int n, vector<vector<int>>& dependencies, int k) {\\n        memset(dp,-1,sizeof(dp));\\n        for(auto edge: dependencies) {\\n            prerequisite[edge.back()-1] |= (1 << (edge.front()-1));\\n        }\\n        this->n = n, this->k = k;\\n        return sol(0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 710123,
                "title": "java-both-100-solution-with-comments-and-explanation-topo-sort-pq",
                "content": "The main idea is topological sort, but some other problems need to be considered:\\n1. When the number of applicable courses is more than k, choose courses with larger outdegree first(so that more courses are released and applicable in next semester);\\n2. Taking one course would result in other courses\\' indegree = 0, but these released courses can only be taken in the next semester.\\n\\nFor problem 1, use a priorityqueue to fetch applicable courses with larger outdegree to fill k courses for a semester; for problem 2, when some courses are released due to taking some courses in a semester, cache them in a new queue instead of directly adding into pq, then add them into pq after a semester is filled with courses.\\n\\nTC - O(ElogV + V)\\nSC - O(E + V)\\n```\\nclass GNode{\\n    int indegrees;\\n    List<Integer> outNodes;\\n    public GNode(){\\n        indegrees = 0;\\n        outNodes = new ArrayList<Integer>();\\n    }\\n}\\n\\nclass Solution {\\n    public int minNumberOfSemesters(int n, int[][] dependencies, int k) {\\n        // No dependency case\\n        if(dependencies.length == 0)\\n            return n % k == 0 ? n / k : n / k + 1;\\n        \\n        // 1) Initialize graph\\n        HashMap<Integer, GNode> graph = new HashMap<Integer, GNode>();\\n        for(int i = 1; i <= n; i++){\\n            graph.put(i, new GNode());\\n        }\\n        for(int[] relation : dependencies){\\n            graph.get(relation[1]).indegrees += 1;\\n            graph.get(relation[0]).outNodes.add(relation[1]);\\n        }\\n        // Prepare a priroityqueue for topological sort and choose nodes(whose indegrees=0) with larger outdegrees first\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>(new Comparator<Integer>(){\\n            public int compare(Integer c1, Integer c2){\\n                return graph.get(c2).outNodes.size() - graph.get(c1).outNodes.size();\\n            }\\n        });\\n        \\n        // 2) Collect all the courses without prerequisite\\n        for(int i = 1; i <= n; i++)\\n            if(graph.get(i).indegrees == 0)\\n                pq.add(i);\\n        \\n        // 3) Topological sort, \\n        int take = 0, ans = 0;\\n        while(!pq.isEmpty()){\\n            Queue<Integer> nextq = new LinkedList<>();\\n            // Start taking courses for a semester\\n            while(take < k && !pq.isEmpty()){\\n                int course = pq.poll();\\n                for(int nextCourse : graph.get(course).outNodes){\\n                    GNode node = graph.get(nextCourse);\\n                    node.indegrees--;\\n                    if(node.indegrees == 0)\\n                        nextq.add(nextCourse);\\n                }\\n                take++;\\n            }\\n            // End taking courses for a semester\\n            take = 0;\\n            ans++;\\n            for(int course : nextq)\\n                pq.add(course);    \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Topological Sort",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass GNode{\\n    int indegrees;\\n    List<Integer> outNodes;\\n    public GNode(){\\n        indegrees = 0;\\n        outNodes = new ArrayList<Integer>();\\n    }\\n}\\n\\nclass Solution {\\n    public int minNumberOfSemesters(int n, int[][] dependencies, int k) {\\n        // No dependency case\\n        if(dependencies.length == 0)\\n            return n % k == 0 ? n / k : n / k + 1;\\n        \\n        // 1) Initialize graph\\n        HashMap<Integer, GNode> graph = new HashMap<Integer, GNode>();\\n        for(int i = 1; i <= n; i++){\\n            graph.put(i, new GNode());\\n        }\\n        for(int[] relation : dependencies){\\n            graph.get(relation[1]).indegrees += 1;\\n            graph.get(relation[0]).outNodes.add(relation[1]);\\n        }\\n        // Prepare a priroityqueue for topological sort and choose nodes(whose indegrees=0) with larger outdegrees first\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>(new Comparator<Integer>(){\\n            public int compare(Integer c1, Integer c2){\\n                return graph.get(c2).outNodes.size() - graph.get(c1).outNodes.size();\\n            }\\n        });\\n        \\n        // 2) Collect all the courses without prerequisite\\n        for(int i = 1; i <= n; i++)\\n            if(graph.get(i).indegrees == 0)\\n                pq.add(i);\\n        \\n        // 3) Topological sort, \\n        int take = 0, ans = 0;\\n        while(!pq.isEmpty()){\\n            Queue<Integer> nextq = new LinkedList<>();\\n            // Start taking courses for a semester\\n            while(take < k && !pq.isEmpty()){\\n                int course = pq.poll();\\n                for(int nextCourse : graph.get(course).outNodes){\\n                    GNode node = graph.get(nextCourse);\\n                    node.indegrees--;\\n                    if(node.indegrees == 0)\\n                        nextq.add(nextCourse);\\n                }\\n                take++;\\n            }\\n            // End taking courses for a semester\\n            take = 0;\\n            ans++;\\n            for(int course : nextq)\\n                pq.add(course);    \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 709987,
                "title": "python-bitmasking-memorization-o-3-n",
                "content": "I was trying VERSION-1 which is getting TLE for n=15 while same logic with VERSION-2 works.\\nCan anybody comment on it, what is fundamental difference between these two?\\n\\nNote:\\nTo run VERSION-1 uncomment BOTH blocks with comment heading #VERSION-1 and comment other TWO blocks with heading #VERSION-2\\n```\\nclass Solution:\\n    def minNumberOfSemesters(self, n: int, dependencies: List[List[int]], k: int) -> int:\\n        def countOne(n):\\n            if not n:\\n                return 0\\n            if n in ha:\\n                return ha[n]\\n            ha[n] = 1+countOne(n&(n-1))\\n            return ha[n]\\n        #VERSION-1\\n        # pre = [0]*n\\n        # for e in dependencies:\\n        #     pre[e[1]-1]+=(1<<(e[0]-1))\\n        \\n        #VERSION-2\\n        pre = [[] for _ in range(n)]\\n        for e in dependencies:\\n            pre[e[1]-1].append(e[0]-1)\\n        \\n        def rec(mask):\\n            if mask == 0:\\n                return 0\\n            \\n            if dp[mask]!=-1:\\n                return dp[mask]\\n        \\n            possible = 0    #Currently possible course bit set\\n            #VERSION-2\\n            for i in range(n):\\n                if mask&(1<<i):\\n                    flag = 1\\n                    for v in pre[i]:\\n                        if mask&(1<<v):\\n                            flag = 0\\n                    if flag:\\n                        possible+=(1<<i)\\n            #VERSION-1\\n            # done = mask^((1<<len(pre))-1)\\n            # for i,val in enumerate(pre):\\n            #     if mask&(1<<i) and val&done == val:\\n            #         possible +=(1<<i)\\n            \\n            submask = possible  #For iteration\\n            dp[mask] = 20\\n            while submask:\\n                if countOne(submask)<=k:\\n                    dp[mask] = min(dp[mask],1+rec(mask-submask))\\n                submask = (submask-1)&possible\\n            return dp[mask]\\n        \\n        dp = [-1]*(1<<n)\\n        ha = {}\\n        return rec((1<<n)-1)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minNumberOfSemesters(self, n: int, dependencies: List[List[int]], k: int) -> int:\\n        def countOne(n):\\n            if not n:\\n                return 0\\n            if n in ha:\\n                return ha[n]\\n            ha[n] = 1+countOne(n&(n-1))\\n            return ha[n]\\n        #VERSION-1\\n        # pre = [0]*n\\n        # for e in dependencies:\\n        #     pre[e[1]-1]+=(1<<(e[0]-1))\\n        \\n        #VERSION-2\\n        pre = [[] for _ in range(n)]\\n        for e in dependencies:\\n            pre[e[1]-1].append(e[0]-1)\\n        \\n        def rec(mask):\\n            if mask == 0:\\n                return 0\\n            \\n            if dp[mask]!=-1:\\n                return dp[mask]\\n        \\n            possible = 0    #Currently possible course bit set\\n            #VERSION-2\\n            for i in range(n):\\n                if mask&(1<<i):\\n                    flag = 1\\n                    for v in pre[i]:\\n                        if mask&(1<<v):\\n                            flag = 0\\n                    if flag:\\n                        possible+=(1<<i)\\n            #VERSION-1\\n            # done = mask^((1<<len(pre))-1)\\n            # for i,val in enumerate(pre):\\n            #     if mask&(1<<i) and val&done == val:\\n            #         possible +=(1<<i)\\n            \\n            submask = possible  #For iteration\\n            dp[mask] = 20\\n            while submask:\\n                if countOne(submask)<=k:\\n                    dp[mask] = min(dp[mask],1+rec(mask-submask))\\n                submask = (submask-1)&possible\\n            return dp[mask]\\n        \\n        dp = [-1]*(1<<n)\\n        ha = {}\\n        return rec((1<<n)-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 709219,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\n    void better(int &x, int y) {\\n        if (x < 0 || x > y) x = y;\\n    }\\npublic:\\n    int minNumberOfSemesters(int n, vector<vector<int>>& dependencies, int k) {\\n        vector<int> d(n);\\n        for (const auto& dep : dependencies) {\\n            d[dep[1] - 1] |= 1 << (dep[0] - 1);\\n        }\\n        vector<int> must(1 << n);\\n        vector<int> one(1 << n);\\n        for (int i = 1; i < must.size(); ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (i & (1 << j)) {\\n                    must[i] |= d[j];\\n                    ++one[i];\\n                }\\n            }\\n        }\\n        vector<int> dp(1 << n, -1);\\n        dp[0] = 0;\\n        for (int i = 1; i < dp.size(); ++i) {\\n            for (int j = i;; j = (j - 1) & i) {\\n                if (dp[j] >= 0) {\\n                    const int select = i ^ j;\\n                    if (one[select] <= k && (must[select] & j) == must[select]) {\\n                        better(dp[i], dp[j] + 1);\\n                    }\\n                }\\n                if (j == 0) break;\\n            }\\n        }\\n        return dp.back();\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    void better(int &x, int y) {\\n        if (x < 0 || x > y) x = y;\\n    }\\npublic:\\n    int minNumberOfSemesters(int n, vector<vector<int>>& dependencies, int k) {\\n        vector<int> d(n);\\n        for (const auto& dep : dependencies) {\\n            d[dep[1] - 1] |= 1 << (dep[0] - 1);\\n        }\\n        vector<int> must(1 << n);\\n        vector<int> one(1 << n);\\n        for (int i = 1; i < must.size(); ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (i & (1 << j)) {\\n                    must[i] |= d[j];\\n                    ++one[i];\\n                }\\n            }\\n        }\\n        vector<int> dp(1 << n, -1);\\n        dp[0] = 0;\\n        for (int i = 1; i < dp.size(); ++i) {\\n            for (int j = i;; j = (j - 1) & i) {\\n                if (dp[j] >= 0) {\\n                    const int select = i ^ j;\\n                    if (one[select] <= k && (must[select] & j) == must[select]) {\\n                        better(dp[i], dp[j] + 1);\\n                    }\\n                }\\n                if (j == 0) break;\\n            }\\n        }\\n        return dp.back();\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 709141,
                "title": "bitmask-dp-o-3-n-2-n-n",
                "content": "The idea is to use DP to get the minimum number of days required to achieve a day set.\\n\\nTo get current mask, it have to be derived from a submask, and the all prereqs in this mask is in the submask. Several optimizations are required for AC: https://cp-algorithms.com/algebra/all-submasks.html and also we can get the prereqs encoded as an integer for the mask just once, instead of computing that each time.\\n\\n```C++\\n#define INF 100\\nclass Solution {\\nprivate:\\npublic:\\n    int minNumberOfSemesters(int n, vector<vector<int>>& dependencies, int k) {\\n      vector<int> dep(n);\\n      for (vector<int>& d : dependencies){\\n        dep[d[1]-1] |= 1 << (d[0]-1);\\n      }\\n      vector<int> dp;\\n      dp = vector<int>(1 << n, INF);\\n      dp[0] = 0;\\n      for (int mask = 1; mask < (1 << n); ++mask) {\\n        int need = 0;\\n        for (int i = 0; i < n; ++i) {\\n          if (mask & (1 << i)) {\\n            need |= dep[i];\\n          }\\n        }\\n        for(int s = mask; ; s = (s - 1) & mask) {\\n          //cerr <<\"first:\"<< mask << \", \" << s << endl;\\n          // Check if passable from s to mask.\\n          if (__builtin_popcountll(mask - s) > k) {\\n            if(s==0)break;\\n            continue;\\n          }\\n          if ((need | s) != s) {\\n            if(s==0)break;\\n            continue;\\n          }\\n          //cerr << \"Survived \" << mask << \", \" << s << endl;\\n          dp[mask] = min(dp[mask], dp[s] + 1);\\n          //cerr << \"dp[\" << mask << \"] = \" << dp[mask] << endl;\\n          if (s == 0) break;\\n        }\\n      }\\n      return dp[(1 << n) - 1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\n#define INF 100\\nclass Solution {\\nprivate:\\npublic:\\n    int minNumberOfSemesters(int n, vector<vector<int>>& dependencies, int k) {\\n      vector<int> dep(n);\\n      for (vector<int>& d : dependencies){\\n        dep[d[1]-1] |= 1 << (d[0]-1);\\n      }\\n      vector<int> dp;\\n      dp = vector<int>(1 << n, INF);\\n      dp[0] = 0;\\n      for (int mask = 1; mask < (1 << n); ++mask) {\\n        int need = 0;\\n        for (int i = 0; i < n; ++i) {\\n          if (mask & (1 << i)) {\\n            need |= dep[i];\\n          }\\n        }\\n        for(int s = mask; ; s = (s - 1) & mask) {\\n          //cerr <<\"first:\"<< mask << \", \" << s << endl;\\n          // Check if passable from s to mask.\\n          if (__builtin_popcountll(mask - s) > k) {\\n            if(s==0)break;\\n            continue;\\n          }\\n          if ((need | s) != s) {\\n            if(s==0)break;\\n            continue;\\n          }\\n          //cerr << \"Survived \" << mask << \", \" << s << endl;\\n          dp[mask] = min(dp[mask], dp[s] + 1);\\n          //cerr << \"dp[\" << mask << \"] = \" << dp[mask] << endl;\\n          if (s == 0) break;\\n        }\\n      }\\n      return dp[(1 << n) - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 709001,
                "title": "python-selecting-by-making-as-much-as-possible-courses-available-in-the-next-turn",
                "content": "Update:\\nNow this solution takes depth into consideration. It passed @s_tsat \\'s test case \\nI think my solution will fail in some other cases, but I haven\\'t come up with one. \\n\\n---\\n\\nThe idea is the current selected courses should make as much as possible courses avaiable in the next turn. \\nWe can only selected the atmost `k` avaiable courses whose `indegree==0` in each turn: \\n* if the number of avaiable courses in this turn `<=k`, select all of them\\n* if `>k`, we sort the list of avaiable courses based on this weight:\\n\\t* as for course `x`, `w(x)=min(indegree[x\\'s neighbor 0], indegree[x\\'s neighbor 1], ..., indegree[x\\'s neighbor m])*100+(15-depth(x))`\\n\\t* if the outdegree of `x` is 0, `w(x)=n*100+(15-depth(x))`\\n\\n(we can also use a heap, however the total num of nodes is <=15, sorting will work fine in this case) \\n\\n```python\\nclass Solution:\\n    def minNumberOfSemesters(self, n: int, dependencies: List[List[int]], k: int) -> int:\\n        # labeled 1->n \\n        if n<2 or k<2:\\n            return n\\n        if len(dependencies)<1:\\n            if n%k==0:\\n                return n//k\\n            else:\\n                return n//k+1\\n        indegree=[0]*(n+1)\\n        depth=[0]*(n+1)\\n        graph={}\\n        for prereq,item in dependencies:\\n            indegree[item]+=1\\n            if prereq not in graph:\\n                graph[prereq]={}\\n            graph[prereq][item]=1\\n        taken=0\\n        step=0\\n        def dfs(node):\\n            if depth[node]>0:\\n                return depth[node]\\n            if node not in graph:\\n                depth[node]=1\\n                return 1\\n            max_val=1\\n            for next in graph[node]:\\n                ret=dfs(next)\\n                max_val=max(max_val,ret)\\n            depth[node]=max_val+1\\n            return max_val+1\\n        for idx in range(1,n+1):\\n            dfs(idx)\\n        def test(x):\\n            if x in graph:\\n                return min(map(lambda y:indegree[y],graph[x].keys()))*100+15-depth[x]\\n            else:\\n                return n*100+15-depth[x]\\n        while taken<n:\\n            target=[]\\n            for idx in range(1,n+1):\\n                if indegree[idx]==0:\\n                    target.append(idx)\\n            if len(target)<=k:\\n                total=len(target)\\n            else:\\n                target.sort(key=test)\\n                total=k\\n            for idx in range(total):\\n                item=target[idx]\\n                indegree[item]=-1\\n                if item in graph:\\n                    for next in graph[item]:\\n                        indegree[next]-=1\\n            taken+=total\\n            step+=1\\n        return step\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minNumberOfSemesters(self, n: int, dependencies: List[List[int]], k: int) -> int:\\n        # labeled 1->n \\n        if n<2 or k<2:\\n            return n\\n        if len(dependencies)<1:\\n            if n%k==0:\\n                return n//k\\n            else:\\n                return n//k+1\\n        indegree=[0]*(n+1)\\n        depth=[0]*(n+1)\\n        graph={}\\n        for prereq,item in dependencies:\\n            indegree[item]+=1\\n            if prereq not in graph:\\n                graph[prereq]={}\\n            graph[prereq][item]=1\\n        taken=0\\n        step=0\\n        def dfs(node):\\n            if depth[node]>0:\\n                return depth[node]\\n            if node not in graph:\\n                depth[node]=1\\n                return 1\\n            max_val=1\\n            for next in graph[node]:\\n                ret=dfs(next)\\n                max_val=max(max_val,ret)\\n            depth[node]=max_val+1\\n            return max_val+1\\n        for idx in range(1,n+1):\\n            dfs(idx)\\n        def test(x):\\n            if x in graph:\\n                return min(map(lambda y:indegree[y],graph[x].keys()))*100+15-depth[x]\\n            else:\\n                return n*100+15-depth[x]\\n        while taken<n:\\n            target=[]\\n            for idx in range(1,n+1):\\n                if indegree[idx]==0:\\n                    target.append(idx)\\n            if len(target)<=k:\\n                total=len(target)\\n            else:\\n                target.sort(key=test)\\n                total=k\\n            for idx in range(total):\\n                item=target[idx]\\n                indegree[item]=-1\\n                if item in graph:\\n                    for next in graph[item]:\\n                        indegree[next]-=1\\n            taken+=total\\n            step+=1\\n        return step\\n```",
                "codeTag": "Java"
            },
            {
                "id": 708949,
                "title": "i-think-my-solution-is-correct",
                "content": "n = 10\\ndeps = [[1,5],[1,6],[1,7],[2,5],[2,6],[2,7],[9,10],[10,5],[10,6],[10,7],[10,8],[3,5],[3,6],[4,5],[4,6]]\\nk = 2\\nanswer = 5\\nn = 9\\ndeps = [[1,4],[1,5],[3,5],[3,6],[2,6],[2,7],[8,4],[8,5],[9,6],[9,7]]\\nk = 3\\nanswer = 4 (where the expected from lettcode is 3 which is wrong)\\n\\n\\nclass Solution:\\n    def minNumberOfSemesters(self, n: int, dependencies: List[List[int]], k: int) -> int:\\n        \\n        self._g = collections.defaultdict(list)\\n        self._g2 = collections.defaultdict(list)\\n        for xi, yi in dependencies:\\n            self._g[yi].append(xi)\\n            self._g2[xi].append(yi)\\n        \\n        self._max_depth = 0\\n        \\n        node_depth = collections.defaultdict(int)\\n        for node in range(1, n + 1):\\n            if node not in node_depth:\\n                self._find_depth(node, node_depth)\\n            \\n        depth_node = collections.defaultdict(list)\\n        for node, depth in node_depth.items():\\n            depth_node[depth + self._max_depth].append(node)\\n            \\n        print(depth_node)\\n        \\n        h = []\\n        \\n        seen = set()\\n        for node in range(1, n + 1):\\n            if len(self._g[node]) == 0:\\n                h.append([-node_depth[node], node])\\n                seen.add(node)\\n        heapq.heapify(h)\\n        \\n        print(h)\\n\\n        count = 0\\n        while h:\\n            h2 = []\\n            cur_depth, _ = h[0]\\n            if h and h[0][0] == cur_depth:\\n                count += 1\\n                for _ in range(k):\\n                    if not h:\\n                        break\\n                    d, node = heapq.heappop(h)\\n                    for child in self._g2[node]:\\n                        self._g[child].remove(node)\\n                        if not self._g[child] and child not in seen:\\n                            seen.add(child)\\n                            heapq.heappush(h2, [-node_depth[child], child])\\n            while h:\\n                heapq.heappush(h2, h.pop())\\n            h = h2\\n        return count\\n    \\n    def _find_depth(self, node, node_depth):\\n        if node in node_depth:\\n            return node_depth[node]\\n        result = 0\\n        for child in self._g2[node]:\\n            result = max(result, 1 + self._find_depth(child, node_depth))\\n        node_depth[node] = result\\n        self._max_depth = max(self._max_depth, result)\\n        return result\\n\\n",
                "solutionTags": [],
                "code": "n = 10\\ndeps = [[1,5],[1,6],[1,7],[2,5],[2,6],[2,7],[9,10],[10,5],[10,6],[10,7],[10,8],[3,5],[3,6],[4,5],[4,6]]\\nk = 2\\nanswer = 5\\nn = 9\\ndeps = [[1,4],[1,5],[3,5],[3,6],[2,6],[2,7],[8,4],[8,5],[9,6],[9,7]]\\nk = 3\\nanswer = 4 (where the expected from lettcode is 3 which is wrong)\\n\\n\\nclass Solution:\\n    def minNumberOfSemesters(self, n: int, dependencies: List[List[int]], k: int) -> int:\\n        \\n        self._g = collections.defaultdict(list)\\n        self._g2 = collections.defaultdict(list)\\n        for xi, yi in dependencies:\\n            self._g[yi].append(xi)\\n            self._g2[xi].append(yi)\\n        \\n        self._max_depth = 0\\n        \\n        node_depth = collections.defaultdict(int)\\n        for node in range(1, n + 1):\\n            if node not in node_depth:\\n                self._find_depth(node, node_depth)\\n            \\n        depth_node = collections.defaultdict(list)\\n        for node, depth in node_depth.items():\\n            depth_node[depth + self._max_depth].append(node)\\n            \\n        print(depth_node)\\n        \\n        h = []\\n        \\n        seen = set()\\n        for node in range(1, n + 1):\\n            if len(self._g[node]) == 0:\\n                h.append([-node_depth[node], node])\\n                seen.add(node)\\n        heapq.heapify(h)\\n        \\n        print(h)\\n\\n        count = 0\\n        while h:\\n            h2 = []\\n            cur_depth, _ = h[0]\\n            if h and h[0][0] == cur_depth:\\n                count += 1\\n                for _ in range(k):\\n                    if not h:\\n                        break\\n                    d, node = heapq.heappop(h)\\n                    for child in self._g2[node]:\\n                        self._g[child].remove(node)\\n                        if not self._g[child] and child not in seen:\\n                            seen.add(child)\\n                            heapq.heappush(h2, [-node_depth[child], child])\\n            while h:\\n                heapq.heappush(h2, h.pop())\\n            h = h2\\n        return count\\n    \\n    def _find_depth(self, node, node_depth):\\n        if node in node_depth:\\n            return node_depth[node]\\n        result = 0\\n        for child in self._g2[node]:\\n            result = max(result, 1 + self._find_depth(child, node_depth))\\n        node_depth[node] = result\\n        self._max_depth = max(self._max_depth, result)\\n        return result\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 708682,
                "title": "c-greedy-solution-with-picture-example",
                "content": "[This solution worked for the test but greedy solution is not the right solution. There are test cases where it will fail like other greedy solutions]\\nGive that course the highest priority which will open up the maximum number of **UNOPENED** courses for us in the next semester.\\n\\nExample:- \\n![image](https://assets.leetcode.com/users/images/350cd502-9c56-473f-a151-baa8a2dcefdd_1593287373.4997926.png)\\n\\nIn the above graph, if we choose ```1``` and ```2``` first, then they will not open up any new course for us to take in next semester. And then in second semester we have to take ```3```. And then in third semester, we will take ```4```. So in total, 3 semesters.\\n**BUT** if we take ```3``` before ```1``` and ```2```, then it will open up ```4``` for second semster and we can take it in second semester as we have a maximum course limit of 2. So the total semesters will be 2 in this case. \\n```\\nclass Solution {\\npublic:\\n    int minNumberOfSemesters(int n, vector<vector<int>>& d, int k) {\\n        vector<int> indeg(n+1,0);\\n        vector<vector<int>> g(n+1,vector<int>());\\n        for(auto x : d){\\n            g[x[0]].push_back(x[1]);\\n            indeg[x[1]]++;\\n        }\\n        int sem = 0;\\n        priority_queue<pair<int,int>> q;\\n        for(int i=1;i<=n;i++){\\n            if(indeg[i]==0){\\n                int count = 0;\\n                for(auto x: g[i]) if(indeg[x]) count++;\\n                q.push({count,i});   \\n            }\\n        } \\n        while(!q.empty()){\\n            int temp = min((int)q.size(),k);    \\n            sem++;\\n            vector<int> tops;\\n            while(temp--){\\n                auto [_,x] = q.top();\\n                q.pop();\\n                tops.push_back(x);\\n            }\\n            for(auto x: tops){\\n                for(auto neigh: g[x]){\\n                    indeg[neigh]--;\\n                    if(indeg[neigh]==0){\\n                        int count = 0;\\n                        for(auto x: g[neigh]) if(indeg[x]) count++;\\n                        q.push({count,neigh});   \\n                    }\\n                }    \\n            }\\n        }\\n        return sem;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```1```\n```2```\n```3```\n```4```\n```3```\n```1```\n```2```\n```4```\n```\\nclass Solution {\\npublic:\\n    int minNumberOfSemesters(int n, vector<vector<int>>& d, int k) {\\n        vector<int> indeg(n+1,0);\\n        vector<vector<int>> g(n+1,vector<int>());\\n        for(auto x : d){\\n            g[x[0]].push_back(x[1]);\\n            indeg[x[1]]++;\\n        }\\n        int sem = 0;\\n        priority_queue<pair<int,int>> q;\\n        for(int i=1;i<=n;i++){\\n            if(indeg[i]==0){\\n                int count = 0;\\n                for(auto x: g[i]) if(indeg[x]) count++;\\n                q.push({count,i});   \\n            }\\n        } \\n        while(!q.empty()){\\n            int temp = min((int)q.size(),k);    \\n            sem++;\\n            vector<int> tops;\\n            while(temp--){\\n                auto [_,x] = q.top();\\n                q.pop();\\n                tops.push_back(x);\\n            }\\n            for(auto x: tops){\\n                for(auto neigh: g[x]){\\n                    indeg[neigh]--;\\n                    if(indeg[neigh]==0){\\n                        int count = 0;\\n                        for(auto x: g[neigh]) if(indeg[x]) count++;\\n                        q.push({count,neigh});   \\n                    }\\n                }    \\n            }\\n        }\\n        return sem;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 708610,
                "title": "java-backtracking-2ms",
                "content": "Although my code looks ugly but I hope it helps. Sorry for my poor English...\\n\\nFirst, let me explain those variables\\n\\n**graph**: graph for inBound\\n**outBound**: graph for outBound\\n**single** in minNumberofSemesters(): a set to record those nodes are not connecting to any others\\n**single** in helper(): the amount of nodes that are not connecting to any others and haven\\'t been visited (It doesn\\'t matter who it is, so we could just use an integer)\\n**list**: the nodes that we **could** visited in this round\\n**set**: the nodes that we **haven\\'t** visited in this round\\n**nextRound**: those node that could be visited in next round\\n**index**: the current index in the list. (we could either choose it or not choose it)\\n**picked**: the amount of nodes that we have picked in this round\\n**currCount**: the semesters that we have used\\n**remain**: the amount of nodes that we haven\\'t visited\\n\\n1. We use two graphs, one for inbound(graph) and  the other for outbound(outBound). Then we also need to record those Single Nodes(I mean they don\\'t connect to any other nodes. Sorry that I don\\'t know how to call them...) in the graph. (Or it will get TLE in testcase 15, [[2,1]], 4)\\nUse a list to record the nodes that we could visit in this round, and use a set to record those nodes that we haven\\'t visited but could be visited in this round.\\n\\n2. Use backtracking to pick k nodes from the hashset for this round. We could either choose or not choose the node(list[index]). If the amount of nodes that we could use for this round is less than k, and there are some Single Nodes that we haven\\'t visited, then we visited those Single Nodes by just deducting the number. We will go to the next round if we have picked k nodes for this round or we don\\'t have anything remaining in this round that we could pick. The recursive function will end when we have visited all the nodes.\\n\\nBelow is the case why we need to use backtracking (each number means a node)\\n5\\n[[3, 5],[4,5]]\\n3\\n\\ngraph:\\n1\\n2\\n3 -> 5\\n4 \\u5201\\n\\nThe Chinese word means an arrow (4 -> 5).\\nIn this case, we should choose either (1, 3, 4) or (2, 3, 4) in the first semester. After that we could choose (2, 5) or (1, 5) in the second semester. So we could complete it in two semesters. If we choose (1,2,3) in the first semester, then we will need 3 semesters to complete it.\\n```\\nclass Solution {\\n    private int ans;\\n    \\n    public int minNumberOfSemesters(int n, int[][] dependencies, int k) {\\n        ans = n;\\n        Set<Integer>[] graph = new Set[n];\\n        List<Integer>[] outBound = new List[n];\\n        Set<Integer> single = new HashSet<>();\\n        for (int i=0; i<n; i++) {\\n            graph[i] = new HashSet<>();\\n            outBound[i] = new ArrayList<>();\\n            single.add(i);\\n        }\\n        for (int[] d : dependencies) {\\n            graph[d[1]-1].add(d[0] - 1);\\n            outBound[d[0]-1].add(d[1] - 1);\\n            single.remove(d[0] - 1);\\n            single.remove(d[1] - 1);\\n        }\\n        List<Integer> list = new ArrayList<>();\\n        Set<Integer> set = new HashSet<>();\\n        for (int i=0; i<n; i++) {\\n            if (graph[i].size() == 0 && !single.contains(i)) {\\n                list.add(i);\\n                set.add(i);\\n            }\\n        }\\n        helper(graph, outBound, list, set, new HashSet<>(), single.size(), k, 0, 0, 0, n);\\n        return ans;\\n    }\\n    \\n    private void helper(Set<Integer>[] graph, List<Integer>[] outBound, List<Integer> list, Set<Integer> set, Set<Integer> nextRound, int single, int k, int index, int picked, int currCount, int remain) {\\n        if (picked == k || set.size() == 0) {\\n            currCount++;\\n            if (k - picked > 0) {\\n                remain -= Math.min(single, k - picked);\\n                single -= Math.min(single, k - picked);\\n            }\\n            if (remain > 0) {\\n                nextRound.addAll(set);\\n                List<Integer> newList = new ArrayList<>(nextRound);\\n                helper(graph, outBound, newList, nextRound, new HashSet<>(), single, k, 0, 0, currCount, remain);\\n                nextRound.removeAll(set);\\n            } else {\\n                ans = Math.min(ans, currCount);\\n            }\\n            return;\\n        }\\n        int curr = list.get(index);\\n        set.remove(curr);\\n        for (int num : outBound[curr]) {\\n            graph[num].remove(curr);\\n            if (graph[num].size() == 0) {\\n                nextRound.add(num);\\n            }\\n        }\\n        helper(graph, outBound, list, set, nextRound, single, k, index + 1, picked + 1, currCount, remain - 1);\\n        set.add(curr);\\n        for (int num : outBound[curr]) {\\n            if (graph[num].size() == 0) {\\n                nextRound.remove(num);\\n            }\\n            graph[num].add(curr);\\n        }\\n        if (list.size() - index - 1 >= k - picked) {\\n            helper(graph, outBound, list, set, nextRound, single, k, index + 1, picked, currCount, remain);\\n        }\\n    }\\n}\\n```\\nUpdate:\\nBitmask version\\n```\\nclass Solution {\\n    private int ans;\\n    \\n    public int minNumberOfSemesters(int n, int[][] dependencies, int k) {\\n        ans = n;\\n        int available = 0;\\n        int[] pre = new int[n];\\n        for (int[] d : dependencies) {\\n            pre[d[1] - 1] |= (1 << (d[0] - 1));\\n        }\\n        for (int i=0; i<n; i++) {\\n            if (pre[i] == 0) {\\n                available |= (1 << i);\\n            }\\n        }\\n        exec(n, k, available, 0, 0, pre);\\n        return ans;\\n    }\\n    \\n    private void exec(int n, int k, int available, int round, int visited, int[] pre) {\\n        if (available == 0) {\\n            ans = Math.min(ans, round);\\n            return;\\n        } else if (round == ans) {\\n            return;\\n        }\\n        int availableBitCount = Integer.bitCount(available);\\n        int nextAvailable = 0;\\n        int v = 0;\\n        if (availableBitCount <= k) {\\n            nextAvailable = 0;\\n            v = visited | available;\\n            for (int i=0; i<n; i++) {\\n                if ((v & (1 << i)) == 0 && (pre[i] & v) == pre[i]) {\\n                    nextAvailable |= (1 << i);\\n                }\\n            }\\n            exec(n, k, nextAvailable, round + 1, v, pre);\\n        } else {\\n            for (int a=available; a>0; a=(a-1)&available) {\\n                if (Integer.bitCount(a) != k) {\\n                    continue;\\n                }\\n                nextAvailable = 0;\\n                v = visited | a;\\n                for (int i=0; i<n; i++) {\\n                    if ((v & (1 << i)) == 0 && (pre[i] & v) == pre[i]) {\\n                        nextAvailable |= (1 << i);\\n                    }\\n                }\\n                exec(n, k, nextAvailable, round + 1, v, pre);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int ans;\\n    \\n    public int minNumberOfSemesters(int n, int[][] dependencies, int k) {\\n        ans = n;\\n        Set<Integer>[] graph = new Set[n];\\n        List<Integer>[] outBound = new List[n];\\n        Set<Integer> single = new HashSet<>();\\n        for (int i=0; i<n; i++) {\\n            graph[i] = new HashSet<>();\\n            outBound[i] = new ArrayList<>();\\n            single.add(i);\\n        }\\n        for (int[] d : dependencies) {\\n            graph[d[1]-1].add(d[0] - 1);\\n            outBound[d[0]-1].add(d[1] - 1);\\n            single.remove(d[0] - 1);\\n            single.remove(d[1] - 1);\\n        }\\n        List<Integer> list = new ArrayList<>();\\n        Set<Integer> set = new HashSet<>();\\n        for (int i=0; i<n; i++) {\\n            if (graph[i].size() == 0 && !single.contains(i)) {\\n                list.add(i);\\n                set.add(i);\\n            }\\n        }\\n        helper(graph, outBound, list, set, new HashSet<>(), single.size(), k, 0, 0, 0, n);\\n        return ans;\\n    }\\n    \\n    private void helper(Set<Integer>[] graph, List<Integer>[] outBound, List<Integer> list, Set<Integer> set, Set<Integer> nextRound, int single, int k, int index, int picked, int currCount, int remain) {\\n        if (picked == k || set.size() == 0) {\\n            currCount++;\\n            if (k - picked > 0) {\\n                remain -= Math.min(single, k - picked);\\n                single -= Math.min(single, k - picked);\\n            }\\n            if (remain > 0) {\\n                nextRound.addAll(set);\\n                List<Integer> newList = new ArrayList<>(nextRound);\\n                helper(graph, outBound, newList, nextRound, new HashSet<>(), single, k, 0, 0, currCount, remain);\\n                nextRound.removeAll(set);\\n            } else {\\n                ans = Math.min(ans, currCount);\\n            }\\n            return;\\n        }\\n        int curr = list.get(index);\\n        set.remove(curr);\\n        for (int num : outBound[curr]) {\\n            graph[num].remove(curr);\\n            if (graph[num].size() == 0) {\\n                nextRound.add(num);\\n            }\\n        }\\n        helper(graph, outBound, list, set, nextRound, single, k, index + 1, picked + 1, currCount, remain - 1);\\n        set.add(curr);\\n        for (int num : outBound[curr]) {\\n            if (graph[num].size() == 0) {\\n                nextRound.remove(num);\\n            }\\n            graph[num].add(curr);\\n        }\\n        if (list.size() - index - 1 >= k - picked) {\\n            helper(graph, outBound, list, set, nextRound, single, k, index + 1, picked, currCount, remain);\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private int ans;\\n    \\n    public int minNumberOfSemesters(int n, int[][] dependencies, int k) {\\n        ans = n;\\n        int available = 0;\\n        int[] pre = new int[n];\\n        for (int[] d : dependencies) {\\n            pre[d[1] - 1] |= (1 << (d[0] - 1));\\n        }\\n        for (int i=0; i<n; i++) {\\n            if (pre[i] == 0) {\\n                available |= (1 << i);\\n            }\\n        }\\n        exec(n, k, available, 0, 0, pre);\\n        return ans;\\n    }\\n    \\n    private void exec(int n, int k, int available, int round, int visited, int[] pre) {\\n        if (available == 0) {\\n            ans = Math.min(ans, round);\\n            return;\\n        } else if (round == ans) {\\n            return;\\n        }\\n        int availableBitCount = Integer.bitCount(available);\\n        int nextAvailable = 0;\\n        int v = 0;\\n        if (availableBitCount <= k) {\\n            nextAvailable = 0;\\n            v = visited | available;\\n            for (int i=0; i<n; i++) {\\n                if ((v & (1 << i)) == 0 && (pre[i] & v) == pre[i]) {\\n                    nextAvailable |= (1 << i);\\n                }\\n            }\\n            exec(n, k, nextAvailable, round + 1, v, pre);\\n        } else {\\n            for (int a=available; a>0; a=(a-1)&available) {\\n                if (Integer.bitCount(a) != k) {\\n                    continue;\\n                }\\n                nextAvailable = 0;\\n                v = visited | a;\\n                for (int i=0; i<n; i++) {\\n                    if ((v & (1 << i)) == 0 && (pre[i] & v) == pre[i]) {\\n                        nextAvailable |= (1 << i);\\n                    }\\n                }\\n                exec(n, k, nextAvailable, round + 1, v, pre);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 708554,
                "title": "java-2ms-dfs",
                "content": "```\\nclass Solution {\\n    List<Integer>adjecent[];\\n    int in[];\\n    Set<Integer>set=new HashSet<>();\\n    int res=Integer.MAX_VALUE;\\n    int N;int K;\\n    Set<Integer>has=new HashSet<>();\\n    public int minNumberOfSemesters(int n, int[][] dependencies, int k) {\\n        this.N=n;this.K=k;\\n        in=new int[n+1];\\n        adjecent=new ArrayList[n+1];\\n        for(int i=0;i<adjecent.length;i++){\\n            adjecent[i]=new ArrayList<>();\\n        }\\n        for(int pair[]:dependencies){\\n            int v1=pair[0],v2=pair[1];\\n            adjecent[v1].add(v2);\\n            has.add(v2);has.add(v1);\\n            in[v2]++;\\n        }\\n        set=new HashSet<>();\\n        int remain=N-set.size();\\n        dfs(0,has.size(),N-has.size());\\n        return res;\\n        \\n    }\\n    \\n    public void dfs(int cnt,int remain,int have){\\n        if(set.size()==N){\\n            res=Math.min(res,cnt);\\n            return;\\n        }\\n        List<Integer>list=get();//get possible course;\\n        List<List<Integer>>com=new ArrayList<>();\\n        int sum=0;\\n        for(int i:in)sum+=i;\\n        if(sum==0){\\n            int newr=remain+have;\\n            if(newr%K==0)res=Math.min(res,cnt+(newr/K));\\n            else res=Math.min(res,cnt+(newr/K)+1);\\n            return;\\n        }\\n        combination(list,0,K,new ArrayList<>(),com);\\n        for(int i=0;i<com.size();i++){\\n            List<Integer>course=com.get(i);\\n            for(int c:course){\\n                set.add(c);\\n                List<Integer>childs=adjecent[c];\\n                for(int chi:childs){\\n                    in[chi]--;\\n                }\\n            }\\n            int newr=remain-course.size();\\n            if(course.size()<K){\\n                int more=(K-course.size());\\n                have-=more;\\n                have=Math.max(have,0);\\n            }\\n            dfs(cnt+1,newr,have);\\n            for(int c:course){\\n                set.remove(c);\\n                List<Integer>childs=adjecent[c];\\n                for(int chi:childs)in[chi]++;\\n            }\\n        }\\n        \\n    }\\n    public void combination(List<Integer>list,int start,int k,List<Integer>cur,List<List<Integer>>com){\\n        if(k==0||start>=list.size()){\\n            if(cur.size()==Math.min(list.size(),K))com.add(new ArrayList<>(cur));\\n        }\\n        for(int i=start;i<list.size();i++){\\n            cur.add(list.get(i)); \\n            combination(list,i+1,k-1,cur,com);\\n            cur.remove(cur.size()-1);\\n        }\\n    }\\n    \\n    public List<Integer> get(){\\n        List<Integer>list=new ArrayList<>();\\n        for(int i=1;i<in.length;i++){\\n            if(in[i]==0&&!set.contains(i)&&has.contains(i)){\\n                list.add(i);\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    List<Integer>adjecent[];\\n    int in[];\\n    Set<Integer>set=new HashSet<>();\\n    int res=Integer.MAX_VALUE;\\n    int N;int K;\\n    Set<Integer>has=new HashSet<>();\\n    public int minNumberOfSemesters(int n, int[][] dependencies, int k) {\\n        this.N=n;this.K=k;\\n        in=new int[n+1];\\n        adjecent=new ArrayList[n+1];\\n        for(int i=0;i<adjecent.length;i++){\\n            adjecent[i]=new ArrayList<>();\\n        }\\n        for(int pair[]:dependencies){\\n            int v1=pair[0],v2=pair[1];\\n            adjecent[v1].add(v2);\\n            has.add(v2);has.add(v1);\\n            in[v2]++;\\n        }\\n        set=new HashSet<>();\\n        int remain=N-set.size();\\n        dfs(0,has.size(),N-has.size());\\n        return res;\\n        \\n    }\\n    \\n    public void dfs(int cnt,int remain,int have){\\n        if(set.size()==N){\\n            res=Math.min(res,cnt);\\n            return;\\n        }\\n        List<Integer>list=get();//get possible course;\\n        List<List<Integer>>com=new ArrayList<>();\\n        int sum=0;\\n        for(int i:in)sum+=i;\\n        if(sum==0){\\n            int newr=remain+have;\\n            if(newr%K==0)res=Math.min(res,cnt+(newr/K));\\n            else res=Math.min(res,cnt+(newr/K)+1);\\n            return;\\n        }\\n        combination(list,0,K,new ArrayList<>(),com);\\n        for(int i=0;i<com.size();i++){\\n            List<Integer>course=com.get(i);\\n            for(int c:course){\\n                set.add(c);\\n                List<Integer>childs=adjecent[c];\\n                for(int chi:childs){\\n                    in[chi]--;\\n                }\\n            }\\n            int newr=remain-course.size();\\n            if(course.size()<K){\\n                int more=(K-course.size());\\n                have-=more;\\n                have=Math.max(have,0);\\n            }\\n            dfs(cnt+1,newr,have);\\n            for(int c:course){\\n                set.remove(c);\\n                List<Integer>childs=adjecent[c];\\n                for(int chi:childs)in[chi]++;\\n            }\\n        }\\n        \\n    }\\n    public void combination(List<Integer>list,int start,int k,List<Integer>cur,List<List<Integer>>com){\\n        if(k==0||start>=list.size()){\\n            if(cur.size()==Math.min(list.size(),K))com.add(new ArrayList<>(cur));\\n        }\\n        for(int i=start;i<list.size();i++){\\n            cur.add(list.get(i)); \\n            combination(list,i+1,k-1,cur,com);\\n            cur.remove(cur.size()-1);\\n        }\\n    }\\n    \\n    public List<Integer> get(){\\n        List<Integer>list=new ArrayList<>();\\n        for(int i=1;i<in.length;i++){\\n            if(in[i]==0&&!set.contains(i)&&has.contains(i)){\\n                list.add(i);\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 708518,
                "title": "c-curious-why-depth-is-needed-dry-run-using-indegree-and-outdegree",
                "content": "First just thought of using topological sorting and using greedy approach but it failed for the last case:(could not sovle this during contest just because of last test case)\\n```\\n9\\n[[4,8],[3,6],[6,8],[7,6],[4,2],[4,1],[4,7],[3,7],[5,2],[5,9],[3,4],[6,9],[5,7]]\\n2\\n```\\n\\nThe result is 5 but greedy approach gives 6.\\nSo the intuition is to always takes courses which have more dependents or depth(Basically enabling more courses)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minNumberOfSemesters(int n, vector<vector<int>>& d, int k) {\\n        vector<vector<int>> adj(n+1);\\n        vector<int> ind(n+1);\\n        vector<int> outd(n+1);\\n        \\n        for(auto x:d){\\n            adj[x[0]].push_back(x[1]);   //track all dependent courses\\n            outd[x[0]]++;\\n            ind[x[1]]++;\\n        }\\n        \\n        priority_queue<pair<int,int>> q;\\n        for(int i=1;i<=n;i++){\\n            if(ind[i]==0){\\n                q.push({outd[i],i});        // first take courses with 0 dpendency\\n            }\\n        }\\n        int res=0;\\n        int rem=0;        \\n        while(!q.empty()){\\n            int nc = min((int)q.size(),k);   // take first k courses based on there outdegree.\\n            res++;            \\n            int i=0;            \\n            priority_queue<pair<int,int>> ptemp;   //create temp pq for this iteration\\n            cout<<\"Itetration:\"<<res<<endl;\\n            while(i<nc){\\n                pair<int,int> cs = q.top();\\n                q.pop();         \\n                cout<<\"taking course:\"<<cs.second<<endl;\\n                for(auto x:adj[cs.second]){  \\n                    ind[x]--;                    \\n                    if(ind[x]==0){         // add all courses for next iteration whihc has indegree 0\\n                        ptemp.push({outd[x],x});\\n                    }\\n                }\\n                i++;\\n            }\\n            while(!ptemp.empty()){  // copy temp pq element into orig pq and sort them by outdegree\\n                q.push(ptemp.top());\\n                ptemp.pop();\\n            }\\n        }        \\n        return res;\\n    }\\n};\\n```\\n\\nFor above example using greedy takes courses in below order:\\n```\\nItetration:1\\ntaking course:3\\ntaking course:5\\nItetration:2\\ntaking course:4\\nItetration:3\\ntaking course:2\\ntaking course:1\\nItetration:4\\ntaking course:7\\nItetration:5\\ntaking course:6\\nItetration:6\\ntaking course:8\\ntaking course:9\\n```\\n\\nSorting based on outdegree and taking courses based on depth basically produces results in below order:\\n```\\nItetration:1\\ntaking course:5\\ntaking course:3\\nItetration:2\\ntaking course:4\\nItetration:3\\ntaking course:7\\ntaking course:2\\nItetration:4\\ntaking course:6\\ntaking course:1\\nItetration:5\\ntaking course:9\\ntaking course:8\\n```\\n\\nHope it helps.",
                "solutionTags": [],
                "code": "```\\n9\\n[[4,8],[3,6],[6,8],[7,6],[4,2],[4,1],[4,7],[3,7],[5,2],[5,9],[3,4],[6,9],[5,7]]\\n2\\n```\n```\\nclass Solution {\\npublic:\\n    int minNumberOfSemesters(int n, vector<vector<int>>& d, int k) {\\n        vector<vector<int>> adj(n+1);\\n        vector<int> ind(n+1);\\n        vector<int> outd(n+1);\\n        \\n        for(auto x:d){\\n            adj[x[0]].push_back(x[1]);   //track all dependent courses\\n            outd[x[0]]++;\\n            ind[x[1]]++;\\n        }\\n        \\n        priority_queue<pair<int,int>> q;\\n        for(int i=1;i<=n;i++){\\n            if(ind[i]==0){\\n                q.push({outd[i],i});        // first take courses with 0 dpendency\\n            }\\n        }\\n        int res=0;\\n        int rem=0;        \\n        while(!q.empty()){\\n            int nc = min((int)q.size(),k);   // take first k courses based on there outdegree.\\n            res++;            \\n            int i=0;            \\n            priority_queue<pair<int,int>> ptemp;   //create temp pq for this iteration\\n            cout<<\"Itetration:\"<<res<<endl;\\n            while(i<nc){\\n                pair<int,int> cs = q.top();\\n                q.pop();         \\n                cout<<\"taking course:\"<<cs.second<<endl;\\n                for(auto x:adj[cs.second]){  \\n                    ind[x]--;                    \\n                    if(ind[x]==0){         // add all courses for next iteration whihc has indegree 0\\n                        ptemp.push({outd[x],x});\\n                    }\\n                }\\n                i++;\\n            }\\n            while(!ptemp.empty()){  // copy temp pq element into orig pq and sort them by outdegree\\n                q.push(ptemp.top());\\n                ptemp.pop();\\n            }\\n        }        \\n        return res;\\n    }\\n};\\n```\n```\\nItetration:1\\ntaking course:3\\ntaking course:5\\nItetration:2\\ntaking course:4\\nItetration:3\\ntaking course:2\\ntaking course:1\\nItetration:4\\ntaking course:7\\nItetration:5\\ntaking course:6\\nItetration:6\\ntaking course:8\\ntaking course:9\\n```\n```\\nItetration:1\\ntaking course:5\\ntaking course:3\\nItetration:2\\ntaking course:4\\nItetration:3\\ntaking course:7\\ntaking course:2\\nItetration:4\\ntaking course:6\\ntaking course:1\\nItetration:5\\ntaking course:9\\ntaking course:8\\n```",
                "codeTag": "C++"
            },
            {
                "id": 708362,
                "title": "java-bottom-up-and-top-down-approach-fucking-slow-1480ms-and-1193ms",
                "content": "i am now adding commets   \\nidea is very brutal: on each level(semester) we permute all the combiation and record it on the dp array (1193 ms for java)  O(n**30)\\n\\n\\n```\\nclass Solution {\\n    int min = Integer.MAX_VALUE/2;\\n    Map<Integer,Set<Integer>> par;\\n    Integer[] dp = new Integer[(1<<16)+1];\\n    public int minNumberOfSemesters(int n, int[][] ds, int k) {\\n        if(k==1) return n;\\n        if(ds.length==0){// shortcut for the emety ds\\n            return n%k==0?n/k:n/k+1;\\n        }\\n        int[] son = new int[n+1];\\n        par = new HashMap<>();\\n        int len = ds.length;\\n        for(int i=1;i<=n;i++) par.put(i,new HashSet<>());\\n        for(int i=0;i<ds.length;i++){// this is just topological thing we need to minus degree of the parent node so we need to memo it\\n            int f = ds[i][0];\\n            int t = ds[i][1];\\n            par.get(f).add(t);\\n            son[t]++;\\n        }\\n\\n        boolean[] bol = new boolean[n+1];\\n        Set<Integer> set = new HashSet<>();\\n        for(int i=1;i<=n;i++){\\n            if(son[i]==0){\\n                set.add(i);\\n                bol[i] = true;\\n            }\\n        }\\n        //System.out.println(par);\\n        return dfs(son,k,new boolean[n+1]);\\n    }\\n    int  dfs(int[] son, int k, boolean[] bol){\\n        Set<Integer> set = new HashSet<>();\\n        Set<Integer> nxt = new HashSet<>();\\n        int mask = 0;\\n        for(int i=1;i<son.length;i++){//kind of like topo\\'s degree thing \\n            if(son[i]==0&&(!bol[i])){\\n                set.add(i);\\n                mask = mask|(1<<i);\\n                //System.out.println(level+\" \"+i);\\n            }\\n        }\\n        if(dp[mask]!=null) return dp[mask];// we this situation is calculated just return that value\\n        int res = 10000;\\n         //System.out.println(set+\" fffff\");\\n        if(set.size()>k){\\n            Set<Set<Integer>> get = new HashSet<>();\\n            helper(new ArrayList<>(set),k,new HashSet<>(),get,0);\\n            for(Set<Integer> st:get){//for each combination we do a dfs \\n                int[] neo = Arrays.copyOf(son,son.length);\\n                boolean[] nbol = Arrays.copyOf(bol,son.length);\\n                nxt = new HashSet<>();\\n                //System.out.println(level+\" gg\"+st);\\n                for(int i:st){\\n                    nbol[i] = true;\\n                    for(int p:par.get(i)){\\n                        neo[p]--;\\n                        if(neo[p]==0) nxt.add(p);\\n                    }\\n                }\\n                for(int i=1;i<=son.length-1;i++){// to find which course we need to take next semester\\n                    if(!nbol[i]&&son[i]==0) nxt.add(i);\\n                }\\n                if(nxt.size()==0){// we are good to graduate\\n                    return 1;\\n                }else{\\n                    res = Math.min(res,dfs(neo,k,nbol)+1);\\n                }\\n            }\\n        }else{\\n            int[] neo = Arrays.copyOf(son,son.length);\\n            boolean[] nbol = Arrays.copyOf(bol,son.length);\\n            //System.out.println(set+\" \"+level);\\n            for(int i:set){\\n                nbol[i] = true;\\n                for(int p:par.get(i)){\\n                    neo[p]--;\\n                    if(neo[p]==0) nxt.add(p);   \\n                }\\n            }\\n            if(nxt.size()==0){\\n                return 1;\\n            }else{\\n                res = Math.min(res,dfs(neo,k,nbol)+1);\\n            }\\n        }\\n        return dp[mask] = res;\\n        \\n    }``\\n    void helper(List<Integer> ls, int k, Set<Integer> set, Set<Set<Integer>> res, int pos){//this is to get all the combinations of the input->set\\n        if(set.size()==k){\\n            res.add(new HashSet<>(set));\\n            return;\\n        }\\n        if(pos==ls.size()){\\n           return;\\n        }\\n        set.add(ls.get(pos));\\n        helper(ls,k,set,res,pos+1);\\n        set.remove(ls.get(pos));\\n        helper(ls,k,set,res,pos+1);\\n        \\n    }\\n}\\n```\\n\\n\\n\\nanother solution using bottom up dynamic programming\\n\\n```\\nclass Solution {\\n    int[] dp = new int[(1<<15)];\\n    Map<Integer,Set<Integer>> par;\\n    public int minNumberOfSemesters(int n, int[][] ds, int k) {\\n        if(ds.length==0){\\n            return (n-1)/k+1;\\n        }\\n        par = new HashMap<>();\\n        Arrays.fill(dp,Integer.MAX_VALUE/2);\\n        int N = (1<<(n))-1;\\n        for(int i=0;i<n;i++){\\n            par.put(i,new HashSet<>());\\n        }\\n        int[] son = new int[n];\\n        for(int[] d: ds){\\n            par.get(--d[0]).add(--d[1]);\\n            son[d[1]]++;\\n        }\\n        dp[0] = 0; // dp[i] means smallest semester we need to take in the i status \\n\\t\\t//we use \"push\" in dynamic programming to the next level\\n        for(int i=0;i<N;i++){\\n            int[] neo = Arrays.copyOf(son,n);\\n            Set<Integer> set = new HashSet<>();\\n            for(int j=0;j<n;j++){\\n                if((i|(1<<j))==i){\\n                    set.add(j);\\n                    for(int p:par.get(j)){\\n                        neo[p]--;\\n                    }\\n                }\\n            }\\n            boolean out = false;\\n            for(int j=0;j<n;j++){\\n                if(set.contains(j)&&neo[j]>0){//this status is not reachable\\n                    out = true;\\n                }\\n            }\\n            if(out) continue;// if this status is not reachable we jump out of loop\\n            int mask = 0;\\n            int cnt = 0;\\n            for(int j=0;j<n;j++){// find how many node can we take at next semester\\n                if(!set.contains(j)&&neo[j]==0){\\n                    mask|=(1<<j);\\n                    cnt++;\\n                }\\n            }\\n            if(cnt<=k){\\n                dp[i|mask] = Math.min(dp[i|mask],dp[i]+1);\\n            }else{// permutate all the combination of k nodes under cnt total available nodes\\n                for(int j=0;j<mask;j++){\\n                    if(Integer.bitCount(j)!=k) continue;\\n                    if((mask|j)==mask){\\n                        dp[i|j] = Math.min(dp[i|j],dp[i]+1);\\n                    }\\n                }\\n            } \\n        }\\n        return dp[N];  \\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int min = Integer.MAX_VALUE/2;\\n    Map<Integer,Set<Integer>> par;\\n    Integer[] dp = new Integer[(1<<16)+1];\\n    public int minNumberOfSemesters(int n, int[][] ds, int k) {\\n        if(k==1) return n;\\n        if(ds.length==0){// shortcut for the emety ds\\n            return n%k==0?n/k:n/k+1;\\n        }\\n        int[] son = new int[n+1];\\n        par = new HashMap<>();\\n        int len = ds.length;\\n        for(int i=1;i<=n;i++) par.put(i,new HashSet<>());\\n        for(int i=0;i<ds.length;i++){// this is just topological thing we need to minus degree of the parent node so we need to memo it\\n            int f = ds[i][0];\\n            int t = ds[i][1];\\n            par.get(f).add(t);\\n            son[t]++;\\n        }\\n\\n        boolean[] bol = new boolean[n+1];\\n        Set<Integer> set = new HashSet<>();\\n        for(int i=1;i<=n;i++){\\n            if(son[i]==0){\\n                set.add(i);\\n                bol[i] = true;\\n            }\\n        }\\n        //System.out.println(par);\\n        return dfs(son,k,new boolean[n+1]);\\n    }\\n    int  dfs(int[] son, int k, boolean[] bol){\\n        Set<Integer> set = new HashSet<>();\\n        Set<Integer> nxt = new HashSet<>();\\n        int mask = 0;\\n        for(int i=1;i<son.length;i++){//kind of like topo\\'s degree thing \\n            if(son[i]==0&&(!bol[i])){\\n                set.add(i);\\n                mask = mask|(1<<i);\\n                //System.out.println(level+\" \"+i);\\n            }\\n        }\\n        if(dp[mask]!=null) return dp[mask];// we this situation is calculated just return that value\\n        int res = 10000;\\n         //System.out.println(set+\" fffff\");\\n        if(set.size()>k){\\n            Set<Set<Integer>> get = new HashSet<>();\\n            helper(new ArrayList<>(set),k,new HashSet<>(),get,0);\\n            for(Set<Integer> st:get){//for each combination we do a dfs \\n                int[] neo = Arrays.copyOf(son,son.length);\\n                boolean[] nbol = Arrays.copyOf(bol,son.length);\\n                nxt = new HashSet<>();\\n                //System.out.println(level+\" gg\"+st);\\n                for(int i:st){\\n                    nbol[i] = true;\\n                    for(int p:par.get(i)){\\n                        neo[p]--;\\n                        if(neo[p]==0) nxt.add(p);\\n                    }\\n                }\\n                for(int i=1;i<=son.length-1;i++){// to find which course we need to take next semester\\n                    if(!nbol[i]&&son[i]==0) nxt.add(i);\\n                }\\n                if(nxt.size()==0){// we are good to graduate\\n                    return 1;\\n                }else{\\n                    res = Math.min(res,dfs(neo,k,nbol)+1);\\n                }\\n            }\\n        }else{\\n            int[] neo = Arrays.copyOf(son,son.length);\\n            boolean[] nbol = Arrays.copyOf(bol,son.length);\\n            //System.out.println(set+\" \"+level);\\n            for(int i:set){\\n                nbol[i] = true;\\n                for(int p:par.get(i)){\\n                    neo[p]--;\\n                    if(neo[p]==0) nxt.add(p);   \\n                }\\n            }\\n            if(nxt.size()==0){\\n                return 1;\\n            }else{\\n                res = Math.min(res,dfs(neo,k,nbol)+1);\\n            }\\n        }\\n        return dp[mask] = res;\\n        \\n    }``\\n    void helper(List<Integer> ls, int k, Set<Integer> set, Set<Set<Integer>> res, int pos){//this is to get all the combinations of the input->set\\n        if(set.size()==k){\\n            res.add(new HashSet<>(set));\\n            return;\\n        }\\n        if(pos==ls.size()){\\n           return;\\n        }\\n        set.add(ls.get(pos));\\n        helper(ls,k,set,res,pos+1);\\n        set.remove(ls.get(pos));\\n        helper(ls,k,set,res,pos+1);\\n        \\n    }\\n}\\n```\n```\\nclass Solution {\\n    int[] dp = new int[(1<<15)];\\n    Map<Integer,Set<Integer>> par;\\n    public int minNumberOfSemesters(int n, int[][] ds, int k) {\\n        if(ds.length==0){\\n            return (n-1)/k+1;\\n        }\\n        par = new HashMap<>();\\n        Arrays.fill(dp,Integer.MAX_VALUE/2);\\n        int N = (1<<(n))-1;\\n        for(int i=0;i<n;i++){\\n            par.put(i,new HashSet<>());\\n        }\\n        int[] son = new int[n];\\n        for(int[] d: ds){\\n            par.get(--d[0]).add(--d[1]);\\n            son[d[1]]++;\\n        }\\n        dp[0] = 0; // dp[i] means smallest semester we need to take in the i status \\n\\t\\t//we use \"push\" in dynamic programming to the next level\\n        for(int i=0;i<N;i++){\\n            int[] neo = Arrays.copyOf(son,n);\\n            Set<Integer> set = new HashSet<>();\\n            for(int j=0;j<n;j++){\\n                if((i|(1<<j))==i){\\n                    set.add(j);\\n                    for(int p:par.get(j)){\\n                        neo[p]--;\\n                    }\\n                }\\n            }\\n            boolean out = false;\\n            for(int j=0;j<n;j++){\\n                if(set.contains(j)&&neo[j]>0){//this status is not reachable\\n                    out = true;\\n                }\\n            }\\n            if(out) continue;// if this status is not reachable we jump out of loop\\n            int mask = 0;\\n            int cnt = 0;\\n            for(int j=0;j<n;j++){// find how many node can we take at next semester\\n                if(!set.contains(j)&&neo[j]==0){\\n                    mask|=(1<<j);\\n                    cnt++;\\n                }\\n            }\\n            if(cnt<=k){\\n                dp[i|mask] = Math.min(dp[i|mask],dp[i]+1);\\n            }else{// permutate all the combination of k nodes under cnt total available nodes\\n                for(int j=0;j<mask;j++){\\n                    if(Integer.bitCount(j)!=k) continue;\\n                    if((mask|j)==mask){\\n                        dp[i|j] = Math.min(dp[i|j],dp[i]+1);\\n                    }\\n                }\\n            } \\n        }\\n        return dp[N];  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 708342,
                "title": "java-priority-queue-based-on-depth-greedy",
                "content": "The idea is always to work on the course which has the maximum depth first.\\n```\\nclass Solution {    \\n    public int minNumberOfSemesters(int n, int[][] dependencies, int k) {\\n        List<Integer>[] child = new List[n+1];//track each node\\'s child\\n        int[] inDegree = new int[n + 1];\\n        int[] depth = new int[n+1];\\n        \\n        //Step 1: build map\\n        buildMap(child, inDegree, dependencies,n);\\n        \\n        //Step 2: build depth for each node\\n        for(int i=1; i<=n; i++)\\n            findDepth(child, depth, i);\\n        \\n        // Step3: use heap to always get the course of highest depth\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b)->depth[b]-depth[a]);\\n        \\n        // Step 4: Init the heap using nodes with no dependencies\\n        for(int i=1; i<=n; i++){\\n            if(inDegree[i]==0){\\n                pq.add(i);\\n            }\\n        }\\n\\n        int ans = 0;\\n        while(!pq.isEmpty()){\\n            //Take courses for each semester\\n            Queue<Integer> temp = new LinkedList<>();\\n            for(int i = Math.min(pq.size(), k); i > 0; i--){\\n                temp.add(pq.poll());\\n            }\\n            // Add the child courses to the pq if the indgree for the child node is 0.\\n            while(!temp.isEmpty()){\\n                int u = temp.poll();\\n                for(int v: child[u]){\\n                    if(--inDegree[v] == 0){\\n                        pq.add(v);\\n                    }\\n                }\\n            }            \\n            ans++;          \\n        }\\n        return ans;        \\n    }\\n    \\n    private void buildMap(List<Integer>[] child, int[] inDegree, int[][] dependencies , int n){\\n        for(int i=1; i<=n; i++){\\n            child[i] = new ArrayList();\\n        }\\n        \\n        for(int[] d : dependencies){\\n            int p = d[0];\\n            int c = d[1];\\n            inDegree[c]++;\\n            child[p].add(c);\\n        }        \\n        \\n    }\\n    private int findDepth(List<Integer>[] child, int[] depth, int course){\\n        if(child[course].size()==0){\\n            return 1;\\n        }\\n        if(depth[course]>0) return depth[course];\\n\\n        for(int c : child[course]){\\n            depth[course] = Math.max(depth[course], findDepth(child, depth, c)+1);\\n        }\\n        \\n        return depth[course];\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {    \\n    public int minNumberOfSemesters(int n, int[][] dependencies, int k) {\\n        List<Integer>[] child = new List[n+1];//track each node\\'s child\\n        int[] inDegree = new int[n + 1];\\n        int[] depth = new int[n+1];\\n        \\n        //Step 1: build map\\n        buildMap(child, inDegree, dependencies,n);\\n        \\n        //Step 2: build depth for each node\\n        for(int i=1; i<=n; i++)\\n            findDepth(child, depth, i);\\n        \\n        // Step3: use heap to always get the course of highest depth\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b)->depth[b]-depth[a]);\\n        \\n        // Step 4: Init the heap using nodes with no dependencies\\n        for(int i=1; i<=n; i++){\\n            if(inDegree[i]==0){\\n                pq.add(i);\\n            }\\n        }\\n\\n        int ans = 0;\\n        while(!pq.isEmpty()){\\n            //Take courses for each semester\\n            Queue<Integer> temp = new LinkedList<>();\\n            for(int i = Math.min(pq.size(), k); i > 0; i--){\\n                temp.add(pq.poll());\\n            }\\n            // Add the child courses to the pq if the indgree for the child node is 0.\\n            while(!temp.isEmpty()){\\n                int u = temp.poll();\\n                for(int v: child[u]){\\n                    if(--inDegree[v] == 0){\\n                        pq.add(v);\\n                    }\\n                }\\n            }            \\n            ans++;          \\n        }\\n        return ans;        \\n    }\\n    \\n    private void buildMap(List<Integer>[] child, int[] inDegree, int[][] dependencies , int n){\\n        for(int i=1; i<=n; i++){\\n            child[i] = new ArrayList();\\n        }\\n        \\n        for(int[] d : dependencies){\\n            int p = d[0];\\n            int c = d[1];\\n            inDegree[c]++;\\n            child[p].add(c);\\n        }        \\n        \\n    }\\n    private int findDepth(List<Integer>[] child, int[] depth, int course){\\n        if(child[course].size()==0){\\n            return 1;\\n        }\\n        if(depth[course]>0) return depth[course];\\n\\n        for(int c : child[course]){\\n            depth[course] = Math.max(depth[course], findDepth(child, depth, c)+1);\\n        }\\n        \\n        return depth[course];\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 708138,
                "title": "java-simple-topological-sort-with-explanation-2ms",
                "content": "Basic idea is that we take the course with no Prerequisites. And if there are multiple courses that are ready to take, we pick the ones with more child course.\\nAny advice appreciated!\\n```\\nclass Solution {\\n    public int minNumberOfSemesters(int n, int[][] dependencies, int k) {\\n        if(dependencies == null || dependencies.length == 0){return (n-1)/k+1;}\\n        int[] indegrees = new int[n+1], outdegrees = new int[n+1];\\n        Map<Integer,List<Integer>> graph = new HashMap<>();//<Prerequisite,List<Child>>\\n        for(int[] d : dependencies){\\n            indegrees[d[1]]++;\\n            outdegrees[d[0]]++;\\n            graph.putIfAbsent(d[0],new ArrayList<>());\\n            graph.get(d[0]).add(d[1]);\\n        }\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a,b) -> outdegrees[b]-outdegrees[a]);//We have to take the course with the max child first\\n        int res = 1;\\n        int count = 0;\\n        //We pick the one with no prerequisites and add them to the maxHeap\\n        for(int i = 1;i <= n;i++){\\n            if(indegrees[i] == 0){\\n                maxHeap.add(i);\\n                \\n            }\\n        }\\n        while(!maxHeap.isEmpty()){\\n            List<Integer> next = new ArrayList<>();//Store the course that are ready to take after,\\n\\t\\t\\t//We could only take at most k courses in one semester\\n            for(int i = 0;i < k;i++){\\n                //maxHeap is empty means we couldn\\'t take courses any more in the rest of semester\\n                if(maxHeap.isEmpty()){break;}\\n                int cur = maxHeap.poll();\\n                List<Integer> children = graph.getOrDefault(cur,new ArrayList<>());\\n                for(int child : children){\\n                    //update the indegrees\\n                    indegrees[child]--;\\n                    if(indegrees[child] == 0){\\n                        //the child course is ready the take\\n                        next.add(child);\\n                    }\\n                }\\n                count++;\\n            }\\n            for(int ne : next){\\n                maxHeap.add(ne);\\n            }\\n            //Here we may not need that condition check since it\\'s guaranteed that we can take all courses in some way\\n            if(count == n){return res;}\\n            res++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minNumberOfSemesters(int n, int[][] dependencies, int k) {\\n        if(dependencies == null || dependencies.length == 0){return (n-1)/k+1;}\\n        int[] indegrees = new int[n+1], outdegrees = new int[n+1];\\n        Map<Integer,List<Integer>> graph = new HashMap<>();//<Prerequisite,List<Child>>\\n        for(int[] d : dependencies){\\n            indegrees[d[1]]++;\\n            outdegrees[d[0]]++;\\n            graph.putIfAbsent(d[0],new ArrayList<>());\\n            graph.get(d[0]).add(d[1]);\\n        }\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a,b) -> outdegrees[b]-outdegrees[a]);//We have to take the course with the max child first\\n        int res = 1;\\n        int count = 0;\\n        //We pick the one with no prerequisites and add them to the maxHeap\\n        for(int i = 1;i <= n;i++){\\n            if(indegrees[i] == 0){\\n                maxHeap.add(i);\\n                \\n            }\\n        }\\n        while(!maxHeap.isEmpty()){\\n            List<Integer> next = new ArrayList<>();//Store the course that are ready to take after,\\n\\t\\t\\t//We could only take at most k courses in one semester\\n            for(int i = 0;i < k;i++){\\n                //maxHeap is empty means we couldn\\'t take courses any more in the rest of semester\\n                if(maxHeap.isEmpty()){break;}\\n                int cur = maxHeap.poll();\\n                List<Integer> children = graph.getOrDefault(cur,new ArrayList<>());\\n                for(int child : children){\\n                    //update the indegrees\\n                    indegrees[child]--;\\n                    if(indegrees[child] == 0){\\n                        //the child course is ready the take\\n                        next.add(child);\\n                    }\\n                }\\n                count++;\\n            }\\n            for(int ne : next){\\n                maxHeap.add(ne);\\n            }\\n            //Here we may not need that condition check since it\\'s guaranteed that we can take all courses in some way\\n            if(count == n){return res;}\\n            res++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 708084,
                "title": "c-using-bfs-and-max-heap-priority-queue-easy-to-understand",
                "content": "```\\nstruct comparePair{\\n    bool operator()(const pair<int, int> &a, pair<int, int>& b) {\\n        return a.second < b.second;\\n    }  \\n};\\nclass Solution {\\n   \\npublic:\\n    int minNumberOfSemesters(int n, vector<vector<int>>& dependencies, int k) {\\n        if (n <= 0) return 0;\\n\\n        unordered_map<int, int> inDegree;\\n        unordered_map<int, vector<int>> graph;\\n        for (int i = 1; i <= n; i++) {\\n          inDegree[i] = 0;\\n          graph[i] = vector<int>();\\n        }\\n\\n        for (int i = 0; i < dependencies.size(); i++) {\\n          int parent = dependencies[i][0], child = dependencies[i][1];\\n          graph[parent].push_back(child);\\n          inDegree[child]++;               \\n        }\\n\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, comparePair> sources, helping;\\n        for (auto entry : inDegree) {\\n            if (entry.second == 0) {\\n            sources.push({entry.first, graph[entry.first].size()});\\n          }\\n        }\\n\\n        int count = 0, vertex, number, size;\\n        while (!sources.empty()) {\\n          size = sources.size();\\n          number = min(k, size);\\n          for(int i = 0; i < number; i++) {\\n              vertex = sources.top().first; sources.pop();\\n              vector<int> children = graph[vertex]; \\n              for (auto child : children) {\\n                inDegree[child]--;\\n                if (inDegree[child] == 0) {\\n                  helping.push({child, graph[child].size()});\\n                }\\n              }\\n           }\\n            \\n           while(!helping.empty()) {\\n               sources.push(helping.top());\\n               helping.pop();\\n           }\\n           count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstruct comparePair{\\n    bool operator()(const pair<int, int> &a, pair<int, int>& b) {\\n        return a.second < b.second;\\n    }  \\n};\\nclass Solution {\\n   \\npublic:\\n    int minNumberOfSemesters(int n, vector<vector<int>>& dependencies, int k) {\\n        if (n <= 0) return 0;\\n\\n        unordered_map<int, int> inDegree;\\n        unordered_map<int, vector<int>> graph;\\n        for (int i = 1; i <= n; i++) {\\n          inDegree[i] = 0;\\n          graph[i] = vector<int>();\\n        }\\n\\n        for (int i = 0; i < dependencies.size(); i++) {\\n          int parent = dependencies[i][0], child = dependencies[i][1];\\n          graph[parent].push_back(child);\\n          inDegree[child]++;               \\n        }\\n\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, comparePair> sources, helping;\\n        for (auto entry : inDegree) {\\n            if (entry.second == 0) {\\n            sources.push({entry.first, graph[entry.first].size()});\\n          }\\n        }\\n\\n        int count = 0, vertex, number, size;\\n        while (!sources.empty()) {\\n          size = sources.size();\\n          number = min(k, size);\\n          for(int i = 0; i < number; i++) {\\n              vertex = sources.top().first; sources.pop();\\n              vector<int> children = graph[vertex]; \\n              for (auto child : children) {\\n                inDegree[child]--;\\n                if (inDegree[child] == 0) {\\n                  helping.push({child, graph[child].size()});\\n                }\\n              }\\n           }\\n            \\n           while(!helping.empty()) {\\n               sources.push(helping.top());\\n               helping.pop();\\n           }\\n           count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055198,
                "title": "dp-bitmask-bitmask-enumeration-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[1<<16]; \\n    int solve(int mask, vector<int> adj[], int n, int k){\\n        if(mask == (1<<n) - 1) return 0;\\n        if(dp[mask]!=-1)return dp[mask];\\n        vector<int> ind(n, 0);\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0;j<adj[i].size(); j++){\\n                if((mask & (1<<adj[i][j])) == 0) ind[i]++;\\n            }\\n        }\\n        int cnt = 0;\\n        int temp = 0;\\n        int ans = INT_MAX;\\n        for(int i = 0; i<n; i++) if(ind[i] == 0 && !(mask & (1<<i))) {temp = temp|(1<<i); cnt++;}\\n        if(cnt <= k){\\n            ans = min(ans, 1 + solve(mask|temp, adj, n, k));\\n        }\\n        else{\\n            // Best thing of the question --- Bitmask enumeration \\n            int temp2 = temp;\\n            while(temp2 > 0){\\n                temp2 = (temp2 - 1)&temp;\\n                cnt = __builtin_popcount(temp2);\\n                if(cnt != k) continue;\\n                ans = min(ans, 1 + solve(mask|temp2, adj, n, k));   \\n            }\\n        }\\n        return dp[mask] = ans;\\n    }\\n    int minNumberOfSemesters(int n, vector<vector<int>>& relations, int k) {\\n        vector<int> adj[n];\\n        memset(dp, -1, sizeof(dp));\\n        for(int i = 0; i<relations.size(); i++){\\n            adj[relations[i][1]-1].push_back(relations[i][0]-1);\\n        }\\n        return solve(0, adj, n, k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1<<16]; \\n    int solve(int mask, vector<int> adj[], int n, int k){\\n        if(mask == (1<<n) - 1) return 0;\\n        if(dp[mask]!=-1)return dp[mask];\\n        vector<int> ind(n, 0);\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0;j<adj[i].size(); j++){\\n                if((mask & (1<<adj[i][j])) == 0) ind[i]++;\\n            }\\n        }\\n        int cnt = 0;\\n        int temp = 0;\\n        int ans = INT_MAX;\\n        for(int i = 0; i<n; i++) if(ind[i] == 0 && !(mask & (1<<i))) {temp = temp|(1<<i); cnt++;}\\n        if(cnt <= k){\\n            ans = min(ans, 1 + solve(mask|temp, adj, n, k));\\n        }\\n        else{\\n            // Best thing of the question --- Bitmask enumeration \\n            int temp2 = temp;\\n            while(temp2 > 0){\\n                temp2 = (temp2 - 1)&temp;\\n                cnt = __builtin_popcount(temp2);\\n                if(cnt != k) continue;\\n                ans = min(ans, 1 + solve(mask|temp2, adj, n, k));   \\n            }\\n        }\\n        return dp[mask] = ans;\\n    }\\n    int minNumberOfSemesters(int n, vector<vector<int>>& relations, int k) {\\n        vector<int> adj[n];\\n        memset(dp, -1, sizeof(dp));\\n        for(int i = 0; i<relations.size(); i++){\\n            adj[relations[i][1]-1].push_back(relations[i][0]-1);\\n        }\\n        return solve(0, adj, n, k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038933,
                "title": "detailed-explanation-and-commented-code-on-why-and-how-to-use-bit-masks",
                "content": "# Intuition\\n- Dependency graph is the smaller graph where we do topo sort like Parallel courses 1\\n- Bigger graph is state of completed courses because each semester we have to choose which k cources to take. \\n\\n- Simply traverse the bigger graph where state is all remaining courses and state transition is to take courses. But it will be slow when k is small. So we need to memorize the state. Since n is small, so we can use bit mask to represent the state and do very quick bit operation to generate next available courses to take.\\n\\n# Approach 1 --- [Time Limit Exceeded] Simple Traverse with Backtracking \\n<!-- Describe your approach to solving the problem. -->\\n```\\nclass Solution {\\n    \\n    int n;\\n    int k;\\n    Map<Integer, Set<Integer>> graph;\\n    int[] indegree;\\n    boolean[] taken;\\n    int min;\\n    public int minNumberOfSemesters(int n, int[][] relations, int k) {\\n        this.n = n;\\n        this.k = k;\\n        this.graph = new HashMap<Integer, Set<Integer>>();\\n        this.indegree = new int[n+1];\\n        this.taken = new boolean[n+1];\\n        this.min = Integer.MAX_VALUE;\\n\\n        for(int i=1; i<=n; i++){\\n            graph.put(i, new HashSet<>());\\n        }\\n        for(int[] r: relations){\\n            graph.get(r[0]).add(r[1]);\\n            indegree[r[1]]++;\\n        }\\n        \\n        \\n        dfs(0, 0);\\n\\n        \\n        return min;\\n    }\\n\\n    void dfs(int total, int semester){\\n        if(total == n){\\n            min = Math.min(min, semester);\\n            return;\\n        }\\n        for(var batch: nextBatches()){\\n            take(batch);\\n            dfs(total + batch.size(), semester+1);\\n            untake(batch);\\n        }\\n    }\\n\\n    \\n    void take(List<Integer> courses){\\n        for (int c: courses){\\n            taken[c] = true;\\n            for(int next: graph.get(c)){\\n                indegree[next]--;\\n            }\\n        }\\n    }\\n\\n    void untake(List<Integer> courses){\\n        for (int c: courses){\\n            taken[c] = false;\\n            for(int next: graph.get(c)){\\n                indegree[next]++;\\n            }\\n        }\\n    }\\n\\n    List<List<Integer>> nextBatches(){\\n        List<List<Integer>> batch = new LinkedList<>();\\n        List<Integer> available = IntStream.range(1,n+1).filter(i->!taken[i] && indegree[i]<=0).boxed().toList();\\n        pick(batch, new ArrayList<>(), available, 0, k);\\n        return batch;\\n    }\\n\\n    static void pick(List<List<Integer>> all, List<Integer> cur, List<Integer> list, int start, int k){\\n        if(k >= list.size()){\\n            all.add(new ArrayList<>(list));\\n            return;\\n        }\\n        if(k == 0){\\n            all.add(new ArrayList<>(cur));\\n            return;\\n        }\\n        for(int i=start; i<list.size(); i++){\\n            cur.add(list.get(i));\\n            pick(all, cur, list, i+1, k-1);\\n            cur.remove(cur.size()-1);\\n        }\\n    }\\n\\n\\n}\\n```\\n\\n\\n# Approach 2 [Accepted] With Memo keyed by bitmask\\n```\\nclass Solution {\\n    \\n    int n;\\n    int k;\\n    int[] parents;\\n    int[] dp;\\n    // use a bit mask to represent a set of courses\\n    // this way all filter operations can be faster\\n    public int minNumberOfSemesters(int n, int[][] relations, int k) {\\n        this.n = n;\\n        this.k = k;\\n        // store prerequesite as a bit mask. So indegree can be tracked as well (parents[i] == 0 means it is a root)\\n        this.parents = new int[n];\\n        dp = new int[1<<n];\\n        Arrays.fill(dp, -1);\\n        for(int[] r: relations){\\n            // zero index for convenience of bit masking\\n            int parent = r[0]-1;\\n            parents[r[1]-1] |= 1<<parent;\\n        }\\n        \\n        // start with all remaining\\n        return dfs((1<<n)-1);\\n    }\\n\\n    int dfs(int mask){\\n        if(mask == 0){\\n            // remaining as zero\\n            return 0;\\n        }\\n\\n        if(dp[mask] != -1){\\n            return dp[mask];\\n        }\\n\\n        // use list of integer instead of bit mask for readablity when calculating combinations\\n        List<Integer> available = IntStream.range(0,n)\\n                                            //not taken AND finished prerequisite\\n                                            .filter(i-> (mask&(1<<i)) != 0 && (mask&parents[i])==0)\\n                                            .boxed().toList();\\n        List<List<Integer>> all = new LinkedList<>();\\n        combinations(all, new ArrayList<>(), available, 0, k);\\n\\n        int min = Integer.MAX_VALUE;\\n        for(var batch: all){\\n            int next = mask;\\n            for(int c: batch){\\n                next &= (~(1<<c)); // take course c by setting it to zero\\n            }\\n            min = Math.min (min, 1+dfs(next));\\n        }\\n        dp[mask] = min;\\n        return min;\\n    }\\n\\n    static void combinations(List<List<Integer>> all, List<Integer> cur, List<Integer> list, int start, int k){\\n        if(k >= list.size()){\\n            all.add(new ArrayList<>(list));\\n            return;\\n        }\\n        if(k == 0){\\n            all.add(new ArrayList<>(cur));\\n            return;\\n        }\\n        for(int i=start; i<list.size(); i++){\\n            cur.add(list.get(i));\\n            combinations(all, cur, list, i+1, k-1);\\n            cur.remove(cur.size()-1);\\n        }\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int n;\\n    int k;\\n    Map<Integer, Set<Integer>> graph;\\n    int[] indegree;\\n    boolean[] taken;\\n    int min;\\n    public int minNumberOfSemesters(int n, int[][] relations, int k) {\\n        this.n = n;\\n        this.k = k;\\n        this.graph = new HashMap<Integer, Set<Integer>>();\\n        this.indegree = new int[n+1];\\n        this.taken = new boolean[n+1];\\n        this.min = Integer.MAX_VALUE;\\n\\n        for(int i=1; i<=n; i++){\\n            graph.put(i, new HashSet<>());\\n        }\\n        for(int[] r: relations){\\n            graph.get(r[0]).add(r[1]);\\n            indegree[r[1]]++;\\n        }\\n        \\n        \\n        dfs(0, 0);\\n\\n        \\n        return min;\\n    }\\n\\n    void dfs(int total, int semester){\\n        if(total == n){\\n            min = Math.min(min, semester);\\n            return;\\n        }\\n        for(var batch: nextBatches()){\\n            take(batch);\\n            dfs(total + batch.size(), semester+1);\\n            untake(batch);\\n        }\\n    }\\n\\n    \\n    void take(List<Integer> courses){\\n        for (int c: courses){\\n            taken[c] = true;\\n            for(int next: graph.get(c)){\\n                indegree[next]--;\\n            }\\n        }\\n    }\\n\\n    void untake(List<Integer> courses){\\n        for (int c: courses){\\n            taken[c] = false;\\n            for(int next: graph.get(c)){\\n                indegree[next]++;\\n            }\\n        }\\n    }\\n\\n    List<List<Integer>> nextBatches(){\\n        List<List<Integer>> batch = new LinkedList<>();\\n        List<Integer> available = IntStream.range(1,n+1).filter(i->!taken[i] && indegree[i]<=0).boxed().toList();\\n        pick(batch, new ArrayList<>(), available, 0, k);\\n        return batch;\\n    }\\n\\n    static void pick(List<List<Integer>> all, List<Integer> cur, List<Integer> list, int start, int k){\\n        if(k >= list.size()){\\n            all.add(new ArrayList<>(list));\\n            return;\\n        }\\n        if(k == 0){\\n            all.add(new ArrayList<>(cur));\\n            return;\\n        }\\n        for(int i=start; i<list.size(); i++){\\n            cur.add(list.get(i));\\n            pick(all, cur, list, i+1, k-1);\\n            cur.remove(cur.size()-1);\\n        }\\n    }\\n\\n\\n}\\n```\n```\\nclass Solution {\\n    \\n    int n;\\n    int k;\\n    int[] parents;\\n    int[] dp;\\n    // use a bit mask to represent a set of courses\\n    // this way all filter operations can be faster\\n    public int minNumberOfSemesters(int n, int[][] relations, int k) {\\n        this.n = n;\\n        this.k = k;\\n        // store prerequesite as a bit mask. So indegree can be tracked as well (parents[i] == 0 means it is a root)\\n        this.parents = new int[n];\\n        dp = new int[1<<n];\\n        Arrays.fill(dp, -1);\\n        for(int[] r: relations){\\n            // zero index for convenience of bit masking\\n            int parent = r[0]-1;\\n            parents[r[1]-1] |= 1<<parent;\\n        }\\n        \\n        // start with all remaining\\n        return dfs((1<<n)-1);\\n    }\\n\\n    int dfs(int mask){\\n        if(mask == 0){\\n            // remaining as zero\\n            return 0;\\n        }\\n\\n        if(dp[mask] != -1){\\n            return dp[mask];\\n        }\\n\\n        // use list of integer instead of bit mask for readablity when calculating combinations\\n        List<Integer> available = IntStream.range(0,n)\\n                                            //not taken AND finished prerequisite\\n                                            .filter(i-> (mask&(1<<i)) != 0 && (mask&parents[i])==0)\\n                                            .boxed().toList();\\n        List<List<Integer>> all = new LinkedList<>();\\n        combinations(all, new ArrayList<>(), available, 0, k);\\n\\n        int min = Integer.MAX_VALUE;\\n        for(var batch: all){\\n            int next = mask;\\n            for(int c: batch){\\n                next &= (~(1<<c)); // take course c by setting it to zero\\n            }\\n            min = Math.min (min, 1+dfs(next));\\n        }\\n        dp[mask] = min;\\n        return min;\\n    }\\n\\n    static void combinations(List<List<Integer>> all, List<Integer> cur, List<Integer> list, int start, int k){\\n        if(k >= list.size()){\\n            all.add(new ArrayList<>(list));\\n            return;\\n        }\\n        if(k == 0){\\n            all.add(new ArrayList<>(cur));\\n            return;\\n        }\\n        for(int i=start; i<list.size(); i++){\\n            cur.add(list.get(i));\\n            combinations(all, cur, list, i+1, k-1);\\n            cur.remove(cur.size()-1);\\n        }\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884929,
                "title": "java-dp-bitmask-memoization-clean",
                "content": "# Code\\n```\\nclass Solution {\\n    \\n    int dp[];\\n    int N;\\n    List<Integer>[] children;\\n\\n    public int minNumberOfSemesters(int n, int[][] relations, int k) {\\n        N = n;\\n        //total courses mask\\n        int course_mask = (1<<n)-1;\\n        dp = new int[course_mask+1];\\n\\n        children = new ArrayList[N];\\n        for (int i = 0; i < N; i++) {\\n            children[i] = new ArrayList<>();\\n        }\\n        int[] indegree = new int[N];\\n        for (int i = 0; i < relations.length; i++) {\\n            // change to zero based index\\n            relations[i][0]--;\\n            relations[i][1]--;\\n            children[relations[i][0]].add(relations[i][1]);\\n            indegree[relations[i][1]]++;\\n        }\\n        \\n        return helper(0, k, indegree);\\n    }\\n    \\n    \\n    public int helper(int currentMask, int k, int[] indegree) {\\n        if (currentMask == ((1<<N)-1)) {\\n            return 0;\\n        }\\n        if (dp[currentMask] > 0) {\\n            return dp[currentMask];\\n        }\\n\\n        // create availability mask\\n        int available = 0;\\n        int size = 0;\\n        for (int i = 0; i < N; i++) {\\n            if (indegree[i] > 0) {\\n                continue;\\n            }\\n            if ( ((1 << i) & currentMask) > 0 ) {\\n                continue;\\n            }\\n            size++;\\n            available = available | (1 << i);\\n        }\\n        List<Integer> masks = new ArrayList<>();\\n        generateMasks(0, masks, 0, Math.min(size, k), available);\\n\\n        dp[currentMask] = 20;\\n        for (int mask : masks) {\\n            for (int i = 0; i < N; i++) {\\n                if ( (1<<i & mask) > 0 ) {\\n                    for (int child : children[i]) {\\n                        indegree[child]--;\\n                    }\\n                }\\n            }\\n            dp[currentMask] = Math.min(dp[currentMask], helper(currentMask | mask, k, indegree));\\n            for (int i = 0; i < N; i++) {\\n                if ( (1<<i & mask) > 0 ) {\\n                    for (int child : children[i]) {\\n                        indegree[child]++;\\n                    }\\n                }\\n            }\\n        }\\n        dp[currentMask]++;\\n        return dp[currentMask];\\n    }\\n\\n    public void generateMasks(int start, List<Integer> masks, int newMask, int k, int available) {\\n        if (k == 0) {\\n            masks.add(newMask);\\n            return;\\n        }\\n\\n        for (int i = start; i < N; i++) {\\n            if ( (1<<i & available) == 0 ) {\\n                continue;\\n            }\\n            generateMasks(i+1, masks, newMask | 1<<i, k-1, available);\\n        }\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int dp[];\\n    int N;\\n    List<Integer>[] children;\\n\\n    public int minNumberOfSemesters(int n, int[][] relations, int k) {\\n        N = n;\\n        //total courses mask\\n        int course_mask = (1<<n)-1;\\n        dp = new int[course_mask+1];\\n\\n        children = new ArrayList[N];\\n        for (int i = 0; i < N; i++) {\\n            children[i] = new ArrayList<>();\\n        }\\n        int[] indegree = new int[N];\\n        for (int i = 0; i < relations.length; i++) {\\n            // change to zero based index\\n            relations[i][0]--;\\n            relations[i][1]--;\\n            children[relations[i][0]].add(relations[i][1]);\\n            indegree[relations[i][1]]++;\\n        }\\n        \\n        return helper(0, k, indegree);\\n    }\\n    \\n    \\n    public int helper(int currentMask, int k, int[] indegree) {\\n        if (currentMask == ((1<<N)-1)) {\\n            return 0;\\n        }\\n        if (dp[currentMask] > 0) {\\n            return dp[currentMask];\\n        }\\n\\n        // create availability mask\\n        int available = 0;\\n        int size = 0;\\n        for (int i = 0; i < N; i++) {\\n            if (indegree[i] > 0) {\\n                continue;\\n            }\\n            if ( ((1 << i) & currentMask) > 0 ) {\\n                continue;\\n            }\\n            size++;\\n            available = available | (1 << i);\\n        }\\n        List<Integer> masks = new ArrayList<>();\\n        generateMasks(0, masks, 0, Math.min(size, k), available);\\n\\n        dp[currentMask] = 20;\\n        for (int mask : masks) {\\n            for (int i = 0; i < N; i++) {\\n                if ( (1<<i & mask) > 0 ) {\\n                    for (int child : children[i]) {\\n                        indegree[child]--;\\n                    }\\n                }\\n            }\\n            dp[currentMask] = Math.min(dp[currentMask], helper(currentMask | mask, k, indegree));\\n            for (int i = 0; i < N; i++) {\\n                if ( (1<<i & mask) > 0 ) {\\n                    for (int child : children[i]) {\\n                        indegree[child]++;\\n                    }\\n                }\\n            }\\n        }\\n        dp[currentMask]++;\\n        return dp[currentMask];\\n    }\\n\\n    public void generateMasks(int start, List<Integer> masks, int newMask, int k, int available) {\\n        if (k == 0) {\\n            masks.add(newMask);\\n            return;\\n        }\\n\\n        for (int i = start; i < N; i++) {\\n            if ( (1<<i & available) == 0 ) {\\n                continue;\\n            }\\n            generateMasks(i+1, masks, newMask | 1<<i, k-1, available);\\n        }\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729956,
                "title": "bitmask-dp-recursion-cpp-easy-approach",
                "content": "# Intuition\\n    Idea is to try out all possible ways of picking a node which are available as constraints are very small(<20)\\n\\n# Approach\\n    - Initialize a degree array which stores incoming edges for a course , course which are currently having Zero means that all pre-requistes are taken , so we are free to choose these courses\\n    - 2 cases on picking group of nodes :\\n        - case 1: When total available node < k ,pick all\\n        - case 2 : when total available node>=k , try to pick any set of k nodes from avaiable nodes by enumerating all submasks of all available mask and pick any of those which are having number of set bits equal k \\n    - Dp array to store value when we again reach such a configuration of nodes \\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    long long VISITED_ALL ; \\n\\n    void updateDegree(long long mask,int delta,vector<int>& degree,vector<vector<int>>& adj){\\n\\n        int n = degree.size();\\n\\n        for(int i=0;i<n;i++){\\n\\n            bool isSet = mask&(1<<i);\\n\\n            if(isSet){\\n\\n                for(auto node:adj[i]){\\n                    degree[node]+= delta; \\n                }\\n\\n            }\\n\\n        }\\n\\n    }\\n\\n    int solve(long long mask,int k,vector<int>& degree,vector<vector<int>>& adj,vector<int>&  dp){\\n\\n\\n        if(mask==VISITED_ALL) {\\n            return 0 ;\\n        }\\n\\n        if(dp[mask]!=-1) return dp[mask];\\n\\n        int n = degree.size();\\n\\n        long long available = 0 ;\\n\\n        for(int i=0;i<n;i++){\\n            \\n            bool isDone = (mask&(1<<i));\\n\\n           // cout<<isDone<<\"-\"<<degree[i]<<\" \";\\n\\n            if(!isDone && degree[i]==0){\\n\\n                available|=(1<<i);\\n\\n            }\\n\\n        }\\n\\n        \\n        \\n        //enumerate all submaks\\n        int countBits = __builtin_popcount(available);\\n\\n        if(countBits<k) {\\n            //pick all \\n\\n            int afterTaking = mask|available ;\\n\\n            updateDegree(available,-1,degree,adj);\\n\\n            int ans = solve(afterTaking,k,degree,adj,dp);\\n\\n            updateDegree(available,1,degree,adj);\\n\\n            return dp[mask] = 1+ans ; \\n            \\n        }\\n\\n        int min_ = 10101010;\\n\\n        for(int i=available;i;i =(i-1)&available){\\n\\n            int countBits = __builtin_popcount(i);\\n\\n            if(countBits==k){\\n                \\n                int afterTaking = mask|i ;\\n\\n                updateDegree(i,-1,degree,adj);\\n\\n                int ans = solve(afterTaking,k,degree,adj,dp);\\n\\n                min_ = min(1+ans,min_);\\n\\n                updateDegree(i,1,degree,adj);\\n            }\\n\\n        }\\n        return dp[mask] = min_ ; \\n\\n\\n    }\\n\\n    int minNumberOfSemesters(int n, vector<vector<int>>& relations, int k) {\\n        \\n        VISITED_ALL = (1<<n)-1;\\n\\n        vector<vector<int>> adj(n);\\n        \\n        vector<int> degree(n),dp(VISITED_ALL+1,-1);\\n        \\n        for(auto link:relations){\\n\\n            int u = link[0]-1 , v = link[1]-1;\\n\\n            adj[u].push_back(v);\\n\\n            degree[v]++;\\n\\n        }\\n\\n        return solve(0,k,degree,adj,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    long long VISITED_ALL ; \\n\\n    void updateDegree(long long mask,int delta,vector<int>& degree,vector<vector<int>>& adj){\\n\\n        int n = degree.size();\\n\\n        for(int i=0;i<n;i++){\\n\\n            bool isSet = mask&(1<<i);\\n\\n            if(isSet){\\n\\n                for(auto node:adj[i]){\\n                    degree[node]+= delta; \\n                }\\n\\n            }\\n\\n        }\\n\\n    }\\n\\n    int solve(long long mask,int k,vector<int>& degree,vector<vector<int>>& adj,vector<int>&  dp){\\n\\n\\n        if(mask==VISITED_ALL) {\\n            return 0 ;\\n        }\\n\\n        if(dp[mask]!=-1) return dp[mask];\\n\\n        int n = degree.size();\\n\\n        long long available = 0 ;\\n\\n        for(int i=0;i<n;i++){\\n            \\n            bool isDone = (mask&(1<<i));\\n\\n           // cout<<isDone<<\"-\"<<degree[i]<<\" \";\\n\\n            if(!isDone && degree[i]==0){\\n\\n                available|=(1<<i);\\n\\n            }\\n\\n        }\\n\\n        \\n        \\n        //enumerate all submaks\\n        int countBits = __builtin_popcount(available);\\n\\n        if(countBits<k) {\\n            //pick all \\n\\n            int afterTaking = mask|available ;\\n\\n            updateDegree(available,-1,degree,adj);\\n\\n            int ans = solve(afterTaking,k,degree,adj,dp);\\n\\n            updateDegree(available,1,degree,adj);\\n\\n            return dp[mask] = 1+ans ; \\n            \\n        }\\n\\n        int min_ = 10101010;\\n\\n        for(int i=available;i;i =(i-1)&available){\\n\\n            int countBits = __builtin_popcount(i);\\n\\n            if(countBits==k){\\n                \\n                int afterTaking = mask|i ;\\n\\n                updateDegree(i,-1,degree,adj);\\n\\n                int ans = solve(afterTaking,k,degree,adj,dp);\\n\\n                min_ = min(1+ans,min_);\\n\\n                updateDegree(i,1,degree,adj);\\n            }\\n\\n        }\\n        return dp[mask] = min_ ; \\n\\n\\n    }\\n\\n    int minNumberOfSemesters(int n, vector<vector<int>>& relations, int k) {\\n        \\n        VISITED_ALL = (1<<n)-1;\\n\\n        vector<vector<int>> adj(n);\\n        \\n        vector<int> degree(n),dp(VISITED_ALL+1,-1);\\n        \\n        for(auto link:relations){\\n\\n            int u = link[0]-1 , v = link[1]-1;\\n\\n            adj[u].push_back(v);\\n\\n            degree[v]++;\\n\\n        }\\n\\n        return solve(0,k,degree,adj,dp);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3622964,
                "title": "dynamic-programming-with-bitmasks",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis Problem falls under the category of the famous Travelling Salesman Graph Problem which Involves Dynamic Programming with Subsets. Ultimately at each Step we need to Identify from a Given Set of Pre-requisite Courses on how many courses we can take Optimally in 1 Semester. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate an adjacency list to represent the prerequisite relationships between courses. Each course is a node, and the prerequisite relationships are the edges in the graph.\\n\\nInitialize a dynamic programming array, dp, with size 2^n (where n is the number of courses). dp[mask] represents the minimum number of semesters needed to take the courses represented by the bitmask mask.\\n\\nInitialize dp[mask] to a large value (e.g., infinity) for all bitmasks mask except for dp[0] = 0, which means no courses are taken.\\n\\nIterate through all possible bitmasks mask from 1 to (1 << n) - 1. For each bitmask, perform the following steps:\\n\\nCalculate the indegree of each course in the current bitmask by iterating through the prerequisite relationships and incrementing the indegree of the next course.\\n\\nCreate a temporary bitmask, temp, to represent all the courses with an indegree of 0 in the current bitmask.\\n\\nIterate through all submasks j of temp (excluding 0) to consider different combinations of courses with an indegree of 0.\\n\\nIf the number of courses in the submask j is equal to or less than k, update the ans (minimum number of semesters) as the minimum between ans and 1 + dp[mask | j]. This means taking the courses in the submask j in the current semester and recursively calculating the minimum number of semesters needed for the remaining courses.\\n\\nReturn dp[(1 << n) - 1], which represents the minimum number of semesters needed to take all the courses.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n * 2^n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(2^n)\\n\\n# Code\\n```\\nclass Solution {\\n    private List<List<Integer>> adj;  \\n    private int n;\\n    private int k;\\n    private int[] dp;\\n\\n    private int solve(int mask) {\\n        if (mask == ((1 << n) - 1)) {\\n            // All courses are taken\\n            return 0;\\n        }\\n        if (dp[mask] != -1) {\\n            // Memoization\\n            return dp[mask];\\n        }\\n\\n        int[] indeg = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            if ((mask & (1 << i)) != 0) {\\n                continue;\\n            }\\n            for (int it : adj.get(i)) {\\n                indeg[it]++;\\n            }\\n        }\\n\\n        int temp = 0;  // For a mask of all nodes with 0-indegree\\n        for (int i = 0; i < n; i++) {\\n            if (indeg[i] == 0 && (mask & (1 << i)) == 0) {\\n                temp |= (1 << i);\\n            }\\n        }\\n\\n        int j = temp;\\n        int cnt = Integer.bitCount(j);  // count of nodes with 0-indegree\\n\\n        int ans = n + 1;  // ans will be \\'n\\' in the worst case, so take (n+1) as infinity\\n        if (cnt > k) {\\n            for (; j > 0; j = (j - 1) & temp) {\\n                // Iterate through all submasks of temp\\n                cnt = Integer.bitCount(j);\\n                if (cnt != k) {\\n                    continue;\\n                }\\n                ans = Math.min(ans, 1 + solve(mask | j));\\n            }\\n        } else {\\n            ans = Math.min(ans, 1 + solve(mask | j));\\n        }\\n\\n        return dp[mask] = ans;\\n    }\\n\\n    public int minNumberOfSemesters(int N, int[][] d, int K) {\\n        n = N;\\n        k = K;\\n        dp = new int[1 << n];\\n        Arrays.fill(dp, -1);\\n        adj = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            adj.add(new ArrayList<>());\\n        }\\n\\n        for (int i = 0; i < d.length; i++) {\\n            d[i][0]--;\\n            d[i][1]--;\\n            adj.get(d[i][0]).add(d[i][1]);\\n        }\\n\\n        return solve(0);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    private List<List<Integer>> adj;  \\n    private int n;\\n    private int k;\\n    private int[] dp;\\n\\n    private int solve(int mask) {\\n        if (mask == ((1 << n) - 1)) {\\n            // All courses are taken\\n            return 0;\\n        }\\n        if (dp[mask] != -1) {\\n            // Memoization\\n            return dp[mask];\\n        }\\n\\n        int[] indeg = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            if ((mask & (1 << i)) != 0) {\\n                continue;\\n            }\\n            for (int it : adj.get(i)) {\\n                indeg[it]++;\\n            }\\n        }\\n\\n        int temp = 0;  // For a mask of all nodes with 0-indegree\\n        for (int i = 0; i < n; i++) {\\n            if (indeg[i] == 0 && (mask & (1 << i)) == 0) {\\n                temp |= (1 << i);\\n            }\\n        }\\n\\n        int j = temp;\\n        int cnt = Integer.bitCount(j);  // count of nodes with 0-indegree\\n\\n        int ans = n + 1;  // ans will be \\'n\\' in the worst case, so take (n+1) as infinity\\n        if (cnt > k) {\\n            for (; j > 0; j = (j - 1) & temp) {\\n                // Iterate through all submasks of temp\\n                cnt = Integer.bitCount(j);\\n                if (cnt != k) {\\n                    continue;\\n                }\\n                ans = Math.min(ans, 1 + solve(mask | j));\\n            }\\n        } else {\\n            ans = Math.min(ans, 1 + solve(mask | j));\\n        }\\n\\n        return dp[mask] = ans;\\n    }\\n\\n    public int minNumberOfSemesters(int N, int[][] d, int K) {\\n        n = N;\\n        k = K;\\n        dp = new int[1 << n];\\n        Arrays.fill(dp, -1);\\n        adj = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            adj.add(new ArrayList<>());\\n        }\\n\\n        for (int i = 0; i < d.length; i++) {\\n            d[i][0]--;\\n            d[i][1]--;\\n            adj.get(d[i][0]).add(d[i][1]);\\n        }\\n\\n        return solve(0);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3601718,
                "title": "c-bitmask",
                "content": "```\\nclass Solution {\\npublic:\\n    int minNumberOfSemesters(int n, vector<vector<int>>& relations, int k) {\\n        int allTaken = (1 << n) - 1;\\n\\n        vector<int> pre(n);\\n        for (auto &r: relations) {\\n            pre[r[1]-1] |= 1 << r[0]-1;\\n        }\\n\\n        vector<int> dp(allTaken + 1, INT_MAX); // lowest time to take dp[i]\\n        dp[0] = 0;\\n\\n        for (int i = 0; i <= allTaken; i++) {\\n            if (dp[i] == INT_MAX) continue; // can\\'t take these course\\n            int toTake = 0;\\n            for (int j = 0; j < n; j++) {\\n                if ((i & (1 << j)) != 0) continue; // skip courses already taken\\n                if ((i & pre[j]) == pre[j]) {\\n                    toTake |= 1 << j;\\n                }\\n            }\\n            \\n            // optimization: if we can take all the toTake courses,\\n            // take them and skip the loop below\\n            if (__builtin_popcount(toTake) <= k) {\\n                dp[i | toTake] = min(dp[i | toTake], dp[i] + 1);\\n                continue;\\n            }\\n\\n            for (int take = toTake; take; take = (take-1) & toTake) {\\n                /* if (__builtin_popcount(take) > k) continue; // can\\'t if more than k */\\n                /* Or to avoid reprocessing, only take k courses\\n                 * Since the order here doesn\\'t matter, we only\\n                 * care about the state where prerequisites are taken.\\n                 * i.e., take 2 -> take 1 is the same as 1 -> 2, \\n                 * let\\'s say 3 courses are take, \\n                 * they\\'re both stored as 111\\n                 * */\\n                if (__builtin_popcount(take) != k) continue;\\n                // take the course and record/update time\\n                dp[i | take] = min(dp[i | take], dp[i] + 1);\\n            }\\n        }\\n\\n        return dp[allTaken];\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfSemesters(int n, vector<vector<int>>& relations, int k) {\\n        int allTaken = (1 << n) - 1;\\n\\n        vector<int> pre(n);\\n        for (auto &r: relations) {\\n            pre[r[1]-1] |= 1 << r[0]-1;\\n        }\\n\\n        vector<int> dp(allTaken + 1, INT_MAX); // lowest time to take dp[i]\\n        dp[0] = 0;\\n\\n        for (int i = 0; i <= allTaken; i++) {\\n            if (dp[i] == INT_MAX) continue; // can\\'t take these course\\n            int toTake = 0;\\n            for (int j = 0; j < n; j++) {\\n                if ((i & (1 << j)) != 0) continue; // skip courses already taken\\n                if ((i & pre[j]) == pre[j]) {\\n                    toTake |= 1 << j;\\n                }\\n            }\\n            \\n            // optimization: if we can take all the toTake courses,\\n            // take them and skip the loop below\\n            if (__builtin_popcount(toTake) <= k) {\\n                dp[i | toTake] = min(dp[i | toTake], dp[i] + 1);\\n                continue;\\n            }\\n\\n            for (int take = toTake; take; take = (take-1) & toTake) {\\n                /* if (__builtin_popcount(take) > k) continue; // can\\'t if more than k */\\n                /* Or to avoid reprocessing, only take k courses\\n                 * Since the order here doesn\\'t matter, we only\\n                 * care about the state where prerequisites are taken.\\n                 * i.e., take 2 -> take 1 is the same as 1 -> 2, \\n                 * let\\'s say 3 courses are take, \\n                 * they\\'re both stored as 111\\n                 * */\\n                if (__builtin_popcount(take) != k) continue;\\n                // take the course and record/update time\\n                dp[i | take] = min(dp[i | take], dp[i] + 1);\\n            }\\n        }\\n\\n        return dp[allTaken];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3473268,
                "title": "c",
                "content": "```\\n//1. subState is a subset of state\\n//2. countOne(state) - cuntOne(subState) <= k\\n//3. subState must contain prerequisities of state\\nclass Solution {\\npublic:\\n    int minNumberOfSemesters(int n, vector<vector<int>>& relations, int k) {\\n        vector<int>dp(1 << n, INT_MAX/2) ;\\n        vector<int>preRequ(1 << n, 0) ;  //contain prerequisities of state\\n        vector<int>preCourse(n) ;\\n        \\n        for(auto&e : relations){\\n            int u = e[0] - 1 ;\\n            int v = e[1] - 1 ;\\n            preCourse[v] |= (1 << u) ;\\n        }\\n        //build preRequ :# contain prerequisities of state\\n        for(int state = 1; state < (1 << n); state++){\\n            for(int i = 0; i < n; i++){\\n                if((state >> i) & 1)\\n                    preRequ[state] |= preCourse[i] ;\\n            }\\n            if(preRequ[state] == 0 && __builtin_popcount(state) <= k)\\n                dp[state] = 1 ;\\n        }\\n        dp[0] = 0 ;\\n        for(int state = 0; state < (1 << n) ; state++){\\n            int sOne = __builtin_popcount(state) ;\\n            //1. subState is a subset of state\\n            for(int subState = state; subState > 0 ; subState = ((subState-1)&state)){\\n                int subOne = __builtin_popcount(subState) ;\\n                //2. countOne(state) - cuntOne(subState) <= k\\n                if(sOne - subOne > k)\\n                    continue ;\\n                //3. subState must contain prerequisities of state\\n                if( (preRequ[state] & subState) == preRequ[state] )\\n                    dp[state] = min(dp[state], dp[subState] + 1) ;\\n            }\\n        }\\n        return (dp[(1 << n)- 1] == INT_MAX/2) ? -1 : dp[(1 << n) - 1] ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n//1. subState is a subset of state\\n//2. countOne(state) - cuntOne(subState) <= k\\n//3. subState must contain prerequisities of state\\nclass Solution {\\npublic:\\n    int minNumberOfSemesters(int n, vector<vector<int>>& relations, int k) {\\n        vector<int>dp(1 << n, INT_MAX/2) ;\\n        vector<int>preRequ(1 << n, 0) ;  //contain prerequisities of state\\n        vector<int>preCourse(n) ;\\n        \\n        for(auto&e : relations){\\n            int u = e[0] - 1 ;\\n            int v = e[1] - 1 ;\\n            preCourse[v] |= (1 << u) ;\\n        }\\n        //build preRequ :# contain prerequisities of state\\n        for(int state = 1; state < (1 << n); state++){\\n            for(int i = 0; i < n; i++){\\n                if((state >> i) & 1)\\n                    preRequ[state] |= preCourse[i] ;\\n            }\\n            if(preRequ[state] == 0 && __builtin_popcount(state) <= k)\\n                dp[state] = 1 ;\\n        }\\n        dp[0] = 0 ;\\n        for(int state = 0; state < (1 << n) ; state++){\\n            int sOne = __builtin_popcount(state) ;\\n            //1. subState is a subset of state\\n            for(int subState = state; subState > 0 ; subState = ((subState-1)&state)){\\n                int subOne = __builtin_popcount(subState) ;\\n                //2. countOne(state) - cuntOne(subState) <= k\\n                if(sOne - subOne > k)\\n                    continue ;\\n                //3. subState must contain prerequisities of state\\n                if( (preRequ[state] & subState) == preRequ[state] )\\n                    dp[state] = min(dp[state], dp[subState] + 1) ;\\n            }\\n        }\\n        return (dp[(1 << n)- 1] == INT_MAX/2) ? -1 : dp[(1 << n) - 1] ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448546,
                "title": "solid-principles-commented-and-explained-bellman-ford",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo get the minimal semesters needed, we need a topological sorting approach. However, this question can never be well suited, as I\\'ll point out below, so we are forced to try an exhaustive search methodology. However, some improvements can be made to reduce the space of search, which we take on in the approach section. \\n\\nTo start with, we have n courses that have some form of relation. We are guaranteed that there is a relation between all courses. However, what we are not gauranteed is the exact relationship between courses, and this proves to be this questions downfall. \\n\\nFrom a naive approach, we can simply take all prerequisites fisrt, and then take any courses for which we are already qualified once we have exhausted all prerequisites. This initially led me to a Kahn style method like in parallel courses one, where we would simply reduce the in degree of courses and add them when able. But in doing so, we avoid the fact that we cannot take courses concurrently and must take up to k every semester as we can. Because of this, Kahn does not quite fit, so we end up having to utilize Bellman Ford. \\n\\nAdditionally, the order of the courses is important overall, and each course id should have its own unique location in our search space. This leads to the idea of bit masking, where each course id is a sufficiently left shifted bit mask, leading to a specific binary key of value as we go through the semesters. \\n\\nFinally, to showcase how unsuited this problem is, assume we have courses with no post requisites, but that show up at differing times of prerequisite coverage. This means there is no way to determine exactly where and when best fit each of these could be placed in the scheduling of classes. In fact, picking the schedule that would lead to them is also impossible unless all our considered. Thus, we must consider all possible unique states of course progression, and not repeat our calculations. This means we need a memo the size of 2^n courses to account for all of the combinations, and that we only reach our goal at 2^n-1 for when we have exhausted all courses as a summation record key. \\n\\nIn the approach we\\'ll detail some optimizations that help with this. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo start with, we consider our initialized process of storage and values. \\nWe want a graph, an out degree and in degree for each node, a bit shifted course id container, a queue, and a seen array. We also want a start, goal, limit, number of courses, and max semesters value. \\n\\nWe then turn to set up where we pass the problems fields \\nn is our number of courses, and we want a graph, outdegree and in degree of size n. \\nSeen is our combination of courses, with size 2^n to account for all course key combinations. \\nGoal is 2^n-1 so that we have completed all courses \\nOur bit shifted courses are 1 << c_i, for the ith course in range n \\nWe then process our relations \\n- We set graph at post requisite course - 1 to increment by 1 << (prerequisite - 1) \\n- We set out degree of pre requisite - 1 to increment by 1 and similar for in degree of post requisite - 1 \\n\\nIn our queue we start with self.start of 0 and 0 semesters \\nWe set our limit to k \\n\\nNow we want to set up our truth finding functions for processing \\nIf a course id is one we are qualified to take, the result of our record key & self.graph at course id should be the same as self.graph at course id. This is because the prerequisites for that course id should be in the record key and the graph at that course id stores the value of pre requisite courses only. \\n\\nIf a course id is not one we have taken, the result of our record key and the bit shifted course id should be zero, meaning we have no overlap. \\n\\nThis then lets us find our available courses given a current record key. \\nWe can loop over our number of courses, and for course id we have in that range \\n- if we have not taken the course and we are qualified to take the course \\n    - it is an available course to consider \\n\\nTo get the prerequisite courses in our available courses we will pass the function only those courses which have an out degree in our available courses. Once we do \\n- we will sort these by the out degree from greatest to least \\n- then, return the bit shifted course id of those in the sorted prerequisites \\n- this ensures we process our prerequisites in order of greatest to least coverage \\n\\nTo get the terminal courses (courses with no post requisites) we again pass the specified available courses as a subset (ones with outdegree 0) \\n- We then sort these by their in degree in increasing order.  \\n- And return the bit shifted course id of those in the sorted terminal courses \\n- This ensures we process our terminals in order of least cost to have covered. We are in essence doing the most valuable terminals first \\n\\nIf we end up in a state where we do not have enough pure pre requisite classes and must instead process terminals with them, we will want to get our new processing output. To do so \\n- calculate a new record key as the sum of the prerequisite course ids with the sum of the terminal keys up to limit minus the length of our prerequisites\\n- If the new record key is now our goal, return semesters + 1 \\n- otherwise, if we have not seen this record key, add it to the queue and mark it seen, then return 0 \\n\\nIf we have too many pre requisites to consider, we still will need to think of all possible combinations. Based on the combinations itertool processing however, we will generate the most valueable to least valueable using our already sorted prerequisites. This is one of our secret time saving tricks! As for how that works, in our process pre req combinations function we \\n- generation combinations from itertools using prerequisites and our limit k \\n    - for each combination, get a new pre reqs key as the sum of the combination \\n    - make a new record key as the record key plus the pre reqs key \\n    - if the new record key magically is our goal \\n        - return semesters plus 1 \\n    - otherwise, if we have not seen it, add to queue and mark seen \\n- at end, return 0 if you haven\\'t already \\n\\nNow we are ready to process our queue. While we have a queue \\n- get record key and semesters by popping from left of queue \\n- get max semesters as max of semesters and current max semesters \\n- get available, prerequisite, and terminals using our functions \\n- if length of prerequisite is less than or equal to limit k, \\n    - set result equal to call of process pre reqs and terminals, passing pre reqs, terminals, record key and semesters \\n    - if result is not 0, return result \\n- otherwise\\n    - set result equal to call of process prereq combinations, passing prereqs, recordkey, and semesters \\n    - if result is not 0, return it \\nIf you exhaust the queue, return max semesters plus 1, as you\\'ll always be one semester away \\n\\nNow we can do the problem by \\n- calling setup, passing n, relations, and k \\n- return the result of calling process queue, and know we will get a result of integer form no matter what        \\n\\n# Complexity\\n- Time complexity: O(min (2^V, V^2 * V choose k))\\n    - We do O(E) processing all relations \\n    - We do O(V) setting up bit shifted courses \\n    - We process at most O(V) times in the queue (course graph is a stick)\\n        - in which we do O(V) times in the available function\\n        - in which we do O(V) setting up for pre req and terminal\\n            - in side of which we do another v log v, but that is subsumed by O(V)\\n    - if we process pre reqs and terminals thats really O(k) to get sums of pre reqs and terminals \\n    - if we process pre req combinations thats O(V * V choose k) \\n    - total absolute worst run time complexity then is min(2^V, V^2 * V choose k)\\n    - We can ignore the E, which is unusual, as for this graph it is bound as V^2. Our queue process needs V * V * V choose k, which dominates this\\n    - We do have 2 ^ V as potentially smaller, which is when we visit all of the possible combinations. Whichever is better is our bound. \\n\\n- Space complexity : O(2^V)\\n    - We store E edges \\n    - We store in and out degree status of V nodes \\n    - We need V * V choose R for combinations \\n    - We need 2^V slots for seen\\n    - Of these, We see the same result as above, except we do not have the nested V for time complexity. This leaves us at 2^V as our space complexity simply. \\n\\n# Code\\n```\\nclass Solution:\\n    def __init__(self) : \\n        self.graph = []\\n        self.out_degree = []\\n        self.in_degree = []\\n        self.bit_shifted_courses = []\\n        self.queue = collections.deque()\\n        self.seen = []\\n        self.start = 0\\n        self.goal  = 1\\n        self.limit = 1\\n        self.number_of_courses = 0\\n        self.max_semesters = 1 \\n\\n    def set_up(self, n, relations, k) : \\n        # graph size and out degree for n nodes \\n        self.number_of_courses = n\\n        self.graph      = [0]*n \\n        self.out_degree = [0]*n\\n        self.in_degree  = [0]*n\\n        # seen is 2 ^ n combinations of bit shifts \\n        self.seen = [0] * (2**n)\\n        # goal is getting all of them \\n        self.goal = 2**n-1\\n        # bit shifted courses for all unique bit identity of courses \\n        self.bit_shifted_courses = [1<<c_i for c_i in range(n)]\\n        # off by one indexing \\n        for prerequisite, post in relations : \\n            self.graph[post-1] += 1 << (prerequisite - 1)\\n            self.out_degree[prerequisite - 1] += 1\\n            self.in_degree[post-1] += 1  \\n        # starting point and limit factor \\n        self.queue.append((self.start, 0))\\n        self.limit = k\\n\\n    def qualified_to_take_course(self, record_key, course_id) : \\n        # if record key & self.graph[course_id] == self.graph[course_id] we have all prerequisites needed\\n        return record_key & self.graph[course_id] == self.graph[course_id]\\n\\n    def have_not_taken_course(self, record_key, course_id) : \\n        # if record_key & bit shifted course at course id is 0, we have not taken it \\n        return record_key & self.bit_shifted_courses[course_id] == 0 \\n\\n    def get_available_courses(self, record_key) : \\n        # using record key \\n        available = []\\n        # loop over number of courses \\n        for course_id in range(self.number_of_courses) : \\n            # if we have not taken it and can take it, add it \\n            if self.have_not_taken_course(record_key, course_id) and self.qualified_to_take_course(record_key, course_id) : \\n                available.append(course_id)\\n        # return when done \\n        return available\\n\\n    def get_prerequisites_in_available_courses(self, available) : \\n        # return those that lead to other courses \\n        # sort by out degree in increasing fashion, so that we consider pre-reqs in order of maximal coverage \\n        available.sort(key = lambda course_id : self.out_degree[course_id], reverse=True)\\n        return [self.bit_shifted_courses[course_id] for course_id in available]\\n\\n    def get_terminal_courses_in_available_courses(self, available) : \\n        # return those that do not lead to other courses \\n        # sort by in degree that have minimal requirements \\n        available.sort(key = lambda course_id : self.in_degree[course_id])\\n        return [self.bit_shifted_courses[course_id] for course_id in available]\\n\\n    def process_pre_reqs_and_terminals(self, pre_reqs, terminals, record_key, semesters) :\\n        # get new record key as combination of pre reqs and terminals we qualify for \\n        record_key += sum(pre_reqs) + sum(terminals[:self.limit - len(pre_reqs)])\\n        # if record key is goal increment steps and return \\n        if record_key == self.goal : \\n            return semesters + 1 \\n        # otherwise, if we have not considered this combination yet \\n        if self.seen[record_key] == 0 : \\n            # consider it and mark it considered \\n            self.queue.append((record_key, semesters+1))\\n            self.seen[record_key] = 1 \\n        # return 0 if not goal\\n        return 0  \\n\\n    def process_pre_req_combinations(self, pre_reqs, record_key, semesters) : \\n        # try all combinations \\n        for combination in itertools.combinations(pre_reqs, self.limit) : \\n            # getting the new pre reqs course bits \\n            pre_reqs_key = sum(combination)\\n            # and updating record key \\n            new_record_key = record_key + pre_reqs_key\\n            # if that completed what we needed \\n            if new_record_key == self.goal : \\n                # return steps plus 1 \\n                return semesters + 1 \\n            # otherwise, if we have not considered it \\n            if self.seen[new_record_key] == 0 : \\n                # consider it and mark as such \\n                self.queue.append((new_record_key, semesters+1))\\n                self.seen[new_record_key] = 1 \\n        # return 0 by default if we never returned otherwise \\n        return 0 \\n\\n    def process_queue(self) : \\n        # process queue and return result when found \\n        while self.queue : \\n            # pop from front\\n            record_key, semesters = self.queue.popleft()\\n            # insurance incase of other mishaps \\n            self.max_semesters = max(self.max_semesters, semesters)\\n            # get available, pre_reqs, and terminals \\n            available = self.get_available_courses(record_key) \\n            pre_reqs  = self.get_prerequisites_in_available_courses([course_id for course_id in available if self.out_degree[course_id]])\\n            terminals = self.get_terminal_courses_in_available_courses([course_id for course_id in available if self.out_degree[course_id]==0])\\n            # if length of prereqs is at or under limit for semester \\n            if len(pre_reqs) <= self.limit : \\n                # get result of processing pre reqs and terminals \\n                result = self.process_pre_reqs_and_terminals(pre_reqs, terminals, record_key, semesters)\\n                # if we got a finish result \\n                if result != 0 : \\n                    # return it \\n                    return result \\n            else : \\n                # similar to above, but now we have too many prerequisites \\n                result = self.process_pre_req_combinations(pre_reqs, record_key, semesters)\\n                # if we finish on account of this, return it \\n                if result != 0 : \\n                    return result \\n        return self.max_semesters + 1 \\n\\n    def minNumberOfSemesters(self, n: int, relations: List[List[int]], k: int) -> int:\\n        self.set_up(n, relations, k)\\n        return self.process_queue()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def __init__(self) : \\n        self.graph = []\\n        self.out_degree = []\\n        self.in_degree = []\\n        self.bit_shifted_courses = []\\n        self.queue = collections.deque()\\n        self.seen = []\\n        self.start = 0\\n        self.goal  = 1\\n        self.limit = 1\\n        self.number_of_courses = 0\\n        self.max_semesters = 1 \\n\\n    def set_up(self, n, relations, k) : \\n        # graph size and out degree for n nodes \\n        self.number_of_courses = n\\n        self.graph      = [0]*n \\n        self.out_degree = [0]*n\\n        self.in_degree  = [0]*n\\n        # seen is 2 ^ n combinations of bit shifts \\n        self.seen = [0] * (2**n)\\n        # goal is getting all of them \\n        self.goal = 2**n-1\\n        # bit shifted courses for all unique bit identity of courses \\n        self.bit_shifted_courses = [1<<c_i for c_i in range(n)]\\n        # off by one indexing \\n        for prerequisite, post in relations : \\n            self.graph[post-1] += 1 << (prerequisite - 1)\\n            self.out_degree[prerequisite - 1] += 1\\n            self.in_degree[post-1] += 1  \\n        # starting point and limit factor \\n        self.queue.append((self.start, 0))\\n        self.limit = k\\n\\n    def qualified_to_take_course(self, record_key, course_id) : \\n        # if record key & self.graph[course_id] == self.graph[course_id] we have all prerequisites needed\\n        return record_key & self.graph[course_id] == self.graph[course_id]\\n\\n    def have_not_taken_course(self, record_key, course_id) : \\n        # if record_key & bit shifted course at course id is 0, we have not taken it \\n        return record_key & self.bit_shifted_courses[course_id] == 0 \\n\\n    def get_available_courses(self, record_key) : \\n        # using record key \\n        available = []\\n        # loop over number of courses \\n        for course_id in range(self.number_of_courses) : \\n            # if we have not taken it and can take it, add it \\n            if self.have_not_taken_course(record_key, course_id) and self.qualified_to_take_course(record_key, course_id) : \\n                available.append(course_id)\\n        # return when done \\n        return available\\n\\n    def get_prerequisites_in_available_courses(self, available) : \\n        # return those that lead to other courses \\n        # sort by out degree in increasing fashion, so that we consider pre-reqs in order of maximal coverage \\n        available.sort(key = lambda course_id : self.out_degree[course_id], reverse=True)\\n        return [self.bit_shifted_courses[course_id] for course_id in available]\\n\\n    def get_terminal_courses_in_available_courses(self, available) : \\n        # return those that do not lead to other courses \\n        # sort by in degree that have minimal requirements \\n        available.sort(key = lambda course_id : self.in_degree[course_id])\\n        return [self.bit_shifted_courses[course_id] for course_id in available]\\n\\n    def process_pre_reqs_and_terminals(self, pre_reqs, terminals, record_key, semesters) :\\n        # get new record key as combination of pre reqs and terminals we qualify for \\n        record_key += sum(pre_reqs) + sum(terminals[:self.limit - len(pre_reqs)])\\n        # if record key is goal increment steps and return \\n        if record_key == self.goal : \\n            return semesters + 1 \\n        # otherwise, if we have not considered this combination yet \\n        if self.seen[record_key] == 0 : \\n            # consider it and mark it considered \\n            self.queue.append((record_key, semesters+1))\\n            self.seen[record_key] = 1 \\n        # return 0 if not goal\\n        return 0  \\n\\n    def process_pre_req_combinations(self, pre_reqs, record_key, semesters) : \\n        # try all combinations \\n        for combination in itertools.combinations(pre_reqs, self.limit) : \\n            # getting the new pre reqs course bits \\n            pre_reqs_key = sum(combination)\\n            # and updating record key \\n            new_record_key = record_key + pre_reqs_key\\n            # if that completed what we needed \\n            if new_record_key == self.goal : \\n                # return steps plus 1 \\n                return semesters + 1 \\n            # otherwise, if we have not considered it \\n            if self.seen[new_record_key] == 0 : \\n                # consider it and mark as such \\n                self.queue.append((new_record_key, semesters+1))\\n                self.seen[new_record_key] = 1 \\n        # return 0 by default if we never returned otherwise \\n        return 0 \\n\\n    def process_queue(self) : \\n        # process queue and return result when found \\n        while self.queue : \\n            # pop from front\\n            record_key, semesters = self.queue.popleft()\\n            # insurance incase of other mishaps \\n            self.max_semesters = max(self.max_semesters, semesters)\\n            # get available, pre_reqs, and terminals \\n            available = self.get_available_courses(record_key) \\n            pre_reqs  = self.get_prerequisites_in_available_courses([course_id for course_id in available if self.out_degree[course_id]])\\n            terminals = self.get_terminal_courses_in_available_courses([course_id for course_id in available if self.out_degree[course_id]==0])\\n            # if length of prereqs is at or under limit for semester \\n            if len(pre_reqs) <= self.limit : \\n                # get result of processing pre reqs and terminals \\n                result = self.process_pre_reqs_and_terminals(pre_reqs, terminals, record_key, semesters)\\n                # if we got a finish result \\n                if result != 0 : \\n                    # return it \\n                    return result \\n            else : \\n                # similar to above, but now we have too many prerequisites \\n                result = self.process_pre_req_combinations(pre_reqs, record_key, semesters)\\n                # if we finish on account of this, return it \\n                if result != 0 : \\n                    return result \\n        return self.max_semesters + 1 \\n\\n    def minNumberOfSemesters(self, n: int, relations: List[List[int]], k: int) -> int:\\n        self.set_up(n, relations, k)\\n        return self.process_queue()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3441602,
                "title": "java-hashset-no-bitmasks-easy-to-understand",
                "content": "```\\nclass Solution {\\n    int N;\\n    int K;\\n    int MIN_POSSIBLE_ANS; // the best possible answer\\n    int CURR_ANS = Integer.MAX_VALUE;\\n    \\n    Set<String> seen = new HashSet<>(); // already calculated paths\\n    List<Set<Integer>> parent = new ArrayList<>(); // child -> parents\\n    List<Set<Integer>> child = new ArrayList<>(); // parent -> children\\n    \\n    public int minNumberOfSemesters(int n, int[][] relations, int k) {\\n        this.N = n;\\n        this.K = k;\\n        this.MIN_POSSIBLE_ANS = n/k + (Math.min(1, n%k));\\n        \\n        for(int i=0;i<=n;i++) {\\n            child.add(new HashSet<>());\\n            parent.add(new HashSet<>());\\n        }\\n        \\n        boolean[] visited = new boolean[n+1];\\n        int[] inDegree = new int[n+1];\\n        \\n        for(int[] r : relations){\\n            inDegree[r[1]]++;\\n            child.get(r[0]).add(r[1]);\\n            parent.get(r[1]).add(r[0]);\\n        }\\n        \\n        for(int i=1;i<=n;i++){\\n            if(inDegree[i] == 0){\\n                Set<Integer> currSemester = new HashSet<>();\\n                currSemester.add(i);\\n                \\n                visited[i] = true;\\n                solve(i, inDegree, visited, 1, 1, currSemester);\\n                if(CURR_ANS <= MIN_POSSIBLE_ANS) return CURR_ANS;\\n                visited[i] = false;\\n            }\\n        }\\n        return CURR_ANS;\\n    }\\n\\n    void solve(int node, int[] inDegree, boolean[] visited, int semester, int coursesTaken, Set<Integer> currSemester){   \\n        String seenKey = key(visited) + \":\" + currSemester.size() + \":\" + semester;\\n        if(seen.contains(seenKey)) return;\\n        \\n        if(coursesTaken >= N) {\\n            CURR_ANS = Math.min(CURR_ANS, semester);\\n            return;\\n        }\\n        \\n        for(int nextNode : child.get(node)) \\n            inDegree[nextNode]--;\\n        \\n        for(int nextNode=1;nextNode<=N;nextNode++){\\n            if(inDegree[nextNode] == 0 && !visited[nextNode]){\\n                \\n                // check if this course depends on a course taken this semester\\n                // if it does, we can only take it the next semester\\n                boolean canTakeThisSemester = true;                \\n                Set<Integer> nextNodeParents = parent.get(nextNode);\\n                \\n                for(Integer currSemesterNode : currSemester){\\n                    if(nextNodeParents.contains(currSemesterNode)) {\\n                        canTakeThisSemester = false;\\n                        break;\\n                    }\\n                }\\n                \\n                visited[nextNode] = true;\\n                \\n                if(!canTakeThisSemester || currSemester.size()+1 > K){\\n                    Set<Integer> nextSemester = new HashSet<>();\\n                    nextSemester.add(nextNode);\\n                    solve(nextNode, inDegree, visited, semester+1, coursesTaken+1, nextSemester);\\n                } else {\\n                    currSemester.add(nextNode);\\n                    solve(nextNode, inDegree, visited, semester, coursesTaken+1, currSemester);\\n                    currSemester.remove(nextNode);\\n                }\\n                \\n                if(CURR_ANS <= MIN_POSSIBLE_ANS) return;\\n                visited[nextNode] = false;\\n            }\\n        }\\n        \\n        // Reset the indegree for the next run\\n        for(int nextNode : child.get(node))\\n            inDegree[nextNode]++;\\n        \\n        seen.add(seenKey); // mark the path to avoid visiting it again\\n    }\\n        \\n    String key(boolean[] arr){\\n        StringBuilder sb = new StringBuilder();\\n        for(boolean x : arr) sb.append(x).append(\",\");\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int N;\\n    int K;\\n    int MIN_POSSIBLE_ANS; // the best possible answer\\n    int CURR_ANS = Integer.MAX_VALUE;\\n    \\n    Set<String> seen = new HashSet<>(); // already calculated paths\\n    List<Set<Integer>> parent = new ArrayList<>(); // child -> parents\\n    List<Set<Integer>> child = new ArrayList<>(); // parent -> children\\n    \\n    public int minNumberOfSemesters(int n, int[][] relations, int k) {\\n        this.N = n;\\n        this.K = k;\\n        this.MIN_POSSIBLE_ANS = n/k + (Math.min(1, n%k));\\n        \\n        for(int i=0;i<=n;i++) {\\n            child.add(new HashSet<>());\\n            parent.add(new HashSet<>());\\n        }\\n        \\n        boolean[] visited = new boolean[n+1];\\n        int[] inDegree = new int[n+1];\\n        \\n        for(int[] r : relations){\\n            inDegree[r[1]]++;\\n            child.get(r[0]).add(r[1]);\\n            parent.get(r[1]).add(r[0]);\\n        }\\n        \\n        for(int i=1;i<=n;i++){\\n            if(inDegree[i] == 0){\\n                Set<Integer> currSemester = new HashSet<>();\\n                currSemester.add(i);\\n                \\n                visited[i] = true;\\n                solve(i, inDegree, visited, 1, 1, currSemester);\\n                if(CURR_ANS <= MIN_POSSIBLE_ANS) return CURR_ANS;\\n                visited[i] = false;\\n            }\\n        }\\n        return CURR_ANS;\\n    }\\n\\n    void solve(int node, int[] inDegree, boolean[] visited, int semester, int coursesTaken, Set<Integer> currSemester){   \\n        String seenKey = key(visited) + \":\" + currSemester.size() + \":\" + semester;\\n        if(seen.contains(seenKey)) return;\\n        \\n        if(coursesTaken >= N) {\\n            CURR_ANS = Math.min(CURR_ANS, semester);\\n            return;\\n        }\\n        \\n        for(int nextNode : child.get(node)) \\n            inDegree[nextNode]--;\\n        \\n        for(int nextNode=1;nextNode<=N;nextNode++){\\n            if(inDegree[nextNode] == 0 && !visited[nextNode]){\\n                \\n                // check if this course depends on a course taken this semester\\n                // if it does, we can only take it the next semester\\n                boolean canTakeThisSemester = true;                \\n                Set<Integer> nextNodeParents = parent.get(nextNode);\\n                \\n                for(Integer currSemesterNode : currSemester){\\n                    if(nextNodeParents.contains(currSemesterNode)) {\\n                        canTakeThisSemester = false;\\n                        break;\\n                    }\\n                }\\n                \\n                visited[nextNode] = true;\\n                \\n                if(!canTakeThisSemester || currSemester.size()+1 > K){\\n                    Set<Integer> nextSemester = new HashSet<>();\\n                    nextSemester.add(nextNode);\\n                    solve(nextNode, inDegree, visited, semester+1, coursesTaken+1, nextSemester);\\n                } else {\\n                    currSemester.add(nextNode);\\n                    solve(nextNode, inDegree, visited, semester, coursesTaken+1, currSemester);\\n                    currSemester.remove(nextNode);\\n                }\\n                \\n                if(CURR_ANS <= MIN_POSSIBLE_ANS) return;\\n                visited[nextNode] = false;\\n            }\\n        }\\n        \\n        // Reset the indegree for the next run\\n        for(int nextNode : child.get(node))\\n            inDegree[nextNode]++;\\n        \\n        seen.add(seenKey); // mark the path to avoid visiting it again\\n    }\\n        \\n    String key(boolean[] arr){\\n        StringBuilder sb = new StringBuilder();\\n        for(boolean x : arr) sb.append(x).append(\",\");\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421381,
                "title": "my-solutions",
                "content": "**Solution I**\\n```\\n/**\\n * Time Complexity: O(3 ^ n)\\n * Space Complexity: O(2 ^ n)\\n */\\nclass Solution {\\n public:\\n  int minNumberOfSemesters(const int n,\\n                           const vector<vector<int>> &relations,\\n                           const int k) {\\n    constexpr unsigned int unresolved = -1U;\\n    int prerequisites[n];\\n    memset(prerequisites, 0, sizeof(prerequisites));\\n    for (const vector<int> &relation : relations) {\\n      prerequisites[relation.back() - 1] |= (1 << (relation.front() - 1));\\n    }\\n    \\n    const int layouts = (1 << n);\\n    unsigned int dp[layouts];\\n    memset(dp, unresolved, sizeof(dp));\\n    dp[0] = 0;\\n    for (int courses_have_been_taken = 0;\\n         courses_have_been_taken < layouts - 1;\\n         ++courses_have_been_taken) {\\n      if (dp[courses_have_been_taken] == unresolved) {\\n        continue;\\n      }\\n\\n      int courses_can_take = 0;\\n      for (int course = 0; course < n; ++course) {\\n        if ((courses_have_been_taken & prerequisites[course]) == prerequisites[course]) {\\n          courses_can_take |= (1 << course);\\n        }\\n      }\\n      \\n      courses_can_take &= (~courses_have_been_taken);\\n      for (int courses_to_take = courses_can_take;\\n           courses_to_take > 0;\\n           courses_to_take = ((courses_to_take - 1) & courses_can_take)) {\\n        if (number_of_courses(courses_to_take) <= k) {\\n          dp[courses_have_been_taken | courses_to_take] = min(dp[courses_have_been_taken | courses_to_take],\\n                                                              1U + dp[courses_have_been_taken]);\\n        }\\n      }\\n    }\\n    return static_cast<int>(dp[layouts - 1]);\\n  }\\n  \\n private:\\n  int number_of_courses(const int layout) {\\n    int ret = 0;\\n    for (int l = layout; l > 0; l -= (l & -l)) {\\n      ++ret;\\n    }\\n    return ret;\\n  }\\n};\\n```\\n**Solution II, based on Solution I, adding the greedy logic, that is taking as many courses as possible in every semester**\\n```\\n/**\\n * Time Complexity: O(3 ^ n)\\n * Space Complexity: O(2 ^ n)\\n */\\nclass Solution {\\n public:\\n  int minNumberOfSemesters(const int n,\\n                           const vector<vector<int>> &relations,\\n                           const int k) {\\n    constexpr unsigned int unresolved = -1U;\\n    int prerequisites[n];\\n    memset(prerequisites, 0, sizeof(prerequisites));\\n    for (const vector<int> &relation : relations) {\\n      prerequisites[relation.back() - 1] |= (1 << (relation.front() - 1));\\n    }\\n    \\n    const int layouts = (1 << n);\\n    unsigned int dp[layouts];\\n    memset(dp, unresolved, sizeof(dp));\\n    dp[0] = 0;\\n    for (int courses_have_been_taken = 0;\\n         courses_have_been_taken < layouts - 1;\\n         ++courses_have_been_taken) {\\n      if (dp[courses_have_been_taken] == unresolved) {\\n        continue;\\n      }\\n\\n      int courses_can_take = 0;\\n      for (int course = 0; course < n; ++course) {\\n        if ((courses_have_been_taken & prerequisites[course]) == prerequisites[course]) {\\n          courses_can_take |= (1 << course);\\n        }\\n      }\\n      \\n      courses_can_take &= (~courses_have_been_taken);\\n      const int number_of_courses_can_take = number_of_courses(courses_can_take);\\n      if (number_of_courses_can_take <= k) {\\n        dp[courses_have_been_taken | courses_can_take] = min(dp[courses_have_been_taken | courses_can_take],\\n                                                             1U + dp[courses_have_been_taken]);\\n        continue;\\n      }\\n      for (int courses_to_take = courses_can_take;\\n           courses_to_take > 0;\\n           courses_to_take = ((courses_to_take - 1) & courses_can_take)) {\\n        if (number_of_courses(courses_to_take) == k) {\\n          dp[courses_have_been_taken | courses_to_take] = min(dp[courses_have_been_taken | courses_to_take],\\n                                                              1U + dp[courses_have_been_taken]);\\n        }\\n      }\\n    }\\n    return static_cast<int>(dp[layouts - 1]);\\n  }\\n  \\n private:\\n  int number_of_courses(const int layout) {\\n    int ret = 0;\\n    for (int l = layout; l > 0; l -= (l & -l)) {\\n      ++ret;\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(3 ^ n)\\n * Space Complexity: O(2 ^ n)\\n */\\nclass Solution {\\n public:\\n  int minNumberOfSemesters(const int n,\\n                           const vector<vector<int>> &relations,\\n                           const int k) {\\n    constexpr unsigned int unresolved = -1U;\\n    int prerequisites[n];\\n    memset(prerequisites, 0, sizeof(prerequisites));\\n    for (const vector<int> &relation : relations) {\\n      prerequisites[relation.back() - 1] |= (1 << (relation.front() - 1));\\n    }\\n    \\n    const int layouts = (1 << n);\\n    unsigned int dp[layouts];\\n    memset(dp, unresolved, sizeof(dp));\\n    dp[0] = 0;\\n    for (int courses_have_been_taken = 0;\\n         courses_have_been_taken < layouts - 1;\\n         ++courses_have_been_taken) {\\n      if (dp[courses_have_been_taken] == unresolved) {\\n        continue;\\n      }\\n\\n      int courses_can_take = 0;\\n      for (int course = 0; course < n; ++course) {\\n        if ((courses_have_been_taken & prerequisites[course]) == prerequisites[course]) {\\n          courses_can_take |= (1 << course);\\n        }\\n      }\\n      \\n      courses_can_take &= (~courses_have_been_taken);\\n      for (int courses_to_take = courses_can_take;\\n           courses_to_take > 0;\\n           courses_to_take = ((courses_to_take - 1) & courses_can_take)) {\\n        if (number_of_courses(courses_to_take) <= k) {\\n          dp[courses_have_been_taken | courses_to_take] = min(dp[courses_have_been_taken | courses_to_take],\\n                                                              1U + dp[courses_have_been_taken]);\\n        }\\n      }\\n    }\\n    return static_cast<int>(dp[layouts - 1]);\\n  }\\n  \\n private:\\n  int number_of_courses(const int layout) {\\n    int ret = 0;\\n    for (int l = layout; l > 0; l -= (l & -l)) {\\n      ++ret;\\n    }\\n    return ret;\\n  }\\n};\\n```\n```\\n/**\\n * Time Complexity: O(3 ^ n)\\n * Space Complexity: O(2 ^ n)\\n */\\nclass Solution {\\n public:\\n  int minNumberOfSemesters(const int n,\\n                           const vector<vector<int>> &relations,\\n                           const int k) {\\n    constexpr unsigned int unresolved = -1U;\\n    int prerequisites[n];\\n    memset(prerequisites, 0, sizeof(prerequisites));\\n    for (const vector<int> &relation : relations) {\\n      prerequisites[relation.back() - 1] |= (1 << (relation.front() - 1));\\n    }\\n    \\n    const int layouts = (1 << n);\\n    unsigned int dp[layouts];\\n    memset(dp, unresolved, sizeof(dp));\\n    dp[0] = 0;\\n    for (int courses_have_been_taken = 0;\\n         courses_have_been_taken < layouts - 1;\\n         ++courses_have_been_taken) {\\n      if (dp[courses_have_been_taken] == unresolved) {\\n        continue;\\n      }\\n\\n      int courses_can_take = 0;\\n      for (int course = 0; course < n; ++course) {\\n        if ((courses_have_been_taken & prerequisites[course]) == prerequisites[course]) {\\n          courses_can_take |= (1 << course);\\n        }\\n      }\\n      \\n      courses_can_take &= (~courses_have_been_taken);\\n      const int number_of_courses_can_take = number_of_courses(courses_can_take);\\n      if (number_of_courses_can_take <= k) {\\n        dp[courses_have_been_taken | courses_can_take] = min(dp[courses_have_been_taken | courses_can_take],\\n                                                             1U + dp[courses_have_been_taken]);\\n        continue;\\n      }\\n      for (int courses_to_take = courses_can_take;\\n           courses_to_take > 0;\\n           courses_to_take = ((courses_to_take - 1) & courses_can_take)) {\\n        if (number_of_courses(courses_to_take) == k) {\\n          dp[courses_have_been_taken | courses_to_take] = min(dp[courses_have_been_taken | courses_to_take],\\n                                                              1U + dp[courses_have_been_taken]);\\n        }\\n      }\\n    }\\n    return static_cast<int>(dp[layouts - 1]);\\n  }\\n  \\n private:\\n  int number_of_courses(const int layout) {\\n    int ret = 0;\\n    for (int l = layout; l > 0; l -= (l & -l)) {\\n      ++ret;\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3354144,
                "title": "can-t-solve",
                "content": "Why is it timing out in the solution ?\\n```\\nclass Solution:\\n    def minNumberOfSemesters(self, n: int, relations: List[List[int]], k: int) -> int:\\n\\n        indegree = defaultdict(set)\\n        for course in range(n):\\n            indegree[course] = set()\\n\\n        for preq, course in relations:\\n            indegree[course - 1].add(preq - 1)\\n\\n        visited = set()\\n        \\n        def dfs(indegree: dict, g: int) -> int:\\n\\n            candidates = [x for x in indegree if not indegree[x]\\n                          and x not in visited]\\n\\n            if len(candidates) == 0:\\n                return 0\\n\\n            result = float(\\'inf\\')\\n\\t\\t\\t\\n            all_combinations = list(combinations(candidates, min(len(candidates), g)))\\n            for combin in all_combinations:\\n                removed_pairs = []\\n\\t\\t\\t\\t\\n                for course in combin:\\n                    visited.add(course)\\n                    for k in [k for k in indegree if course in indegree[k]]:\\n                        removed_pairs.append((k, course))\\n                        indegree[k].remove(course)\\n\\n                result = min(result, dfs(indegree, g) + 1)\\n\\t\\t\\t\\t\\n                # backtrack\\n                for course in combin:\\n                    visited.remove(course)\\n                for k, course in removed_pairs:\\n                    indegree[k].add(course)\\n\\n            return result\\n\\n        return dfs(indegree, k)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minNumberOfSemesters(self, n: int, relations: List[List[int]], k: int) -> int:\\n\\n        indegree = defaultdict(set)\\n        for course in range(n):\\n            indegree[course] = set()\\n\\n        for preq, course in relations:\\n            indegree[course - 1].add(preq - 1)\\n\\n        visited = set()\\n        \\n        def dfs(indegree: dict, g: int) -> int:\\n\\n            candidates = [x for x in indegree if not indegree[x]\\n                          and x not in visited]\\n\\n            if len(candidates) == 0:\\n                return 0\\n\\n            result = float(\\'inf\\')\\n\\t\\t\\t\\n            all_combinations = list(combinations(candidates, min(len(candidates), g)))\\n            for combin in all_combinations:\\n                removed_pairs = []\\n\\t\\t\\t\\t\\n                for course in combin:\\n                    visited.add(course)\\n                    for k in [k for k in indegree if course in indegree[k]]:\\n                        removed_pairs.append((k, course))\\n                        indegree[k].remove(course)\\n\\n                result = min(result, dfs(indegree, g) + 1)\\n\\t\\t\\t\\t\\n                # backtrack\\n                for course in combin:\\n                    visited.remove(course)\\n                for k, course in removed_pairs:\\n                    indegree[k].add(course)\\n\\n            return result\\n\\n        return dfs(indegree, k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3302416,
                "title": "desi-approach-for-this-problem-for-indians",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumberOfSemesters(int n, vector<vector<int>>& relations, int k) {\\n        vector<int> dependancy(1 << n), dp(1 << n, -1);\\n        for(auto &e : relations){\\n            int u = e[0] - 1;\\n            int v = e[1] - 1;\\n            dependancy[1 << v] |= (1 << u);\\n        }\\n        auto combinations = [&](vector<int> &nanga){\\n            vector<int> comb;\\n            function<void(int, int , int)> foo = [&](int idx, int count, int mask){\\n                if(count == k){\\n                    comb.push_back(mask);\\n                    return;\\n                }\\n                if(idx == nanga.size()) return;\\n                foo(idx + 1, count, mask);\\n                foo(idx + 1, count + 1, mask | (1 << nanga[idx]));\\n            };\\n            foo(0, 0, 0);\\n            return comb;\\n        };\\n        function<int(int) > dfs = [&](int mask){\\n            if(mask == (1 << n) - 1)\\n                return 0;\\n            if(dp[mask] != -1)\\n                return dp[mask];\\n            vector<int> nanga;\\n            int to_mask = mask;\\n            for(int i = 0; i < n; i++){\\n                if((dependancy[1 << i] & mask) == dependancy[1 << i]){ // all dep resolved.\\n                   if(mask & (1 << i)) continue;\\n                    nanga.push_back(i);\\n                    to_mask |= (1 << i);\\n                }\\n            }\\n            int ans = INT_MAX / 10;\\n            if(nanga.size() > k){\\n                for(auto new_mask : combinations(nanga)){\\n                    ans = min(ans, 1 + dfs(mask | new_mask));\\n                }\\n            }\\n            else\\n                ans = 1 + dfs(to_mask);\\n            return dp[mask] = ans;\\n        };\\n\\n        return dfs(0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfSemesters(int n, vector<vector<int>>& relations, int k) {\\n        vector<int> dependancy(1 << n), dp(1 << n, -1);\\n        for(auto &e : relations){\\n            int u = e[0] - 1;\\n            int v = e[1] - 1;\\n            dependancy[1 << v] |= (1 << u);\\n        }\\n        auto combinations = [&](vector<int> &nanga){\\n            vector<int> comb;\\n            function<void(int, int , int)> foo = [&](int idx, int count, int mask){\\n                if(count == k){\\n                    comb.push_back(mask);\\n                    return;\\n                }\\n                if(idx == nanga.size()) return;\\n                foo(idx + 1, count, mask);\\n                foo(idx + 1, count + 1, mask | (1 << nanga[idx]));\\n            };\\n            foo(0, 0, 0);\\n            return comb;\\n        };\\n        function<int(int) > dfs = [&](int mask){\\n            if(mask == (1 << n) - 1)\\n                return 0;\\n            if(dp[mask] != -1)\\n                return dp[mask];\\n            vector<int> nanga;\\n            int to_mask = mask;\\n            for(int i = 0; i < n; i++){\\n                if((dependancy[1 << i] & mask) == dependancy[1 << i]){ // all dep resolved.\\n                   if(mask & (1 << i)) continue;\\n                    nanga.push_back(i);\\n                    to_mask |= (1 << i);\\n                }\\n            }\\n            int ans = INT_MAX / 10;\\n            if(nanga.size() > k){\\n                for(auto new_mask : combinations(nanga)){\\n                    ans = min(ans, 1 + dfs(mask | new_mask));\\n                }\\n            }\\n            else\\n                ans = 1 + dfs(to_mask);\\n            return dp[mask] = ans;\\n        };\\n\\n        return dfs(0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3249353,
                "title": "python3-fast-solution-using-dp-bitmask",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minNumberOfSemesters(self, n: int, relations: List[List[int]], k: int) -> int:\\n\\n        graph = [set() for _ in range(n)]\\n        for pre, cur in relations:\\n            graph[pre - 1].add(cur - 1)\\n\\n        dp = [-1] * (1 << n)    # value is number of Semester\\n        dp[0] = 0   # no selection at all\\n\\n        for msk in range(1 << n):\\n            if dp[msk] == -1:   # no such selection\\n                continue\\n            \\n            #candidates for next selection with zero indegree\\n            cand = self.zero_ind(msk, graph)\\n\\n            #dfs to find next possible masks\\n            self.dfs(cand, 0, msk, msk, dp, k, 0)\\n\\n        return dp[-1]\\n\\n    def zero_ind(self, msk, graph):\\n        cand1 = set()\\n        for idx in range(len(graph)):\\n            if (msk | (1 << idx)) == msk:\\n                continue\\n            cand1.add(idx)\\n        \\n        cand2 = cand1.copy()\\n        for i in cand2:\\n            cand1 = cand1 - graph[i]\\n        return list(cand1)\\n\\n    def dfs(self, cand, depth, msk, msk0, dp, k, start):\\n        if depth == k or depth == len(cand):\\n            if dp[msk] == -1 or dp[msk] > dp[msk0] + 1:\\n                dp[msk] = dp[msk0] + 1\\n            return\\n\\n        for i in range(start, len(cand)):\\n            self.dfs(cand, depth + 1, msk + (1<<cand[i]), msk0, dp, k, i + 1)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumberOfSemesters(self, n: int, relations: List[List[int]], k: int) -> int:\\n\\n        graph = [set() for _ in range(n)]\\n        for pre, cur in relations:\\n            graph[pre - 1].add(cur - 1)\\n\\n        dp = [-1] * (1 << n)    # value is number of Semester\\n        dp[0] = 0   # no selection at all\\n\\n        for msk in range(1 << n):\\n            if dp[msk] == -1:   # no such selection\\n                continue\\n            \\n            #candidates for next selection with zero indegree\\n            cand = self.zero_ind(msk, graph)\\n\\n            #dfs to find next possible masks\\n            self.dfs(cand, 0, msk, msk, dp, k, 0)\\n\\n        return dp[-1]\\n\\n    def zero_ind(self, msk, graph):\\n        cand1 = set()\\n        for idx in range(len(graph)):\\n            if (msk | (1 << idx)) == msk:\\n                continue\\n            cand1.add(idx)\\n        \\n        cand2 = cand1.copy()\\n        for i in cand2:\\n            cand1 = cand1 - graph[i]\\n        return list(cand1)\\n\\n    def dfs(self, cand, depth, msk, msk0, dp, k, start):\\n        if depth == k or depth == len(cand):\\n            if dp[msk] == -1 or dp[msk] > dp[msk0] + 1:\\n                dp[msk] = dp[msk0] + 1\\n            return\\n\\n        for i in range(start, len(cand)):\\n            self.dfs(cand, depth + 1, msk + (1<<cand[i]), msk0, dp, k, i + 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3223973,
                "title": "c-bitmask",
                "content": "# Intuition\\nPorted from C++ from: https://leetcode.com/problems/parallel-courses-ii/solutions/2411686/leetcode-the-hard-way-dp-bit-manipulation/\\n\\n# Approach\\nI know... looking at this solution length, it looks like magic. Credits to the original C++ author (link above).\\n\\nHere\\'s what\\'s happening:\\n### 1\\nWe\\'ll use an array of integers called $$dp$$ of of size (1 << n). $$dp[i]$$ will hold the minimum number of semesters needed to take the courses with the bit set in $$i$$. Since $$1 <= n <= 15$$, we only need at most 2^15 elements.\\nThe worst case is when, in each semester, we can only take one course, hence initialize with $$n$$. We\\'re decreasing all input integers by one so we can use a zero-indexed array.\\n$$pre$$ will hold the pre-requisites for each course in the form of a bitmask. That\\'s why it has $$n$$ elements.\\n\\n```\\nList<int> dp = new List<int>(new int[1 << n]);\\nfor (int i = 0; i<(1 << n); i++)\\n{\\n    dp[i] = n;\\n}\\nList<int> pre = new List<int>(new int[n]);\\nforeach (var x in relations) {\\n    --x[0];\\n    --x[1];\\n    pre[x[1]] |= 1 << x[0];\\n}\\n```\\n### 2\\nBase case: 0 semester. 0 course. $$i$$ is a set of courses that we\\'ve already studied. Initialize $$can$$ as 0 to record how many $$can$$ courses we can study. Iterate over all courses. Check if we\\'ve studied their prerequisite courses. If so, we can study course $$j$$.\\n```\\n dp[0] = 0;\\nfor (int i = 0; i < (1 << n); i++) {\\n    int can = 0;\\n    for (int j = 0; j < n; j++) {\\n        if ((pre[j] & i) == pre[j]) {\\n            can |= (1 << j);\\n        }\\n    }\\n    \\n```\\n### 3\\nRemove those courses that we\\'ve already studied. Enumerate all the bit 1 combinations of $$can$$, i.e. all subsets of a bit representation. Check if we can take $$BitOperations.PopCount(s)$$ courses. If so, we combine the previous results (what\\'ve studied already) or we take a new semester.\\n```\\ncan &= ~i;\\n    for (int s = can; Convert.ToBoolean(s) ; s = ((s - 1) & can)) {\\n        if (System.Numerics.BitOperations.PopCount((uint)s) <= k) {\\n            dp[i | s] = Math.Min(dp[i | s], dp[i] + 1);\\n        }\\n    }\\n}\\nreturn dp[(1 << n) - 1];\\n```\\n# Code\\n```\\npublic class Solution {\\n    public int MinNumberOfSemesters(int n, int[][] relations, int k) {\\n        List<int> dp = new List<int>(new int[1 << n]);\\n        for (int i = 0; i<(1 << n); i++)\\n        {\\n            dp[i] = n;\\n        }\\n        List<int> pre = new List<int>(new int[n]);\\n        foreach (var x in relations) {\\n            --x[0];\\n            --x[1];\\n            pre[x[1]] |= 1 << x[0];\\n        }\\n        dp[0] = 0;\\n        for (int i = 0; i < (1 << n); i++) {\\n            int can = 0;\\n            for (int j = 0; j < n; j++) {\\n                if ((pre[j] & i) == pre[j]) {\\n                    can |= (1 << j);\\n                }\\n            }\\n            can &= ~i;\\n            for (int s = can; Convert.ToBoolean(s) ; s = ((s - 1) & can)) {\\n                if (System.Numerics.BitOperations.PopCount((uint)s) <= k) {\\n                    dp[i | s] = Math.Min(dp[i | s], dp[i] + 1);\\n                }\\n            }\\n        }\\n        return dp[(1 << n) - 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nList<int> dp = new List<int>(new int[1 << n]);\\nfor (int i = 0; i<(1 << n); i++)\\n{\\n    dp[i] = n;\\n}\\nList<int> pre = new List<int>(new int[n]);\\nforeach (var x in relations) {\\n    --x[0];\\n    --x[1];\\n    pre[x[1]] |= 1 << x[0];\\n}\\n```\n```\\n dp[0] = 0;\\nfor (int i = 0; i < (1 << n); i++) {\\n    int can = 0;\\n    for (int j = 0; j < n; j++) {\\n        if ((pre[j] & i) == pre[j]) {\\n            can |= (1 << j);\\n        }\\n    }\\n    \\n```\n```\\ncan &= ~i;\\n    for (int s = can; Convert.ToBoolean(s) ; s = ((s - 1) & can)) {\\n        if (System.Numerics.BitOperations.PopCount((uint)s) <= k) {\\n            dp[i | s] = Math.Min(dp[i | s], dp[i] + 1);\\n        }\\n    }\\n}\\nreturn dp[(1 << n) - 1];\\n```\n```\\npublic class Solution {\\n    public int MinNumberOfSemesters(int n, int[][] relations, int k) {\\n        List<int> dp = new List<int>(new int[1 << n]);\\n        for (int i = 0; i<(1 << n); i++)\\n        {\\n            dp[i] = n;\\n        }\\n        List<int> pre = new List<int>(new int[n]);\\n        foreach (var x in relations) {\\n            --x[0];\\n            --x[1];\\n            pre[x[1]] |= 1 << x[0];\\n        }\\n        dp[0] = 0;\\n        for (int i = 0; i < (1 << n); i++) {\\n            int can = 0;\\n            for (int j = 0; j < n; j++) {\\n                if ((pre[j] & i) == pre[j]) {\\n                    can |= (1 << j);\\n                }\\n            }\\n            can &= ~i;\\n            for (int s = can; Convert.ToBoolean(s) ; s = ((s - 1) & can)) {\\n                if (System.Numerics.BitOperations.PopCount((uint)s) <= k) {\\n                    dp[i | s] = Math.Min(dp[i | s], dp[i] + 1);\\n                }\\n            }\\n        }\\n        return dp[(1 << n) - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3160250,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn min_number_of_semesters(n: i32, relations: Vec<Vec<i32>>, k: i32) -> i32 {\\n        fn count_setbit(mask: i32) -> i32 {\\n            if mask == 0 {\\n                return 0;\\n            }\\n            1 + count_setbit(mask & (mask - 1))\\n        }\\n\\n        let n = n as usize;\\n        let k = k as usize;\\n        let mut dependency = vec![0; n];\\n        for relation in relations {\\n            let course = (relation[1] - 1) as usize;\\n            let prerequisite = (relation[0] - 1) as usize;\\n            dependency[course] |= 1 << prerequisite;\\n        }\\n\\n        let mut prerequisites = vec![0; 1 << n];\\n        for (i, prerequisite) in prerequisites.iter_mut().enumerate().take(1 << n) {\\n            for (j, &item) in dependency.iter().enumerate().take(n) {\\n                if i & (1 << j) != 0 {\\n                    *prerequisite |= item;\\n                }\\n            }\\n        }\\n\\n        let mut dp = vec![n + 1; 1 << n];\\n        dp[0] = 0;\\n        for i in 1..(1 << n) {\\n            let mut j = i;\\n            loop {\\n                if count_setbit(j as i32) as usize > k {\\n                    j = (j - 1) & i;\\n                    continue;\\n                }\\n\\n                let already_taken = i ^ ((1 << n) - 1);\\n                if (already_taken & prerequisites[j]) == prerequisites[j] {\\n                    dp[i] = dp[i].min(dp[i ^ j] + 1);\\n                }\\n\\n                if j == 0 {\\n                    break;\\n                }\\n                j = (j - 1) & i;\\n            }\\n        }\\n\\n        dp[(1 << n) - 1] as _\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_number_of_semesters(n: i32, relations: Vec<Vec<i32>>, k: i32) -> i32 {\\n        fn count_setbit(mask: i32) -> i32 {\\n            if mask == 0 {\\n                return 0;\\n            }\\n            1 + count_setbit(mask & (mask - 1))\\n        }\\n\\n        let n = n as usize;\\n        let k = k as usize;\\n        let mut dependency = vec![0; n];\\n        for relation in relations {\\n            let course = (relation[1] - 1) as usize;\\n            let prerequisite = (relation[0] - 1) as usize;\\n            dependency[course] |= 1 << prerequisite;\\n        }\\n\\n        let mut prerequisites = vec![0; 1 << n];\\n        for (i, prerequisite) in prerequisites.iter_mut().enumerate().take(1 << n) {\\n            for (j, &item) in dependency.iter().enumerate().take(n) {\\n                if i & (1 << j) != 0 {\\n                    *prerequisite |= item;\\n                }\\n            }\\n        }\\n\\n        let mut dp = vec![n + 1; 1 << n];\\n        dp[0] = 0;\\n        for i in 1..(1 << n) {\\n            let mut j = i;\\n            loop {\\n                if count_setbit(j as i32) as usize > k {\\n                    j = (j - 1) & i;\\n                    continue;\\n                }\\n\\n                let already_taken = i ^ ((1 << n) - 1);\\n                if (already_taken & prerequisites[j]) == prerequisites[j] {\\n                    dp[i] = dp[i].min(dp[i ^ j] + 1);\\n                }\\n\\n                if j == 0 {\\n                    break;\\n                }\\n                j = (j - 1) & i;\\n            }\\n        }\\n\\n        dp[(1 << n) - 1] as _\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3086274,
                "title": "js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar minNumberOfSemesters = function (n, relations, k) {\\n\\tconst indegrees = new Array(n + 1);\\n\\tconst dependencies = new Map();\\n\\n\\tfor (let i = 1; i <= n; ++i) {\\n\\t\\tdependencies.set(i, new Set());\\n\\t\\tindegrees[i] = 0;\\n\\t}\\n\\n\\tfor (const [from, to] of relations) {\\n\\t\\tdependencies.get(from).add(to);\\n\\t\\tindegrees[to]++;\\n\\t}\\n\\n\\tlet freeCourseQueue = [];\\n\\tlet startQueue = [];\\n\\n\\tfor (let i = 1; i < indegrees.length; ++i) {\\n\\t\\tif (indegrees[i] === 0) {\\n\\t\\t\\tif (dependencies.get(i).size === 0) {\\n\\t\\t\\t\\tfreeCourseQueue.push(i); //queue of items that are free to study at any time due to not unlocking any new dependencies\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tstartQueue.push(i);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfunction generateCombos(queue) {\\n\\t\\tlet combos = [];\\n\\t\\tlet temp = new Array(k);\\n\\n\\t\\tfunction generateUniqueCombinations(start, index) {\\n\\t\\t\\tif (index === k) {\\n\\t\\t\\t\\tcombos.push([...temp]);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (start < queue.length) {\\n\\t\\t\\t\\t\\ttemp[index] = queue[start];\\n\\t\\t\\t\\t\\tgenerateUniqueCombinations(start + 1, index + 1);\\n\\t\\t\\t\\t\\tgenerateUniqueCombinations(start + 1, index);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tgenerateUniqueCombinations(0, 0);\\n\\t\\treturn combos;\\n\\t}\\n\\tlet minFound = Number.MAX_VALUE;\\n\\n\\tfunction findMinSemesterTime(currQueue, currTime, prevCompleted, prevIndegrees) {\\n\\t\\t//need to make a copy of completed/indegrees as each combination will have to have its own record\\n\\t\\tlet currCompleted = new Set(Array.from(prevCompleted));\\n\\t\\tlet currIndegrees = [...prevIndegrees];\\n\\n\\t\\tfor (let i = 0; i < currQueue.length; ++i) {\\n\\t\\t\\tconst node = currQueue[i];\\n\\t\\t\\tif (!currCompleted.has(node)) {\\n\\t\\t\\t\\tcurrCompleted.add(node);\\n\\t\\t\\t\\tfor (const other of dependencies.get(node)) {\\n\\t\\t\\t\\t\\tcurrIndegrees[other]--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t++currTime;\\n\\n\\t\\tif (currCompleted.size === n) {\\n\\t\\t\\tminFound = Math.min(currTime, minFound);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tlet nextFreeCourses = [];\\n\\t\\tlet nextQueue = [];\\n\\t\\tfor (let i = 1; i < currIndegrees.length; ++i) {\\n\\t\\t\\tif (!currCompleted.has(i) && currIndegrees[i] === 0) {\\n\\t\\t\\t\\tif (dependencies.get(i).size === 0) {\\n\\t\\t\\t\\t\\tnextFreeCourses.push(i);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tnextQueue.push(i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (nextQueue.length > k) {\\n\\t\\t\\tconst nextQueueCombos = generateCombos(nextQueue);\\n\\t\\t\\tfor (const queueCombo of nextQueueCombos) {\\n\\t\\t\\t\\tfindMinSemesterTime(queueCombo, currTime, currCompleted, currIndegrees);\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\twhile (nextQueue.length < k && nextFreeCourses.length) {\\n\\t\\t\\t\\tnextQueue.push(nextFreeCourses.pop());\\n\\t\\t\\t}\\n\\t\\t\\tfindMinSemesterTime(nextQueue, currTime, currCompleted, currIndegrees);\\n\\t\\t}\\n\\t}\\n\\n\\tconst startTime = 0;\\n\\tconst startCompleted = new Set();\\n\\tif (startQueue.length > k) {\\n\\t\\tconst nextQueueCombos = generateCombos(startQueue);\\n\\t\\tfor (const queueCombo of nextQueueCombos) {\\n\\t\\t\\tfindMinSemesterTime(queueCombo, startTime, startCompleted, indegrees);\\n\\t\\t}\\n\\t} else {\\n\\t\\twhile (startQueue.length < k && freeCourseQueue.length) {\\n\\t\\t\\tstartQueue.push(freeCourseQueue.pop());\\n\\t\\t}\\n\\t\\tfindMinSemesterTime(startQueue, startTime, startCompleted, indegrees);\\n\\t}\\n\\treturn minFound;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minNumberOfSemesters = function (n, relations, k) {\\n\\tconst indegrees = new Array(n + 1);\\n\\tconst dependencies = new Map();\\n\\n\\tfor (let i = 1; i <= n; ++i) {\\n\\t\\tdependencies.set(i, new Set());\\n\\t\\tindegrees[i] = 0;\\n\\t}\\n\\n\\tfor (const [from, to] of relations) {\\n\\t\\tdependencies.get(from).add(to);\\n\\t\\tindegrees[to]++;\\n\\t}\\n\\n\\tlet freeCourseQueue = [];\\n\\tlet startQueue = [];\\n\\n\\tfor (let i = 1; i < indegrees.length; ++i) {\\n\\t\\tif (indegrees[i] === 0) {\\n\\t\\t\\tif (dependencies.get(i).size === 0) {\\n\\t\\t\\t\\tfreeCourseQueue.push(i); //queue of items that are free to study at any time due to not unlocking any new dependencies\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tstartQueue.push(i);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfunction generateCombos(queue) {\\n\\t\\tlet combos = [];\\n\\t\\tlet temp = new Array(k);\\n\\n\\t\\tfunction generateUniqueCombinations(start, index) {\\n\\t\\t\\tif (index === k) {\\n\\t\\t\\t\\tcombos.push([...temp]);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (start < queue.length) {\\n\\t\\t\\t\\t\\ttemp[index] = queue[start];\\n\\t\\t\\t\\t\\tgenerateUniqueCombinations(start + 1, index + 1);\\n\\t\\t\\t\\t\\tgenerateUniqueCombinations(start + 1, index);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tgenerateUniqueCombinations(0, 0);\\n\\t\\treturn combos;\\n\\t}\\n\\tlet minFound = Number.MAX_VALUE;\\n\\n\\tfunction findMinSemesterTime(currQueue, currTime, prevCompleted, prevIndegrees) {\\n\\t\\t//need to make a copy of completed/indegrees as each combination will have to have its own record\\n\\t\\tlet currCompleted = new Set(Array.from(prevCompleted));\\n\\t\\tlet currIndegrees = [...prevIndegrees];\\n\\n\\t\\tfor (let i = 0; i < currQueue.length; ++i) {\\n\\t\\t\\tconst node = currQueue[i];\\n\\t\\t\\tif (!currCompleted.has(node)) {\\n\\t\\t\\t\\tcurrCompleted.add(node);\\n\\t\\t\\t\\tfor (const other of dependencies.get(node)) {\\n\\t\\t\\t\\t\\tcurrIndegrees[other]--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t++currTime;\\n\\n\\t\\tif (currCompleted.size === n) {\\n\\t\\t\\tminFound = Math.min(currTime, minFound);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tlet nextFreeCourses = [];\\n\\t\\tlet nextQueue = [];\\n\\t\\tfor (let i = 1; i < currIndegrees.length; ++i) {\\n\\t\\t\\tif (!currCompleted.has(i) && currIndegrees[i] === 0) {\\n\\t\\t\\t\\tif (dependencies.get(i).size === 0) {\\n\\t\\t\\t\\t\\tnextFreeCourses.push(i);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tnextQueue.push(i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (nextQueue.length > k) {\\n\\t\\t\\tconst nextQueueCombos = generateCombos(nextQueue);\\n\\t\\t\\tfor (const queueCombo of nextQueueCombos) {\\n\\t\\t\\t\\tfindMinSemesterTime(queueCombo, currTime, currCompleted, currIndegrees);\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\twhile (nextQueue.length < k && nextFreeCourses.length) {\\n\\t\\t\\t\\tnextQueue.push(nextFreeCourses.pop());\\n\\t\\t\\t}\\n\\t\\t\\tfindMinSemesterTime(nextQueue, currTime, currCompleted, currIndegrees);\\n\\t\\t}\\n\\t}\\n\\n\\tconst startTime = 0;\\n\\tconst startCompleted = new Set();\\n\\tif (startQueue.length > k) {\\n\\t\\tconst nextQueueCombos = generateCombos(startQueue);\\n\\t\\tfor (const queueCombo of nextQueueCombos) {\\n\\t\\t\\tfindMinSemesterTime(queueCombo, startTime, startCompleted, indegrees);\\n\\t\\t}\\n\\t} else {\\n\\t\\twhile (startQueue.length < k && freeCourseQueue.length) {\\n\\t\\t\\tstartQueue.push(freeCourseQueue.pop());\\n\\t\\t}\\n\\t\\tfindMinSemesterTime(startQueue, startTime, startCompleted, indegrees);\\n\\t}\\n\\treturn minFound;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3058927,
                "title": "python-recursion-memoization-easy-to-understand",
                "content": "# Intuition\\nIdea is to try all k-combinations of courses whose in-degree is zero\\n\\n# Approach\\nManipulate in-degree for all k-combinations and undo them after you are done\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nfrom itertools import combinations\\n\\n\\nclass Solution(object):\\n    def __init__(self):\\n        self.dp = {}\\n\\n    def recur(self, graph, in_degree, k, already_taken):\\n        # DP key is this hash value instead of the full set\\n        hash_value = sum([2 ** i for i in in_degree if i not in already_taken])\\n        if hash_value not in self.dp:\\n            indegree_zero_not_taken_yet = [i for i in in_degree if i not in already_taken and in_degree[i] == 0]\\n            if len(indegree_zero_not_taken_yet) == 0:\\n                return 0\\n            mn = float(\"inf\")\\n            for current_taken in combinations(indegree_zero_not_taken_yet, min(k, len(indegree_zero_not_taken_yet))):\\n                # manipulate in_degree if we are taking current combination\\n                for current_element in current_taken:\\n                    for neighbour in graph[current_element]:\\n                        in_degree[neighbour] -= 1\\n                # create temporary already_taken set for current combination\\n                temp_set = set([i for i in already_taken])\\n                temp_set.update(current_taken)\\n                mn = min(mn, self.recur(graph, in_degree, k, temp_set) + 1)\\n                # Undo in_degree manipulation we did above\\n                for current_element in current_taken:\\n                    for neighbour in graph[current_element]:\\n                        in_degree[neighbour] += 1\\n            self.dp[hash_value] = mn\\n        return self.dp[hash_value]\\n\\n\\n    def minNumberOfSemesters(self, n, relations, k):\\n        # create graph and in_degree map(can be an array)\\n        self.dp = {}\\n        graph = defaultdict(list)\\n        in_degree = {i: 0 for i in range(n)}\\n        for prev, next in relations:\\n            graph[prev - 1].append(next - 1)\\n            in_degree[next - 1] += 1\\n\\n        return self.recur(graph, in_degree, k, set([]))\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nfrom collections import defaultdict\\nfrom itertools import combinations\\n\\n\\nclass Solution(object):\\n    def __init__(self):\\n        self.dp = {}\\n\\n    def recur(self, graph, in_degree, k, already_taken):\\n        # DP key is this hash value instead of the full set\\n        hash_value = sum([2 ** i for i in in_degree if i not in already_taken])\\n        if hash_value not in self.dp:\\n            indegree_zero_not_taken_yet = [i for i in in_degree if i not in already_taken and in_degree[i] == 0]\\n            if len(indegree_zero_not_taken_yet) == 0:\\n                return 0\\n            mn = float(\"inf\")\\n            for current_taken in combinations(indegree_zero_not_taken_yet, min(k, len(indegree_zero_not_taken_yet))):\\n                # manipulate in_degree if we are taking current combination\\n                for current_element in current_taken:\\n                    for neighbour in graph[current_element]:\\n                        in_degree[neighbour] -= 1\\n                # create temporary already_taken set for current combination\\n                temp_set = set([i for i in already_taken])\\n                temp_set.update(current_taken)\\n                mn = min(mn, self.recur(graph, in_degree, k, temp_set) + 1)\\n                # Undo in_degree manipulation we did above\\n                for current_element in current_taken:\\n                    for neighbour in graph[current_element]:\\n                        in_degree[neighbour] += 1\\n            self.dp[hash_value] = mn\\n        return self.dp[hash_value]\\n\\n\\n    def minNumberOfSemesters(self, n, relations, k):\\n        # create graph and in_degree map(can be an array)\\n        self.dp = {}\\n        graph = defaultdict(list)\\n        in_degree = {i: 0 for i in range(n)}\\n        for prev, next in relations:\\n            graph[prev - 1].append(next - 1)\\n            in_degree[next - 1] += 1\\n\\n        return self.recur(graph, in_degree, k, set([]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2967911,
                "title": "bitmask-top-down-clean-without-have-optimization",
                "content": "# Intuition\\nIn general, we just need to check all possible combinations of how we can take courses with respect to dependencies and k.\\n\\nBased on this we will need detect what courses can be taken on current step. Then create all possible combination of length k.\\n\\nUse each combination as the current step and go forward.\\n\\n# Approach\\nBitmask for detected visited courses + memo in dfs way.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minNumberOfSemesters(self, n: int, relations: List[List[int]], k: int) -> int:\\n        tree = collections.defaultdict(list)\\n        for x,y in relations:\\n            tree[x - 1].append(y - 1)\\n\\n        @cache\\n        def dp(bitmask):\\n            if bitmask == 0: return 0\\n            allowed = list()\\n            for i in range(n):\\n                if bitmask & (1 << i) == 0: continue\\n                if i not in tree or all(bitmask & (1 << c) == 0 for c in tree[i]):\\n                   allowed.append(i)\\n\\n            check = []\\n            for com in itertools.combinations(allowed, k):\\n                check.append(com)\\n\\n            if len(check) == 0:\\n                check = [allowed]\\n\\n            result = sys.maxsize\\n            for c in check:\\n                change = sum((1 << i for i in c))\\n                result = min(result, dp(bitmask - change) + 1)\\n            return result\\n\\n\\n        return dp((1 << n) - 1)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumberOfSemesters(self, n: int, relations: List[List[int]], k: int) -> int:\\n        tree = collections.defaultdict(list)\\n        for x,y in relations:\\n            tree[x - 1].append(y - 1)\\n\\n        @cache\\n        def dp(bitmask):\\n            if bitmask == 0: return 0\\n            allowed = list()\\n            for i in range(n):\\n                if bitmask & (1 << i) == 0: continue\\n                if i not in tree or all(bitmask & (1 << c) == 0 for c in tree[i]):\\n                   allowed.append(i)\\n\\n            check = []\\n            for com in itertools.combinations(allowed, k):\\n                check.append(com)\\n\\n            if len(check) == 0:\\n                check = [allowed]\\n\\n            result = sys.maxsize\\n            for c in check:\\n                change = sum((1 << i for i in c))\\n                result = min(result, dp(bitmask - change) + 1)\\n            return result\\n\\n\\n        return dp((1 << n) - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2891689,
                "title": "dp-c",
                "content": "# Intuition\\nFor every subset of courses compute how fast we can take all of them.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(2**n * n)$$\\n\\n\\n- Space complexity:\\n$$O(2**n)$$\\n\\n# Code\\n```\\n#include <bit>\\n\\nclass Solution {\\npublic:\\n    static int dp(int n, int k, int mask, const vector<int>& deps, vector<int>& dpMem) {\\n        if (mask + 1 == 1 << n) {\\n            return 0;\\n        }\\n\\n        if (dpMem[mask] != -1) {\\n            return dpMem[mask];\\n        }\\n\\n        int possible = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if ((mask & deps[i]) == deps[i]) {\\n                if ((mask & (1 << i)) == 0) {\\n                    possible |= 1 << i;\\n                }\\n            }\\n        }\\n\\n        int best = 123456789;\\n        for (int daymask = possible; daymask > 0; daymask = ((daymask - 1) & possible)) {\\n            if (__popcount(daymask) <= k) {\\n                best = min(best, 1 + dp(n, k, mask | daymask, deps, dpMem));\\n            }\\n        }\\n        dpMem[mask] = best;\\n        return best;\\n    }\\n\\n    int minNumberOfSemesters(int n, const vector<vector<int>>& relations, int k) {\\n        vector<int> deps(n);\\n        for (const auto& v: relations) {\\n            deps[v[1] - 1] |= 1 << (v[0] - 1);\\n        }\\n        vector<int> dpMem(1 << n, -1);\\n        return dp(n, k, 0, deps, dpMem);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <bit>\\n\\nclass Solution {\\npublic:\\n    static int dp(int n, int k, int mask, const vector<int>& deps, vector<int>& dpMem) {\\n        if (mask + 1 == 1 << n) {\\n            return 0;\\n        }\\n\\n        if (dpMem[mask] != -1) {\\n            return dpMem[mask];\\n        }\\n\\n        int possible = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if ((mask & deps[i]) == deps[i]) {\\n                if ((mask & (1 << i)) == 0) {\\n                    possible |= 1 << i;\\n                }\\n            }\\n        }\\n\\n        int best = 123456789;\\n        for (int daymask = possible; daymask > 0; daymask = ((daymask - 1) & possible)) {\\n            if (__popcount(daymask) <= k) {\\n                best = min(best, 1 + dp(n, k, mask | daymask, deps, dpMem));\\n            }\\n        }\\n        dpMem[mask] = best;\\n        return best;\\n    }\\n\\n    int minNumberOfSemesters(int n, const vector<vector<int>>& relations, int k) {\\n        vector<int> deps(n);\\n        for (const auto& v: relations) {\\n            deps[v[1] - 1] |= 1 << (v[0] - 1);\\n        }\\n        vector<int> dpMem(1 << n, -1);\\n        return dp(n, k, 0, deps, dpMem);\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2863309,
                "title": "a-branch-n-bound-solution-that-runs-in-3ms",
                "content": "This is a branch-and-bound solution, that does not try to do anything smart like using bit masks to represent states, but that runs fast because the branching heuristic works very well.\\n\\nNot intended to be concise code, instead intended to be as clear as possible.\\n\\nThe idea is simple: among courses that can be taken at a given semester, choose with higher priority those who have the longest chain of dependency. This is computed in linear time initially using the \"longest path in a DAG\" algorithm.\\n\\nOnce all the precomputation is done, the rest is worst case exponential-time, but at least on the test suite it works nicely.\\n\\nHere\\'s the full code:\\n\\n```rust\\nuse std::cmp;\\n\\n/// Returns the nodes [0..n) in topo order: if an edge in the graph\\n/// goes from topo[i] to topo[j], with \\'topo\\' the output of this function,\\n/// then i <j.\\n///\\n/// graph: direct edges in the node-centric representation\\n/// rev: revserse edges in the node-centric representation\\nfn topo_sort(graph: &Vec::<Vec::<usize>>, rev: &Vec::<Vec::<usize>>) -> Vec<usize> {\\n    let mut in_degree : Vec::<usize> = rev.iter().map(Vec::len).collect();\\n    let mut zero_in_deg : Vec::<usize> =\\n        in_degree.iter().enumerate().filter(|&(n, &d)| d==0).map(|(n,_)| n).collect();\\n    let mut topo = Vec::<usize>::new();\\n    while let Some(n) = zero_in_deg.pop() {\\n        topo.push(n);\\n        for &s in &graph[n] {\\n            *in_degree.get_mut(s).unwrap() -= 1;\\n            if in_degree[s]==0 {\\n                zero_in_deg.push(s);\\n            }\\n        }\\n    }\\n    topo\\n}\\n\\n/// A branch-n-bound solver for the parallel course problem.\\nstruct Solver {\\n    \\n    /// Direct edges.\\n    graph: Vec<Vec<usize>>,\\n    \\n    /// Reverse edges.\\n    rev: Vec<Vec<usize>>,\\n    \\n    /// The i-th element is length of the longest dependency chain\\n    /// originating from course i, including itself.\\n    ///\\n    /// Examples:\\n    /// - A course with no successor has value 1\\n    /// - A course with 1 successor has value 2\\n    /// - A course with 2 successors that can be taken in parallel has value 2\\n    /// - A course with 2 successors that must be taken in sequence has value 3\\n    length_of_longest_chain_from_node: Vec<usize>,\\n    \\n    /// A permutation of the courses [0..n) in a heuristic order, with the\\n    /// elements near the end being chosen first. That is, branching priority\\n    /// is increasing.\\n    courses_in_heuristic_order : Vec<usize>,\\n    \\n    /// Max number of courses per semester. \\n    k : usize,\\n}\\n\\nimpl Solver {\\n    \\n    /// Computes the min number of semester to take all courses. \\n    fn solve(&self) -> usize {\\n        let mut remaining_indegree : Vec::<i32> = self.rev.iter().map(|v| v.len() as i32).collect();\\n        self.bnb(self.graph.len(), 0, &mut remaining_indegree)\\n    }\\n    \\n    /// Computes the min number of semesters to take all course,\\n    /// using a Branch-and-bound approach, from a given search state.\\n    ///\\n    /// remaining_indegree represents the current search state:\\n    /// * remaining_indegree[i] = 0: i is allowed this semester\\n    /// * remaining_indegree[i] < 0: i is already done\\n    /// * remaining_indegree[i] > 0 : i is not yet allowed\\n    ///\\n    /// best: number of semesters in the best solution found so far.\\n    ///\\n    /// sem: number of semesters fully completed so far.\\n    fn bnb(&self, best: usize, sem: usize, remaining_indegree: &mut[i32]) -> usize {\\n        // Are we done?\\n        if remaining_indegree.iter().all(|&d| d < 0) {\\n            /*if (sem < best) {\\n                println!(\"Found new best solution: {:?}\",\\n                    (0_i32..sem as i32).map(|s|\\n                       remaining_indegree\\n                        .iter()\\n                        .enumerate()\\n                        .filter(|&(_, &neg_s)| neg_s==-s-1)\\n                        .map(|(n, _)| n+1)\\n                        .collect::<Vec::<usize>>()\\n                    ).collect::<Vec::<Vec::<usize>>>());\\n            }*/\\n            return cmp::min(best, sem);\\n        }\\n        if (sem + self.lower_bound_remaining_semesters(remaining_indegree) >= best) {\\n            // Abort search\\n            return best;\\n        }\\n        \\n        let allowed : Vec<usize> = self.courses_in_heuristic_order\\n            .iter()\\n            .filter(|n| remaining_indegree[**n]==0)\\n            .cloned()\\n            .collect();\\n        \\n        self.iterate_children(best, sem, remaining_indegree, &allowed, self.k)\\n    }\\n    \\n    /// Computes a lower bound on the number of semesters for any\\n    /// solution derived from the current state.\\n    fn lower_bound_remaining_semesters(&self, remaining_indegree: &mut[i32]) -> usize {\\n        // Bound based on the dependency structure\\n        let lb_graph = remaining_indegree\\n            .iter()\\n            .enumerate()\\n            .filter(|(_, &d)| d==0)\\n            .map(|(n, _)| self.length_of_longest_chain_from_node[n])\\n            .max()\\n            .unwrap_or(0);\\n        // Bound based on the capacity per semester\\n        let num_unassigned = remaining_indegree\\n            .iter()\\n            .enumerate()\\n            .filter(|(_, &d)| d>=0)\\n            .count();\\n        let lb_capa = (num_unassigned + self.k - 1)/self.k;\\n        cmp::max(lb_graph, lb_capa)\\n    }\\n    \\n    /// Iterate over all possibile branching decisions for a given semester,\\n    /// and make corresponding calls to explore the search space deeper.\\n    ///\\n    /// allowed: slice of courses allowed to be taken this semester, in order of\\n    ///   branching priority (best last).\\n    /// capa: remaining number of courses that can be taken this semester.\\n    fn iterate_children(&self, best: usize, sem: usize, remaining_indegree: &mut[i32], allowed: &[usize], capa: usize) -> usize {\\n        if capa==0 || allowed.is_empty() {\\n            // We\\'ve fully decided what we take this semester.\\n            // Now explore the next semester.\\n            self.bnb(best, sem+1, remaining_indegree)\\n        } else {\\n            // We still have capacity for this semester.\\n            // Branch on the last allowed course.\\n            let course = allowed.last().unwrap().clone();\\n            // Modify the state to reflect that this course is taken this semester.\\n            *remaining_indegree.get_mut(course).unwrap() = -(sem as i32) - 1;\\n            for &s in &self.graph[course] {\\n                *remaining_indegree.get_mut(s).unwrap() -= 1;\\n            }\\n            let mut best = self.iterate_children(\\n                best,\\n                sem,\\n                remaining_indegree,\\n                &allowed[..allowed.len()-1],  // The decision on the last course is made: remove it\\n                capa-1); // One course has been taken: decrease remaining capacity.\\n            // Backtrack: restore the state.\\n            *remaining_indegree.get_mut(course).unwrap() = 0;\\n            for &s in &self.graph[course] {\\n                *remaining_indegree.get_mut(s).unwrap() += 1;\\n            }\\n            // Now try NOT taking this course this semester.\\n            // If allowed.len() == capa, it\\'s always best to take everything: leaving \"holes\"\\n            // is dominated.\\n            if allowed.len() > capa {\\n                best = self.iterate_children(\\n                    best,\\n                    sem,\\n                    remaining_indegree,\\n                    &allowed[..allowed.len()-1],  // The decision on the last course is made: remove it\\n                    capa); // The course was not taken, remaining capacity is unchanged.\\n            }\\n            \\n            best\\n        }\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn min_number_of_semesters(n: i32, relations: Vec<Vec<i32>>, k: i32) -> i32 {\\n        // Let\\'s make everything usized and 0-based first\\n        let n = n as usize;\\n        let k = k as usize;\\n        let relations : Vec::<Vec::<usize>> = relations\\n            .into_iter()\\n            .map(|v| v.into_iter().map(|x| (x-1) as usize).collect())\\n            .collect();\\n\\n        // Construct node-centric representation of the graph, in\\n        // both directions.\\n        let mut graph = vec![Vec::<usize>::new(); n];\\n        let mut rev = vec![Vec::<usize>::new(); n];\\n        for r in relations.iter() {\\n            graph.get_mut(r[0]).unwrap().push(r[1]);\\n            rev.get_mut(r[1]).unwrap().push(r[0]);\\n        }\\n        \\n        // Topo sort\\n        let topo = topo_sort(&graph, &rev);\\n        \\n        // Longest dependency chain from each node (including itself).\\n        // This is the \"longest path in a DAG\" algorithm\\n        let mut length_of_longest_chain_from_node = vec![0; n];\\n        for &n in topo.iter().rev() {\\n            *length_of_longest_chain_from_node.get_mut(n).unwrap() = \\n                graph[n].iter().map(|&s| length_of_longest_chain_from_node[s]).max().map(|m| m+1).unwrap_or(1);\\n        }\\n        \\n        // Sort courses in heuristic order(best last)\\n        let mut courses_in_heuristic_order : Vec<usize> = (0..n).collect();\\n        courses_in_heuristic_order.sort_by_key(|&n| length_of_longest_chain_from_node[n]);\\n        \\n        let solver = Solver {\\n            graph, rev, length_of_longest_chain_from_node, courses_in_heuristic_order, k\\n        };\\n        \\n        solver.solve() as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::cmp;\\n\\n/// Returns the nodes [0..n) in topo order: if an edge in the graph\\n/// goes from topo[i] to topo[j], with \\'topo\\' the output of this function,\\n/// then i <j.\\n///\\n/// graph: direct edges in the node-centric representation\\n/// rev: revserse edges in the node-centric representation\\nfn topo_sort(graph: &Vec::<Vec::<usize>>, rev: &Vec::<Vec::<usize>>) -> Vec<usize> {\\n    let mut in_degree : Vec::<usize> = rev.iter().map(Vec::len).collect();\\n    let mut zero_in_deg : Vec::<usize> =\\n        in_degree.iter().enumerate().filter(|&(n, &d)| d==0).map(|(n,_)| n).collect();\\n    let mut topo = Vec::<usize>::new();\\n    while let Some(n) = zero_in_deg.pop() {\\n        topo.push(n);\\n        for &s in &graph[n] {\\n            *in_degree.get_mut(s).unwrap() -= 1;\\n            if in_degree[s]==0 {\\n                zero_in_deg.push(s);\\n            }\\n        }\\n    }\\n    topo\\n}\\n\\n/// A branch-n-bound solver for the parallel course problem.\\nstruct Solver {\\n    \\n    /// Direct edges.\\n    graph: Vec<Vec<usize>>,\\n    \\n    /// Reverse edges.\\n    rev: Vec<Vec<usize>>,\\n    \\n    /// The i-th element is length of the longest dependency chain\\n    /// originating from course i, including itself.\\n    ///\\n    /// Examples:\\n    /// - A course with no successor has value 1\\n    /// - A course with 1 successor has value 2\\n    /// - A course with 2 successors that can be taken in parallel has value 2\\n    /// - A course with 2 successors that must be taken in sequence has value 3\\n    length_of_longest_chain_from_node: Vec<usize>,\\n    \\n    /// A permutation of the courses [0..n) in a heuristic order, with the\\n    /// elements near the end being chosen first. That is, branching priority\\n    /// is increasing.\\n    courses_in_heuristic_order : Vec<usize>,\\n    \\n    /// Max number of courses per semester. \\n    k : usize,\\n}\\n\\nimpl Solver {\\n    \\n    /// Computes the min number of semester to take all courses. \\n    fn solve(&self) -> usize {\\n        let mut remaining_indegree : Vec::<i32> = self.rev.iter().map(|v| v.len() as i32).collect();\\n        self.bnb(self.graph.len(), 0, &mut remaining_indegree)\\n    }\\n    \\n    /// Computes the min number of semesters to take all course,\\n    /// using a Branch-and-bound approach, from a given search state.\\n    ///\\n    /// remaining_indegree represents the current search state:\\n    /// * remaining_indegree[i] = 0: i is allowed this semester\\n    /// * remaining_indegree[i] < 0: i is already done\\n    /// * remaining_indegree[i] > 0 : i is not yet allowed\\n    ///\\n    /// best: number of semesters in the best solution found so far.\\n    ///\\n    /// sem: number of semesters fully completed so far.\\n    fn bnb(&self, best: usize, sem: usize, remaining_indegree: &mut[i32]) -> usize {\\n        // Are we done?\\n        if remaining_indegree.iter().all(|&d| d < 0) {\\n            /*if (sem < best) {\\n                println!(\"Found new best solution: {:?}\",\\n                    (0_i32..sem as i32).map(|s|\\n                       remaining_indegree\\n                        .iter()\\n                        .enumerate()\\n                        .filter(|&(_, &neg_s)| neg_s==-s-1)\\n                        .map(|(n, _)| n+1)\\n                        .collect::<Vec::<usize>>()\\n                    ).collect::<Vec::<Vec::<usize>>>());\\n            }*/\\n            return cmp::min(best, sem);\\n        }\\n        if (sem + self.lower_bound_remaining_semesters(remaining_indegree) >= best) {\\n            // Abort search\\n            return best;\\n        }\\n        \\n        let allowed : Vec<usize> = self.courses_in_heuristic_order\\n            .iter()\\n            .filter(|n| remaining_indegree[**n]==0)\\n            .cloned()\\n            .collect();\\n        \\n        self.iterate_children(best, sem, remaining_indegree, &allowed, self.k)\\n    }\\n    \\n    /// Computes a lower bound on the number of semesters for any\\n    /// solution derived from the current state.\\n    fn lower_bound_remaining_semesters(&self, remaining_indegree: &mut[i32]) -> usize {\\n        // Bound based on the dependency structure\\n        let lb_graph = remaining_indegree\\n            .iter()\\n            .enumerate()\\n            .filter(|(_, &d)| d==0)\\n            .map(|(n, _)| self.length_of_longest_chain_from_node[n])\\n            .max()\\n            .unwrap_or(0);\\n        // Bound based on the capacity per semester\\n        let num_unassigned = remaining_indegree\\n            .iter()\\n            .enumerate()\\n            .filter(|(_, &d)| d>=0)\\n            .count();\\n        let lb_capa = (num_unassigned + self.k - 1)/self.k;\\n        cmp::max(lb_graph, lb_capa)\\n    }\\n    \\n    /// Iterate over all possibile branching decisions for a given semester,\\n    /// and make corresponding calls to explore the search space deeper.\\n    ///\\n    /// allowed: slice of courses allowed to be taken this semester, in order of\\n    ///   branching priority (best last).\\n    /// capa: remaining number of courses that can be taken this semester.\\n    fn iterate_children(&self, best: usize, sem: usize, remaining_indegree: &mut[i32], allowed: &[usize], capa: usize) -> usize {\\n        if capa==0 || allowed.is_empty() {\\n            // We\\'ve fully decided what we take this semester.\\n            // Now explore the next semester.\\n            self.bnb(best, sem+1, remaining_indegree)\\n        } else {\\n            // We still have capacity for this semester.\\n            // Branch on the last allowed course.\\n            let course = allowed.last().unwrap().clone();\\n            // Modify the state to reflect that this course is taken this semester.\\n            *remaining_indegree.get_mut(course).unwrap() = -(sem as i32) - 1;\\n            for &s in &self.graph[course] {\\n                *remaining_indegree.get_mut(s).unwrap() -= 1;\\n            }\\n            let mut best = self.iterate_children(\\n                best,\\n                sem,\\n                remaining_indegree,\\n                &allowed[..allowed.len()-1],  // The decision on the last course is made: remove it\\n                capa-1); // One course has been taken: decrease remaining capacity.\\n            // Backtrack: restore the state.\\n            *remaining_indegree.get_mut(course).unwrap() = 0;\\n            for &s in &self.graph[course] {\\n                *remaining_indegree.get_mut(s).unwrap() += 1;\\n            }\\n            // Now try NOT taking this course this semester.\\n            // If allowed.len() == capa, it\\'s always best to take everything: leaving \"holes\"\\n            // is dominated.\\n            if allowed.len() > capa {\\n                best = self.iterate_children(\\n                    best,\\n                    sem,\\n                    remaining_indegree,\\n                    &allowed[..allowed.len()-1],  // The decision on the last course is made: remove it\\n                    capa); // The course was not taken, remaining capacity is unchanged.\\n            }\\n            \\n            best\\n        }\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn min_number_of_semesters(n: i32, relations: Vec<Vec<i32>>, k: i32) -> i32 {\\n        // Let\\'s make everything usized and 0-based first\\n        let n = n as usize;\\n        let k = k as usize;\\n        let relations : Vec::<Vec::<usize>> = relations\\n            .into_iter()\\n            .map(|v| v.into_iter().map(|x| (x-1) as usize).collect())\\n            .collect();\\n\\n        // Construct node-centric representation of the graph, in\\n        // both directions.\\n        let mut graph = vec![Vec::<usize>::new(); n];\\n        let mut rev = vec![Vec::<usize>::new(); n];\\n        for r in relations.iter() {\\n            graph.get_mut(r[0]).unwrap().push(r[1]);\\n            rev.get_mut(r[1]).unwrap().push(r[0]);\\n        }\\n        \\n        // Topo sort\\n        let topo = topo_sort(&graph, &rev);\\n        \\n        // Longest dependency chain from each node (including itself).\\n        // This is the \"longest path in a DAG\" algorithm\\n        let mut length_of_longest_chain_from_node = vec![0; n];\\n        for &n in topo.iter().rev() {\\n            *length_of_longest_chain_from_node.get_mut(n).unwrap() = \\n                graph[n].iter().map(|&s| length_of_longest_chain_from_node[s]).max().map(|m| m+1).unwrap_or(1);\\n        }\\n        \\n        // Sort courses in heuristic order(best last)\\n        let mut courses_in_heuristic_order : Vec<usize> = (0..n).collect();\\n        courses_in_heuristic_order.sort_by_key(|&n| length_of_longest_chain_from_node[n]);\\n        \\n        let solver = Solver {\\n            graph, rev, length_of_longest_chain_from_node, courses_in_heuristic_order, k\\n        };\\n        \\n        solver.solve() as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2836215,
                "title": "swift-105-ms",
                "content": "```\\nclass Solution {\\n    func minNumberOfSemesters(_ n: Int, _ relations: [[Int]], _ k: Int) -> Int {\\n        var relationMasks = Array(repeating: 0, count: n)\\n        relations.forEach { relationMasks[$0[1] - 1] |= (1 << ($0[0] - 1)) }\\n        var cache: [Int: Int] = [:]\\n        return minNumberOfSemesters(n, k, relationMasks, 0, &cache)\\n    }\\n\\n    private func minNumberOfSemesters(_ n: Int, _ k: Int, _ relations: [Int], _ visited: Int, _ cache: inout [Int: Int]) -> Int {\\n        if visited == (1 << n) - 1 { return 0 }\\n        if let c = cache[visited] { return c }\\n        var pretendents: [Int] = []\\n        for (i, r) in relations.enumerated() {\\n            let m = 1 << i\\n            if (visited & m) == 0 && (r & ~visited) == 0 { pretendents.append(m) }\\n        }\\n        var variants: [Int] = []\\n        choose(k, pretendents, 0, 0, &variants)\\n        var count = Int.max\\n        for v in variants {\\n            count = min(count, 1 + minNumberOfSemesters(n, k, relations, visited | v, &cache))\\n        }\\n        cache[visited] = count\\n        return count\\n    }\\n\\n    // choose all subarrays of k elements from arr,\\n    // compute OR operation of all elements of the subarray\\n    // and push it to the result\\n    private func choose(_ k: Int, _ arr: [Int], _ from: Int, _ cur: Int, _ result: inout [Int]) {\\n        if arr.count - from <= k {\\n            var v = cur\\n            for i in from ..< arr.count {\\n                v |= arr[i]\\n            }\\n            result.append(v)\\n            return\\n        }\\n        for i in from ..< arr.count - k + 1 {\\n            if k == 1 {\\n                result.append(cur | arr[i])\\n            } else {\\n                choose(k - 1, arr, i + 1, cur | arr[i], &result)\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minNumberOfSemesters(_ n: Int, _ relations: [[Int]], _ k: Int) -> Int {\\n        var relationMasks = Array(repeating: 0, count: n)\\n        relations.forEach { relationMasks[$0[1] - 1] |= (1 << ($0[0] - 1)) }\\n        var cache: [Int: Int] = [:]\\n        return minNumberOfSemesters(n, k, relationMasks, 0, &cache)\\n    }\\n\\n    private func minNumberOfSemesters(_ n: Int, _ k: Int, _ relations: [Int], _ visited: Int, _ cache: inout [Int: Int]) -> Int {\\n        if visited == (1 << n) - 1 { return 0 }\\n        if let c = cache[visited] { return c }\\n        var pretendents: [Int] = []\\n        for (i, r) in relations.enumerated() {\\n            let m = 1 << i\\n            if (visited & m) == 0 && (r & ~visited) == 0 { pretendents.append(m) }\\n        }\\n        var variants: [Int] = []\\n        choose(k, pretendents, 0, 0, &variants)\\n        var count = Int.max\\n        for v in variants {\\n            count = min(count, 1 + minNumberOfSemesters(n, k, relations, visited | v, &cache))\\n        }\\n        cache[visited] = count\\n        return count\\n    }\\n\\n    // choose all subarrays of k elements from arr,\\n    // compute OR operation of all elements of the subarray\\n    // and push it to the result\\n    private func choose(_ k: Int, _ arr: [Int], _ from: Int, _ cur: Int, _ result: inout [Int]) {\\n        if arr.count - from <= k {\\n            var v = cur\\n            for i in from ..< arr.count {\\n                v |= arr[i]\\n            }\\n            result.append(v)\\n            return\\n        }\\n        for i in from ..< arr.count - k + 1 {\\n            if k == 1 {\\n                result.append(cur | arr[i])\\n            } else {\\n                choose(k - 1, arr, i + 1, cur | arr[i], &result)\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2813922,
                "title": "rust-bit-masking-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1) Use masks to represent the set of courses (nodes) taken.\\n2) For a particular mask, calculate the courses that could be taken.\\n3) If the available courses calculated from step 2) are more than k, use DP to try all subsets with k size \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nimpl Solution {\\n    pub fn min_number_of_semesters(n: i32, relations: Vec<Vec<i32>>, k: i32) -> i32 {\\n        let (n, sz) = (n as usize, 1 << n as usize);\\n        let mut graph = vec![vec![]; n];\\n\\n        for relation in relations {\\n            let (u, v) = (relation[0] as usize - 1, relation[1] as usize - 1);\\n\\n            graph[u].push(v);\\n        }\\n\\n        let mut dp = vec![-1; sz];\\n        dp[sz - 1] = 0;\\n\\n        Self::solve(&graph, &mut dp, 0, k as usize)\\n    }\\n\\n    // return the available courses after finishing the courses masked in taken_mask\\n    fn availavle_courses(graph: &Vec<Vec<usize>>, taken_mask: usize) -> Vec<usize> {\\n        let n = graph.len();\\n        let mut indegree = vec![0; n];\\n        \\n        for u in 0 .. n {\\n            if 1 << u & taken_mask > 0 { continue }\\n            \\n            for v in &graph[u] { \\n                if 1 << v & taken_mask > 0 { continue }\\n                \\n                indegree[*v] += 1; \\n            }\\n        }\\n\\n        let mut ret = vec![];\\n        for u in 0 .. n {\\n            if 1 << u & taken_mask == 0 && indegree[u] == 0 { ret.push(u); }\\n        }\\n\\n        ret\\n    }\\n \\n    fn solve(graph: &Vec<Vec<usize>>, dp: &mut Vec<i32>, taken_mask: usize, k: usize) -> i32 {\\n        if dp[taken_mask] != -1 { return dp[taken_mask] }\\n\\n        let indexes = Self::availavle_courses(graph, taken_mask);\\n\\n        if indexes.len() <= k {\\n            let mut new_mask = 0;\\n            for u in indexes { new_mask |= 1 << u; }\\n            \\n            dp[taken_mask] = 1 + Self::solve(graph, dp, taken_mask | new_mask, k);\\n            \\n            return dp[taken_mask]\\n        }\\n\\n        let sz = 1 << indexes.len();\\n        dp[taken_mask] = i32::MAX;\\n\\n        for mask in 0 .. sz {\\n            let (mut new_mask, mut cnt) = (0, 0);\\n            \\n            for k in 0 .. indexes.len() {\\n                if 1 << k & mask == 0 { continue }\\n                new_mask |= 1 << indexes[k];\\n\\n                cnt += 1;\\n            }\\n\\n            if cnt != k { continue }\\n             \\n             let temp = Self::solve(graph, dp, taken_mask | new_mask, k);\\n             if temp < dp[taken_mask] - 1 { dp[taken_mask] = 1 + temp; }           \\n        }\\n\\n        dp[taken_mask]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n\\nimpl Solution {\\n    pub fn min_number_of_semesters(n: i32, relations: Vec<Vec<i32>>, k: i32) -> i32 {\\n        let (n, sz) = (n as usize, 1 << n as usize);\\n        let mut graph = vec![vec![]; n];\\n\\n        for relation in relations {\\n            let (u, v) = (relation[0] as usize - 1, relation[1] as usize - 1);\\n\\n            graph[u].push(v);\\n        }\\n\\n        let mut dp = vec![-1; sz];\\n        dp[sz - 1] = 0;\\n\\n        Self::solve(&graph, &mut dp, 0, k as usize)\\n    }\\n\\n    // return the available courses after finishing the courses masked in taken_mask\\n    fn availavle_courses(graph: &Vec<Vec<usize>>, taken_mask: usize) -> Vec<usize> {\\n        let n = graph.len();\\n        let mut indegree = vec![0; n];\\n        \\n        for u in 0 .. n {\\n            if 1 << u & taken_mask > 0 { continue }\\n            \\n            for v in &graph[u] { \\n                if 1 << v & taken_mask > 0 { continue }\\n                \\n                indegree[*v] += 1; \\n            }\\n        }\\n\\n        let mut ret = vec![];\\n        for u in 0 .. n {\\n            if 1 << u & taken_mask == 0 && indegree[u] == 0 { ret.push(u); }\\n        }\\n\\n        ret\\n    }\\n \\n    fn solve(graph: &Vec<Vec<usize>>, dp: &mut Vec<i32>, taken_mask: usize, k: usize) -> i32 {\\n        if dp[taken_mask] != -1 { return dp[taken_mask] }\\n\\n        let indexes = Self::availavle_courses(graph, taken_mask);\\n\\n        if indexes.len() <= k {\\n            let mut new_mask = 0;\\n            for u in indexes { new_mask |= 1 << u; }\\n            \\n            dp[taken_mask] = 1 + Self::solve(graph, dp, taken_mask | new_mask, k);\\n            \\n            return dp[taken_mask]\\n        }\\n\\n        let sz = 1 << indexes.len();\\n        dp[taken_mask] = i32::MAX;\\n\\n        for mask in 0 .. sz {\\n            let (mut new_mask, mut cnt) = (0, 0);\\n            \\n            for k in 0 .. indexes.len() {\\n                if 1 << k & mask == 0 { continue }\\n                new_mask |= 1 << indexes[k];\\n\\n                cnt += 1;\\n            }\\n\\n            if cnt != k { continue }\\n             \\n             let temp = Self::solve(graph, dp, taken_mask | new_mask, k);\\n             if temp < dp[taken_mask] - 1 { dp[taken_mask] = 1 + temp; }           \\n        }\\n\\n        dp[taken_mask]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2757554,
                "title": "javascript-backtrack-bitmask-memoization",
                "content": "```\\nlet minNumberOfSemesters = function(n, relations, k) {  \\n    let MEMO = new Map();\\n    \\n    let inDegree = new Array(n).fill(0);\\n    let postCources = new Array(n).fill(0);\\n        \\n    for ( let [pre, post] of relations )\\n    {\\n        ++inDegree[post - 1];\\n        postCources[pre - 1] |= 1 << ( post - 1 );\\n    }\\n    \\n    //--------------------------------------------------------------\\n    let countSetBit = function( mask ) {\\n        if ( 0 == mask ) return 0;\\n        return 1 + countSetBit( ( mask - 1 ) & mask );\\n    }\\n    \\n    //--------------------------------------------------------------\\n    let backtrack = function( alreadytakenMask ) {\\n        let hit = MEMO.get(alreadytakenMask);\\n        if ( hit != undefined ) return hit;\\n            \\n        if ( alreadytakenMask == ( 1 << n ) - 1 )\\n            return 0;\\n        \\n        MEMO.set(alreadytakenMask, 200);\\n        let can = 0;\\n        \\n        for ( let j = 0; j < n; ++j )\\n        {\\n            if ( inDegree[j] == 0 )\\n                can |= 1 << j;\\n        }\\n        can &= ~alreadytakenMask;\\n        \\n        let setBitLen = Math.min(countSetBit(can), k);\\n        for ( let submask = can; submask; submask = ( submask - 1 ) & can )\\n        {\\n            if ( countSetBit(submask) == setBitLen )\\n            {\\n                let newmask = alreadytakenMask;\\n                let newInDegree = inDegree.slice();\\n                \\n                for ( let bit = 0; bit < n; ++bit )\\n                {\\n                    if ( (submask >> bit) % 2 != 0 )\\n                    {\\n                        newmask |= 1 << bit;\\n                        \\n                        for ( let j = 0; j < n; ++j )\\n                        {\\n                            if ( (postCources[bit] >> j) % 2 != 0 )\\n                                --inDegree[j];\\n                        }\\n                    }\\n                }\\n                \\n                MEMO.set(alreadytakenMask, Math.min( MEMO.get(alreadytakenMask), 1 + backtrack(newmask) ) );\\n                inDegree = newInDegree;\\n            }\\n        }\\n        return MEMO.get(alreadytakenMask);\\n    }\\n    return backtrack(0);   \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Memoization",
                    "Bitmask"
                ],
                "code": "```\\nlet minNumberOfSemesters = function(n, relations, k) {  \\n    let MEMO = new Map();\\n    \\n    let inDegree = new Array(n).fill(0);\\n    let postCources = new Array(n).fill(0);\\n        \\n    for ( let [pre, post] of relations )\\n    {\\n        ++inDegree[post - 1];\\n        postCources[pre - 1] |= 1 << ( post - 1 );\\n    }\\n    \\n    //--------------------------------------------------------------\\n    let countSetBit = function( mask ) {\\n        if ( 0 == mask ) return 0;\\n        return 1 + countSetBit( ( mask - 1 ) & mask );\\n    }\\n    \\n    //--------------------------------------------------------------\\n    let backtrack = function( alreadytakenMask ) {\\n        let hit = MEMO.get(alreadytakenMask);\\n        if ( hit != undefined ) return hit;\\n            \\n        if ( alreadytakenMask == ( 1 << n ) - 1 )\\n            return 0;\\n        \\n        MEMO.set(alreadytakenMask, 200);\\n        let can = 0;\\n        \\n        for ( let j = 0; j < n; ++j )\\n        {\\n            if ( inDegree[j] == 0 )\\n                can |= 1 << j;\\n        }\\n        can &= ~alreadytakenMask;\\n        \\n        let setBitLen = Math.min(countSetBit(can), k);\\n        for ( let submask = can; submask; submask = ( submask - 1 ) & can )\\n        {\\n            if ( countSetBit(submask) == setBitLen )\\n            {\\n                let newmask = alreadytakenMask;\\n                let newInDegree = inDegree.slice();\\n                \\n                for ( let bit = 0; bit < n; ++bit )\\n                {\\n                    if ( (submask >> bit) % 2 != 0 )\\n                    {\\n                        newmask |= 1 << bit;\\n                        \\n                        for ( let j = 0; j < n; ++j )\\n                        {\\n                            if ( (postCources[bit] >> j) % 2 != 0 )\\n                                --inDegree[j];\\n                        }\\n                    }\\n                }\\n                \\n                MEMO.set(alreadytakenMask, Math.min( MEMO.get(alreadytakenMask), 1 + backtrack(newmask) ) );\\n                inDegree = newInDegree;\\n            }\\n        }\\n        return MEMO.get(alreadytakenMask);\\n    }\\n    return backtrack(0);   \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2715924,
                "title": "java-solution-ask-for-suggestions",
                "content": "currently just barely passing. (i think this questions is just a lot harder than other hard question (like alien dictionary lol, also topological sort))\\nThe only reason it\\'s passing is because I added procedures for special cases (graphs with very little edges)\\n\\nMy solution is based on Topological sort (BFS)\\nFirst create Adj. list (graph) and indegree array (ind), as well as sources list (vertices with no incoming edges)\\n\\nrecursively check: all combinations of current sources\\nso for every element in sources: use it as the first course in that semester, and run the function on the rest of the sources;\\nif k is reached or we took all the source courses, return value + 1 and we add the new available sources to the sources list\\n\\nI used Map as memoization: key is <current courses of semester + [sortedset of remaining courses].toString>, value is min semesters\\nim sure the memoization helped but I\\'m not sure if there is a better way\\n\\nGraphs with many vertices and few edges always time out. So I made a special case for them: if minimum possible semester is reached, end for loop (15 courses with k = 4, minimum is ceiling(15/4) = 4)\\n\\nI am aware of small optimizations (e.g. I dont need to clone all the data structures every time), I want to ask if there are any major optimizations, I think the current big O is O(V!+ k) based on the memoization\\n\\n```\\nclass Solution {\\n    public int minNumberOfSemesters(int n, int[][] relations, int k) {\\n        int[] ind = new int[n + 1];\\n        List<Integer>[] graph = new List[n + 1];\\n        for (int i = 1; i <= n; i++) {\\n            graph[i] = new ArrayList<>();\\n        }\\n        for (int[] edge: relations) {\\n            ind[edge[1]]++;\\n            graph[edge[0]].add(edge[1]);\\n        }\\n        List<Integer> sources = new ArrayList<>();\\n        Set<Integer> test = new TreeSet<>();\\n        for (int i = 1; i <= n; i++) {\\n            test.add(i);\\n            if (ind[i] == 0) {\\n                sources.add(i);\\n            }\\n        }\\n        Map<String, Integer> dp = new HashMap<>();\\n        \\n\\n        \\n            \\n        int ans = rec(dp, sources, graph, ind, k, 0, new ArrayList<>(), test);\\n        return ans;\\n    }\\n    \\n    public List<Integer> copyList(List<Integer> list, int remove) {\\n        List<Integer> ret = new ArrayList<>();\\n        for (int i: list) {\\n            if (i == remove) {\\n                continue;\\n            }\\n            ret.add(i);\\n        }\\n        return ret;\\n    }\\n    \\n    public int rec(Map<String, Integer> dp, List<Integer> sources, List<Integer>[] graph, int[] ind, int k, int cur, List<Integer> newSources, Set<Integer> processed) {\\n        \\n\\n        List<Integer> newS = new ArrayList<>(sources);\\n        \\n        if (newS.isEmpty() && newSources.isEmpty()) {\\n            return 1;\\n        }\\n        else if (newS.isEmpty()) {\\n            return 1 + rec(dp, newSources, graph, ind.clone(), k, 0, new ArrayList<>(), processed);\\n        }\\n        if (dp.containsKey(cur + \"?\" + processed.toString())) {\\n            return dp.get(cur + \"?\" + processed.toString());\\n        }\\n        int ret = 0;\\n        if (cur == k) {\\n            cur = 0;\\n            ret++;\\n            newS.addAll(newSources);\\n            newSources = new ArrayList<>();\\n        }\\n        int min = Integer.MAX_VALUE;\\n        \\n        for (int s: newS) {\\n            List<Integer> sourceminueone = copyList(newS, s);\\n            int[] newInd = ind.clone();\\n            List<Integer> newNS = new ArrayList<>(newSources);\\n            \\n            for (int v2: graph[s]) {\\n                \\n                newInd[v2]--;\\n                if (newInd[v2] == 0) {\\n                    newNS.add(v2);\\n                }\\n            }\\n            Set<Integer> newP = new TreeSet<>(processed);\\n            newP.remove(s);\\n            min = Math.min(min, rec(dp, sourceminueone, graph, newInd.clone(), k, cur + 1, newNS, newP));\\n            if (min == (newP.size() + k - 1) / k) {\\n                break;\\n            }\\n        }\\n        dp.put(cur+\"?\"+processed.toString(), min + ret);\\n        return min + ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumberOfSemesters(int n, int[][] relations, int k) {\\n        int[] ind = new int[n + 1];\\n        List<Integer>[] graph = new List[n + 1];\\n        for (int i = 1; i <= n; i++) {\\n            graph[i] = new ArrayList<>();\\n        }\\n        for (int[] edge: relations) {\\n            ind[edge[1]]++;\\n            graph[edge[0]].add(edge[1]);\\n        }\\n        List<Integer> sources = new ArrayList<>();\\n        Set<Integer> test = new TreeSet<>();\\n        for (int i = 1; i <= n; i++) {\\n            test.add(i);\\n            if (ind[i] == 0) {\\n                sources.add(i);\\n            }\\n        }\\n        Map<String, Integer> dp = new HashMap<>();\\n        \\n\\n        \\n            \\n        int ans = rec(dp, sources, graph, ind, k, 0, new ArrayList<>(), test);\\n        return ans;\\n    }\\n    \\n    public List<Integer> copyList(List<Integer> list, int remove) {\\n        List<Integer> ret = new ArrayList<>();\\n        for (int i: list) {\\n            if (i == remove) {\\n                continue;\\n            }\\n            ret.add(i);\\n        }\\n        return ret;\\n    }\\n    \\n    public int rec(Map<String, Integer> dp, List<Integer> sources, List<Integer>[] graph, int[] ind, int k, int cur, List<Integer> newSources, Set<Integer> processed) {\\n        \\n\\n        List<Integer> newS = new ArrayList<>(sources);\\n        \\n        if (newS.isEmpty() && newSources.isEmpty()) {\\n            return 1;\\n        }\\n        else if (newS.isEmpty()) {\\n            return 1 + rec(dp, newSources, graph, ind.clone(), k, 0, new ArrayList<>(), processed);\\n        }\\n        if (dp.containsKey(cur + \"?\" + processed.toString())) {\\n            return dp.get(cur + \"?\" + processed.toString());\\n        }\\n        int ret = 0;\\n        if (cur == k) {\\n            cur = 0;\\n            ret++;\\n            newS.addAll(newSources);\\n            newSources = new ArrayList<>();\\n        }\\n        int min = Integer.MAX_VALUE;\\n        \\n        for (int s: newS) {\\n            List<Integer> sourceminueone = copyList(newS, s);\\n            int[] newInd = ind.clone();\\n            List<Integer> newNS = new ArrayList<>(newSources);\\n            \\n            for (int v2: graph[s]) {\\n                \\n                newInd[v2]--;\\n                if (newInd[v2] == 0) {\\n                    newNS.add(v2);\\n                }\\n            }\\n            Set<Integer> newP = new TreeSet<>(processed);\\n            newP.remove(s);\\n            min = Math.min(min, rec(dp, sourceminueone, graph, newInd.clone(), k, cur + 1, newNS, newP));\\n            if (min == (newP.size() + k - 1) / k) {\\n                break;\\n            }\\n        }\\n        dp.put(cur+\"?\"+processed.toString(), min + ret);\\n        return min + ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2682261,
                "title": "c-dp-solution-with-memoization",
                "content": "class Solution {\\npublic:\\n    typedef vector<int> vi;\\n    typedef vector<vi> vvi;\\n    #define pb push_back\\n    #define F first\\n    #define S second\\n    #define MP make_pair\\n    const int INF_ = 1e9;\\n    \\n    int n,k;\\n    vi dp;\\n    vvi g, gin;\\n    \\n    // rec(st) = mininmum number of days to reach state=\"end\" from state \"curr\"\\n    int rec(int curr){\\n        if(curr==((1<<n)-1)) return dp[curr]=0;\\n        if(dp[curr]!=-1) return dp[curr];\\n        \\n        int ans = n;\\n        vi candis;\\n        for(int b=0;b<n;b++){\\n            bool validcandi=1;\\n            if(((1<<b)&curr)==0){ // this course has not yet been covered\\n                for(auto &v:gin[b]){\\n                    if(((1<<v)&curr)==0){\\n                        validcandi=0;\\n                        break;\\n                    }\\n                }\\n                if(validcandi) candis.pb(b);\\n            }\\n        }\\n        int numcandis = candis.size();\\n        if(numcandis<=k){\\n            int nextstate = curr;\\n            for(int i=0;i<numcandis;i++){\\n                nextstate|=(1<<candis[i]);\\n            }\\n            return dp[curr]=1+rec(nextstate);\\n        }\\n        \\n        for(int i=0;i<(1<<numcandis);i++){\\n            int cnt=0;\\n            int selmask = 0;\\n            for(int b=0;b<numcandis;b++){\\n                if(i&(1<<b)){\\n                    cnt++;\\n                    selmask|=(1<<candis[b]);\\n                }\\n            }\\n            if(cnt==k){\\n                int newstate = curr|selmask;\\n                ans = min(ans, rec(newstate)+1);\\n            }\\n        }\\n        return dp[curr]=ans;\\n    }\\n    \\n    int minNumberOfSemesters(int nt, vvi& relations, int kt) {\\n        n = nt; k=kt;\\n        dp.clear(); dp.resize((1<<n),-1);\\n        g.clear(); g.resize(n);\\n        gin.clear(); gin.resize(n);\\n        for(int i=0;i<relations.size();i++){\\n            g[relations[i][0]-1].pb(relations[i][1]-1);\\n            gin[relations[i][1]-1].pb(relations[i][0]-1);\\n        }\\n        int startstate = 0;\\n        return rec(startstate);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    typedef vector<int> vi;\\n    typedef vector<vi> vvi;\\n    #define pb push_back\\n    #define F first\\n    #define S second\\n    #define MP make_pair\\n    const int INF_ = 1e9;\\n    \\n    int n,k;\\n    vi dp;\\n    vvi g, gin;\\n    \\n    // rec(st) = mininmum number of days to reach state=\"end\" from state \"curr\"\\n    int rec(int curr){\\n        if(curr==((1<<n)-1)) return dp[curr]=0;\\n        if(dp[curr]!=-1) return dp[curr];\\n        \\n        int ans = n;\\n        vi candis;\\n        for(int b=0;b<n;b++){\\n            bool validcandi=1;\\n            if(((1<<b)&curr)==0){ // this course has not yet been covered\\n                for(auto &v:gin[b]){\\n                    if(((1<<v)&curr)==0){\\n                        validcandi=0;\\n                        break;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 2598811,
                "title": "c-solution-with-toposort-priorityqueue-passing-78-81-test-cases",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int dfs(vector<vector<int>> &adjList, int start) {\\n        int d = 0;\\n        for (auto &i:adjList[start]) \\n            d = max(d, dfs(adjList, i));\\n        return d + 1;\\n    }\\n    \\n    int minNumberOfSemesters(int n, vector<vector<int>>& relations, int k) {\\n        vector<vector<int>> adjList (n + 1);\\n        vector<int> inDegrees(n + 1, 0);\\n        for(auto &i:relations) {\\n            inDegrees[i[1]] ++;\\n            adjList[i[0]].push_back(i[1]);\\n        }\\n        \\n        //max heap\\n        priority_queue<pair<int,int>> pq;\\n        \\n        for (int i=1 ; i<=n;i++) {\\n            if (inDegrees[i] == 0) {\\n                int maxCourses = dfs(adjList, i);\\n                cout<<\"maxCourses for \"<<i<<\"is \"<<maxCourses<<endl;\\n                pq.push({maxCourses, i});\\n            }\\n        }\\n        \\n        int sem = 0;\\n        while(!pq.empty()) {\\n            sem++;\\n            int subThisSem = 0;\\n            \\n            priority_queue<pair<int,int>> temp;\\n            \\n            for (int s = pq.size();s>0;s--) {\\n                auto node = pq.top().second;   \\n                pq.pop();\\n                //cout<<\"Node is \"<<node<<endl;\\n                for (auto &j:adjList[node]) {\\n                    if (--inDegrees[j] == 0) {\\n                        int maxCourses = dfs(adjList, j);\\n                        //cout<<\"maxCourses for \"<<j<<\"is \"<<maxCourses<<endl;\\n                        temp.push({maxCourses, j});\\n                    }\\n                }\\n                if (++subThisSem >= k) break;\\n            }\\n            while(!temp.empty()) {\\n                pq.push(temp.top());\\n                temp.pop();\\n            }\\n        }\\n        return sem;\\n    }\\n};\\n```\\n\\nCan someone help me figure out what I\\'m missing for remaining 3 cases to pass?",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dfs(vector<vector<int>> &adjList, int start) {\\n        int d = 0;\\n        for (auto &i:adjList[start]) \\n            d = max(d, dfs(adjList, i));\\n        return d + 1;\\n    }\\n    \\n    int minNumberOfSemesters(int n, vector<vector<int>>& relations, int k) {\\n        vector<vector<int>> adjList (n + 1);\\n        vector<int> inDegrees(n + 1, 0);\\n        for(auto &i:relations) {\\n            inDegrees[i[1]] ++;\\n            adjList[i[0]].push_back(i[1]);\\n        }\\n        \\n        //max heap\\n        priority_queue<pair<int,int>> pq;\\n        \\n        for (int i=1 ; i<=n;i++) {\\n            if (inDegrees[i] == 0) {\\n                int maxCourses = dfs(adjList, i);\\n                cout<<\"maxCourses for \"<<i<<\"is \"<<maxCourses<<endl;\\n                pq.push({maxCourses, i});\\n            }\\n        }\\n        \\n        int sem = 0;\\n        while(!pq.empty()) {\\n            sem++;\\n            int subThisSem = 0;\\n            \\n            priority_queue<pair<int,int>> temp;\\n            \\n            for (int s = pq.size();s>0;s--) {\\n                auto node = pq.top().second;   \\n                pq.pop();\\n                //cout<<\"Node is \"<<node<<endl;\\n                for (auto &j:adjList[node]) {\\n                    if (--inDegrees[j] == 0) {\\n                        int maxCourses = dfs(adjList, j);\\n                        //cout<<\"maxCourses for \"<<j<<\"is \"<<maxCourses<<endl;\\n                        temp.push({maxCourses, j});\\n                    }\\n                }\\n                if (++subThisSem >= k) break;\\n            }\\n            while(!temp.empty()) {\\n                pq.push(temp.top());\\n                temp.pop();\\n            }\\n        }\\n        return sem;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2453140,
                "title": "best-python-implementation-top-98-2-easy-to-understand",
                "content": "Check out this Github repository I just found https://github.com/AnasImloul/Leetcode-solutions/.\\nIt is very interesting, and I wanted to share it with you.\\n```\\nclass Solution:\\n    def minNumberOfSemesters(self, n: int, relations: List[List[int]], k: int) -> int:\\n        graph = [0] * n\\n        out_degree = [0] * n\\n        # -1 to fix 1-based indexing offset from prompt.\\n        for pre_req, course in relations:\\n            graph[course-1] += 1 << (pre_req-1)\\n            out_degree[pre_req-1] += 1\\n        # Just converts course to its shifted value\\n        c2shift = [1<<course for course in range(n)]\\n        start = 0\\n        goal = 2**n-1  # will eq course_total once all have been taken.\\n        queue = collections.deque([(start,0)])\\n        seen = [0] * (2 ** n)\\n\\n        # Similar to Bellman-Ford\\n        while queue:\\n            # course_total is state. Each bit representing a taken course.\\n            course_total, steps = queue.popleft()\\n            available = []\\n            for course_num in range(n):\\n                if (course_total & graph[course_num] == graph[course_num]) \\\\\\n                            and (course_total & c2shift[course_num] == 0):\\n                    available.append(course_num)\\n\\n            # pre_req courses can unlock others.\\n            pre_reqs = [c2shift[course_num] for course_num in available if out_degree[course_num]]\\n            leaves = [c2shift[course_num] for course_num in available if out_degree[course_num] == 0] \\n            \\n            # We only include leaf courses when we have extra space\\n            if len(pre_reqs) <= k:\\n                course_total += sum(pre_reqs) + sum(leaves[:k-len(pre_reqs)])\\n                if course_total == goal:\\n                    return steps + 1\\n                if not seen[course_total]:\\n                    queue.append((course_total,steps+1))\\n                    seen[course_total] = 1\\n            else:\\n                # Trying every combination of the pre_reqs.\\n                # comb is required here because we can\\'t simply take them all (len(pre_reqs) > k)\\n                for batch in itertools.combinations(pre_reqs, k):\\n                    diff = sum(batch)\\n                    t = course_total + diff\\n                    if t == goal:\\n                        return steps + 1\\n                    if not seen[t]:\\n                        queue.append((t, steps+1))\\n                        seen[t] = 1![Uploading file...]()\\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minNumberOfSemesters(self, n: int, relations: List[List[int]], k: int) -> int:\\n        graph = [0] * n\\n        out_degree = [0] * n\\n        # -1 to fix 1-based indexing offset from prompt.\\n        for pre_req, course in relations:\\n            graph[course-1] += 1 << (pre_req-1)\\n            out_degree[pre_req-1] += 1\\n        # Just converts course to its shifted value\\n        c2shift = [1<<course for course in range(n)]\\n        start = 0\\n        goal = 2**n-1  # will eq course_total once all have been taken.\\n        queue = collections.deque([(start,0)])\\n        seen = [0] * (2 ** n)\\n\\n        # Similar to Bellman-Ford\\n        while queue:\\n            # course_total is state. Each bit representing a taken course.\\n            course_total, steps = queue.popleft()\\n            available = []\\n            for course_num in range(n):\\n                if (course_total & graph[course_num] == graph[course_num]) \\\\\\n                            and (course_total & c2shift[course_num] == 0):\\n                    available.append(course_num)\\n\\n            # pre_req courses can unlock others.\\n            pre_reqs = [c2shift[course_num] for course_num in available if out_degree[course_num]]\\n            leaves = [c2shift[course_num] for course_num in available if out_degree[course_num] == 0] \\n            \\n            # We only include leaf courses when we have extra space\\n            if len(pre_reqs) <= k:\\n                course_total += sum(pre_reqs) + sum(leaves[:k-len(pre_reqs)])\\n                if course_total == goal:\\n                    return steps + 1\\n                if not seen[course_total]:\\n                    queue.append((course_total,steps+1))\\n                    seen[course_total] = 1\\n            else:\\n                # Trying every combination of the pre_reqs.\\n                # comb is required here because we can\\'t simply take them all (len(pre_reqs) > k)\\n                for batch in itertools.combinations(pre_reqs, k):\\n                    diff = sum(batch)\\n                    t = course_total + diff\\n                    if t == goal:\\n                        return steps + 1\\n                    if not seen[t]:\\n                        queue.append((t, steps+1))\\n                        seen[t] = 1![Uploading file...]()\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2299977,
                "title": "c-dynamic-programing",
                "content": "```\\nclass Solution {\\npublic:\\n    int minNumberOfSemesters(int n, vector<vector<int>>& dep, int k) {\\n        vector<int> pre(n);\\n        \\n        for(int i=0;i<dep.size();i++){\\n            int x=dep[i][0]-1;\\n            int y=dep[i][1]-1;\\n            \\n            pre[y]|=(1<<x);\\n        }\\n        \\n        vector<int> dp(1<<n,n);\\n        \\n        dp[0]=0;\\n        \\n        for(int i=0;i<(1<<n);i++){\\n            int ex=0;\\n            \\n            for(int j=0;j<n;j++){\\n                if((pre[j]&i)==pre[j]){\\n                    ex|=(1<<j);\\n                }\\n            }\\n            \\n            ex&=(~i);\\n            \\n            // enumerate all subset of ex which have size less than k\\n            // https://cp-algorithms.com/algebra/all-submasks.html\\n            for(int s=ex;s;s=(s-1)&ex){\\n                if(__builtin_popcount(s)<=k){\\n                    dp[i|s]=min(dp[i|s],dp[i]+1);\\n                }\\n            }\\n        }\\n        \\n        return dp.back();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfSemesters(int n, vector<vector<int>>& dep, int k) {\\n        vector<int> pre(n);\\n        \\n        for(int i=0;i<dep.size();i++){\\n            int x=dep[i][0]-1;\\n            int y=dep[i][1]-1;\\n            \\n            pre[y]|=(1<<x);\\n        }\\n        \\n        vector<int> dp(1<<n,n);\\n        \\n        dp[0]=0;\\n        \\n        for(int i=0;i<(1<<n);i++){\\n            int ex=0;\\n            \\n            for(int j=0;j<n;j++){\\n                if((pre[j]&i)==pre[j]){\\n                    ex|=(1<<j);\\n                }\\n            }\\n            \\n            ex&=(~i);\\n            \\n            // enumerate all subset of ex which have size less than k\\n            // https://cp-algorithms.com/algebra/all-submasks.html\\n            for(int s=ex;s;s=(s-1)&ex){\\n                if(__builtin_popcount(s)<=k){\\n                    dp[i|s]=min(dp[i|s],dp[i]+1);\\n                }\\n            }\\n        }\\n        \\n        return dp.back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2183290,
                "title": "javascript-no-bitmask",
                "content": "This solution was possible thanks to https://leetcode.com/problems/parallel-courses-ii/discuss/804820/Java-Easy-Recursive-Solution. I used their neat combination helper which generates unique combinations. My version would\\'ve been a lot slower using a backtracking combo generator.\\n\\nThe only way to solve this properly is to check every combination that is possible within the constraints of K. Without K this is just a topological sorting of prerequisites. So in order to solve this fully, we generate all the unique combinations in which we can study up to K courses per semester and then record our minimum time taken to complete all courses.\\n\\nNote that courses that do not unlock other courses can be studied at any time and we can separate them into a free queue. So we\\'re only concerned with courses that unlock other courses and how we can explore each combination of those courses.\\n\\n```\\nvar minNumberOfSemesters = function (n, relations, k) {\\n\\tconst indegrees = new Array(n + 1);\\n\\tconst dependencies = new Map();\\n\\n\\tfor (let i = 1; i <= n; ++i) {\\n\\t\\tdependencies.set(i, new Set());\\n\\t\\tindegrees[i] = 0;\\n\\t}\\n\\n\\tfor (const [from, to] of relations) {\\n\\t\\tdependencies.get(from).add(to);\\n\\t\\tindegrees[to]++;\\n\\t}\\n\\n\\tlet freeCourseQueue = [];\\n\\tlet startQueue = [];\\n\\n\\tfor (let i = 1; i < indegrees.length; ++i) {\\n\\t\\tif (indegrees[i] === 0) {\\n\\t\\t\\tif (dependencies.get(i).size === 0) {\\n\\t\\t\\t\\tfreeCourseQueue.push(i); //queue of items that are free to study at any time due to not unlocking any new dependencies\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tstartQueue.push(i);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfunction generateCombos(queue) {\\n\\t\\tlet combos = [];\\n\\t\\tlet temp = new Array(k);\\n\\n\\t\\tfunction generateUniqueCombinations(start, index) {\\n\\t\\t\\tif (index === k) {\\n\\t\\t\\t\\tcombos.push([...temp]);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (start < queue.length) {\\n\\t\\t\\t\\t\\ttemp[index] = queue[start];\\n\\t\\t\\t\\t\\tgenerateUniqueCombinations(start + 1, index + 1);\\n\\t\\t\\t\\t\\tgenerateUniqueCombinations(start + 1, index);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tgenerateUniqueCombinations(0, 0);\\n\\t\\treturn combos;\\n\\t}\\n\\tlet minFound = Number.MAX_VALUE;\\n\\n\\tfunction findMinSemesterTime(currQueue, currTime, prevCompleted, prevIndegrees) {\\n\\t\\t//need to make a copy of completed/indegrees as each combination will have to have its own record\\n\\t\\tlet currCompleted = new Set(Array.from(prevCompleted));\\n\\t\\tlet currIndegrees = [...prevIndegrees];\\n\\n\\t\\tfor (let i = 0; i < currQueue.length; ++i) {\\n\\t\\t\\tconst node = currQueue[i];\\n\\t\\t\\tif (!currCompleted.has(node)) {\\n\\t\\t\\t\\tcurrCompleted.add(node);\\n\\t\\t\\t\\tfor (const other of dependencies.get(node)) {\\n\\t\\t\\t\\t\\tcurrIndegrees[other]--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t++currTime;\\n\\n\\t\\tif (currCompleted.size === n) {\\n\\t\\t\\tminFound = Math.min(currTime, minFound);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tlet nextFreeCourses = [];\\n\\t\\tlet nextQueue = [];\\n\\t\\tfor (let i = 1; i < currIndegrees.length; ++i) {\\n\\t\\t\\tif (!currCompleted.has(i) && currIndegrees[i] === 0) {\\n\\t\\t\\t\\tif (dependencies.get(i).size === 0) {\\n\\t\\t\\t\\t\\tnextFreeCourses.push(i);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tnextQueue.push(i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (nextQueue.length > k) {\\n\\t\\t\\tconst nextQueueCombos = generateCombos(nextQueue);\\n\\t\\t\\tfor (const queueCombo of nextQueueCombos) {\\n\\t\\t\\t\\tfindMinSemesterTime(queueCombo, currTime, currCompleted, currIndegrees);\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\twhile (nextQueue.length < k && nextFreeCourses.length) {\\n\\t\\t\\t\\tnextQueue.push(nextFreeCourses.pop());\\n\\t\\t\\t}\\n\\t\\t\\tfindMinSemesterTime(nextQueue, currTime, currCompleted, currIndegrees);\\n\\t\\t}\\n\\t}\\n\\n\\tconst startTime = 0;\\n\\tconst startCompleted = new Set();\\n\\tif (startQueue.length > k) {\\n\\t\\tconst nextQueueCombos = generateCombos(startQueue);\\n\\t\\tfor (const queueCombo of nextQueueCombos) {\\n\\t\\t\\tfindMinSemesterTime(queueCombo, startTime, startCompleted, indegrees);\\n\\t\\t}\\n\\t} else {\\n\\t\\twhile (startQueue.length < k && freeCourseQueue.length) {\\n\\t\\t\\tstartQueue.push(freeCourseQueue.pop());\\n\\t\\t}\\n\\t\\tfindMinSemesterTime(startQueue, startTime, startCompleted, indegrees);\\n\\t}\\n\\treturn minFound;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minNumberOfSemesters = function (n, relations, k) {\\n\\tconst indegrees = new Array(n + 1);\\n\\tconst dependencies = new Map();\\n\\n\\tfor (let i = 1; i <= n; ++i) {\\n\\t\\tdependencies.set(i, new Set());\\n\\t\\tindegrees[i] = 0;\\n\\t}\\n\\n\\tfor (const [from, to] of relations) {\\n\\t\\tdependencies.get(from).add(to);\\n\\t\\tindegrees[to]++;\\n\\t}\\n\\n\\tlet freeCourseQueue = [];\\n\\tlet startQueue = [];\\n\\n\\tfor (let i = 1; i < indegrees.length; ++i) {\\n\\t\\tif (indegrees[i] === 0) {\\n\\t\\t\\tif (dependencies.get(i).size === 0) {\\n\\t\\t\\t\\tfreeCourseQueue.push(i); //queue of items that are free to study at any time due to not unlocking any new dependencies\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tstartQueue.push(i);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfunction generateCombos(queue) {\\n\\t\\tlet combos = [];\\n\\t\\tlet temp = new Array(k);\\n\\n\\t\\tfunction generateUniqueCombinations(start, index) {\\n\\t\\t\\tif (index === k) {\\n\\t\\t\\t\\tcombos.push([...temp]);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (start < queue.length) {\\n\\t\\t\\t\\t\\ttemp[index] = queue[start];\\n\\t\\t\\t\\t\\tgenerateUniqueCombinations(start + 1, index + 1);\\n\\t\\t\\t\\t\\tgenerateUniqueCombinations(start + 1, index);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tgenerateUniqueCombinations(0, 0);\\n\\t\\treturn combos;\\n\\t}\\n\\tlet minFound = Number.MAX_VALUE;\\n\\n\\tfunction findMinSemesterTime(currQueue, currTime, prevCompleted, prevIndegrees) {\\n\\t\\t//need to make a copy of completed/indegrees as each combination will have to have its own record\\n\\t\\tlet currCompleted = new Set(Array.from(prevCompleted));\\n\\t\\tlet currIndegrees = [...prevIndegrees];\\n\\n\\t\\tfor (let i = 0; i < currQueue.length; ++i) {\\n\\t\\t\\tconst node = currQueue[i];\\n\\t\\t\\tif (!currCompleted.has(node)) {\\n\\t\\t\\t\\tcurrCompleted.add(node);\\n\\t\\t\\t\\tfor (const other of dependencies.get(node)) {\\n\\t\\t\\t\\t\\tcurrIndegrees[other]--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t++currTime;\\n\\n\\t\\tif (currCompleted.size === n) {\\n\\t\\t\\tminFound = Math.min(currTime, minFound);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tlet nextFreeCourses = [];\\n\\t\\tlet nextQueue = [];\\n\\t\\tfor (let i = 1; i < currIndegrees.length; ++i) {\\n\\t\\t\\tif (!currCompleted.has(i) && currIndegrees[i] === 0) {\\n\\t\\t\\t\\tif (dependencies.get(i).size === 0) {\\n\\t\\t\\t\\t\\tnextFreeCourses.push(i);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tnextQueue.push(i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (nextQueue.length > k) {\\n\\t\\t\\tconst nextQueueCombos = generateCombos(nextQueue);\\n\\t\\t\\tfor (const queueCombo of nextQueueCombos) {\\n\\t\\t\\t\\tfindMinSemesterTime(queueCombo, currTime, currCompleted, currIndegrees);\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\twhile (nextQueue.length < k && nextFreeCourses.length) {\\n\\t\\t\\t\\tnextQueue.push(nextFreeCourses.pop());\\n\\t\\t\\t}\\n\\t\\t\\tfindMinSemesterTime(nextQueue, currTime, currCompleted, currIndegrees);\\n\\t\\t}\\n\\t}\\n\\n\\tconst startTime = 0;\\n\\tconst startCompleted = new Set();\\n\\tif (startQueue.length > k) {\\n\\t\\tconst nextQueueCombos = generateCombos(startQueue);\\n\\t\\tfor (const queueCombo of nextQueueCombos) {\\n\\t\\t\\tfindMinSemesterTime(queueCombo, startTime, startCompleted, indegrees);\\n\\t\\t}\\n\\t} else {\\n\\t\\twhile (startQueue.length < k && freeCourseQueue.length) {\\n\\t\\t\\tstartQueue.push(freeCourseQueue.pop());\\n\\t\\t}\\n\\t\\tfindMinSemesterTime(startQueue, startTime, startCompleted, indegrees);\\n\\t}\\n\\treturn minFound;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2149222,
                "title": "python-bfs-with-bitmask",
                "content": "```\\nfrom itertools import combinations\\nclass Solution:\\n    def minNumberOfSemesters(self, n: int, relations: List[List[int]], k: int) -> int:\\n        pre = [0] * n\\n        GOAL = (1<<n) - 1\\n        for u, v in relations:\\n            u, v = u - 1, v - 1\\n            pre[v] += 1 << u\\n        que = deque([[0,0]]) # (state, minimum number of semesters to reach state)\\n        visited = set()\\n        while que:\\n            [state, step] = que.popleft()\\n            if state in visited: continue\\n            visited.add(state)\\n            if state == GOAL: return step\\n            next_courses_to_study = []\\n            for i in range(n):\\n                if pre[i] & state != pre[i]: continue\\n                if (1<<i) & state: continue\\n                next_courses_to_study.append(i)\\n            if len(next_courses_to_study) <= k:\\n                for course in next_courses_to_study:\\n                    state += 1 << course\\n                que.append([state, step+1])\\n            else:\\n                for seq in list(combinations(next_courses_to_study, k)):\\n                    next_state = state\\n                    for course in seq:\\n                        next_state += 1 << course\\n                    que.append([next_state, step+1])",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Bitmask"
                ],
                "code": "```\\nfrom itertools import combinations\\nclass Solution:\\n    def minNumberOfSemesters(self, n: int, relations: List[List[int]], k: int) -> int:\\n        pre = [0] * n\\n        GOAL = (1<<n) - 1\\n        for u, v in relations:\\n            u, v = u - 1, v - 1\\n            pre[v] += 1 << u\\n        que = deque([[0,0]]) # (state, minimum number of semesters to reach state)\\n        visited = set()\\n        while que:\\n            [state, step] = que.popleft()\\n            if state in visited: continue\\n            visited.add(state)\\n            if state == GOAL: return step\\n            next_courses_to_study = []\\n            for i in range(n):\\n                if pre[i] & state != pre[i]: continue\\n                if (1<<i) & state: continue\\n                next_courses_to_study.append(i)\\n            if len(next_courses_to_study) <= k:\\n                for course in next_courses_to_study:\\n                    state += 1 << course\\n                que.append([state, step+1])\\n            else:\\n                for seq in list(combinations(next_courses_to_study, k)):\\n                    next_state = state\\n                    for course in seq:\\n                        next_state += 1 << course\\n                    que.append([next_state, step+1])",
                "codeTag": "Java"
            },
            {
                "id": 2135394,
                "title": "go-dp",
                "content": "```\\nfunc min(a int, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc dfs(state int, n int, k int, pre [][]int, dp []int) int {\\n    if state == (1 << n) - 1 {\\n        return 0\\n    }\\n    if dp[state] != -1 {\\n        return dp[state]\\n    }\\n    \\n    res := 1000000000\\n    \\n    a := make([]int, 0)\\n    for i := 0; i < n; i++ {\\n        if (state & (1 << i) ) == 0 { //not taken\\n            good := true\\n            for x := 0; x < len(pre[i]); x++ {\\n                if (state & (1 << pre[i][x])) == 0 {\\n                    good = false\\n                }\\n            }\\n            if good {\\n                a = append(a, i)\\n            }\\n        }\\n    }\\n        \\n    size := len(a)\\n    for i := 1; i < (1 << size); i++ {\\n        bitcnt := 0\\n        newtake := 0\\n        for j := 0; j < size; j++ {\\n            if (i & (1 << j)) > 0 {\\n                bitcnt++\\n                newtake |= (1 << a[j])\\n            }\\n        }\\n        \\n        if bitcnt <= k {\\n            res = min(res, 1 + dfs(state | newtake, n, k, pre, dp))\\n        }\\n    }\\n    \\n    dp[state] = res\\n    return dp[state]\\n}\\n\\nfunc minNumberOfSemesters(n int, relations [][]int, k int) int {\\n    pre := make([][]int, n)\\n    for i := 0; i < len(pre); i++ {\\n        pre[i] = make([]int, 0)    \\n    }\\n    \\n    for i := 0; i < len(relations); i++ {\\n        var u, v int = relations[i][0] - 1, relations[i][1] - 1\\n        pre[v] = append(pre[v], u)\\n    }\\n    \\n    dp := make([]int, (1 << n))\\n    for i := 0; i < len(dp); i++ {\\n        dp[i] = -1\\n    }\\n    \\n      \\n    return dfs(0, n, k, pre, dp)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc min(a int, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc dfs(state int, n int, k int, pre [][]int, dp []int) int {\\n    if state == (1 << n) - 1 {\\n        return 0\\n    }\\n    if dp[state] != -1 {\\n        return dp[state]\\n    }\\n    \\n    res := 1000000000\\n    \\n    a := make([]int, 0)\\n    for i := 0; i < n; i++ {\\n        if (state & (1 << i) ) == 0 { //not taken\\n            good := true\\n            for x := 0; x < len(pre[i]); x++ {\\n                if (state & (1 << pre[i][x])) == 0 {\\n                    good = false\\n                }\\n            }\\n            if good {\\n                a = append(a, i)\\n            }\\n        }\\n    }\\n        \\n    size := len(a)\\n    for i := 1; i < (1 << size); i++ {\\n        bitcnt := 0\\n        newtake := 0\\n        for j := 0; j < size; j++ {\\n            if (i & (1 << j)) > 0 {\\n                bitcnt++\\n                newtake |= (1 << a[j])\\n            }\\n        }\\n        \\n        if bitcnt <= k {\\n            res = min(res, 1 + dfs(state | newtake, n, k, pre, dp))\\n        }\\n    }\\n    \\n    dp[state] = res\\n    return dp[state]\\n}\\n\\nfunc minNumberOfSemesters(n int, relations [][]int, k int) int {\\n    pre := make([][]int, n)\\n    for i := 0; i < len(pre); i++ {\\n        pre[i] = make([]int, 0)    \\n    }\\n    \\n    for i := 0; i < len(relations); i++ {\\n        var u, v int = relations[i][0] - 1, relations[i][1] - 1\\n        pre[v] = append(pre[v], u)\\n    }\\n    \\n    dp := make([]int, (1 << n))\\n    for i := 0; i < len(dp); i++ {\\n        dp[i] = -1\\n    }\\n    \\n      \\n    return dfs(0, n, k, pre, dp)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2096001,
                "title": "python3-topological-sorting-69-81-test-cases-passed",
                "content": "The code provided below passes 69 out of 81 test cases. Open to discussions about how to improve the code.\\n\\n```\"\"\"https://leetcode.com/problems/parallel-courses-ii/\"\"\"\\n\"\"\"69 / 81 test cases passed\"\"\"\\nfrom collections import defaultdict\\n\\n\\nclass Solution:\\n    def minNumberOfSemesters(self, n: int, relations: List[List[int]], k: int) -> int:\\n        # construct the graph\\n        graph = defaultdict(list)\\n        indegree_counter = defaultdict(int)\\n        for prev_course, next_course in relations:\\n            graph[prev_course].append(next_course)\\n            indegree_counter[next_course] += 1\\n\\n        max_semesters, visited = 0, set()\\n        courses_with_no_prerequisite = [u for u in range(1, n + 1) if indegree_counter[u] == 0]\\n        # a dictionary that keep track of the number of courses each semester\\n        courses_per_semester = defaultdict(int)\\n\\n        # initialize the queue with courses without any prerequisite, set the semester when such a\\n        # course is taken based on the threshold allowed\\n        q = []\\n        for index, u in enumerate(courses_with_no_prerequisite):\\n            semester_number = index // k + 1\\n            q.append((u, semester_number))\\n            courses_per_semester[semester_number] += 1\\n\\n        while q:\\n            node, num_semesters = q.pop(0)\\n            max_semesters = max(max_semesters, num_semesters)\\n            visited.add(node)\\n            for neighbor in graph[node]:\\n                if neighbor not in visited:\\n                    indegree_counter[neighbor] -= 1\\n                    if indegree_counter[neighbor] == 0:\\n                        new_num_semesters = num_semesters + 1\\n                        # keep updating the semester number until a semester is found which is not \\n                        # completely booked\\n                        while courses_per_semester[new_num_semesters] == k:\\n                            new_num_semesters += 1\\n                        courses_per_semester[new_num_semesters] += 1\\n                        q.append((neighbor, new_num_semesters))\\n\\n        return max_semesters if len(visited) == n else -1```\\n",
                "solutionTags": [
                    "Python3",
                    "Topological Sort"
                ],
                "code": "```\"\"\"https://leetcode.com/problems/parallel-courses-ii/\"\"\"\\n\"\"\"69 / 81 test cases passed\"\"\"\\nfrom collections import defaultdict\\n\\n\\nclass Solution:\\n    def minNumberOfSemesters(self, n: int, relations: List[List[int]], k: int) -> int:\\n        # construct the graph\\n        graph = defaultdict(list)\\n        indegree_counter = defaultdict(int)\\n        for prev_course, next_course in relations:\\n            graph[prev_course].append(next_course)\\n            indegree_counter[next_course] += 1\\n\\n        max_semesters, visited = 0, set()\\n        courses_with_no_prerequisite = [u for u in range(1, n + 1) if indegree_counter[u] == 0]\\n        # a dictionary that keep track of the number of courses each semester\\n        courses_per_semester = defaultdict(int)\\n\\n        # initialize the queue with courses without any prerequisite, set the semester when such a\\n        # course is taken based on the threshold allowed\\n        q = []\\n        for index, u in enumerate(courses_with_no_prerequisite):\\n            semester_number = index // k + 1\\n            q.append((u, semester_number))\\n            courses_per_semester[semester_number] += 1\\n\\n        while q:\\n            node, num_semesters = q.pop(0)\\n            max_semesters = max(max_semesters, num_semesters)\\n            visited.add(node)\\n            for neighbor in graph[node]:\\n                if neighbor not in visited:\\n                    indegree_counter[neighbor] -= 1\\n                    if indegree_counter[neighbor] == 0:\\n                        new_num_semesters = num_semesters + 1\\n                        # keep updating the semester number until a semester is found which is not \\n                        # completely booked\\n                        while courses_per_semester[new_num_semesters] == k:\\n                            new_num_semesters += 1\\n                        courses_per_semester[new_num_semesters] += 1\\n                        q.append((neighbor, new_num_semesters))\\n\\n        return max_semesters if len(visited) == n else -1```",
                "codeTag": "Java"
            },
            {
                "id": 2088769,
                "title": "c-sln-with-bitmasks-and-dp-clean-code",
                "content": "```\\nint minNumberOfSemesters(int n, vector<vector<int>>& relations, int k) {\\n        vector<vector<int>> g(n);\\n        for (const auto& v: relations) {\\n            g[v[1] - 1].push_back(v[0] - 1);\\n        }\\n        unordered_map<int, int> dp;\\n        dp[0] = 0;\\n        \\n        const auto isCourseCompleted = [](int course, int mask) {\\n            return ((1 << course) & mask) == 0;\\n        };\\n        \\n        const auto getPossibleCourses = [&](int mask) {\\n            int possibleCourses = 0;\\n            for (int i = 0; i < n; ++i) {\\n                if (isCourseCompleted(i, mask)) {\\n                    continue;\\n                }\\n                if (all_of(cbegin(g[i]), cend(g[i]), [&](int v) {\\n                    return isCourseCompleted(v, mask);\\n                })) {\\n                    possibleCourses = possibleCourses | (1 << i);\\n                }\\n            }\\n            return possibleCourses;\\n        };\\n        \\n        const auto getAllCombinations = [&](int mask) {\\n            vector<int> courses;\\n            for (int i = 0; i < n; ++i) {\\n                if (!isCourseCompleted(i, mask)) {\\n                    courses.push_back(i);\\n                }\\n            }\\n            const int sz = min<int>(k, size(courses));\\n            int current = 0;\\n            vector<int> ans;\\n            function<void(int, int)> backtrack;\\n            backtrack = [&](int idx, int count) {\\n                if (count == sz) {\\n                    ans.push_back(current);\\n                    return;\\n                }\\n                for (int i = idx; i < size(courses); ++i) {\\n                    current = current | (1 << courses[i]);\\n                    backtrack(i + 1, count + 1);\\n                    current = current ^ (1 << courses[i]);\\n                }\\n            };\\n            backtrack(0, 0);\\n            return ans;\\n        };\\n        \\n        function<int(int)> getOrCompute;\\n        getOrCompute = [&](int mask) {\\n            if (const auto it = dp.find(mask); it != cend(dp)) {\\n                return it->second;\\n            }\\n            int res = numeric_limits<int>::max();\\n            for (const auto possibleCourses: getAllCombinations(getPossibleCourses(mask))) {\\n                res = min(res, getOrCompute(mask ^ possibleCourses));\\n            }\\n            return dp[mask] = 1 + res;\\n        };\\n        return getOrCompute((1 << n) - 1);\\n    }",
                "solutionTags": [],
                "code": "```\\nint minNumberOfSemesters(int n, vector<vector<int>>& relations, int k) {\\n        vector<vector<int>> g(n);\\n        for (const auto& v: relations) {\\n            g[v[1] - 1].push_back(v[0] - 1);\\n        }\\n        unordered_map<int, int> dp;\\n        dp[0] = 0;\\n        \\n        const auto isCourseCompleted = [](int course, int mask) {\\n            return ((1 << course) & mask) == 0;\\n        };\\n        \\n        const auto getPossibleCourses = [&](int mask) {\\n            int possibleCourses = 0;\\n            for (int i = 0; i < n; ++i) {\\n                if (isCourseCompleted(i, mask)) {\\n                    continue;\\n                }\\n                if (all_of(cbegin(g[i]), cend(g[i]), [&](int v) {\\n                    return isCourseCompleted(v, mask);\\n                })) {\\n                    possibleCourses = possibleCourses | (1 << i);\\n                }\\n            }\\n            return possibleCourses;\\n        };\\n        \\n        const auto getAllCombinations = [&](int mask) {\\n            vector<int> courses;\\n            for (int i = 0; i < n; ++i) {\\n                if (!isCourseCompleted(i, mask)) {\\n                    courses.push_back(i);\\n                }\\n            }\\n            const int sz = min<int>(k, size(courses));\\n            int current = 0;\\n            vector<int> ans;\\n            function<void(int, int)> backtrack;\\n            backtrack = [&](int idx, int count) {\\n                if (count == sz) {\\n                    ans.push_back(current);\\n                    return;\\n                }\\n                for (int i = idx; i < size(courses); ++i) {\\n                    current = current | (1 << courses[i]);\\n                    backtrack(i + 1, count + 1);\\n                    current = current ^ (1 << courses[i]);\\n                }\\n            };\\n            backtrack(0, 0);\\n            return ans;\\n        };\\n        \\n        function<int(int)> getOrCompute;\\n        getOrCompute = [&](int mask) {\\n            if (const auto it = dp.find(mask); it != cend(dp)) {\\n                return it->second;\\n            }\\n            int res = numeric_limits<int>::max();\\n            for (const auto possibleCourses: getAllCombinations(getPossibleCourses(mask))) {\\n                res = min(res, getOrCompute(mask ^ possibleCourses));\\n            }\\n            return dp[mask] = 1 + res;\\n        };\\n        return getOrCompute((1 << n) - 1);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2054235,
                "title": "java-submasks-trick",
                "content": "\\nThis is NP-Complete problem. Hence trying all combinations\\n\\n```\\nclass Solution {\\n    public int minNumberOfSemesters(int n, int[][] dependencies, int k) {\\n        int size=(1<<n);\\n        int[] dp=new int[size];\\n        \\n        for(int graph=1;graph<size;graph++)\\n        {\\n            Set<Integer> nodes=new HashSet();\\n            \\n            for(int j=0;(1<<j)<=graph;j++)\\n            {\\n                if((graph&(1<<j))!=0)\\n                {\\n                    nodes.add(j);\\n                }\\n            }\\n            \\n            Set<Integer> opened=new HashSet(nodes);\\n            \\n            for(int[] edge:dependencies)\\n            {\\n                if(nodes.contains(edge[0]-1) && nodes.contains(edge[1]-1))\\n                {\\n                    opened.remove(edge[1]-1);\\n                }\\n            }\\n            \\n            if(opened.size()<=k)\\n            {\\n                int sum=0;\\n                for(int node:opened)\\n                {\\n                    sum=sum|(1<<node);\\n                }\\n                dp[graph]=dp[graph^sum]+1;\\n            } else {\\n                \\n                dp[graph]=Integer.MAX_VALUE;\\n                Set<Integer> sums=new HashSet();\\n                int mask=0;\\n                for(int j:opened)\\n                {\\n                    mask=mask|(1<<j);\\n                }\\n                //generate all submasks\\n                //https://cp-algorithms.com/algebra/all-submasks.html\\n                int submask=mask;\\n                while(submask>0)\\n                {\\n                    submask=(submask-1)&mask;\\n                    if(submask>0)\\n                    {\\n                        int count=Integer.bitCount(submask);\\n                        if(count==k)\\n                           sums.add(submask);\\n                    }\\n                }\\n\\t\\t\\t\\t//get the minimum\\n                for(int sum:sums)\\n                {\\n                    dp[graph]=Math.min(dp[graph], dp[graph^sum]+1);\\n                }\\n            }\\n        }\\n        return dp[size-1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minNumberOfSemesters(int n, int[][] dependencies, int k) {\\n        int size=(1<<n);\\n        int[] dp=new int[size];\\n        \\n        for(int graph=1;graph<size;graph++)\\n        {\\n            Set<Integer> nodes=new HashSet();\\n            \\n            for(int j=0;(1<<j)<=graph;j++)\\n            {\\n                if((graph&(1<<j))!=0)\\n                {\\n                    nodes.add(j);\\n                }\\n            }\\n            \\n            Set<Integer> opened=new HashSet(nodes);\\n            \\n            for(int[] edge:dependencies)\\n            {\\n                if(nodes.contains(edge[0]-1) && nodes.contains(edge[1]-1))\\n                {\\n                    opened.remove(edge[1]-1);\\n                }\\n            }\\n            \\n            if(opened.size()<=k)\\n            {\\n                int sum=0;\\n                for(int node:opened)\\n                {\\n                    sum=sum|(1<<node);\\n                }\\n                dp[graph]=dp[graph^sum]+1;\\n            } else {\\n                \\n                dp[graph]=Integer.MAX_VALUE;\\n                Set<Integer> sums=new HashSet();\\n                int mask=0;\\n                for(int j:opened)\\n                {\\n                    mask=mask|(1<<j);\\n                }\\n                //generate all submasks\\n                //https://cp-algorithms.com/algebra/all-submasks.html\\n                int submask=mask;\\n                while(submask>0)\\n                {\\n                    submask=(submask-1)&mask;\\n                    if(submask>0)\\n                    {\\n                        int count=Integer.bitCount(submask);\\n                        if(count==k)\\n                           sums.add(submask);\\n                    }\\n                }\\n\\t\\t\\t\\t//get the minimum\\n                for(int sum:sums)\\n                {\\n                    dp[graph]=Math.min(dp[graph], dp[graph^sum]+1);\\n                }\\n            }\\n        }\\n        return dp[size-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976610,
                "title": "easy-to-understand-c-very-fast-top-down-bitmask-dp-with-greedy-flavor",
                "content": "# [C++] Very Fast Top-Down bitmask DP with Greedy flavor.\\n* I added lots of comments in the code, so that it\\'ll be easy to understand.\\n* Acknowledgements: this algorithm is not mine. it\\'s adapted from an anonymous solution. \\n* \\n* `done_bitmask` represents the courses that were already done or taken.\\n* because we only try the combinations of available courses, this algo has a flavor of **Greedy** algorithm.\\n* because the top-down search space is much **sparser**, and **easier to prune**, than the bottom-up DP, the former is much faster than the latter.\\n\\n```\\n// very fast bitmask DP (top-down) + Greedy algo, in 20~25 milliseconds, vs the slower one (bottom-up)\\n// which take 1518 milliseconds.\\nclass Solution {\\n    /// \\\\brief Generate all the combinations of size `c`\\n    static inline std::vector<std::pair<std::vector<int>, std::vector<int>>>\\n    GetCombinations(const std::vector<int>& nums, const int c) {\\n        if (c >= static_cast<int>(nums.size())) {\\n            return {{nums, {}}};\\n        }\\n        std::vector<bool> v(nums.size(), false);\\n        // fill with c number of true\\'s at the tail.\\n        std::fill(v.end() - c, v.end(), true);\\n        std::vector<std::pair<std::vector<int>, std::vector<int>>> combinations;\\n        do {\\n            combinations.push_back({{}, {}});\\n            for (size_t i = 0; i < v.size(); ++i) {\\n                if (v[i]) {\\n                    combinations.back().first.push_back(nums[i]);\\n                } else {\\n                    combinations.back().second.push_back(nums[i]);\\n                }\\n            }\\n        } while (std::next_permutation(v.begin(), v.end()));\\n        return combinations;\\n    }\\n    /// \\\\brief top-down DP with memo, and with Greedy flavor because we only consider the available\\n    /// courses.\\n    // the bitmask represents the courses that were already done/taken.\\n    static int GetMinNumberOfSemesters(\\n            const std::vector<std::vector<int>>& g, // graph, Adjacency list\\n            const std::vector<int>& available_courses, // satisfied courses to be taken\\n            const int n,\\n            const int k,\\n            const int done_bitmask, // courses already done/taken. no need to take anymore.\\n            std::vector<int>& parent_counts, // in-degrees\\n            std::unordered_map<int, int>& bitmask_to_result // memo\\n    ) {\\n        if (bitmask_to_result.count(done_bitmask)) { // get from the memo directly\\n            return bitmask_to_result[done_bitmask];\\n        }\\n        if (available_courses.empty()) { // no further course to take.\\n            bitmask_to_result[done_bitmask] = 0;\\n            return 0;\\n        }\\n        int left_count = 0; // courses that are not done yet.\\n        for (int i = 0; i < n; ++i) {\\n            if (!((done_bitmask >> i) & 1)) {\\n                left_count++;\\n            }\\n        }\\n        int result = n;\\n        // try all possible k-combinations of the available/satisfied courses.\\n        for (auto& [courses, left_courses] : GetCombinations(available_courses, k)) {\\n            // we take the `courses` in the current semester, whereas we\\'ll take `left_courses` in\\n            // future semesters.\\n            int cur_bitmask = done_bitmask;\\n            for (const int course : courses) {\\n                cur_bitmask |= (1 << course); // mark these courses as taken\\n                for (const int child_course : g[course]) {\\n                    if (--parent_counts[child_course] == 0) { // set free these child-courses\\n                        // for future semesters.\\n                        // because the graph is a DAG, child_course is guaranteed to be not in\\n                        // `done_bitmask` nor `courses` nor `left_courses`.\\n                        left_courses.push_back(child_course);\\n                    }\\n                }\\n            }\\n            // explore taking the remaining courses in the future semesters.\\n            result = std::min(\\n                    result,\\n                    GetMinNumberOfSemesters(\\n                            g, left_courses, n, k, cur_bitmask, parent_counts, bitmask_to_result)\\n                            + 1);\\n            // restore the states for subsequent searches.\\n            for (const int course : courses) {\\n                for (const int child_course : g[course]) {\\n                    ++parent_counts[child_course];\\n                }\\n            }\\n            // prune the search-space: if already reached the best possible result, stop the search\\n            // right here.\\n            if (result == (left_count - 1) / k + 1) {\\n                break;\\n            }\\n        }\\n        bitmask_to_result[done_bitmask] = result;\\n        return bitmask_to_result[done_bitmask];\\n    }\\n\\npublic:\\n    int minNumberOfSemesters(int n, vector<vector<int>>& relations, int k) {\\n        std::vector<std::vector<int>> g(n, std::vector<int>()); // graph adjacency list rep\\n        // in-degrees, i.e. the counts of parent/prerequisite courses for each course\\n        std::vector<int> parent_counts(n, 0);\\n        for (const std::vector<int>& relation : relations) {\\n            g[relation[0] - 1].push_back(relation[1] - 1); // convert to 0-based course-id\\n            parent_counts[relation[1] - 1]++;\\n        }\\n        std::vector<int> available_courses; // satisfied courses, i.e. without any prerequisite.\\n        for (int i = 0; i < n; ++i) {\\n            if (parent_counts[i] == 0) {\\n                available_courses.push_back(i);\\n            }\\n        }\\n        // bitmask represents the courses that were already done/taken.\\n        std::unordered_map<int, int> bitmask_to_result; // memo\\n        return GetMinNumberOfSemesters(\\n                g, available_courses, n, k, 0, parent_counts, bitmask_to_result);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\n// very fast bitmask DP (top-down) + Greedy algo, in 20~25 milliseconds, vs the slower one (bottom-up)\\n// which take 1518 milliseconds.\\nclass Solution {\\n    /// \\\\brief Generate all the combinations of size `c`\\n    static inline std::vector<std::pair<std::vector<int>, std::vector<int>>>\\n    GetCombinations(const std::vector<int>& nums, const int c) {\\n        if (c >= static_cast<int>(nums.size())) {\\n            return {{nums, {}}};\\n        }\\n        std::vector<bool> v(nums.size(), false);\\n        // fill with c number of true\\'s at the tail.\\n        std::fill(v.end() - c, v.end(), true);\\n        std::vector<std::pair<std::vector<int>, std::vector<int>>> combinations;\\n        do {\\n            combinations.push_back({{}, {}});\\n            for (size_t i = 0; i < v.size(); ++i) {\\n                if (v[i]) {\\n                    combinations.back().first.push_back(nums[i]);\\n                } else {\\n                    combinations.back().second.push_back(nums[i]);\\n                }\\n            }\\n        } while (std::next_permutation(v.begin(), v.end()));\\n        return combinations;\\n    }\\n    /// \\\\brief top-down DP with memo, and with Greedy flavor because we only consider the available\\n    /// courses.\\n    // the bitmask represents the courses that were already done/taken.\\n    static int GetMinNumberOfSemesters(\\n            const std::vector<std::vector<int>>& g, // graph, Adjacency list\\n            const std::vector<int>& available_courses, // satisfied courses to be taken\\n            const int n,\\n            const int k,\\n            const int done_bitmask, // courses already done/taken. no need to take anymore.\\n            std::vector<int>& parent_counts, // in-degrees\\n            std::unordered_map<int, int>& bitmask_to_result // memo\\n    ) {\\n        if (bitmask_to_result.count(done_bitmask)) { // get from the memo directly\\n            return bitmask_to_result[done_bitmask];\\n        }\\n        if (available_courses.empty()) { // no further course to take.\\n            bitmask_to_result[done_bitmask] = 0;\\n            return 0;\\n        }\\n        int left_count = 0; // courses that are not done yet.\\n        for (int i = 0; i < n; ++i) {\\n            if (!((done_bitmask >> i) & 1)) {\\n                left_count++;\\n            }\\n        }\\n        int result = n;\\n        // try all possible k-combinations of the available/satisfied courses.\\n        for (auto& [courses, left_courses] : GetCombinations(available_courses, k)) {\\n            // we take the `courses` in the current semester, whereas we\\'ll take `left_courses` in\\n            // future semesters.\\n            int cur_bitmask = done_bitmask;\\n            for (const int course : courses) {\\n                cur_bitmask |= (1 << course); // mark these courses as taken\\n                for (const int child_course : g[course]) {\\n                    if (--parent_counts[child_course] == 0) { // set free these child-courses\\n                        // for future semesters.\\n                        // because the graph is a DAG, child_course is guaranteed to be not in\\n                        // `done_bitmask` nor `courses` nor `left_courses`.\\n                        left_courses.push_back(child_course);\\n                    }\\n                }\\n            }\\n            // explore taking the remaining courses in the future semesters.\\n            result = std::min(\\n                    result,\\n                    GetMinNumberOfSemesters(\\n                            g, left_courses, n, k, cur_bitmask, parent_counts, bitmask_to_result)\\n                            + 1);\\n            // restore the states for subsequent searches.\\n            for (const int course : courses) {\\n                for (const int child_course : g[course]) {\\n                    ++parent_counts[child_course];\\n                }\\n            }\\n            // prune the search-space: if already reached the best possible result, stop the search\\n            // right here.\\n            if (result == (left_count - 1) / k + 1) {\\n                break;\\n            }\\n        }\\n        bitmask_to_result[done_bitmask] = result;\\n        return bitmask_to_result[done_bitmask];\\n    }\\n\\npublic:\\n    int minNumberOfSemesters(int n, vector<vector<int>>& relations, int k) {\\n        std::vector<std::vector<int>> g(n, std::vector<int>()); // graph adjacency list rep\\n        // in-degrees, i.e. the counts of parent/prerequisite courses for each course\\n        std::vector<int> parent_counts(n, 0);\\n        for (const std::vector<int>& relation : relations) {\\n            g[relation[0] - 1].push_back(relation[1] - 1); // convert to 0-based course-id\\n            parent_counts[relation[1] - 1]++;\\n        }\\n        std::vector<int> available_courses; // satisfied courses, i.e. without any prerequisite.\\n        for (int i = 0; i < n; ++i) {\\n            if (parent_counts[i] == 0) {\\n                available_courses.push_back(i);\\n            }\\n        }\\n        // bitmask represents the courses that were already done/taken.\\n        std::unordered_map<int, int> bitmask_to_result; // memo\\n        return GetMinNumberOfSemesters(\\n                g, available_courses, n, k, 0, parent_counts, bitmask_to_result);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1966518,
                "title": "c-bfs-topological-sort-73-81-testcases-passed",
                "content": "```\\nclass Solution {\\npublic:\\n    int depth(vector<vector<int>> &adj, int start) {\\n        int d = 0;\\n        for (auto &i:adj[start]) d = max(d, depth(adj, i));\\n        return d + 1;\\n    }\\n    int minNumberOfSemesters(int n, vector<vector<int>>& relations, int k) {\\n        vector<vector<int>> adj(n + 1);\\n        vector<int> inDegrees(n + 1, 0);\\n        for(auto &i:relations) {\\n            inDegrees[i[1]] ++;\\n            adj[i[0]].push_back(i[1]);\\n        }\\n        priority_queue<pair<int,int>> pq;\\n        for (int i=1 ; i<=n;i++) {\\n            if (inDegrees[i] == 0) {\\n                pq.push({depth(adj, i), i});\\n            }\\n        }\\n        int sem = 0;\\n        while(!pq.empty()) {\\n            sem++;\\n            int subThisSem = 0;\\n            priority_queue<pair<int,int>> temp;\\n            for (int s = pq.size();s>0;s--) {\\n                auto node = pq.top().second;   pq.pop();\\n                for (auto &j:adj[node]) {\\n                    if (--inDegrees[j] == 0) {\\n                        temp.push({(adj, j), j});\\n                    }\\n                }\\n                if (++subThisSem >= k) break;\\n            }\\n            while(!temp.empty()) {\\n                pq.push(temp.top());\\n                temp.pop();\\n            }\\n        }\\n        return sem;\\n    }\\n};\\n```\\nWritten above code, but don\\'t know why one of testcase failed.\\nFailed testCase\\n12\\n[[1,2],[2,3],[4,5],[5,6],[7,8],[8,9],[10,11],[11,12]]\\n3\\nAccording to me, this should return 6 (which above code actually returns).\\nBut don\\'t know why expected output is 4.\\nIt will be highly appreciated if any of the person reading this post explains why it is 4.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int depth(vector<vector<int>> &adj, int start) {\\n        int d = 0;\\n        for (auto &i:adj[start]) d = max(d, depth(adj, i));\\n        return d + 1;\\n    }\\n    int minNumberOfSemesters(int n, vector<vector<int>>& relations, int k) {\\n        vector<vector<int>> adj(n + 1);\\n        vector<int> inDegrees(n + 1, 0);\\n        for(auto &i:relations) {\\n            inDegrees[i[1]] ++;\\n            adj[i[0]].push_back(i[1]);\\n        }\\n        priority_queue<pair<int,int>> pq;\\n        for (int i=1 ; i<=n;i++) {\\n            if (inDegrees[i] == 0) {\\n                pq.push({depth(adj, i), i});\\n            }\\n        }\\n        int sem = 0;\\n        while(!pq.empty()) {\\n            sem++;\\n            int subThisSem = 0;\\n            priority_queue<pair<int,int>> temp;\\n            for (int s = pq.size();s>0;s--) {\\n                auto node = pq.top().second;   pq.pop();\\n                for (auto &j:adj[node]) {\\n                    if (--inDegrees[j] == 0) {\\n                        temp.push({(adj, j), j});\\n                    }\\n                }\\n                if (++subThisSem >= k) break;\\n            }\\n            while(!temp.empty()) {\\n                pq.push(temp.top());\\n                temp.pop();\\n            }\\n        }\\n        return sem;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1933278,
                "title": "c-dp-topological-sort",
                "content": "Thanks to @rauniyar1401 for pointing out that there are several test cases need to be fixed.\\n\\nI slightly did the modification inspired by the better solution with bitmasks and dynamic programming inspired by @cjchirag7. It is the best to me, so clear and concise, and also gets accepted status. We consider two scenarios. 1.  Take courses with indegree 0  > k  2. takes  courses with indegree 0 < k. \\n\\nScenario 1. Take courses with indegree 0  > k\\nBreaking it down into simpler sub-problems in a recursive manner and take exactly k course\\n\\nScenario 2. Takes  courses with indegree 0 < k\\nit is optimal to take all the course.\\n\\n```\\nint find_min_semester( std::vector< std::vector<int> > relations, std::vector<int> & bitmask, int mask, int k, int n) {\\n    // finish when all courses are taken\\n    if (mask == ((1 << n) - 1)) return 0;\\n\\n    // Memorization of the taken courses\\n    if (bitmask[mask] != -1) return  bitmask[mask];\\n\\n    // Initialize all courses with indegree 0\\n    std::vector<int> indegree(n, 0);\\n\\n    // Update the indegree\\n    for (int i = 0; i < n; ++i) {\\n        // skip the courses have been taken\\n        if (mask & (1 << i)) continue;\\n        for (auto &elem : relations[i]) {\\n            indegree[elem] ++;\\n        }\\n    }\\n\\n    // For a mask of all courses with 0-indegree\\n    int temp = 0;\\n    for (int i = 0; i < n; ++i) {\\n        // iterate through all the courses with zero indegree and have\\'t been taken\\n        if (indegree[i] == 0 && !(mask & (1<<i))) temp = temp | (1<<i);\\n    }\\n\\n    int courses = temp;\\n    // count of courses with 0-indegree\\n    int count = __builtin_popcount(courses);\\n    int semester = INT_MAX;\\n\\n    if (count > k) {\\n        // (Overlapping sub-problem) iterate through all submasks (sub-problem) of temp\\n        while (courses) {\\n            courses = (courses - 1) & temp;\\n            count = __builtin_popcount(courses);\\n            if (count != k) continue;\\n            semester = std::min(semester, 1 + find_min_semester(relations, bitmask, mask|courses, k, n));\\n        }\\n    } else {\\n        semester = std::min(semester, 1 + find_min_semester(relations, bitmask, mask|courses, k, n));\\n    }\\n\\n    return bitmask[mask] = semester;\\n}\\n\\nint minNumberOfSemesters(int n, std::vector< std::vector<int> > & relations, int k) {\\n\\n    if (relations.size() == 0) return n % k == 0 ? n/ k: n/ k + 1;\\n\\n    std::vector< std::vector<int> > adjacent(n);\\n    std::vector<int> bitmask;\\n\\t\\n    // Creating graph\\n    for (auto &course : relations) {\\n        adjacent[course[0] - 1].push_back(course[1] - 1);\\n    }\\n\\n    // initial bitmask that all of courses haven\\'t been taken\\n    bitmask.assign(1<<n, -1);\\n\\t\\n    return find_min_semester(adjacent, bitmask, 0, k, n);\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Topological Sort"
                ],
                "code": "```\\nint find_min_semester( std::vector< std::vector<int> > relations, std::vector<int> & bitmask, int mask, int k, int n) {\\n    // finish when all courses are taken\\n    if (mask == ((1 << n) - 1)) return 0;\\n\\n    // Memorization of the taken courses\\n    if (bitmask[mask] != -1) return  bitmask[mask];\\n\\n    // Initialize all courses with indegree 0\\n    std::vector<int> indegree(n, 0);\\n\\n    // Update the indegree\\n    for (int i = 0; i < n; ++i) {\\n        // skip the courses have been taken\\n        if (mask & (1 << i)) continue;\\n        for (auto &elem : relations[i]) {\\n            indegree[elem] ++;\\n        }\\n    }\\n\\n    // For a mask of all courses with 0-indegree\\n    int temp = 0;\\n    for (int i = 0; i < n; ++i) {\\n        // iterate through all the courses with zero indegree and have\\'t been taken\\n        if (indegree[i] == 0 && !(mask & (1<<i))) temp = temp | (1<<i);\\n    }\\n\\n    int courses = temp;\\n    // count of courses with 0-indegree\\n    int count = __builtin_popcount(courses);\\n    int semester = INT_MAX;\\n\\n    if (count > k) {\\n        // (Overlapping sub-problem) iterate through all submasks (sub-problem) of temp\\n        while (courses) {\\n            courses = (courses - 1) & temp;\\n            count = __builtin_popcount(courses);\\n            if (count != k) continue;\\n            semester = std::min(semester, 1 + find_min_semester(relations, bitmask, mask|courses, k, n));\\n        }\\n    } else {\\n        semester = std::min(semester, 1 + find_min_semester(relations, bitmask, mask|courses, k, n));\\n    }\\n\\n    return bitmask[mask] = semester;\\n}\\n\\nint minNumberOfSemesters(int n, std::vector< std::vector<int> > & relations, int k) {\\n\\n    if (relations.size() == 0) return n % k == 0 ? n/ k: n/ k + 1;\\n\\n    std::vector< std::vector<int> > adjacent(n);\\n    std::vector<int> bitmask;\\n\\t\\n    // Creating graph\\n    for (auto &course : relations) {\\n        adjacent[course[0] - 1].push_back(course[1] - 1);\\n    }\\n\\n    // initial bitmask that all of courses haven\\'t been taken\\n    bitmask.assign(1<<n, -1);\\n\\t\\n    return find_min_semester(adjacent, bitmask, 0, k, n);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1910885,
                "title": "72-81-test-cases-passing",
                "content": "I am trying to come up with a solution preceeding with this implemntation.\\nThe idea is basically on topological sort.\\nThe Queue is sorted acc to adjacenecyList size.\\nI am getting incorrect output for a very few number of testcases.\\nWill appreciate any help on improving the same.\\n\\n\\n\\n\\n```\\nclass Solution {\\n    public int minNumberOfSemesters(int n, int[][] relations, int k) {\\n        int inD[] =new int[n];\\n        HashMap<Integer,List<Integer>> adj = new HashMap<>();\\n        for(int i=0;i<relations.length;i++){\\n            int a = relations[i][0]-1;\\n            int b = relations[i][1]-1;\\n            if(!adj.containsKey(a)) adj.put(a,new ArrayList<Integer>());\\n            adj.get(a).add(b);\\n            inD[b]++;\\n        }\\n        int c = 0;\\n        int minSem = 0;\\n       Queue<Integer> q = new PriorityQueue<>((a,b)->  {\\n       return Integer.compare(adj.containsKey(b) ? adj.get(b).size() : 0,\\n                              adj.containsKey(a) ? adj.get(a).size() : 0);\\n                                                       });\\n        int r =0;\\n        while(r<n){\\n            if(inD[r]==0)q.add(r);\\n            r++;\\n        }\\n        int a =0;\\n        LinkedList<Integer> newQ = new LinkedList<>();\\n        LinkedList<LinkedList<Integer>> qMain = new LinkedList<>();\\n        \\n        while(c!=n){\\n            \\n            while(!q.isEmpty() && a<k){\\n                \\n                int d = q.poll();\\n                a++;\\n                c++;\\n                \\n                if(adj.containsKey(d) ){\\n                    for(int g : adj.remove(d)){\\n                        inD[g]--;\\n                        if(inD[g]==0) newQ.add(g);\\n                    }\\n                }\\n                \\n            }\\n\\n\\t\\tif(!newQ.isEmpty())qMain.add(new LinkedList(newQ));\\n\\t\\tnewQ.clear();\\n\\t\\tif(qMain.peekFirst()!=null) q``.addAll(qMain.pollFirst());\\n\\n\\t\\ta=0;\\n\\t\\tminSem++;\\n\\t}\\n        return minSem;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minNumberOfSemesters(int n, int[][] relations, int k) {\\n        int inD[] =new int[n];\\n        HashMap<Integer,List<Integer>> adj = new HashMap<>();\\n        for(int i=0;i<relations.length;i++){\\n            int a = relations[i][0]-1;\\n            int b = relations[i][1]-1;\\n            if(!adj.containsKey(a)) adj.put(a,new ArrayList<Integer>());\\n            adj.get(a).add(b);\\n            inD[b]++;\\n        }\\n        int c = 0;\\n        int minSem = 0;\\n       Queue<Integer> q = new PriorityQueue<>((a,b)->  {\\n       return Integer.compare(adj.containsKey(b) ? adj.get(b).size() : 0,\\n                              adj.containsKey(a) ? adj.get(a).size() : 0);\\n                                                       });\\n        int r =0;\\n        while(r<n){\\n            if(inD[r]==0)q.add(r);\\n            r++;\\n        }\\n        int a =0;\\n        LinkedList<Integer> newQ = new LinkedList<>();\\n        LinkedList<LinkedList<Integer>> qMain = new LinkedList<>();\\n        \\n        while(c!=n){\\n            \\n            while(!q.isEmpty() && a<k){\\n                \\n                int d = q.poll();\\n                a++;\\n                c++;\\n                \\n                if(adj.containsKey(d) ){\\n                    for(int g : adj.remove(d)){\\n                        inD[g]--;\\n                        if(inD[g]==0) newQ.add(g);\\n                    }\\n                }\\n                \\n            }\\n\\n\\t\\tif(!newQ.isEmpty())qMain.add(new LinkedList(newQ));\\n\\t\\tnewQ.clear();\\n\\t\\tif(qMain.peekFirst()!=null) q``.addAll(qMain.pollFirst());\\n\\n\\t\\ta=0;\\n\\t\\tminSem++;\\n\\t}\\n        return minSem;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1829274,
                "title": "high-level-solution",
                "content": "We can solve this problem is via Topological sort with small changes.Here is the explanation\\nThere are 3 categories of courses.\\na) courses which are independent , that can be taken any time (not part of any relations edge list).\\nb) courses which are pre-requisites to the next level courses.\\nc) the remaining courses which cannot be taken without pre-requisites met,  which have an incoming edge, i.e. with a non-zero indegree.\\n\\nThese category (b) courses have to be finished before we move to category (c) courses. But the category (a) courses can be bundled into any semester, whenever there is room.\\n\\n\\tcompute the indegree of the graph and create an adjacency list\\n\\tqueue up the nodes which have no incoming edges i.e indegree of 0 and are pre-reqs. Category (b) above.\\n\\twhile (queue not empty  or independentCourses)\\n\\t\\tpre-reqs-course-size = queue size\\n\\t\\tsemesters = semesters + (pre-reqs-course-size)/K (As we can only take K courses at a time.)\\n\\t\\t#check if there is any room for any independent courses (room = K - (pre-reqs-course-size%K))\\n\\t\\tupdate the semester count by 1 accordingly PLUS decrement the independentCourse count by room left\\n\\t\\t# above we are bundling the independent courses whenever we find place, as these can be taken any time\\n\\n\\t\\twhile(pre-reqs-course-size) \\n\\t\\t\\tpre-reqs-course-size--;\\n\\t\\t\\tpop course from front of the queue.\\n\\t\\t\\tfor each outging edge of the course in adjacency list\\n\\t\\t\\t\\tdecrement the indegree and add to queue if the indegree becomes zero (pre-reqs have been met)\\n\\n\\nThis is the high level flow which can deliver with O(V+E) time, if we consider V as N then it will be O(N^2).\\n\\t\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\n\\t",
                "solutionTags": [],
                "code": "We can solve this problem is via Topological sort with small changes.Here is the explanation\\nThere are 3 categories of courses.\\na) courses which are independent , that can be taken any time (not part of any relations edge list).\\nb) courses which are pre-requisites to the next level courses.\\nc) the remaining courses which cannot be taken without pre-requisites met,  which have an incoming edge, i.e. with a non-zero indegree.\\n\\nThese category (b) courses have to be finished before we move to category (c) courses. But the category (a) courses can be bundled into any semester, whenever there is room.\\n\\n\\tcompute the indegree of the graph and create an adjacency list\\n\\tqueue up the nodes which have no incoming edges i.e indegree of 0 and are pre-reqs. Category (b) above.\\n\\twhile (queue not empty  or independentCourses)\\n\\t\\tpre-reqs-course-size = queue size\\n\\t\\tsemesters = semesters + (pre-reqs-course-size)/K (As we can only take K courses at a time.)\\n\\t\\t#check if there is any room for any independent courses (room = K - (pre-reqs-course-size%K))\\n\\t\\tupdate the semester count by 1 accordingly PLUS decrement the independentCourse count by room left\\n\\t\\t# above we are bundling the independent courses whenever we find place, as these can be taken any time\\n\\n\\t\\twhile(pre-reqs-course-size) \\n\\t\\t\\tpre-reqs-course-size--;\\n\\t\\t\\tpop course from front of the queue.\\n\\t\\t\\tfor each outging edge of the course in adjacency list\\n\\t\\t\\t\\tdecrement the indegree and add to queue if the indegree becomes zero (pre-reqs have been met)\\n\\n\\nThis is the high level flow which can deliver with O(V+E) time, if we consider V as N then it will be O(N^2).\\n\\t\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1791456,
                "title": "c-textbook-dp-bitmasking-clean-neat-concise-amateur-friendly",
                "content": "```\\n/*\\nMOST IMPORTANT NOTE!!!!\\n\\nObserve that there are 2 cases :\\nLet p = number of nodes with indegree 0 at any stage\\n\\nCase I. p > k\\nIn this case, it is optimal to take a subset of nodes having EXACLTY k nodes.\\n\\nCase II. p < k\\nIn this case, it is optimal to take ALL the p nodes.\\n\\n\\\\\\\\------------------------------------\\nNote: If the i\\'th bit is set in the bitMask, this means that node=i, has already been \\ntaken/done in the previous semester\\n\\nCLAIM: The BitMask completely stores the information of a particular state\\n\\nQ. How does bitMask store information of the indegree vector?\\n\\nA. From the bitMask, we get to know which nodes have already been done, hence\\nin theory we can always calculate the indegree vector by knowing which nodes \\nhave already been done.\\nHow?\\n-for all adj nodes of the done nodes, we reduce the adj node\\'s indegree by 1\\n- in the end, all the done nodes will automaticaly have 0 indegree\\n\\nHENCE: BITMASK COMPLETELY STORES THE INFORMATION OF THE STATE\\nHENCE: WE CAN DO DP + BITMASKING\\n\\\\\\\\------------------------------------\\n\\n*/\\nclass Solution {\\npublic:\\n    int n; int k;\\n    vector<vector<int>> adj;\\n    vector<int> indegree;\\n\\n    int bitMask;\\n    \\n    vector<int> f; // memoizes the bitMask\\n\\n    int backTracking(){\\n        \\n        if(f[bitMask] != -1) return f[bitMask];\\n        \\n        if(bitMask == ((1 << n) - 1))\\n            return  f[bitMask] = 0;\\n        \\n        int minSemRqd = INT_MAX;\\n\\n        vector<int> v;\\n        for(int i=0;i<n;i++){\\n            if((bitMask & (1 << i)) || indegree[i] > 0) continue;\\n            \\n            v.push_back(i);\\n        }\\n\\n        int m = v.size();\\n\\n        for(int take_mask = 1; take_mask < (1 << m); take_mask++){ \\n            \\n            if(m <= k) take_mask = (1 << m) - 1; // THE MOST IMP LINE!!!!! [CASE-2]\\n          \\n            else if(numOnes(take_mask) != k) continue; // THE MOST IMP LINE!!!! [CASE-1]\\n\\n            int takeMask = 0;\\n            for(int i=0;i<m;i++){\\n\\n                if(take_mask & (1 << i)){\\n                  \\n                    int currNode = v[i];\\n\\n                    takeMask = takeMask | (1 << currNode);\\n\\n                    for(auto& adjNode : adj[currNode])\\n                        indegree[adjNode]--;\\n                    \\n                }\\n            }\\n           \\n            bitMask = bitMask | takeMask;\\n\\n            int semRqd = 1 + backTracking();\\n            minSemRqd = min(minSemRqd, semRqd);\\n\\n            bitMask = bitMask ^ takeMask; // BACKTRACKING\\n\\n            //BACKTRACKING\\n            for(int i=0;i<m;i++){\\n\\n                if(take_mask & (1 << i)){\\n                    \\n                    int currNode = v[i];\\n\\n                    for(auto& adjNode : adj[currNode])\\n                        indegree[adjNode]++; \\n                }\\n            }\\n        }\\n        \\n        return f[bitMask] =  minSemRqd;\\n\\n\\n    }\\n\\n    int minNumberOfSemesters(int n, vector<vector<int>>& relations, int k) {\\n            \\n        if(relations.size() == 0) return (n+(k-1))/k;\\n        \\n        this->n = n, this->k = k;\\n        this->adj.resize(n);\\n        this->indegree.resize(n, 0);\\n\\n        for(auto& e : relations){\\n            int u = e[0]-1, v = e[1]-1;\\n            adj[u].push_back(v);\\n            indegree[v]++;\\n        }\\n\\n        this->bitMask = 0;\\n        this->f.resize((1 << n), -1);\\n        return backTracking();\\n    }\\n    \\n    int numOnes(int a){\\n        int cnt = 0;\\n        while(a){\\n            cnt ++;\\n            a = a & (a-1);\\n        }\\n\\n        return cnt;\\n    }\\n    \\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nMOST IMPORTANT NOTE!!!!\\n\\nObserve that there are 2 cases :\\nLet p = number of nodes with indegree 0 at any stage\\n\\nCase I. p > k\\nIn this case, it is optimal to take a subset of nodes having EXACLTY k nodes.\\n\\nCase II. p < k\\nIn this case, it is optimal to take ALL the p nodes.\\n\\n\\\\\\\\------------------------------------\\nNote: If the i\\'th bit is set in the bitMask, this means that node=i, has already been \\ntaken/done in the previous semester\\n\\nCLAIM: The BitMask completely stores the information of a particular state\\n\\nQ. How does bitMask store information of the indegree vector?\\n\\nA. From the bitMask, we get to know which nodes have already been done, hence\\nin theory we can always calculate the indegree vector by knowing which nodes \\nhave already been done.\\nHow?\\n-for all adj nodes of the done nodes, we reduce the adj node\\'s indegree by 1\\n- in the end, all the done nodes will automaticaly have 0 indegree\\n\\nHENCE: BITMASK COMPLETELY STORES THE INFORMATION OF THE STATE\\nHENCE: WE CAN DO DP + BITMASKING\\n\\\\\\\\------------------------------------\\n\\n*/\\nclass Solution {\\npublic:\\n    int n; int k;\\n    vector<vector<int>> adj;\\n    vector<int> indegree;\\n\\n    int bitMask;\\n    \\n    vector<int> f; // memoizes the bitMask\\n\\n    int backTracking(){\\n        \\n        if(f[bitMask] != -1) return f[bitMask];\\n        \\n        if(bitMask == ((1 << n) - 1))\\n            return  f[bitMask] = 0;\\n        \\n        int minSemRqd = INT_MAX;\\n\\n        vector<int> v;\\n        for(int i=0;i<n;i++){\\n            if((bitMask & (1 << i)) || indegree[i] > 0) continue;\\n            \\n            v.push_back(i);\\n        }\\n\\n        int m = v.size();\\n\\n        for(int take_mask = 1; take_mask < (1 << m); take_mask++){ \\n            \\n            if(m <= k) take_mask = (1 << m) - 1; // THE MOST IMP LINE!!!!! [CASE-2]\\n          \\n            else if(numOnes(take_mask) != k) continue; // THE MOST IMP LINE!!!! [CASE-1]\\n\\n            int takeMask = 0;\\n            for(int i=0;i<m;i++){\\n\\n                if(take_mask & (1 << i)){\\n                  \\n                    int currNode = v[i];\\n\\n                    takeMask = takeMask | (1 << currNode);\\n\\n                    for(auto& adjNode : adj[currNode])\\n                        indegree[adjNode]--;\\n                    \\n                }\\n            }\\n           \\n            bitMask = bitMask | takeMask;\\n\\n            int semRqd = 1 + backTracking();\\n            minSemRqd = min(minSemRqd, semRqd);\\n\\n            bitMask = bitMask ^ takeMask; // BACKTRACKING\\n\\n            //BACKTRACKING\\n            for(int i=0;i<m;i++){\\n\\n                if(take_mask & (1 << i)){\\n                    \\n                    int currNode = v[i];\\n\\n                    for(auto& adjNode : adj[currNode])\\n                        indegree[adjNode]++; \\n                }\\n            }\\n        }\\n        \\n        return f[bitMask] =  minSemRqd;\\n\\n\\n    }\\n\\n    int minNumberOfSemesters(int n, vector<vector<int>>& relations, int k) {\\n            \\n        if(relations.size() == 0) return (n+(k-1))/k;\\n        \\n        this->n = n, this->k = k;\\n        this->adj.resize(n);\\n        this->indegree.resize(n, 0);\\n\\n        for(auto& e : relations){\\n            int u = e[0]-1, v = e[1]-1;\\n            adj[u].push_back(v);\\n            indegree[v]++;\\n        }\\n\\n        this->bitMask = 0;\\n        this->f.resize((1 << n), -1);\\n        return backTracking();\\n    }\\n    \\n    int numOnes(int a){\\n        int cnt = 0;\\n        while(a){\\n            cnt ++;\\n            a = a & (a-1);\\n        }\\n\\n        return cnt;\\n    }\\n    \\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1784460,
                "title": "30-line-python-beats-100",
                "content": "brute force search with bit mask\\n```Python\\nclass Solution:\\n    def minNumberOfSemesters(self, n: int, dependencies: List[List[int]], k: int) -> int:\\n        bin_rep = [1 << i for i in range(n)]\\n        has_child = [0] * n\\n        completion = (1 << n) - 1\\n        dep = [0] * n\\n        for i, j in dependencies:\\n            dep[j - 1] |= bin_rep[i - 1]\\n            has_child[i - 1] = 1\\n        seen = set()\\n        pool = [0]\\n        semester = 0\\n        while pool:\\n            pool1 = []\\n            for state in pool:\\n                can_take = [i for i in range(n) if bin_rep[i] & state == 0 and dep[i] & state == dep[i]]\\n                parent_take = [i for i in can_take if has_child[i]]\\n                leaf_take = [i for i in can_take if not has_child[i]]\\n                if len(parent_take) <= k:\\n                    to_takes = [parent_take + leaf_take[:k - len(parent_take)]]\\n                else:\\n                    to_takes = combinations(parent_take, k)\\n                for can_take in to_takes:\\n                    tmp = reduce(lambda x, y: x | y, [bin_rep[i] for i in can_take], state)\\n                    if tmp == completion:\\n                        return semester + 1\\n                    if tmp not in seen:\\n                        seen.add(tmp)\\n                        pool1.append(tmp)\\n            semester += 1\\n            pool = pool1\\n```\\t\\t",
                "solutionTags": [],
                "code": "```Python\\nclass Solution:\\n    def minNumberOfSemesters(self, n: int, dependencies: List[List[int]], k: int) -> int:\\n        bin_rep = [1 << i for i in range(n)]\\n        has_child = [0] * n\\n        completion = (1 << n) - 1\\n        dep = [0] * n\\n        for i, j in dependencies:\\n            dep[j - 1] |= bin_rep[i - 1]\\n            has_child[i - 1] = 1\\n        seen = set()\\n        pool = [0]\\n        semester = 0\\n        while pool:\\n            pool1 = []\\n            for state in pool:\\n                can_take = [i for i in range(n) if bin_rep[i] & state == 0 and dep[i] & state == dep[i]]\\n                parent_take = [i for i in can_take if has_child[i]]\\n                leaf_take = [i for i in can_take if not has_child[i]]\\n                if len(parent_take) <= k:\\n                    to_takes = [parent_take + leaf_take[:k - len(parent_take)]]\\n                else:\\n                    to_takes = combinations(parent_take, k)\\n                for can_take in to_takes:\\n                    tmp = reduce(lambda x, y: x | y, [bin_rep[i] for i in can_take], state)\\n                    if tmp == completion:\\n                        return semester + 1\\n                    if tmp not in seen:\\n                        seen.add(tmp)\\n                        pool1.append(tmp)\\n            semester += 1\\n            pool = pool1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1746342,
                "title": "python-dp",
                "content": "```\\n\\nclass Solution:\\n    def minNumberOfSemesters(self, n: int, relations: List[List[int]], k: int) -> int:\\n        ###Generate bitmask for all courses taken\\n        all_bits = 0        \\n        for i in range(1, n + 1):\\n            all_bits |= 1 << i\\n            \\n        ###Pre-requisite bit mask\\n        al = [0] * (n + 1)        \\n        for u, v in relations:\\n            al[v] |= (1 << u)\\n            \\n        \\n        ###Helper function to check all possible combination to take k course if number of courses can be taken (m) is more than k. This is similar to permutations of  k set bits out of total m number of bits\\n        def compute_next_courses(can_take, count):\\n            courses= [(0, 0)]\\n            \\n            for i, c in enumerate(can_take):\\n                m = len(courses)\\n                for j in range(m):\\n                    courses.append((courses[j][0] | 1 << c, courses[j][1] + 1))\\n                    \\n            return [c for c, freq in courses if freq == count]\\n        \\n        @lru_cache(None)\\n        def dp(bits):\\n            ##all course taken\\n            if bits == all_bits:\\n                return 0\\n            \\n            ###Based on current bitmask (bits), check next courses can be taken by checking prerequisites\\n            can_take = []        \\n            for i in range(1, n + 1):\\n                ###First condition is to check course whether i has been taken. Second condition is to check if all prerequisite for course i is met\\n                if (bits & 1 << i) == 0 and (al[i] & bits) == al[i]:\\n                    can_take.append(i)\\n                   \\n            ###If number of courses can be taken is less than or equal to k, take all these courses\\n            if len(can_take) <= k:\\n                new_bits = bits\\n                for v in can_take:\\n                    new_bits |= (1 << v)\\n                return 1 + dp(new_bits)\\n            \\n            else:\\n                ##Chose k course if number of course can be taken is more than k\\n                next_courses = compute_next_courses(can_take, k) \\n                min_semester = n\\n                for c in next_courses:\\n                    min_semester = min(min_semester, 1 + dp(bits | c))\\n\\n                    \\n                return min_semester\\n            \\n            \\n        return dp(0)\\n    \\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution:\\n    def minNumberOfSemesters(self, n: int, relations: List[List[int]], k: int) -> int:\\n        ###Generate bitmask for all courses taken\\n        all_bits = 0        \\n        for i in range(1, n + 1):\\n            all_bits |= 1 << i\\n            \\n        ###Pre-requisite bit mask\\n        al = [0] * (n + 1)        \\n        for u, v in relations:\\n            al[v] |= (1 << u)\\n            \\n        \\n        ###Helper function to check all possible combination to take k course if number of courses can be taken (m) is more than k. This is similar to permutations of  k set bits out of total m number of bits\\n        def compute_next_courses(can_take, count):\\n            courses= [(0, 0)]\\n            \\n            for i, c in enumerate(can_take):\\n                m = len(courses)\\n                for j in range(m):\\n                    courses.append((courses[j][0] | 1 << c, courses[j][1] + 1))\\n                    \\n            return [c for c, freq in courses if freq == count]\\n        \\n        @lru_cache(None)\\n        def dp(bits):\\n            ##all course taken\\n            if bits == all_bits:\\n                return 0\\n            \\n            ###Based on current bitmask (bits), check next courses can be taken by checking prerequisites\\n            can_take = []        \\n            for i in range(1, n + 1):\\n                ###First condition is to check course whether i has been taken. Second condition is to check if all prerequisite for course i is met\\n                if (bits & 1 << i) == 0 and (al[i] & bits) == al[i]:\\n                    can_take.append(i)\\n                   \\n            ###If number of courses can be taken is less than or equal to k, take all these courses\\n            if len(can_take) <= k:\\n                new_bits = bits\\n                for v in can_take:\\n                    new_bits |= (1 << v)\\n                return 1 + dp(new_bits)\\n            \\n            else:\\n                ##Chose k course if number of course can be taken is more than k\\n                next_courses = compute_next_courses(can_take, k) \\n                min_semester = n\\n                for c in next_courses:\\n                    min_semester = min(min_semester, 1 + dp(bits | c))\\n\\n                    \\n                return min_semester\\n            \\n            \\n        return dp(0)\\n    \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1742949,
                "title": "recursive-memoization-topological-sort-bitmask",
                "content": "Comment below if you need explanation.\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\n\\n\\t\\tvector<int> masks;\\n\\t\\tvoid generate(int i, int n, int mask, int k){\\n\\t\\t\\tif(k==0){\\n\\t\\t\\t\\tmasks.push_back(mask);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tif(i == n) return;\\n\\t\\t\\tif(mask & (1<<i)){\\n\\t\\t\\t\\tint newmask = mask ^ (1<<i);\\n\\t\\t\\t\\tgenerate(i+1,n,newmask,k-1);\\n\\t\\t\\t}\\n\\t\\t\\tgenerate(i+1,n,mask,k);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint dp[(1<<15) + 1];\\n\\t\\tint solve(int n, int k, vector<vector<int>> &adj, vector<int> &in, int mask, int c){\\n\\t\\t\\tif(mask == 0) return 0;\\n\\t\\t\\tif(dp[mask] != -1) return dp[mask];\\n\\t\\t\\tif(c <=k){            \\n\\t\\t\\t\\tint newmask = 0;\\n\\t\\t\\t\\tc = 0;\\n\\t\\t\\t\\tvector<int> tempin = in;\\n\\t\\t\\t\\tfor(int i=0; i<n; i++){\\n\\t\\t\\t\\t\\tif(mask & (1<<i)){\\n\\t\\t\\t\\t\\t\\tfor(auto nbr : adj[i]){\\n\\t\\t\\t\\t\\t\\t\\tin[nbr]--;\\n\\t\\t\\t\\t\\t\\t\\tif(in[nbr] == 0) {\\n\\t\\t\\t\\t\\t\\t\\t\\tnewmask = newmask ^ (1<<nbr);\\n\\t\\t\\t\\t\\t\\t\\t\\tc++;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tint retval =  1 + solve(n,k,adj,in,newmask,c);\\n\\t\\t\\t\\tin = tempin;\\n\\t\\t\\t\\treturn dp[mask] = retval;\\n\\t\\t\\t}\\n\\t\\t\\tgenerate(0,n,mask,k);\\n\\t\\t\\tvector<int> newmasks = masks;\\n\\t\\t\\tmasks.clear();\\n\\t\\t\\tint retval = INT_MAX;\\n\\t\\t\\tc = c - k;\\n\\t\\t\\tfor(int i=0; i<newmasks.size(); i++){\\n\\t\\t\\t\\tint newmask = newmasks[i];\\n\\t\\t\\t\\tvector<int> tempin = in;\\n\\t\\t\\t\\tint tempc = c;\\n\\t\\t\\t\\tfor(int j=0; j<n; j++){\\n\\t\\t\\t\\t\\tif((mask & (1<<j) && !(newmask&(1<<j)))){\\n\\t\\t\\t\\t\\t\\tfor(auto it : adj[j]){\\n\\t\\t\\t\\t\\t\\t\\tin[it]--;\\n\\t\\t\\t\\t\\t\\t\\tif(in[it] == 0){\\n\\t\\t\\t\\t\\t\\t\\t\\tnewmask = newmask ^ (1<<it);\\n\\t\\t\\t\\t\\t\\t\\t\\tc++;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tretval = min(retval,1 + solve(n,k,adj,in,newmask,c));\\n\\t\\t\\t\\tin = tempin;\\n\\t\\t\\t\\tc = tempc;\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[mask] = retval;\\n\\n\\n\\t\\t}\\n\\t\\tint minNumberOfSemesters(int n, vector<vector<int>>& relations, int k) {\\n\\t\\t\\tvector<vector<int>> adj(n);\\n\\t\\t\\tvector<int> in(n,0);\\n\\t\\t\\tmemset(dp,-1,sizeof(dp));\\n\\t\\t\\tfor(int i=0; i<relations.size(); i++){\\n\\t\\t\\t\\tint u = relations[i][0];\\n\\t\\t\\t\\tint v = relations[i][1];\\n\\t\\t\\t\\tu--;\\n\\t\\t\\t\\tv--;\\n\\t\\t\\t\\tin[v]++;\\n\\t\\t\\t\\tadj[u].push_back(v);\\n\\t\\t\\t}\\n\\t\\t\\tint mask = 0;\\n\\t\\t\\tint c = 0;\\n\\t\\t\\tfor(int i=0; i<n; i++){\\n\\t\\t\\t\\tif(in[i] == 0){\\n\\t\\t\\t\\t\\tmask = mask^(1<<i);\\n\\t\\t\\t\\t\\tc++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tmasks.clear();\\n\\t\\t\\tint ans = 0;\\n\\t\\t\\tans = solve(n,k,adj,in,mask, c);\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\n\\n\\t\\tvector<int> masks;\\n\\t\\tvoid generate(int i, int n, int mask, int k){\\n\\t\\t\\tif(k==0){\\n\\t\\t\\t\\tmasks.push_back(mask);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1740215,
                "title": "python-bitmap-dp-with-comments",
                "content": "```\\nclass Solution:\\n    def minNumberOfSemesters(self, n: int, relations: List[List[int]], k: int) -> int:\\n        # pre[course] is the bitmask of prerequisite for course\\n        pre = [0] * n\\n        for u, v in relations:\\n            u, v = u - 1, v - 1\\n            pre[v] |= (1 << u)\\n        \\n        # stores the smallest semester to get to state\\n        memo = [n + 1] * (1 << n)\\n        \\n        # ending state (all course bits are 1)\\n        end_state = (1 << n) - 1        \\n            \\n        queue = collections.deque([(0, 0)]) # state, semester\\n        \\n        while queue:\\n            state, semester = queue.popleft()\\n            \\n            potential_new_courses = []\\n            \\n            # find all the potential new courses given the current state\\n            for course in range(n):\\n                if pre[course] & state != pre[course]:\\n                    # prerequisite not met\\n                    continue\\n                if (1 << course) & state != 0:\\n                    # in this state, course is taken already\\n                    continue\\n                potential_new_courses.append(course)\\n                \\n            if len(potential_new_courses) <= k:\\n                # we can take all the potential new courses, and we will\\n                new_state = state\\n                for course in potential_new_courses:\\n                    new_state |= (1 << course)\\n                \\n                # if all courses are taken in the new state, returns early\\n                if new_state == end_state:\\n                    return semester + 1\\n                \\n                # only update the result if better\\n                if memo[new_state] > semester + 1:\\n                    memo[new_state] = semester + 1\\n                    queue.append((new_state, semester + 1))\\n            \\n            else:\\n                # we can\\'t take all the courses, so we need to make a selection (k courses from potential_new_courses)\\n                for selection in itertools.combinations(potential_new_courses, k):\\n                    new_state = state\\n                    for course in selection:\\n                        new_state |= (1 << course)\\n\\n                    # if all courses are taken in the new state, returns early\\n                    if new_state == end_state:\\n                        return semester + 1\\n\\n                    # only update the result if better\\n                    if memo[new_state] > semester + 1:\\n                        memo[new_state] = semester + 1\\n                        queue.append((new_state, semester + 1))\\n\\t\\treturn -1\\n                    \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def minNumberOfSemesters(self, n: int, relations: List[List[int]], k: int) -> int:\\n        # pre[course] is the bitmask of prerequisite for course\\n        pre = [0] * n\\n        for u, v in relations:\\n            u, v = u - 1, v - 1\\n            pre[v] |= (1 << u)\\n        \\n        # stores the smallest semester to get to state\\n        memo = [n + 1] * (1 << n)\\n        \\n        # ending state (all course bits are 1)\\n        end_state = (1 << n) - 1        \\n            \\n        queue = collections.deque([(0, 0)]) # state, semester\\n        \\n        while queue:\\n            state, semester = queue.popleft()\\n            \\n            potential_new_courses = []\\n            \\n            # find all the potential new courses given the current state\\n            for course in range(n):\\n                if pre[course] & state != pre[course]:\\n                    # prerequisite not met\\n                    continue\\n                if (1 << course) & state != 0:\\n                    # in this state, course is taken already\\n                    continue\\n                potential_new_courses.append(course)\\n                \\n            if len(potential_new_courses) <= k:\\n                # we can take all the potential new courses, and we will\\n                new_state = state\\n                for course in potential_new_courses:\\n                    new_state |= (1 << course)\\n                \\n                # if all courses are taken in the new state, returns early\\n                if new_state == end_state:\\n                    return semester + 1\\n                \\n                # only update the result if better\\n                if memo[new_state] > semester + 1:\\n                    memo[new_state] = semester + 1\\n                    queue.append((new_state, semester + 1))\\n            \\n            else:\\n                # we can\\'t take all the courses, so we need to make a selection (k courses from potential_new_courses)\\n                for selection in itertools.combinations(potential_new_courses, k):\\n                    new_state = state\\n                    for course in selection:\\n                        new_state |= (1 << course)\\n\\n                    # if all courses are taken in the new state, returns early\\n                    if new_state == end_state:\\n                        return semester + 1\\n\\n                    # only update the result if better\\n                    if memo[new_state] > semester + 1:\\n                        memo[new_state] = semester + 1\\n                        queue.append((new_state, semester + 1))\\n\\t\\treturn -1\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1657957,
                "title": "fyi-a-heuristic-method-in-o-n-mlogm",
                "content": "I saw many good dp + binary solutions, such as [this](https://leetcode.com/problems/parallel-courses-ii/discuss/710229/Python-Short-DP-with-Binary-Masks-O(n2*2n)-explained), or [this](https://leetcode.com/problems/parallel-courses-ii/discuss/710229/Python-Short-DP-with-Binary-Masks-O(n2*2n)-explained/830096):\\n\\nas a record keeping:\\n```python\\n    def minNumberOfSemesters(self, n: int, deps: List[List[int]], k: int) -> int:\\n        G = [[] for _ in range(n)]\\n        indeg = [0] * n\\n        for a, b in deps:\\n            indeg[b-1] += 1\\n            G[a-1] += b-1,\\n        \\n        @lru_cache(None)\\n        def dfs(taken, indeg):\\n            \\'\\'\\'\\n            taken: binary form of selected courses: e.g. 1101 means course 1, 2, 3 are taken\\n            \\'\\'\\'\\n            if not taken: \\n                return 0\\n            \\n            sink = []\\n            for i in range(n):\\n                if (taken & (1 << i)) and (indeg[i] == 0):  # sink node\\n                    sink += i,\\n                    \\n            res = math.inf\\n            for c in itertools.combinations(sink, min(k, len(sink))):\\n                t, d = taken, list(indeg)\\n                for a in c:\\n                    t ^= 1 << a\\n                    for b in G[a]:\\n                        d[b] -= 1\\n                res = min(res, 1 + dfs(t, tuple(d)))\\n            return res\\n        \\n        return dfs((1 << n) - 1, tuple(indeg))\\n```\\n\\nI\\'m providing a heuristic approach in O(n+mlogm), n is nodes, m is edges. It passes **70/73** provided test cases. Explaination is in the comments.\\n```python\\n    def minNumberOfSemesters(self, n: int, relations: List[List[int]], k: int) -> int:\\n        # graph is dag\\n        G = [[] for _ in range(n)]\\n        Grev = [[] for _ in range(n)]\\n        indeg = [0] * n\\n        outdeg = [0] * n\\n        for u, v in relations:\\n            G[u-1].append(v-1)\\n            Grev[v-1].append(u-1)\\n            indeg[v-1] += 1\\n            outdeg[u-1] += 1\\n        \\n        depth = [1] * n\\n        q = []\\n        for u, d in enumerate(outdeg):\\n            if not d:\\n                q.append(u)\\n        \\n        # 1st pass, get depth of each node, O(m+n)\\n        while q:  # O(n+m)\\n            u = q.pop()\\n            for v in Grev[u]:\\n                depth[v] = max(depth[v], depth[u] + 1)\\n                outdeg[v] -= 1\\n                if not outdeg[v]:\\n                    q.append(v)\\n                    \\n        # 2nd pass, bfs, allocate resources per step, \\n        # if available resources < available nodes, heuristically prioritize nodes with higher depth,\\n        # O(n+mlogm)\\n        q, nq = [], []\\n        for u, d in enumerate(indeg):\\n            if not d:\\n                heapq.heappush(q, (depth[u], u))\\n        \\n        step = 0\\n        while q:\\n            while len(q) > k:\\n                heapq.heappush(nq, heapq.heappop(q))\\n            n -= len(q)\\n            for d, u in q:\\n                for v in G[u]:\\n                    indeg[v] -= 1\\n                    if not indeg[v]:\\n                        heapq.heappush(nq, (depth[v], v))\\n            \\n            q, nq = nq, []\\n            step += 1\\n        \\n        return step\\n```",
                "solutionTags": [],
                "code": "```python\\n    def minNumberOfSemesters(self, n: int, deps: List[List[int]], k: int) -> int:\\n        G = [[] for _ in range(n)]\\n        indeg = [0] * n\\n        for a, b in deps:\\n            indeg[b-1] += 1\\n            G[a-1] += b-1,\\n        \\n        @lru_cache(None)\\n        def dfs(taken, indeg):\\n            \\'\\'\\'\\n            taken: binary form of selected courses: e.g. 1101 means course 1, 2, 3 are taken\\n            \\'\\'\\'\\n            if not taken: \\n                return 0\\n            \\n            sink = []\\n            for i in range(n):\\n                if (taken & (1 << i)) and (indeg[i] == 0):  # sink node\\n                    sink += i,\\n                    \\n            res = math.inf\\n            for c in itertools.combinations(sink, min(k, len(sink))):\\n                t, d = taken, list(indeg)\\n                for a in c:\\n                    t ^= 1 << a\\n                    for b in G[a]:\\n                        d[b] -= 1\\n                res = min(res, 1 + dfs(t, tuple(d)))\\n            return res\\n        \\n        return dfs((1 << n) - 1, tuple(indeg))\\n```\n```python\\n    def minNumberOfSemesters(self, n: int, relations: List[List[int]], k: int) -> int:\\n        # graph is dag\\n        G = [[] for _ in range(n)]\\n        Grev = [[] for _ in range(n)]\\n        indeg = [0] * n\\n        outdeg = [0] * n\\n        for u, v in relations:\\n            G[u-1].append(v-1)\\n            Grev[v-1].append(u-1)\\n            indeg[v-1] += 1\\n            outdeg[u-1] += 1\\n        \\n        depth = [1] * n\\n        q = []\\n        for u, d in enumerate(outdeg):\\n            if not d:\\n                q.append(u)\\n        \\n        # 1st pass, get depth of each node, O(m+n)\\n        while q:  # O(n+m)\\n            u = q.pop()\\n            for v in Grev[u]:\\n                depth[v] = max(depth[v], depth[u] + 1)\\n                outdeg[v] -= 1\\n                if not outdeg[v]:\\n                    q.append(v)\\n                    \\n        # 2nd pass, bfs, allocate resources per step, \\n        # if available resources < available nodes, heuristically prioritize nodes with higher depth,\\n        # O(n+mlogm)\\n        q, nq = [], []\\n        for u, d in enumerate(indeg):\\n            if not d:\\n                heapq.heappush(q, (depth[u], u))\\n        \\n        step = 0\\n        while q:\\n            while len(q) > k:\\n                heapq.heappush(nq, heapq.heappop(q))\\n            n -= len(q)\\n            for d, u in q:\\n                for v in G[u]:\\n                    indeg[v] -= 1\\n                    if not indeg[v]:\\n                        heapq.heappush(nq, (depth[v], v))\\n            \\n            q, nq = nq, []\\n            step += 1\\n        \\n        return step\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1639771,
                "title": "python-beats-all-greedy-solves-70-73-cases",
                "content": "```python\\nfrom collections import defaultdict, deque\\nfrom heapq import heappush, heappop\\nfrom typing import List\\n\\n\\nclass Solution:\\n    def minNumberOfSemesters(self, n: int, relations: List[List[int]], k: int) -> int:\\n        adjList = defaultdict(set)\\n        ancList = defaultdict(set)\\n        inD = {}\\n        outD = {}\\n        depth = {}\\n\\n        for i in range(1, n + 1):\\n            adjList[i] = adjList[i]\\n            inD[i] = 0\\n            outD[i] = 0\\n\\n        for rel in relations:\\n            a, b = rel[0], rel[1]\\n            adjList[a].add(b)\\n            ancList[b].add(a)\\n            inD[b] = inD.get(b, 0) + 1\\n            outD[a] = outD.get(a, 0) + 1\\n\\n        # find the depth of each node in the graph\\n        # do a DFS from each node, keeping track\\n        # of already calculated depths\\n        def dfs_depth(node):\\n            if node in depth:\\n                return 1 + depth[node]\\n            node_d = 0\\n            for neighbor in adjList[node]:\\n                node_d = max(node_d, dfs_depth(neighbor))\\n            depth[node] = node_d\\n            return 1 + depth[node]\\n\\n        for n, d in inD.items():\\n            dfs_depth(n)\\n\\n        # create a priority queue of unblocked nodes\\n        # prioritized by their depth\\n        h = []\\n        for n, d in inD.items():\\n            if d == 0:\\n                heappush(h, ((-depth[n], -outD[n]), n))\\n\\n        semesters = 0\\n        while h:\\n            semesters += 1\\n            h_next = []\\n            for _ in range(k):\\n                if not h:\\n                    break\\n                (d, od), a = heappop(h)\\n                for b in adjList[a]:\\n                    inD[b] -= 1\\n                    if inD[b] == 0:\\n                        heappush(h_next, ((-depth[b], -outD[n]), b))\\n            while h_next:\\n                heappush(h, heappop(h_next))\\n\\n        return semesters\\n```",
                "solutionTags": [],
                "code": "```python\\nfrom collections import defaultdict, deque\\nfrom heapq import heappush, heappop\\nfrom typing import List\\n\\n\\nclass Solution:\\n    def minNumberOfSemesters(self, n: int, relations: List[List[int]], k: int) -> int:\\n        adjList = defaultdict(set)\\n        ancList = defaultdict(set)\\n        inD = {}\\n        outD = {}\\n        depth = {}\\n\\n        for i in range(1, n + 1):\\n            adjList[i] = adjList[i]\\n            inD[i] = 0\\n            outD[i] = 0\\n\\n        for rel in relations:\\n            a, b = rel[0], rel[1]\\n            adjList[a].add(b)\\n            ancList[b].add(a)\\n            inD[b] = inD.get(b, 0) + 1\\n            outD[a] = outD.get(a, 0) + 1\\n\\n        # find the depth of each node in the graph\\n        # do a DFS from each node, keeping track\\n        # of already calculated depths\\n        def dfs_depth(node):\\n            if node in depth:\\n                return 1 + depth[node]\\n            node_d = 0\\n            for neighbor in adjList[node]:\\n                node_d = max(node_d, dfs_depth(neighbor))\\n            depth[node] = node_d\\n            return 1 + depth[node]\\n\\n        for n, d in inD.items():\\n            dfs_depth(n)\\n\\n        # create a priority queue of unblocked nodes\\n        # prioritized by their depth\\n        h = []\\n        for n, d in inD.items():\\n            if d == 0:\\n                heappush(h, ((-depth[n], -outD[n]), n))\\n\\n        semesters = 0\\n        while h:\\n            semesters += 1\\n            h_next = []\\n            for _ in range(k):\\n                if not h:\\n                    break\\n                (d, od), a = heappop(h)\\n                for b in adjList[a]:\\n                    inD[b] -= 1\\n                    if inD[b] == 0:\\n                        heappush(h_next, ((-depth[b], -outD[n]), b))\\n            while h_next:\\n                heappush(h, heappop(h_next))\\n\\n        return semesters\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1616346,
                "title": "solves-66-73-test-cases-topo-sort-heap-of-outdegrees-for-selection-of-next-candidate",
                "content": "```python\\nclass Solution:\\n    def minNumberOfSemesters(self, n: int, relations: List[List[int]], k: int) -> int:\\n        adjList = defaultdict(set)\\n        inD = {}\\n        outD = {}\\n\\n        for i in range(1, n + 1):\\n            adjList[i] = adjList.get(i, set())\\n            inD[i] = 0\\n            outD[i] = 0\\n\\n        for rel in relations:\\n            a, b = rel[0], rel[1]\\n            adjList[a].add(b)\\n            inD[b] = inD.get(b, 0) + 1\\n            inD[a] = inD.get(a, 0)\\n            outD[a] = outD.get(a, 0) + 1\\n            outD[b] = outD.get(b, 0)\\n\\n        h = []\\n        for n, i in inD.items():\\n            if i == 0:\\n                heappush(h, (-outD[n], n))\\n\\n        def getBestCandidate(h, sem_deps):\\n            h2 = []\\n            aOD, a = None, None\\n            while h:\\n                aOD, a = heappop(h)\\n                if a not in sem_deps:\\n                    break\\n                else:\\n                    h2.append((aOD, a))\\n                    aOD, a = None, None\\n            for bOD, b in h2:\\n                heappush(h, (bOD, b))\\n            return aOD, a\\n\\n        courses = 0\\n        semesters = 0\\n        sem_courses = 0\\n        all_sems = []\\n        sem_deps = set()\\n        sem_set = set()\\n        while h:\\n            aOD, a = getBestCandidate(h, sem_deps)\\n            if not a:\\n                semesters += 1\\n                sem_deps = set()\\n                all_sems.append(tuple(sem_set))\\n                sem_set = set()\\n                sem_courses = 0\\n                aOD, a = heappop(h)\\n\\n            sem_deps.update(adjList[a])\\n            sem_set.add(a)\\n            courses += 1\\n            sem_courses += 1\\n            if sem_courses % k == 0:\\n                semesters += 1\\n                sem_deps = set()\\n                all_sems.append(tuple(sem_set))\\n                sem_set = set()\\n                sem_courses = 0\\n            for b in adjList[a]:\\n                inD[b] -= 1\\n                if inD[b] == 0:\\n                    heappush(h, (-outD[b], b))\\n\\n        if sem_courses > 0:\\n            semesters += math.ceil(sem_courses/k)\\n\\n        return semesters if courses == len(inD) else -1\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minNumberOfSemesters(self, n: int, relations: List[List[int]], k: int) -> int:\\n        adjList = defaultdict(set)\\n        inD = {}\\n        outD = {}\\n\\n        for i in range(1, n + 1):\\n            adjList[i] = adjList.get(i, set())\\n            inD[i] = 0\\n            outD[i] = 0\\n\\n        for rel in relations:\\n            a, b = rel[0], rel[1]\\n            adjList[a].add(b)\\n            inD[b] = inD.get(b, 0) + 1\\n            inD[a] = inD.get(a, 0)\\n            outD[a] = outD.get(a, 0) + 1\\n            outD[b] = outD.get(b, 0)\\n\\n        h = []\\n        for n, i in inD.items():\\n            if i == 0:\\n                heappush(h, (-outD[n], n))\\n\\n        def getBestCandidate(h, sem_deps):\\n            h2 = []\\n            aOD, a = None, None\\n            while h:\\n                aOD, a = heappop(h)\\n                if a not in sem_deps:\\n                    break\\n                else:\\n                    h2.append((aOD, a))\\n                    aOD, a = None, None\\n            for bOD, b in h2:\\n                heappush(h, (bOD, b))\\n            return aOD, a\\n\\n        courses = 0\\n        semesters = 0\\n        sem_courses = 0\\n        all_sems = []\\n        sem_deps = set()\\n        sem_set = set()\\n        while h:\\n            aOD, a = getBestCandidate(h, sem_deps)\\n            if not a:\\n                semesters += 1\\n                sem_deps = set()\\n                all_sems.append(tuple(sem_set))\\n                sem_set = set()\\n                sem_courses = 0\\n                aOD, a = heappop(h)\\n\\n            sem_deps.update(adjList[a])\\n            sem_set.add(a)\\n            courses += 1\\n            sem_courses += 1\\n            if sem_courses % k == 0:\\n                semesters += 1\\n                sem_deps = set()\\n                all_sems.append(tuple(sem_set))\\n                sem_set = set()\\n                sem_courses = 0\\n            for b in adjList[a]:\\n                inD[b] -= 1\\n                if inD[b] == 0:\\n                    heappush(h, (-outD[b], b))\\n\\n        if sem_courses > 0:\\n            semesters += math.ceil(sem_courses/k)\\n\\n        return semesters if courses == len(inD) else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1596678,
                "title": "java-bit-masking-dp-with-full-explanation-and-example",
                "content": "```\\n\\nc = max number of combination\\nworcase, O(C^N)\\n\\n\\npublic int minNumberOfSemesters(int n, int[][] relations, int k) {\\n    \\n        /*            \\n            from 1st example in question                        \\n            e.g: 2-->1 --->4\\n                 3-->1\\n                 \\n            1. make it 0-indexed by minus one\\n            e.g: 1-->0---->3\\n                 2-->0\\n            \\n            2. declare int array of size n\\n               because input range is n is maximum 15\\n               2^15 < Integer.MAX_VALUE\\n               each node can represent in bits reprensation, it\\'s previous course == preRequisite array\\n               \\n                 to take course 0, it has to finish 1 and 2 previous course\\n            e.g: preRequisites[0]=000000000000110                 \\n                 preRequisites[1]=000000000000000\\n                 preRequisites[2]=000000000000000\\n                 preRequisites[3]=000000000000111                             \\n        */\\n        int[] preRequisites = new int[n];\\n        for(int[] r:relations){\\n            int u=r[0]-1;\\n            int v=r[1]-1;\\n            preRequisites[v]|=(1<<u);\\n        }\\n        \\n        /* memoization \\n          e.g: when took all course from above example          \\n                     memo[000000000001111] =3\\n                     \\n         hence  size of  1000000000000000 == 1<<n can contain all interim result as memoization\\n        */\\n        Integer[] memo = new Integer[1<<n];        \\n        return dp(preRequisites,0,k,n,memo);        \\n    }\\n    \\n    private int dp(int[] P,int currState,int k,int n,Integer[] memo){\\n        /*\\n        e.g: from 1st question in example\\n        4 nodes \\n        1111 represents check all 4 course\\n        1111 == (1<<4) -1\\n        */        \\n        int endState=(1<<n)-1;\\n        \\n        //no more course to take\\n        if(currState==endState)\\n            return 0;\\n        \\n        //check from memoized array\\n        if(memo[currState]!=null)\\n            return memo[currState];\\n        \\n        List<Integer> courseList=new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            boolean isPrevCourseAllTaken =  (P[i]&currState) == P[i];\\n            boolean isCurrCourseNotTaken = (currState&(1<<i))==0;\\n            if(isPrevCourseAllTaken && isCurrCourseNotTaken){\\n                courseList.add(i);            \\n            }\\n        }        \\n        \\n        int res=Integer.MAX_VALUE;\\n        if(courseList.size()<=k){\\n            \\n            /**\\n            e.g: from 1st question\\n            if currstate = 0 = 0000            \\n            if newly Added state is course 2 and 3 \\n            course 2->1 , course 3->2            \\n            newlyAddedState =  0110            \\n            so xor bit mask will be 0110 which will represent 2 course taken\\n            **/\\n            \\n            int newlyAddedState=0;\\n            \\n            for(int c:courseList)\\n                newlyAddedState^= (1<<c);\\n            \\n            // 1 semester took to finsih above course\\n            res= dp(P,(currState^newlyAddedState),k,n,memo)+1;\\n        } \\n        //if size exceeds\\n        else{\\n            \\n            /*\\n            e.g: if we have course 1,2,3,4 and k is 3\\n                 1,2,3 (0,1,2)  --> 0111\\n                 1,2,4 (0,1,3) ---> 1011                  \\n                 2,3,4 (1,2,3) ---> 1110\\n                 1,3,4 (0,2,3) ---> 1101\\n                 \\n            */\\n            List<Integer> combinationResult=new ArrayList<>();\\n            combination(courseList,0,0,k,combinationResult);                                                \\n            \\n            for(int kCourseState:combinationResult){\\n                int newState= currState | kCourseState;\\n                if(newState==currState) continue;\\n                \\n                int r=dp(P,newState,k,n,memo);\\n                if(r==Integer.MAX_VALUE) continue;\\n                \\n                res=Math.min(res,r+1);                                \\n            }            \\n            \\n        }\\n        \\n        return memo[currState]=res;\\n    }\\n    \\n    private void combination(List<Integer> list,int idx,int currState,int k,List<Integer> result){\\n        //we already pick k\\n        if(k==0){\\n            result.add(currState);\\n            return;\\n        }\\n                \\n        for(int i=idx;i<=list.size()-k;i++){\\n            int course=(1<<list.get(i));\\n            combination(list,i+1,(currState^course),k-1,result);\\n        }                \\n    }\\n\\t\\n\\t```",
                "solutionTags": [],
                "code": "```\\n\\nc = max number of combination\\nworcase, O(C^N)\\n\\n\\npublic int minNumberOfSemesters(int n, int[][] relations, int k) {\\n    \\n        /*            \\n            from 1st example in question                        \\n            e.g: 2-->1 --->4\\n                 3-->1\\n                 \\n            1. make it 0-indexed by minus one\\n            e.g: 1-->0---->3\\n                 2-->0\\n            \\n            2. declare int array of size n\\n               because input range is n is maximum 15\\n               2^15 < Integer.MAX_VALUE\\n               each node can represent in bits reprensation, it\\'s previous course == preRequisite array\\n               \\n                 to take course 0, it has to finish 1 and 2 previous course\\n            e.g: preRequisites[0]=000000000000110                 \\n                 preRequisites[1]=000000000000000\\n                 preRequisites[2]=000000000000000\\n                 preRequisites[3]=000000000000111                             \\n        */\\n        int[] preRequisites = new int[n];\\n        for(int[] r:relations){\\n            int u=r[0]-1;\\n            int v=r[1]-1;\\n            preRequisites[v]|=(1<<u);\\n        }\\n        \\n        /* memoization \\n          e.g: when took all course from above example          \\n                     memo[000000000001111] =3\\n                     \\n         hence  size of  1000000000000000 == 1<<n can contain all interim result as memoization\\n        */\\n        Integer[] memo = new Integer[1<<n];        \\n        return dp(preRequisites,0,k,n,memo);        \\n    }\\n    \\n    private int dp(int[] P,int currState,int k,int n,Integer[] memo){\\n        /*\\n        e.g: from 1st question in example\\n        4 nodes \\n        1111 represents check all 4 course\\n        1111 == (1<<4) -1\\n        */        \\n        int endState=(1<<n)-1;\\n        \\n        //no more course to take\\n        if(currState==endState)\\n            return 0;\\n        \\n        //check from memoized array\\n        if(memo[currState]!=null)\\n            return memo[currState];\\n        \\n        List<Integer> courseList=new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            boolean isPrevCourseAllTaken =  (P[i]&currState) == P[i];\\n            boolean isCurrCourseNotTaken = (currState&(1<<i))==0;\\n            if(isPrevCourseAllTaken && isCurrCourseNotTaken){\\n                courseList.add(i);            \\n            }\\n        }        \\n        \\n        int res=Integer.MAX_VALUE;\\n        if(courseList.size()<=k){\\n            \\n            /**\\n            e.g: from 1st question\\n            if currstate = 0 = 0000            \\n            if newly Added state is course 2 and 3 \\n            course 2->1 , course 3->2            \\n            newlyAddedState =  0110            \\n            so xor bit mask will be 0110 which will represent 2 course taken\\n            **/\\n            \\n            int newlyAddedState=0;\\n            \\n            for(int c:courseList)\\n                newlyAddedState^= (1<<c);\\n            \\n            // 1 semester took to finsih above course\\n            res= dp(P,(currState^newlyAddedState),k,n,memo)+1;\\n        } \\n        //if size exceeds\\n        else{\\n            \\n            /*\\n            e.g: if we have course 1,2,3,4 and k is 3\\n                 1,2,3 (0,1,2)  --> 0111\\n                 1,2,4 (0,1,3) ---> 1011                  \\n                 2,3,4 (1,2,3) ---> 1110\\n                 1,3,4 (0,2,3) ---> 1101\\n                 \\n            */\\n            List<Integer> combinationResult=new ArrayList<>();\\n            combination(courseList,0,0,k,combinationResult);                                                \\n            \\n            for(int kCourseState:combinationResult){\\n                int newState= currState | kCourseState;\\n                if(newState==currState) continue;\\n                \\n                int r=dp(P,newState,k,n,memo);\\n                if(r==Integer.MAX_VALUE) continue;\\n                \\n                res=Math.min(res,r+1);                                \\n            }            \\n            \\n        }\\n        \\n        return memo[currState]=res;\\n    }\\n    \\n    private void combination(List<Integer> list,int idx,int currState,int k,List<Integer> result){\\n        //we already pick k\\n        if(k==0){\\n            result.add(currState);\\n            return;\\n        }\\n                \\n        for(int i=idx;i<=list.size()-k;i++){\\n            int course=(1<<list.get(i));\\n            combination(list,i+1,(currState^course),k-1,result);\\n        }                \\n    }\\n\\t\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1590882,
                "title": "c-topological-sort-dp-top-down-approach-commented",
                "content": "\\t\\n\\tclass Solution {\\n    private:\\n        unordered_map <int, int> memo;\\n        void getCombinations(int i, int index, int k, vector <int> &combination, vector <int> &available, vector <vector <int>> &combinations) {\\n            if(index == k) {\\n                combinations.push_back(combination);\\n                return ;\\n            }\\n            if(i == available.size())\\n                return ;\\n            else {\\n                combination[index] = available[i];\\n                getCombinations(i + 1, index + 1, k, combination, available, combinations);\\n\\n                getCombinations(i + 1,index,  k, combination, available, combinations);\\n            }\\n\\n        }\\n        int dp(int bitmask, int takenCourses, int k, int totalCourses, vector < int > &inDegree, vector <vector <int>> &graph) {\\n            // if all courses are taken\\n            if(takenCourses == totalCourses) {\\n                return 0;\\n            }\\n\\n            // look for cache\\n            if(memo.count(bitmask) != 0)\\n                return memo[bitmask];\\n            \\n            // get courses which are not taken yet, and have 0 inDegree\\n            vector <int> availableCourses;\\n            for(int i = 0; i < totalCourses; i++)\\n                if(inDegree[i] == 0 && (bitmask & (1 << i)) == 0)\\n                    availableCourses.push_back(i);\\n\\n            int res = INT_MAX / 2;\\n            vector  <vector <int>> combinations;\\n            \\n            // if available courses are less than or equal to k,  then we must take them all\\n            if(availableCourses.size() <= k) {\\n                combinations.push_back(availableCourses);\\n            }\\n            // if they are more than k available courses, then we will get all combinations of k from available courses\\n            else {\\n                vector <int> combination(k, -1);\\n                getCombinations(0, 0, k, combination, availableCourses, combinations);\\n            }\\n\\n            // for every combination\\n            for(auto combination : combinations) {\\n                // save bitmask in temporary variable\\n                int temp = bitmask;\\n\\n                for(auto course : combination) {\\n                    // take selected courses\\n                    bitmask |= (1 << course);\\n                    // decrease their neighbour indegrees\\n                    for(auto nextCourse : graph[course]) {\\n                        inDegree[nextCourse]--;\\n                    }                            \\n                }\\n\\n                //backtrack\\n                res = min(res, dp(bitmask, takenCourses + combination.size(), k, totalCourses, inDegree, graph) + 1);\\n\\n                // restore state\\n                bitmask = temp;\\n                for(auto course : combination) {\\n                    for(auto nextCourse : graph[course]) {\\n                        inDegree[nextCourse]++;\\n                    }                            \\n                }\\n            }\\n            // save result for current state in cache\\n            memo[bitmask] = res;\\n            return res;\\n        }\\n\\tpublic:\\n\\t\\tint minNumberOfSemesters(int n, vector<vector<int>>& relations, int k) {\\n\\t\\t\\tvector < int > inDegree(n, 0);\\n\\t\\t\\tvector < vector < int > > graph(n);\\n\\t\\t\\t// calculate indegrees\\n\\t\\t\\tfor(auto course : relations) {\\n\\t\\t\\t\\tgraph[course[0] - 1].push_back(course[1] - 1);\\n\\t\\t\\t\\tinDegree[course[1] - 1]++;\\n\\t\\t\\t}\\n\\t\\t\\treturn dp(0, 0, k, n, inDegree, graph);\\n\\t\\t}\\n\\t};\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    private:\\n        unordered_map <int, int> memo;\\n        void getCombinations(int i, int index, int k, vector <int> &combination, vector <int> &available, vector <vector <int>> &combinations) {\\n            if(index == k) {\\n                combinations.push_back(combination);\\n                return ;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1584904,
                "title": "javascript-bitmask-dp-176ms-100",
                "content": "```\\nconst initializeGraph = (n) => { let G = []; for (let i = 0; i < n; i++) { G.push([]); } return G; };\\nconst packDG = (G, Edges) => { for (const [u, v] of Edges) { G[u-1].push(v-1); } }; // package/generate directed graph\\nconst bitCount = (n) => { n = n - ((n >> 1) & 0x55555555); n = (n & 0x33333333) + ((n >> 2) & 0x33333333); return ((n + (n >> 4) & 0xF0F0F0F) * 0x1010101) >> 24; };\\n\\nconst MAX = Number.MAX_SAFE_INTEGER;\\nconst minNumberOfSemesters = (n, relations, k) => {\\n    let g = initializeGraph(n);\\n    packDG(g, relations);\\n    let dp = Array(1 << n).fill(0);\\n    for (let mask = 0; mask < 1 << n; mask++) dp[mask] = MAX; // set mask to max for getting min\\n    dp[0] = 0;\\n    for (let mask = 0; mask < 1 << n; mask++) {\\n        if (dp[mask] == MAX) continue;\\n        let can = 0;\\n        for (let i = 0; i < n; i++) {\\n            if (mask & (1 << i)) continue;\\n\\t\\t\\t// bit of 0\\'s\\n            let set1s = false;\\n            for (const child of g[i]) {\\n                if (mask & (1 << child)) continue; // bit of 1\\'s skip\\n                set1s = true; // bit of 0\\'s, need to set\\n                break;\\n            }\\n            if (!set1s) can |= 1 << i; // set bit from 0 to 1\\n        }\\n        for (let semester = can; semester; semester = (semester -1) & can) {\\n            if (bitCount(semester) > k) continue;\\n            dp[mask | semester] = Math.min(dp[mask | semester], dp[mask] + 1);\\n        }\\n    }\\n    return dp[(1 << n) - 1];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nconst initializeGraph = (n) => { let G = []; for (let i = 0; i < n; i++) { G.push([]); } return G; };\\nconst packDG = (G, Edges) => { for (const [u, v] of Edges) { G[u-1].push(v-1); } }; // package/generate directed graph\\nconst bitCount = (n) => { n = n - ((n >> 1) & 0x55555555); n = (n & 0x33333333) + ((n >> 2) & 0x33333333); return ((n + (n >> 4) & 0xF0F0F0F) * 0x1010101) >> 24; };\\n\\nconst MAX = Number.MAX_SAFE_INTEGER;\\nconst minNumberOfSemesters = (n, relations, k) => {\\n    let g = initializeGraph(n);\\n    packDG(g, relations);\\n    let dp = Array(1 << n).fill(0);\\n    for (let mask = 0; mask < 1 << n; mask++) dp[mask] = MAX; // set mask to max for getting min\\n    dp[0] = 0;\\n    for (let mask = 0; mask < 1 << n; mask++) {\\n        if (dp[mask] == MAX) continue;\\n        let can = 0;\\n        for (let i = 0; i < n; i++) {\\n            if (mask & (1 << i)) continue;\\n\\t\\t\\t// bit of 0\\'s\\n            let set1s = false;\\n            for (const child of g[i]) {\\n                if (mask & (1 << child)) continue; // bit of 1\\'s skip\\n                set1s = true; // bit of 0\\'s, need to set\\n                break;\\n            }\\n            if (!set1s) can |= 1 << i; // set bit from 0 to 1\\n        }\\n        for (let semester = can; semester; semester = (semester -1) & can) {\\n            if (bitCount(semester) > k) continue;\\n            dp[mask | semester] = Math.min(dp[mask | semester], dp[mask] + 1);\\n        }\\n    }\\n    return dp[(1 << n) - 1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1538475,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\n    int preq[15];\\n    int N, K;\\n    int dp[1<<15];\\n\\n    int getMin(int vis) {\\n        if(vis == (1<<N) - 1)\\n            return 0;\\n        if (dp[vis] != -1)\\n            return dp[vis];\\n        int cand = 0;\\n        for(int c = 0; c < N; ++c)\\n            if ((vis&(1<<c)) == 0 && (preq[c]&vis)==preq[c])\\n                cand |= (1<<c);\\n        int ans = 15;\\n        for (int submask = cand; submask > 0; submask = (submask-1)&cand) \\n            if (__builtin_popcount(submask) <= K) \\n                ans = min(ans, getMin(vis|submask) + 1);\\n        return dp[vis] = ans;\\n    }\\n\\npublic:\\n    int minNumberOfSemesters(int n, vector<vector<int>>& dependencies, int k) {\\n        memset(dp,-1,sizeof(dp));\\n        N = n, K = k;\\n        for(auto& e : dependencies)\\n            preq[e[1]-1] |= (1<<(e[0]-1));\\n        return getMin(0);\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int preq[15];\\n    int N, K;\\n    int dp[1<<15];\\n\\n    int getMin(int vis) {\\n        if(vis == (1<<N) - 1)\\n            return 0;\\n        if (dp[vis] != -1)\\n            return dp[vis];\\n        int cand = 0;\\n        for(int c = 0; c < N; ++c)\\n            if ((vis&(1<<c)) == 0 && (preq[c]&vis)==preq[c])\\n                cand |= (1<<c);\\n        int ans = 15;\\n        for (int submask = cand; submask > 0; submask = (submask-1)&cand) \\n            if (__builtin_popcount(submask) <= K) \\n                ans = min(ans, getMin(vis|submask) + 1);\\n        return dp[vis] = ans;\\n    }\\n\\npublic:\\n    int minNumberOfSemesters(int n, vector<vector<int>>& dependencies, int k) {\\n        memset(dp,-1,sizeof(dp));\\n        N = n, K = k;\\n        for(auto& e : dependencies)\\n            preq[e[1]-1] |= (1<<(e[0]-1));\\n        return getMin(0);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1535724,
                "title": "can-someone-explain-this-test-case",
                "content": "12\\n[[11,10],[6,3],[2,5],[9,2],[4,12],[8,7],[9,5],[6,2],[7,2],[7,4],[9,3],[11,1],[4,3]]\\n3\\n\\nMy answer: 5\\nCorrect answer: 4\\n\\nI can\\'t figure out how you can do it in four semesters.\\n\\nHere is my run:\\nSemester 0\\nWe had already taken set()\\nAnd we can take {8, 9, 11, 6}\\n\\nSemester 1\\nWe had already taken {8, 9, 6}\\nAnd we can take {7, 11}\\n\\nSemester 2\\nWe had already taken {6, 7, 8, 9, 11}\\nAnd we can take {1, 2, 4, 10}\\n\\nSemester 3\\nWe had already taken {2, 4, 6, 7, 8, 9, 10, 11}\\nAnd we can take {1, 3, 5, 12}\\n\\nSemester 4\\nWe had already taken {1, 2, 4, 5, 6, 7, 8, 9, 10, 11, 12}\\nAnd we can take {3}\\n\\n\\nAnd here is my code, which prioritizes the available classes with bigger \"chain\" of classes that could be taken after them.\\n```\\nclass HeapTuple: #max\\n    def __init__(self):\\n        self.heap = []\\n        \\n        self.track = {} #tracking the first index\\n        \\n        \\n    def swap(self, a, i1, i2):\\n        tmp = a[i2]\\n        a[i2] = a[i1]\\n        a[i1] = tmp\\n    \\n    def swapTrack(self, a, b): #we are tracking the location of the second element\\n        tmp = self.track[a[1]]\\n        self.track[a[1]] = self.track[b[1]]\\n        self.track[b[1]] = tmp\\n    \\n    def top(self):\\n        return self.heap[0]\\n\\n    #bubble up for insert\\n    def insert(self, value):\\n        a = self.heap\\n        #leftmost space\\n        a.append(value)\\n        \\n        on = len(a) -1\\n        self.track[value[1]] = on\\n        \\n        # if value== 0.5: print(a)\\n        \\n        while True:\\n            index = (on-1)//2 #its parent\\n            if index < 0:\\n                break\\n\\n            \\n            if a[index][0] < a[on][0]: #max heap\\n                #update tracking\\n                self.swapTrack(a[index], a[on])\\n                \\n                self.swap(a, index, on)\\n                on = index\\n                \\n\\n                \\n            else:\\n                break\\n    \\n    \\n    #Are we supposed to bubble up for min heap\\n    \\n    \\n    #bubble down for remove\\n    def remove(self, i):\\n        ret = self.heap[0]\\n        \\n        a = self.heap\\n        self.swapTrack(a[i], a[len(a) - 1])\\n        self.swap(a, i, len(a) - 1)\\n        del a[-1]\\n        \\n        while True:\\n            left = i *2+1 #its left child\\n            right = i *2+2 #its right child\\n            if 0 <= left < len(a) and 0 <= right < len(a) and a[i][0] < a[left][0] and a[i][0] < a[right][0]:\\n                if a[left][0] < a[right][0]: #take bigger between the two for max\\n                    self.swapTrack(a[i], a[right])\\n                    self.swap(a, right, i)\\n                    i = right\\n                else:\\n                    self.swapTrack(a[left], a[i])\\n                    self.swap(a, left, i)\\n                    i = left\\n            elif 0 <= left < len(a) and a[i][0] < a[left][0]:\\n                self.swapTrack(a[left], a[i])\\n                self.swap(a, left, i)\\n                i = left\\n            elif 0 <= right < len(a) and a[i][0] < a[right][0]:\\n                self.swapTrack(a[i], a[right])\\n                self.swap(a, right, i)\\n                i = right\\n            else: #in perfect position\\n                break\\n        \\n        return ret\\n\\n\\n\\n\\n\\n\\nclass Solution:\\n    def minNumberOfSemesters(self, n: int, edges: List[List[int]], k: int) -> int:\\n        graph = collections.defaultdict(set)\\n        \\n        prereq = collections.defaultdict(set)\\n        for a, b in edges:\\n            graph[a].add(b) #a graph\\n            prereq[b].add(a)\\n        \\n        cantake = set() #courses that\\'s open for the taking.\\n        for i in range(1, n+1):\\n            if i not in prereq:\\n                cantake.add(i)\\n        \\n        #notice! When you take one course in the semester, a->b->c, it takes at least 3 semester\\n        #you can\\'t take a course and its postrequisite at the same time!\\n        \\n        \"\"\"\\n        take the ones with the deepest depth first?\\n        \\n        Rescan entire graph every time. We choose to deal with nodes that have the deepest depth (or depth of tree below them, or height in avl) first.\\n        \\n        If: There are two ways to reach the same node, we choose the more lengthier way --- because you have to take all prereqs first, not just the easier/shallower ones.\\n        \\n        5\\n[[2,1],[3,1],[1,4], [5, 4]]\\n2\\n        \\n        No time complexity requirements\\n        \"\"\"\\n        #graph is how you navigate the tree\\n        #prereq is prereq for every course\\n        \\n        self.h = HeapTuple() #available classes to take in terms of depth\\n        #[maxmimum depth of tree below it, node name]\\n        \\n        \\n        def dfs(on): #find the maximum depth of current node\\n            # print(on)\\n            curr = 1\\n            \\n            maxbelow = 0 #maximum height tree below\\n            \\n            for e in graph[on]:\\n                maxbelow = max(maxbelow, dfs(e))\\n            \\n            \\n            return curr + maxbelow\\n        \\n        # print(dfs(2))\\n        \\n        done = set()\\n        \\n        c = 0\\n        while True:\\n            #we had taken all the classes\\n            if len(cantake) == 0: break\\n            \\n            print(\"Semester\", c)\\n            print(\"We had already taken\", done)\\n            print(\"And we can take\", cantake)\\n            \\n            #do prescan EVERYTIME for which ones got most depth --- those need to be dealt with first\\n            self.h.heap = []\\n            self.h.track = {}\\n            \\n            \\n            \\n            #for all undealt with nodes that have no children:\\n            for on in cantake:\\n                depth = dfs(on) #maxdepth for on\\n                \\n\\n                \\n                heap = self.h.heap\\n                tracker = self.h.track\\n                \\n                #if this one is deeper than something we already got, then deal with that.\\n                if on in tracker:\\n                    #check if this one is deeper, and then\\n                    inloc = tracker[on] #already in location\\n                    inval = heap[inloc][0]\\n\\n                    if depth > inval: \\n                        self.h.remove(inloc)\\n                        self.h.insert([depth, on])\\n            \\n                else: #new thing. Just add in its depth\\n                    self.h.insert([depth, on])\\n            \\n            print(heap)\\n            \\n            #Now choose what we\\'re dealing with\\n            for i in range(k):\\n                if self.h.heap == []: break\\n                \\n                removed = self.h.remove(0)[1] #[depth, actual index]\\n                done.add(removed)\\n                \\n                cantake.remove(removed)\\n                \\n                for e in graph[removed]:\\n                    prereq[e].remove(removed) #its succeeding classes have one less children\\n                    #and it they now have no children, we can add that to can take\\n                    if len(prereq[e]) == 0:\\n                        cantake.add(e)\\n            \\n\\n            \\n            \"\"\"\\n            8\\n[[2,1],[3,1],[4,1],[1,5], [5, 6], [6, 7], [5, 8]]\\n2\\n            \\n            \"\"\"\\n\\n\\n            c+=1\\n        \\n        \\n        \\n        return c\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass HeapTuple: #max\\n    def __init__(self):\\n        self.heap = []\\n        \\n        self.track = {} #tracking the first index\\n        \\n        \\n    def swap(self, a, i1, i2):\\n        tmp = a[i2]\\n        a[i2] = a[i1]\\n        a[i1] = tmp\\n    \\n    def swapTrack(self, a, b): #we are tracking the location of the second element\\n        tmp = self.track[a[1]]\\n        self.track[a[1]] = self.track[b[1]]\\n        self.track[b[1]] = tmp\\n    \\n    def top(self):\\n        return self.heap[0]\\n\\n    #bubble up for insert\\n    def insert(self, value):\\n        a = self.heap\\n        #leftmost space\\n        a.append(value)\\n        \\n        on = len(a) -1\\n        self.track[value[1]] = on\\n        \\n        # if value== 0.5: print(a)\\n        \\n        while True:\\n            index = (on-1)//2 #its parent\\n            if index < 0:\\n                break\\n\\n            \\n            if a[index][0] < a[on][0]: #max heap\\n                #update tracking\\n                self.swapTrack(a[index], a[on])\\n                \\n                self.swap(a, index, on)\\n                on = index\\n                \\n\\n                \\n            else:\\n                break\\n    \\n    \\n    #Are we supposed to bubble up for min heap\\n    \\n    \\n    #bubble down for remove\\n    def remove(self, i):\\n        ret = self.heap[0]\\n        \\n        a = self.heap\\n        self.swapTrack(a[i], a[len(a) - 1])\\n        self.swap(a, i, len(a) - 1)\\n        del a[-1]\\n        \\n        while True:\\n            left = i *2+1 #its left child\\n            right = i *2+2 #its right child\\n            if 0 <= left < len(a) and 0 <= right < len(a) and a[i][0] < a[left][0] and a[i][0] < a[right][0]:\\n                if a[left][0] < a[right][0]: #take bigger between the two for max\\n                    self.swapTrack(a[i], a[right])\\n                    self.swap(a, right, i)\\n                    i = right\\n                else:\\n                    self.swapTrack(a[left], a[i])\\n                    self.swap(a, left, i)\\n                    i = left\\n            elif 0 <= left < len(a) and a[i][0] < a[left][0]:\\n                self.swapTrack(a[left], a[i])\\n                self.swap(a, left, i)\\n                i = left\\n            elif 0 <= right < len(a) and a[i][0] < a[right][0]:\\n                self.swapTrack(a[i], a[right])\\n                self.swap(a, right, i)\\n                i = right\\n            else: #in perfect position\\n                break\\n        \\n        return ret\\n\\n\\n\\n\\n\\n\\nclass Solution:\\n    def minNumberOfSemesters(self, n: int, edges: List[List[int]], k: int) -> int:\\n        graph = collections.defaultdict(set)\\n        \\n        prereq = collections.defaultdict(set)\\n        for a, b in edges:\\n            graph[a].add(b) #a graph\\n            prereq[b].add(a)\\n        \\n        cantake = set() #courses that\\'s open for the taking.\\n        for i in range(1, n+1):\\n            if i not in prereq:\\n                cantake.add(i)\\n        \\n        #notice! When you take one course in the semester, a->b->c, it takes at least 3 semester\\n        #you can\\'t take a course and its postrequisite at the same time!\\n        \\n        \"\"\"\\n        take the ones with the deepest depth first?\\n        \\n        Rescan entire graph every time. We choose to deal with nodes that have the deepest depth (or depth of tree below them, or height in avl) first.\\n        \\n        If: There are two ways to reach the same node, we choose the more lengthier way --- because you have to take all prereqs first, not just the easier/shallower ones.\\n        \\n        5\\n[[2,1],[3,1],[1,4], [5, 4]]\\n2\\n        \\n        No time complexity requirements\\n        \"\"\"\\n        #graph is how you navigate the tree\\n        #prereq is prereq for every course\\n        \\n        self.h = HeapTuple() #available classes to take in terms of depth\\n        #[maxmimum depth of tree below it, node name]\\n        \\n        \\n        def dfs(on): #find the maximum depth of current node\\n            # print(on)\\n            curr = 1\\n            \\n            maxbelow = 0 #maximum height tree below\\n            \\n            for e in graph[on]:\\n                maxbelow = max(maxbelow, dfs(e))\\n            \\n            \\n            return curr + maxbelow\\n        \\n        # print(dfs(2))\\n        \\n        done = set()\\n        \\n        c = 0\\n        while True:\\n            #we had taken all the classes\\n            if len(cantake) == 0: break\\n            \\n            print(\"Semester\", c)\\n            print(\"We had already taken\", done)\\n            print(\"And we can take\", cantake)\\n            \\n            #do prescan EVERYTIME for which ones got most depth --- those need to be dealt with first\\n            self.h.heap = []\\n            self.h.track = {}\\n            \\n            \\n            \\n            #for all undealt with nodes that have no children:\\n            for on in cantake:\\n                depth = dfs(on) #maxdepth for on\\n                \\n\\n                \\n                heap = self.h.heap\\n                tracker = self.h.track\\n                \\n                #if this one is deeper than something we already got, then deal with that.\\n                if on in tracker:\\n                    #check if this one is deeper, and then\\n                    inloc = tracker[on] #already in location\\n                    inval = heap[inloc][0]\\n\\n                    if depth > inval: \\n                        self.h.remove(inloc)\\n                        self.h.insert([depth, on])\\n            \\n                else: #new thing. Just add in its depth\\n                    self.h.insert([depth, on])\\n            \\n            print(heap)\\n            \\n            #Now choose what we\\'re dealing with\\n            for i in range(k):\\n                if self.h.heap == []: break\\n                \\n                removed = self.h.remove(0)[1] #[depth, actual index]\\n                done.add(removed)\\n                \\n                cantake.remove(removed)\\n                \\n                for e in graph[removed]:\\n                    prereq[e].remove(removed) #its succeeding classes have one less children\\n                    #and it they now have no children, we can add that to can take\\n                    if len(prereq[e]) == 0:\\n                        cantake.add(e)\\n            \\n\\n            \\n            \"\"\"\\n            8\\n[[2,1],[3,1],[4,1],[1,5], [5, 6], [6, 7], [5, 8]]\\n2\\n            \\n            \"\"\"\\n\\n\\n            c+=1\\n        \\n        \\n        \\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1395741,
                "title": "can-any1-help-what-is-wrong-here",
                "content": "```\\nclass Solution {\\n    int dis[];\\n    public int minNumberOfSemesters(int n, int[][] relations, int k) {\\n        if(relations.length == 0)\\n            return n/k + n%k;\\n\\n        ArrayList<ArrayList<Integer>> g = new ArrayList<>();\\n        for(int i=0;i<=n;i++)\\n            g.add(i, new ArrayList<>());\\n        \\n        int indeg[] = new int[n+1];\\n        for(int e[] : relations){\\n            g.get(e[0]).add(e[1]);\\n            indeg[e[1]]++;\\n        }\\n        \\n        dis = new int[n+1];\\n        Arrays.fill(dis, -1);\\n\\n        for(int v=1;v<=n;v++){\\n            dfs(v, g);\\n        }\\n        \\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b)->dis[b]-dis[a]);\\n        for(int id=1;id<=n;id++){\\n            if(indeg[id] == 0 && dis[id] != -1){\\n                pq.add(id);\\n            }\\n        }\\n        \\n        int sems=0;\\n        while(!pq.isEmpty()){\\n            int sz = pq.size();\\n            for(int j=0;j < Math.min(sz,k);j++){\\n                int id = pq.poll(); \\n\\n                for(int x=0;x<g.get(id).size();x++){\\n                        indeg[g.get(id).get(x)]--;\\n                        if(indeg[g.get(id).get(x)]==0)\\n                            pq.add(g.get(id).get(x));\\n                }\\n            }\\n            sems++;\\n        }\\n        \\n        return sems;\\n    }\\n    \\n    int dfs(int u, ArrayList<ArrayList<Integer>> g){\\n        if(dis[u]!= -1)\\n            return dis[u];\\n        \\n        for(int id : g.get(u)){\\n            dis[u] = Math.max(dis[u], dfs(id, g));\\n        }\\n        \\n        dis[u] = dis[u]+1;\\n        return dis[u];\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int dis[];\\n    public int minNumberOfSemesters(int n, int[][] relations, int k) {\\n        if(relations.length == 0)\\n            return n/k + n%k;\\n\\n        ArrayList<ArrayList<Integer>> g = new ArrayList<>();\\n        for(int i=0;i<=n;i++)\\n            g.add(i, new ArrayList<>());\\n        \\n        int indeg[] = new int[n+1];\\n        for(int e[] : relations){\\n            g.get(e[0]).add(e[1]);\\n            indeg[e[1]]++;\\n        }\\n        \\n        dis = new int[n+1];\\n        Arrays.fill(dis, -1);\\n\\n        for(int v=1;v<=n;v++){\\n            dfs(v, g);\\n        }\\n        \\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b)->dis[b]-dis[a]);\\n        for(int id=1;id<=n;id++){\\n            if(indeg[id] == 0 && dis[id] != -1){\\n                pq.add(id);\\n            }\\n        }\\n        \\n        int sems=0;\\n        while(!pq.isEmpty()){\\n            int sz = pq.size();\\n            for(int j=0;j < Math.min(sz,k);j++){\\n                int id = pq.poll(); \\n\\n                for(int x=0;x<g.get(id).size();x++){\\n                        indeg[g.get(id).get(x)]--;\\n                        if(indeg[g.get(id).get(x)]==0)\\n                            pq.add(g.get(id).get(x));\\n                }\\n            }\\n            sems++;\\n        }\\n        \\n        return sems;\\n    }\\n    \\n    int dfs(int u, ArrayList<ArrayList<Integer>> g){\\n        if(dis[u]!= -1)\\n            return dis[u];\\n        \\n        for(int id : g.get(u)){\\n            dis[u] = Math.max(dis[u], dfs(id, g));\\n        }\\n        \\n        dis[u] = dis[u]+1;\\n        return dis[u];\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1382570,
                "title": "how-to-choose-a-course-to-learn",
                "content": "/**\\n   * Here shows how to choose a course to learn\\n   * First let\\'s reverse time, time will go from future to past\\n   * (just mean learn course backwards, and their relation ship changes, learning next course can free previous couse)\\n   * Remember, we always try to learn as many courses as possible(max k)\\n   * Next we start choose course:\\n   * a) If a course has bigger depth, we learn it first, as each depth need at least one term\\n   * b) If they have same depth, we try to compare how many pre courses it can free\\n   * \\n   */",
                "solutionTags": [],
                "code": "/**\\n   * Here shows how to choose a course to learn\\n   * First let\\'s reverse time, time will go from future to past\\n   * (just mean learn course backwards, and their relation ship changes, learning next course can free previous couse)\\n   * Remember, we always try to learn as many courses as possible(max k)\\n   * Next we start choose course:\\n   * a) If a course has bigger depth, we learn it first, as each depth need at least one term\\n   * b) If they have same depth, we try to compare how many pre courses it can free\\n   * \\n   */",
                "codeTag": "Unknown"
            },
            {
                "id": 1381844,
                "title": "test-case-explanation",
                "content": "Can someone explain this test case \\n\\n13\\n[[12,8],[2,4],[3,7],[6,8],[11,8],[9,4],[9,7],[12,4],[11,4],[6,4],[1,4],[10,7],[10,4],[1,7],[1,8],[2,7],[8,4],[10,8],[12,7],[5,4],[3,4],[11,7],[7,4],[13,4],[9,8],[13,8]]\\n9",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1377941,
                "title": "c-dp-bitmask",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>adj;\\n    int n,k;\\n    int dp[33000];\\n    int SB(int x)\\n    {\\n        int res=0;\\n        while(x)\\n        {\\n            res++;\\n            x=x&(x-1);\\n        }\\n        return res;\\n    }\\n    int get(int mask)\\n    {\\n        if(mask==((1<<n)-1))\\n            return 0;\\n        if(dp[mask]!=-1)\\n            return dp[mask];\\n        vector<int>indeg(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            int bit=1&(mask>>i);\\n            if(!bit)\\n            {\\n                for(auto j:adj[i])\\n                    indeg[j]++;\\n            }\\n        }\\n        vector<int>deg0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int bit=1&(mask>>i);\\n            if(!bit && indeg[i]==0)\\n                deg0.push_back(i);\\n        }\\n        int cnt=deg0.size(),res=INT_MAX;\\n        if(cnt<=k)\\n        {\\n            int mask2=mask;\\n            for(auto i:deg0)\\n                mask2|=(1<<i);\\n            res=min(res,1+get(mask2));\\n        }\\n        else\\n        {\\n            int N=1<<cnt;\\n            for(int j=0;j<N;j++)\\n            {\\n                int set_bit=SB(j);\\n                if(set_bit==k)\\n                {\\n                    int mask2=mask;\\n                    for(int i=0;i<cnt;i++)\\n                    {\\n                        int bit=1&(j>>i);\\n                        if(bit)\\n                            mask2|=(1<<(deg0[i]));\\n                    }\\n                    res=min(res,1+get(mask2));\\n                }\\n            }\\n        }\\n        return dp[mask]=res;\\n    }\\n    int minNumberOfSemesters(int N, vector<vector<int>>&d, int K) \\n    {\\n        n=N,k=K;\\n        adj.resize(n);\\n        memset(dp,-1,sizeof(dp));\\n        for(auto v:d)\\n            adj[v[0]-1].push_back(v[1]-1);\\n        return get(0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>adj;\\n    int n,k;\\n    int dp[33000];\\n    int SB(int x)\\n    {\\n        int res=0;\\n        while(x)\\n        {\\n            res++;\\n            x=x&(x-1);\\n        }\\n        return res;\\n    }\\n    int get(int mask)\\n    {\\n        if(mask==((1<<n)-1))\\n            return 0;\\n        if(dp[mask]!=-1)\\n            return dp[mask];\\n        vector<int>indeg(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            int bit=1&(mask>>i);\\n            if(!bit)\\n            {\\n                for(auto j:adj[i])\\n                    indeg[j]++;\\n            }\\n        }\\n        vector<int>deg0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int bit=1&(mask>>i);\\n            if(!bit && indeg[i]==0)\\n                deg0.push_back(i);\\n        }\\n        int cnt=deg0.size(),res=INT_MAX;\\n        if(cnt<=k)\\n        {\\n            int mask2=mask;\\n            for(auto i:deg0)\\n                mask2|=(1<<i);\\n            res=min(res,1+get(mask2));\\n        }\\n        else\\n        {\\n            int N=1<<cnt;\\n            for(int j=0;j<N;j++)\\n            {\\n                int set_bit=SB(j);\\n                if(set_bit==k)\\n                {\\n                    int mask2=mask;\\n                    for(int i=0;i<cnt;i++)\\n                    {\\n                        int bit=1&(j>>i);\\n                        if(bit)\\n                            mask2|=(1<<(deg0[i]));\\n                    }\\n                    res=min(res,1+get(mask2));\\n                }\\n            }\\n        }\\n        return dp[mask]=res;\\n    }\\n    int minNumberOfSemesters(int N, vector<vector<int>>&d, int K) \\n    {\\n        n=N,k=K;\\n        adj.resize(n);\\n        memset(dp,-1,sizeof(dp));\\n        for(auto v:d)\\n            adj[v[0]-1].push_back(v[1]-1);\\n        return get(0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1377840,
                "title": "easiest-c-1d-dp-bitmasking",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    unordered_map<int,vector<int>> DEPEND ;\\n    \\n    int MASK ;\\n\\n    int t[32770] ;\\n    \\n    \\n   inline void generate(vector<int>&Available , int i, int mask, vector<int>&Ans , int taken, int k)\\n    {\\n        if(taken==k)\\n        {\\n            Ans.push_back(mask) ;\\n            return ;\\n        }\\n        \\n        if(i==Available.size())\\n        {\\n            if(taken>0)   \\n                Ans.push_back(mask) ;\\n            \\n            return ;\\n        }\\n        \\n        generate(Available,i+1,mask|(1<<Available[i]) , Ans , taken+1,k) ;\\n        generate(Available,i+1,mask,Ans,taken,k) ;\\n    }\\n    \\n    \\n   inline int Solve(int mask , int N , int k)\\n    {\\n\\n        if(mask==MASK)\\n            return 0 ;\\n\\n        int Ans = 1e7 ;\\n\\n        if(t[mask]!=-1)\\n            return t[mask]  ;\\n        \\n        \\n        vector<int> Available ;\\n        \\n        for(int i=0 ; i<N ; i++)\\n        {\\n            if( (mask&(1<<i) )==0 )\\n            {\\n                // check if all prev are done or not ;\\n                \\n                bool flag = true ;\\n                \\n                if(DEPEND.find(i)!=DEPEND.end()) {\\n                for(auto x:DEPEND[i])\\n                {\\n                    if( (mask&(1<<x) ) == 0 ) \\n                       flag = false ;\\n                }\\n                }\\n                \\n                if(flag==true)\\n               {\\n                   Available.push_back(i) ;   // this current node is not dependent anymore on others\\n               }\\n            }\\n        }\\n        \\n    \\n    vector<int> AllMask ; \\n    generate(Available,0,mask,AllMask,0,k) ;\\n        // Generates all the combinations of the nodes present in available vector\\n        \\n       for(int i=0 ; i<AllMask.size() ; i++) \\n       {\\n           Ans = min(Ans,1+Solve(AllMask[i] , N ,k)) ;\\n       }\\n        \\n        return t[mask] = Ans ;\\n    }\\n    \\n    \\n    int minNumberOfSemesters(int n, vector<vector<int>>& R, int k) {\\n        \\n        for(auto x:R)\\n        DEPEND[x[1]-1].push_back(x[0]-1) ;\\n        \\n        MASK = 1<<n ;\\n        MASK-- ;\\n       \\n        memset(t,-1,sizeof(t)) ;\\n        \\n        return Solve(0,n,k) ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    unordered_map<int,vector<int>> DEPEND ;\\n    \\n    int MASK ;\\n\\n    int t[32770] ;\\n    \\n    \\n   inline void generate(vector<int>&Available , int i, int mask, vector<int>&Ans , int taken, int k)\\n    {\\n        if(taken==k)\\n        {\\n            Ans.push_back(mask) ;\\n            return ;\\n        }\\n        \\n        if(i==Available.size())\\n        {\\n            if(taken>0)   \\n                Ans.push_back(mask) ;\\n            \\n            return ;\\n        }\\n        \\n        generate(Available,i+1,mask|(1<<Available[i]) , Ans , taken+1,k) ;\\n        generate(Available,i+1,mask,Ans,taken,k) ;\\n    }\\n    \\n    \\n   inline int Solve(int mask , int N , int k)\\n    {\\n\\n        if(mask==MASK)\\n            return 0 ;\\n\\n        int Ans = 1e7 ;\\n\\n        if(t[mask]!=-1)\\n            return t[mask]  ;\\n        \\n        \\n        vector<int> Available ;\\n        \\n        for(int i=0 ; i<N ; i++)\\n        {\\n            if( (mask&(1<<i) )==0 )\\n            {\\n                // check if all prev are done or not ;\\n                \\n                bool flag = true ;\\n                \\n                if(DEPEND.find(i)!=DEPEND.end()) {\\n                for(auto x:DEPEND[i])\\n                {\\n                    if( (mask&(1<<x) ) == 0 ) \\n                       flag = false ;\\n                }\\n                }\\n                \\n                if(flag==true)\\n               {\\n                   Available.push_back(i) ;   // this current node is not dependent anymore on others\\n               }\\n            }\\n        }\\n        \\n    \\n    vector<int> AllMask ; \\n    generate(Available,0,mask,AllMask,0,k) ;\\n        // Generates all the combinations of the nodes present in available vector\\n        \\n       for(int i=0 ; i<AllMask.size() ; i++) \\n       {\\n           Ans = min(Ans,1+Solve(AllMask[i] , N ,k)) ;\\n       }\\n        \\n        return t[mask] = Ans ;\\n    }\\n    \\n    \\n    int minNumberOfSemesters(int n, vector<vector<int>>& R, int k) {\\n        \\n        for(auto x:R)\\n        DEPEND[x[1]-1].push_back(x[0]-1) ;\\n        \\n        MASK = 1<<n ;\\n        MASK-- ;\\n       \\n        memset(t,-1,sizeof(t)) ;\\n        \\n        return Solve(0,n,k) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1375272,
                "title": "bfs-with-bitmask",
                "content": "State is bitmask of waiting courses. First, we need to find bitmask of required courses for each course. From the state (done courses are 0), we can determine the possible courses that can be taken in the next semester (using the required course bitmask). Initialize visited_states set and the BFS queue.\\n3. Start with all combinations of possible initial courses and add it in the visited_states set and the BFS queue.\\n4. Run BFS and ignore if already visited state occurs again.\\n```\\nfrom collections import defaultdict, deque\\nfrom itertools import combinations\\nclass Solution:\\n    def minNumberOfSemesters(self, n: int, relations: List[List[int]], k: int) -> int:\\n        if n==1:return 1\\n        requires =defaultdict(int)\\n        for prv,nxt in relations:\\n            requires[nxt-1] |= (1<<(prv-1))  \\n        available = (1<<n)-1\\n        #Create Queue\\n        visited = set()\\n        possible = [j for j in range(n) if (available & (1<<j)) and not (available & requires[j])]\\n        queue = deque()\\n        for perm in combinations(possible,min(k, len(possible)) ):\\n            new_mask = available\\n            for x in perm:\\n                new_mask = new_mask ^(1<<x)\\n            queue.append(new_mask)\\n            visited.add(new_mask)\\n        #\\n        steps = 0\\n\\n        while queue:\\n            count = len(queue)\\n            steps +=1\\n            while count:\\n                mask = queue.popleft()\\n                if mask==0:return steps\\n                possible = [j for j in range(n) if (mask & (1<<j)) and not (mask & requires[j])]\\n                for perm in combinations(possible,min(k, len(possible)) ):\\n                    new_mask = mask\\n                    for x in perm:\\n                        new_mask = new_mask ^(1<<x)\\n                    if new_mask not in visited:\\n                        queue.append(new_mask)\\n                        visited.add(new_mask)\\n                count -= 1\\n        \\n            \\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict, deque\\nfrom itertools import combinations\\nclass Solution:\\n    def minNumberOfSemesters(self, n: int, relations: List[List[int]], k: int) -> int:\\n        if n==1:return 1\\n        requires =defaultdict(int)\\n        for prv,nxt in relations:\\n            requires[nxt-1] |= (1<<(prv-1))  \\n        available = (1<<n)-1\\n        #Create Queue\\n        visited = set()\\n        possible = [j for j in range(n) if (available & (1<<j)) and not (available & requires[j])]\\n        queue = deque()\\n        for perm in combinations(possible,min(k, len(possible)) ):\\n            new_mask = available\\n            for x in perm:\\n                new_mask = new_mask ^(1<<x)\\n            queue.append(new_mask)\\n            visited.add(new_mask)\\n        #\\n        steps = 0\\n\\n        while queue:\\n            count = len(queue)\\n            steps +=1\\n            while count:\\n                mask = queue.popleft()\\n                if mask==0:return steps\\n                possible = [j for j in range(n) if (mask & (1<<j)) and not (mask & requires[j])]\\n                for perm in combinations(possible,min(k, len(possible)) ):\\n                    new_mask = mask\\n                    for x in perm:\\n                        new_mask = new_mask ^(1<<x)\\n                    if new_mask not in visited:\\n                        queue.append(new_mask)\\n                        visited.add(new_mask)\\n                count -= 1\\n        \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1260064,
                "title": "bit-mask-and-bfs",
                "content": "inspired by @hxu10\\n\\nuse the mask to represent which courses are selected\\ngiven a mask, the courses that can be selected are those 0 bits whose prerequisites are already selected\\na bit mask can also be used to represent reprequisites of a course\\n![](https://assets.leetcode.com/uploads/2020/05/22/leetcode_parallel_courses_1.png)\\n```\\nreprequisites of above example: (alll node u will be reduced by 1)\\n0: 0110\\n1: 0000\\n2: 0000\\n3: 0001\\n```\\n\\nfor each state(mask), we can select as many courses as we can. The operation will produce serveral children state. So the states (masks) can be prepresented by a graph. \\nThen we can adopt BFS to search the min length from root (mask with 0) to target (mask with (1 << n) - 1).\\n\\n**Python**\\n```\\nclass Solution:\\n    def minNumberOfSemesters(self, n: int, relations: List[List[int]], k: int) -> int:\\n        graph = [[] for _ in range(n)]\\n        pre = [0] * n\\n        \\n        for u, v in relations:\\n            graph[u - 1].append(v - 1)\\n            pre[v - 1] |= 1 << (u - 1)\\n        \\n        queue = collections.deque([0])\\n        vis = set([0])\\n        steps = 0\\n        while queue:\\n            for _ in range(len(queue)):\\n                mask = queue.popleft()\\n                if mask == (1 << n) - 1:\\n                    return steps\\n                available = []\\n                for i in range(n):\\n                    if not mask & (1 << i) and pre[i] & mask == pre[i]:\\n                        available.append(i)\\n                m = min(k, len(available))\\n                for com in itertools.combinations(available, m):\\n                    _mask = mask\\n                    for u in com:\\n                        _mask |= (1 << u)\\n                    if _mask not in vis:\\n                        vis.add(_mask)\\n                        queue.append(_mask)\\n            steps += 1\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\nreprequisites of above example: (alll node u will be reduced by 1)\\n0: 0110\\n1: 0000\\n2: 0000\\n3: 0001\\n```\n```\\nclass Solution:\\n    def minNumberOfSemesters(self, n: int, relations: List[List[int]], k: int) -> int:\\n        graph = [[] for _ in range(n)]\\n        pre = [0] * n\\n        \\n        for u, v in relations:\\n            graph[u - 1].append(v - 1)\\n            pre[v - 1] |= 1 << (u - 1)\\n        \\n        queue = collections.deque([0])\\n        vis = set([0])\\n        steps = 0\\n        while queue:\\n            for _ in range(len(queue)):\\n                mask = queue.popleft()\\n                if mask == (1 << n) - 1:\\n                    return steps\\n                available = []\\n                for i in range(n):\\n                    if not mask & (1 << i) and pre[i] & mask == pre[i]:\\n                        available.append(i)\\n                m = min(k, len(available))\\n                for com in itertools.combinations(available, m):\\n                    _mask = mask\\n                    for u in com:\\n                        _mask |= (1 << u)\\n                    if _mask not in vis:\\n                        vis.add(_mask)\\n                        queue.append(_mask)\\n            steps += 1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1243768,
                "title": "how-to-prune-optimize-my-java-solution",
                "content": "Here\\'s my `Kahn\\'s + Permutations` based solution with `O(V!)` complexity. It gets TLE on `11 [] 2`. I state `O(V!)` because the complexity of array permutations adds up to `O(n!)`.\\n\\nIs it unacceptable complexity at all or could my \"permutations\" be improved in any way?\\n\\n```\\nclass Solution {\\n    \\n    public int minNumberOfSemesters(final int n, final int[][] edges, final int k) {\\n        final Map<Integer, List<Integer>> graph = new HashMap<>();\\n        for (int i = 1; i <= n; i++) {\\n            graph.put(i, new ArrayList<>());\\n        }\\n        final int[] inDegree = new int[n + 1];\\n        for (final int[] dep: edges) {\\n            graph.get(dep[0]).add(dep[1]);\\n            inDegree[dep[1]]++;\\n        }\\n        final List<Integer> seq = new ArrayList<>();\\n        final List<List<Integer>> combinations = new ArrayList<>();\\n        for (int i = 1; i <= n; i++) {\\n            if (inDegree[i] == 0) {\\n                combinations(graph, i, inDegree, seq, combinations);\\n            }\\n        }\\n        int result = n;\\n        for (final List<Integer> combination: combinations) {\\n            int counter = 1, w = 0;\\n            final Set<Integer> dependents = new HashSet<>();\\n            for (final int course: combination) {\\n                if (dependents.contains(course) || w == k) {\\n                    counter++;\\n                    w = 0;\\n                    dependents.clear();\\n                }\\n                w++;\\n                dependents.addAll(graph.get(course));\\n            }\\n            result = Math.min(result, counter);\\n        }\\n        return result;\\n    }\\n\\n    public void combinations(final Map<Integer, List<Integer>> graph, final int vertex, final int[] inDegree, final List<Integer> seq, final List<List<Integer>> combinations) {\\n        final List<Integer> adjs = graph.remove(vertex);\\n        if (adjs == null) {\\n            return;\\n        }\\n        seq.add(vertex);\\n        if (seq.size() == inDegree.length - 1) {\\n            combinations.add(new ArrayList<>(seq));\\n        } else {\\n            for (final int adj: adjs) {\\n                inDegree[adj]--;\\n            }\\n            for (int i = 1, n = inDegree.length; i < n; i++) {\\n                if (inDegree[i] == 0) {\\n                    combinations(graph, i, inDegree, seq, combinations);\\n                }\\n            }\\n            for (final int adj: adjs) {\\n                inDegree[adj]++;\\n            }\\n        }\\n        seq.remove(seq.size() - 1);\\n        graph.put(vertex, adjs);\\n    }\\n\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int minNumberOfSemesters(final int n, final int[][] edges, final int k) {\\n        final Map<Integer, List<Integer>> graph = new HashMap<>();\\n        for (int i = 1; i <= n; i++) {\\n            graph.put(i, new ArrayList<>());\\n        }\\n        final int[] inDegree = new int[n + 1];\\n        for (final int[] dep: edges) {\\n            graph.get(dep[0]).add(dep[1]);\\n            inDegree[dep[1]]++;\\n        }\\n        final List<Integer> seq = new ArrayList<>();\\n        final List<List<Integer>> combinations = new ArrayList<>();\\n        for (int i = 1; i <= n; i++) {\\n            if (inDegree[i] == 0) {\\n                combinations(graph, i, inDegree, seq, combinations);\\n            }\\n        }\\n        int result = n;\\n        for (final List<Integer> combination: combinations) {\\n            int counter = 1, w = 0;\\n            final Set<Integer> dependents = new HashSet<>();\\n            for (final int course: combination) {\\n                if (dependents.contains(course) || w == k) {\\n                    counter++;\\n                    w = 0;\\n                    dependents.clear();\\n                }\\n                w++;\\n                dependents.addAll(graph.get(course));\\n            }\\n            result = Math.min(result, counter);\\n        }\\n        return result;\\n    }\\n\\n    public void combinations(final Map<Integer, List<Integer>> graph, final int vertex, final int[] inDegree, final List<Integer> seq, final List<List<Integer>> combinations) {\\n        final List<Integer> adjs = graph.remove(vertex);\\n        if (adjs == null) {\\n            return;\\n        }\\n        seq.add(vertex);\\n        if (seq.size() == inDegree.length - 1) {\\n            combinations.add(new ArrayList<>(seq));\\n        } else {\\n            for (final int adj: adjs) {\\n                inDegree[adj]--;\\n            }\\n            for (int i = 1, n = inDegree.length; i < n; i++) {\\n                if (inDegree[i] == 0) {\\n                    combinations(graph, i, inDegree, seq, combinations);\\n                }\\n            }\\n            for (final int adj: adjs) {\\n                inDegree[adj]++;\\n            }\\n        }\\n        seq.remove(seq.size() - 1);\\n        graph.put(vertex, adjs);\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1223376,
                "title": "double-greedy-optimal-o-n-2",
                "content": "```\\nclass Solution {\\npublic:\\n    int minNumberOfSemesters(int n, vector<vector<int>>& dependencies, int k) {\\n        int return_min = INT_MAX;\\n        \\n        for (double weight = 0; weight <= 1; weight += 0.50){\\n            return_min = min(return_min, minNumberOfSemestersWeighted(n, dependencies, k, weight));    \\n        }\\n        \\n        return return_min;\\n    }\\n    \\n    int minNumberOfSemestersWeighted(int n, vector<vector<int>>& dependencies, int k, double weight) {\\n        unordered_map<int, vector<int>> parent;\\n        vector<int> requirement_count(n+1); \\n            \\n        for (int i = 1; i < n+1; i++){\\n            requirement_count[i] = 0;\\n        }\\n        \\n        for (int i = 0; i < dependencies.size(); i++){\\n            parent[dependencies[i][1]].push_back(dependencies[i][0]);\\n            requirement_count[dependencies[i][0]]++;\\n        }\\n        \\n        priority_queue<Node> nodes;\\n        priority_queue<Node> temp_nodes;\\n        \\n        for (int i = 1; i < n+1; i++){\\n            if (requirement_count[i] == 0)\\n                nodes.push(Node(i, getMaxDepth(i, parent), parent[i].size(), weight));\\n        }\\n        \\n        int return_count = 0;\\n        \\n        while (!nodes.empty()){\\n            temp_nodes = nodes;\\n            nodes = priority_queue<Node>();\\n            \\n            int count = 0;\\n            \\n            while (!temp_nodes.empty() && count < k){\\n                int course = temp_nodes.top().course;\\n                temp_nodes.pop();\\n                count++;\\n\\n                for (int i = 0; i < parent[course].size(); i++){\\n                    int curr_parent = parent[course][i];\\n                    if (--requirement_count[curr_parent] == 0){\\n                        nodes.push(Node(curr_parent, getMaxDepth(curr_parent, parent), parent[curr_parent].size(), weight));\\n                    }\\n                }\\n            }\\n            \\n            while (!temp_nodes.empty()){\\n                nodes.push(temp_nodes.top());\\n                temp_nodes.pop();\\n            }\\n            return_count += 1;\\n        }\\n        \\n        return return_count;\\n    }\\n    \\n    int getMaxDepth(int root, unordered_map<int, vector<int>>& parent){\\n        if (parent[root].size() == 0)\\n            return 0;\\n        \\n        int maxDepth = 0;\\n        \\n        for (int i = 0; i < parent[root].size(); i++)\\n            maxDepth = max(maxDepth, getMaxDepth(parent[root][i], parent) + 1);\\n        \\n        return maxDepth;\\n    }\\n    \\n    struct Node{\\n        int course;\\n        int depth_count;\\n        int parent_count;\\n        double weight;\\n        \\n        Node(int course, int depth_count, int parent_count, double weight){\\n            this->course = course;\\n            this->depth_count = depth_count;\\n            this->parent_count = parent_count;\\n            this->weight = weight;\\n        }\\n        \\n        bool operator <(const Node& b) const{\\n            return this->depth_count + this->parent_count*this->weight < b.depth_count + b.parent_count*b.weight;\\n        }\\n        \\n    };\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfSemesters(int n, vector<vector<int>>& dependencies, int k) {\\n        int return_min = INT_MAX;\\n        \\n        for (double weight = 0; weight <= 1; weight += 0.50){\\n            return_min = min(return_min, minNumberOfSemestersWeighted(n, dependencies, k, weight));    \\n        }\\n        \\n        return return_min;\\n    }\\n    \\n    int minNumberOfSemestersWeighted(int n, vector<vector<int>>& dependencies, int k, double weight) {\\n        unordered_map<int, vector<int>> parent;\\n        vector<int> requirement_count(n+1); \\n            \\n        for (int i = 1; i < n+1; i++){\\n            requirement_count[i] = 0;\\n        }\\n        \\n        for (int i = 0; i < dependencies.size(); i++){\\n            parent[dependencies[i][1]].push_back(dependencies[i][0]);\\n            requirement_count[dependencies[i][0]]++;\\n        }\\n        \\n        priority_queue<Node> nodes;\\n        priority_queue<Node> temp_nodes;\\n        \\n        for (int i = 1; i < n+1; i++){\\n            if (requirement_count[i] == 0)\\n                nodes.push(Node(i, getMaxDepth(i, parent), parent[i].size(), weight));\\n        }\\n        \\n        int return_count = 0;\\n        \\n        while (!nodes.empty()){\\n            temp_nodes = nodes;\\n            nodes = priority_queue<Node>();\\n            \\n            int count = 0;\\n            \\n            while (!temp_nodes.empty() && count < k){\\n                int course = temp_nodes.top().course;\\n                temp_nodes.pop();\\n                count++;\\n\\n                for (int i = 0; i < parent[course].size(); i++){\\n                    int curr_parent = parent[course][i];\\n                    if (--requirement_count[curr_parent] == 0){\\n                        nodes.push(Node(curr_parent, getMaxDepth(curr_parent, parent), parent[curr_parent].size(), weight));\\n                    }\\n                }\\n            }\\n            \\n            while (!temp_nodes.empty()){\\n                nodes.push(temp_nodes.top());\\n                temp_nodes.pop();\\n            }\\n            return_count += 1;\\n        }\\n        \\n        return return_count;\\n    }\\n    \\n    int getMaxDepth(int root, unordered_map<int, vector<int>>& parent){\\n        if (parent[root].size() == 0)\\n            return 0;\\n        \\n        int maxDepth = 0;\\n        \\n        for (int i = 0; i < parent[root].size(); i++)\\n            maxDepth = max(maxDepth, getMaxDepth(parent[root][i], parent) + 1);\\n        \\n        return maxDepth;\\n    }\\n    \\n    struct Node{\\n        int course;\\n        int depth_count;\\n        int parent_count;\\n        double weight;\\n        \\n        Node(int course, int depth_count, int parent_count, double weight){\\n            this->course = course;\\n            this->depth_count = depth_count;\\n            this->parent_count = parent_count;\\n            this->weight = weight;\\n        }\\n        \\n        bool operator <(const Node& b) const{\\n            return this->depth_count + this->parent_count*this->weight < b.depth_count + b.parent_count*b.weight;\\n        }\\n        \\n    };\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1154819,
                "title": "plagiarizing-from-answer-add-some-comments",
                "content": "Hi, first declare that:\\n\\tafter I take the solution from discuss, I read a better solution with more less time complexity, I add some comments.\\n\\tthe follow solution is not my idea, I just copy from better solutions to here. I just add some comments for it. Hope it can be understand easily. I don\\'t know who come up with the idea, I just keep its original code as much as posssible.\\n\\tI JUST COPY THE CODE, IF THERE IS COPYRIGHT, NOTICE ME, AND I WILL DELETE IT.\\n```\\n// #define DEBUGGG\\nnamespace { // alvin-777\\n#ifdef DEBUGGG\\n#define LOG(x) std::cout << (x) << std::endl << std::flush\\n#define PL(l) { std::cout << \"[\"; for (auto & e : l) std::cout << e << \\',\\'; std::cout << \"]\" << std::endl; }\\n#else\\n#define LOG(x)\\n#define PL(l)\\n#endif\\nstatic auto _speedupMagic = [] { ios::sync_with_stdio(false); cin.tie(nullptr); return 0; }();\\n}\\n\\nclass Solution {\\npublic:\\n    int minNumberOfSemesters(int n, std::vector<std::vector<int>> const & dependencies, int k) {\\n        std::array<std::pair<int, int>, 16> deps{};\\n        // availAll the first n bits are 1, the last bit will be 0, it is like 111...10 (n + 1 bits)\\n        int availAll = (1 << (n + 1)) - 2, availNow = availAll;\\n        for (auto & dep : dependencies) {\\n            deps[dep[0]].second |= 1 << dep[1];\\n            deps[dep[1]].first |= 1 << dep[0];\\n            // no depended bits will keep set\\n            availNow &= ~(1 << dep[1]);\\n        }\\n        std::array<int, 1 << 16> memo{};\\n        std::function<int(int, int)> BT = [&] (int aa, int an) -> int {\\n            if (!an) {\\n                // we can\\'t take a course\\n                return 0;\\n            }\\n            if (memo[aa]) {\\n                // we have already compute the state\\n                return memo[aa];\\n            }\\n            int kk = std::min(k, __builtin_popcount(an));\\n            int sub = an, end = 0;\\n            while (__builtin_popcount(sub) > kk) {\\n                // remove the least significant 1 bit\\n                // keep the bit from left to right with at most kk bits;\\n                sub &= sub - 1;\\n            }\\n            for (int sh = 0; __builtin_popcount(end) < kk; ++sh) {\\n                // remove the most significant bits\\n                // keep the bits from right to left with at most kk bits\\n                end |= an & (1 << sh);\\n            }\\n            /*\\n               if kk == __builtin_popcount(an), sub == end;\\n               if kk > k; sub > end;\\n             */\\n            int r = n;\\n            for (; sub >= end; sub = (sub - 1) & an) {\\n                // count the number of bits of sub to get the course that need taken\\n                int subbits = __builtin_popcount(sub);\\n                while (subbits > kk) {\\n                    // if the number is larget than k, we first deal with the most left k bits\\n                    sub &= sub - 1, --subbits;\\n                }\\n                if (subbits < kk) {\\n                    // because kk is std::min(k, __builtin_popcount(an)), subbits < kk is some cases, not all case\\n                    continue;\\n                }\\n                int aaNext = aa ^ sub, next = 0;\\n                for (int i = 1; i <= n; ++i) {\\n                    // the i idx need deal with and its depended courses are not in aaNext\\n                    // which means the i idx is free depended now\\n                    if (((1 << i) & aaNext) && !(deps[i].first & aaNext)) {\\n                        next |= 1 << i;\\n                    }\\n                }\\n                r = std::min(r, BT(aaNext, next) + 1);\\n                if (aa == availAll && r == (n + k - 1) / k) {\\n                    // n eleements and each time take k elements, it at least need (n + k - 1) / k times;\\n                    return memo[aa] = r;\\n                }\\n            }\\n            return memo[aa] = r;\\n        };\\n        return BT(availAll, availNow);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// #define DEBUGGG\\nnamespace { // alvin-777\\n#ifdef DEBUGGG\\n#define LOG(x) std::cout << (x) << std::endl << std::flush\\n#define PL(l) { std::cout << \"[\"; for (auto & e : l) std::cout << e << \\',\\'; std::cout << \"]\" << std::endl; }\\n#else\\n#define LOG(x)\\n#define PL(l)\\n#endif\\nstatic auto _speedupMagic = [] { ios::sync_with_stdio(false); cin.tie(nullptr); return 0; }();\\n}\\n\\nclass Solution {\\npublic:\\n    int minNumberOfSemesters(int n, std::vector<std::vector<int>> const & dependencies, int k) {\\n        std::array<std::pair<int, int>, 16> deps{};\\n        // availAll the first n bits are 1, the last bit will be 0, it is like 111...10 (n + 1 bits)\\n        int availAll = (1 << (n + 1)) - 2, availNow = availAll;\\n        for (auto & dep : dependencies) {\\n            deps[dep[0]].second |= 1 << dep[1];\\n            deps[dep[1]].first |= 1 << dep[0];\\n            // no depended bits will keep set\\n            availNow &= ~(1 << dep[1]);\\n        }\\n        std::array<int, 1 << 16> memo{};\\n        std::function<int(int, int)> BT = [&] (int aa, int an) -> int {\\n            if (!an) {\\n                // we can\\'t take a course\\n                return 0;\\n            }\\n            if (memo[aa]) {\\n                // we have already compute the state\\n                return memo[aa];\\n            }\\n            int kk = std::min(k, __builtin_popcount(an));\\n            int sub = an, end = 0;\\n            while (__builtin_popcount(sub) > kk) {\\n                // remove the least significant 1 bit\\n                // keep the bit from left to right with at most kk bits;\\n                sub &= sub - 1;\\n            }\\n            for (int sh = 0; __builtin_popcount(end) < kk; ++sh) {\\n                // remove the most significant bits\\n                // keep the bits from right to left with at most kk bits\\n                end |= an & (1 << sh);\\n            }\\n            /*\\n               if kk == __builtin_popcount(an), sub == end;\\n               if kk > k; sub > end;\\n             */\\n            int r = n;\\n            for (; sub >= end; sub = (sub - 1) & an) {\\n                // count the number of bits of sub to get the course that need taken\\n                int subbits = __builtin_popcount(sub);\\n                while (subbits > kk) {\\n                    // if the number is larget than k, we first deal with the most left k bits\\n                    sub &= sub - 1, --subbits;\\n                }\\n                if (subbits < kk) {\\n                    // because kk is std::min(k, __builtin_popcount(an)), subbits < kk is some cases, not all case\\n                    continue;\\n                }\\n                int aaNext = aa ^ sub, next = 0;\\n                for (int i = 1; i <= n; ++i) {\\n                    // the i idx need deal with and its depended courses are not in aaNext\\n                    // which means the i idx is free depended now\\n                    if (((1 << i) & aaNext) && !(deps[i].first & aaNext)) {\\n                        next |= 1 << i;\\n                    }\\n                }\\n                r = std::min(r, BT(aaNext, next) + 1);\\n                if (aa == availAll && r == (n + k - 1) / k) {\\n                    // n eleements and each time take k elements, it at least need (n + k - 1) / k times;\\n                    return memo[aa] = r;\\n                }\\n            }\\n            return memo[aa] = r;\\n        };\\n        return BT(availAll, availNow);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1142143,
                "title": "answer-that-is-provided-is-incorrect",
                "content": "I think the answer is wrong for the question:\\n```\\n6\\n[[2,1],[3,1],[1,4],[5,1],[5,6]]\\n2\\n```\\n\\nWhere the graph would look like\\n![image](https://assets.leetcode.com/users/images/321127ab-475a-4209-ba23-e79c4cbaa829_1617535216.069359.png)\\n\\nThe answer that the question provides is 4, but if you took the courses in the order: ```(3,5),(2,1),(4,6)``` then you would be able to do it in 3 semesters instead of 4.\\n\\nWhat am I missing?",
                "solutionTags": [],
                "code": "```\\n6\\n[[2,1],[3,1],[1,4],[5,1],[5,6]]\\n2\\n```\n```(3,5),(2,1),(4,6)```",
                "codeTag": "Unknown"
            },
            {
                "id": 1138235,
                "title": "c-with-explanation",
                "content": "Problem is definitely hard. The main indicator that problem is NP-Complete are the constraints.\\nCode is inspired from youtube video by Shivam Patel.\\n\\nI tried to explain by commenting main steps to solve the problem. Hopefully it helps!\\nTC : O(3 ^ n)\\nSC: O(2 ^ n)\\n```\\n\\n        public int MinNumberOfSemesters(int n, int[][] dependencies, int k)\\n        {\\n            // Point 1 - Decrement everything by one to apply bit masking.\\n            foreach (var dependency in dependencies)\\n            {\\n                dependency[0]--;\\n                dependency[1]--;\\n            }\\n\\n            // Fill with -1 to distinguish between processed and not processed.\\n            var dp = new int[1 << n];\\n            Array.Fill(dp, -1);\\n            return Helpers(n, dependencies, k, 0, dp);\\n        }\\n\\n        private int Helpers(int n, int[][] dependencies, int k, int mask, int[] dp)\\n        {\\n            if (mask == dp.Length - 1)\\n                return 0;\\n\\n            if (dp[mask] != -1)\\n                return dp[mask];\\n\\n            var min = n + 1;\\n            var availableMask = 0;\\n            var inDegree = new int[n];\\n\\n            // The objective is to find the AvailableMask which tells which courses can be taken now.\\n            // 1. Filter out courses which are already taken.\\n            for (var index = 0; index < n; index++)\\n            {\\n                if ((mask & (1 << index)) != 0)\\n                {\\n                    inDegree[index] = -1;\\n                }\\n            }\\n            // 2. Calculate InDegree for each course which hasn\\'t been taken.\\n            foreach (var dependency in dependencies)\\n            {\\n                var source = dependency[0];\\n                var dest = dependency[1];\\n                if (inDegree[dest] != -1 && inDegree[source] != -1)\\n                    inDegree[dest]++;\\n            }\\n\\n            // 3. If in Degree is 0 then we can take this course now, so add it AvailableMask.\\n            for (var i = 0; i < n; i++)\\n            {\\n                if (inDegree[i] == 0)\\n                    availableMask |= (1 << i);\\n            }\\n\\n            var coursesToTake = CountOneBits(availableMask);\\n            // 4. If you can take all courses, go for it. \\n            if (coursesToTake <= k)\\n            {\\n                min = Math.Min(min, 1 + Helpers(n, dependencies, k, mask | availableMask, dp));\\n            }\\n            else\\n            {\\n                // 5. Since you cannot take > k courses, Loop through sub masks of size k and calculate the minimum one.\\n\\t\\t\\t\\t// https://cp-algorithms.com/algebra/all-submasks.html\\n                for (var s = availableMask; s > 0; s = (s - 1) & availableMask)\\n                {\\n                    var availCourses = CountOneBits(s);\\n                    if (availCourses != k)\\n                        continue;\\n                    min = Math.Min(min, 1 + Helpers(n, dependencies, k, mask | s, dp));\\n                }\\n            }\\n\\n            dp[mask] = min;\\n            return dp[mask];\\n        }\\n\\n        private int CountOneBits(int mask)\\n        {\\n            var c = 0;\\n            while (mask > 0)\\n            {\\n                if ((mask & 1) != 0)\\n                    c++;\\n                mask >>= 1;\\n            }\\n            return c;\\n        }\\n\\n```",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "```\\n\\n        public int MinNumberOfSemesters(int n, int[][] dependencies, int k)\\n        {\\n            // Point 1 - Decrement everything by one to apply bit masking.\\n            foreach (var dependency in dependencies)\\n            {\\n                dependency[0]--;\\n                dependency[1]--;\\n            }\\n\\n            // Fill with -1 to distinguish between processed and not processed.\\n            var dp = new int[1 << n];\\n            Array.Fill(dp, -1);\\n            return Helpers(n, dependencies, k, 0, dp);\\n        }\\n\\n        private int Helpers(int n, int[][] dependencies, int k, int mask, int[] dp)\\n        {\\n            if (mask == dp.Length - 1)\\n                return 0;\\n\\n            if (dp[mask] != -1)\\n                return dp[mask];\\n\\n            var min = n + 1;\\n            var availableMask = 0;\\n            var inDegree = new int[n];\\n\\n            // The objective is to find the AvailableMask which tells which courses can be taken now.\\n            // 1. Filter out courses which are already taken.\\n            for (var index = 0; index < n; index++)\\n            {\\n                if ((mask & (1 << index)) != 0)\\n                {\\n                    inDegree[index] = -1;\\n                }\\n            }\\n            // 2. Calculate InDegree for each course which hasn\\'t been taken.\\n            foreach (var dependency in dependencies)\\n            {\\n                var source = dependency[0];\\n                var dest = dependency[1];\\n                if (inDegree[dest] != -1 && inDegree[source] != -1)\\n                    inDegree[dest]++;\\n            }\\n\\n            // 3. If in Degree is 0 then we can take this course now, so add it AvailableMask.\\n            for (var i = 0; i < n; i++)\\n            {\\n                if (inDegree[i] == 0)\\n                    availableMask |= (1 << i);\\n            }\\n\\n            var coursesToTake = CountOneBits(availableMask);\\n            // 4. If you can take all courses, go for it. \\n            if (coursesToTake <= k)\\n            {\\n                min = Math.Min(min, 1 + Helpers(n, dependencies, k, mask | availableMask, dp));\\n            }\\n            else\\n            {\\n                // 5. Since you cannot take > k courses, Loop through sub masks of size k and calculate the minimum one.\\n\\t\\t\\t\\t// https://cp-algorithms.com/algebra/all-submasks.html\\n                for (var s = availableMask; s > 0; s = (s - 1) & availableMask)\\n                {\\n                    var availCourses = CountOneBits(s);\\n                    if (availCourses != k)\\n                        continue;\\n                    min = Math.Min(min, 1 + Helpers(n, dependencies, k, mask | s, dp));\\n                }\\n            }\\n\\n            dp[mask] = min;\\n            return dp[mask];\\n        }\\n\\n        private int CountOneBits(int mask)\\n        {\\n            var c = 0;\\n            while (mask > 0)\\n            {\\n                if ((mask & 1) != 0)\\n                    c++;\\n                mask >>= 1;\\n            }\\n            return c;\\n        }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1132158,
                "title": "greedy-with-thinking-process",
                "content": "the key to the question is to divide all nodes to two groups, free nodes(have no connections with other nodes) and parent nodes(other nodes dependent upon), fyi, don\\'t use dp to store the state, it could override the optimal solution.\\n```\\nint indegree[];\\n    Set<Integer>[] edges;\\n    public int minNumberOfSemesters(int n, int[][] dependencies, int k) {\\n        edges = new Set[n];\\n        indegree = new int[n];\\n        int sig = 0;\\n        for (int i = 0; i < n; i++){\\n            sig += 1<<i;\\n            edges[i] = new HashSet<Integer>();\\n        }\\n        for (int[] d: dependencies){\\n            int s1 = d[0] - 1, s2 = d[1] - 1;\\n            indegree[s2]++;\\n            edges[s1].add(s2);\\n        }\\n        return dfs(n,k,sig);\\n    }\\n    int dfs(int n, int k, int sig){\\n        if (sig == 0) return 0;\\n        int cnt;\\n        List<Integer> nxt = new ArrayList<>(), priority = new ArrayList<>();\\n        for (int i = 0; i < n; i++){\\n            if ((sig & (1<<i)) != 0 && indegree[i] == 0){\\n                if (edges[i].size() != 0){\\n                    priority.add(i);\\n                }else{\\n                    nxt.add(i);\\n                }\\n            } \\n        }\\n        if (priority.size() == 0){\\n            cnt = nxt.size();\\n            if (cnt%k == 0){\\n                cnt/=k;\\n            }else{\\n                cnt/=k;\\n                cnt++;\\n            }\\n            return cnt;\\n        }\\n        if (priority.size() <= k){\\n            int minus = k - priority.size();\\n            for (int d: priority){\\n                sig -= 1<<d;\\n                for (int x: edges[d]){\\n                    indegree[x]--;\\n                }\\n            }\\n            for (int i = 0; i < Math.min(minus,nxt.size()); i++){\\n                sig-=1<<nxt.get(i);\\n            }\\n            cnt = 1+dfs(n,k,sig);\\n            for (int d: priority){\\n                for (int x: edges[d]){\\n                    indegree[x]++;\\n                }\\n            }\\n        }else{\\n            cnt = Integer.MAX_VALUE;\\n            Set<Integer> set = new HashSet<>();\\n            permuation(set,0,0,k,priority);\\n            for (int p:set){\\n                for (int d:priority){\\n                    if ((p&(1<<d)) != 0){\\n                        for (int x: edges[d]){\\n                            indegree[x]--;\\n                        }\\n                    }\\n                }\\n                cnt = Math.min(cnt,1+dfs(n,k,sig-p));\\n                for (int d:priority){\\n                    if ((p&(1<<d)) != 0){\\n                        for (int x: edges[d]){\\n                            indegree[x]++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n    void permuation(Set<Integer> set, int sig, int idx,int pick, List<Integer> arr){\\n        if (pick == 0){\\n            set.add(sig);\\n            return;\\n        } \\n        if (arr.size() - idx == pick){\\n            for (int i = idx; i < arr.size(); i++){\\n                sig += 1<<arr.get(i);\\n            }\\n            set.add(sig);\\n            return;\\n        }\\n        permuation(set,sig,idx+1,pick,arr);\\n        int nxt = sig + (1<<arr.get(idx));\\n        permuation(set,nxt,idx+1,pick-1,arr);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint indegree[];\\n    Set<Integer>[] edges;\\n    public int minNumberOfSemesters(int n, int[][] dependencies, int k) {\\n        edges = new Set[n];\\n        indegree = new int[n];\\n        int sig = 0;\\n        for (int i = 0; i < n; i++){\\n            sig += 1<<i;\\n            edges[i] = new HashSet<Integer>();\\n        }\\n        for (int[] d: dependencies){\\n            int s1 = d[0] - 1, s2 = d[1] - 1;\\n            indegree[s2]++;\\n            edges[s1].add(s2);\\n        }\\n        return dfs(n,k,sig);\\n    }\\n    int dfs(int n, int k, int sig){\\n        if (sig == 0) return 0;\\n        int cnt;\\n        List<Integer> nxt = new ArrayList<>(), priority = new ArrayList<>();\\n        for (int i = 0; i < n; i++){\\n            if ((sig & (1<<i)) != 0 && indegree[i] == 0){\\n                if (edges[i].size() != 0){\\n                    priority.add(i);\\n                }else{\\n                    nxt.add(i);\\n                }\\n            } \\n        }\\n        if (priority.size() == 0){\\n            cnt = nxt.size();\\n            if (cnt%k == 0){\\n                cnt/=k;\\n            }else{\\n                cnt/=k;\\n                cnt++;\\n            }\\n            return cnt;\\n        }\\n        if (priority.size() <= k){\\n            int minus = k - priority.size();\\n            for (int d: priority){\\n                sig -= 1<<d;\\n                for (int x: edges[d]){\\n                    indegree[x]--;\\n                }\\n            }\\n            for (int i = 0; i < Math.min(minus,nxt.size()); i++){\\n                sig-=1<<nxt.get(i);\\n            }\\n            cnt = 1+dfs(n,k,sig);\\n            for (int d: priority){\\n                for (int x: edges[d]){\\n                    indegree[x]++;\\n                }\\n            }\\n        }else{\\n            cnt = Integer.MAX_VALUE;\\n            Set<Integer> set = new HashSet<>();\\n            permuation(set,0,0,k,priority);\\n            for (int p:set){\\n                for (int d:priority){\\n                    if ((p&(1<<d)) != 0){\\n                        for (int x: edges[d]){\\n                            indegree[x]--;\\n                        }\\n                    }\\n                }\\n                cnt = Math.min(cnt,1+dfs(n,k,sig-p));\\n                for (int d:priority){\\n                    if ((p&(1<<d)) != 0){\\n                        for (int x: edges[d]){\\n                            indegree[x]++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n    void permuation(Set<Integer> set, int sig, int idx,int pick, List<Integer> arr){\\n        if (pick == 0){\\n            set.add(sig);\\n            return;\\n        } \\n        if (arr.size() - idx == pick){\\n            for (int i = idx; i < arr.size(); i++){\\n                sig += 1<<arr.get(i);\\n            }\\n            set.add(sig);\\n            return;\\n        }\\n        permuation(set,sig,idx+1,pick,arr);\\n        int nxt = sig + (1<<arr.get(idx));\\n        permuation(set,nxt,idx+1,pick-1,arr);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1112943,
                "title": "can-someone-tell-why-my-code-is-failing",
                "content": "**testcase:13\\n[[12,8],[2,4],[3,7],[6,8],[11,8],[9,4],[9,7],[12,4],[11,4],[6,4],[1,4],[10,7],[10,4],[1,7],[1,8],[2,7],[8,4],[10,8],[12,7],[5,4],[3,4],[11,7],[7,4],[13,4],[9,8],[13,8]]\\n9\\n**\\n```\\nclass Solution {\\n    public int minNumberOfSemesters(int n, int[][] dependencies, int k) {\\n        \\n            \\n          //kahns algo \\n            \\n          int[] indegree=new int[n+1] ;\\n            \\n            \\n          \\n            \\n            \\n            ArrayList<ArrayList<Integer>> graph=new ArrayList<>();\\n            \\n            for(int i=1;i<=n+1;i++){\\n                    graph.add(new ArrayList<>());\\n            }\\n            \\n           for(int i=0;i<dependencies.length;i++){\\n                    indegree[dependencies[i][1]]++;\\n                 int u=  dependencies[i][0];\\n            int v=  dependencies[i][1];\\n                   graph.get(u).add(v);\\n            }\\n            \\n            LinkedList<Integer> que=new LinkedList<>();\\n            \\n            int ans=1;\\n          \\n            for(int i=0;i<indegree.length;i++){\\n                    if(i!=0&&indegree[i]==0){\\n                         \\n                            que.add(i);\\n                    }\\n            }\\n            \\n          \\n        while(que.size()!=0){\\n                \\n                int size=que.size();\\n                  int count=0;\\n                \\n                \\n                while(size-->0){\\n                    int vrtx=que.removeFirst();   \\n                        \\n                      count++;\\n                        if(count>k){\\n                                ans++;\\n                                count=1;\\n                        }\\n                        \\n                        for(int child:graph.get(vrtx)){\\n                                if(--indegree[child]==0){\\n                                        que.add(child);\\n                                }\\n                                \\n                        }\\n                        \\n                        \\n                        \\n                        \\n                        \\n                        \\n                }\\n                if(que.size()!=0)\\n                       if(count!=0) \\n                ans++;\\n                \\n                \\n        }\\n            \\n            \\n            \\n            return ans;\\n            \\n            \\n      \\n            \\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minNumberOfSemesters(int n, int[][] dependencies, int k) {\\n        \\n            \\n          //kahns algo \\n            \\n          int[] indegree=new int[n+1] ;\\n            \\n            \\n          \\n            \\n            \\n            ArrayList<ArrayList<Integer>> graph=new ArrayList<>();\\n            \\n            for(int i=1;i<=n+1;i++){\\n                    graph.add(new ArrayList<>());\\n            }\\n            \\n           for(int i=0;i<dependencies.length;i++){\\n                    indegree[dependencies[i][1]]++;\\n                 int u=  dependencies[i][0];\\n            int v=  dependencies[i][1];\\n                   graph.get(u).add(v);\\n            }\\n            \\n            LinkedList<Integer> que=new LinkedList<>();\\n            \\n            int ans=1;\\n          \\n            for(int i=0;i<indegree.length;i++){\\n                    if(i!=0&&indegree[i]==0){\\n                         \\n                            que.add(i);\\n                    }\\n            }\\n            \\n          \\n        while(que.size()!=0){\\n                \\n                int size=que.size();\\n                  int count=0;\\n                \\n                \\n                while(size-->0){\\n                    int vrtx=que.removeFirst();   \\n                        \\n                      count++;\\n                        if(count>k){\\n                                ans++;\\n                                count=1;\\n                        }\\n                        \\n                        for(int child:graph.get(vrtx)){\\n                                if(--indegree[child]==0){\\n                                        que.add(child);\\n                                }\\n                                \\n                        }\\n                        \\n                        \\n                        \\n                        \\n                        \\n                        \\n                }\\n                if(que.size()!=0)\\n                       if(count!=0) \\n                ans++;\\n                \\n                \\n        }\\n            \\n            \\n            \\n            return ans;\\n            \\n            \\n      \\n            \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1033482,
                "title": "python3-top-down-dp-bitmask-500ms",
                "content": "```\\nclass Solution:\\n    def minNumberOfSemesters(self, n: int, dependencies: List[List[int]], k: int) -> int:\\n        post = defaultdict(list)\\n        degree = [0] * n\\n        for a, b in dependencies:\\n            degree[b-1] += 1\\n            post[a-1] += b-1,\\n        \\n        @lru_cache(None)\\n        def dfs(mask, degree):\\n            if not mask: return 0\\n            \\n            take = []\\n            for i in range(n):\\n                if mask & 1 << i and degree[i] == 0:\\n                    take += i,\\n                    \\n            res = inf\\n            for c in combinations(take, min(k, len(take))):\\n                m, d = mask, list(degree)\\n                for a in c:\\n                    m ^= 1 << a\\n                    for b in post[a]:\\n                        d[b] -= 1\\n                res = min(res, 1 + dfs(m, tuple(d)))\\n            return res\\n        \\n        return dfs((1 << n) - 1, tuple(degree))",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minNumberOfSemesters(self, n: int, dependencies: List[List[int]], k: int) -> int:\\n        post = defaultdict(list)\\n        degree = [0] * n\\n        for a, b in dependencies:\\n            degree[b-1] += 1\\n            post[a-1] += b-1,\\n        \\n        @lru_cache(None)\\n        def dfs(mask, degree):\\n            if not mask: return 0\\n            \\n            take = []\\n            for i in range(n):\\n                if mask & 1 << i and degree[i] == 0:\\n                    take += i,\\n                    \\n            res = inf\\n            for c in combinations(take, min(k, len(take))):\\n                m, d = mask, list(degree)\\n                for a in c:\\n                    m ^= 1 << a\\n                    for b in post[a]:\\n                        d[b] -= 1\\n                res = min(res, 1 + dfs(m, tuple(d)))\\n            return res\\n        \\n        return dfs((1 << n) - 1, tuple(degree))",
                "codeTag": "Java"
            },
            {
                "id": 950985,
                "title": "backtrack-bit-manipulation-dp-clean-and-easy-to-understand-with-description",
                "content": "```\\nfunc minNumberOfSemesters(n int, dependencies [][]int, k int) int {\\n\\tpres := make([]int, n, n)\\n\\tfor _, dep := range dependencies {\\n\\t\\tu, v := dep[0]-1, dep[1]-1 //1<=n<=15 to 0 <=n < 15\\n\\t\\tpres[v] |= 1 << u    //class v need prerequisite classes u (in bit representation)\\n\\t}\\n\\n    dp := make([]int, 1<<n, 1<<n) //stores how much semester is needed to take to taken i(in bit representation) classes\\n    for i := range dp{\\n        dp[i] = n //set each to max needed semester. that is n.\\n    }\\n    dp[0] = 1 //we start from 0, so set it to 1\\n\\n\\tvar backTrack func(taken, needSemester int)\\n\\n\\tbackTrack = func(taken, needSemester int) {\\n\\t\\t//bit representation of taken represents classes which have already been taken\\n        if needSemester >= dp[taken]{return} //there is a better solution in this situation \\n        \\n        dp[taken] = needSemester\\n\\n\\t\\tcanTake := 0 //canTake indicates that classes can be taken (in bit representaion) at situation taken\\n\\t\\tfor class, pre := range pres {\\n\\t\\t\\tif taken&pre == pre { //taken & pre == pre means that taken includes all prerequisite\\n\\t\\t\\t\\tcanTake |= 1 << class\\n\\t\\t\\t} //so we do canTake |= class. Add class to canTake.\\n\\t\\t}\\n\\n\\t\\tcanTake &= ^taken //we want to take classes which are not been taken\\n\\n\\t\\tneedSemester++\\n\\t\\t// count how much classes can be take as canTakeCnt\\n\\t\\tif canTakeCnt := bit1cntOfInt16(canTake); canTakeCnt <= k { \\n\\t\\t\\tbackTrack(taken|canTake, needSemester) //we can take all classes of canTake since canTakeCnt<=k\\n\\t\\t} else {\\n\\t\\t\\tfor subCanTake := canTake; subCanTake > 0; subCanTake = (subCanTake - 1) & canTake {\\n\\t\\t\\t\\t//emurate all combination of take k classes from canTake\\n\\t\\t\\t\\tif bit1cntOfInt16(subCanTake) == k { //take classes not lesser than k\\n\\t\\t\\t\\t\\tbackTrack(taken|subCanTake, needSemester)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tbackTrack(0, 0)\\n\\n    return dp[len(dp)-1]\\n}\\n\\nfunc bit1cntOfInt16(n int) int {\\n\\tcnt := 0\\n\\tfor i := 0; i < 15; i++ {\\n\\t\\tif test := 1 << i; test&n == test {\\n\\t\\t\\tcnt++\\n\\t\\t}\\n\\t}\\n\\treturn cnt\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc minNumberOfSemesters(n int, dependencies [][]int, k int) int {\\n\\tpres := make([]int, n, n)\\n\\tfor _, dep := range dependencies {\\n\\t\\tu, v := dep[0]-1, dep[1]-1 //1<=n<=15 to 0 <=n < 15\\n\\t\\tpres[v] |= 1 << u    //class v need prerequisite classes u (in bit representation)\\n\\t}\\n\\n    dp := make([]int, 1<<n, 1<<n) //stores how much semester is needed to take to taken i(in bit representation) classes\\n    for i := range dp{\\n        dp[i] = n //set each to max needed semester. that is n.\\n    }\\n    dp[0] = 1 //we start from 0, so set it to 1\\n\\n\\tvar backTrack func(taken, needSemester int)\\n\\n\\tbackTrack = func(taken, needSemester int) {\\n\\t\\t//bit representation of taken represents classes which have already been taken\\n        if needSemester >= dp[taken]{return} //there is a better solution in this situation \\n        \\n        dp[taken] = needSemester\\n\\n\\t\\tcanTake := 0 //canTake indicates that classes can be taken (in bit representaion) at situation taken\\n\\t\\tfor class, pre := range pres {\\n\\t\\t\\tif taken&pre == pre { //taken & pre == pre means that taken includes all prerequisite\\n\\t\\t\\t\\tcanTake |= 1 << class\\n\\t\\t\\t} //so we do canTake |= class. Add class to canTake.\\n\\t\\t}\\n\\n\\t\\tcanTake &= ^taken //we want to take classes which are not been taken\\n\\n\\t\\tneedSemester++\\n\\t\\t// count how much classes can be take as canTakeCnt\\n\\t\\tif canTakeCnt := bit1cntOfInt16(canTake); canTakeCnt <= k { \\n\\t\\t\\tbackTrack(taken|canTake, needSemester) //we can take all classes of canTake since canTakeCnt<=k\\n\\t\\t} else {\\n\\t\\t\\tfor subCanTake := canTake; subCanTake > 0; subCanTake = (subCanTake - 1) & canTake {\\n\\t\\t\\t\\t//emurate all combination of take k classes from canTake\\n\\t\\t\\t\\tif bit1cntOfInt16(subCanTake) == k { //take classes not lesser than k\\n\\t\\t\\t\\t\\tbackTrack(taken|subCanTake, needSemester)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tbackTrack(0, 0)\\n\\n    return dp[len(dp)-1]\\n}\\n\\nfunc bit1cntOfInt16(n int) int {\\n\\tcnt := 0\\n\\tfor i := 0; i < 15; i++ {\\n\\t\\tif test := 1 << i; test&n == test {\\n\\t\\t\\tcnt++\\n\\t\\t}\\n\\t}\\n\\treturn cnt\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 922756,
                "title": "python-top-down",
                "content": "Idea from other posts:\\n- greedy doesn\\'t work, you can try it your self\\n- so go with complete search + memo (top down dp)\\n- `dp[state]` : minimum number of semesters needed to complete `all courses` given that we already learnt some courses which is set in the bitmask `state`\\n  answer = `dp[0]`, start out without learning any courses\\n- at each step:\\n\\t- we find out which other courses we can study `can_study`\\n\\t- we will study at most `k` courses if we can because a course should be studied sooner than later `min(k, len(can_study))`\\n\\t- we don\\'t know which courses to pick to study, this is where greedy failed, we thought we could study `k` courses in any order but actually we can\\'t, order of courses to study matters, so we need to try out all of combinations and find the minimum overall\\n\\ncomplexity:\\n[proof](https://cp-algorithms.com/algebra/all-submasks.html#toc-tgt-1)\\n[ref](https://leetcode.com/problems/parallel-courses-ii/discuss/709382/C++-O(3n)-bitmask-dynamic-programming-code-with-comments-and-tutorial/607616)\\n- each state is a mask, `can_study` also represents a mask, number of courses (bits) is `m`, number of masks has `m` bits is `C(n, m)`\\n- number of combinations each mask: `C(m, k)`\\n- total: `n * ( C(1, k)*C(n, 1) + C(2, k)*C(n, 2) + .... + C(n, k)*C(n, n) )`\\n\\t\\t< `n * (2^1*C(n, 1) + 2^2*C(n,2) + ... + 2^n*C(n, n))`\\n\\t\\t= `n * 3^n`\\n\\n```python\\nclass Solution(object):\\n    def minNumberOfSemesters(self, n, dependencies, k):\\n        \"\"\"\\n        :type n: int\\n        :type dependencies: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        def dp(state):\\n            if state in memo: return memo[state]\\n            # print \\'---\\'\\n            # print bin(state)\\n            if state == (1 << n) - 1:\\n                memo[state] = 0\\n                return 0\\n            \\n            can_study = []\\n            for i in xrange(n):\\n                if state & 1 << i: continue # alr learnt\\n                if dep[i] & state == dep[i]: can_study.append(i)\\n            # print can_study\\n            \\n            res = float(\\'inf\\')\\n            for to_study in itertools.combinations(can_study, min(k, len(can_study))):\\n                new_state = state\\n                for i in to_study:\\n                    new_state |= 1 << i\\n                res = min(res, 1 + dp(new_state))\\n                \\n            memo[state] = res\\n            return res\\n        \\n        dep = [0]*n\\n        for i, j in dependencies:\\n            dep[j-1] |= 1 << i-1\\n        \\n        memo = {}\\n        return dp(0)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def minNumberOfSemesters(self, n, dependencies, k):\\n        \"\"\"\\n        :type n: int\\n        :type dependencies: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        def dp(state):\\n            if state in memo: return memo[state]\\n            # print \\'---\\'\\n            # print bin(state)\\n            if state == (1 << n) - 1:\\n                memo[state] = 0\\n                return 0\\n            \\n            can_study = []\\n            for i in xrange(n):\\n                if state & 1 << i: continue # alr learnt\\n                if dep[i] & state == dep[i]: can_study.append(i)\\n            # print can_study\\n            \\n            res = float(\\'inf\\')\\n            for to_study in itertools.combinations(can_study, min(k, len(can_study))):\\n                new_state = state\\n                for i in to_study:\\n                    new_state |= 1 << i\\n                res = min(res, 1 + dp(new_state))\\n                \\n            memo[state] = res\\n            return res\\n        \\n        dep = [0]*n\\n        for i, j in dependencies:\\n            dep[j-1] |= 1 << i-1\\n        \\n        memo = {}\\n        return dp(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 890824,
                "title": "sharing-my-python3-dfs-memorization-solution",
                "content": "First tried topological sort + greedy and then realized that it might not be the correct answer.\\n(https://leetcode.com/problems/parallel-courses-ii/discuss/708445/Weak-test-case-most-solutions-posted-using-depth-or-outdgree-are-wrong)\\n\\nSince the number of courses are less than 15, we can DFS to iterate all the possibilities for each layers. Then to optimize it, I used a dictionary to keep track of the previous minimal depth for visited nodes. If the current iteration depth is higher, we can skip the iteration.\\n\\nSince it is fairly easy to represent the states and choices at each states, it should be also solvable in Top-down DP.\\n\\n**DFS + memorization**\\n```\\nfrom collections import deque, defaultdict\\nimport itertools\\nclass Solution:\\n    def minNumberOfSemesters(self, n: int, dependencies: List[List[int]], k: int) -> int:\\n        # Initializing\\n        ins = collections.defaultdict(int)\\n        outs = collections.defaultdict(list)\\n        for x in range(1, n + 1):\\n            ins[x] = 0\\n        \\n        for a, b in dependencies:\\n            ins[b] += 1\\n            outs[a].append(b)\\n        \\n        # DFS\\n        self.states = {}\\n        self.dfs(ins, outs, k, [], 0)\\n        last_key = tuple( x for x in range(1, n + 1))\\n        return self.states[last_key]\\n    \\n        \\n    def dfs(self, ins, outs, k, last, dep):\\n        zero_outs = [ key for key, val in ins.items( ) if val == 0 ]\\n        combinations = self.getCombinations(zero_outs, k)\\n                \\n        for candidates in combinations:\\n            key = tuple(sorted(last + list(candidates)))\\n            if key in self.states and dep + 1 >= self.states[key]:  # visisted. Skip\\n                continue\\n            \\n            # Update then go to next level\\n            self.states[key] = dep + 1\\n            new_ins = { key: val for key, val in ins.items() }  # Deep Copy\\n            for candidate in candidates:\\n                del new_ins[candidate]\\n                for out in outs[candidate]:\\n                    new_ins[out] -= 1\\n            self.dfs(new_ins, outs, k, last + list(candidates), dep + 1)\\n\\n            \\n    def getCombinations(self, L, k):\\n        while k > len(L):\\n            k -= 1\\n        return list(itertools.combinations(L, k)) if k > 0 else []\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque, defaultdict\\nimport itertools\\nclass Solution:\\n    def minNumberOfSemesters(self, n: int, dependencies: List[List[int]], k: int) -> int:\\n        # Initializing\\n        ins = collections.defaultdict(int)\\n        outs = collections.defaultdict(list)\\n        for x in range(1, n + 1):\\n            ins[x] = 0\\n        \\n        for a, b in dependencies:\\n            ins[b] += 1\\n            outs[a].append(b)\\n        \\n        # DFS\\n        self.states = {}\\n        self.dfs(ins, outs, k, [], 0)\\n        last_key = tuple( x for x in range(1, n + 1))\\n        return self.states[last_key]\\n    \\n        \\n    def dfs(self, ins, outs, k, last, dep):\\n        zero_outs = [ key for key, val in ins.items( ) if val == 0 ]\\n        combinations = self.getCombinations(zero_outs, k)\\n                \\n        for candidates in combinations:\\n            key = tuple(sorted(last + list(candidates)))\\n            if key in self.states and dep + 1 >= self.states[key]:  # visisted. Skip\\n                continue\\n            \\n            # Update then go to next level\\n            self.states[key] = dep + 1\\n            new_ins = { key: val for key, val in ins.items() }  # Deep Copy\\n            for candidate in candidates:\\n                del new_ins[candidate]\\n                for out in outs[candidate]:\\n                    new_ins[out] -= 1\\n            self.dfs(new_ins, outs, k, last + list(candidates), dep + 1)\\n\\n            \\n    def getCombinations(self, L, k):\\n        while k > len(L):\\n            k -= 1\\n        return list(itertools.combinations(L, k)) if k > 0 else []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 844296,
                "title": "bit-mask-solution-but-tle-needs-someone-s-help",
                "content": "```\\nclass Solution {\\n    int res = 0;\\n    int[] indegree;\\n    Map<Integer,Set<Integer>> map = new HashMap<>();\\n    int sum_state = 0;\\n    int k;\\n    public int minNumberOfSemesters(int n, int[][] dependencies, int k) {\\n           if(n==0){\\n               return 0;\\n           }\\n           if(dependencies.length == 0){\\n               return n%k==0?n/k:n/k+1;\\n           }\\n           this.k = k;\\n           \\n           indegree = new int[n+1];\\n           for(int[] ele: dependencies){\\n               int pre = ele[0], cur = ele[1];\\n               indegree[ele[1]]++;\\n               if(map.containsKey(ele[0])==false){\\n                   map.put(pre, new HashSet<>());\\n               }\\n               map.get(pre).add(cur);\\n           }\\n          \\n           for(int i=1;i<=n;i++){\\n               sum_state = (sum_state | (1<<i));\\n           }\\n        \\n           res = n;\\n           int level = 1;\\n        \\n           int size = 0;\\n           List<Integer> cur_list = new ArrayList<>();\\n           for(int i=1;i<indegree.length;i++){\\n                if(indegree[i]==0){\\n                    size++;\\n                    cur_list.add(i);\\n                 }\\n            }\\n        \\n        \\n           \\n           \\n           backTracking(cur_list, 0, Math.min(size, this.k), 0, 0, 1);\\n           return res;\\n    \\n    }\\n    \\n    \\n    public void backTracking(List<Integer> cur_list, int start_i, int threshold, int state, int cur_count, int level){\\n         \\n         if(state == sum_state){\\n             res = Math.min(res, level);\\n             //System.out.println(res);\\n             return;\\n         }\\n         \\n         if(cur_count == threshold){\\n             level++;\\n             cur_count= 0;\\n             int size = 0;\\n             cur_list = new ArrayList<>();\\n             for(int i=1;i<indegree.length;i++){\\n                 if(indegree[i]==0 && ((state&(1<<i))==0)){\\n                     cur_list.add(i);\\n                     size++;\\n                 }\\n             }\\n             threshold = Math.min(this.k, size);\\n             start_i = 0;\\n         }\\n        \\n\\n       \\n        \\n\\n         \\n         \\n         for(Integer i: cur_list){\\n             if(i<=start_i){\\n                 continue;\\n             }\\n             \\n             int new_state = (state | (1<<i));\\n             \\n             if(map.containsKey(i)){\\n                 for(int child: map.get(i)){\\n                     indegree[child]--;\\n                 }\\n             }\\n             \\n             cur_count++;\\n             backTracking(cur_list, i, threshold, new_state, cur_count, level);\\n             cur_count--;\\n             \\n             if(map.containsKey(i)){\\n                 for(int child: map.get(i)){\\n                     indegree[child]++;\\n                 }\\n             }\\n             \\n         }\\n        \\n         \\n         \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int res = 0;\\n    int[] indegree;\\n    Map<Integer,Set<Integer>> map = new HashMap<>();\\n    int sum_state = 0;\\n    int k;\\n    public int minNumberOfSemesters(int n, int[][] dependencies, int k) {\\n           if(n==0){\\n               return 0;\\n           }\\n           if(dependencies.length == 0){\\n               return n%k==0?n/k:n/k+1;\\n           }\\n           this.k = k;\\n           \\n           indegree = new int[n+1];\\n           for(int[] ele: dependencies){\\n               int pre = ele[0], cur = ele[1];\\n               indegree[ele[1]]++;\\n               if(map.containsKey(ele[0])==false){\\n                   map.put(pre, new HashSet<>());\\n               }\\n               map.get(pre).add(cur);\\n           }\\n          \\n           for(int i=1;i<=n;i++){\\n               sum_state = (sum_state | (1<<i));\\n           }\\n        \\n           res = n;\\n           int level = 1;\\n        \\n           int size = 0;\\n           List<Integer> cur_list = new ArrayList<>();\\n           for(int i=1;i<indegree.length;i++){\\n                if(indegree[i]==0){\\n                    size++;\\n                    cur_list.add(i);\\n                 }\\n            }\\n        \\n        \\n           \\n           \\n           backTracking(cur_list, 0, Math.min(size, this.k), 0, 0, 1);\\n           return res;\\n    \\n    }\\n    \\n    \\n    public void backTracking(List<Integer> cur_list, int start_i, int threshold, int state, int cur_count, int level){\\n         \\n         if(state == sum_state){\\n             res = Math.min(res, level);\\n             //System.out.println(res);\\n             return;\\n         }\\n         \\n         if(cur_count == threshold){\\n             level++;\\n             cur_count= 0;\\n             int size = 0;\\n             cur_list = new ArrayList<>();\\n             for(int i=1;i<indegree.length;i++){\\n                 if(indegree[i]==0 && ((state&(1<<i))==0)){\\n                     cur_list.add(i);\\n                     size++;\\n                 }\\n             }\\n             threshold = Math.min(this.k, size);\\n             start_i = 0;\\n         }\\n        \\n\\n       \\n        \\n\\n         \\n         \\n         for(Integer i: cur_list){\\n             if(i<=start_i){\\n                 continue;\\n             }\\n             \\n             int new_state = (state | (1<<i));\\n             \\n             if(map.containsKey(i)){\\n                 for(int child: map.get(i)){\\n                     indegree[child]--;\\n                 }\\n             }\\n             \\n             cur_count++;\\n             backTracking(cur_list, i, threshold, new_state, cur_count, level);\\n             cur_count--;\\n             \\n             if(map.containsKey(i)){\\n                 for(int child: map.get(i)){\\n                     indegree[child]++;\\n                 }\\n             }\\n             \\n         }\\n        \\n         \\n         \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 843212,
                "title": "i-dont-know-why-my-solution-is-incorrect",
                "content": "I  am unclear as to why my solution is incorrect this is incorrect and how this testcase leads to 6 rather than 9\\n```\\n12\\n[[1,2],[1,3],[7,5],[7,6],[4,8],[8,9],[9,10],[10,11],[11,12]]\\n2\\n\\nclass Solution:\\n    def minNumberOfSemesters(self, n: int, dependencies: List[List[int]], k: int) -> int:\\n        prereqs, classes, count, processing, processed = defaultdict(list), defaultdict(list), 0, [False for _ in range(n)], [False for _ in range(n)]\\n        \\n        curr = k\\n        for x, y in dependencies:\\n            prereqs[y].append(x)\\n            classes[x].append(y)\\n\\n        starters = []\\n        for i in range(1, n + 1):\\n            if not prereqs[i]:\\n                starters.append(i)\\n                \\n        q = deque(starters)\\n        current_levels = [0 for i in range(n)]\\n        \\n        for node in starters: \\n            processing[node - 1] = True\\n        levels = defaultdict(int)\\n        levelsa = defaultdict(list)\\n        \\n        while q:\\n            node = q.popleft()\\n            level = current_levels[node - 1]\\n            add_again = True\\n            \\n            if not prereqs[node] or all([ processed[i - 1] for i in prereqs[node]]):\\n                processing[node - 1] = False\\n                processed[node - 1] = True\\n                add_again = False\\n            \\n            for req in classes[node]:\\n                current_levels[req - 1] = max(level + 1, current_levels[req - 1])\\n                if not  processing[req - 1]:\\n                    processing[req - 1] = True\\n                    q.append(req)\\n                    \\n            \\n            if add_again:\\n                q.append(node)\\n            else:\\n                levels[level] += 1\\n                levelsa[level].append(node)\\n         \\n        \\n        for val in levels.values():\\n            count += max(1, (val // k) + 1) if val % k != 0 else max(1, (val // k))\\n        \\n        \\n        return count   \\n",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "I  am unclear as to why my solution is incorrect this is incorrect and how this testcase leads to 6 rather than 9\\n```\\n12\\n[[1,2],[1,3],[7,5],[7,6],[4,8],[8,9],[9,10],[10,11],[11,12]]\\n2\\n\\nclass Solution:\\n    def minNumberOfSemesters(self, n: int, dependencies: List[List[int]], k: int) -> int:\\n        prereqs, classes, count, processing, processed = defaultdict(list), defaultdict(list), 0, [False for _ in range(n)], [False for _ in range(n)]\\n        \\n        curr = k\\n        for x, y in dependencies:\\n            prereqs[y].append(x)\\n            classes[x].append(y)\\n\\n        starters = []\\n        for i in range(1, n + 1):\\n            if not prereqs[i]:\\n                starters.append(i)\\n                \\n        q = deque(starters)\\n        current_levels = [0 for i in range(n)]\\n        \\n        for node in starters: \\n            processing[node - 1] = True\\n        levels = defaultdict(int)\\n        levelsa = defaultdict(list)\\n        \\n        while q:\\n            node = q.popleft()\\n            level = current_levels[node - 1]\\n            add_again = True\\n            \\n            if not prereqs[node] or all([ processed[i - 1] for i in prereqs[node]]):\\n                processing[node - 1] = False\\n                processed[node - 1] = True\\n                add_again = False\\n            \\n            for req in classes[node]:\\n                current_levels[req - 1] = max(level + 1, current_levels[req - 1])\\n                if not  processing[req - 1]:\\n                    processing[req - 1] = True\\n                    q.append(req)\\n                    \\n            \\n            if add_again:\\n                q.append(node)\\n            else:\\n                levels[level] += 1\\n                levelsa[level].append(node)\\n         \\n        \\n        for val in levels.values():\\n            count += max(1, (val // k) + 1) if val % k != 0 else max(1, (val // k))\\n        \\n        \\n        return count   \\n",
                "codeTag": "Java"
            },
            {
                "id": 824372,
                "title": "c-optimization-34-66-90-3-code",
                "content": "34/66\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>a;set<int>s;\\n    int minNumberOfSemesters(int n, vector<vector<int>>& dependencies, int k) {\\n        a=vector<vector<int>>(n+1);\\n        s=set<int>();\\n        for(int i=1;i<=n;i++)s.insert(i);\\n        for(vector<int> &i:dependencies){\\n            a[i[0]].push_back(i[1]);if(s.count(i[1])==1)s.erase(i[1]);\\n        }\\n        queue<int>q;int ans=0;\\n        vector<int>vis(n+1,0);\\n        for(auto i:s)q.push(i),vis[i]=1;\\n        while(q.empty()==0){\\n            int z=q.size();\\n            ans+=(z+k-1)/k;\\n            vector<int>tmp;\\n            while(z--){\\n                int u=q.front();\\n                q.pop();\\n                for(auto i:a[u])if(vis[i]==0){\\n                    tmp.push_back(i);\\n                }\\n            }\\n            for(auto i:tmp)if(vis[i]==0)q.push(i),vis[i]=1;\\n        }\\n        return ans;\\n    }\\n};``\\n```\\n57/66\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>a;int n,k;\\n    int f(int mask){\\n        if(mask+1==(1<<n))return 0;\\n        vector<int>in(n,0);\\n        for(int i=0;i<n;i++)for(auto j:a[i])if(((1<<i)&mask)==0)\\n            in[j]++;\\n        int cnt=0,new_mask=0,ans=1e9;\\n        for(int i=0;i<n;i++)if(in[i]==0 and ((1<<i)&mask)==0)cnt++,new_mask|=(1<<i);\\n        if(cnt<=k)return 1+f(mask|new_mask);\\n        for(int s=new_mask;s!=0;s=(s-1)&new_mask)if(__builtin_popcount(s)==k)\\n            ans=min(ans,1+f(s|mask));\\n        return ans;\\n    }\\n    int minNumberOfSemesters(int N, vector<vector<int>>& dependencies, int K) {\\n        a=vector<vector<int>>(N);k=K;n=N;\\n        for(vector<int> &i:dependencies){\\n            a[i[0]-1].push_back(i[1]-1);\\n        }\\n        return f(0);\\n    }\\n};\\n```\\n90 % bitmasking\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>a;int n,k,dp[1<<15];\\n    int f(int mask){\\n        if(dp[mask]!=-1)return dp[mask];\\n        if(mask+1==(1<<n))return dp[mask]=0;\\n        vector<int>in(n,0);\\n        for(int i=0;i<n;i++)for(auto j:a[i])if(((1<<i)&mask)==0)\\n            in[j]++;\\n        int cnt=0,new_mask=0,ans=1e9;\\n        for(int i=0;i<n;i++)if(in[i]==0 and ((1<<i)&mask)==0)cnt++,new_mask|=(1<<i);\\n        if(cnt<=k)return dp[mask]=1+f(mask|new_mask);\\n        for(int s=new_mask;s!=0;s=(s-1)&new_mask)if(__builtin_popcount(s)==k)\\n            ans=min(ans,1+f(s|mask));\\n        return dp[mask]=ans;\\n    }\\n    int minNumberOfSemesters(int N, vector<vector<int>>& dependencies, int K) {\\n        a=vector<vector<int>>(N);k=K;n=N;fill(dp,dp+(1<<15),-1);\\n        for(vector<int> &i:dependencies){\\n            a[i[0]-1].push_back(i[1]-1);\\n        }\\n        return f(0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>a;set<int>s;\\n    int minNumberOfSemesters(int n, vector<vector<int>>& dependencies, int k) {\\n        a=vector<vector<int>>(n+1);\\n        s=set<int>();\\n        for(int i=1;i<=n;i++)s.insert(i);\\n        for(vector<int> &i:dependencies){\\n            a[i[0]].push_back(i[1]);if(s.count(i[1])==1)s.erase(i[1]);\\n        }\\n        queue<int>q;int ans=0;\\n        vector<int>vis(n+1,0);\\n        for(auto i:s)q.push(i),vis[i]=1;\\n        while(q.empty()==0){\\n            int z=q.size();\\n            ans+=(z+k-1)/k;\\n            vector<int>tmp;\\n            while(z--){\\n                int u=q.front();\\n                q.pop();\\n                for(auto i:a[u])if(vis[i]==0){\\n                    tmp.push_back(i);\\n                }\\n            }\\n            for(auto i:tmp)if(vis[i]==0)q.push(i),vis[i]=1;\\n        }\\n        return ans;\\n    }\\n};``\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>a;int n,k;\\n    int f(int mask){\\n        if(mask+1==(1<<n))return 0;\\n        vector<int>in(n,0);\\n        for(int i=0;i<n;i++)for(auto j:a[i])if(((1<<i)&mask)==0)\\n            in[j]++;\\n        int cnt=0,new_mask=0,ans=1e9;\\n        for(int i=0;i<n;i++)if(in[i]==0 and ((1<<i)&mask)==0)cnt++,new_mask|=(1<<i);\\n        if(cnt<=k)return 1+f(mask|new_mask);\\n        for(int s=new_mask;s!=0;s=(s-1)&new_mask)if(__builtin_popcount(s)==k)\\n            ans=min(ans,1+f(s|mask));\\n        return ans;\\n    }\\n    int minNumberOfSemesters(int N, vector<vector<int>>& dependencies, int K) {\\n        a=vector<vector<int>>(N);k=K;n=N;\\n        for(vector<int> &i:dependencies){\\n            a[i[0]-1].push_back(i[1]-1);\\n        }\\n        return f(0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>a;int n,k,dp[1<<15];\\n    int f(int mask){\\n        if(dp[mask]!=-1)return dp[mask];\\n        if(mask+1==(1<<n))return dp[mask]=0;\\n        vector<int>in(n,0);\\n        for(int i=0;i<n;i++)for(auto j:a[i])if(((1<<i)&mask)==0)\\n            in[j]++;\\n        int cnt=0,new_mask=0,ans=1e9;\\n        for(int i=0;i<n;i++)if(in[i]==0 and ((1<<i)&mask)==0)cnt++,new_mask|=(1<<i);\\n        if(cnt<=k)return dp[mask]=1+f(mask|new_mask);\\n        for(int s=new_mask;s!=0;s=(s-1)&new_mask)if(__builtin_popcount(s)==k)\\n            ans=min(ans,1+f(s|mask));\\n        return dp[mask]=ans;\\n    }\\n    int minNumberOfSemesters(int N, vector<vector<int>>& dependencies, int K) {\\n        a=vector<vector<int>>(N);k=K;n=N;fill(dp,dp+(1<<15),-1);\\n        for(vector<int> &i:dependencies){\\n            a[i[0]-1].push_back(i[1]-1);\\n        }\\n        return f(0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 793181,
                "title": "c-dynamic-programming",
                "content": "```\\nint memo[32768][15];\\nint minNumberOfSemesters(int n, vector<vector<int>>& arr, int k) \\n{\\n    int prereq[15];\\n\\tmemset(prereq,0,sizeof(prereq));\\n    for(vector<int> x:arr)\\n        prereq[x[1]-1]|=1<<(x[0]-1);\\n    int allmask=(1<<n)-1;\\n    memset(memo,-1,sizeof(memo));\\n    return dfs(0,allmask,prereq,0,n,0,k);\\n}\\nint dfs(int mask,int allmask,int* prereq,int submask,int n,int count,int k)\\n{\\n\\tif(mask==allmask)\\n\\t\\treturn 0;\\n    else if(memo[mask][count]!=-1)\\n        return memo[mask][count];\\n\\telse if(submask)\\n\\t{\\n\\t\\tint q=n;\\n\\t\\tfor(int i=0;i<n;++i)\\n\\t\\t\\tif(submask&1<<i)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint newMask=submask&(~(1<<i));\\n\\t\\t\\t\\tif(count+1==k||newMask==0)\\n\\t\\t\\t\\t\\tq=min(q,1+dfs(mask|1<<i,allmask,prereq,0,n,0,k));\\n\\t\\t\\t\\telse q=min(q,dfs(mask|1<<i,allmask,prereq,newMask,n,count+1,k));\\n\\t\\t\\t}\\n\\t\\treturn memo[mask][count]=q;\\n\\t}\\n\\telse\\n\\t{\\n\\t\\tint submask=0,temp=0,ret=n;\\n\\t\\tfor(int i=0;i<n;++i)\\n\\t\\t\\tif((mask&1<<i)==0&&((prereq[i]&mask)==prereq[i]))\\n\\t\\t\\t{\\n\\t\\t\\t\\tsubmask|=1<<i;\\n\\t\\t\\t\\t++temp;\\n\\t\\t\\t}\\n\\t\\tif(temp<=k)\\n\\t\\t\\treturn memo[mask][count]=1+dfs(mask|submask,allmask,prereq,0,n,0,k);\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tint q=n;\\n\\t\\t\\tfor(int i=0;i<n;++i)\\n\\t\\t\\t\\tif(submask&1<<i)\\n\\t\\t\\t\\t\\tif(k>1)\\n\\t\\t\\t\\t\\t\\tq=min(q,dfs(mask|1<<i,allmask,prereq,submask&(~(1<<i)),n,1,k));\\n\\t\\t\\t\\t\\telse q=min(q,1+dfs(mask|1<<i,allmask,prereq,submask&(~(1<<i)),n,0,k));\\n\\t\\t\\treturn memo[mask][count]=q;\\n\\t\\t}\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint memo[32768][15];\\nint minNumberOfSemesters(int n, vector<vector<int>>& arr, int k) \\n{\\n    int prereq[15];\\n\\tmemset(prereq,0,sizeof(prereq));\\n    for(vector<int> x:arr)\\n        prereq[x[1]-1]|=1<<(x[0]-1);\\n    int allmask=(1<<n)-1;\\n    memset(memo,-1,sizeof(memo));\\n    return dfs(0,allmask,prereq,0,n,0,k);\\n}\\nint dfs(int mask,int allmask,int* prereq,int submask,int n,int count,int k)\\n{\\n\\tif(mask==allmask)\\n\\t\\treturn 0;\\n    else if(memo[mask][count]!=-1)\\n        return memo[mask][count];\\n\\telse if(submask)\\n\\t{\\n\\t\\tint q=n;\\n\\t\\tfor(int i=0;i<n;++i)\\n\\t\\t\\tif(submask&1<<i)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint newMask=submask&(~(1<<i));\\n\\t\\t\\t\\tif(count+1==k||newMask==0)\\n\\t\\t\\t\\t\\tq=min(q,1+dfs(mask|1<<i,allmask,prereq,0,n,0,k));\\n\\t\\t\\t\\telse q=min(q,dfs(mask|1<<i,allmask,prereq,newMask,n,count+1,k));\\n\\t\\t\\t}\\n\\t\\treturn memo[mask][count]=q;\\n\\t}\\n\\telse\\n\\t{\\n\\t\\tint submask=0,temp=0,ret=n;\\n\\t\\tfor(int i=0;i<n;++i)\\n\\t\\t\\tif((mask&1<<i)==0&&((prereq[i]&mask)==prereq[i]))\\n\\t\\t\\t{\\n\\t\\t\\t\\tsubmask|=1<<i;\\n\\t\\t\\t\\t++temp;\\n\\t\\t\\t}\\n\\t\\tif(temp<=k)\\n\\t\\t\\treturn memo[mask][count]=1+dfs(mask|submask,allmask,prereq,0,n,0,k);\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tint q=n;\\n\\t\\t\\tfor(int i=0;i<n;++i)\\n\\t\\t\\t\\tif(submask&1<<i)\\n\\t\\t\\t\\t\\tif(k>1)\\n\\t\\t\\t\\t\\t\\tq=min(q,dfs(mask|1<<i,allmask,prereq,submask&(~(1<<i)),n,1,k));\\n\\t\\t\\t\\t\\telse q=min(q,1+dfs(mask|1<<i,allmask,prereq,submask&(~(1<<i)),n,0,k));\\n\\t\\t\\treturn memo[mask][count]=q;\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1564895,
                "content": [
                    {
                        "username": "hqztrue",
                        "content": "This is called the DAG scheduling problem."
                    },
                    {
                        "username": "phung_manh_cuong",
                        "content": "From white paper: https://core.ac.uk/reader/82723490"
                    },
                    {
                        "username": "hobiter",
                        "content": "I have seen most the published solution use greedy sort or heap, for examle: \\nfinish the prerequisite with deepest depth first, then with most courses depend on it (out degree) ..\\n\\nTha above greedy strategy based on assumption that:\\n1, you can find the best solution, without knowing the details/arrangement from next semester...\\n\\nHowever, this assumption is not true, you have to know the next semester\\'s arrangement before you find this semester\\'s best. \\n\\nTherefore, you have to use a DFS to compare result by each different arrangement of this semester. Then best way to use some storage, such as multi-dementional array, to cache the result to avoid duplicate calculation, however it should not be linear dimentional array, then become an NP problem.\\n\\n\\n"
                    },
                    {
                        "username": "aumo",
                        "content": "can confirm this, my max heap sorted by depth and # outgoing edges fails on test 79 of 81"
                    },
                    {
                        "username": "azhw1983",
                        "content": "why everyone is using bitmask? no other way to avoid that?"
                    },
                    {
                        "username": "sqqqa23",
                        "content": "12\\n[[1,2],[1,3],[7,5],[7,6],[4,8],[8,9],[9,10],[10,11],[11,12]]\\n2\\nfor this testcase  expected ans is \"6\" i am not sure how is that expected  as in directed graph \\'4->8->9->10->11->12\\' this chain is there this itself should be taking 6 semester so according to me  ans must be greater than this"
                    },
                    {
                        "username": "harsha335",
                        "content": "above graphs are\\n1 --2,3\\n7 --5,6\\n4 - 8 - 9 - 10 - 11 -12\\n1st sem - complete 1 & 4 in a sem 7, 2 , 3 , 8 unlocked for next sem.\\n2nd - read 2 & 8 . current unlocked sub are 3 ,9,7.\\n3rd - read 3 & 9. unlocked sub are 7,10\\n4th - read 7 & 10. unlocked sub are 5,6,11\\n5th - read 5 & 11. unlocked sub are 6,12\\n6th sem - read 6 & 12\\nall sub are completed in 6 semesters."
                    },
                    {
                        "username": "yuhwu",
                        "content": "Greedy without proving correctness => WRONG ANSWER. LC please improve the test cases."
                    },
                    {
                        "username": "sooraj123456789",
                        "content": "13\\n[[12,8],[2,4],[3,7],[6,8],[11,8],[9,4],[9,7],[12,4],[11,4],[6,4],[1,4],[10,7],[10,4],[1,7],[1,8],[2,7],[8,4],[10,8],[12,7],[5,4],[3,4],[11,7],[7,4],[13,4],[9,8],[13,8]]\\n9 \\nCan anyone explain me that why its output is 3. I am getting 4 as in one semester there are total 10 subjects and it can take maximum 9 so, 2 semesters are required and for remaining semesters there are 2 and 1 subjects so total 4 semesters are required but answer is 3 .How?\\n"
                    },
                    {
                        "username": "seafmch",
                        "content": "Description:\\n\\nIn one semester, you can take at most k courses as long as you have taken all the prerequisites in the previous semester for the courses you are taking.\\n\\nWRONG. Should be \"previous SEMESTERS\". No guarantee you took all the prereqs in the exact previous semester."
                    }
                ]
            },
            {
                "id": 1575859,
                "content": [
                    {
                        "username": "hqztrue",
                        "content": "This is called the DAG scheduling problem."
                    },
                    {
                        "username": "phung_manh_cuong",
                        "content": "From white paper: https://core.ac.uk/reader/82723490"
                    },
                    {
                        "username": "hobiter",
                        "content": "I have seen most the published solution use greedy sort or heap, for examle: \\nfinish the prerequisite with deepest depth first, then with most courses depend on it (out degree) ..\\n\\nTha above greedy strategy based on assumption that:\\n1, you can find the best solution, without knowing the details/arrangement from next semester...\\n\\nHowever, this assumption is not true, you have to know the next semester\\'s arrangement before you find this semester\\'s best. \\n\\nTherefore, you have to use a DFS to compare result by each different arrangement of this semester. Then best way to use some storage, such as multi-dementional array, to cache the result to avoid duplicate calculation, however it should not be linear dimentional array, then become an NP problem.\\n\\n\\n"
                    },
                    {
                        "username": "aumo",
                        "content": "can confirm this, my max heap sorted by depth and # outgoing edges fails on test 79 of 81"
                    },
                    {
                        "username": "azhw1983",
                        "content": "why everyone is using bitmask? no other way to avoid that?"
                    },
                    {
                        "username": "sqqqa23",
                        "content": "12\\n[[1,2],[1,3],[7,5],[7,6],[4,8],[8,9],[9,10],[10,11],[11,12]]\\n2\\nfor this testcase  expected ans is \"6\" i am not sure how is that expected  as in directed graph \\'4->8->9->10->11->12\\' this chain is there this itself should be taking 6 semester so according to me  ans must be greater than this"
                    },
                    {
                        "username": "harsha335",
                        "content": "above graphs are\\n1 --2,3\\n7 --5,6\\n4 - 8 - 9 - 10 - 11 -12\\n1st sem - complete 1 & 4 in a sem 7, 2 , 3 , 8 unlocked for next sem.\\n2nd - read 2 & 8 . current unlocked sub are 3 ,9,7.\\n3rd - read 3 & 9. unlocked sub are 7,10\\n4th - read 7 & 10. unlocked sub are 5,6,11\\n5th - read 5 & 11. unlocked sub are 6,12\\n6th sem - read 6 & 12\\nall sub are completed in 6 semesters."
                    },
                    {
                        "username": "yuhwu",
                        "content": "Greedy without proving correctness => WRONG ANSWER. LC please improve the test cases."
                    },
                    {
                        "username": "sooraj123456789",
                        "content": "13\\n[[12,8],[2,4],[3,7],[6,8],[11,8],[9,4],[9,7],[12,4],[11,4],[6,4],[1,4],[10,7],[10,4],[1,7],[1,8],[2,7],[8,4],[10,8],[12,7],[5,4],[3,4],[11,7],[7,4],[13,4],[9,8],[13,8]]\\n9 \\nCan anyone explain me that why its output is 3. I am getting 4 as in one semester there are total 10 subjects and it can take maximum 9 so, 2 semesters are required and for remaining semesters there are 2 and 1 subjects so total 4 semesters are required but answer is 3 .How?\\n"
                    },
                    {
                        "username": "seafmch",
                        "content": "Description:\\n\\nIn one semester, you can take at most k courses as long as you have taken all the prerequisites in the previous semester for the courses you are taking.\\n\\nWRONG. Should be \"previous SEMESTERS\". No guarantee you took all the prereqs in the exact previous semester."
                    }
                ]
            },
            {
                "id": 1573981,
                "content": [
                    {
                        "username": "hqztrue",
                        "content": "This is called the DAG scheduling problem."
                    },
                    {
                        "username": "phung_manh_cuong",
                        "content": "From white paper: https://core.ac.uk/reader/82723490"
                    },
                    {
                        "username": "hobiter",
                        "content": "I have seen most the published solution use greedy sort or heap, for examle: \\nfinish the prerequisite with deepest depth first, then with most courses depend on it (out degree) ..\\n\\nTha above greedy strategy based on assumption that:\\n1, you can find the best solution, without knowing the details/arrangement from next semester...\\n\\nHowever, this assumption is not true, you have to know the next semester\\'s arrangement before you find this semester\\'s best. \\n\\nTherefore, you have to use a DFS to compare result by each different arrangement of this semester. Then best way to use some storage, such as multi-dementional array, to cache the result to avoid duplicate calculation, however it should not be linear dimentional array, then become an NP problem.\\n\\n\\n"
                    },
                    {
                        "username": "aumo",
                        "content": "can confirm this, my max heap sorted by depth and # outgoing edges fails on test 79 of 81"
                    },
                    {
                        "username": "azhw1983",
                        "content": "why everyone is using bitmask? no other way to avoid that?"
                    },
                    {
                        "username": "sqqqa23",
                        "content": "12\\n[[1,2],[1,3],[7,5],[7,6],[4,8],[8,9],[9,10],[10,11],[11,12]]\\n2\\nfor this testcase  expected ans is \"6\" i am not sure how is that expected  as in directed graph \\'4->8->9->10->11->12\\' this chain is there this itself should be taking 6 semester so according to me  ans must be greater than this"
                    },
                    {
                        "username": "harsha335",
                        "content": "above graphs are\\n1 --2,3\\n7 --5,6\\n4 - 8 - 9 - 10 - 11 -12\\n1st sem - complete 1 & 4 in a sem 7, 2 , 3 , 8 unlocked for next sem.\\n2nd - read 2 & 8 . current unlocked sub are 3 ,9,7.\\n3rd - read 3 & 9. unlocked sub are 7,10\\n4th - read 7 & 10. unlocked sub are 5,6,11\\n5th - read 5 & 11. unlocked sub are 6,12\\n6th sem - read 6 & 12\\nall sub are completed in 6 semesters."
                    },
                    {
                        "username": "yuhwu",
                        "content": "Greedy without proving correctness => WRONG ANSWER. LC please improve the test cases."
                    },
                    {
                        "username": "sooraj123456789",
                        "content": "13\\n[[12,8],[2,4],[3,7],[6,8],[11,8],[9,4],[9,7],[12,4],[11,4],[6,4],[1,4],[10,7],[10,4],[1,7],[1,8],[2,7],[8,4],[10,8],[12,7],[5,4],[3,4],[11,7],[7,4],[13,4],[9,8],[13,8]]\\n9 \\nCan anyone explain me that why its output is 3. I am getting 4 as in one semester there are total 10 subjects and it can take maximum 9 so, 2 semesters are required and for remaining semesters there are 2 and 1 subjects so total 4 semesters are required but answer is 3 .How?\\n"
                    },
                    {
                        "username": "seafmch",
                        "content": "Description:\\n\\nIn one semester, you can take at most k courses as long as you have taken all the prerequisites in the previous semester for the courses you are taking.\\n\\nWRONG. Should be \"previous SEMESTERS\". No guarantee you took all the prereqs in the exact previous semester."
                    }
                ]
            },
            {
                "id": 1576204,
                "content": [
                    {
                        "username": "hqztrue",
                        "content": "This is called the DAG scheduling problem."
                    },
                    {
                        "username": "phung_manh_cuong",
                        "content": "From white paper: https://core.ac.uk/reader/82723490"
                    },
                    {
                        "username": "hobiter",
                        "content": "I have seen most the published solution use greedy sort or heap, for examle: \\nfinish the prerequisite with deepest depth first, then with most courses depend on it (out degree) ..\\n\\nTha above greedy strategy based on assumption that:\\n1, you can find the best solution, without knowing the details/arrangement from next semester...\\n\\nHowever, this assumption is not true, you have to know the next semester\\'s arrangement before you find this semester\\'s best. \\n\\nTherefore, you have to use a DFS to compare result by each different arrangement of this semester. Then best way to use some storage, such as multi-dementional array, to cache the result to avoid duplicate calculation, however it should not be linear dimentional array, then become an NP problem.\\n\\n\\n"
                    },
                    {
                        "username": "aumo",
                        "content": "can confirm this, my max heap sorted by depth and # outgoing edges fails on test 79 of 81"
                    },
                    {
                        "username": "azhw1983",
                        "content": "why everyone is using bitmask? no other way to avoid that?"
                    },
                    {
                        "username": "sqqqa23",
                        "content": "12\\n[[1,2],[1,3],[7,5],[7,6],[4,8],[8,9],[9,10],[10,11],[11,12]]\\n2\\nfor this testcase  expected ans is \"6\" i am not sure how is that expected  as in directed graph \\'4->8->9->10->11->12\\' this chain is there this itself should be taking 6 semester so according to me  ans must be greater than this"
                    },
                    {
                        "username": "harsha335",
                        "content": "above graphs are\\n1 --2,3\\n7 --5,6\\n4 - 8 - 9 - 10 - 11 -12\\n1st sem - complete 1 & 4 in a sem 7, 2 , 3 , 8 unlocked for next sem.\\n2nd - read 2 & 8 . current unlocked sub are 3 ,9,7.\\n3rd - read 3 & 9. unlocked sub are 7,10\\n4th - read 7 & 10. unlocked sub are 5,6,11\\n5th - read 5 & 11. unlocked sub are 6,12\\n6th sem - read 6 & 12\\nall sub are completed in 6 semesters."
                    },
                    {
                        "username": "yuhwu",
                        "content": "Greedy without proving correctness => WRONG ANSWER. LC please improve the test cases."
                    },
                    {
                        "username": "sooraj123456789",
                        "content": "13\\n[[12,8],[2,4],[3,7],[6,8],[11,8],[9,4],[9,7],[12,4],[11,4],[6,4],[1,4],[10,7],[10,4],[1,7],[1,8],[2,7],[8,4],[10,8],[12,7],[5,4],[3,4],[11,7],[7,4],[13,4],[9,8],[13,8]]\\n9 \\nCan anyone explain me that why its output is 3. I am getting 4 as in one semester there are total 10 subjects and it can take maximum 9 so, 2 semesters are required and for remaining semesters there are 2 and 1 subjects so total 4 semesters are required but answer is 3 .How?\\n"
                    },
                    {
                        "username": "seafmch",
                        "content": "Description:\\n\\nIn one semester, you can take at most k courses as long as you have taken all the prerequisites in the previous semester for the courses you are taking.\\n\\nWRONG. Should be \"previous SEMESTERS\". No guarantee you took all the prereqs in the exact previous semester."
                    }
                ]
            },
            {
                "id": 1574215,
                "content": [
                    {
                        "username": "hqztrue",
                        "content": "This is called the DAG scheduling problem."
                    },
                    {
                        "username": "phung_manh_cuong",
                        "content": "From white paper: https://core.ac.uk/reader/82723490"
                    },
                    {
                        "username": "hobiter",
                        "content": "I have seen most the published solution use greedy sort or heap, for examle: \\nfinish the prerequisite with deepest depth first, then with most courses depend on it (out degree) ..\\n\\nTha above greedy strategy based on assumption that:\\n1, you can find the best solution, without knowing the details/arrangement from next semester...\\n\\nHowever, this assumption is not true, you have to know the next semester\\'s arrangement before you find this semester\\'s best. \\n\\nTherefore, you have to use a DFS to compare result by each different arrangement of this semester. Then best way to use some storage, such as multi-dementional array, to cache the result to avoid duplicate calculation, however it should not be linear dimentional array, then become an NP problem.\\n\\n\\n"
                    },
                    {
                        "username": "aumo",
                        "content": "can confirm this, my max heap sorted by depth and # outgoing edges fails on test 79 of 81"
                    },
                    {
                        "username": "azhw1983",
                        "content": "why everyone is using bitmask? no other way to avoid that?"
                    },
                    {
                        "username": "sqqqa23",
                        "content": "12\\n[[1,2],[1,3],[7,5],[7,6],[4,8],[8,9],[9,10],[10,11],[11,12]]\\n2\\nfor this testcase  expected ans is \"6\" i am not sure how is that expected  as in directed graph \\'4->8->9->10->11->12\\' this chain is there this itself should be taking 6 semester so according to me  ans must be greater than this"
                    },
                    {
                        "username": "harsha335",
                        "content": "above graphs are\\n1 --2,3\\n7 --5,6\\n4 - 8 - 9 - 10 - 11 -12\\n1st sem - complete 1 & 4 in a sem 7, 2 , 3 , 8 unlocked for next sem.\\n2nd - read 2 & 8 . current unlocked sub are 3 ,9,7.\\n3rd - read 3 & 9. unlocked sub are 7,10\\n4th - read 7 & 10. unlocked sub are 5,6,11\\n5th - read 5 & 11. unlocked sub are 6,12\\n6th sem - read 6 & 12\\nall sub are completed in 6 semesters."
                    },
                    {
                        "username": "yuhwu",
                        "content": "Greedy without proving correctness => WRONG ANSWER. LC please improve the test cases."
                    },
                    {
                        "username": "sooraj123456789",
                        "content": "13\\n[[12,8],[2,4],[3,7],[6,8],[11,8],[9,4],[9,7],[12,4],[11,4],[6,4],[1,4],[10,7],[10,4],[1,7],[1,8],[2,7],[8,4],[10,8],[12,7],[5,4],[3,4],[11,7],[7,4],[13,4],[9,8],[13,8]]\\n9 \\nCan anyone explain me that why its output is 3. I am getting 4 as in one semester there are total 10 subjects and it can take maximum 9 so, 2 semesters are required and for remaining semesters there are 2 and 1 subjects so total 4 semesters are required but answer is 3 .How?\\n"
                    },
                    {
                        "username": "seafmch",
                        "content": "Description:\\n\\nIn one semester, you can take at most k courses as long as you have taken all the prerequisites in the previous semester for the courses you are taking.\\n\\nWRONG. Should be \"previous SEMESTERS\". No guarantee you took all the prereqs in the exact previous semester."
                    }
                ]
            },
            {
                "id": 1573979,
                "content": [
                    {
                        "username": "hqztrue",
                        "content": "This is called the DAG scheduling problem."
                    },
                    {
                        "username": "phung_manh_cuong",
                        "content": "From white paper: https://core.ac.uk/reader/82723490"
                    },
                    {
                        "username": "hobiter",
                        "content": "I have seen most the published solution use greedy sort or heap, for examle: \\nfinish the prerequisite with deepest depth first, then with most courses depend on it (out degree) ..\\n\\nTha above greedy strategy based on assumption that:\\n1, you can find the best solution, without knowing the details/arrangement from next semester...\\n\\nHowever, this assumption is not true, you have to know the next semester\\'s arrangement before you find this semester\\'s best. \\n\\nTherefore, you have to use a DFS to compare result by each different arrangement of this semester. Then best way to use some storage, such as multi-dementional array, to cache the result to avoid duplicate calculation, however it should not be linear dimentional array, then become an NP problem.\\n\\n\\n"
                    },
                    {
                        "username": "aumo",
                        "content": "can confirm this, my max heap sorted by depth and # outgoing edges fails on test 79 of 81"
                    },
                    {
                        "username": "azhw1983",
                        "content": "why everyone is using bitmask? no other way to avoid that?"
                    },
                    {
                        "username": "sqqqa23",
                        "content": "12\\n[[1,2],[1,3],[7,5],[7,6],[4,8],[8,9],[9,10],[10,11],[11,12]]\\n2\\nfor this testcase  expected ans is \"6\" i am not sure how is that expected  as in directed graph \\'4->8->9->10->11->12\\' this chain is there this itself should be taking 6 semester so according to me  ans must be greater than this"
                    },
                    {
                        "username": "harsha335",
                        "content": "above graphs are\\n1 --2,3\\n7 --5,6\\n4 - 8 - 9 - 10 - 11 -12\\n1st sem - complete 1 & 4 in a sem 7, 2 , 3 , 8 unlocked for next sem.\\n2nd - read 2 & 8 . current unlocked sub are 3 ,9,7.\\n3rd - read 3 & 9. unlocked sub are 7,10\\n4th - read 7 & 10. unlocked sub are 5,6,11\\n5th - read 5 & 11. unlocked sub are 6,12\\n6th sem - read 6 & 12\\nall sub are completed in 6 semesters."
                    },
                    {
                        "username": "yuhwu",
                        "content": "Greedy without proving correctness => WRONG ANSWER. LC please improve the test cases."
                    },
                    {
                        "username": "sooraj123456789",
                        "content": "13\\n[[12,8],[2,4],[3,7],[6,8],[11,8],[9,4],[9,7],[12,4],[11,4],[6,4],[1,4],[10,7],[10,4],[1,7],[1,8],[2,7],[8,4],[10,8],[12,7],[5,4],[3,4],[11,7],[7,4],[13,4],[9,8],[13,8]]\\n9 \\nCan anyone explain me that why its output is 3. I am getting 4 as in one semester there are total 10 subjects and it can take maximum 9 so, 2 semesters are required and for remaining semesters there are 2 and 1 subjects so total 4 semesters are required but answer is 3 .How?\\n"
                    },
                    {
                        "username": "seafmch",
                        "content": "Description:\\n\\nIn one semester, you can take at most k courses as long as you have taken all the prerequisites in the previous semester for the courses you are taking.\\n\\nWRONG. Should be \"previous SEMESTERS\". No guarantee you took all the prereqs in the exact previous semester."
                    }
                ]
            },
            {
                "id": 2038342,
                "content": [
                    {
                        "username": "hqztrue",
                        "content": "This is called the DAG scheduling problem."
                    },
                    {
                        "username": "phung_manh_cuong",
                        "content": "From white paper: https://core.ac.uk/reader/82723490"
                    },
                    {
                        "username": "hobiter",
                        "content": "I have seen most the published solution use greedy sort or heap, for examle: \\nfinish the prerequisite with deepest depth first, then with most courses depend on it (out degree) ..\\n\\nTha above greedy strategy based on assumption that:\\n1, you can find the best solution, without knowing the details/arrangement from next semester...\\n\\nHowever, this assumption is not true, you have to know the next semester\\'s arrangement before you find this semester\\'s best. \\n\\nTherefore, you have to use a DFS to compare result by each different arrangement of this semester. Then best way to use some storage, such as multi-dementional array, to cache the result to avoid duplicate calculation, however it should not be linear dimentional array, then become an NP problem.\\n\\n\\n"
                    },
                    {
                        "username": "aumo",
                        "content": "can confirm this, my max heap sorted by depth and # outgoing edges fails on test 79 of 81"
                    },
                    {
                        "username": "azhw1983",
                        "content": "why everyone is using bitmask? no other way to avoid that?"
                    },
                    {
                        "username": "sqqqa23",
                        "content": "12\\n[[1,2],[1,3],[7,5],[7,6],[4,8],[8,9],[9,10],[10,11],[11,12]]\\n2\\nfor this testcase  expected ans is \"6\" i am not sure how is that expected  as in directed graph \\'4->8->9->10->11->12\\' this chain is there this itself should be taking 6 semester so according to me  ans must be greater than this"
                    },
                    {
                        "username": "harsha335",
                        "content": "above graphs are\\n1 --2,3\\n7 --5,6\\n4 - 8 - 9 - 10 - 11 -12\\n1st sem - complete 1 & 4 in a sem 7, 2 , 3 , 8 unlocked for next sem.\\n2nd - read 2 & 8 . current unlocked sub are 3 ,9,7.\\n3rd - read 3 & 9. unlocked sub are 7,10\\n4th - read 7 & 10. unlocked sub are 5,6,11\\n5th - read 5 & 11. unlocked sub are 6,12\\n6th sem - read 6 & 12\\nall sub are completed in 6 semesters."
                    },
                    {
                        "username": "yuhwu",
                        "content": "Greedy without proving correctness => WRONG ANSWER. LC please improve the test cases."
                    },
                    {
                        "username": "sooraj123456789",
                        "content": "13\\n[[12,8],[2,4],[3,7],[6,8],[11,8],[9,4],[9,7],[12,4],[11,4],[6,4],[1,4],[10,7],[10,4],[1,7],[1,8],[2,7],[8,4],[10,8],[12,7],[5,4],[3,4],[11,7],[7,4],[13,4],[9,8],[13,8]]\\n9 \\nCan anyone explain me that why its output is 3. I am getting 4 as in one semester there are total 10 subjects and it can take maximum 9 so, 2 semesters are required and for remaining semesters there are 2 and 1 subjects so total 4 semesters are required but answer is 3 .How?\\n"
                    },
                    {
                        "username": "seafmch",
                        "content": "Description:\\n\\nIn one semester, you can take at most k courses as long as you have taken all the prerequisites in the previous semester for the courses you are taking.\\n\\nWRONG. Should be \"previous SEMESTERS\". No guarantee you took all the prereqs in the exact previous semester."
                    }
                ]
            },
            {
                "id": 1576596,
                "content": [
                    {
                        "username": "hqztrue",
                        "content": "This is called the DAG scheduling problem."
                    },
                    {
                        "username": "phung_manh_cuong",
                        "content": "From white paper: https://core.ac.uk/reader/82723490"
                    },
                    {
                        "username": "hobiter",
                        "content": "I have seen most the published solution use greedy sort or heap, for examle: \\nfinish the prerequisite with deepest depth first, then with most courses depend on it (out degree) ..\\n\\nTha above greedy strategy based on assumption that:\\n1, you can find the best solution, without knowing the details/arrangement from next semester...\\n\\nHowever, this assumption is not true, you have to know the next semester\\'s arrangement before you find this semester\\'s best. \\n\\nTherefore, you have to use a DFS to compare result by each different arrangement of this semester. Then best way to use some storage, such as multi-dementional array, to cache the result to avoid duplicate calculation, however it should not be linear dimentional array, then become an NP problem.\\n\\n\\n"
                    },
                    {
                        "username": "aumo",
                        "content": "can confirm this, my max heap sorted by depth and # outgoing edges fails on test 79 of 81"
                    },
                    {
                        "username": "azhw1983",
                        "content": "why everyone is using bitmask? no other way to avoid that?"
                    },
                    {
                        "username": "sqqqa23",
                        "content": "12\\n[[1,2],[1,3],[7,5],[7,6],[4,8],[8,9],[9,10],[10,11],[11,12]]\\n2\\nfor this testcase  expected ans is \"6\" i am not sure how is that expected  as in directed graph \\'4->8->9->10->11->12\\' this chain is there this itself should be taking 6 semester so according to me  ans must be greater than this"
                    },
                    {
                        "username": "harsha335",
                        "content": "above graphs are\\n1 --2,3\\n7 --5,6\\n4 - 8 - 9 - 10 - 11 -12\\n1st sem - complete 1 & 4 in a sem 7, 2 , 3 , 8 unlocked for next sem.\\n2nd - read 2 & 8 . current unlocked sub are 3 ,9,7.\\n3rd - read 3 & 9. unlocked sub are 7,10\\n4th - read 7 & 10. unlocked sub are 5,6,11\\n5th - read 5 & 11. unlocked sub are 6,12\\n6th sem - read 6 & 12\\nall sub are completed in 6 semesters."
                    },
                    {
                        "username": "yuhwu",
                        "content": "Greedy without proving correctness => WRONG ANSWER. LC please improve the test cases."
                    },
                    {
                        "username": "sooraj123456789",
                        "content": "13\\n[[12,8],[2,4],[3,7],[6,8],[11,8],[9,4],[9,7],[12,4],[11,4],[6,4],[1,4],[10,7],[10,4],[1,7],[1,8],[2,7],[8,4],[10,8],[12,7],[5,4],[3,4],[11,7],[7,4],[13,4],[9,8],[13,8]]\\n9 \\nCan anyone explain me that why its output is 3. I am getting 4 as in one semester there are total 10 subjects and it can take maximum 9 so, 2 semesters are required and for remaining semesters there are 2 and 1 subjects so total 4 semesters are required but answer is 3 .How?\\n"
                    },
                    {
                        "username": "seafmch",
                        "content": "Description:\\n\\nIn one semester, you can take at most k courses as long as you have taken all the prerequisites in the previous semester for the courses you are taking.\\n\\nWRONG. Should be \"previous SEMESTERS\". No guarantee you took all the prereqs in the exact previous semester."
                    }
                ]
            }
        ]
    },
    {
        "title": "Sum of All Subset XOR Totals",
        "question_content": "<p>The <strong>XOR total</strong> of an array is defined as the bitwise <code>XOR</code> of<strong> all its elements</strong>, or <code>0</code> if the array is<strong> empty</strong>.</p>\n\n<ul>\n\t<li>For example, the <strong>XOR total</strong> of the array <code>[2,5,6]</code> is <code>2 XOR 5 XOR 6 = 1</code>.</li>\n</ul>\n\n<p>Given an array <code>nums</code>, return <em>the <strong>sum</strong> of all <strong>XOR totals</strong> for every <strong>subset</strong> of </em><code>nums</code>.&nbsp;</p>\n\n<p><strong>Note:</strong> Subsets with the <strong>same</strong> elements should be counted <strong>multiple</strong> times.</p>\n\n<p>An array <code>a</code> is a <strong>subset</strong> of an array <code>b</code> if <code>a</code> can be obtained from <code>b</code> by deleting some (possibly zero) elements of <code>b</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,3]\n<strong>Output:</strong> 6\n<strong>Explanation: </strong>The 4 subsets of [1,3] are:\n- The empty subset has an XOR total of 0.\n- [1] has an XOR total of 1.\n- [3] has an XOR total of 3.\n- [1,3] has an XOR total of 1 XOR 3 = 2.\n0 + 1 + 3 + 2 = 6\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [5,1,6]\n<strong>Output:</strong> 28\n<strong>Explanation: </strong>The 8 subsets of [5,1,6] are:\n- The empty subset has an XOR total of 0.\n- [5] has an XOR total of 5.\n- [1] has an XOR total of 1.\n- [6] has an XOR total of 6.\n- [5,1] has an XOR total of 5 XOR 1 = 4.\n- [5,6] has an XOR total of 5 XOR 6 = 3.\n- [1,6] has an XOR total of 1 XOR 6 = 7.\n- [5,1,6] has an XOR total of 5 XOR 1 XOR 6 = 2.\n0 + 5 + 1 + 6 + 4 + 3 + 7 + 2 = 28\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,4,5,6,7,8]\n<strong>Output:</strong> 480\n<strong>Explanation:</strong> The sum of all XOR totals for every subset is 480.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 12</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 20</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1242073,
                "title": "java-backtracking-approach-with-explanation",
                "content": "*Why use Backtracking?*\\n\\nOne of the indicators from the description to use backtracking are the words \"All subset\". Looking at the constraints, the length of the input array is relatively small, so we can approach this question using brute force.\\n\\n*General Approach*\\n\\n1.  Firstly, we need to generate all the possible subsets from the input array.\\n2.  Then, for all calculated subsets, calculate the XOR of all elements in each subset.\\n3.  Return the sum of all calculated XORs.\\n\\n*Detailed Approach*\\n1. Generate all possible subsets:\\nWe can recursively generate all possible subsets given an array. For each element in the array, you will have two choices: Include the current element in the array in the generated subset, or withhold the current element from the generated subset. \\nVisualization: \\n![image](https://assets.leetcode.com/users/images/a3577006-9ec5-4d9e-9731-749ab42ba81d_1622422572.769027.png)\\n\\n2. If we are going the step by step approach, we would store all the subsets in a list and calculate their XORs. However, this is not necessary as we can calculate the ongoing XOR total while generating the subsets. The trick is to be able to remember the state of the current xor that is calculated for each recursive step.\\n\\n3. As we are not explicitly storing the subsets in a list, we just need to return the sum of the calculated xor when the current element is considered + the calculated xor when the current element is not considered.\\n\\n*Code*\\n```\\n\\tpublic int subsetXORSum(int[] nums) {\\n        return helper(nums, 0, 0);\\n    }\\n    \\n    private int helper(int[] nums, int index, int currentXor) {\\n        // return currentXor when all elements in nums are already considered\\n        if (index == nums.length) return currentXor;\\n        \\n        // calculate sum of xor with current element\\n        int withElement = helper(nums, index + 1, currentXor ^ nums[index]);\\n        \\n        // calculate sum of xor without current element\\n        int withoutElement = helper(nums, index + 1, currentXor);\\n        \\n        // return sum of xors from recursion\\n        return withElement + withoutElement;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\n\\tpublic int subsetXORSum(int[] nums) {\\n        return helper(nums, 0, 0);\\n    }\\n    \\n    private int helper(int[] nums, int index, int currentXor) {\\n        // return currentXor when all elements in nums are already considered\\n        if (index == nums.length) return currentXor;\\n        \\n        // calculate sum of xor with current element\\n        int withElement = helper(nums, index + 1, currentXor ^ nums[index]);\\n        \\n        // calculate sum of xor without current element\\n        int withoutElement = helper(nums, index + 1, currentXor);\\n        \\n        // return sum of xors from recursion\\n        return withElement + withoutElement;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1211182,
                "title": "one-liner-bitmask",
                "content": "I\\'ll start with a one-liner O(n) solution, but it may help to check out approach 2 first.\\n\\nThis approach requires an additional bit of intuition: if you look at binary representation of XOR total for all 2 ^ n subsets (which you can generate in approach 2), you can see that each bit appears 2 ^ (n - 1) times. So we collect all bits using binary OR, and then multiply it by 2 ^ (n - 1).\\n\\n#### Approach 1: O(n)\\n**C++**\\n```cpp\\nint subsetXORSum(vector<int>& n) {\\n    return accumulate(begin(n), end(n), 0, bit_or<int>()) << (n.size() - 1);\\n}\\n```\\n#### Approach 2: O(n * 2 ^ n)\\nSince we only have 12 numbers, we can represent all combinations using a bitmask: `[1 << 0.... 1 << n)`:\\n- Iterate through all bitmask values;\\n- Go through array and do XOR numbers at positions indicated by the bitmask.\\n\\n**C++**\\n```cpp\\nint subsetXORSum(vector<int>& nums) {\\n    int res = 0;\\n    for (auto i = 1; i < (1 << nums.size()); ++i) {\\n        int total = 0;\\n        for (auto j = 0; j < nums.size(); ++j)\\n            if (i & (1 << j))\\n                total ^= nums[j];\\n        res += total;\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint subsetXORSum(vector<int>& n) {\\n    return accumulate(begin(n), end(n), 0, bit_or<int>()) << (n.size() - 1);\\n}\\n```\n```cpp\\nint subsetXORSum(vector<int>& nums) {\\n    int res = 0;\\n    for (auto i = 1; i < (1 << nums.size()); ++i) {\\n        int total = 0;\\n        for (auto j = 0; j < nums.size(); ++j)\\n            if (i & (1 << j))\\n                total ^= nums[j];\\n        res += total;\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1211213,
                "title": "python-bitwise-or-with-explanation-o-n",
                "content": "```\\nclass Solution:\\n    def subsetXORSum(self, nums: List[int]) -> int:\\n        \"\"\"\\n        an efficient approach: find bitwise OR of array. ith bit contribution to to xor sum is 2**(n-1).\\n        The result is 2**(n-1) * bitORSum\\n        \\n        Explanation:\\n        \\n        consider ith bit for the final result. If there is no element whose ith bit is 1, then all xor subset \\n        sums has 0 in ith bit; if there are k (k>=1) elements whose ith bits are 1, then there are in total \\n        comb(k, 1) + comb(k,3) + .. = 2**(k-1) ways to select odd number our of these k elements to make the subset\\n        xor sum\\'s ith bit to be 1, and there are 2**(n-k) ways to choose from the remaining elements whose ith bits\\n        are 0s. Therefore, we have in total 2**(k-1) * 2**(n-k) = 2**(n-1) subsets whose xor sums have 1 in their\\n        ith bit, which means the contribution to the final sum is 2**(n-1) * 2**i. Notice this result is irrelevant\\n        to k. \\n        \\n        So we only need to determine whether there is any element whose ith bit is 1. We use bitwise OR sum to do this.\\n        \\n        Time complexity: O(n), Space: O(1)\\n        \"\"\"\\n        bits = 0\\n        for a in nums:\\n            bits |= a\\n        return bits * int(pow(2, len(nums)-1))\\n    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def subsetXORSum(self, nums: List[int]) -> int:\\n        \"\"\"\\n        an efficient approach: find bitwise OR of array. ith bit contribution to to xor sum is 2**(n-1).\\n        The result is 2**(n-1) * bitORSum\\n        \\n        Explanation:\\n        \\n        consider ith bit for the final result. If there is no element whose ith bit is 1, then all xor subset \\n        sums has 0 in ith bit; if there are k (k>=1) elements whose ith bits are 1, then there are in total \\n        comb(k, 1) + comb(k,3) + .. = 2**(k-1) ways to select odd number our of these k elements to make the subset\\n        xor sum\\'s ith bit to be 1, and there are 2**(n-k) ways to choose from the remaining elements whose ith bits\\n        are 0s. Therefore, we have in total 2**(k-1) * 2**(n-k) = 2**(n-1) subsets whose xor sums have 1 in their\\n        ith bit, which means the contribution to the final sum is 2**(n-1) * 2**i. Notice this result is irrelevant\\n        to k. \\n        \\n        So we only need to determine whether there is any element whose ith bit is 1. We use bitwise OR sum to do this.\\n        \\n        Time complexity: O(n), Space: O(1)\\n        \"\"\"\\n        bits = 0\\n        for a in nums:\\n            bits |= a\\n        return bits * int(pow(2, len(nums)-1))\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1224163,
                "title": "java-100-easy-short-solution",
                "content": "if you like it pls upvote\\n\\nJava\\n```\\nclass Solution {\\n    int sum=0;\\n    public int subsetXORSum(int[] nums) {\\n        sum=0;\\n        return getAns(nums,0,0);\\n    }\\n    \\n    int getAns(int[] arr,int i,int cur){\\n        if(i==arr.length){\\n            return cur;\\n        }\\n        return getAns(arr,i+1,cur^arr[i]) + getAns(arr,i+1,cur);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int sum=0;\\n    public int subsetXORSum(int[] nums) {\\n        sum=0;\\n        return getAns(nums,0,0);\\n    }\\n    \\n    int getAns(int[] arr,int i,int cur){\\n        if(i==arr.length){\\n            return cur;\\n        }\\n        return getAns(arr,i+1,cur^arr[i]) + getAns(arr,i+1,cur);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3350298,
                "title": "python3-beats-99-91-bitmask-or",
                "content": "The code calculates the bitwise OR of all numbers in the input list using the bitwise OR operator | and stores it in the variable all_or. It then calculates the total number of possible subsets of nums, which is 2^n where n is the length of the list, using the left bit shift operator << and subtracts 1 from it to get the number of subsets excluding the empty set. Finally, it multiplies all_or with the number of subsets to get the sum of XOR of all subsets.\\n\\nNote that this code does not actually generate all the subsets and calculate their XORs, which would be a brute force approach with O(2^n) time complexity. Instead, it uses a mathematical property of XOR operation that the XOR of two equal numbers is 0 and XOR of a number with 0 is the number itself, and calculates the answer using a formula. This approach has a time complexity of O(n) and is more efficient for larger inputs.\\n\\n![image.png](https://assets.leetcode.com/users/images/f54185ef-bb76-4c6e-807b-66e506e7fab0_1678294130.6935549.png)\\n# Please Upvote \\uD83D\\uDE07\\n\\n## Python3\\n```\\nclass Solution:\\n    def subsetXORSum(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        all_or=0\\n        for i in range(n):\\n            all_or|=nums[i]\\n        return all_or*(1<<(n-1))\\n```\\n![image.png](https://assets.leetcode.com/users/images/a6c83c54-1d1a-4f26-8273-b687d119dd5b_1679889261.1494205.png)",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def subsetXORSum(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        all_or=0\\n        for i in range(n):\\n            all_or|=nums[i]\\n        return all_or*(1<<(n-1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1230324,
                "title": "python-all-the-4-different-ways-to-solve-this-problem",
                "content": "Subsets recursive\\n```\\nclass Solution:\\n    def subsetXORSum(self, nums: List[int]) -> int:\\n        def sums(term, idx):\\n            if idx == len(nums):\\n                return term            \\n            return sums(term, idx + 1) + sums(term ^ nums[idx], idx + 1)\\n        \\n        return sums(0, 0)\\n```\\nSubsets iterative\\n```\\nclass Solution:\\n    def subsetXORSum(self, nums: List[int]) -> int:\\n        result = 0\\n        subsets = [0]\\n        for n in nums:\\n            new_subsets = subsets.copy()\\n            for s in subsets:\\n                new_subsets.append(s ^ n)\\n                result += new_subsets[-1]\\n            subsets = new_subsets\\n                \\n        return result\\n```\\nSubsets bit manipulations\\n```\\nclass Solution:\\n    def subsetXORSum(self, nums: List[int]) -> int:\\n        result = 0 \\n        for n in range(1 << len(nums)):\\n            term = 0\\n            for i in range(len(nums)):\\n                if n & 1:\\n                    term ^= nums[i]\\n                n >>= 1\\n            result += term\\n        return result\\n```\\nMath based one-liner\\n```\\nclass Solution:\\n    def subsetXORSum(self, nums: List[int]) -> int:\\n        return reduce(operator.or_, nums, 0) * 2**(len(nums) - 1)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def subsetXORSum(self, nums: List[int]) -> int:\\n        def sums(term, idx):\\n            if idx == len(nums):\\n                return term            \\n            return sums(term, idx + 1) + sums(term ^ nums[idx], idx + 1)\\n        \\n        return sums(0, 0)\\n```\n```\\nclass Solution:\\n    def subsetXORSum(self, nums: List[int]) -> int:\\n        result = 0\\n        subsets = [0]\\n        for n in nums:\\n            new_subsets = subsets.copy()\\n            for s in subsets:\\n                new_subsets.append(s ^ n)\\n                result += new_subsets[-1]\\n            subsets = new_subsets\\n                \\n        return result\\n```\n```\\nclass Solution:\\n    def subsetXORSum(self, nums: List[int]) -> int:\\n        result = 0 \\n        for n in range(1 << len(nums)):\\n            term = 0\\n            for i in range(len(nums)):\\n                if n & 1:\\n                    term ^= nums[i]\\n                n >>= 1\\n            result += term\\n        return result\\n```\n```\\nclass Solution:\\n    def subsetXORSum(self, nums: List[int]) -> int:\\n        return reduce(operator.or_, nums, 0) * 2**(len(nums) - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1211067,
                "title": "c-simple-approach-with-explanation",
                "content": "Brute force approach where we iterate over all possible subsets and compute their XORs and add that to result.\\n\\nHere the trick is to use binary representation of numbers to generate power set.\\nFor instance, if we have 3 elements, we can generate binary counting upto `2^3` to get all possible subsets.\\n\\n```\\n000 => {empty set}\\n001 => {set with only first element}\\n010 => {set with only second element}\\n011 => {set with first and second element}\\n100 ... and so on\\n101\\n110\\n111 => {subset with all three elements}\\n```\\n\\nHere is the C++ code for this brute force approach.\\n\\n```\\nclass Solution\\n{\\npublic:\\n    int subsetXORSum(vector<int>& nums)\\n    {\\n        int N = nums.size();\\n        int numOfSubsets = pow(2, N);\\n        int result = 0;\\n        \\n        // binary representation of subsets help us identify whether to take an element of num or not\\n        for (int subset = 1; subset < numOfSubsets; ++subset)\\n        {\\n            int runningXor = 0;\\n            for (int i = 0, bits = subset; i < nums.size(); ++i, bits >>= 1)\\n                if (bits & 1)   // whether to include current element in subset\\n                    runningXor ^= nums[i];\\n            \\n            result += runningXor;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n000 => {empty set}\\n001 => {set with only first element}\\n010 => {set with only second element}\\n011 => {set with first and second element}\\n100 ... and so on\\n101\\n110\\n111 => {subset with all three elements}\\n```\n```\\nclass Solution\\n{\\npublic:\\n    int subsetXORSum(vector<int>& nums)\\n    {\\n        int N = nums.size();\\n        int numOfSubsets = pow(2, N);\\n        int result = 0;\\n        \\n        // binary representation of subsets help us identify whether to take an element of num or not\\n        for (int subset = 1; subset < numOfSubsets; ++subset)\\n        {\\n            int runningXor = 0;\\n            for (int i = 0, bits = subset; i < nums.size(); ++i, bits >>= 1)\\n                if (bits & 1)   // whether to include current element in subset\\n                    runningXor ^= nums[i];\\n            \\n            result += runningXor;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1228132,
                "title": "simple-c-o-n-iterative-solution",
                "content": "Since the range of nums[i] is small, We can iterate through each bit and count the no. of subsets in which the bit will be set.\\nSuppose the bit is set in m elements in the array(**I use m** in the explanation **in place of variable count in the code**). Now, the subsets in which the bit will be set can be formed by\\ntaking **odd number of elements**(1,3,5...etc.) **out of the m elements that have the bit set** in them. Thus the no. of subsets :\\n\\n![image](https://assets.leetcode.com/users/images/8d5e6458-d9ff-4e78-b888-3755ac26862e_1621871698.7043123.png)\\n\\nif the **bit is not set**, there are **no subsets** having the bit set and hence we **ignore** the contribution from that bit.\\n\\n Those elemets that don\\'t have the bit set can either be **choosen or ignored** (hence two choices for each of them). Hence the factor **2^(N-m)** for them. (*N denotes the size* of array).\\n \\n Now the **contribution** for each **bit *i*** is the **no. of times it is set** in the subsets **multiplied by 2^i**. Hence we add the contribution for each bit and add it to the ans.\\n \\n In the code below, I have iterated through all the 32 bits( in C++, ints are of 32 bits) so that the code works for larger values of nums[i] which makes it *O(Nlog(max(nums[i]))*, though in the que **nums[i]<20** and hence we hardly need to **iterate through 6 bits making it O(N).**\\n \\n Hope the explanation helps. Upvote if you liked it.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    \\n    int subsetXORSum(vector<int>& nums) \\n    {\\n        int ans=0;\\n        for(int i=0; i<32; i++)\\n        {\\n            int mask=1<<i;\\n            int count=0;\\n            for(int j=0; j<nums.size(); j++)\\n            {\\n                if(nums[j]&mask) count++;\\n            }\\n            if(count)\\n            {\\n                ans+=mask*(1<<(count-1))*(1<<(nums.size()-count));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    int subsetXORSum(vector<int>& nums) \\n    {\\n        int ans=0;\\n        for(int i=0; i<32; i++)\\n        {\\n            int mask=1<<i;\\n            int count=0;\\n            for(int j=0; j<nums.size(); j++)\\n            {\\n                if(nums[j]&mask) count++;\\n            }\\n            if(count)\\n            {\\n                ans+=mask*(1<<(count-1))*(1<<(nums.size()-count));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1211170,
                "title": "c-brute-force-solutions",
                "content": "For each element, we either choose/not choose it.\\n```\\nclass Solution {\\npublic:\\n    int subsetXORSum(vector<int>& nums) {\\n        ret = 0;\\n        dfs(nums, 0, 0);\\n        return ret;\\n    }\\n    \\n    void dfs(vector<int>& nums, int pos, int cur){\\n        if(pos == nums.size()){\\n            ret += cur;\\n            return;\\n        }\\n        dfs(nums, pos + 1, cur);\\n        dfs(nums, pos + 1, cur ^ nums[pos]);\\n    }\\n    \\n    int ret;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subsetXORSum(vector<int>& nums) {\\n        ret = 0;\\n        dfs(nums, 0, 0);\\n        return ret;\\n    }\\n    \\n    void dfs(vector<int>& nums, int pos, int cur){\\n        if(pos == nums.size()){\\n            ret += cur;\\n            return;\\n        }\\n        dfs(nums, pos + 1, cur);\\n        dfs(nums, pos + 1, cur ^ nums[pos]);\\n    }\\n    \\n    int ret;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1225391,
                "title": "c-na-ve-solution-using-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void help(vector<int>& arr, int i, int xorr){\\n        if(i >= arr.size()){\\n            ans += xorr;\\n            return;\\n        }\\n        help(arr, i+1, xorr^arr[i]);\\n        help(arr, i+1, xorr);\\n    }\\n\\t\\n    int subsetXORSum(vector<int>& arr) {\\n       help(arr, 0, 0);\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void help(vector<int>& arr, int i, int xorr){\\n        if(i >= arr.size()){\\n            ans += xorr;\\n            return;\\n        }\\n        help(arr, i+1, xorr^arr[i]);\\n        help(arr, i+1, xorr);\\n    }\\n\\t\\n    int subsetXORSum(vector<int>& arr) {\\n       help(arr, 0, 0);\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1219078,
                "title": "python-combinations-and-reduce",
                "content": "```\\nclass Solution(object):\\n   \\n    def subsetXORSum(self, nums):\\n        res = 0\\n        for i in range(1, len(nums)+1):\\n            for arr in itertools.combinations(nums, i):\\t        \\n                tmp = functools.reduce(lambda x, y: x ^ y, list(arr))\\n                res += tmp\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n   \\n    def subsetXORSum(self, nums):\\n        res = 0\\n        for i in range(1, len(nums)+1):\\n            for arr in itertools.combinations(nums, i):\\t        \\n                tmp = functools.reduce(lambda x, y: x ^ y, list(arr))\\n                res += tmp\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1212248,
                "title": "java-backtracking",
                "content": "```\\nclass Solution {\\n    public int subsetXORSum(int[] nums) {\\n        int[] sum = new int[1];\\n        dfs(nums, 0, new ArrayList<>(), sum);\\n        return sum[0];\\n    }\\n    \\n    void dfs(int[] nums, int current, List<Integer> ls, int[] sum) {\\n        int temp = 0;\\n        for (int num: ls)\\n            temp ^= num;\\n        sum[0] += temp;\\n        \\n        for (int i = current; i < nums.length; i++) {\\n            ls.add(nums[i]);\\n            dfs(nums, i + 1, ls, sum);\\n            ls.remove(ls.size() - 1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int subsetXORSum(int[] nums) {\\n        int[] sum = new int[1];\\n        dfs(nums, 0, new ArrayList<>(), sum);\\n        return sum[0];\\n    }\\n    \\n    void dfs(int[] nums, int current, List<Integer> ls, int[] sum) {\\n        int temp = 0;\\n        for (int num: ls)\\n            temp ^= num;\\n        sum[0] += temp;\\n        \\n        for (int i = current; i < nums.length; i++) {\\n            ls.add(nums[i]);\\n            dfs(nums, i + 1, ls, sum);\\n            ls.remove(ls.size() - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1211062,
                "title": "a-few-solutions",
                "content": "Perform DFS.  There are two use cases to consider for each `i`<sup>th</sup> element of the input array `A`:\\n\\n* **`\\u2705` Case 1:** include the `i`<sup>th</sup> element in the ongoing xor `x`\\n* **`\\uD83D\\uDEAB` Case 2:** exclude the `i`<sup>th</sup> element in the ongoing xor `x`\\n\\nReturn the accumulated sum of all possibilities as the recursive stack unwinds.\\n\\n---\\n\\n**1-Liner Solutions:**\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun subsetXORSum(A: IntArray, i: Int = 0, x: Int = 0): Int {\\n        return if (i == A.size) x else subsetXORSum(A, i + 1, x xor A[i]) + subsetXORSum(A, i + 1, x)\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet subsetXORSum = (A, i = 0, x = 0) => i == A.length ? x : subsetXORSum(A, i + 1, x ^ A[i]) + subsetXORSum(A, i + 1, x);\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def subsetXORSum(self, A: List[int], i = 0, x = 0) -> int:\\n        return x if i == len(A) else self.subsetXORSum(A, i + 1, x ^ A[i]) + self.subsetXORSum(A, i + 1, x)\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int subsetXORSum(VI& A, int i = 0, int x = 0) {\\n        return i == A.size() ? x : subsetXORSum(A, i + 1, x ^ A[i]) + subsetXORSum(A, i +1, x);\\n    }\\n};\\n```\\n\\n---\\n\\n**Verbose Solutions:**\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun subsetXORSum(A: IntArray): Int {\\n        fun go(i: Int = 0, x: Int = 0): Int {\\n            if (i == A.size)\\n                return x\\n            var include = go(i + 1, x xor A[i])  // \\u2705 case 1: include\\n            var exclude = go(i + 1, x)           // \\uD83D\\uDEAB case 2: exclude\\n            return include + exclude\\n        }\\n        return go()\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet subsetXORSum = A => {\\n    let go = (i = 0, x = 0) => {\\n        if (i == A.length)\\n            return x;\\n        let include = go(i + 1, x ^ A[i]),  // \\u2705 case 1: include\\n            exclude = go(i + 1, x);         // \\uD83D\\uDEAB case 2: exclude\\n        return include + exclude;\\n    };\\n    return go();\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def subsetXORSum(self, A: List[int]) -> int:\\n        def go(i = 0, x = 0):\\n            if i == len(A):\\n                return x\\n            include = go(i + 1, x ^ A[i])  # \\u2705 case 1: include\\n            exclude = go(i + 1, x)         # \\uD83D\\uDEAB case 2: exclude\\n            return include + exclude\\n        return go()\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int, int)>;\\n    int subsetXORSum(VI& A) {\\n        fun go = [&](auto i, auto x) {\\n            if (i == A.size()) \\n                return x;\\n            auto include = go(i + 1, x ^ A[i]);  // \\u2705 case 1: include\\n            auto exclude = go(i + 1, x);         // \\uD83D\\uDEAB case 2: exclude\\n            return include + exclude;\\n        };\\n        return go(0, 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun subsetXORSum(A: IntArray, i: Int = 0, x: Int = 0): Int {\\n        return if (i == A.size) x else subsetXORSum(A, i + 1, x xor A[i]) + subsetXORSum(A, i + 1, x)\\n    }\\n}\\n```\n```\\nlet subsetXORSum = (A, i = 0, x = 0) => i == A.length ? x : subsetXORSum(A, i + 1, x ^ A[i]) + subsetXORSum(A, i + 1, x);\\n```\n```\\nclass Solution:\\n    def subsetXORSum(self, A: List[int], i = 0, x = 0) -> int:\\n        return x if i == len(A) else self.subsetXORSum(A, i + 1, x ^ A[i]) + self.subsetXORSum(A, i + 1, x)\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int subsetXORSum(VI& A, int i = 0, int x = 0) {\\n        return i == A.size() ? x : subsetXORSum(A, i + 1, x ^ A[i]) + subsetXORSum(A, i +1, x);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    fun subsetXORSum(A: IntArray): Int {\\n        fun go(i: Int = 0, x: Int = 0): Int {\\n            if (i == A.size)\\n                return x\\n            var include = go(i + 1, x xor A[i])  // \\u2705 case 1: include\\n            var exclude = go(i + 1, x)           // \\uD83D\\uDEAB case 2: exclude\\n            return include + exclude\\n        }\\n        return go()\\n    }\\n}\\n```\n```\\nlet subsetXORSum = A => {\\n    let go = (i = 0, x = 0) => {\\n        if (i == A.length)\\n            return x;\\n        let include = go(i + 1, x ^ A[i]),  // \\u2705 case 1: include\\n            exclude = go(i + 1, x);         // \\uD83D\\uDEAB case 2: exclude\\n        return include + exclude;\\n    };\\n    return go();\\n};\\n```\n```\\nclass Solution:\\n    def subsetXORSum(self, A: List[int]) -> int:\\n        def go(i = 0, x = 0):\\n            if i == len(A):\\n                return x\\n            include = go(i + 1, x ^ A[i])  # \\u2705 case 1: include\\n            exclude = go(i + 1, x)         # \\uD83D\\uDEAB case 2: exclude\\n            return include + exclude\\n        return go()\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int, int)>;\\n    int subsetXORSum(VI& A) {\\n        fun go = [&](auto i, auto x) {\\n            if (i == A.size()) \\n                return x;\\n            auto include = go(i + 1, x ^ A[i]);  // \\u2705 case 1: include\\n            auto exclude = go(i + 1, x);         // \\uD83D\\uDEAB case 2: exclude\\n            return include + exclude;\\n        };\\n        return go(0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1211694,
                "title": "c-recursion",
                "content": "```\\nclass Solution {\\n    int result;\\n    void helper(vector<int>& nums,int sum,int i)\\n    {\\n        if(i<nums.size()-1)\\n        {\\n             helper(nums,sum,i+1);\\n             helper(nums,sum^nums[i],i+1);\\n        }\\n        else\\n        {\\n            result+= sum + (sum^nums[i]);\\n        }\\n    }\\npublic:\\n    int subsetXORSum(vector<int>& nums) {\\n        result=0;\\n        helper(nums,0,0);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int result;\\n    void helper(vector<int>& nums,int sum,int i)\\n    {\\n        if(i<nums.size()-1)\\n        {\\n             helper(nums,sum,i+1);\\n             helper(nums,sum^nums[i],i+1);\\n        }\\n        else\\n        {\\n            result+= sum + (sum^nums[i]);\\n        }\\n    }\\npublic:\\n    int subsetXORSum(vector<int>& nums) {\\n        result=0;\\n        helper(nums,0,0);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1211219,
                "title": "java-dfs-approach",
                "content": "Similar to 17\\n\\n```\\nclass Solution {\\n    int sum = 0;\\n    \\n    public int subsetXORSum(int[] nums) {\\n       \\n            dfs(nums, 0, sum);\\n       \\n        \\n        return sum;\\n        \\n    }\\n    \\n    public void dfs (int[] nums, int start,  int prevSum) {\\n        if(start >= nums.length) {\\n            return ;\\n        }\\n        \\n        for(int i = start; i < nums.length ; i++) {\\n            int currentSum = prevSum ^ nums[i];\\n            sum += currentSum;\\n            dfs(nums, i + 1, currentSum);\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int sum = 0;\\n    \\n    public int subsetXORSum(int[] nums) {\\n       \\n            dfs(nums, 0, sum);\\n       \\n        \\n        return sum;\\n        \\n    }\\n    \\n    public void dfs (int[] nums, int start,  int prevSum) {\\n        if(start >= nums.length) {\\n            return ;\\n        }\\n        \\n        for(int i = start; i < nums.length ; i++) {\\n            int currentSum = prevSum ^ nums[i];\\n            sum += currentSum;\\n            dfs(nums, i + 1, currentSum);\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3235321,
                "title": "simple-java-bit-manipulations-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int subsetXORSum(int[] nums) {\\n         \\n int n=nums.length;\\n int ogans=0;\\n for(int i=0;i<(1<<n);i++){\\n  int sum=0;\\n  for(int j=0;j<n;j++){\\nint bit=i&(1<<j);\\nif (bit!=0){\\n sum=sum^nums[j];\\n}    \\n}\\n  ogans+=sum;\\n }\\nreturn ogans;\\n    }\\n}\\n```\\n![6233d50d-1433-4516-8d8e-90fb8e13d32f_1677303191.974716.jpeg](https://assets.leetcode.com/users/images/c2707256-6db3-4117-8e35-6275099af5a6_1677479335.2731755.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public int subsetXORSum(int[] nums) {\\n         \\n int n=nums.length;\\n int ogans=0;\\n for(int i=0;i<(1<<n);i++){\\n  int sum=0;\\n  for(int j=0;j<n;j++){\\nint bit=i&(1<<j);\\nif (bit!=0){\\n sum=sum^nums[j];\\n}    \\n}\\n  ogans+=sum;\\n }\\nreturn ogans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2884033,
                "title": "easy-c-approach",
                "content": "# Intuition\\n1. Find all subsets \\n2. Find EX-OR\\n\\n```\\nif(you like the solution && find it helpful){\\n    return upvote;\\n}\\n```\\n\\n# Approach\\nHow do we find [subset](https://en.wikipedia.org/wiki/Subset) of an array?\\nLets say we have,\\nAn input `array = {1, 2, 3}`\\nThen its subsets are\\n```\\n{},\\n{3},\\n{2},\\n{2,3},\\n{1},\\n{1,3},\\n{1,2},\\n{1,2,3}\\n```\\nHave you noticed a pattern here? The pattern is first we include nothing to get `empty arrat{}` Then we included the third element and excluded others`{3}`, then the second is included `{2}`, then the first `{1}`, this inclusion and exclusion resembles the binary number order...\\n\\n```\\n000\\n001\\n010\\n011\\n100\\n101\\n110\\n111\\n```\\nSo while writing code to find subsets recursively what we will do is follow the same logic. In the first call, we\\'ll include an element, and in the second calwe\\'ll exclude that element. `Inclusion means storing the element and exclusion means not storing the element.`\\n\\nThe recursive tree will look something like this-\\n![c5bad5ce-c362-4346-9e94-a7626914d318.jpg](https://assets.leetcode.com/users/images/977283c7-b46f-4b62-a962-5277151f571e_1675316625.420387.jpeg)\\n\\n# Algorithm\\n- Make a recursive function with the input array, current index, output array, or current subset as parameters. Because all subsets must be stored, a vector of vector is required.\\n- If you are going to include the current element then store that element in curr_subset and make the recursive call for the next element.\\n- If you are going to exclude the current element then ignore that element and make the recursive call for the next element.\\n- Finally, the recursion will terminate at the base case when the index will exceed the size of the input.\\n\\n# Complexity\\nAs we know for any finite set the number of subsets is 2 ^ (number of elements) The time complexity will be $$O(2^n)$$ and to store the numbers we are using extra memory.\\n\\n- Time complexity:  $$O(2^n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    void solve(vector<int>& arr, vector<vector<int>>& subsets, vector<int> curr_subset, int i =0){\\n        if(i == arr.size()){\\n            subsets.push_back(curr_subset);\\n            return;\\n        }\\n        // Include\\n        curr_subset.push_back(arr[i]);\\n        solve(arr, subsets,curr_subset, i+1);\\n        // Backtrack\\n        curr_subset.pop_back();\\n        // Exclude\\n        solve(arr, subsets,curr_subset, i+1);\\n    }\\npublic:\\n    int subsetXORSum(vector<int>& arr) {\\n        // Step 1:\\n        vector<vector<int>> subsets;\\n        vector<int> curr_subset;\\n        solve(arr,subsets,curr_subset);\\n\\n        // Step 2:\\n        int grand_total = 0;\\n        for(auto i: subsets){\\n            int curr_total = 0;\\n            for(auto j: i){\\n                curr_total =  (curr_total ^ j);\\n            }\\n            grand_total += curr_total;\\n        }\\n        return grand_total;\\n    }\\n};\\n```\\n\\n# Simple One (No BT & in One step)\\n```\\nclass Solution {\\nprivate:\\n    void solve(vector<int>& arr, int& grand_total, int xorAns, int i =0){\\n        if(i == arr.size()){\\n            grand_total += xorAns;\\n            return;\\n        }\\n        // Include\\n        solve(arr, grand_total,xorAns ^ arr[i], i+1);\\n        // Exclude\\n        solve(arr, grand_total,xorAns, i+1);\\n    }\\npublic:\\n    int subsetXORSum(vector<int>& arr) {\\n        // Step 1:\\n        int grand_total = 0;\\n        int xorAns = 0;\\n        solve(arr,grand_total,xorAns);\\n        return grand_total;\\n    }\\n};\\n```\\n\\n**If you find this explaination useful, upvote it. \\uD83D\\uDE42**",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nif(you like the solution && find it helpful){\\n    return upvote;\\n}\\n```\n```\\n{},\\n{3},\\n{2},\\n{2,3},\\n{1},\\n{1,3},\\n{1,2},\\n{1,2,3}\\n```\n```\\n000\\n001\\n010\\n011\\n100\\n101\\n110\\n111\\n```\n```\\nclass Solution {\\nprivate:\\n    void solve(vector<int>& arr, vector<vector<int>>& subsets, vector<int> curr_subset, int i =0){\\n        if(i == arr.size()){\\n            subsets.push_back(curr_subset);\\n            return;\\n        }\\n        // Include\\n        curr_subset.push_back(arr[i]);\\n        solve(arr, subsets,curr_subset, i+1);\\n        // Backtrack\\n        curr_subset.pop_back();\\n        // Exclude\\n        solve(arr, subsets,curr_subset, i+1);\\n    }\\npublic:\\n    int subsetXORSum(vector<int>& arr) {\\n        // Step 1:\\n        vector<vector<int>> subsets;\\n        vector<int> curr_subset;\\n        solve(arr,subsets,curr_subset);\\n\\n        // Step 2:\\n        int grand_total = 0;\\n        for(auto i: subsets){\\n            int curr_total = 0;\\n            for(auto j: i){\\n                curr_total =  (curr_total ^ j);\\n            }\\n            grand_total += curr_total;\\n        }\\n        return grand_total;\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    void solve(vector<int>& arr, int& grand_total, int xorAns, int i =0){\\n        if(i == arr.size()){\\n            grand_total += xorAns;\\n            return;\\n        }\\n        // Include\\n        solve(arr, grand_total,xorAns ^ arr[i], i+1);\\n        // Exclude\\n        solve(arr, grand_total,xorAns, i+1);\\n    }\\npublic:\\n    int subsetXORSum(vector<int>& arr) {\\n        // Step 1:\\n        int grand_total = 0;\\n        int xorAns = 0;\\n        solve(arr,grand_total,xorAns);\\n        return grand_total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1569785,
                "title": "c-easy-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    vector<int> v;\\n    void fun(vector<int> &nums,int id){\\n        int res=0;\\n        if(v.size()>0){\\n            res=v[0];\\n            for(int i=1;i<v.size();i++){\\n                res=res^v[i];\\n            }\\n        }\\n        ans+=res;\\n        for(int i=id;i<nums.size();i++){\\n            v.push_back(nums[i]);\\n            fun(nums,i+1);\\n            v.pop_back();\\n        }\\n    }\\n    int subsetXORSum(vector<int>& nums) {\\n        fun(nums,0);\\n        return ans;\\n    }\\n};\\n\\nPlease upvote if I could help you out\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    vector<int> v;\\n    void fun(vector<int> &nums,int id){\\n        int res=0;\\n        if(v.size()>0){\\n            res=v[0];\\n            for(int i=1;i<v.size();i++){\\n                res=res^v[i];\\n            }\\n        }\\n        ans+=res;\\n        for(int i=id;i<nums.size();i++){\\n            v.push_back(nums[i]);\\n            fun(nums,i+1);\\n            v.pop_back();\\n        }\\n    }\\n    int subsetXORSum(vector<int>& nums) {\\n        fun(nums,0);\\n        return ans;\\n    }\\n};\\n\\nPlease upvote if I could help you out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1232435,
                "title": "javascript-easy-solution",
                "content": "I divided the problem into 2 parts:\\nFirst I built all the combinations into a subset array.\\nThen I applied the xor operation to each one of them.\\n\\n```\\nvar subsetXORSum = function(nums) {\\n    const subsets = [[]]\\n    let sum = 0\\n    for(const el of nums){\\n        const last = subsets.length-1\\n        for(let i = 0; i<=last; i++){\\n            subsets.push([...subsets[i],el])\\n        }\\n    }\\n    \\n    for(let j = 0; j<subsets.length;j++){\\n        if (subsets[j].length === 0) sum = sum +0\\n        else if(subsets[j].length === 1) sum = sum + parseInt(subsets[j])\\n        else sum = sum + parseInt(subsets[j].reduce((acc,curr) => acc^curr))   \\n    }\\n    return sum\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar subsetXORSum = function(nums) {\\n    const subsets = [[]]\\n    let sum = 0\\n    for(const el of nums){\\n        const last = subsets.length-1\\n        for(let i = 0; i<=last; i++){\\n            subsets.push([...subsets[i],el])\\n        }\\n    }\\n    \\n    for(let j = 0; j<subsets.length;j++){\\n        if (subsets[j].length === 0) sum = sum +0\\n        else if(subsets[j].length === 1) sum = sum + parseInt(subsets[j])\\n        else sum = sum + parseInt(subsets[j].reduce((acc,curr) => acc^curr))   \\n    }\\n    return sum\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1211232,
                "title": "python3-power-set",
                "content": "`O(N*2^N)`\\n```\\nclass Solution:\\n    def subsetXORSum(self, nums: List[int]) -> int:\\n        ans = 0\\n        for mask in range(1 << len(nums)): \\n            val = 0\\n            for i in range(len(nums)): \\n                if mask & 1 << i: val ^= nums[i]\\n            ans += val\\n        return ans \\n```\\n\\nAdding an `O(N)` approach per @srinivasteja18 in this [post](https://leetcode.com/problems/sum-of-all-subset-xor-totals/discuss/1211177/C%2B%2B-simple-solution-oror-5-lines-of-code-oror-Explained!!).\\n```\\nclass Solution:\\n    def subsetXORSum(self, nums: List[int]) -> int:\\n        ans = 0 \\n        for x in nums: \\n            ans |= x \\n        return ans * 2 ** (len(nums)-1)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subsetXORSum(self, nums: List[int]) -> int:\\n        ans = 0\\n        for mask in range(1 << len(nums)): \\n            val = 0\\n            for i in range(len(nums)): \\n                if mask & 1 << i: val ^= nums[i]\\n            ans += val\\n        return ans \\n```\n```\\nclass Solution:\\n    def subsetXORSum(self, nums: List[int]) -> int:\\n        ans = 0 \\n        for x in nums: \\n            ans |= x \\n        return ans * 2 ** (len(nums)-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3184853,
                "title": "c-simple-backtracking-with-comments",
                "content": "# approach\\n-> we are using backtracking to generate all subsets.\\n-> for each num, we have two choices either take or not take that number.\\n-> along with subset generation we maintain the xorsum of each subset in \"sum\" variable.\\n-> and add all xorsum to our \"ans\" variable.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n//app 1: using backtracking in O(2^N) --> same concept as susets problem\\n    void dfs(int idx,vector<int>& nums,int sum,int &ans,int n){\\n        if(idx == n){\\n            ans += sum;\\n            return;\\n        }\\n\\n        //take\\n        dfs(idx+1,nums,sum^nums[idx],ans,n);\\n        //not take\\n        dfs(idx+1,nums,sum,ans,n);\\n    }\\n    int subsetXORSum(vector<int>& nums) {\\n        int n=nums.size();\\n\\n        int ans=0;\\n        dfs(0,nums,0,ans,n);\\n        return ans;\\n    }\\n};\\n```\\n# Please Do Upvote, if you understood the code!\\nHappy coding :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//app 1: using backtracking in O(2^N) --> same concept as susets problem\\n    void dfs(int idx,vector<int>& nums,int sum,int &ans,int n){\\n        if(idx == n){\\n            ans += sum;\\n            return;\\n        }\\n\\n        //take\\n        dfs(idx+1,nums,sum^nums[idx],ans,n);\\n        //not take\\n        dfs(idx+1,nums,sum,ans,n);\\n    }\\n    int subsetXORSum(vector<int>& nums) {\\n        int n=nums.size();\\n\\n        int ans=0;\\n        dfs(0,nums,0,ans,n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1222044,
                "title": "c-0-ms-100-faster",
                "content": "```\\nint subsetXORSum(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        int bits = 0;\\n        for (int i = 0; i < n; i++)\\n            bits |= nums[i];\\n\\n        int ans = bits * pow(2, n - 1);\\n\\n        return ans;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nint subsetXORSum(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        int bits = 0;\\n        for (int i = 0; i < n; i++)\\n            bits |= nums[i];\\n\\n        int ans = bits * pow(2, n - 1);\\n\\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2410712,
                "title": "easy-c-solution-simple-to-understand",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\n\\t\\tint solve(vector<int>& nums, int level, int currXor){\\n\\n\\t\\t\\t// Base Condition\\n\\t\\t\\tif(level == nums.size()){\\n\\t\\t\\t\\treturn currXor;\\n\\t\\t\\t}\\n\\n\\t\\t\\tint include = solve(nums, level + 1, currXor ^ nums[level]);\\n\\t\\t\\tint exclude = solve(nums, level + 1, currXor);\\n\\n\\t\\t\\treturn include + exclude;\\n\\t\\t}\\n\\n\\t\\tint subsetXORSum(vector<int>& nums) {\\n\\t\\t\\treturn solve(nums, 0, 0);\\n\\t\\t}\\n\\n\\t};\\nI hope that you\\'ve found the solution useful.\\nIn that case, please do upvote. Happy Coding :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\n\\t\\tint solve(vector<int>& nums, int level, int currXor){\\n\\n\\t\\t\\t// Base Condition\\n\\t\\t\\tif(level == nums.size()){\\n\\t\\t\\t\\treturn currXor;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2317954,
                "title": "easy-to-understand",
                "content": "```\\n```class Solution:\\n    def subsetXORSum(self, nums: List[int]) -> int:\\n        sume = 0\\n        xor = 0\\n        for i in range(1,pow(2, len(nums))):\\n            xor = 0\\n            for j in range(len(nums)):\\n                if (i & (1 << j)):\\n                    xor ^= nums[j]\\n            sume += xor\\n        return (sume)\\n\\t\\t\\nPlease! Upvote if you understand.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1222099,
                "title": "c-0ms-backtracking-very-much-simple-to-understand",
                "content": "Easy to understand, i don\\'t think it needs any explanation. Just a easy backtracking code. If having doubt comment.\\n```\\nclass Solution {\\npublic:\\n    int sum=0;\\n    void getAns(vector<int>&a,int i,int cur){\\n        if(i==a.size()){\\n            sum+=cur;\\n            return;\\n        }\\n        getAns(a,i+1,cur^a[i]);\\n        getAns(a,i+1,cur);\\n        \\n    }\\n    int subsetXORSum(vector<int>& nums) {\\n        sum=0;\\n        getAns(nums,0,0);\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int sum=0;\\n    void getAns(vector<int>&a,int i,int cur){\\n        if(i==a.size()){\\n            sum+=cur;\\n            return;\\n        }\\n        getAns(a,i+1,cur^a[i]);\\n        getAns(a,i+1,cur);\\n        \\n    }\\n    int subsetXORSum(vector<int>& nums) {\\n        sum=0;\\n        getAns(nums,0,0);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2687234,
                "title": "c-3-easy-understanding-iterative-recursive-sol",
                "content": "```\\nclass Solution {\\npublic:\\n    int findAllSubsetXor(int i, vector<int>& nums, int x) {\\n      if(i == nums.size()) return x;\\n      return findAllSubsetXor(i+1, nums, x ^ nums[i])+findAllSubsetXor(i+1, nums,x);\\n    }\\n    int subsetXORSum(vector<int>& nums) {\\n        return findAllSubsetXor(0,nums,0);\\n    }\\n};\\n\\n```\\n```\\nclass Solution {\\npublic:\\n    int subsetXORSum(vector<int>& nums,int i=0,  int x=0) {\\n      if(i == nums.size()) return x;\\n      return subsetXORSum(nums,i+1,x ^ nums[i])+subsetXORSum(nums,i+1,x);\\n    }\\n};\\n```\\n```\\nclass Solution {\\npublic:\\n    int subsetXORSum(vector<int>& nums) {\\n        int n = nums.size(), totalSubsets = 1<<n, sum = 0;\\n        for(int mask=0;mask<totalSubsets;mask++){\\n            int subXor = 0,x=1;\\n            for(int i=0;i<n;i++){\\n                if(mask & x) subXor ^= nums[i];x<<=1;\\n            }\\n            sum += subXor;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findAllSubsetXor(int i, vector<int>& nums, int x) {\\n      if(i == nums.size()) return x;\\n      return findAllSubsetXor(i+1, nums, x ^ nums[i])+findAllSubsetXor(i+1, nums,x);\\n    }\\n    int subsetXORSum(vector<int>& nums) {\\n        return findAllSubsetXor(0,nums,0);\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int subsetXORSum(vector<int>& nums,int i=0,  int x=0) {\\n      if(i == nums.size()) return x;\\n      return subsetXORSum(nums,i+1,x ^ nums[i])+subsetXORSum(nums,i+1,x);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int subsetXORSum(vector<int>& nums) {\\n        int n = nums.size(), totalSubsets = 1<<n, sum = 0;\\n        for(int mask=0;mask<totalSubsets;mask++){\\n            int subXor = 0,x=1;\\n            for(int i=0;i<n;i++){\\n                if(mask & x) subXor ^= nums[i];x<<=1;\\n            }\\n            sum += subXor;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1660795,
                "title": "concise-backtracking-python",
                "content": "* Using backtrack to access all subsets\\n* Using `reduce()` + `lambda` to calculate the list `xor`.\\n\\n```python\\n\\tclass Solution:\\n    def subsetXORSum(self, nums: List[int]) -> int:\\n        ret = []\\n        subsets = []\\n        def dfs(idx):\\n            if idx == len(nums):\\n                if subsets:\\n                    ret.append(reduce(lambda a, b: a^b, subsets))\\n                return\\n\\n\\t\\t\\t# At each step, you can either pick the value or not pick it to your subset.\\n\\t\\t   # pick\\n            subsets.append(nums[idx])\\n            dfs( idx + 1 )\\n\\t\\t\\t# dodn\\'t forget to pop the last pick\\n            subsets.pop()\\n\\t\\t\\t# not pick\\n            dfs( idx + 1 )\\n\\n        dfs(0)\\n        return sum(ret)\\n``",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "* Using backtrack to access all subsets\\n* Using `reduce()` + `lambda` to calculate the list `xor`.\\n\\n```python\\n\\tclass Solution:\\n    def subsetXORSum(self, nums: List[int]) -> int:\\n        ret = []\\n        subsets = []\\n        def dfs(idx):\\n            if idx == len(nums):\\n                if subsets:\\n                    ret.append(reduce(lambda a, b: a^b, subsets))\\n                return\\n\\n\\t\\t\\t# At each step, you can either pick the value or not pick it to your subset.\\n\\t\\t   # pick\\n            subsets.append(nums[idx])\\n            dfs( idx + 1 )\\n\\t\\t\\t# dodn\\'t forget to pop the last pick\\n            subsets.pop()\\n\\t\\t\\t# not pick\\n            dfs( idx + 1 )\\n\\n        dfs(0)\\n        return sum(ret)\\n``",
                "codeTag": "Java"
            },
            {
                "id": 1338826,
                "title": "c-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    int backtrack(vector<int>& nums, int index, int curXor)\\n    {\\n        if (index == nums.size()) {\\n            return curXor;\\n        }\\n        \\n        int withElement = backtrack(nums, index + 1, curXor ^ nums[index]);\\n        int withoutElement = backtrack(nums, index + 1, curXor);\\n        \\n        return withElement + withoutElement;    \\n    }\\n    \\n    int subsetXORSum(vector<int>& nums) \\n    {\\n        int index = 0;\\n        int curXor = 0;\\n        int totalXor = backtrack(nums, index, curXor);\\n        return totalXor;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int backtrack(vector<int>& nums, int index, int curXor)\\n    {\\n        if (index == nums.size()) {\\n            return curXor;\\n        }\\n        \\n        int withElement = backtrack(nums, index + 1, curXor ^ nums[index]);\\n        int withoutElement = backtrack(nums, index + 1, curXor);\\n        \\n        return withElement + withoutElement;    \\n    }\\n    \\n    int subsetXORSum(vector<int>& nums) \\n    {\\n        int index = 0;\\n        int curXor = 0;\\n        int totalXor = backtrack(nums, index, curXor);\\n        return totalXor;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2216715,
                "title": "javascript-to-xor-or-not-to-xor-recursive-path-trailing-in-binary-tree",
                "content": "**Intuition**\\n```\\n          Binary Tree\\n           /       \\\\\\n^=5       Y         N          #  i.e. nums=[5,1,6].\\n        /  \\\\       /  \\\\        #  when meet a nums[i], we can decide whether to XOR with it or not.\\n^=1    Y    N     Y    N       #  so there\\'ll be 2^n possible results for nums.length=n. \\n      / \\\\  / \\\\   / \\\\  / \\\\      #  it becomes a PATH-TRAILING problem of binary tree.\\n^=6   Y N  Y N   Y N  Y N\\n      | |  | |   | |  | |      #  ans = 2+4+3+5+7+1+6+0 = 28.\\n\\t  2 4  3 5   7 1  6 0\\n```\\n\\nI\\'ll do it with **recursive DFS** with 2 variables:\\n\\n`val`: record the results UNTIL NOW.\\n`i`: get the next number.\\n\\n> if `i`=nums.length, means we\\'ve reached to end (there\\'s NO next number)\\n> so we add the result to `sum`.\\n\\n.\\n**Full-Codes**\\n\\n```\\nvar subsetXORSum = function(nums) {\\n    let sum=0;\\n    dfs(0, 0); return sum;\\n    \\n    function dfs(val, i){\\n        if(i<nums.length){\\n            dfs(val^nums[i], i+1);  // to XOR with nums[i].\\n            dfs(val, i+1);          // NOT to XOR.\\n        }\\n        if(i==nums.length){sum+=val};\\n    }\\n};\\n```\\n\\n\\nMore examples of PATH-TRAILING:\\n\\n[112. Path Sum](https://leetcode.com/problems/path-sum/)\\n[257. Binary Tree Paths](https://leetcode.com/problems/binary-tree-paths/)\\n[1022. Sum of Root To Leaf Binary Numbers](https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/)\\n.\\nThanks for your reading and **up-voting** :)\\n\\n**\\u2B50 Check [HERE](https://github.com/Lynn19950915/LeetCode_King) for my full Leetcode Notes ~**\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n          Binary Tree\\n           /       \\\\\\n^=5       Y         N          #  i.e. nums=[5,1,6].\\n        /  \\\\       /  \\\\        #  when meet a nums[i], we can decide whether to XOR with it or not.\\n^=1    Y    N     Y    N       #  so there\\'ll be 2^n possible results for nums.length=n. \\n      / \\\\  / \\\\   / \\\\  / \\\\      #  it becomes a PATH-TRAILING problem of binary tree.\\n^=6   Y N  Y N   Y N  Y N\\n      | |  | |   | |  | |      #  ans = 2+4+3+5+7+1+6+0 = 28.\\n\\t  2 4  3 5   7 1  6 0\\n```\n```\\nvar subsetXORSum = function(nums) {\\n    let sum=0;\\n    dfs(0, 0); return sum;\\n    \\n    function dfs(val, i){\\n        if(i<nums.length){\\n            dfs(val^nums[i], i+1);  // to XOR with nums[i].\\n            dfs(val, i+1);          // NOT to XOR.\\n        }\\n        if(i==nums.length){sum+=val};\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1609018,
                "title": "java-100-faster",
                "content": "```\\n\\tint res = 0;\\n    public int subsetXORSum(int[] nums) {\\n        subsets(nums, 0, 0);\\n        return res;\\n    }\\n    \\n    void subsets(int[] nums, int start, int xor) {\\n        res += xor;\\n        \\n        for(int i = start; i < nums.length; i++) {\\n            subsets(nums, i+1, xor ^ nums[i]);\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\n\\tint res = 0;\\n    public int subsetXORSum(int[] nums) {\\n        subsets(nums, 0, 0);\\n        return res;\\n    }\\n    \\n    void subsets(int[] nums, int start, int xor) {\\n        res += xor;\\n        \\n        for(int i = start; i < nums.length; i++) {\\n            subsets(nums, i+1, xor ^ nums[i]);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1225878,
                "title": "cpp-solution-simple-to-understand",
                "content": "**Do upvote if you like the solution **\\n```\\nclass Solution {\\npublic:\\n    int subsetXORSum(vector<int>& nums) {\\n        \\n        \\n        int n = nums.size();\\n        int sum=0;\\n        int limit = 1<<n ;\\n        for(int i=0;i< limit;i++)\\n        {\\n            int xoR=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i & (1<<j))\\n                {\\n                    xoR^= nums[j];\\n                }\\n            }\\n            sum+= xoR;\\n        }\\n        return sum;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int subsetXORSum(vector<int>& nums) {\\n        \\n        \\n        int n = nums.size();\\n        int sum=0;\\n        int limit = 1<<n ;\\n        for(int i=0;i< limit;i++)\\n        {\\n            int xoR=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i & (1<<j))\\n                {\\n                    xoR^= nums[j];\\n                }\\n            }\\n            sum+= xoR;\\n        }\\n        return sum;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1214497,
                "title": "python-3-5-line-simple-100-faster-combination-accumulate",
                "content": "```\\ndef subsetXORSum(self, nums: List[int]) -> int:\\n\\nfrom itertools import combinations, accumulate\\n\\nres = 0\\nfor i in range(1, len(nums)+1):  # Iterate through all lengths of subsets\\n\\tfor arr in combinations(nums, i):  # Sum up the XOR results\\n\\t\\tres += list(accumulate(arr, func=lambda x, y: x ^ y))[-1]\\nreturn res",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef subsetXORSum(self, nums: List[int]) -> int:\\n\\nfrom itertools import combinations, accumulate\\n\\nres = 0\\nfor i in range(1, len(nums)+1):  # Iterate through all lengths of subsets\\n\\tfor arr in combinations(nums, i):  # Sum up the XOR results\\n\\t\\tres += list(accumulate(arr, func=lambda x, y: x ^ y))[-1]\\nreturn res",
                "codeTag": "Python3"
            },
            {
                "id": 3738461,
                "title": "simplest-solution-using-subset-generation-technique-with-explanation",
                "content": "**Overview of th Approach :**   1. We will store xor of Every Subset into a Vector ans , and the we will return the sum of the elements of the vector.\\n\\n**Step-1 :**  We will Generate the Subset using Pick and non-Pick approach. For that we will create one function generateSubs () ,in this function when the index will be equal to the size of the given array we will get one subset and after getting one subset we will iterate over it and calculate the xor of that subset .\\n\\n**Step-2 :** Just store the xor of every subset into a vector or any data structure and just return the sum .\\n\\n\\n**Time Complexity will be : O(2 ^n * ds.size() ) ~~ O(2^n)  as we are looping till ds.size()  only when index == size(). and 2^n recuresion calls will be there .**\\n\\n```\\nclass Solution {\\npublic:\\nvector<int> ans;\\nvector<int> ds;\\n\\nvoid generateSubs(vector<int> &nums , int index){\\n    if(index == nums.size()){\\n        int xorAns=0;\\n        for(auto &i:ds){\\n            xorAns ^= i;\\n        }\\n        ans.push_back(xorAns);\\n        return;\\n    }\\n    ds.push_back(nums[index]);\\n    generateSubs(nums,index+1);\\n    ds.pop_back();\\n    generateSubs(nums,index+1);\\n}\\nint subsetXORSum(vector<int>& nums) {\\n\\n    generateSubs(nums,0);\\n    return accumulate(ans.begin(),ans.end(),0);\\n\\n}\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<int> ans;\\nvector<int> ds;\\n\\nvoid generateSubs(vector<int> &nums , int index){\\n    if(index == nums.size()){\\n        int xorAns=0;\\n        for(auto &i:ds){\\n            xorAns ^= i;\\n        }\\n        ans.push_back(xorAns);\\n        return;\\n    }\\n    ds.push_back(nums[index]);\\n    generateSubs(nums,index+1);\\n    ds.pop_back();\\n    generateSubs(nums,index+1);\\n}\\nint subsetXORSum(vector<int>& nums) {\\n\\n    generateSubs(nums,0);\\n    return accumulate(ans.begin(),ans.end(),0);\\n\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2611932,
                "title": "c-easy-0-ms",
                "content": "```\\nclass Solution {\\n    int result;\\n    void helper(vector<int>& nums,int sum,int i)\\n    {\\n        if(i==nums.size()-1) {\\n            result+= sum + (sum^nums[i]);\\n            return;\\n        }\\n        helper(nums,sum,i+1);\\n        helper(nums,sum^nums[i],i+1);\\n    }\\npublic:\\n    int subsetXORSum(vector<int>& nums) {\\n        result=0;\\n        helper(nums,0,0);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    int result;\\n    void helper(vector<int>& nums,int sum,int i)\\n    {\\n        if(i==nums.size()-1) {\\n            result+= sum + (sum^nums[i]);\\n            return;\\n        }\\n        helper(nums,sum,i+1);\\n        helper(nums,sum^nums[i],i+1);\\n    }\\npublic:\\n    int subsetXORSum(vector<int>& nums) {\\n        result=0;\\n        helper(nums,0,0);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2562697,
                "title": "explained-backtracking-java-c",
                "content": "```\\n/* Java Solution */\\nclass Solution {\\n    public int subsetXORSum(int[] nums) {\\n        return helper(nums, 0, 0);\\n    }\\n    \\n    private int helper(int[] nums, int index, int currentXor) {\\n        // return currentXor when all elements in nums are already considered\\n        if (index == nums.length) return currentXor;\\n        \\n        // calculate sum of xor with current element\\n        int withElement = helper(nums, index + 1, currentXor ^ nums[index]);\\n        \\n        // calculate sum of xor without current element\\n        int withoutElement = helper(nums, index + 1, currentXor);\\n        \\n        // return sum of xors from recursion\\n        return withElement + withoutElement;\\n    }\\n}\\n\\n\\n\\n/* C++ Solution */\\nclass Solution {\\npublic:\\n    int subsetXORSum(vector<int>& nums) {\\n        return helper(nums,0,0);\\n    }\\n    \\n    int helper(vector<int>& nums, int index, int currentXor) {\\n        // return currentXor when all elements in nums are already considered\\n        if (index == nums.size()) return currentXor;\\n        \\n        // calculate sum of xor with current element\\n        int withElement = helper(nums, index + 1, currentXor ^ nums[index]);\\n        \\n        // calculate sum of xor without current element\\n        int withoutElement = helper(nums, index + 1, currentXor);\\n        \\n        // return sum of xors from recursion\\n        return withElement + withoutElement;\\n    }\\n};\\n\\n\\n\\n/*\\n\\tif(you like)\\n\\t\\tplease upvote;\\n*/\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n/* Java Solution */\\nclass Solution {\\n    public int subsetXORSum(int[] nums) {\\n        return helper(nums, 0, 0);\\n    }\\n    \\n    private int helper(int[] nums, int index, int currentXor) {\\n        // return currentXor when all elements in nums are already considered\\n        if (index == nums.length) return currentXor;\\n        \\n        // calculate sum of xor with current element\\n        int withElement = helper(nums, index + 1, currentXor ^ nums[index]);\\n        \\n        // calculate sum of xor without current element\\n        int withoutElement = helper(nums, index + 1, currentXor);\\n        \\n        // return sum of xors from recursion\\n        return withElement + withoutElement;\\n    }\\n}\\n\\n\\n\\n/* C++ Solution */\\nclass Solution {\\npublic:\\n    int subsetXORSum(vector<int>& nums) {\\n        return helper(nums,0,0);\\n    }\\n    \\n    int helper(vector<int>& nums, int index, int currentXor) {\\n        // return currentXor when all elements in nums are already considered\\n        if (index == nums.size()) return currentXor;\\n        \\n        // calculate sum of xor with current element\\n        int withElement = helper(nums, index + 1, currentXor ^ nums[index]);\\n        \\n        // calculate sum of xor without current element\\n        int withoutElement = helper(nums, index + 1, currentXor);\\n        \\n        // return sum of xors from recursion\\n        return withElement + withoutElement;\\n    }\\n};\\n\\n\\n\\n/*\\n\\tif(you like)\\n\\t\\tplease upvote;\\n*/\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2110416,
                "title": "c-backtracking-bit-manipulation-and-optimization-explained",
                "content": "A simple backtracking based solution, where we either choose the element at *index* or ignore it is as follows:\\n```\\nclass Solution {\\nprivate:\\n    int res = 0;\\n    void solve(vector<int>& nums, int index, int curr){\\n        if(index == nums.size()){\\n            res += curr;\\n            return;\\n        }\\n        // If we choose the element at index\\n        solve(nums, index + 1, curr ^ nums[index]);\\n        // If we don\\'t choose the element at index\\n        solve(nums, index + 1, curr);\\n    }\\n    \\npublic:\\n    int subsetXORSum(vector<int>& nums) {\\n        solve(nums, 0, 0);\\n        return res;\\n    }\\n};\\n```\\n\\n# Optimization\\nConsider a simple example of **[1, 3]**. Let\\'s depict the numbers in binary form and see what how the result is formed.\\n```\\n[1]                    = 1           -->                      0 0 1\\n[3]                    = 3           -->                      0 1 1\\n[1, 3] = 1 ^ 3         = 2           -->                      0 1 0\\n-----------------------------------------------------------------------\\nTotal =                  6          -->                       1 1 0 \\n```\\n\\nConsider another example of **[1,3, 4]**.\\n```\\n[1]                    = 1           -->                      0 0 1\\n[3]                    = 3           -->                      0 1 1\\n[4]                    = 4           -->                      1 0 0\\n[1, 3] = 1 ^ 3         = 2           -->                      0 1 0\\n[1, 4] = 1 ^ 4         = 5           -->                      1 0 1\\n[3, 4] = 3 ^ 4         = 7           -->                      1 1 1\\n[1, 3, 4] = 1 ^ 3 ^ 4  = 6           -->                      1 1 0\\n-----------------------------------------------------------------------\\nTotal =                  28          -->                      1 1 0 0 0\\n```\\n\\nWe can see that in total, one appears *2 x (n-1)* times in each bit position. Thus, optimization can be achieved by doing **OR** operation of all the numbers, and multiplying the result by *2 x (n-1)*.\\n```\\nclass Solution {\\npublic:\\n    int subsetXORSum(vector<int>& nums) {\\n        int res = 0;\\n        for (auto &num: nums) res |= num;\\n        return res << nums.size() - 1;\\n    }\\n};\\n```\\n\\nDo consider upvoting, if found useful :)\\n",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int res = 0;\\n    void solve(vector<int>& nums, int index, int curr){\\n        if(index == nums.size()){\\n            res += curr;\\n            return;\\n        }\\n        // If we choose the element at index\\n        solve(nums, index + 1, curr ^ nums[index]);\\n        // If we don\\'t choose the element at index\\n        solve(nums, index + 1, curr);\\n    }\\n    \\npublic:\\n    int subsetXORSum(vector<int>& nums) {\\n        solve(nums, 0, 0);\\n        return res;\\n    }\\n};\\n```\n```\\n[1]                    = 1           -->                      0 0 1\\n[3]                    = 3           -->                      0 1 1\\n[1, 3] = 1 ^ 3         = 2           -->                      0 1 0\\n-----------------------------------------------------------------------\\nTotal =                  6          -->                       1 1 0 \\n```\n```\\n[1]                    = 1           -->                      0 0 1\\n[3]                    = 3           -->                      0 1 1\\n[4]                    = 4           -->                      1 0 0\\n[1, 3] = 1 ^ 3         = 2           -->                      0 1 0\\n[1, 4] = 1 ^ 4         = 5           -->                      1 0 1\\n[3, 4] = 3 ^ 4         = 7           -->                      1 1 1\\n[1, 3, 4] = 1 ^ 3 ^ 4  = 6           -->                      1 1 0\\n-----------------------------------------------------------------------\\nTotal =                  28          -->                      1 1 0 0 0\\n```\n```\\nclass Solution {\\npublic:\\n    int subsetXORSum(vector<int>& nums) {\\n        int res = 0;\\n        for (auto &num: nums) res |= num;\\n        return res << nums.size() - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2078954,
                "title": "go-backtrack",
                "content": "```\\nfunc subsetXORSum(nums []int) int {\\n    return backtrack(nums, 0)\\n}\\n\\nfunc backtrack(nums []int, curXor int) int {\\n    if len(nums) == 0 {\\n        return curXor\\n    }\\n    \\n    withNum := backtrack(nums[1:], curXor ^ nums[0])\\n    withoutNum := backtrack(nums[1:], curXor)\\n    \\n    return withNum + withoutNum\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc subsetXORSum(nums []int) int {\\n    return backtrack(nums, 0)\\n}\\n\\nfunc backtrack(nums []int, curXor int) int {\\n    if len(nums) == 0 {\\n        return curXor\\n    }\\n    \\n    withNum := backtrack(nums[1:], curXor ^ nums[0])\\n    withoutNum := backtrack(nums[1:], curXor)\\n    \\n    return withNum + withoutNum\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1813982,
                "title": "one-liner-oms-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int subsetXORSum(vector<int>& nums) {\\n       return accumulate(begin(nums), end(nums), 0, bit_or<int>()) << (nums.size() - 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subsetXORSum(vector<int>& nums) {\\n       return accumulate(begin(nums), end(nums), 0, bit_or<int>()) << (nums.size() - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1725119,
                "title": "c-recursion-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int sum=0;\\n    void solve(vector<int>& nums,int i,int xr){\\n        if(i==nums.size()) sum+=xr;\\n        else {\\n            solve(nums,i+1,xr^nums[i]);\\n            solve(nums,i+1,xr);\\n        }\\n        \\n    }\\n    int subsetXORSum(vector<int>& nums) {\\n        solve(nums,0,0);\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sum=0;\\n    void solve(vector<int>& nums,int i,int xr){\\n        if(i==nums.size()) sum+=xr;\\n        else {\\n            solve(nums,i+1,xr^nums[i]);\\n            solve(nums,i+1,xr);\\n        }\\n        \\n    }\\n    int subsetXORSum(vector<int>& nums) {\\n        solve(nums,0,0);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1406975,
                "title": "java-very-simple-solution",
                "content": "class Solution {\\n    public int subsetXORSum(int[] nums) {\\n        return subs(nums,0,0);\\n        \\n    }\\n    public int subs(int nums[],int i, int xor)\\n    {\\n        if(i==nums.length)\\n            return xor;\\n        return subs(nums,i+1,xor^nums[i]) + subs(nums,i+1,xor);\\n    }\\n}****\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "class Solution {\\n    public int subsetXORSum(int[] nums) {\\n        return subs(nums,0,0);\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1347478,
                "title": "java-recursion-100-faster-solution",
                "content": "```\\nclass Solution {\\n    public int subsetXORSum(int[] nums) {\\n        return go(nums, 0, 0);\\n    }\\n\\n    private int go(int[] nums, int i, int xor) {\\n        if (i == nums.length) return xor;\\n        return go(nums, i + 1, xor ^ nums[i]) + go(nums, i + 1, xor);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int subsetXORSum(int[] nums) {\\n        return go(nums, 0, 0);\\n    }\\n\\n    private int go(int[] nums, int i, int xor) {\\n        if (i == nums.length) return xor;\\n        return go(nums, i + 1, xor ^ nums[i]) + go(nums, i + 1, xor);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1343016,
                "title": "c-0ms-solution-with-detailed-explanation-of-the-concept",
                "content": "Explanation link is here [https://medium.com/programming-problems-and-solutions/sum-of-all-subset-xor-totals-928a06fb7ae0]\\n\\n```\\nint subsetXORSum(vector<int>& nums) {\\n        int ors= 0;\\n        for(int i=0;i<nums.size();++i){\\n            ors|=nums[i];\\n        }\\n        return pow(2,nums.size()-1)*(ors);\\n       \\n    }\\n\\t```\\n\\t",
                "solutionTags": [],
                "code": "```\\nint subsetXORSum(vector<int>& nums) {\\n        int ors= 0;\\n        for(int i=0;i<nums.size();++i){\\n            ors|=nums[i];\\n        }\\n        return pow(2,nums.size()-1)*(ors);\\n       \\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1302492,
                "title": "c-solution-recursion-100-faster",
                "content": "Explanation:\\n\\n1. The basic idea is to find the XOR totals of all the subsets and add them up.\\n2. Let F(idx, current_xor_total) be a function that returns the sum of XOR totals of all subsets from index `idx`.\\n3. When we are at the index `idx`, we have 2 options to consider: we can either include the element at \\'idx\\' or not include it in the subset.\\n4. So the recursive relation can be defined as:` F(idx, current_xor_total) -> F(idx+1,current_xor_total^nums[idx])+F(idx+1,current_xor_total)`\\n(i) When we are including the `idx` element in the subset then we must xor `nums[idx]` to the current_xor_total. This is given by `F(idx+1,current_xor_total^nums[idx])`\\n(ii) When we are not including `idx` in the subset then we do not need to xor the element and just move forward by incrementing `idx`. This is given by `F(idx+1,current_xor_total)`\\n4. As our recursive relation is done, we need to define the base case which can be defined as:\\n`if(idx==nums.size()) return current_xor_total`\\n\\nCode:\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int> &nums, int indx,int current_xor_total)\\n    {\\n        if(indx==nums.size())\\n        {\\n            return current_xor_total;\\n        }\\n        return solve(nums,indx+1,current_xor_total^nums[indx])+solve(nums,indx+1,current_xor_total);\\n    }\\n    int subsetXORSum(vector<int>& nums) {\\n        return solve(nums,0,0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int> &nums, int indx,int current_xor_total)\\n    {\\n        if(indx==nums.size())\\n        {\\n            return current_xor_total;\\n        }\\n        return solve(nums,indx+1,current_xor_total^nums[indx])+solve(nums,indx+1,current_xor_total);\\n    }\\n    int subsetXORSum(vector<int>& nums) {\\n        return solve(nums,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1236661,
                "title": "javascript-backtracking",
                "content": "Runtime: 72 ms, faster than 96.53% of JavaScript online submissions for Sum of All Subset XOR Totals.\\n```\\nvar subsetXORSum = function(nums) {\\n    let output=[];\\n    backtrack();\\n    return output.reduce((a,b)=>a+b);\\n    function backtrack(start = 0, arr=[nums[0]]){\\n       output.push([...arr].reduce((a,b)=>a^b,0));\\n       for(let i=start; i<nums.length; i++){\\n            arr.push(nums[i]);\\n            backtrack(i+1, arr);\\n            arr.pop();\\n       }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\nvar subsetXORSum = function(nums) {\\n    let output=[];\\n    backtrack();\\n    return output.reduce((a,b)=>a+b);\\n    function backtrack(start = 0, arr=[nums[0]]){\\n       output.push([...arr].reduce((a,b)=>a^b,0));\\n       for(let i=start; i<nums.length; i++){\\n            arr.push(nums[i]);\\n            backtrack(i+1, arr);\\n            arr.pop();\\n       }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1229039,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    void helper(vector<int>& nums,int index,int tmp,int &sum)\\n    {\\n        if(index==nums.size())\\n        {\\n            sum+=tmp;\\n            return;\\n        }\\n        helper(nums,index+1,tmp^nums[index],sum);\\n        helper(nums,index+1,tmp,sum);\\n    }\\n    int subsetXORSum(vector<int>& nums) \\n    {\\n        int sum=0;\\n        helper(nums,0,0,sum);\\n        return sum;\\n    }\\n};\\n```\\n**Please upvote if you have got any help from my code. Thank you.**",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    void helper(vector<int>& nums,int index,int tmp,int &sum)\\n    {\\n        if(index==nums.size())\\n        {\\n            sum+=tmp;\\n            return;\\n        }\\n        helper(nums,index+1,tmp^nums[index],sum);\\n        helper(nums,index+1,tmp,sum);\\n    }\\n    int subsetXORSum(vector<int>& nums) \\n    {\\n        int sum=0;\\n        helper(nums,0,0,sum);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1212570,
                "title": "python-python3-solution-brute-force-optimized",
                "content": "**Brute Force Code:**\\n```\\nclass Solution:\\n    def XoRSum(self,lis):\\n        if lis == []:\\n            return 0\\n        if len(lis) == 1:\\n            return lis[0]\\n        xor = 0\\n        for i in lis:\\n            xor ^= i\\n        return xor\\n    def subset(self,seq):\\n        if len(seq) <= 0:\\n            yield []\\n        else:\\n            for item in self.subset(seq[1:]):\\n                yield [seq[0]]+item\\n                yield item\\n    def subsetXORSum(self, nums: List[int]) -> int:\\n        lis = [x for x in self.subset(nums)]\\n        sumXor = 0\\n        lis.sort()\\n        #print(lis)\\n        for i in lis:\\n            sumXor += self.XoRSum(i)\\n        return sumXor\\n```\\nIn the above Solution \\n* I have used generator concept to generate the all the subset. (To know more about generator [click here](https://www.programiz.com/python-programming/generator#:~:text=Python%20generators%20are%20a%20simple%20way%20of%20creating%20iterators.&text=Simply%20speaking%2C%20a%20generator%20is,one%20value%20at%20a%20time).)\\n* After generating all the subset in the list.\\n* Finding the xor values by passing the subset list generated and adding it to sumXor.\\n\\n**Optimized Solution:**\\n```\\nclass Solution:\\n    def subsetXORSum(self, nums: List[int]) -> int:\\n        sumXor = 0\\n        for i in nums:\\n            sumXor |= i\\n        return sumXor * 2 ** (len(nums)-1)\\n```\\n\\nIf you need detailed explaination on the above code kindly visit [@srinivasteja18 Code\\'s post](https://leetcode.com/problems/sum-of-all-subset-xor-totals/discuss/1211177/C%2B%2B-simple-solution-oror-5-lines-of-code-oror-Explained!!)\\n\\n***We rise by lifting others***\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def XoRSum(self,lis):\\n        if lis == []:\\n            return 0\\n        if len(lis) == 1:\\n            return lis[0]\\n        xor = 0\\n        for i in lis:\\n            xor ^= i\\n        return xor\\n    def subset(self,seq):\\n        if len(seq) <= 0:\\n            yield []\\n        else:\\n            for item in self.subset(seq[1:]):\\n                yield [seq[0]]+item\\n                yield item\\n    def subsetXORSum(self, nums: List[int]) -> int:\\n        lis = [x for x in self.subset(nums)]\\n        sumXor = 0\\n        lis.sort()\\n        #print(lis)\\n        for i in lis:\\n            sumXor += self.XoRSum(i)\\n        return sumXor\\n```\n```\\nclass Solution:\\n    def subsetXORSum(self, nums: List[int]) -> int:\\n        sumXor = 0\\n        for i in nums:\\n            sumXor |= i\\n        return sumXor * 2 ** (len(nums)-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4019874,
                "title": "optimal-solution-c-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI started by counting how many combinations there are for each number or how many times a number will be in subset I calculated this using combinations \\nfor example  $\\\\binom{3}{1}+\\\\binom{3}{2}+\\\\binom{3}{3}$ for size 3, so I figured that if a number has a bit in it that other numbers don\\'t the bit will be added exacly that many times because XOR doesnt affect it for this example with number 3 it is 4 times \\nthen I noticed it works even if other numbers have the same bit because XORing same bits cancels out all the additional combinations. In the exaple with 3 numbers lets say two of the numbers are 1 each will have 4 combinations but $\\\\binom{1}{0}+\\\\binom{1}{1} $(using 1 as $n$ beacause we have 2 unchangable numbers from 3 so $3-2$)common combinations which will cancel 2 of them for each resulting in 4 again.\\nSo we just need to multiply number with all the used bits by sum of all the combinations \\nsum of all combinations are powers of 2 as you can see in this Pascals triangle \\n![Screenshot 2023-09-08 214255.png](https://assets.leetcode.com/users/images/174b74e5-6e63-4493-8f96-a8a8616f034f_1694202250.0160797.png)\\nso we can achieve this by bitshifting\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf a bit apears in any number at least once it will be used in addition exacly $2^{n-1}$ times so we just need to get all used bits in a number and bit shift them $n-1$ times to the left \\n# Complexity\\n- Time complexity: $O(N)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(1)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subsetXORSum(vector<int>& nums) {\\n       int res = 0;\\n       for(int n :nums){\\n           res|=n;\\n       } \\n       return res<<(nums.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subsetXORSum(vector<int>& nums) {\\n       int res = 0;\\n       for(int n :nums){\\n           res|=n;\\n       } \\n       return res<<(nums.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3772042,
                "title": "detailed-explanation-of-the-topic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code calculates the XOR sum of all possible subsets of the input list nums and returns the result\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Perform bitwise OR operation: ans |= x performs a bitwise OR operation between the current ans value and the current number x. The bitwise OR operation (|) combines the bits of ans and x, setting a bit to 1 if either of the corresponding bits in ans or x is 1. This step accumulates the XOR values of all the numbers in nums into ans.\\n\\n2. Calculate the final result: return ans * 2 ** (len(nums)-1) calculates the XOR sum of all subsets. The XOR sum of all subsets can be derived by multiplying the accumulated XOR value ans with 2 ** (len(nums)-1), where 2 ** (len(nums)-1) represents the total number of subsets of nums.\\n\\nThe expression 2 ** (len(nums)-1) calculates the total number of subsets by taking 2 to the power of len(nums)-1. Since each element in nums can either be included or excluded in a subset, there are 2 choices for each element, resulting in a total of 2 ** len(nums) subsets. By subtracting 1 (len(nums)-1), we exclude the empty set from the count, giving us the total number of non-empty subsets.\\nMultiplying ans by 2 ** (len(nums)-1) gives us the XOR sum of all subsets.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\nThe loop for x in nums: iterates through each number in the nums list. Hence, the time complexity of the loop is **O(N)**, where N is the length of the nums list.\\nThe bitwise OR operation ans |= x is a constant time operation.\\nCalculating 2 ** (len(nums)-1) is also a constant time operation.\\nOverall, the time complexity of the code snippet is O(N), where N is the length of the nums list.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nThe space complexity is determined by the usage of additional memory, excluding the input and the output space.\\nThe only additional space used in this code snippet is for the variable ans.\\nSince ans is a single integer variable, the space complexity is **O(1)**, constant space.\\n\\n# Code\\n```\\nclass Solution:\\n    def subsetXORSum(self, nums: List[int]) -> int:\\n        res =0\\n        for x in nums:\\n            res |= x\\n        return res*(2**(len(nums)-1))\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subsetXORSum(self, nums: List[int]) -> int:\\n        res =0\\n        for x in nums:\\n            res |= x\\n        return res*(2**(len(nums)-1))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3727829,
                "title": "java-solution-using-recursion-with-example-and-explanation",
                "content": "**Approach**\\nWe can use the recursive approach of generating all subsets .\\n![image](https://assets.leetcode.com/users/images/cdc7cef1-9a78-4b36-9ae8-fdaa9dda0b34_1688655681.940065.png)\\n![image](https://assets.leetcode.com/users/images/2162d0f8-453f-4fd2-bc55-68a5864a1e24_1688655692.6975644.png)\\n```\\nclass Solution {\\n    int sum=0;\\n    public void fnSubset(int nums[],int xor,int index)\\n    {\\n        if(index==nums.length)//subset generated\\n        {\\n            sum+=xor;//adding the xor of all subsets \\n            return ;\\n            \\n        }\\n        fnSubset(nums,xor^nums[index],index+1);//including the element at index\\n        fnSubset(nums,xor,index+1);//excluding the element at index\\n    }\\n    public int subsetXORSum(int[] nums) {\\n            fnSubset(nums,0,0);\\n        return sum;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int sum=0;\\n    public void fnSubset(int nums[],int xor,int index)\\n    {\\n        if(index==nums.length)//subset generated\\n        {\\n            sum+=xor;//adding the xor of all subsets \\n            return ;\\n            \\n        }\\n        fnSubset(nums,xor^nums[index],index+1);//including the element at index\\n        fnSubset(nums,xor,index+1);//excluding the element at index\\n    }\\n    public int subsetXORSum(int[] nums) {\\n            fnSubset(nums,0,0);\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3359127,
                "title": "simple-c-code-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSubsets are needed to be made so use take not take method\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nEach time while creating a subset evaluate the XOR in the recursive call. When the base case is met, simply add them. \\n\\nExplained with comment for better understanding.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(2^n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ \\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void help(int i,vector<int>&nums,int &ans,int sum){\\n        if(i==nums.size()){\\n            ans+=sum;\\n            return;\\n        }\\n        //  { Same concept used as Subset }\\n        // Recursive call to take it.\\n        help(i+1,nums,ans,sum^nums[i]); // If taken then XOR is done \\n        //Recursive call to not take it\\n        help(i+1,nums,ans,sum);\\n    }\\n    int subsetXORSum(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=0;\\n        help(0,nums,ans,0);\\n        return ans;\\n    }\\n};\\n```\\n# Please Upvote if it was helpful\\u2B06\\uFE0F",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void help(int i,vector<int>&nums,int &ans,int sum){\\n        if(i==nums.size()){\\n            ans+=sum;\\n            return;\\n        }\\n        //  { Same concept used as Subset }\\n        // Recursive call to take it.\\n        help(i+1,nums,ans,sum^nums[i]); // If taken then XOR is done \\n        //Recursive call to not take it\\n        help(i+1,nums,ans,sum);\\n    }\\n    int subsetXORSum(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=0;\\n        help(0,nums,ans,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3138987,
                "title": "very-easy-way-in-cpp",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subsetXORSum(vector<int>& nums) {\\n        \\n   \\n        int n=nums.size();\\n\\n        int x=pow(2,n-1);\\n\\n        int bit=0;\\n        for(int i=0; i<n; i++){\\n            bit |=nums[i];\\n        }\\n        return (bit)*(x);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subsetXORSum(vector<int>& nums) {\\n        \\n   \\n        int n=nums.size();\\n\\n        int x=pow(2,n-1);\\n\\n        int bit=0;\\n        for(int i=0; i<n; i++){\\n            bit |=nums[i];\\n        }\\n        return (bit)*(x);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2958347,
                "title": "easy-c-solution-recursion-0ms-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe create all the subset that can be formed and calculate XOR of each subset that can be fromed.\\n\\n\\n# Complexity\\n- Time complexity:O(2^N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subset(int i, vector<int> &v ,vector<int> & nums,int n)\\n    {\\n        if (i == n)\\n        {\\n            int ans = 0;\\n            for (auto i : v)\\n            ans^= i;\\n            return ans;\\n        }\\n        v.push_back(nums[i]);\\n        int l = subset(i+1, v,nums,n);\\n        v.pop_back();\\n        int r = subset(i+1, v,nums,n);\\n        return l+r;\\n    }\\n    int subsetXORSum(vector<int>& nums) {\\n        vector<int> v;\\n        return subset(0,v,nums,nums.size());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subset(int i, vector<int> &v ,vector<int> & nums,int n)\\n    {\\n        if (i == n)\\n        {\\n            int ans = 0;\\n            for (auto i : v)\\n            ans^= i;\\n            return ans;\\n        }\\n        v.push_back(nums[i]);\\n        int l = subset(i+1, v,nums,n);\\n        v.pop_back();\\n        int r = subset(i+1, v,nums,n);\\n        return l+r;\\n    }\\n    int subsetXORSum(vector<int>& nums) {\\n        vector<int> v;\\n        return subset(0,v,nums,nums.size());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2917155,
                "title": "easiest-java-solution-with-100-faster-time-complexity",
                "content": "\\n# Code\\n```\\nclass Solution {\\n\\n    int solve(int[] nums, int idx, int currentXor){\\n\\n        if(idx==nums.length)\\n        return currentXor;\\n\\n        int with = solve(nums, idx+1, currentXor^nums[idx]);\\n        int without = solve(nums, idx+1, currentXor);\\n\\n        return with + without;\\n    }\\n    public int subsetXORSum(int[] nums) {\\n        return solve(nums, 0, 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n\\n    int solve(int[] nums, int idx, int currentXor){\\n\\n        if(idx==nums.length)\\n        return currentXor;\\n\\n        int with = solve(nums, idx+1, currentXor^nums[idx]);\\n        int without = solve(nums, idx+1, currentXor);\\n\\n        return with + without;\\n    }\\n    public int subsetXORSum(int[] nums) {\\n        return solve(nums, 0, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2550640,
                "title": "two-python-solutions-naive-and-fast",
                "content": "Here is my naive solution:\\n\\n```python\\n    def subsetXORSum(self, nums: List[int]) -> int:\\n        ans = 0\\n        for ss in range(1<<len(nums)):\\n            xsum = 0\\n            for num in nums:\\n                if ss & 1:\\n                    xsum ^= num\\n                ss >>= 1\\n            ans += xsum\\n        return ans\\n```\\n\\nAnd another one extra fast. The intuition is well explained by many others.\\n```python\\n    def subsetXORSum(self, nums: List[int]) -> int:\\n        bits = 0\\n        for a in nums:\\n            bits |= a\\n        return bits * 1 << (len(nums)-1)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n    def subsetXORSum(self, nums: List[int]) -> int:\\n        ans = 0\\n        for ss in range(1<<len(nums)):\\n            xsum = 0\\n            for num in nums:\\n                if ss & 1:\\n                    xsum ^= num\\n                ss >>= 1\\n            ans += xsum\\n        return ans\\n```\n```python\\n    def subsetXORSum(self, nums: List[int]) -> int:\\n        bits = 0\\n        for a in nums:\\n            bits |= a\\n        return bits * 1 << (len(nums)-1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2121984,
                "title": "c-simple-solution",
                "content": "**Power Set Algorithm as constraint is very less.**\\n\\n```\\nclass Solution {\\npublic:\\n    int subsetXORSum(vector<int>& nums) {\\n        int n = nums.size(),ans = 0;\\n        \\n        for(int i = 0;i<(1<<n);i++){\\n            int xo =0;\\n            for(int bits = 0;bits<n;bits++){\\n                if(i&1<<bits){\\n                    xo=xo^nums[bits];\\n                }\\n            }\\n            ans+=xo;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subsetXORSum(vector<int>& nums) {\\n        int n = nums.size(),ans = 0;\\n        \\n        for(int i = 0;i<(1<<n);i++){\\n            int xo =0;\\n            for(int bits = 0;bits<n;bits++){\\n                if(i&1<<bits){\\n                    xo=xo^nums[bits];\\n                }\\n            }\\n            ans+=xo;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2094992,
                "title": "backtrack-99ms-solution-python",
                "content": "\\'\\'\\'        \\n\\t\\t\\n\\t\\tself.s=0\\n        def backtrack(idx=0,s=0):\\n            self.s+=s\\n            if idx>=len(nums):\\n                return\\n            \\n            for i in range(idx,len(nums)):\\n                backtrack(i+1,s^nums[i])\\n        backtrack()\\n        return self.s\\n\\'\\'\\'",
                "solutionTags": [
                    "Backtracking",
                    "Recursion"
                ],
                "code": "\\'\\'\\'        \\n\\t\\t\\n\\t\\tself.s=0\\n        def backtrack(idx=0,s=0):\\n            self.s+=s\\n            if idx>=len(nums):\\n                return\\n            \\n            for i in range(idx,len(nums)):\\n                backtrack(i+1,s^nums[i])\\n        backtrack()\\n        return self.s\\n\\'\\'\\'",
                "codeTag": "Python3"
            },
            {
                "id": 2070778,
                "title": "4-line-python-solution",
                "content": "0 ^ number = number itself\\n```\\ndef subsetXORSum(self, nums: List[int]) -> int:\\n\\tresult = [0]\\n\\tfor num in nums:\\n\\t\\tresult += [r ^ num for r in result]\\n\\treturn sum(result)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef subsetXORSum(self, nums: List[int]) -> int:\\n\\tresult = [0]\\n\\tfor num in nums:\\n\\t\\tresult += [r ^ num for r in result]\\n\\treturn sum(result)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1906673,
                "title": "java-easy-solution-recursion-2-lines-of-code-tc-o-n",
                "content": "```\\nclass Solution {\\n    public int solveXORSum(int[] nums, int i, int ans) {\\n        if(i == nums.length) {\\n            return ans;\\n        }\\n        return solveXORSum(nums,i+1,ans^nums[i]) + solveXORSum(nums,i+1,ans);\\n    }\\n    \\n    public int subsetXORSum(int[] nums) {\\n        return solveXORSum(nums,0,0);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int solveXORSum(int[] nums, int i, int ans) {\\n        if(i == nums.length) {\\n            return ans;\\n        }\\n        return solveXORSum(nums,i+1,ans^nums[i]) + solveXORSum(nums,i+1,ans);\\n    }\\n    \\n    public int subsetXORSum(int[] nums) {\\n        return solveXORSum(nums,0,0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1772293,
                "title": "java-0-ms-1-liner",
                "content": "**Method 1:** Reuse [LC 78. Subsets](https://leetcode.com/problems/subsets/discuss/351412/Java-or-DFS-or-BFS-or-Time-and-Memory-beats-100-or-With-video-explanation). Generate all subsets, find xor of the subset and return the total sum of all the subset xors\\n>**T/S:** O(2\\u207F)/O(n), where n = size(nums)\\n```\\npublic int subsetXORSum(int[] nums) {\\n\\tvar sum = new int[]{0};\\n\\tbacktrack(nums, 0, new ArrayDeque<>(), sum);\\n\\treturn sum[0];\\n}\\n\\nprivate void backtrack(int[] nums, int start, Deque<Integer> subset, int[] sum) {\\n\\t// add XOR of subset-array to the sum\\n\\tsum[0] += subset.stream()\\n\\t\\t\\t\\t\\t.mapToInt(n -> n)\\n\\t\\t\\t\\t\\t.reduce(0, (a, b) -> a ^ b);\\n\\n\\t// Backtracking template: for each choice\\n\\tfor (var i = start; i < nums.length; i++) {\\n\\t\\t// choose\\n\\t\\tsubset.addLast(nums[i]);\\n\\t\\t// explore \\n\\t\\tbacktrack(nums, i + 1, subset, sum);\\n\\t\\t// unchoose\\n\\t\\tsubset.removeLast();\\n\\t}\\n}\\n```\\n**Method 2:** Optimised backtracking, 2 liner. 0 ms, time beats 100%\\n* For every num, either include it or exclude it to generate all subsets\\n* Each leaf node will end in a subset, so keep a running xor of that subset\\n* Add all the running xors\\n>**T/S:** O(2\\u207F)/O(n)\\n\\n![image](https://assets.leetcode.com/users/images/6abcb66f-40d9-4a93-9a41-0620266ed13c_1644888083.979053.png)\\n```\\npublic int subsetXORSum(int[] nums) {\\n\\treturn backtrack(nums, 0, 0);\\n}\\n\\nprivate int backtrack(int[] nums, int i, int xor) {\\n\\treturn (i == nums.length) ? xor :\\n\\t\\t   backtrack(nums, i + 1, xor ^ nums[i]) + // include current num\\n\\t\\t   backtrack(nums, i + 1, xor); // exclude current num\\n}\\n```\\n**Method 3:** Java version of [this solution](https://leetcode.com/problems/sum-of-all-subset-xor-totals/discuss/1211177/Simple-trick-oror-4-lines-of-code-oror-Explained!!)\\n>**T/S:** O(n)/O(1)\\n```\\npublic int subsetXORSum(int[] nums) {\\n\\tvar ans = 0;\\n\\tfor (var num : nums)\\n\\t\\tans |= num;\\n\\treturn (1 << nums.length - 1) * ans;\\n}\\n```\\n**Version 2:** 1 liner of Method 2 using streams\\n```\\npublic int subsetXORSum(int[] nums) {\\n\\treturn (1 << nums.length - 1) * Arrays.stream(nums)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  .reduce(0, (a, b) -> a | b);\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int subsetXORSum(int[] nums) {\\n\\tvar sum = new int[]{0};\\n\\tbacktrack(nums, 0, new ArrayDeque<>(), sum);\\n\\treturn sum[0];\\n}\\n\\nprivate void backtrack(int[] nums, int start, Deque<Integer> subset, int[] sum) {\\n\\t// add XOR of subset-array to the sum\\n\\tsum[0] += subset.stream()\\n\\t\\t\\t\\t\\t.mapToInt(n -> n)\\n\\t\\t\\t\\t\\t.reduce(0, (a, b) -> a ^ b);\\n\\n\\t// Backtracking template: for each choice\\n\\tfor (var i = start; i < nums.length; i++) {\\n\\t\\t// choose\\n\\t\\tsubset.addLast(nums[i]);\\n\\t\\t// explore \\n\\t\\tbacktrack(nums, i + 1, subset, sum);\\n\\t\\t// unchoose\\n\\t\\tsubset.removeLast();\\n\\t}\\n}\\n```\n```\\npublic int subsetXORSum(int[] nums) {\\n\\treturn backtrack(nums, 0, 0);\\n}\\n\\nprivate int backtrack(int[] nums, int i, int xor) {\\n\\treturn (i == nums.length) ? xor :\\n\\t\\t   backtrack(nums, i + 1, xor ^ nums[i]) + // include current num\\n\\t\\t   backtrack(nums, i + 1, xor); // exclude current num\\n}\\n```\n```\\npublic int subsetXORSum(int[] nums) {\\n\\tvar ans = 0;\\n\\tfor (var num : nums)\\n\\t\\tans |= num;\\n\\treturn (1 << nums.length - 1) * ans;\\n}\\n```\n```\\npublic int subsetXORSum(int[] nums) {\\n\\treturn (1 << nums.length - 1) * Arrays.stream(nums)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  .reduce(0, (a, b) -> a | b);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1695281,
                "title": "1863-sum-of-all-subset-xor-totals-two-solutions-by-bit-manipulation",
                "content": "**Method I**\\n```\\nclass Solution {\\npublic:\\n    int subsetXORSum(vector<int>& nums) {\\n        int bit_or = 0;\\n        for( auto i: nums)\\n            bit_or |= i;\\n        \\n        return bit_or * pow(2, nums.size()-1);\\n    }\\n};\\n```\\nThe idea is simple. We need to find a pattern. After observing XOR total of each subset, It can be seen that the bit is set for 2^(n-1) for every ith position.\\n\\n**Method II**\\n```\\nclass Solution {\\npublic:\\n    int subsetXORSum(vector<int>& nums) {\\n        int n = nums.size();\\n        int PowSize = pow(2, n);\\n        int sum = 0;\\n        for(int counter = 0; counter < PowSize; counter++)\\n        {\\n            int x = 0;\\n            for(int j=0;j<n; j++)\\n            {\\n                if((counter & (1<<j)) !=0)\\n                {\\n                    x = x ^ nums[j];  \\n                }\\n            }\\n            sum += x;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subsetXORSum(vector<int>& nums) {\\n        int bit_or = 0;\\n        for( auto i: nums)\\n            bit_or |= i;\\n        \\n        return bit_or * pow(2, nums.size()-1);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int subsetXORSum(vector<int>& nums) {\\n        int n = nums.size();\\n        int PowSize = pow(2, n);\\n        int sum = 0;\\n        for(int counter = 0; counter < PowSize; counter++)\\n        {\\n            int x = 0;\\n            for(int j=0;j<n; j++)\\n            {\\n                if((counter & (1<<j)) !=0)\\n                {\\n                    x = x ^ nums[j];  \\n                }\\n            }\\n            sum += x;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1611783,
                "title": "python-backtracking-with-template-super-easy-to-understand",
                "content": "**A naive way to solve this problem, but it uses the same template as most of the other backtracking problems.**\\n```python\\nclass Solution:\\n    def subsetXORSum(self, nums: List[int]) -> int:\\n        self.res = 0\\n        \\n        def dfs(path, start):\\n            curSum = 0\\n            for n in path:\\n                curSum = curSum ^ n\\n            self.res += curSum\\n            \\n            for i in range(start, len(nums)):\\n                num = nums[i]\\n                path.append(num)\\n                dfs(path, i + 1)\\n                path.pop()\\n            \\n        dfs([], 0)    \\n        return self.res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```python\\nclass Solution:\\n    def subsetXORSum(self, nums: List[int]) -> int:\\n        self.res = 0\\n        \\n        def dfs(path, start):\\n            curSum = 0\\n            for n in path:\\n                curSum = curSum ^ n\\n            self.res += curSum\\n            \\n            for i in range(start, len(nums)):\\n                num = nums[i]\\n                path.append(num)\\n                dfs(path, i + 1)\\n                path.pop()\\n            \\n        dfs([], 0)    \\n        return self.res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1555030,
                "title": "python-backtracking-solution",
                "content": "```\\nclass Solution(object):\\n    def subsetXORSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        def dfs(output,nums):\\n            if not nums:\\n                return output\\n            \\n            \\n            output1 = dfs(output^nums[0], nums[1:])\\n            output2 = dfs(output, nums[1:])\\n            \\n            return output1 + output2\\n        \\n        \\n        return dfs(0,nums)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def subsetXORSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        def dfs(output,nums):\\n            if not nums:\\n                return output\\n            \\n            \\n            output1 = dfs(output^nums[0], nums[1:])\\n            output2 = dfs(output, nums[1:])\\n            \\n            return output1 + output2\\n        \\n        \\n        return dfs(0,nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1416126,
                "title": "backtracking-in-python3",
                "content": "def subsetXORSum(self, nums: List[int]) -> int:\\n\\t\\t\\t\\treturn self.backtr(nums,0,0)\\n        \\n    def backtr(self,nums,i,xor):\\n        if(i==len(nums)):\\n            return xor\\n        return self.backtr(nums,i+1,xor^nums[i])+self.backtr(nums,i+1,xor)",
                "solutionTags": [],
                "code": "def subsetXORSum(self, nums: List[int]) -> int:\\n\\t\\t\\t\\treturn self.backtr(nums,0,0)\\n        \\n    def backtr(self,nums,i,xor):\\n        if(i==len(nums)):\\n            return xor\\n        return self.backtr(nums,i+1,xor^nums[i])+self.backtr(nums,i+1,xor)",
                "codeTag": "Python3"
            },
            {
                "id": 1374077,
                "title": "python-3-simple-backtracking-solution",
                "content": "```\\ndef subsetXORSum(self, nums: List[int]) -> int:\\n\\tl = len(nums)\\n\\tres = 0\\n\\n\\tstack = [(0, 0)]\\n\\n\\twhile stack:\\n\\t\\tpos, xor = stack.pop()\\n\\t\\tres+=xor\\n\\t\\tfor i in range(pos, l):\\n\\t\\t\\tstack.append((i+1, xor^nums[i]))\\n\\treturn res\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\ndef subsetXORSum(self, nums: List[int]) -> int:\\n\\tl = len(nums)\\n\\tres = 0\\n\\n\\tstack = [(0, 0)]\\n\\n\\twhile stack:\\n\\t\\tpos, xor = stack.pop()\\n\\t\\tres+=xor\\n\\t\\tfor i in range(pos, l):\\n\\t\\t\\tstack.append((i+1, xor^nums[i]))\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1230748,
                "title": "naive-python-with-comment",
                "content": "```\\n\\nclass Solution:\\n    def subsetXORSum(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        \\n        res = [[]]\\n        tot = 0\\n        \\n        # generate subset\\n        for num in nums:\\n            res += [[num] + i  for i in res ]\\n            \\n        # remove []\\n        if [] in res:\\n            res.remove([])\\n            \\n       \\n        for r in res:\\n            tot += functools.reduce(lambda x, y: x^y , r)  \\n            \\n        return tot\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\nclass Solution:\\n    def subsetXORSum(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        \\n        res = [[]]\\n        tot = 0\\n        \\n        # generate subset\\n        for num in nums:\\n            res += [[num] + i  for i in res ]\\n            \\n        # remove []\\n        if [] in res:\\n            res.remove([])\\n            \\n       \\n        for r in res:\\n            tot += functools.reduce(lambda x, y: x^y , r)  \\n            \\n        return tot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1211322,
                "title": "my-java-solution-brute-force-producing-each-subset-and-finding",
                "content": "```\\nclass Solution {\\n    public int subsetXORSum(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        List<Integer> current = new ArrayList<>();\\n        backtrack(result, current, nums, 0);\\n        int xor = 0;\\n        for (List<Integer> val : result) {\\n            int currentXor = 0;\\n            for (Integer value : val) {\\n                if (value != null)\\n                    currentXor ^= value;\\n            }\\n            xor += currentXor;\\n        }\\n        return xor;\\n        \\n    }\\n    \\n    public void backtrack(List<List<Integer>> result, List<Integer> current, int [] nums, int pos) {\\n        result.add(new ArrayList<>(current));\\n        for (int i=pos; i<nums.length; i++) {\\n            current.add(nums[i]);\\n            backtrack(result, current, nums, i+1);\\n            current.remove(current.size() - 1);\\n        }\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public int subsetXORSum(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        List<Integer> current = new ArrayList<>();\\n        backtrack(result, current, nums, 0);\\n        int xor = 0;\\n        for (List<Integer> val : result) {\\n            int currentXor = 0;\\n            for (Integer value : val) {\\n                if (value != null)\\n                    currentXor ^= value;\\n            }\\n            xor += currentXor;\\n        }\\n        return xor;\\n        \\n    }\\n    \\n    public void backtrack(List<List<Integer>> result, List<Integer> current, int [] nums, int pos) {\\n        result.add(new ArrayList<>(current));\\n        for (int i=pos; i<nums.length; i++) {\\n            current.add(nums[i]);\\n            backtrack(result, current, nums, i+1);\\n            current.remove(current.size() - 1);\\n        }\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1211210,
                "title": "python-simple-solution-logic-explanation",
                "content": "Steps to solve this question are:\\n\\t1. Create the subsets.\\n\\t2. Do XOR of each elements of every subset.\\n\\t3. Add the XOR values and return the output.\\n\\n```\\nclass Solution:\\n    def subsetXORSum(self, nums: List[int]) -> int:\\n        lst = []\\n        output = 0\\n        for i in range(1, len(nums)):\\n            comb = list(itertools.combinations(nums, i))\\n            for j in comb:\\n                xor = 0\\n                for k in j:\\n                    xor ^= k\\n                output += xor\\n        xor = 0\\n        for i in nums:\\n            xor ^= i\\n            \\n        return output + xor\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subsetXORSum(self, nums: List[int]) -> int:\\n        lst = []\\n        output = 0\\n        for i in range(1, len(nums)):\\n            comb = list(itertools.combinations(nums, i))\\n            for j in comb:\\n                xor = 0\\n                for k in j:\\n                    xor ^= k\\n                output += xor\\n        xor = 0\\n        for i in nums:\\n            xor ^= i\\n            \\n        return output + xor\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1211154,
                "title": "c-bit-manipulation-to-generate-subsets",
                "content": "```\\nint subsetXORSum(vector<int>& arr) {\\n        int n = arr.size();\\n        int sum=0;    \\n    for (int i = 0; i < (int) pow(2, n); i++){\\n        vector<int> currSubset;\\n        //keeping the current subset in a vector\\n        for (int j = 0; j < n; j++)\\n        {\\n            if ((i & (1 << j)) != 0)\\n                currSubset.push_back(arr[j]);\\n        }\\n            //getting XOR of elements of current subset\\n        int tempXOR =0;\\n        for(int k=0; k< currSubset.size(); k++){\\n              tempXOR^=(currSubset[k]);\\n         }\\n         sum+=tempXOR;\\n    }\\n        return sum;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nint subsetXORSum(vector<int>& arr) {\\n        int n = arr.size();\\n        int sum=0;    \\n    for (int i = 0; i < (int) pow(2, n); i++){\\n        vector<int> currSubset;\\n        //keeping the current subset in a vector\\n        for (int j = 0; j < n; j++)\\n        {\\n            if ((i & (1 << j)) != 0)\\n                currSubset.push_back(arr[j]);\\n        }\\n            //getting XOR of elements of current subset\\n        int tempXOR =0;\\n        for(int k=0; k< currSubset.size(); k++){\\n              tempXOR^=(currSubset[k]);\\n         }\\n         sum+=tempXOR;\\n    }\\n        return sum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1211124,
                "title": "easy-to-understand-python-solution-with-explanation",
                "content": "I approached this question as a variation of the subsets problem on Leetcode. I used backtracking. The decision in each step is to include the item or exclude the item. The only difference is that we have to compute the xor of the elements as we traverse and generate all the subsets recursively.\\n\\n```python\\ndef subsetXORSum(self, nums: List[int]) -> int:\\n  res = 0\\n  def subsets(i=0, path=0):\\n    nonlocal res\\n    if i == len(nums):\\n      res += path\\n      return\\n    \\n    subsets(i + 1, path ^ nums[i])\\n    subsets(i + 1, path)\\n  \\n  subsets()\\n  return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```python\\ndef subsetXORSum(self, nums: List[int]) -> int:\\n  res = 0\\n  def subsets(i=0, path=0):\\n    nonlocal res\\n    if i == len(nums):\\n      res += path\\n      return\\n    \\n    subsets(i + 1, path ^ nums[i])\\n    subsets(i + 1, path)\\n  \\n  subsets()\\n  return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3597709,
                "title": "c-dfs-backtracking-simple",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int subsetXORSum(vector<int>& nums) {\\n        int sum = 0;\\n        int subset = 0;\\n        solve(nums, sum, subset, 0);\\n        return sum;\\n    }\\n\\nprivate:\\n    void solve(vector<int>& nums, int& sum, int& subset, int start) {\\n        sum += subset;\\n\\n        for (int i = start; i < nums.size(); i++) {\\n            subset ^= nums[i];\\n            solve(nums, sum, subset, i + 1);\\n            subset ^= nums[i];\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subsetXORSum(vector<int>& nums) {\\n        int sum = 0;\\n        int subset = 0;\\n        solve(nums, sum, subset, 0);\\n        return sum;\\n    }\\n\\nprivate:\\n    void solve(vector<int>& nums, int& sum, int& subset, int start) {\\n        sum += subset;\\n\\n        for (int i = start; i < nums.size(); i++) {\\n            subset ^= nums[i];\\n            solve(nums, sum, subset, i + 1);\\n            subset ^= nums[i];\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2680018,
                "title": "java-0ms-easily-understand",
                "content": "# Intuition\\n\\nhttps://medium.com/programming-problems-and-solutions/sum-of-all-subset-xor-totals-928a06fb7ae0\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int subsetXORSum(int[] nums) {\\n        int bits = 0;\\n     \\n        for (int i = 0; i < nums.length; i++)\\n            bits |= nums[i];\\n     \\n        int ans = bits * (int)Math.pow(2, nums.length-1);\\n     \\n        return ans;\\n\\n        }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int subsetXORSum(int[] nums) {\\n        int bits = 0;\\n     \\n        for (int i = 0; i < nums.length; i++)\\n            bits |= nums[i];\\n     \\n        int ans = bits * (int)Math.pow(2, nums.length-1);\\n     \\n        return ans;\\n\\n        }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2597926,
                "title": "simple-bit-manipulation",
                "content": "![image](https://assets.leetcode.com/users/images/824a599e-c386-4971-ae11-01ae6cd33951_1663604741.5429075.png)\\n\\n\\nExample:\\n```\\na = 9 = 1001 (Binary)\\nb = 10 = 1010 (Binary)\\na | b = 1001 | 1010\\n        = 1011\\n        = 11 (Decimal)\\n```\\n\\n*Bitwise `OR` operator( | ) : Returns `1` if either of the bit is `1` else `0`.*\\n\\n```\\nclass Solution:\\n    def subsetXORSum(self, nums: List[int]) -> int:\\n        bits = 0\\n        for n in nums:\\n            bits |= n\\n        return bits * 2**(len(nums)-1)\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\na = 9 = 1001 (Binary)\\nb = 10 = 1010 (Binary)\\na | b = 1001 | 1010\\n        = 1011\\n        = 11 (Decimal)\\n```\n```\\nclass Solution:\\n    def subsetXORSum(self, nums: List[int]) -> int:\\n        bits = 0\\n        for n in nums:\\n            bits |= n\\n        return bits * 2**(len(nums)-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2586348,
                "title": "java-0ms-backtracking-solution",
                "content": "Backtracking forms a tree, with each tree, where each branch ends in leaf nodes equivalent to size of array.\\nAs, we keep the sum as it is in one recursion, and the current number in one recursion. This way we simulate all the possible combinations of subarrays.\\n\\n```java\\nclass Solution {\\n    public int subsetXORSum(int[] nums) {\\n        return backtrack(nums, 0, 0);\\n    }\\n    \\n    public int backtrack(int[] nums, int sum, int index){\\n        if(index == nums.length) return sum;\\n        \\n        int withCurrentDigit = backtrack(nums, sum ^ nums[index], index + 1);\\n        int withoutCurrentDigit = backtrack(nums, sum, index + 1);\\n        \\n        return withCurrentDigit + withoutCurrentDigit;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```java\\nclass Solution {\\n    public int subsetXORSum(int[] nums) {\\n        return backtrack(nums, 0, 0);\\n    }\\n    \\n    public int backtrack(int[] nums, int sum, int index){\\n        if(index == nums.length) return sum;\\n        \\n        int withCurrentDigit = backtrack(nums, sum ^ nums[index], index + 1);\\n        int withoutCurrentDigit = backtrack(nums, sum, index + 1);\\n        \\n        return withCurrentDigit + withoutCurrentDigit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2575329,
                "title": "python-oneliner",
                "content": "```py\\nclass Solution:\\n    def subsetXORSum(self, nums: List[int]) -> int:\\n        \\n        return sum(reduce(operator.xor, comb) for i in range(1, len(nums)+1) for comb in combinations(nums, i))\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```py\\nclass Solution:\\n    def subsetXORSum(self, nums: List[int]) -> int:\\n        \\n        return sum(reduce(operator.xor, comb) for i in range(1, len(nums)+1) for comb in combinations(nums, i))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2540608,
                "title": "bit-masking-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int subsetXORSum(vector<int>& nums) {\\n        int n = nums.size(), total_subsets = 1<<n, sum = 0;\\n        for(int mask=0;mask<total_subsets;mask++){\\n            int sub_xor = 0;\\n            for(int i=0;i<n;i++){\\n                if(mask & 1<<i) sub_xor ^= nums[i];\\n            }\\n            sum += sub_xor;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subsetXORSum(vector<int>& nums) {\\n        int n = nums.size(), total_subsets = 1<<n, sum = 0;\\n        for(int mask=0;mask<total_subsets;mask++){\\n            int sub_xor = 0;\\n            for(int i=0;i<n;i++){\\n                if(mask & 1<<i) sub_xor ^= nums[i];\\n            }\\n            sum += sub_xor;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2281127,
                "title": "backtracking-pick-not-pick-method",
                "content": "Find all subsets \\nHow ?\\nFor n numbers, there are 2^n subsets\\n[2, 5, 6]\\nAll subsets :\\nFor each index, we either decide to pick it or not pick it\\nP -> pick\\nNP -> not pick\\n[2] --> P, NP, NP\\n[5] --> NP, P, NP\\n[6] --> NP, NP, P\\n[2, 5] --> P, P, NP\\n[2, 6] --> P, NP, P\\n[5, 6] --> NP, P, P\\n[2, 5, 6] --> P,P, P\\n[] --> NP, NP, NP\\n\\nDraw Recursion Tree & see \\n\\nNow, during the find of subsets, keep track of xor of subset elements\\nwhen subset found add that subset xor in ans \\nat end you will get ans as sum of all subsets xors.\\n\\n```\\nvoid subsets(int ind, int n, vector<int>& nums, int xorSum, int &ans){\\n        if(ind == n){\\n            ans += xorSum;\\n            return;\\n        }\\n        // pick\\n        subsets(ind + 1, n, nums, xorSum ^ nums[ind], ans);\\n        // not pick\\n        subsets(ind + 1, n, nums, xorSum, ans);\\n        \\n    }\\n    int subsetXORSum(vector<int>& nums) {\\n        int n = nums.size();\\n        int ans = 0;\\n        subsets(0, n, nums, 0, ans);\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nvoid subsets(int ind, int n, vector<int>& nums, int xorSum, int &ans){\\n        if(ind == n){\\n            ans += xorSum;\\n            return;\\n        }\\n        // pick\\n        subsets(ind + 1, n, nums, xorSum ^ nums[ind], ans);\\n        // not pick\\n        subsets(ind + 1, n, nums, xorSum, ans);\\n        \\n    }\\n    int subsetXORSum(vector<int>& nums) {\\n        int n = nums.size();\\n        int ans = 0;\\n        subsets(0, n, nums, 0, ans);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2119366,
                "title": "python-simple-backtracking-solution",
                "content": "```\\n\\nclass Solution:\\n    \\n\\tdef subsetXORSum(self, nums: List[int]) -> int:\\n        \\n        def backtrack(arr: list[int], i: int = 0) -> int:\\n\\t\\t\\t# calculate XOR sum of current array combination\\n            total = arr[0] if arr else 0\\n            for r in arr[1:]:\\n                total = total ^ r\\n\\t\\t\\t\\n\\t\\t\\t# return in case all numbers from \\'nums\\' used\\n            if len(nums) == i:\\n                return total\\n\\t\\t\\t\\n\\t\\t\\t# recursively build new combinations of arrays\\n            for j, n in enumerate(nums[i:], start=i):\\n\\t\\t\\t\\tarr.append(n)\\n                total += backtrack(arr, j + 1)\\n                arr.pop()\\n\\n            return total\\n        \\n        return backtrack([])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    \\n\\tdef subsetXORSum(self, nums: List[int]) -> int:\\n        \\n        def backtrack(arr: list[int], i: int = 0) -> int:\\n\\t\\t\\t# calculate XOR sum of current array combination\\n            total = arr[0] if arr else 0\\n            for r in arr[1:]:\\n                total = total ^ r\\n\\t\\t\\t\\n\\t\\t\\t# return in case all numbers from \\'nums\\' used\\n            if len(nums) == i:\\n                return total\\n\\t\\t\\t\\n\\t\\t\\t# recursively build new combinations of arrays\\n            for j, n in enumerate(nums[i:], start=i):\\n\\t\\t\\t\\tarr.append(n)\\n                total += backtrack(arr, j + 1)\\n                arr.pop()\\n\\n            return total\\n        \\n        return backtrack([])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2020193,
                "title": "java-solution-easy-to-understand",
                "content": "class Solution {\\n    public int subsetXORSum(int[] nums) \\n    {\\n         return calculator(nums, 0, 0);\\n    }\\n    \\n    public int calculator(int[] nums, int level, int curXOR) \\n    {\\n        if(level == nums.length) \\n        {\\n            return curXOR;\\n        }\\n        int include = calculator(nums, level+1, curXOR^nums[level]);\\n        int exclude = calculator(nums, level+1, curXOR);\\n        return include + exclude;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int subsetXORSum(int[] nums) \\n    {\\n         return calculator(nums, 0, 0);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1906814,
                "title": "python-solution-using-combinations-and-reduce",
                "content": "```\\nclass Solution:\\n    def subsetXORSum(self, nums: List[int]) -> int:\\n        lst=[]\\n        for i in range(len(nums)+1):\\n            x=list(itertools.combinations(nums,i))\\n            for j in x:\\n                lst.append(j)\\n        # print(lst)\\n        add=0\\n        for i in lst:\\n            # print(i,len(i))\\n            if len(i)==0:\\n                continue\\n            elif len(i)==1:\\n                add+=i[0]\\n            else:\\n                res = reduce(lambda x, y: x ^ y, i)\\n                # print(res)\\n                add+=res\\n                # print(add)\\n        return add\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution:\\n    def subsetXORSum(self, nums: List[int]) -> int:\\n        lst=[]\\n        for i in range(len(nums)+1):\\n            x=list(itertools.combinations(nums,i))\\n            for j in x:\\n                lst.append(j)\\n        # print(lst)\\n        add=0\\n        for i in lst:\\n            # print(i,len(i))\\n            if len(i)==0:\\n                continue\\n            elif len(i)==1:\\n                add+=i[0]\\n            else:\\n                res = reduce(lambda x, y: x ^ y, i)\\n                # print(res)\\n                add+=res\\n                # print(add)\\n        return add\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1812315,
                "title": "simplest-solution-c-backtracking",
                "content": "**AN UPVOTE WOULD BE HIGHLY APPERICIATED**\\n```\\nclass Solution {\\nprivate:\\n    void Backtracking(vector<int>& nums,int& xorSum, int xo, int index) {\\n        for (int i=index; i<nums.size(); i++) {\\n            xo = xo^nums[i];\\n            xorSum += xo;\\n            Backtracking(nums,xorSum, xo, i+1);\\n            xo= xo^nums[i];\\n        }\\n    }\\npublic:\\n    int subsetXORSum(vector<int>& nums) {\\n        int xorSum = 0;\\n        Backtracking(nums,xorSum, 0, 0);\\n        return xorSum;\\n    \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void Backtracking(vector<int>& nums,int& xorSum, int xo, int index) {\\n        for (int i=index; i<nums.size(); i++) {\\n            xo = xo^nums[i];\\n            xorSum += xo;\\n            Backtracking(nums,xorSum, xo, i+1);\\n            xo= xo^nums[i];\\n        }\\n    }\\npublic:\\n    int subsetXORSum(vector<int>& nums) {\\n        int xorSum = 0;\\n        Backtracking(nums,xorSum, 0, 0);\\n        return xorSum;\\n    \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1773268,
                "title": "just-backtracking",
                "content": "1. Recursive case: sum of paths with and without the element (`x ^ nums[i]` and `x ^ 0` or just `x`) \\n2. Base case: if path is finished (or maximum recursion depth, tracked with `i` has been reached) the result is the current path which was aggregated in `x`\\n\\n```\\nclass Solution:\\n    def subsetXORSum(self, nums: List[int]) -> int:\\n        def dfs(x, i):\\n            if i == len(nums):\\n                return x\\n            return dfs(x ^ nums[i], i + 1) + dfs(x, i + 1)\\n        return dfs(0, 0)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def subsetXORSum(self, nums: List[int]) -> int:\\n        def dfs(x, i):\\n            if i == len(nums):\\n                return x\\n            return dfs(x ^ nums[i], i + 1) + dfs(x, i + 1)\\n        return dfs(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1723262,
                "title": "beginner-friendly-java-soluton",
                "content": "```\\nclass Solution {\\n    public int subsetXORSum(int[] nums) {\\n        return sumXor(nums, 0, 0);\\n    }\\n    \\n    private int sumXor(int[] nums, int i, int cur){\\n        if(i == nums.length)   return cur;\\n        return sumXor(nums, i+1, cur) + sumXor(nums, i+1, cur^nums[i]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int subsetXORSum(int[] nums) {\\n        return sumXor(nums, 0, 0);\\n    }\\n    \\n    private int sumXor(int[] nums, int i, int cur){\\n        if(i == nums.length)   return cur;\\n        return sumXor(nums, i+1, cur) + sumXor(nums, i+1, cur^nums[i]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1694749,
                "title": "1-liner-0ms-100-faster-using-bitmask",
                "content": "```\\nclass Solution {\\npublic:\\n    int subsetXORSum(vector<int>& nums) {\\n            return accumulate(begin(nums), end(nums), 0, bit_or<int>()) << (nums.size() - 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subsetXORSum(vector<int>& nums) {\\n            return accumulate(begin(nums), end(nums), 0, bit_or<int>()) << (nums.size() - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1639912,
                "title": "c-100-backtracking",
                "content": "**Runtime:** 0 ms, faster than 100.00% of C++ online submissions for Sum of All Subset XOR Totals.\\n**Memory Usage:** 7.1 MB, less than 53.84% of C++ online submissions for Sum of All Subset XOR Totals.\\n```\\nclass Solution {\\npublic:\\n    int subsetXORSum(vector<int>& nums) {\\n        int ret = 0;\\n        xorHelper(nums, 0, 0, ret);\\n        return ret;\\n    }\\n    void xorHelper(vector<int>& nums, int i, int temp, int& ret) {\\n        if(i >= nums.size()){\\n            ret += temp;\\n            return;\\n        }\\n        xorHelper(nums, i+1, temp, ret);  // donot select nums[i]\\n        temp ^= nums[i]; //select nums[i]\\n        xorHelper(nums, i+1, temp, ret);\\n        return;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subsetXORSum(vector<int>& nums) {\\n        int ret = 0;\\n        xorHelper(nums, 0, 0, ret);\\n        return ret;\\n    }\\n    void xorHelper(vector<int>& nums, int i, int temp, int& ret) {\\n        if(i >= nums.size()){\\n            ret += temp;\\n            return;\\n        }\\n        xorHelper(nums, i+1, temp, ret);  // donot select nums[i]\\n        temp ^= nums[i]; //select nums[i]\\n        xorHelper(nums, i+1, temp, ret);\\n        return;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1586753,
                "title": "it-s-a-binary-johny-power-set-is-power-of-2",
                "content": "```\\nlet subsetXORSum=n=>n.reduce((s,e)=>s|e) * 2**(n.length-1)\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nlet subsetXORSum=n=>n.reduce((s,e)=>s|e) * 2**(n.length-1)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1530531,
                "title": "bitmask-solution-and-math-solution-python",
                "content": "First method is brute force in view of the length <= 15. We could use bitmask to represent every subsequence of `nums`, compute its `xor` total, and summation.\\n```\\nclass Solution:\\n    def subsetXORSum(self, nums: List[int]) -> int:\\n        res = 0\\n        n = len(nums)\\n        for mask in range(2 ** n):\\n            tmp_xor = 0\\n            for i, bit in enumerate(self.to_binary(mask, n)):\\n                if bit == 1:\\n                    tmp_xor ^= nums[i]\\n            res += tmp_xor\\n        return res\\n\\n    def to_binary(self, m, n):\\n        res = []\\n        while m > 0:\\n            q, r = divmod(m, 2)\\n            res.append(r)\\n            m = q\\n        return res + [0] *(n - len(res))\\n        \\n```\\nA shorter version:\\n```\\nclass Solution:\\n    def subsetXORSum(self, nums: List[int]) -> int:\\n        res = 0\\n        n = len(nums)\\n        for mask in range(2 ** n):\\n            tmp_xor = 0\\n            for i in range(n):\\n                if mask & 2 **i == 2 **i:\\n                    tmp_xor ^= nums[i]\\n            res += tmp_xor\\n        return res\\n```\\n\\n\\nMath solution.\\n\\n(a) Observation\\nAssume that there exists element in `nums` whose `i`th bit position is 1. Assume there are `m` such numbers out of total `n` elements of `nums`. The number of subsets whose `xor` total has  `i`th bit being 1 is:\\n\\n```[C(m, 1) + C(m, 3) +... + C(m, odd) +..] * 2 ** (n - m) = 2 ** (m - 1) * 2 ** (n - m) = 2 ** (n - 1)```\\nthe factor in the `[]` means we need to choose odd number of elements from those `m`, and second factor means for each of the `n - m` there are two choices.\\nTherefore, if the final result have 1 in `i`th bit position (corresponding to 2 ** i), there will be `2 ** (n - 1)` of it, contributing to the final sum `2 ** (n - 1 + i)`.\\n\\n(2) How to determine if the `i`th bit position is 1 or 0? Use bitwise `or`.\\n\\n```\\nclass Solution:\\n    def subsetXORSum(self, nums: List[int]) -> int:\\n        total_or = 0\\n        for x in nums:\\n            total_or |= x\\n        return total_or * 2 ** (len(nums) - 1)\\n        \\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def subsetXORSum(self, nums: List[int]) -> int:\\n        res = 0\\n        n = len(nums)\\n        for mask in range(2 ** n):\\n            tmp_xor = 0\\n            for i, bit in enumerate(self.to_binary(mask, n)):\\n                if bit == 1:\\n                    tmp_xor ^= nums[i]\\n            res += tmp_xor\\n        return res\\n\\n    def to_binary(self, m, n):\\n        res = []\\n        while m > 0:\\n            q, r = divmod(m, 2)\\n            res.append(r)\\n            m = q\\n        return res + [0] *(n - len(res))\\n        \\n```\n```\\nclass Solution:\\n    def subsetXORSum(self, nums: List[int]) -> int:\\n        res = 0\\n        n = len(nums)\\n        for mask in range(2 ** n):\\n            tmp_xor = 0\\n            for i in range(n):\\n                if mask & 2 **i == 2 **i:\\n                    tmp_xor ^= nums[i]\\n            res += tmp_xor\\n        return res\\n```\n```[C(m, 1) + C(m, 3) +... + C(m, odd) +..] * 2 ** (n - m) = 2 ** (m - 1) * 2 ** (n - m) = 2 ** (n - 1)```\n```\\nclass Solution:\\n    def subsetXORSum(self, nums: List[int]) -> int:\\n        total_or = 0\\n        for x in nums:\\n            total_or |= x\\n        return total_or * 2 ** (len(nums) - 1)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1271419,
                "title": "bit-masking-solution",
                "content": "A simple bit masking code \\n``` \\nint sum=0;\\n        int size=nums.size();\\n        int n=(1<<size);\\n        for(int i=0;i<n;i++)\\n        {\\n        int current =0;\\n            for(int j=0;j<size;j++)\\n            {\\n              if((i&(1<<j))) current=current ^ nums[j];\\n            }\\n            sum+=current;\\n        }\\n        return sum;\\n    }\\n\\t```\\n\\t",
                "solutionTags": [],
                "code": "``` \\nint sum=0;\\n        int size=nums.size();\\n        int n=(1<<size);\\n        for(int i=0;i<n;i++)\\n        {\\n        int current =0;\\n            for(int j=0;j<size;j++)\\n            {\\n              if((i&(1<<j))) current=current ^ nums[j];\\n            }\\n            sum+=current;\\n        }\\n        return sum;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1235407,
                "title": "c-easy-solution",
                "content": "\\tpublic class Solution {\\n\\t\\tpublic int SubsetXORSum(int[] nums) {\\n\\t\\t\\treturn SubsetXORSumUntil(nums, 0, 0);\\n\\t\\t}\\n\\n\\t\\tpublic int SubsetXORSumUntil(int[] nums, int idx, int xor) {\\n\\t\\t\\tif(idx == nums.Length)\\n\\t\\t\\t\\treturn xor;\\n\\n\\t\\t\\treturn SubsetXORSumUntil(nums, idx + 1, xor ^ nums[idx]) + SubsetXORSumUntil(nums, idx + 1, xor);\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "C#"
                ],
                "code": "class Solution {\\n\\t\\tpublic int SubsetXORSum(int[] nums) {\\n\\t\\t\\treturn SubsetXORSumUntil(nums, 0, 0);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1231970,
                "title": "c-iterative-approach-to-find-all-subsets-then-xor-them",
                "content": "\\n    \\n    int subsetXORSum(vector<int>& nums) {\\n        \\n        int size = nums.size();\\n        int comb = 1<<size;\\n        int c = 0, y=0, xor_sum=0, xorP=0  ;\\n        for(int I=0;I<comb;I++)\\n        {\\n            c=0;\\n            y=I;\\n            xorP=0;\\n            while(y>0)\\n            {\\n                if(y&1)\\n                {\\n                    xorP^=nums[c];\\n                }\\n                y=y>>1;\\n                c++;\\n            }\\n            xor_sum += xorP;\\n        }\\n    \\n        return xor_sum;\\n    }\\n",
                "solutionTags": [],
                "code": "\\n    \\n    int subsetXORSum(vector<int>& nums) {\\n        \\n        int size = nums.size();\\n        int comb = 1<<size;\\n        int c = 0, y=0, xor_sum=0, xorP=0  ;\\n        for(int I=0;I<comb;I++)\\n        {\\n            c=0;\\n            y=I;\\n            xorP=0;\\n            while(y>0)\\n            {\\n                if(y&1)\\n                {\\n                    xorP^=nums[c];\\n                }\\n                y=y>>1;\\n                c++;\\n            }\\n            xor_sum += xorP;\\n        }\\n    \\n        return xor_sum;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1229934,
                "title": "c-recursion-4-lines",
                "content": "```\\nclass Solution {\\npublic:\\n    int subsetXORSum(const vector<int>& nums, int pre = 0, int i = -1) {\\n        int s = pre; \\n        for (int j = i + 1; j < nums.size(); j++)\\n            s += subsetXORSum(nums, pre ^ nums[j], j);\\n        return s;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    int subsetXORSum(const vector<int>& nums, int pre = 0, int i = -1) {\\n        int s = pre; \\n        for (int j = i + 1; j < nums.size(); j++)\\n            s += subsetXORSum(nums, pre ^ nums[j], j);\\n        return s;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1226230,
                "title": "bit-masking-java-sol",
                "content": "\\n\\tpublic int subsetXORSum(int[] nums) \\n    {\\n        int n=nums.length;\\n        int pow=(int)Math.pow(2,n);\\n        int xor=0,sum=0;\\n        for(int i=0;i<pow;i++)\\n        {\\n            xor=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                if((i&(1<<j))!= 0)\\n                {\\n                    xor^=nums[j];\\n                }\\n            }\\n            sum+=xor;\\n        }\\n        return sum;\\n    }",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "\\n\\tpublic int subsetXORSum(int[] nums) \\n    {\\n        int n=nums.length;\\n        int pow=(int)Math.pow(2,n);\\n        int xor=0,sum=0;\\n        for(int i=0;i<pow;i++)\\n        {\\n            xor=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                if((i&(1<<j))!= 0)\\n                {\\n                    xor^=nums[j];\\n                }\\n            }\\n            sum+=xor;\\n        }\\n        return sum;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1225481,
                "title": "backtracking-java",
                "content": "```\\n\\tint sum;\\n    public int subsetXORSum(int[] nums) {\\n        sum = 0;\\n        backtrack(nums, 0, 0);\\n        return sum;\\n    }\\n    \\n    private void backtrack(int[] nums, int index, int curr) {\\n        sum += curr;\\n        \\n        for(int i=index; i<nums.length; i++) {\\n            curr ^= nums[i];\\n            backtrack(nums, i+1, curr);\\n            curr ^= nums[i];\\n        }\\n    }\\n```\\nTime complexity: O(2^n)\\nSpace complexity: O(n)",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n\\tint sum;\\n    public int subsetXORSum(int[] nums) {\\n        sum = 0;\\n        backtrack(nums, 0, 0);\\n        return sum;\\n    }\\n    \\n    private void backtrack(int[] nums, int index, int curr) {\\n        sum += curr;\\n        \\n        for(int i=index; i<nums.length; i++) {\\n            curr ^= nums[i];\\n            backtrack(nums, i+1, curr);\\n            curr ^= nums[i];\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1221663,
                "title": "java-easy-recursive-solution",
                "content": "```\\nclass Solution {\\n    public int subsetXORSum(int[] arr) {\\n      subsets(arr,0,0);\\n        return sum;\\n    }\\n  int sum=0;\\n   public void subsets(int arr[],int idx,int cxor){\\n     if(idx==arr.length){\\n      // System.out.println(cs);\\n       sum+=cxor;\\n       return;\\n     }\\n   \\n     subsets(arr,idx+1,cxor^arr[idx]);\\n     subsets(arr,idx+1,cxor);\\n    \\n     \\n   }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int subsetXORSum(int[] arr) {\\n      subsets(arr,0,0);\\n        return sum;\\n    }\\n  int sum=0;\\n   public void subsets(int arr[],int idx,int cxor){\\n     if(idx==arr.length){\\n      // System.out.println(cs);\\n       sum+=cxor;\\n       return;\\n     }\\n   \\n     subsets(arr,idx+1,cxor^arr[idx]);\\n     subsets(arr,idx+1,cxor);\\n    \\n     \\n   }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1218309,
                "title": "simple-python-solution-with-explanation",
                "content": "For a given set of size `n` there are `2**n` subsets. For each element in the set we ask ourseves \\'Do we include this element in the set or not?\\' This directly corresponds to the `bt` function below. Our base case is that we have considered every element in the set, once we have done that we add the `running_xor` value to our `ans`. We call `bt` once for the case that we do include a given element in the subset and once for the case that we do not include the given element in the subset.\\n```\\nclass Solution:\\n    def subsetXORSum(self, nums: List[int]) -> int:\\n        ans = 0\\n        def bt(nums, index, running_xor):\\n            nonlocal ans\\n            if index >= len(nums):\\n                ans += running_xor\\n            else:\\n                bt(nums, index+1, nums[index]^running_xor)\\n                bt(nums, index+1, running_xor)\\n                \\n        bt(nums, 0, 0)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def subsetXORSum(self, nums: List[int]) -> int:\\n        ans = 0\\n        def bt(nums, index, running_xor):\\n            nonlocal ans\\n            if index >= len(nums):\\n                ans += running_xor\\n            else:\\n                bt(nums, index+1, nums[index]^running_xor)\\n                bt(nums, index+1, running_xor)\\n                \\n        bt(nums, 0, 0)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1212870,
                "title": "swift-solution",
                "content": "Swift solution\\n```\\nclass Solution {\\n    func subsetXORSum(_ nums: [Int]) -> Int {\\n        let c = nums.count\\n        var result = 0\\n        func helper(_ xor: Int, _ start: Int) {\\n            guard start < c else { return }\\n            let nextXor = xor ^ nums[start]\\n            result += nextXor\\n            helper(xor, start + 1)\\n            helper(nextXor, start + 1)\\n        }\\n        helper(0, 0)\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func subsetXORSum(_ nums: [Int]) -> Int {\\n        let c = nums.count\\n        var result = 0\\n        func helper(_ xor: Int, _ start: Int) {\\n            guard start < c else { return }\\n            let nextXor = xor ^ nums[start]\\n            result += nextXor\\n            helper(xor, start + 1)\\n            helper(nextXor, start + 1)\\n        }\\n        helper(0, 0)\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1212295,
                "title": "c-bit-wise-or-on-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int subsetXORSum(vector<int>& nums) {\\n        int bit_or=0;\\n        for(auto i:nums)\\n            bit_or|=i;\\n        return bit_or*pow(2,nums.size()-1);\\n    }\\n};\\n```\\nThe efficient approach is to look for a pattern\\n```\\n 1 = 001\\n 5 = 101\\n 6 = 110\\n1 ^ 5 = 100\\n1 ^ 6 = 111\\n5 ^ 6 = 011\\n1^5^6 = 010\\n```\\n\\nHere it can be clearly spotted that the bit is set in 2^(n-1) times for every ith position\\n\\nIf there is any value of arr[] that has set tth bit set, then exactly half of 2n subsets will be of the form, so they will contribute to 2n-1+i to the final sum.\\n\\nIf there is no value of arr[] that ith bit set, then we can say that there will be no term in all subsets that have a ith bit set.\\n**Time Complexity = O(N)\\nSpace Complexity = O(1)**",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subsetXORSum(vector<int>& nums) {\\n        int bit_or=0;\\n        for(auto i:nums)\\n            bit_or|=i;\\n        return bit_or*pow(2,nums.size()-1);\\n    }\\n};\\n```\n```\\n 1 = 001\\n 5 = 101\\n 6 = 110\\n1 ^ 5 = 100\\n1 ^ 6 = 111\\n5 ^ 6 = 011\\n1^5^6 = 010\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1211390,
                "title": "solution-in-java",
                "content": "```\\nclass Solution {\\n    public int subsetXORSum(int[] nums) {\\n       int res=0,sum=0;\\n       for(int i=0;i<nums.length;i++){\\n           sum|=nums[i];\\n       }\\n       res=sum*((int)Math.pow(2,nums.length-1));\\n       return res;\\n    }\\n}\\n```\\nPlease **upvote**, if you like the solution:)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int subsetXORSum(int[] nums) {\\n       int res=0,sum=0;\\n       for(int i=0;i<nums.length;i++){\\n           sum|=nums[i];\\n       }\\n       res=sum*((int)Math.pow(2,nums.length-1));\\n       return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1211285,
                "title": "recursion-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    void solve(vector<int>op,vector<int>& ip,int i){\\n        if(i==ip.size()){\\n            ans.push_back(op);\\n            return;\\n        }\\n        solve(op,ip,i+1);\\n        op.push_back(ip[i]);\\n        solve(op,ip,i+1);\\n        return;\\n    }\\n    int sum=0,res=0;\\n    int subsetXORSum(vector<int>& nums) {\\n        vector<int>op;\\n        solve(op,nums,0);\\n        int n=ans.size();\\n        for(int i=0;i<n;i++){\\n            int k=ans[i].size();\\n            for(int j=0;j<k;j++){\\n                sum^=ans[i][j];\\n            }\\n            res+=sum;\\n            sum=0;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    void solve(vector<int>op,vector<int>& ip,int i){\\n        if(i==ip.size()){\\n            ans.push_back(op);\\n            return;\\n        }\\n        solve(op,ip,i+1);\\n        op.push_back(ip[i]);\\n        solve(op,ip,i+1);\\n        return;\\n    }\\n    int sum=0,res=0;\\n    int subsetXORSum(vector<int>& nums) {\\n        vector<int>op;\\n        solve(op,nums,0);\\n        int n=ans.size();\\n        for(int i=0;i<n;i++){\\n            int k=ans[i].size();\\n            for(int j=0;j<k;j++){\\n                sum^=ans[i][j];\\n            }\\n            res+=sum;\\n            sum=0;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1211268,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int subsetXORSum(int[] nums) {\\n        int total_xor = 0;\\n        if(nums.length == 0)\\n            return 0;\\n        else\\n        {\\n            for(int i = 0; i < (1 << nums.length); i++)\\n            {\\n                int xor = 0;\\n                for(int j = 0; j < nums.length; j++)\\n                {\\n                    if ((i & (1 << j)) > 0)\\n                    {\\n                      xor ^= nums[j];  \\n                    }\\n                    \\n                }\\n                \\n                total_xor += xor;\\n            }\\n        }\\n        \\n        return total_xor;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int subsetXORSum(int[] nums) {\\n        int total_xor = 0;\\n        if(nums.length == 0)\\n            return 0;\\n        else\\n        {\\n            for(int i = 0; i < (1 << nums.length); i++)\\n            {\\n                int xor = 0;\\n                for(int j = 0; j < nums.length; j++)\\n                {\\n                    if ((i & (1 << j)) > 0)\\n                    {\\n                      xor ^= nums[j];  \\n                    }\\n                    \\n                }\\n                \\n                total_xor += xor;\\n            }\\n        }\\n        \\n        return total_xor;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1211179,
                "title": "java-with-explanation-simple-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int subsetXORSum(int[] nums) {\\n     \\n        int n = nums.length;\\n        int tmp = 0;\\n        int sum = 0;\\n  \\n        // Run a loop for printing all 2^n\\n        // subsets one by one\\n        for (int i = 0; i < (1<<n); i++) {\\n           tmp = 0;\\n            for (int j = 0; j < n; j++) {\\n                // (1<<j) is a number with jth bit 1\\n                // so when we \\'and\\' them with the\\n                // subset number we get which numbers\\n                // are present in the subset and which\\n                // are not\\n                if ((i & (1 << j)) > 0) {\\n                  tmp = tmp ^ nums[j];\\n                }\\n            }\\n           sum+=tmp;\\n        }\\n      return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int subsetXORSum(int[] nums) {\\n     \\n        int n = nums.length;\\n        int tmp = 0;\\n        int sum = 0;\\n  \\n        // Run a loop for printing all 2^n\\n        // subsets one by one\\n        for (int i = 0; i < (1<<n); i++) {\\n           tmp = 0;\\n            for (int j = 0; j < n; j++) {\\n                // (1<<j) is a number with jth bit 1\\n                // so when we \\'and\\' them with the\\n                // subset number we get which numbers\\n                // are present in the subset and which\\n                // are not\\n                if ((i & (1 << j)) > 0) {\\n                  tmp = tmp ^ nums[j];\\n                }\\n            }\\n           sum+=tmp;\\n        }\\n      return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1211134,
                "title": "c-100-percent-fast-o-n",
                "content": "```\\n  int subsetXORSum(vector<int>& nums) {\\n        int XOR = 0;\\n        int OR = 0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            OR = OR | nums[i];\\n        }\\n        \\n        return OR * pow(2,nums.size()-1);\\n    }\\n\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n  int subsetXORSum(vector<int>& nums) {\\n        int XOR = 0;\\n        int OR = 0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            OR = OR | nums[i];\\n        }\\n        \\n        return OR * pow(2,nums.size()-1);\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1211106,
                "title": "1863-sum-of-all-subset-xor-totals-javascript-solution",
                "content": "```\\nvar subsetXORSum = function(nums) {\\n   let bitOR = 0;\\n   for (let  i=0; i < nums.length; ++i) {\\n       bitOR |= nums[i]; \\n   }\\n   return (bitOR * Math.pow(2, nums.length-1));\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar subsetXORSum = function(nums) {\\n   let bitOR = 0;\\n   for (let  i=0; i < nums.length; ++i) {\\n       bitOR |= nums[i]; \\n   }\\n   return (bitOR * Math.pow(2, nums.length-1));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3962386,
                "title": "new-way-from-itertools-import-combinations",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom itertools import combinations\\nclass Solution(object):\\n    def subsetXORSum(self, nums):\\n        result = 0\\n        for r in range(len(nums) + 1):\\n            for subset in combinations(nums, r):\\n                xor_total = 0\\n                for num in subset:\\n                    xor_total ^= num\\n                result += xor_total\\n        return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom itertools import combinations\\nclass Solution(object):\\n    def subsetXORSum(self, nums):\\n        result = 0\\n        for r in range(len(nums) + 1):\\n            for subset in combinations(nums, r):\\n                xor_total = 0\\n                for num in subset:\\n                    xor_total ^= num\\n                result += xor_total\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953041,
                "title": "best-optimal-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def subsetXORSum(self, nums: List[int]) -> int:\\n        sum = 0\\n        for i in nums:\\n            sum |= i\\n            result = sum*(2**(len(nums)-1))\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subsetXORSum(self, nums: List[int]) -> int:\\n        sum = 0\\n        for i in nums:\\n            sum |= i\\n            result = sum*(2**(len(nums)-1))\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3774236,
                "title": "go-golang-solution",
                "content": "```\\nfunc subsetXORSum(nums []int) int {\\n        n := len(nums)\\n        var sum int\\n\\n        for i := 0; i < (1 << n); i++ {\\n                var val int\\n\\n                for j := 0; j < n; j++ {\\n                        if (i & (1 << j)) != 0 {\\n                                num := nums[j]\\n                                if val == 0 {\\n                                        val = num\\n                                        continue\\n                                }\\n\\n                                val ^= num\\n                        }\\n                }\\n\\n                sum += val\\n        }\\n\\n        return sum\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc subsetXORSum(nums []int) int {\\n        n := len(nums)\\n        var sum int\\n\\n        for i := 0; i < (1 << n); i++ {\\n                var val int\\n\\n                for j := 0; j < n; j++ {\\n                        if (i & (1 << j)) != 0 {\\n                                num := nums[j]\\n                                if val == 0 {\\n                                        val = num\\n                                        continue\\n                                }\\n\\n                                val ^= num\\n                        }\\n                }\\n\\n                sum += val\\n        }\\n\\n        return sum\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3444136,
                "title": "java-simple-solution-backtracking-recursion",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    public int subsetXORSum(int[] nums) {\\n        return helper(nums, 0, 0);\\n    }\\n    \\n    private int helper(int[] nums, int index, int currentXor) {\\n        // return currentXor when all elements in nums are already considered\\n        if (index == nums.length) return currentXor;\\n        \\n        // calculate sum of xor with current element\\n        int withElement = helper(nums, index + 1, currentXor ^ nums[index]);\\n        \\n        // calculate sum of xor without current element\\n        int withoutElement = helper(nums, index + 1, currentXor);\\n        \\n        // return sum of xors from recursion\\n        return withElement + withoutElement;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int subsetXORSum(int[] nums) {\\n        return helper(nums, 0, 0);\\n    }\\n    \\n    private int helper(int[] nums, int index, int currentXor) {\\n        // return currentXor when all elements in nums are already considered\\n        if (index == nums.length) return currentXor;\\n        \\n        // calculate sum of xor with current element\\n        int withElement = helper(nums, index + 1, currentXor ^ nums[index]);\\n        \\n        // calculate sum of xor without current element\\n        int withoutElement = helper(nums, index + 1, currentXor);\\n        \\n        // return sum of xors from recursion\\n        return withElement + withoutElement;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435225,
                "title": "c-easy",
                "content": "# Code\\n```\\npublic class Solution {\\n    \\n        public int SubsetXORSum(int[] nums)\\n        {\\n            return XORSubsets(nums, 0, 0);\\n        }\\n\\n        private int XORSubsets(int[] nums, int index, int res)\\n        {\\n            if (index == nums.Length)\\n            {\\n                return res;\\n            }\\n\\n            return XORSubsets(nums, index + 1, res) + XORSubsets(nums, index + 1, res ^ nums[index]);\\n        }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    \\n        public int SubsetXORSum(int[] nums)\\n        {\\n            return XORSubsets(nums, 0, 0);\\n        }\\n\\n        private int XORSubsets(int[] nums, int index, int res)\\n        {\\n            if (index == nums.Length)\\n            {\\n                return res;\\n            }\\n\\n            return XORSubsets(nums, index + 1, res) + XORSubsets(nums, index + 1, res ^ nums[index]);\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3325914,
                "title": "very-easy-solution",
                "content": "```\\nclass Solution:\\n    def subsetXORSum(self, A: List[int]) -> int:\\n        ans=0\\n        def solve(idx,sum1):\\n            if idx==len(A):\\n                nonlocal ans\\n                ans+=sum1\\n                return\\n            solve(idx+1,sum1^A[idx])\\n            solve(idx+1,sum1)\\n        solve(0,0)\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def subsetXORSum(self, A: List[int]) -> int:\\n        ans=0\\n        def solve(idx,sum1):\\n            if idx==len(A):\\n                nonlocal ans\\n                ans+=sum1\\n                return\\n            solve(idx+1,sum1^A[idx])\\n            solve(idx+1,sum1)\\n        solve(0,0)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3155791,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subsetXORSum(vector<int>& nums) {\\n        \\n    int n=nums.size();\\n    int sum = 0;\\n    for (int i = 0; i < (1 << n); i++)\\n    {\\n        int temp = 0;\\n        for (int j = 0; j < n; j++)\\n        {\\n            if (i & (1 << j))\\n            {\\n                temp = temp ^ nums[j];\\n            }\\n        }\\n        sum = sum + temp;\\n    }\\n    return sum;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subsetXORSum(vector<int>& nums) {\\n        \\n    int n=nums.size();\\n    int sum = 0;\\n    for (int i = 0; i < (1 << n); i++)\\n    {\\n        int temp = 0;\\n        for (int j = 0; j < n; j++)\\n        {\\n            if (i & (1 << j))\\n            {\\n                temp = temp ^ nums[j];\\n            }\\n        }\\n        sum = sum + temp;\\n    }\\n    return sum;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096796,
                "title": "java-easy-solution-using-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    /*First we calculaye all the subset of the array nums usinging backtracking then we calculate xor of each subset and add it to the sum and also since duplicate subset should also be taken so we are storing all subset in a ArrayList insted of Set because in set we will only get unique list*/\\n    public int subsetXORSum(int[] nums) {\\n    List<List<Integer>> ans=new ArrayList<>(); \\n    List<Integer> temp=new ArrayList<>();\\n    backTrack(ans,temp,nums,0);\\n    return calculateXor(ans);\\n    }\\n    public void backTrack(List<List<Integer>> ans,List<Integer> temp,int nums[],int index){\\n        for(int i=index;i<nums.length;i++){\\n            temp.add(nums[i]);\\n            backTrack(ans,temp,nums,i+1);\\n            ans.add(new ArrayList<>(temp));\\n            temp.remove(temp.size()-1);\\n        }\\n    }\\n    public int calculateXor(List<List<Integer>> l){\\n        int sum=0;\\n        for(int i=0;i<l.size();i++){\\n            List<Integer> temp=l.get(i);\\n            if(temp.size()==1){\\n                sum+=temp.get(0);\\n            }else{\\n                int total=0;\\n                for(int j=0;j<temp.size();j++){\\n                    total=total^temp.get(j);\\n                }\\n                 sum+=total;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    /*First we calculaye all the subset of the array nums usinging backtracking then we calculate xor of each subset and add it to the sum and also since duplicate subset should also be taken so we are storing all subset in a ArrayList insted of Set because in set we will only get unique list*/\\n    public int subsetXORSum(int[] nums) {\\n    List<List<Integer>> ans=new ArrayList<>(); \\n    List<Integer> temp=new ArrayList<>();\\n    backTrack(ans,temp,nums,0);\\n    return calculateXor(ans);\\n    }\\n    public void backTrack(List<List<Integer>> ans,List<Integer> temp,int nums[],int index){\\n        for(int i=index;i<nums.length;i++){\\n            temp.add(nums[i]);\\n            backTrack(ans,temp,nums,i+1);\\n            ans.add(new ArrayList<>(temp));\\n            temp.remove(temp.size()-1);\\n        }\\n    }\\n    public int calculateXor(List<List<Integer>> l){\\n        int sum=0;\\n        for(int i=0;i<l.size();i++){\\n            List<Integer> temp=l.get(i);\\n            if(temp.size()==1){\\n                sum+=temp.get(0);\\n            }else{\\n                int total=0;\\n                for(int j=0;j<temp.size();j++){\\n                    total=total^temp.get(j);\\n                }\\n                 sum+=total;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2983221,
                "title": "subset-in-java-100-0ms",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    int total=0;\\n    public int subsetXORSum(int[] nums) {\\n        subset(nums,0,0,nums.length);\\n        return total;\\n    }\\n    public void subset(int[] arr,int prev_xor,int start,int len){\\n        for(int i=start;i<len;i++){\\n            int temp=prev_xor^arr[i];\\n            total+=temp;\\n            //System.out.println(prev_xor+\" \"+total);\\n            subset(arr,temp,i+1,len);\\n        }\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int total=0;\\n    public int subsetXORSum(int[] nums) {\\n        subset(nums,0,0,nums.length);\\n        return total;\\n    }\\n    public void subset(int[] arr,int prev_xor,int start,int len){\\n        for(int i=start;i<len;i++){\\n            int temp=prev_xor^arr[i];\\n            total+=temp;\\n            //System.out.println(prev_xor+\" \"+total);\\n            subset(arr,temp,i+1,len);\\n        }\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830690,
                "title": "java-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nrecursive approach\\n\\ncontinously xoring elements on left and right side of recursion tree \\nfor example, after selecting 5, you may select 1 or not select 1 \\nafter 1 is selected, you may select 3 or not select 3 \\n    \\n        /* \\n\\n               5\\n            /    \\\\\\n         5,1       5\\n         / \\\\     /   \\\\\\n    5,1,3  5,1  5,6   5\\n\\n        \\n         */\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(2^n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int subsetXORSum(int[] nums) {\\n        return xorHelp(nums, 0 , 0);\\n        \\n    }\\n    private int xorHelp(int[] nums, int index, int currXor){\\n        //if reached array\\'s end, return currXor\\n        if(index==nums.length)return currXor;\\n      \\n\\n         int include= xorHelp(nums, index+1, currXor^nums[index]);\\n         int exlude= xorHelp(nums, index+1, currXor);\\n\\n         int ansSum= include+exlude;\\n         return ansSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int subsetXORSum(int[] nums) {\\n        return xorHelp(nums, 0 , 0);\\n        \\n    }\\n    private int xorHelp(int[] nums, int index, int currXor){\\n        //if reached array\\'s end, return currXor\\n        if(index==nums.length)return currXor;\\n      \\n\\n         int include= xorHelp(nums, index+1, currXor^nums[index]);\\n         int exlude= xorHelp(nums, index+1, currXor);\\n\\n         int ansSum= include+exlude;\\n         return ansSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2738052,
                "title": "java-solution-using-bit-masking-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int subsetXORSum(int[] nums) {\\n        int n=nums.length;\\n        int size=(1<<n);\\n        int sum=0;\\n        for(int i=0;i<size;i++)\\n        {\\n            int temp=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                if((i & (1<<j))>0)\\n                {\\n                    temp^=nums[j];\\n                    \\n               }\\n            }\\n            sum+=temp;\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int subsetXORSum(int[] nums) {\\n        int n=nums.length;\\n        int size=(1<<n);\\n        int sum=0;\\n        for(int i=0;i<size;i++)\\n        {\\n            int temp=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                if((i & (1<<j))>0)\\n                {\\n                    temp^=nums[j];\\n                    \\n               }\\n            }\\n            sum+=temp;\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2668208,
                "title": "100-fast-simple-and-understandable-recursive-solution",
                "content": "```\\nclass Solution {\\n    \\n    static int subset( int[] nums , int i , int xor , int ans){\\n        \\n        if( nums.length == i){\\n            \\n            ans += xor;\\n            \\n            return ans;\\n            \\n        }\\n        \\n        int l = subset( nums , i + 1 , xor ^ nums[i] , ans);\\n        \\n        int r = subset( nums , i + 1 , xor , ans );\\n        \\n        return (l + r);\\n    }\\n    \\n    public int subsetXORSum(int[] nums) {\\n        \\n        int ans = 0;\\n        \\n        return subset( nums , 0 , 0 , ans);\\n    \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n    \\n    static int subset( int[] nums , int i , int xor , int ans){\\n        \\n        if( nums.length == i){\\n            \\n            ans += xor;\\n            \\n            return ans;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2659042,
                "title": "java-backtracking-solution-simple-efficient-code",
                "content": "```\\nclass Solution {\\n    public int ans = 0;\\n    public void solve(int[] arr, int i, int xor) {\\n        //When we reach the end of array we add the xor to the ans variable\\n        if(i==arr.length) {\\n            ans+=xor;\\n            return;\\n        }\\n        //including the current index element\\n        xor^=arr[i];\\n        solve(arr,i+1,xor);\\n        //backtracking to remove the current index element from the xor\\n        xor^=arr[i];\\n        //excluding the current index element\\n        solve(arr,i+1,xor);\\n    }\\n    public int subsetXORSum(int[] nums) {\\n        int xor=0;\\n        int ind=0;\\n        solve(nums,ind,xor);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public int ans = 0;\\n    public void solve(int[] arr, int i, int xor) {\\n        //When we reach the end of array we add the xor to the ans variable\\n        if(i==arr.length) {\\n            ans+=xor;\\n            return;\\n        }\\n        //including the current index element\\n        xor^=arr[i];\\n        solve(arr,i+1,xor);\\n        //backtracking to remove the current index element from the xor\\n        xor^=arr[i];\\n        //excluding the current index element\\n        solve(arr,i+1,xor);\\n    }\\n    public int subsetXORSum(int[] nums) {\\n        int xor=0;\\n        int ind=0;\\n        solve(nums,ind,xor);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2608762,
                "title": "c-easy-solution-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    int f(int ind, int xorValue, vector<int> &a) {\\n        if(ind == a.size()) return xorValue;\\n        int pick = f(ind+1, xorValue^a[ind], a);\\n        int notPick = f(ind+1, xorValue, a);\\n        return pick + notPick;\\n    }\\n    int subsetXORSum(vector<int>& a) {\\n        int ind = 0, xorValue = 0;\\n        return f(ind, xorValue, a);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int ind, int xorValue, vector<int> &a) {\\n        if(ind == a.size()) return xorValue;\\n        int pick = f(ind+1, xorValue^a[ind], a);\\n        int notPick = f(ind+1, xorValue, a);\\n        return pick + notPick;\\n    }\\n    int subsetXORSum(vector<int>& a) {\\n        int ind = 0, xorValue = 0;\\n        return f(ind, xorValue, a);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2500702,
                "title": "inclusion-exclusion-principle-c-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    void subset(vector<int>nums,vector<int>output,vector<vector<int>>& ans,int index){\\n        if(index>=nums.size()){\\n            ans.push_back(output);\\n            return;\\n        }\\n        subset(nums,output,ans,index+1);\\n        int element=nums[index];\\n        output.push_back(element);\\n        subset(nums,output,ans,index+1);\\n        output.pop_back();\\n        \\n    }\\n    \\n    int subsetXORSum(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        vector<int>output;\\n         int index=0;\\n       \\n        subset(nums,output,ans,index);\\n        \\n         int answer=0;\\n         for(int i=0;i<ans.size();i++){\\n             int xor_calc=0;\\n             for(int j=0;j<ans[i].size();j++){\\n                 xor_calc=xor_calc^ans[i][j];\\n             }\\n             answer+=xor_calc;\\n         }\\n        \\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void subset(vector<int>nums,vector<int>output,vector<vector<int>>& ans,int index){\\n        if(index>=nums.size()){\\n            ans.push_back(output);\\n            return;\\n        }\\n        subset(nums,output,ans,index+1);\\n        int element=nums[index];\\n        output.push_back(element);\\n        subset(nums,output,ans,index+1);\\n        output.pop_back();\\n        \\n    }\\n    \\n    int subsetXORSum(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        vector<int>output;\\n         int index=0;\\n       \\n        subset(nums,output,ans,index);\\n        \\n         int answer=0;\\n         for(int i=0;i<ans.size();i++){\\n             int xor_calc=0;\\n             for(int j=0;j<ans[i].size();j++){\\n                 xor_calc=xor_calc^ans[i][j];\\n             }\\n             answer+=xor_calc;\\n         }\\n        \\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2479358,
                "title": "6ms-c-back-tracking-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(int s,int &n,int &x,int &ans,vector<int> &nums){\\n        if(s>n)return;\\n        for(int i = s; i <= n; i++){\\n            x ^= nums[i];\\n            // cout<<x<<\" \";\\n            // i++;\\n            ans += x;\\n            solve(i+1,n,x,ans,nums);\\n            x ^= nums[i];\\n            // i--;\\n        }\\n    }\\n    int subsetXORSum(vector<int>& nums) {\\n        int ans = 0;\\n        int s = 0, n = nums.size()-1, x = 0;\\n        solve(s,n,x,ans,nums);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int s,int &n,int &x,int &ans,vector<int> &nums){\\n        if(s>n)return;\\n        for(int i = s; i <= n; i++){\\n            x ^= nums[i];\\n            // cout<<x<<\" \";\\n            // i++;\\n            ans += x;\\n            solve(i+1,n,x,ans,nums);\\n            x ^= nums[i];\\n            // i--;\\n        }\\n    }\\n    int subsetXORSum(vector<int>& nums) {\\n        int ans = 0;\\n        int s = 0, n = nums.size()-1, x = 0;\\n        solve(s,n,x,ans,nums);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2453553,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Backtracking***\\n\\n* ***Time Complexity :- O(N * 2 ^ N)***\\n\\n* ***Space Complexity :- O(N * 2 ^ N)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int total_sum = 0;\\n    \\n    void dfs(vector<int>& nums, int i, int n, vector<int> curr)\\n    {\\n        if(i == n)\\n        {\\n            // find the xorr of the set\\n            \\n            int xorr = 0;\\n            \\n            for(auto x : curr)\\n            {\\n                xorr ^= x;\\n            }\\n            \\n            // update total sum\\n            \\n            total_sum += xorr;\\n            \\n            return;\\n        }\\n        \\n        // exclude the curr element\\n        \\n        dfs(nums, i + 1, n, curr);\\n        \\n        // include the curr element\\n        \\n        curr.push_back(nums[i]);\\n        \\n        dfs(nums, i + 1, n, curr);\\n        \\n        // backtrack \\n        \\n        curr.pop_back();\\n    }\\n    \\n    int subsetXORSum(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        dfs(nums, 0, n, {});\\n        \\n        return total_sum;\\n    }\\n};\\n```\\n\\n* ***Optimized Version Of Above***\\n\\n* ***Time Complexity :- O(2 ^ N)***\\n\\n* ***Space Complexity :- O(2 ^ N)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int dfs(vector<int>& nums, int i, int n, int xorr)\\n    {\\n        // base case\\n        \\n        if(i == n)\\n        {\\n            return xorr;\\n        }\\n        \\n        // exclude the curr element\\n        \\n        int exc = dfs(nums, i + 1, n, xorr);\\n        \\n        // include the curr element\\n       \\n        int inc = dfs(nums, i + 1, n, xorr ^ nums[i]);\\n        \\n        // return total\\n        \\n        return inc + exc;\\n    }\\n    \\n    int subsetXORSum(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        return dfs(nums, 0, n, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int total_sum = 0;\\n    \\n    void dfs(vector<int>& nums, int i, int n, vector<int> curr)\\n    {\\n        if(i == n)\\n        {\\n            // find the xorr of the set\\n            \\n            int xorr = 0;\\n            \\n            for(auto x : curr)\\n            {\\n                xorr ^= x;\\n            }\\n            \\n            // update total sum\\n            \\n            total_sum += xorr;\\n            \\n            return;\\n        }\\n        \\n        // exclude the curr element\\n        \\n        dfs(nums, i + 1, n, curr);\\n        \\n        // include the curr element\\n        \\n        curr.push_back(nums[i]);\\n        \\n        dfs(nums, i + 1, n, curr);\\n        \\n        // backtrack \\n        \\n        curr.pop_back();\\n    }\\n    \\n    int subsetXORSum(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        dfs(nums, 0, n, {});\\n        \\n        return total_sum;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int dfs(vector<int>& nums, int i, int n, int xorr)\\n    {\\n        // base case\\n        \\n        if(i == n)\\n        {\\n            return xorr;\\n        }\\n        \\n        // exclude the curr element\\n        \\n        int exc = dfs(nums, i + 1, n, xorr);\\n        \\n        // include the curr element\\n       \\n        int inc = dfs(nums, i + 1, n, xorr ^ nums[i]);\\n        \\n        // return total\\n        \\n        return inc + exc;\\n    }\\n    \\n    int subsetXORSum(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        return dfs(nums, 0, n, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2387993,
                "title": "java-solution-simple-and-easy",
                "content": "![image](https://assets.leetcode.com/users/images/e2acda25-8740-4645-a76f-f8ac14e7df7d_1659799796.851562.png)\\n\\n```java \\nclass Solution {\\n    private int sum=0;\\n    public int subsetXORSum(int[] nums) {\\n        generate(nums,new ArrayList<Integer>(),0,0,0);\\n        return sum;\\n    }\\n    \\n    \\n    private void generate(int[] nums,ArrayList<Integer> a,int index,int xor,int c)\\n    {\\n        sum+=xor;\\n        for(int i=index;i<nums.length;i++)\\n            generate(nums,a,i+1,xor^nums[i],c+1);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    private int sum=0;\\n    public int subsetXORSum(int[] nums) {\\n        generate(nums,new ArrayList<Integer>(),0,0,0);\\n        return sum;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2371180,
                "title": "java-recursion-simple-solution",
                "content": "```\\nclass Solution {\\n    int subset(int[] a , int i,int n,int sum){\\n        if(i == n){\\n            return sum;\\n        }\\n        int l = subset(a,i+1,n,a[i]^sum);//take\\n        int r = subset(a,i+1,n,sum);//not take\\n        return l+r;\\n    }\\n    public int subsetXORSum(int[] nums) {\\n        return subset(nums,0,nums.length,0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int subset(int[] a , int i,int n,int sum){\\n        if(i == n){\\n            return sum;\\n        }\\n        int l = subset(a,i+1,n,a[i]^sum);//take\\n        int r = subset(a,i+1,n,sum);//not take\\n        return l+r;\\n    }\\n    public int subsetXORSum(int[] nums) {\\n        return subset(nums,0,nums.length,0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2326960,
                "title": "java-easy-solution-using-bit-manipulation",
                "content": "***Please upvote***\\n```\\nclass Solution {\\n   public int subsetXORSum(int[] nums) {\\n \\n     int combinations = 1<<(nums.length);\\n     int ans=0;\\n     for(int i=1;i<combinations;i++)\\n     {\\n         int counter=0,xor=0,temp=i;\\n         while(temp>0)\\n         {\\n             if((temp&1)== 1) \\n                 xor=xor^nums[counter];\\n             temp=temp>>1;\\n             counter++;\\n         }\\n         ans+=xor;\\n\\n     }\\n    return ans;\\n    }\\n  }\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n   public int subsetXORSum(int[] nums) {\\n \\n     int combinations = 1<<(nums.length);\\n     int ans=0;\\n     for(int i=1;i<combinations;i++)\\n     {\\n         int counter=0,xor=0,temp=i;\\n         while(temp>0)\\n         {\\n             if((temp&1)== 1) \\n                 xor=xor^nums[counter];\\n             temp=temp>>1;\\n             counter++;\\n         }\\n         ans+=xor;\\n\\n     }\\n    return ans;\\n    }\\n  }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2303119,
                "title": "c-solution-time-o-2-n-memory-o-1-easy-to-understand-recursion",
                "content": "```C#\\npublic class Solution {\\n    public int SubsetXORSum(int[] nums) {\\n        int sum = 0;\\n        Solve(0, 0);\\n        \\n        return sum;\\n    \\n        void Solve(int index, int runningSum) {\\n            for (int i = index; i < nums.Length; i++) {\\n                int newRunningSum = runningSum ^ nums[i];\\n                sum += newRunningSum;\\n                \\n                if (i + 1 < nums.Length) Solve(i + 1, newRunningSum);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```C#\\npublic class Solution {\\n    public int SubsetXORSum(int[] nums) {\\n        int sum = 0;\\n        Solve(0, 0);\\n        \\n        return sum;\\n    \\n        void Solve(int index, int runningSum) {\\n            for (int i = index; i < nums.Length; i++) {\\n                int newRunningSum = runningSum ^ nums[i];\\n                sum += newRunningSum;\\n                \\n                if (i + 1 < nums.Length) Solve(i + 1, newRunningSum);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2299580,
                "title": "c-solution-recursion-with-backtrackng",
                "content": "```\\nclass Solution {\\npublic:\\n    void maker(int ind,vector<int> nums,int sum,int& ans){\\n        if(ind==nums.size()){\\n            ans+=sum;\\n            return;\\n        }\\n        maker(ind+1,nums,sum,ans);\\n        sum^=nums[ind];\\n        maker(ind+1,nums,sum,ans);\\n    }\\n    int subsetXORSum(vector<int>& nums) {\\n        int ans=0;\\n        maker(0,nums,0,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void maker(int ind,vector<int> nums,int sum,int& ans){\\n        if(ind==nums.size()){\\n            ans+=sum;\\n            return;\\n        }\\n        maker(ind+1,nums,sum,ans);\\n        sum^=nums[ind];\\n        maker(ind+1,nums,sum,ans);\\n    }\\n    int subsetXORSum(vector<int>& nums) {\\n        int ans=0;\\n        maker(0,nums,0,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2291121,
                "title": "c-easy-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int subsetXORSum(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=0;\\n        for(int i=0;i<1<<n;i++){\\n            \\n            int XOR=0;\\n            \\n            for(int bits=0;bits<n;bits++){\\n                if(i&(1<<bits))\\n                    XOR=XOR^nums[bits];   \\n            }\\n            \\n            ans+=XOR;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\npublic:\\n    int subsetXORSum(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=0;\\n        for(int i=0;i<1<<n;i++){\\n            \\n            int XOR=0;\\n            \\n            for(int bits=0;bits<n;bits++){\\n                if(i&(1<<bits))\\n                    XOR=XOR^nums[bits];   \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2277602,
                "title": "c-recursion-easy-code",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    int res=0;\\n    int subsetXORSum(vector<int>& nums) {\\n        vector<int> v;\\n        fun(nums,v,0);\\n        return res;\\n    }\\n    void fun(vector<int>& nums,vector<int>& v,int i)\\n    {\\n        if(i==nums.size())\\n        {\\n            res+=XOR(v);\\n            return;\\n        }\\n        \\n        fun(nums,v,i+1);\\n        v.push_back(nums[i]);\\n        fun(nums,v,i+1);\\n        v.pop_back();\\n        \\n    }\\n    int XOR(vector<int>& v)\\n    {\\n        int t=0;\\n        for(auto x:v)\\n            t^=x;\\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int res=0;\\n    int subsetXORSum(vector<int>& nums) {\\n        vector<int> v;\\n        fun(nums,v,0);\\n        return res;\\n    }\\n    void fun(vector<int>& nums,vector<int>& v,int i)\\n    {\\n        if(i==nums.size())\\n        {\\n            res+=XOR(v);\\n            return;\\n        }\\n        \\n        fun(nums,v,i+1);\\n        v.push_back(nums[i]);\\n        fun(nums,v,i+1);\\n        v.pop_back();\\n        \\n    }\\n    int XOR(vector<int>& v)\\n    {\\n        int t=0;\\n        for(auto x:v)\\n            t^=x;\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2231737,
                "title": "one-liner-java-solution",
                "content": "class Solution {\\n    public int subset(int [] nums, int start, int end, int ans){\\n        if(start == end) return ans;\\n        return subset(nums, start+1, end, ans^nums[start]) + subset(nums, start+1, end, ans);\\n    }\\n    public int subsetXORSum(int[] nums) {\\n        return subset(nums, 0, nums.length, 0);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public int subset(int [] nums, int start, int end, int ans){\\n        if(start == end) return ans;\\n        return subset(nums, start+1, end, ans^nums[start]) + subset(nums, start+1, end, ans);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2208010,
                "title": "c-solution-with-5ms-runtime",
                "content": "Using bit manipulation, solution of this question becomes very easy.\\nFirst of all, perform Bitwise OR among all the elements of the array.\\nAfter that perform left-shift operation with array.size() - 1.\\n```\\nclass Solution {\\npublic:\\n    int subsetXORSum(vector<int>& nums) {\\n        int res = 0;\\n        for(auto x : nums) {\\n            res |= x;\\n        }\\n        return res << (nums.size() - 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subsetXORSum(vector<int>& nums) {\\n        int res = 0;\\n        for(auto x : nums) {\\n            res |= x;\\n        }\\n        return res << (nums.size() - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2195462,
                "title": "c-backtracking-bitmanipulation-recursion",
                "content": "![image](https://assets.leetcode.com/users/images/d987f474-7431-4163-a612-3cd606aa8e2a_1656164464.7806656.png)\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\n\\t\\tvector<vector<int>>v;\\n\\t\\t\\n\\t\\tvoid generate(vector<int>&subset,int i,vector<int>&nums){\\n\\t\\t\\tif(i==nums.size()){\\n\\t\\t\\t\\tv.push_back(subset);\\n\\t\\t\\t\\treturn ;\\n\\t\\t\\t}\\n\\t\\t\\tgenerate(subset,i+1,nums);\\n\\t\\t\\tsubset.push_back(nums[i]);\\n\\t\\t\\tgenerate(subset,i+1,nums);\\n\\t\\t\\tsubset.pop_back();\\n\\t\\t}\\n\\n\\n\\t\\tint subsetXORSum(vector<int>& nums) {\\n\\t\\t\\tvector<int>empty;\\n\\t\\t\\tgenerate(empty,0,nums);\\n\\t\\t\\tint sum=0;\\n\\t\\t\\tfor(int i=0;i<v.size();i++){\\n\\t\\t\\t\\tif(v[i].size()>1){\\n\\t\\t\\t\\t\\tint x=v[i][0];\\n\\t\\t\\t\\t\\tfor(int j=1;j<v[i].size();j++) x^=v[i][j];\\n\\t\\t\\t\\t\\tsum+=x;\\n\\t\\t\\t\\t} \\n\\t\\t\\t\\telse if(v[i].size()==1)sum+=v[i][0];\\n\\t\\t\\t}\\n\\t\\t\\treturn sum;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\n\\t\\tvector<vector<int>>v;\\n\\t\\t\\n\\t\\tvoid generate(vector<int>&subset,int i,vector<int>&nums){\\n\\t\\t\\tif(i==nums.size()){\\n\\t\\t\\t\\tv.push_back(subset);\\n\\t\\t\\t\\treturn ;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2190403,
                "title": "c-easy-bit-masking",
                "content": "class Solution {\\npublic:\\n    int subsetXORSum(vector<int>& nums) {\\n        int n=nums.size();\\n        int sum=0;\\n        \\n        for(int i=0;i<(1<<n);i++)\\n        { int add=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                if((1<<j)&i)\\n                {\\n                    add^=nums[j];\\n                }\\n                    \\n            }\\n         sum+=add;\\n        }\\n        return sum;\\n    }\\n    \\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int subsetXORSum(vector<int>& nums) {\\n        int n=nums.size();\\n        int sum=0;\\n        \\n        for(int i=0;i<(1<<n);i++)\\n        { int add=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                if((1<<j)&i)\\n                {\\n                    add^=nums[j];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2146274,
                "title": "c-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void helper(vector<int> &nums,vector<int> &ans,int &XOR,int &sum,int index)\\n    {\\n        if(index == nums.size())\\n        {\\n            for(int i=0;i<ans.size();i++)\\n            {\\n                XOR = XOR^ans[i];   \\n            }\\n            sum+=XOR;\\n            XOR = 0;\\n            return;\\n        }\\n        ans.push_back(nums[index]);\\n        helper(nums,ans,XOR,sum,index+1);\\n        ans.pop_back();\\n        helper(nums,ans,XOR,sum,index+1);\\n    }\\n    int subsetXORSum(vector<int>& nums) {\\n        int sum = 0;\\n        int XOR = 0;\\n        vector<int> ans;\\n        helper(nums,ans,XOR,sum,0);\\n        return(sum);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(vector<int> &nums,vector<int> &ans,int &XOR,int &sum,int index)\\n    {\\n        if(index == nums.size())\\n        {\\n            for(int i=0;i<ans.size();i++)\\n            {\\n                XOR = XOR^ans[i];   \\n            }\\n            sum+=XOR;\\n            XOR = 0;\\n            return;\\n        }\\n        ans.push_back(nums[index]);\\n        helper(nums,ans,XOR,sum,index+1);\\n        ans.pop_back();\\n        helper(nums,ans,XOR,sum,index+1);\\n    }\\n    int subsetXORSum(vector<int>& nums) {\\n        int sum = 0;\\n        int XOR = 0;\\n        vector<int> ans;\\n        helper(nums,ans,XOR,sum,0);\\n        return(sum);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2070002,
                "title": "c-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    void f(vector<int>&nums,int i,vector<int>&v,int xr)\\n    { \\n        if(i>=nums.size())\\n        { \\n            v.push_back(xr);\\n            return ;\\n        }\\n        \\n        xr=xr^nums[i];\\n        f(nums,i+1,v,xr);\\n        xr=xr^nums[i];\\n        f(nums,i+1,v,xr);\\n    }\\n    int subsetXORSum(vector<int>& nums) {\\n        vector<int>v;\\n        int xr=0;\\n        f(nums,0,v,0);\\n        int ans=0;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            ans=ans+v[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void f(vector<int>&nums,int i,vector<int>&v,int xr)\\n    { \\n        if(i>=nums.size())\\n        { \\n            v.push_back(xr);\\n            return ;\\n        }\\n        \\n        xr=xr^nums[i];\\n        f(nums,i+1,v,xr);\\n        xr=xr^nums[i];\\n        f(nums,i+1,v,xr);\\n    }\\n    int subsetXORSum(vector<int>& nums) {\\n        vector<int>v;\\n        int xr=0;\\n        f(nums,0,v,0);\\n        int ans=0;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            ans=ans+v[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2021456,
                "title": "c",
                "content": "int subsetXORSum(vector<int>& nums) {\\n        int ans=0;\\n        \\n        for(int i=0;i<1<<nums.size();i++){\\n            int n=i;\\n            int temp=0;\\n            int j=0;\\n            while(n){\\n                if(n&1){\\n                    temp^=nums[j];\\n                }\\n                j++;\\n                n>>=1;\\n            }\\n            ans+=temp;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "int subsetXORSum(vector<int>& nums) {\\n        int ans=0;\\n        \\n        for(int i=0;i<1<<nums.size();i++){\\n            int n=i;\\n            int temp=0;\\n            int j=0;\\n            while(n){\\n                if(n&1){\\n                    temp^=nums[j];\\n                }\\n                j++;\\n                n>>=1;\\n            }\\n            ans+=temp;\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1982975,
                "title": "c-solution-backtracking",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int subsetXORSum(vector<int>& nums) \\n    {\\n        int res = 0;\\n        std::vector<int> temp;\\n        subsetsUtil(nums, temp, 0, res);\\n        \\n        return res;\\n    }\\nprivate:\\n    void subsetsUtil(vector<int>& A, vector<int>& subset, int index, int& res)\\n    {\\n        // calculate xor of total\\n        int x = 0;\\n        for (const int& n : subset)\\n            x ^= n;\\n        res += x;\\n        \\n        for (int i = index; i < A.size(); i++) \\n        {\\n\\n            // include the A[i] in subset.\\n            subset.push_back(A[i]);\\n\\n            // move onto the next element.\\n            subsetsUtil(A, subset, i + 1, res);\\n\\n            // exclude the A[i] from subset and triggers\\n            // backtracking.\\n            subset.pop_back();\\n        }\\n\\n        return;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int subsetXORSum(vector<int>& nums) \\n    {\\n        int res = 0;\\n        std::vector<int> temp;\\n        subsetsUtil(nums, temp, 0, res);\\n        \\n        return res;\\n    }\\nprivate:\\n    void subsetsUtil(vector<int>& A, vector<int>& subset, int index, int& res)\\n    {\\n        // calculate xor of total\\n        int x = 0;\\n        for (const int& n : subset)\\n            x ^= n;\\n        res += x;\\n        \\n        for (int i = index; i < A.size(); i++) \\n        {\\n\\n            // include the A[i] in subset.\\n            subset.push_back(A[i]);\\n\\n            // move onto the next element.\\n            subsetsUtil(A, subset, i + 1, res);\\n\\n            // exclude the A[i] from subset and triggers\\n            // backtracking.\\n            subset.pop_back();\\n        }\\n\\n        return;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976223,
                "title": "java-backtracking-solution-with-for-and-recursion",
                "content": "```\\nclass Solution {\\n    \\n    public int subsetXORSum(int[] nums) {\\n        return xorSum(nums, 0, 0);\\n    }\\n    \\n    public int xorSum(int[] nums, int idx, int xor){\\n        int sum = 0;\\n        for(int i=idx; i<nums.length; i++){\\n            sum+=xorSum(nums, i+1, xor^nums[i]);\\n        }\\n        \\n        return sum+xor;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int subsetXORSum(int[] nums) {\\n        return xorSum(nums, 0, 0);\\n    }\\n    \\n    public int xorSum(int[] nums, int idx, int xor){\\n        int sum = 0;\\n        for(int i=idx; i<nums.length; i++){\\n            sum+=xorSum(nums, i+1, xor^nums[i]);\\n        }\\n        \\n        return sum+xor;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1953339,
                "title": "easy-100-faster-0ms-solution",
                "content": "```\\nclass Solution {\\n    public int subsetXORSum(int[] nums) {\\n        return calculator(nums, 0, 0);\\n    }\\n    \\n    public int calculator(int[] nums, int level, int currentXOR) {\\n        if(level == nums.length) {\\n            return currentXOR;\\n        }\\n        int include = calculator(nums, level+1, currentXOR^nums[level]);\\n        int exclude = calculator(nums, level+1, currentXOR);\\n        return include + exclude;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int subsetXORSum(int[] nums) {\\n        return calculator(nums, 0, 0);\\n    }\\n    \\n    public int calculator(int[] nums, int level, int currentXOR) {\\n        if(level == nums.length) {\\n            return currentXOR;\\n        }\\n        int include = calculator(nums, level+1, currentXOR^nums[level]);\\n        int exclude = calculator(nums, level+1, currentXOR);\\n        return include + exclude;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1948562,
                "title": "c-backtracking-easy",
                "content": "\\n    int sumxor(vector<int>&nums,int ind,int sxor){\\n        if(ind==nums.size()) {\\n            return sxor;\\n        }\\n        int pick=sumxor(nums,ind+1,sxor^nums[ind]);\\n        int notpick=sumxor(nums,ind+1,sxor);\\n        \\n        return pick + notpick;\\n    }\\n    int subsetXORSum(vector<int>& nums) {\\n        int index=0;\\n        int sxor=0;\\n        int totalxor=sumxor(nums,index,sxor);\\n        return totalxor;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "\\n    int sumxor(vector<int>&nums,int ind,int sxor){\\n        if(ind==nums.size()) {\\n            return sxor;\\n        }\\n        int pick=sumxor(nums,ind+1,sxor^nums[ind]);\\n        int notpick=sumxor(nums,ind+1,sxor);\\n        \\n        return pick + notpick;\\n    }\\n    int subsetXORSum(vector<int>& nums) {\\n        int index=0;\\n        int sxor=0;\\n        int totalxor=sumxor(nums,index,sxor);\\n        return totalxor;\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1872994,
                "title": "c-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int subsetXORSum(vector<int>& nums) {\\n        int n = pow(2, nums.size());\\n        int ans = 0;\\n        for(int i=1; i<n; i++)\\n        { \\n            int tempAns = 0;\\n            for(int j=0; j<nums.size(); j++)\\n            {\\n                int temp = 1<<j;\\n                if(i&temp)\\n                {\\n                    tempAns = tempAns^nums[j];\\n                }\\n            }\\n            ans += tempAns;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int subsetXORSum(vector<int>& nums) {\\n        int n = pow(2, nums.size());\\n        int ans = 0;\\n        for(int i=1; i<n; i++)\\n        { \\n            int tempAns = 0;\\n            for(int j=0; j<nums.size(); j++)\\n            {\\n                int temp = 1<<j;\\n                if(i&temp)\\n                {\\n                    tempAns = tempAns^nums[j];\\n                }\\n            }\\n            ans += tempAns;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1869391,
                "title": "python-backtracking-why-easy",
                "content": "I\\'m kind of confused why this is an easy problem but problem #78 (Subsets) is a medium (since problem #78 is just part of this problem?)\\n\\nclass Solution:\\n\\n    def subsetXORSum(self, nums: List[int]) -> int:\\n        self.res = []\\n        self.l = []\\n        self.dfs(nums,0)\\n        ans = 0\\n        for i in range(len(self.res)):\\n            ans = ans + self.listXor(self.res[i])\\n        return ans\\n\\n    def dfs(self,nums,start):\\n        if start == len(nums):return\\n        for i in range(start,len(nums)):\\n            self.l.append(nums[i])\\n            a = [j for j in self.l]\\n            self.res.append(a)\\n            self.dfs(nums,i+1)\\n            self.l.pop()\\n    \\n    def listXor(self,a):\\n        n = len(a)\\n        if n == 1:\\n            return a[0]\\n        res = a[0]\\n        for i in range(1,n):\\n            res = a[i]^res\\n        return res",
                "solutionTags": [],
                "code": "I\\'m kind of confused why this is an easy problem but problem #78 (Subsets) is a medium (since problem #78 is just part of this problem?)\\n\\nclass Solution:\\n\\n    def subsetXORSum(self, nums: List[int]) -> int:\\n        self.res = []\\n        self.l = []\\n        self.dfs(nums,0)\\n        ans = 0\\n        for i in range(len(self.res)):\\n            ans = ans + self.listXor(self.res[i])\\n        return ans\\n\\n    def dfs(self,nums,start):\\n        if start == len(nums):return\\n        for i in range(start,len(nums)):\\n            self.l.append(nums[i])\\n            a = [j for j in self.l]\\n            self.res.append(a)\\n            self.dfs(nums,i+1)\\n            self.l.pop()\\n    \\n    def listXor(self,a):\\n        n = len(a)\\n        if n == 1:\\n            return a[0]\\n        res = a[0]\\n        for i in range(1,n):\\n            res = a[i]^res\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1865154,
                "title": "java-bfs-beats-100",
                "content": "```\\nclass Solution {\\n    public int subsetXORSum(int[] nums) {\\n     return subsetXORSum(nums, 0, 0);\\n    }\\n    \\n    public int subsetXORSum(int[] nums, int start, int xor) {\\n        if(start==nums.length) return xor;\\n        int sum=0;\\n        for(int i=start;i<nums.length;i++){\\n            sum+=subsetXORSum(nums, i+1, nums[i]^xor);\\n        }\\n        return xor+sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int subsetXORSum(int[] nums) {\\n     return subsetXORSum(nums, 0, 0);\\n    }\\n    \\n    public int subsetXORSum(int[] nums, int start, int xor) {\\n        if(start==nums.length) return xor;\\n        int sum=0;\\n        for(int i=start;i<nums.length;i++){\\n            sum+=subsetXORSum(nums, i+1, nums[i]^xor);\\n        }\\n        return xor+sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1847400,
                "title": "swift-recursion-backtracking",
                "content": "```\\n\\nclass Solution {\\n    func bt(at index: Int, for current: inout Int, _ list: [Int]) -> Int {\\n        if (index == list.count) {\\n            return current\\n        }\\n        var c = current ^ list[index]\\n        return bt(at: index+1, for: &c, list) + bt(at: index+1, for: &current, list)\\n        \\n    }\\n    func subsetXORSum(_ nums: [Int]) -> Int {\\n        var current = 0\\n        return bt(at: 0, for: &current, nums)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n\\nclass Solution {\\n    func bt(at index: Int, for current: inout Int, _ list: [Int]) -> Int {\\n        if (index == list.count) {\\n            return current\\n        }\\n        var c = current ^ list[index]\\n        return bt(at: index+1, for: &c, list) + bt(at: index+1, for: &current, list)\\n        \\n    }\\n    func subsetXORSum(_ nums: [Int]) -> Int {\\n        var current = 0\\n        return bt(at: 0, for: &current, nums)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1818201,
                "title": "python-bit-manipulation-easy-understanding",
                "content": "Hello if you\\'ve got any perspective or understanding on the solution then please give me an upvote. Thanks in advance!\\n\\n```\\ndef subsetXORSum(self, nums: List[int]) -> int:\\n        \\n        xor = 0\\n        xorSum = 0\\n        \\n        numLen = len(nums)\\n        numPow = pow(2, numLen)\\n        \\n        for i in range(numPow):\\n            temp = []\\n            \\n            for j in range(numLen):\\n                if i & (1 << j) != 0:\\n                    temp.append(nums[j])\\n            \\n            xor = 0\\n            for x in temp:\\n                xor = xor ^ x\\n            \\n            xorSum = xorSum + xor\\n            \\n        return xorSum\\n```\\n\\nIf you got any better solutions please comment, would love to learn :)",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\ndef subsetXORSum(self, nums: List[int]) -> int:\\n        \\n        xor = 0\\n        xorSum = 0\\n        \\n        numLen = len(nums)\\n        numPow = pow(2, numLen)\\n        \\n        for i in range(numPow):\\n            temp = []\\n            \\n            for j in range(numLen):\\n                if i & (1 << j) != 0:\\n                    temp.append(nums[j])\\n            \\n            xor = 0\\n            for x in temp:\\n                xor = xor ^ x\\n            \\n            xorSum = xorSum + xor\\n            \\n        return xorSum\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1816205,
                "title": "easiest-solution-available",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    int subsetXORSum(vector<int>& arr ) {\\n        int n=arr.size();\\n          int bits = 0;\\n \\n    // Finding bitwise OR of all elements\\n    for (int i=0; i < n; ++i)\\n    {\\n        bits |= arr[i];\\n    }\\n    int ans = bits * pow(2, n-1);\\n \\n    return ans;\\n    }\\n};",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1813148,
                "title": "100-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int subsetXORSum(vector<int>& nums) {\\n        if(nums.size()==0)return 0;\\n        if(nums.size()==1)return nums[0];\\n        getSum(0,nums,0);\\n        return ans;\\n    }\\n    void getSum(int index,vector<int> &nums,int sum)\\n    {\\n        if(index==nums.size())\\n        {\\n            ans+=sum;\\n            return;\\n        }\\n        getSum(index+1,nums,sum xor nums[index]);\\n        getSum(index+1,nums,sum);\\n    }\\n};",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n    int ans=0;\\n    int subsetXORSum(vector<int>& nums) {\\n        if(nums.size()==0)return 0;\\n        if(nums.size()==1)return nums[0];\\n        getSum(0,nums,0);\\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1723263,
                "title": "beginner-friendly-javascript-solution",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar subsetXORSum = function(nums) {\\n    var sumXor = (nums, i, cur) => {\\n        if(i == nums.length)   return cur;\\n        return sumXor(nums, i+1, cur) + sumXor(nums, i+1, cur^nums[i]);\\n    }\\n    return sumXor(nums, 0, 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar subsetXORSum = function(nums) {\\n    var sumXor = (nums, i, cur) => {\\n        if(i == nums.length)   return cur;\\n        return sumXor(nums, i+1, cur) + sumXor(nums, i+1, cur^nums[i]);\\n    }\\n    return sumXor(nums, 0, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1720981,
                "title": "java-solution-using-loop-and-bits",
                "content": "```\\nclass Solution {\\n    public static int subsetXORSum(int[] nums) \\n    {\\n        \\n          int ans = 0;\\n          int pow = (int) Math.pow(2 , nums.length); //Calculate limit for outer loop, pow = 2n\\n\\n        \\n          for(int i=0; i<pow; i++) //Run Outer Loop from 0 to pow == limit .\\n          {\\n                 int temp = i;\\n                 int num  = 0;\\n              \\n              for(int j=nums.length-1; j>=0; j--) // Run Inner Loop from n-1 to 0 (n is length of array).\\n              {\\n                    if(temp % 2 == 1) //Check if the last bit is set or not (by checking if temp % 2 == 1 or not).\\n                    {\\n                        num ^= nums[j];\\n                    }\\n                    temp /= 2; //Divide temp by 2 to remove the rightmost bit.\\n              }\\n              ans += num;\\n          }\\n      return ans;\\n     }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int subsetXORSum(int[] nums) \\n    {\\n        \\n          int ans = 0;\\n          int pow = (int) Math.pow(2 , nums.length); //Calculate limit for outer loop, pow = 2n\\n\\n        \\n          for(int i=0; i<pow; i++) //Run Outer Loop from 0 to pow == limit .\\n          {\\n                 int temp = i;\\n                 int num  = 0;\\n              \\n              for(int j=nums.length-1; j>=0; j--) // Run Inner Loop from n-1 to 0 (n is length of array).\\n              {\\n                    if(temp % 2 == 1) //Check if the last bit is set or not (by checking if temp % 2 == 1 or not).\\n                    {\\n                        num ^= nums[j];\\n                    }\\n                    temp /= 2; //Divide temp by 2 to remove the rightmost bit.\\n              }\\n              ans += num;\\n          }\\n      return ans;\\n     }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1713162,
                "title": "c-solution-using-bit-masking",
                "content": "```\\nclass Solution {\\npublic:\\n    int subsetXORSum(vector<int>& nums) \\n    {\\n        int n=nums.size(), ans=0;\\n        int bitmask=pow(2, n);\\n        for(int i=0; i<bitmask; ++i){\\n            int xor_temp=0;\\n            for(int j=0; j<12; ++j){\\n                if(i&(1<<j)) {\\n                    xor_temp^=nums[j];\\n                }\\n            }\\n            ans+=xor_temp;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int subsetXORSum(vector<int>& nums) \\n    {\\n        int n=nums.size(), ans=0;\\n        int bitmask=pow(2, n);\\n        for(int i=0; i<bitmask; ++i){\\n            int xor_temp=0;\\n            for(int j=0; j<12; ++j){\\n                if(i&(1<<j)) {\\n                    xor_temp^=nums[j];\\n                }\\n            }\\n            ans+=xor_temp;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1707343,
                "title": "backtracking-explanation-and-recursion-c-beginner-friendly",
                "content": "1.First we make a function which does all our calculations using recursion and backtracking. The original array is passes as reference to avoid making copies. Other variables passes are the xor values of each subset(initialised to zero) and the current index of element.\\n2. Now we have two choices for each element for making subset i.e to include the element or not include the element. if we donot invlude the current element we call the function(gen) by upgrading the  index. If we include the element, then we calculate the xor of that element and pass the updated value of xor in the next call alongwith upgrading index. since we already took the element and xored it, we need to de-xor it by xor-ing once more(x^x=0) -----here we are using backtracking. De-xoring to avoid passing the current xor-ed value in next call.\\n3. Base case here is when we reach the end element of nums. Here we take the xored sum and return.\\n\\n```\\nclass Solution {\\npublic:\\n    int sum=0;\\n    void gen(int v,int i, vector<int>&nums)\\n    {\\n        //base case\\n        if(i==nums.size())\\n        {\\n            sum+=v;\\n            return;\\n        }\\n        //donot include\\n        gen(v,i+1,nums);\\n        //include\\n        v^=nums[i];\\n        gen(v,i+1,nums);\\n        v^=nums[i];\\n        \\n        \\n    }\\n    int subsetXORSum(vector<int>& nums) {\\n        gen(0,0,nums);\\n        return sum;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    int sum=0;\\n    void gen(int v,int i, vector<int>&nums)\\n    {\\n        //base case\\n        if(i==nums.size())\\n        {\\n            sum+=v;\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1699919,
                "title": "ruby-one-liner-rust-one-liner",
                "content": "```\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef subset_xor_sum(nums)\\n  nums.reduce(:|) << (nums.size - 1)\\nend\\n```\\n\\n```\\nuse std::ops::BitOr;\\n\\nimpl Solution {\\n    pub fn subset_xor_sum(nums: Vec<i32>) -> i32 {\\n        nums.iter().fold(0, i32::bitor) << (nums.len() - 1)        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef subset_xor_sum(nums)\\n  nums.reduce(:|) << (nums.size - 1)\\nend\\n```\n```\\nuse std::ops::BitOr;\\n\\nimpl Solution {\\n    pub fn subset_xor_sum(nums: Vec<i32>) -> i32 {\\n        nums.iter().fold(0, i32::bitor) << (nums.len() - 1)        \\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1689478,
                "title": "simple-approach-with-recursive-tree-explained",
                "content": "![image](https://assets.leetcode.com/users/images/992b16bd-93e0-471c-8e3d-fea0a10892d9_1642159219.3357265.jpeg)\\n\\nNOTE: 5 in firstnode of recursive tree is (element at index 0), it should be index i.e.0, by mistake i have taken the element at index 0, rather than taking index 0.\\n\\n```\\nclass Solution {\\npublic:\\n    int subsetXORSum(vector<int>& nums) {\\n        int ans=0;\\n        findsum(0,0,nums,ans);\\n        return ans;\\n    }\\n    \\n void findsum(int current,int temp,vector<int>& nums,int& ans)\\n {\\n     if(current>=nums.size())\\n     {  ans+=temp;\\n       return;\\n     }\\n      findsum(current+1,temp,nums,ans);    \\n      temp^=nums[current];\\n     findsum(current+1,temp,nums,ans);\\n     return;\\n }\\n    \\n}\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subsetXORSum(vector<int>& nums) {\\n        int ans=0;\\n        findsum(0,0,nums,ans);\\n        return ans;\\n    }\\n    \\n void findsum(int current,int temp,vector<int>& nums,int& ans)\\n {\\n     if(current>=nums.size())\\n     {  ans+=temp;\\n       return;\\n     }\\n      findsum(current+1,temp,nums,ans);    \\n      temp^=nums[current];\\n     findsum(current+1,temp,nums,ans);\\n     return;\\n }\\n    \\n}\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1721344,
                "content": [
                    {
                        "username": "IamUday",
                        "content": "Is this really an Easy level Question ?"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "[@Gurugubelli_Anil](/Gurugubelli_Anil) sure, changing from one challenging approach to even more challenging"
                    },
                    {
                        "username": "Gurugubelli_Anil",
                        "content": "yes, by changing the approach of solving"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "It requires strong foundation of recursion and backtracking. This is definitely not a easy problem:|"
                    },
                    {
                        "username": "klaca",
                        "content": "if you know math, it's super easy, you don't need any algorithmic knowledge, except  loops.\n\nOn the other hand, upper limit for length of input array being 12 makes it possible to brute force without timeout. THAT is easy without math, too."
                    },
                    {
                        "username": "FirozMars",
                        "content": "why this is in easy section?\natleast medium "
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "Holy crap....this is definitely not an easy question........if i don\\'t want to hire someone I would ask them this question and will tell them that you can\\'t even do an easy leetcode question what did you do in ICPC "
                    },
                    {
                        "username": "sherlockieee",
                        "content": "> The XOR total of an array is defined as the bitwise XOR of all its elements, or 0 if the array is empty.  For example, XOR total of the array [2,5,6] is 2 XOR 5 XOR 6 = 1\\n\\n\\nI don\\'t understand this statement. Can someone explain to me the XOR concept or point to me resources that do?"
                    },
                    {
                        "username": "viishhnu",
                        "content": "wow! can say how u have figured this\\n"
                    },
                    {
                        "username": "BahaDew",
                        "content": "Written in these programming languages => 2 ^ 5 ^ 6\\nXOR  =  ^"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "basic XOR means the numbers are xor ed if(both the bits are different then 1 is placed and 0 if both are same  (in the bits format like 3 is 011)) and 3^4^5 is basically same as (3^4) ^5 . \\nhope this helps :) "
                    },
                    {
                        "username": "stephan_plakunov",
                        "content": "I got it after this explanation: https://stackoverflow.com/questions/14526584/what-does-the-xor-operator-do#:~:text=XOR%20is%20a%20binary%20operation,of%20the%20bits%20is%20set.&text=This%20operation%20is%20performed%20between%20every%20two%20corresponding%20bits%20of%20a%20number.&text=Properties%3A%20The%20operation%20is%20commutative%2C%20associative%20and%20self%2Dinverse."
                    },
                    {
                        "username": "adityakiran",
                        "content": "It is the same as 2 ^ (5 ^ 6) or (2 ^ 5) ^ 6. Hope this helps"
                    },
                    {
                        "username": "Gurugubelli_Anil",
                        "content": "bitwise XOR for subsets of array can be solved by   performing bitwise OR for every element and  final answer multiply by 2**len(nums)-1"
                    },
                    {
                        "username": "1rosehip",
                        "content": "Could you explain why this solution works?"
                    },
                    {
                        "username": "z3eg",
                        "content": "Note: Subsets with the same elements should be counted multiple times.\\n\\nyet in the very first example they count only 1,3 and not 3,1"
                    },
                    {
                        "username": "anujeet98",
                        "content": "3,1 is not a subset. you are altering the order of numbers"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "More and more often I started noticing the solutions like \\n\\n```\\ntestNumber = 0;\\nvar fakeSolution = function(params) {\\n  return [15, 1432, 5234, ... ][testNumber++];  \\n};\\n```\\n\\nFirst of all, what is the point to submit this kind of solutions? In the end, as I understand, this platform is about studying and self improvement, by \"faking\" solution people just fool themselves \\uD83E\\uDD37\\u200D\\u2642\\uFE0F\\nSecondly, it is just so easy to avoid this kind of solutions by creating randomised tests, this is quite weird to me that platforms like this do not have this approach as a requirement \\uD83D\\uDE15"
                    },
                    {
                        "username": "klaca",
                        "content": "My line of thought, spoilers ahead:\n\nEvery number is an element in half of the subsets. Thus, every bit of every element will be xor'ed in half of the subsets. Based on this, it can be shown that every bit that occurs in any of the numbers will be xor'ed odd times in half of the subsets, and even times in the other half of the subsets, because being in the subset or not is a symmetric attribute for every element. Xor-ing something even times is zero, xor-ing something odd times results in itself.\nNow you only need to find the bits that occur at least once in the array and multiply the sum of their value by half of the number of possible subsets."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "How to know whether the problem can be memoized or not ?\\n\\nfor every index the answer varies with previous considered element so we can fix certain value at every index for granted so there is no memo\\nis it true??\\n\\nhow to identify the sub problems?"
                    }
                ]
            },
            {
                "id": 1730860,
                "content": [
                    {
                        "username": "IamUday",
                        "content": "Is this really an Easy level Question ?"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "[@Gurugubelli_Anil](/Gurugubelli_Anil) sure, changing from one challenging approach to even more challenging"
                    },
                    {
                        "username": "Gurugubelli_Anil",
                        "content": "yes, by changing the approach of solving"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "It requires strong foundation of recursion and backtracking. This is definitely not a easy problem:|"
                    },
                    {
                        "username": "klaca",
                        "content": "if you know math, it's super easy, you don't need any algorithmic knowledge, except  loops.\n\nOn the other hand, upper limit for length of input array being 12 makes it possible to brute force without timeout. THAT is easy without math, too."
                    },
                    {
                        "username": "FirozMars",
                        "content": "why this is in easy section?\natleast medium "
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "Holy crap....this is definitely not an easy question........if i don\\'t want to hire someone I would ask them this question and will tell them that you can\\'t even do an easy leetcode question what did you do in ICPC "
                    },
                    {
                        "username": "sherlockieee",
                        "content": "> The XOR total of an array is defined as the bitwise XOR of all its elements, or 0 if the array is empty.  For example, XOR total of the array [2,5,6] is 2 XOR 5 XOR 6 = 1\\n\\n\\nI don\\'t understand this statement. Can someone explain to me the XOR concept or point to me resources that do?"
                    },
                    {
                        "username": "viishhnu",
                        "content": "wow! can say how u have figured this\\n"
                    },
                    {
                        "username": "BahaDew",
                        "content": "Written in these programming languages => 2 ^ 5 ^ 6\\nXOR  =  ^"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "basic XOR means the numbers are xor ed if(both the bits are different then 1 is placed and 0 if both are same  (in the bits format like 3 is 011)) and 3^4^5 is basically same as (3^4) ^5 . \\nhope this helps :) "
                    },
                    {
                        "username": "stephan_plakunov",
                        "content": "I got it after this explanation: https://stackoverflow.com/questions/14526584/what-does-the-xor-operator-do#:~:text=XOR%20is%20a%20binary%20operation,of%20the%20bits%20is%20set.&text=This%20operation%20is%20performed%20between%20every%20two%20corresponding%20bits%20of%20a%20number.&text=Properties%3A%20The%20operation%20is%20commutative%2C%20associative%20and%20self%2Dinverse."
                    },
                    {
                        "username": "adityakiran",
                        "content": "It is the same as 2 ^ (5 ^ 6) or (2 ^ 5) ^ 6. Hope this helps"
                    },
                    {
                        "username": "Gurugubelli_Anil",
                        "content": "bitwise XOR for subsets of array can be solved by   performing bitwise OR for every element and  final answer multiply by 2**len(nums)-1"
                    },
                    {
                        "username": "1rosehip",
                        "content": "Could you explain why this solution works?"
                    },
                    {
                        "username": "z3eg",
                        "content": "Note: Subsets with the same elements should be counted multiple times.\\n\\nyet in the very first example they count only 1,3 and not 3,1"
                    },
                    {
                        "username": "anujeet98",
                        "content": "3,1 is not a subset. you are altering the order of numbers"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "More and more often I started noticing the solutions like \\n\\n```\\ntestNumber = 0;\\nvar fakeSolution = function(params) {\\n  return [15, 1432, 5234, ... ][testNumber++];  \\n};\\n```\\n\\nFirst of all, what is the point to submit this kind of solutions? In the end, as I understand, this platform is about studying and self improvement, by \"faking\" solution people just fool themselves \\uD83E\\uDD37\\u200D\\u2642\\uFE0F\\nSecondly, it is just so easy to avoid this kind of solutions by creating randomised tests, this is quite weird to me that platforms like this do not have this approach as a requirement \\uD83D\\uDE15"
                    },
                    {
                        "username": "klaca",
                        "content": "My line of thought, spoilers ahead:\n\nEvery number is an element in half of the subsets. Thus, every bit of every element will be xor'ed in half of the subsets. Based on this, it can be shown that every bit that occurs in any of the numbers will be xor'ed odd times in half of the subsets, and even times in the other half of the subsets, because being in the subset or not is a symmetric attribute for every element. Xor-ing something even times is zero, xor-ing something odd times results in itself.\nNow you only need to find the bits that occur at least once in the array and multiply the sum of their value by half of the number of possible subsets."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "How to know whether the problem can be memoized or not ?\\n\\nfor every index the answer varies with previous considered element so we can fix certain value at every index for granted so there is no memo\\nis it true??\\n\\nhow to identify the sub problems?"
                    }
                ]
            },
            {
                "id": 1729867,
                "content": [
                    {
                        "username": "IamUday",
                        "content": "Is this really an Easy level Question ?"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "[@Gurugubelli_Anil](/Gurugubelli_Anil) sure, changing from one challenging approach to even more challenging"
                    },
                    {
                        "username": "Gurugubelli_Anil",
                        "content": "yes, by changing the approach of solving"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "It requires strong foundation of recursion and backtracking. This is definitely not a easy problem:|"
                    },
                    {
                        "username": "klaca",
                        "content": "if you know math, it's super easy, you don't need any algorithmic knowledge, except  loops.\n\nOn the other hand, upper limit for length of input array being 12 makes it possible to brute force without timeout. THAT is easy without math, too."
                    },
                    {
                        "username": "FirozMars",
                        "content": "why this is in easy section?\natleast medium "
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "Holy crap....this is definitely not an easy question........if i don\\'t want to hire someone I would ask them this question and will tell them that you can\\'t even do an easy leetcode question what did you do in ICPC "
                    },
                    {
                        "username": "sherlockieee",
                        "content": "> The XOR total of an array is defined as the bitwise XOR of all its elements, or 0 if the array is empty.  For example, XOR total of the array [2,5,6] is 2 XOR 5 XOR 6 = 1\\n\\n\\nI don\\'t understand this statement. Can someone explain to me the XOR concept or point to me resources that do?"
                    },
                    {
                        "username": "viishhnu",
                        "content": "wow! can say how u have figured this\\n"
                    },
                    {
                        "username": "BahaDew",
                        "content": "Written in these programming languages => 2 ^ 5 ^ 6\\nXOR  =  ^"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "basic XOR means the numbers are xor ed if(both the bits are different then 1 is placed and 0 if both are same  (in the bits format like 3 is 011)) and 3^4^5 is basically same as (3^4) ^5 . \\nhope this helps :) "
                    },
                    {
                        "username": "stephan_plakunov",
                        "content": "I got it after this explanation: https://stackoverflow.com/questions/14526584/what-does-the-xor-operator-do#:~:text=XOR%20is%20a%20binary%20operation,of%20the%20bits%20is%20set.&text=This%20operation%20is%20performed%20between%20every%20two%20corresponding%20bits%20of%20a%20number.&text=Properties%3A%20The%20operation%20is%20commutative%2C%20associative%20and%20self%2Dinverse."
                    },
                    {
                        "username": "adityakiran",
                        "content": "It is the same as 2 ^ (5 ^ 6) or (2 ^ 5) ^ 6. Hope this helps"
                    },
                    {
                        "username": "Gurugubelli_Anil",
                        "content": "bitwise XOR for subsets of array can be solved by   performing bitwise OR for every element and  final answer multiply by 2**len(nums)-1"
                    },
                    {
                        "username": "1rosehip",
                        "content": "Could you explain why this solution works?"
                    },
                    {
                        "username": "z3eg",
                        "content": "Note: Subsets with the same elements should be counted multiple times.\\n\\nyet in the very first example they count only 1,3 and not 3,1"
                    },
                    {
                        "username": "anujeet98",
                        "content": "3,1 is not a subset. you are altering the order of numbers"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "More and more often I started noticing the solutions like \\n\\n```\\ntestNumber = 0;\\nvar fakeSolution = function(params) {\\n  return [15, 1432, 5234, ... ][testNumber++];  \\n};\\n```\\n\\nFirst of all, what is the point to submit this kind of solutions? In the end, as I understand, this platform is about studying and self improvement, by \"faking\" solution people just fool themselves \\uD83E\\uDD37\\u200D\\u2642\\uFE0F\\nSecondly, it is just so easy to avoid this kind of solutions by creating randomised tests, this is quite weird to me that platforms like this do not have this approach as a requirement \\uD83D\\uDE15"
                    },
                    {
                        "username": "klaca",
                        "content": "My line of thought, spoilers ahead:\n\nEvery number is an element in half of the subsets. Thus, every bit of every element will be xor'ed in half of the subsets. Based on this, it can be shown that every bit that occurs in any of the numbers will be xor'ed odd times in half of the subsets, and even times in the other half of the subsets, because being in the subset or not is a symmetric attribute for every element. Xor-ing something even times is zero, xor-ing something odd times results in itself.\nNow you only need to find the bits that occur at least once in the array and multiply the sum of their value by half of the number of possible subsets."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "How to know whether the problem can be memoized or not ?\\n\\nfor every index the answer varies with previous considered element so we can fix certain value at every index for granted so there is no memo\\nis it true??\\n\\nhow to identify the sub problems?"
                    }
                ]
            },
            {
                "id": 1898472,
                "content": [
                    {
                        "username": "IamUday",
                        "content": "Is this really an Easy level Question ?"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "[@Gurugubelli_Anil](/Gurugubelli_Anil) sure, changing from one challenging approach to even more challenging"
                    },
                    {
                        "username": "Gurugubelli_Anil",
                        "content": "yes, by changing the approach of solving"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "It requires strong foundation of recursion and backtracking. This is definitely not a easy problem:|"
                    },
                    {
                        "username": "klaca",
                        "content": "if you know math, it's super easy, you don't need any algorithmic knowledge, except  loops.\n\nOn the other hand, upper limit for length of input array being 12 makes it possible to brute force without timeout. THAT is easy without math, too."
                    },
                    {
                        "username": "FirozMars",
                        "content": "why this is in easy section?\natleast medium "
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "Holy crap....this is definitely not an easy question........if i don\\'t want to hire someone I would ask them this question and will tell them that you can\\'t even do an easy leetcode question what did you do in ICPC "
                    },
                    {
                        "username": "sherlockieee",
                        "content": "> The XOR total of an array is defined as the bitwise XOR of all its elements, or 0 if the array is empty.  For example, XOR total of the array [2,5,6] is 2 XOR 5 XOR 6 = 1\\n\\n\\nI don\\'t understand this statement. Can someone explain to me the XOR concept or point to me resources that do?"
                    },
                    {
                        "username": "viishhnu",
                        "content": "wow! can say how u have figured this\\n"
                    },
                    {
                        "username": "BahaDew",
                        "content": "Written in these programming languages => 2 ^ 5 ^ 6\\nXOR  =  ^"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "basic XOR means the numbers are xor ed if(both the bits are different then 1 is placed and 0 if both are same  (in the bits format like 3 is 011)) and 3^4^5 is basically same as (3^4) ^5 . \\nhope this helps :) "
                    },
                    {
                        "username": "stephan_plakunov",
                        "content": "I got it after this explanation: https://stackoverflow.com/questions/14526584/what-does-the-xor-operator-do#:~:text=XOR%20is%20a%20binary%20operation,of%20the%20bits%20is%20set.&text=This%20operation%20is%20performed%20between%20every%20two%20corresponding%20bits%20of%20a%20number.&text=Properties%3A%20The%20operation%20is%20commutative%2C%20associative%20and%20self%2Dinverse."
                    },
                    {
                        "username": "adityakiran",
                        "content": "It is the same as 2 ^ (5 ^ 6) or (2 ^ 5) ^ 6. Hope this helps"
                    },
                    {
                        "username": "Gurugubelli_Anil",
                        "content": "bitwise XOR for subsets of array can be solved by   performing bitwise OR for every element and  final answer multiply by 2**len(nums)-1"
                    },
                    {
                        "username": "1rosehip",
                        "content": "Could you explain why this solution works?"
                    },
                    {
                        "username": "z3eg",
                        "content": "Note: Subsets with the same elements should be counted multiple times.\\n\\nyet in the very first example they count only 1,3 and not 3,1"
                    },
                    {
                        "username": "anujeet98",
                        "content": "3,1 is not a subset. you are altering the order of numbers"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "More and more often I started noticing the solutions like \\n\\n```\\ntestNumber = 0;\\nvar fakeSolution = function(params) {\\n  return [15, 1432, 5234, ... ][testNumber++];  \\n};\\n```\\n\\nFirst of all, what is the point to submit this kind of solutions? In the end, as I understand, this platform is about studying and self improvement, by \"faking\" solution people just fool themselves \\uD83E\\uDD37\\u200D\\u2642\\uFE0F\\nSecondly, it is just so easy to avoid this kind of solutions by creating randomised tests, this is quite weird to me that platforms like this do not have this approach as a requirement \\uD83D\\uDE15"
                    },
                    {
                        "username": "klaca",
                        "content": "My line of thought, spoilers ahead:\n\nEvery number is an element in half of the subsets. Thus, every bit of every element will be xor'ed in half of the subsets. Based on this, it can be shown that every bit that occurs in any of the numbers will be xor'ed odd times in half of the subsets, and even times in the other half of the subsets, because being in the subset or not is a symmetric attribute for every element. Xor-ing something even times is zero, xor-ing something odd times results in itself.\nNow you only need to find the bits that occur at least once in the array and multiply the sum of their value by half of the number of possible subsets."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "How to know whether the problem can be memoized or not ?\\n\\nfor every index the answer varies with previous considered element so we can fix certain value at every index for granted so there is no memo\\nis it true??\\n\\nhow to identify the sub problems?"
                    }
                ]
            },
            {
                "id": 1575300,
                "content": [
                    {
                        "username": "IamUday",
                        "content": "Is this really an Easy level Question ?"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "[@Gurugubelli_Anil](/Gurugubelli_Anil) sure, changing from one challenging approach to even more challenging"
                    },
                    {
                        "username": "Gurugubelli_Anil",
                        "content": "yes, by changing the approach of solving"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "It requires strong foundation of recursion and backtracking. This is definitely not a easy problem:|"
                    },
                    {
                        "username": "klaca",
                        "content": "if you know math, it's super easy, you don't need any algorithmic knowledge, except  loops.\n\nOn the other hand, upper limit for length of input array being 12 makes it possible to brute force without timeout. THAT is easy without math, too."
                    },
                    {
                        "username": "FirozMars",
                        "content": "why this is in easy section?\natleast medium "
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "Holy crap....this is definitely not an easy question........if i don\\'t want to hire someone I would ask them this question and will tell them that you can\\'t even do an easy leetcode question what did you do in ICPC "
                    },
                    {
                        "username": "sherlockieee",
                        "content": "> The XOR total of an array is defined as the bitwise XOR of all its elements, or 0 if the array is empty.  For example, XOR total of the array [2,5,6] is 2 XOR 5 XOR 6 = 1\\n\\n\\nI don\\'t understand this statement. Can someone explain to me the XOR concept or point to me resources that do?"
                    },
                    {
                        "username": "viishhnu",
                        "content": "wow! can say how u have figured this\\n"
                    },
                    {
                        "username": "BahaDew",
                        "content": "Written in these programming languages => 2 ^ 5 ^ 6\\nXOR  =  ^"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "basic XOR means the numbers are xor ed if(both the bits are different then 1 is placed and 0 if both are same  (in the bits format like 3 is 011)) and 3^4^5 is basically same as (3^4) ^5 . \\nhope this helps :) "
                    },
                    {
                        "username": "stephan_plakunov",
                        "content": "I got it after this explanation: https://stackoverflow.com/questions/14526584/what-does-the-xor-operator-do#:~:text=XOR%20is%20a%20binary%20operation,of%20the%20bits%20is%20set.&text=This%20operation%20is%20performed%20between%20every%20two%20corresponding%20bits%20of%20a%20number.&text=Properties%3A%20The%20operation%20is%20commutative%2C%20associative%20and%20self%2Dinverse."
                    },
                    {
                        "username": "adityakiran",
                        "content": "It is the same as 2 ^ (5 ^ 6) or (2 ^ 5) ^ 6. Hope this helps"
                    },
                    {
                        "username": "Gurugubelli_Anil",
                        "content": "bitwise XOR for subsets of array can be solved by   performing bitwise OR for every element and  final answer multiply by 2**len(nums)-1"
                    },
                    {
                        "username": "1rosehip",
                        "content": "Could you explain why this solution works?"
                    },
                    {
                        "username": "z3eg",
                        "content": "Note: Subsets with the same elements should be counted multiple times.\\n\\nyet in the very first example they count only 1,3 and not 3,1"
                    },
                    {
                        "username": "anujeet98",
                        "content": "3,1 is not a subset. you are altering the order of numbers"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "More and more often I started noticing the solutions like \\n\\n```\\ntestNumber = 0;\\nvar fakeSolution = function(params) {\\n  return [15, 1432, 5234, ... ][testNumber++];  \\n};\\n```\\n\\nFirst of all, what is the point to submit this kind of solutions? In the end, as I understand, this platform is about studying and self improvement, by \"faking\" solution people just fool themselves \\uD83E\\uDD37\\u200D\\u2642\\uFE0F\\nSecondly, it is just so easy to avoid this kind of solutions by creating randomised tests, this is quite weird to me that platforms like this do not have this approach as a requirement \\uD83D\\uDE15"
                    },
                    {
                        "username": "klaca",
                        "content": "My line of thought, spoilers ahead:\n\nEvery number is an element in half of the subsets. Thus, every bit of every element will be xor'ed in half of the subsets. Based on this, it can be shown that every bit that occurs in any of the numbers will be xor'ed odd times in half of the subsets, and even times in the other half of the subsets, because being in the subset or not is a symmetric attribute for every element. Xor-ing something even times is zero, xor-ing something odd times results in itself.\nNow you only need to find the bits that occur at least once in the array and multiply the sum of their value by half of the number of possible subsets."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "How to know whether the problem can be memoized or not ?\\n\\nfor every index the answer varies with previous considered element so we can fix certain value at every index for granted so there is no memo\\nis it true??\\n\\nhow to identify the sub problems?"
                    }
                ]
            },
            {
                "id": 1851758,
                "content": [
                    {
                        "username": "IamUday",
                        "content": "Is this really an Easy level Question ?"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "[@Gurugubelli_Anil](/Gurugubelli_Anil) sure, changing from one challenging approach to even more challenging"
                    },
                    {
                        "username": "Gurugubelli_Anil",
                        "content": "yes, by changing the approach of solving"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "It requires strong foundation of recursion and backtracking. This is definitely not a easy problem:|"
                    },
                    {
                        "username": "klaca",
                        "content": "if you know math, it's super easy, you don't need any algorithmic knowledge, except  loops.\n\nOn the other hand, upper limit for length of input array being 12 makes it possible to brute force without timeout. THAT is easy without math, too."
                    },
                    {
                        "username": "FirozMars",
                        "content": "why this is in easy section?\natleast medium "
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "Holy crap....this is definitely not an easy question........if i don\\'t want to hire someone I would ask them this question and will tell them that you can\\'t even do an easy leetcode question what did you do in ICPC "
                    },
                    {
                        "username": "sherlockieee",
                        "content": "> The XOR total of an array is defined as the bitwise XOR of all its elements, or 0 if the array is empty.  For example, XOR total of the array [2,5,6] is 2 XOR 5 XOR 6 = 1\\n\\n\\nI don\\'t understand this statement. Can someone explain to me the XOR concept or point to me resources that do?"
                    },
                    {
                        "username": "viishhnu",
                        "content": "wow! can say how u have figured this\\n"
                    },
                    {
                        "username": "BahaDew",
                        "content": "Written in these programming languages => 2 ^ 5 ^ 6\\nXOR  =  ^"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "basic XOR means the numbers are xor ed if(both the bits are different then 1 is placed and 0 if both are same  (in the bits format like 3 is 011)) and 3^4^5 is basically same as (3^4) ^5 . \\nhope this helps :) "
                    },
                    {
                        "username": "stephan_plakunov",
                        "content": "I got it after this explanation: https://stackoverflow.com/questions/14526584/what-does-the-xor-operator-do#:~:text=XOR%20is%20a%20binary%20operation,of%20the%20bits%20is%20set.&text=This%20operation%20is%20performed%20between%20every%20two%20corresponding%20bits%20of%20a%20number.&text=Properties%3A%20The%20operation%20is%20commutative%2C%20associative%20and%20self%2Dinverse."
                    },
                    {
                        "username": "adityakiran",
                        "content": "It is the same as 2 ^ (5 ^ 6) or (2 ^ 5) ^ 6. Hope this helps"
                    },
                    {
                        "username": "Gurugubelli_Anil",
                        "content": "bitwise XOR for subsets of array can be solved by   performing bitwise OR for every element and  final answer multiply by 2**len(nums)-1"
                    },
                    {
                        "username": "1rosehip",
                        "content": "Could you explain why this solution works?"
                    },
                    {
                        "username": "z3eg",
                        "content": "Note: Subsets with the same elements should be counted multiple times.\\n\\nyet in the very first example they count only 1,3 and not 3,1"
                    },
                    {
                        "username": "anujeet98",
                        "content": "3,1 is not a subset. you are altering the order of numbers"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "More and more often I started noticing the solutions like \\n\\n```\\ntestNumber = 0;\\nvar fakeSolution = function(params) {\\n  return [15, 1432, 5234, ... ][testNumber++];  \\n};\\n```\\n\\nFirst of all, what is the point to submit this kind of solutions? In the end, as I understand, this platform is about studying and self improvement, by \"faking\" solution people just fool themselves \\uD83E\\uDD37\\u200D\\u2642\\uFE0F\\nSecondly, it is just so easy to avoid this kind of solutions by creating randomised tests, this is quite weird to me that platforms like this do not have this approach as a requirement \\uD83D\\uDE15"
                    },
                    {
                        "username": "klaca",
                        "content": "My line of thought, spoilers ahead:\n\nEvery number is an element in half of the subsets. Thus, every bit of every element will be xor'ed in half of the subsets. Based on this, it can be shown that every bit that occurs in any of the numbers will be xor'ed odd times in half of the subsets, and even times in the other half of the subsets, because being in the subset or not is a symmetric attribute for every element. Xor-ing something even times is zero, xor-ing something odd times results in itself.\nNow you only need to find the bits that occur at least once in the array and multiply the sum of their value by half of the number of possible subsets."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "How to know whether the problem can be memoized or not ?\\n\\nfor every index the answer varies with previous considered element so we can fix certain value at every index for granted so there is no memo\\nis it true??\\n\\nhow to identify the sub problems?"
                    }
                ]
            },
            {
                "id": 1909120,
                "content": [
                    {
                        "username": "IamUday",
                        "content": "Is this really an Easy level Question ?"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "[@Gurugubelli_Anil](/Gurugubelli_Anil) sure, changing from one challenging approach to even more challenging"
                    },
                    {
                        "username": "Gurugubelli_Anil",
                        "content": "yes, by changing the approach of solving"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "It requires strong foundation of recursion and backtracking. This is definitely not a easy problem:|"
                    },
                    {
                        "username": "klaca",
                        "content": "if you know math, it's super easy, you don't need any algorithmic knowledge, except  loops.\n\nOn the other hand, upper limit for length of input array being 12 makes it possible to brute force without timeout. THAT is easy without math, too."
                    },
                    {
                        "username": "FirozMars",
                        "content": "why this is in easy section?\natleast medium "
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "Holy crap....this is definitely not an easy question........if i don\\'t want to hire someone I would ask them this question and will tell them that you can\\'t even do an easy leetcode question what did you do in ICPC "
                    },
                    {
                        "username": "sherlockieee",
                        "content": "> The XOR total of an array is defined as the bitwise XOR of all its elements, or 0 if the array is empty.  For example, XOR total of the array [2,5,6] is 2 XOR 5 XOR 6 = 1\\n\\n\\nI don\\'t understand this statement. Can someone explain to me the XOR concept or point to me resources that do?"
                    },
                    {
                        "username": "viishhnu",
                        "content": "wow! can say how u have figured this\\n"
                    },
                    {
                        "username": "BahaDew",
                        "content": "Written in these programming languages => 2 ^ 5 ^ 6\\nXOR  =  ^"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "basic XOR means the numbers are xor ed if(both the bits are different then 1 is placed and 0 if both are same  (in the bits format like 3 is 011)) and 3^4^5 is basically same as (3^4) ^5 . \\nhope this helps :) "
                    },
                    {
                        "username": "stephan_plakunov",
                        "content": "I got it after this explanation: https://stackoverflow.com/questions/14526584/what-does-the-xor-operator-do#:~:text=XOR%20is%20a%20binary%20operation,of%20the%20bits%20is%20set.&text=This%20operation%20is%20performed%20between%20every%20two%20corresponding%20bits%20of%20a%20number.&text=Properties%3A%20The%20operation%20is%20commutative%2C%20associative%20and%20self%2Dinverse."
                    },
                    {
                        "username": "adityakiran",
                        "content": "It is the same as 2 ^ (5 ^ 6) or (2 ^ 5) ^ 6. Hope this helps"
                    },
                    {
                        "username": "Gurugubelli_Anil",
                        "content": "bitwise XOR for subsets of array can be solved by   performing bitwise OR for every element and  final answer multiply by 2**len(nums)-1"
                    },
                    {
                        "username": "1rosehip",
                        "content": "Could you explain why this solution works?"
                    },
                    {
                        "username": "z3eg",
                        "content": "Note: Subsets with the same elements should be counted multiple times.\\n\\nyet in the very first example they count only 1,3 and not 3,1"
                    },
                    {
                        "username": "anujeet98",
                        "content": "3,1 is not a subset. you are altering the order of numbers"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "More and more often I started noticing the solutions like \\n\\n```\\ntestNumber = 0;\\nvar fakeSolution = function(params) {\\n  return [15, 1432, 5234, ... ][testNumber++];  \\n};\\n```\\n\\nFirst of all, what is the point to submit this kind of solutions? In the end, as I understand, this platform is about studying and self improvement, by \"faking\" solution people just fool themselves \\uD83E\\uDD37\\u200D\\u2642\\uFE0F\\nSecondly, it is just so easy to avoid this kind of solutions by creating randomised tests, this is quite weird to me that platforms like this do not have this approach as a requirement \\uD83D\\uDE15"
                    },
                    {
                        "username": "klaca",
                        "content": "My line of thought, spoilers ahead:\n\nEvery number is an element in half of the subsets. Thus, every bit of every element will be xor'ed in half of the subsets. Based on this, it can be shown that every bit that occurs in any of the numbers will be xor'ed odd times in half of the subsets, and even times in the other half of the subsets, because being in the subset or not is a symmetric attribute for every element. Xor-ing something even times is zero, xor-ing something odd times results in itself.\nNow you only need to find the bits that occur at least once in the array and multiply the sum of their value by half of the number of possible subsets."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "How to know whether the problem can be memoized or not ?\\n\\nfor every index the answer varies with previous considered element so we can fix certain value at every index for granted so there is no memo\\nis it true??\\n\\nhow to identify the sub problems?"
                    }
                ]
            },
            {
                "id": 1876038,
                "content": [
                    {
                        "username": "IamUday",
                        "content": "Is this really an Easy level Question ?"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "[@Gurugubelli_Anil](/Gurugubelli_Anil) sure, changing from one challenging approach to even more challenging"
                    },
                    {
                        "username": "Gurugubelli_Anil",
                        "content": "yes, by changing the approach of solving"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "It requires strong foundation of recursion and backtracking. This is definitely not a easy problem:|"
                    },
                    {
                        "username": "klaca",
                        "content": "if you know math, it's super easy, you don't need any algorithmic knowledge, except  loops.\n\nOn the other hand, upper limit for length of input array being 12 makes it possible to brute force without timeout. THAT is easy without math, too."
                    },
                    {
                        "username": "FirozMars",
                        "content": "why this is in easy section?\natleast medium "
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "Holy crap....this is definitely not an easy question........if i don\\'t want to hire someone I would ask them this question and will tell them that you can\\'t even do an easy leetcode question what did you do in ICPC "
                    },
                    {
                        "username": "sherlockieee",
                        "content": "> The XOR total of an array is defined as the bitwise XOR of all its elements, or 0 if the array is empty.  For example, XOR total of the array [2,5,6] is 2 XOR 5 XOR 6 = 1\\n\\n\\nI don\\'t understand this statement. Can someone explain to me the XOR concept or point to me resources that do?"
                    },
                    {
                        "username": "viishhnu",
                        "content": "wow! can say how u have figured this\\n"
                    },
                    {
                        "username": "BahaDew",
                        "content": "Written in these programming languages => 2 ^ 5 ^ 6\\nXOR  =  ^"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "basic XOR means the numbers are xor ed if(both the bits are different then 1 is placed and 0 if both are same  (in the bits format like 3 is 011)) and 3^4^5 is basically same as (3^4) ^5 . \\nhope this helps :) "
                    },
                    {
                        "username": "stephan_plakunov",
                        "content": "I got it after this explanation: https://stackoverflow.com/questions/14526584/what-does-the-xor-operator-do#:~:text=XOR%20is%20a%20binary%20operation,of%20the%20bits%20is%20set.&text=This%20operation%20is%20performed%20between%20every%20two%20corresponding%20bits%20of%20a%20number.&text=Properties%3A%20The%20operation%20is%20commutative%2C%20associative%20and%20self%2Dinverse."
                    },
                    {
                        "username": "adityakiran",
                        "content": "It is the same as 2 ^ (5 ^ 6) or (2 ^ 5) ^ 6. Hope this helps"
                    },
                    {
                        "username": "Gurugubelli_Anil",
                        "content": "bitwise XOR for subsets of array can be solved by   performing bitwise OR for every element and  final answer multiply by 2**len(nums)-1"
                    },
                    {
                        "username": "1rosehip",
                        "content": "Could you explain why this solution works?"
                    },
                    {
                        "username": "z3eg",
                        "content": "Note: Subsets with the same elements should be counted multiple times.\\n\\nyet in the very first example they count only 1,3 and not 3,1"
                    },
                    {
                        "username": "anujeet98",
                        "content": "3,1 is not a subset. you are altering the order of numbers"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "More and more often I started noticing the solutions like \\n\\n```\\ntestNumber = 0;\\nvar fakeSolution = function(params) {\\n  return [15, 1432, 5234, ... ][testNumber++];  \\n};\\n```\\n\\nFirst of all, what is the point to submit this kind of solutions? In the end, as I understand, this platform is about studying and self improvement, by \"faking\" solution people just fool themselves \\uD83E\\uDD37\\u200D\\u2642\\uFE0F\\nSecondly, it is just so easy to avoid this kind of solutions by creating randomised tests, this is quite weird to me that platforms like this do not have this approach as a requirement \\uD83D\\uDE15"
                    },
                    {
                        "username": "klaca",
                        "content": "My line of thought, spoilers ahead:\n\nEvery number is an element in half of the subsets. Thus, every bit of every element will be xor'ed in half of the subsets. Based on this, it can be shown that every bit that occurs in any of the numbers will be xor'ed odd times in half of the subsets, and even times in the other half of the subsets, because being in the subset or not is a symmetric attribute for every element. Xor-ing something even times is zero, xor-ing something odd times results in itself.\nNow you only need to find the bits that occur at least once in the array and multiply the sum of their value by half of the number of possible subsets."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "How to know whether the problem can be memoized or not ?\\n\\nfor every index the answer varies with previous considered element so we can fix certain value at every index for granted so there is no memo\\nis it true??\\n\\nhow to identify the sub problems?"
                    }
                ]
            },
            {
                "id": 1845298,
                "content": [
                    {
                        "username": "IamUday",
                        "content": "Is this really an Easy level Question ?"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "[@Gurugubelli_Anil](/Gurugubelli_Anil) sure, changing from one challenging approach to even more challenging"
                    },
                    {
                        "username": "Gurugubelli_Anil",
                        "content": "yes, by changing the approach of solving"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "It requires strong foundation of recursion and backtracking. This is definitely not a easy problem:|"
                    },
                    {
                        "username": "klaca",
                        "content": "if you know math, it's super easy, you don't need any algorithmic knowledge, except  loops.\n\nOn the other hand, upper limit for length of input array being 12 makes it possible to brute force without timeout. THAT is easy without math, too."
                    },
                    {
                        "username": "FirozMars",
                        "content": "why this is in easy section?\natleast medium "
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "Holy crap....this is definitely not an easy question........if i don\\'t want to hire someone I would ask them this question and will tell them that you can\\'t even do an easy leetcode question what did you do in ICPC "
                    },
                    {
                        "username": "sherlockieee",
                        "content": "> The XOR total of an array is defined as the bitwise XOR of all its elements, or 0 if the array is empty.  For example, XOR total of the array [2,5,6] is 2 XOR 5 XOR 6 = 1\\n\\n\\nI don\\'t understand this statement. Can someone explain to me the XOR concept or point to me resources that do?"
                    },
                    {
                        "username": "viishhnu",
                        "content": "wow! can say how u have figured this\\n"
                    },
                    {
                        "username": "BahaDew",
                        "content": "Written in these programming languages => 2 ^ 5 ^ 6\\nXOR  =  ^"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "basic XOR means the numbers are xor ed if(both the bits are different then 1 is placed and 0 if both are same  (in the bits format like 3 is 011)) and 3^4^5 is basically same as (3^4) ^5 . \\nhope this helps :) "
                    },
                    {
                        "username": "stephan_plakunov",
                        "content": "I got it after this explanation: https://stackoverflow.com/questions/14526584/what-does-the-xor-operator-do#:~:text=XOR%20is%20a%20binary%20operation,of%20the%20bits%20is%20set.&text=This%20operation%20is%20performed%20between%20every%20two%20corresponding%20bits%20of%20a%20number.&text=Properties%3A%20The%20operation%20is%20commutative%2C%20associative%20and%20self%2Dinverse."
                    },
                    {
                        "username": "adityakiran",
                        "content": "It is the same as 2 ^ (5 ^ 6) or (2 ^ 5) ^ 6. Hope this helps"
                    },
                    {
                        "username": "Gurugubelli_Anil",
                        "content": "bitwise XOR for subsets of array can be solved by   performing bitwise OR for every element and  final answer multiply by 2**len(nums)-1"
                    },
                    {
                        "username": "1rosehip",
                        "content": "Could you explain why this solution works?"
                    },
                    {
                        "username": "z3eg",
                        "content": "Note: Subsets with the same elements should be counted multiple times.\\n\\nyet in the very first example they count only 1,3 and not 3,1"
                    },
                    {
                        "username": "anujeet98",
                        "content": "3,1 is not a subset. you are altering the order of numbers"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "More and more often I started noticing the solutions like \\n\\n```\\ntestNumber = 0;\\nvar fakeSolution = function(params) {\\n  return [15, 1432, 5234, ... ][testNumber++];  \\n};\\n```\\n\\nFirst of all, what is the point to submit this kind of solutions? In the end, as I understand, this platform is about studying and self improvement, by \"faking\" solution people just fool themselves \\uD83E\\uDD37\\u200D\\u2642\\uFE0F\\nSecondly, it is just so easy to avoid this kind of solutions by creating randomised tests, this is quite weird to me that platforms like this do not have this approach as a requirement \\uD83D\\uDE15"
                    },
                    {
                        "username": "klaca",
                        "content": "My line of thought, spoilers ahead:\n\nEvery number is an element in half of the subsets. Thus, every bit of every element will be xor'ed in half of the subsets. Based on this, it can be shown that every bit that occurs in any of the numbers will be xor'ed odd times in half of the subsets, and even times in the other half of the subsets, because being in the subset or not is a symmetric attribute for every element. Xor-ing something even times is zero, xor-ing something odd times results in itself.\nNow you only need to find the bits that occur at least once in the array and multiply the sum of their value by half of the number of possible subsets."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "How to know whether the problem can be memoized or not ?\\n\\nfor every index the answer varies with previous considered element so we can fix certain value at every index for granted so there is no memo\\nis it true??\\n\\nhow to identify the sub problems?"
                    }
                ]
            },
            {
                "id": 2020345,
                "content": [
                    {
                        "username": "IamUday",
                        "content": "Is this really an Easy level Question ?"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "[@Gurugubelli_Anil](/Gurugubelli_Anil) sure, changing from one challenging approach to even more challenging"
                    },
                    {
                        "username": "Gurugubelli_Anil",
                        "content": "yes, by changing the approach of solving"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "It requires strong foundation of recursion and backtracking. This is definitely not a easy problem:|"
                    },
                    {
                        "username": "klaca",
                        "content": "if you know math, it's super easy, you don't need any algorithmic knowledge, except  loops.\n\nOn the other hand, upper limit for length of input array being 12 makes it possible to brute force without timeout. THAT is easy without math, too."
                    },
                    {
                        "username": "FirozMars",
                        "content": "why this is in easy section?\natleast medium "
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "Holy crap....this is definitely not an easy question........if i don\\'t want to hire someone I would ask them this question and will tell them that you can\\'t even do an easy leetcode question what did you do in ICPC "
                    },
                    {
                        "username": "sherlockieee",
                        "content": "> The XOR total of an array is defined as the bitwise XOR of all its elements, or 0 if the array is empty.  For example, XOR total of the array [2,5,6] is 2 XOR 5 XOR 6 = 1\\n\\n\\nI don\\'t understand this statement. Can someone explain to me the XOR concept or point to me resources that do?"
                    },
                    {
                        "username": "viishhnu",
                        "content": "wow! can say how u have figured this\\n"
                    },
                    {
                        "username": "BahaDew",
                        "content": "Written in these programming languages => 2 ^ 5 ^ 6\\nXOR  =  ^"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "basic XOR means the numbers are xor ed if(both the bits are different then 1 is placed and 0 if both are same  (in the bits format like 3 is 011)) and 3^4^5 is basically same as (3^4) ^5 . \\nhope this helps :) "
                    },
                    {
                        "username": "stephan_plakunov",
                        "content": "I got it after this explanation: https://stackoverflow.com/questions/14526584/what-does-the-xor-operator-do#:~:text=XOR%20is%20a%20binary%20operation,of%20the%20bits%20is%20set.&text=This%20operation%20is%20performed%20between%20every%20two%20corresponding%20bits%20of%20a%20number.&text=Properties%3A%20The%20operation%20is%20commutative%2C%20associative%20and%20self%2Dinverse."
                    },
                    {
                        "username": "adityakiran",
                        "content": "It is the same as 2 ^ (5 ^ 6) or (2 ^ 5) ^ 6. Hope this helps"
                    },
                    {
                        "username": "Gurugubelli_Anil",
                        "content": "bitwise XOR for subsets of array can be solved by   performing bitwise OR for every element and  final answer multiply by 2**len(nums)-1"
                    },
                    {
                        "username": "1rosehip",
                        "content": "Could you explain why this solution works?"
                    },
                    {
                        "username": "z3eg",
                        "content": "Note: Subsets with the same elements should be counted multiple times.\\n\\nyet in the very first example they count only 1,3 and not 3,1"
                    },
                    {
                        "username": "anujeet98",
                        "content": "3,1 is not a subset. you are altering the order of numbers"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "More and more often I started noticing the solutions like \\n\\n```\\ntestNumber = 0;\\nvar fakeSolution = function(params) {\\n  return [15, 1432, 5234, ... ][testNumber++];  \\n};\\n```\\n\\nFirst of all, what is the point to submit this kind of solutions? In the end, as I understand, this platform is about studying and self improvement, by \"faking\" solution people just fool themselves \\uD83E\\uDD37\\u200D\\u2642\\uFE0F\\nSecondly, it is just so easy to avoid this kind of solutions by creating randomised tests, this is quite weird to me that platforms like this do not have this approach as a requirement \\uD83D\\uDE15"
                    },
                    {
                        "username": "klaca",
                        "content": "My line of thought, spoilers ahead:\n\nEvery number is an element in half of the subsets. Thus, every bit of every element will be xor'ed in half of the subsets. Based on this, it can be shown that every bit that occurs in any of the numbers will be xor'ed odd times in half of the subsets, and even times in the other half of the subsets, because being in the subset or not is a symmetric attribute for every element. Xor-ing something even times is zero, xor-ing something odd times results in itself.\nNow you only need to find the bits that occur at least once in the array and multiply the sum of their value by half of the number of possible subsets."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "How to know whether the problem can be memoized or not ?\\n\\nfor every index the answer varies with previous considered element so we can fix certain value at every index for granted so there is no memo\\nis it true??\\n\\nhow to identify the sub problems?"
                    }
                ]
            },
            {
                "id": 1721344,
                "content": [
                    {
                        "username": "IamUday",
                        "content": "Is this really an Easy level Question ?"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "[@Gurugubelli_Anil](/Gurugubelli_Anil) sure, changing from one challenging approach to even more challenging"
                    },
                    {
                        "username": "Gurugubelli_Anil",
                        "content": "yes, by changing the approach of solving"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "It requires strong foundation of recursion and backtracking. This is definitely not a easy problem:|"
                    },
                    {
                        "username": "klaca",
                        "content": "if you know math, it's super easy, you don't need any algorithmic knowledge, except  loops.\n\nOn the other hand, upper limit for length of input array being 12 makes it possible to brute force without timeout. THAT is easy without math, too."
                    },
                    {
                        "username": "FirozMars",
                        "content": "why this is in easy section?\natleast medium "
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "Holy crap....this is definitely not an easy question........if i don\\'t want to hire someone I would ask them this question and will tell them that you can\\'t even do an easy leetcode question what did you do in ICPC "
                    },
                    {
                        "username": "sherlockieee",
                        "content": "> The XOR total of an array is defined as the bitwise XOR of all its elements, or 0 if the array is empty.  For example, XOR total of the array [2,5,6] is 2 XOR 5 XOR 6 = 1\\n\\n\\nI don\\'t understand this statement. Can someone explain to me the XOR concept or point to me resources that do?"
                    },
                    {
                        "username": "viishhnu",
                        "content": "wow! can say how u have figured this\\n"
                    },
                    {
                        "username": "BahaDew",
                        "content": "Written in these programming languages => 2 ^ 5 ^ 6\\nXOR  =  ^"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "basic XOR means the numbers are xor ed if(both the bits are different then 1 is placed and 0 if both are same  (in the bits format like 3 is 011)) and 3^4^5 is basically same as (3^4) ^5 . \\nhope this helps :) "
                    },
                    {
                        "username": "stephan_plakunov",
                        "content": "I got it after this explanation: https://stackoverflow.com/questions/14526584/what-does-the-xor-operator-do#:~:text=XOR%20is%20a%20binary%20operation,of%20the%20bits%20is%20set.&text=This%20operation%20is%20performed%20between%20every%20two%20corresponding%20bits%20of%20a%20number.&text=Properties%3A%20The%20operation%20is%20commutative%2C%20associative%20and%20self%2Dinverse."
                    },
                    {
                        "username": "adityakiran",
                        "content": "It is the same as 2 ^ (5 ^ 6) or (2 ^ 5) ^ 6. Hope this helps"
                    },
                    {
                        "username": "Gurugubelli_Anil",
                        "content": "bitwise XOR for subsets of array can be solved by   performing bitwise OR for every element and  final answer multiply by 2**len(nums)-1"
                    },
                    {
                        "username": "1rosehip",
                        "content": "Could you explain why this solution works?"
                    },
                    {
                        "username": "z3eg",
                        "content": "Note: Subsets with the same elements should be counted multiple times.\\n\\nyet in the very first example they count only 1,3 and not 3,1"
                    },
                    {
                        "username": "anujeet98",
                        "content": "3,1 is not a subset. you are altering the order of numbers"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "More and more often I started noticing the solutions like \\n\\n```\\ntestNumber = 0;\\nvar fakeSolution = function(params) {\\n  return [15, 1432, 5234, ... ][testNumber++];  \\n};\\n```\\n\\nFirst of all, what is the point to submit this kind of solutions? In the end, as I understand, this platform is about studying and self improvement, by \"faking\" solution people just fool themselves \\uD83E\\uDD37\\u200D\\u2642\\uFE0F\\nSecondly, it is just so easy to avoid this kind of solutions by creating randomised tests, this is quite weird to me that platforms like this do not have this approach as a requirement \\uD83D\\uDE15"
                    },
                    {
                        "username": "klaca",
                        "content": "My line of thought, spoilers ahead:\n\nEvery number is an element in half of the subsets. Thus, every bit of every element will be xor'ed in half of the subsets. Based on this, it can be shown that every bit that occurs in any of the numbers will be xor'ed odd times in half of the subsets, and even times in the other half of the subsets, because being in the subset or not is a symmetric attribute for every element. Xor-ing something even times is zero, xor-ing something odd times results in itself.\nNow you only need to find the bits that occur at least once in the array and multiply the sum of their value by half of the number of possible subsets."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "How to know whether the problem can be memoized or not ?\\n\\nfor every index the answer varies with previous considered element so we can fix certain value at every index for granted so there is no memo\\nis it true??\\n\\nhow to identify the sub problems?"
                    }
                ]
            },
            {
                "id": 1730860,
                "content": [
                    {
                        "username": "IamUday",
                        "content": "Is this really an Easy level Question ?"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "[@Gurugubelli_Anil](/Gurugubelli_Anil) sure, changing from one challenging approach to even more challenging"
                    },
                    {
                        "username": "Gurugubelli_Anil",
                        "content": "yes, by changing the approach of solving"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "It requires strong foundation of recursion and backtracking. This is definitely not a easy problem:|"
                    },
                    {
                        "username": "klaca",
                        "content": "if you know math, it's super easy, you don't need any algorithmic knowledge, except  loops.\n\nOn the other hand, upper limit for length of input array being 12 makes it possible to brute force without timeout. THAT is easy without math, too."
                    },
                    {
                        "username": "FirozMars",
                        "content": "why this is in easy section?\natleast medium "
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "Holy crap....this is definitely not an easy question........if i don\\'t want to hire someone I would ask them this question and will tell them that you can\\'t even do an easy leetcode question what did you do in ICPC "
                    },
                    {
                        "username": "sherlockieee",
                        "content": "> The XOR total of an array is defined as the bitwise XOR of all its elements, or 0 if the array is empty.  For example, XOR total of the array [2,5,6] is 2 XOR 5 XOR 6 = 1\\n\\n\\nI don\\'t understand this statement. Can someone explain to me the XOR concept or point to me resources that do?"
                    },
                    {
                        "username": "viishhnu",
                        "content": "wow! can say how u have figured this\\n"
                    },
                    {
                        "username": "BahaDew",
                        "content": "Written in these programming languages => 2 ^ 5 ^ 6\\nXOR  =  ^"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "basic XOR means the numbers are xor ed if(both the bits are different then 1 is placed and 0 if both are same  (in the bits format like 3 is 011)) and 3^4^5 is basically same as (3^4) ^5 . \\nhope this helps :) "
                    },
                    {
                        "username": "stephan_plakunov",
                        "content": "I got it after this explanation: https://stackoverflow.com/questions/14526584/what-does-the-xor-operator-do#:~:text=XOR%20is%20a%20binary%20operation,of%20the%20bits%20is%20set.&text=This%20operation%20is%20performed%20between%20every%20two%20corresponding%20bits%20of%20a%20number.&text=Properties%3A%20The%20operation%20is%20commutative%2C%20associative%20and%20self%2Dinverse."
                    },
                    {
                        "username": "adityakiran",
                        "content": "It is the same as 2 ^ (5 ^ 6) or (2 ^ 5) ^ 6. Hope this helps"
                    },
                    {
                        "username": "Gurugubelli_Anil",
                        "content": "bitwise XOR for subsets of array can be solved by   performing bitwise OR for every element and  final answer multiply by 2**len(nums)-1"
                    },
                    {
                        "username": "1rosehip",
                        "content": "Could you explain why this solution works?"
                    },
                    {
                        "username": "z3eg",
                        "content": "Note: Subsets with the same elements should be counted multiple times.\\n\\nyet in the very first example they count only 1,3 and not 3,1"
                    },
                    {
                        "username": "anujeet98",
                        "content": "3,1 is not a subset. you are altering the order of numbers"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "More and more often I started noticing the solutions like \\n\\n```\\ntestNumber = 0;\\nvar fakeSolution = function(params) {\\n  return [15, 1432, 5234, ... ][testNumber++];  \\n};\\n```\\n\\nFirst of all, what is the point to submit this kind of solutions? In the end, as I understand, this platform is about studying and self improvement, by \"faking\" solution people just fool themselves \\uD83E\\uDD37\\u200D\\u2642\\uFE0F\\nSecondly, it is just so easy to avoid this kind of solutions by creating randomised tests, this is quite weird to me that platforms like this do not have this approach as a requirement \\uD83D\\uDE15"
                    },
                    {
                        "username": "klaca",
                        "content": "My line of thought, spoilers ahead:\n\nEvery number is an element in half of the subsets. Thus, every bit of every element will be xor'ed in half of the subsets. Based on this, it can be shown that every bit that occurs in any of the numbers will be xor'ed odd times in half of the subsets, and even times in the other half of the subsets, because being in the subset or not is a symmetric attribute for every element. Xor-ing something even times is zero, xor-ing something odd times results in itself.\nNow you only need to find the bits that occur at least once in the array and multiply the sum of their value by half of the number of possible subsets."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "How to know whether the problem can be memoized or not ?\\n\\nfor every index the answer varies with previous considered element so we can fix certain value at every index for granted so there is no memo\\nis it true??\\n\\nhow to identify the sub problems?"
                    }
                ]
            },
            {
                "id": 1729867,
                "content": [
                    {
                        "username": "IamUday",
                        "content": "Is this really an Easy level Question ?"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "[@Gurugubelli_Anil](/Gurugubelli_Anil) sure, changing from one challenging approach to even more challenging"
                    },
                    {
                        "username": "Gurugubelli_Anil",
                        "content": "yes, by changing the approach of solving"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "It requires strong foundation of recursion and backtracking. This is definitely not a easy problem:|"
                    },
                    {
                        "username": "klaca",
                        "content": "if you know math, it's super easy, you don't need any algorithmic knowledge, except  loops.\n\nOn the other hand, upper limit for length of input array being 12 makes it possible to brute force without timeout. THAT is easy without math, too."
                    },
                    {
                        "username": "FirozMars",
                        "content": "why this is in easy section?\natleast medium "
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "Holy crap....this is definitely not an easy question........if i don\\'t want to hire someone I would ask them this question and will tell them that you can\\'t even do an easy leetcode question what did you do in ICPC "
                    },
                    {
                        "username": "sherlockieee",
                        "content": "> The XOR total of an array is defined as the bitwise XOR of all its elements, or 0 if the array is empty.  For example, XOR total of the array [2,5,6] is 2 XOR 5 XOR 6 = 1\\n\\n\\nI don\\'t understand this statement. Can someone explain to me the XOR concept or point to me resources that do?"
                    },
                    {
                        "username": "viishhnu",
                        "content": "wow! can say how u have figured this\\n"
                    },
                    {
                        "username": "BahaDew",
                        "content": "Written in these programming languages => 2 ^ 5 ^ 6\\nXOR  =  ^"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "basic XOR means the numbers are xor ed if(both the bits are different then 1 is placed and 0 if both are same  (in the bits format like 3 is 011)) and 3^4^5 is basically same as (3^4) ^5 . \\nhope this helps :) "
                    },
                    {
                        "username": "stephan_plakunov",
                        "content": "I got it after this explanation: https://stackoverflow.com/questions/14526584/what-does-the-xor-operator-do#:~:text=XOR%20is%20a%20binary%20operation,of%20the%20bits%20is%20set.&text=This%20operation%20is%20performed%20between%20every%20two%20corresponding%20bits%20of%20a%20number.&text=Properties%3A%20The%20operation%20is%20commutative%2C%20associative%20and%20self%2Dinverse."
                    },
                    {
                        "username": "adityakiran",
                        "content": "It is the same as 2 ^ (5 ^ 6) or (2 ^ 5) ^ 6. Hope this helps"
                    },
                    {
                        "username": "Gurugubelli_Anil",
                        "content": "bitwise XOR for subsets of array can be solved by   performing bitwise OR for every element and  final answer multiply by 2**len(nums)-1"
                    },
                    {
                        "username": "1rosehip",
                        "content": "Could you explain why this solution works?"
                    },
                    {
                        "username": "z3eg",
                        "content": "Note: Subsets with the same elements should be counted multiple times.\\n\\nyet in the very first example they count only 1,3 and not 3,1"
                    },
                    {
                        "username": "anujeet98",
                        "content": "3,1 is not a subset. you are altering the order of numbers"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "More and more often I started noticing the solutions like \\n\\n```\\ntestNumber = 0;\\nvar fakeSolution = function(params) {\\n  return [15, 1432, 5234, ... ][testNumber++];  \\n};\\n```\\n\\nFirst of all, what is the point to submit this kind of solutions? In the end, as I understand, this platform is about studying and self improvement, by \"faking\" solution people just fool themselves \\uD83E\\uDD37\\u200D\\u2642\\uFE0F\\nSecondly, it is just so easy to avoid this kind of solutions by creating randomised tests, this is quite weird to me that platforms like this do not have this approach as a requirement \\uD83D\\uDE15"
                    },
                    {
                        "username": "klaca",
                        "content": "My line of thought, spoilers ahead:\n\nEvery number is an element in half of the subsets. Thus, every bit of every element will be xor'ed in half of the subsets. Based on this, it can be shown that every bit that occurs in any of the numbers will be xor'ed odd times in half of the subsets, and even times in the other half of the subsets, because being in the subset or not is a symmetric attribute for every element. Xor-ing something even times is zero, xor-ing something odd times results in itself.\nNow you only need to find the bits that occur at least once in the array and multiply the sum of their value by half of the number of possible subsets."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "How to know whether the problem can be memoized or not ?\\n\\nfor every index the answer varies with previous considered element so we can fix certain value at every index for granted so there is no memo\\nis it true??\\n\\nhow to identify the sub problems?"
                    }
                ]
            },
            {
                "id": 1898472,
                "content": [
                    {
                        "username": "IamUday",
                        "content": "Is this really an Easy level Question ?"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "[@Gurugubelli_Anil](/Gurugubelli_Anil) sure, changing from one challenging approach to even more challenging"
                    },
                    {
                        "username": "Gurugubelli_Anil",
                        "content": "yes, by changing the approach of solving"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "It requires strong foundation of recursion and backtracking. This is definitely not a easy problem:|"
                    },
                    {
                        "username": "klaca",
                        "content": "if you know math, it's super easy, you don't need any algorithmic knowledge, except  loops.\n\nOn the other hand, upper limit for length of input array being 12 makes it possible to brute force without timeout. THAT is easy without math, too."
                    },
                    {
                        "username": "FirozMars",
                        "content": "why this is in easy section?\natleast medium "
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "Holy crap....this is definitely not an easy question........if i don\\'t want to hire someone I would ask them this question and will tell them that you can\\'t even do an easy leetcode question what did you do in ICPC "
                    },
                    {
                        "username": "sherlockieee",
                        "content": "> The XOR total of an array is defined as the bitwise XOR of all its elements, or 0 if the array is empty.  For example, XOR total of the array [2,5,6] is 2 XOR 5 XOR 6 = 1\\n\\n\\nI don\\'t understand this statement. Can someone explain to me the XOR concept or point to me resources that do?"
                    },
                    {
                        "username": "viishhnu",
                        "content": "wow! can say how u have figured this\\n"
                    },
                    {
                        "username": "BahaDew",
                        "content": "Written in these programming languages => 2 ^ 5 ^ 6\\nXOR  =  ^"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "basic XOR means the numbers are xor ed if(both the bits are different then 1 is placed and 0 if both are same  (in the bits format like 3 is 011)) and 3^4^5 is basically same as (3^4) ^5 . \\nhope this helps :) "
                    },
                    {
                        "username": "stephan_plakunov",
                        "content": "I got it after this explanation: https://stackoverflow.com/questions/14526584/what-does-the-xor-operator-do#:~:text=XOR%20is%20a%20binary%20operation,of%20the%20bits%20is%20set.&text=This%20operation%20is%20performed%20between%20every%20two%20corresponding%20bits%20of%20a%20number.&text=Properties%3A%20The%20operation%20is%20commutative%2C%20associative%20and%20self%2Dinverse."
                    },
                    {
                        "username": "adityakiran",
                        "content": "It is the same as 2 ^ (5 ^ 6) or (2 ^ 5) ^ 6. Hope this helps"
                    },
                    {
                        "username": "Gurugubelli_Anil",
                        "content": "bitwise XOR for subsets of array can be solved by   performing bitwise OR for every element and  final answer multiply by 2**len(nums)-1"
                    },
                    {
                        "username": "1rosehip",
                        "content": "Could you explain why this solution works?"
                    },
                    {
                        "username": "z3eg",
                        "content": "Note: Subsets with the same elements should be counted multiple times.\\n\\nyet in the very first example they count only 1,3 and not 3,1"
                    },
                    {
                        "username": "anujeet98",
                        "content": "3,1 is not a subset. you are altering the order of numbers"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "More and more often I started noticing the solutions like \\n\\n```\\ntestNumber = 0;\\nvar fakeSolution = function(params) {\\n  return [15, 1432, 5234, ... ][testNumber++];  \\n};\\n```\\n\\nFirst of all, what is the point to submit this kind of solutions? In the end, as I understand, this platform is about studying and self improvement, by \"faking\" solution people just fool themselves \\uD83E\\uDD37\\u200D\\u2642\\uFE0F\\nSecondly, it is just so easy to avoid this kind of solutions by creating randomised tests, this is quite weird to me that platforms like this do not have this approach as a requirement \\uD83D\\uDE15"
                    },
                    {
                        "username": "klaca",
                        "content": "My line of thought, spoilers ahead:\n\nEvery number is an element in half of the subsets. Thus, every bit of every element will be xor'ed in half of the subsets. Based on this, it can be shown that every bit that occurs in any of the numbers will be xor'ed odd times in half of the subsets, and even times in the other half of the subsets, because being in the subset or not is a symmetric attribute for every element. Xor-ing something even times is zero, xor-ing something odd times results in itself.\nNow you only need to find the bits that occur at least once in the array and multiply the sum of their value by half of the number of possible subsets."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "How to know whether the problem can be memoized or not ?\\n\\nfor every index the answer varies with previous considered element so we can fix certain value at every index for granted so there is no memo\\nis it true??\\n\\nhow to identify the sub problems?"
                    }
                ]
            },
            {
                "id": 1575300,
                "content": [
                    {
                        "username": "IamUday",
                        "content": "Is this really an Easy level Question ?"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "[@Gurugubelli_Anil](/Gurugubelli_Anil) sure, changing from one challenging approach to even more challenging"
                    },
                    {
                        "username": "Gurugubelli_Anil",
                        "content": "yes, by changing the approach of solving"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "It requires strong foundation of recursion and backtracking. This is definitely not a easy problem:|"
                    },
                    {
                        "username": "klaca",
                        "content": "if you know math, it's super easy, you don't need any algorithmic knowledge, except  loops.\n\nOn the other hand, upper limit for length of input array being 12 makes it possible to brute force without timeout. THAT is easy without math, too."
                    },
                    {
                        "username": "FirozMars",
                        "content": "why this is in easy section?\natleast medium "
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "Holy crap....this is definitely not an easy question........if i don\\'t want to hire someone I would ask them this question and will tell them that you can\\'t even do an easy leetcode question what did you do in ICPC "
                    },
                    {
                        "username": "sherlockieee",
                        "content": "> The XOR total of an array is defined as the bitwise XOR of all its elements, or 0 if the array is empty.  For example, XOR total of the array [2,5,6] is 2 XOR 5 XOR 6 = 1\\n\\n\\nI don\\'t understand this statement. Can someone explain to me the XOR concept or point to me resources that do?"
                    },
                    {
                        "username": "viishhnu",
                        "content": "wow! can say how u have figured this\\n"
                    },
                    {
                        "username": "BahaDew",
                        "content": "Written in these programming languages => 2 ^ 5 ^ 6\\nXOR  =  ^"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "basic XOR means the numbers are xor ed if(both the bits are different then 1 is placed and 0 if both are same  (in the bits format like 3 is 011)) and 3^4^5 is basically same as (3^4) ^5 . \\nhope this helps :) "
                    },
                    {
                        "username": "stephan_plakunov",
                        "content": "I got it after this explanation: https://stackoverflow.com/questions/14526584/what-does-the-xor-operator-do#:~:text=XOR%20is%20a%20binary%20operation,of%20the%20bits%20is%20set.&text=This%20operation%20is%20performed%20between%20every%20two%20corresponding%20bits%20of%20a%20number.&text=Properties%3A%20The%20operation%20is%20commutative%2C%20associative%20and%20self%2Dinverse."
                    },
                    {
                        "username": "adityakiran",
                        "content": "It is the same as 2 ^ (5 ^ 6) or (2 ^ 5) ^ 6. Hope this helps"
                    },
                    {
                        "username": "Gurugubelli_Anil",
                        "content": "bitwise XOR for subsets of array can be solved by   performing bitwise OR for every element and  final answer multiply by 2**len(nums)-1"
                    },
                    {
                        "username": "1rosehip",
                        "content": "Could you explain why this solution works?"
                    },
                    {
                        "username": "z3eg",
                        "content": "Note: Subsets with the same elements should be counted multiple times.\\n\\nyet in the very first example they count only 1,3 and not 3,1"
                    },
                    {
                        "username": "anujeet98",
                        "content": "3,1 is not a subset. you are altering the order of numbers"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "More and more often I started noticing the solutions like \\n\\n```\\ntestNumber = 0;\\nvar fakeSolution = function(params) {\\n  return [15, 1432, 5234, ... ][testNumber++];  \\n};\\n```\\n\\nFirst of all, what is the point to submit this kind of solutions? In the end, as I understand, this platform is about studying and self improvement, by \"faking\" solution people just fool themselves \\uD83E\\uDD37\\u200D\\u2642\\uFE0F\\nSecondly, it is just so easy to avoid this kind of solutions by creating randomised tests, this is quite weird to me that platforms like this do not have this approach as a requirement \\uD83D\\uDE15"
                    },
                    {
                        "username": "klaca",
                        "content": "My line of thought, spoilers ahead:\n\nEvery number is an element in half of the subsets. Thus, every bit of every element will be xor'ed in half of the subsets. Based on this, it can be shown that every bit that occurs in any of the numbers will be xor'ed odd times in half of the subsets, and even times in the other half of the subsets, because being in the subset or not is a symmetric attribute for every element. Xor-ing something even times is zero, xor-ing something odd times results in itself.\nNow you only need to find the bits that occur at least once in the array and multiply the sum of their value by half of the number of possible subsets."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "How to know whether the problem can be memoized or not ?\\n\\nfor every index the answer varies with previous considered element so we can fix certain value at every index for granted so there is no memo\\nis it true??\\n\\nhow to identify the sub problems?"
                    }
                ]
            },
            {
                "id": 1851758,
                "content": [
                    {
                        "username": "IamUday",
                        "content": "Is this really an Easy level Question ?"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "[@Gurugubelli_Anil](/Gurugubelli_Anil) sure, changing from one challenging approach to even more challenging"
                    },
                    {
                        "username": "Gurugubelli_Anil",
                        "content": "yes, by changing the approach of solving"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "It requires strong foundation of recursion and backtracking. This is definitely not a easy problem:|"
                    },
                    {
                        "username": "klaca",
                        "content": "if you know math, it's super easy, you don't need any algorithmic knowledge, except  loops.\n\nOn the other hand, upper limit for length of input array being 12 makes it possible to brute force without timeout. THAT is easy without math, too."
                    },
                    {
                        "username": "FirozMars",
                        "content": "why this is in easy section?\natleast medium "
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "Holy crap....this is definitely not an easy question........if i don\\'t want to hire someone I would ask them this question and will tell them that you can\\'t even do an easy leetcode question what did you do in ICPC "
                    },
                    {
                        "username": "sherlockieee",
                        "content": "> The XOR total of an array is defined as the bitwise XOR of all its elements, or 0 if the array is empty.  For example, XOR total of the array [2,5,6] is 2 XOR 5 XOR 6 = 1\\n\\n\\nI don\\'t understand this statement. Can someone explain to me the XOR concept or point to me resources that do?"
                    },
                    {
                        "username": "viishhnu",
                        "content": "wow! can say how u have figured this\\n"
                    },
                    {
                        "username": "BahaDew",
                        "content": "Written in these programming languages => 2 ^ 5 ^ 6\\nXOR  =  ^"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "basic XOR means the numbers are xor ed if(both the bits are different then 1 is placed and 0 if both are same  (in the bits format like 3 is 011)) and 3^4^5 is basically same as (3^4) ^5 . \\nhope this helps :) "
                    },
                    {
                        "username": "stephan_plakunov",
                        "content": "I got it after this explanation: https://stackoverflow.com/questions/14526584/what-does-the-xor-operator-do#:~:text=XOR%20is%20a%20binary%20operation,of%20the%20bits%20is%20set.&text=This%20operation%20is%20performed%20between%20every%20two%20corresponding%20bits%20of%20a%20number.&text=Properties%3A%20The%20operation%20is%20commutative%2C%20associative%20and%20self%2Dinverse."
                    },
                    {
                        "username": "adityakiran",
                        "content": "It is the same as 2 ^ (5 ^ 6) or (2 ^ 5) ^ 6. Hope this helps"
                    },
                    {
                        "username": "Gurugubelli_Anil",
                        "content": "bitwise XOR for subsets of array can be solved by   performing bitwise OR for every element and  final answer multiply by 2**len(nums)-1"
                    },
                    {
                        "username": "1rosehip",
                        "content": "Could you explain why this solution works?"
                    },
                    {
                        "username": "z3eg",
                        "content": "Note: Subsets with the same elements should be counted multiple times.\\n\\nyet in the very first example they count only 1,3 and not 3,1"
                    },
                    {
                        "username": "anujeet98",
                        "content": "3,1 is not a subset. you are altering the order of numbers"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "More and more often I started noticing the solutions like \\n\\n```\\ntestNumber = 0;\\nvar fakeSolution = function(params) {\\n  return [15, 1432, 5234, ... ][testNumber++];  \\n};\\n```\\n\\nFirst of all, what is the point to submit this kind of solutions? In the end, as I understand, this platform is about studying and self improvement, by \"faking\" solution people just fool themselves \\uD83E\\uDD37\\u200D\\u2642\\uFE0F\\nSecondly, it is just so easy to avoid this kind of solutions by creating randomised tests, this is quite weird to me that platforms like this do not have this approach as a requirement \\uD83D\\uDE15"
                    },
                    {
                        "username": "klaca",
                        "content": "My line of thought, spoilers ahead:\n\nEvery number is an element in half of the subsets. Thus, every bit of every element will be xor'ed in half of the subsets. Based on this, it can be shown that every bit that occurs in any of the numbers will be xor'ed odd times in half of the subsets, and even times in the other half of the subsets, because being in the subset or not is a symmetric attribute for every element. Xor-ing something even times is zero, xor-ing something odd times results in itself.\nNow you only need to find the bits that occur at least once in the array and multiply the sum of their value by half of the number of possible subsets."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "How to know whether the problem can be memoized or not ?\\n\\nfor every index the answer varies with previous considered element so we can fix certain value at every index for granted so there is no memo\\nis it true??\\n\\nhow to identify the sub problems?"
                    }
                ]
            },
            {
                "id": 1909120,
                "content": [
                    {
                        "username": "IamUday",
                        "content": "Is this really an Easy level Question ?"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "[@Gurugubelli_Anil](/Gurugubelli_Anil) sure, changing from one challenging approach to even more challenging"
                    },
                    {
                        "username": "Gurugubelli_Anil",
                        "content": "yes, by changing the approach of solving"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "It requires strong foundation of recursion and backtracking. This is definitely not a easy problem:|"
                    },
                    {
                        "username": "klaca",
                        "content": "if you know math, it's super easy, you don't need any algorithmic knowledge, except  loops.\n\nOn the other hand, upper limit for length of input array being 12 makes it possible to brute force without timeout. THAT is easy without math, too."
                    },
                    {
                        "username": "FirozMars",
                        "content": "why this is in easy section?\natleast medium "
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "Holy crap....this is definitely not an easy question........if i don\\'t want to hire someone I would ask them this question and will tell them that you can\\'t even do an easy leetcode question what did you do in ICPC "
                    },
                    {
                        "username": "sherlockieee",
                        "content": "> The XOR total of an array is defined as the bitwise XOR of all its elements, or 0 if the array is empty.  For example, XOR total of the array [2,5,6] is 2 XOR 5 XOR 6 = 1\\n\\n\\nI don\\'t understand this statement. Can someone explain to me the XOR concept or point to me resources that do?"
                    },
                    {
                        "username": "viishhnu",
                        "content": "wow! can say how u have figured this\\n"
                    },
                    {
                        "username": "BahaDew",
                        "content": "Written in these programming languages => 2 ^ 5 ^ 6\\nXOR  =  ^"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "basic XOR means the numbers are xor ed if(both the bits are different then 1 is placed and 0 if both are same  (in the bits format like 3 is 011)) and 3^4^5 is basically same as (3^4) ^5 . \\nhope this helps :) "
                    },
                    {
                        "username": "stephan_plakunov",
                        "content": "I got it after this explanation: https://stackoverflow.com/questions/14526584/what-does-the-xor-operator-do#:~:text=XOR%20is%20a%20binary%20operation,of%20the%20bits%20is%20set.&text=This%20operation%20is%20performed%20between%20every%20two%20corresponding%20bits%20of%20a%20number.&text=Properties%3A%20The%20operation%20is%20commutative%2C%20associative%20and%20self%2Dinverse."
                    },
                    {
                        "username": "adityakiran",
                        "content": "It is the same as 2 ^ (5 ^ 6) or (2 ^ 5) ^ 6. Hope this helps"
                    },
                    {
                        "username": "Gurugubelli_Anil",
                        "content": "bitwise XOR for subsets of array can be solved by   performing bitwise OR for every element and  final answer multiply by 2**len(nums)-1"
                    },
                    {
                        "username": "1rosehip",
                        "content": "Could you explain why this solution works?"
                    },
                    {
                        "username": "z3eg",
                        "content": "Note: Subsets with the same elements should be counted multiple times.\\n\\nyet in the very first example they count only 1,3 and not 3,1"
                    },
                    {
                        "username": "anujeet98",
                        "content": "3,1 is not a subset. you are altering the order of numbers"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "More and more often I started noticing the solutions like \\n\\n```\\ntestNumber = 0;\\nvar fakeSolution = function(params) {\\n  return [15, 1432, 5234, ... ][testNumber++];  \\n};\\n```\\n\\nFirst of all, what is the point to submit this kind of solutions? In the end, as I understand, this platform is about studying and self improvement, by \"faking\" solution people just fool themselves \\uD83E\\uDD37\\u200D\\u2642\\uFE0F\\nSecondly, it is just so easy to avoid this kind of solutions by creating randomised tests, this is quite weird to me that platforms like this do not have this approach as a requirement \\uD83D\\uDE15"
                    },
                    {
                        "username": "klaca",
                        "content": "My line of thought, spoilers ahead:\n\nEvery number is an element in half of the subsets. Thus, every bit of every element will be xor'ed in half of the subsets. Based on this, it can be shown that every bit that occurs in any of the numbers will be xor'ed odd times in half of the subsets, and even times in the other half of the subsets, because being in the subset or not is a symmetric attribute for every element. Xor-ing something even times is zero, xor-ing something odd times results in itself.\nNow you only need to find the bits that occur at least once in the array and multiply the sum of their value by half of the number of possible subsets."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "How to know whether the problem can be memoized or not ?\\n\\nfor every index the answer varies with previous considered element so we can fix certain value at every index for granted so there is no memo\\nis it true??\\n\\nhow to identify the sub problems?"
                    }
                ]
            },
            {
                "id": 1876038,
                "content": [
                    {
                        "username": "IamUday",
                        "content": "Is this really an Easy level Question ?"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "[@Gurugubelli_Anil](/Gurugubelli_Anil) sure, changing from one challenging approach to even more challenging"
                    },
                    {
                        "username": "Gurugubelli_Anil",
                        "content": "yes, by changing the approach of solving"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "It requires strong foundation of recursion and backtracking. This is definitely not a easy problem:|"
                    },
                    {
                        "username": "klaca",
                        "content": "if you know math, it's super easy, you don't need any algorithmic knowledge, except  loops.\n\nOn the other hand, upper limit for length of input array being 12 makes it possible to brute force without timeout. THAT is easy without math, too."
                    },
                    {
                        "username": "FirozMars",
                        "content": "why this is in easy section?\natleast medium "
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "Holy crap....this is definitely not an easy question........if i don\\'t want to hire someone I would ask them this question and will tell them that you can\\'t even do an easy leetcode question what did you do in ICPC "
                    },
                    {
                        "username": "sherlockieee",
                        "content": "> The XOR total of an array is defined as the bitwise XOR of all its elements, or 0 if the array is empty.  For example, XOR total of the array [2,5,6] is 2 XOR 5 XOR 6 = 1\\n\\n\\nI don\\'t understand this statement. Can someone explain to me the XOR concept or point to me resources that do?"
                    },
                    {
                        "username": "viishhnu",
                        "content": "wow! can say how u have figured this\\n"
                    },
                    {
                        "username": "BahaDew",
                        "content": "Written in these programming languages => 2 ^ 5 ^ 6\\nXOR  =  ^"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "basic XOR means the numbers are xor ed if(both the bits are different then 1 is placed and 0 if both are same  (in the bits format like 3 is 011)) and 3^4^5 is basically same as (3^4) ^5 . \\nhope this helps :) "
                    },
                    {
                        "username": "stephan_plakunov",
                        "content": "I got it after this explanation: https://stackoverflow.com/questions/14526584/what-does-the-xor-operator-do#:~:text=XOR%20is%20a%20binary%20operation,of%20the%20bits%20is%20set.&text=This%20operation%20is%20performed%20between%20every%20two%20corresponding%20bits%20of%20a%20number.&text=Properties%3A%20The%20operation%20is%20commutative%2C%20associative%20and%20self%2Dinverse."
                    },
                    {
                        "username": "adityakiran",
                        "content": "It is the same as 2 ^ (5 ^ 6) or (2 ^ 5) ^ 6. Hope this helps"
                    },
                    {
                        "username": "Gurugubelli_Anil",
                        "content": "bitwise XOR for subsets of array can be solved by   performing bitwise OR for every element and  final answer multiply by 2**len(nums)-1"
                    },
                    {
                        "username": "1rosehip",
                        "content": "Could you explain why this solution works?"
                    },
                    {
                        "username": "z3eg",
                        "content": "Note: Subsets with the same elements should be counted multiple times.\\n\\nyet in the very first example they count only 1,3 and not 3,1"
                    },
                    {
                        "username": "anujeet98",
                        "content": "3,1 is not a subset. you are altering the order of numbers"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "More and more often I started noticing the solutions like \\n\\n```\\ntestNumber = 0;\\nvar fakeSolution = function(params) {\\n  return [15, 1432, 5234, ... ][testNumber++];  \\n};\\n```\\n\\nFirst of all, what is the point to submit this kind of solutions? In the end, as I understand, this platform is about studying and self improvement, by \"faking\" solution people just fool themselves \\uD83E\\uDD37\\u200D\\u2642\\uFE0F\\nSecondly, it is just so easy to avoid this kind of solutions by creating randomised tests, this is quite weird to me that platforms like this do not have this approach as a requirement \\uD83D\\uDE15"
                    },
                    {
                        "username": "klaca",
                        "content": "My line of thought, spoilers ahead:\n\nEvery number is an element in half of the subsets. Thus, every bit of every element will be xor'ed in half of the subsets. Based on this, it can be shown that every bit that occurs in any of the numbers will be xor'ed odd times in half of the subsets, and even times in the other half of the subsets, because being in the subset or not is a symmetric attribute for every element. Xor-ing something even times is zero, xor-ing something odd times results in itself.\nNow you only need to find the bits that occur at least once in the array and multiply the sum of their value by half of the number of possible subsets."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "How to know whether the problem can be memoized or not ?\\n\\nfor every index the answer varies with previous considered element so we can fix certain value at every index for granted so there is no memo\\nis it true??\\n\\nhow to identify the sub problems?"
                    }
                ]
            },
            {
                "id": 1845298,
                "content": [
                    {
                        "username": "IamUday",
                        "content": "Is this really an Easy level Question ?"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "[@Gurugubelli_Anil](/Gurugubelli_Anil) sure, changing from one challenging approach to even more challenging"
                    },
                    {
                        "username": "Gurugubelli_Anil",
                        "content": "yes, by changing the approach of solving"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "It requires strong foundation of recursion and backtracking. This is definitely not a easy problem:|"
                    },
                    {
                        "username": "klaca",
                        "content": "if you know math, it's super easy, you don't need any algorithmic knowledge, except  loops.\n\nOn the other hand, upper limit for length of input array being 12 makes it possible to brute force without timeout. THAT is easy without math, too."
                    },
                    {
                        "username": "FirozMars",
                        "content": "why this is in easy section?\natleast medium "
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "Holy crap....this is definitely not an easy question........if i don\\'t want to hire someone I would ask them this question and will tell them that you can\\'t even do an easy leetcode question what did you do in ICPC "
                    },
                    {
                        "username": "sherlockieee",
                        "content": "> The XOR total of an array is defined as the bitwise XOR of all its elements, or 0 if the array is empty.  For example, XOR total of the array [2,5,6] is 2 XOR 5 XOR 6 = 1\\n\\n\\nI don\\'t understand this statement. Can someone explain to me the XOR concept or point to me resources that do?"
                    },
                    {
                        "username": "viishhnu",
                        "content": "wow! can say how u have figured this\\n"
                    },
                    {
                        "username": "BahaDew",
                        "content": "Written in these programming languages => 2 ^ 5 ^ 6\\nXOR  =  ^"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "basic XOR means the numbers are xor ed if(both the bits are different then 1 is placed and 0 if both are same  (in the bits format like 3 is 011)) and 3^4^5 is basically same as (3^4) ^5 . \\nhope this helps :) "
                    },
                    {
                        "username": "stephan_plakunov",
                        "content": "I got it after this explanation: https://stackoverflow.com/questions/14526584/what-does-the-xor-operator-do#:~:text=XOR%20is%20a%20binary%20operation,of%20the%20bits%20is%20set.&text=This%20operation%20is%20performed%20between%20every%20two%20corresponding%20bits%20of%20a%20number.&text=Properties%3A%20The%20operation%20is%20commutative%2C%20associative%20and%20self%2Dinverse."
                    },
                    {
                        "username": "adityakiran",
                        "content": "It is the same as 2 ^ (5 ^ 6) or (2 ^ 5) ^ 6. Hope this helps"
                    },
                    {
                        "username": "Gurugubelli_Anil",
                        "content": "bitwise XOR for subsets of array can be solved by   performing bitwise OR for every element and  final answer multiply by 2**len(nums)-1"
                    },
                    {
                        "username": "1rosehip",
                        "content": "Could you explain why this solution works?"
                    },
                    {
                        "username": "z3eg",
                        "content": "Note: Subsets with the same elements should be counted multiple times.\\n\\nyet in the very first example they count only 1,3 and not 3,1"
                    },
                    {
                        "username": "anujeet98",
                        "content": "3,1 is not a subset. you are altering the order of numbers"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "More and more often I started noticing the solutions like \\n\\n```\\ntestNumber = 0;\\nvar fakeSolution = function(params) {\\n  return [15, 1432, 5234, ... ][testNumber++];  \\n};\\n```\\n\\nFirst of all, what is the point to submit this kind of solutions? In the end, as I understand, this platform is about studying and self improvement, by \"faking\" solution people just fool themselves \\uD83E\\uDD37\\u200D\\u2642\\uFE0F\\nSecondly, it is just so easy to avoid this kind of solutions by creating randomised tests, this is quite weird to me that platforms like this do not have this approach as a requirement \\uD83D\\uDE15"
                    },
                    {
                        "username": "klaca",
                        "content": "My line of thought, spoilers ahead:\n\nEvery number is an element in half of the subsets. Thus, every bit of every element will be xor'ed in half of the subsets. Based on this, it can be shown that every bit that occurs in any of the numbers will be xor'ed odd times in half of the subsets, and even times in the other half of the subsets, because being in the subset or not is a symmetric attribute for every element. Xor-ing something even times is zero, xor-ing something odd times results in itself.\nNow you only need to find the bits that occur at least once in the array and multiply the sum of their value by half of the number of possible subsets."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "How to know whether the problem can be memoized or not ?\\n\\nfor every index the answer varies with previous considered element so we can fix certain value at every index for granted so there is no memo\\nis it true??\\n\\nhow to identify the sub problems?"
                    }
                ]
            },
            {
                "id": 2020345,
                "content": [
                    {
                        "username": "IamUday",
                        "content": "Is this really an Easy level Question ?"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "[@Gurugubelli_Anil](/Gurugubelli_Anil) sure, changing from one challenging approach to even more challenging"
                    },
                    {
                        "username": "Gurugubelli_Anil",
                        "content": "yes, by changing the approach of solving"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "It requires strong foundation of recursion and backtracking. This is definitely not a easy problem:|"
                    },
                    {
                        "username": "klaca",
                        "content": "if you know math, it's super easy, you don't need any algorithmic knowledge, except  loops.\n\nOn the other hand, upper limit for length of input array being 12 makes it possible to brute force without timeout. THAT is easy without math, too."
                    },
                    {
                        "username": "FirozMars",
                        "content": "why this is in easy section?\natleast medium "
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "Holy crap....this is definitely not an easy question........if i don\\'t want to hire someone I would ask them this question and will tell them that you can\\'t even do an easy leetcode question what did you do in ICPC "
                    },
                    {
                        "username": "sherlockieee",
                        "content": "> The XOR total of an array is defined as the bitwise XOR of all its elements, or 0 if the array is empty.  For example, XOR total of the array [2,5,6] is 2 XOR 5 XOR 6 = 1\\n\\n\\nI don\\'t understand this statement. Can someone explain to me the XOR concept or point to me resources that do?"
                    },
                    {
                        "username": "viishhnu",
                        "content": "wow! can say how u have figured this\\n"
                    },
                    {
                        "username": "BahaDew",
                        "content": "Written in these programming languages => 2 ^ 5 ^ 6\\nXOR  =  ^"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "basic XOR means the numbers are xor ed if(both the bits are different then 1 is placed and 0 if both are same  (in the bits format like 3 is 011)) and 3^4^5 is basically same as (3^4) ^5 . \\nhope this helps :) "
                    },
                    {
                        "username": "stephan_plakunov",
                        "content": "I got it after this explanation: https://stackoverflow.com/questions/14526584/what-does-the-xor-operator-do#:~:text=XOR%20is%20a%20binary%20operation,of%20the%20bits%20is%20set.&text=This%20operation%20is%20performed%20between%20every%20two%20corresponding%20bits%20of%20a%20number.&text=Properties%3A%20The%20operation%20is%20commutative%2C%20associative%20and%20self%2Dinverse."
                    },
                    {
                        "username": "adityakiran",
                        "content": "It is the same as 2 ^ (5 ^ 6) or (2 ^ 5) ^ 6. Hope this helps"
                    },
                    {
                        "username": "Gurugubelli_Anil",
                        "content": "bitwise XOR for subsets of array can be solved by   performing bitwise OR for every element and  final answer multiply by 2**len(nums)-1"
                    },
                    {
                        "username": "1rosehip",
                        "content": "Could you explain why this solution works?"
                    },
                    {
                        "username": "z3eg",
                        "content": "Note: Subsets with the same elements should be counted multiple times.\\n\\nyet in the very first example they count only 1,3 and not 3,1"
                    },
                    {
                        "username": "anujeet98",
                        "content": "3,1 is not a subset. you are altering the order of numbers"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "More and more often I started noticing the solutions like \\n\\n```\\ntestNumber = 0;\\nvar fakeSolution = function(params) {\\n  return [15, 1432, 5234, ... ][testNumber++];  \\n};\\n```\\n\\nFirst of all, what is the point to submit this kind of solutions? In the end, as I understand, this platform is about studying and self improvement, by \"faking\" solution people just fool themselves \\uD83E\\uDD37\\u200D\\u2642\\uFE0F\\nSecondly, it is just so easy to avoid this kind of solutions by creating randomised tests, this is quite weird to me that platforms like this do not have this approach as a requirement \\uD83D\\uDE15"
                    },
                    {
                        "username": "klaca",
                        "content": "My line of thought, spoilers ahead:\n\nEvery number is an element in half of the subsets. Thus, every bit of every element will be xor'ed in half of the subsets. Based on this, it can be shown that every bit that occurs in any of the numbers will be xor'ed odd times in half of the subsets, and even times in the other half of the subsets, because being in the subset or not is a symmetric attribute for every element. Xor-ing something even times is zero, xor-ing something odd times results in itself.\nNow you only need to find the bits that occur at least once in the array and multiply the sum of their value by half of the number of possible subsets."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "How to know whether the problem can be memoized or not ?\\n\\nfor every index the answer varies with previous considered element so we can fix certain value at every index for granted so there is no memo\\nis it true??\\n\\nhow to identify the sub problems?"
                    }
                ]
            }
        ]
    }
]