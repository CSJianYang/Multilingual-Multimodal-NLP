[
    {
        "title": "Squares of a Sorted Array",
        "question_content": "Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order.\n&nbsp;\nExample 1:\n\nInput: nums = [-4,-1,0,3,10]\nOutput: [0,1,9,16,100]\nExplanation: After squaring, the array becomes [16,1,0,9,100].\nAfter sorting, it becomes [0,1,9,16,100].\n\nExample 2:\n\nInput: nums = [-7,-3,2,3,11]\nOutput: [4,9,9,49,121]\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 104\n\t-104 <= nums[i] <= 104\n\tnums is sorted in non-decreasing order.\n\n&nbsp;\nFollow up: Squaring each element and sorting the new array is very trivial, could you find an O(n) solution using a different approach?",
        "solutions": [
            {
                "id": 221922,
                "title": "java-two-pointers-o-n",
                "content": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] A) {\\n        int n = A.length;\\n        int[] result = new int[n];\\n        int i = 0, j = n - 1;\\n        for (int p = n - 1; p >= 0; p--) {\\n            if (Math.abs(A[i]) > Math.abs(A[j])) {\\n                result[p] = A[i] * A[i];\\n                i++;\\n            } else {\\n                result[p] = A[j] * A[j];\\n                j--;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] A) {\\n        int n = A.length;\\n        int[] result = new int[n];\\n        int i = 0, j = n - 1;\\n        for (int p = n - 1; p >= 0; p--) {\\n            if (Math.abs(A[i]) > Math.abs(A[j])) {\\n                result[p] = A[i] * A[i];\\n                i++;\\n            } else {\\n                result[p] = A[j] * A[j];\\n                j--;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 495394,
                "title": "c-simplest-one-pass-two-pointers",
                "content": "Based on [original post by yukuairoy](https://leetcode.com/problems/squares-of-a-sorted-array/discuss/283978/Python-Two-Pointers).\\n\\nLet\\'s take example with negative and positive numbers, like:\\n```\\n[-4, -2, 0, 1, 3]\\n```\\nSince we need to put squeres in result array, we can consider that all numbers are positive (since: `-4**2 = 4**2 = 16`). Now our array looks like it sorted from middle to outside on both sides:\\n```\\n[4, 2, 0, 1, 3]\\n```\\nNow, we can have two pointers `l` to left most element, `r` to most right element.\\nCreate `res` result array same size as `A`.\\nMove from right to left in `res` and past `max(abs(A[l]), abs(A[r]))`, move correspondingly `l++` or `r--`.\\n\\n![image](https://assets.leetcode.com/users/andnik/image_1580828708.png)\\n\\nSame works for example with all negative and all positive numbers.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& A) {\\n        vector<int> res(A.size());\\n        int l = 0, r = A.size() - 1;\\n        for (int k = A.size() - 1; k >= 0; k--) {\\n            if (abs(A[r]) > abs(A[l])) res[k] = A[r] * A[r--];\\n            else res[k] = A[l] * A[l++];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n[-4, -2, 0, 1, 3]\\n```\n```\\n[4, 2, 0, 1, 3]\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& A) {\\n        vector<int> res(A.size());\\n        int l = 0, r = A.size() - 1;\\n        for (int k = A.size() - 1; k >= 0; k--) {\\n            if (abs(A[r]) > abs(A[l])) res[k] = A[r] * A[r--];\\n            else res[k] = A[l] * A[l++];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 310865,
                "title": "python-a-comparison-of-lots-of-approaches-sorting-two-pointers-deque-iterator-generator",
                "content": "This question is a cool one in that there is lots of different approaches, each with its own pros and cons. And then there\\'s also different ways of implementing them, depending on whether you are after raw performance or beautiful code.\\n\\nSomething slightly irritating is that leetcode isn\\'t testing with big enough test cases to push the time complexity of the O(n-log-n) approaches below the O(n) ones. It goes to show, sometimes what \"wins\" at the notoriously inaccurate Leetcode time/ space percentiles isn\\'t always the best in practice, or even in an interview.\\n\\n# Approach #1: Using built in sort.\\nThere are a few similar approaches we can take here, each with its own subtle differences. All are of an ```O(n-log-n)``` time complexity due to using the inbuilt sort, although they differ in their space complexity.\\n\\n## a) Overwriting input:\\n\\n```\\n    def sortedSquares(self, A: List[int]) -> List[int]:\\n        for i in range(len(A)):\\n            A[i] *= A[i]\\n        A.sort()\\n        return A\\n```\\n\\nThis approach uses ```O(1)``` memory beyond the input array, and is truely **in-place**. *However*, it is not always a good idea to overwrite inputs. Remember that because we passed it by reference, the original is actually lost. Often functions like this are a part of an API, and in a lot of cases, nobody wants an API that clobbers their input.\\n\\nI think it\\'s best to ask your interviewer if they want something done **in-place** or not. It is a common misconception that we should *always* be trying to do things in-place, overwriting the inputs.\\n\\n## b) Making a new array, not in place, O(n) auxillary space.\\n\\n```\\ndef sortedSquares(self, A: List[int]) -> List[int]:\\n        return sorted([v**2 for v in A])\\n```\\n\\nAhhhh, our good \\'ol clever Python one-liner. There is a suble space inefficiency in it though. For a brief moment, we\\'re using 3n memory, not 2n. The one line has 2 not-in-place operations in it; the list comprehension creates a new list, and so does sorted. The list comprehension list is promptly garbage collected upon function return, *but* because it was briefly there, the max memory usage was ultimately 3n. With lots of memory, this is totally fine, and the pythonic nature of it makes it a great solution. But we do need to be aware of it.\\n\\n## c) Making a new array, not in place, O(1) auxillary space.\\n\\nMaking a new array, in place.\\n\\n```\\ndef sortedSquares(self, A: List[int]) -> List[int]:\\n        return_array = [v**2 for v in A]\\n\\t\\treturn_array.sort() # This is in place!\\n\\t\\treturn return_array\\n```\\n\\nSo, is this ```O(1)``` space or ```O(n)``` space? Arguments can be made either way, sometimes people say to count the output data stucture in the calculation, and sometimes they don\\'t. If we\\'re talking about *auxillary* space, we generally don\\'t count the output data structure, which would make it ```O(1)```. I think this is a more accurate way of putting it -- we are trying to measure what the algorithm itself is using, not just what the inevitable size of the output is. But it\\'s important to be clear in interviews what you are and aren\\'t counting.\\n\\n## Overall thoughts on these approaches\\nYou won\\'t be coding any of these approaches in an interview (in my own very, very limited experience though!). By all means your interviewer will want to hear that you could do it this way, but there is 3 big problems if they are the only approaches you can come up with.\\n1) We shouldn\\'t need to use an O(n-log-n) sort operation on data that for the most part is already sorted. There\\'s something not right with that. If this is the approach the interviewer wanted, they wouldn\\'t have given you the numbers in a sorted list in the first place.\\n2) Following on from that, there are O(n) solutions.\\n3) Why would they be asking you to code something so trivial? Let\\'s be honest. They want to see you writing some meaty code. \\n\\nThe remaining approaches exploit the existing sorting. If we were to go down the list squaring each number, we\\'d have a \"v\" sorted list, in that the squares of the negatives decrease, and then the squares of the positives increase, i.e.\\n```[-4, -2, -1, 0, 1, 2, 3, 5] -> [16, 4, 1, 0, 1, 4, 9, 25]```\\n\\nWe can get this into a sorted list in ```O(n)``` time.\\n# Approach 2: Raw pointers\\nIn terms of performance, you can\\'t beat this (well, if leetcode actually tested on massive test cases...). It\\'s O(n) time, and O(1) auxillary space.\\n\\n```\\nclass Solution:\\n    def sortedSquares(self, A: List[int]) -> List[int]:\\n        return_array = [0] * len(A)\\n        write_pointer = len(A) - 1\\n        left_read_pointer = 0\\n        right_read_pointer = len(A) - 1\\n        left_square = A[left_read_pointer] ** 2\\n        right_square = A[right_read_pointer] ** 2\\n        while write_pointer >= 0:\\n            if left_square > right_square:\\n                return_array[write_pointer] = left_square\\n                left_read_pointer += 1\\n                left_square = A[left_read_pointer] ** 2\\n            else:\\n                return_array[write_pointer] = right_square\\n                right_read_pointer -= 1\\n                right_square = A[right_read_pointer] ** 2\\n            write_pointer -= 1\\n        return return_array\\n```\\n\\n# Approach 3: Using a deque \\nThis approach is the first of the trading-off-some-raw-performance-for-beauty=and-elegance approaches. It remains as ```O(n)``` *time complexity* like approach 2, but the heavy-weight nature of it will slow it down by a constant amount. If this doesn\\'t matter though (and in a lot of cases it doesn\\'t), then the elegance will reduce the risk of bugs and lead to more readable and maintable code. It is also important to note that it does use ```O(n)``` *auxillary space*.\\n\\n```\\n    def sortedSquares(self, A: List[int]) -> List[int]:\\n        number_deque = collections.deque(A)\\n        reverse_sorted_squares = []\\n        while number_deque:\\n            left_square = number_deque[0] ** 2\\n            right_square = number_deque[-1] ** 2\\n            if left_square > right_square:\\n                reverse_sorted_squares.append(left_square)\\n                number_deque.popleft()\\n            else:\\n                reverse_sorted_squares.append(right_square)\\n                number_deque.pop()\\n        return reverse_sorted_squares[::-1]\\n```\\n\\n# Approach 4: The iterator pattern\\nThis is one of my favourites. While it suffers from the same constant time slowdown as the previous approach, its auxillary space usage remains at ```O(1)```. The iterator pattern is a great way of splitting up code into more testable units. It seperates the problem of getting the squares in a sorted order from the problem of writing them into an array.\\n\\nThere are 2 subapproaches. One that returns the squares in reversed order, and one that puts them around the right way. The latter is more complex to code, but it means that the code dealing with the writing doesn\\'t have to reverse them, and it is still a time complexity of ```O(n)``` and an auxillary space usage of ```O(1)```.\\n\\n## a) Iterator returning from largest -> smallest\\n\\n```\\nclass SquaresIterator(object):\\n    def __init__(self, sorted_array):\\n        self.sorted_array = sorted_array\\n        self.left_pointer = 0\\n        self.right_pointer = len(sorted_array) - 1\\n    \\n    def __iter__(self):\\n        return self\\n    \\n    def __next__(self):\\n        if self.left_pointer > self.right_pointer:\\n            raise StopIteration\\n        left_square = self.sorted_array[self.left_pointer] ** 2\\n        right_square = self.sorted_array[self.right_pointer] ** 2\\n        if left_square > right_square:\\n            self.left_pointer += 1\\n            return left_square\\n        else:\\n            self.right_pointer -= 1\\n            return right_square\\n     \\n\\nclass Solution:\\n    def sortedSquares(self, A: List[int]) -> List[int]:\\n        return_array = [0] * len(A)\\n        write_pointer = len(A) - 1\\n        for square in SquaresIterator(A):\\n            return_array[write_pointer] = square\\n            write_pointer -= 1\\n        return return_array\\n```\\n\\n## b) Iterator returning from smallest -> largest\\n\\nThis one uses a binary search to set the left and right pointers in the middle of the array to begin with. This way, the items are returned in the correct order. We don\\'t even need explicit write code here!\\n\\n```\\nclass SquaresIterator(object):\\n    \\n    def __init__(self, sorted_array):\\n        self.sorted_array = sorted_array\\n        self.left_pointer, self.right_pointer = self._get_pointers()\\n    \\n    def __iter__(self):\\n        return self\\n    \\n    def __next__(self):\\n        \\n        # If there\\'s no values remaining.\\n        if self.left_pointer < 0 and self.right_pointer >= len(self.sorted_array):\\n            raise StopIteration\\n        \\n        # If there\\'s no values remaining on the left end.\\n        if self.left_pointer < 0:\\n            self.right_pointer += 1\\n            return self.sorted_array[self.right_pointer - 1] ** 2\\n        \\n        # If there\\'s no values remaining on the right end.\\n        if self.right_pointer >= len(self.sorted_array):\\n            self.left_pointer -= 1\\n            return self.sorted_array[self.left_pointer + 1] ** 2\\n        \\n        # If there\\'s values remaining on both ends.\\n        left_square = self.sorted_array[self.left_pointer] ** 2\\n        right_square = self.sorted_array[self.right_pointer] ** 2\\n        if left_square < right_square:\\n            self.left_pointer -= 1\\n            return left_square\\n        else:\\n            self.right_pointer += 1\\n            return right_square\\n    \\n    \\n    def _get_pointers(self):\\n        low = 0\\n        high = len(self.sorted_array)\\n        while high - low > 1:\\n            mid = low + (high - low) // 2\\n            if self.sorted_array[mid] > 0:\\n                high = mid\\n            else:\\n                low = mid\\n        return low, high\\n        \\n    \\nclass Solution:\\n    def sortedSquares(self, A: List[int]) -> List[int]:\\n        return list(SquaresIterator(A))\\n```\\n\\n# Approach 5: Generators\\nWhy are we using iterators for such a simple task? We can use a generator function instead!\\n\\nAgain, it\\'s O(n) time with O(1) auxillary space.\\n\\n```\\nclass Solution:\\n    \\n    def generate_sorted_squares(self, nums):\\n        \\n        # Start by doing our binary search to find where\\n        # to place the pointers.\\n        left = 0\\n        right = len(nums)\\n        while right - left > 1:\\n            mid = left + (right - left) // 2\\n            if nums[mid] > 0:\\n                right = mid\\n            else:\\n                left = mid\\n        \\n        # And now the main generator loop. The condition is the negation\\n        # of the StopIteration condition for the iterator approach.\\n        while left >= 0 or right < len(nums):\\n            if left < 0:\\n                right += 1\\n                yield nums[right - 1] ** 2\\n            elif right >= len(nums):\\n                left -= 1\\n                yield nums[left + 1] ** 2\\n            else:\\n                left_square = nums[left] ** 2\\n                right_square = nums[right] ** 2\\n                if left_square < right_square:\\n                    left -= 1\\n                    yield left_square\\n                else:\\n                    right += 1\\n                    yield right_square\\n        \\n    \\n    def sortedSquares(self, A: List[int]) -> List[int]:\\n        return list(self.generate_sorted_squares(A))\\n```\\n\\n# In conclusion\\nI\\'m sure there are many more approaches. Another would be to combine the 2 pointer technique with the binary search. \\n\\nI\\'m interested in thoughts people have on which is best in an interview!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "Queue",
                    "Sorting",
                    "Iterator"
                ],
                "code": "```O(n-log-n)```\n```\\n    def sortedSquares(self, A: List[int]) -> List[int]:\\n        for i in range(len(A)):\\n            A[i] *= A[i]\\n        A.sort()\\n        return A\\n```\n```O(1)```\n```\\ndef sortedSquares(self, A: List[int]) -> List[int]:\\n        return sorted([v**2 for v in A])\\n```\n```\\ndef sortedSquares(self, A: List[int]) -> List[int]:\\n        return_array = [v**2 for v in A]\\n\\t\\treturn_array.sort() # This is in place!\\n\\t\\treturn return_array\\n```\n```O(1)```\n```O(n)```\n```O(1)```\n```[-4, -2, -1, 0, 1, 2, 3, 5] -> [16, 4, 1, 0, 1, 4, 9, 25]```\n```O(n)```\n```\\nclass Solution:\\n    def sortedSquares(self, A: List[int]) -> List[int]:\\n        return_array = [0] * len(A)\\n        write_pointer = len(A) - 1\\n        left_read_pointer = 0\\n        right_read_pointer = len(A) - 1\\n        left_square = A[left_read_pointer] ** 2\\n        right_square = A[right_read_pointer] ** 2\\n        while write_pointer >= 0:\\n            if left_square > right_square:\\n                return_array[write_pointer] = left_square\\n                left_read_pointer += 1\\n                left_square = A[left_read_pointer] ** 2\\n            else:\\n                return_array[write_pointer] = right_square\\n                right_read_pointer -= 1\\n                right_square = A[right_read_pointer] ** 2\\n            write_pointer -= 1\\n        return return_array\\n```\n```O(n)```\n```O(n)```\n```\\n    def sortedSquares(self, A: List[int]) -> List[int]:\\n        number_deque = collections.deque(A)\\n        reverse_sorted_squares = []\\n        while number_deque:\\n            left_square = number_deque[0] ** 2\\n            right_square = number_deque[-1] ** 2\\n            if left_square > right_square:\\n                reverse_sorted_squares.append(left_square)\\n                number_deque.popleft()\\n            else:\\n                reverse_sorted_squares.append(right_square)\\n                number_deque.pop()\\n        return reverse_sorted_squares[::-1]\\n```\n```O(1)```\n```O(n)```\n```O(1)```\n```\\nclass SquaresIterator(object):\\n    def __init__(self, sorted_array):\\n        self.sorted_array = sorted_array\\n        self.left_pointer = 0\\n        self.right_pointer = len(sorted_array) - 1\\n    \\n    def __iter__(self):\\n        return self\\n    \\n    def __next__(self):\\n        if self.left_pointer > self.right_pointer:\\n            raise StopIteration\\n        left_square = self.sorted_array[self.left_pointer] ** 2\\n        right_square = self.sorted_array[self.right_pointer] ** 2\\n        if left_square > right_square:\\n            self.left_pointer += 1\\n            return left_square\\n        else:\\n            self.right_pointer -= 1\\n            return right_square\\n     \\n\\nclass Solution:\\n    def sortedSquares(self, A: List[int]) -> List[int]:\\n        return_array = [0] * len(A)\\n        write_pointer = len(A) - 1\\n        for square in SquaresIterator(A):\\n            return_array[write_pointer] = square\\n            write_pointer -= 1\\n        return return_array\\n```\n```\\nclass SquaresIterator(object):\\n    \\n    def __init__(self, sorted_array):\\n        self.sorted_array = sorted_array\\n        self.left_pointer, self.right_pointer = self._get_pointers()\\n    \\n    def __iter__(self):\\n        return self\\n    \\n    def __next__(self):\\n        \\n        # If there\\'s no values remaining.\\n        if self.left_pointer < 0 and self.right_pointer >= len(self.sorted_array):\\n            raise StopIteration\\n        \\n        # If there\\'s no values remaining on the left end.\\n        if self.left_pointer < 0:\\n            self.right_pointer += 1\\n            return self.sorted_array[self.right_pointer - 1] ** 2\\n        \\n        # If there\\'s no values remaining on the right end.\\n        if self.right_pointer >= len(self.sorted_array):\\n            self.left_pointer -= 1\\n            return self.sorted_array[self.left_pointer + 1] ** 2\\n        \\n        # If there\\'s values remaining on both ends.\\n        left_square = self.sorted_array[self.left_pointer] ** 2\\n        right_square = self.sorted_array[self.right_pointer] ** 2\\n        if left_square < right_square:\\n            self.left_pointer -= 1\\n            return left_square\\n        else:\\n            self.right_pointer += 1\\n            return right_square\\n    \\n    \\n    def _get_pointers(self):\\n        low = 0\\n        high = len(self.sorted_array)\\n        while high - low > 1:\\n            mid = low + (high - low) // 2\\n            if self.sorted_array[mid] > 0:\\n                high = mid\\n            else:\\n                low = mid\\n        return low, high\\n        \\n    \\nclass Solution:\\n    def sortedSquares(self, A: List[int]) -> List[int]:\\n        return list(SquaresIterator(A))\\n```\n```\\nclass Solution:\\n    \\n    def generate_sorted_squares(self, nums):\\n        \\n        # Start by doing our binary search to find where\\n        # to place the pointers.\\n        left = 0\\n        right = len(nums)\\n        while right - left > 1:\\n            mid = left + (right - left) // 2\\n            if nums[mid] > 0:\\n                right = mid\\n            else:\\n                left = mid\\n        \\n        # And now the main generator loop. The condition is the negation\\n        # of the StopIteration condition for the iterator approach.\\n        while left >= 0 or right < len(nums):\\n            if left < 0:\\n                right += 1\\n                yield nums[right - 1] ** 2\\n            elif right >= len(nums):\\n                left -= 1\\n                yield nums[left + 1] ** 2\\n            else:\\n                left_square = nums[left] ** 2\\n                right_square = nums[right] ** 2\\n                if left_square < right_square:\\n                    left -= 1\\n                    yield left_square\\n                else:\\n                    right += 1\\n                    yield right_square\\n        \\n    \\n    def sortedSquares(self, A: List[int]) -> List[int]:\\n        return list(self.generate_sorted_squares(A))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 222079,
                "title": "python-o-n-10-lines-two-solutions-explained-beats-100",
                "content": "```python\\ndef sortedSquares(self, A):\\n    answer = collections.deque()\\n    l, r = 0, len(A) - 1\\n    while l <= r:\\n        left, right = abs(A[l]), abs(A[r])\\n        if left > right:\\n            answer.appendleft(left * left)\\n            l += 1\\n        else:\\n            answer.appendleft(right * right)\\n            r -= 1\\n    return list(answer)\\n```\\nThe question boils down to understanding that if we look at the magnitude of the elements in the array, `A`, both ends \"slide down\" and converge towards the center of the array. With that understanding, we can use two pointers, one at each end, to iteratively collect the larger square to a list. However, collecting the larger square in a list with `list`\\'s `append`, results in elements sorted in descending order. To circumvent this, we need to append to the left of the list. Using a `collections.deque()` allows us to append elements to the left of `answer` in O(1) time, maintaining the required increasing order.\\n\\n**Alternative without deque or list reversal**\\n```python\\ndef sortedSquares(self, A):\\n    answer = [0] * len(A)\\n    l, r = 0, len(A) - 1\\n    while l <= r:\\n        left, right = abs(A[l]), abs(A[r])\\n        if left > right:\\n            answer[r - l] = left * left\\n            l += 1\\n        else:\\n            answer[r - l] = right * right\\n            r -= 1\\n    return answer\\n```\\nWe first declare a list of length, `len(A)` then add the larger square from the back of the list, denoted by the index `r - l`.\\n\\n**Shorter, terribly unreadable version - 6 lines**\\n```python\\ndef sortedSquares(self, A):\\n    l, r, answer = 0, len(A) - 1, [0] * len(A)\\n    while l <= r:\\n        left, right = abs(A[l]), abs(A[r])\\n        answer[r - l] = max(left, right) ** 2\\n        l, r = l + (left > right), r - (left <= right)\\n    return answer\\n```\\n",
                "solutionTags": [],
                "code": "```python\\ndef sortedSquares(self, A):\\n    answer = collections.deque()\\n    l, r = 0, len(A) - 1\\n    while l <= r:\\n        left, right = abs(A[l]), abs(A[r])\\n        if left > right:\\n            answer.appendleft(left * left)\\n            l += 1\\n        else:\\n            answer.appendleft(right * right)\\n            r -= 1\\n    return list(answer)\\n```\n```python\\ndef sortedSquares(self, A):\\n    answer = [0] * len(A)\\n    l, r = 0, len(A) - 1\\n    while l <= r:\\n        left, right = abs(A[l]), abs(A[r])\\n        if left > right:\\n            answer[r - l] = left * left\\n            l += 1\\n        else:\\n            answer[r - l] = right * right\\n            r -= 1\\n    return answer\\n```\n```python\\ndef sortedSquares(self, A):\\n    l, r, answer = 0, len(A) - 1, [0] * len(A)\\n    while l <= r:\\n        left, right = abs(A[l]), abs(A[r])\\n        answer[r - l] = max(left, right) ** 2\\n        l, r = l + (left > right), r - (left <= right)\\n    return answer\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 973576,
                "title": "a-good-interview-problem-interview-explanation-c",
                "content": "I really like these problems when the right solutions are not that trivial to come by and the solutions actually require some explanation analysis for the advantages and disadvantages.\\n\\nThe obvious/simplest solution would be just using **built in sort** (or code one yourself) and you can say it would work O(NlogN) time / O(1) space. (some python people can say built in works for O(N), but w/e)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& a) {\\n        for (auto &x : a) x *= x;\\n        sort(a.begin(), a.end());\\n        return a;\\n    }\\n};\\n```\\n\\nThe interviewer may easily ask if you could do better time wise ... and well, here, time to think a bit xD\\n\\nOne can do **counting sort** with the constraints of NUM_MAX <= 10^4 are not that big for numbers themselves and scale same as the N <= 10^4 so it would be a good idea. Just need to make every number absolute and count them. O(N) time, O(NUM_MAX <= 10^4) extra space.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& a) {\\n        int j = 0, m = 0;\\n        for (auto &x : a) x = abs(x), m = max(m, x);\\n        vector <int> c(m + 1, 0);\\n        for (auto &x : a) c[x]++; \\n        for (int i = 0; i <= m; i++) \\n            while (c[i]--) \\n                a[j++] = i * i;\\n        return a;\\n    }\\n};\\n```\\n\\n\\nFor people who are here on leetcode for sometime they would come to an idea of two pointers pretty fast, however, with some caveat. \\n\\nFirst why two pointers? Well, after a bit of thinking you may notice that after squaring numbers, all negative numbers are big ... they go down, meet at zero with positive numbers ... and then all those positive numbers are squared. So natural solution of merging two sorted lists from the middle will do. Just use two pointers that go from the middle outwards.\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& a) {\\n        int m = 0, n = a.size(), k = 0;\\n        vector <int> ret(n, 0);\\n        while (m < n && a[m] < 0) m++;\\n        for (auto &x : a) x *= x;\\n        int i = m - 1, j = m;\\n        while (i >= 0 && j < n) {\\n            if (a[i] < a[j]) ret[k++] = a[i--];\\n            else ret[k++] = a[j++];\\n        }\\n        while (i >= 0) ret[k++] = a[i--];\\n        while (j <  n) ret[k++] = a[j++];\\n        return ret;\\n    }\\n};\\n```\\nCleaner implementation of the two pointers is to go from the both ends of the list as the biggest numbers are there and meet in the middle instead. This solution is way nicer to code, but needs a bit of **reverse** thinking ;) \\nO(N) time, O(N) space.\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& a) {\\n        int i = 0, j = a.size() - 1, k = j;\\n        vector <int> ret(k + 1, 0);\\n        while (k >= 0) {\\n            if (abs(a[i]) > abs(a[j])) ret[k--] = a[i] * a[i++];\\n            else ret[k--] = a[j] * a[j--];\\n        }\\n        return ret;\\n    }\\n};\\n```\\n\\nI believe the most important part is to be able to **thoroughly argue**. One must be very thorough in the opinions and not leave anything unanswered as the interviewer will notice some inaccuracies in the explanation right away. It is usually the giveaway if the person has analytical skills to understand problems completely, what those problems would entail, and how different solutions address those problems. \\n\\nTry to argue when would each of the solutions above do great, and when not so great. What if we change contraints (increase, decrease), which solutions would fail, which will thrive? One example is to say that counting sort is actually better when numbers are all NUM_MAX < N, cause that defines extra space and well that would make it a solution that uses less space with the same O(N) time, or if we increase N < 10^7 e.g. \\n\\nI hope that helps everyone to prepare for the coding interview, just give it a thought for every other problem that makes a huge difference :)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Sorting",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& a) {\\n        for (auto &x : a) x *= x;\\n        sort(a.begin(), a.end());\\n        return a;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& a) {\\n        int j = 0, m = 0;\\n        for (auto &x : a) x = abs(x), m = max(m, x);\\n        vector <int> c(m + 1, 0);\\n        for (auto &x : a) c[x]++; \\n        for (int i = 0; i <= m; i++) \\n            while (c[i]--) \\n                a[j++] = i * i;\\n        return a;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& a) {\\n        int m = 0, n = a.size(), k = 0;\\n        vector <int> ret(n, 0);\\n        while (m < n && a[m] < 0) m++;\\n        for (auto &x : a) x *= x;\\n        int i = m - 1, j = m;\\n        while (i >= 0 && j < n) {\\n            if (a[i] < a[j]) ret[k++] = a[i--];\\n            else ret[k++] = a[j++];\\n        }\\n        while (i >= 0) ret[k++] = a[i--];\\n        while (j <  n) ret[k++] = a[j++];\\n        return ret;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& a) {\\n        int i = 0, j = a.size() - 1, k = j;\\n        vector <int> ret(k + 1, 0);\\n        while (k >= 0) {\\n            if (abs(a[i]) > abs(a[j])) ret[k--] = a[i] * a[i++];\\n            else ret[k--] = a[j] * a[j--];\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1463098,
                "title": "o-n-detailed-aproach",
                "content": "**Brute Force Approach**\\nSquares of sorted array seems like the easiest problem, if you try to solve it in **O(nlogn) **approach\\n```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        for(int i = 0;i<nums.length;i++)\\n        {\\n            nums[i] *= nums[i];\\n        }\\n        Arrays.sort(nums);\\n        return nums;\\n    }\\n}\\n```\\n**Optimized Approach**\\nBut if you want to solve the problem in **O(n)** then it needs brainstorming to find the approach.\\nInput: nums = [-7,-3,2,3,11]\\nIf we see the elements with their absolute value then will get to know the element at the start and the last can be the highest value.\\nSo we use this approach to find our solution, by using the two pointer solution\\nTaking one pointer at the start of the array and then another pointer at the last of the array, and then compare these values\\n{7,-3,0,3,9,11}\\nMath.abs(-7) < Math.abs(11)\\n\\n{ , , , ,121} in the resultant array\\n\\nby this we will get the last element of the last array and we can store that value to the resultant array\\n\\nrepeat the same method until left\\u2264right.\\n```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int left = 0;\\n        int right = nums.length -1;\\n        int index = nums.length- 1;\\n        int result[] = new int [nums.length];\\n        while(left<=right)\\n        {\\n            if(Math.abs(nums[left])>Math.abs(nums[right]))\\n            {\\n                result[index] = nums[left] * nums[left];\\n                left++;\\n            }\\n            else\\n            {\\n                result[index] = nums[right] * nums[right];\\n                right--;\\n            }\\n            index--;\\n        }\\n        return result;\\n    }\\n}``\\n```\\n\\n**DO UPVOTE IF YOU LIKE THE SOLUTION**",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        for(int i = 0;i<nums.length;i++)\\n        {\\n            nums[i] *= nums[i];\\n        }\\n        Arrays.sort(nums);\\n        return nums;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int left = 0;\\n        int right = nums.length -1;\\n        int index = nums.length- 1;\\n        int result[] = new int [nums.length];\\n        while(left<=right)\\n        {\\n            if(Math.abs(nums[left])>Math.abs(nums[right]))\\n            {\\n                result[index] = nums[left] * nums[left];\\n                left++;\\n            }\\n            else\\n            {\\n                result[index] = nums[right] * nums[right];\\n                right--;\\n            }\\n            index--;\\n        }\\n        return result;\\n    }\\n}``\\n```",
                "codeTag": "Java"
            },
            {
                "id": 283978,
                "title": "python-two-pointers",
                "content": "```\\nclass Solution:\\n    def sortedSquares(self, A: List[int]) -> List[int]:\\n        result = [None for _ in A]\\n        left, right = 0, len(A) - 1\\n        for index in range(len(A)-1, -1, -1):\\n            if abs(A[left]) > abs(A[right]):\\n                result[index] = A[left] ** 2\\n                left += 1\\n            else:\\n                result[index] = A[right] ** 2\\n                right -= 1\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def sortedSquares(self, A: List[int]) -> List[int]:\\n        result = [None for _ in A]\\n        left, right = 0, len(A) - 1\\n        for index in range(len(A)-1, -1, -1):\\n            if abs(A[left]) > abs(A[right]):\\n                result[index] = A[left] ** 2\\n                left += 1\\n            else:\\n                result[index] = A[right] ** 2\\n                right -= 1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 410331,
                "title": "java-o-n-two-pointer-w-comments-beats-100",
                "content": "```java\\npublic int[] sortedSquares(int[] A) {\\n\\t//result array\\n\\tint[] res = new int[A.length];\\n\\t//pointers for left and right\\n\\tint lo = 0; int hi = A.length - 1;\\n\\t//iterate from n to 0\\n\\tfor (int i = A.length - 1; i >= 0; i--) {\\n\\t\\t//check if abs left is less than or equal to abs right\\n\\t\\tif (Math.abs(A[lo]) >= Math.abs(A[hi])) {\\n\\t\\t\\t//add left squared to result array\\n\\t\\t\\tres[i] = A[lo] * A[lo];\\n\\t\\t\\t//increment left pointer\\n\\t\\t\\tlo++;\\n\\t\\t} else {\\n\\t\\t\\t//add right squared to result array\\n\\t\\t\\tres[i] = A[hi] * A[hi];\\n\\t\\t\\t//decrement right pointer\\n\\t\\t\\thi--;\\n\\t\\t}\\n\\t}\\n\\t//result\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```java\\npublic int[] sortedSquares(int[] A) {\\n\\t//result array\\n\\tint[] res = new int[A.length];\\n\\t//pointers for left and right\\n\\tint lo = 0; int hi = A.length - 1;\\n\\t//iterate from n to 0\\n\\tfor (int i = A.length - 1; i >= 0; i--) {\\n\\t\\t//check if abs left is less than or equal to abs right\\n\\t\\tif (Math.abs(A[lo]) >= Math.abs(A[hi])) {\\n\\t\\t\\t//add left squared to result array\\n\\t\\t\\tres[i] = A[lo] * A[lo];\\n\\t\\t\\t//increment left pointer\\n\\t\\t\\tlo++;\\n\\t\\t} else {\\n\\t\\t\\t//add right squared to result array\\n\\t\\t\\tres[i] = A[hi] * A[hi];\\n\\t\\t\\t//decrement right pointer\\n\\t\\t\\thi--;\\n\\t\\t}\\n\\t}\\n\\t//result\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 221924,
                "title": "c-java-4-lines-o-n-inside-out-or-outside-in",
                "content": "We find the first non-negative element in the array. From there, we move \\'negative\\' pointer (```np```) towards zero, and \\'positive\\' pointer (```pp```) towards the end of the array, selecting the next square.\\n```\\nvector<int> sortedSquares(vector<int>& A) {\\n  vector<int> res;\\n  int pvt = lower_bound(begin(A), end(A), 0) - begin(A);\\n  for (int pp = pvt, pn = pvt - 1; pp < A.size() || pn >= 0;) {\\n    if (abs(pn >= 0 ? A[pn] : INT_MAX) < abs(pp < A.size() ? A[pp] : INT_MAX))\\n      res.push_back(pow(A[pn--], 2));\\n    else res.push_back(pow(A[pp++], 2));\\n  }\\n  return res;\\n}\\n```\\nIn a way, we are going *inside out* and filling our result vector from the beginning. Alternativelly, we can go *outside in* and fill the result in the reverse order:\\n```\\nvector<int> sortedSquares(vector<int>& A) {\\n  vector<int> res(A.size());\\n  for (int pn = 0, pp = A.size() - 1, pos = A.size() - 1; pn <= pp; --pos)\\n    res[pos] = pow(abs(A[pn]) < abs(A[pp]) ? A[pp--] : A[pn++], 2);\\n  return res;\\n}  \\n```\\nJava version:\\n```\\npublic int[] sortedSquares(int[] A) {\\n  int[] res = new int[A.length];\\n  for (int pn = 0, pp = A.length - 1, pos = A.length - 1; pn <= pp; --pos)\\n    res[pos] = (int)Math.pow(Math.abs(A[pn]) < Math.abs(A[pp]) ? A[pp--] : A[pn++], 2);\\n  return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```np```\n```pp```\n```\\nvector<int> sortedSquares(vector<int>& A) {\\n  vector<int> res;\\n  int pvt = lower_bound(begin(A), end(A), 0) - begin(A);\\n  for (int pp = pvt, pn = pvt - 1; pp < A.size() || pn >= 0;) {\\n    if (abs(pn >= 0 ? A[pn] : INT_MAX) < abs(pp < A.size() ? A[pp] : INT_MAX))\\n      res.push_back(pow(A[pn--], 2));\\n    else res.push_back(pow(A[pp++], 2));\\n  }\\n  return res;\\n}\\n```\n```\\nvector<int> sortedSquares(vector<int>& A) {\\n  vector<int> res(A.size());\\n  for (int pn = 0, pp = A.size() - 1, pos = A.size() - 1; pn <= pp; --pos)\\n    res[pos] = pow(abs(A[pn]) < abs(A[pp]) ? A[pp--] : A[pn++], 2);\\n  return res;\\n}  \\n```\n```\\npublic int[] sortedSquares(int[] A) {\\n  int[] res = new int[A.length];\\n  for (int pn = 0, pp = A.length - 1, pos = A.length - 1; pn <= pp; --pos)\\n    res[pos] = (int)Math.pow(Math.abs(A[pn]) < Math.abs(A[pp]) ? A[pp--] : A[pn++], 2);\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 285251,
                "title": "javascript-two-pointers-solution",
                "content": "Since we know that the source array is sorted, it is obvious that the largest numbers (by absolute value) are at the edges of the array, gradually decreasing towards the middle. So two pointers technique is ideal here.\\n\\n```\\n/**\\n * @param {number[]} A\\n * @return {number[]}\\n */\\nvar sortedSquares = function(A) {\\n    let result = [];\\n    let l = 0;\\n    let r = A.length - 1;\\n    let p = r;\\n\\n    while (l <= r) {\\n        if (A[l] ** 2 > A[r] ** 2) {\\n            result[p--] = A[l++] ** 2;\\n        } else {\\n            result[p--] = A[r--] ** 2;\\n        }\\n    }\\n    \\n    return result;\\n};\\n```\\nTime complexity: `O(n)`\\nSpace complexity: `O(n)`",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * @param {number[]} A\\n * @return {number[]}\\n */\\nvar sortedSquares = function(A) {\\n    let result = [];\\n    let l = 0;\\n    let r = A.length - 1;\\n    let p = r;\\n\\n    while (l <= r) {\\n        if (A[l] ** 2 > A[r] ** 2) {\\n            result[p--] = A[l++] ** 2;\\n        } else {\\n            result[p--] = A[r--] ** 2;\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1102204,
                "title": "javascript-two-pointers-o-n",
                "content": "```\\nvar sortedSquares = function(nums) {\\n    // use two pointers\\n    // create a new array\\n    const result = new Array(nums.length);\\n    let left = 0, \\n        right = nums.length - 1;\\n    \\n\\t// don\\'t want to rearrange the array, so iterating the array in descending order \\n    for (let i = nums.length - 1; i >= 0; i--) {\\n        if (Math.abs(nums[left]) < Math.abs(nums[right])) {\\n            result[i] = nums[right] ** 2\\n            right--;\\n        } else {\\n            result[i] = nums[left] ** 2\\n            left++;\\n        }\\n    }\\n    \\n    return result;\\n};\\n```\\n\\nRuntime: 96 ms, faster than 99.97% of JavaScript online submissions for Squares of a Sorted Array.\\nMemory Usage: 45.6 MB, less than 21.94% of JavaScript online submissions for Squares of a Sorted Array.\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers",
                    "Iterator"
                ],
                "code": "```\\nvar sortedSquares = function(nums) {\\n    // use two pointers\\n    // create a new array\\n    const result = new Array(nums.length);\\n    let left = 0, \\n        right = nums.length - 1;\\n    \\n\\t// don\\'t want to rearrange the array, so iterating the array in descending order \\n    for (let i = nums.length - 1; i >= 0; i--) {\\n        if (Math.abs(nums[left]) < Math.abs(nums[right])) {\\n            result[i] = nums[right] ** 2\\n            right--;\\n        } else {\\n            result[i] = nums[left] ** 2\\n            left++;\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2672974,
                "title": "js-two-pointers-85-with-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/92e8f912-6d40-492d-8d31-fa705da87411_1665151374.3462088.png)\\n\\nTwo pointers is the use of two different pointers (usually to keep track of array or string indexes) to solve a problem with specified indexes in order to save time and space.\\n\\nIn solving this problem, we alternately compare the values by indexes of pointers, and depending on whether one or another value is greater than another, we shift the pointers until we go through the entire array. To create a new sorted array, we also create an additional index variable so as not to affect the already added (sorted values).\\n\\n![image](https://assets.leetcode.com/users/images/5df0d2ab-6066-4948-90b9-e47ac2c572f0_1665156031.6328247.png)\\n\\n\\n```\\nvar sortedSquares = function(nums) {\\n    let start = 0;\\n    let end = nums.length - 1;\\n    let idx = end;\\n    let sortPowArr = [];\\n\\n    while (idx > -1) {\\n        if (Math.abs(nums[start]) > Math.abs(nums[end])) {\\n            sortPowArr[idx--] = nums[start] * nums[start];\\n            start++;\\n        } else {\\n            sortPowArr[idx--] = nums[end] * nums[end];\\n            end--;\\n        }\\n    }\\n    return sortPowArr;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nvar sortedSquares = function(nums) {\\n    let start = 0;\\n    let end = nums.length - 1;\\n    let idx = end;\\n    let sortPowArr = [];\\n\\n    while (idx > -1) {\\n        if (Math.abs(nums[start]) > Math.abs(nums[end])) {\\n            sortPowArr[idx--] = nums[start] * nums[start];\\n            start++;\\n        } else {\\n            sortPowArr[idx--] = nums[end] * nums[end];\\n            end--;\\n        }\\n    }\\n    return sortPowArr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1759948,
                "title": "c-efficient-two-pointers-tc-o-n-sc-o-n-with-explanation",
                "content": "##### If you understand the approach please please upvote!!!\\uD83D\\uDC4D\\n***Thanks :)***\\n\\n* Since we need to put squeres in result array, we can consider that all numbers are positive\\n* Let\\'s take example with negative and positive numbers, like: `[-4, -2, 0, 1, 3]` => `[4, 2, 0, 1, 3]`\\n* Now, we can have two pointers `low` to left most element, `high` to most right element.\\n* Create `v` result array/vector same size as ` nums `.\\n* Move from right to left in resutl array `v`  whit the help of `k` , and put squares  of` max(abs(nums[low]), abs(nums[high]) ),` move correspondingly`low++` or `high--`\\n\\n*Time Complexity: O (n)\\nSpace Complexity: O (n)*\\n#### C++ code:\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int n=nums.size();\\n        int low=0;\\n        int high=n-1;\\n        \\n        vector<int>v(n);//resutl vector\\n        int k=n-1;//start traversing for the end of v till 0   \\n        \\n        while(low<=high){\\n            if(abs(nums[low]) > abs(nums[high])){\\n                v[k--]=nums[low] * nums[low];\\n                low++;\\n            }else{\\n                v[k--]=nums[high] * nums[high];\\n                high--;\\n            }\\n        }\\n        return v; \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int n=nums.size();\\n        int low=0;\\n        int high=n-1;\\n        \\n        vector<int>v(n);//resutl vector\\n        int k=n-1;//start traversing for the end of v till 0   \\n        \\n        while(low<=high){\\n            if(abs(nums[low]) > abs(nums[high])){\\n                v[k--]=nums[low] * nums[low];\\n                low++;\\n            }else{\\n                v[k--]=nums[high] * nums[high];\\n                high--;\\n            }\\n        }\\n        return v; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2336381,
                "title": "one-liner-two-pointer-explanation-python",
                "content": "One Liner:\\nThis is probably what comes first to your mind. Why not just find all squares and sort them. Simple right? But this will give you an `O(n*logn)` solution. Which is good but we can do better than this.\\n```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        return sorted([num ** 2 for num in nums])\\n```\\n\\nTwo Pointer Solution:\\nWe know our input is always sorted. So the largest squared values are on left and right sides of the input. So we can use 2 pointers `(l, r)` to compared the left and right most values and insert the larger ones to the resultant list.\\nBut when we add larger ones first, we have a list that\\'s in descending order. We want the result to be in ascending order. We can simply reverse the resultant list to get that.\\nThis 2 pointer approach will give us a `O(n)` solutions.\\n```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        l, r = 0, len(nums) - 1 # Initialise 2 pointers\\n        res = [] # initialise the result list\\n\\n        while l <= r: # continue the loop untill we go through all values, either with left pointer or with right pointer\\n            if abs(nums[l]) > abs(nums[r]):\\n\\t\\t\\t\\t# If the absolute value at left pointer is bigger, we know the square of left value will be bigger than the right one\\n                res.append(nums[l]**2)\\n                l += 1 # increment pointer because we can now look at the next value\\n            else:\\n\\t\\t\\t\\t# If left is not bigger, it\\'s either equal or right value is bigger. In both cases, we can add right value to the result.\\n                res.append(nums[r]**2)\\n                r -= 1 # decrement pointer to go to the previous value\\n        return res[::-1]\\n```\\n\\nMinor optimisation:\\nIn the above algorithm, we reverse the output which is a `O(n)` operation. Which can be avoided by creating a result list of the same length with dummy values (I\\'m taking 0s here but this doesn\\'t actually matter). The thing to keep in mind is that, we\\'re finding the largest values one by one. So we have to fill the result from the right end, or the starting index will be `len(nums) - 1`. We keep decrementing this value as we add more values to the result.\\n\\n```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        l, r = 0, len(nums) - 1\\n        res = [0] * len(nums) # create a result list with dummy values\\n        i = len(nums) - 1 # index on which we will fill the result\\n\\n        while l <= r:\\n            if abs(nums[l]) > abs(nums[r]):\\n                res[i] = nums[l]**2\\n                l += 1\\n            else:\\n                res[i] = nums[r]**2\\n                r -= 1\\n            i -= 1 # we have filled the result on this index, now we go to the index one lesser than this\\n        return res\\n```\\n\\nPlease upvote if you found this useful!",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        return sorted([num ** 2 for num in nums])\\n```\n```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        l, r = 0, len(nums) - 1 # Initialise 2 pointers\\n        res = [] # initialise the result list\\n\\n        while l <= r: # continue the loop untill we go through all values, either with left pointer or with right pointer\\n            if abs(nums[l]) > abs(nums[r]):\\n\\t\\t\\t\\t# If the absolute value at left pointer is bigger, we know the square of left value will be bigger than the right one\\n                res.append(nums[l]**2)\\n                l += 1 # increment pointer because we can now look at the next value\\n            else:\\n\\t\\t\\t\\t# If left is not bigger, it\\'s either equal or right value is bigger. In both cases, we can add right value to the result.\\n                res.append(nums[r]**2)\\n                r -= 1 # decrement pointer to go to the previous value\\n        return res[::-1]\\n```\n```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        l, r = 0, len(nums) - 1\\n        res = [0] * len(nums) # create a result list with dummy values\\n        i = len(nums) - 1 # index on which we will fill the result\\n\\n        while l <= r:\\n            if abs(nums[l]) > abs(nums[r]):\\n                res[i] = nums[l]**2\\n                l += 1\\n            else:\\n                res[i] = nums[r]**2\\n                r -= 1\\n            i -= 1 # we have filled the result on this index, now we go to the index one lesser than this\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1181063,
                "title": "java-clean-concise-code-two-pointer-technique-100-optimal-faster-solution",
                "content": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        \\n        int[] answer = new int[nums.length];\\n        int i = 0, j = nums.length - 1, k = nums.length - 1;\\n        \\n        while (k >= 0) {\\n            if (Math.abs (nums[i]) > Math.abs (nums[j])) {\\n                answer[k--] = nums[i] * nums[i++];\\n            }\\n            else {\\n                answer[k--] = nums[j] * nums[j--];\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n\\n**LOVE CODING :)\\nHAPPY CODING :)\\nHAPPY LEARNING :)**",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        \\n        int[] answer = new int[nums.length];\\n        int i = 0, j = nums.length - 1, k = nums.length - 1;\\n        \\n        while (k >= 0) {\\n            if (Math.abs (nums[i]) > Math.abs (nums[j])) {\\n                answer[k--] = nums[i] * nums[i++];\\n            }\\n            else {\\n                answer[k--] = nums[j] * nums[j--];\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3110139,
                "title": "beats-100-c-two-pinter-very-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIdea is array is already sorted so no need to first take all the elemnts and then sort and also making tc  nlogn either we will do two pointer appraoch and check absolute value form start and last where they can be placed .\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTwo Pointer Appraoch :\\n- Keep two pinters and check if (magnitude wise i,e take abs) $$arr[i]>arr[j] $$push $$arr[i]^2 $$else push $$arr[j]^2$$\\n# Complexity\\n- Time complexity:$$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<int>ans(n);\\n        int i=0,j=n-1,k=n-1;\\n        while(i<=j){\\n            if(abs(arr[i])>abs(arr[j])){\\n                ans[k--]=(arr[i]*arr[i]),i++;\\n            }\\n            else ans[k--]=(arr[j]*arr[j]),j--;\\n        }\\n        //reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<int>ans(n);\\n        int i=0,j=n-1,k=n-1;\\n        while(i<=j){\\n            if(abs(arr[i])>abs(arr[j])){\\n                ans[k--]=(arr[i]*arr[i]),i++;\\n            }\\n            else ans[k--]=(arr[j]*arr[j]),j--;\\n        }\\n        //reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 251088,
                "title": "c-solution",
                "content": "```C\\nint *sortedSquares(int *A, int ASize, int *returnSize) {\\n    int *result = malloc(sizeof(int) * (*returnSize = ASize)), *p = A, *q = A + ASize - 1;\\n    int index = ASize - 1;\\n    while (p <= q) {\\n        *p = *p > 0 ? *p : *p * -1;\\n        *q = *q > 0 ? *q : *q * -1;\\n        if (*p >= *q) {\\n            result[index--] = *p * (*p);\\n            p++;\\n        } else {\\n            result[index--] = *q * (*q);\\n            q--;\\n        }\\n    }\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```C\\nint *sortedSquares(int *A, int ASize, int *returnSize) {\\n    int *result = malloc(sizeof(int) * (*returnSize = ASize)), *p = A, *q = A + ASize - 1;\\n    int index = ASize - 1;\\n    while (p <= q) {\\n        *p = *p > 0 ? *p : *p * -1;\\n        *q = *q > 0 ? *q : *q * -1;\\n        if (*p >= *q) {\\n            result[index--] = *p * (*p);\\n            p++;\\n        } else {\\n            result[index--] = *q * (*q);\\n            q--;\\n        }\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3189378,
                "title": "python-two-pointer-clean-simple-o-n-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere, We are having many solutions but here i am showing you just 2. \\n1. We are having a **Two Pointer** approach which should work well.\\n    - Here we had one pointer $$i$$ at $$start$$ index, second pointer $$j$$ at $$end$$ index , a list $$ans$$ of size n, and a $$k$$ pointer to update value in $$ans$$ list.\\n    - Then, we start comapring absolute value in nums where pointers are pointing.\\n    - ` if abs(nums[l]) > nums[r]:`\\n    - So, we update value at $$k$$ position in ans with ` nums[l] * nums[l]`.\\n    - ` else:`\\n    - Update value at $$k$$ position in ans with ` nums[r] * nums[r]`.\\n2. **List Comprehension + Sorting:** \\n    - Here, we are making a list with square of nums using list comprehension and making it sort and directly returning it.\\n\\n# Code\\n## 1. Two Pointer Approach :\\n\\n### Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        \\n        # Two Pointer Approach\\n        n = len(nums)\\n        l, r = 0, n - 1\\n        k = n - 1\\n        ans = [0] * n\\n        while k >= 0:\\n            if abs(nums[l]) > nums[r]:\\n                ans[k] = nums[l] * nums[l]\\n                l += 1\\n            else:\\n                ans[k] = nums[r] * nums[r]\\n                r -= 1\\n            k -= 1\\n        return ans\\n\\n```\\n## 2. List Comprehension + Sorting :\\n\\n### Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        \\n        # One Liner\\n        return sorted([num * num for num in nums])\\n        \\n```\\n- Here I personally felt **List Comprehension + Sorting** isn\\'t fast but this approach give me fast runtime in submission.\\n- So, don\\'t know what\\'s wrong with leetcode runtime checking algorithm.\\n- If anyone have suggestion please comment it.\\n- If you found it helpful please upvote, it helps to create such a more content.",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        \\n        # Two Pointer Approach\\n        n = len(nums)\\n        l, r = 0, n - 1\\n        k = n - 1\\n        ans = [0] * n\\n        while k >= 0:\\n            if abs(nums[l]) > nums[r]:\\n                ans[k] = nums[l] * nums[l]\\n                l += 1\\n            else:\\n                ans[k] = nums[r] * nums[r]\\n                r -= 1\\n            k -= 1\\n        return ans\\n\\n```\n```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        \\n        # One Liner\\n        return sorted([num * num for num in nums])\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2943161,
                "title": "full-description-on-how-to-solve-using-two-pointers-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe will use two pointers approach to solve this problem. The given array is **sorted** means the **square** of the elements present at either the **leftmost side** and the **rightmost side** is the greatest.\\n\\nExample:-\\n$$nums = [-14,-1,0,3,10]$$ \\nSquare of -14 is the greatest of all sqaures.\\n\\n$$nums = [-7,-3,2,3,11]$$\\nSquare of 11 is the greatest of all sqaures, followed by square of -7.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe have taken two pointers: `left` and `right`.\\n\\n`left` initially points to first element of the given array whereas `right` points to last element of the given array.\\n\\nNow,lets run a `while()`loop with the condition`left<=right`. The condition means that we will perform particular operations till `left` pointer is either before, or at the same position as the `right` pointer.\\n\\ni.e.: \\n![My First Board.jpg](https://assets.leetcode.com/users/images/f2e94a4b-3268-4299-98b3-dff8d7e2550f_1671818204.6543193.jpeg)\\n\\n*left pointer cannot go ahead of right pointer but both can be at same position therefore \\'=\\' sign is also used in the condition.*\\n\\n---\\n\\nNow, lets understand the body of the while loop, which is the main algorithm of our code.\\n\\n**Firstly :-** We compare the abs values pointed by the `left` and `right` pointers and store it in the `max` variable. We will use ternary operator for this task. \\n\\n***Moving the pointers***\\n We also need to move the pointers so we check which pointer\\'s value `max` is storing. So we use an `if()`loop here with the condition `max==nums[right]`, if the condition is *true*, it means abs value pointed by `right` is greater than the abs value pointed by `left`, so we move right pointer by one position i.e., `right--`. If the condition is false, we move the left pointer.\\n\\n**Lastly :-** We store the square of the greater value i.e., `max*max` and store it in `ans[k]`. `K` is a variable used for the resultant array, initially pointing to last index of the `ans`. After storing the value, we decrement the value of k.\\n\\n---\\n\\n\\n\\n\\n\\n**Variables and their use in the code:**\\n- `left` : left pointer, initial value = 0, points to 1st element of the array.\\n- `right`: right pointer, initial value = `nums.length-1` i.e., points to the last value of the array.\\n- `k`: used to store values in the new array `ans`. Initial value of `nums.length-1` i.e. points to last position in the resultant array as we will eneter elements from right to left.\\n- `max`: used to store the greater of the two number pointed by `left` and `right`.\\n\\n**Java Code**\\n```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int left=0, right=nums.length-1;\\n        int ans[]= new int[nums.length];\\n        int k=nums.length-1;\\n        while(left<=right){\\n            int max=(Math.abs(nums[left])<Math.abs(nums[right])? nums[right]: nums[left]);\\n            if(max==nums[right])\\n                right--;\\n                else \\n                    left++;\\n            ans[k]=max*max;\\n            k--;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int left=0, right=nums.length-1;\\n        int ans[]= new int[nums.length];\\n        int k=nums.length-1;\\n        while(left<=right){\\n            int max=(Math.abs(nums[left])<Math.abs(nums[right])? nums[right]: nums[left]);\\n            if(max==nums[right])\\n                right--;\\n                else \\n                    left++;\\n            ans[k]=max*max;\\n            k--;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783139,
                "title": "c-concise-o-n-solution",
                "content": "C# doesn\\'t get enough love here, but here\\'s a fairly simple/intuitive example of a concise one pass solution using C#\\n\\n```\\n    public int[] SortedSquares(int[] nums) {\\n        var arr = new int[nums.Length];\\n        int begIndex = 0;\\n        int endIndex = nums.Length-1;\\n        int end = endIndex;\\n        while (begIndex <= endIndex)\\n            arr[end--] = Math.Abs(nums[endIndex]) > Math.Abs(nums[begIndex])\\n                ? nums[endIndex] * nums[endIndex--]\\n                : nums[begIndex] * nums[begIndex++];\\n        return arr;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "C#"
                ],
                "code": "```\\n    public int[] SortedSquares(int[] nums) {\\n        var arr = new int[nums.Length];\\n        int begIndex = 0;\\n        int endIndex = nums.Length-1;\\n        int end = endIndex;\\n        while (begIndex <= endIndex)\\n            arr[end--] = Math.Abs(nums[endIndex]) > Math.Abs(nums[begIndex])\\n                ? nums[endIndex] * nums[endIndex--]\\n                : nums[begIndex] * nums[begIndex++];\\n        return arr;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1467196,
                "title": "intuition-java-two-pointer-plots-visualization",
                "content": "**If you guys are thinking about the intuition behind this two pointer algorithm , This article is for you!!**\\n\\nConsider , \\nInput:  nums = [-4,-1,0,3,10]\\nafter squaring we will get [16,1,0,9,100]\\nif we plot this points as (0,16), (1,1), (2,0), (3,9), (4,100)\\nwe will get the following plots\\n![image](https://assets.leetcode.com/users/images/d4dd8182-3262-4df3-aa1e-571c7386451f_1631786175.9753773.png)\\nOur goal is to find squares of sorted array , So by seeing the plot we can make out the maximum value is 100. Here, max value is on extreme right.\\n\\nNow, we can similarly think about these two plots\\n\\n![image](https://assets.leetcode.com/users/images/c4528640-9431-4a9a-95d3-aac7586ef67c_1631786259.1755123.png)\\n Here, max value is on extreme left.\\n \\n![image](https://assets.leetcode.com/users/images/2820deda-263c-4f87-9455-c27b6679285d_1631786303.2714875.png)\\n Here, max value is present on extreme left as well as extreme right.\\n \\n \\n Till here, we have understood that to get max value in entire array we have to check for extreme left and right, hence we fill our answer array in reverse manner.\\n So we keep two pointers at extreme ends and check which square is greatest among them and finally place it in answer array, similarly we will do for all elements.\\n \\n \\n \\n ```\\n \\n public int[] sortedSquares(int[] nums) {\\n        \\n        int i = 0; //pointer at extreme left\\n        int j = nums.length-1;//pointer at extreme right\\n        int k = nums.length-1;//used for filling answer array in reverse\\n        \\n        int[]ans = new int[nums.length];\\n        \\n        while(i<=j)\\n        {\\n            int v1 = nums[i];\\n            int v2 = nums[j];\\n            int sq1 = v1*v1;\\n            int sq2 = v2*v2;\\n            if( sq1 < sq2)\\n            {\\n                ans[k--] = sq2;\\n                j--;\\n            }\\n            else\\n            {\\n                ans[k--] = sq1;\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\t\\n ```\\n \\n \\n Time Complexity: O(N)\\n Auxillary Space: O(1) \\n\\n**NOTE : since the function itself is expecting from us to return answer in an array , it is not considered in auxiliary space.**\\n\\n\\n# YOU ALL CAN BUY ME A COFFEE AT \\uD83D\\uDC47\\n https://www.buymeacoffee.com/deepakgupta",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\n \\n public int[] sortedSquares(int[] nums) {\\n        \\n        int i = 0; //pointer at extreme left\\n        int j = nums.length-1;//pointer at extreme right\\n        int k = nums.length-1;//used for filling answer array in reverse\\n        \\n        int[]ans = new int[nums.length];\\n        \\n        while(i<=j)\\n        {\\n            int v1 = nums[i];\\n            int v2 = nums[j];\\n            int sq1 = v1*v1;\\n            int sq2 = v2*v2;\\n            if( sq1 < sq2)\\n            {\\n                ans[k--] = sq2;\\n                j--;\\n            }\\n            else\\n            {\\n                ans[k--] = sq1;\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\t\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1477544,
                "title": "go-o-n-solution-with-explanation",
                "content": "**Explanation - Code at bottom**\\nWe know that a non-decreasing array means that the numbers will be sorted from the smallest to the largest - with the lowest negative number on the far left, and the greatest positive number on the far right.\\n\\nTake a look at example 1 from the problem: nums = [-4, -1, 0, 3, 10].\\n\\nLet\\'s explore those numbers in the array to see if we can identify a pattern. \\n\\nIf we square every number in the list we arrive at [16, 1, 0, 9, 100]. We can see that squared negative numbers results in a positive integer - so whether we square the negatives or we square the absolute values, we arrive at the same result.\\n\\nSquaring the absolute values [4, 1, 0, 3, 10] gives us a new array of [16, 1, 0, 9, 100].\\nSquaring the negative values [-4, -1, 0, 3, 10] gives us a new array of [16, 1, 0, 9, 100]\\n\\nAgain, because the given array is in non-decreasing order we know that the largest value will always be either the absolute value of the first number of the given array or the absolute value of the last number of the given array.\\n\\nKnowing this, we can start off by comparing the absolute values of the first and last indices of the given array to determine which is larger. We can then append the largest of the two to the last index of our new array.\\n\\nSo, is the absolute value of -4 less than the absolute value of 10? Yes, because 16 is less than 100. So we can add the square of 10 to the last index in our new array.\\n\\n[null, null, null, null, 100]\\n\\nNow that we have added the last index of the given array, we can ignore that index from here on out. \\n\\n[-4, -1, 0, 3]\\n\\nThe largest absolute value on the right is now 3. Let\\'s compare the squared absolute value of 3 to the outermost index on the left - again, this is -4.\\n\\n(abs(-4))^2 = 16\\n(abs(93))^2 = 9\\n\\n16 is greater than 9, so the next number to be added to our new array is 16.\\n\\n[null, null, null, 16, 100]\\n\\nWe now ignore the initial first index, as it\\'s square has already been placed in our new array, and focus on the remaining given array. \\n\\n[-1, 0, 3]\\n\\nAgain, we know the next largest squared number will come from one of the two outside numbers. So let\\'s find it.\\n\\n(abs(-1))^2 = 1\\n(abs(3))^2 = 9\\n\\n9 is greater than 1 so let\\'s add it to our new array.\\n\\n[null, null, 9, 16, 100]\\n\\nThat means our given array is now\\n\\n[-1, 0]\\n\\nAgain, we are going to compare the left-most and right-most indices.\\n\\n(abs(-1))^2 = 1\\n(abs(0))^2 - 0\\n\\n1 is greater than 0 so let\\'s add it to our new array.\\n\\n[null, 1, 9, 16, 100]\\n\\nWe have one remaining index from our given array so let\\'s add it.\\n\\n[0, 1, 9, 16, 100]\\n\\nWe have taken each index from the given array, squared it, then placed it sorted within a new array.\\n\\n*Of note, we can square the numbers before or after the comparison and get the same result.*\\n\\nabsolute(-4) < absolute(10) and (absolute(-4))^2 < (absolute(10))^2\\n\\n**Let\\'s code this algorithm in Go.**\\n\\nStart by getting the length of whatever the input array is.\\n\\n`n := len(nums)`\\n\\nNext, create our new slice, of type int and size n, that will contain the sorted squares. We can call it result. \\n\\n`result := make([]int, n)`\\n\\nWe can now create our left and right pointers.\\n\\n`left, right := 0, n - 1`\\n\\n*Note: We are using n - 1 here because there are n items in the array, starting at 1, but the index always starts with 0. So the final index of the array is n - 1.*\\n\\nWe can now start filling in our new array from the last index to the start. So, from n - 1 to 0.\\n\\nLet\\'s declare a square variable.\\n\\n`square := 0`\\n\\nNow we need to compare the absolute values. We can use the math package, but I will just create our own function that returns the absolute value:\\n\\n```\\n// function to get the absolute value\\nfunc Abs(x int) int {\\n    if x < 0 {\\n        return -x\\n    }\\n    \\n    return x\\n}\\n```\\n\\nWithin our for loop iterating over our new slice in reverse, let\\'s compare the absolute values of each pointer and set square to the largest one and adjust the pointer at that value.\\n\\n```\\nfor i := n - 1; i >= 0; i-- {\\n        square := 0\\n        \\n        if Abs(nums[left]) < Abs(nums[right]) {\\n            square = nums[right]\\n            right--\\n        } else {\\n            square = nums[left]\\n            left ++\\n        }\\n    }\\n```\\n\\n**Here is the final code with comments:**\\n\\n```\\n// function to get the absolute value\\nfunc Abs(x int) int {\\n    if x < 0 {\\n        return -x\\n    }\\n    \\n    return x\\n}\\n\\n// main function to get the sorted squares array\\nfunc sortedSquares(nums []int) []int {\\n    \\n    n := len(nums) // get the length of the given array\\n    result := make([]int, n) // create a new slice of type int that can hold n values\\n    \\n    // left and right pointers\\n    left, right := 0, n - 1\\n    \\n    // iterate through our new slice (result) in reverse as we will be adding numbers from largest to smallest\\n    for i := n - 1; i >= 0; i-- {\\n        square := 0 // the variable that will store the largest absolute value of the two pointers\\n        \\n        // if the absolute value of the left pointer is less than the absolute value of the right pointer, \\n        // set square to the larger number from the right pointer and move the right pointer one left.\\n        // Else set square to the larger number from the left pointer and move the left pointer one right.\\n        if Abs(nums[left]) < Abs(nums[right]) {\\n            square = nums[right]\\n            right--\\n        } else {\\n            square = nums[left]\\n            left ++\\n        }\\n        \\n        // square the value and add it to the appropriate index\\n        result[i] = square * square\\n    }\\n    \\n    // return the sorted array with the squared values\\n    return result\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Two Pointers"
                ],
                "code": "```\\n// function to get the absolute value\\nfunc Abs(x int) int {\\n    if x < 0 {\\n        return -x\\n    }\\n    \\n    return x\\n}\\n```\n```\\nfor i := n - 1; i >= 0; i-- {\\n        square := 0\\n        \\n        if Abs(nums[left]) < Abs(nums[right]) {\\n            square = nums[right]\\n            right--\\n        } else {\\n            square = nums[left]\\n            left ++\\n        }\\n    }\\n```\n```\\n// function to get the absolute value\\nfunc Abs(x int) int {\\n    if x < 0 {\\n        return -x\\n    }\\n    \\n    return x\\n}\\n\\n// main function to get the sorted squares array\\nfunc sortedSquares(nums []int) []int {\\n    \\n    n := len(nums) // get the length of the given array\\n    result := make([]int, n) // create a new slice of type int that can hold n values\\n    \\n    // left and right pointers\\n    left, right := 0, n - 1\\n    \\n    // iterate through our new slice (result) in reverse as we will be adding numbers from largest to smallest\\n    for i := n - 1; i >= 0; i-- {\\n        square := 0 // the variable that will store the largest absolute value of the two pointers\\n        \\n        // if the absolute value of the left pointer is less than the absolute value of the right pointer, \\n        // set square to the larger number from the right pointer and move the right pointer one left.\\n        // Else set square to the larger number from the left pointer and move the left pointer one right.\\n        if Abs(nums[left]) < Abs(nums[right]) {\\n            square = nums[right]\\n            right--\\n        } else {\\n            square = nums[left]\\n            left ++\\n        }\\n        \\n        // square the value and add it to the appropriate index\\n        result[i] = square * square\\n    }\\n    \\n    // return the sorted array with the squared values\\n    return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2748647,
                "title": "java-runtime-1ms-faster-than-100-memory-usage-less-than-95-87",
                "content": "```\\nclass Solution {\\n    public  int[] sortedSquares(int[] nums) {\\n        int length = nums.length;\\n        if (length == 0) return new int[0];\\n        \\n        int[] result = new int[length];\\n        int l = 0, r = length - 1;\\n        for (int i = length - 1; i >= 0; i--) {\\n            int start = nums[l] * nums[l];\\n            int end = nums[r] * nums[r];\\n            if (start > end) {\\n                result[i] = start;\\n                l++;\\n            } else {\\n                result[i] = end;\\n                r--;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/55988ba5-1e00-4f70-9aff-5b34e26e9cbe_1666863577.579867.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public  int[] sortedSquares(int[] nums) {\\n        int length = nums.length;\\n        if (length == 0) return new int[0];\\n        \\n        int[] result = new int[length];\\n        int l = 0, r = length - 1;\\n        for (int i = length - 1; i >= 0; i--) {\\n            int start = nums[l] * nums[l];\\n            int end = nums[r] * nums[r];\\n            if (start > end) {\\n                result[i] = start;\\n                l++;\\n            } else {\\n                result[i] = end;\\n                r--;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 302304,
                "title": "js-faster-than-99-simple-solution",
                "content": "```\\nvar sortedSquares = function(A) {\\n  const result = [];\\n  let head = 0;\\n  let tail = A.length - 1;\\n\\n  while (head <= tail) {\\n    if (A[head] ** 2 > A[tail] ** 2) result.push(A[head++] ** 2);\\n    else result.push(A[tail--] ** 2);\\n  }\\n\\n  return result.reverse();\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nvar sortedSquares = function(A) {\\n  const result = [];\\n  let head = 0;\\n  let tail = A.length - 1;\\n\\n  while (head <= tail) {\\n    if (A[head] ** 2 > A[tail] ** 2) result.push(A[head++] ** 2);\\n    else result.push(A[tail--] ** 2);\\n  }\\n\\n  return result.reverse();\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 243791,
                "title": "java-1-line-solution-using-streams",
                "content": "Java one liner\\n```\\nreturn Arrays.stream(A).map(a -> a*a).sorted().toArray();\\n```",
                "solutionTags": [],
                "code": "```\\nreturn Arrays.stream(A).map(a -> a*a).sorted().toArray();\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1666085,
                "title": "c-easy-solution-with-explanations",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Simple approach: convert squares of every elements & then sort them.\\n- **Time complexity:** O(nlogn).\\n\\n### Solution 02\\n\\n- 2 pointer approach.\\n- Take a separate array of size n.\\n- Take 2 pointers: l & r.\\n- Compare square of l & r indexed elements & put the max element to last of ans array.\\n- **Time complexity:** O(n).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int n= nums.size();\\n        for(int i=0; i<n; i++){\\n            nums[i] = nums[i]*nums[i];\\n        }\\n        sort(nums.begin(), nums.end());\\n        return nums;\\n    }\\n};**\\n\\n//Solution 02:\\n**class Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int n=nums.size()-1;\\n        int l=0, r=n;\\n        vector<int> ans(nums.begin(), nums.end());\\n        \\n        while(n>=0){\\n            if(nums[l]*nums[l] > nums[r]*nums[r]){\\n                ans[n] = nums[l]*nums[l];\\n                l++; n--;\\n            }\\n            else{\\n                ans[n] = nums[r]*nums[r];\\n                r--; n--;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};**\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int n= nums.size();\\n        for(int i=0; i<n; i++){\\n            nums[i] = nums[i]*nums[i];\\n        }\\n        sort(nums.begin(), nums.end());\\n        return nums;\\n    }\\n};**\\n\\n//Solution 02:\\n**class Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int n=nums.size()-1;\\n        int l=0, r=n;\\n        vector<int> ans(nums.begin(), nums.end());\\n        \\n        while(n>=0){\\n            if(nums[l]*nums[l] > nums[r]*nums[r]){\\n                ans[n] = nums[l]*nums[l];\\n                l++; n--;\\n            }\\n            else{\\n                ans[n] = nums[r]*nums[r];\\n                r--; n--;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1461322,
                "title": "python-one-line-solution",
                "content": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        return sorted([i * i for i in nums])\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        return sorted([i * i for i in nums])\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1299085,
                "title": "3-solutions-2-pointer-and-sort-explained",
                "content": "**Solution 1**\\n- uses 2 pointers. \\n- **Start both pointers from opposite directions**. When working with sorted arrays, ask yourself it makes sense to start pointers from opposite ends. In this problem, starting from opposite ends is a good strategy. This visualization may help. \\n![image](https://assets.leetcode.com/users/images/a93e2573-233a-4e5e-85bf-98eb792f854e_1624738522.3515596.png)\\n- If we start from opposite ends, we know that both ends will give us the respective highest squares, especially when working with negative numbers.\\n- Next, we make a comparison, and grab the highest value and insert it into the results array.\\n\\n```\\n[-4, -3,  0, 3, 5]\\n```\\n\\neven if we don\\'t have negative numbers this strategy works nicely.\\n\\n```\\n[ 0, 3, 5, 7]\\n```\\n\\n```\\nvar sortedSquares = function (nums) {\\n    const results = new Array(nums.length);\\n    let left_idx = 0;\\n    let right_idx = nums.length-1;\\n    let next_highest_square_index = nums.length-1; // keep track where our next insert position will be in the results array\\n\\n    while(left_idx <= right_idx){\\n        const left_el = Math.pow(nums[left_idx],2)\\n        const right_el = Math.pow(nums[right_idx],2)\\n        if(left_el > right_el){\\n            results[next_highest_square_index] = left_el\\n            next_highest_square_index -=1;\\n            left_idx +=1\\n        }\\n        else {\\n            results[next_highest_square_index] = right_el;\\n\\t\\t\\tnext_highest_square_index -= 1;\\n            right_idx -= 1\\n        }\\n    }\\n    return results\\n};\\n```\\n\\n\\n**Solution 2**\\n- 2 pointer, start pointers close to each other\\n- start right index at the first positive number index\\n- start left index and the first positive number index - 1;\\n![image](https://assets.leetcode.com/users/images/4b11ad63-5b29-4c86-b289-4fe7d637925d_1624739338.4962318.png)\\n\\nSolution 2, requires **aloooot of edge case handling**, so the first solution is definetly better, I think. Again, with sorted inputs, its always good idea to ask yourself if starting pointers from the opposite direction is better/simpler\\n\\n\\n**Solution 3 (brute force)**\\n- loop over each element, square it. Before returning sort the list\\n- downside, compared to solution 1 is that we are sorting which adds `n log n` complexity \\n\\n```\\nvar sortedSquares = function(nums) {\\n    return nums\\n            .map(num => Math.pow(num, 2))\\n            .sort((a,b) => a-b); // sort ascending\\n};\\n```\\n\\n\\nAdditonal resource readings\\n- https://emre.me/coding-patterns/two-pointers/",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\n[-4, -3,  0, 3, 5]\\n```\n```\\n[ 0, 3, 5, 7]\\n```\n```\\nvar sortedSquares = function (nums) {\\n    const results = new Array(nums.length);\\n    let left_idx = 0;\\n    let right_idx = nums.length-1;\\n    let next_highest_square_index = nums.length-1; // keep track where our next insert position will be in the results array\\n\\n    while(left_idx <= right_idx){\\n        const left_el = Math.pow(nums[left_idx],2)\\n        const right_el = Math.pow(nums[right_idx],2)\\n        if(left_el > right_el){\\n            results[next_highest_square_index] = left_el\\n            next_highest_square_index -=1;\\n            left_idx +=1\\n        }\\n        else {\\n            results[next_highest_square_index] = right_el;\\n\\t\\t\\tnext_highest_square_index -= 1;\\n            right_idx -= 1\\n        }\\n    }\\n    return results\\n};\\n```\n```\\nvar sortedSquares = function(nums) {\\n    return nums\\n            .map(num => Math.pow(num, 2))\\n            .sort((a,b) => a-b); // sort ascending\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 514315,
                "title": "javascript-two-pointers-o-n-solution",
                "content": "```javascript\\n/**\\n * @param {number[]} A\\n * @return {number[]}\\n */\\nvar sortedSquares = function(A) {\\n  const res = [];\\n  let i = 0;\\n  while (A[i] < 0) i++;\\n  let j = i - 1;\\n  while (j >= 0 || i < A.length) {\\n    if (i >= A.length || -A[j] <= A[i]) {\\n      res.push(A[j--] ** 2);\\n    } else {\\n      res.push(A[i++] ** 2);\\n    }\\n  }\\n  return res;\\n};\\n```\\n\\n* 132/132 cases passed (92 ms)\\n* Your runtime beats 99.09 % of javascript submissions\\n* Your memory usage beats 88.89 % of javascript submissions (42.6 MB)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {number[]} A\\n * @return {number[]}\\n */\\nvar sortedSquares = function(A) {\\n  const res = [];\\n  let i = 0;\\n  while (A[i] < 0) i++;\\n  let j = i - 1;\\n  while (j >= 0 || i < A.length) {\\n    if (i >= A.length || -A[j] <= A[i]) {\\n      res.push(A[j--] ** 2);\\n    } else {\\n      res.push(A[i++] ** 2);\\n    }\\n  }\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1873182,
                "title": "c-easy-solution-100-o-n",
                "content": "```\\nint* sortedSquares(int* nums, int numsSize, int* returnSize)\\n{\\n    int *res = malloc(sizeof(nums[0]) * numsSize);\\n    int start = 0;\\n    int end = numsSize - 1;\\n    for (int i = numsSize - 1; start <= end; i--) {\\n        int a = nums[start] * nums[start];\\n        int b = nums[end] * nums[end];\\n        if (a > b) {\\n            res[i] = a;\\n            start++;\\n        } else {\\n            res[i] = b;\\n            end--;\\n        }\\n    }\\n    *returnSize = numsSize;\\n    return res;\\n}\\n```\\n\\n**If this was helpful, don\\'t hesitate to upvote! :)**\\nHave a nice day!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint* sortedSquares(int* nums, int numsSize, int* returnSize)\\n{\\n    int *res = malloc(sizeof(nums[0]) * numsSize);\\n    int start = 0;\\n    int end = numsSize - 1;\\n    for (int i = numsSize - 1; start <= end; i--) {\\n        int a = nums[start] * nums[start];\\n        int b = nums[end] * nums[end];\\n        if (a > b) {\\n            res[i] = a;\\n            start++;\\n        } else {\\n            res[i] = b;\\n            end--;\\n        }\\n    }\\n    *returnSize = numsSize;\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1419437,
                "title": "python-two-pointers-solution-o-n",
                "content": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        \\n        i = 0\\n        n = len(nums)\\n        j = n - 1\\n        \\n        new = [0] * n\\n        k = n - 1\\n        \\n        while i <= j:\\n            if abs(nums[i]) < abs(nums[j]):\\n                new[k] = nums[j] ** 2\\n                j -= 1\\n                \\n            else:\\n                new[k] = nums[i] ** 2\\n                i += 1\\n            k -= 1\\n            \\n        return new",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        \\n        i = 0\\n        n = len(nums)\\n        j = n - 1\\n        \\n        new = [0] * n\\n        k = n - 1\\n        \\n        while i <= j:\\n            if abs(nums[i]) < abs(nums[j]):\\n                new[k] = nums[j] ** 2\\n                j -= 1\\n                \\n            else:\\n                new[k] = nums[i] ** 2\\n                i += 1\\n            k -= 1\\n            \\n        return new",
                "codeTag": "Java"
            },
            {
                "id": 2230684,
                "title": "simple-o-n-solution-not-o-nlogn",
                "content": "```\\n   vector<int> sortedSquares(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n);\\n        int l = 0 , r = n-1;\\n        for(int i = n-1 ; i>=0 ; i--){\\n            if(abs(nums[l]) > abs(nums[r])){\\n                \\n            \\n                ans[i] = nums[l]*nums[l];\\n                l++;\\n            }\\n            else{\\n                ans[i] = nums[r]*nums[r];\\n                r--;\\n            }\\n        }\\n        return ans;   \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n   vector<int> sortedSquares(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n);\\n        int l = 0 , r = n-1;\\n        for(int i = n-1 ; i>=0 ; i--){\\n            if(abs(nums[l]) > abs(nums[r])){\\n                \\n            \\n                ans[i] = nums[l]*nums[l];\\n                l++;\\n            }\\n            else{\\n                ans[i] = nums[r]*nums[r];\\n                r--;\\n            }\\n        }\\n        return ans;   \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 764051,
                "title": "c-o-n-sol",
                "content": "```\\nint* sortedSquares(int* A, int ASize, int* returnSize){\\n    int* arr = malloc(sizeof(int)*ASize);\\n    *returnSize = ASize;\\n    int end = ASize-1, start = 0, ptr = ASize-1;\\n    while ((start <= end) && (ptr>=0))\\n    {\\n        if (pow(A[end],2) >= pow(A[start],2))\\n        {\\n            arr[ptr] = pow(A[end--],2);\\n        }\\n        else\\n        {\\n            arr[ptr] = pow(A[start++],2);\\n        }\\n        ptr--;\\n    }\\n    return arr;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint* sortedSquares(int* A, int ASize, int* returnSize){\\n    int* arr = malloc(sizeof(int)*ASize);\\n    *returnSize = ASize;\\n    int end = ASize-1, start = 0, ptr = ASize-1;\\n    while ((start <= end) && (ptr>=0))\\n    {\\n        if (pow(A[end],2) >= pow(A[start],2))\\n        {\\n            arr[ptr] = pow(A[end--],2);\\n        }\\n        else\\n        {\\n            arr[ptr] = pow(A[start++],2);\\n        }\\n        ptr--;\\n    }\\n    return arr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 410492,
                "title": "c-with-two-indices-explained",
                "content": "So at first we look at sorting as nlogn and we know we need to have this solution, \\nthe naive solution here is just multiply everything and sort again.\\n\\nlet\\'s try better than that.\\n\\nwe need to understand that the only thing we know of absolute value is the fact is says how far are we from zero. meaning if we compare two numbers in their absulote values we know which one is bigger, so when we will raise them by power of 2 they will be positives as well. \\nso this is the main idea here how do we utilize Math.Abs in order to sort our array.\\n\\nso the tricky part is to understand how to fill the array. well ...\\n\\nso we need to understand which Math.Abs is bigger in order to put it....last...\\nbecause we are sorting.\\n\\nwho can be the biggest? the last value or the first value (which is negative in the example.)\\n\\nso we have start and end index and we compare \\nMath.Abs(A[start]) > Math.Abs(A[end)\\n\\nwhoever is bigger goes to the end;\\n\\nso we need to start the iteration from the end as well.\\n\\n```\\n  public int[] SortedSquares(int[] A) {\\n        int[] res=new int[A.Length];\\n        int start = 0;\\n        int end = A.Length-1;\\n        for(int i=A.Length-1;i>=0; i--)\\n        {\\n            if(Math.Abs(A[start]) > Math.Abs(A[end]))\\n            {\\n                res[i]  = A[start] * A[start];\\n                start++;\\n            }\\n            else{\\n                res[i] = A[end]*A[end];\\n                end--;\\n            }\\n            \\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  public int[] SortedSquares(int[] A) {\\n        int[] res=new int[A.Length];\\n        int start = 0;\\n        int end = A.Length-1;\\n        for(int i=A.Length-1;i>=0; i--)\\n        {\\n            if(Math.Abs(A[start]) > Math.Abs(A[end]))\\n            {\\n                res[i]  = A[start] * A[start];\\n                start++;\\n            }\\n            else{\\n                res[i] = A[end]*A[end];\\n                end--;\\n            }\\n            \\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 366635,
                "title": "94-faster-than-all-the-submission-o-n-time-solution-with-detailed-explantnation",
                "content": "**First Aproach :**\\n* \\t Iterate through the vector and square the elements.\\n* \\t Use built in sort function to sort the vector.\\n* \\t this solution is slow and take O(n log n).\\n\\t\\n```\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\tvector<int> sortedSquares(vector<int>& A) {\\n        for(int i=0;i<A.size();i++){\\n            A[i]*=A[i];\\n        }\\n     \\n        sort(A.begin(),A.end());\\n        \\n        return A;\\n    }\\n```\\n\\n**Second Aproach :**\\n\\n Since we are given with ***sorted array*** we can iterate through the vector and get the first positive number, which will divide the array in two halfs.\\n* \\tThese two halfs are sorted and there squares will also be sorted.\\n* \\tNow merge the sorted arrays as we do it in merge sort.\\n* \\tThis approach will yeild a O(n) solution.\\n```\\nclass Solution {\\n\\npublic:    \\n    vector<int> sortedSquares(vector<int>& A) {  \\n        \\n        int l=A.size(),j=l-1;\\n        \\n        vector<int> result;\\n        \\n        //geting the index of first non negative number\\n        for(int m=0;m<l;m++){\\n            if(A[m]>=0){\\n                j=m;break;\\n            }\\n        }\\n              \\n        //squaring the elements.\\n        for(int i=0;i<l;i++)\\n        {\\n            A[i]*=A[i];\\n            \\n        }\\n        int k=j,i=j-1;\\n        //merging the elements such that they are increasing order.\\n           while(i>=0 && k<l){\\n               if(A[i]<A[k]){\\n                   result.push_back(A[i]);\\n                   i--;\\n               }\\n               else{\\n                   result.push_back(A[k]);\\n                   k++;\\n               }\\n           }\\n            //copy rest of elemets to result\\n            while(i>=0){\\n                result.push_back(A[i]);i--;\\n            }\\n            while(k<l){\\n                result.push_back(A[k]);k++;\\n            }\\n            return result ;\\n    }\\n};\\n```\\n\\n Please do comment and let me know if i am wrong anywhere or if you have any better approach.\\n Thanks",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\tvector<int> sortedSquares(vector<int>& A) {\\n        for(int i=0;i<A.size();i++){\\n            A[i]*=A[i];\\n        }\\n     \\n        sort(A.begin(),A.end());\\n        \\n        return A;\\n    }\\n```\n```\\nclass Solution {\\n\\npublic:    \\n    vector<int> sortedSquares(vector<int>& A) {  \\n        \\n        int l=A.size(),j=l-1;\\n        \\n        vector<int> result;\\n        \\n        //geting the index of first non negative number\\n        for(int m=0;m<l;m++){\\n            if(A[m]>=0){\\n                j=m;break;\\n            }\\n        }\\n              \\n        //squaring the elements.\\n        for(int i=0;i<l;i++)\\n        {\\n            A[i]*=A[i];\\n            \\n        }\\n        int k=j,i=j-1;\\n        //merging the elements such that they are increasing order.\\n           while(i>=0 && k<l){\\n               if(A[i]<A[k]){\\n                   result.push_back(A[i]);\\n                   i--;\\n               }\\n               else{\\n                   result.push_back(A[k]);\\n                   k++;\\n               }\\n           }\\n            //copy rest of elemets to result\\n            while(i>=0){\\n                result.push_back(A[i]);i--;\\n            }\\n            while(k<l){\\n                result.push_back(A[k]);k++;\\n            }\\n            return result ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2569679,
                "title": "c-using-two-pointer-method-easy-solution-95-25-faster",
                "content": "```\\nvector<int> sortedSquares(vector<int>& nums) {\\n        //Two Pointer\\n        int n = nums.size();\\n        int left = 0, right = n-1;\\n        vector<int>v(n,0);\\n        for(int i = n-1;i>=0;i--){\\n            if(abs(nums[left])>nums[right]){\\n                v[i] = nums[left]*nums[left];\\n                left++;\\n            }\\n            else{\\n                v[i] = nums[right]*nums[right];\\n                right--;\\n            }\\n        }\\n        return v;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nvector<int> sortedSquares(vector<int>& nums) {\\n        //Two Pointer\\n        int n = nums.size();\\n        int left = 0, right = n-1;\\n        vector<int>v(n,0);\\n        for(int i = n-1;i>=0;i--){\\n            if(abs(nums[left])>nums[right]){\\n                v[i] = nums[left]*nums[left];\\n                left++;\\n            }\\n            else{\\n                v[i] = nums[right]*nums[right];\\n                right--;\\n            }\\n        }\\n        return v;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1884640,
                "title": "95-faster-one-pass-solution-two-pointers",
                "content": "***Please Upvote to keep me motivated*** \\u270C\\n\\n**Intution :-** Maintain the two pointers in start and in the end and check the absolute values in array.\\nWhichever is largest, push its square into the result array. Reverse the result array and return it.\\nWe are not maintaining the smaller values in result array because we may get more smaller values by moving ahead in the nums array.\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> res;\\n        int l = 0;\\n        int h = n - 1;\\n        while(l <= h){\\n           if(abs(nums[l]) > abs(nums[h])){\\n               res.push_back(nums[l] * nums[l]);\\n               l++;\\n           } \\n           else{\\n                res.push_back(nums[h] * nums[h]);\\n                 h--;\\n           }\\n        }\\n        reverse(res.begin() , res.end());\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> res;\\n        int l = 0;\\n        int h = n - 1;\\n        while(l <= h){\\n           if(abs(nums[l]) > abs(nums[h])){\\n               res.push_back(nums[l] * nums[l]);\\n               l++;\\n           } \\n           else{\\n                res.push_back(nums[h] * nums[h]);\\n                 h--;\\n           }\\n        }\\n        reverse(res.begin() , res.end());\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1517010,
                "title": "reading-the-question-carefully-is-very-important-java-easy",
                "content": "+ A classic 2 pointer solution, s is pointer1 and e is pointer 2.\\n+ s starts from the begenning and e from end.\\n```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int l = nums.length;\\n        int[] f = new int[l];\\n        int s=0, e=l-1, i=l-1,a,b;\\n        while(s<=e){\\n            a= nums[s]*nums[s]; b= nums[e]*nums[e];\\n            if(a>b){\\n                f[i]=a;\\n                s++;\\n            }else{\\n                f[i]=b;\\n                e--;\\n            }\\n            i--;\\n        }\\n        return f;\\n}}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int l = nums.length;\\n        int[] f = new int[l];\\n        int s=0, e=l-1, i=l-1,a,b;\\n        while(s<=e){\\n            a= nums[s]*nums[s]; b= nums[e]*nums[e];\\n            if(a>b){\\n                f[i]=a;\\n                s++;\\n            }else{\\n                f[i]=b;\\n                e--;\\n            }\\n            i--;\\n        }\\n        return f;\\n}}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 973045,
                "title": "c-c-short-and-simple-o-n-solution",
                "content": "```\\nint* sortedSquares(int* A, int ASize, int* returnSize){\\n    int* arr = malloc(sizeof(int)*ASize);\\n    *returnSize = ASize;\\n    int end = ASize-1, start = 0, ptr = ASize-1;\\n    while ((start <= end) && (ptr>=0))\\n    {\\n        if (pow(A[end],2) >= pow(A[start],2))\\n            arr[ptr] = pow(A[end--],2);\\n        else\\n            arr[ptr] = pow(A[start++],2);\\n        \\n        ptr--;\\n    }\\n    return arr;\\n}\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint* sortedSquares(int* A, int ASize, int* returnSize){\\n    int* arr = malloc(sizeof(int)*ASize);\\n    *returnSize = ASize;\\n    int end = ASize-1, start = 0, ptr = ASize-1;\\n    while ((start <= end) && (ptr>=0))\\n    {\\n        if (pow(A[end],2) >= pow(A[start],2))\\n            arr[ptr] = pow(A[end--],2);\\n        else\\n            arr[ptr] = pow(A[start++],2);\\n        \\n        ptr--;\\n    }\\n    return arr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 678147,
                "title": "c-two-pointer-solution",
                "content": "```\\n/*\\n    Time: O(n) where n is the size of input array\\n    Space: O(n) due to the output array\\n*/\\npublic class Solution {\\n    public int[] SortedSquares(int[] A) {\\n        \\n        int[] res = new int[A.Length];       \\n        int left = 0, right = A.Length - 1;        \\n        \\n        for(int i = A.Length - 1; i >= 0; i--)\\n        {\\n            if(Math.Abs(A[left]) >= Math.Abs(A[right]))\\n            {\\n                res[i] = A[left] * A[left];\\n                left++;\\n            }\\n            else\\n            {\\n                res[i] = A[right] * A[right];\\n                right--;\\n            }           \\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n    Time: O(n) where n is the size of input array\\n    Space: O(n) due to the output array\\n*/\\npublic class Solution {\\n    public int[] SortedSquares(int[] A) {\\n        \\n        int[] res = new int[A.Length];       \\n        int left = 0, right = A.Length - 1;        \\n        \\n        for(int i = A.Length - 1; i >= 0; i--)\\n        {\\n            if(Math.Abs(A[left]) >= Math.Abs(A[right]))\\n            {\\n                res[i] = A[left] * A[left];\\n                left++;\\n            }\\n            else\\n            {\\n                res[i] = A[right] * A[right];\\n                right--;\\n            }           \\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2074042,
                "title": "ruby-solution-using-pointers-instead-of-built-in-ruby-sort-method",
                "content": "**O(nlogn) Solution**\\nYes, we all know that Ruby is awesome and this problem can be solved with a simple one-liner:\\n```Ruby\\ndef sorted_squares(nums)\\n  nums.map { |n| n**2 }.sort\\nend\\n```\\nBut, there are a couple issues with this solution. Most notably, this is NOT the most optimal solution. Ruby\\'s `sort` method uses quicksort internally, thus the complexity for this solution will end up being `O(nlogn)`. The other issue with this solution is that it doesn\\'t really honor the spirit of LeetCode (IE, coming up with your own clever algorithm to solve a given problem). In a real world interview your interviewer likely wouldn\\'t accept this as a \"final\" solution. Maybe a first stab. And first stabs aren\\'t bad! But we can do better.\\n\\n**O(n) Solution**\\nUsing simple pointers, we can come up with an `O(n)` solution. The basic principle: We know the `nums` array is already sorted, but the trick here is that it may contain some negative values. This means that when we square those negative values they\\'ll end up at some new index location in our final squared and sorted array. Luckily, we do know that they are already sorted ... just sorted in a more-or-less *backwards* order. Using this knowledge, we take two pointers - one for the left side of the nums array and one on the right side - and slowly increase the left pointer while simultaneously decreasing the right pointer, comparing the results of each squared number at each iteration. **Think of the array as two parts: a left array sorted from left to right and a right array sorted from right to left.** We move our left pointer along the \"left\" array and the right pointer along the \"right\" array, from largest to smallest in each case. We then stick the larger of the two at the end of our final array and move on to compare the next two left and right values by decreasing the left or right index by one each step. Our comparison window will slowly shrink until the left and right pointers meet and we have compared all values in the array one at a time. At this point we will have inserted each squared value *in sorted order* into our final array, and we\\'re done. Bim bam boom.\\n\\nHere\\'s my implmentation:\\n```ruby\\ndef sorted_squares(nums)\\n  arr = [] # Initialize an empty array to store squared values\\n  l = 0 # Initialize the left pointer to zero (IE, the LARGEST value of the \"left\" array)\\n  r = nums.size - 1 # Initialize the right pointer to the size of nums (IE, the LARGEST value for the \"right\" array)\\n  i = r # Initialize our \"insert index\". Because we are starting with the largest values and working our way inward, we will insert each value into the array starting at the end (IE, the largest index in nums)\\n  \\n  until i < 0 # Loop until we\\'ve exhausted all nums\\n    left = nums[l]**2 # Square the left side value\\n    right = nums[r]**2 # Square the right side value\\n    \\n    if left > right\\n\\t  # If the left value is larger store it in our array at the current index and increment the left pointer\\n      arr[i] = left\\n      l += 1\\n    else\\n\\t  # Otherwise the right value is larger, store it at the current index and decrement the right pointer\\n      arr[i] = right\\n      r -= 1\\n    end\\n    \\n    i -= 1 # We inserted one squared value into our final array, decrement the current index\\n  end\\n     \\n  arr # Return the final array\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Sorting"
                ],
                "code": "```Ruby\\ndef sorted_squares(nums)\\n  nums.map { |n| n**2 }.sort\\nend\\n```\n```ruby\\ndef sorted_squares(nums)\\n  arr = [] # Initialize an empty array to store squared values\\n  l = 0 # Initialize the left pointer to zero (IE, the LARGEST value of the \"left\" array)\\n  r = nums.size - 1 # Initialize the right pointer to the size of nums (IE, the LARGEST value for the \"right\" array)\\n  i = r # Initialize our \"insert index\". Because we are starting with the largest values and working our way inward, we will insert each value into the array starting at the end (IE, the largest index in nums)\\n  \\n  until i < 0 # Loop until we\\'ve exhausted all nums\\n    left = nums[l]**2 # Square the left side value\\n    right = nums[r]**2 # Square the right side value\\n    \\n    if left > right\\n\\t  # If the left value is larger store it in our array at the current index and increment the left pointer\\n      arr[i] = left\\n      l += 1\\n    else\\n\\t  # Otherwise the right value is larger, store it at the current index and decrement the right pointer\\n      arr[i] = right\\n      r -= 1\\n    end\\n    \\n    i -= 1 # We inserted one squared value into our final array, decrement the current index\\n  end\\n     \\n  arr # Return the final array\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1695344,
                "title": "java-two-pointers-o-n",
                "content": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int n=nums.length;\\n        int[] res=new int[n];\\n        int left=0;\\n        int right=n-1;\\n        for(int i=n-1;i>=0;i--){\\n            if(Math.abs(nums[left])>=Math.abs(nums[right])){\\n                res[i]=nums[left]*nums[left];\\n                left++;\\n            }\\n            else{\\n                res[i]=nums[right]*nums[right];\\n                right--;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n\\n**Do upvote if you find this useful**",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int n=nums.length;\\n        int[] res=new int[n];\\n        int left=0;\\n        int right=n-1;\\n        for(int i=n-1;i>=0;i--){\\n            if(Math.abs(nums[left])>=Math.abs(nums[right])){\\n                res[i]=nums[left]*nums[left];\\n                left++;\\n            }\\n            else{\\n                res[i]=nums[right]*nums[right];\\n                right--;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 234202,
                "title": "swift-no-brainer",
                "content": "```\\nclass Solution {\\n    func sortedSquares(_ A: [Int]) -> [Int] {\\n        return A.map{ $0 * $0 }.sorted()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func sortedSquares(_ A: [Int]) -> [Int] {\\n        return A.map{ $0 * $0 }.sorted()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531964,
                "title": "java-two-pointers",
                "content": "![IMG_20230516_220315.jpg](https://assets.leetcode.com/users/images/a8e537ec-9c2f-4402-95b0-5db8601d2d16_1684263908.2499745.jpeg)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int n = nums.length;\\n        int[] result = new int[n];\\n        int left = 0;\\n        int right = n - 1;\\n        int i = n - 1;\\n\\n        while (left <= right) {\\n            int leftSquare = nums[left] * nums[left];\\n            int rightSquare = nums[right] * nums[right];\\n\\n            if (leftSquare > rightSquare) {\\n                result[i] = leftSquare;\\n                left++;\\n            } else {\\n                result[i] = rightSquare;\\n                right--;\\n            }\\n\\n            i--;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Go",
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int n = nums.length;\\n        int[] result = new int[n];\\n        int left = 0;\\n        int right = n - 1;\\n        int i = n - 1;\\n\\n        while (left <= right) {\\n            int leftSquare = nums[left] * nums[left];\\n            int rightSquare = nums[right] * nums[right];\\n\\n            if (leftSquare > rightSquare) {\\n                result[i] = leftSquare;\\n                left++;\\n            } else {\\n                result[i] = rightSquare;\\n                right--;\\n            }\\n\\n            i--;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3062168,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int i=0, n=nums.size();\\n        while(i<n-1 && abs(nums[i+1])<=abs(nums[i]))\\n        i++;\\n        i++;\\n        int j=i-1;\\n        vector<int> ans;\\n        while(j>=0 && i<n)\\n        {\\n            if(abs(nums[j])<abs(nums[i]))\\n            {\\n                ans.push_back(nums[j]*nums[j]);\\n                j--;\\n            }\\n            else\\n            {\\n                ans.push_back(nums[i]*nums[i]);\\n                i++;\\n            }\\n        }\\n        while(j>=0)\\n        {\\n            ans.push_back(nums[j]*nums[j]);\\n            j--;\\n        }\\n        while(i<n)\\n        {\\n            ans.push_back(nums[i]*nums[i]);\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int i=0, n=nums.size();\\n        while(i<n-1 && abs(nums[i+1])<=abs(nums[i]))\\n        i++;\\n        i++;\\n        int j=i-1;\\n        vector<int> ans;\\n        while(j>=0 && i<n)\\n        {\\n            if(abs(nums[j])<abs(nums[i]))\\n            {\\n                ans.push_back(nums[j]*nums[j]);\\n                j--;\\n            }\\n            else\\n            {\\n                ans.push_back(nums[i]*nums[i]);\\n                i++;\\n            }\\n        }\\n        while(j>=0)\\n        {\\n            ans.push_back(nums[j]*nums[j]);\\n            j--;\\n        }\\n        while(i<n)\\n        {\\n            ans.push_back(nums[i]*nums[i]);\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1480790,
                "title": "shortest-possible-java-solution-only-4-lines-of-code-beats-100",
                "content": "Before showing the solution I suggest having a look at the [Merge Sorted Array](https://leetcode.com/problems/merge-sorted-array/) problem if you didn\\'t, and you can see how I solved it [here](https://leetcode.com/problems/merge-sorted-array/discuss/1480686/shortest-java-solution-only-6-lines-of-code-beats-100).\\n\\nBy using the same logic, our approuch is to have two pointers starting at the beginning and end of the array and select whichever is higher and continuously fills out our new array from end to start with the selected element.\\n\\n\\n```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int[] temp = new int[nums.length];\\n        \\n        for (int i = 0, j = nums.length - 1, current = j; current >= 0; ) {\\n            temp[current--] = Math.abs(nums[i]) >= Math.abs(nums[j]) ? nums[i] * nums[i++] : nums[j] * nums[j--];\\n        }\\n        return temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int[] temp = new int[nums.length];\\n        \\n        for (int i = 0, j = nums.length - 1, current = j; current >= 0; ) {\\n            temp[current--] = Math.abs(nums[i]) >= Math.abs(nums[j]) ? nums[i] * nums[i++] : nums[j] * nums[j--];\\n        }\\n        return temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 972954,
                "title": "python-oneliner-o-n-explained",
                "content": "Note, that our numbers will look like this: first we have some negative numbers in increasing order (may be `0` of them) and then we have some positive numbers in increasing order (again may be `0` of them). \\n\\n1. Note, that if we have negative number in increasing order, then their squares will be in decreasing order, so we need to invert this part.\\n2. If we have positive increasing numbers, then their squares also increasing numbers.\\n3. Now we have two lists with increasing numbers and we need to creaty one list with increasing numbers, how we can do it? We can use **merge** sort and do it by hands. However it happens, that if we run the code as it is it will be `O(n)`. Why? Because python uses so-called **Timsort** https://en.wikipedia.org/wiki/Timsort which will look for sorted patterns in data.\\n\\n**Complexity**: time and space complexity is `O(n)`.\\n\\n```\\nclass Solution:\\n    def sortedSquares(self, nums):\\n        return sorted([i**2 for i in nums if i > 0][::-1] + [i**2 for i in nums if i <= 0])\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sortedSquares(self, nums):\\n        return sorted([i**2 for i in nums if i > 0][::-1] + [i**2 for i in nums if i <= 0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 483503,
                "title": "python-one-liner",
                "content": "```\\nclass Solution:\\n    def sortedSquares(self, A: List[int]) -> List[int]:\\n        return sorted([x**2 for x in A])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sortedSquares(self, A: List[int]) -> List[int]:\\n        return sorted([x**2 for x in A])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 230731,
                "title": "c-well-commented-solution-with-explanation-using-double-ended-queue",
                "content": "```\\n/* Idea ---- \\n1) Store the array in a double ended queue  \\n2) Now the element with the largest magnitude would be at the front or at the back\\n3) Moreover, the element with the largest magnitude would have the largest square value\\n4) So, Pop it and similarly get the second largest in magnitude\\n5) Finally, Reverse the answer to sort in non_decreasing order\\n*/\\n\\nclass Solution\\n{\\npublic:\\n    vector<int> sortedSquares(vector<int>& myVector);\\n};\\n\\n/* Returns the vector of sorted square */\\nvector<int> Solution :: sortedSquares(vector<int>& myVector)\\n{\\n    // Declare the deque and the container to hold the answer\\n    vector<int> answer;\\n    deque<int> dq;\\n    \\n    // Fill all elements in the deque\\n    for(auto ele: myVector)\\n        dq.push_back(ele);\\n    \\n    // Keep extracting the element with the highest magnitude\\n    while(!dq.empty())\\n    {\\n        // Get a copy\\n        int front = dq.front();\\n        int back = dq.back();\\n        \\n        // If the largest magnitude occurs at the front, pop it and append it\\n        if(abs(front) > abs(back))\\n        {\\n            dq.pop_front();\\n            answer.push_back(front*front);\\n        }\\n        \\n        // Else pop the back and append it to answer\\n        else\\n        {\\n            dq.pop_back();\\n            answer.push_back(back*back);\\n        }\\n    }\\n    \\n    // Fianlly Reverse the answer to sort in non decreasing order\\n    reverse(answer.begin(), answer.end());\\n    \\n    // Return the new answer\\n    return answer;\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n/* Idea ---- \\n1) Store the array in a double ended queue  \\n2) Now the element with the largest magnitude would be at the front or at the back\\n3) Moreover, the element with the largest magnitude would have the largest square value\\n4) So, Pop it and similarly get the second largest in magnitude\\n5) Finally, Reverse the answer to sort in non_decreasing order\\n*/\\n\\nclass Solution\\n{\\npublic:\\n    vector<int> sortedSquares(vector<int>& myVector);\\n};\\n\\n/* Returns the vector of sorted square */\\nvector<int> Solution :: sortedSquares(vector<int>& myVector)\\n{\\n    // Declare the deque and the container to hold the answer\\n    vector<int> answer;\\n    deque<int> dq;\\n    \\n    // Fill all elements in the deque\\n    for(auto ele: myVector)\\n        dq.push_back(ele);\\n    \\n    // Keep extracting the element with the highest magnitude\\n    while(!dq.empty())\\n    {\\n        // Get a copy\\n        int front = dq.front();\\n        int back = dq.back();\\n        \\n        // If the largest magnitude occurs at the front, pop it and append it\\n        if(abs(front) > abs(back))\\n        {\\n            dq.pop_front();\\n            answer.push_back(front*front);\\n        }\\n        \\n        // Else pop the back and append it to answer\\n        else\\n        {\\n            dq.pop_back();\\n            answer.push_back(back*back);\\n        }\\n    }\\n    \\n    // Fianlly Reverse the answer to sort in non decreasing order\\n    reverse(answer.begin(), answer.end());\\n    \\n    // Return the new answer\\n    return answer;\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2806619,
                "title": "simple-python-solution-by-queue",
                "content": "![image.png](https://assets.leetcode.com/users/images/37ab4945-e4fe-414d-aec6-72e248e4217d_1668256343.9517837.png)\\n\\n\\n# Intuition\\nusing Queue\\n\\n# Approach\\n1. compare square of left most element and square of right most element, assign pop the max element from queue\\n2. Repeat this until the deque contains element.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        res = []\\n        num_deque = collections.deque(nums)\\n\\n        while num_deque:\\n            left = num_deque[0] ** 2\\n            right = num_deque[-1] ** 2\\n\\n            if left > right:\\n                res.append(left)\\n                num_deque.popleft()\\n            else:\\n                res.append(right)\\n                num_deque.pop()\\n        \\n        return res[::-1]\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        res = []\\n        num_deque = collections.deque(nums)\\n\\n        while num_deque:\\n            left = num_deque[0] ** 2\\n            right = num_deque[-1] ** 2\\n\\n            if left > right:\\n                res.append(left)\\n                num_deque.popleft()\\n            else:\\n                res.append(right)\\n                num_deque.pop()\\n        \\n        return res[::-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2238816,
                "title": "python-two-pointers-o-n-runtime-71-43",
                "content": "### Solution\\nFirstly, we initialize left and right pointers at the beginning and the end of the array. Then, we check the absolute values of the ends and populate the array in decreasing order.\\n```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        left, right, new_arr = 0, len(nums)-1, []\\n        \\n        while left <= right:\\n            if abs(nums[left]) <= abs(nums[right]):\\n                new_arr.append(nums[right]**2)\\n                right -= 1\\n            else:\\n                new_arr.append(nums[left]**2)\\n                left += 1\\n            \\n        return(new_arr[::-1])\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        left, right, new_arr = 0, len(nums)-1, []\\n        \\n        while left <= right:\\n            if abs(nums[left]) <= abs(nums[right]):\\n                new_arr.append(nums[right]**2)\\n                right -= 1\\n            else:\\n                new_arr.append(nums[left]**2)\\n                left += 1\\n            \\n        return(new_arr[::-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2126752,
                "title": "java-two-approaches-o-n-concise-solution-one-pass-with-well-explained-code",
                "content": "```\\n/*\\n     * BruteForce Approach.\\n     * (1) Square all the elements of array.\\n     * (2) Sort the squared array.\\n     * Time Complexity = O(n*logn) for sorting.\\n     * Space Complexity = O(1) no extra space is used.\\n     */\\n\\n    static int[] sortedSquares(int[] nums) {\\n        for (int i = 0; i < nums.length; i++) {\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        Arrays.sort(nums);\\n        return nums;\\n    }\\n\\n    /*\\n     * Better Approach.\\n     * (1) Create new array & start filling it from behind.\\n     * (2) Make two pointers that points starting & ending index of original array\\n     * respectively.\\n     * Time Complexity = O(n) for traversing.\\n     * Space Complexity = O(n) extra space for answer array.\\n     */\\n\\n    static int[] sortedSquares(int[] nums) {\\n        int[] ans = new int[nums.length];\\n        int start = 0, end = nums.length - 1;\\n\\n        int ansIdx = nums.length - 1;\\n        while (start <= end) {\\n            if (nums[start] * nums[start] > nums[end] * nums[end]) {\\n                ans[ansIdx--] = nums[start] * nums[start];\\n                start++;\\n            } else {\\n                ans[ansIdx--] = nums[end] * nums[end];\\n                end--;\\n            }\\n        }\\n        return ans;\\n    }\\n\\t\\n\\tPlease Upvote if you like this :)\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\n/*\\n     * BruteForce Approach.\\n     * (1) Square all the elements of array.\\n     * (2) Sort the squared array.\\n     * Time Complexity = O(n*logn) for sorting.\\n     * Space Complexity = O(1) no extra space is used.\\n     */\\n\\n    static int[] sortedSquares(int[] nums) {\\n        for (int i = 0; i < nums.length; i++) {\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        Arrays.sort(nums);\\n        return nums;\\n    }\\n\\n    /*\\n     * Better Approach.\\n     * (1) Create new array & start filling it from behind.\\n     * (2) Make two pointers that points starting & ending index of original array\\n     * respectively.\\n     * Time Complexity = O(n) for traversing.\\n     * Space Complexity = O(n) extra space for answer array.\\n     */\\n\\n    static int[] sortedSquares(int[] nums) {\\n        int[] ans = new int[nums.length];\\n        int start = 0, end = nums.length - 1;\\n\\n        int ansIdx = nums.length - 1;\\n        while (start <= end) {\\n            if (nums[start] * nums[start] > nums[end] * nums[end]) {\\n                ans[ansIdx--] = nums[start] * nums[start];\\n                start++;\\n            } else {\\n                ans[ansIdx--] = nums[end] * nums[end];\\n                end--;\\n            }\\n        }\\n        return ans;\\n    }\\n\\t\\n\\tPlease Upvote if you like this :)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1109072,
                "title": "java-two-pointers-o-n-with-interview-tips",
                "content": "Before proceeding to solution ask clarification question. for eg:\\n 1. can the values in the array be negative.\\n 2. can square of values can exceed Integer.MAX_VALUE.\\n 3. values are in long or Integer.\\n 4. is given array sorted.(even if the example are sorted) this helped me in google interview interviewer told me that this is nice question. (I was not asked this question but a question where sample cases where sorted )\\n \\n now move to solution :\\nSolution 1: Square all the values of the array and now sort the array . \\n                    Time :O(nlogn) and space O(1) \\n\\t\\t\\t\\t\\task then sir/mam that this is one kind of solution should i need to improve time complexity                      or are you fine with it. (if they told to improve then go to O(n) soln)\\n\\t\\t\\t\\t\\t\\nSolution 2: \\t\\t\\t\\t\\n```\\nclass Solution {\\n    public int[] sortedSquares(int[] A) {\\n        \\n        \\n        int i=0;\\n        int j=A.length-1;\\n        int k=A.length-1;\\n        int[] ans=new int[A.length];\\n        \\n        while(i<=j){\\n            int val1=Math.abs(A[i]);\\n            int val2=Math.abs(A[j]);\\n             \\n            if(val2>val1){\\n                val2=val2*val2;\\n                ans[k]=val2;\\n                k--;\\n                j--;\\n            }else{\\n                val1=val1*val1;\\n                ans[k]=val1;\\n                k--;\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\nPlease upvote if find it helpful love to hear some feedback or any doubt you have in solution.",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] A) {\\n        \\n        \\n        int i=0;\\n        int j=A.length-1;\\n        int k=A.length-1;\\n        int[] ans=new int[A.length];\\n        \\n        while(i<=j){\\n            int val1=Math.abs(A[i]);\\n            int val2=Math.abs(A[j]);\\n             \\n            if(val2>val1){\\n                val2=val2*val2;\\n                ans[k]=val2;\\n                k--;\\n                j--;\\n            }else{\\n                val1=val1*val1;\\n                ans[k]=val1;\\n                k--;\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 325435,
                "title": "short-java-solution-1ms-beat-100-40-3mb",
                "content": "```\\n    public int[] sortedSquares(int[] A) {\\n        int res[] = new int[A.length];\\n        int i = 0;\\n        int k = A.length - 1;\\n        int z = A.length - 1;\\n        while(z >= 0){ \\n            res[z--] = Math.abs(A[i]) > Math.abs(A[k]) ? A[i] * A[i++] : A[k] * A[k--];\\n        }\\n        return res;\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int[] sortedSquares(int[] A) {\\n        int res[] = new int[A.length];\\n        int i = 0;\\n        int k = A.length - 1;\\n        int z = A.length - 1;\\n        while(z >= 0){ \\n            res[z--] = Math.abs(A[i]) > Math.abs(A[k]) ? A[i] * A[i++] : A[k] * A[k--];\\n        }\\n        return res;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 286050,
                "title": "java-100-rt",
                "content": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] A) {\\n        int i = 0, j = A.length -1, k=j;\\n        int[] B = new int[A.length];\\n        while(k>=0){\\n            int x = A[i]*A[i], y = A[j]*A[j];\\n            if(x >= y){\\n                B[k] = x;\\n                i++;\\n            } else{\\n                B[k] = y;\\n                j--;\\n            }\\n\\t\\t\\tk--;\\n        }\\n        return B;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] A) {\\n        int i = 0, j = A.length -1, k=j;\\n        int[] B = new int[A.length];\\n        while(k>=0){\\n            int x = A[i]*A[i], y = A[j]*A[j];\\n            if(x >= y){\\n                B[k] = x;\\n                i++;\\n            } else{\\n                B[k] = y;\\n                j--;\\n            }\\n\\t\\t\\tk--;\\n        }\\n        return B;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 226530,
                "title": "javascript-o-n-solution-w-explanation-11-lines-no-arrays-sort",
                "content": "```Given an array of integers A sorted in non-decreasing order, return an array of the squares of each number, also in sorted non-decreasing order.```\\n\\nUsing the given, we know that the array is already in sorted order. \\nThis tells us:\\n1. The next largest square will be on either end of the array.\\n2. We can use two pointers starting on each end to find the largest square then append it to our result. We move the pointer that held the larger square.\\n3. Once our pointers have crossed we have covered every value in the original array and can return our result array.\\n\\nNote: *Instead of using the unshift() function I have decided to use push and then reversing the whole array because unshift is a costly function that has to move all of the elements of the array.*\\n\\n```\\nvar sortedSquares = function(A) {\\n    let res = [];\\n    let up = 0, down = A.length-1;\\n    \\n    let a = A[up]*A[up];\\n    let b = A[down]*A[down];\\n    \\n    while (up <= down) {\\n        if (a > b) {\\n            res.push(a);\\n            up++;\\n            a = A[up]*A[up];\\n        } else {\\n            res.push(b);\\n            down--;\\n            b = A[down]*A[down];\\n        }\\n    }\\n    \\n    return res.reverse();\\n};",
                "solutionTags": [],
                "code": "```Given an array of integers A sorted in non-decreasing order, return an array of the squares of each number, also in sorted non-decreasing order.```",
                "codeTag": "Unknown"
            },
            {
                "id": 1663563,
                "title": "2-javascript-solutions-with-explanations",
                "content": "There\\'s at least 2 ways which we can solve this problem:\\n\\n1. As the question suggests, it\\'s easy to map through our input, square each number and then sort the output.\\n\\n```\\nreturn nums\\n        .map(num => Math.pow(num, 2))\\n        .sort((numOne, numTwo) => numOne - numTwo);\\n```\\n\\nThis would result in an algorithm that is `O(n log n)` due to the underlying quicksort and requires constant `O(log n)` space.\\n\\n2. We could instead take advantage of the property of the array being sorted and instead create an output array and 2 pointers that will increment/decrement depending on the result of the squaring of each and comparing them.\\n\\n```\\nconst sortedSquares = nums => {\\n    const sorted = new Array(nums.length);\\n    \\n    let start = 0;\\n    let end = sorted.length - 1;\\n    \\n    for (let insert = end; insert >= 0; insert--) {\\n        const squaredStart = Math.pow(nums[start], 2);\\n        const squaredEnd = Math.pow(nums[end], 2);\\n        \\n        if (squaredStart > squaredEnd) {\\n            sorted[insert] = squaredStart;\\n            start++;\\n        } else {\\n            sorted[insert] = squaredEnd;\\n            end--;\\n        }\\n    }\\n    \\n    return sorted;\\n};\\n```\\n\\nThis results in an algorithm that requires `O(n)` time as traverse our entire input array and `O(n)` space as our created array is dependent on the size of our input.\\n\\nHappy coding :)",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nreturn nums\\n        .map(num => Math.pow(num, 2))\\n        .sort((numOne, numTwo) => numOne - numTwo);\\n```\n```\\nconst sortedSquares = nums => {\\n    const sorted = new Array(nums.length);\\n    \\n    let start = 0;\\n    let end = sorted.length - 1;\\n    \\n    for (let insert = end; insert >= 0; insert--) {\\n        const squaredStart = Math.pow(nums[start], 2);\\n        const squaredEnd = Math.pow(nums[end], 2);\\n        \\n        if (squaredStart > squaredEnd) {\\n            sorted[insert] = squaredStart;\\n            start++;\\n        } else {\\n            sorted[insert] = squaredEnd;\\n            end--;\\n        }\\n    }\\n    \\n    return sorted;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1596760,
                "title": "easy-c-solution-o-n-time-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        \\n        vector<int> res(nums.size());\\n        int l = 0, r = nums.size() - 1;\\n        \\n        for (int k = nums.size() - 1; k >= 0; k--) {\\n            \\n            if (abs(nums[r]) > abs(nums[l])) \\n                res[k] = nums[r] * nums[r--];\\n            else \\n                res[k] = nums[l] * nums[l++];\\n            \\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nIf you like the solution then please upvote. Open to queries.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        \\n        vector<int> res(nums.size());\\n        int l = 0, r = nums.size() - 1;\\n        \\n        for (int k = nums.size() - 1; k >= 0; k--) {\\n            \\n            if (abs(nums[r]) > abs(nums[l])) \\n                res[k] = nums[r] * nums[r--];\\n            else \\n                res[k] = nums[l] * nums[l++];\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1472964,
                "title": "commented-rust-o-n-beats-99",
                "content": "```\\nimpl Solution {\\n    pub fn sorted_squares(nums: Vec<i32>) -> Vec<i32> {\\n        // The code works without this, but it removes a\\n        // lot of useless allocations for a base case\\n        if nums.len() == 1 {\\n            return vec![i32::pow(nums[0], 2)];\\n        }\\n        \\n        // We\\'ll use this for inserting later\\n        let mut location = nums.len();\\n        \\n        // Pre-allocate so we can start indexing from the end\\n        let mut output = vec![0; location];\\n        \\n        // These are our markers for the 2 ends of the array\\n        let mut left = 0 as usize;\\n        let mut right = nums.len() - 1;\\n        \\n        // We\\'re only going to compute each value once\\n        let mut computed_left = i32::pow(nums[left], 2);\\n        let mut computed_right = i32::pow(nums[right], 2);\\n        \\n        while left != right {\\n            // Every loop we\\'re moving one spot further to the left\\n            location-=1;\\n            // Every loop iteration we check which value is larger and\\n            // put that at the end of the output vector that we pre-allocated\\n            if computed_left > computed_right {\\n                output[location] = computed_left;\\n                left+=1;\\n                computed_left = i32::pow(nums[left], 2);\\n            } else {\\n                output[location] = computed_right;\\n                right-=1;\\n                computed_right = i32::pow(nums[right], 2);\\n            }\\n        }\\n        // Could do either one, because at this point they should be the\\n        // same index / value\\n        output[0] = computed_right;\\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Two Pointers"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn sorted_squares(nums: Vec<i32>) -> Vec<i32> {\\n        // The code works without this, but it removes a\\n        // lot of useless allocations for a base case\\n        if nums.len() == 1 {\\n            return vec![i32::pow(nums[0], 2)];\\n        }\\n        \\n        // We\\'ll use this for inserting later\\n        let mut location = nums.len();\\n        \\n        // Pre-allocate so we can start indexing from the end\\n        let mut output = vec![0; location];\\n        \\n        // These are our markers for the 2 ends of the array\\n        let mut left = 0 as usize;\\n        let mut right = nums.len() - 1;\\n        \\n        // We\\'re only going to compute each value once\\n        let mut computed_left = i32::pow(nums[left], 2);\\n        let mut computed_right = i32::pow(nums[right], 2);\\n        \\n        while left != right {\\n            // Every loop we\\'re moving one spot further to the left\\n            location-=1;\\n            // Every loop iteration we check which value is larger and\\n            // put that at the end of the output vector that we pre-allocated\\n            if computed_left > computed_right {\\n                output[location] = computed_left;\\n                left+=1;\\n                computed_left = i32::pow(nums[left], 2);\\n            } else {\\n                output[location] = computed_right;\\n                right-=1;\\n                computed_right = i32::pow(nums[right], 2);\\n            }\\n        }\\n        // Could do either one, because at this point they should be the\\n        // same index / value\\n        output[0] = computed_right;\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1217913,
                "title": "c-two-pointers",
                "content": "\\n**1st approach :** 1) Take the squares of each element and store it.\\n                                2) Then finally sort the vector and return it.\\n                                3) T.C - O(NlogN)\\n **2 approach :** Take two pointers at either ends of array.\\n                              Check abs value of both the elements and fill \\n\\t\\t\\t\\t\\t\\t\\t  the array backwards bcoz largest value will be at last\\n\\n\\n\\t\\tvector<int> sortedSquares(vector<int>& nums) {\\n\\t\\t\\t\\t\\t\\t\\tvector<int>ans(nums.size());\\n\\t\\t\\t\\t\\t\\t\\tint i=0;\\n\\t\\t\\t\\t\\t\\t\\tint j=nums.size()-1;\\n\\t\\t\\t\\t\\t\\t\\tfor(int k=nums.size()-1;k>=0;k--)\\n\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tif(abs(nums[i]) < abs(nums[j]))\\n\\t\\t\\t\\t\\t\\t\\t\\t   {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   ans[k] = nums[j]*nums[j];\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   j--;\\n\\t\\t\\t\\t\\t\\t\\t\\t   }\\n\\t\\t\\t\\t\\t\\t\\t\\t   else\\n\\t\\t\\t\\t\\t\\t\\t\\t   {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   ans[k] = nums[i]*nums[i];\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   i++;\\n\\t\\t\\t\\t\\t\\t\\t\\t   }\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t   return ans;\\n\\t\\t\\t\\t\\t\\t}",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "\\n**1st approach :** 1) Take the squares of each element and store it.\\n                                2) Then finally sort the vector and return it.\\n                                3) T.C - O(NlogN)\\n **2 approach :** Take two pointers at either ends of array.\\n                              Check abs value of both the elements and fill \\n\\t\\t\\t\\t\\t\\t\\t  the array backwards bcoz largest value will be at last\\n\\n\\n\\t\\tvector<int> sortedSquares(vector<int>& nums) {\\n\\t\\t\\t\\t\\t\\t\\tvector<int>ans(nums.size());\\n\\t\\t\\t\\t\\t\\t\\tint i=0;\\n\\t\\t\\t\\t\\t\\t\\tint j=nums.size()-1;\\n\\t\\t\\t\\t\\t\\t\\tfor(int k=nums.size()-1;k>=0;k--)\\n\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tif(abs(nums[i]) < abs(nums[j]))\\n\\t\\t\\t\\t\\t\\t\\t\\t   {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   ans[k] = nums[j]*nums[j];\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   j--;\\n\\t\\t\\t\\t\\t\\t\\t\\t   }\\n\\t\\t\\t\\t\\t\\t\\t\\t   else\\n\\t\\t\\t\\t\\t\\t\\t\\t   {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   ans[k] = nums[i]*nums[i];\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   i++;\\n\\t\\t\\t\\t\\t\\t\\t\\t   }\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t   return ans;\\n\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 3834119,
                "title": "most-optimal-code-clean-code-explanation-c",
                "content": "# Intuition & Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- The problem which can be solved using inbuilt sorting function, but we need to execute this in O(n).\\n- We\\'ll be dealing with two pointers with NO DOUBT.\\n- Let\\'s point to end and and start.\\n- The one which is greater put at the end.\\n- And decrement the pointer of ans vector.\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int i=0,j=nums.size()-1, k=nums.size()-1;\\n        vector<int>v(nums.size(),0);\\n        while(i<=j)\\n        {\\n            if(abs(nums[i])>=abs(nums[j]))\\n             v[k--]=(pow(nums[i++],2));\\n            \\n            else v[k--]=(pow(nums[j--],2));\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int i=0,j=nums.size()-1, k=nums.size()-1;\\n        vector<int>v(nums.size(),0);\\n        while(i<=j)\\n        {\\n            if(abs(nums[i])>=abs(nums[j]))\\n             v[k--]=(pow(nums[i++],2));\\n            \\n            else v[k--]=(pow(nums[j--],2));\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3123725,
                "title": "c-3-line-sol-must-watch-2023-method",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& v) {\\n        for_each(v.begin(),v.end(),[](int &x){x*=x;});\\n        sort(v.begin(),v.end());\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& v) {\\n        for_each(v.begin(),v.end(),[](int &x){x*=x;});\\n        sort(v.begin(),v.end());\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1868051,
                "title": "java-optimized-easy",
                "content": "## **Please Upvote if you understood this** (\\uFF5E\\uFFE3\\u25BD\\uFFE3)\\uFF5E\\n```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n//         for(int i=0;i<nums.length;i++) nums[i]*=nums[i];\\n//         Arrays.sort(nums);\\n//         return nums;\\n        int start = 0;\\n        int end = nums.length - 1;\\n        int index = end;\\n        int[] res = new int[nums.length];\\n        while(start<=end){\\n            if(Math.abs(nums[start])>Math.abs(nums[end])){\\n                res[index--]=nums[start]*nums[start];\\n                start++;\\n            }\\n            else{\\n                res[index--]=nums[end]*nums[end];\\n                end--;\\n            }\\n        }\\n        return res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n//         for(int i=0;i<nums.length;i++) nums[i]*=nums[i];\\n//         Arrays.sort(nums);\\n//         return nums;\\n        int start = 0;\\n        int end = nums.length - 1;\\n        int index = end;\\n        int[] res = new int[nums.length];\\n        while(start<=end){\\n            if(Math.abs(nums[start])>Math.abs(nums[end])){\\n                res[index--]=nums[start]*nums[start];\\n                start++;\\n            }\\n            else{\\n                res[index--]=nums[end]*nums[end];\\n                end--;\\n            }\\n        }\\n        return res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1763243,
                "title": "java-without-sorting-one-pass-solution-o-n",
                "content": "```\\nclass Solution \\n{\\n    public int[] sortedSquares(int[] nums) \\n    {\\n        int n=nums.length,i=0,j,x=0;\\n        int a[] = new int[n];     \\n        while(i<n && nums[i]<0)\\n            i++;\\n        j=i-1;\\n        while(j>=0 && i<n)\\n        {\\n            if(nums[i] < -nums[j])\\n                a[x++]=nums[i]*nums[i++];\\n            else\\n                a[x++]=nums[j]*nums[j--];\\n        }\\n        while(j>=0)\\n            a[x++]=nums[j]*nums[j--];\\n        while(i<n)\\n            a[x++]=nums[i]*nums[i++];\\n        //Arrays.sort(nums);\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int[] sortedSquares(int[] nums) \\n    {\\n        int n=nums.length,i=0,j,x=0;\\n        int a[] = new int[n];     \\n        while(i<n && nums[i]<0)\\n            i++;\\n        j=i-1;\\n        while(j>=0 && i<n)\\n        {\\n            if(nums[i] < -nums[j])\\n                a[x++]=nums[i]*nums[i++];\\n            else\\n                a[x++]=nums[j]*nums[j--];\\n        }\\n        while(j>=0)\\n            a[x++]=nums[j]*nums[j--];\\n        while(i<n)\\n            a[x++]=nums[i]*nums[i++];\\n        //Arrays.sort(nums);\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1681614,
                "title": "swift-two-pointers-o-n",
                "content": "```swift\\nfunc sortedSquares(_ nums: [Int]) -> [Int] {\\n    var right = nums.count - 1\\n    var left = 0\\n    \\n    var result = nums\\n    var index = right\\n    while index >= 0 {\\n        if abs(nums[left]) < abs(nums[right]) {\\n            result[index] = nums[right] * nums[right]\\n            right -= 1\\n        } else {\\n            result[index] = nums[left] * nums[left]\\n            left += 1\\n        }\\n        index -= 1\\n    }\\n    return result\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```swift\\nfunc sortedSquares(_ nums: [Int]) -> [Int] {\\n    var right = nums.count - 1\\n    var left = 0\\n    \\n    var result = nums\\n    var index = right\\n    while index >= 0 {\\n        if abs(nums[left]) < abs(nums[right]) {\\n            result[index] = nums[right] * nums[right]\\n            right -= 1\\n        } else {\\n            result[index] = nums[left] * nums[left]\\n            left += 1\\n        }\\n        index -= 1\\n    }\\n    return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1592437,
                "title": "python-two-pointer-approach",
                "content": "```\\n# Two pointer approach\\nclass Solution(object):\\n    def sortedsquares(self, nums):\\n        result = [None for _ in nums]\\n        left, right = 0, len(nums)-1\\n        for i in range(len(nums)-1,-1,-1):\\n            if abs(nums[left]) > abs(nums[right]):\\n                result[i] = nums[left] ** 2\\n                left += 1\\n            else:\\n                result[i] = nums[right] ** 2\\n                right -= 1\\n        return result\\n```\\n\\n\\n```\\n# one liner solution:\\nclass Solution(object):\\n    def sortedSquares(self, nums):\\n        return sorted ([i*i for i in nums])\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\n# Two pointer approach\\nclass Solution(object):\\n    def sortedsquares(self, nums):\\n        result = [None for _ in nums]\\n        left, right = 0, len(nums)-1\\n        for i in range(len(nums)-1,-1,-1):\\n            if abs(nums[left]) > abs(nums[right]):\\n                result[i] = nums[left] ** 2\\n                left += 1\\n            else:\\n                result[i] = nums[right] ** 2\\n                right -= 1\\n        return result\\n```\n```\\n# one liner solution:\\nclass Solution(object):\\n    def sortedSquares(self, nums):\\n        return sorted ([i*i for i in nums])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1422991,
                "title": "java-two-pointer-approach-o-n-faster-than-100",
                "content": "``` class Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        \\n        if (nums == null || nums.length == 0) return nums;\\n        \\n        int len = nums.length;\\n        \\n        int result[] = new int[len];\\n        int firstPtr = 0, lastPtr = len-1;\\n        int k = len - 1;\\n        while (k >= 0) {\\n            int firstSq = nums[firstPtr] * nums[firstPtr];\\n            int lastSq = nums[lastPtr] * nums[lastPtr];\\n            \\n            if (firstSq >= lastSq) {\\n                result[k] = firstSq;\\n                firstPtr++;\\n            } else {\\n                result[k] = lastSq;\\n                lastPtr--;\\n            }\\n            \\n            k--;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "``` class Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        \\n        if (nums == null || nums.length == 0) return nums;\\n        \\n        int len = nums.length;\\n        \\n        int result[] = new int[len];\\n        int firstPtr = 0, lastPtr = len-1;\\n        int k = len - 1;\\n        while (k >= 0) {\\n            int firstSq = nums[firstPtr] * nums[firstPtr];\\n            int lastSq = nums[lastPtr] * nums[lastPtr];\\n            \\n            if (firstSq >= lastSq) {\\n                result[k] = firstSq;\\n                firstPtr++;\\n            } else {\\n                result[k] = lastSq;\\n                lastPtr--;\\n            }\\n            \\n            k--;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 763982,
                "title": "c-o-n-solution",
                "content": "```\\nint* sortedSquares(int* A, int ASize, int* returnSize)\\n{\\n    int* res = (int *)malloc(sizeof(int) * ASize);\\n    *returnSize = ASize;\\n    int *pos = A + ASize - 1, *neg = A, k = ASize - 1;\\n    while (pos != neg - 1)\\n    {\\n        if (*pos >= abs(*neg))\\n        {\\n            res[k] = (*pos) * (*pos);\\n            k--;\\n            pos--;\\n        }\\n        else\\n        {\\n            res[k] = (*neg) * (*neg);\\n            k--;\\n            neg++;\\n        }\\n    }\\n    return res;\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nint* sortedSquares(int* A, int ASize, int* returnSize)\\n{\\n    int* res = (int *)malloc(sizeof(int) * ASize);\\n    *returnSize = ASize;\\n    int *pos = A + ASize - 1, *neg = A, k = ASize - 1;\\n    while (pos != neg - 1)\\n    {\\n        if (*pos >= abs(*neg))\\n        {\\n            res[k] = (*pos) * (*pos);\\n            k--;\\n            pos--;\\n        }\\n        else\\n        {\\n            res[k] = (*neg) * (*neg);\\n            k--;\\n            neg++;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 235219,
                "title": "runtime-error",
                "content": "When I execute the code follows, the error info showed like this.\\nFinished in N/A\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==29==ERROR: AddressSanitizer: SEGV on unknown address 0x180a7fff8012 (pc 0x0000004121a3 bp 0x7ffdc83ec450 sp 0x7ffdc83ec080 T0)\\n==29==The signal is caused by a READ memory access.\\n    #3 0x7fccfd9322e0 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x202e0)\\n\\nAddressSanitizer can not provide additional info.\\n==29==ABORTING\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& A) {\\n        int left = 0;\\n        int right = A.size()-1;\\n        vector <int> ans;\\n        for(int j=A.size()-1;j>=0;j--){\\n            if(A[left]*A[left]>A[right]*A[right]){\\n                ans.insert(A.begin()+j,A[left]*A[left]);\\n                left++;\\n            }\\n            else{\\n                ans.insert(A.begin()+j,A[right]*A[right]);\\n                right--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& A) {\\n        int left = 0;\\n        int right = A.size()-1;\\n        vector <int> ans;\\n        for(int j=A.size()-1;j>=0;j--){\\n            if(A[left]*A[left]>A[right]*A[right]){\\n                ans.insert(A.begin()+j,A[left]*A[left]);\\n                left++;\\n            }\\n            else{\\n                ans.insert(A.begin()+j,A[right]*A[right]);\\n                right--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 222278,
                "title": "java-3-lines-o-n-time",
                "content": "```\\n    public int[] sortedSquares(int[] A) {\\n        int[] r = new int[A.length];\\n        for(int d=A.length-1,u=0,i=d; i>=0; i--) r[i] = -A[u]>A[d] ? A[u]*A[u++] : A[d]*A[d--];\\n        return r;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[] sortedSquares(int[] A) {\\n        int[] r = new int[A.length];\\n        for(int d=A.length-1,u=0,i=d; i>=0; i--) r[i] = -A[u]>A[d] ? A[u]*A[u++] : A[d]*A[d--];\\n        return r;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3101079,
                "title": "1ms-java-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int[] array = new int[nums.length];\\n        int i = 0;\\n        int j = nums.length-1;\\n        int k = nums.length-1;\\n        while(i<=j){\\n            int val1 = nums[i]*nums[i];\\n            int val2 = nums[j]*nums[j];\\n            if(val1 > val2){\\n                array[k] = val1;\\n                i++;\\n            }else{\\n                array[k] = val2;\\n                j--;\\n            }\\n            k--;\\n        }\\n        return array;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int[] array = new int[nums.length];\\n        int i = 0;\\n        int j = nums.length-1;\\n        int k = nums.length-1;\\n        while(i<=j){\\n            int val1 = nums[i]*nums[i];\\n            int val2 = nums[j]*nums[j];\\n            if(val1 > val2){\\n                array[k] = val1;\\n                i++;\\n            }else{\\n                array[k] = val2;\\n                j--;\\n            }\\n            k--;\\n        }\\n        return array;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2796230,
                "title": "2ms-solution-fully-explained-two-pointers-o-n-java",
                "content": "# Approach : Two Pointers Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity : O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Request \\uD83D\\uDE4F\\uD83D\\uDE4F:\\n- If you find this solution easy to understand and helpful.\\nThen please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n\\n# Code (Explained in comments below \\uD83D\\uDC47\\uD83D\\uDC47)\\n```\\nclass Solution \\n{\\n    public int[] sortedSquares(int[] nums) \\n    {\\n        int i=0;//pointer 1\\n        int j=nums.length-1;//pointer 2\\n        int[] arr=new int[nums.length];//new array to store sorted squares\\n        int l=nums.length-1;//index variable\\n        while(i<=j)// Create a loop until i is less than j\\n        {\\n            int sq1=nums[i]*nums[i];//square of pointer 1\\n            int sq2=nums[j]*nums[j];//square of pointer 2\\n            if(sq1<sq2)//if 1st element is smaller than last element\\n            {\\n                arr[l--]=sq2;//storing maximum value at last index\\n                j--;\\n            }\\n            else//if 1st element is greater than last element\\n            {\\n                arr[l--]=sq1;//storing minimum value at first index\\n                i++;\\n            }\\n\\n        }return arr;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int[] sortedSquares(int[] nums) \\n    {\\n        int i=0;//pointer 1\\n        int j=nums.length-1;//pointer 2\\n        int[] arr=new int[nums.length];//new array to store sorted squares\\n        int l=nums.length-1;//index variable\\n        while(i<=j)// Create a loop until i is less than j\\n        {\\n            int sq1=nums[i]*nums[i];//square of pointer 1\\n            int sq2=nums[j]*nums[j];//square of pointer 2\\n            if(sq1<sq2)//if 1st element is smaller than last element\\n            {\\n                arr[l--]=sq2;//storing maximum value at last index\\n                j--;\\n            }\\n            else//if 1st element is greater than last element\\n            {\\n                arr[l--]=sq1;//storing minimum value at first index\\n                i++;\\n            }\\n\\n        }return arr;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2720654,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] A) {\\n        int n = A.length;\\n        int[] result = new int[n];\\n        int i = 0, j = n - 1;\\n        for (int p = n - 1; p >= 0; p--) {\\n            if (Math.abs(A[i]) > Math.abs(A[j])) {\\n                result[p] = A[i] * A[i];\\n                i++;\\n            } else {\\n                result[p] = A[j] * A[j];\\n                j--;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] A) {\\n        int n = A.length;\\n        int[] result = new int[n];\\n        int i = 0, j = n - 1;\\n        for (int p = n - 1; p >= 0; p--) {\\n            if (Math.abs(A[i]) > Math.abs(A[j])) {\\n                result[p] = A[i] * A[i];\\n                i++;\\n            } else {\\n                result[p] = A[j] * A[j];\\n                j--;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2254389,
                "title": "3-approaches-clean-and-concise-code-two-pointers-c",
                "content": "Here, I will be discussing 3 approaches to this problem.\\n\\n**Approach 1: Using Sorting**\\n\\nThe simplest solution would be just using built-in sort function and you can say it would work by squaring the elements in-place (over-writing) them and finally sorting it.\\n\\n```\\n\\t\\tint n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            nums[i]=pow(nums[i],2);\\n        }\\n        sort(nums.begin(),nums.end());\\n        return nums;\\n```\\n\\n**Time Complexity: O(nlogn)**\\n**Space Complexity: O(1)**\\n\\n\\n**Approach 2: Two Pointers - 1**\\n\\nLet\\'s take an example with negative and positive numbers, like:\\n\\n[-4, -2, 0, 1, 3]\\n\\nSince, we need to put squares in result array, we can consider that all numbers are positive (since: -4 ** 2 = 4 ** 2 = 16). Now our array looks like it sorted from middle to outside on both sides:\\n\\n[4, 2, 0, 1, 3]\\n\\nNow, we can have two pointers \"left\" to left most element, \"right\" to the right most element.\\nCreate \"res\" result array with the same size as A.\\nMove from right to left in res and check max(abs(A[l]), abs(A[r])), then correspondingly move left++ or right--.\\n\\n\\n```\\n\\t\\tint n=nums.size();\\n        vector<int> res(n);\\n        int left=0;\\n        int right=n-1;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(abs(nums[left])>abs(nums[right])) res[i]=nums[left]*nums[left++];\\n            else res[i]=nums[right]*nums[right--];\\n        }\\n        return res;\\n```\\n\\n**Time Complexity: O(n)**\\n**Space Complexity: O(n)**\\n\\n**Approach 3: Two Pointers - 2**\\nFirstly, why another two pointers approach? \\n\\nWell, after a bit of thinking you may notice that after squaring numbers, firstly, all negative numbers which are big would go further away from zero and negative numbers smaller relatively would meet at zero with the positive numbers.\\n\\nNow, the same goes with the case of positive numbers squared. Thus, it is a natural solution of merging two sorted lists from the middle will do. Just use two pointers that go from the middle outwards. This is intutitive and really easy to undertsand.\\n\\n```\\n\\t\\t//Two Pointers-2\\n        int n=nums.size();\\n        vector<int> res(n);\\n        int p=0;\\n        while(p<n && nums[p]<0) p++;\\n        int neg=p-1;\\n        int i;\\n        for(i=0;neg>=0 && p<n;i++)\\n        {\\n            if(nums[neg]*nums[neg]<nums[p]*nums[p]) res[i]=nums[neg]*nums[neg--];\\n            else res[i]=nums[p]*nums[p++];\\n        }\\n\\t\\t//For leftover positive elements\\n        for(;p<n;i++)\\n            res[i]=nums[p]*nums[p++];\\n\\t\\t\\n\\t\\t//For leftover negative elements\\n        for(;neg>=0;i++)\\n            res[i]=nums[neg]*nums[neg--];\\n        \\n\\t\\treturn res;\\n\\n```\\n**Time Complexity: O(n)**\\n**Space Complexity: O(n)**\\n\\n**Please upvote this solution if you liked it! \\uD83D\\uDE00\\u270C\\uFE0F**",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\n\\t\\tint n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            nums[i]=pow(nums[i],2);\\n        }\\n        sort(nums.begin(),nums.end());\\n        return nums;\\n```\n```\\n\\t\\tint n=nums.size();\\n        vector<int> res(n);\\n        int left=0;\\n        int right=n-1;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(abs(nums[left])>abs(nums[right])) res[i]=nums[left]*nums[left++];\\n            else res[i]=nums[right]*nums[right--];\\n        }\\n        return res;\\n```\n```\\n\\t\\t//Two Pointers-2\\n        int n=nums.size();\\n        vector<int> res(n);\\n        int p=0;\\n        while(p<n && nums[p]<0) p++;\\n        int neg=p-1;\\n        int i;\\n        for(i=0;neg>=0 && p<n;i++)\\n        {\\n            if(nums[neg]*nums[neg]<nums[p]*nums[p]) res[i]=nums[neg]*nums[neg--];\\n            else res[i]=nums[p]*nums[p++];\\n        }\\n\\t\\t//For leftover positive elements\\n        for(;p<n;i++)\\n            res[i]=nums[p]*nums[p++];\\n\\t\\t\\n\\t\\t//For leftover negative elements\\n        for(;neg>=0;i++)\\n            res[i]=nums[neg]*nums[neg--];\\n        \\n\\t\\treturn res;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2013937,
                "title": "two-pointers-and-one-liner-approach-python",
                "content": "**One Liner Approach**\\n```\\nreturn sorted(i*i for i in nums)\\n```\\n\\n**Two Pointers Approach**\\n```\\n        n = len(nums)\\n        result = [0] * n\\n        left = 0\\n        right = n - 1\\n        for i in range(n - 1, -1, -1):\\n            if abs(nums[left]) < abs(nums[right]):\\n                square = nums[right]\\n                right -= 1\\n            else:\\n                square = nums[left]\\n                left += 1\\n            result[i] = square * square\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nreturn sorted(i*i for i in nums)\\n```\n```\\n        n = len(nums)\\n        result = [0] * n\\n        left = 0\\n        right = n - 1\\n        for i in range(n - 1, -1, -1):\\n            if abs(nums[left]) < abs(nums[right]):\\n                square = nums[right]\\n                right -= 1\\n            else:\\n                square = nums[left]\\n                left += 1\\n            result[i] = square * square\\n        return result\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1791585,
                "title": "python-solution",
                "content": "Here\\'s my solution:\\n```\\n# Runtime: 329 ms, faster than 46.92% of Python3 online submissions for Squares of a Sorted Array.\\n# Memory Usage: 16.3 MB, less than 40.77% of Python3 online submissions for Squares of a Sorted Array.\\nclass Solution:\\n    def sortedSquares(self, nums):\\n        i, j, n = 0, len(nums)-1, len(nums)-1\\n        result = [0 for _ in range(len(nums))]\\n        while n>=0:\\n            if abs(nums[i])>abs(nums[j]):\\n                result[n] = nums[i]**2\\n                i += 1\\n            else:\\n                result[n] = nums[j]**2\\n                j -= 1\\n            n -= 1\\n        return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Runtime: 329 ms, faster than 46.92% of Python3 online submissions for Squares of a Sorted Array.\\n# Memory Usage: 16.3 MB, less than 40.77% of Python3 online submissions for Squares of a Sorted Array.\\nclass Solution:\\n    def sortedSquares(self, nums):\\n        i, j, n = 0, len(nums)-1, len(nums)-1\\n        result = [0 for _ in range(len(nums))]\\n        while n>=0:\\n            if abs(nums[i])>abs(nums[j]):\\n                result[n] = nums[i]**2\\n                i += 1\\n            else:\\n                result[n] = nums[j]**2\\n                j -= 1\\n            n -= 1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1701883,
                "title": "easy-to-understand-solution-with-comments-explaination",
                "content": "If this solution helps please consider upvoting\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n//         This takes O(N) time\\n//         declare a new vector\\n        vector<int> res(nums.size());\\n//         two pointer taken for sorting\\n        int left=0,right=nums.size()-1;\\n//         start from the last \\n        for(int i =nums.size()-1;i>=0;i--){\\n//             used abs because we know array is sorted to all negative numbers will be on the left\\n            if(abs(nums[left])>nums[right]){\\n                res[i]=nums[left]*nums[left];\\n                left++;\\n            }\\n//             else we add the last element\\n            else{\\n                res[i]=nums[right]*nums[right];\\n                right--;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n//         This takes O(N) time\\n//         declare a new vector\\n        vector<int> res(nums.size());\\n//         two pointer taken for sorting\\n        int left=0,right=nums.size()-1;\\n//         start from the last \\n        for(int i =nums.size()-1;i>=0;i--){\\n//             used abs because we know array is sorted to all negative numbers will be on the left\\n            if(abs(nums[left])>nums[right]){\\n                res[i]=nums[left]*nums[left];\\n                left++;\\n            }\\n//             else we add the last element\\n            else{\\n                res[i]=nums[right]*nums[right];\\n                right--;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1678024,
                "title": "python-o-n-solution",
                "content": "```\\ndef sortedSquares(self, nums: List[int]) -> List[int]:\\n        lowIndex=0\\n        highIndex=len(nums)-1\\n        Index=len(nums)-1\\n        a=[0]*len(nums)\\n        while(lowIndex<=highIndex):\\n            if(abs(nums[lowIndex])>=abs(nums[highIndex])):\\n                a[Index]=nums[lowIndex]*nums[lowIndex]\\n                lowIndex+=1\\n            else:\\n                a[Index]=nums[highIndex]*nums[highIndex]\\n                highIndex-=1\\n            Index-=1\\n        return a\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\ndef sortedSquares(self, nums: List[int]) -> List[int]:\\n        lowIndex=0\\n        highIndex=len(nums)-1\\n        Index=len(nums)-1\\n        a=[0]*len(nums)\\n        while(lowIndex<=highIndex):\\n            if(abs(nums[lowIndex])>=abs(nums[highIndex])):\\n                a[Index]=nums[lowIndex]*nums[lowIndex]\\n                lowIndex+=1\\n            else:\\n                a[Index]=nums[highIndex]*nums[highIndex]\\n                highIndex-=1\\n            Index-=1\\n        return a\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1627809,
                "title": "simple-java-solution-o-n-time",
                "content": "**Upvote if you Got It** \\uD83D\\uDE42\\nclass Solution {\\n\\n    public int[] sortedSquares(int[] nums) {\\n        int l=0,r=nums.length-1,k=r;\\n        int[] res = new int[nums.length];\\n        while(l<=r){\\n            if(Math.abs(nums[l])>Math.abs(nums[r])){\\n                res[k]=nums[l]*nums[l];\\n                l++;\\n            }\\n            else{\\n                res[k]=nums[r]*nums[r];\\n                r--;\\n            }\\n            k--;\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n\\n    public int[] sortedSquares(int[] nums) {\\n        int l=0,r=nums.length-1,k=r;\\n        int[] res = new int[nums.length];\\n        while(l<=r){\\n            if(Math.abs(nums[l])>Math.abs(nums[r])){\\n                res[k]=nums[l]*nums[l];\\n                l++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1413346,
                "title": "java-solution-from-pratik",
                "content": "**Solution 1: Sorting Approach**\\n\\n**Algorithm**:\\n1. Create an array of the squares of each element\\n1. Sort the array of squares.\\n\\n**Time Complexity**: `O(N log N)`, where `N` is the length of input array.\\n**Space complexity**: `O(log N)` In Java, the Arrays.sort() is implemented as a variant of quicksort algorithm whose space complexity is `O(log N)`.\\n\\n```\\nclass Solution {\\n    public int[] sortedSquares(int[] A) {\\n        int[] result = new int[A.length];\\n        \\n        for (int i = 0; i < A.length; i++) {\\n            result[i] = A[i] * A[i];\\n        }\\n        \\n        Arrays.sort(result);\\n        return result;\\n    }\\n}\\n```\\n\\n**Solution 2: Two Pointer Approach**\\n\\n**Intuition**:\\n- Since the array `A` is sorted, loosely speaking it has some negative elements with squares in decreasing order, then some positive elements with squares in increasing order.\\n- For example, with `[-3, -2, -1, 4, 5, 6]`, we have the negative part `[-3, -2, -1]` with squares `[9, 4, 1]`, and the positive part `[4, 5, 6]` with squares `[16, 25, 36]`\\n- Now, this is a variant of merging two sorted arrays.\\n\\n**Algorithm**:\\n1. We can use two pointers, one at each end, to iteratively collect the larger square to the result array.\\n\\n**Time Complexity**: `O(N)`, where `N` is the length of input array.\\n**Space Complexity**: `O(N)` if we consider the space required for result array and `O(1)` otherwise.\\n\\n```\\nclass Solution {\\n    public int[] sortedSquares(int[] A) {\\n        int[] result = new int[A.length];\\n        int start = 0;\\n        int end = A.length - 1;\\n\\n        for (int i = A.length - 1; i >= 0; i--) {\\n            if (Math.abs(A[start]) < Math.abs(A[end])) {\\n                result[i] = A[end] * A[end];\\n                end--;\\n            } else {\\n                result[i] = A[start] * A[start];\\n                start++;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] A) {\\n        int[] result = new int[A.length];\\n        \\n        for (int i = 0; i < A.length; i++) {\\n            result[i] = A[i] * A[i];\\n        }\\n        \\n        Arrays.sort(result);\\n        return result;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] sortedSquares(int[] A) {\\n        int[] result = new int[A.length];\\n        int start = 0;\\n        int end = A.length - 1;\\n\\n        for (int i = A.length - 1; i >= 0; i--) {\\n            if (Math.abs(A[start]) < Math.abs(A[end])) {\\n                result[i] = A[end] * A[end];\\n                end--;\\n            } else {\\n                result[i] = A[start] * A[start];\\n                start++;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1160450,
                "title": "python-stack-o-n-memory-o-n",
                "content": "Traverse the array nums once.\\nFor elements which are negative, just append them to the stack, and once you start encountering non-negative elements, start clearing the stack by comparing current element to last value in stack and then appending the squared value to output accordingly. \\nFinally, if all elements have been seen in nums, start clearing stack by appending squared value to output. \\n\\n```\\nclass Solution(object):\\n    def sortedSquares(self, nums):\\n        stack = []\\n        output = []\\n        for i in range(len(nums)):\\n            if nums[i] < 0:\\n                stack.append(-nums[i])\\n            else:\\n                while stack and stack[-1] < nums[i]:\\n                    output.append(stack.pop() ** 2)\\n                output.append(nums[i] ** 2)\\n        while stack:\\n            output.append(stack.pop() ** 2)\\n        return output\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution(object):\\n    def sortedSquares(self, nums):\\n        stack = []\\n        output = []\\n        for i in range(len(nums)):\\n            if nums[i] < 0:\\n                stack.append(-nums[i])\\n            else:\\n                while stack and stack[-1] < nums[i]:\\n                    output.append(stack.pop() ** 2)\\n                output.append(nums[i] ** 2)\\n        while stack:\\n            output.append(stack.pop() ** 2)\\n        return output\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1088214,
                "title": "kotlin-simple",
                "content": "Two pointers approach:\\n```\\n    fun sortedSquares(nums: IntArray): IntArray {\\n        val arr = IntArray(nums.size)\\n        var l = 0\\n        var r = nums.lastIndex\\n        var i = arr.lastIndex\\n        while (l <= r) {\\n            if (nums[l] * nums[l] > nums[r] * nums[r]) {\\n                arr[i] = nums[l] * nums[l]\\n                l++\\n            } else {\\n                arr[i] = nums[r] * nums[r]\\n                r--\\n            }\\n            i--\\n        }\\n        arr[0] = nums[l] * nums[l]\\n\\n        return arr\\n    }\\n```\\n\\nNaive approach:\\n```\\nfun sortedSquares(nums: IntArray) = nums.map { it * it }.sorted().toIntArray()\\n```\\n",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\n    fun sortedSquares(nums: IntArray): IntArray {\\n        val arr = IntArray(nums.size)\\n        var l = 0\\n        var r = nums.lastIndex\\n        var i = arr.lastIndex\\n        while (l <= r) {\\n            if (nums[l] * nums[l] > nums[r] * nums[r]) {\\n                arr[i] = nums[l] * nums[l]\\n                l++\\n            } else {\\n                arr[i] = nums[r] * nums[r]\\n                r--\\n            }\\n            i--\\n        }\\n        arr[0] = nums[l] * nums[l]\\n\\n        return arr\\n    }\\n```\n```\\nfun sortedSquares(nums: IntArray) = nums.map { it * it }.sorted().toIntArray()\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 973317,
                "title": "c-two-pointers-moving-from-both-ends",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        const int n = nums.size();\\n        vector<int> ans(n);\\n        int l = 0, r = n - 1, idx = n - 1;\\n        while(l<=r){\\n            if(nums[l]*nums[l] < nums[r] * nums[r]){\\n                ans[idx--] = nums[r] * nums[r];\\n                r--;\\n            }else{\\n                ans[idx--] = nums[l] * nums[l];\\n                l++;\\n            }\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        const int n = nums.size();\\n        vector<int> ans(n);\\n        int l = 0, r = n - 1, idx = n - 1;\\n        while(l<=r){\\n            if(nums[l]*nums[l] < nums[r] * nums[r]){\\n                ans[idx--] = nums[r] * nums[r];\\n                r--;\\n            }else{\\n                ans[idx--] = nums[l] * nums[l];\\n                l++;\\n            }\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 972966,
                "title": "squares-of-a-sorted-array-java-o-n-two-pointer-solution",
                "content": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int n = nums.length, i= 0, j = n-1, idx = n-1;\\n        \\n        int[] ans = new int[n];\\n        \\n        while(idx >= 0){\\n            if(Math.abs(nums[i]) > Math.abs(nums[j])){\\n                ans[idx] = nums[i]*nums[i];\\n                i++;\\n            }else{\\n                ans[idx] = nums[j]*nums[j];\\n                j--;\\n            } \\n            idx--;\\n        }\\n        \\n        return ans;   \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int n = nums.length, i= 0, j = n-1, idx = n-1;\\n        \\n        int[] ans = new int[n];\\n        \\n        while(idx >= 0){\\n            if(Math.abs(nums[i]) > Math.abs(nums[j])){\\n                ans[idx] = nums[i]*nums[i];\\n                i++;\\n            }else{\\n                ans[idx] = nums[j]*nums[j];\\n                j--;\\n            } \\n            idx--;\\n        }\\n        \\n        return ans;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 763999,
                "title": "c-solution",
                "content": "\\n```\\nclass Solution \\n{\\npublic:\\n    vector<int> sortedSquares(vector<int>& A)\\n\\t{\\n        vector<int> res;\\n        int i_negative, i_positive;\\n        \\n        for (i_positive = 0; i_positive < A.size() && A[i_positive] < 0; i_positive++);\\n        i_negative = i_positive - 1;\\n        \\n        while (i_negative >= 0 && i_positive < A.size()) \\n\\t\\t{\\n            if (-A[i_negative] <= A[i_positive])\\n                res.push_back(pow(A[i_negative--], 2));\\n            else\\n                res.push_back(pow(A[i_positive++], 2));\\n        }\\n        \\n        if (res.size() < A.size()) \\n\\t\\t{\\n            while (i_negative >= 0)\\n                res.push_back(pow(A[i_negative--], 2));\\n            while (i_positive < A.size())\\n                res.push_back(pow(A[i_positive++], 2));\\n        }\\n        return res;\\n    }\\n};\\n\\nstatic auto _______ = []()\\n{\\n    // turn off sync\\n    std::ios::sync_with_stdio(false);\\n    // untie in/out streams\\n    std::cin.tie(nullptr);\\n    return 0;\\n}();\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<int> sortedSquares(vector<int>& A)\\n\\t{\\n        vector<int> res;\\n        int i_negative, i_positive;\\n        \\n        for (i_positive = 0; i_positive < A.size() && A[i_positive] < 0; i_positive++);\\n        i_negative = i_positive - 1;\\n        \\n        while (i_negative >= 0 && i_positive < A.size()) \\n\\t\\t{\\n            if (-A[i_negative] <= A[i_positive])\\n                res.push_back(pow(A[i_negative--], 2));\\n            else\\n                res.push_back(pow(A[i_positive++], 2));\\n        }\\n        \\n        if (res.size() < A.size()) \\n\\t\\t{\\n            while (i_negative >= 0)\\n                res.push_back(pow(A[i_negative--], 2));\\n            while (i_positive < A.size())\\n                res.push_back(pow(A[i_positive++], 2));\\n        }\\n        return res;\\n    }\\n};\\n\\nstatic auto _______ = []()\\n{\\n    // turn off sync\\n    std::ios::sync_with_stdio(false);\\n    // untie in/out streams\\n    std::cin.tie(nullptr);\\n    return 0;\\n}();\\n```",
                "codeTag": "Java"
            },
            {
                "id": 557344,
                "title": "kotlin-o-n-95-time-100-space",
                "content": "```kotlin\\nclass Solution {\\n    fun sortedSquares(A: IntArray): IntArray {\\n        \\n        // Create markers to use to navigate inward since we know that\\n        // the polar ends are (possibly, but not always) the largest\\n        var leftMarker = 0\\n        var rightMarker = A.size - 1\\n        \\n        // Create a marker to track insertions into the new array\\n        var resultIndex = A.size - 1\\n        val result = IntArray(A.size)\\n        \\n        // Iterate over the items until the markers reach each other.\\n        // Its likely a little faster to consider the case where the left\\n        // marker is no longer producing elements that are less than zero.\\n        while (leftMarker <= rightMarker) {\\n            // Grab the absolute values of the elements at the respective\\n            // markers so they can be compared and inserted into the right\\n            // index.\\n            val left = Math.abs(A[leftMarker])\\n            val right = Math.abs(A[rightMarker])\\n            \\n            // Do checks to decide which item to insert next.\\n            result[resultIndex] = if (right > left) {\\n                rightMarker--\\n                right * right\\n            } else {\\n                leftMarker++\\n                left * left\\n            }\\n            \\n            // Once the item is inserted we can update the index we want\\n            // to insert at next.\\n            resultIndex--\\n        }\\n        \\n        return result\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```kotlin\\nclass Solution {\\n    fun sortedSquares(A: IntArray): IntArray {\\n        \\n        // Create markers to use to navigate inward since we know that\\n        // the polar ends are (possibly, but not always) the largest\\n        var leftMarker = 0\\n        var rightMarker = A.size - 1\\n        \\n        // Create a marker to track insertions into the new array\\n        var resultIndex = A.size - 1\\n        val result = IntArray(A.size)\\n        \\n        // Iterate over the items until the markers reach each other.\\n        // Its likely a little faster to consider the case where the left\\n        // marker is no longer producing elements that are less than zero.\\n        while (leftMarker <= rightMarker) {\\n            // Grab the absolute values of the elements at the respective\\n            // markers so they can be compared and inserted into the right\\n            // index.\\n            val left = Math.abs(A[leftMarker])\\n            val right = Math.abs(A[rightMarker])\\n            \\n            // Do checks to decide which item to insert next.\\n            result[resultIndex] = if (right > left) {\\n                rightMarker--\\n                right * right\\n            } else {\\n                leftMarker++\\n                left * left\\n            }\\n            \\n            // Once the item is inserted we can update the index we want\\n            // to insert at next.\\n            resultIndex--\\n        }\\n        \\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 520334,
                "title": "javascript-two-pointers-o-n",
                "content": "```\\n/**\\n * @param {number[]} A\\n * @return {number[]}\\n */\\nvar sortedSquares = function(A) {\\n    if (A.length < 2) // Early exit if the array only has less than two element.\\n        return [ Math.pow(A[0], 2) ];\\n    \\n    const newArray = [];\\n    let i = 0;\\n    let j = A.length - 1;\\n    \\n    while (i <= j) {\\n        const left = Math.pow(A[i], 2); // Square the number to obtain positive value. e.g. -2**2 = 4\\n        const right = Math.pow(A[j], 2); // Square the number to obtain positive value. e.g. 4**2 = 16\\n         \\n        if (left >= right) { // If left is bigger or equal than the right add that as the first position of the array\\n            newArray.unshift(left);\\n            i++;\\n        } else { // If the right is bigger than the left add that as the first position of the array\\n            newArray.unshift(right);\\n            j--;\\n        }\\n    } // It will traverse the array only once, since if you combine i and j the two pointers will meet in a middle point,\\n    \\n    return newArray;\\n    \\n    /**\\n    * Use two pointers to compare each end since we know that they are the highest numbers when squared.\\n    * Time Complexity: O(n)\\n    * Space Complexity: O(n)\\n    **/\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * @param {number[]} A\\n * @return {number[]}\\n */\\nvar sortedSquares = function(A) {\\n    if (A.length < 2) // Early exit if the array only has less than two element.\\n        return [ Math.pow(A[0], 2) ];\\n    \\n    const newArray = [];\\n    let i = 0;\\n    let j = A.length - 1;\\n    \\n    while (i <= j) {\\n        const left = Math.pow(A[i], 2); // Square the number to obtain positive value. e.g. -2**2 = 4\\n        const right = Math.pow(A[j], 2); // Square the number to obtain positive value. e.g. 4**2 = 16\\n         \\n        if (left >= right) { // If left is bigger or equal than the right add that as the first position of the array\\n            newArray.unshift(left);\\n            i++;\\n        } else { // If the right is bigger than the left add that as the first position of the array\\n            newArray.unshift(right);\\n            j--;\\n        }\\n    } // It will traverse the array only once, since if you combine i and j the two pointers will meet in a middle point,\\n    \\n    return newArray;\\n    \\n    /**\\n    * Use two pointers to compare each end since we know that they are the highest numbers when squared.\\n    * Time Complexity: O(n)\\n    * Space Complexity: O(n)\\n    **/\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 359123,
                "title": "golang-solution",
                "content": "when see sorted   we usually thought two pointer\\n```\\nfunc sortedSquares(A []int) []int {\\n\\tret := make([]int, len(A))\\n\\tleft, right := 0, len(A)-1\\n\\tfor i := len(A)-1; i >= 0; i-- {\\n        if math.Abs(float64(A[left])) < math.Abs(float64(A[right])) {\\n\\t\\t\\tret[i] = A[right] * A[right]\\n            right--\\n\\t\\t} else {\\n\\t\\t\\tret[i] = A[left] * A[left]\\n            left++\\n\\t\\t}\\n\\t}\\n\\n\\treturn ret\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc sortedSquares(A []int) []int {\\n\\tret := make([]int, len(A))\\n\\tleft, right := 0, len(A)-1\\n\\tfor i := len(A)-1; i >= 0; i-- {\\n        if math.Abs(float64(A[left])) < math.Abs(float64(A[right])) {\\n\\t\\t\\tret[i] = A[right] * A[right]\\n            right--\\n\\t\\t} else {\\n\\t\\t\\tret[i] = A[left] * A[left]\\n            left++\\n\\t\\t}\\n\\t}\\n\\n\\treturn ret\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 226469,
                "title": "go-two-pointers-without-finding-first-positive-number",
                "content": "The idea is than we can go down from both ends and collecting result array in descending order.\\n\\n```go\\nfunc sortedSquares(A []int) []int {\\n    length := len(A)\\n    res := make([]int, length)\\n    i, j := 0, length - 1\\n    \\n    for z := length - 1; z >= 0; z-- {\\n        sq1, sq2 := A[i]*A[i], A[j]* A[j]\\n        \\n        if sq1 > sq2 {\\n            res[z] = sq1\\n            i++\\n        } else {\\n            res[z] = sq2\\n            j--\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc sortedSquares(A []int) []int {\\n    length := len(A)\\n    res := make([]int, length)\\n    i, j := 0, length - 1\\n    \\n    for z := length - 1; z >= 0; z-- {\\n        sq1, sq2 := A[i]*A[i], A[j]* A[j]\\n        \\n        if sq1 > sq2 {\\n            res[z] = sq1\\n            i++\\n        } else {\\n            res[z] = sq2\\n            j--\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 224554,
                "title": "c-1-line",
                "content": "```\\npublic class Solution {\\n    public int[] SortedSquares(int[] A) {\\n        return A.Select(a => a * a).OrderBy(b => b).ToArray();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[] SortedSquares(int[] A) {\\n        return A.Select(a => a * a).OrderBy(b => b).ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3243882,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        for(int i=0;i<nums.length;i++){\\n            nums[i] = nums[i]*nums[i];\\n        }\\n        Arrays.sort(nums);\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        for(int i=0;i<nums.length;i++){\\n            nums[i] = nums[i]*nums[i];\\n        }\\n        Arrays.sort(nums);\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3129573,
                "title": "tc-o-n-sc-o-1-two-pointer-approach-easy-understanding-beats-90-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->Only focusing on Mangnitude for -ve numbers\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        vector<int> ans;\\n       int i=-1,j=0;\\n       for(int k=0;k<nums.size();k++){\\n           if(nums[k]<0) i=k;\\n       }\\n       j=i+1;\\n        \\n        while(i>=0 && j<nums.size()){\\n            if(-1*nums[i]>=nums[j]){\\n                ans.push_back(nums[j]*nums[j]); j++;\\n            }\\n            else {\\n                ans.push_back(nums[i]*nums[i]); i--;\\n            }\\n        }\\n        while(j<nums.size()){\\n            ans.push_back(nums[j]*nums[j]); j++;\\n        }\\n        while(i>=0){\\n            ans.push_back(nums[i]*nums[i]); i--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        vector<int> ans;\\n       int i=-1,j=0;\\n       for(int k=0;k<nums.size();k++){\\n           if(nums[k]<0) i=k;\\n       }\\n       j=i+1;\\n        \\n        while(i>=0 && j<nums.size()){\\n            if(-1*nums[i]>=nums[j]){\\n                ans.push_back(nums[j]*nums[j]); j++;\\n            }\\n            else {\\n                ans.push_back(nums[i]*nums[i]); i--;\\n            }\\n        }\\n        while(j<nums.size()){\\n            ans.push_back(nums[j]*nums[j]); j++;\\n        }\\n        while(i>=0){\\n            ans.push_back(nums[i]*nums[i]); i--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2905692,
                "title": "simple-python3-two-pointer-easy-to-understand-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse two pointers to start from edges of sorted list. Since 0 is the smallest value and we have the potential to have negative and positive numbers that need to be interwoven, we can take advantage of the sorted list by having a left and right (l, r) pointers. Then we can see if the element at l or r has a larger absolute value (which implies larger square value) and fill in res so that it descends in squared value. The idea is to start from the wings of the nums list and center down to 0, which would thus give you a sorted decreasing list of squares. Then since the problem asks for increasing, just reverse the list at the end. \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$ where $$N$$ is the length of nums. \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$ where $$N$$ is the length of nums. \\n\\n# Code\\n```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        l, r = 0, len(nums)-1\\n        res = []\\n\\n        while l <= r:\\n            if abs(nums[l]) >= abs(nums[r]):\\n                res.append(nums[l] ** 2)\\n                l += 1\\n            else:\\n                res.append(nums[r] ** 2)\\n                r -= 1\\n        return reversed(res)\\n\\n```\\n\\nThanks for taking a look at my solution, and feel free to let me know if I can improve anything :)",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        l, r = 0, len(nums)-1\\n        res = []\\n\\n        while l <= r:\\n            if abs(nums[l]) >= abs(nums[r]):\\n                res.append(nums[l] ** 2)\\n                l += 1\\n            else:\\n                res.append(nums[r] ** 2)\\n                r -= 1\\n        return reversed(res)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2319821,
                "title": "python-o-n-solution-explained",
                "content": "#### **Final Code:**\\n```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        result = []        \\n        left, right = 0, len(nums) - 1\\n        \\n        while left <= right:\\n            \\n            if nums[left] ** 2 < nums[right] ** 2:\\n                result.append(nums[right] ** 2)\\n                right -= 1\\n                \\n            else:\\n                result.append(nums[left] ** 2)\\n                left += 1\\n            \\n        return result[::-1]\\n```\\n\\n#### **Steps:**\\n* **Step1:**  \\nCreate an empty array to store the squared values.\\n```result = []```\\n\\n* **Step2:**  \\nInitialize our 2 pointers: left and right, and set them equal to the first and last index\\n                      positions of the array.\\n```left, right = 0, len(nums) - 1```\\n\\n* **Step3:** \\nWe can run a while loop and continue till our left pointer is greater than the right pointer.\\nmeaning till they cross each other in the array\\n```while left <= right:```\\n\\n* **Step4:**  \\nIf the square of the number on the right is greater than the square of the left number then\\nappend it to the result array and **decrease** the right pointer \\nOr\\nappend the left square and **increase** the left pointer.\\n```\\n            if nums[left] ** 2 < nums[right] ** 2:\\n                result.append(nums[right] ** 2)\\n                right -= 1\\n                \\n            else:\\n                result.append(nums[left] ** 2)\\n                left += 1\\n```\\n* **Step5:**  \\nAfter this we will end up with the result array but it is in descending order.\\nTo make it in ascending order we can just reverse it like:\\n```return result[::-1]```\\n\\n**And we have conquered this problem: Squares of Sorted Array \\uD83E\\uDD13**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        result = []        \\n        left, right = 0, len(nums) - 1\\n        \\n        while left <= right:\\n            \\n            if nums[left] ** 2 < nums[right] ** 2:\\n                result.append(nums[right] ** 2)\\n                right -= 1\\n                \\n            else:\\n                result.append(nums[left] ** 2)\\n                left += 1\\n            \\n        return result[::-1]\\n```\n```result = []```\n```left, right = 0, len(nums) - 1```\n```while left <= right:```\n```\\n            if nums[left] ** 2 < nums[right] ** 2:\\n                result.append(nums[right] ** 2)\\n                right -= 1\\n                \\n            else:\\n                result.append(nums[left] ** 2)\\n                left += 1\\n```\n```return result[::-1]```",
                "codeTag": "Java"
            },
            {
                "id": 2123293,
                "title": "c-using-stack",
                "content": "**Using stack :** We are pushing squared (sq) values of elements in stack , push the current sq value if stack top is greater then sq else pop from stack till stack top is greater then the sq and simultaneously put that sq in result (vector). \\n\\n```\\n vector<int> sortedSquares(vector<int>& nums) {\\n        stack<int> st;\\n        vector<int> res;\\n        \\n        for(int i=0 ; i<nums.size() ; i++){\\n            int sq = nums[i] * nums[i];\\n\\t\\t\\t\\n\\t\\t\\t// if sq is less then the top of stack then push sq in the stack\\n            if(st.size() == 0 || st.top() >= sq ){\\n                st.push(sq);\\n            }\\n\\t\\t\\t// else store the top of stack in res and pop from the stack till stack top is greater then the sq\\n            else{\\n                while(st.size() > 0 && st.top() < sq){\\n                    res.push_back(st.top());\\n                    st.pop();     \\n                }\\n                st.push(sq);\\n            }\\n        }\\n\\t\\t// if stack is not empty push all elements in res\\n        while(st.size() > 0){\\n            res.push_back(st.top());\\n            st.pop(); \\n        }\\n        return res;\\n    }\\n\\t\\n```\\t\\nIf you like the solution , do **UPVOTE**.\\nFeel free to ask any doubts in the comment section.",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\n vector<int> sortedSquares(vector<int>& nums) {\\n        stack<int> st;\\n        vector<int> res;\\n        \\n        for(int i=0 ; i<nums.size() ; i++){\\n            int sq = nums[i] * nums[i];\\n\\t\\t\\t\\n\\t\\t\\t// if sq is less then the top of stack then push sq in the stack\\n            if(st.size() == 0 || st.top() >= sq ){\\n                st.push(sq);\\n            }\\n\\t\\t\\t// else store the top of stack in res and pop from the stack till stack top is greater then the sq\\n            else{\\n                while(st.size() > 0 && st.top() < sq){\\n                    res.push_back(st.top());\\n                    st.pop();     \\n                }\\n                st.push(sq);\\n            }\\n        }\\n\\t\\t// if stack is not empty push all elements in res\\n        while(st.size() > 0){\\n            res.push_back(st.top());\\n            st.pop(); \\n        }\\n        return res;\\n    }\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2112476,
                "title": "python3-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        \\n        l, r = 0, n - 1\\n        res = []\\n        while l <= r:\\n            if abs(nums[r]) > abs(nums[l]):\\n                res.append(nums[r] * nums[r])\\n                r -= 1\\n            else:\\n                res.append(nums[l] * nums[l])\\n                l += 1\\n                \\n        return res[::-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        \\n        l, r = 0, n - 1\\n        res = []\\n        while l <= r:\\n            if abs(nums[r]) > abs(nums[l]):\\n                res.append(nums[r] * nums[r])\\n                r -= 1\\n            else:\\n                res.append(nums[l] * nums[l])\\n                l += 1\\n                \\n        return res[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083247,
                "title": "java-two-pointers",
                "content": "\\'\\'\\'\\n\\n\\t\\tint i=0,j=nums.length-1;\\n        int[] ans=new int[nums.length];\\n        for(int k=nums.length-1;k>=0;k--)\\n        {\\n            if(Math.abs(nums[i])>Math.abs(nums[j]))\\n            {\\n                ans[k]=(int)Math.pow(nums[i],2);\\n                i++;\\n            }\\n            else\\n            {\\n                ans[k]=(int)Math.pow(nums[j],2);\\n                j--;\\n            }\\n        }\\n        return ans;\\n\\t\\t\\'\\'\\'",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "\\'\\'\\'\\n\\n\\t\\tint i=0,j=nums.length-1;\\n        int[] ans=new int[nums.length];\\n        for(int k=nums.length-1;k>=0;k--)\\n        {\\n            if(Math.abs(nums[i])>Math.abs(nums[j]))\\n            {\\n                ans[k]=(int)Math.pow(nums[i],2);\\n                i++;\\n            }\\n            else\\n            {\\n                ans[k]=(int)Math.pow(nums[j],2);\\n                j--;\\n            }\\n        }\\n        return ans;\\n\\t\\t\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1934797,
                "title": "my-java-o-n-solution-beats-100-submissions",
                "content": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int[] sol = new int[nums.length];\\n        int i=0,j=nums.length-1;\\n        for (int k=sol.length-1;k>=0;k--){\\n            if (Math.abs(nums[i])>Math.abs(nums[j])){\\n                sol[k] = nums[i]*nums[i];\\n                i++;\\n            }else {\\n                sol[k] = nums[j]*nums[j];\\n                j--;\\n            }\\n        }\\n        return sol;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int[] sol = new int[nums.length];\\n        int i=0,j=nums.length-1;\\n        for (int k=sol.length-1;k>=0;k--){\\n            if (Math.abs(nums[i])>Math.abs(nums[j])){\\n                sol[k] = nums[i]*nums[i];\\n                i++;\\n            }else {\\n                sol[k] = nums[j]*nums[j];\\n                j--;\\n            }\\n        }\\n        return sol;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1882625,
                "title": "python3-two-pointer-approach",
                "content": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        start,end = 0, len(nums)-1\\n        result  = [0] * (end+1)\\n        index = end\\n        while index>=0:\\n            startElementSquare, endElementSquare = nums[start]**2, nums[end]**2\\n            if(endElementSquare > startElementSquare):\\n                result[index] = endElementSquare\\n                end -= 1\\n            else:\\n                result[index] = startElementSquare\\n                start+=1\\n            index-=1\\n        return result\\n                \\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        start,end = 0, len(nums)-1\\n        result  = [0] * (end+1)\\n        index = end\\n        while index>=0:\\n            startElementSquare, endElementSquare = nums[start]**2, nums[end]**2\\n            if(endElementSquare > startElementSquare):\\n                result[index] = endElementSquare\\n                end -= 1\\n            else:\\n                result[index] = startElementSquare\\n                start+=1\\n            index-=1\\n        return result\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1877413,
                "title": "javascript-two-pointers-clean-and-simple",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar sortedSquares = function(nums) {\\n    const squreSorted = new Array(nums.length); // define empty array\\n \\n    \\n    let leftIndx = 0; // left pointer\\n    let rightIndx = nums.length - 1; // right pointer\\n    \\n    let pointer = nums.length; // point to last empty squreSorted index\\n    \\n    while(pointer){\\n        pointer--;\\n        \\n        let leftValue = nums[leftIndx] ** 2;\\n        let rightValue = nums[rightIndx] ** 2;\\n        \\n        if(leftValue > rightValue) \\n        {\\n            squreSorted[pointer] = leftValue;\\n            leftIndx++;\\n        }\\n        else{ \\n            squreSorted[pointer] = rightValue;\\n            rightIndx--;\\n        }\\n    }\\n    \\n    return squreSorted\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar sortedSquares = function(nums) {\\n    const squreSorted = new Array(nums.length); // define empty array\\n \\n    \\n    let leftIndx = 0; // left pointer\\n    let rightIndx = nums.length - 1; // right pointer\\n    \\n    let pointer = nums.length; // point to last empty squreSorted index\\n    \\n    while(pointer){\\n        pointer--;\\n        \\n        let leftValue = nums[leftIndx] ** 2;\\n        let rightValue = nums[rightIndx] ** 2;\\n        \\n        if(leftValue > rightValue) \\n        {\\n            squreSorted[pointer] = leftValue;\\n            leftIndx++;\\n        }\\n        else{ \\n            squreSorted[pointer] = rightValue;\\n            rightIndx--;\\n        }\\n    }\\n    \\n    return squreSorted\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1850495,
                "title": "javascript-solution",
                "content": "Runtime: 88 ms, faster than 99.30% of JavaScript online submissions for Squares of a Sorted Array.\\nMemory Usage: 49.3 MB, less than 10.82% of JavaScript online submissions for Squares of a Sorted Array.\\n```\\nvar sortedSquares = function(nums) {\\n    let arr = [];\\n    let start = 0;\\n    let end = nums.length -1;\\n    \\n    while(start <= end){\\n        if(nums[start] **2 > nums[end] **2){\\n            arr.push(nums[start] **2);\\n            start++;\\n        } else {\\n            arr.push(nums[end] **2);\\n            end--;\\n        }\\n    }\\n    return arr.reverse();\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar sortedSquares = function(nums) {\\n    let arr = [];\\n    let start = 0;\\n    let end = nums.length -1;\\n    \\n    while(start <= end){\\n        if(nums[start] **2 > nums[end] **2){\\n            arr.push(nums[start] **2);\\n            start++;\\n        } else {\\n            arr.push(nums[end] **2);\\n            end--;\\n        }\\n    }\\n    return arr.reverse();\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1781273,
                "title": "java-brute-o-nlogn-better-o-n-both-explained",
                "content": "**1. First approach is to iterate and update with its square. And then Sort the array and return.**\\n\\n```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        for(int i=0;i<nums.length;i++){\\n            nums[i]=nums[i]*nums[i];\\n        }\\n        Arrays.sort(nums);\\n        return nums;\\n    }\\n}\\n```\\n\\n**2. Second approach is to use of two pointer and take whichever (abs) is greater and update it in new array. Iterate until new array become updated.**\\n\\n```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int arr[]=new int[nums.length];\\n        int i=0,j=nums.length-1,k=nums.length-1;\\n        while(k>=0){\\n            if(Math.abs(nums[i])>=Math.abs(nums[j])){\\n                arr[k]=nums[i]*nums[i];\\n                i++;\\n            }\\n            else{\\n                arr[k]=nums[j]*nums[j];\\n                j--;\\n            }\\n            k--;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        for(int i=0;i<nums.length;i++){\\n            nums[i]=nums[i]*nums[i];\\n        }\\n        Arrays.sort(nums);\\n        return nums;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int arr[]=new int[nums.length];\\n        int i=0,j=nums.length-1,k=nums.length-1;\\n        while(k>=0){\\n            if(Math.abs(nums[i])>=Math.abs(nums[j])){\\n                arr[k]=nums[i]*nums[i];\\n                i++;\\n            }\\n            else{\\n                arr[k]=nums[j]*nums[j];\\n                j--;\\n            }\\n            k--;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1708128,
                "title": "javascript-radix-sort-o-n-time-o-1-space",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\n\\nfunction getDigit(number, place) {\\n    return Math.floor(Math.abs(number) / Math.pow(10, place)) % 10;\\n}\\n\\nfunction getDigitCount(number) {\\n    return number === 0\\n        ? number\\n        : Math.floor(Math.log10(Math.abs(number))) + 1;\\n}\\n\\nfunction getHighestDigitCount(numbers) {\\n    return Math.max(...numbers.map(n => getDigitCount(n)));\\n}\\n\\nfunction radixSort(numbers) {\\n    const maxDigitCount = getHighestDigitCount(numbers);\\n\\n    let numArr = [];\\n\\n    for(let i = 0; i < maxDigitCount; i++) {\\n\\n        for(let j = 0; j < numbers.length; j++) {\\n            let digit = getDigit(numbers[j], i);\\n            if(numArr[digit] === undefined) {\\n                numArr[digit] = [numbers[j]];\\n            } else {\\n                numArr[digit].push(numbers[j]);\\n            }\\n        }\\n\\n        numbers = numArr.flat(1);\\n        numArr = [];\\n    }\\n\\n    return numbers;\\n}\\n\\nvar sortedSquares = function(nums) {\\n    for(let i = 0; i < nums.length; i++) {\\n        nums[i] = Math.abs(nums[i] ** 2);\\n    }\\n    return radixSort(nums);\\n};\\n```\\n\\nThis solution is using radix sort which has a time complexity of O(kN). However, there are specific applications where if k is small enough that Radix Sort will exhibit linear-time performance in practice. Counting sort should also exhibit O(n) time complexity for the same reasons.\\n\\nIt is also using O(1) space complexity.\\n\\nYou can learn more about Radix sort here: http://en.wikipedia.org/wiki/Radix_sort",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\n\\nfunction getDigit(number, place) {\\n    return Math.floor(Math.abs(number) / Math.pow(10, place)) % 10;\\n}\\n\\nfunction getDigitCount(number) {\\n    return number === 0\\n        ? number\\n        : Math.floor(Math.log10(Math.abs(number))) + 1;\\n}\\n\\nfunction getHighestDigitCount(numbers) {\\n    return Math.max(...numbers.map(n => getDigitCount(n)));\\n}\\n\\nfunction radixSort(numbers) {\\n    const maxDigitCount = getHighestDigitCount(numbers);\\n\\n    let numArr = [];\\n\\n    for(let i = 0; i < maxDigitCount; i++) {\\n\\n        for(let j = 0; j < numbers.length; j++) {\\n            let digit = getDigit(numbers[j], i);\\n            if(numArr[digit] === undefined) {\\n                numArr[digit] = [numbers[j]];\\n            } else {\\n                numArr[digit].push(numbers[j]);\\n            }\\n        }\\n\\n        numbers = numArr.flat(1);\\n        numArr = [];\\n    }\\n\\n    return numbers;\\n}\\n\\nvar sortedSquares = function(nums) {\\n    for(let i = 0; i < nums.length; i++) {\\n        nums[i] = Math.abs(nums[i] ** 2);\\n    }\\n    return radixSort(nums);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1707363,
                "title": "c-cpp-different-stl-implementation",
                "content": "Tried this to make this solution nearly 100% fast, Ended up 95% Faster\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        for_each(nums.begin(),nums.end(),[](int& a){a=a*a;});\\n        sort(nums.begin(),nums.end());\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        for_each(nums.begin(),nums.end(),[](int& a){a=a*a;});\\n        sort(nums.begin(),nums.end());\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1670332,
                "title": "java-with-explanation-two-pointers-faster-than-100",
                "content": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int start = 0;\\n        int end = nums.length - 1;\\n        int[] squares = new int[nums.length];\\n\\t\\t\\n        int j = nums.length - 1;\\n        \\n        while (start <= end) {\\n            if (Math.abs(nums[start]) > Math.abs(nums[end])) {\\n                squares[j] = nums[start] * nums[start];\\n                start++;\\n            } else {\\n                squares[j] = nums[end] * nums[end];\\n                end--;\\n            }\\n            j--;\\n        }\\n        \\n        return squares;\\n    }\\n}\\n```\\n\\n# Explanation \\n\\nWhen squaring an integer, its sign doesn\\'t matter: the answer is always the same. This means that in our array of negative and positive integers, the largest squares are located towards both ends of the array. \\n\\nThe idea behind my code is getting the bigger number from either ends of the array using what\\'s called the **two-pointer** technique. \\n\\n### Code run-through: \\n\\n1. Initiliaze your variables. \\n\\ta. `start` points to the first index of your array while `end` is the last.\\n\\tb. `squares` is where you would store your sorted squares. \\n\\tc. `j` is used populate your `squares` array; it starts from the end of the array (`nums.length - 1`) since you\\'d be populating it with the biggest elements first. \\n```\\nint start = 0;\\nint end = nums.length - 1;\\nint[] squares = new int[nums.length];\\n\\nint j = nums.length - 1;\\n```\\n\\n2. The next part is the meat of the code. \\n\\ta. The `while-loop` goes through all the elements in `nums` until the `start <= end` (you\\'ll see why). \\n\\tb. The `if-else` statement checks which of the either indices has the bigger **absolute** value. \\n\\tc. If `nums[start]` is bigger than `nums[end]`, then we set `squares[j]` to the square of`nums[start]`; then increment `start` by 1. \\n\\t\\td. Else, we set we set `squares[j]` to the square of`nums[end]`; then decrement `end` by 1.\\n\\t\\te. Finally, decrement `j` by 1. \\n```\\nwhile (start <= end) {\\n\\tif (Math.abs(nums[start]) > Math.abs(nums[end])) {\\n\\t\\tsquares[j] = nums[start] * nums[start];\\n\\t\\tstart++;\\n\\t} else {\\n\\t\\tsquares[j] = nums[end] * nums[end];\\n\\t\\tend--;\\n\\t}\\n\\tj--;\\n}\\n```\\n\\n### Run-time Analysis:\\n\\nSince we only loop through the array once, we have a linear runtime O(n). \\n\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int start = 0;\\n        int end = nums.length - 1;\\n        int[] squares = new int[nums.length];\\n\\t\\t\\n        int j = nums.length - 1;\\n        \\n        while (start <= end) {\\n            if (Math.abs(nums[start]) > Math.abs(nums[end])) {\\n                squares[j] = nums[start] * nums[start];\\n                start++;\\n            } else {\\n                squares[j] = nums[end] * nums[end];\\n                end--;\\n            }\\n            j--;\\n        }\\n        \\n        return squares;\\n    }\\n}\\n```\n```\\nint start = 0;\\nint end = nums.length - 1;\\nint[] squares = new int[nums.length];\\n\\nint j = nums.length - 1;\\n```\n```\\nwhile (start <= end) {\\n\\tif (Math.abs(nums[start]) > Math.abs(nums[end])) {\\n\\t\\tsquares[j] = nums[start] * nums[start];\\n\\t\\tstart++;\\n\\t} else {\\n\\t\\tsquares[j] = nums[end] * nums[end];\\n\\t\\tend--;\\n\\t}\\n\\tj--;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1594612,
                "title": "java-o-n-time-complexity-easy-solution",
                "content": "Kindly upvote, if it helps you!\\n```\\nBrute force Approach\\nTime Complexity - O(n + nlogn)\\nSpace Complexity - O(n)\\npublic int[] sortedSquares(int[] nums) {\\n        int[] result = new int[nums.length];\\n        int i = 0;\\n        for(int num: nums){\\n            result[i++] = num*num;\\n        }\\n        Arrays.sort(result);\\n        return result;\\n    }\\n\\nApproach no. 2\\nTime Complexity - O(n)\\nSpace Complexity - O(n)\\npublic int[] sortedSquares(int[] nums) {\\n        int[] result = new int[nums.length];\\n        int i = 0, j= nums.length-1, k = nums.length-1;\\n        while(i<=j && k>=0){\\n            if(nums[i]*nums[i] < nums[j]*nums[j]){\\n                result[k] = nums[j]*nums[j];\\n                j--;\\n            }else{\\n                result[k] = nums[i]*nums[i];\\n                i++;\\n            }\\n            k--;\\n        }\\n        return result;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Kindly upvote, if it helps you!\\n```\\nBrute force Approach\\nTime Complexity - O(n + nlogn)\\nSpace Complexity - O(n)\\npublic int[] sortedSquares(int[] nums) {\\n        int[] result = new int[nums.length];\\n        int i = 0;\\n        for(int num: nums){\\n            result[i++] = num*num;\\n        }\\n        Arrays.sort(result);\\n        return result;\\n    }\\n\\nApproach no. 2\\nTime Complexity - O(n)\\nSpace Complexity - O(n)\\npublic int[] sortedSquares(int[] nums) {\\n        int[] result = new int[nums.length];\\n        int i = 0, j= nums.length-1, k = nums.length-1;\\n        while(i<=j && k>=0){\\n            if(nums[i]*nums[i] < nums[j]*nums[j]){\\n                result[k] = nums[j]*nums[j];\\n                j--;\\n            }else{\\n                result[k] = nums[i]*nums[i];\\n                i++;\\n            }\\n            k--;\\n        }\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1498777,
                "title": "java-solution-2ms",
                "content": "\\tclass Solution {\\n\\t\\tpublic int[] sortedSquares(int[] nums) {\\n \\n\\t\\t\\tint[] square = new int[nums.length];\\n\\t\\t\\tint pcur = 0 ;\\n\\t\\t\\tint ncur = nums.length-1;\\n\\n\\t\\t\\tfor(int i = nums.length-1; i >= 0; i--){\\n\\t\\t\\t\\tif(nums[pcur]* nums[pcur] > nums[ncur] * nums[ncur]){\\n\\t\\t\\t\\t\\t\\tsquare[i] = nums[pcur] * nums[pcur];\\n\\t\\t\\t\\t\\t\\tpcur++;\\n\\t\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t\\tsquare[i] = nums[ncur] * nums[ncur];\\n\\t\\t\\t\\t\\t\\tncur--;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t\\treturn square;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int[] sortedSquares(int[] nums) {\\n \\n\\t\\t\\tint[] square = new int[nums.length];\\n\\t\\t\\tint pcur = 0 ;\\n\\t\\t\\tint ncur = nums.length-1;\\n\\n\\t\\t\\tfor(int i = nums.length-1; i >= 0; i--){\\n\\t\\t\\t\\tif(nums[pcur]* nums[pcur] > nums[ncur] * nums[ncur]){\\n\\t\\t\\t\\t\\t\\tsquare[i] = nums[pcur] * nums[pcur];\\n\\t\\t\\t\\t\\t\\tpcur++;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1483326,
                "title": "c-no-sorting-simple-solution",
                "content": "**Please Upvote if it helped You !!!\\nHappy Coding :)**\\n```\\nvector<int> sortedSquares(vector<int>& nums) \\n    {\\n        vector<int> answer(nums.size());\\n        int left=0;\\n        int right=nums.size()-1;\\n        for(int i=right;i>=0;i--)\\n        {\\n            if(abs(nums[right]) > abs(nums[left]))\\n            {\\n                answer[i]=nums[right] * nums[right];\\n                right--;\\n            }\\n            else \\n            {\\n                answer[i]=nums[left] * nums[left];\\n                left++;\\n            }\\n        }\\n        return answer;\\n    }\\n```\\t",
                "solutionTags": [],
                "code": "```\\nvector<int> sortedSquares(vector<int>& nums) \\n    {\\n        vector<int> answer(nums.size());\\n        int left=0;\\n        int right=nums.size()-1;\\n        for(int i=right;i>=0;i--)\\n        {\\n            if(abs(nums[right]) > abs(nums[left]))\\n            {\\n                answer[i]=nums[right] * nums[right];\\n                right--;\\n            }\\n            else \\n            {\\n                answer[i]=nums[left] * nums[left];\\n                left++;\\n            }\\n        }\\n        return answer;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1439593,
                "title": "javascript-o-n-time-o-1-space-simple-easy-to-understand-solution",
                "content": "```\\n// ! O(1) space complexity when not considering the result array as extra space, otherwise O(n) space complexity\\n\\nvar sortedSquares = function(nums) {\\n  let li = 0, ri = nums.length - 1, result = [];\\n\\n  for (let i = nums.length - 1; i >= 0; i--) {\\n    let left = Math.abs(nums[li]), right = Math.abs(nums[ri]);\\n\\n    if (left <= right) { result[i] = right * right; ri--; }\\n    else if (left > right) { result[i] = left * left; li++; }\\n  }\\n\\n  return result;\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\n// ! O(1) space complexity when not considering the result array as extra space, otherwise O(n) space complexity\\n\\nvar sortedSquares = function(nums) {\\n  let li = 0, ri = nums.length - 1, result = [];\\n\\n  for (let i = nums.length - 1; i >= 0; i--) {\\n    let left = Math.abs(nums[li]), right = Math.abs(nums[ri]);\\n\\n    if (left <= right) { result[i] = right * right; ri--; }\\n    else if (left > right) { result[i] = left * left; li++; }\\n  }\\n\\n  return result;\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1411602,
                "title": "two-pointers-c-simple-solution-o-n",
                "content": "***Please upvote if you find this useful***\\n\\nWe take another vector ```result``` of the same size as vector ```nums``` to store the new array, containing the sqaures in sorted order.\\n\\nWe then take two pointers ```start``` and ```end``` pointing to the first and last index of the ```nums``` vector. \\nWe also take another pointer ```i``` which points at last index of our new vector ```result```\\n\\nThen, we compare that whether, the squared value of the first index or the squared value of last index is higher. Whichever is higher, we put that value in the last index of our ```result``` vector. We run the loop and traverse ```nums``` till ```start``` pointer is less than or equal to ```end``` pointer. \\n\\n*Intuition: * If you carefully notice, you will see that the first element and the last element of the ```nums``` vector has the potential of giving the largest squared number. \\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int start = 0;\\n        int end = nums.size()-1;\\n        vector<int> result(nums.size()) ;\\n        int i = result.size()-1;\\n        \\n        while(start<=end)\\n        {\\n            if(nums[start]*nums[start] > nums[end]*nums[end])\\n            {\\n                result[i] = nums[start]*nums[start]; \\n                start++;\\n            }\\n               \\n        \\n        else{\\n            result[i] = nums[end]*nums[end];\\n            end--;\\n        }\\n           i--; \\n            \\n        }  \\n        return result;\\n            \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```result```\n```nums```\n```start```\n```end```\n```nums```\n```i```\n```result```\n```result```\n```nums```\n```start```\n```end```\n```nums```",
                "codeTag": "Unknown"
            },
            {
                "id": 1252319,
                "title": "c-two-pointers-o-n-no-sorting-required",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& a) {\\n        \\n        int n=a.size();\\n        vector<int>ans(n);\\n        int i=0;\\n        int j=n-1;\\n        int k=n-1;\\n        \\n        while(i<=j)\\n        {\\n            if(abs(a[i])>=abs(a[j]))\\n            {\\n                ans[k] = a[i]*a[i];\\n                i++;\\n            }\\n            else\\n            {\\n                ans[k] = a[j]*a[j];\\n                j--;\\n            }\\n            k--;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& a) {\\n        \\n        int n=a.size();\\n        vector<int>ans(n);\\n        int i=0;\\n        int j=n-1;\\n        int k=n-1;\\n        \\n        while(i<=j)\\n        {\\n            if(abs(a[i])>=abs(a[j]))\\n            {\\n                ans[k] = a[i]*a[i];\\n                i++;\\n            }\\n            else\\n            {\\n                ans[k] = a[j]*a[j];\\n                j--;\\n            }\\n            k--;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1167055,
                "title": "c-o-n-99-99-faster",
                "content": "\\n    vector<int> sortedSquares(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        vector<int> res(n);\\n        int s = 0, e = n - 1, idx = n - 1;\\n        \\n        while(s <= e)\\n        {\\n            if(abs(nums[s]) < abs(nums[e]))\\n            {\\n                res[idx--] = nums[e] * nums[e];\\n                e--;\\n            }\\n            else\\n            {\\n                res[idx--] = nums[s] * nums[s];\\n                s++;\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "\\n    vector<int> sortedSquares(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        vector<int> res(n);\\n        int s = 0, e = n - 1, idx = n - 1;\\n        \\n        while(s <= e)\\n        {\\n            if(abs(nums[s]) < abs(nums[e]))\\n            {\\n                res[idx--] = nums[e] * nums[e];\\n                e--;\\n            }\\n            else\\n            {\\n                res[idx--] = nums[s] * nums[s];\\n                s++;\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1164759,
                "title": "java-single-while-loop-approach-faster-than-100",
                "content": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n\\t\\tint[] res = new int[nums.length];\\n\\t\\tint i = 0;\\n\\t\\tint j = nums.length - 1;\\n\\t\\tint counter = nums.length - 1;\\n\\t\\twhile (counter >= 0) {\\n\\t\\t\\tint iSquare = nums[i] * nums[i];\\n\\t\\t\\tint jSquare = nums[j] * nums[j];\\n\\t\\t\\tif (iSquare > jSquare) {\\n\\t\\t\\t\\tres[counter] = iSquare;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tres[counter] = jSquare;\\n\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t\\tcounter--;\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n\\t\\tint[] res = new int[nums.length];\\n\\t\\tint i = 0;\\n\\t\\tint j = nums.length - 1;\\n\\t\\tint counter = nums.length - 1;\\n\\t\\twhile (counter >= 0) {\\n\\t\\t\\tint iSquare = nums[i] * nums[i];\\n\\t\\t\\tint jSquare = nums[j] * nums[j];\\n\\t\\t\\tif (iSquare > jSquare) {\\n\\t\\t\\t\\tres[counter] = iSquare;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tres[counter] = jSquare;\\n\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t\\tcounter--;\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1062638,
                "title": "java-o-n-1ms",
                "content": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int n = nums.length;\\n        int arr[] = new int [n];\\n        int start =0, end = n-1;\\n        for(int i =n-1;i>=0;i--){\\n            int square =Math.abs(nums[start])<Math.abs(nums[end])?nums[end--]:nums[start++];\\n            arr[i] = square*square;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int n = nums.length;\\n        int arr[] = new int [n];\\n        int start =0, end = n-1;\\n        for(int i =n-1;i>=0;i--){\\n            int square =Math.abs(nums[start])<Math.abs(nums[end])?nums[end--]:nums[start++];\\n            arr[i] = square*square;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 941592,
                "title": "c-two-approach-solution",
                "content": "**1. Using in-built sort function (NlogN time complexity)**\\nRuntime: 100 ms, faster than 54.72% of C++ online submissions for Squares of a Sorted Array.\\n\\n\\t\\tclass Solution {\\n\\t\\t\\tpublic:\\n\\t\\t\\t\\tvector<int> sortedSquares(vector<int>& A) {\\n\\n\\t\\t\\t\\t\\tfor(int i=0;i<A.size();i++) A[i] *= A[i];\\n\\n\\t\\t\\t\\t\\tsort(A.begin(),A.end());\\n\\n\\t\\t\\t\\t\\treturn A;\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\t\\n**2. Using two pointers (O(N) time complexity)**\\nRuntime: 20 ms, faster than 97.93% of C++ online submissions for Squares of a Sorted Array.\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> sortedSquares(vector<int>& nums) {\\n\\n\\t\\t\\tint n = nums.size();\\n\\t\\t\\tvector<int> res(n);\\n\\n\\t\\t\\tint i = 0; //pointing on \\'nums\\' vector\\n\\t\\t\\tint j = n-1; //pointing on \\'nums\\' vector\\n\\t\\t\\tint idx = n-1; //pointing on \\'res\\' vector\\n\\n\\t\\t\\twhile(i <= j){\\n\\t\\t\\t\\tint v1 = nums[i] * nums[i];\\n\\t\\t\\t\\tint v2 = nums[j] * nums[j];;\\n\\n\\t\\t\\t\\tif(v1 > v2){\\n\\t\\t\\t\\t\\tres[idx] = v1;\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tres[idx] = v2;\\n\\t\\t\\t\\t\\tj--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tidx--;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\t\\t\\tpublic:\\n\\t\\t\\t\\tvector<int> sortedSquares(vector<int>& A) {\\n\\n\\t\\t\\t\\t\\tfor(int i=0;i<A.size();i++) A[i] *= A[i];\\n\\n\\t\\t\\t\\t\\tsort(A.begin(),A.end());\\n\\n\\t\\t\\t\\t\\treturn A;\\n\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 659371,
                "title": "simple-and-straightforward-python-solution-o-n",
                "content": "```\\n        res = []\\n        \\n        i = 0\\n        j = len(A) - 1\\n        \\n        while i <= j:\\n            \\n            if abs(A[i]) < abs(A[j]):\\n                res.append(A[j]**2)\\n                j-=1\\n            else:\\n                res.append(A[i]**2)\\n                i+=1\\n                \\n                \\n        return res[::-1]\\n```\\n\\ntwo pointer approach",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\n        res = []\\n        \\n        i = 0\\n        j = len(A) - 1\\n        \\n        while i <= j:\\n            \\n            if abs(A[i]) < abs(A[j]):\\n                res.append(A[j]**2)\\n                j-=1\\n            else:\\n                res.append(A[i]**2)\\n                i+=1\\n                \\n                \\n        return res[::-1]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 576683,
                "title": "swift",
                "content": "```\\n    func sortedSquares(_ A: [Int]) -> [Int] {\\n        var res = [Int](repeating: 0, count: A.count)\\n        var index = A.count - 1\\n        var left = 0\\n        var right = A.count - 1\\n        while left <= right {\\n            var a = A[left] * A[left]\\n            var b = A[right] * A[right]\\n            if a > b {\\n                res[index] = a\\n                index -= 1\\n                left += 1\\n            } else {\\n                res[index] = b\\n                index -= 1\\n                right -= 1\\n            }\\n        }\\n        return res\\n    }",
                "solutionTags": [],
                "code": "```\\n    func sortedSquares(_ A: [Int]) -> [Int] {\\n        var res = [Int](repeating: 0, count: A.count)\\n        var index = A.count - 1\\n        var left = 0\\n        var right = A.count - 1\\n        while left <= right {\\n            var a = A[left] * A[left]\\n            var b = A[right] * A[right]\\n            if a > b {\\n                res[index] = a\\n                index -= 1\\n                left += 1\\n            } else {\\n                res[index] = b\\n                index -= 1\\n                right -= 1\\n            }\\n        }\\n        return res\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 504370,
                "title": "python-explained-without-using-sorted",
                "content": "The intuition is that the first and last bits of the originally sorted array will be the two candidates to append to the squares array back to front. \\n\\nFor example, in: `[-9,-3,-2,0,3,4]` the two largest possible are -9^2 and 4^2. If it\\'s the left, increment left and append it to the back of the result array. \\n\\n```\\n    def sortedSquares(self, A: List[int]) -> List[int]:\\n        l, r, ptr = 0, len(A) - 1, len(A) - 1\\n        fin = [None] * len(A)\\n        while l <= r:\\n            lS, rS = A[l] ** 2, A[r] ** 2\\n            if lS >= rS: \\n                fin[ptr], l = lS, l + 1\\n            else:\\n                fin[ptr], r = rS, r - 1\\n            ptr -= 1\\n        return fin\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def sortedSquares(self, A: List[int]) -> List[int]:\\n        l, r, ptr = 0, len(A) - 1, len(A) - 1\\n        fin = [None] * len(A)\\n        while l <= r:\\n            lS, rS = A[l] ** 2, A[r] ** 2\\n            if lS >= rS: \\n                fin[ptr], l = lS, l + 1\\n            else:\\n                fin[ptr], r = rS, r - 1\\n            ptr -= 1\\n        return fin\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 391005,
                "title": "two-pointers-c-one-pass-o-n-detailed-explanation",
                "content": "Note that the given array is already sorted, so in terms of sqaure values, it can be considered as at most two sorted arrays connected somewhere in the middle. Then we could use the same idea to merge two sorted arrays.\\n\\n```cpp\\n    vector<int> sortedSquares(vector<int>& a) {        \\n        int n = a.size();\\n        int L = 0; // read position from left a[]\\n        int R = n-1; // read position from right a[]\\n        int w = n-1; // write position in res[]\\n        \\n        vector<int> res(n);\\n        \\n        while (w >= 0) // pick large one in asb\\n            res[w--] = (abs(a[L]) >= abs(a[R]))? a[L]*a[L++] : a[R]*a[R--];\\n\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```cpp\\n    vector<int> sortedSquares(vector<int>& a) {        \\n        int n = a.size();\\n        int L = 0; // read position from left a[]\\n        int R = n-1; // read position from right a[]\\n        int w = n-1; // write position in res[]\\n        \\n        vector<int> res(n);\\n        \\n        while (w >= 0) // pick large one in asb\\n            res[w--] = (abs(a[L]) >= abs(a[R]))? a[L]*a[L++] : a[R]*a[R--];\\n\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 332449,
                "title": "swift-o-n-solution",
                "content": "```swift\\nclass Solution {\\n    func sortedSquares(_ A: [Int]) -> [Int] {\\n        let n = A.count\\n        var outputs = Array(repeating: 0, count: n)\\n        \\n        var i = 0, j = n - 1\\n        \\n        for p in (0 ..< n).reversed() {\\n            if abs(A[i]) > abs(A[j]) {\\n                outputs[p] = A[i] * A[i]\\n                i += 1\\n            } else {\\n                outputs[p] = A[j] * A[j]\\n                j -= 1\\n            }\\n        }\\n        \\n        return outputs\\n    }\\n}\\n\\xB7\\xB7\\xB7",
                "solutionTags": [
                    "Swift"
                ],
                "code": "class Solution {\\n    func sortedSquares(_ A: [Int]) -> [Int] {\\n        let n = A.count\\n        var outputs = Array(repeating: 0, count: n)\\n        \\n        var i = 0, j = n - 1\\n        \\n        for p in (0 ..< n).reversed() {\\n            if abs(A[i]) > abs(A[j]) {\\n                outputs[p] = A[i] * A[i]\\n                i += 1\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 239305,
                "title": "c-solution",
                "content": "```\\nint* sortedSquares(int* A, int ASize, int* returnSize) {\\n    int* ans = calloc(ASize, sizeof(int));\\n    *returnSize = ASize;\\n    int i = 0, j = ASize - 1, index = ASize - 1;\\n    while(i <= j)\\n    {\\n        if(-A[i] > A[j])\\n        {\\n            ans[index--] = A[i] * A[i];\\n            i++;\\n        }\\n        else\\n        {\\n            ans[index--] = A[j] * A[j];\\n            j--;\\n        }\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint* sortedSquares(int* A, int ASize, int* returnSize) {\\n    int* ans = calloc(ASize, sizeof(int));\\n    *returnSize = ASize;\\n    int i = 0, j = ASize - 1, index = ASize - 1;\\n    while(i <= j)\\n    {\\n        if(-A[i] > A[j])\\n        {\\n            ans[index--] = A[i] * A[i];\\n            i++;\\n        }\\n        else\\n        {\\n            ans[index--] = A[j] * A[j];\\n            j--;\\n        }\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3697662,
                "title": "easy-solution-two-pointers-beats-97-facebook",
                "content": "``` C++ []\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int left=0, right=nums.size()-1;\\n        vector<int> arr(nums.size());\\n        int i=arr.size()-1;\\n        while(left<=right){\\n            int temp=max(nums[left]*nums[left],nums[right]*nums[right]);\\n            arr[i--]=temp;\\n            if(abs(nums[left])<abs(nums[right])){\\n                right--;\\n            }\\n            else{\\n                left++;\\n            }\\n        }\\n        return arr;\\n    }\\n};\\n```\\n- The code aims to square each element in the given input array nums, sort the squared values in non-decreasing order, and return the sorted result.\\n- It uses two pointers, left and right, to track the left and right ends of the input array.\\n- The algorithm initializes an empty result array of the same size as nums.\\n- Starting from the ends of the array, the algorithm compares the absolute values of the elements at the left and right pointers.\\n- It squares the larger absolute value and assigns it to the end of the result array.\\n- The pointer of the assigned value is then decremented.\\n- The algorithm moves the pointer that corresponds to the element with the smaller absolute value.\\n- This process continues until the pointers meet or cross each other.\\n- Finally, the algorithm returns the sorted result array.\\n- The time complexity is O(n) linear because the algorithm iterates through the input array only once. \\n- The space complexity is also O(n) linear because it requires space to store the result array of the same size as the input array.\\n\\n```\\nI hope this helps ^_^\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int left=0, right=nums.size()-1;\\n        vector<int> arr(nums.size());\\n        int i=arr.size()-1;\\n        while(left<=right){\\n            int temp=max(nums[left]*nums[left],nums[right]*nums[right]);\\n            arr[i--]=temp;\\n            if(abs(nums[left])<abs(nums[right])){\\n                right--;\\n            }\\n            else{\\n                left++;\\n            }\\n        }\\n        return arr;\\n    }\\n};\\n```\n```\\nI hope this helps ^_^\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3391656,
                "title": "easy-clean-js-solution",
                "content": "\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nconst sortedSquares = function(nums) {\\n  const arr =  nums.map(value => Math.pow(value,2));\\n  return arr.sort((a,b)=> a-b);\\n  \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nconst sortedSquares = function(nums) {\\n  const arr =  nums.map(value => Math.pow(value,2));\\n  return arr.sort((a,b)=> a-b);\\n  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3196486,
                "title": "simple-two-pointer-solution-tc-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGiven an integer array sorted in non-decreasing order, we need to return an array of the squares of each number sorted in non-decreasing order. Since the given array is sorted, the squares of $$negative$$ numbers will be in $$decreasing$$ order and the squares of $$positive$$ numbers will be in $$increasing$$ order. We can merge these two arrays of squares using a $$two-pointer$$ approach.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- We will start with two pointers, $$left$$ and $$right$$, both at the two ends of the given array. We will also create an empty result array called $$\\'res\\'$$.\\n- We will loop until the $$left$$ pointer is less than or equal to the $$right$$ pointer.\\n- If the element pointed by the $$left$$ pointer is negative, we will compare its $$absolute$$ value with the element pointed by the $$right$$ pointer. \\n- If the absolute value of the $$left$$ element is greater than or equal to the $$right$$ element, we will add the square of the $$left$$ element to the $$\\'res\\'$$ array and move the $$left$$ pointer one position to the right.\\n- Otherwise, we will add the square of the right element to the $$\\'res\\'$$ array and move the $$right$$ pointer one position to the left.\\n- If the element pointed by the $$left$$ pointer is non-negative, we will $$break$$ out of the loop since all remaining elements will also be non-negative and their squares will be in $$increasing$$ order.\\n- We will loop through the remaining elements in the array from the $$right$$ pointer to the $$left$$ pointer and append their squares to the $$\\'res\\'$$ array.\\n- Since we appended the squares of the remaining elements from right to left, we need to reverse the $$\\'res\\'$$ array to get the squares in $$non-decreasing$$ order.\\n- We will return the $$\\'res\\'$$ array.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n```\\nThe given array is iterated twice - once using the two-pointer\\napproach and once to loop through the remaining elements. \\nTherefore, the time complexity of this algorithm is O(n), where \\'n\\'\\nis the length of the given array.\\n```\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n```\\nWe are creating an empty array to store the result. Therefore, \\nthe space complexity of this algorithm is O(n), where \\'n\\' is \\nthe length of the given array.\\n```\\n# Code\\n```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        res = []  # to store the result\\n        left, right = 0, len(nums)-1  # initialize left and right pointers to the two ends of the array\\n        \\n        # loop until left pointer is less than or equal to right pointer\\n        while left <= right:\\n            if nums[left] < 0:  \\n                # if the element pointed by left pointer is negative\\n                # compare absolute value of left element with the right element\\n                if abs(nums[left]) >= nums[right]:\\n                    res.append(nums[left]**2)  \\n                    # if absolute value of left element is greater than or equal\\n                    # to right element, add square of left element to the result array\\n                    left += 1  # move left pointer one position to the right\\n                else:\\n                    res.append(nums[right]**2)  \\n                    # if absolute value of left element is less than right element, add square of right\\n                    # element to the result array\\n                    right -= 1  # move right pointer one position to the left\\n            else:  \\n                # if the element pointed by left pointer is non-negative, break out of the loop\\n                break\\n        \\n        # loop through the remaining elements from right pointer to left pointer and \\n        # append their squares to the result array\\n        for i in range(right, left-1, -1):\\n            res.append(nums[i]**2)\\n        \\n        res.reverse()  # reverse the result array to get the squares in non-decreasing order\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nThe given array is iterated twice - once using the two-pointer\\napproach and once to loop through the remaining elements. \\nTherefore, the time complexity of this algorithm is O(n), where \\'n\\'\\nis the length of the given array.\\n```\n```\\nWe are creating an empty array to store the result. Therefore, \\nthe space complexity of this algorithm is O(n), where \\'n\\' is \\nthe length of the given array.\\n```\n```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        res = []  # to store the result\\n        left, right = 0, len(nums)-1  # initialize left and right pointers to the two ends of the array\\n        \\n        # loop until left pointer is less than or equal to right pointer\\n        while left <= right:\\n            if nums[left] < 0:  \\n                # if the element pointed by left pointer is negative\\n                # compare absolute value of left element with the right element\\n                if abs(nums[left]) >= nums[right]:\\n                    res.append(nums[left]**2)  \\n                    # if absolute value of left element is greater than or equal\\n                    # to right element, add square of left element to the result array\\n                    left += 1  # move left pointer one position to the right\\n                else:\\n                    res.append(nums[right]**2)  \\n                    # if absolute value of left element is less than right element, add square of right\\n                    # element to the result array\\n                    right -= 1  # move right pointer one position to the left\\n            else:  \\n                # if the element pointed by left pointer is non-negative, break out of the loop\\n                break\\n        \\n        # loop through the remaining elements from right pointer to left pointer and \\n        # append their squares to the result array\\n        for i in range(right, left-1, -1):\\n            res.append(nums[i]**2)\\n        \\n        res.reverse()  # reverse the result array to get the squares in non-decreasing order\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144443,
                "title": "one-line",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        return sorted([i*i for i in nums])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        return sorted([i*i for i in nums])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3114237,
                "title": "basic-code-begginer-friendly",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n//Please Upvote if you like the approach \\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            int temp=nums[i]*nums[i];\\n            ans.push_back(temp);\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//Please Upvote if you like the approach \\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            int temp=nums[i]*nums[i];\\n            ans.push_back(temp);\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3066994,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMultiplicatio of two elements at same index.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn this problem i just simply multiply elements at same index and after that i just simply sort the array.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlog(n))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            nums[i]=nums[i]*nums[i];\\n        }\\n        sort(nums.begin(),nums.end());\\n        return nums;\\n    }\\n};\\nPlease UPVOTE if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            nums[i]=nums[i]*nums[i];\\n        }\\n        sort(nums.begin(),nums.end());\\n        return nums;\\n    }\\n};\\nPlease UPVOTE if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2838888,
                "title": "c-best-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        for(int i=0;i<nums.size();i++){\\n            nums[i]=(nums[i]*nums[i]);\\n        }\\n        sort(nums.begin(),nums.end());\\n        return nums;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        for(int i=0;i<nums.size();i++){\\n            nums[i]=(nums[i]*nums[i]);\\n        }\\n        sort(nums.begin(),nums.end());\\n        return nums;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2797840,
                "title": "kotlin-one-liner-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    fun sortedSquares(nums: IntArray): IntArray {\\n        return nums.map { it * it }.sorted().toIntArray()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun sortedSquares(nums: IntArray): IntArray {\\n        return nums.map { it * it }.sorted().toIntArray()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792303,
                "title": "python-two-pointers-99-45-faster-o-n-solution",
                "content": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        c,n=0,len(nums)\\n        if n==1:\\n            nums[0]*=nums[0]\\n            return nums\\n        for i in range(n):\\n            if nums[i]>=0: #it will give us the index of the first postive number\\n                break\\n            c+=1\\n        for i in range(n):\\n            nums[i]*=nums[i]\\n        if c==n:\\n            return nums[-1::-1]\\n        i,j=c,c-1\\n        ans=[]\\n        while i<n and j>=0:\\n            if nums[i]<nums[j]:\\n                ans.append(nums[i])\\n                i+=1\\n            else:\\n                ans.append(nums[j])\\n                j-=1\\n# Here wer are running these two loops to check that if there is any element left or not\\n        for ind in range(i,n):\\n            ans.append(nums[ind]) \\n        for ind in range(j,-1,-1):\\n            ans.append(nums[ind])\\n        return ans\\n```\\n\\n**Please upvote if you like the solution**\\n                \\n        \\n",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        c,n=0,len(nums)\\n        if n==1:\\n            nums[0]*=nums[0]\\n            return nums\\n        for i in range(n):\\n            if nums[i]>=0: #it will give us the index of the first postive number\\n                break\\n            c+=1\\n        for i in range(n):\\n            nums[i]*=nums[i]\\n        if c==n:\\n            return nums[-1::-1]\\n        i,j=c,c-1\\n        ans=[]\\n        while i<n and j>=0:\\n            if nums[i]<nums[j]:\\n                ans.append(nums[i])\\n                i+=1\\n            else:\\n                ans.append(nums[j])\\n                j-=1\\n# Here wer are running these two loops to check that if there is any element left or not\\n        for ind in range(i,n):\\n            ans.append(nums[ind]) \\n        for ind in range(j,-1,-1):\\n            ans.append(nums[ind])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784534,
                "title": "python-easy",
                "content": "**2 Pointer Approch**\\n```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        i = 0 \\n        j = len(nums) - 1\\n        lst = []\\n        while(i<=j):\\n            if(nums[i]<0):\\n                nums[i] *= -1\\n            if(nums[j]<0):\\n                nums[j] = nums[j]*(-1)\\n            if(nums[i]>nums[j]):\\n                    lst.append(nums[i]*nums[i])\\n                    i+=1\\n            else:\\n                    lst.append(nums[j]*nums[j])\\n                    j-=1\\n        return lst[::-1]\\n```\\n**OverWriting Method**\\n```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        lst = []\\n        for i in nums:\\n            lst.append(i*i)\\n        return sorted(lst)\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        i = 0 \\n        j = len(nums) - 1\\n        lst = []\\n        while(i<=j):\\n            if(nums[i]<0):\\n                nums[i] *= -1\\n            if(nums[j]<0):\\n                nums[j] = nums[j]*(-1)\\n            if(nums[i]>nums[j]):\\n                    lst.append(nums[i]*nums[i])\\n                    i+=1\\n            else:\\n                    lst.append(nums[j]*nums[j])\\n                    j-=1\\n        return lst[::-1]\\n```\n```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        lst = []\\n        for i in nums:\\n            lst.append(i*i)\\n        return sorted(lst)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2676939,
                "title": "clean-0ms-runtime-faster-than-100-submission",
                "content": "Time Complexity - O(N)\\nSpace Complexity - O(N)\\n```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n         if(nums.length==0)\\n            return nums; \\n\\t\\t\\t\\n//naive Approach\\n//         for(int i=0;i<nums.length;i++)\\n//             nums[i]*=nums[i];\\n//         Arrays.sort(nums);\\n       \\n            \\n        int ans[]= new int[nums.length];\\n            \\n        int l=0;\\n        int r = ans.length-1;\\n        int index = nums.length-1;\\n        \\n        while(l<=r)\\n        {\\n            int val1 = nums[l]*nums[l];\\n            int val2 = nums[r]*nums[r];\\n            if(val1>val2)\\n            {\\n                ans[index] = val1;\\n                l++;\\n            }\\n            else\\n            {\\n                ans[index] = val2;\\n                r--;\\n            }\\n            index--;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n         if(nums.length==0)\\n            return nums; \\n\\t\\t\\t\\n//naive Approach\\n//         for(int i=0;i<nums.length;i++)\\n//             nums[i]*=nums[i];\\n//         Arrays.sort(nums);\\n       \\n            \\n        int ans[]= new int[nums.length];\\n            \\n        int l=0;\\n        int r = ans.length-1;\\n        int index = nums.length-1;\\n        \\n        while(l<=r)\\n        {\\n            int val1 = nums[l]*nums[l];\\n            int val2 = nums[r]*nums[r];\\n            if(val1>val2)\\n            {\\n                ans[index] = val1;\\n                l++;\\n            }\\n            else\\n            {\\n                ans[index] = val2;\\n                r--;\\n            }\\n            index--;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2598384,
                "title": "c-solution-two-pointers",
                "content": "class Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        \\n        int left = 0;\\n        int right = nums.size()-1;\\n        vector<int>ans(nums.size(),0);\\n        \\n        for(int i = nums.size()-1; i>=0; i--){\\n            \\n            if(abs(nums[left]) > nums[right]){\\n                ans[i] = nums[left]*nums[left];\\n                left++;\\n            }\\n            else{\\n                ans[i] = nums[right]*nums[right];\\n                right--;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        \\n        int left = 0;\\n        int right = nums.size()-1;\\n        vector<int>ans(nums.size(),0);\\n        \\n        for(int i = nums.size()-1; i>=0; i--){\\n            \\n            if(abs(nums[left]) > nums[right]){\\n                ans[i] = nums[left]*nums[left];\\n                left++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2429646,
                "title": "java-easiest-solution-beginner-friendly-approach-8ms-runtime-faster-than-50-submission",
                "content": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        for(int i=0;i<nums.length;i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        Arrays.sort(nums);\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        for(int i=0;i<nums.length;i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        Arrays.sort(nums);\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2406220,
                "title": "2-pointers-fully-explained-python-3-o-n-79-29-faster",
                "content": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        \\n        # Solution with 2 Pointers\\n        # Time Complexity: O(n)  Space Complexity: O(n)\\n        \\n        \"\"\"\\n        \\n        1. Initialize two pointers: lowValue = 0; highValue = len(nums) - 1\\n        2. Create a list with same length as nums to  store squared values arranged in non decreasing order\\n        3. Loop through the nums array \"Backwards\" (last index to 0) \\n        \\n            For each i, compare the absolute values of given list at the lowValue and highValue indexes\\n            \\n            3a. If absolute value of element at index lowValue >= absolute value of element at index highValue:\\n                \\n                - Element of index i of new list = square (element at index lowValue)\\n                - lowValue += l (Increment lowValue)\\n                \\n            3b. Else if absolute value of element at index lowValue < absolute value of element at index highValue:\\n                \\n                - Element of index i of new list = square (element at index highValue)\\n                - highValue -= l (Decrement highValue)\\n             \\n        \"\"\"\\n                \\n        # Step 1.\\n        \\n        lowValue = 0\\n        highValue = len(nums) - 1\\n        \\n        # Step 2.\\n        nums_square = [None] * int(len(nums))\\n        \\n        # Step 3.\\n        for i in range(len(nums) - 1, -1, -1):\\n            \\n            # Step 3a.\\n            if abs(nums[lowValue]) >= abs(nums[highValue]):\\n                \\n                nums_square[i] = nums[lowValue] * nums[lowValue]\\n                lowValue+=1\\n            \\n            # Step 3b\\n            else:\\n                nums_square[i] = nums[highValue] * nums[highValue]\\n                highValue-=1\\n                \\n        return nums_square\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        \\n        # Solution with 2 Pointers\\n        # Time Complexity: O(n)  Space Complexity: O(n)\\n        \\n        \"\"\"\\n        \\n        1. Initialize two pointers: lowValue = 0; highValue = len(nums) - 1\\n        2. Create a list with same length as nums to  store squared values arranged in non decreasing order\\n        3. Loop through the nums array \"Backwards\" (last index to 0) \\n        \\n            For each i, compare the absolute values of given list at the lowValue and highValue indexes\\n            \\n            3a. If absolute value of element at index lowValue >= absolute value of element at index highValue:\\n                \\n                - Element of index i of new list = square (element at index lowValue)\\n                - lowValue += l (Increment lowValue)\\n                \\n            3b. Else if absolute value of element at index lowValue < absolute value of element at index highValue:\\n                \\n                - Element of index i of new list = square (element at index highValue)\\n                - highValue -= l (Decrement highValue)\\n             \\n        \"\"\"\\n                \\n        # Step 1.\\n        \\n        lowValue = 0\\n        highValue = len(nums) - 1\\n        \\n        # Step 2.\\n        nums_square = [None] * int(len(nums))\\n        \\n        # Step 3.\\n        for i in range(len(nums) - 1, -1, -1):\\n            \\n            # Step 3a.\\n            if abs(nums[lowValue]) >= abs(nums[highValue]):\\n                \\n                nums_square[i] = nums[lowValue] * nums[lowValue]\\n                lowValue+=1\\n            \\n            # Step 3b\\n            else:\\n                nums_square[i] = nums[highValue] * nums[highValue]\\n                highValue-=1\\n                \\n        return nums_square\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2284502,
                "title": "simple-python-solution-optimized-two-pointer-approach-with-comments",
                "content": "```\\n# Two Pointer Approach\\n\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        left, right, new_arr = 0, len(nums)-1, []\\n        \\n        while left <= right:\\n            if abs(nums[left]) <= abs(nums[right]): # if the absolute value of left pointer value is less than or equal to right pointer\\n                new_arr.append(nums[right]**2) # Since we need non decreasing order sorted array, append the square of the value of right pointer to nums.\\n                right -= 1\\n            else:\\n                new_arr.append(nums[left]**2) # append left pointer value to nums\\n                left += 1\\n            \\n        return(new_arr[::-1]) # since we need non decreasing order, we reverse the nums array\\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\n# Two Pointer Approach\\n\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        left, right, new_arr = 0, len(nums)-1, []\\n        \\n        while left <= right:\\n            if abs(nums[left]) <= abs(nums[right]): # if the absolute value of left pointer value is less than or equal to right pointer\\n                new_arr.append(nums[right]**2) # Since we need non decreasing order sorted array, append the square of the value of right pointer to nums.\\n                right -= 1\\n            else:\\n                new_arr.append(nums[left]**2) # append left pointer value to nums\\n                left += 1\\n            \\n        return(new_arr[::-1]) # since we need non decreasing order, we reverse the nums array\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 2280333,
                "title": "c-solution-3-lines-code-better-than-94-square-then-sort",
                "content": "```\\nvector<int> sortedSquares(vector<int>& nums) {\\n        for(auto &i: nums)\\n\\t\\t\\ti = i*i;\\n        sort(nums.begin(), nums.end());\\n        return nums;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nvector<int> sortedSquares(vector<int>& nums) {\\n        for(auto &i: nums)\\n\\t\\t\\ti = i*i;\\n        sort(nums.begin(), nums.end());\\n        return nums;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2267875,
                "title": "c-easy-clean-and-fastest-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        vector<int>res(nums.size());\\n        int l=0,r=nums.size()-1;\\n        for(int i=nums.size()-1;i>=0;i--)\\n        {\\n            if(abs(nums[r])>abs(nums[l]))\\n            {\\n                res[i]=nums[r]*nums[r];\\n                r--;\\n            }\\n            else\\n            {\\n                res[i]=nums[l]*nums[l];\\n                l++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\nUpvote if you find it useful. \\uD83D\\uDE4C",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        vector<int>res(nums.size());\\n        int l=0,r=nums.size()-1;\\n        for(int i=nums.size()-1;i>=0;i--)\\n        {\\n            if(abs(nums[r])>abs(nums[l]))\\n            {\\n                res[i]=nums[r]*nums[r];\\n                r--;\\n            }\\n            else\\n            {\\n                res[i]=nums[l]*nums[l];\\n                l++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2076517,
                "title": "easiest-java-soln-using-two-pointer-approach",
                "content": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int n=nums.length;\\n        int ans[]=new int [n];\\n        int a=0,b=n-1,x,y,i=n-1;\\n            while(a<=b)\\n            {\\n                x=nums[a]*nums[a];\\n                y=nums[b]*nums[b];\\n                if(x>y)\\n                {\\n                    ans[i--]=x;\\n                    a++;\\n                }\\n                else\\n                {\\n                    ans[i--]=y;\\n                    b--;\\n                }\\n            }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int n=nums.length;\\n        int ans[]=new int [n];\\n        int a=0,b=n-1,x,y,i=n-1;\\n            while(a<=b)\\n            {\\n                x=nums[a]*nums[a];\\n                y=nums[b]*nums[b];\\n                if(x>y)\\n                {\\n                    ans[i--]=x;\\n                    a++;\\n                }\\n                else\\n                {\\n                    ans[i--]=y;\\n                    b--;\\n                }\\n            }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2042618,
                "title": "o-n-solution-in-javascript",
                "content": "```javascript\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar sortedSquares = function(nums) {\\n    let result = Array(nums.length).fill(0);\\n    let left = 0;\\n    let right = nums.length - 1;\\n    for (let i = nums.length - 1; i >= 0; --i) {\\n        if (Math.abs(nums[left]) > Math.abs(nums[right])) {\\n            result[i] = nums[left] ** 2;\\n            left += 1;\\n        } else {\\n            result[i] = nums[right] ** 2;\\n            right -= 1;\\n        }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar sortedSquares = function(nums) {\\n    let result = Array(nums.length).fill(0);\\n    let left = 0;\\n    let right = nums.length - 1;\\n    for (let i = nums.length - 1; i >= 0; --i) {\\n        if (Math.abs(nums[left]) > Math.abs(nums[right])) {\\n            result[i] = nums[left] ** 2;\\n            left += 1;\\n        } else {\\n            result[i] = nums[right] ** 2;\\n            right -= 1;\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1966872,
                "title": "squares-of-a-sorted-array-java-easy-o-n-2-pointers-fastest-soln",
                "content": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        \\n        //Naive Approach\\n        \\n//         int n=nums.length;\\n//         int []arr=new int[n];\\n        \\n//         for(int i=0;i<n;i++){\\n//             arr[i]=nums[i]*nums[i];\\n//         }\\n        \\n//         Arrays.sort(arr);\\n        \\n//         return arr;\\n        \\n        \\n        int n=nums.length;\\n        \\n        int i=0;\\n        int j=n-1;\\n        \\n        int []res=new int[n];\\n        \\n        for(int k=n-1;k>=0;k--){\\n            if(Math.abs(nums[i])>Math.abs(nums[j])){\\n                res[k]=nums[i]*nums[i];\\n                i++;\\n            }else{\\n                res[k]=nums[j]*nums[j];\\n                j--;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        \\n        //Naive Approach\\n        \\n//         int n=nums.length;\\n//         int []arr=new int[n];\\n        \\n//         for(int i=0;i<n;i++){\\n//             arr[i]=nums[i]*nums[i];\\n//         }\\n        \\n//         Arrays.sort(arr);\\n        \\n//         return arr;\\n        \\n        \\n        int n=nums.length;\\n        \\n        int i=0;\\n        int j=n-1;\\n        \\n        int []res=new int[n];\\n        \\n        for(int k=n-1;k>=0;k--){\\n            if(Math.abs(nums[i])>Math.abs(nums[j])){\\n                res[k]=nums[i]*nums[i];\\n                i++;\\n            }else{\\n                res[k]=nums[j]*nums[j];\\n                j--;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1938824,
                "title": "very-easy-and-straight-forward-solution",
                "content": "```\\n\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        \\n        for(int i=0;i<nums.length;i++){\\n            \\n            nums[i]=nums[i]*nums[i];\\n        }\\n        \\n        Arrays.sort(nums);\\n        \\n        return nums;\\n        \\n    }\\n}\\n\\n```\\n\\nStep-1: Traverse the array\\nStep-2: At each traversal simply multiply the two numbers and store it at the \\'i-th\\' place.\\nStep-3: Sort the array and return its value.",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        \\n        for(int i=0;i<nums.length;i++){\\n            \\n            nums[i]=nums[i]*nums[i];\\n        }\\n        \\n        Arrays.sort(nums);\\n        \\n        return nums;\\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1903311,
                "title": "most-efficient-python-solution-using-two-pointers-approach",
                "content": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        l=0\\n        r=len(nums)-1\\n        ans=[0]*len(nums)\\n        for i in range(len(nums)-1,-1,-1):\\n            if nums[l]**2<nums[r]**2:\\n                ans[i]=nums[r]**2\\n                r-=1\\n            else:\\n                ans[i]=nums[l]**2\\n                l+=1\\n        return ans\\n```\\n**Complexity Analysis**\\n\\nTime Complexity: O(n) [Linear]\\nSpace complexity: O(n)\\n\\n**PLEASE UPVOTE FOR MOTIVATING ME TO CONTINUE COMMUNITY SUPPORT**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        l=0\\n        r=len(nums)-1\\n        ans=[0]*len(nums)\\n        for i in range(len(nums)-1,-1,-1):\\n            if nums[l]**2<nums[r]**2:\\n                ans[i]=nums[r]**2\\n                r-=1\\n            else:\\n                ans[i]=nums[l]**2\\n                l+=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1874940,
                "title": "python3-two-pointers-approach",
                "content": "In the two pointer approach you have to use two pointers to move around the array an do the stuff that you need.\\n\\nSo in this case, we have a pointer to the start of the array and another pointer in the end of the array. We compare the absolute value of the two values and get the bigger one, square the value and put at the end of the new array, and increment or decrement the pointer depending on which value is bigger.\\n\\nContinue on the loop till the start pointer is == to the end pointer and you will have the new array ordened with the squared values.\\n\\nPlease, if you have a better solution using the two pointers approach let me know!!! :D\\n\\n```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        length = len(nums)\\n        start, end = 0, length - 1\\n        res = [0]*length\\n        index = -1\\n\\n        while start <= end:\\n            if abs(nums[start]) > abs(nums[end]):\\n                res[index] = nums[start] * nums[start]\\n                start += 1\\n            else:\\n                res[index] = nums[end] * nums[end]\\n                end -= 1\\n            index -= 1\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        length = len(nums)\\n        start, end = 0, length - 1\\n        res = [0]*length\\n        index = -1\\n\\n        while start <= end:\\n            if abs(nums[start]) > abs(nums[end]):\\n                res[index] = nums[start] * nums[start]\\n                start += 1\\n            else:\\n                res[index] = nums[end] * nums[end]\\n                end -= 1\\n            index -= 1\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1792436,
                "title": "python-two-pointer-98-less-space",
                "content": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        left = 0\\n        right = len(nums) - 1\\n        \\n        while left <= right:\\n            l_sq = nums[left]**2\\n            r_sq = nums[right]**2\\n            \\n            if l_sq > r_sq:\\n                nums.insert(right + 1, l_sq)\\n                nums.pop(left)\\n            else:\\n                nums[right] = r_sq\\n            \\n            right -= 1\\n                \\n        return nums\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        left = 0\\n        right = len(nums) - 1\\n        \\n        while left <= right:\\n            l_sq = nums[left]**2\\n            r_sq = nums[right]**2\\n            \\n            if l_sq > r_sq:\\n                nums.insert(right + 1, l_sq)\\n                nums.pop(left)\\n            else:\\n                nums[right] = r_sq\\n            \\n            right -= 1\\n                \\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1759471,
                "title": "go-two-solutions-sort-o-nlogn-and-two-pointers-o-n",
                "content": "Hello Gophers!\\n\\n## Without the constraint O(n)\\n\\n### Solution 1 - Sort O(nlogn)\\n\\n```go\\nfunc sortedSquares(nums []int) []int {\\n    for idx, num := range nums {\\n        num *= num\\n        nums[idx] = num\\n    }\\n    sort.Ints(nums) // This is the reason why it\\'s O(nlogn)\\n    return nums\\n}\\n```\\n\\n## With the constraint O(n)\\n\\n> Constraint: Squaring each element and sorting the new array is very trivial, could you find an O(n) solution using a different approach?\\n\\n### Solution 2 - Two Pointers O(n)\\n\\nInstead of sorting, we use two pointers.\\nWe square all the nums, we add the numbers to the result slice (array)\\nfrom the smallest to the biggest, from middle of the array to the extemities (begin/end).\\n\\n```go\\nfunc sortedSquares(nums []int) []int {\\n    // STEP 1\\n\\t// First, we square all the nums\\n    for idx, num := range nums {\\n        num *= num\\n        nums[idx] = num\\n    }\\n    \\n    if len(nums) <= 1 {\\n        return nums\\n    }\\n    \\n\\t// STEP 2\\n\\t// After this, we move our two pointers where the smallest number is found\\n\\t// (near center, could be beginning or end)\\n    var ptr1, ptr2 int = 0, 1\\n    for ptr2 < len(nums)-1 && nums[ptr1] >= nums[ptr1+1] && nums[ptr2] >= nums[ptr2+1] {\\n        ptr1++\\n        ptr2++\\n    }\\n    \\n\\t// STEP 3\\n\\t// We add the smallest number to the result slice (array)\\n\\t//\\n\\t// If we add the value of the first pointer `ptr1`, we move it to left\\n\\t// Else if we add the value of the second pointer `ptr2`, we move it to the right\\n\\t// \\n\\t// If we are done with one pointer, to add values of the other pointers.\\n\\t// And we do this until we can\\'t.\\n    result := make([]int, 0)\\n    for {\\n        if ptr1 < 0 && ptr2 >= len(nums) {\\n            return result\\n        } else if ptr1 < 0 {\\n            result = append(result, nums[ptr2])\\n            ptr2++\\n        } else if ptr2 >= len(nums) {\\n            result = append(result, nums[ptr1])\\n            ptr1--\\n        } else if nums[ptr1] <= nums[ptr2] {\\n            result = append(result, nums[ptr1])\\n            ptr1--\\n        } else {\\n            result = append(result, nums[ptr2])\\n            ptr2++\\n        }\\n    }\\n    \\n    return result\\n}\\n```\\n\\n### Solution 3 - Two Pointers improved O(n)\\n\\nInspired by [this great solution](https://leetcode.com/problems/squares-of-a-sorted-array/discuss/495394/C%2B%2B%3A-Simplest-one-pass-two-pointers) (please, go like his post if you liked mine because of this solution):  \\ndo the same as the second solution, but\\n- we don\\'t square the values (step 1) before the construction of our result slice (step 3)\\n- we add the numbers to the result slice (array) from the biggest to the smallest, from the extemities (begin/end) of the array to the middle (no need of step 2)\\n\\n```go\\nfunc sortedSquares(nums []int) []int {\\n    var ptr1, ptr2 int = 0, len(nums)-1\\n    var currentIndex int = len(nums)-1\\n    result := make([]int, len(nums))\\n    for ptr2 >= ptr1 {    \\n        val1, val2 := nums[ptr1], nums[ptr2]\\n        sqr1, sqr2 := val1*val1, val2*val2\\n        if sqr1 >= sqr2 {\\n            result[currentIndex] = sqr1\\n            ptr1++\\n        } else /* if sqr1 < sqr2 */ {\\n            result[currentIndex] = sqr2\\n            ptr2--\\n        }\\n        currentIndex--\\n    }\\n    return result\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Two Pointers"
                ],
                "code": "```go\\nfunc sortedSquares(nums []int) []int {\\n    for idx, num := range nums {\\n        num *= num\\n        nums[idx] = num\\n    }\\n    sort.Ints(nums) // This is the reason why it\\'s O(nlogn)\\n    return nums\\n}\\n```\n```go\\nfunc sortedSquares(nums []int) []int {\\n    // STEP 1\\n\\t// First, we square all the nums\\n    for idx, num := range nums {\\n        num *= num\\n        nums[idx] = num\\n    }\\n    \\n    if len(nums) <= 1 {\\n        return nums\\n    }\\n    \\n\\t// STEP 2\\n\\t// After this, we move our two pointers where the smallest number is found\\n\\t// (near center, could be beginning or end)\\n    var ptr1, ptr2 int = 0, 1\\n    for ptr2 < len(nums)-1 && nums[ptr1] >= nums[ptr1+1] && nums[ptr2] >= nums[ptr2+1] {\\n        ptr1++\\n        ptr2++\\n    }\\n    \\n\\t// STEP 3\\n\\t// We add the smallest number to the result slice (array)\\n\\t//\\n\\t// If we add the value of the first pointer `ptr1`, we move it to left\\n\\t// Else if we add the value of the second pointer `ptr2`, we move it to the right\\n\\t// \\n\\t// If we are done with one pointer, to add values of the other pointers.\\n\\t// And we do this until we can\\'t.\\n    result := make([]int, 0)\\n    for {\\n        if ptr1 < 0 && ptr2 >= len(nums) {\\n            return result\\n        } else if ptr1 < 0 {\\n            result = append(result, nums[ptr2])\\n            ptr2++\\n        } else if ptr2 >= len(nums) {\\n            result = append(result, nums[ptr1])\\n            ptr1--\\n        } else if nums[ptr1] <= nums[ptr2] {\\n            result = append(result, nums[ptr1])\\n            ptr1--\\n        } else {\\n            result = append(result, nums[ptr2])\\n            ptr2++\\n        }\\n    }\\n    \\n    return result\\n}\\n```\n```go\\nfunc sortedSquares(nums []int) []int {\\n    var ptr1, ptr2 int = 0, len(nums)-1\\n    var currentIndex int = len(nums)-1\\n    result := make([]int, len(nums))\\n    for ptr2 >= ptr1 {    \\n        val1, val2 := nums[ptr1], nums[ptr2]\\n        sqr1, sqr2 := val1*val1, val2*val2\\n        if sqr1 >= sqr2 {\\n            result[currentIndex] = sqr1\\n            ptr1++\\n        } else /* if sqr1 < sqr2 */ {\\n            result[currentIndex] = sqr2\\n            ptr2--\\n        }\\n        currentIndex--\\n    }\\n    return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1683558,
                "title": "python-2-approaches",
                "content": "### Approach 1: \\n*  **Using Python Bisect to find the position to keep the element, so that the array remains sorted.**\\n \\n```\\nclass Solution(object):\\n    def sortedSquares(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        negativeList = []\\n        positiveList = []\\n        \\n        if len(nums) == 1:\\n            return [nums[0]**2]\\n        \\n        for i in nums:\\n            if i<0:\\n                negativeList.append(i)\\n            else:\\n                positiveList.append(i)\\n                \\n        negativeList = [abs(i) for i in negativeList]\\n\\n        for  i in negativeList:\\n            x = bisect.bisect(positiveList, i)\\n            positiveList.insert(x,i)\\n        \\n        res = [i*i for i in positiveList]\\n        return res\\n```       \\n\\n   ### Approach 2:\\n*    **Using two pointers technique**\\n*   **Took less time than the first approach**\\n\\n   ```\\n   class Solution(object):\\n    def sortedSquares(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        left = 0\\n        right = len(nums) - 1\\n        answer = [None]*len(nums)\\n        for i in range(len(nums)-1,-1,-1):\\n            if abs(nums[left]) > abs(nums[right]):\\n                answer[i] = nums[left]**2\\n                left += 1\\n                \\n            else:\\n                answer[i] = nums[right]**2\\n                right-=1\\n        return answer\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution(object):\\n    def sortedSquares(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        negativeList = []\\n        positiveList = []\\n        \\n        if len(nums) == 1:\\n            return [nums[0]**2]\\n        \\n        for i in nums:\\n            if i<0:\\n                negativeList.append(i)\\n            else:\\n                positiveList.append(i)\\n                \\n        negativeList = [abs(i) for i in negativeList]\\n\\n        for  i in negativeList:\\n            x = bisect.bisect(positiveList, i)\\n            positiveList.insert(x,i)\\n        \\n        res = [i*i for i in positiveList]\\n        return res\\n```\n```\\n   class Solution(object):\\n    def sortedSquares(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        left = 0\\n        right = len(nums) - 1\\n        answer = [None]*len(nums)\\n        for i in range(len(nums)-1,-1,-1):\\n            if abs(nums[left]) > abs(nums[right]):\\n                answer[i] = nums[left]**2\\n                left += 1\\n                \\n            else:\\n                answer[i] = nums[right]**2\\n                right-=1\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1658950,
                "title": "c-naive-vs-linear-time-constant-space-2-pointer-solution-100-time-90-space",
                "content": "First of all, the naive approach, which is trivially transforming the array and then sorting it, in place:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& A) {\\n        std::transform(begin(A), end(A), begin(A), [](int a){ return a * a; });\\n        sort(begin(A), end(A));\\n        return A;\\n    }\\n};\\n```\\n\\nPlus another variant of it I wrote [here](https://leetcode.com/problems/squares-of-a-sorted-array/discuss/793033/C%2B%2B-In-Place-3-Lines-Solution-Explained-~60-Time-~90-Space) a while ago.\\n\\nStill decent start in an interview setting, but odds are is that we will be asked the follow up question of this problem soon, so how can we solve it in linear time, even if it requires us to sort the elements following a new criterium?\\n\\nWell, turns out that we are not really left on our own device on this point, since we are provided an array that is *initially* already sorted and that is no small advantage at all!\\n\\nThe trick will be for us to pinpoint there the negative numbers end and when the positive ones star, with two separate points - at that point, we will pick the lesser one in absolute value and insert it into our result variable and so on.\\n\\nIn order to proceed, we will first of all declare a few support variables:\\n* `len` will store the length of our initial input, which also happens to be the length of our result variable;\\n* `i` will be the pointer set at the beginning of all the non-negative numbers (ie: `0` included, for convenience, not that it would change much if you were to put it under the other pointer); since `nums` is given to us as sorted, we can find this place in logn time, with built-in binary search (just be ready to explain how it works in an interview!);\\n* `j`, specularly, will point to the last (and thus lesser, since `nums` is sorted) negative number, right before `i`;\\n* `r` will point to where in `res` we will go writing;\\n* `n` is a support variable we will use soon;\\n* `res` is our accumulator variable, initially set to be of size `len` to avoid reallocations (and that is also why we have to use `r` to write in it).\\n\\nWe will then have a first loop that will proceed as long both `i` and `j` are within the boundaries of `nums` and that will:\\n* check if the absolute value of the element pointed by `j` is smaller than the one pointed by `i`, in which case we will:\\n\\t* store `nums[j]` into `n`;\\n\\t* decrease `j`;\\n\\t* write `n * n` in `res` at position `r`;\\n\\t* increase `r`;\\n* alternatively, we will:\\n\\t* store `nums[i]` into `n`;\\n\\t* increase `i`;\\n\\t* write `n * n` in `res` at position `r`;\\n\\t* increase `r`;\\n\\nFor the sake of efficiency, once either of this conditions is no longer `true`, we will then run two separate loops to do what we did in the first or second case, until even the second pointer is out of boundaries (ie: we are done writing into `res`); a bit of duplicated code, I concede, but still rather good to avoid looping with one extra unnecessary condition.\\n\\nOnce done, we can return `res` :)\\n\\nThe code (which varies crazily in performance when you run it, sometimes logging more than 4X the best time, my guess is because the test cases were not really well balanced across different runs):\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int len = nums.size(), i = lower_bound(begin(nums), end(nums), 0) - begin(nums),\\n            j = i - 1, r = 0, n;\\n        vector<int> res(len);\\n        while (j > -1 && i < len) {\\n            // first case: negative number with smaller absolute value\\n            if (-nums[j] < nums[i]) {\\n                n = nums[j--];\\n                res[r++] = n * n;\\n            }\\n            // second case: positive number with smaller absolute value\\n            else {\\n                n = nums[i++];\\n                res[r++] = n * n;\\n            }\\n        }\\n        // dealing with leftover negative numbers, if any\\n        while (j > -1) {\\n            n = nums[j--];\\n            res[r++] = n * n;\\n        }\\n        // dealing with leftover positive numbers, if any\\n        while (i < len) {\\n            n = nums[i++];\\n            res[r++] = n * n;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nBut, hey: since `lower_bound` gives us iterators, can\\'t we just use them? Turns out we of course can and they also perform better, at least running the code a few times for comparison:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int len = nums.size(), r = 0;\\n        auto start = begin(nums), ed = end(nums), i = lower_bound(start, ed, 0), j = i - 1;\\n        vector<int> res(len);\\n        while (j >= start && i != ed) {\\n            // first case: negative number with smaller absolute value\\n            if (-*j < *i) res[r++] = *j * *j--;\\n            // second case: positive number with smaller absolute value\\n            else res[r++] = *i * *i++;\\n        }\\n        // dealing with leftover negative numbers, if any\\n        while (j >= start) {\\n            res[r++] = *j * *j--;\\n        }\\n        // dealing with leftover positive numbers, if any\\n        while (i != ed) {\\n            res[r++] = *i * *i++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Sorting"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& A) {\\n        std::transform(begin(A), end(A), begin(A), [](int a){ return a * a; });\\n        sort(begin(A), end(A));\\n        return A;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int len = nums.size(), i = lower_bound(begin(nums), end(nums), 0) - begin(nums),\\n            j = i - 1, r = 0, n;\\n        vector<int> res(len);\\n        while (j > -1 && i < len) {\\n            // first case: negative number with smaller absolute value\\n            if (-nums[j] < nums[i]) {\\n                n = nums[j--];\\n                res[r++] = n * n;\\n            }\\n            // second case: positive number with smaller absolute value\\n            else {\\n                n = nums[i++];\\n                res[r++] = n * n;\\n            }\\n        }\\n        // dealing with leftover negative numbers, if any\\n        while (j > -1) {\\n            n = nums[j--];\\n            res[r++] = n * n;\\n        }\\n        // dealing with leftover positive numbers, if any\\n        while (i < len) {\\n            n = nums[i++];\\n            res[r++] = n * n;\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int len = nums.size(), r = 0;\\n        auto start = begin(nums), ed = end(nums), i = lower_bound(start, ed, 0), j = i - 1;\\n        vector<int> res(len);\\n        while (j >= start && i != ed) {\\n            // first case: negative number with smaller absolute value\\n            if (-*j < *i) res[r++] = *j * *j--;\\n            // second case: positive number with smaller absolute value\\n            else res[r++] = *i * *i++;\\n        }\\n        // dealing with leftover negative numbers, if any\\n        while (j >= start) {\\n            res[r++] = *j * *j--;\\n        }\\n        // dealing with leftover positive numbers, if any\\n        while (i != ed) {\\n            res[r++] = *i * *i++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1627416,
                "title": "easy-c-solution-with-two-pointers",
                "content": "```\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        vector <int> arr(nums.size());\\n\\t\\t// q and p are pointers, k is needed to push highest elements at the end of a new array\\n        int q=0, p=nums.size()-1, k=nums.size()-1;\\n        \\n        while(q<=p){\\n            if(nums[q]*nums[q]>nums[p]*nums[p]){\\n                arr[k--]=nums[q]*nums[q]; // Here we push at the end\\n                q++;\\n            }\\n            else{\\n                arr[k--]=nums[p]*nums[p];\\n                p--;\\n            }\\n        }\\n        return arr;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        vector <int> arr(nums.size());\\n\\t\\t// q and p are pointers, k is needed to push highest elements at the end of a new array\\n        int q=0, p=nums.size()-1, k=nums.size()-1;\\n        \\n        while(q<=p){\\n            if(nums[q]*nums[q]>nums[p]*nums[p]){\\n                arr[k--]=nums[q]*nums[q]; // Here we push at the end\\n                q++;\\n            }\\n            else{\\n                arr[k--]=nums[p]*nums[p];\\n                p--;\\n            }\\n        }\\n        return arr;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1577468,
                "title": "java-linear-time-solution",
                "content": "class Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        \\n        int n= nums.length;\\n        int left=0;\\n        int right=n-1;\\n        int[] answer = new int[n];\\n        \\n        for( int i=n-1;i>=0;i--)\\n        {\\n            int square =0;\\n            // We take a reverse approach for negative numbers\\n            if(Math.abs(nums[left])< Math.abs(nums[right]))\\n            {\\n                square= nums[right];\\n                right--;\\n            }\\n            else\\n            {\\n                square = nums[left];\\n                left++;  \\n            }\\n                \\n            answer[i]= square*square;\\n        }\\n        return answer;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        \\n        int n= nums.length;\\n        int left=0;\\n        int right=n-1;\\n        int[] answer = new int[n];\\n        \\n        for( int i=n-1;i>=0;i--)\\n        {\\n            int square =0;\\n            // We take a reverse approach for negative numbers\\n            if(Math.abs(nums[left])< Math.abs(nums[right]))\\n            {\\n                square= nums[right];\\n                right--;\\n            }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1576438,
                "content": [
                    {
                        "username": "robertocannella",
                        "content": "I created this interacitve tool to help me understand visually what is happening behind the code.   It  may help out others as well.  I will continue to build these so if there is interest in a specific algorithm or challenge, just send a note.\\nhttps://robertocannella-f5b4b.web.app/coding-challenges/sorted-squares"
                    },
                    {
                        "username": "zainabsajid",
                        "content": "this helped me alot thanks!\\n"
                    },
                    {
                        "username": "c8763yee",
                        "content": "thanks! but i don\\'t unstand why the 2nd approach using $O(logN)$ time complexity instead of $O(n)$"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You are amazing man!"
                    },
                    {
                        "username": "Itz-Verma",
                        "content": "thanks!"
                    },
                    {
                        "username": "kirsty",
                        "content": "Great animations, thank you! One comment - I believe the 2 ptr approach is actually O(N) runtime, your site says \"Two Pointer: O(N log N) time, O(N) or O(logN) space\".  Can you explain why it would be O(NlogN) runtime, or if it is a typo? "
                    },
                    {
                        "username": "Ayoub-89",
                        "content": "Legend ! thanks.\\n"
                    },
                    {
                        "username": "Damiandd",
                        "content": "it would be nice to slow it down a bit, but still excellent work. great thx!"
                    },
                    {
                        "username": "thapabharat123456",
                        "content": "wow..."
                    },
                    {
                        "username": "garrethue",
                        "content": "Hey, just want to say that I love your animations and the site in general. Keep it up dude!"
                    },
                    {
                        "username": "ijxx",
                        "content": "+1 for your animations."
                    },
                    {
                        "username": "puckhog08",
                        "content": "In the Arrays 101 Explore card leetcode asks you to solve this problem in-place and in O(n) time:\\n\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nHowever, even their own solution doesn\\'t meet these requirements. It doesn\\'t seem possible to stay within O(n) time without using extra space. Has anyone solved it this way?"
                    },
                    {
                        "username": "rokade",
                        "content": "[@blundell337](/blundell337) Asking an inplace solution for this (where we are not allowed to create a new output array) is the same problem as \"merge two sorted arrays in place and in O(n) time\". This can be done, but the techniques are extremely complicated. Here\\'s a white paper showing how it can be done :\\nhttp://akira.ruc.dk/~keld/teaching/algoritmedesign_f04/Artikler/04/Huang88.pdf\\n\\nOn a high level, the alog in the white paper uses parts of one of the array as a buffer to aid in sorting and merging the rest of the two arrays. I dont think one can be expected to give this solution in an interview.\\nHowever, i read it and found it fascinating on the same level that i find Knuth-Prat-Morris algorithm fascinating :)"
                    },
                    {
                        "username": "blundell337",
                        "content": "They mention in the \"Two Pointers\" explanation: \\n\\n\"Like in the previous two examples, this algorithm uses constant space (if we don\\'t count the output as extra space) and has a linear runtime.\"\\n\\nSo perhaps they are again, not counting the output?"
                    },
                    {
                        "username": "Primusai",
                        "content": "Python\\'s builtin sort is timsort which works by aggregating increasing and decreasing runs and then merging them. Since the resultant array after squaring all the terms will be first strictly decreasing and then strictly increasing, timsort reverses the strictly decreasing segment and then merges both runs in O(N)."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "How does timsort actually function? Is it an ensemble of sorting methods?"
                    },
                    {
                        "username": "h4rishabh",
                        "content": "Just a simple implementation, using Java 8 Streams\\n\\n` return Arrays.stream(nums).map(x -> x*x).sorted().toArray();`\\n\\n"
                    },
                    {
                        "username": "Devvyn",
                        "content": "this defeats the point of the question. You are not supposed to use built in functions. You are supposed to solve with data structures and algorithms. This question is meant to test two pointers approach. "
                    },
                    {
                        "username": "milileetcode",
                        "content": "![image](https://assets.leetcode.com/users/images/50ed0057-5595-48b7-bfc2-41c60b2f3229_1595280154.602534.png)\\n\\n\\nThis time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\\n\\nDid anyone work out such a solution?\\n"
                    },
                    {
                        "username": "joyrajlongjam",
                        "content": "![image](https://assets.leetcode.com/users/images/415c5cca-7771-4133-98f3-166e95fe6c05_1632028652.9367518.png)\\n"
                    },
                    {
                        "username": "t0rped0",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "Ed_H",
                        "content": "From the given information (provided when the (i) icon next to the problem name is selected):\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nThe given solution, both Java and Python versions, creates a new array.  The solutions in the comments either create a new array, or they do an in-place sort.  The in-place sorts usually use a built-in sort, which is not an O(N) solution, in addition to violating the \"No using built-in sort\" requirement.\\n\\nWe can have O(N) time or use O(1) space.  I don\\'t believe we can have both, and would be very interested in seeing an example to the contrary."
                    },
                    {
                        "username": "anth-volk",
                        "content": "For JS, an actually good programmer would just use the most syntactic, readable elements of the language, right? nums.map, followed by nums.sort. This code would be more readable, more maintainable, and potentially more modular, depending on implementation. And yet here we are, trying to move around array indices to sort this thing *slightly* faster"
                    },
                    {
                        "username": "nilanjan9",
                        "content": "\\'\\'\\'\\nreturn sorted(list(map(lambda x:x*x,nums )))\\n\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1565880,
                "content": [
                    {
                        "username": "robertocannella",
                        "content": "I created this interacitve tool to help me understand visually what is happening behind the code.   It  may help out others as well.  I will continue to build these so if there is interest in a specific algorithm or challenge, just send a note.\\nhttps://robertocannella-f5b4b.web.app/coding-challenges/sorted-squares"
                    },
                    {
                        "username": "zainabsajid",
                        "content": "this helped me alot thanks!\\n"
                    },
                    {
                        "username": "c8763yee",
                        "content": "thanks! but i don\\'t unstand why the 2nd approach using $O(logN)$ time complexity instead of $O(n)$"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You are amazing man!"
                    },
                    {
                        "username": "Itz-Verma",
                        "content": "thanks!"
                    },
                    {
                        "username": "kirsty",
                        "content": "Great animations, thank you! One comment - I believe the 2 ptr approach is actually O(N) runtime, your site says \"Two Pointer: O(N log N) time, O(N) or O(logN) space\".  Can you explain why it would be O(NlogN) runtime, or if it is a typo? "
                    },
                    {
                        "username": "Ayoub-89",
                        "content": "Legend ! thanks.\\n"
                    },
                    {
                        "username": "Damiandd",
                        "content": "it would be nice to slow it down a bit, but still excellent work. great thx!"
                    },
                    {
                        "username": "thapabharat123456",
                        "content": "wow..."
                    },
                    {
                        "username": "garrethue",
                        "content": "Hey, just want to say that I love your animations and the site in general. Keep it up dude!"
                    },
                    {
                        "username": "ijxx",
                        "content": "+1 for your animations."
                    },
                    {
                        "username": "puckhog08",
                        "content": "In the Arrays 101 Explore card leetcode asks you to solve this problem in-place and in O(n) time:\\n\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nHowever, even their own solution doesn\\'t meet these requirements. It doesn\\'t seem possible to stay within O(n) time without using extra space. Has anyone solved it this way?"
                    },
                    {
                        "username": "rokade",
                        "content": "[@blundell337](/blundell337) Asking an inplace solution for this (where we are not allowed to create a new output array) is the same problem as \"merge two sorted arrays in place and in O(n) time\". This can be done, but the techniques are extremely complicated. Here\\'s a white paper showing how it can be done :\\nhttp://akira.ruc.dk/~keld/teaching/algoritmedesign_f04/Artikler/04/Huang88.pdf\\n\\nOn a high level, the alog in the white paper uses parts of one of the array as a buffer to aid in sorting and merging the rest of the two arrays. I dont think one can be expected to give this solution in an interview.\\nHowever, i read it and found it fascinating on the same level that i find Knuth-Prat-Morris algorithm fascinating :)"
                    },
                    {
                        "username": "blundell337",
                        "content": "They mention in the \"Two Pointers\" explanation: \\n\\n\"Like in the previous two examples, this algorithm uses constant space (if we don\\'t count the output as extra space) and has a linear runtime.\"\\n\\nSo perhaps they are again, not counting the output?"
                    },
                    {
                        "username": "Primusai",
                        "content": "Python\\'s builtin sort is timsort which works by aggregating increasing and decreasing runs and then merging them. Since the resultant array after squaring all the terms will be first strictly decreasing and then strictly increasing, timsort reverses the strictly decreasing segment and then merges both runs in O(N)."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "How does timsort actually function? Is it an ensemble of sorting methods?"
                    },
                    {
                        "username": "h4rishabh",
                        "content": "Just a simple implementation, using Java 8 Streams\\n\\n` return Arrays.stream(nums).map(x -> x*x).sorted().toArray();`\\n\\n"
                    },
                    {
                        "username": "Devvyn",
                        "content": "this defeats the point of the question. You are not supposed to use built in functions. You are supposed to solve with data structures and algorithms. This question is meant to test two pointers approach. "
                    },
                    {
                        "username": "milileetcode",
                        "content": "![image](https://assets.leetcode.com/users/images/50ed0057-5595-48b7-bfc2-41c60b2f3229_1595280154.602534.png)\\n\\n\\nThis time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\\n\\nDid anyone work out such a solution?\\n"
                    },
                    {
                        "username": "joyrajlongjam",
                        "content": "![image](https://assets.leetcode.com/users/images/415c5cca-7771-4133-98f3-166e95fe6c05_1632028652.9367518.png)\\n"
                    },
                    {
                        "username": "t0rped0",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "Ed_H",
                        "content": "From the given information (provided when the (i) icon next to the problem name is selected):\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nThe given solution, both Java and Python versions, creates a new array.  The solutions in the comments either create a new array, or they do an in-place sort.  The in-place sorts usually use a built-in sort, which is not an O(N) solution, in addition to violating the \"No using built-in sort\" requirement.\\n\\nWe can have O(N) time or use O(1) space.  I don\\'t believe we can have both, and would be very interested in seeing an example to the contrary."
                    },
                    {
                        "username": "anth-volk",
                        "content": "For JS, an actually good programmer would just use the most syntactic, readable elements of the language, right? nums.map, followed by nums.sort. This code would be more readable, more maintainable, and potentially more modular, depending on implementation. And yet here we are, trying to move around array indices to sort this thing *slightly* faster"
                    },
                    {
                        "username": "nilanjan9",
                        "content": "\\'\\'\\'\\nreturn sorted(list(map(lambda x:x*x,nums )))\\n\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1564797,
                "content": [
                    {
                        "username": "robertocannella",
                        "content": "I created this interacitve tool to help me understand visually what is happening behind the code.   It  may help out others as well.  I will continue to build these so if there is interest in a specific algorithm or challenge, just send a note.\\nhttps://robertocannella-f5b4b.web.app/coding-challenges/sorted-squares"
                    },
                    {
                        "username": "zainabsajid",
                        "content": "this helped me alot thanks!\\n"
                    },
                    {
                        "username": "c8763yee",
                        "content": "thanks! but i don\\'t unstand why the 2nd approach using $O(logN)$ time complexity instead of $O(n)$"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You are amazing man!"
                    },
                    {
                        "username": "Itz-Verma",
                        "content": "thanks!"
                    },
                    {
                        "username": "kirsty",
                        "content": "Great animations, thank you! One comment - I believe the 2 ptr approach is actually O(N) runtime, your site says \"Two Pointer: O(N log N) time, O(N) or O(logN) space\".  Can you explain why it would be O(NlogN) runtime, or if it is a typo? "
                    },
                    {
                        "username": "Ayoub-89",
                        "content": "Legend ! thanks.\\n"
                    },
                    {
                        "username": "Damiandd",
                        "content": "it would be nice to slow it down a bit, but still excellent work. great thx!"
                    },
                    {
                        "username": "thapabharat123456",
                        "content": "wow..."
                    },
                    {
                        "username": "garrethue",
                        "content": "Hey, just want to say that I love your animations and the site in general. Keep it up dude!"
                    },
                    {
                        "username": "ijxx",
                        "content": "+1 for your animations."
                    },
                    {
                        "username": "puckhog08",
                        "content": "In the Arrays 101 Explore card leetcode asks you to solve this problem in-place and in O(n) time:\\n\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nHowever, even their own solution doesn\\'t meet these requirements. It doesn\\'t seem possible to stay within O(n) time without using extra space. Has anyone solved it this way?"
                    },
                    {
                        "username": "rokade",
                        "content": "[@blundell337](/blundell337) Asking an inplace solution for this (where we are not allowed to create a new output array) is the same problem as \"merge two sorted arrays in place and in O(n) time\". This can be done, but the techniques are extremely complicated. Here\\'s a white paper showing how it can be done :\\nhttp://akira.ruc.dk/~keld/teaching/algoritmedesign_f04/Artikler/04/Huang88.pdf\\n\\nOn a high level, the alog in the white paper uses parts of one of the array as a buffer to aid in sorting and merging the rest of the two arrays. I dont think one can be expected to give this solution in an interview.\\nHowever, i read it and found it fascinating on the same level that i find Knuth-Prat-Morris algorithm fascinating :)"
                    },
                    {
                        "username": "blundell337",
                        "content": "They mention in the \"Two Pointers\" explanation: \\n\\n\"Like in the previous two examples, this algorithm uses constant space (if we don\\'t count the output as extra space) and has a linear runtime.\"\\n\\nSo perhaps they are again, not counting the output?"
                    },
                    {
                        "username": "Primusai",
                        "content": "Python\\'s builtin sort is timsort which works by aggregating increasing and decreasing runs and then merging them. Since the resultant array after squaring all the terms will be first strictly decreasing and then strictly increasing, timsort reverses the strictly decreasing segment and then merges both runs in O(N)."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "How does timsort actually function? Is it an ensemble of sorting methods?"
                    },
                    {
                        "username": "h4rishabh",
                        "content": "Just a simple implementation, using Java 8 Streams\\n\\n` return Arrays.stream(nums).map(x -> x*x).sorted().toArray();`\\n\\n"
                    },
                    {
                        "username": "Devvyn",
                        "content": "this defeats the point of the question. You are not supposed to use built in functions. You are supposed to solve with data structures and algorithms. This question is meant to test two pointers approach. "
                    },
                    {
                        "username": "milileetcode",
                        "content": "![image](https://assets.leetcode.com/users/images/50ed0057-5595-48b7-bfc2-41c60b2f3229_1595280154.602534.png)\\n\\n\\nThis time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\\n\\nDid anyone work out such a solution?\\n"
                    },
                    {
                        "username": "joyrajlongjam",
                        "content": "![image](https://assets.leetcode.com/users/images/415c5cca-7771-4133-98f3-166e95fe6c05_1632028652.9367518.png)\\n"
                    },
                    {
                        "username": "t0rped0",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "Ed_H",
                        "content": "From the given information (provided when the (i) icon next to the problem name is selected):\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nThe given solution, both Java and Python versions, creates a new array.  The solutions in the comments either create a new array, or they do an in-place sort.  The in-place sorts usually use a built-in sort, which is not an O(N) solution, in addition to violating the \"No using built-in sort\" requirement.\\n\\nWe can have O(N) time or use O(1) space.  I don\\'t believe we can have both, and would be very interested in seeing an example to the contrary."
                    },
                    {
                        "username": "anth-volk",
                        "content": "For JS, an actually good programmer would just use the most syntactic, readable elements of the language, right? nums.map, followed by nums.sort. This code would be more readable, more maintainable, and potentially more modular, depending on implementation. And yet here we are, trying to move around array indices to sort this thing *slightly* faster"
                    },
                    {
                        "username": "nilanjan9",
                        "content": "\\'\\'\\'\\nreturn sorted(list(map(lambda x:x*x,nums )))\\n\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1570583,
                "content": [
                    {
                        "username": "robertocannella",
                        "content": "I created this interacitve tool to help me understand visually what is happening behind the code.   It  may help out others as well.  I will continue to build these so if there is interest in a specific algorithm or challenge, just send a note.\\nhttps://robertocannella-f5b4b.web.app/coding-challenges/sorted-squares"
                    },
                    {
                        "username": "zainabsajid",
                        "content": "this helped me alot thanks!\\n"
                    },
                    {
                        "username": "c8763yee",
                        "content": "thanks! but i don\\'t unstand why the 2nd approach using $O(logN)$ time complexity instead of $O(n)$"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You are amazing man!"
                    },
                    {
                        "username": "Itz-Verma",
                        "content": "thanks!"
                    },
                    {
                        "username": "kirsty",
                        "content": "Great animations, thank you! One comment - I believe the 2 ptr approach is actually O(N) runtime, your site says \"Two Pointer: O(N log N) time, O(N) or O(logN) space\".  Can you explain why it would be O(NlogN) runtime, or if it is a typo? "
                    },
                    {
                        "username": "Ayoub-89",
                        "content": "Legend ! thanks.\\n"
                    },
                    {
                        "username": "Damiandd",
                        "content": "it would be nice to slow it down a bit, but still excellent work. great thx!"
                    },
                    {
                        "username": "thapabharat123456",
                        "content": "wow..."
                    },
                    {
                        "username": "garrethue",
                        "content": "Hey, just want to say that I love your animations and the site in general. Keep it up dude!"
                    },
                    {
                        "username": "ijxx",
                        "content": "+1 for your animations."
                    },
                    {
                        "username": "puckhog08",
                        "content": "In the Arrays 101 Explore card leetcode asks you to solve this problem in-place and in O(n) time:\\n\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nHowever, even their own solution doesn\\'t meet these requirements. It doesn\\'t seem possible to stay within O(n) time without using extra space. Has anyone solved it this way?"
                    },
                    {
                        "username": "rokade",
                        "content": "[@blundell337](/blundell337) Asking an inplace solution for this (where we are not allowed to create a new output array) is the same problem as \"merge two sorted arrays in place and in O(n) time\". This can be done, but the techniques are extremely complicated. Here\\'s a white paper showing how it can be done :\\nhttp://akira.ruc.dk/~keld/teaching/algoritmedesign_f04/Artikler/04/Huang88.pdf\\n\\nOn a high level, the alog in the white paper uses parts of one of the array as a buffer to aid in sorting and merging the rest of the two arrays. I dont think one can be expected to give this solution in an interview.\\nHowever, i read it and found it fascinating on the same level that i find Knuth-Prat-Morris algorithm fascinating :)"
                    },
                    {
                        "username": "blundell337",
                        "content": "They mention in the \"Two Pointers\" explanation: \\n\\n\"Like in the previous two examples, this algorithm uses constant space (if we don\\'t count the output as extra space) and has a linear runtime.\"\\n\\nSo perhaps they are again, not counting the output?"
                    },
                    {
                        "username": "Primusai",
                        "content": "Python\\'s builtin sort is timsort which works by aggregating increasing and decreasing runs and then merging them. Since the resultant array after squaring all the terms will be first strictly decreasing and then strictly increasing, timsort reverses the strictly decreasing segment and then merges both runs in O(N)."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "How does timsort actually function? Is it an ensemble of sorting methods?"
                    },
                    {
                        "username": "h4rishabh",
                        "content": "Just a simple implementation, using Java 8 Streams\\n\\n` return Arrays.stream(nums).map(x -> x*x).sorted().toArray();`\\n\\n"
                    },
                    {
                        "username": "Devvyn",
                        "content": "this defeats the point of the question. You are not supposed to use built in functions. You are supposed to solve with data structures and algorithms. This question is meant to test two pointers approach. "
                    },
                    {
                        "username": "milileetcode",
                        "content": "![image](https://assets.leetcode.com/users/images/50ed0057-5595-48b7-bfc2-41c60b2f3229_1595280154.602534.png)\\n\\n\\nThis time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\\n\\nDid anyone work out such a solution?\\n"
                    },
                    {
                        "username": "joyrajlongjam",
                        "content": "![image](https://assets.leetcode.com/users/images/415c5cca-7771-4133-98f3-166e95fe6c05_1632028652.9367518.png)\\n"
                    },
                    {
                        "username": "t0rped0",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "Ed_H",
                        "content": "From the given information (provided when the (i) icon next to the problem name is selected):\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nThe given solution, both Java and Python versions, creates a new array.  The solutions in the comments either create a new array, or they do an in-place sort.  The in-place sorts usually use a built-in sort, which is not an O(N) solution, in addition to violating the \"No using built-in sort\" requirement.\\n\\nWe can have O(N) time or use O(1) space.  I don\\'t believe we can have both, and would be very interested in seeing an example to the contrary."
                    },
                    {
                        "username": "anth-volk",
                        "content": "For JS, an actually good programmer would just use the most syntactic, readable elements of the language, right? nums.map, followed by nums.sort. This code would be more readable, more maintainable, and potentially more modular, depending on implementation. And yet here we are, trying to move around array indices to sort this thing *slightly* faster"
                    },
                    {
                        "username": "nilanjan9",
                        "content": "\\'\\'\\'\\nreturn sorted(list(map(lambda x:x*x,nums )))\\n\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1570076,
                "content": [
                    {
                        "username": "robertocannella",
                        "content": "I created this interacitve tool to help me understand visually what is happening behind the code.   It  may help out others as well.  I will continue to build these so if there is interest in a specific algorithm or challenge, just send a note.\\nhttps://robertocannella-f5b4b.web.app/coding-challenges/sorted-squares"
                    },
                    {
                        "username": "zainabsajid",
                        "content": "this helped me alot thanks!\\n"
                    },
                    {
                        "username": "c8763yee",
                        "content": "thanks! but i don\\'t unstand why the 2nd approach using $O(logN)$ time complexity instead of $O(n)$"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You are amazing man!"
                    },
                    {
                        "username": "Itz-Verma",
                        "content": "thanks!"
                    },
                    {
                        "username": "kirsty",
                        "content": "Great animations, thank you! One comment - I believe the 2 ptr approach is actually O(N) runtime, your site says \"Two Pointer: O(N log N) time, O(N) or O(logN) space\".  Can you explain why it would be O(NlogN) runtime, or if it is a typo? "
                    },
                    {
                        "username": "Ayoub-89",
                        "content": "Legend ! thanks.\\n"
                    },
                    {
                        "username": "Damiandd",
                        "content": "it would be nice to slow it down a bit, but still excellent work. great thx!"
                    },
                    {
                        "username": "thapabharat123456",
                        "content": "wow..."
                    },
                    {
                        "username": "garrethue",
                        "content": "Hey, just want to say that I love your animations and the site in general. Keep it up dude!"
                    },
                    {
                        "username": "ijxx",
                        "content": "+1 for your animations."
                    },
                    {
                        "username": "puckhog08",
                        "content": "In the Arrays 101 Explore card leetcode asks you to solve this problem in-place and in O(n) time:\\n\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nHowever, even their own solution doesn\\'t meet these requirements. It doesn\\'t seem possible to stay within O(n) time without using extra space. Has anyone solved it this way?"
                    },
                    {
                        "username": "rokade",
                        "content": "[@blundell337](/blundell337) Asking an inplace solution for this (where we are not allowed to create a new output array) is the same problem as \"merge two sorted arrays in place and in O(n) time\". This can be done, but the techniques are extremely complicated. Here\\'s a white paper showing how it can be done :\\nhttp://akira.ruc.dk/~keld/teaching/algoritmedesign_f04/Artikler/04/Huang88.pdf\\n\\nOn a high level, the alog in the white paper uses parts of one of the array as a buffer to aid in sorting and merging the rest of the two arrays. I dont think one can be expected to give this solution in an interview.\\nHowever, i read it and found it fascinating on the same level that i find Knuth-Prat-Morris algorithm fascinating :)"
                    },
                    {
                        "username": "blundell337",
                        "content": "They mention in the \"Two Pointers\" explanation: \\n\\n\"Like in the previous two examples, this algorithm uses constant space (if we don\\'t count the output as extra space) and has a linear runtime.\"\\n\\nSo perhaps they are again, not counting the output?"
                    },
                    {
                        "username": "Primusai",
                        "content": "Python\\'s builtin sort is timsort which works by aggregating increasing and decreasing runs and then merging them. Since the resultant array after squaring all the terms will be first strictly decreasing and then strictly increasing, timsort reverses the strictly decreasing segment and then merges both runs in O(N)."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "How does timsort actually function? Is it an ensemble of sorting methods?"
                    },
                    {
                        "username": "h4rishabh",
                        "content": "Just a simple implementation, using Java 8 Streams\\n\\n` return Arrays.stream(nums).map(x -> x*x).sorted().toArray();`\\n\\n"
                    },
                    {
                        "username": "Devvyn",
                        "content": "this defeats the point of the question. You are not supposed to use built in functions. You are supposed to solve with data structures and algorithms. This question is meant to test two pointers approach. "
                    },
                    {
                        "username": "milileetcode",
                        "content": "![image](https://assets.leetcode.com/users/images/50ed0057-5595-48b7-bfc2-41c60b2f3229_1595280154.602534.png)\\n\\n\\nThis time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\\n\\nDid anyone work out such a solution?\\n"
                    },
                    {
                        "username": "joyrajlongjam",
                        "content": "![image](https://assets.leetcode.com/users/images/415c5cca-7771-4133-98f3-166e95fe6c05_1632028652.9367518.png)\\n"
                    },
                    {
                        "username": "t0rped0",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "Ed_H",
                        "content": "From the given information (provided when the (i) icon next to the problem name is selected):\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nThe given solution, both Java and Python versions, creates a new array.  The solutions in the comments either create a new array, or they do an in-place sort.  The in-place sorts usually use a built-in sort, which is not an O(N) solution, in addition to violating the \"No using built-in sort\" requirement.\\n\\nWe can have O(N) time or use O(1) space.  I don\\'t believe we can have both, and would be very interested in seeing an example to the contrary."
                    },
                    {
                        "username": "anth-volk",
                        "content": "For JS, an actually good programmer would just use the most syntactic, readable elements of the language, right? nums.map, followed by nums.sort. This code would be more readable, more maintainable, and potentially more modular, depending on implementation. And yet here we are, trying to move around array indices to sort this thing *slightly* faster"
                    },
                    {
                        "username": "nilanjan9",
                        "content": "\\'\\'\\'\\nreturn sorted(list(map(lambda x:x*x,nums )))\\n\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1575767,
                "content": [
                    {
                        "username": "robertocannella",
                        "content": "I created this interacitve tool to help me understand visually what is happening behind the code.   It  may help out others as well.  I will continue to build these so if there is interest in a specific algorithm or challenge, just send a note.\\nhttps://robertocannella-f5b4b.web.app/coding-challenges/sorted-squares"
                    },
                    {
                        "username": "zainabsajid",
                        "content": "this helped me alot thanks!\\n"
                    },
                    {
                        "username": "c8763yee",
                        "content": "thanks! but i don\\'t unstand why the 2nd approach using $O(logN)$ time complexity instead of $O(n)$"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You are amazing man!"
                    },
                    {
                        "username": "Itz-Verma",
                        "content": "thanks!"
                    },
                    {
                        "username": "kirsty",
                        "content": "Great animations, thank you! One comment - I believe the 2 ptr approach is actually O(N) runtime, your site says \"Two Pointer: O(N log N) time, O(N) or O(logN) space\".  Can you explain why it would be O(NlogN) runtime, or if it is a typo? "
                    },
                    {
                        "username": "Ayoub-89",
                        "content": "Legend ! thanks.\\n"
                    },
                    {
                        "username": "Damiandd",
                        "content": "it would be nice to slow it down a bit, but still excellent work. great thx!"
                    },
                    {
                        "username": "thapabharat123456",
                        "content": "wow..."
                    },
                    {
                        "username": "garrethue",
                        "content": "Hey, just want to say that I love your animations and the site in general. Keep it up dude!"
                    },
                    {
                        "username": "ijxx",
                        "content": "+1 for your animations."
                    },
                    {
                        "username": "puckhog08",
                        "content": "In the Arrays 101 Explore card leetcode asks you to solve this problem in-place and in O(n) time:\\n\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nHowever, even their own solution doesn\\'t meet these requirements. It doesn\\'t seem possible to stay within O(n) time without using extra space. Has anyone solved it this way?"
                    },
                    {
                        "username": "rokade",
                        "content": "[@blundell337](/blundell337) Asking an inplace solution for this (where we are not allowed to create a new output array) is the same problem as \"merge two sorted arrays in place and in O(n) time\". This can be done, but the techniques are extremely complicated. Here\\'s a white paper showing how it can be done :\\nhttp://akira.ruc.dk/~keld/teaching/algoritmedesign_f04/Artikler/04/Huang88.pdf\\n\\nOn a high level, the alog in the white paper uses parts of one of the array as a buffer to aid in sorting and merging the rest of the two arrays. I dont think one can be expected to give this solution in an interview.\\nHowever, i read it and found it fascinating on the same level that i find Knuth-Prat-Morris algorithm fascinating :)"
                    },
                    {
                        "username": "blundell337",
                        "content": "They mention in the \"Two Pointers\" explanation: \\n\\n\"Like in the previous two examples, this algorithm uses constant space (if we don\\'t count the output as extra space) and has a linear runtime.\"\\n\\nSo perhaps they are again, not counting the output?"
                    },
                    {
                        "username": "Primusai",
                        "content": "Python\\'s builtin sort is timsort which works by aggregating increasing and decreasing runs and then merging them. Since the resultant array after squaring all the terms will be first strictly decreasing and then strictly increasing, timsort reverses the strictly decreasing segment and then merges both runs in O(N)."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "How does timsort actually function? Is it an ensemble of sorting methods?"
                    },
                    {
                        "username": "h4rishabh",
                        "content": "Just a simple implementation, using Java 8 Streams\\n\\n` return Arrays.stream(nums).map(x -> x*x).sorted().toArray();`\\n\\n"
                    },
                    {
                        "username": "Devvyn",
                        "content": "this defeats the point of the question. You are not supposed to use built in functions. You are supposed to solve with data structures and algorithms. This question is meant to test two pointers approach. "
                    },
                    {
                        "username": "milileetcode",
                        "content": "![image](https://assets.leetcode.com/users/images/50ed0057-5595-48b7-bfc2-41c60b2f3229_1595280154.602534.png)\\n\\n\\nThis time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\\n\\nDid anyone work out such a solution?\\n"
                    },
                    {
                        "username": "joyrajlongjam",
                        "content": "![image](https://assets.leetcode.com/users/images/415c5cca-7771-4133-98f3-166e95fe6c05_1632028652.9367518.png)\\n"
                    },
                    {
                        "username": "t0rped0",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "Ed_H",
                        "content": "From the given information (provided when the (i) icon next to the problem name is selected):\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nThe given solution, both Java and Python versions, creates a new array.  The solutions in the comments either create a new array, or they do an in-place sort.  The in-place sorts usually use a built-in sort, which is not an O(N) solution, in addition to violating the \"No using built-in sort\" requirement.\\n\\nWe can have O(N) time or use O(1) space.  I don\\'t believe we can have both, and would be very interested in seeing an example to the contrary."
                    },
                    {
                        "username": "anth-volk",
                        "content": "For JS, an actually good programmer would just use the most syntactic, readable elements of the language, right? nums.map, followed by nums.sort. This code would be more readable, more maintainable, and potentially more modular, depending on implementation. And yet here we are, trying to move around array indices to sort this thing *slightly* faster"
                    },
                    {
                        "username": "nilanjan9",
                        "content": "\\'\\'\\'\\nreturn sorted(list(map(lambda x:x*x,nums )))\\n\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1573931,
                "content": [
                    {
                        "username": "robertocannella",
                        "content": "I created this interacitve tool to help me understand visually what is happening behind the code.   It  may help out others as well.  I will continue to build these so if there is interest in a specific algorithm or challenge, just send a note.\\nhttps://robertocannella-f5b4b.web.app/coding-challenges/sorted-squares"
                    },
                    {
                        "username": "zainabsajid",
                        "content": "this helped me alot thanks!\\n"
                    },
                    {
                        "username": "c8763yee",
                        "content": "thanks! but i don\\'t unstand why the 2nd approach using $O(logN)$ time complexity instead of $O(n)$"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You are amazing man!"
                    },
                    {
                        "username": "Itz-Verma",
                        "content": "thanks!"
                    },
                    {
                        "username": "kirsty",
                        "content": "Great animations, thank you! One comment - I believe the 2 ptr approach is actually O(N) runtime, your site says \"Two Pointer: O(N log N) time, O(N) or O(logN) space\".  Can you explain why it would be O(NlogN) runtime, or if it is a typo? "
                    },
                    {
                        "username": "Ayoub-89",
                        "content": "Legend ! thanks.\\n"
                    },
                    {
                        "username": "Damiandd",
                        "content": "it would be nice to slow it down a bit, but still excellent work. great thx!"
                    },
                    {
                        "username": "thapabharat123456",
                        "content": "wow..."
                    },
                    {
                        "username": "garrethue",
                        "content": "Hey, just want to say that I love your animations and the site in general. Keep it up dude!"
                    },
                    {
                        "username": "ijxx",
                        "content": "+1 for your animations."
                    },
                    {
                        "username": "puckhog08",
                        "content": "In the Arrays 101 Explore card leetcode asks you to solve this problem in-place and in O(n) time:\\n\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nHowever, even their own solution doesn\\'t meet these requirements. It doesn\\'t seem possible to stay within O(n) time without using extra space. Has anyone solved it this way?"
                    },
                    {
                        "username": "rokade",
                        "content": "[@blundell337](/blundell337) Asking an inplace solution for this (where we are not allowed to create a new output array) is the same problem as \"merge two sorted arrays in place and in O(n) time\". This can be done, but the techniques are extremely complicated. Here\\'s a white paper showing how it can be done :\\nhttp://akira.ruc.dk/~keld/teaching/algoritmedesign_f04/Artikler/04/Huang88.pdf\\n\\nOn a high level, the alog in the white paper uses parts of one of the array as a buffer to aid in sorting and merging the rest of the two arrays. I dont think one can be expected to give this solution in an interview.\\nHowever, i read it and found it fascinating on the same level that i find Knuth-Prat-Morris algorithm fascinating :)"
                    },
                    {
                        "username": "blundell337",
                        "content": "They mention in the \"Two Pointers\" explanation: \\n\\n\"Like in the previous two examples, this algorithm uses constant space (if we don\\'t count the output as extra space) and has a linear runtime.\"\\n\\nSo perhaps they are again, not counting the output?"
                    },
                    {
                        "username": "Primusai",
                        "content": "Python\\'s builtin sort is timsort which works by aggregating increasing and decreasing runs and then merging them. Since the resultant array after squaring all the terms will be first strictly decreasing and then strictly increasing, timsort reverses the strictly decreasing segment and then merges both runs in O(N)."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "How does timsort actually function? Is it an ensemble of sorting methods?"
                    },
                    {
                        "username": "h4rishabh",
                        "content": "Just a simple implementation, using Java 8 Streams\\n\\n` return Arrays.stream(nums).map(x -> x*x).sorted().toArray();`\\n\\n"
                    },
                    {
                        "username": "Devvyn",
                        "content": "this defeats the point of the question. You are not supposed to use built in functions. You are supposed to solve with data structures and algorithms. This question is meant to test two pointers approach. "
                    },
                    {
                        "username": "milileetcode",
                        "content": "![image](https://assets.leetcode.com/users/images/50ed0057-5595-48b7-bfc2-41c60b2f3229_1595280154.602534.png)\\n\\n\\nThis time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\\n\\nDid anyone work out such a solution?\\n"
                    },
                    {
                        "username": "joyrajlongjam",
                        "content": "![image](https://assets.leetcode.com/users/images/415c5cca-7771-4133-98f3-166e95fe6c05_1632028652.9367518.png)\\n"
                    },
                    {
                        "username": "t0rped0",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "Ed_H",
                        "content": "From the given information (provided when the (i) icon next to the problem name is selected):\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nThe given solution, both Java and Python versions, creates a new array.  The solutions in the comments either create a new array, or they do an in-place sort.  The in-place sorts usually use a built-in sort, which is not an O(N) solution, in addition to violating the \"No using built-in sort\" requirement.\\n\\nWe can have O(N) time or use O(1) space.  I don\\'t believe we can have both, and would be very interested in seeing an example to the contrary."
                    },
                    {
                        "username": "anth-volk",
                        "content": "For JS, an actually good programmer would just use the most syntactic, readable elements of the language, right? nums.map, followed by nums.sort. This code would be more readable, more maintainable, and potentially more modular, depending on implementation. And yet here we are, trying to move around array indices to sort this thing *slightly* faster"
                    },
                    {
                        "username": "nilanjan9",
                        "content": "\\'\\'\\'\\nreturn sorted(list(map(lambda x:x*x,nums )))\\n\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1573757,
                "content": [
                    {
                        "username": "robertocannella",
                        "content": "I created this interacitve tool to help me understand visually what is happening behind the code.   It  may help out others as well.  I will continue to build these so if there is interest in a specific algorithm or challenge, just send a note.\\nhttps://robertocannella-f5b4b.web.app/coding-challenges/sorted-squares"
                    },
                    {
                        "username": "zainabsajid",
                        "content": "this helped me alot thanks!\\n"
                    },
                    {
                        "username": "c8763yee",
                        "content": "thanks! but i don\\'t unstand why the 2nd approach using $O(logN)$ time complexity instead of $O(n)$"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You are amazing man!"
                    },
                    {
                        "username": "Itz-Verma",
                        "content": "thanks!"
                    },
                    {
                        "username": "kirsty",
                        "content": "Great animations, thank you! One comment - I believe the 2 ptr approach is actually O(N) runtime, your site says \"Two Pointer: O(N log N) time, O(N) or O(logN) space\".  Can you explain why it would be O(NlogN) runtime, or if it is a typo? "
                    },
                    {
                        "username": "Ayoub-89",
                        "content": "Legend ! thanks.\\n"
                    },
                    {
                        "username": "Damiandd",
                        "content": "it would be nice to slow it down a bit, but still excellent work. great thx!"
                    },
                    {
                        "username": "thapabharat123456",
                        "content": "wow..."
                    },
                    {
                        "username": "garrethue",
                        "content": "Hey, just want to say that I love your animations and the site in general. Keep it up dude!"
                    },
                    {
                        "username": "ijxx",
                        "content": "+1 for your animations."
                    },
                    {
                        "username": "puckhog08",
                        "content": "In the Arrays 101 Explore card leetcode asks you to solve this problem in-place and in O(n) time:\\n\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nHowever, even their own solution doesn\\'t meet these requirements. It doesn\\'t seem possible to stay within O(n) time without using extra space. Has anyone solved it this way?"
                    },
                    {
                        "username": "rokade",
                        "content": "[@blundell337](/blundell337) Asking an inplace solution for this (where we are not allowed to create a new output array) is the same problem as \"merge two sorted arrays in place and in O(n) time\". This can be done, but the techniques are extremely complicated. Here\\'s a white paper showing how it can be done :\\nhttp://akira.ruc.dk/~keld/teaching/algoritmedesign_f04/Artikler/04/Huang88.pdf\\n\\nOn a high level, the alog in the white paper uses parts of one of the array as a buffer to aid in sorting and merging the rest of the two arrays. I dont think one can be expected to give this solution in an interview.\\nHowever, i read it and found it fascinating on the same level that i find Knuth-Prat-Morris algorithm fascinating :)"
                    },
                    {
                        "username": "blundell337",
                        "content": "They mention in the \"Two Pointers\" explanation: \\n\\n\"Like in the previous two examples, this algorithm uses constant space (if we don\\'t count the output as extra space) and has a linear runtime.\"\\n\\nSo perhaps they are again, not counting the output?"
                    },
                    {
                        "username": "Primusai",
                        "content": "Python\\'s builtin sort is timsort which works by aggregating increasing and decreasing runs and then merging them. Since the resultant array after squaring all the terms will be first strictly decreasing and then strictly increasing, timsort reverses the strictly decreasing segment and then merges both runs in O(N)."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "How does timsort actually function? Is it an ensemble of sorting methods?"
                    },
                    {
                        "username": "h4rishabh",
                        "content": "Just a simple implementation, using Java 8 Streams\\n\\n` return Arrays.stream(nums).map(x -> x*x).sorted().toArray();`\\n\\n"
                    },
                    {
                        "username": "Devvyn",
                        "content": "this defeats the point of the question. You are not supposed to use built in functions. You are supposed to solve with data structures and algorithms. This question is meant to test two pointers approach. "
                    },
                    {
                        "username": "milileetcode",
                        "content": "![image](https://assets.leetcode.com/users/images/50ed0057-5595-48b7-bfc2-41c60b2f3229_1595280154.602534.png)\\n\\n\\nThis time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\\n\\nDid anyone work out such a solution?\\n"
                    },
                    {
                        "username": "joyrajlongjam",
                        "content": "![image](https://assets.leetcode.com/users/images/415c5cca-7771-4133-98f3-166e95fe6c05_1632028652.9367518.png)\\n"
                    },
                    {
                        "username": "t0rped0",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "Ed_H",
                        "content": "From the given information (provided when the (i) icon next to the problem name is selected):\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nThe given solution, both Java and Python versions, creates a new array.  The solutions in the comments either create a new array, or they do an in-place sort.  The in-place sorts usually use a built-in sort, which is not an O(N) solution, in addition to violating the \"No using built-in sort\" requirement.\\n\\nWe can have O(N) time or use O(1) space.  I don\\'t believe we can have both, and would be very interested in seeing an example to the contrary."
                    },
                    {
                        "username": "anth-volk",
                        "content": "For JS, an actually good programmer would just use the most syntactic, readable elements of the language, right? nums.map, followed by nums.sort. This code would be more readable, more maintainable, and potentially more modular, depending on implementation. And yet here we are, trying to move around array indices to sort this thing *slightly* faster"
                    },
                    {
                        "username": "nilanjan9",
                        "content": "\\'\\'\\'\\nreturn sorted(list(map(lambda x:x*x,nums )))\\n\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1969402,
                "content": [
                    {
                        "username": "robertocannella",
                        "content": "I created this interacitve tool to help me understand visually what is happening behind the code.   It  may help out others as well.  I will continue to build these so if there is interest in a specific algorithm or challenge, just send a note.\\nhttps://robertocannella-f5b4b.web.app/coding-challenges/sorted-squares"
                    },
                    {
                        "username": "zainabsajid",
                        "content": "this helped me alot thanks!\\n"
                    },
                    {
                        "username": "c8763yee",
                        "content": "thanks! but i don\\'t unstand why the 2nd approach using $O(logN)$ time complexity instead of $O(n)$"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You are amazing man!"
                    },
                    {
                        "username": "Itz-Verma",
                        "content": "thanks!"
                    },
                    {
                        "username": "kirsty",
                        "content": "Great animations, thank you! One comment - I believe the 2 ptr approach is actually O(N) runtime, your site says \"Two Pointer: O(N log N) time, O(N) or O(logN) space\".  Can you explain why it would be O(NlogN) runtime, or if it is a typo? "
                    },
                    {
                        "username": "Ayoub-89",
                        "content": "Legend ! thanks.\\n"
                    },
                    {
                        "username": "Damiandd",
                        "content": "it would be nice to slow it down a bit, but still excellent work. great thx!"
                    },
                    {
                        "username": "thapabharat123456",
                        "content": "wow..."
                    },
                    {
                        "username": "garrethue",
                        "content": "Hey, just want to say that I love your animations and the site in general. Keep it up dude!"
                    },
                    {
                        "username": "ijxx",
                        "content": "+1 for your animations."
                    },
                    {
                        "username": "puckhog08",
                        "content": "In the Arrays 101 Explore card leetcode asks you to solve this problem in-place and in O(n) time:\\n\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nHowever, even their own solution doesn\\'t meet these requirements. It doesn\\'t seem possible to stay within O(n) time without using extra space. Has anyone solved it this way?"
                    },
                    {
                        "username": "rokade",
                        "content": "[@blundell337](/blundell337) Asking an inplace solution for this (where we are not allowed to create a new output array) is the same problem as \"merge two sorted arrays in place and in O(n) time\". This can be done, but the techniques are extremely complicated. Here\\'s a white paper showing how it can be done :\\nhttp://akira.ruc.dk/~keld/teaching/algoritmedesign_f04/Artikler/04/Huang88.pdf\\n\\nOn a high level, the alog in the white paper uses parts of one of the array as a buffer to aid in sorting and merging the rest of the two arrays. I dont think one can be expected to give this solution in an interview.\\nHowever, i read it and found it fascinating on the same level that i find Knuth-Prat-Morris algorithm fascinating :)"
                    },
                    {
                        "username": "blundell337",
                        "content": "They mention in the \"Two Pointers\" explanation: \\n\\n\"Like in the previous two examples, this algorithm uses constant space (if we don\\'t count the output as extra space) and has a linear runtime.\"\\n\\nSo perhaps they are again, not counting the output?"
                    },
                    {
                        "username": "Primusai",
                        "content": "Python\\'s builtin sort is timsort which works by aggregating increasing and decreasing runs and then merging them. Since the resultant array after squaring all the terms will be first strictly decreasing and then strictly increasing, timsort reverses the strictly decreasing segment and then merges both runs in O(N)."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "How does timsort actually function? Is it an ensemble of sorting methods?"
                    },
                    {
                        "username": "h4rishabh",
                        "content": "Just a simple implementation, using Java 8 Streams\\n\\n` return Arrays.stream(nums).map(x -> x*x).sorted().toArray();`\\n\\n"
                    },
                    {
                        "username": "Devvyn",
                        "content": "this defeats the point of the question. You are not supposed to use built in functions. You are supposed to solve with data structures and algorithms. This question is meant to test two pointers approach. "
                    },
                    {
                        "username": "milileetcode",
                        "content": "![image](https://assets.leetcode.com/users/images/50ed0057-5595-48b7-bfc2-41c60b2f3229_1595280154.602534.png)\\n\\n\\nThis time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\\n\\nDid anyone work out such a solution?\\n"
                    },
                    {
                        "username": "joyrajlongjam",
                        "content": "![image](https://assets.leetcode.com/users/images/415c5cca-7771-4133-98f3-166e95fe6c05_1632028652.9367518.png)\\n"
                    },
                    {
                        "username": "t0rped0",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "Ed_H",
                        "content": "From the given information (provided when the (i) icon next to the problem name is selected):\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nThe given solution, both Java and Python versions, creates a new array.  The solutions in the comments either create a new array, or they do an in-place sort.  The in-place sorts usually use a built-in sort, which is not an O(N) solution, in addition to violating the \"No using built-in sort\" requirement.\\n\\nWe can have O(N) time or use O(1) space.  I don\\'t believe we can have both, and would be very interested in seeing an example to the contrary."
                    },
                    {
                        "username": "anth-volk",
                        "content": "For JS, an actually good programmer would just use the most syntactic, readable elements of the language, right? nums.map, followed by nums.sort. This code would be more readable, more maintainable, and potentially more modular, depending on implementation. And yet here we are, trying to move around array indices to sort this thing *slightly* faster"
                    },
                    {
                        "username": "nilanjan9",
                        "content": "\\'\\'\\'\\nreturn sorted(list(map(lambda x:x*x,nums )))\\n\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1575297,
                "content": [
                    {
                        "username": "robertocannella",
                        "content": "I created this interacitve tool to help me understand visually what is happening behind the code.   It  may help out others as well.  I will continue to build these so if there is interest in a specific algorithm or challenge, just send a note.\\nhttps://robertocannella-f5b4b.web.app/coding-challenges/sorted-squares"
                    },
                    {
                        "username": "zainabsajid",
                        "content": "this helped me alot thanks!\\n"
                    },
                    {
                        "username": "c8763yee",
                        "content": "thanks! but i don\\'t unstand why the 2nd approach using $O(logN)$ time complexity instead of $O(n)$"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You are amazing man!"
                    },
                    {
                        "username": "Itz-Verma",
                        "content": "thanks!"
                    },
                    {
                        "username": "kirsty",
                        "content": "Great animations, thank you! One comment - I believe the 2 ptr approach is actually O(N) runtime, your site says \"Two Pointer: O(N log N) time, O(N) or O(logN) space\".  Can you explain why it would be O(NlogN) runtime, or if it is a typo? "
                    },
                    {
                        "username": "Ayoub-89",
                        "content": "Legend ! thanks.\\n"
                    },
                    {
                        "username": "Damiandd",
                        "content": "it would be nice to slow it down a bit, but still excellent work. great thx!"
                    },
                    {
                        "username": "thapabharat123456",
                        "content": "wow..."
                    },
                    {
                        "username": "garrethue",
                        "content": "Hey, just want to say that I love your animations and the site in general. Keep it up dude!"
                    },
                    {
                        "username": "ijxx",
                        "content": "+1 for your animations."
                    },
                    {
                        "username": "puckhog08",
                        "content": "In the Arrays 101 Explore card leetcode asks you to solve this problem in-place and in O(n) time:\\n\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nHowever, even their own solution doesn\\'t meet these requirements. It doesn\\'t seem possible to stay within O(n) time without using extra space. Has anyone solved it this way?"
                    },
                    {
                        "username": "rokade",
                        "content": "[@blundell337](/blundell337) Asking an inplace solution for this (where we are not allowed to create a new output array) is the same problem as \"merge two sorted arrays in place and in O(n) time\". This can be done, but the techniques are extremely complicated. Here\\'s a white paper showing how it can be done :\\nhttp://akira.ruc.dk/~keld/teaching/algoritmedesign_f04/Artikler/04/Huang88.pdf\\n\\nOn a high level, the alog in the white paper uses parts of one of the array as a buffer to aid in sorting and merging the rest of the two arrays. I dont think one can be expected to give this solution in an interview.\\nHowever, i read it and found it fascinating on the same level that i find Knuth-Prat-Morris algorithm fascinating :)"
                    },
                    {
                        "username": "blundell337",
                        "content": "They mention in the \"Two Pointers\" explanation: \\n\\n\"Like in the previous two examples, this algorithm uses constant space (if we don\\'t count the output as extra space) and has a linear runtime.\"\\n\\nSo perhaps they are again, not counting the output?"
                    },
                    {
                        "username": "Primusai",
                        "content": "Python\\'s builtin sort is timsort which works by aggregating increasing and decreasing runs and then merging them. Since the resultant array after squaring all the terms will be first strictly decreasing and then strictly increasing, timsort reverses the strictly decreasing segment and then merges both runs in O(N)."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "How does timsort actually function? Is it an ensemble of sorting methods?"
                    },
                    {
                        "username": "h4rishabh",
                        "content": "Just a simple implementation, using Java 8 Streams\\n\\n` return Arrays.stream(nums).map(x -> x*x).sorted().toArray();`\\n\\n"
                    },
                    {
                        "username": "Devvyn",
                        "content": "this defeats the point of the question. You are not supposed to use built in functions. You are supposed to solve with data structures and algorithms. This question is meant to test two pointers approach. "
                    },
                    {
                        "username": "milileetcode",
                        "content": "![image](https://assets.leetcode.com/users/images/50ed0057-5595-48b7-bfc2-41c60b2f3229_1595280154.602534.png)\\n\\n\\nThis time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\\n\\nDid anyone work out such a solution?\\n"
                    },
                    {
                        "username": "joyrajlongjam",
                        "content": "![image](https://assets.leetcode.com/users/images/415c5cca-7771-4133-98f3-166e95fe6c05_1632028652.9367518.png)\\n"
                    },
                    {
                        "username": "t0rped0",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "Ed_H",
                        "content": "From the given information (provided when the (i) icon next to the problem name is selected):\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nThe given solution, both Java and Python versions, creates a new array.  The solutions in the comments either create a new array, or they do an in-place sort.  The in-place sorts usually use a built-in sort, which is not an O(N) solution, in addition to violating the \"No using built-in sort\" requirement.\\n\\nWe can have O(N) time or use O(1) space.  I don\\'t believe we can have both, and would be very interested in seeing an example to the contrary."
                    },
                    {
                        "username": "anth-volk",
                        "content": "For JS, an actually good programmer would just use the most syntactic, readable elements of the language, right? nums.map, followed by nums.sort. This code would be more readable, more maintainable, and potentially more modular, depending on implementation. And yet here we are, trying to move around array indices to sort this thing *slightly* faster"
                    },
                    {
                        "username": "nilanjan9",
                        "content": "\\'\\'\\'\\nreturn sorted(list(map(lambda x:x*x,nums )))\\n\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1576438,
                "content": [
                    {
                        "username": "robertocannella",
                        "content": "I created this interacitve tool to help me understand visually what is happening behind the code.   It  may help out others as well.  I will continue to build these so if there is interest in a specific algorithm or challenge, just send a note.\\nhttps://robertocannella-f5b4b.web.app/coding-challenges/sorted-squares"
                    },
                    {
                        "username": "zainabsajid",
                        "content": "this helped me alot thanks!\\n"
                    },
                    {
                        "username": "c8763yee",
                        "content": "thanks! but i don\\'t unstand why the 2nd approach using $O(logN)$ time complexity instead of $O(n)$"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You are amazing man!"
                    },
                    {
                        "username": "Itz-Verma",
                        "content": "thanks!"
                    },
                    {
                        "username": "kirsty",
                        "content": "Great animations, thank you! One comment - I believe the 2 ptr approach is actually O(N) runtime, your site says \"Two Pointer: O(N log N) time, O(N) or O(logN) space\".  Can you explain why it would be O(NlogN) runtime, or if it is a typo? "
                    },
                    {
                        "username": "Ayoub-89",
                        "content": "Legend ! thanks.\\n"
                    },
                    {
                        "username": "Damiandd",
                        "content": "it would be nice to slow it down a bit, but still excellent work. great thx!"
                    },
                    {
                        "username": "thapabharat123456",
                        "content": "wow..."
                    },
                    {
                        "username": "garrethue",
                        "content": "Hey, just want to say that I love your animations and the site in general. Keep it up dude!"
                    },
                    {
                        "username": "ijxx",
                        "content": "+1 for your animations."
                    },
                    {
                        "username": "puckhog08",
                        "content": "In the Arrays 101 Explore card leetcode asks you to solve this problem in-place and in O(n) time:\\n\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nHowever, even their own solution doesn\\'t meet these requirements. It doesn\\'t seem possible to stay within O(n) time without using extra space. Has anyone solved it this way?"
                    },
                    {
                        "username": "rokade",
                        "content": "[@blundell337](/blundell337) Asking an inplace solution for this (where we are not allowed to create a new output array) is the same problem as \"merge two sorted arrays in place and in O(n) time\". This can be done, but the techniques are extremely complicated. Here\\'s a white paper showing how it can be done :\\nhttp://akira.ruc.dk/~keld/teaching/algoritmedesign_f04/Artikler/04/Huang88.pdf\\n\\nOn a high level, the alog in the white paper uses parts of one of the array as a buffer to aid in sorting and merging the rest of the two arrays. I dont think one can be expected to give this solution in an interview.\\nHowever, i read it and found it fascinating on the same level that i find Knuth-Prat-Morris algorithm fascinating :)"
                    },
                    {
                        "username": "blundell337",
                        "content": "They mention in the \"Two Pointers\" explanation: \\n\\n\"Like in the previous two examples, this algorithm uses constant space (if we don\\'t count the output as extra space) and has a linear runtime.\"\\n\\nSo perhaps they are again, not counting the output?"
                    },
                    {
                        "username": "Primusai",
                        "content": "Python\\'s builtin sort is timsort which works by aggregating increasing and decreasing runs and then merging them. Since the resultant array after squaring all the terms will be first strictly decreasing and then strictly increasing, timsort reverses the strictly decreasing segment and then merges both runs in O(N)."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "How does timsort actually function? Is it an ensemble of sorting methods?"
                    },
                    {
                        "username": "h4rishabh",
                        "content": "Just a simple implementation, using Java 8 Streams\\n\\n` return Arrays.stream(nums).map(x -> x*x).sorted().toArray();`\\n\\n"
                    },
                    {
                        "username": "Devvyn",
                        "content": "this defeats the point of the question. You are not supposed to use built in functions. You are supposed to solve with data structures and algorithms. This question is meant to test two pointers approach. "
                    },
                    {
                        "username": "milileetcode",
                        "content": "![image](https://assets.leetcode.com/users/images/50ed0057-5595-48b7-bfc2-41c60b2f3229_1595280154.602534.png)\\n\\n\\nThis time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\\n\\nDid anyone work out such a solution?\\n"
                    },
                    {
                        "username": "joyrajlongjam",
                        "content": "![image](https://assets.leetcode.com/users/images/415c5cca-7771-4133-98f3-166e95fe6c05_1632028652.9367518.png)\\n"
                    },
                    {
                        "username": "t0rped0",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "Ed_H",
                        "content": "From the given information (provided when the (i) icon next to the problem name is selected):\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nThe given solution, both Java and Python versions, creates a new array.  The solutions in the comments either create a new array, or they do an in-place sort.  The in-place sorts usually use a built-in sort, which is not an O(N) solution, in addition to violating the \"No using built-in sort\" requirement.\\n\\nWe can have O(N) time or use O(1) space.  I don\\'t believe we can have both, and would be very interested in seeing an example to the contrary."
                    },
                    {
                        "username": "anth-volk",
                        "content": "For JS, an actually good programmer would just use the most syntactic, readable elements of the language, right? nums.map, followed by nums.sort. This code would be more readable, more maintainable, and potentially more modular, depending on implementation. And yet here we are, trying to move around array indices to sort this thing *slightly* faster"
                    },
                    {
                        "username": "nilanjan9",
                        "content": "\\'\\'\\'\\nreturn sorted(list(map(lambda x:x*x,nums )))\\n\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1565880,
                "content": [
                    {
                        "username": "robertocannella",
                        "content": "I created this interacitve tool to help me understand visually what is happening behind the code.   It  may help out others as well.  I will continue to build these so if there is interest in a specific algorithm or challenge, just send a note.\\nhttps://robertocannella-f5b4b.web.app/coding-challenges/sorted-squares"
                    },
                    {
                        "username": "zainabsajid",
                        "content": "this helped me alot thanks!\\n"
                    },
                    {
                        "username": "c8763yee",
                        "content": "thanks! but i don\\'t unstand why the 2nd approach using $O(logN)$ time complexity instead of $O(n)$"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You are amazing man!"
                    },
                    {
                        "username": "Itz-Verma",
                        "content": "thanks!"
                    },
                    {
                        "username": "kirsty",
                        "content": "Great animations, thank you! One comment - I believe the 2 ptr approach is actually O(N) runtime, your site says \"Two Pointer: O(N log N) time, O(N) or O(logN) space\".  Can you explain why it would be O(NlogN) runtime, or if it is a typo? "
                    },
                    {
                        "username": "Ayoub-89",
                        "content": "Legend ! thanks.\\n"
                    },
                    {
                        "username": "Damiandd",
                        "content": "it would be nice to slow it down a bit, but still excellent work. great thx!"
                    },
                    {
                        "username": "thapabharat123456",
                        "content": "wow..."
                    },
                    {
                        "username": "garrethue",
                        "content": "Hey, just want to say that I love your animations and the site in general. Keep it up dude!"
                    },
                    {
                        "username": "ijxx",
                        "content": "+1 for your animations."
                    },
                    {
                        "username": "puckhog08",
                        "content": "In the Arrays 101 Explore card leetcode asks you to solve this problem in-place and in O(n) time:\\n\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nHowever, even their own solution doesn\\'t meet these requirements. It doesn\\'t seem possible to stay within O(n) time without using extra space. Has anyone solved it this way?"
                    },
                    {
                        "username": "rokade",
                        "content": "[@blundell337](/blundell337) Asking an inplace solution for this (where we are not allowed to create a new output array) is the same problem as \"merge two sorted arrays in place and in O(n) time\". This can be done, but the techniques are extremely complicated. Here\\'s a white paper showing how it can be done :\\nhttp://akira.ruc.dk/~keld/teaching/algoritmedesign_f04/Artikler/04/Huang88.pdf\\n\\nOn a high level, the alog in the white paper uses parts of one of the array as a buffer to aid in sorting and merging the rest of the two arrays. I dont think one can be expected to give this solution in an interview.\\nHowever, i read it and found it fascinating on the same level that i find Knuth-Prat-Morris algorithm fascinating :)"
                    },
                    {
                        "username": "blundell337",
                        "content": "They mention in the \"Two Pointers\" explanation: \\n\\n\"Like in the previous two examples, this algorithm uses constant space (if we don\\'t count the output as extra space) and has a linear runtime.\"\\n\\nSo perhaps they are again, not counting the output?"
                    },
                    {
                        "username": "Primusai",
                        "content": "Python\\'s builtin sort is timsort which works by aggregating increasing and decreasing runs and then merging them. Since the resultant array after squaring all the terms will be first strictly decreasing and then strictly increasing, timsort reverses the strictly decreasing segment and then merges both runs in O(N)."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "How does timsort actually function? Is it an ensemble of sorting methods?"
                    },
                    {
                        "username": "h4rishabh",
                        "content": "Just a simple implementation, using Java 8 Streams\\n\\n` return Arrays.stream(nums).map(x -> x*x).sorted().toArray();`\\n\\n"
                    },
                    {
                        "username": "Devvyn",
                        "content": "this defeats the point of the question. You are not supposed to use built in functions. You are supposed to solve with data structures and algorithms. This question is meant to test two pointers approach. "
                    },
                    {
                        "username": "milileetcode",
                        "content": "![image](https://assets.leetcode.com/users/images/50ed0057-5595-48b7-bfc2-41c60b2f3229_1595280154.602534.png)\\n\\n\\nThis time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\\n\\nDid anyone work out such a solution?\\n"
                    },
                    {
                        "username": "joyrajlongjam",
                        "content": "![image](https://assets.leetcode.com/users/images/415c5cca-7771-4133-98f3-166e95fe6c05_1632028652.9367518.png)\\n"
                    },
                    {
                        "username": "t0rped0",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "Ed_H",
                        "content": "From the given information (provided when the (i) icon next to the problem name is selected):\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nThe given solution, both Java and Python versions, creates a new array.  The solutions in the comments either create a new array, or they do an in-place sort.  The in-place sorts usually use a built-in sort, which is not an O(N) solution, in addition to violating the \"No using built-in sort\" requirement.\\n\\nWe can have O(N) time or use O(1) space.  I don\\'t believe we can have both, and would be very interested in seeing an example to the contrary."
                    },
                    {
                        "username": "anth-volk",
                        "content": "For JS, an actually good programmer would just use the most syntactic, readable elements of the language, right? nums.map, followed by nums.sort. This code would be more readable, more maintainable, and potentially more modular, depending on implementation. And yet here we are, trying to move around array indices to sort this thing *slightly* faster"
                    },
                    {
                        "username": "nilanjan9",
                        "content": "\\'\\'\\'\\nreturn sorted(list(map(lambda x:x*x,nums )))\\n\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1564797,
                "content": [
                    {
                        "username": "robertocannella",
                        "content": "I created this interacitve tool to help me understand visually what is happening behind the code.   It  may help out others as well.  I will continue to build these so if there is interest in a specific algorithm or challenge, just send a note.\\nhttps://robertocannella-f5b4b.web.app/coding-challenges/sorted-squares"
                    },
                    {
                        "username": "zainabsajid",
                        "content": "this helped me alot thanks!\\n"
                    },
                    {
                        "username": "c8763yee",
                        "content": "thanks! but i don\\'t unstand why the 2nd approach using $O(logN)$ time complexity instead of $O(n)$"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You are amazing man!"
                    },
                    {
                        "username": "Itz-Verma",
                        "content": "thanks!"
                    },
                    {
                        "username": "kirsty",
                        "content": "Great animations, thank you! One comment - I believe the 2 ptr approach is actually O(N) runtime, your site says \"Two Pointer: O(N log N) time, O(N) or O(logN) space\".  Can you explain why it would be O(NlogN) runtime, or if it is a typo? "
                    },
                    {
                        "username": "Ayoub-89",
                        "content": "Legend ! thanks.\\n"
                    },
                    {
                        "username": "Damiandd",
                        "content": "it would be nice to slow it down a bit, but still excellent work. great thx!"
                    },
                    {
                        "username": "thapabharat123456",
                        "content": "wow..."
                    },
                    {
                        "username": "garrethue",
                        "content": "Hey, just want to say that I love your animations and the site in general. Keep it up dude!"
                    },
                    {
                        "username": "ijxx",
                        "content": "+1 for your animations."
                    },
                    {
                        "username": "puckhog08",
                        "content": "In the Arrays 101 Explore card leetcode asks you to solve this problem in-place and in O(n) time:\\n\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nHowever, even their own solution doesn\\'t meet these requirements. It doesn\\'t seem possible to stay within O(n) time without using extra space. Has anyone solved it this way?"
                    },
                    {
                        "username": "rokade",
                        "content": "[@blundell337](/blundell337) Asking an inplace solution for this (where we are not allowed to create a new output array) is the same problem as \"merge two sorted arrays in place and in O(n) time\". This can be done, but the techniques are extremely complicated. Here\\'s a white paper showing how it can be done :\\nhttp://akira.ruc.dk/~keld/teaching/algoritmedesign_f04/Artikler/04/Huang88.pdf\\n\\nOn a high level, the alog in the white paper uses parts of one of the array as a buffer to aid in sorting and merging the rest of the two arrays. I dont think one can be expected to give this solution in an interview.\\nHowever, i read it and found it fascinating on the same level that i find Knuth-Prat-Morris algorithm fascinating :)"
                    },
                    {
                        "username": "blundell337",
                        "content": "They mention in the \"Two Pointers\" explanation: \\n\\n\"Like in the previous two examples, this algorithm uses constant space (if we don\\'t count the output as extra space) and has a linear runtime.\"\\n\\nSo perhaps they are again, not counting the output?"
                    },
                    {
                        "username": "Primusai",
                        "content": "Python\\'s builtin sort is timsort which works by aggregating increasing and decreasing runs and then merging them. Since the resultant array after squaring all the terms will be first strictly decreasing and then strictly increasing, timsort reverses the strictly decreasing segment and then merges both runs in O(N)."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "How does timsort actually function? Is it an ensemble of sorting methods?"
                    },
                    {
                        "username": "h4rishabh",
                        "content": "Just a simple implementation, using Java 8 Streams\\n\\n` return Arrays.stream(nums).map(x -> x*x).sorted().toArray();`\\n\\n"
                    },
                    {
                        "username": "Devvyn",
                        "content": "this defeats the point of the question. You are not supposed to use built in functions. You are supposed to solve with data structures and algorithms. This question is meant to test two pointers approach. "
                    },
                    {
                        "username": "milileetcode",
                        "content": "![image](https://assets.leetcode.com/users/images/50ed0057-5595-48b7-bfc2-41c60b2f3229_1595280154.602534.png)\\n\\n\\nThis time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\\n\\nDid anyone work out such a solution?\\n"
                    },
                    {
                        "username": "joyrajlongjam",
                        "content": "![image](https://assets.leetcode.com/users/images/415c5cca-7771-4133-98f3-166e95fe6c05_1632028652.9367518.png)\\n"
                    },
                    {
                        "username": "t0rped0",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "Ed_H",
                        "content": "From the given information (provided when the (i) icon next to the problem name is selected):\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nThe given solution, both Java and Python versions, creates a new array.  The solutions in the comments either create a new array, or they do an in-place sort.  The in-place sorts usually use a built-in sort, which is not an O(N) solution, in addition to violating the \"No using built-in sort\" requirement.\\n\\nWe can have O(N) time or use O(1) space.  I don\\'t believe we can have both, and would be very interested in seeing an example to the contrary."
                    },
                    {
                        "username": "anth-volk",
                        "content": "For JS, an actually good programmer would just use the most syntactic, readable elements of the language, right? nums.map, followed by nums.sort. This code would be more readable, more maintainable, and potentially more modular, depending on implementation. And yet here we are, trying to move around array indices to sort this thing *slightly* faster"
                    },
                    {
                        "username": "nilanjan9",
                        "content": "\\'\\'\\'\\nreturn sorted(list(map(lambda x:x*x,nums )))\\n\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1570583,
                "content": [
                    {
                        "username": "robertocannella",
                        "content": "I created this interacitve tool to help me understand visually what is happening behind the code.   It  may help out others as well.  I will continue to build these so if there is interest in a specific algorithm or challenge, just send a note.\\nhttps://robertocannella-f5b4b.web.app/coding-challenges/sorted-squares"
                    },
                    {
                        "username": "zainabsajid",
                        "content": "this helped me alot thanks!\\n"
                    },
                    {
                        "username": "c8763yee",
                        "content": "thanks! but i don\\'t unstand why the 2nd approach using $O(logN)$ time complexity instead of $O(n)$"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You are amazing man!"
                    },
                    {
                        "username": "Itz-Verma",
                        "content": "thanks!"
                    },
                    {
                        "username": "kirsty",
                        "content": "Great animations, thank you! One comment - I believe the 2 ptr approach is actually O(N) runtime, your site says \"Two Pointer: O(N log N) time, O(N) or O(logN) space\".  Can you explain why it would be O(NlogN) runtime, or if it is a typo? "
                    },
                    {
                        "username": "Ayoub-89",
                        "content": "Legend ! thanks.\\n"
                    },
                    {
                        "username": "Damiandd",
                        "content": "it would be nice to slow it down a bit, but still excellent work. great thx!"
                    },
                    {
                        "username": "thapabharat123456",
                        "content": "wow..."
                    },
                    {
                        "username": "garrethue",
                        "content": "Hey, just want to say that I love your animations and the site in general. Keep it up dude!"
                    },
                    {
                        "username": "ijxx",
                        "content": "+1 for your animations."
                    },
                    {
                        "username": "puckhog08",
                        "content": "In the Arrays 101 Explore card leetcode asks you to solve this problem in-place and in O(n) time:\\n\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nHowever, even their own solution doesn\\'t meet these requirements. It doesn\\'t seem possible to stay within O(n) time without using extra space. Has anyone solved it this way?"
                    },
                    {
                        "username": "rokade",
                        "content": "[@blundell337](/blundell337) Asking an inplace solution for this (where we are not allowed to create a new output array) is the same problem as \"merge two sorted arrays in place and in O(n) time\". This can be done, but the techniques are extremely complicated. Here\\'s a white paper showing how it can be done :\\nhttp://akira.ruc.dk/~keld/teaching/algoritmedesign_f04/Artikler/04/Huang88.pdf\\n\\nOn a high level, the alog in the white paper uses parts of one of the array as a buffer to aid in sorting and merging the rest of the two arrays. I dont think one can be expected to give this solution in an interview.\\nHowever, i read it and found it fascinating on the same level that i find Knuth-Prat-Morris algorithm fascinating :)"
                    },
                    {
                        "username": "blundell337",
                        "content": "They mention in the \"Two Pointers\" explanation: \\n\\n\"Like in the previous two examples, this algorithm uses constant space (if we don\\'t count the output as extra space) and has a linear runtime.\"\\n\\nSo perhaps they are again, not counting the output?"
                    },
                    {
                        "username": "Primusai",
                        "content": "Python\\'s builtin sort is timsort which works by aggregating increasing and decreasing runs and then merging them. Since the resultant array after squaring all the terms will be first strictly decreasing and then strictly increasing, timsort reverses the strictly decreasing segment and then merges both runs in O(N)."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "How does timsort actually function? Is it an ensemble of sorting methods?"
                    },
                    {
                        "username": "h4rishabh",
                        "content": "Just a simple implementation, using Java 8 Streams\\n\\n` return Arrays.stream(nums).map(x -> x*x).sorted().toArray();`\\n\\n"
                    },
                    {
                        "username": "Devvyn",
                        "content": "this defeats the point of the question. You are not supposed to use built in functions. You are supposed to solve with data structures and algorithms. This question is meant to test two pointers approach. "
                    },
                    {
                        "username": "milileetcode",
                        "content": "![image](https://assets.leetcode.com/users/images/50ed0057-5595-48b7-bfc2-41c60b2f3229_1595280154.602534.png)\\n\\n\\nThis time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\\n\\nDid anyone work out such a solution?\\n"
                    },
                    {
                        "username": "joyrajlongjam",
                        "content": "![image](https://assets.leetcode.com/users/images/415c5cca-7771-4133-98f3-166e95fe6c05_1632028652.9367518.png)\\n"
                    },
                    {
                        "username": "t0rped0",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "Ed_H",
                        "content": "From the given information (provided when the (i) icon next to the problem name is selected):\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nThe given solution, both Java and Python versions, creates a new array.  The solutions in the comments either create a new array, or they do an in-place sort.  The in-place sorts usually use a built-in sort, which is not an O(N) solution, in addition to violating the \"No using built-in sort\" requirement.\\n\\nWe can have O(N) time or use O(1) space.  I don\\'t believe we can have both, and would be very interested in seeing an example to the contrary."
                    },
                    {
                        "username": "anth-volk",
                        "content": "For JS, an actually good programmer would just use the most syntactic, readable elements of the language, right? nums.map, followed by nums.sort. This code would be more readable, more maintainable, and potentially more modular, depending on implementation. And yet here we are, trying to move around array indices to sort this thing *slightly* faster"
                    },
                    {
                        "username": "nilanjan9",
                        "content": "\\'\\'\\'\\nreturn sorted(list(map(lambda x:x*x,nums )))\\n\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1570076,
                "content": [
                    {
                        "username": "robertocannella",
                        "content": "I created this interacitve tool to help me understand visually what is happening behind the code.   It  may help out others as well.  I will continue to build these so if there is interest in a specific algorithm or challenge, just send a note.\\nhttps://robertocannella-f5b4b.web.app/coding-challenges/sorted-squares"
                    },
                    {
                        "username": "zainabsajid",
                        "content": "this helped me alot thanks!\\n"
                    },
                    {
                        "username": "c8763yee",
                        "content": "thanks! but i don\\'t unstand why the 2nd approach using $O(logN)$ time complexity instead of $O(n)$"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You are amazing man!"
                    },
                    {
                        "username": "Itz-Verma",
                        "content": "thanks!"
                    },
                    {
                        "username": "kirsty",
                        "content": "Great animations, thank you! One comment - I believe the 2 ptr approach is actually O(N) runtime, your site says \"Two Pointer: O(N log N) time, O(N) or O(logN) space\".  Can you explain why it would be O(NlogN) runtime, or if it is a typo? "
                    },
                    {
                        "username": "Ayoub-89",
                        "content": "Legend ! thanks.\\n"
                    },
                    {
                        "username": "Damiandd",
                        "content": "it would be nice to slow it down a bit, but still excellent work. great thx!"
                    },
                    {
                        "username": "thapabharat123456",
                        "content": "wow..."
                    },
                    {
                        "username": "garrethue",
                        "content": "Hey, just want to say that I love your animations and the site in general. Keep it up dude!"
                    },
                    {
                        "username": "ijxx",
                        "content": "+1 for your animations."
                    },
                    {
                        "username": "puckhog08",
                        "content": "In the Arrays 101 Explore card leetcode asks you to solve this problem in-place and in O(n) time:\\n\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nHowever, even their own solution doesn\\'t meet these requirements. It doesn\\'t seem possible to stay within O(n) time without using extra space. Has anyone solved it this way?"
                    },
                    {
                        "username": "rokade",
                        "content": "[@blundell337](/blundell337) Asking an inplace solution for this (where we are not allowed to create a new output array) is the same problem as \"merge two sorted arrays in place and in O(n) time\". This can be done, but the techniques are extremely complicated. Here\\'s a white paper showing how it can be done :\\nhttp://akira.ruc.dk/~keld/teaching/algoritmedesign_f04/Artikler/04/Huang88.pdf\\n\\nOn a high level, the alog in the white paper uses parts of one of the array as a buffer to aid in sorting and merging the rest of the two arrays. I dont think one can be expected to give this solution in an interview.\\nHowever, i read it and found it fascinating on the same level that i find Knuth-Prat-Morris algorithm fascinating :)"
                    },
                    {
                        "username": "blundell337",
                        "content": "They mention in the \"Two Pointers\" explanation: \\n\\n\"Like in the previous two examples, this algorithm uses constant space (if we don\\'t count the output as extra space) and has a linear runtime.\"\\n\\nSo perhaps they are again, not counting the output?"
                    },
                    {
                        "username": "Primusai",
                        "content": "Python\\'s builtin sort is timsort which works by aggregating increasing and decreasing runs and then merging them. Since the resultant array after squaring all the terms will be first strictly decreasing and then strictly increasing, timsort reverses the strictly decreasing segment and then merges both runs in O(N)."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "How does timsort actually function? Is it an ensemble of sorting methods?"
                    },
                    {
                        "username": "h4rishabh",
                        "content": "Just a simple implementation, using Java 8 Streams\\n\\n` return Arrays.stream(nums).map(x -> x*x).sorted().toArray();`\\n\\n"
                    },
                    {
                        "username": "Devvyn",
                        "content": "this defeats the point of the question. You are not supposed to use built in functions. You are supposed to solve with data structures and algorithms. This question is meant to test two pointers approach. "
                    },
                    {
                        "username": "milileetcode",
                        "content": "![image](https://assets.leetcode.com/users/images/50ed0057-5595-48b7-bfc2-41c60b2f3229_1595280154.602534.png)\\n\\n\\nThis time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\\n\\nDid anyone work out such a solution?\\n"
                    },
                    {
                        "username": "joyrajlongjam",
                        "content": "![image](https://assets.leetcode.com/users/images/415c5cca-7771-4133-98f3-166e95fe6c05_1632028652.9367518.png)\\n"
                    },
                    {
                        "username": "t0rped0",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "Ed_H",
                        "content": "From the given information (provided when the (i) icon next to the problem name is selected):\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nThe given solution, both Java and Python versions, creates a new array.  The solutions in the comments either create a new array, or they do an in-place sort.  The in-place sorts usually use a built-in sort, which is not an O(N) solution, in addition to violating the \"No using built-in sort\" requirement.\\n\\nWe can have O(N) time or use O(1) space.  I don\\'t believe we can have both, and would be very interested in seeing an example to the contrary."
                    },
                    {
                        "username": "anth-volk",
                        "content": "For JS, an actually good programmer would just use the most syntactic, readable elements of the language, right? nums.map, followed by nums.sort. This code would be more readable, more maintainable, and potentially more modular, depending on implementation. And yet here we are, trying to move around array indices to sort this thing *slightly* faster"
                    },
                    {
                        "username": "nilanjan9",
                        "content": "\\'\\'\\'\\nreturn sorted(list(map(lambda x:x*x,nums )))\\n\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1575767,
                "content": [
                    {
                        "username": "robertocannella",
                        "content": "I created this interacitve tool to help me understand visually what is happening behind the code.   It  may help out others as well.  I will continue to build these so if there is interest in a specific algorithm or challenge, just send a note.\\nhttps://robertocannella-f5b4b.web.app/coding-challenges/sorted-squares"
                    },
                    {
                        "username": "zainabsajid",
                        "content": "this helped me alot thanks!\\n"
                    },
                    {
                        "username": "c8763yee",
                        "content": "thanks! but i don\\'t unstand why the 2nd approach using $O(logN)$ time complexity instead of $O(n)$"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You are amazing man!"
                    },
                    {
                        "username": "Itz-Verma",
                        "content": "thanks!"
                    },
                    {
                        "username": "kirsty",
                        "content": "Great animations, thank you! One comment - I believe the 2 ptr approach is actually O(N) runtime, your site says \"Two Pointer: O(N log N) time, O(N) or O(logN) space\".  Can you explain why it would be O(NlogN) runtime, or if it is a typo? "
                    },
                    {
                        "username": "Ayoub-89",
                        "content": "Legend ! thanks.\\n"
                    },
                    {
                        "username": "Damiandd",
                        "content": "it would be nice to slow it down a bit, but still excellent work. great thx!"
                    },
                    {
                        "username": "thapabharat123456",
                        "content": "wow..."
                    },
                    {
                        "username": "garrethue",
                        "content": "Hey, just want to say that I love your animations and the site in general. Keep it up dude!"
                    },
                    {
                        "username": "ijxx",
                        "content": "+1 for your animations."
                    },
                    {
                        "username": "puckhog08",
                        "content": "In the Arrays 101 Explore card leetcode asks you to solve this problem in-place and in O(n) time:\\n\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nHowever, even their own solution doesn\\'t meet these requirements. It doesn\\'t seem possible to stay within O(n) time without using extra space. Has anyone solved it this way?"
                    },
                    {
                        "username": "rokade",
                        "content": "[@blundell337](/blundell337) Asking an inplace solution for this (where we are not allowed to create a new output array) is the same problem as \"merge two sorted arrays in place and in O(n) time\". This can be done, but the techniques are extremely complicated. Here\\'s a white paper showing how it can be done :\\nhttp://akira.ruc.dk/~keld/teaching/algoritmedesign_f04/Artikler/04/Huang88.pdf\\n\\nOn a high level, the alog in the white paper uses parts of one of the array as a buffer to aid in sorting and merging the rest of the two arrays. I dont think one can be expected to give this solution in an interview.\\nHowever, i read it and found it fascinating on the same level that i find Knuth-Prat-Morris algorithm fascinating :)"
                    },
                    {
                        "username": "blundell337",
                        "content": "They mention in the \"Two Pointers\" explanation: \\n\\n\"Like in the previous two examples, this algorithm uses constant space (if we don\\'t count the output as extra space) and has a linear runtime.\"\\n\\nSo perhaps they are again, not counting the output?"
                    },
                    {
                        "username": "Primusai",
                        "content": "Python\\'s builtin sort is timsort which works by aggregating increasing and decreasing runs and then merging them. Since the resultant array after squaring all the terms will be first strictly decreasing and then strictly increasing, timsort reverses the strictly decreasing segment and then merges both runs in O(N)."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "How does timsort actually function? Is it an ensemble of sorting methods?"
                    },
                    {
                        "username": "h4rishabh",
                        "content": "Just a simple implementation, using Java 8 Streams\\n\\n` return Arrays.stream(nums).map(x -> x*x).sorted().toArray();`\\n\\n"
                    },
                    {
                        "username": "Devvyn",
                        "content": "this defeats the point of the question. You are not supposed to use built in functions. You are supposed to solve with data structures and algorithms. This question is meant to test two pointers approach. "
                    },
                    {
                        "username": "milileetcode",
                        "content": "![image](https://assets.leetcode.com/users/images/50ed0057-5595-48b7-bfc2-41c60b2f3229_1595280154.602534.png)\\n\\n\\nThis time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\\n\\nDid anyone work out such a solution?\\n"
                    },
                    {
                        "username": "joyrajlongjam",
                        "content": "![image](https://assets.leetcode.com/users/images/415c5cca-7771-4133-98f3-166e95fe6c05_1632028652.9367518.png)\\n"
                    },
                    {
                        "username": "t0rped0",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "Ed_H",
                        "content": "From the given information (provided when the (i) icon next to the problem name is selected):\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nThe given solution, both Java and Python versions, creates a new array.  The solutions in the comments either create a new array, or they do an in-place sort.  The in-place sorts usually use a built-in sort, which is not an O(N) solution, in addition to violating the \"No using built-in sort\" requirement.\\n\\nWe can have O(N) time or use O(1) space.  I don\\'t believe we can have both, and would be very interested in seeing an example to the contrary."
                    },
                    {
                        "username": "anth-volk",
                        "content": "For JS, an actually good programmer would just use the most syntactic, readable elements of the language, right? nums.map, followed by nums.sort. This code would be more readable, more maintainable, and potentially more modular, depending on implementation. And yet here we are, trying to move around array indices to sort this thing *slightly* faster"
                    },
                    {
                        "username": "nilanjan9",
                        "content": "\\'\\'\\'\\nreturn sorted(list(map(lambda x:x*x,nums )))\\n\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1573931,
                "content": [
                    {
                        "username": "robertocannella",
                        "content": "I created this interacitve tool to help me understand visually what is happening behind the code.   It  may help out others as well.  I will continue to build these so if there is interest in a specific algorithm or challenge, just send a note.\\nhttps://robertocannella-f5b4b.web.app/coding-challenges/sorted-squares"
                    },
                    {
                        "username": "zainabsajid",
                        "content": "this helped me alot thanks!\\n"
                    },
                    {
                        "username": "c8763yee",
                        "content": "thanks! but i don\\'t unstand why the 2nd approach using $O(logN)$ time complexity instead of $O(n)$"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You are amazing man!"
                    },
                    {
                        "username": "Itz-Verma",
                        "content": "thanks!"
                    },
                    {
                        "username": "kirsty",
                        "content": "Great animations, thank you! One comment - I believe the 2 ptr approach is actually O(N) runtime, your site says \"Two Pointer: O(N log N) time, O(N) or O(logN) space\".  Can you explain why it would be O(NlogN) runtime, or if it is a typo? "
                    },
                    {
                        "username": "Ayoub-89",
                        "content": "Legend ! thanks.\\n"
                    },
                    {
                        "username": "Damiandd",
                        "content": "it would be nice to slow it down a bit, but still excellent work. great thx!"
                    },
                    {
                        "username": "thapabharat123456",
                        "content": "wow..."
                    },
                    {
                        "username": "garrethue",
                        "content": "Hey, just want to say that I love your animations and the site in general. Keep it up dude!"
                    },
                    {
                        "username": "ijxx",
                        "content": "+1 for your animations."
                    },
                    {
                        "username": "puckhog08",
                        "content": "In the Arrays 101 Explore card leetcode asks you to solve this problem in-place and in O(n) time:\\n\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nHowever, even their own solution doesn\\'t meet these requirements. It doesn\\'t seem possible to stay within O(n) time without using extra space. Has anyone solved it this way?"
                    },
                    {
                        "username": "rokade",
                        "content": "[@blundell337](/blundell337) Asking an inplace solution for this (where we are not allowed to create a new output array) is the same problem as \"merge two sorted arrays in place and in O(n) time\". This can be done, but the techniques are extremely complicated. Here\\'s a white paper showing how it can be done :\\nhttp://akira.ruc.dk/~keld/teaching/algoritmedesign_f04/Artikler/04/Huang88.pdf\\n\\nOn a high level, the alog in the white paper uses parts of one of the array as a buffer to aid in sorting and merging the rest of the two arrays. I dont think one can be expected to give this solution in an interview.\\nHowever, i read it and found it fascinating on the same level that i find Knuth-Prat-Morris algorithm fascinating :)"
                    },
                    {
                        "username": "blundell337",
                        "content": "They mention in the \"Two Pointers\" explanation: \\n\\n\"Like in the previous two examples, this algorithm uses constant space (if we don\\'t count the output as extra space) and has a linear runtime.\"\\n\\nSo perhaps they are again, not counting the output?"
                    },
                    {
                        "username": "Primusai",
                        "content": "Python\\'s builtin sort is timsort which works by aggregating increasing and decreasing runs and then merging them. Since the resultant array after squaring all the terms will be first strictly decreasing and then strictly increasing, timsort reverses the strictly decreasing segment and then merges both runs in O(N)."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "How does timsort actually function? Is it an ensemble of sorting methods?"
                    },
                    {
                        "username": "h4rishabh",
                        "content": "Just a simple implementation, using Java 8 Streams\\n\\n` return Arrays.stream(nums).map(x -> x*x).sorted().toArray();`\\n\\n"
                    },
                    {
                        "username": "Devvyn",
                        "content": "this defeats the point of the question. You are not supposed to use built in functions. You are supposed to solve with data structures and algorithms. This question is meant to test two pointers approach. "
                    },
                    {
                        "username": "milileetcode",
                        "content": "![image](https://assets.leetcode.com/users/images/50ed0057-5595-48b7-bfc2-41c60b2f3229_1595280154.602534.png)\\n\\n\\nThis time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\\n\\nDid anyone work out such a solution?\\n"
                    },
                    {
                        "username": "joyrajlongjam",
                        "content": "![image](https://assets.leetcode.com/users/images/415c5cca-7771-4133-98f3-166e95fe6c05_1632028652.9367518.png)\\n"
                    },
                    {
                        "username": "t0rped0",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "Ed_H",
                        "content": "From the given information (provided when the (i) icon next to the problem name is selected):\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nThe given solution, both Java and Python versions, creates a new array.  The solutions in the comments either create a new array, or they do an in-place sort.  The in-place sorts usually use a built-in sort, which is not an O(N) solution, in addition to violating the \"No using built-in sort\" requirement.\\n\\nWe can have O(N) time or use O(1) space.  I don\\'t believe we can have both, and would be very interested in seeing an example to the contrary."
                    },
                    {
                        "username": "anth-volk",
                        "content": "For JS, an actually good programmer would just use the most syntactic, readable elements of the language, right? nums.map, followed by nums.sort. This code would be more readable, more maintainable, and potentially more modular, depending on implementation. And yet here we are, trying to move around array indices to sort this thing *slightly* faster"
                    },
                    {
                        "username": "nilanjan9",
                        "content": "\\'\\'\\'\\nreturn sorted(list(map(lambda x:x*x,nums )))\\n\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1573757,
                "content": [
                    {
                        "username": "robertocannella",
                        "content": "I created this interacitve tool to help me understand visually what is happening behind the code.   It  may help out others as well.  I will continue to build these so if there is interest in a specific algorithm or challenge, just send a note.\\nhttps://robertocannella-f5b4b.web.app/coding-challenges/sorted-squares"
                    },
                    {
                        "username": "zainabsajid",
                        "content": "this helped me alot thanks!\\n"
                    },
                    {
                        "username": "c8763yee",
                        "content": "thanks! but i don\\'t unstand why the 2nd approach using $O(logN)$ time complexity instead of $O(n)$"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You are amazing man!"
                    },
                    {
                        "username": "Itz-Verma",
                        "content": "thanks!"
                    },
                    {
                        "username": "kirsty",
                        "content": "Great animations, thank you! One comment - I believe the 2 ptr approach is actually O(N) runtime, your site says \"Two Pointer: O(N log N) time, O(N) or O(logN) space\".  Can you explain why it would be O(NlogN) runtime, or if it is a typo? "
                    },
                    {
                        "username": "Ayoub-89",
                        "content": "Legend ! thanks.\\n"
                    },
                    {
                        "username": "Damiandd",
                        "content": "it would be nice to slow it down a bit, but still excellent work. great thx!"
                    },
                    {
                        "username": "thapabharat123456",
                        "content": "wow..."
                    },
                    {
                        "username": "garrethue",
                        "content": "Hey, just want to say that I love your animations and the site in general. Keep it up dude!"
                    },
                    {
                        "username": "ijxx",
                        "content": "+1 for your animations."
                    },
                    {
                        "username": "puckhog08",
                        "content": "In the Arrays 101 Explore card leetcode asks you to solve this problem in-place and in O(n) time:\\n\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nHowever, even their own solution doesn\\'t meet these requirements. It doesn\\'t seem possible to stay within O(n) time without using extra space. Has anyone solved it this way?"
                    },
                    {
                        "username": "rokade",
                        "content": "[@blundell337](/blundell337) Asking an inplace solution for this (where we are not allowed to create a new output array) is the same problem as \"merge two sorted arrays in place and in O(n) time\". This can be done, but the techniques are extremely complicated. Here\\'s a white paper showing how it can be done :\\nhttp://akira.ruc.dk/~keld/teaching/algoritmedesign_f04/Artikler/04/Huang88.pdf\\n\\nOn a high level, the alog in the white paper uses parts of one of the array as a buffer to aid in sorting and merging the rest of the two arrays. I dont think one can be expected to give this solution in an interview.\\nHowever, i read it and found it fascinating on the same level that i find Knuth-Prat-Morris algorithm fascinating :)"
                    },
                    {
                        "username": "blundell337",
                        "content": "They mention in the \"Two Pointers\" explanation: \\n\\n\"Like in the previous two examples, this algorithm uses constant space (if we don\\'t count the output as extra space) and has a linear runtime.\"\\n\\nSo perhaps they are again, not counting the output?"
                    },
                    {
                        "username": "Primusai",
                        "content": "Python\\'s builtin sort is timsort which works by aggregating increasing and decreasing runs and then merging them. Since the resultant array after squaring all the terms will be first strictly decreasing and then strictly increasing, timsort reverses the strictly decreasing segment and then merges both runs in O(N)."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "How does timsort actually function? Is it an ensemble of sorting methods?"
                    },
                    {
                        "username": "h4rishabh",
                        "content": "Just a simple implementation, using Java 8 Streams\\n\\n` return Arrays.stream(nums).map(x -> x*x).sorted().toArray();`\\n\\n"
                    },
                    {
                        "username": "Devvyn",
                        "content": "this defeats the point of the question. You are not supposed to use built in functions. You are supposed to solve with data structures and algorithms. This question is meant to test two pointers approach. "
                    },
                    {
                        "username": "milileetcode",
                        "content": "![image](https://assets.leetcode.com/users/images/50ed0057-5595-48b7-bfc2-41c60b2f3229_1595280154.602534.png)\\n\\n\\nThis time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\\n\\nDid anyone work out such a solution?\\n"
                    },
                    {
                        "username": "joyrajlongjam",
                        "content": "![image](https://assets.leetcode.com/users/images/415c5cca-7771-4133-98f3-166e95fe6c05_1632028652.9367518.png)\\n"
                    },
                    {
                        "username": "t0rped0",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "Ed_H",
                        "content": "From the given information (provided when the (i) icon next to the problem name is selected):\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nThe given solution, both Java and Python versions, creates a new array.  The solutions in the comments either create a new array, or they do an in-place sort.  The in-place sorts usually use a built-in sort, which is not an O(N) solution, in addition to violating the \"No using built-in sort\" requirement.\\n\\nWe can have O(N) time or use O(1) space.  I don\\'t believe we can have both, and would be very interested in seeing an example to the contrary."
                    },
                    {
                        "username": "anth-volk",
                        "content": "For JS, an actually good programmer would just use the most syntactic, readable elements of the language, right? nums.map, followed by nums.sort. This code would be more readable, more maintainable, and potentially more modular, depending on implementation. And yet here we are, trying to move around array indices to sort this thing *slightly* faster"
                    },
                    {
                        "username": "nilanjan9",
                        "content": "\\'\\'\\'\\nreturn sorted(list(map(lambda x:x*x,nums )))\\n\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1969402,
                "content": [
                    {
                        "username": "robertocannella",
                        "content": "I created this interacitve tool to help me understand visually what is happening behind the code.   It  may help out others as well.  I will continue to build these so if there is interest in a specific algorithm or challenge, just send a note.\\nhttps://robertocannella-f5b4b.web.app/coding-challenges/sorted-squares"
                    },
                    {
                        "username": "zainabsajid",
                        "content": "this helped me alot thanks!\\n"
                    },
                    {
                        "username": "c8763yee",
                        "content": "thanks! but i don\\'t unstand why the 2nd approach using $O(logN)$ time complexity instead of $O(n)$"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You are amazing man!"
                    },
                    {
                        "username": "Itz-Verma",
                        "content": "thanks!"
                    },
                    {
                        "username": "kirsty",
                        "content": "Great animations, thank you! One comment - I believe the 2 ptr approach is actually O(N) runtime, your site says \"Two Pointer: O(N log N) time, O(N) or O(logN) space\".  Can you explain why it would be O(NlogN) runtime, or if it is a typo? "
                    },
                    {
                        "username": "Ayoub-89",
                        "content": "Legend ! thanks.\\n"
                    },
                    {
                        "username": "Damiandd",
                        "content": "it would be nice to slow it down a bit, but still excellent work. great thx!"
                    },
                    {
                        "username": "thapabharat123456",
                        "content": "wow..."
                    },
                    {
                        "username": "garrethue",
                        "content": "Hey, just want to say that I love your animations and the site in general. Keep it up dude!"
                    },
                    {
                        "username": "ijxx",
                        "content": "+1 for your animations."
                    },
                    {
                        "username": "puckhog08",
                        "content": "In the Arrays 101 Explore card leetcode asks you to solve this problem in-place and in O(n) time:\\n\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nHowever, even their own solution doesn\\'t meet these requirements. It doesn\\'t seem possible to stay within O(n) time without using extra space. Has anyone solved it this way?"
                    },
                    {
                        "username": "rokade",
                        "content": "[@blundell337](/blundell337) Asking an inplace solution for this (where we are not allowed to create a new output array) is the same problem as \"merge two sorted arrays in place and in O(n) time\". This can be done, but the techniques are extremely complicated. Here\\'s a white paper showing how it can be done :\\nhttp://akira.ruc.dk/~keld/teaching/algoritmedesign_f04/Artikler/04/Huang88.pdf\\n\\nOn a high level, the alog in the white paper uses parts of one of the array as a buffer to aid in sorting and merging the rest of the two arrays. I dont think one can be expected to give this solution in an interview.\\nHowever, i read it and found it fascinating on the same level that i find Knuth-Prat-Morris algorithm fascinating :)"
                    },
                    {
                        "username": "blundell337",
                        "content": "They mention in the \"Two Pointers\" explanation: \\n\\n\"Like in the previous two examples, this algorithm uses constant space (if we don\\'t count the output as extra space) and has a linear runtime.\"\\n\\nSo perhaps they are again, not counting the output?"
                    },
                    {
                        "username": "Primusai",
                        "content": "Python\\'s builtin sort is timsort which works by aggregating increasing and decreasing runs and then merging them. Since the resultant array after squaring all the terms will be first strictly decreasing and then strictly increasing, timsort reverses the strictly decreasing segment and then merges both runs in O(N)."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "How does timsort actually function? Is it an ensemble of sorting methods?"
                    },
                    {
                        "username": "h4rishabh",
                        "content": "Just a simple implementation, using Java 8 Streams\\n\\n` return Arrays.stream(nums).map(x -> x*x).sorted().toArray();`\\n\\n"
                    },
                    {
                        "username": "Devvyn",
                        "content": "this defeats the point of the question. You are not supposed to use built in functions. You are supposed to solve with data structures and algorithms. This question is meant to test two pointers approach. "
                    },
                    {
                        "username": "milileetcode",
                        "content": "![image](https://assets.leetcode.com/users/images/50ed0057-5595-48b7-bfc2-41c60b2f3229_1595280154.602534.png)\\n\\n\\nThis time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\\n\\nDid anyone work out such a solution?\\n"
                    },
                    {
                        "username": "joyrajlongjam",
                        "content": "![image](https://assets.leetcode.com/users/images/415c5cca-7771-4133-98f3-166e95fe6c05_1632028652.9367518.png)\\n"
                    },
                    {
                        "username": "t0rped0",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "Ed_H",
                        "content": "From the given information (provided when the (i) icon next to the problem name is selected):\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nThe given solution, both Java and Python versions, creates a new array.  The solutions in the comments either create a new array, or they do an in-place sort.  The in-place sorts usually use a built-in sort, which is not an O(N) solution, in addition to violating the \"No using built-in sort\" requirement.\\n\\nWe can have O(N) time or use O(1) space.  I don\\'t believe we can have both, and would be very interested in seeing an example to the contrary."
                    },
                    {
                        "username": "anth-volk",
                        "content": "For JS, an actually good programmer would just use the most syntactic, readable elements of the language, right? nums.map, followed by nums.sort. This code would be more readable, more maintainable, and potentially more modular, depending on implementation. And yet here we are, trying to move around array indices to sort this thing *slightly* faster"
                    },
                    {
                        "username": "nilanjan9",
                        "content": "\\'\\'\\'\\nreturn sorted(list(map(lambda x:x*x,nums )))\\n\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1575297,
                "content": [
                    {
                        "username": "robertocannella",
                        "content": "I created this interacitve tool to help me understand visually what is happening behind the code.   It  may help out others as well.  I will continue to build these so if there is interest in a specific algorithm or challenge, just send a note.\\nhttps://robertocannella-f5b4b.web.app/coding-challenges/sorted-squares"
                    },
                    {
                        "username": "zainabsajid",
                        "content": "this helped me alot thanks!\\n"
                    },
                    {
                        "username": "c8763yee",
                        "content": "thanks! but i don\\'t unstand why the 2nd approach using $O(logN)$ time complexity instead of $O(n)$"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You are amazing man!"
                    },
                    {
                        "username": "Itz-Verma",
                        "content": "thanks!"
                    },
                    {
                        "username": "kirsty",
                        "content": "Great animations, thank you! One comment - I believe the 2 ptr approach is actually O(N) runtime, your site says \"Two Pointer: O(N log N) time, O(N) or O(logN) space\".  Can you explain why it would be O(NlogN) runtime, or if it is a typo? "
                    },
                    {
                        "username": "Ayoub-89",
                        "content": "Legend ! thanks.\\n"
                    },
                    {
                        "username": "Damiandd",
                        "content": "it would be nice to slow it down a bit, but still excellent work. great thx!"
                    },
                    {
                        "username": "thapabharat123456",
                        "content": "wow..."
                    },
                    {
                        "username": "garrethue",
                        "content": "Hey, just want to say that I love your animations and the site in general. Keep it up dude!"
                    },
                    {
                        "username": "ijxx",
                        "content": "+1 for your animations."
                    },
                    {
                        "username": "puckhog08",
                        "content": "In the Arrays 101 Explore card leetcode asks you to solve this problem in-place and in O(n) time:\\n\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nHowever, even their own solution doesn\\'t meet these requirements. It doesn\\'t seem possible to stay within O(n) time without using extra space. Has anyone solved it this way?"
                    },
                    {
                        "username": "rokade",
                        "content": "[@blundell337](/blundell337) Asking an inplace solution for this (where we are not allowed to create a new output array) is the same problem as \"merge two sorted arrays in place and in O(n) time\". This can be done, but the techniques are extremely complicated. Here\\'s a white paper showing how it can be done :\\nhttp://akira.ruc.dk/~keld/teaching/algoritmedesign_f04/Artikler/04/Huang88.pdf\\n\\nOn a high level, the alog in the white paper uses parts of one of the array as a buffer to aid in sorting and merging the rest of the two arrays. I dont think one can be expected to give this solution in an interview.\\nHowever, i read it and found it fascinating on the same level that i find Knuth-Prat-Morris algorithm fascinating :)"
                    },
                    {
                        "username": "blundell337",
                        "content": "They mention in the \"Two Pointers\" explanation: \\n\\n\"Like in the previous two examples, this algorithm uses constant space (if we don\\'t count the output as extra space) and has a linear runtime.\"\\n\\nSo perhaps they are again, not counting the output?"
                    },
                    {
                        "username": "Primusai",
                        "content": "Python\\'s builtin sort is timsort which works by aggregating increasing and decreasing runs and then merging them. Since the resultant array after squaring all the terms will be first strictly decreasing and then strictly increasing, timsort reverses the strictly decreasing segment and then merges both runs in O(N)."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "How does timsort actually function? Is it an ensemble of sorting methods?"
                    },
                    {
                        "username": "h4rishabh",
                        "content": "Just a simple implementation, using Java 8 Streams\\n\\n` return Arrays.stream(nums).map(x -> x*x).sorted().toArray();`\\n\\n"
                    },
                    {
                        "username": "Devvyn",
                        "content": "this defeats the point of the question. You are not supposed to use built in functions. You are supposed to solve with data structures and algorithms. This question is meant to test two pointers approach. "
                    },
                    {
                        "username": "milileetcode",
                        "content": "![image](https://assets.leetcode.com/users/images/50ed0057-5595-48b7-bfc2-41c60b2f3229_1595280154.602534.png)\\n\\n\\nThis time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\\n\\nDid anyone work out such a solution?\\n"
                    },
                    {
                        "username": "joyrajlongjam",
                        "content": "![image](https://assets.leetcode.com/users/images/415c5cca-7771-4133-98f3-166e95fe6c05_1632028652.9367518.png)\\n"
                    },
                    {
                        "username": "t0rped0",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "Ed_H",
                        "content": "From the given information (provided when the (i) icon next to the problem name is selected):\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nThe given solution, both Java and Python versions, creates a new array.  The solutions in the comments either create a new array, or they do an in-place sort.  The in-place sorts usually use a built-in sort, which is not an O(N) solution, in addition to violating the \"No using built-in sort\" requirement.\\n\\nWe can have O(N) time or use O(1) space.  I don\\'t believe we can have both, and would be very interested in seeing an example to the contrary."
                    },
                    {
                        "username": "anth-volk",
                        "content": "For JS, an actually good programmer would just use the most syntactic, readable elements of the language, right? nums.map, followed by nums.sort. This code would be more readable, more maintainable, and potentially more modular, depending on implementation. And yet here we are, trying to move around array indices to sort this thing *slightly* faster"
                    },
                    {
                        "username": "nilanjan9",
                        "content": "\\'\\'\\'\\nreturn sorted(list(map(lambda x:x*x,nums )))\\n\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1573930,
                "content": [
                    {
                        "username": "nikash",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "satwik95",
                        "content": "\\tvar sortedSquares = function(A) {\\n\\t\\treturn A.map(function(item){return item*item;}).sort(function(a, b){return a-b;});\\n\\t};"
                    },
                    {
                        "username": "dmc8686",
                        "content": "O(nlogn) seems to be the faster one than O(n). Testcases aren\\'t big enough I think."
                    },
                    {
                        "username": "talk2ritaj",
                        "content": "for i in range(len(nums)):\\n\\t nums[i]=nums[i]**2\\nreturn sorted(nums)"
                    },
                    {
                        "username": "_Ivan_Vigorito_",
                        "content": "If you like it, Upvote ;) \\n\\n\\n#### Solution\\nreturn sorted(map(lambda x: (x)**2, nums))"
                    },
                    {
                        "username": "zxak",
                        "content": "solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/squares-of-sorted-array.html"
                    },
                    {
                        "username": "kunalchitkara",
                        "content": "`var sortedSquares = A => A.sort((x,y) => Math.abs(x) - Math.abs(y)).map(x => x*x);`"
                    },
                    {
                        "username": "tushartiwari25",
                        "content": "Can anyone explain how a two pointer solution in one of binary search...."
                    },
                    {
                        "username": "__buruno",
                        "content": "it maybe a very dumb question but i\\'ll ask anyway... can anybody explain to me why do i need to do *returnsize = numsSize?"
                    },
                    {
                        "username": "tuhinssam",
                        "content": "after putting this constraint: \"Squaring each element and sorting the new array is very trivial, could you find an O(n) solution using a different approach\", it doesn\\'t remain easy anymore"
                    }
                ]
            },
            {
                "id": 1572727,
                "content": [
                    {
                        "username": "nikash",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "satwik95",
                        "content": "\\tvar sortedSquares = function(A) {\\n\\t\\treturn A.map(function(item){return item*item;}).sort(function(a, b){return a-b;});\\n\\t};"
                    },
                    {
                        "username": "dmc8686",
                        "content": "O(nlogn) seems to be the faster one than O(n). Testcases aren\\'t big enough I think."
                    },
                    {
                        "username": "talk2ritaj",
                        "content": "for i in range(len(nums)):\\n\\t nums[i]=nums[i]**2\\nreturn sorted(nums)"
                    },
                    {
                        "username": "_Ivan_Vigorito_",
                        "content": "If you like it, Upvote ;) \\n\\n\\n#### Solution\\nreturn sorted(map(lambda x: (x)**2, nums))"
                    },
                    {
                        "username": "zxak",
                        "content": "solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/squares-of-sorted-array.html"
                    },
                    {
                        "username": "kunalchitkara",
                        "content": "`var sortedSquares = A => A.sort((x,y) => Math.abs(x) - Math.abs(y)).map(x => x*x);`"
                    },
                    {
                        "username": "tushartiwari25",
                        "content": "Can anyone explain how a two pointer solution in one of binary search...."
                    },
                    {
                        "username": "__buruno",
                        "content": "it maybe a very dumb question but i\\'ll ask anyway... can anybody explain to me why do i need to do *returnsize = numsSize?"
                    },
                    {
                        "username": "tuhinssam",
                        "content": "after putting this constraint: \"Squaring each element and sorting the new array is very trivial, could you find an O(n) solution using a different approach\", it doesn\\'t remain easy anymore"
                    }
                ]
            },
            {
                "id": 1572541,
                "content": [
                    {
                        "username": "nikash",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "satwik95",
                        "content": "\\tvar sortedSquares = function(A) {\\n\\t\\treturn A.map(function(item){return item*item;}).sort(function(a, b){return a-b;});\\n\\t};"
                    },
                    {
                        "username": "dmc8686",
                        "content": "O(nlogn) seems to be the faster one than O(n). Testcases aren\\'t big enough I think."
                    },
                    {
                        "username": "talk2ritaj",
                        "content": "for i in range(len(nums)):\\n\\t nums[i]=nums[i]**2\\nreturn sorted(nums)"
                    },
                    {
                        "username": "_Ivan_Vigorito_",
                        "content": "If you like it, Upvote ;) \\n\\n\\n#### Solution\\nreturn sorted(map(lambda x: (x)**2, nums))"
                    },
                    {
                        "username": "zxak",
                        "content": "solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/squares-of-sorted-array.html"
                    },
                    {
                        "username": "kunalchitkara",
                        "content": "`var sortedSquares = A => A.sort((x,y) => Math.abs(x) - Math.abs(y)).map(x => x*x);`"
                    },
                    {
                        "username": "tushartiwari25",
                        "content": "Can anyone explain how a two pointer solution in one of binary search...."
                    },
                    {
                        "username": "__buruno",
                        "content": "it maybe a very dumb question but i\\'ll ask anyway... can anybody explain to me why do i need to do *returnsize = numsSize?"
                    },
                    {
                        "username": "tuhinssam",
                        "content": "after putting this constraint: \"Squaring each element and sorting the new array is very trivial, could you find an O(n) solution using a different approach\", it doesn\\'t remain easy anymore"
                    }
                ]
            },
            {
                "id": 1576328,
                "content": [
                    {
                        "username": "nikash",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "satwik95",
                        "content": "\\tvar sortedSquares = function(A) {\\n\\t\\treturn A.map(function(item){return item*item;}).sort(function(a, b){return a-b;});\\n\\t};"
                    },
                    {
                        "username": "dmc8686",
                        "content": "O(nlogn) seems to be the faster one than O(n). Testcases aren\\'t big enough I think."
                    },
                    {
                        "username": "talk2ritaj",
                        "content": "for i in range(len(nums)):\\n\\t nums[i]=nums[i]**2\\nreturn sorted(nums)"
                    },
                    {
                        "username": "_Ivan_Vigorito_",
                        "content": "If you like it, Upvote ;) \\n\\n\\n#### Solution\\nreturn sorted(map(lambda x: (x)**2, nums))"
                    },
                    {
                        "username": "zxak",
                        "content": "solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/squares-of-sorted-array.html"
                    },
                    {
                        "username": "kunalchitkara",
                        "content": "`var sortedSquares = A => A.sort((x,y) => Math.abs(x) - Math.abs(y)).map(x => x*x);`"
                    },
                    {
                        "username": "tushartiwari25",
                        "content": "Can anyone explain how a two pointer solution in one of binary search...."
                    },
                    {
                        "username": "__buruno",
                        "content": "it maybe a very dumb question but i\\'ll ask anyway... can anybody explain to me why do i need to do *returnsize = numsSize?"
                    },
                    {
                        "username": "tuhinssam",
                        "content": "after putting this constraint: \"Squaring each element and sorting the new array is very trivial, could you find an O(n) solution using a different approach\", it doesn\\'t remain easy anymore"
                    }
                ]
            },
            {
                "id": 1576715,
                "content": [
                    {
                        "username": "nikash",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "satwik95",
                        "content": "\\tvar sortedSquares = function(A) {\\n\\t\\treturn A.map(function(item){return item*item;}).sort(function(a, b){return a-b;});\\n\\t};"
                    },
                    {
                        "username": "dmc8686",
                        "content": "O(nlogn) seems to be the faster one than O(n). Testcases aren\\'t big enough I think."
                    },
                    {
                        "username": "talk2ritaj",
                        "content": "for i in range(len(nums)):\\n\\t nums[i]=nums[i]**2\\nreturn sorted(nums)"
                    },
                    {
                        "username": "_Ivan_Vigorito_",
                        "content": "If you like it, Upvote ;) \\n\\n\\n#### Solution\\nreturn sorted(map(lambda x: (x)**2, nums))"
                    },
                    {
                        "username": "zxak",
                        "content": "solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/squares-of-sorted-array.html"
                    },
                    {
                        "username": "kunalchitkara",
                        "content": "`var sortedSquares = A => A.sort((x,y) => Math.abs(x) - Math.abs(y)).map(x => x*x);`"
                    },
                    {
                        "username": "tushartiwari25",
                        "content": "Can anyone explain how a two pointer solution in one of binary search...."
                    },
                    {
                        "username": "__buruno",
                        "content": "it maybe a very dumb question but i\\'ll ask anyway... can anybody explain to me why do i need to do *returnsize = numsSize?"
                    },
                    {
                        "username": "tuhinssam",
                        "content": "after putting this constraint: \"Squaring each element and sorting the new array is very trivial, could you find an O(n) solution using a different approach\", it doesn\\'t remain easy anymore"
                    }
                ]
            },
            {
                "id": 1574693,
                "content": [
                    {
                        "username": "nikash",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "satwik95",
                        "content": "\\tvar sortedSquares = function(A) {\\n\\t\\treturn A.map(function(item){return item*item;}).sort(function(a, b){return a-b;});\\n\\t};"
                    },
                    {
                        "username": "dmc8686",
                        "content": "O(nlogn) seems to be the faster one than O(n). Testcases aren\\'t big enough I think."
                    },
                    {
                        "username": "talk2ritaj",
                        "content": "for i in range(len(nums)):\\n\\t nums[i]=nums[i]**2\\nreturn sorted(nums)"
                    },
                    {
                        "username": "_Ivan_Vigorito_",
                        "content": "If you like it, Upvote ;) \\n\\n\\n#### Solution\\nreturn sorted(map(lambda x: (x)**2, nums))"
                    },
                    {
                        "username": "zxak",
                        "content": "solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/squares-of-sorted-array.html"
                    },
                    {
                        "username": "kunalchitkara",
                        "content": "`var sortedSquares = A => A.sort((x,y) => Math.abs(x) - Math.abs(y)).map(x => x*x);`"
                    },
                    {
                        "username": "tushartiwari25",
                        "content": "Can anyone explain how a two pointer solution in one of binary search...."
                    },
                    {
                        "username": "__buruno",
                        "content": "it maybe a very dumb question but i\\'ll ask anyway... can anybody explain to me why do i need to do *returnsize = numsSize?"
                    },
                    {
                        "username": "tuhinssam",
                        "content": "after putting this constraint: \"Squaring each element and sorting the new array is very trivial, could you find an O(n) solution using a different approach\", it doesn\\'t remain easy anymore"
                    }
                ]
            },
            {
                "id": 1573915,
                "content": [
                    {
                        "username": "nikash",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "satwik95",
                        "content": "\\tvar sortedSquares = function(A) {\\n\\t\\treturn A.map(function(item){return item*item;}).sort(function(a, b){return a-b;});\\n\\t};"
                    },
                    {
                        "username": "dmc8686",
                        "content": "O(nlogn) seems to be the faster one than O(n). Testcases aren\\'t big enough I think."
                    },
                    {
                        "username": "talk2ritaj",
                        "content": "for i in range(len(nums)):\\n\\t nums[i]=nums[i]**2\\nreturn sorted(nums)"
                    },
                    {
                        "username": "_Ivan_Vigorito_",
                        "content": "If you like it, Upvote ;) \\n\\n\\n#### Solution\\nreturn sorted(map(lambda x: (x)**2, nums))"
                    },
                    {
                        "username": "zxak",
                        "content": "solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/squares-of-sorted-array.html"
                    },
                    {
                        "username": "kunalchitkara",
                        "content": "`var sortedSquares = A => A.sort((x,y) => Math.abs(x) - Math.abs(y)).map(x => x*x);`"
                    },
                    {
                        "username": "tushartiwari25",
                        "content": "Can anyone explain how a two pointer solution in one of binary search...."
                    },
                    {
                        "username": "__buruno",
                        "content": "it maybe a very dumb question but i\\'ll ask anyway... can anybody explain to me why do i need to do *returnsize = numsSize?"
                    },
                    {
                        "username": "tuhinssam",
                        "content": "after putting this constraint: \"Squaring each element and sorting the new array is very trivial, could you find an O(n) solution using a different approach\", it doesn\\'t remain easy anymore"
                    }
                ]
            },
            {
                "id": 2073126,
                "content": [
                    {
                        "username": "nikash",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "satwik95",
                        "content": "\\tvar sortedSquares = function(A) {\\n\\t\\treturn A.map(function(item){return item*item;}).sort(function(a, b){return a-b;});\\n\\t};"
                    },
                    {
                        "username": "dmc8686",
                        "content": "O(nlogn) seems to be the faster one than O(n). Testcases aren\\'t big enough I think."
                    },
                    {
                        "username": "talk2ritaj",
                        "content": "for i in range(len(nums)):\\n\\t nums[i]=nums[i]**2\\nreturn sorted(nums)"
                    },
                    {
                        "username": "_Ivan_Vigorito_",
                        "content": "If you like it, Upvote ;) \\n\\n\\n#### Solution\\nreturn sorted(map(lambda x: (x)**2, nums))"
                    },
                    {
                        "username": "zxak",
                        "content": "solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/squares-of-sorted-array.html"
                    },
                    {
                        "username": "kunalchitkara",
                        "content": "`var sortedSquares = A => A.sort((x,y) => Math.abs(x) - Math.abs(y)).map(x => x*x);`"
                    },
                    {
                        "username": "tushartiwari25",
                        "content": "Can anyone explain how a two pointer solution in one of binary search...."
                    },
                    {
                        "username": "__buruno",
                        "content": "it maybe a very dumb question but i\\'ll ask anyway... can anybody explain to me why do i need to do *returnsize = numsSize?"
                    },
                    {
                        "username": "tuhinssam",
                        "content": "after putting this constraint: \"Squaring each element and sorting the new array is very trivial, could you find an O(n) solution using a different approach\", it doesn\\'t remain easy anymore"
                    }
                ]
            },
            {
                "id": 1929284,
                "content": [
                    {
                        "username": "nikash",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "satwik95",
                        "content": "\\tvar sortedSquares = function(A) {\\n\\t\\treturn A.map(function(item){return item*item;}).sort(function(a, b){return a-b;});\\n\\t};"
                    },
                    {
                        "username": "dmc8686",
                        "content": "O(nlogn) seems to be the faster one than O(n). Testcases aren\\'t big enough I think."
                    },
                    {
                        "username": "talk2ritaj",
                        "content": "for i in range(len(nums)):\\n\\t nums[i]=nums[i]**2\\nreturn sorted(nums)"
                    },
                    {
                        "username": "_Ivan_Vigorito_",
                        "content": "If you like it, Upvote ;) \\n\\n\\n#### Solution\\nreturn sorted(map(lambda x: (x)**2, nums))"
                    },
                    {
                        "username": "zxak",
                        "content": "solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/squares-of-sorted-array.html"
                    },
                    {
                        "username": "kunalchitkara",
                        "content": "`var sortedSquares = A => A.sort((x,y) => Math.abs(x) - Math.abs(y)).map(x => x*x);`"
                    },
                    {
                        "username": "tushartiwari25",
                        "content": "Can anyone explain how a two pointer solution in one of binary search...."
                    },
                    {
                        "username": "__buruno",
                        "content": "it maybe a very dumb question but i\\'ll ask anyway... can anybody explain to me why do i need to do *returnsize = numsSize?"
                    },
                    {
                        "username": "tuhinssam",
                        "content": "after putting this constraint: \"Squaring each element and sorting the new array is very trivial, could you find an O(n) solution using a different approach\", it doesn\\'t remain easy anymore"
                    }
                ]
            },
            {
                "id": 1915592,
                "content": [
                    {
                        "username": "nikash",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "satwik95",
                        "content": "\\tvar sortedSquares = function(A) {\\n\\t\\treturn A.map(function(item){return item*item;}).sort(function(a, b){return a-b;});\\n\\t};"
                    },
                    {
                        "username": "dmc8686",
                        "content": "O(nlogn) seems to be the faster one than O(n). Testcases aren\\'t big enough I think."
                    },
                    {
                        "username": "talk2ritaj",
                        "content": "for i in range(len(nums)):\\n\\t nums[i]=nums[i]**2\\nreturn sorted(nums)"
                    },
                    {
                        "username": "_Ivan_Vigorito_",
                        "content": "If you like it, Upvote ;) \\n\\n\\n#### Solution\\nreturn sorted(map(lambda x: (x)**2, nums))"
                    },
                    {
                        "username": "zxak",
                        "content": "solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/squares-of-sorted-array.html"
                    },
                    {
                        "username": "kunalchitkara",
                        "content": "`var sortedSquares = A => A.sort((x,y) => Math.abs(x) - Math.abs(y)).map(x => x*x);`"
                    },
                    {
                        "username": "tushartiwari25",
                        "content": "Can anyone explain how a two pointer solution in one of binary search...."
                    },
                    {
                        "username": "__buruno",
                        "content": "it maybe a very dumb question but i\\'ll ask anyway... can anybody explain to me why do i need to do *returnsize = numsSize?"
                    },
                    {
                        "username": "tuhinssam",
                        "content": "after putting this constraint: \"Squaring each element and sorting the new array is very trivial, could you find an O(n) solution using a different approach\", it doesn\\'t remain easy anymore"
                    }
                ]
            },
            {
                "id": 1888341,
                "content": [
                    {
                        "username": "ansarnitp",
                        "content": "Is it possible to solve in O(n) time and O(k) space ?\\nLike in two pointer method, we use an extra array to store the values. But I don\\'t want to use any extra array and sort the squared result in the same array itself."
                    },
                    {
                        "username": "manojjha",
                        "content": "Hello guys for my below solution my testcases are passing when I run the code but when I submit it then I get error \"Time Limit Exceeded\". In submission it 128/137 testcases passed \\n\"\"\"class Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        SquareList=[]\\n        SquareList = [num**2 for num in nums]\\n        for i in range(len(SquareList)):\\n            for j in range(len(SquareList)):\\n                if SquareList[i]<SquareList[j]:\\n                    SquareList[j], SquareList[i] = SquareList[i],SquareList[j]\\n        return SquareList\"\"\"\\nWhat is wrong I am doing in this?\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "Hope you aren\\'t gonna do sorting :)"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "Further follow-up. Is there a solution of O(N) time complexity and at the same time sort the array in-place? \\n\\nIn the \"merge two sorted array\" approach, I can only think of copying the negatives to a new array and fill back into the original nums array. Can we avoid the \"copying\" into a new array part?"
                    },
                    {
                        "username": "chubbycccc",
                        "content": "Hello guys, would you like to help me to solve this error?  I have no idea why the error showed that\"list assignment index out of range\" for the \"result[k]=result[j]*result[j].\\nThanks a lot !\\n\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n          result=[]\\n          n=len(nums)\\n          k,j=n-1,n-1\\n          i=0\\n         while i<=j:\\n            if nums[i]*nums[i]>nums[j]*nums[j]:\\n                result[k]=nums[i]*nums[i]\\n                i+=1\\n            else:\\n                result[k]=nums[j]*nums[j]\\n                j-=1\\n            k-=1\\n        \\n        return result\\n"
                    },
                    {
                        "username": "payalraman0",
                        "content": "if you want to solve it in O(n) time ,it can be converted in merge two sorted arrays but you need extra space O(n) . I don\\'t know how to do it in TC: O(n), SC :O(1) "
                    },
                    {
                        "username": "payalraman0",
                        "content": "[@linuscodes56](/linuscodes56) you don\\'t need to reverse the array"
                    },
                    {
                        "username": "linuscodes56",
                        "content": "yes it is possible . the array is in sorted order so apply two pointer and push the values^2 in decreasing order in new array than reverse the array."
                    },
                    {
                        "username": "amanjaiman890",
                        "content": "I Solved this question by 1ms O(n), you guys have any idea/solution that we can solve by 0ms :)"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "are you sure bro?.Seems confusing"
                    },
                    {
                        "username": "payalraman0",
                        "content": "Can you tell me how you have done in O(N)"
                    },
                    {
                        "username": "Ayu_0308958",
                        "content": " for(int i=0;i<nums.size();i++){\\n        nums[i] =(nums[i]*nums[i]);}\\n        sort(nums.begin(),nums.end());\\n        return nums;\\n"
                    },
                    {
                        "username": "Bhavyaa_Arora_08",
                        "content": "Is an O(1) space or inplace solution possible for this question ?"
                    },
                    {
                        "username": "fireship_2004",
                        "content": "[@linuscodes56](/linuscodes56) stop spamming dude. you just said to push the values^2 in decreasing order in a new array then how come your solution stays in O(1) space complexity?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "[@linuscodes56](/linuscodes56) if you are using additional space then how it will be o(1).That will be o(n)"
                    },
                    {
                        "username": "linuscodes56",
                        "content": "yes it is possible . the array is in sorted order so apply two pointer and push the values^2 in decreasing order in new array than reverse the array."
                    },
                    {
                        "username": "harshmishra3263",
                        "content": "I have solved this question using bubble sort and in this it is showing that you have passed 137 out of 137 test cases but above it is displaying time limit exceeded.\\n"
                    }
                ]
            },
            {
                "id": 1880457,
                "content": [
                    {
                        "username": "ansarnitp",
                        "content": "Is it possible to solve in O(n) time and O(k) space ?\\nLike in two pointer method, we use an extra array to store the values. But I don\\'t want to use any extra array and sort the squared result in the same array itself."
                    },
                    {
                        "username": "manojjha",
                        "content": "Hello guys for my below solution my testcases are passing when I run the code but when I submit it then I get error \"Time Limit Exceeded\". In submission it 128/137 testcases passed \\n\"\"\"class Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        SquareList=[]\\n        SquareList = [num**2 for num in nums]\\n        for i in range(len(SquareList)):\\n            for j in range(len(SquareList)):\\n                if SquareList[i]<SquareList[j]:\\n                    SquareList[j], SquareList[i] = SquareList[i],SquareList[j]\\n        return SquareList\"\"\"\\nWhat is wrong I am doing in this?\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "Hope you aren\\'t gonna do sorting :)"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "Further follow-up. Is there a solution of O(N) time complexity and at the same time sort the array in-place? \\n\\nIn the \"merge two sorted array\" approach, I can only think of copying the negatives to a new array and fill back into the original nums array. Can we avoid the \"copying\" into a new array part?"
                    },
                    {
                        "username": "chubbycccc",
                        "content": "Hello guys, would you like to help me to solve this error?  I have no idea why the error showed that\"list assignment index out of range\" for the \"result[k]=result[j]*result[j].\\nThanks a lot !\\n\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n          result=[]\\n          n=len(nums)\\n          k,j=n-1,n-1\\n          i=0\\n         while i<=j:\\n            if nums[i]*nums[i]>nums[j]*nums[j]:\\n                result[k]=nums[i]*nums[i]\\n                i+=1\\n            else:\\n                result[k]=nums[j]*nums[j]\\n                j-=1\\n            k-=1\\n        \\n        return result\\n"
                    },
                    {
                        "username": "payalraman0",
                        "content": "if you want to solve it in O(n) time ,it can be converted in merge two sorted arrays but you need extra space O(n) . I don\\'t know how to do it in TC: O(n), SC :O(1) "
                    },
                    {
                        "username": "payalraman0",
                        "content": "[@linuscodes56](/linuscodes56) you don\\'t need to reverse the array"
                    },
                    {
                        "username": "linuscodes56",
                        "content": "yes it is possible . the array is in sorted order so apply two pointer and push the values^2 in decreasing order in new array than reverse the array."
                    },
                    {
                        "username": "amanjaiman890",
                        "content": "I Solved this question by 1ms O(n), you guys have any idea/solution that we can solve by 0ms :)"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "are you sure bro?.Seems confusing"
                    },
                    {
                        "username": "payalraman0",
                        "content": "Can you tell me how you have done in O(N)"
                    },
                    {
                        "username": "Ayu_0308958",
                        "content": " for(int i=0;i<nums.size();i++){\\n        nums[i] =(nums[i]*nums[i]);}\\n        sort(nums.begin(),nums.end());\\n        return nums;\\n"
                    },
                    {
                        "username": "Bhavyaa_Arora_08",
                        "content": "Is an O(1) space or inplace solution possible for this question ?"
                    },
                    {
                        "username": "fireship_2004",
                        "content": "[@linuscodes56](/linuscodes56) stop spamming dude. you just said to push the values^2 in decreasing order in a new array then how come your solution stays in O(1) space complexity?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "[@linuscodes56](/linuscodes56) if you are using additional space then how it will be o(1).That will be o(n)"
                    },
                    {
                        "username": "linuscodes56",
                        "content": "yes it is possible . the array is in sorted order so apply two pointer and push the values^2 in decreasing order in new array than reverse the array."
                    },
                    {
                        "username": "harshmishra3263",
                        "content": "I have solved this question using bubble sort and in this it is showing that you have passed 137 out of 137 test cases but above it is displaying time limit exceeded.\\n"
                    }
                ]
            },
            {
                "id": 1856876,
                "content": [
                    {
                        "username": "ansarnitp",
                        "content": "Is it possible to solve in O(n) time and O(k) space ?\\nLike in two pointer method, we use an extra array to store the values. But I don\\'t want to use any extra array and sort the squared result in the same array itself."
                    },
                    {
                        "username": "manojjha",
                        "content": "Hello guys for my below solution my testcases are passing when I run the code but when I submit it then I get error \"Time Limit Exceeded\". In submission it 128/137 testcases passed \\n\"\"\"class Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        SquareList=[]\\n        SquareList = [num**2 for num in nums]\\n        for i in range(len(SquareList)):\\n            for j in range(len(SquareList)):\\n                if SquareList[i]<SquareList[j]:\\n                    SquareList[j], SquareList[i] = SquareList[i],SquareList[j]\\n        return SquareList\"\"\"\\nWhat is wrong I am doing in this?\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "Hope you aren\\'t gonna do sorting :)"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "Further follow-up. Is there a solution of O(N) time complexity and at the same time sort the array in-place? \\n\\nIn the \"merge two sorted array\" approach, I can only think of copying the negatives to a new array and fill back into the original nums array. Can we avoid the \"copying\" into a new array part?"
                    },
                    {
                        "username": "chubbycccc",
                        "content": "Hello guys, would you like to help me to solve this error?  I have no idea why the error showed that\"list assignment index out of range\" for the \"result[k]=result[j]*result[j].\\nThanks a lot !\\n\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n          result=[]\\n          n=len(nums)\\n          k,j=n-1,n-1\\n          i=0\\n         while i<=j:\\n            if nums[i]*nums[i]>nums[j]*nums[j]:\\n                result[k]=nums[i]*nums[i]\\n                i+=1\\n            else:\\n                result[k]=nums[j]*nums[j]\\n                j-=1\\n            k-=1\\n        \\n        return result\\n"
                    },
                    {
                        "username": "payalraman0",
                        "content": "if you want to solve it in O(n) time ,it can be converted in merge two sorted arrays but you need extra space O(n) . I don\\'t know how to do it in TC: O(n), SC :O(1) "
                    },
                    {
                        "username": "payalraman0",
                        "content": "[@linuscodes56](/linuscodes56) you don\\'t need to reverse the array"
                    },
                    {
                        "username": "linuscodes56",
                        "content": "yes it is possible . the array is in sorted order so apply two pointer and push the values^2 in decreasing order in new array than reverse the array."
                    },
                    {
                        "username": "amanjaiman890",
                        "content": "I Solved this question by 1ms O(n), you guys have any idea/solution that we can solve by 0ms :)"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "are you sure bro?.Seems confusing"
                    },
                    {
                        "username": "payalraman0",
                        "content": "Can you tell me how you have done in O(N)"
                    },
                    {
                        "username": "Ayu_0308958",
                        "content": " for(int i=0;i<nums.size();i++){\\n        nums[i] =(nums[i]*nums[i]);}\\n        sort(nums.begin(),nums.end());\\n        return nums;\\n"
                    },
                    {
                        "username": "Bhavyaa_Arora_08",
                        "content": "Is an O(1) space or inplace solution possible for this question ?"
                    },
                    {
                        "username": "fireship_2004",
                        "content": "[@linuscodes56](/linuscodes56) stop spamming dude. you just said to push the values^2 in decreasing order in a new array then how come your solution stays in O(1) space complexity?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "[@linuscodes56](/linuscodes56) if you are using additional space then how it will be o(1).That will be o(n)"
                    },
                    {
                        "username": "linuscodes56",
                        "content": "yes it is possible . the array is in sorted order so apply two pointer and push the values^2 in decreasing order in new array than reverse the array."
                    },
                    {
                        "username": "harshmishra3263",
                        "content": "I have solved this question using bubble sort and in this it is showing that you have passed 137 out of 137 test cases but above it is displaying time limit exceeded.\\n"
                    }
                ]
            },
            {
                "id": 1809015,
                "content": [
                    {
                        "username": "ansarnitp",
                        "content": "Is it possible to solve in O(n) time and O(k) space ?\\nLike in two pointer method, we use an extra array to store the values. But I don\\'t want to use any extra array and sort the squared result in the same array itself."
                    },
                    {
                        "username": "manojjha",
                        "content": "Hello guys for my below solution my testcases are passing when I run the code but when I submit it then I get error \"Time Limit Exceeded\". In submission it 128/137 testcases passed \\n\"\"\"class Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        SquareList=[]\\n        SquareList = [num**2 for num in nums]\\n        for i in range(len(SquareList)):\\n            for j in range(len(SquareList)):\\n                if SquareList[i]<SquareList[j]:\\n                    SquareList[j], SquareList[i] = SquareList[i],SquareList[j]\\n        return SquareList\"\"\"\\nWhat is wrong I am doing in this?\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "Hope you aren\\'t gonna do sorting :)"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "Further follow-up. Is there a solution of O(N) time complexity and at the same time sort the array in-place? \\n\\nIn the \"merge two sorted array\" approach, I can only think of copying the negatives to a new array and fill back into the original nums array. Can we avoid the \"copying\" into a new array part?"
                    },
                    {
                        "username": "chubbycccc",
                        "content": "Hello guys, would you like to help me to solve this error?  I have no idea why the error showed that\"list assignment index out of range\" for the \"result[k]=result[j]*result[j].\\nThanks a lot !\\n\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n          result=[]\\n          n=len(nums)\\n          k,j=n-1,n-1\\n          i=0\\n         while i<=j:\\n            if nums[i]*nums[i]>nums[j]*nums[j]:\\n                result[k]=nums[i]*nums[i]\\n                i+=1\\n            else:\\n                result[k]=nums[j]*nums[j]\\n                j-=1\\n            k-=1\\n        \\n        return result\\n"
                    },
                    {
                        "username": "payalraman0",
                        "content": "if you want to solve it in O(n) time ,it can be converted in merge two sorted arrays but you need extra space O(n) . I don\\'t know how to do it in TC: O(n), SC :O(1) "
                    },
                    {
                        "username": "payalraman0",
                        "content": "[@linuscodes56](/linuscodes56) you don\\'t need to reverse the array"
                    },
                    {
                        "username": "linuscodes56",
                        "content": "yes it is possible . the array is in sorted order so apply two pointer and push the values^2 in decreasing order in new array than reverse the array."
                    },
                    {
                        "username": "amanjaiman890",
                        "content": "I Solved this question by 1ms O(n), you guys have any idea/solution that we can solve by 0ms :)"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "are you sure bro?.Seems confusing"
                    },
                    {
                        "username": "payalraman0",
                        "content": "Can you tell me how you have done in O(N)"
                    },
                    {
                        "username": "Ayu_0308958",
                        "content": " for(int i=0;i<nums.size();i++){\\n        nums[i] =(nums[i]*nums[i]);}\\n        sort(nums.begin(),nums.end());\\n        return nums;\\n"
                    },
                    {
                        "username": "Bhavyaa_Arora_08",
                        "content": "Is an O(1) space or inplace solution possible for this question ?"
                    },
                    {
                        "username": "fireship_2004",
                        "content": "[@linuscodes56](/linuscodes56) stop spamming dude. you just said to push the values^2 in decreasing order in a new array then how come your solution stays in O(1) space complexity?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "[@linuscodes56](/linuscodes56) if you are using additional space then how it will be o(1).That will be o(n)"
                    },
                    {
                        "username": "linuscodes56",
                        "content": "yes it is possible . the array is in sorted order so apply two pointer and push the values^2 in decreasing order in new array than reverse the array."
                    },
                    {
                        "username": "harshmishra3263",
                        "content": "I have solved this question using bubble sort and in this it is showing that you have passed 137 out of 137 test cases but above it is displaying time limit exceeded.\\n"
                    }
                ]
            },
            {
                "id": 1791819,
                "content": [
                    {
                        "username": "ansarnitp",
                        "content": "Is it possible to solve in O(n) time and O(k) space ?\\nLike in two pointer method, we use an extra array to store the values. But I don\\'t want to use any extra array and sort the squared result in the same array itself."
                    },
                    {
                        "username": "manojjha",
                        "content": "Hello guys for my below solution my testcases are passing when I run the code but when I submit it then I get error \"Time Limit Exceeded\". In submission it 128/137 testcases passed \\n\"\"\"class Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        SquareList=[]\\n        SquareList = [num**2 for num in nums]\\n        for i in range(len(SquareList)):\\n            for j in range(len(SquareList)):\\n                if SquareList[i]<SquareList[j]:\\n                    SquareList[j], SquareList[i] = SquareList[i],SquareList[j]\\n        return SquareList\"\"\"\\nWhat is wrong I am doing in this?\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "Hope you aren\\'t gonna do sorting :)"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "Further follow-up. Is there a solution of O(N) time complexity and at the same time sort the array in-place? \\n\\nIn the \"merge two sorted array\" approach, I can only think of copying the negatives to a new array and fill back into the original nums array. Can we avoid the \"copying\" into a new array part?"
                    },
                    {
                        "username": "chubbycccc",
                        "content": "Hello guys, would you like to help me to solve this error?  I have no idea why the error showed that\"list assignment index out of range\" for the \"result[k]=result[j]*result[j].\\nThanks a lot !\\n\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n          result=[]\\n          n=len(nums)\\n          k,j=n-1,n-1\\n          i=0\\n         while i<=j:\\n            if nums[i]*nums[i]>nums[j]*nums[j]:\\n                result[k]=nums[i]*nums[i]\\n                i+=1\\n            else:\\n                result[k]=nums[j]*nums[j]\\n                j-=1\\n            k-=1\\n        \\n        return result\\n"
                    },
                    {
                        "username": "payalraman0",
                        "content": "if you want to solve it in O(n) time ,it can be converted in merge two sorted arrays but you need extra space O(n) . I don\\'t know how to do it in TC: O(n), SC :O(1) "
                    },
                    {
                        "username": "payalraman0",
                        "content": "[@linuscodes56](/linuscodes56) you don\\'t need to reverse the array"
                    },
                    {
                        "username": "linuscodes56",
                        "content": "yes it is possible . the array is in sorted order so apply two pointer and push the values^2 in decreasing order in new array than reverse the array."
                    },
                    {
                        "username": "amanjaiman890",
                        "content": "I Solved this question by 1ms O(n), you guys have any idea/solution that we can solve by 0ms :)"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "are you sure bro?.Seems confusing"
                    },
                    {
                        "username": "payalraman0",
                        "content": "Can you tell me how you have done in O(N)"
                    },
                    {
                        "username": "Ayu_0308958",
                        "content": " for(int i=0;i<nums.size();i++){\\n        nums[i] =(nums[i]*nums[i]);}\\n        sort(nums.begin(),nums.end());\\n        return nums;\\n"
                    },
                    {
                        "username": "Bhavyaa_Arora_08",
                        "content": "Is an O(1) space or inplace solution possible for this question ?"
                    },
                    {
                        "username": "fireship_2004",
                        "content": "[@linuscodes56](/linuscodes56) stop spamming dude. you just said to push the values^2 in decreasing order in a new array then how come your solution stays in O(1) space complexity?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "[@linuscodes56](/linuscodes56) if you are using additional space then how it will be o(1).That will be o(n)"
                    },
                    {
                        "username": "linuscodes56",
                        "content": "yes it is possible . the array is in sorted order so apply two pointer and push the values^2 in decreasing order in new array than reverse the array."
                    },
                    {
                        "username": "harshmishra3263",
                        "content": "I have solved this question using bubble sort and in this it is showing that you have passed 137 out of 137 test cases but above it is displaying time limit exceeded.\\n"
                    }
                ]
            },
            {
                "id": 1787176,
                "content": [
                    {
                        "username": "ansarnitp",
                        "content": "Is it possible to solve in O(n) time and O(k) space ?\\nLike in two pointer method, we use an extra array to store the values. But I don\\'t want to use any extra array and sort the squared result in the same array itself."
                    },
                    {
                        "username": "manojjha",
                        "content": "Hello guys for my below solution my testcases are passing when I run the code but when I submit it then I get error \"Time Limit Exceeded\". In submission it 128/137 testcases passed \\n\"\"\"class Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        SquareList=[]\\n        SquareList = [num**2 for num in nums]\\n        for i in range(len(SquareList)):\\n            for j in range(len(SquareList)):\\n                if SquareList[i]<SquareList[j]:\\n                    SquareList[j], SquareList[i] = SquareList[i],SquareList[j]\\n        return SquareList\"\"\"\\nWhat is wrong I am doing in this?\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "Hope you aren\\'t gonna do sorting :)"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "Further follow-up. Is there a solution of O(N) time complexity and at the same time sort the array in-place? \\n\\nIn the \"merge two sorted array\" approach, I can only think of copying the negatives to a new array and fill back into the original nums array. Can we avoid the \"copying\" into a new array part?"
                    },
                    {
                        "username": "chubbycccc",
                        "content": "Hello guys, would you like to help me to solve this error?  I have no idea why the error showed that\"list assignment index out of range\" for the \"result[k]=result[j]*result[j].\\nThanks a lot !\\n\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n          result=[]\\n          n=len(nums)\\n          k,j=n-1,n-1\\n          i=0\\n         while i<=j:\\n            if nums[i]*nums[i]>nums[j]*nums[j]:\\n                result[k]=nums[i]*nums[i]\\n                i+=1\\n            else:\\n                result[k]=nums[j]*nums[j]\\n                j-=1\\n            k-=1\\n        \\n        return result\\n"
                    },
                    {
                        "username": "payalraman0",
                        "content": "if you want to solve it in O(n) time ,it can be converted in merge two sorted arrays but you need extra space O(n) . I don\\'t know how to do it in TC: O(n), SC :O(1) "
                    },
                    {
                        "username": "payalraman0",
                        "content": "[@linuscodes56](/linuscodes56) you don\\'t need to reverse the array"
                    },
                    {
                        "username": "linuscodes56",
                        "content": "yes it is possible . the array is in sorted order so apply two pointer and push the values^2 in decreasing order in new array than reverse the array."
                    },
                    {
                        "username": "amanjaiman890",
                        "content": "I Solved this question by 1ms O(n), you guys have any idea/solution that we can solve by 0ms :)"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "are you sure bro?.Seems confusing"
                    },
                    {
                        "username": "payalraman0",
                        "content": "Can you tell me how you have done in O(N)"
                    },
                    {
                        "username": "Ayu_0308958",
                        "content": " for(int i=0;i<nums.size();i++){\\n        nums[i] =(nums[i]*nums[i]);}\\n        sort(nums.begin(),nums.end());\\n        return nums;\\n"
                    },
                    {
                        "username": "Bhavyaa_Arora_08",
                        "content": "Is an O(1) space or inplace solution possible for this question ?"
                    },
                    {
                        "username": "fireship_2004",
                        "content": "[@linuscodes56](/linuscodes56) stop spamming dude. you just said to push the values^2 in decreasing order in a new array then how come your solution stays in O(1) space complexity?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "[@linuscodes56](/linuscodes56) if you are using additional space then how it will be o(1).That will be o(n)"
                    },
                    {
                        "username": "linuscodes56",
                        "content": "yes it is possible . the array is in sorted order so apply two pointer and push the values^2 in decreasing order in new array than reverse the array."
                    },
                    {
                        "username": "harshmishra3263",
                        "content": "I have solved this question using bubble sort and in this it is showing that you have passed 137 out of 137 test cases but above it is displaying time limit exceeded.\\n"
                    }
                ]
            },
            {
                "id": 1786287,
                "content": [
                    {
                        "username": "ansarnitp",
                        "content": "Is it possible to solve in O(n) time and O(k) space ?\\nLike in two pointer method, we use an extra array to store the values. But I don\\'t want to use any extra array and sort the squared result in the same array itself."
                    },
                    {
                        "username": "manojjha",
                        "content": "Hello guys for my below solution my testcases are passing when I run the code but when I submit it then I get error \"Time Limit Exceeded\". In submission it 128/137 testcases passed \\n\"\"\"class Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        SquareList=[]\\n        SquareList = [num**2 for num in nums]\\n        for i in range(len(SquareList)):\\n            for j in range(len(SquareList)):\\n                if SquareList[i]<SquareList[j]:\\n                    SquareList[j], SquareList[i] = SquareList[i],SquareList[j]\\n        return SquareList\"\"\"\\nWhat is wrong I am doing in this?\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "Hope you aren\\'t gonna do sorting :)"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "Further follow-up. Is there a solution of O(N) time complexity and at the same time sort the array in-place? \\n\\nIn the \"merge two sorted array\" approach, I can only think of copying the negatives to a new array and fill back into the original nums array. Can we avoid the \"copying\" into a new array part?"
                    },
                    {
                        "username": "chubbycccc",
                        "content": "Hello guys, would you like to help me to solve this error?  I have no idea why the error showed that\"list assignment index out of range\" for the \"result[k]=result[j]*result[j].\\nThanks a lot !\\n\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n          result=[]\\n          n=len(nums)\\n          k,j=n-1,n-1\\n          i=0\\n         while i<=j:\\n            if nums[i]*nums[i]>nums[j]*nums[j]:\\n                result[k]=nums[i]*nums[i]\\n                i+=1\\n            else:\\n                result[k]=nums[j]*nums[j]\\n                j-=1\\n            k-=1\\n        \\n        return result\\n"
                    },
                    {
                        "username": "payalraman0",
                        "content": "if you want to solve it in O(n) time ,it can be converted in merge two sorted arrays but you need extra space O(n) . I don\\'t know how to do it in TC: O(n), SC :O(1) "
                    },
                    {
                        "username": "payalraman0",
                        "content": "[@linuscodes56](/linuscodes56) you don\\'t need to reverse the array"
                    },
                    {
                        "username": "linuscodes56",
                        "content": "yes it is possible . the array is in sorted order so apply two pointer and push the values^2 in decreasing order in new array than reverse the array."
                    },
                    {
                        "username": "amanjaiman890",
                        "content": "I Solved this question by 1ms O(n), you guys have any idea/solution that we can solve by 0ms :)"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "are you sure bro?.Seems confusing"
                    },
                    {
                        "username": "payalraman0",
                        "content": "Can you tell me how you have done in O(N)"
                    },
                    {
                        "username": "Ayu_0308958",
                        "content": " for(int i=0;i<nums.size();i++){\\n        nums[i] =(nums[i]*nums[i]);}\\n        sort(nums.begin(),nums.end());\\n        return nums;\\n"
                    },
                    {
                        "username": "Bhavyaa_Arora_08",
                        "content": "Is an O(1) space or inplace solution possible for this question ?"
                    },
                    {
                        "username": "fireship_2004",
                        "content": "[@linuscodes56](/linuscodes56) stop spamming dude. you just said to push the values^2 in decreasing order in a new array then how come your solution stays in O(1) space complexity?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "[@linuscodes56](/linuscodes56) if you are using additional space then how it will be o(1).That will be o(n)"
                    },
                    {
                        "username": "linuscodes56",
                        "content": "yes it is possible . the array is in sorted order so apply two pointer and push the values^2 in decreasing order in new array than reverse the array."
                    },
                    {
                        "username": "harshmishra3263",
                        "content": "I have solved this question using bubble sort and in this it is showing that you have passed 137 out of 137 test cases but above it is displaying time limit exceeded.\\n"
                    }
                ]
            },
            {
                "id": 1781187,
                "content": [
                    {
                        "username": "ansarnitp",
                        "content": "Is it possible to solve in O(n) time and O(k) space ?\\nLike in two pointer method, we use an extra array to store the values. But I don\\'t want to use any extra array and sort the squared result in the same array itself."
                    },
                    {
                        "username": "manojjha",
                        "content": "Hello guys for my below solution my testcases are passing when I run the code but when I submit it then I get error \"Time Limit Exceeded\". In submission it 128/137 testcases passed \\n\"\"\"class Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        SquareList=[]\\n        SquareList = [num**2 for num in nums]\\n        for i in range(len(SquareList)):\\n            for j in range(len(SquareList)):\\n                if SquareList[i]<SquareList[j]:\\n                    SquareList[j], SquareList[i] = SquareList[i],SquareList[j]\\n        return SquareList\"\"\"\\nWhat is wrong I am doing in this?\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "Hope you aren\\'t gonna do sorting :)"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "Further follow-up. Is there a solution of O(N) time complexity and at the same time sort the array in-place? \\n\\nIn the \"merge two sorted array\" approach, I can only think of copying the negatives to a new array and fill back into the original nums array. Can we avoid the \"copying\" into a new array part?"
                    },
                    {
                        "username": "chubbycccc",
                        "content": "Hello guys, would you like to help me to solve this error?  I have no idea why the error showed that\"list assignment index out of range\" for the \"result[k]=result[j]*result[j].\\nThanks a lot !\\n\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n          result=[]\\n          n=len(nums)\\n          k,j=n-1,n-1\\n          i=0\\n         while i<=j:\\n            if nums[i]*nums[i]>nums[j]*nums[j]:\\n                result[k]=nums[i]*nums[i]\\n                i+=1\\n            else:\\n                result[k]=nums[j]*nums[j]\\n                j-=1\\n            k-=1\\n        \\n        return result\\n"
                    },
                    {
                        "username": "payalraman0",
                        "content": "if you want to solve it in O(n) time ,it can be converted in merge two sorted arrays but you need extra space O(n) . I don\\'t know how to do it in TC: O(n), SC :O(1) "
                    },
                    {
                        "username": "payalraman0",
                        "content": "[@linuscodes56](/linuscodes56) you don\\'t need to reverse the array"
                    },
                    {
                        "username": "linuscodes56",
                        "content": "yes it is possible . the array is in sorted order so apply two pointer and push the values^2 in decreasing order in new array than reverse the array."
                    },
                    {
                        "username": "amanjaiman890",
                        "content": "I Solved this question by 1ms O(n), you guys have any idea/solution that we can solve by 0ms :)"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "are you sure bro?.Seems confusing"
                    },
                    {
                        "username": "payalraman0",
                        "content": "Can you tell me how you have done in O(N)"
                    },
                    {
                        "username": "Ayu_0308958",
                        "content": " for(int i=0;i<nums.size();i++){\\n        nums[i] =(nums[i]*nums[i]);}\\n        sort(nums.begin(),nums.end());\\n        return nums;\\n"
                    },
                    {
                        "username": "Bhavyaa_Arora_08",
                        "content": "Is an O(1) space or inplace solution possible for this question ?"
                    },
                    {
                        "username": "fireship_2004",
                        "content": "[@linuscodes56](/linuscodes56) stop spamming dude. you just said to push the values^2 in decreasing order in a new array then how come your solution stays in O(1) space complexity?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "[@linuscodes56](/linuscodes56) if you are using additional space then how it will be o(1).That will be o(n)"
                    },
                    {
                        "username": "linuscodes56",
                        "content": "yes it is possible . the array is in sorted order so apply two pointer and push the values^2 in decreasing order in new array than reverse the array."
                    },
                    {
                        "username": "harshmishra3263",
                        "content": "I have solved this question using bubble sort and in this it is showing that you have passed 137 out of 137 test cases but above it is displaying time limit exceeded.\\n"
                    }
                ]
            },
            {
                "id": 1781171,
                "content": [
                    {
                        "username": "ansarnitp",
                        "content": "Is it possible to solve in O(n) time and O(k) space ?\\nLike in two pointer method, we use an extra array to store the values. But I don\\'t want to use any extra array and sort the squared result in the same array itself."
                    },
                    {
                        "username": "manojjha",
                        "content": "Hello guys for my below solution my testcases are passing when I run the code but when I submit it then I get error \"Time Limit Exceeded\". In submission it 128/137 testcases passed \\n\"\"\"class Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        SquareList=[]\\n        SquareList = [num**2 for num in nums]\\n        for i in range(len(SquareList)):\\n            for j in range(len(SquareList)):\\n                if SquareList[i]<SquareList[j]:\\n                    SquareList[j], SquareList[i] = SquareList[i],SquareList[j]\\n        return SquareList\"\"\"\\nWhat is wrong I am doing in this?\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "Hope you aren\\'t gonna do sorting :)"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "Further follow-up. Is there a solution of O(N) time complexity and at the same time sort the array in-place? \\n\\nIn the \"merge two sorted array\" approach, I can only think of copying the negatives to a new array and fill back into the original nums array. Can we avoid the \"copying\" into a new array part?"
                    },
                    {
                        "username": "chubbycccc",
                        "content": "Hello guys, would you like to help me to solve this error?  I have no idea why the error showed that\"list assignment index out of range\" for the \"result[k]=result[j]*result[j].\\nThanks a lot !\\n\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n          result=[]\\n          n=len(nums)\\n          k,j=n-1,n-1\\n          i=0\\n         while i<=j:\\n            if nums[i]*nums[i]>nums[j]*nums[j]:\\n                result[k]=nums[i]*nums[i]\\n                i+=1\\n            else:\\n                result[k]=nums[j]*nums[j]\\n                j-=1\\n            k-=1\\n        \\n        return result\\n"
                    },
                    {
                        "username": "payalraman0",
                        "content": "if you want to solve it in O(n) time ,it can be converted in merge two sorted arrays but you need extra space O(n) . I don\\'t know how to do it in TC: O(n), SC :O(1) "
                    },
                    {
                        "username": "payalraman0",
                        "content": "[@linuscodes56](/linuscodes56) you don\\'t need to reverse the array"
                    },
                    {
                        "username": "linuscodes56",
                        "content": "yes it is possible . the array is in sorted order so apply two pointer and push the values^2 in decreasing order in new array than reverse the array."
                    },
                    {
                        "username": "amanjaiman890",
                        "content": "I Solved this question by 1ms O(n), you guys have any idea/solution that we can solve by 0ms :)"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "are you sure bro?.Seems confusing"
                    },
                    {
                        "username": "payalraman0",
                        "content": "Can you tell me how you have done in O(N)"
                    },
                    {
                        "username": "Ayu_0308958",
                        "content": " for(int i=0;i<nums.size();i++){\\n        nums[i] =(nums[i]*nums[i]);}\\n        sort(nums.begin(),nums.end());\\n        return nums;\\n"
                    },
                    {
                        "username": "Bhavyaa_Arora_08",
                        "content": "Is an O(1) space or inplace solution possible for this question ?"
                    },
                    {
                        "username": "fireship_2004",
                        "content": "[@linuscodes56](/linuscodes56) stop spamming dude. you just said to push the values^2 in decreasing order in a new array then how come your solution stays in O(1) space complexity?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "[@linuscodes56](/linuscodes56) if you are using additional space then how it will be o(1).That will be o(n)"
                    },
                    {
                        "username": "linuscodes56",
                        "content": "yes it is possible . the array is in sorted order so apply two pointer and push the values^2 in decreasing order in new array than reverse the array."
                    },
                    {
                        "username": "harshmishra3263",
                        "content": "I have solved this question using bubble sort and in this it is showing that you have passed 137 out of 137 test cases but above it is displaying time limit exceeded.\\n"
                    }
                ]
            },
            {
                "id": 1763423,
                "content": [
                    {
                        "username": "ansarnitp",
                        "content": "Is it possible to solve in O(n) time and O(k) space ?\\nLike in two pointer method, we use an extra array to store the values. But I don\\'t want to use any extra array and sort the squared result in the same array itself."
                    },
                    {
                        "username": "manojjha",
                        "content": "Hello guys for my below solution my testcases are passing when I run the code but when I submit it then I get error \"Time Limit Exceeded\". In submission it 128/137 testcases passed \\n\"\"\"class Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        SquareList=[]\\n        SquareList = [num**2 for num in nums]\\n        for i in range(len(SquareList)):\\n            for j in range(len(SquareList)):\\n                if SquareList[i]<SquareList[j]:\\n                    SquareList[j], SquareList[i] = SquareList[i],SquareList[j]\\n        return SquareList\"\"\"\\nWhat is wrong I am doing in this?\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "Hope you aren\\'t gonna do sorting :)"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "Further follow-up. Is there a solution of O(N) time complexity and at the same time sort the array in-place? \\n\\nIn the \"merge two sorted array\" approach, I can only think of copying the negatives to a new array and fill back into the original nums array. Can we avoid the \"copying\" into a new array part?"
                    },
                    {
                        "username": "chubbycccc",
                        "content": "Hello guys, would you like to help me to solve this error?  I have no idea why the error showed that\"list assignment index out of range\" for the \"result[k]=result[j]*result[j].\\nThanks a lot !\\n\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n          result=[]\\n          n=len(nums)\\n          k,j=n-1,n-1\\n          i=0\\n         while i<=j:\\n            if nums[i]*nums[i]>nums[j]*nums[j]:\\n                result[k]=nums[i]*nums[i]\\n                i+=1\\n            else:\\n                result[k]=nums[j]*nums[j]\\n                j-=1\\n            k-=1\\n        \\n        return result\\n"
                    },
                    {
                        "username": "payalraman0",
                        "content": "if you want to solve it in O(n) time ,it can be converted in merge two sorted arrays but you need extra space O(n) . I don\\'t know how to do it in TC: O(n), SC :O(1) "
                    },
                    {
                        "username": "payalraman0",
                        "content": "[@linuscodes56](/linuscodes56) you don\\'t need to reverse the array"
                    },
                    {
                        "username": "linuscodes56",
                        "content": "yes it is possible . the array is in sorted order so apply two pointer and push the values^2 in decreasing order in new array than reverse the array."
                    },
                    {
                        "username": "amanjaiman890",
                        "content": "I Solved this question by 1ms O(n), you guys have any idea/solution that we can solve by 0ms :)"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "are you sure bro?.Seems confusing"
                    },
                    {
                        "username": "payalraman0",
                        "content": "Can you tell me how you have done in O(N)"
                    },
                    {
                        "username": "Ayu_0308958",
                        "content": " for(int i=0;i<nums.size();i++){\\n        nums[i] =(nums[i]*nums[i]);}\\n        sort(nums.begin(),nums.end());\\n        return nums;\\n"
                    },
                    {
                        "username": "Bhavyaa_Arora_08",
                        "content": "Is an O(1) space or inplace solution possible for this question ?"
                    },
                    {
                        "username": "fireship_2004",
                        "content": "[@linuscodes56](/linuscodes56) stop spamming dude. you just said to push the values^2 in decreasing order in a new array then how come your solution stays in O(1) space complexity?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "[@linuscodes56](/linuscodes56) if you are using additional space then how it will be o(1).That will be o(n)"
                    },
                    {
                        "username": "linuscodes56",
                        "content": "yes it is possible . the array is in sorted order so apply two pointer and push the values^2 in decreasing order in new array than reverse the array."
                    },
                    {
                        "username": "harshmishra3263",
                        "content": "I have solved this question using bubble sort and in this it is showing that you have passed 137 out of 137 test cases but above it is displaying time limit exceeded.\\n"
                    }
                ]
            },
            {
                "id": 1761845,
                "content": [
                    {
                        "username": "Abhi3091",
                        "content": "\\n        for(in\\nt i = 0; i<nums.length; i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        int left = 0;\\n\\n        int right = nums.length-1;\\n        int index = nums.length-1;\\n        int[] result = new int[nums.length];\\n\\n\\n        while(left <= right){\\n            //16 1 0 9 100\\n            int leftSquare = nums[left];\\n            int rightSquare = nums[right];\\n\\n            //we want to fill up the arrays from right\\n            // the trick is to use new array result\\n            //compare using pointers if right square is large\\n            // update and decrement right index\\n            if(rightSquare > leftSquare){\\n\\n                result[index] = rightSquare;\\n                right--;\\n            //else left index is incremented\\n            }else if(leftSquare > rightSquare){\\n\\n                result[index] = leftSquare;\\n                left++;\\n            //if equal then right value and right index decremented\\n            }else if(leftSquare == rightSquare){\\n\\n                result[index] = rightSquare;\\n                right--;\\n            }\\n\\n            index--;\\n        }\\n\\n        return result;\\n\\nMy java solution beats 100 %"
                    },
                    {
                        "username": "kprat",
                        "content": "Can someone help explain the space and time complexity of this solution:\\n\\nobject Solution {\\n    def sortedSquares(nums: Array[Int]): Array[Int] = {\\n        var left = 0\\n        var right = nums.length\\n        var newArray = new Array[Int](nums.length)\\n        var min = 0\\n        if (nums.length==1)\\n            return Array(sq(nums(0)))\\n        //val status:HashMap[Int,Boolean] = HashMap[Int,Boolean]()\\n        while(left<nums.length-1){\\n            //printArray(nums)\\n            if(Math.abs(nums(left))>Math.abs(nums(left+1)))\\n             swap(left,left+1)\\n            else \\n              {\\n              newArray(left) = sq(nums(left))\\n              newArray(left+1) = sq(nums(left+1))\\n              left+=1\\n              }\\n        }\\n        def swap(i:Int,j:Int) = {\\n            val temp = nums(j)\\n            nums(j) = nums(i)\\n            nums(i) = temp\\n            //newArray(i) = sq(nums(i))\\n            //newArray(j) = sq(nums(j))\\n            if(i>0){\\n            left-=1\\n            }\\n        }\\n\\n        def sq(i:Int):Int = {\\n            i*i\\n        }\\n\\n        def printArray(nums:Array[Int]) = {\\n            println(\"Left:\"+left)\\n            println(\"Array Status\")\\n            nums.foreach(x=> print(\" \" + x + \" \"))\\n            println()\\n        }\\n        newArray\\n    }\\n}"
                    },
                    {
                        "username": "mkaypl",
                        "content": "O(N^2) for time complexity (it\\'s bubble sort)"
                    },
                    {
                        "username": "hoangduy265",
                        "content": "`public class Solution {\n    public int[] SortedSquares(int[] nums) {\n        int[] result = new int[nums.Length];\n        for (int i = 0; i < nums.Length; i++)\n        {\n            if (nums[i] < 0) nums[i] = -nums[i];\n            result[i] = nums[i] * nums[i];\n        }\n        Array.Sort(result);\n        return result;\n    }\n}`"
                    },
                    {
                        "username": "AKUTOTA_SANJAY",
                        "content": "  vector<int> sortedSquares(vector<int>& nums) {\n        vector<int> v;\n        int pi=0,ni,k,l;\n        while(nums[pi]<0)\n        {\n            pi++;\n        }      \n        k=pi;\n        ni=pi-1;\n        for(int k=0;k<nums.size();k++)\n        {\n            nums[k]=nums[k]*nums[k];\n        }\n\n            if(ni==-1)\n            {\n                return nums;\n            }\n          else\n          {\n        while(k<nums.size() and ni>=0)\n        {\n            if(nums[k]<nums[ni])\n            {\n                 \n                v.push_back(nums[k]);\n                k++;\n               \n            }\n            else\n            {\n                 v.push_back(nums[ni]);\n                 ni--;\n            }  \n\n            }\n    }\n        \n        \n        for( ;ni>=0;ni--)\n        {\n            v.push_back(nums[ni]);\n        }\n\n        for(;k<nums.size();k++)\n        {\n             v.push_back(nums[k]);\n        }\n\n     return v;\n    }\n\n\nGetting this error plz help?\n\n=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000514 at pc 0x000000345f9b bp 0x7fffa113dd10 sp 0x7fffa113dd08\nREAD of size 4 at 0x602000000514 thread T0\n    #2 0x7f5544f740b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000514 is located 0 bytes to the right of 4-byte region [0x602000000510,0x602000000514)\nallocated by thread T0 here:\n    #6 0x7f5544f740b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n=>0x0c047fff80a0: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING"
                    },
                    {
                        "username": "Ahmed777Khalil",
                        "content": "  return nums.Select(x => x * x ).OrderBy(x=> x).ToArray();\\nC# Linq\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Anyone else getting signed integer overflow? Not sure how to fix this with the return type being a vector<int>"
                    },
                    {
                        "username": "Soumya1999",
                        "content": "Why its shows like memory limit exceeded?\\n"
                    },
                    {
                        "username": "Aryan_Arya",
                        "content": "I have a doubt, can we find the minimum absolute element using log(n) time complexity. Our array is given in sorted fashion. Can we use binary search to find the smallest element (in terms of magnitude)?"
                    },
                    {
                        "username": "irfann2022skipq",
                        "content": "Solved it in very easy wasy with O(n) time complexity.\nvar sortedSquares = function(nums) {\n    let squareArray = []\n    for(let i=0;i<nums.length;i++){\n      squareArray.push(nums[i]*nums[i])\n    }\n    return squareArray.sort((a,b)=>{return a-b})\n}  "
                    },
                    {
                        "username": "eliaashraf",
                        "content": "An easy solution to this would be to first find the squares of each element using a pointer and then using a Arrays.sort(array_name) function to solve this prolem.\\n\\nThis is what I have done-\\n `for(int i = 0; i <= nums.length - 1; i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        Arrays.sort(nums);\\n        return nums;`"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "then the time complexity will be 0(n logn).Try to solve this in 0(n).That is the challenge"
                    },
                    {
                        "username": "mkaypl",
                        "content": "Sorting isn\\'t O(n), just in case you missed the follow up note."
                    }
                ]
            },
            {
                "id": 1742261,
                "content": [
                    {
                        "username": "Abhi3091",
                        "content": "\\n        for(in\\nt i = 0; i<nums.length; i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        int left = 0;\\n\\n        int right = nums.length-1;\\n        int index = nums.length-1;\\n        int[] result = new int[nums.length];\\n\\n\\n        while(left <= right){\\n            //16 1 0 9 100\\n            int leftSquare = nums[left];\\n            int rightSquare = nums[right];\\n\\n            //we want to fill up the arrays from right\\n            // the trick is to use new array result\\n            //compare using pointers if right square is large\\n            // update and decrement right index\\n            if(rightSquare > leftSquare){\\n\\n                result[index] = rightSquare;\\n                right--;\\n            //else left index is incremented\\n            }else if(leftSquare > rightSquare){\\n\\n                result[index] = leftSquare;\\n                left++;\\n            //if equal then right value and right index decremented\\n            }else if(leftSquare == rightSquare){\\n\\n                result[index] = rightSquare;\\n                right--;\\n            }\\n\\n            index--;\\n        }\\n\\n        return result;\\n\\nMy java solution beats 100 %"
                    },
                    {
                        "username": "kprat",
                        "content": "Can someone help explain the space and time complexity of this solution:\\n\\nobject Solution {\\n    def sortedSquares(nums: Array[Int]): Array[Int] = {\\n        var left = 0\\n        var right = nums.length\\n        var newArray = new Array[Int](nums.length)\\n        var min = 0\\n        if (nums.length==1)\\n            return Array(sq(nums(0)))\\n        //val status:HashMap[Int,Boolean] = HashMap[Int,Boolean]()\\n        while(left<nums.length-1){\\n            //printArray(nums)\\n            if(Math.abs(nums(left))>Math.abs(nums(left+1)))\\n             swap(left,left+1)\\n            else \\n              {\\n              newArray(left) = sq(nums(left))\\n              newArray(left+1) = sq(nums(left+1))\\n              left+=1\\n              }\\n        }\\n        def swap(i:Int,j:Int) = {\\n            val temp = nums(j)\\n            nums(j) = nums(i)\\n            nums(i) = temp\\n            //newArray(i) = sq(nums(i))\\n            //newArray(j) = sq(nums(j))\\n            if(i>0){\\n            left-=1\\n            }\\n        }\\n\\n        def sq(i:Int):Int = {\\n            i*i\\n        }\\n\\n        def printArray(nums:Array[Int]) = {\\n            println(\"Left:\"+left)\\n            println(\"Array Status\")\\n            nums.foreach(x=> print(\" \" + x + \" \"))\\n            println()\\n        }\\n        newArray\\n    }\\n}"
                    },
                    {
                        "username": "mkaypl",
                        "content": "O(N^2) for time complexity (it\\'s bubble sort)"
                    },
                    {
                        "username": "hoangduy265",
                        "content": "`public class Solution {\n    public int[] SortedSquares(int[] nums) {\n        int[] result = new int[nums.Length];\n        for (int i = 0; i < nums.Length; i++)\n        {\n            if (nums[i] < 0) nums[i] = -nums[i];\n            result[i] = nums[i] * nums[i];\n        }\n        Array.Sort(result);\n        return result;\n    }\n}`"
                    },
                    {
                        "username": "AKUTOTA_SANJAY",
                        "content": "  vector<int> sortedSquares(vector<int>& nums) {\n        vector<int> v;\n        int pi=0,ni,k,l;\n        while(nums[pi]<0)\n        {\n            pi++;\n        }      \n        k=pi;\n        ni=pi-1;\n        for(int k=0;k<nums.size();k++)\n        {\n            nums[k]=nums[k]*nums[k];\n        }\n\n            if(ni==-1)\n            {\n                return nums;\n            }\n          else\n          {\n        while(k<nums.size() and ni>=0)\n        {\n            if(nums[k]<nums[ni])\n            {\n                 \n                v.push_back(nums[k]);\n                k++;\n               \n            }\n            else\n            {\n                 v.push_back(nums[ni]);\n                 ni--;\n            }  \n\n            }\n    }\n        \n        \n        for( ;ni>=0;ni--)\n        {\n            v.push_back(nums[ni]);\n        }\n\n        for(;k<nums.size();k++)\n        {\n             v.push_back(nums[k]);\n        }\n\n     return v;\n    }\n\n\nGetting this error plz help?\n\n=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000514 at pc 0x000000345f9b bp 0x7fffa113dd10 sp 0x7fffa113dd08\nREAD of size 4 at 0x602000000514 thread T0\n    #2 0x7f5544f740b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000514 is located 0 bytes to the right of 4-byte region [0x602000000510,0x602000000514)\nallocated by thread T0 here:\n    #6 0x7f5544f740b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n=>0x0c047fff80a0: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING"
                    },
                    {
                        "username": "Ahmed777Khalil",
                        "content": "  return nums.Select(x => x * x ).OrderBy(x=> x).ToArray();\\nC# Linq\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Anyone else getting signed integer overflow? Not sure how to fix this with the return type being a vector<int>"
                    },
                    {
                        "username": "Soumya1999",
                        "content": "Why its shows like memory limit exceeded?\\n"
                    },
                    {
                        "username": "Aryan_Arya",
                        "content": "I have a doubt, can we find the minimum absolute element using log(n) time complexity. Our array is given in sorted fashion. Can we use binary search to find the smallest element (in terms of magnitude)?"
                    },
                    {
                        "username": "irfann2022skipq",
                        "content": "Solved it in very easy wasy with O(n) time complexity.\nvar sortedSquares = function(nums) {\n    let squareArray = []\n    for(let i=0;i<nums.length;i++){\n      squareArray.push(nums[i]*nums[i])\n    }\n    return squareArray.sort((a,b)=>{return a-b})\n}  "
                    },
                    {
                        "username": "eliaashraf",
                        "content": "An easy solution to this would be to first find the squares of each element using a pointer and then using a Arrays.sort(array_name) function to solve this prolem.\\n\\nThis is what I have done-\\n `for(int i = 0; i <= nums.length - 1; i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        Arrays.sort(nums);\\n        return nums;`"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "then the time complexity will be 0(n logn).Try to solve this in 0(n).That is the challenge"
                    },
                    {
                        "username": "mkaypl",
                        "content": "Sorting isn\\'t O(n), just in case you missed the follow up note."
                    }
                ]
            },
            {
                "id": 1732657,
                "content": [
                    {
                        "username": "Abhi3091",
                        "content": "\\n        for(in\\nt i = 0; i<nums.length; i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        int left = 0;\\n\\n        int right = nums.length-1;\\n        int index = nums.length-1;\\n        int[] result = new int[nums.length];\\n\\n\\n        while(left <= right){\\n            //16 1 0 9 100\\n            int leftSquare = nums[left];\\n            int rightSquare = nums[right];\\n\\n            //we want to fill up the arrays from right\\n            // the trick is to use new array result\\n            //compare using pointers if right square is large\\n            // update and decrement right index\\n            if(rightSquare > leftSquare){\\n\\n                result[index] = rightSquare;\\n                right--;\\n            //else left index is incremented\\n            }else if(leftSquare > rightSquare){\\n\\n                result[index] = leftSquare;\\n                left++;\\n            //if equal then right value and right index decremented\\n            }else if(leftSquare == rightSquare){\\n\\n                result[index] = rightSquare;\\n                right--;\\n            }\\n\\n            index--;\\n        }\\n\\n        return result;\\n\\nMy java solution beats 100 %"
                    },
                    {
                        "username": "kprat",
                        "content": "Can someone help explain the space and time complexity of this solution:\\n\\nobject Solution {\\n    def sortedSquares(nums: Array[Int]): Array[Int] = {\\n        var left = 0\\n        var right = nums.length\\n        var newArray = new Array[Int](nums.length)\\n        var min = 0\\n        if (nums.length==1)\\n            return Array(sq(nums(0)))\\n        //val status:HashMap[Int,Boolean] = HashMap[Int,Boolean]()\\n        while(left<nums.length-1){\\n            //printArray(nums)\\n            if(Math.abs(nums(left))>Math.abs(nums(left+1)))\\n             swap(left,left+1)\\n            else \\n              {\\n              newArray(left) = sq(nums(left))\\n              newArray(left+1) = sq(nums(left+1))\\n              left+=1\\n              }\\n        }\\n        def swap(i:Int,j:Int) = {\\n            val temp = nums(j)\\n            nums(j) = nums(i)\\n            nums(i) = temp\\n            //newArray(i) = sq(nums(i))\\n            //newArray(j) = sq(nums(j))\\n            if(i>0){\\n            left-=1\\n            }\\n        }\\n\\n        def sq(i:Int):Int = {\\n            i*i\\n        }\\n\\n        def printArray(nums:Array[Int]) = {\\n            println(\"Left:\"+left)\\n            println(\"Array Status\")\\n            nums.foreach(x=> print(\" \" + x + \" \"))\\n            println()\\n        }\\n        newArray\\n    }\\n}"
                    },
                    {
                        "username": "mkaypl",
                        "content": "O(N^2) for time complexity (it\\'s bubble sort)"
                    },
                    {
                        "username": "hoangduy265",
                        "content": "`public class Solution {\n    public int[] SortedSquares(int[] nums) {\n        int[] result = new int[nums.Length];\n        for (int i = 0; i < nums.Length; i++)\n        {\n            if (nums[i] < 0) nums[i] = -nums[i];\n            result[i] = nums[i] * nums[i];\n        }\n        Array.Sort(result);\n        return result;\n    }\n}`"
                    },
                    {
                        "username": "AKUTOTA_SANJAY",
                        "content": "  vector<int> sortedSquares(vector<int>& nums) {\n        vector<int> v;\n        int pi=0,ni,k,l;\n        while(nums[pi]<0)\n        {\n            pi++;\n        }      \n        k=pi;\n        ni=pi-1;\n        for(int k=0;k<nums.size();k++)\n        {\n            nums[k]=nums[k]*nums[k];\n        }\n\n            if(ni==-1)\n            {\n                return nums;\n            }\n          else\n          {\n        while(k<nums.size() and ni>=0)\n        {\n            if(nums[k]<nums[ni])\n            {\n                 \n                v.push_back(nums[k]);\n                k++;\n               \n            }\n            else\n            {\n                 v.push_back(nums[ni]);\n                 ni--;\n            }  \n\n            }\n    }\n        \n        \n        for( ;ni>=0;ni--)\n        {\n            v.push_back(nums[ni]);\n        }\n\n        for(;k<nums.size();k++)\n        {\n             v.push_back(nums[k]);\n        }\n\n     return v;\n    }\n\n\nGetting this error plz help?\n\n=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000514 at pc 0x000000345f9b bp 0x7fffa113dd10 sp 0x7fffa113dd08\nREAD of size 4 at 0x602000000514 thread T0\n    #2 0x7f5544f740b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000514 is located 0 bytes to the right of 4-byte region [0x602000000510,0x602000000514)\nallocated by thread T0 here:\n    #6 0x7f5544f740b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n=>0x0c047fff80a0: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING"
                    },
                    {
                        "username": "Ahmed777Khalil",
                        "content": "  return nums.Select(x => x * x ).OrderBy(x=> x).ToArray();\\nC# Linq\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Anyone else getting signed integer overflow? Not sure how to fix this with the return type being a vector<int>"
                    },
                    {
                        "username": "Soumya1999",
                        "content": "Why its shows like memory limit exceeded?\\n"
                    },
                    {
                        "username": "Aryan_Arya",
                        "content": "I have a doubt, can we find the minimum absolute element using log(n) time complexity. Our array is given in sorted fashion. Can we use binary search to find the smallest element (in terms of magnitude)?"
                    },
                    {
                        "username": "irfann2022skipq",
                        "content": "Solved it in very easy wasy with O(n) time complexity.\nvar sortedSquares = function(nums) {\n    let squareArray = []\n    for(let i=0;i<nums.length;i++){\n      squareArray.push(nums[i]*nums[i])\n    }\n    return squareArray.sort((a,b)=>{return a-b})\n}  "
                    },
                    {
                        "username": "eliaashraf",
                        "content": "An easy solution to this would be to first find the squares of each element using a pointer and then using a Arrays.sort(array_name) function to solve this prolem.\\n\\nThis is what I have done-\\n `for(int i = 0; i <= nums.length - 1; i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        Arrays.sort(nums);\\n        return nums;`"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "then the time complexity will be 0(n logn).Try to solve this in 0(n).That is the challenge"
                    },
                    {
                        "username": "mkaypl",
                        "content": "Sorting isn\\'t O(n), just in case you missed the follow up note."
                    }
                ]
            },
            {
                "id": 1732488,
                "content": [
                    {
                        "username": "Abhi3091",
                        "content": "\\n        for(in\\nt i = 0; i<nums.length; i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        int left = 0;\\n\\n        int right = nums.length-1;\\n        int index = nums.length-1;\\n        int[] result = new int[nums.length];\\n\\n\\n        while(left <= right){\\n            //16 1 0 9 100\\n            int leftSquare = nums[left];\\n            int rightSquare = nums[right];\\n\\n            //we want to fill up the arrays from right\\n            // the trick is to use new array result\\n            //compare using pointers if right square is large\\n            // update and decrement right index\\n            if(rightSquare > leftSquare){\\n\\n                result[index] = rightSquare;\\n                right--;\\n            //else left index is incremented\\n            }else if(leftSquare > rightSquare){\\n\\n                result[index] = leftSquare;\\n                left++;\\n            //if equal then right value and right index decremented\\n            }else if(leftSquare == rightSquare){\\n\\n                result[index] = rightSquare;\\n                right--;\\n            }\\n\\n            index--;\\n        }\\n\\n        return result;\\n\\nMy java solution beats 100 %"
                    },
                    {
                        "username": "kprat",
                        "content": "Can someone help explain the space and time complexity of this solution:\\n\\nobject Solution {\\n    def sortedSquares(nums: Array[Int]): Array[Int] = {\\n        var left = 0\\n        var right = nums.length\\n        var newArray = new Array[Int](nums.length)\\n        var min = 0\\n        if (nums.length==1)\\n            return Array(sq(nums(0)))\\n        //val status:HashMap[Int,Boolean] = HashMap[Int,Boolean]()\\n        while(left<nums.length-1){\\n            //printArray(nums)\\n            if(Math.abs(nums(left))>Math.abs(nums(left+1)))\\n             swap(left,left+1)\\n            else \\n              {\\n              newArray(left) = sq(nums(left))\\n              newArray(left+1) = sq(nums(left+1))\\n              left+=1\\n              }\\n        }\\n        def swap(i:Int,j:Int) = {\\n            val temp = nums(j)\\n            nums(j) = nums(i)\\n            nums(i) = temp\\n            //newArray(i) = sq(nums(i))\\n            //newArray(j) = sq(nums(j))\\n            if(i>0){\\n            left-=1\\n            }\\n        }\\n\\n        def sq(i:Int):Int = {\\n            i*i\\n        }\\n\\n        def printArray(nums:Array[Int]) = {\\n            println(\"Left:\"+left)\\n            println(\"Array Status\")\\n            nums.foreach(x=> print(\" \" + x + \" \"))\\n            println()\\n        }\\n        newArray\\n    }\\n}"
                    },
                    {
                        "username": "mkaypl",
                        "content": "O(N^2) for time complexity (it\\'s bubble sort)"
                    },
                    {
                        "username": "hoangduy265",
                        "content": "`public class Solution {\n    public int[] SortedSquares(int[] nums) {\n        int[] result = new int[nums.Length];\n        for (int i = 0; i < nums.Length; i++)\n        {\n            if (nums[i] < 0) nums[i] = -nums[i];\n            result[i] = nums[i] * nums[i];\n        }\n        Array.Sort(result);\n        return result;\n    }\n}`"
                    },
                    {
                        "username": "AKUTOTA_SANJAY",
                        "content": "  vector<int> sortedSquares(vector<int>& nums) {\n        vector<int> v;\n        int pi=0,ni,k,l;\n        while(nums[pi]<0)\n        {\n            pi++;\n        }      \n        k=pi;\n        ni=pi-1;\n        for(int k=0;k<nums.size();k++)\n        {\n            nums[k]=nums[k]*nums[k];\n        }\n\n            if(ni==-1)\n            {\n                return nums;\n            }\n          else\n          {\n        while(k<nums.size() and ni>=0)\n        {\n            if(nums[k]<nums[ni])\n            {\n                 \n                v.push_back(nums[k]);\n                k++;\n               \n            }\n            else\n            {\n                 v.push_back(nums[ni]);\n                 ni--;\n            }  \n\n            }\n    }\n        \n        \n        for( ;ni>=0;ni--)\n        {\n            v.push_back(nums[ni]);\n        }\n\n        for(;k<nums.size();k++)\n        {\n             v.push_back(nums[k]);\n        }\n\n     return v;\n    }\n\n\nGetting this error plz help?\n\n=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000514 at pc 0x000000345f9b bp 0x7fffa113dd10 sp 0x7fffa113dd08\nREAD of size 4 at 0x602000000514 thread T0\n    #2 0x7f5544f740b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000514 is located 0 bytes to the right of 4-byte region [0x602000000510,0x602000000514)\nallocated by thread T0 here:\n    #6 0x7f5544f740b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n=>0x0c047fff80a0: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING"
                    },
                    {
                        "username": "Ahmed777Khalil",
                        "content": "  return nums.Select(x => x * x ).OrderBy(x=> x).ToArray();\\nC# Linq\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Anyone else getting signed integer overflow? Not sure how to fix this with the return type being a vector<int>"
                    },
                    {
                        "username": "Soumya1999",
                        "content": "Why its shows like memory limit exceeded?\\n"
                    },
                    {
                        "username": "Aryan_Arya",
                        "content": "I have a doubt, can we find the minimum absolute element using log(n) time complexity. Our array is given in sorted fashion. Can we use binary search to find the smallest element (in terms of magnitude)?"
                    },
                    {
                        "username": "irfann2022skipq",
                        "content": "Solved it in very easy wasy with O(n) time complexity.\nvar sortedSquares = function(nums) {\n    let squareArray = []\n    for(let i=0;i<nums.length;i++){\n      squareArray.push(nums[i]*nums[i])\n    }\n    return squareArray.sort((a,b)=>{return a-b})\n}  "
                    },
                    {
                        "username": "eliaashraf",
                        "content": "An easy solution to this would be to first find the squares of each element using a pointer and then using a Arrays.sort(array_name) function to solve this prolem.\\n\\nThis is what I have done-\\n `for(int i = 0; i <= nums.length - 1; i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        Arrays.sort(nums);\\n        return nums;`"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "then the time complexity will be 0(n logn).Try to solve this in 0(n).That is the challenge"
                    },
                    {
                        "username": "mkaypl",
                        "content": "Sorting isn\\'t O(n), just in case you missed the follow up note."
                    }
                ]
            },
            {
                "id": 1728889,
                "content": [
                    {
                        "username": "Abhi3091",
                        "content": "\\n        for(in\\nt i = 0; i<nums.length; i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        int left = 0;\\n\\n        int right = nums.length-1;\\n        int index = nums.length-1;\\n        int[] result = new int[nums.length];\\n\\n\\n        while(left <= right){\\n            //16 1 0 9 100\\n            int leftSquare = nums[left];\\n            int rightSquare = nums[right];\\n\\n            //we want to fill up the arrays from right\\n            // the trick is to use new array result\\n            //compare using pointers if right square is large\\n            // update and decrement right index\\n            if(rightSquare > leftSquare){\\n\\n                result[index] = rightSquare;\\n                right--;\\n            //else left index is incremented\\n            }else if(leftSquare > rightSquare){\\n\\n                result[index] = leftSquare;\\n                left++;\\n            //if equal then right value and right index decremented\\n            }else if(leftSquare == rightSquare){\\n\\n                result[index] = rightSquare;\\n                right--;\\n            }\\n\\n            index--;\\n        }\\n\\n        return result;\\n\\nMy java solution beats 100 %"
                    },
                    {
                        "username": "kprat",
                        "content": "Can someone help explain the space and time complexity of this solution:\\n\\nobject Solution {\\n    def sortedSquares(nums: Array[Int]): Array[Int] = {\\n        var left = 0\\n        var right = nums.length\\n        var newArray = new Array[Int](nums.length)\\n        var min = 0\\n        if (nums.length==1)\\n            return Array(sq(nums(0)))\\n        //val status:HashMap[Int,Boolean] = HashMap[Int,Boolean]()\\n        while(left<nums.length-1){\\n            //printArray(nums)\\n            if(Math.abs(nums(left))>Math.abs(nums(left+1)))\\n             swap(left,left+1)\\n            else \\n              {\\n              newArray(left) = sq(nums(left))\\n              newArray(left+1) = sq(nums(left+1))\\n              left+=1\\n              }\\n        }\\n        def swap(i:Int,j:Int) = {\\n            val temp = nums(j)\\n            nums(j) = nums(i)\\n            nums(i) = temp\\n            //newArray(i) = sq(nums(i))\\n            //newArray(j) = sq(nums(j))\\n            if(i>0){\\n            left-=1\\n            }\\n        }\\n\\n        def sq(i:Int):Int = {\\n            i*i\\n        }\\n\\n        def printArray(nums:Array[Int]) = {\\n            println(\"Left:\"+left)\\n            println(\"Array Status\")\\n            nums.foreach(x=> print(\" \" + x + \" \"))\\n            println()\\n        }\\n        newArray\\n    }\\n}"
                    },
                    {
                        "username": "mkaypl",
                        "content": "O(N^2) for time complexity (it\\'s bubble sort)"
                    },
                    {
                        "username": "hoangduy265",
                        "content": "`public class Solution {\n    public int[] SortedSquares(int[] nums) {\n        int[] result = new int[nums.Length];\n        for (int i = 0; i < nums.Length; i++)\n        {\n            if (nums[i] < 0) nums[i] = -nums[i];\n            result[i] = nums[i] * nums[i];\n        }\n        Array.Sort(result);\n        return result;\n    }\n}`"
                    },
                    {
                        "username": "AKUTOTA_SANJAY",
                        "content": "  vector<int> sortedSquares(vector<int>& nums) {\n        vector<int> v;\n        int pi=0,ni,k,l;\n        while(nums[pi]<0)\n        {\n            pi++;\n        }      \n        k=pi;\n        ni=pi-1;\n        for(int k=0;k<nums.size();k++)\n        {\n            nums[k]=nums[k]*nums[k];\n        }\n\n            if(ni==-1)\n            {\n                return nums;\n            }\n          else\n          {\n        while(k<nums.size() and ni>=0)\n        {\n            if(nums[k]<nums[ni])\n            {\n                 \n                v.push_back(nums[k]);\n                k++;\n               \n            }\n            else\n            {\n                 v.push_back(nums[ni]);\n                 ni--;\n            }  \n\n            }\n    }\n        \n        \n        for( ;ni>=0;ni--)\n        {\n            v.push_back(nums[ni]);\n        }\n\n        for(;k<nums.size();k++)\n        {\n             v.push_back(nums[k]);\n        }\n\n     return v;\n    }\n\n\nGetting this error plz help?\n\n=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000514 at pc 0x000000345f9b bp 0x7fffa113dd10 sp 0x7fffa113dd08\nREAD of size 4 at 0x602000000514 thread T0\n    #2 0x7f5544f740b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000514 is located 0 bytes to the right of 4-byte region [0x602000000510,0x602000000514)\nallocated by thread T0 here:\n    #6 0x7f5544f740b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n=>0x0c047fff80a0: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING"
                    },
                    {
                        "username": "Ahmed777Khalil",
                        "content": "  return nums.Select(x => x * x ).OrderBy(x=> x).ToArray();\\nC# Linq\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Anyone else getting signed integer overflow? Not sure how to fix this with the return type being a vector<int>"
                    },
                    {
                        "username": "Soumya1999",
                        "content": "Why its shows like memory limit exceeded?\\n"
                    },
                    {
                        "username": "Aryan_Arya",
                        "content": "I have a doubt, can we find the minimum absolute element using log(n) time complexity. Our array is given in sorted fashion. Can we use binary search to find the smallest element (in terms of magnitude)?"
                    },
                    {
                        "username": "irfann2022skipq",
                        "content": "Solved it in very easy wasy with O(n) time complexity.\nvar sortedSquares = function(nums) {\n    let squareArray = []\n    for(let i=0;i<nums.length;i++){\n      squareArray.push(nums[i]*nums[i])\n    }\n    return squareArray.sort((a,b)=>{return a-b})\n}  "
                    },
                    {
                        "username": "eliaashraf",
                        "content": "An easy solution to this would be to first find the squares of each element using a pointer and then using a Arrays.sort(array_name) function to solve this prolem.\\n\\nThis is what I have done-\\n `for(int i = 0; i <= nums.length - 1; i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        Arrays.sort(nums);\\n        return nums;`"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "then the time complexity will be 0(n logn).Try to solve this in 0(n).That is the challenge"
                    },
                    {
                        "username": "mkaypl",
                        "content": "Sorting isn\\'t O(n), just in case you missed the follow up note."
                    }
                ]
            },
            {
                "id": 1725935,
                "content": [
                    {
                        "username": "Abhi3091",
                        "content": "\\n        for(in\\nt i = 0; i<nums.length; i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        int left = 0;\\n\\n        int right = nums.length-1;\\n        int index = nums.length-1;\\n        int[] result = new int[nums.length];\\n\\n\\n        while(left <= right){\\n            //16 1 0 9 100\\n            int leftSquare = nums[left];\\n            int rightSquare = nums[right];\\n\\n            //we want to fill up the arrays from right\\n            // the trick is to use new array result\\n            //compare using pointers if right square is large\\n            // update and decrement right index\\n            if(rightSquare > leftSquare){\\n\\n                result[index] = rightSquare;\\n                right--;\\n            //else left index is incremented\\n            }else if(leftSquare > rightSquare){\\n\\n                result[index] = leftSquare;\\n                left++;\\n            //if equal then right value and right index decremented\\n            }else if(leftSquare == rightSquare){\\n\\n                result[index] = rightSquare;\\n                right--;\\n            }\\n\\n            index--;\\n        }\\n\\n        return result;\\n\\nMy java solution beats 100 %"
                    },
                    {
                        "username": "kprat",
                        "content": "Can someone help explain the space and time complexity of this solution:\\n\\nobject Solution {\\n    def sortedSquares(nums: Array[Int]): Array[Int] = {\\n        var left = 0\\n        var right = nums.length\\n        var newArray = new Array[Int](nums.length)\\n        var min = 0\\n        if (nums.length==1)\\n            return Array(sq(nums(0)))\\n        //val status:HashMap[Int,Boolean] = HashMap[Int,Boolean]()\\n        while(left<nums.length-1){\\n            //printArray(nums)\\n            if(Math.abs(nums(left))>Math.abs(nums(left+1)))\\n             swap(left,left+1)\\n            else \\n              {\\n              newArray(left) = sq(nums(left))\\n              newArray(left+1) = sq(nums(left+1))\\n              left+=1\\n              }\\n        }\\n        def swap(i:Int,j:Int) = {\\n            val temp = nums(j)\\n            nums(j) = nums(i)\\n            nums(i) = temp\\n            //newArray(i) = sq(nums(i))\\n            //newArray(j) = sq(nums(j))\\n            if(i>0){\\n            left-=1\\n            }\\n        }\\n\\n        def sq(i:Int):Int = {\\n            i*i\\n        }\\n\\n        def printArray(nums:Array[Int]) = {\\n            println(\"Left:\"+left)\\n            println(\"Array Status\")\\n            nums.foreach(x=> print(\" \" + x + \" \"))\\n            println()\\n        }\\n        newArray\\n    }\\n}"
                    },
                    {
                        "username": "mkaypl",
                        "content": "O(N^2) for time complexity (it\\'s bubble sort)"
                    },
                    {
                        "username": "hoangduy265",
                        "content": "`public class Solution {\n    public int[] SortedSquares(int[] nums) {\n        int[] result = new int[nums.Length];\n        for (int i = 0; i < nums.Length; i++)\n        {\n            if (nums[i] < 0) nums[i] = -nums[i];\n            result[i] = nums[i] * nums[i];\n        }\n        Array.Sort(result);\n        return result;\n    }\n}`"
                    },
                    {
                        "username": "AKUTOTA_SANJAY",
                        "content": "  vector<int> sortedSquares(vector<int>& nums) {\n        vector<int> v;\n        int pi=0,ni,k,l;\n        while(nums[pi]<0)\n        {\n            pi++;\n        }      \n        k=pi;\n        ni=pi-1;\n        for(int k=0;k<nums.size();k++)\n        {\n            nums[k]=nums[k]*nums[k];\n        }\n\n            if(ni==-1)\n            {\n                return nums;\n            }\n          else\n          {\n        while(k<nums.size() and ni>=0)\n        {\n            if(nums[k]<nums[ni])\n            {\n                 \n                v.push_back(nums[k]);\n                k++;\n               \n            }\n            else\n            {\n                 v.push_back(nums[ni]);\n                 ni--;\n            }  \n\n            }\n    }\n        \n        \n        for( ;ni>=0;ni--)\n        {\n            v.push_back(nums[ni]);\n        }\n\n        for(;k<nums.size();k++)\n        {\n             v.push_back(nums[k]);\n        }\n\n     return v;\n    }\n\n\nGetting this error plz help?\n\n=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000514 at pc 0x000000345f9b bp 0x7fffa113dd10 sp 0x7fffa113dd08\nREAD of size 4 at 0x602000000514 thread T0\n    #2 0x7f5544f740b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000514 is located 0 bytes to the right of 4-byte region [0x602000000510,0x602000000514)\nallocated by thread T0 here:\n    #6 0x7f5544f740b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n=>0x0c047fff80a0: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING"
                    },
                    {
                        "username": "Ahmed777Khalil",
                        "content": "  return nums.Select(x => x * x ).OrderBy(x=> x).ToArray();\\nC# Linq\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Anyone else getting signed integer overflow? Not sure how to fix this with the return type being a vector<int>"
                    },
                    {
                        "username": "Soumya1999",
                        "content": "Why its shows like memory limit exceeded?\\n"
                    },
                    {
                        "username": "Aryan_Arya",
                        "content": "I have a doubt, can we find the minimum absolute element using log(n) time complexity. Our array is given in sorted fashion. Can we use binary search to find the smallest element (in terms of magnitude)?"
                    },
                    {
                        "username": "irfann2022skipq",
                        "content": "Solved it in very easy wasy with O(n) time complexity.\nvar sortedSquares = function(nums) {\n    let squareArray = []\n    for(let i=0;i<nums.length;i++){\n      squareArray.push(nums[i]*nums[i])\n    }\n    return squareArray.sort((a,b)=>{return a-b})\n}  "
                    },
                    {
                        "username": "eliaashraf",
                        "content": "An easy solution to this would be to first find the squares of each element using a pointer and then using a Arrays.sort(array_name) function to solve this prolem.\\n\\nThis is what I have done-\\n `for(int i = 0; i <= nums.length - 1; i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        Arrays.sort(nums);\\n        return nums;`"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "then the time complexity will be 0(n logn).Try to solve this in 0(n).That is the challenge"
                    },
                    {
                        "username": "mkaypl",
                        "content": "Sorting isn\\'t O(n), just in case you missed the follow up note."
                    }
                ]
            },
            {
                "id": 1683890,
                "content": [
                    {
                        "username": "Abhi3091",
                        "content": "\\n        for(in\\nt i = 0; i<nums.length; i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        int left = 0;\\n\\n        int right = nums.length-1;\\n        int index = nums.length-1;\\n        int[] result = new int[nums.length];\\n\\n\\n        while(left <= right){\\n            //16 1 0 9 100\\n            int leftSquare = nums[left];\\n            int rightSquare = nums[right];\\n\\n            //we want to fill up the arrays from right\\n            // the trick is to use new array result\\n            //compare using pointers if right square is large\\n            // update and decrement right index\\n            if(rightSquare > leftSquare){\\n\\n                result[index] = rightSquare;\\n                right--;\\n            //else left index is incremented\\n            }else if(leftSquare > rightSquare){\\n\\n                result[index] = leftSquare;\\n                left++;\\n            //if equal then right value and right index decremented\\n            }else if(leftSquare == rightSquare){\\n\\n                result[index] = rightSquare;\\n                right--;\\n            }\\n\\n            index--;\\n        }\\n\\n        return result;\\n\\nMy java solution beats 100 %"
                    },
                    {
                        "username": "kprat",
                        "content": "Can someone help explain the space and time complexity of this solution:\\n\\nobject Solution {\\n    def sortedSquares(nums: Array[Int]): Array[Int] = {\\n        var left = 0\\n        var right = nums.length\\n        var newArray = new Array[Int](nums.length)\\n        var min = 0\\n        if (nums.length==1)\\n            return Array(sq(nums(0)))\\n        //val status:HashMap[Int,Boolean] = HashMap[Int,Boolean]()\\n        while(left<nums.length-1){\\n            //printArray(nums)\\n            if(Math.abs(nums(left))>Math.abs(nums(left+1)))\\n             swap(left,left+1)\\n            else \\n              {\\n              newArray(left) = sq(nums(left))\\n              newArray(left+1) = sq(nums(left+1))\\n              left+=1\\n              }\\n        }\\n        def swap(i:Int,j:Int) = {\\n            val temp = nums(j)\\n            nums(j) = nums(i)\\n            nums(i) = temp\\n            //newArray(i) = sq(nums(i))\\n            //newArray(j) = sq(nums(j))\\n            if(i>0){\\n            left-=1\\n            }\\n        }\\n\\n        def sq(i:Int):Int = {\\n            i*i\\n        }\\n\\n        def printArray(nums:Array[Int]) = {\\n            println(\"Left:\"+left)\\n            println(\"Array Status\")\\n            nums.foreach(x=> print(\" \" + x + \" \"))\\n            println()\\n        }\\n        newArray\\n    }\\n}"
                    },
                    {
                        "username": "mkaypl",
                        "content": "O(N^2) for time complexity (it\\'s bubble sort)"
                    },
                    {
                        "username": "hoangduy265",
                        "content": "`public class Solution {\n    public int[] SortedSquares(int[] nums) {\n        int[] result = new int[nums.Length];\n        for (int i = 0; i < nums.Length; i++)\n        {\n            if (nums[i] < 0) nums[i] = -nums[i];\n            result[i] = nums[i] * nums[i];\n        }\n        Array.Sort(result);\n        return result;\n    }\n}`"
                    },
                    {
                        "username": "AKUTOTA_SANJAY",
                        "content": "  vector<int> sortedSquares(vector<int>& nums) {\n        vector<int> v;\n        int pi=0,ni,k,l;\n        while(nums[pi]<0)\n        {\n            pi++;\n        }      \n        k=pi;\n        ni=pi-1;\n        for(int k=0;k<nums.size();k++)\n        {\n            nums[k]=nums[k]*nums[k];\n        }\n\n            if(ni==-1)\n            {\n                return nums;\n            }\n          else\n          {\n        while(k<nums.size() and ni>=0)\n        {\n            if(nums[k]<nums[ni])\n            {\n                 \n                v.push_back(nums[k]);\n                k++;\n               \n            }\n            else\n            {\n                 v.push_back(nums[ni]);\n                 ni--;\n            }  \n\n            }\n    }\n        \n        \n        for( ;ni>=0;ni--)\n        {\n            v.push_back(nums[ni]);\n        }\n\n        for(;k<nums.size();k++)\n        {\n             v.push_back(nums[k]);\n        }\n\n     return v;\n    }\n\n\nGetting this error plz help?\n\n=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000514 at pc 0x000000345f9b bp 0x7fffa113dd10 sp 0x7fffa113dd08\nREAD of size 4 at 0x602000000514 thread T0\n    #2 0x7f5544f740b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000514 is located 0 bytes to the right of 4-byte region [0x602000000510,0x602000000514)\nallocated by thread T0 here:\n    #6 0x7f5544f740b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n=>0x0c047fff80a0: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING"
                    },
                    {
                        "username": "Ahmed777Khalil",
                        "content": "  return nums.Select(x => x * x ).OrderBy(x=> x).ToArray();\\nC# Linq\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Anyone else getting signed integer overflow? Not sure how to fix this with the return type being a vector<int>"
                    },
                    {
                        "username": "Soumya1999",
                        "content": "Why its shows like memory limit exceeded?\\n"
                    },
                    {
                        "username": "Aryan_Arya",
                        "content": "I have a doubt, can we find the minimum absolute element using log(n) time complexity. Our array is given in sorted fashion. Can we use binary search to find the smallest element (in terms of magnitude)?"
                    },
                    {
                        "username": "irfann2022skipq",
                        "content": "Solved it in very easy wasy with O(n) time complexity.\nvar sortedSquares = function(nums) {\n    let squareArray = []\n    for(let i=0;i<nums.length;i++){\n      squareArray.push(nums[i]*nums[i])\n    }\n    return squareArray.sort((a,b)=>{return a-b})\n}  "
                    },
                    {
                        "username": "eliaashraf",
                        "content": "An easy solution to this would be to first find the squares of each element using a pointer and then using a Arrays.sort(array_name) function to solve this prolem.\\n\\nThis is what I have done-\\n `for(int i = 0; i <= nums.length - 1; i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        Arrays.sort(nums);\\n        return nums;`"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "then the time complexity will be 0(n logn).Try to solve this in 0(n).That is the challenge"
                    },
                    {
                        "username": "mkaypl",
                        "content": "Sorting isn\\'t O(n), just in case you missed the follow up note."
                    }
                ]
            },
            {
                "id": 1676020,
                "content": [
                    {
                        "username": "Abhi3091",
                        "content": "\\n        for(in\\nt i = 0; i<nums.length; i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        int left = 0;\\n\\n        int right = nums.length-1;\\n        int index = nums.length-1;\\n        int[] result = new int[nums.length];\\n\\n\\n        while(left <= right){\\n            //16 1 0 9 100\\n            int leftSquare = nums[left];\\n            int rightSquare = nums[right];\\n\\n            //we want to fill up the arrays from right\\n            // the trick is to use new array result\\n            //compare using pointers if right square is large\\n            // update and decrement right index\\n            if(rightSquare > leftSquare){\\n\\n                result[index] = rightSquare;\\n                right--;\\n            //else left index is incremented\\n            }else if(leftSquare > rightSquare){\\n\\n                result[index] = leftSquare;\\n                left++;\\n            //if equal then right value and right index decremented\\n            }else if(leftSquare == rightSquare){\\n\\n                result[index] = rightSquare;\\n                right--;\\n            }\\n\\n            index--;\\n        }\\n\\n        return result;\\n\\nMy java solution beats 100 %"
                    },
                    {
                        "username": "kprat",
                        "content": "Can someone help explain the space and time complexity of this solution:\\n\\nobject Solution {\\n    def sortedSquares(nums: Array[Int]): Array[Int] = {\\n        var left = 0\\n        var right = nums.length\\n        var newArray = new Array[Int](nums.length)\\n        var min = 0\\n        if (nums.length==1)\\n            return Array(sq(nums(0)))\\n        //val status:HashMap[Int,Boolean] = HashMap[Int,Boolean]()\\n        while(left<nums.length-1){\\n            //printArray(nums)\\n            if(Math.abs(nums(left))>Math.abs(nums(left+1)))\\n             swap(left,left+1)\\n            else \\n              {\\n              newArray(left) = sq(nums(left))\\n              newArray(left+1) = sq(nums(left+1))\\n              left+=1\\n              }\\n        }\\n        def swap(i:Int,j:Int) = {\\n            val temp = nums(j)\\n            nums(j) = nums(i)\\n            nums(i) = temp\\n            //newArray(i) = sq(nums(i))\\n            //newArray(j) = sq(nums(j))\\n            if(i>0){\\n            left-=1\\n            }\\n        }\\n\\n        def sq(i:Int):Int = {\\n            i*i\\n        }\\n\\n        def printArray(nums:Array[Int]) = {\\n            println(\"Left:\"+left)\\n            println(\"Array Status\")\\n            nums.foreach(x=> print(\" \" + x + \" \"))\\n            println()\\n        }\\n        newArray\\n    }\\n}"
                    },
                    {
                        "username": "mkaypl",
                        "content": "O(N^2) for time complexity (it\\'s bubble sort)"
                    },
                    {
                        "username": "hoangduy265",
                        "content": "`public class Solution {\n    public int[] SortedSquares(int[] nums) {\n        int[] result = new int[nums.Length];\n        for (int i = 0; i < nums.Length; i++)\n        {\n            if (nums[i] < 0) nums[i] = -nums[i];\n            result[i] = nums[i] * nums[i];\n        }\n        Array.Sort(result);\n        return result;\n    }\n}`"
                    },
                    {
                        "username": "AKUTOTA_SANJAY",
                        "content": "  vector<int> sortedSquares(vector<int>& nums) {\n        vector<int> v;\n        int pi=0,ni,k,l;\n        while(nums[pi]<0)\n        {\n            pi++;\n        }      \n        k=pi;\n        ni=pi-1;\n        for(int k=0;k<nums.size();k++)\n        {\n            nums[k]=nums[k]*nums[k];\n        }\n\n            if(ni==-1)\n            {\n                return nums;\n            }\n          else\n          {\n        while(k<nums.size() and ni>=0)\n        {\n            if(nums[k]<nums[ni])\n            {\n                 \n                v.push_back(nums[k]);\n                k++;\n               \n            }\n            else\n            {\n                 v.push_back(nums[ni]);\n                 ni--;\n            }  \n\n            }\n    }\n        \n        \n        for( ;ni>=0;ni--)\n        {\n            v.push_back(nums[ni]);\n        }\n\n        for(;k<nums.size();k++)\n        {\n             v.push_back(nums[k]);\n        }\n\n     return v;\n    }\n\n\nGetting this error plz help?\n\n=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000514 at pc 0x000000345f9b bp 0x7fffa113dd10 sp 0x7fffa113dd08\nREAD of size 4 at 0x602000000514 thread T0\n    #2 0x7f5544f740b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000514 is located 0 bytes to the right of 4-byte region [0x602000000510,0x602000000514)\nallocated by thread T0 here:\n    #6 0x7f5544f740b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n=>0x0c047fff80a0: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING"
                    },
                    {
                        "username": "Ahmed777Khalil",
                        "content": "  return nums.Select(x => x * x ).OrderBy(x=> x).ToArray();\\nC# Linq\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Anyone else getting signed integer overflow? Not sure how to fix this with the return type being a vector<int>"
                    },
                    {
                        "username": "Soumya1999",
                        "content": "Why its shows like memory limit exceeded?\\n"
                    },
                    {
                        "username": "Aryan_Arya",
                        "content": "I have a doubt, can we find the minimum absolute element using log(n) time complexity. Our array is given in sorted fashion. Can we use binary search to find the smallest element (in terms of magnitude)?"
                    },
                    {
                        "username": "irfann2022skipq",
                        "content": "Solved it in very easy wasy with O(n) time complexity.\nvar sortedSquares = function(nums) {\n    let squareArray = []\n    for(let i=0;i<nums.length;i++){\n      squareArray.push(nums[i]*nums[i])\n    }\n    return squareArray.sort((a,b)=>{return a-b})\n}  "
                    },
                    {
                        "username": "eliaashraf",
                        "content": "An easy solution to this would be to first find the squares of each element using a pointer and then using a Arrays.sort(array_name) function to solve this prolem.\\n\\nThis is what I have done-\\n `for(int i = 0; i <= nums.length - 1; i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        Arrays.sort(nums);\\n        return nums;`"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "then the time complexity will be 0(n logn).Try to solve this in 0(n).That is the challenge"
                    },
                    {
                        "username": "mkaypl",
                        "content": "Sorting isn\\'t O(n), just in case you missed the follow up note."
                    }
                ]
            },
            {
                "id": 1630715,
                "content": [
                    {
                        "username": "Abhi3091",
                        "content": "\\n        for(in\\nt i = 0; i<nums.length; i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        int left = 0;\\n\\n        int right = nums.length-1;\\n        int index = nums.length-1;\\n        int[] result = new int[nums.length];\\n\\n\\n        while(left <= right){\\n            //16 1 0 9 100\\n            int leftSquare = nums[left];\\n            int rightSquare = nums[right];\\n\\n            //we want to fill up the arrays from right\\n            // the trick is to use new array result\\n            //compare using pointers if right square is large\\n            // update and decrement right index\\n            if(rightSquare > leftSquare){\\n\\n                result[index] = rightSquare;\\n                right--;\\n            //else left index is incremented\\n            }else if(leftSquare > rightSquare){\\n\\n                result[index] = leftSquare;\\n                left++;\\n            //if equal then right value and right index decremented\\n            }else if(leftSquare == rightSquare){\\n\\n                result[index] = rightSquare;\\n                right--;\\n            }\\n\\n            index--;\\n        }\\n\\n        return result;\\n\\nMy java solution beats 100 %"
                    },
                    {
                        "username": "kprat",
                        "content": "Can someone help explain the space and time complexity of this solution:\\n\\nobject Solution {\\n    def sortedSquares(nums: Array[Int]): Array[Int] = {\\n        var left = 0\\n        var right = nums.length\\n        var newArray = new Array[Int](nums.length)\\n        var min = 0\\n        if (nums.length==1)\\n            return Array(sq(nums(0)))\\n        //val status:HashMap[Int,Boolean] = HashMap[Int,Boolean]()\\n        while(left<nums.length-1){\\n            //printArray(nums)\\n            if(Math.abs(nums(left))>Math.abs(nums(left+1)))\\n             swap(left,left+1)\\n            else \\n              {\\n              newArray(left) = sq(nums(left))\\n              newArray(left+1) = sq(nums(left+1))\\n              left+=1\\n              }\\n        }\\n        def swap(i:Int,j:Int) = {\\n            val temp = nums(j)\\n            nums(j) = nums(i)\\n            nums(i) = temp\\n            //newArray(i) = sq(nums(i))\\n            //newArray(j) = sq(nums(j))\\n            if(i>0){\\n            left-=1\\n            }\\n        }\\n\\n        def sq(i:Int):Int = {\\n            i*i\\n        }\\n\\n        def printArray(nums:Array[Int]) = {\\n            println(\"Left:\"+left)\\n            println(\"Array Status\")\\n            nums.foreach(x=> print(\" \" + x + \" \"))\\n            println()\\n        }\\n        newArray\\n    }\\n}"
                    },
                    {
                        "username": "mkaypl",
                        "content": "O(N^2) for time complexity (it\\'s bubble sort)"
                    },
                    {
                        "username": "hoangduy265",
                        "content": "`public class Solution {\n    public int[] SortedSquares(int[] nums) {\n        int[] result = new int[nums.Length];\n        for (int i = 0; i < nums.Length; i++)\n        {\n            if (nums[i] < 0) nums[i] = -nums[i];\n            result[i] = nums[i] * nums[i];\n        }\n        Array.Sort(result);\n        return result;\n    }\n}`"
                    },
                    {
                        "username": "AKUTOTA_SANJAY",
                        "content": "  vector<int> sortedSquares(vector<int>& nums) {\n        vector<int> v;\n        int pi=0,ni,k,l;\n        while(nums[pi]<0)\n        {\n            pi++;\n        }      \n        k=pi;\n        ni=pi-1;\n        for(int k=0;k<nums.size();k++)\n        {\n            nums[k]=nums[k]*nums[k];\n        }\n\n            if(ni==-1)\n            {\n                return nums;\n            }\n          else\n          {\n        while(k<nums.size() and ni>=0)\n        {\n            if(nums[k]<nums[ni])\n            {\n                 \n                v.push_back(nums[k]);\n                k++;\n               \n            }\n            else\n            {\n                 v.push_back(nums[ni]);\n                 ni--;\n            }  \n\n            }\n    }\n        \n        \n        for( ;ni>=0;ni--)\n        {\n            v.push_back(nums[ni]);\n        }\n\n        for(;k<nums.size();k++)\n        {\n             v.push_back(nums[k]);\n        }\n\n     return v;\n    }\n\n\nGetting this error plz help?\n\n=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000514 at pc 0x000000345f9b bp 0x7fffa113dd10 sp 0x7fffa113dd08\nREAD of size 4 at 0x602000000514 thread T0\n    #2 0x7f5544f740b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000514 is located 0 bytes to the right of 4-byte region [0x602000000510,0x602000000514)\nallocated by thread T0 here:\n    #6 0x7f5544f740b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n=>0x0c047fff80a0: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING"
                    },
                    {
                        "username": "Ahmed777Khalil",
                        "content": "  return nums.Select(x => x * x ).OrderBy(x=> x).ToArray();\\nC# Linq\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Anyone else getting signed integer overflow? Not sure how to fix this with the return type being a vector<int>"
                    },
                    {
                        "username": "Soumya1999",
                        "content": "Why its shows like memory limit exceeded?\\n"
                    },
                    {
                        "username": "Aryan_Arya",
                        "content": "I have a doubt, can we find the minimum absolute element using log(n) time complexity. Our array is given in sorted fashion. Can we use binary search to find the smallest element (in terms of magnitude)?"
                    },
                    {
                        "username": "irfann2022skipq",
                        "content": "Solved it in very easy wasy with O(n) time complexity.\nvar sortedSquares = function(nums) {\n    let squareArray = []\n    for(let i=0;i<nums.length;i++){\n      squareArray.push(nums[i]*nums[i])\n    }\n    return squareArray.sort((a,b)=>{return a-b})\n}  "
                    },
                    {
                        "username": "eliaashraf",
                        "content": "An easy solution to this would be to first find the squares of each element using a pointer and then using a Arrays.sort(array_name) function to solve this prolem.\\n\\nThis is what I have done-\\n `for(int i = 0; i <= nums.length - 1; i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        Arrays.sort(nums);\\n        return nums;`"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "then the time complexity will be 0(n logn).Try to solve this in 0(n).That is the challenge"
                    },
                    {
                        "username": "mkaypl",
                        "content": "Sorting isn\\'t O(n), just in case you missed the follow up note."
                    }
                ]
            },
            {
                "id": 1749808,
                "content": [
                    {
                        "username": "Abhi3091",
                        "content": "\\n        for(in\\nt i = 0; i<nums.length; i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        int left = 0;\\n\\n        int right = nums.length-1;\\n        int index = nums.length-1;\\n        int[] result = new int[nums.length];\\n\\n\\n        while(left <= right){\\n            //16 1 0 9 100\\n            int leftSquare = nums[left];\\n            int rightSquare = nums[right];\\n\\n            //we want to fill up the arrays from right\\n            // the trick is to use new array result\\n            //compare using pointers if right square is large\\n            // update and decrement right index\\n            if(rightSquare > leftSquare){\\n\\n                result[index] = rightSquare;\\n                right--;\\n            //else left index is incremented\\n            }else if(leftSquare > rightSquare){\\n\\n                result[index] = leftSquare;\\n                left++;\\n            //if equal then right value and right index decremented\\n            }else if(leftSquare == rightSquare){\\n\\n                result[index] = rightSquare;\\n                right--;\\n            }\\n\\n            index--;\\n        }\\n\\n        return result;\\n\\nMy java solution beats 100 %"
                    },
                    {
                        "username": "kprat",
                        "content": "Can someone help explain the space and time complexity of this solution:\\n\\nobject Solution {\\n    def sortedSquares(nums: Array[Int]): Array[Int] = {\\n        var left = 0\\n        var right = nums.length\\n        var newArray = new Array[Int](nums.length)\\n        var min = 0\\n        if (nums.length==1)\\n            return Array(sq(nums(0)))\\n        //val status:HashMap[Int,Boolean] = HashMap[Int,Boolean]()\\n        while(left<nums.length-1){\\n            //printArray(nums)\\n            if(Math.abs(nums(left))>Math.abs(nums(left+1)))\\n             swap(left,left+1)\\n            else \\n              {\\n              newArray(left) = sq(nums(left))\\n              newArray(left+1) = sq(nums(left+1))\\n              left+=1\\n              }\\n        }\\n        def swap(i:Int,j:Int) = {\\n            val temp = nums(j)\\n            nums(j) = nums(i)\\n            nums(i) = temp\\n            //newArray(i) = sq(nums(i))\\n            //newArray(j) = sq(nums(j))\\n            if(i>0){\\n            left-=1\\n            }\\n        }\\n\\n        def sq(i:Int):Int = {\\n            i*i\\n        }\\n\\n        def printArray(nums:Array[Int]) = {\\n            println(\"Left:\"+left)\\n            println(\"Array Status\")\\n            nums.foreach(x=> print(\" \" + x + \" \"))\\n            println()\\n        }\\n        newArray\\n    }\\n}"
                    },
                    {
                        "username": "mkaypl",
                        "content": "O(N^2) for time complexity (it\\'s bubble sort)"
                    },
                    {
                        "username": "hoangduy265",
                        "content": "`public class Solution {\n    public int[] SortedSquares(int[] nums) {\n        int[] result = new int[nums.Length];\n        for (int i = 0; i < nums.Length; i++)\n        {\n            if (nums[i] < 0) nums[i] = -nums[i];\n            result[i] = nums[i] * nums[i];\n        }\n        Array.Sort(result);\n        return result;\n    }\n}`"
                    },
                    {
                        "username": "AKUTOTA_SANJAY",
                        "content": "  vector<int> sortedSquares(vector<int>& nums) {\n        vector<int> v;\n        int pi=0,ni,k,l;\n        while(nums[pi]<0)\n        {\n            pi++;\n        }      \n        k=pi;\n        ni=pi-1;\n        for(int k=0;k<nums.size();k++)\n        {\n            nums[k]=nums[k]*nums[k];\n        }\n\n            if(ni==-1)\n            {\n                return nums;\n            }\n          else\n          {\n        while(k<nums.size() and ni>=0)\n        {\n            if(nums[k]<nums[ni])\n            {\n                 \n                v.push_back(nums[k]);\n                k++;\n               \n            }\n            else\n            {\n                 v.push_back(nums[ni]);\n                 ni--;\n            }  \n\n            }\n    }\n        \n        \n        for( ;ni>=0;ni--)\n        {\n            v.push_back(nums[ni]);\n        }\n\n        for(;k<nums.size();k++)\n        {\n             v.push_back(nums[k]);\n        }\n\n     return v;\n    }\n\n\nGetting this error plz help?\n\n=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000514 at pc 0x000000345f9b bp 0x7fffa113dd10 sp 0x7fffa113dd08\nREAD of size 4 at 0x602000000514 thread T0\n    #2 0x7f5544f740b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000514 is located 0 bytes to the right of 4-byte region [0x602000000510,0x602000000514)\nallocated by thread T0 here:\n    #6 0x7f5544f740b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n=>0x0c047fff80a0: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING"
                    },
                    {
                        "username": "Ahmed777Khalil",
                        "content": "  return nums.Select(x => x * x ).OrderBy(x=> x).ToArray();\\nC# Linq\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Anyone else getting signed integer overflow? Not sure how to fix this with the return type being a vector<int>"
                    },
                    {
                        "username": "Soumya1999",
                        "content": "Why its shows like memory limit exceeded?\\n"
                    },
                    {
                        "username": "Aryan_Arya",
                        "content": "I have a doubt, can we find the minimum absolute element using log(n) time complexity. Our array is given in sorted fashion. Can we use binary search to find the smallest element (in terms of magnitude)?"
                    },
                    {
                        "username": "irfann2022skipq",
                        "content": "Solved it in very easy wasy with O(n) time complexity.\nvar sortedSquares = function(nums) {\n    let squareArray = []\n    for(let i=0;i<nums.length;i++){\n      squareArray.push(nums[i]*nums[i])\n    }\n    return squareArray.sort((a,b)=>{return a-b})\n}  "
                    },
                    {
                        "username": "eliaashraf",
                        "content": "An easy solution to this would be to first find the squares of each element using a pointer and then using a Arrays.sort(array_name) function to solve this prolem.\\n\\nThis is what I have done-\\n `for(int i = 0; i <= nums.length - 1; i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        Arrays.sort(nums);\\n        return nums;`"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "then the time complexity will be 0(n logn).Try to solve this in 0(n).That is the challenge"
                    },
                    {
                        "username": "mkaypl",
                        "content": "Sorting isn\\'t O(n), just in case you missed the follow up note."
                    }
                ]
            }
        ]
    },
    {
        "title": "Constrained Subsequence Sum",
        "question_content": "<p>Given an integer array <code>nums</code> and an integer <code>k</code>, return the maximum sum of a <strong>non-empty</strong> subsequence of that array such that for every two <strong>consecutive</strong> integers in the subsequence, <code>nums[i]</code> and <code>nums[j]</code>, where <code>i &lt; j</code>, the condition <code>j - i &lt;= k</code> is satisfied.</p>\n\n<p>A <em>subsequence</em> of an array is obtained by deleting some number of elements (can be zero) from the array, leaving the remaining elements in their original order.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [10,2,-10,5,20], k = 2\n<strong>Output:</strong> 37\n<b>Explanation:</b> The subsequence is [10, 2, 5, 20].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-1,-2,-3], k = 1\n<strong>Output:</strong> -1\n<b>Explanation:</b> The subsequence must be non-empty, so we choose the largest number.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [10,-2,-10,-5,20], k = 2\n<strong>Output:</strong> 23\n<b>Explanation:</b> The subsequence is [10, -2, -5, 20].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 597751,
                "title": "java-c-python-o-n-decreasing-deque",
                "content": "## **Intuition**\\nWe need to know the maximum in the window of size `k`.\\nUse `heqp` will be `O(NlogN)`\\nUse `TreeMap` will be `O(NlogK)`\\nUse `deque` will be `O(N)`\\n<br>\\n\\n## **Prepare**\\nHow about google \"sliding window maximum\",\\nand make sure you understand 239. Sliding Window Maximum\\nDone. (If not done, continue read)\\n<br>\\n\\n## **Explanation**\\nUpdate `res[i]`,\\nwhere `res[i]` means the maximum result you can get if the last element is `A[i]`.\\n\\nI directly modify on the input `A`,\\nif you don\\'t like it,\\nuse a copy of `A`\\n\\nKeep a decreasing deque `q`,\\n`deque[0]` is the maximum result in the last element of result.\\n\\nIf `deque[0] > 0`. we add it to `A[i]`\\n\\nIn the end, we return the maximum `res`.\\n<br>\\n\\n## **Complexity**\\nBecause all element are pushed and popped at most once.\\nTime `O(N)`\\n\\nBecause at most O(K) elements in the deque.\\nSpace `O(K)`\\n<br>\\n\\n## **More**\\nDeque can be widely used in all bfs problems.\\nFor more complecated usage,\\nI recall this problem\\n[862. Shortest Subarray with Sum at Least K](https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/discuss/143726/)\\n<br>\\n\\n**Java:**\\n```java\\n    public int constrainedSubsetSum(int[] A, int k) {\\n        int res = A[0];\\n        Deque<Integer> q = new ArrayDeque<>();\\n        for (int i = 0; i < A.length; ++i) {\\n            A[i] += !q.isEmpty() ? q.peek() : 0;\\n            res = Math.max(res, A[i]);\\n            while (!q.isEmpty() && A[i] > q.peekLast())\\n                q.pollLast();\\n            if (A[i] > 0)\\n                q.offer(A[i]);\\n            if (i >= k && !q.isEmpty() && q.peek() == A[i - k])\\n                q.poll();\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    int constrainedSubsetSum(vector<int>& A, int k) {\\n        deque<int> q;\\n        int res = A[0];\\n        for (int i = 0; i < A.size(); ++i) {\\n            A[i] += q.size() ? q.front() : 0;\\n            res = max(res, A[i]);\\n            while (q.size() && A[i] > q.back())\\n                q.pop_back();\\n            if (A[i] > 0)\\n                q.push_back(A[i]);\\n            if (i >= k && q.size() && q.front() == A[i - k])\\n                q.pop_front();\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python:**\\n```py\\n    def constrainedSubsetSum(self, A, k):\\n        deque = collections.deque()\\n        for i in xrange(len(A)):\\n            A[i] += deque[0] if deque else 0\\n            while len(deque) and A[i] > deque[-1]:\\n                deque.pop()\\n            if A[i] > 0:\\n                deque.append(A[i])\\n            if i >= k and deque and deque[0] == A[i - k]:\\n                deque.popleft()\\n        return max(A)\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int constrainedSubsetSum(int[] A, int k) {\\n        int res = A[0];\\n        Deque<Integer> q = new ArrayDeque<>();\\n        for (int i = 0; i < A.length; ++i) {\\n            A[i] += !q.isEmpty() ? q.peek() : 0;\\n            res = Math.max(res, A[i]);\\n            while (!q.isEmpty() && A[i] > q.peekLast())\\n                q.pollLast();\\n            if (A[i] > 0)\\n                q.offer(A[i]);\\n            if (i >= k && !q.isEmpty() && q.peek() == A[i - k])\\n                q.poll();\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int constrainedSubsetSum(vector<int>& A, int k) {\\n        deque<int> q;\\n        int res = A[0];\\n        for (int i = 0; i < A.size(); ++i) {\\n            A[i] += q.size() ? q.front() : 0;\\n            res = max(res, A[i]);\\n            while (q.size() && A[i] > q.back())\\n                q.pop_back();\\n            if (A[i] > 0)\\n                q.push_back(A[i]);\\n            if (i >= k && q.size() && q.front() == A[i - k])\\n                q.pop_front();\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def constrainedSubsetSum(self, A, k):\\n        deque = collections.deque()\\n        for i in xrange(len(A)):\\n            A[i] += deque[0] if deque else 0\\n            while len(deque) and A[i] > deque[-1]:\\n                deque.pop()\\n            if A[i] > 0:\\n                deque.append(A[i])\\n            if i >= k and deque and deque[0] == A[i - k]:\\n                deque.popleft()\\n        return max(A)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 597693,
                "title": "python-c-dp-with-decreasing-deque",
                "content": "**Idea**\\nThis is a typical knapsack problem. we maintain an array `dp`, where `dp[i]` is the maximum sum we can get from nums[:i] and nums[i] is guaranteed to be included.\\n\\n- Base case: `dp[0] = nums[0]`\\n- state transition: `dp[i] = max(dp[i - k], dp[i-k+1], ..., dp[i - 1], 0) + x`\\n    - NOTE that x can be a fresh start when all the previous dp are negative.\\n\\nThis algorithm is only \\x10`O(n * k)`, we need to improve it to `O(n)` because both `k` and `n` can be 10^5.\\n\\nThe Idea is straight-forward, we can maintain an non-increasing deque `decrease` that records the maximum value among `dp[i - k], dp[i-k+1], ..., dp[i - 1]`. When encountering a new value `x`, we only record it in `decrease` if `x > decrease[decrease.size - 1]`. Thus the first element in `decrease` will always be the largest value we want.\\n\\n**Complexity**\\nTime: `O(n)`\\nSpace: `O(n)`\\n\\n**Python**\\n```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        dp = nums[:1]\\n        decrease = collections.deque(dp)\\n        for i, x in enumerate(nums[1:], 1):\\n            if i > k and decrease[0] == dp[i - k - 1]:\\n                decrease.popleft()\\n            tmp = max(x, decrease[0] + x)\\n            dp += tmp,\\n            while decrease and decrease[-1] < tmp:\\n                decrease.pop()\\n            decrease += tmp,                \\n        return max(dp)  \\n```\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        vector<int> dp {nums[0]};\\n        deque<int> decrease {nums[0]};\\n        int res = nums[0];\\n        \\n        for (int i=1; i<nums.size(); i++) {\\n            if (i > k && decrease[0] == dp[i - k - 1])\\n                decrease.pop_front();\\n            int tmp = max(nums[i], decrease[0] + nums[i]);\\n            dp.push_back(tmp);\\n            while (!decrease.empty() && decrease.back() < tmp)\\n                decrease.pop_back();\\n            decrease.push_back(tmp);\\n            \\n            res = max(res, tmp);\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        dp = nums[:1]\\n        decrease = collections.deque(dp)\\n        for i, x in enumerate(nums[1:], 1):\\n            if i > k and decrease[0] == dp[i - k - 1]:\\n                decrease.popleft()\\n            tmp = max(x, decrease[0] + x)\\n            dp += tmp,\\n            while decrease and decrease[-1] < tmp:\\n                decrease.pop()\\n            decrease += tmp,                \\n        return max(dp)  \\n```\n```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        vector<int> dp {nums[0]};\\n        deque<int> decrease {nums[0]};\\n        int res = nums[0];\\n        \\n        for (int i=1; i<nums.size(); i++) {\\n            if (i > k && decrease[0] == dp[i - k - 1])\\n                decrease.pop_front();\\n            int tmp = max(nums[i], decrease[0] + nums[i]);\\n            dp.push_back(tmp);\\n            while (!decrease.empty() && decrease.back() < tmp)\\n                decrease.pop_back();\\n            decrease.push_back(tmp);\\n            \\n            res = max(res, tmp);\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 605822,
                "title": "java-decreasing-monotonic-queue-clean-code-o-n",
                "content": "**Idea**\\ndp[i] is the max sum we can have from A[:i] when A[i] has been chosen.\\n\\n**\\u2714\\uFE0F Solution 1: DP Straight forward - TLE**\\n```java\\nclass Solution {\\n    public int constrainedSubsetSum(int[] arr, int k) {\\n        int n = arr.length;\\n        int[] dp = new int[n];\\n        int ans = Integer.MIN_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            int max = 0;\\n            for (int j = Math.max(i - k, 0); j < i; j++) { // choose the max element in latest k elements, it\\'s in range [i-k, i-1]\\n                max = Math.max(max, dp[j]);\\n            }\\n            dp[i] = arr[i] + max;\\n            ans = Math.max(ans, dp[i]);\\n        }\\n        return ans;\\n    }\\n}\\n```\\nComplexity:\\n- Time: `O(N*K)`\\n- Space: `O(N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: DP + Decreasing Monotonic Queue**\\nWe need to get the max element in k latest elements in `O(1)` by using Decreasing Monotonic Queue, the same with this problem: [239. Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/discuss/598751)\\n```java\\nclass Solution {\\n    public int constrainedSubsetSum(int[] arr, int k) {\\n        int n = arr.length;\\n        int[] dp = new int[n];\\n        Deque<Integer> deque = new LinkedList<>();\\n        int ans = Integer.MIN_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            int max = Math.max(0, deque.isEmpty() ? 0 : dp[deque.peekFirst()]);\\n            dp[i] = arr[i] + max;\\n            ans = Math.max(ans, dp[i]);\\n            while (!deque.isEmpty() && dp[i] >= dp[deque.peekLast()]) { // If dp[i] >= deque.peekLast() -> Can discard the tail since it\\'s useless\\n                deque.pollLast();\\n            }\\n            deque.addLast(i);\\n            if (i - deque.peekFirst() + 1 > k) { // remove the last element of range k\\n                deque.removeFirst();\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\nComplexity:\\n- Time: `O(N)`\\n- Space: `O(N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 3: DP + Decreasing Monotonic Queue + Optimized Space**\\nUse `arr` as `dp` instead of create new one.\\n```java\\nclass Solution {\\n    public int constrainedSubsetSum(int[] arr, int k) {\\n        int n = arr.length;\\n        Deque<Integer> deque = new LinkedList<>();\\n        int ans = Integer.MIN_VALUE;\\n        for (int i = 0; i < n; i++) {\\n\\t\\t\\tint max = Math.max(0, deque.isEmpty() ? 0 : arr[deque.peekFirst()]);\\n            arr[i] += max;\\n            ans = Math.max(ans, arr[i]);\\n            while (!deque.isEmpty() && arr[i] >= arr[deque.peekLast()]) { // If dp[i] >= deque.peekLast() -> Can discard the tail since it\\'s useless\\n                deque.pollLast();\\n            }\\n            deque.addLast(i);\\n            if (i - deque.peekFirst() + 1 > k) { // remove the last element of range k\\n                deque.removeFirst();\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\nComplexity:\\n- Time: `O(N)`\\n- Space: `O(K)`",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int constrainedSubsetSum(int[] arr, int k) {\\n        int n = arr.length;\\n        int[] dp = new int[n];\\n        int ans = Integer.MIN_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            int max = 0;\\n            for (int j = Math.max(i - k, 0); j < i; j++) { // choose the max element in latest k elements, it\\'s in range [i-k, i-1]\\n                max = Math.max(max, dp[j]);\\n            }\\n            dp[i] = arr[i] + max;\\n            ans = Math.max(ans, dp[i]);\\n        }\\n        return ans;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int constrainedSubsetSum(int[] arr, int k) {\\n        int n = arr.length;\\n        int[] dp = new int[n];\\n        Deque<Integer> deque = new LinkedList<>();\\n        int ans = Integer.MIN_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            int max = Math.max(0, deque.isEmpty() ? 0 : dp[deque.peekFirst()]);\\n            dp[i] = arr[i] + max;\\n            ans = Math.max(ans, dp[i]);\\n            while (!deque.isEmpty() && dp[i] >= dp[deque.peekLast()]) { // If dp[i] >= deque.peekLast() -> Can discard the tail since it\\'s useless\\n                deque.pollLast();\\n            }\\n            deque.addLast(i);\\n            if (i - deque.peekFirst() + 1 > k) { // remove the last element of range k\\n                deque.removeFirst();\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int constrainedSubsetSum(int[] arr, int k) {\\n        int n = arr.length;\\n        Deque<Integer> deque = new LinkedList<>();\\n        int ans = Integer.MIN_VALUE;\\n        for (int i = 0; i < n; i++) {\\n\\t\\t\\tint max = Math.max(0, deque.isEmpty() ? 0 : arr[deque.peekFirst()]);\\n            arr[i] += max;\\n            ans = Math.max(ans, arr[i]);\\n            while (!deque.isEmpty() && arr[i] >= arr[deque.peekLast()]) { // If dp[i] >= deque.peekLast() -> Can discard the tail since it\\'s useless\\n                deque.pollLast();\\n            }\\n            deque.addLast(i);\\n            if (i - deque.peekFirst() + 1 > k) { // remove the last element of range k\\n                deque.removeFirst();\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 597744,
                "title": "python-o-n-monoqueue",
                "content": "Consider a typical (but inefficient) DP: we have dp[i] = the max sum of some non-empty subset of nums[..i] that contains nums[i].  The final answer is max(dp).\\n\\nIn this dp, we have the recurrence relation `dp[i+K] = nums[i+K] + max(0, dp[i], dp[i+1], ..., dp[i+K-1])`.  We can use a monoqueue (a queue that supports a O(1) max operation) to efficiently perform this DP - it stores the result of max(...) and we update it by eg. adding dp[i+K+1] and popping dp[i].\\n\\n```\\nclass Monoqueue(collections.deque):\\n    def enqueue(self, val):\\n        count = 1\\n        while self and self[-1][0] < val:\\n            count += self.pop()[1]\\n        self.append([val, count])\\n\\n    def dequeue(self):\\n        ans = self.max()\\n        self[0][1] -= 1\\n        if self[0][1] <= 0:\\n            self.popleft()\\n        return ans\\n\\n    def max(self):\\n        return self[0][0] if self else 0\\n\\n\\nclass Solution(object):\\n    def constrainedSubsetSum(self, A, K):\\n        monoq = Monoqueue()\\n        ans = max(A)\\n        for i, x in enumerate(A):\\n            monoq.enqueue(x + max(0, monoq.max()))\\n            if i >= K:\\n                ans = max(ans, monoq.dequeue())\\n        return max(ans, monoq.dequeue())\\n```",
                "solutionTags": [],
                "code": "```\\nclass Monoqueue(collections.deque):\\n    def enqueue(self, val):\\n        count = 1\\n        while self and self[-1][0] < val:\\n            count += self.pop()[1]\\n        self.append([val, count])\\n\\n    def dequeue(self):\\n        ans = self.max()\\n        self[0][1] -= 1\\n        if self[0][1] <= 0:\\n            self.popleft()\\n        return ans\\n\\n    def max(self):\\n        return self[0][0] if self else 0\\n\\n\\nclass Solution(object):\\n    def constrainedSubsetSum(self, A, K):\\n        monoq = Monoqueue()\\n        ans = max(A)\\n        for i, x in enumerate(A):\\n            monoq.enqueue(x + max(0, monoq.max()))\\n            if i >= K:\\n                ans = max(ans, monoq.dequeue())\\n        return max(ans, monoq.dequeue())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1402185,
                "title": "c-4-ways-tle-tle-accepted-accepted",
                "content": "```\\n//Approach-1 (Recursion+Memo) - TLE (18 / 25 test cases passed)\\n/*\\n\\tYou should always start from an approach like this for \\n\\tany DP problem.\\n*/\\nclass Solution {\\npublic:\\n    int k, n;\\n    unordered_map<string, int> mp;\\n    int solve(vector<int>& nums, int idx, int lastIdx) {\\n        if(idx >= n) return 0;\\n        string key = to_string(idx) + \"_\" + to_string(lastIdx);\\n        if(mp.count(key))\\n            return mp[key];\\n        \\n        if(lastIdx == -1) {\\n            int taken    = nums[idx] + solve(nums, idx+1, idx);\\n            int notTaken = solve(nums, idx+1, lastIdx);\\n            return mp[key] = max(taken, notTaken);\\n        } else if(idx-lastIdx <= k) {\\n            int taken    = nums[idx] + solve(nums, idx+1, idx);\\n            int notTaken = solve(nums, idx+1, lastIdx);\\n            return mp[key] = max(taken, notTaken);\\n        }\\n        \\n        return mp[key] = 0;\\n    }\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        this->n = nums.size();\\n        this->k = k;\\n        int val = solve(nums, 0, -1);\\n        mp.clear();\\n        \\n        if(val == 0)\\n            return *max_element(begin(nums), end(nums));\\n        return val;\\n    }\\n};\\n```\\n\\n```\\n//Approach-2 (Bottom Up DP) - TLE (20 / 25 test cases passed)\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        \\n        vector<int> t(n, 0);\\n        for(int i = 0; i<n; i++)\\n            t[i] = nums[i];\\n        \\n        int maxR = t[0];\\n        \\n        for(int i = 1; i<n; i++) {\\n            for(int j = i-1; i-j <= k && j >= 0; j--) {\\n                t[i] = max(t[i], nums[i] + t[j]);\\n            }\\n            \\n            maxR = max(maxR, t[i]);\\n        }\\n        \\n        \\n        return maxR;\\n    }\\n};\\n```\\n\\n```\\n//Approach-3 (Using Priority_queue) Accepted\\n/*\\n\\tBasically in approach-2, you want the maximum value in the range of [i, i-k]\\n\\tWhy not store them in max heap and access them in one go\\n*/\\n\\nclass Solution {\\npublic:\\n    typedef pair<int, int> P;\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        \\n        vector<int> t(n, 0);\\n        t = nums;\\n        priority_queue<P, vector<P>> pq;\\n        pq.push({t[0], 0});\\n        \\n        int maxR = t[0];\\n        \\n        for(int i = 1; i<n; i++) {\\n            \\n            while(!pq.empty() && pq.top().second < i - k)\\n                pq.pop();\\n            \\n            t[i] = max(t[i], nums[i] + pq.top().first);\\n            pq.push({t[i], i});\\n            \\n            maxR = max(maxR, t[i]);\\n        }\\n        \\n        \\n        return maxR;\\n    }\\n};\\n```\\n\\n```\\n//Approach-4 (Using monotonic decreasing deque) Accepted\\n/*\\n\\t\\tThis is similar to approach-3 it\\'s just we use deque and maintain decreasing order.\\n\\t\\tNOTE : Approach-3 and Approach-4 are used to solve \"Sliding Window Maximum\" also with similar approach (Leetcode-239)\\n\\t\\tLink : https://github.com/MAZHARMIK/Interview_DS_Algo/blob/master/Sliding%20Window/Sliding%20Window%20Maximum.cpp\\n*/\\n\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        deque<int> deq;\\n        vector<int> t(nums);\\n        int maxR = t[0];\\n        \\n        for(int i = 0; i<n; i++) {\\n            \\n            while(!deq.empty() && deq.front() < i-k)\\n                deq.pop_front();\\n            \\n            if(!deq.empty())\\n                t[i] = max(t[i], nums[i] + t[deq.front()]);\\n            \\n            //we maintain the deque in descending order\\n            while(!deq.empty() && t[i] >= t[deq.back()])\\n                deq.pop_back();\\n            \\n            deq.push_back(i);\\n            \\n            maxR = max(maxR, t[i]);\\n        }\\n        \\n        return maxR;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Approach-1 (Recursion+Memo) - TLE (18 / 25 test cases passed)\\n/*\\n\\tYou should always start from an approach like this for \\n\\tany DP problem.\\n*/\\nclass Solution {\\npublic:\\n    int k, n;\\n    unordered_map<string, int> mp;\\n    int solve(vector<int>& nums, int idx, int lastIdx) {\\n        if(idx >= n) return 0;\\n        string key = to_string(idx) + \"_\" + to_string(lastIdx);\\n        if(mp.count(key))\\n            return mp[key];\\n        \\n        if(lastIdx == -1) {\\n            int taken    = nums[idx] + solve(nums, idx+1, idx);\\n            int notTaken = solve(nums, idx+1, lastIdx);\\n            return mp[key] = max(taken, notTaken);\\n        } else if(idx-lastIdx <= k) {\\n            int taken    = nums[idx] + solve(nums, idx+1, idx);\\n            int notTaken = solve(nums, idx+1, lastIdx);\\n            return mp[key] = max(taken, notTaken);\\n        }\\n        \\n        return mp[key] = 0;\\n    }\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        this->n = nums.size();\\n        this->k = k;\\n        int val = solve(nums, 0, -1);\\n        mp.clear();\\n        \\n        if(val == 0)\\n            return *max_element(begin(nums), end(nums));\\n        return val;\\n    }\\n};\\n```\n```\\n//Approach-2 (Bottom Up DP) - TLE (20 / 25 test cases passed)\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        \\n        vector<int> t(n, 0);\\n        for(int i = 0; i<n; i++)\\n            t[i] = nums[i];\\n        \\n        int maxR = t[0];\\n        \\n        for(int i = 1; i<n; i++) {\\n            for(int j = i-1; i-j <= k && j >= 0; j--) {\\n                t[i] = max(t[i], nums[i] + t[j]);\\n            }\\n            \\n            maxR = max(maxR, t[i]);\\n        }\\n        \\n        \\n        return maxR;\\n    }\\n};\\n```\n```\\n//Approach-3 (Using Priority_queue) Accepted\\n/*\\n\\tBasically in approach-2, you want the maximum value in the range of [i, i-k]\\n\\tWhy not store them in max heap and access them in one go\\n*/\\n\\nclass Solution {\\npublic:\\n    typedef pair<int, int> P;\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        \\n        vector<int> t(n, 0);\\n        t = nums;\\n        priority_queue<P, vector<P>> pq;\\n        pq.push({t[0], 0});\\n        \\n        int maxR = t[0];\\n        \\n        for(int i = 1; i<n; i++) {\\n            \\n            while(!pq.empty() && pq.top().second < i - k)\\n                pq.pop();\\n            \\n            t[i] = max(t[i], nums[i] + pq.top().first);\\n            pq.push({t[i], i});\\n            \\n            maxR = max(maxR, t[i]);\\n        }\\n        \\n        \\n        return maxR;\\n    }\\n};\\n```\n```\\n//Approach-4 (Using monotonic decreasing deque) Accepted\\n/*\\n\\t\\tThis is similar to approach-3 it\\'s just we use deque and maintain decreasing order.\\n\\t\\tNOTE : Approach-3 and Approach-4 are used to solve \"Sliding Window Maximum\" also with similar approach (Leetcode-239)\\n\\t\\tLink : https://github.com/MAZHARMIK/Interview_DS_Algo/blob/master/Sliding%20Window/Sliding%20Window%20Maximum.cpp\\n*/\\n\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        deque<int> deq;\\n        vector<int> t(nums);\\n        int maxR = t[0];\\n        \\n        for(int i = 0; i<n; i++) {\\n            \\n            while(!deq.empty() && deq.front() < i-k)\\n                deq.pop_front();\\n            \\n            if(!deq.empty())\\n                t[i] = max(t[i], nums[i] + t[deq.front()]);\\n            \\n            //we maintain the deque in descending order\\n            while(!deq.empty() && t[i] >= t[deq.back()])\\n                deq.pop_back();\\n            \\n            deq.push_back(i);\\n            \\n            maxR = max(maxR, t[i]);\\n        }\\n        \\n        return maxR;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 597714,
                "title": "python-simple-explanation-heap-solution",
                "content": "Recommended reading: https://en.wikipedia.org/wiki/Heap_(data_structure)\\n\\nAt first glance, this seems easy. All you need to do is use dynamic programming to keep track of the largest subset sum ending at, and including index i for 0 <= i < len(nums) (we\\'ll call this dp[i]), and return the maximum value out of them. However, calculating the best subset sum for every i requires looking back at previous value dp[j] for i - k <= j < i. This is no good, because if k is too big, this solution is basically O(N**2). That\\'ll give you a TLE.\\n\\nInstead of that, maintain a max heap of the values that would be in dp. In this heap, include the index that this value corresponds to. So, instead of an array dp, you\\'d have a heap filled with (dp[i], i). At each iteration \\'i\\', make sure the current maximum is within k indices from i. If it isn\\'t, pop from the heap until it is.\\n\\nNote that the max heap functions of heapq are slow for some reason, so I instead keep a min heap and multiply each dp[i] by -1 to compensate for that. I got a TLE when I tried using the max heap functions for some reason! Isn\\'t that weird?\\n\\n```\\ndef constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n\\timport heapq\\n\\n\\theap = [(-nums[0], 0)]\\n\\tret = nums[0]\\n\\n\\tfor i in range(1, len(nums)):\\n\\t\\tremove = i - k - 1\\n\\t\\twhile remove >= heap[0][1]:\\n\\t\\t\\theapq.heappop(heap)\\n\\n\\t\\tcur = max(0, -heap[0][0]) + nums[i]\\n\\t\\tret = max(ret, cur)\\n\\t\\theapq.heappush(heap, (-cur, i))\\n\\n\\treturn ret\\n```",
                "solutionTags": [],
                "code": "```\\ndef constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n\\timport heapq\\n\\n\\theap = [(-nums[0], 0)]\\n\\tret = nums[0]\\n\\n\\tfor i in range(1, len(nums)):\\n\\t\\tremove = i - k - 1\\n\\t\\twhile remove >= heap[0][1]:\\n\\t\\t\\theapq.heappop(heap)\\n\\n\\t\\tcur = max(0, -heap[0][0]) + nums[i]\\n\\t\\tret = max(ret, cur)\\n\\t\\theapq.heappush(heap, (-cur, i))\\n\\n\\treturn ret\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 597767,
                "title": "cpp-8-line-dp-solution-easy-to-understand",
                "content": "This is a O(N log N) solution.\\n\\nNot so fast, but easy to understand.\\n\\n```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        // dp[i] is the max subset sum which ENDING AT i\\n        vector<int> dp(nums.size());\\n        // window contains dp[i - k:i] and a additional 0.\\n        multiset<int> window = {0};\\n        \\n        for(int i = 0; i < nums.size(); i++) {\\n            // dp[i] = nums[i] + max(0, dp[i - k: i])\\n            dp[i] = nums[i] + *window.rbegin();\\n            // update window.\\n            window.insert(dp[i]);\\n            if(i >= k) window.erase(window.find(dp[i - k]));\\n        }\\n        \\n        // return max(dp)\\n        return *max_element(dp.begin(), dp.end());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        // dp[i] is the max subset sum which ENDING AT i\\n        vector<int> dp(nums.size());\\n        // window contains dp[i - k:i] and a additional 0.\\n        multiset<int> window = {0};\\n        \\n        for(int i = 0; i < nums.size(); i++) {\\n            // dp[i] = nums[i] + max(0, dp[i - k: i])\\n            dp[i] = nums[i] + *window.rbegin();\\n            // update window.\\n            window.insert(dp[i]);\\n            if(i >= k) window.erase(window.find(dp[i - k]));\\n        }\\n        \\n        // return max(dp)\\n        return *max_element(dp.begin(), dp.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 736798,
                "title": "python-thought-process-recursion-memoization-tabulation-monoqueue",
                "content": "In this post, I\\'ll describe my thought process behind solving this question. I will start with a naive recursive solution and improve it to the optimal O(n) solution using DP + monoqueue.\\n\\n**1. Recursion**\\n\\nLet\\'s say that `nums[j]` is the **last** number in the required subsequence. Since we need to maximize the sum of the numbers in the subsequence, the previous number in the subsequence could be `max(nums[j-1], nums[j-2], ..., nums[j-i], ..., nums[j-k])` where `j-i >= 0`. However, if all `nums[j-1], nums[j-2], ..., nums[j-i], ..., nums[j-k]` are negative, there would be no previous number, as it would lower the required sum.\\n\\nLet `F(j)` denote the maximum sum of the subsequence with `nums[j]` as the last number. Following the idea above, `F(j) = nums[j] + max(0, F(j-1), F(j-2), ..., F(j-i), ... F(j-k))` where `j-i >= 0`. Note that if all of the valid `F(j-1), F(j-2), ..., F(j-i), ... F(j-k)` are negative, we will not choose any of these values because choosing one of them would lower the value of the required sum: hence we have a `0` in the `max` term. Since the solution to this problem is built off of solutions to the subproblems, we formuate a recursive solution.\\n\\nFor each `j` in the range `[0, len(nums)-1]`, inclusive, we will call `F(j)`, i.e, we consider every `j` as a potential last index of the subsequence. The required answer will be the max of all such `F(j)`.\\n\\nNote that this solution can also be formulated in a forward direction instead of going backwards. E.g. `F(i) = nums[i] + max(0, F(i+1), F(i+2), ... F(i+j), ..., F(i+k)` where `i+j < len(nums)` and `F(i)` denotes the maximum sum of the suquence with `nums[i]` as the **first** element. The reason why I chose to go backwards is because it is easier to convert it to an iterative approach as explained later.\\n\\n```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        def helper(j):\\n            if j < 0:\\n                return 0\\n            \\n            max_val = 0\\n            for i in range(1, k+1):\\n                max_val = max(max_val, helper(j-i))\\n            \\n            return nums[j]+max_val\\n        \\n        ans = float(\"-inf\")\\n        for i in range(len(nums)):\\n            ans = max(ans, helper(i))\\n        return ans\\n```\\n\\n**Time complexity: O(k^n) (TLE)**\\n**Space complexity: O(n)**\\n\\nThe recurrence relation is,\\n```\\nF(n) = F(n-1) + F(n-2) + ... + F(n-k)\\n.\\n.\\n.\\nF(0) = 1\\n```\\nIf you draw a recursion tree, it will be a `k-ary` tree with depth `n`, where `n` is the length of `nums`. The time complexity is the number of nodes in this tree, `O(k^n)`. The space complexity is the depth of this tree (recursion stack), `O(n)`.\\n\\n**2. Memoization**\\n\\nThe above solution has multiple calls to `F(j)` with the same `j`. To avoid exponential growth, we can store these intermediate results and retrieve them from memory next time the function is called with the same `j`. This is called Memoization (not Memorization), and it is a way of doing dynamic programming. A really convenient way to do memoization in Python is using the decorator `lru_cache`.\\n\\n```\\nfrom functools import lru_cache\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        @lru_cache(maxsize=None) # add this line to the previous solution\\n        def helper(j):\\n            if j < 0:\\n                return 0\\n            \\n            max_val = 0\\n            for i in range(1, k+1):\\n                max_val = max(max_val, helper(j-i))\\n            \\n            return nums[j]+max_val\\n        \\n        ans = float(\"-inf\")\\n        for i in range(len(nums)):\\n            ans = max(ans, helper(i))\\n        return ans\\n```\\n\\n**Time complexity: O(nk) (TLE)**\\n**Space complexity: O(n)**\\n\\nBy doing memoization, `F(j)` is processed at most once, where `j` is in the range `[0, n-1]`, inclusive. To determine each `F(j)`, we recursively call `F(j-1), F(j-2), ..., F(j-i), ... F(j-k)`. Hence, for each `F(j)`, we do `k` amount of work. Think of it as using a for loop with `k` iterations. Since there are `n` such calls to `F(j)` as described previously, we do `n*k` amount of work overall. Hence, the time complexity is `O(nk)`. The space complexity has two components: recursion stack and the memory used for memoization. Together, they require `2*n` amount of space. Hence the space complexity remains linear, `O(n)`.\\n\\n**3. Tabulation**\\n\\nWe can use an iterative approach for the above solution. Tabulation is another (iterative) way of doing dynamic programming. We create a list called `dp` with size `n` and initialize it with zeros. Here, `dp[j]` represents the maximum sum of the subsequence with `nums[j]` as the last element. Using the same idea described in the above solutions, `dp[j] = nums[j] + max(0, dp[j-1], dp[j-2], ..., dp[j-i], ..., dp[j-k])`, where `j-i >= 0`. To start with, we set `dp[0] = nums[0]`, this is our initial condition. For each `j` in the range `[1, n-1]`, inclusive, we determine `dp[j]`. The final answer is the max of all such `dp[j]`.\\n\\n```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        dp = [0]*len(nums)\\n        dp[0] = nums[0]\\n        ans = dp[0]\\n        for j in range(1, len(nums)):\\n\\t\\t\\t# use max(0, j-k) in the range to keep the index within bounds\\n            for i in reversed(range(max(0, j-k), j)):\\n                dp[j] = max(dp[j], dp[i])\\n            dp[j] += nums[j]\\n            ans = max(ans, dp[j])\\n        return ans\\n```\\n\\n**Time complexity: O(nk) (TLE)**\\n**Space complexity: O(n)**\\n\\nThe time and space complexity is the same as the memoization solution. Perhaps, the time complexity of the memoization solution can be better understood after relating it to this solution. The space complexity is `O(n)` due to the `dp` list. We can modify the code a little and improve it to `O(k)`, since we care only about the previous `k` elements of `dp` at a time. Or we can avoid using a `dp` list and update the `nums` list directly to make it `O(1)`.\\n\\n**4. Tabulation with Monoqueue**\\n\\nTo understand this approach, I highly recommend you to solve [239. Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/) first. In the previous approach, we determine `dp[j]` by finding the maximum of the previous `k` elements of `dp`. The bottleneck of the previous approach is iterating `k` times for each `j` to find this maximum, resulting in `O(nk)` time complexity. This can be avoided by using a monoqueue: a monotonically decreasing (or increasing in some cases) queue. Essentially, we use the sliding window maximum approach on the `dp` list. The gist of this approach is figuring out the following:\\n\\nLet\\'s say we want to determine `dp[j]`. Consider the window `dp[j-k] to dp[j-1]`. There are two indexes in this window, `p` and `q`, where `p` < `q`.\\n1. `nums[p] < nums[q]`. In this case, `nums[p]` is no longer a candidate for the maximum since we have found `nums[q]`, which is greater than `nums[p]`, within the window. So we can discard `nums[p]`.\\n2. `nums[p] >= nums[q]`. In this case, `nums[p]` **is** a candidate for the maximum. But we also need to keep track of `nums[q]` because it might become a candidate later when `p` goes out of the window. Note that index `q` comes after index `p`, therefore, as the window slides forward (while determining `dp[j+1], dp[j+2], ..., dp[n-1]`), we will lose `p` first.\\n\\nFrom the above points, it is evident that we need to keep track of monotonically decreasing numbers.\\n\\nWhile keeping track of such numbers, if the largest number (the first number in this monotonically decreasing list) goes out of the window for a certain `dp[j]`, we need to remove it from the beginning of the list. Hence we use a monoqueue (and not a monostack).\\n\\nThat being said, we maintain a monoqueue while determining each `dp[j]`. For each `j` in the range `[1, n-1]`, inclusive, we check whether the first element of the queue is within the window. If not, then we pop it from the beginning. If yes, then this element is, indeed, the maximum within the window due to the monoqueue property. Thus `dp[j] = nums[j] + max(0, queue[0])`. Now, we add this `dp[j]` to the monoqueue while maintaining its property by removing all the elements less than `dp[j]` from the end of the queue. As before, the final answer is the max of all `dp[j]`.\\n\\nHere is the code:\\n```\\nfrom collections import deque\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        dp = [0]*len(nums)\\n        dp[0] = nums[0]\\n        \\n        ans = dp[0]\\n        \\n\\t\\t# queue holds the index\\n        queue = deque([0])\\n        \\n        for j in range(1, len(nums)):\\n            if queue and queue[0] < j-k:\\n                queue.popleft()\\n            \\n            dp[j] = nums[j] + max(0, dp[queue[0]])\\n            \\n            while queue and dp[queue[-1]] < dp[j]:\\n                queue.pop()\\n            \\n            queue.append(j)\\n            ans = max(ans, dp[j])\\n        \\n        return ans\\n```\\n\\n**Time complexity: O(n)**\\n**Space complexity: O(n)**\\n\\nThis monoqueue takes care of the unnecessary `k` iterations in the previous approach and reduces the time complexity to `O(n)`, since each element is added and popped out of the queue at most once. The space complexity is `O(k)` due to queue and `O(n)` due to the `dp` list. It can be reduced to `O(k)` by directly updating the `nums` list instead of creating a `dp` list.\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        def helper(j):\\n            if j < 0:\\n                return 0\\n            \\n            max_val = 0\\n            for i in range(1, k+1):\\n                max_val = max(max_val, helper(j-i))\\n            \\n            return nums[j]+max_val\\n        \\n        ans = float(\"-inf\")\\n        for i in range(len(nums)):\\n            ans = max(ans, helper(i))\\n        return ans\\n```\n```\\nF(n) = F(n-1) + F(n-2) + ... + F(n-k)\\n.\\n.\\n.\\nF(0) = 1\\n```\n```\\nfrom functools import lru_cache\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        @lru_cache(maxsize=None) # add this line to the previous solution\\n        def helper(j):\\n            if j < 0:\\n                return 0\\n            \\n            max_val = 0\\n            for i in range(1, k+1):\\n                max_val = max(max_val, helper(j-i))\\n            \\n            return nums[j]+max_val\\n        \\n        ans = float(\"-inf\")\\n        for i in range(len(nums)):\\n            ans = max(ans, helper(i))\\n        return ans\\n```\n```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        dp = [0]*len(nums)\\n        dp[0] = nums[0]\\n        ans = dp[0]\\n        for j in range(1, len(nums)):\\n\\t\\t\\t# use max(0, j-k) in the range to keep the index within bounds\\n            for i in reversed(range(max(0, j-k), j)):\\n                dp[j] = max(dp[j], dp[i])\\n            dp[j] += nums[j]\\n            ans = max(ans, dp[j])\\n        return ans\\n```\n```\\nfrom collections import deque\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        dp = [0]*len(nums)\\n        dp[0] = nums[0]\\n        \\n        ans = dp[0]\\n        \\n\\t\\t# queue holds the index\\n        queue = deque([0])\\n        \\n        for j in range(1, len(nums)):\\n            if queue and queue[0] < j-k:\\n                queue.popleft()\\n            \\n            dp[j] = nums[j] + max(0, dp[queue[0]])\\n            \\n            while queue and dp[queue[-1]] < dp[j]:\\n                queue.pop()\\n            \\n            queue.append(j)\\n            ans = max(ans, dp[j])\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 597768,
                "title": "cpp-monotonic-deque-solution",
                "content": "let dp[i] = the maximum sum of the subset using A[i] as the ending number\\n\\ndp[i] = max(A[i], dp[i - 1] + A[i], dp[i - 2] + A[i] ... dp[i - k] + A[i]);\\n\\nso we can easily have a O(N* k) solution, which won\\'t work in this problem (TLE I guess)\\n\\nThe dp[i - 1] ... dp[i - k] is actually a sliding window.\\n\\nAnd we can use the solution of [Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/) to solve it\\n\\nTime: O(N)\\nSpace: O(N)\\n\\n```\\n    int constrainedSubsetSum(vector<int> A, int k) {\\n\\t\\tdeque<int> mono;\\n\\t\\tint n = A.size();\\n\\t\\tvector<int> dp(n, 0);\\n\\t\\tfor (int i = 0; i < n; ++i) {\\n\\t\\t\\tif (mono.size() && mono.front() < i - k)\\n\\t\\t\\t\\tmono.pop_front();\\n\\t\\t\\tint max_cur = mono.size() ? dp[mono.front()] : 0;\\n\\t\\t\\tdp[i] = max(max_cur,0) + A[i];\\n\\t\\t\\twhile (!mono.empty() && dp[i] > dp[mono.back()]) {\\n\\t\\t\\t\\tmono.pop_back();\\n\\t\\t\\t}\\n\\t\\t\\tmono.push_back(i);\\n\\t\\t}\\n\\t\\treturn *max_element(dp.begin(), dp.end());\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\n    int constrainedSubsetSum(vector<int> A, int k) {\\n\\t\\tdeque<int> mono;\\n\\t\\tint n = A.size();\\n\\t\\tvector<int> dp(n, 0);\\n\\t\\tfor (int i = 0; i < n; ++i) {\\n\\t\\t\\tif (mono.size() && mono.front() < i - k)\\n\\t\\t\\t\\tmono.pop_front();\\n\\t\\t\\tint max_cur = mono.size() ? dp[mono.front()] : 0;\\n\\t\\t\\tdp[i] = max(max_cur,0) + A[i];\\n\\t\\t\\twhile (!mono.empty() && dp[i] > dp[mono.back()]) {\\n\\t\\t\\t\\tmono.pop_back();\\n\\t\\t\\t}\\n\\t\\t\\tmono.push_back(i);\\n\\t\\t}\\n\\t\\treturn *max_element(dp.begin(), dp.end());\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 598467,
                "title": "javascript-sliding-window-o-n-time-and-o-k-space",
                "content": "#### Follow the comments for the algorithm :-\\n\\n```\\n//have a window array that should not exceed the size k\\n//store index and lastKsum in that window array, initialize \"max\" to nums[0] \\n//for nums length iterate over array, extract first elememt of window (index, lastKsum)\\n//check if window is in bound of k size.\\n//if not shift the first element out\\n//calculate the newsum which would be lastKsum/0 + nums[i]\\n//calcute max from max and newsum\\n//pop out the elements from window till their lastKsum is less than new sum or the window is empty\\n//push the index and new sum to window\\n//return max\\n\\nvar constrainedSubsetSum = function(nums, k) {\\n    var window = [[0,nums[0]]];\\n    var max = nums[0];\\n    for(var i=1; i<nums.length; i++){\\n        var [index,lastKsum] = window[0];\\n        if(index == i-k){\\n            window.shift();\\n        }\\n        var sum = Math.max(lastKsum, 0) + nums[i]\\n        max = Math.max(max, sum);\\n        while(window.length>0 && window[window.length-1][1] < sum){\\n            window.pop();\\n        }\\n        window.push([i,sum]);\\n    }\\n    return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\n//have a window array that should not exceed the size k\\n//store index and lastKsum in that window array, initialize \"max\" to nums[0] \\n//for nums length iterate over array, extract first elememt of window (index, lastKsum)\\n//check if window is in bound of k size.\\n//if not shift the first element out\\n//calculate the newsum which would be lastKsum/0 + nums[i]\\n//calcute max from max and newsum\\n//pop out the elements from window till their lastKsum is less than new sum or the window is empty\\n//push the index and new sum to window\\n//return max\\n\\nvar constrainedSubsetSum = function(nums, k) {\\n    var window = [[0,nums[0]]];\\n    var max = nums[0];\\n    for(var i=1; i<nums.length; i++){\\n        var [index,lastKsum] = window[0];\\n        if(index == i-k){\\n            window.shift();\\n        }\\n        var sum = Math.max(lastKsum, 0) + nums[i]\\n        max = Math.max(max, sum);\\n        while(window.length>0 && window[window.length-1][1] < sum){\\n            window.pop();\\n        }\\n        window.push([i,sum]);\\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1005863,
                "title": "dp-sliding-window-maximum-video-explanation-cpp",
                "content": "To understand this question, please implement [Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/) (it will increase your count of another hard problem!!). Solution to this is explained very clearly by Aditya Verma on his YT channel [here](https://www.youtube.com/watch?v=xFJXtB5vSmM&t=2035s)\\n\\nFor English, you can refer this video by Pepcoding [here](https://www.youtube.com/watch?v=TCHSXAu5pls)\\n\\nOnce completely undertanding the above solution, this solution can be seen as a variation of that problem with the following main differences:\\n1. Here we find the maximum from the dp array while in the original question we find maximum in the given array\\n2. Here the window excludes the current element (j) while finding the maximum. (We find the maximum in dp array k elements before j and take a decision whether to add that maxValue to the nums[j] and store it in the dp array or simple store nums[j] (`dp[j] = max(nums[j], nums[j]+maxValue)`)\\n\\nFinally, we find the maximum value in this dp array and return that.\\n\\n```\\n// Using Sliding Window Maximum + DP\\n// We create a dp array. At each point we fill the dp[j] by finding the maximum of\\n// window size k before j (excluding j).\\n// i.e. dp[j] = max(nums[j], nums[j] + maxValue)\\n// the maxValue is represented by the front of the deque (q.front())\\n// At the end, we find the max in the dp array and return.\\n\\n// To understand how Sliding Window Maximum works, video link is given above.\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        vector<int> dp(nums.size());\\n        \\n        int i = 0;\\n        int j = 0;\\n    \\n        deque<int> q;\\n        while(j<nums.size()){\\n            if (q.empty()){\\n                dp[j] = nums[j];\\n                q.push_back(j);\\n            }else{\\n                dp[j] = max(nums[j], nums[j] + dp[q.front()]);\\n                while(!q.empty() && dp[q.back()]<dp[j]){\\n                    q.pop_back();\\n                }\\n                q.push_back(j);\\n            }\\n            \\n            if (j-i<k){\\n                j++;\\n            }else{\\n                if(!q.empty() && q.front() == i){\\n                    q.pop_front();\\n                }\\n                i++;\\n                j++;\\n            }\\n            \\n            \\n        }\\n        \\n        int mx = INT_MIN;\\n        \\n        for (auto i: dp){\\n            mx = max(mx, i);\\n        }\\n        \\n        \\n        return mx;\\n        \\n    }\\n};\\n```\\n\\nLet me know if you have any doubts.\\n\\nBonus: [Jump Game VI](https://leetcode.com/problems/jump-game-vi/) is also a variation of Sliding Window Maximum and very similar to this one. Try and implement that as well. (only one line of code change to this code).\\n\\nHope this helps!! \\n\\nPlease Upvote. Thanks!",
                "solutionTags": [],
                "code": "```\\n// Using Sliding Window Maximum + DP\\n// We create a dp array. At each point we fill the dp[j] by finding the maximum of\\n// window size k before j (excluding j).\\n// i.e. dp[j] = max(nums[j], nums[j] + maxValue)\\n// the maxValue is represented by the front of the deque (q.front())\\n// At the end, we find the max in the dp array and return.\\n\\n// To understand how Sliding Window Maximum works, video link is given above.\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        vector<int> dp(nums.size());\\n        \\n        int i = 0;\\n        int j = 0;\\n    \\n        deque<int> q;\\n        while(j<nums.size()){\\n            if (q.empty()){\\n                dp[j] = nums[j];\\n                q.push_back(j);\\n            }else{\\n                dp[j] = max(nums[j], nums[j] + dp[q.front()]);\\n                while(!q.empty() && dp[q.back()]<dp[j]){\\n                    q.pop_back();\\n                }\\n                q.push_back(j);\\n            }\\n            \\n            if (j-i<k){\\n                j++;\\n            }else{\\n                if(!q.empty() && q.front() == i){\\n                    q.pop_front();\\n                }\\n                i++;\\n                j++;\\n            }\\n            \\n            \\n        }\\n        \\n        int mx = INT_MIN;\\n        \\n        for (auto i: dp){\\n            mx = max(mx, i);\\n        }\\n        \\n        \\n        return mx;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 818658,
                "title": "java-3-approaches-well-commented-brute-force-o-nk-treemap-o-nlogk-sliding-deque-o-n",
                "content": "```\\n/**\\n * Approach: Extension of treeMap solution. Instead of using treeMap, used a monotonic increasing queue to keep track of sliding maximum\\n * TimeComplexity: O(n)\\n */\\npublic int constrainedSubsetSumUsingDeque(int[] nums, int k) {\\n\\tint n = nums.length;\\n\\tint[] dp = new int[n];\\n\\tArrayDeque<Integer> queue = new ArrayDeque<>();\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tdp[i] = Math.max(nums[i], nums[i] + (queue.isEmpty() ? 0 : queue.peekFirst()));\\n\\t\\twhile (!queue.isEmpty() && queue.peekLast() < dp[i]) {\\n\\t\\t\\t//remove all elements smaller than dp[i]\\n\\t\\t\\tqueue.pollLast();\\n\\t\\t}\\n\\t\\tqueue.add(dp[i]);\\n\\t\\tif (i >= k && dp[i - k] == queue.peekFirst()) {\\n\\t\\t\\t//need to remove the prefix sum falling out of the window, also pollFirst() only if the value equals the prefix sum falling outside the window\\n\\t\\t\\t// because there is a chance that it has already been polled\\n\\t\\t\\tqueue.pollFirst();\\n\\t\\t}\\n\\t}\\n\\treturn Arrays.stream(dp).max().getAsInt();\\n}\\n\\n/**\\n * Approach: Extension of brute force approach, instead of iterating over the past k indices to find the max,\\n * store the result of the past k indices in a treeMap and use lastKey() to find the max value\\n * TimeComplexity: O(nlogk)\\n */\\npublic int constrainedSubsetSumUsingTreeMap(int[] nums, int k) {\\n\\tint n = nums.length;\\n\\tint[] dp = new int[n];\\n\\tTreeMap<Integer, Integer> map = new TreeMap<>();\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\t//max to handle negative lastKey()\\n\\t\\tdp[i] = Math.max(nums[i], nums[i] + (map.isEmpty() ? 0 : map.lastKey()));\\n\\t\\tmap.put(dp[i], map.getOrDefault(dp[i], 0) + 1);\\n\\t\\tif (i >= k) {\\n\\t\\t\\t//need to remove the prefix sum falling out of the window\\n\\t\\t\\tint key = dp[i - k];\\n\\t\\t\\tint val = map.get(key);\\n\\t\\t\\tif (val == 1) {\\n\\t\\t\\t\\tmap.remove(key);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmap.put(key, val - 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn Arrays.stream(dp).max().getAsInt();\\n}\\n\\n/**\\n * Approach: For every index i, check the result of the previous i-k indexes and update the result at dp[i]\\n * Basically need to find the maximum for the previous k indexes in order to compute the result for dp[i]\\n * Time Complexity: O(n*k)\\n */\\npublic int constrainedSubsetSumBruteForceTLE(int[] nums, int k) {\\n\\tint n = nums.length;\\n\\tint[] dp = new int[n];\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tdp[i] = nums[i];\\n\\t\\tint maxOffset = i - k;\\n\\t\\tfor (int j = i - 1; j >= 0 && j >= maxOffset; j--) {\\n\\t\\t\\tdp[i] = Math.max(dp[i], nums[i] + dp[j]);\\n\\t\\t}\\n\\t}\\n\\treturn Arrays.stream(dp).max().getAsInt();\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Approach: Extension of treeMap solution. Instead of using treeMap, used a monotonic increasing queue to keep track of sliding maximum\\n * TimeComplexity: O(n)\\n */\\npublic int constrainedSubsetSumUsingDeque(int[] nums, int k) {\\n\\tint n = nums.length;\\n\\tint[] dp = new int[n];\\n\\tArrayDeque<Integer> queue = new ArrayDeque<>();\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tdp[i] = Math.max(nums[i], nums[i] + (queue.isEmpty() ? 0 : queue.peekFirst()));\\n\\t\\twhile (!queue.isEmpty() && queue.peekLast() < dp[i]) {\\n\\t\\t\\t//remove all elements smaller than dp[i]\\n\\t\\t\\tqueue.pollLast();\\n\\t\\t}\\n\\t\\tqueue.add(dp[i]);\\n\\t\\tif (i >= k && dp[i - k] == queue.peekFirst()) {\\n\\t\\t\\t//need to remove the prefix sum falling out of the window, also pollFirst() only if the value equals the prefix sum falling outside the window\\n\\t\\t\\t// because there is a chance that it has already been polled\\n\\t\\t\\tqueue.pollFirst();\\n\\t\\t}\\n\\t}\\n\\treturn Arrays.stream(dp).max().getAsInt();\\n}\\n\\n/**\\n * Approach: Extension of brute force approach, instead of iterating over the past k indices to find the max,\\n * store the result of the past k indices in a treeMap and use lastKey() to find the max value\\n * TimeComplexity: O(nlogk)\\n */\\npublic int constrainedSubsetSumUsingTreeMap(int[] nums, int k) {\\n\\tint n = nums.length;\\n\\tint[] dp = new int[n];\\n\\tTreeMap<Integer, Integer> map = new TreeMap<>();\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\t//max to handle negative lastKey()\\n\\t\\tdp[i] = Math.max(nums[i], nums[i] + (map.isEmpty() ? 0 : map.lastKey()));\\n\\t\\tmap.put(dp[i], map.getOrDefault(dp[i], 0) + 1);\\n\\t\\tif (i >= k) {\\n\\t\\t\\t//need to remove the prefix sum falling out of the window\\n\\t\\t\\tint key = dp[i - k];\\n\\t\\t\\tint val = map.get(key);\\n\\t\\t\\tif (val == 1) {\\n\\t\\t\\t\\tmap.remove(key);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmap.put(key, val - 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn Arrays.stream(dp).max().getAsInt();\\n}\\n\\n/**\\n * Approach: For every index i, check the result of the previous i-k indexes and update the result at dp[i]\\n * Basically need to find the maximum for the previous k indexes in order to compute the result for dp[i]\\n * Time Complexity: O(n*k)\\n */\\npublic int constrainedSubsetSumBruteForceTLE(int[] nums, int k) {\\n\\tint n = nums.length;\\n\\tint[] dp = new int[n];\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tdp[i] = nums[i];\\n\\t\\tint maxOffset = i - k;\\n\\t\\tfor (int j = i - 1; j >= 0 && j >= maxOffset; j--) {\\n\\t\\t\\tdp[i] = Math.max(dp[i], nums[i] + dp[j]);\\n\\t\\t}\\n\\t}\\n\\treturn Arrays.stream(dp).max().getAsInt();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 668769,
                "title": "java-dp-and-arraydeque",
                "content": "version 1:\\nPure DP, TLE\\ndp[i] means results based on first half of array ending with i, but must contains i in the subsequence;\\nit will be easy to get dp[j] based on dp[i], where j - k <= i < j;\\n```\\n public int constrainedSubsetSum(int[] nums, int k) {\\n        int[] dp = new int[nums.length];\\n        dp[0] = nums[0];\\n        int res = dp[0];\\n        for (int i = 1; i < dp.length; i++) {\\n            dp[i] = nums[i];\\n            for (int j = 1; j <= k && i - j >= 0; j++) dp[i] = Math.max(dp[i], dp[i - j] + nums[i]);\\n            res = Math.max(res, dp[i]);\\n        }\\n        return res;\\n    }\\n```\\n\\nVersion 2, \\nWe are only interested in the max of a slinding window, that is, max dp from dp[i], where j - k <= i < j.\\nSounds familiar? Right, we can use  deque to:\\n1, Maintain a mono decreasing queue then apply DP;\\n2, Use a Deque to optimize, where we just need to get the max dp from dp[i], where j - k <= i < j;\\nRef; https://leetcode.com/problems/constrained-subsequence-sum/discuss/597751/JavaC%2B%2BPython-O(N)-Decreasing-Deque\\n```\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int[] dp = new int[nums.length];\\n        dp[0] = nums[0];\\n        int res = dp[0];\\n        Deque<Integer> dq = new ArrayDeque<>();\\n        for (int i = 0; i < dp.length; i++) {\\n            dp[i] = nums[i] + (dq.isEmpty() ? 0 : dp[dq.peek()]);\\n            res = Math.max(res, dp[i]);\\n            while (!dq.isEmpty() && dp[i] >= dp[dq.peekLast()]) dq.pollLast();\\n            if (dp[i] > 0) dq.offer(i);\\n            while (i >= k && !dq.isEmpty() && dq.peek() <= i - k) dq.poll();\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int constrainedSubsetSum(int[] nums, int k) {\\n        int[] dp = new int[nums.length];\\n        dp[0] = nums[0];\\n        int res = dp[0];\\n        for (int i = 1; i < dp.length; i++) {\\n            dp[i] = nums[i];\\n            for (int j = 1; j <= k && i - j >= 0; j++) dp[i] = Math.max(dp[i], dp[i - j] + nums[i]);\\n            res = Math.max(res, dp[i]);\\n        }\\n        return res;\\n    }\\n```\n```\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int[] dp = new int[nums.length];\\n        dp[0] = nums[0];\\n        int res = dp[0];\\n        Deque<Integer> dq = new ArrayDeque<>();\\n        for (int i = 0; i < dp.length; i++) {\\n            dp[i] = nums[i] + (dq.isEmpty() ? 0 : dp[dq.peek()]);\\n            res = Math.max(res, dp[i]);\\n            while (!dq.isEmpty() && dp[i] >= dp[dq.peekLast()]) dq.pollLast();\\n            if (dp[i] > 0) dq.offer(i);\\n            while (i >= k && !dq.isEmpty() && dq.peek() <= i - k) dq.poll();\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 597761,
                "title": "simple-sliding-window-solution-based-on-sliding-window-maximum-python",
                "content": "It is really similar to the [Sliding Window Maximum Problem](https://leetcode.com/problems/sliding-window-maximum). \\n\\nWe would use a double ended queue to store the maximum sums in last K indices.\\n\\n```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        d = collections.deque([(0, nums[0])])\\n        ans = nums[0]\\n        for i in range(1, len(nums)):\\n            idx, lastKSumMax = d[0]\\n            if idx == i - k:\\n                d.popleft()\\n            newSum = max(lastKSumMax, 0) + nums[i]\\n            ans = max(ans, newSum)\\n            while d and d[-1][1] < newSum:\\n                d.pop()\\n            d.append((i, newSum))\\n        return ans\\n```\\n\\nTake `[10, -2, -10, -5, 20], k=2` as an example,\\n\\n1. First, we have `[(0, 10)]` as deque initialization,\\n2. Then with `-2`, we have a newSum `8` and push it to our deque. Our deque would be `[(0, 10), (1, 8)]`,\\n3. Then with `-10`, we have a newSum `0`, this time we need to do a `popleft` operation as the sum at index `0` should not be used anymore in the future calculation. Again, our deque would be `[(1, 8), (2, 0)]`,\\n4. With `-5`, we have a newSum `3`, and again we need to do a `popleft` operation. We also need to pop `(2, 0)` as `3 > 0`(we would never use the sum at index `2` as the sum at index `3` is greater than it. Our deque would be `[(3, 3)]`,\\n5. With `20` we have newSum `23`, and our deque would be `[(4, 23)]`.\\n\\nThe answer would be 23 as it is the biggest newSum. \\n\\nThe time complexity should be just `O(N)`, and space complexity is `O(K)`. \\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        d = collections.deque([(0, nums[0])])\\n        ans = nums[0]\\n        for i in range(1, len(nums)):\\n            idx, lastKSumMax = d[0]\\n            if idx == i - k:\\n                d.popleft()\\n            newSum = max(lastKSumMax, 0) + nums[i]\\n            ans = max(ans, newSum)\\n            while d and d[-1][1] < newSum:\\n                d.pop()\\n            d.append((i, newSum))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 597924,
                "title": "java-monotonic-decreasing-deque-o-n",
                "content": "```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] dp = new int[n];\\n        Deque<Integer> dq = new LinkedList();\\n        int res = Integer.MIN_VALUE;\\n        for(int i=0; i<n; i++){\\n            int firstIndex = dq.isEmpty() ? -1 : dq.peekFirst();\\n            int prevMax = firstIndex==-1 ? 0 : dp[firstIndex];\\n            dp[i] = prevMax+nums[i];\\n            res = Math.max(res, dp[i]);\\n            if(firstIndex<=i-k){\\n                dq.pollFirst();\\n            }\\n            while(!dq.isEmpty() && dp[i]>=dp[dq.peekLast()]){\\n                dq.pollLast();\\n            }\\n            if(dp[i]>0) dq.offerLast(i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] dp = new int[n];\\n        Deque<Integer> dq = new LinkedList();\\n        int res = Integer.MIN_VALUE;\\n        for(int i=0; i<n; i++){\\n            int firstIndex = dq.isEmpty() ? -1 : dq.peekFirst();\\n            int prevMax = firstIndex==-1 ? 0 : dp[firstIndex];\\n            dp[i] = prevMax+nums[i];\\n            res = Math.max(res, dp[i]);\\n            if(firstIndex<=i-k){\\n                dq.pollFirst();\\n            }\\n            while(!dq.isEmpty() && dp[i]>=dp[dq.peekLast()]){\\n                dq.pollLast();\\n            }\\n            if(dp[i]>0) dq.offerLast(i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 597736,
                "title": "c-dp-with-multiset-o-n-lg-k-with-monotone-deque-o-n",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        // Time Complexity: O(n log k)\\n        // Space Complexity: O(k)\\n        \\n        int n = nums.size();\\n        int sums[k][2];\\n        \\n        // 0: not choose nums[i], so we take max of sums[i-1][0], sums[i-1][1] (res from previous)\\n        // 1: choose nums[i], then have to choose between sums[i-k] and sums[i-1]\\n        \\n        sums[0][0] = 0;\\n        sums[0][1] = nums[0];\\n        \\n        bool neg = nums[0] < 0;\\n        int least = nums[0];\\n        multiset<int> prevs({sums[0][1]});\\n        \\n        for (int i = 1; i < n; ++i) {\\n            sums[i % k][0] = max(sums[(i - 1) % k][0], sums[(i - 1) % k][1]);\\n            int temp = max(0, *prevs.rbegin()) + nums[i];\\n            if (i >= k) prevs.erase(sums[i % k][1]);\\n            sums[i % k][1] = temp;\\n            prevs.insert(sums[i % k][1]);\\n            if (neg &= nums[i] < 0) least = max(least, nums[i]);\\n        }\\n        \\n        return neg ? least : max(sums[(n - 1) % k][0], sums[(n - 1) % k][1]);\\n    }\\n};\\n```\\n\\nThanks for the idea of maintaining a monotone deque from other posts. The time complexity is further reduced to O(N).\\n\\n```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        // Time Complexity: O(n)\\n        // Space Complexity: O(k)\\n        \\n        int n = nums.size();\\n        int sums[k][2];\\n        \\n        // 0: not choose nums[i], so we take max of sums[i-1][0], sums[i-1][1] (res from previous)\\n        // 1: choose nums[i], then have to choose between sums[i-k] and sums[i-1]\\n        \\n        sums[0][0] = 0;\\n        sums[0][1] = nums[0];\\n        \\n        bool neg = nums[0] < 0;\\n        int least = nums[0];\\n        deque<int> dq({0}); // store indices of sums[index][1]\\n        \\n        for (int i = 1; i < n; ++i) {\\n            sums[i % k][0] = max(sums[(i - 1) % k][0], sums[(i - 1) % k][1]);\\n            sums[i % k][1] = max(0, dq.empty() ? 0 : sums[dq.front() % k][1]) + nums[i];\\n\\t\\t\\t\\n            // store at most k indices\\n            while (!dq.empty() && dq.front() <= i - k)\\n                dq.pop_front();\\n\\t\\t\\t\\n\\t\\t\\t// maintain the decreasing order\\n            while (!dq.empty() && sums[dq.back() % k][1] <= sums[i % k][1])\\n                dq.pop_back();\\n            \\n\\t\\t\\t// update if the current sum is positive\\n\\t\\t\\tif (sums[i % k][1] > 0)\\n                dq.push_back(i);\\n            \\n            if (neg &= nums[i] < 0) least = max(least, nums[i]);\\n        }\\n        \\n        return neg ? least : max(sums[(n - 1) % k][0], sums[(n - 1) % k][1]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        // Time Complexity: O(n log k)\\n        // Space Complexity: O(k)\\n        \\n        int n = nums.size();\\n        int sums[k][2];\\n        \\n        // 0: not choose nums[i], so we take max of sums[i-1][0], sums[i-1][1] (res from previous)\\n        // 1: choose nums[i], then have to choose between sums[i-k] and sums[i-1]\\n        \\n        sums[0][0] = 0;\\n        sums[0][1] = nums[0];\\n        \\n        bool neg = nums[0] < 0;\\n        int least = nums[0];\\n        multiset<int> prevs({sums[0][1]});\\n        \\n        for (int i = 1; i < n; ++i) {\\n            sums[i % k][0] = max(sums[(i - 1) % k][0], sums[(i - 1) % k][1]);\\n            int temp = max(0, *prevs.rbegin()) + nums[i];\\n            if (i >= k) prevs.erase(sums[i % k][1]);\\n            sums[i % k][1] = temp;\\n            prevs.insert(sums[i % k][1]);\\n            if (neg &= nums[i] < 0) least = max(least, nums[i]);\\n        }\\n        \\n        return neg ? least : max(sums[(n - 1) % k][0], sums[(n - 1) % k][1]);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        // Time Complexity: O(n)\\n        // Space Complexity: O(k)\\n        \\n        int n = nums.size();\\n        int sums[k][2];\\n        \\n        // 0: not choose nums[i], so we take max of sums[i-1][0], sums[i-1][1] (res from previous)\\n        // 1: choose nums[i], then have to choose between sums[i-k] and sums[i-1]\\n        \\n        sums[0][0] = 0;\\n        sums[0][1] = nums[0];\\n        \\n        bool neg = nums[0] < 0;\\n        int least = nums[0];\\n        deque<int> dq({0}); // store indices of sums[index][1]\\n        \\n        for (int i = 1; i < n; ++i) {\\n            sums[i % k][0] = max(sums[(i - 1) % k][0], sums[(i - 1) % k][1]);\\n            sums[i % k][1] = max(0, dq.empty() ? 0 : sums[dq.front() % k][1]) + nums[i];\\n\\t\\t\\t\\n            // store at most k indices\\n            while (!dq.empty() && dq.front() <= i - k)\\n                dq.pop_front();\\n\\t\\t\\t\\n\\t\\t\\t// maintain the decreasing order\\n            while (!dq.empty() && sums[dq.back() % k][1] <= sums[i % k][1])\\n                dq.pop_back();\\n            \\n\\t\\t\\t// update if the current sum is positive\\n\\t\\t\\tif (sums[i % k][1] > 0)\\n                dq.push_back(i);\\n            \\n            if (neg &= nums[i] < 0) least = max(least, nums[i]);\\n        }\\n        \\n        return neg ? least : max(sums[(n - 1) % k][0], sums[(n - 1) % k][1]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1225612,
                "title": "c-deque",
                "content": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        \\n      deque<pair<int,int>>dq;\\n      int ans=INT_MIN;\\n      for(int i=0;i<nums.size();i++){\\n        \\n        while(!dq.empty() && dq.front().first<i-k){\\n         dq.pop_front();\\n        } \\n        if(!dq.empty()){\\n         nums[i] = max(nums[i],nums[i]+dq.front().second);\\n        }\\n         while(!dq.empty()&&nums[i]>=dq.back().second) dq.pop_back();\\n         dq.push_back({i,nums[i]});\\n         ans=max(ans,nums[i]);\\n        \\n      }\\n      \\n      return ans;\\n      \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        \\n      deque<pair<int,int>>dq;\\n      int ans=INT_MIN;\\n      for(int i=0;i<nums.size();i++){\\n        \\n        while(!dq.empty() && dq.front().first<i-k){\\n         dq.pop_front();\\n        } \\n        if(!dq.empty()){\\n         nums[i] = max(nums[i],nums[i]+dq.front().second);\\n        }\\n         while(!dq.empty()&&nums[i]>=dq.back().second) dq.pop_back();\\n         dq.push_back({i,nums[i]});\\n         ans=max(ans,nums[i]);\\n        \\n      }\\n      \\n      return ans;\\n      \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 821169,
                "title": "python-using-deque-and-concept-of-dp-with-explaination-o-n",
                "content": "Observation from the question:\\nWe want to find the sequence with max sum, and the different between any two number in the sequence should not bigger than k:\\n=> suppose dp[i] means the max sum of all the valid sequences that end at nums[i]\\n=> dp[i] = max(dp[i-k] + nums[i], dp[i-k+1] +nums[i], ... ,dp[i-1] +nums[i], nums[i])\\n\\nif we use dp, the time complexity is  O(NK), but here we can use \"deque\" to improve the time complexity to  O(N).\\nwe use deque to save the information: \\nthe possible useful sequence which end with a number form A[i-k:i-1], in a decreasing order (according to the sum of the sequence)\\n(actually we save the index in deque, because we need to check the index to make sure the sequence is valid)\\nso that every time we only need O(1) to compute dp[i] instead of O(K) => dp[i] = nums[deque[0]] + nums[i]\\n\\nhere, I didn\\'t create new dp array, I just saved dp[i] directly in A[i], because we will never use A[i] again after computed dp[i]. \\nSo here, new A[i] = dp[i] = max sum of the valid sequence end at i.\\n```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        deque = []\\n        for i, num in enumerate(nums):\\n                \\n            while(deque and deque[0] < i - k): # delete that didn\\'t end with a number in A[i-k:i]\\n                deque.pop(0)\\n                \\n            if deque:  # compute the max sum we can get at index i\\n                nums[i] = nums[deque[0]] + num\\n            \\n            while(deque and nums[deque[-1]] < nums[i]): \\n                # delet all the sequence that smaller than current sum, becaus there will never be\\n                # considers ==> smaller than current sequence, and end before current sequence\\n                deque.pop()\\n                \\n            if nums[i] > 0: # if nums[i] < 0, it can\\'t be a useful prefix sum    \\n            \\tdeque.append(i)\\n        \\n        return max(nums)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        deque = []\\n        for i, num in enumerate(nums):\\n                \\n            while(deque and deque[0] < i - k): # delete that didn\\'t end with a number in A[i-k:i]\\n                deque.pop(0)\\n                \\n            if deque:  # compute the max sum we can get at index i\\n                nums[i] = nums[deque[0]] + num\\n            \\n            while(deque and nums[deque[-1]] < nums[i]): \\n                # delet all the sequence that smaller than current sum, becaus there will never be\\n                # considers ==> smaller than current sequence, and end before current sequence\\n                deque.pop()\\n                \\n            if nums[i] > 0: # if nums[i] < 0, it can\\'t be a useful prefix sum    \\n            \\tdeque.append(i)\\n        \\n        return max(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 606588,
                "title": "c-solution-100-memory-70-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k)\\n    {   \\n        int n = nums.size();\\n        vector<int> dp(n);\\n        deque<int> q;\\n        \\n        dp[0]=nums[0];\\n        q.push_back(0);\\n        int ans=dp[0];\\n        \\n        for(int i=1;i<n;i++)\\n        {   \\n            dp[i] = max(0,dp[q.front()]) + nums[i];\\n            ans=max(ans,dp[i]);\\n            \\n            while(!q.empty() && q.front()<=i-k)  //Similar to sliding window maximum problem\\n                q.pop_front();\\n            while(!q.empty() && dp[i]>=dp[q.back()])\\n                q.pop_back();\\n            q.push_back(i);\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k)\\n    {   \\n        int n = nums.size();\\n        vector<int> dp(n);\\n        deque<int> q;\\n        \\n        dp[0]=nums[0];\\n        q.push_back(0);\\n        int ans=dp[0];\\n        \\n        for(int i=1;i<n;i++)\\n        {   \\n            dp[i] = max(0,dp[q.front()]) + nums[i];\\n            ans=max(ans,dp[i]);\\n            \\n            while(!q.empty() && q.front()<=i-k)  //Similar to sliding window maximum problem\\n                q.pop_front();\\n            while(!q.empty() && dp[i]>=dp[q.back()])\\n                q.pop_back();\\n            q.push_back(i);\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328738,
                "title": "dp-with-segment-tree",
                "content": "\\n```\\nclass Solution {\\npublic: \\n    int tree[4*100001] ; \\n    void update(int node, int low, int high,int val, int ind) {\\n        if(low==high) {\\n            tree[node]=val; \\n            return ; \\n        }\\n        int mid=(low+high)>>1; \\n        if(ind<=mid) {\\n            update(2*node,low,mid, val, ind)  ; \\n        }\\n        else {\\n            update(2*node+1,mid+1, high, val , ind) ; \\n        }\\n        tree[node]=max(tree[2*node],tree[2*node+1]) ; \\n    }\\n    int rangequery(int node, int low, int high, int l, int r) {\\n           if(l>high or r<low) {\\n               return 0; \\n           }\\n           if(low>=l and high<=r) {\\n               return tree[node] ; \\n           }\\n           int mid=(low+high)>>1; \\n           int left=rangequery(2*node, low, mid, l , r) ; \\n           int right=rangequery(2*node+1, mid+1, high, l, r) ; \\n           return max(left, right) ; \\n    }\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n         int n=nums.size() ; ; \\n         vector<int>dp(n,-1e9) ;\\n         dp[0]=nums[0] ; \\n         update(1,0,n-1,dp[0],0) ; \\n         for(int i=1; i<n; i++) {\\n                int left=i-k; \\n                if(left<0) left=0; \\n               int  prev=rangequery(1,0,n-1,left,i-1) ; \\n               if(prev>=0) dp[i]=prev+nums[i]; \\n               else dp[i]=nums[i] ;  \\n               update(1,0,n-1,dp[i],i) ; \\n         }\\n         int res=dp[0] ; \\n         for(int i=1; i<n; i++) res=max(res , dp[i]) ; \\n         return res;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Segment Tree"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    int tree[4*100001] ; \\n    void update(int node, int low, int high,int val, int ind) {\\n        if(low==high) {\\n            tree[node]=val; \\n            return ; \\n        }\\n        int mid=(low+high)>>1; \\n        if(ind<=mid) {\\n            update(2*node,low,mid, val, ind)  ; \\n        }\\n        else {\\n            update(2*node+1,mid+1, high, val , ind) ; \\n        }\\n        tree[node]=max(tree[2*node],tree[2*node+1]) ; \\n    }\\n    int rangequery(int node, int low, int high, int l, int r) {\\n           if(l>high or r<low) {\\n               return 0; \\n           }\\n           if(low>=l and high<=r) {\\n               return tree[node] ; \\n           }\\n           int mid=(low+high)>>1; \\n           int left=rangequery(2*node, low, mid, l , r) ; \\n           int right=rangequery(2*node+1, mid+1, high, l, r) ; \\n           return max(left, right) ; \\n    }\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n         int n=nums.size() ; ; \\n         vector<int>dp(n,-1e9) ;\\n         dp[0]=nums[0] ; \\n         update(1,0,n-1,dp[0],0) ; \\n         for(int i=1; i<n; i++) {\\n                int left=i-k; \\n                if(left<0) left=0; \\n               int  prev=rangequery(1,0,n-1,left,i-1) ; \\n               if(prev>=0) dp[i]=prev+nums[i]; \\n               else dp[i]=nums[i] ;  \\n               update(1,0,n-1,dp[i],i) ; \\n         }\\n         int res=dp[0] ; \\n         for(int i=1; i<n; i++) res=max(res , dp[i]) ; \\n         return res;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1817246,
                "title": "java-solution-using-heap-and-dynamic-programming-o-n",
                "content": "My first intuition was to solve the problem just like we solve LIS i.e by using two loops which would result in O(n2) complexity and i was quite satisfied with my solution as it passed my test cases , however on getting the TLE , i soon realized my mistake as the complexity was hitting O(n2) . \\n\\nThe thought of using a priorityqueue came when i realized that all we need between the indices [j-k<=i<j] is the max in that range , however we need to ascertain that the max we are getting is infact from the range specified .\\n\\n```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int n=nums.length;\\n        int[] dp=new int[n];\\n        int res=nums[0];\\n        Queue<Integer> queue=new PriorityQueue<>((a,b)->dp[b]-dp[a]); //Declaring Max heap\\n        \\n        Arrays.fill(dp,Integer.MIN_VALUE);\\n        dp[0]=nums[0];\\n        queue.offer(0);\\n        \\n        for(int j=1;j<n;j++){\\n            int i=Math.max(j-k,0);    // get the furthest index possible \\n            while(!queue.isEmpty() && queue.peek()<i) queue.poll();     // find the global max in the specified range for that particular j index\\n            int idx=queue.peek();\\n            dp[j]=Math.max(dp[idx]+nums[j],nums[j]);\\n            res=Math.max(res,dp[j]);\\n            queue.offer(j);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int n=nums.length;\\n        int[] dp=new int[n];\\n        int res=nums[0];\\n        Queue<Integer> queue=new PriorityQueue<>((a,b)->dp[b]-dp[a]); //Declaring Max heap\\n        \\n        Arrays.fill(dp,Integer.MIN_VALUE);\\n        dp[0]=nums[0];\\n        queue.offer(0);\\n        \\n        for(int j=1;j<n;j++){\\n            int i=Math.max(j-k,0);    // get the furthest index possible \\n            while(!queue.isEmpty() && queue.peek()<i) queue.poll();     // find the global max in the specified range for that particular j index\\n            int idx=queue.peek();\\n            dp[j]=Math.max(dp[idx]+nums[j],nums[j]);\\n            res=Math.max(res,dp[j]);\\n            queue.offer(j);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1566821,
                "title": "c-dp-tabulation-priority-queue",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k)\\n    {\\n        int n=nums.size();\\n        int ans=-10000;\\n        int dp[n+1];\\n        \\n        dp[0]=nums[0];\\n        for(int i=0;i<n;i++)\\n        {\\n            dp[i]=nums[i];\\n            ans=max(ans,dp[i]);\\n        }\\n        priority_queue<pair<int,int>>pq;\\n        pq.push(make_pair(nums[0],0));\\n        for(int i=1;i<n;i++)\\n        {\\n            while(i-pq.top().second>k)\\n            {\\n                pq.pop();\\n            }\\n            dp[i]=max(dp[i],nums[i]+pq.top().first);\\n            pq.push(make_pair(dp[i],i));\\n            ans=max(ans,dp[i]);\\n        }\\n        return ans;\\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k)\\n    {\\n        int n=nums.size();\\n        int ans=-10000;\\n        int dp[n+1];\\n        \\n        dp[0]=nums[0];\\n        for(int i=0;i<n;i++)\\n        {\\n            dp[i]=nums[i];\\n            ans=max(ans,dp[i]);\\n        }\\n        priority_queue<pair<int,int>>pq;\\n        pq.push(make_pair(nums[0],0));\\n        for(int i=1;i<n;i++)\\n        {\\n            while(i-pq.top().second>k)\\n            {\\n                pq.pop();\\n            }\\n            dp[i]=max(dp[i],nums[i]+pq.top().first);\\n            pq.push(make_pair(dp[i],i));\\n            ans=max(ans,dp[i]);\\n        }\\n        return ans;\\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 597906,
                "title": "java-heap",
                "content": "```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        if(nums.length==1)return nums[0];\\n        int dp[]=new int[nums.length];\\n        PriorityQueue<int[]>pq=new PriorityQueue<>((a1,a2)->{\\n            return a2[1]-a1[1];\\n        });\\n        int res=Integer.MIN_VALUE;\\n        pq.add(new int[]{0,nums[0]});\\n        for(int i=1;i<nums.length;i++){\\n            while(pq.size()!=0&&i-pq.peek()[0]>k){\\n                res=Math.max(res,pq.poll()[1]);\\n            }\\n            int cur[]=new int[]{i,nums[i]};\\n            if(pq.size()!=0){\\n                cur[1]+=Math.max(0,pq.peek()[1]);\\n                pq.add(cur);\\n            }\\n        }\\n        res=Math.max(res,pq.peek()[1]);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        if(nums.length==1)return nums[0];\\n        int dp[]=new int[nums.length];\\n        PriorityQueue<int[]>pq=new PriorityQueue<>((a1,a2)->{\\n            return a2[1]-a1[1];\\n        });\\n        int res=Integer.MIN_VALUE;\\n        pq.add(new int[]{0,nums[0]});\\n        for(int i=1;i<nums.length;i++){\\n            while(pq.size()!=0&&i-pq.peek()[0]>k){\\n                res=Math.max(res,pq.poll()[1]);\\n            }\\n            int cur[]=new int[]{i,nums[i]};\\n            if(pq.size()!=0){\\n                cur[1]+=Math.max(0,pq.peek()[1]);\\n                pq.add(cur);\\n            }\\n        }\\n        res=Math.max(res,pq.peek()[1]);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3676228,
                "title": "same-as-jump-game-iv-and-sliding-window-maximum",
                "content": "Solution to Constrained Subsequence:\\n```\\nint constrainedSubsetSum(vector<int>& nums, int k) {\\n            \\n            \\n        \\n            int n = nums.size();\\n            vector<int> score = nums; // First Change Line\\n            score[0] = nums[0];\\n            \\n            priority_queue<pair<int,int>> pq;\\n            pq.push({score[0],0});\\n            \\n            for(int i = 1;i<nums.size();i++){\\n                    \\n                    while(!pq.empty() && pq.top().second < i-k) pq.pop();\\n                    \\n                    score[i] = max(score[i],nums[i] + (pq.empty() ? 0  : pq.top().first));\\n                   \\n                    pq.push(make_pair(score[i],i));\\n                    \\n                 \\n            }\\n            return *max_element(score.begin(),score.end()); // Second Change Line\\n            \\n    }\\n```\\n\\n\\nSolution To Jump Game IV :\\n```\\nint maxResult(vector<int>& nums, int k) {\\n        \\n            int n = nums.size();\\n            vector<int> score(n,INT_MIN);  // See Exact Line Above\\n            score[0] = nums[0];\\n            \\n            priority_queue<pair<int,int>> pq;\\n            pq.push({score[0],0});\\n            \\n            for(int i = 1;i<nums.size();i++){\\n                    \\n                    while(!pq.empty() && pq.top().second < i-k) pq.pop();\\n                    \\n                    score[i] = max(score[i],nums[i] + (pq.empty() ? 0  : pq.top().first));\\n                   \\n                    pq.push(make_pair(score[i],i));\\n                    \\n                 \\n            }\\n           // cout\\n            return score[nums.size()-1];  // See Exact Line Above\\n    }\\n```\\n\\nSolution to SLIDING WINDOW MAXIMUM\\n\\n```\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n            \\n            \\n            \\n            priority_queue<pair<int,int>> pq;\\n            vector<int> ans;\\n            \\n            for(int i = 0;i<nums.size();i++){\\n                    while(!pq.empty() && pq.top().second < i - k + 1) pq.pop();\\n                    pq.push({nums[i],i});\\n                    if(pq.size() >= k){\\n                            ans.push_back(pq.top().first);\\n                    }\\n            }\\n            return ans;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nint constrainedSubsetSum(vector<int>& nums, int k) {\\n            \\n            \\n        \\n            int n = nums.size();\\n            vector<int> score = nums; // First Change Line\\n            score[0] = nums[0];\\n            \\n            priority_queue<pair<int,int>> pq;\\n            pq.push({score[0],0});\\n            \\n            for(int i = 1;i<nums.size();i++){\\n                    \\n                    while(!pq.empty() && pq.top().second < i-k) pq.pop();\\n                    \\n                    score[i] = max(score[i],nums[i] + (pq.empty() ? 0  : pq.top().first));\\n                   \\n                    pq.push(make_pair(score[i],i));\\n                    \\n                 \\n            }\\n            return *max_element(score.begin(),score.end()); // Second Change Line\\n            \\n    }\\n```\n```\\nint maxResult(vector<int>& nums, int k) {\\n        \\n            int n = nums.size();\\n            vector<int> score(n,INT_MIN);  // See Exact Line Above\\n            score[0] = nums[0];\\n            \\n            priority_queue<pair<int,int>> pq;\\n            pq.push({score[0],0});\\n            \\n            for(int i = 1;i<nums.size();i++){\\n                    \\n                    while(!pq.empty() && pq.top().second < i-k) pq.pop();\\n                    \\n                    score[i] = max(score[i],nums[i] + (pq.empty() ? 0  : pq.top().first));\\n                   \\n                    pq.push(make_pair(score[i],i));\\n                    \\n                 \\n            }\\n           // cout\\n            return score[nums.size()-1];  // See Exact Line Above\\n    }\\n```\n```\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n            \\n            \\n            \\n            priority_queue<pair<int,int>> pq;\\n            vector<int> ans;\\n            \\n            for(int i = 0;i<nums.size();i++){\\n                    while(!pq.empty() && pq.top().second < i - k + 1) pq.pop();\\n                    pq.push({nums[i],i});\\n                    if(pq.size() >= k){\\n                            ans.push_back(pq.top().first);\\n                    }\\n            }\\n            return ans;\\n        \\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2583565,
                "title": "c-98-faster-solution-using-deque",
                "content": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        int n = nums.size(), res = INT_MIN;\\n        \\n        vector<int> dp(n);\\n        deque<int> sums;\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (sums.front() == i - k - 1) sums.pop_front();\\n            dp[i] = max(nums[i] + (sums.empty() ? 0 : dp[sums.front()]), nums[i]);\\n            res = max(res, dp[i]);\\n            while (!sums.empty() && dp[sums.back()] <= dp[i]) sums.pop_back();\\n            sums.push_back(i);\\n        }\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        int n = nums.size(), res = INT_MIN;\\n        \\n        vector<int> dp(n);\\n        deque<int> sums;\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (sums.front() == i - k - 1) sums.pop_front();\\n            dp[i] = max(nums[i] + (sums.empty() ? 0 : dp[sums.front()]), nums[i]);\\n            res = max(res, dp[i]);\\n            while (!sums.empty() && dp[sums.back()] <= dp[i]) sums.pop_back();\\n            sums.push_back(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2578199,
                "title": "segment-tree-o-nlogn",
                "content": "for nums[i] we have to take maximum sum in the range i-k to i-1 so to find maximu sum we have used Segment tree which gives us ths query in O(logN) time\\nand then we are updating the segment tree as nums[i]+max_sum_in_range(i-k,i-1)\\n```\\nclass SegmentTree\\n{\\n    public:\\n    vector<int> tree;\\n    int n;\\n    SegmentTree(int n)\\n    {\\n        int x=ceil(log2(n));\\n        int max_size=2*(int)pow(2,x)-1;\\n        this->n=max_size;\\n        this->tree.resize(max_size);\\n    }\\n    int query(int ql,int qr,int cl,int cr,int node){\\n        if(cl>=ql && cr<=qr){\\n            return tree[node];\\n        }\\n        if(cr<ql||cl>qr){\\n            return 0;\\n        }\\n        int mid=(cl+cr)/2;\\n        int x=query(ql,qr,cl,mid,2*node+1),y=query(ql,qr,mid+1,cr,2*node+2);\\n        return max(x,y);\\n    }\\n    void update(int idx,int val, int cl,int cr,int pos){\\n        if(pos<cl||pos>cr)return;\\n        \\n        if(cl==cr){\\n            tree[idx]=val;\\n            return;\\n        }\\n        int mid=(cl+cr)/2;\\n        update(2*idx+1,val,cl,mid,pos);\\n        update(2*idx+2,val,mid+1,cr,pos);\\n        tree[idx]=max(tree[2*idx+1],tree[2*idx+2]);\\n    }\\n};\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        SegmentTree t(nums.size());\\n    \\n        for(int i=0;i<nums.size();i++){\\n            int left=max(0,i-k),right=max(0,i-1);\\n            int x=t.query(left,right,0,nums.size()-1,0);\\n            t.update(0,nums[i]+x,0,nums.size()-1,i);\\n        }\\n        return t.tree[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass SegmentTree\\n{\\n    public:\\n    vector<int> tree;\\n    int n;\\n    SegmentTree(int n)\\n    {\\n        int x=ceil(log2(n));\\n        int max_size=2*(int)pow(2,x)-1;\\n        this->n=max_size;\\n        this->tree.resize(max_size);\\n    }\\n    int query(int ql,int qr,int cl,int cr,int node){\\n        if(cl>=ql && cr<=qr){\\n            return tree[node];\\n        }\\n        if(cr<ql||cl>qr){\\n            return 0;\\n        }\\n        int mid=(cl+cr)/2;\\n        int x=query(ql,qr,cl,mid,2*node+1),y=query(ql,qr,mid+1,cr,2*node+2);\\n        return max(x,y);\\n    }\\n    void update(int idx,int val, int cl,int cr,int pos){\\n        if(pos<cl||pos>cr)return;\\n        \\n        if(cl==cr){\\n            tree[idx]=val;\\n            return;\\n        }\\n        int mid=(cl+cr)/2;\\n        update(2*idx+1,val,cl,mid,pos);\\n        update(2*idx+2,val,mid+1,cr,pos);\\n        tree[idx]=max(tree[2*idx+1],tree[2*idx+2]);\\n    }\\n};\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        SegmentTree t(nums.size());\\n    \\n        for(int i=0;i<nums.size();i++){\\n            int left=max(0,i-k),right=max(0,i-1);\\n            int x=t.query(left,right,0,nums.size()-1,0);\\n            t.update(0,nums[i]+x,0,nums.size()-1,i);\\n        }\\n        return t.tree[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2333895,
                "title": "c-easy-to-understand-priority-queue",
                "content": "**Approach:**\\n1. Maintain a `Max Heap`  maximum sum with `k` window. \\n2. Calculate the `Current Sum` push it to the `Max Heap` and also calculate the `max sum`.\\n3. Check the window is greater than `k` or not. If it is greater than `k` remove the elements from the `Max Heap`.\\n\\n**Time:** `O(N log K)`\\n**Space:** `O(K)`\\n```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        priority_queue<array<int, 2>> que;\\n        int ret = nums[0], curr;\\n        que.push({nums[0], 0});\\n        for (int i = 1; i < nums.size(); i++) {\\n            while (!que.empty() && que.top()[1] < i - k) {\\n                que.pop();\\n            }\\n            curr = max(0, que.top()[0]) + nums[i];\\n\\t\\t    ret = max(ret, curr);\\n            que.push({curr, i});\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        priority_queue<array<int, 2>> que;\\n        int ret = nums[0], curr;\\n        que.push({nums[0], 0});\\n        for (int i = 1; i < nums.size(); i++) {\\n            while (!que.empty() && que.top()[1] < i - k) {\\n                que.pop();\\n            }\\n            curr = max(0, que.top()[0]) + nums[i];\\n\\t\\t    ret = max(ret, curr);\\n            que.push({curr, i});\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2257482,
                "title": "c-easy-approach-using-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n       int n = nums.size();\\n       int dp[n];\\n       priority_queue<pair<int, int>> pq;\\n       int ans = INT_MIN;\\n       for(int i = n-1; i>=0; i--){\\n         while(pq.size() > 0 && pq.top().second > i+k){\\n            pq.pop();\\n         }\\n\\n         dp[i] = nums[i];\\n         if(pq.size() > 0){\\n           if(pq.top().first >=0){\\n            dp[i] += pq.top().first;\\n           }\\n         }\\n         ans = max(dp[i], ans);\\n         pq.push({dp[i], i});\\n       } \\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n       int n = nums.size();\\n       int dp[n];\\n       priority_queue<pair<int, int>> pq;\\n       int ans = INT_MIN;\\n       for(int i = n-1; i>=0; i--){\\n         while(pq.size() > 0 && pq.top().second > i+k){\\n            pq.pop();\\n         }\\n\\n         dp[i] = nums[i];\\n         if(pq.size() > 0){\\n           if(pq.top().first >=0){\\n            dp[i] += pq.top().first;\\n           }\\n         }\\n         ans = max(dp[i], ans);\\n         pq.push({dp[i], i});\\n       } \\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2142135,
                "title": "c-monotonic-deque-similar-to-jump-game-vi",
                "content": "* Deque stores elements in decreasing order such that front of deque will give max element.\\n\\n* Problem Based on Same Idea [Jump Game VI](https://leetcode.com/contest/weekly-contest-220/problems/jump-game-vi/)\\n```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        deque<int> dq ;\\n        for(int i = 0 ; i < nums.size() ; ++i ){\\n            while(dq.size() and dq.front() < i - k ) dq.pop_front() ;\\n            int curr_max = dq.size() ? nums[dq.front()] : 0 ;\\n            nums[i] += max(0,curr_max) ; \\n            while(dq.size() and nums[dq.back()] <= nums[i]) dq.pop_back() ;\\n            dq.push_back(i) ;\\n        }\\n        \\n        return *max_element(begin(nums),end(nums)) ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        deque<int> dq ;\\n        for(int i = 0 ; i < nums.size() ; ++i ){\\n            while(dq.size() and dq.front() < i - k ) dq.pop_front() ;\\n            int curr_max = dq.size() ? nums[dq.front()] : 0 ;\\n            nums[i] += max(0,curr_max) ; \\n            while(dq.size() and nums[dq.back()] <= nums[i]) dq.pop_back() ;\\n            dq.push_back(i) ;\\n        }\\n        \\n        return *max_element(begin(nums),end(nums)) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1733168,
                "title": "c-o-n-decreasing-monotonic-queue-solution",
                "content": "Let\\'s see the optimal substructure of the problem:\\nThe optimal subsequence sum that terminate at element nums[i] should be\\n1. 0 + nums[i],  if all the previous k subsequence sum are all negative\\n2. (The largest optimal subsequence sum for the previous k subsequences that terminates at nums[i-k]...numsp[i-1]) + nums[i]\\n\\nSo the motivation to use a monotonic (decreasing) queue is that we have to keep the largest subsequence sum for the previous k elements. At each step we first pop out the out-of-range subsequence sum from the front(the larger side), determine the optimal subsequence sum terminated at nums[i], and then push the current sum from the back(the smaller side).\\n\\n```\\n\\tint constrainedSubsetSum(vector<int>& nums, int k) {\\n        deque<pair<int,int>> dq; // (subsequence sum, index)\\n        \\n        int res = INT_MIN;\\n        for (int i =0; i < nums.size(); ++i) {\\n\\t\\t\\t// pop out subsequences that ends at index < i-k\\n            while(!dq.empty() && dq.front().second < i - k) {\\n                dq.pop_front();\\n            }\\n\\t\\t\\t// determine current subsequence sum\\n\\t\\t\\t// dq.front() is the largest valid subseq sum\\n\\t\\t\\t// if dq is empty, then all the previous subseq sum are all non-positive integer\\n            int cur = nums[i] + (dq.empty()?0:dq.front().first);\\n\\t\\t\\t\\n\\t\\t\\t// if the current subseq sum is positive, then it is no way to keep subseq sum\\n\\t\\t\\t// that is smaller than current subseq sum\\n            if (cur > 0){\\n                while(!dq.empty() && dq.back().first <= cur) {\\n                    dq.pop_back();\\n                }\\n                dq.push_back({cur, i});\\n            }\\n            res = max(res, cur);\\n        }\\n        return res;\\n    }\\n```\\n\\nSince each subseq sum can only be push to the deque once and pop out once, the time complexity is O(N).\\nThe space complexity for this problem is O(n) because there can be at most n elements in the deque.",
                "solutionTags": [
                    "C",
                    "Monotonic Queue"
                ],
                "code": "```\\n\\tint constrainedSubsetSum(vector<int>& nums, int k) {\\n        deque<pair<int,int>> dq; // (subsequence sum, index)\\n        \\n        int res = INT_MIN;\\n        for (int i =0; i < nums.size(); ++i) {\\n\\t\\t\\t// pop out subsequences that ends at index < i-k\\n            while(!dq.empty() && dq.front().second < i - k) {\\n                dq.pop_front();\\n            }\\n\\t\\t\\t// determine current subsequence sum\\n\\t\\t\\t// dq.front() is the largest valid subseq sum\\n\\t\\t\\t// if dq is empty, then all the previous subseq sum are all non-positive integer\\n            int cur = nums[i] + (dq.empty()?0:dq.front().first);\\n\\t\\t\\t\\n\\t\\t\\t// if the current subseq sum is positive, then it is no way to keep subseq sum\\n\\t\\t\\t// that is smaller than current subseq sum\\n            if (cur > 0){\\n                while(!dq.empty() && dq.back().first <= cur) {\\n                    dq.pop_back();\\n                }\\n                dq.push_back({cur, i});\\n            }\\n            res = max(res, cur);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1676684,
                "title": "python-o-n-monotonic-deque-sliding-window-with-explanation",
                "content": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        # O(n) monotonic deque sliding window solution\\n        # max_dq is a monotonic deque containing the top\\n        # sums in the current window of size k.\\n        # each element is a tuple of sum and index of last element in that sum\\n        max_dq = deque()\\n        max_dq.append([nums[0], 0])\\n\\n        max_sum = nums[0]\\n\\n        for i in range(1, len(nums)):\\n            # remove the max if it exceeds the current window bounds\\n            if i - max_dq[0][1] > k:\\n                max_dq.popleft()\\n            \\n            # the max sum containing element i is either nums[i] alone\\n            # or the maximum from the window of size k\\n            # we easily get that from the front of the deque\\n            curr_max = max(nums[i], nums[i] + max_dq[0][0])\\n\\n            # push the current sum to appropriate spot in monotonic deque\\n            while max_dq and curr_max > max_dq[-1][0]:\\n                max_dq.pop()\\n            max_dq.append([curr_max, i])\\n\\n            max_sum = max(max_sum, curr_max)\\n\\n        return max_sum\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window",
                    "Monotonic Queue"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        # O(n) monotonic deque sliding window solution\\n        # max_dq is a monotonic deque containing the top\\n        # sums in the current window of size k.\\n        # each element is a tuple of sum and index of last element in that sum\\n        max_dq = deque()\\n        max_dq.append([nums[0], 0])\\n\\n        max_sum = nums[0]\\n\\n        for i in range(1, len(nums)):\\n            # remove the max if it exceeds the current window bounds\\n            if i - max_dq[0][1] > k:\\n                max_dq.popleft()\\n            \\n            # the max sum containing element i is either nums[i] alone\\n            # or the maximum from the window of size k\\n            # we easily get that from the front of the deque\\n            curr_max = max(nums[i], nums[i] + max_dq[0][0])\\n\\n            # push the current sum to appropriate spot in monotonic deque\\n            while max_dq and curr_max > max_dq[-1][0]:\\n                max_dq.pop()\\n            max_dq.append([curr_max, i])\\n\\n            max_sum = max(max_sum, curr_max)\\n\\n        return max_sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1524114,
                "title": "python3-dp-mono-queue",
                "content": "dp[i] is the max result that ends at this position\\nkey concept: dp[i] = max(nums[i] + max(dp[i - 1], dp[i - 2].. dp[i - k]), nums[i])\\n\\nWe can directly calculate this `max(dp[i - 1], dp[i - 2].. dp[i - k]`. The time complexity is O(N^2).\\nThe sliding windown and monotonic queue idea can be applied to dp array to the get the previous maximum number here, reducing the time complexity to O(N).\\n\\n```py\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        # Maximum sum subsequence \\n\\t\\t# Max skip -> k steps\\n        # dp[i] is the max results that ended at this position\\n        # dp[0] = nums[0]\\n        # dp[1] = max(nums[i] + max(dp[i - 1], dp[i - 2].. dp[i - k]), nums[i])\\n        # compare 1 by 1 -> O(n^2)\\n        # some data structure to find previous max\\n\\t\\t# find the max in a sliding window\\n        # queue -> Monotonic queue\\n        # queue is applied for dp array\\n        q = deque([])\\n        dp = [float(\"-inf\")] * (len(nums) + 1)\\n        q.append(0) \\n        for i in range(len(nums)):\\n            # max(dp[i - 1], dp[i - 2].. dp[i - k])\\n            # k >= 1\\n            while q and i + 1 - q[0] > k:\\n                q.popleft()\\n                \\n            dp[i + 1] = max(nums[i] + dp[q[0]], nums[i])\\n            while q and dp[i + 1] >= dp[q[-1]]:\\n                q.pop()   \\n            q.append(i + 1)\\n            \\n        return max(dp[1:])\\n```",
                "solutionTags": [],
                "code": "```py\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        # Maximum sum subsequence \\n\\t\\t# Max skip -> k steps\\n        # dp[i] is the max results that ended at this position\\n        # dp[0] = nums[0]\\n        # dp[1] = max(nums[i] + max(dp[i - 1], dp[i - 2].. dp[i - k]), nums[i])\\n        # compare 1 by 1 -> O(n^2)\\n        # some data structure to find previous max\\n\\t\\t# find the max in a sliding window\\n        # queue -> Monotonic queue\\n        # queue is applied for dp array\\n        q = deque([])\\n        dp = [float(\"-inf\")] * (len(nums) + 1)\\n        q.append(0) \\n        for i in range(len(nums)):\\n            # max(dp[i - 1], dp[i - 2].. dp[i - k])\\n            # k >= 1\\n            while q and i + 1 - q[0] > k:\\n                q.popleft()\\n                \\n            dp[i + 1] = max(nums[i] + dp[q[0]], nums[i])\\n            while q and dp[i + 1] >= dp[q[-1]]:\\n                q.pop()   \\n            q.append(i + 1)\\n            \\n        return max(dp[1:])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1026799,
                "title": "normal-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        vector<int> dp(nums.size());\\n        multiset<int> m;\\n        m.insert(0);\\n        for(int i =0; i<nums.size(); i++){\\n            dp[i] = nums[i] + *m.rbegin();\\n            m.insert(dp[i]);\\n            if(i>=k){\\n                m.erase(m.find((dp[i-k])));\\n            }\\n            \\n        }\\n        \\n        return *max_element(dp.begin(),dp.end());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        vector<int> dp(nums.size());\\n        multiset<int> m;\\n        m.insert(0);\\n        for(int i =0; i<nums.size(); i++){\\n            dp[i] = nums[i] + *m.rbegin();\\n            m.insert(dp[i]);\\n            if(i>=k){\\n                m.erase(m.find((dp[i-k])));\\n            }\\n            \\n        }\\n        \\n        return *max_element(dp.begin(),dp.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 716743,
                "title": "intiutive-solution-greedy-dp-without-using-deque",
                "content": "My Approach is ,if we find a block of negative no bw blocks of positive numbers.\\nlike [1,2,4,2,3,**-4,-1,-3,-2,-3**,3,5,2,1] , So what we need to do calculate maimum value of this negative window to get out of that ,and for this we will use DP **O((size of window x k))** +greedliy selected positive blocks **O(n)**.\\n```\\nint call(vector<int>&nums,int st,int end,int k)\\n    {   \\n        int n=end-st+1;\\n        if(n<k)\\n            return 0;\\n        int dp[end-st+1];\\n        int ans=INT_MIN;\\n       // Similar to LIS approach ,we can skip k-1 indexes from any point \\n        for(int i=0;i<n;i++)\\n        {\\n            dp[i]=nums[st+i];\\n            if(i>=k)\\n            {   int val=INT_MIN;\\n                for(int j=i-1;j>=i-k;j--)\\n                {\\n                    val=max(val,dp[j]);\\n                }\\n               dp[i]+=val;\\n               \\n             \\n            }\\n            if(i>=n-k)\\n                ans=max(ans,dp[i]);  // If it reachable to end with one jump\\n            \\n        }\\n       return ans; \\n    }\\n    \\n    int sequenceSum(vector<int>&updated)\\n    {\\n        int n=updated.size();\\n        int cur=0;\\n        int ans=INT_MIN;  // Simply update maximum sequence sum\\n        for(int i=0;i<n;i++)\\n        {\\n           cur+=updated[i];\\n            if(cur>ans)\\n                ans=cur;\\n            if(cur<0)\\n                cur=0;\\n        }\\n        return ans;\\n    }\\n    \\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n       \\n        vector<int>updated;  // further Updated input\\n        int n=nums.size();\\n        int l=0;      // start of neg index\\n        int i=0;\\n        int count=0;\\n        \\n        while(i<n)\\n        {  \\n            l=i;\\n            if(nums[i]>=0)\\n            {\\n                updated.push_back(nums[i]);   //if nums[i]>0,just push it to updated vector\\n                i++;\\n                continue;\\n            }\\n                \\n            while(i<n&&nums[i]<0)\\n            {\\n                i++;\\n                count++;      // Iterate till we find a positive number\\n            }\\n            if(count==n)\\n                return *max_element(nums.begin(),nums.end());  // if all elements are neg\\n           \\n            int change=call(nums,l,i-1,k);// It will find minimum cost to clear all negative window from l to i-1\\n            \\n            updated.push_back(change); // Push that value\\n            \\n        }\\n        \\n        int maximumSum=sequenceSum(updated);  // Now find maximum sequence sum\\n        \\n        return maximumSum;\\n        \\n    }",
                "solutionTags": [],
                "code": "My Approach is ,if we find a block of negative no bw blocks of positive numbers.\\nlike [1,2,4,2,3,**-4,-1,-3,-2,-3**,3,5,2,1] , So what we need to do calculate maimum value of this negative window to get out of that ,and for this we will use DP **O((size of window x k))** +greedliy selected positive blocks **O(n)**.\\n```\\nint call(vector<int>&nums,int st,int end,int k)\\n    {   \\n        int n=end-st+1;\\n        if(n<k)\\n            return 0;\\n        int dp[end-st+1];\\n        int ans=INT_MIN;\\n       // Similar to LIS approach ,we can skip k-1 indexes from any point \\n        for(int i=0;i<n;i++)\\n        {\\n            dp[i]=nums[st+i];\\n            if(i>=k)\\n            {   int val=INT_MIN;\\n                for(int j=i-1;j>=i-k;j--)\\n                {\\n                    val=max(val,dp[j]);\\n                }\\n               dp[i]+=val;\\n               \\n             \\n            }\\n            if(i>=n-k)\\n                ans=max(ans,dp[i]);  // If it reachable to end with one jump\\n            \\n        }\\n       return ans; \\n    }\\n    \\n    int sequenceSum(vector<int>&updated)\\n    {\\n        int n=updated.size();\\n        int cur=0;\\n        int ans=INT_MIN;  // Simply update maximum sequence sum\\n        for(int i=0;i<n;i++)\\n        {\\n           cur+=updated[i];\\n            if(cur>ans)\\n                ans=cur;\\n            if(cur<0)\\n                cur=0;\\n        }\\n        return ans;\\n    }\\n    \\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n       \\n        vector<int>updated;  // further Updated input\\n        int n=nums.size();\\n        int l=0;      // start of neg index\\n        int i=0;\\n        int count=0;\\n        \\n        while(i<n)\\n        {  \\n            l=i;\\n            if(nums[i]>=0)\\n            {\\n                updated.push_back(nums[i]);   //if nums[i]>0,just push it to updated vector\\n                i++;\\n                continue;\\n            }\\n                \\n            while(i<n&&nums[i]<0)\\n            {\\n                i++;\\n                count++;      // Iterate till we find a positive number\\n            }\\n            if(count==n)\\n                return *max_element(nums.begin(),nums.end());  // if all elements are neg\\n           \\n            int change=call(nums,l,i-1,k);// It will find minimum cost to clear all negative window from l to i-1\\n            \\n            updated.push_back(change); // Push that value\\n            \\n        }\\n        \\n        int maximumSum=sequenceSum(updated);  // Now find maximum sequence sum\\n        \\n        return maximumSum;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 599572,
                "title": "python3-o-n-time-o-k-space-easy-to-understand-monotonic-queue-dp",
                "content": "This is inspired by my friend\\'s Monotonic Queue code and maximum subarray sum.\\n\\nFirst, let\\'s take a look of the question: \\n```\\nGiven an integer array nums and an integer k, \\nreturn the maximum sum of a non-empty subset of that array such that for every two consecutive integers in the subset,\\nnums[i] and nums[j], where i < j, the condition j - i <= k is satisfied.\\n```\\nIt\\'s pretty similar to maximum subarray sum but with some restrictions like: the picked numbers in the subsequence must be within a window k (not sure if it\\'s the best word to explain..)\\n\\nLet\\'s take a look of the transition function for maximum subarray sum:\\n```\\ndp[i] = max(nums[i], dp[i-1]+nums[i]) \\n# should we take this number with previous sum or just start with the current number\\n```\\n\\nSimilarly, for this question, we can construct a transition function:\\n```\\ndp[i] = max(nums[i], dp[j]+arr[i]) for j in range(i-k, i)\\n# should we take this number with the previous sum, where the previous sum shoud be the max in range dp[i-k:i]\\n# Or should we just start with the current number\\n```\\n\\nBut with this DP setup, it\\'s taking O(NK) time and I\\'m facing the TLE.\\n\\nAnother necessary step is to further reduce time complexity through supporting O(1) find maximum in the sliding window dp[i-k:i] instead of O(K).\\n\\nA useful technique - monotonic queue - came into my mind. So we can keep a sliding window of K to traverse the array, and keep a maxQueue to track/update the maximum value in the sliding window of K.\\n\\nHere is a the implementation:\\nI learned the MaxQueue/MinQueue class implementation from my friend, and I\\'m reusing most of the MaxQueue code here.\\nI feel like wrapping the functionality of MaxQueue into a class would be easier for people to read!\\n```\\nfrom collections import deque\\nclass MaxQueue:\\n\\n    def __init__(self, k):\\n        self.capacity = k\\n        self.queue = deque()\\n        self.maxQueue = deque()\\n\\n\\n    def enqueue(self, value):\\n        if len(self.queue) == self.capacity:\\n            self.pop()\\n\\n        self.queue.append(value)\\n        while self.maxQueue and value > self.maxQueue[-1]:\\n            self.maxQueue.pop()\\n        self.maxQueue.append(value)\\n\\n\\n    def pop(self):\\n        val = self.queue.popleft()\\n        if val == self.getMax():\\n            self.maxQueue.popleft()\\n        return val\\n\\n\\n    def getMax(self):\\n        return self.maxQueue[0]\\n\\n\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        if not nums or len(nums) == 0:\\n            return 0\\n\\n        globalmax = 0\\n\\n        maxQueue = MaxQueue(k)\\n        maxQueue.enqueue(nums[0])\\n\\n        globalmax = nums[0]\\n        for i in range(1, len(nums)):\\n            maxQueue.enqueue(max(nums[i], nums[i] + maxQueue.getMax()))\\n            globalmax = max(globalmax, maxQueue.getMax())\\n\\n        return globalmax\\n```\\n\\nI think this is a really good problem by combining DP with monotonic queue.\\nThe structure of Monotonic queue class can be reused in a lot of problems and can be generalized into a framework.\\nHope my solution can help you understand and generalize the question!",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nGiven an integer array nums and an integer k, \\nreturn the maximum sum of a non-empty subset of that array such that for every two consecutive integers in the subset,\\nnums[i] and nums[j], where i < j, the condition j - i <= k is satisfied.\\n```\n```\\ndp[i] = max(nums[i], dp[i-1]+nums[i]) \\n# should we take this number with previous sum or just start with the current number\\n```\n```\\ndp[i] = max(nums[i], dp[j]+arr[i]) for j in range(i-k, i)\\n# should we take this number with the previous sum, where the previous sum shoud be the max in range dp[i-k:i]\\n# Or should we just start with the current number\\n```\n```\\nfrom collections import deque\\nclass MaxQueue:\\n\\n    def __init__(self, k):\\n        self.capacity = k\\n        self.queue = deque()\\n        self.maxQueue = deque()\\n\\n\\n    def enqueue(self, value):\\n        if len(self.queue) == self.capacity:\\n            self.pop()\\n\\n        self.queue.append(value)\\n        while self.maxQueue and value > self.maxQueue[-1]:\\n            self.maxQueue.pop()\\n        self.maxQueue.append(value)\\n\\n\\n    def pop(self):\\n        val = self.queue.popleft()\\n        if val == self.getMax():\\n            self.maxQueue.popleft()\\n        return val\\n\\n\\n    def getMax(self):\\n        return self.maxQueue[0]\\n\\n\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        if not nums or len(nums) == 0:\\n            return 0\\n\\n        globalmax = 0\\n\\n        maxQueue = MaxQueue(k)\\n        maxQueue.enqueue(nums[0])\\n\\n        globalmax = nums[0]\\n        for i in range(1, len(nums)):\\n            maxQueue.enqueue(max(nums[i], nums[i] + maxQueue.getMax()))\\n            globalmax = max(globalmax, maxQueue.getMax())\\n\\n        return globalmax\\n```",
                "codeTag": "Java"
            },
            {
                "id": 598900,
                "title": "c-faster-than-100-less-than-100-mem-o-n-k",
                "content": "Runtime: 152 ms\\nMemory Usage: 40 MB\\n\\n```\\n\\n   public int ConstrainedSubsetSum(int[] nums, int k) {\\n        int[] dp = new int[nums.Length];\\n        \\n        dp[dp.Length-1] = nums[nums.Length-1];\\n        int max = dp[dp.Length-1];\\n        \\n        int crntMaxIndex = dp.Length-1;\\n        int limit;\\n            \\n        for(int i=nums.Length-2; i>=0; i--)\\n        {\\n            if (crntMaxIndex - i > k)\\n            {\\n                limit = Math.Min(i+k+1, nums.Length);\\n                crntMaxIndex = i+1;\\n                \\n                for(int j=i+2; j < limit; j++)\\n                {\\n                    if (dp[crntMaxIndex] < dp[j])\\n                    {\\n                         crntMaxIndex = j;\\n                    }\\n                } \\n            }\\n            \\n            dp[i] = Math.Max(nums[i], nums[i] + dp[crntMaxIndex]);\\n                \\n            if (dp[i] >= dp[crntMaxIndex])\\n            {\\n                crntMaxIndex = i;\\n            }\\n            \\n            max = Math.Max(max, dp[i]);\\n        }\\n        \\n        return max;\\n    }",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "Runtime: 152 ms\\nMemory Usage: 40 MB\\n\\n```\\n\\n   public int ConstrainedSubsetSum(int[] nums, int k) {\\n        int[] dp = new int[nums.Length];\\n        \\n        dp[dp.Length-1] = nums[nums.Length-1];\\n        int max = dp[dp.Length-1];\\n        \\n        int crntMaxIndex = dp.Length-1;\\n        int limit;\\n            \\n        for(int i=nums.Length-2; i>=0; i--)\\n        {\\n            if (crntMaxIndex - i > k)\\n            {\\n                limit = Math.Min(i+k+1, nums.Length);\\n                crntMaxIndex = i+1;\\n                \\n                for(int j=i+2; j < limit; j++)\\n                {\\n                    if (dp[crntMaxIndex] < dp[j])\\n                    {\\n                         crntMaxIndex = j;\\n                    }\\n                } \\n            }\\n            \\n            dp[i] = Math.Max(nums[i], nums[i] + dp[crntMaxIndex]);\\n                \\n            if (dp[i] >= dp[crntMaxIndex])\\n            {\\n                crntMaxIndex = i;\\n            }\\n            \\n            max = Math.Max(max, dp[i]);\\n        }\\n        \\n        return max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 597912,
                "title": "c-o-n-o-nlogn-o-n-2-solution",
                "content": "**1. O(N^2) Solution with Dynamic Programming**\\n**Let DP[i] means maximum result we can get at index[i], which has to include current value**\\nFor example, [10, -2, -10, -5, 20], k = 2. \\nWill get [10, 8, 0, 3, 23]\\n\\nFor each **DP[i]**, we need to update **DP[i] = max(DP[i], cur + DP[j]), DP[j]** means all the index satisfies **i - k <= j < i**\\n\\n**2. O(NLogN) Solution with Ordered Set**\\n```\\nint constrainedSubsetSum(vector<int>& nums, int k) {\\n        int res = INT_MIN;\\n        set<int> st;\\n        vector<int> mem;\\n\\n        for (int i = 0; i < nums.size(); i++) {\\n\\t\\t    // cur means the maxRes we can get at index i;\\n            int cur = nums[i] + (st.empty() ? 0 : *st.rbegin());\\n            res = max(res, cur);\\n            \\n\\t\\t\\t// keep an orderd set\\n            if (cur > 0) st.insert(cur);\\n            mem.push_back(cur);\\n            \\n            // keep k + 1 sliding window, pop out the element out of border\\n            if (i - k >= 0) {\\n                if (st.empty()) continue;\\n                if (mem[i - k] == *st.rbegin()) {\\n                    st.erase(st.find(mem[i-k]));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\n**3. O(N) Solution with Monotonic Decreasing Queue**\\n```\\nint constrainedSubsetSum(vector<int>& nums, int k) {\\n\\tint res = INT_MIN;\\n\\tdeque<int> q;\\n\\tvector<int> mem;\\n\\n\\tfor (int i = 0; i < nums.size(); i++) {\\n\\t\\t// cur means the maxRes we can get at index i;\\n\\t\\tint cur = nums[i] + (q.empty() ? 0 : q.front());\\n\\t\\tres = max(res, cur);\\n\\t\\t\\n\\t\\t// make sure current number popped out all smaller number\\n\\t\\twhile (!q.empty() && q.back() < cur) q.pop_back();\\n\\t\\tif (cur > 0) q.push_back(cur); \\n\\t\\tmem.push_back(cur);\\n\\n\\t\\t// keep k + 1 sliding window, pop out the element out of border\\n\\t\\tif (i - k >= 0) {\\n\\t\\t\\tif (mem[i - k] == q.front()) {\\n\\t\\t\\t\\tq.pop_front();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint constrainedSubsetSum(vector<int>& nums, int k) {\\n        int res = INT_MIN;\\n        set<int> st;\\n        vector<int> mem;\\n\\n        for (int i = 0; i < nums.size(); i++) {\\n\\t\\t    // cur means the maxRes we can get at index i;\\n            int cur = nums[i] + (st.empty() ? 0 : *st.rbegin());\\n            res = max(res, cur);\\n            \\n\\t\\t\\t// keep an orderd set\\n            if (cur > 0) st.insert(cur);\\n            mem.push_back(cur);\\n            \\n            // keep k + 1 sliding window, pop out the element out of border\\n            if (i - k >= 0) {\\n                if (st.empty()) continue;\\n                if (mem[i - k] == *st.rbegin()) {\\n                    st.erase(st.find(mem[i-k]));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```\n```\\nint constrainedSubsetSum(vector<int>& nums, int k) {\\n\\tint res = INT_MIN;\\n\\tdeque<int> q;\\n\\tvector<int> mem;\\n\\n\\tfor (int i = 0; i < nums.size(); i++) {\\n\\t\\t// cur means the maxRes we can get at index i;\\n\\t\\tint cur = nums[i] + (q.empty() ? 0 : q.front());\\n\\t\\tres = max(res, cur);\\n\\t\\t\\n\\t\\t// make sure current number popped out all smaller number\\n\\t\\twhile (!q.empty() && q.back() < cur) q.pop_back();\\n\\t\\tif (cur > 0) q.push_back(cur); \\n\\t\\tmem.push_back(cur);\\n\\n\\t\\t// keep k + 1 sliding window, pop out the element out of border\\n\\t\\tif (i - k >= 0) {\\n\\t\\t\\tif (mem[i - k] == q.front()) {\\n\\t\\t\\t\\tq.pop_front();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 597729,
                "title": "c-o-n-log-n-dp-sliding-window-balanced-tree",
                "content": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> dp(n);\\n        multiset<int, greater<int>> win;\\n        dp[0] = nums[0];\\n        win.insert(nums[0]);\\n        int result = nums[0];\\n        for (int i = 1; i < n; i++) {\\n            int m = *win.begin();\\n            dp[i] = max(nums[i], nums[i] + m);\\n            win.insert(dp[i]);\\n            if (win.size() > k) {\\n                win.erase(win.find(dp[i - k]));\\n            }\\n            result = max(result, dp[i]);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> dp(n);\\n        multiset<int, greater<int>> win;\\n        dp[0] = nums[0];\\n        win.insert(nums[0]);\\n        int result = nums[0];\\n        for (int i = 1; i < n; i++) {\\n            int m = *win.begin();\\n            dp[i] = max(nums[i], nums[i] + m);\\n            win.insert(dp[i]);\\n            if (win.size() > k) {\\n                win.erase(win.find(dp[i - k]));\\n            }\\n            result = max(result, dp[i]);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3476819,
                "title": "python-dp-max-window-element-monotonic-queue",
                "content": "\\n```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        dp = copy.deepcopy(nums)\\n        q = deque()\\n        q.append(0)\\n        for i in range(1,len(nums)):\\n            while(q[-1] < i-k ):\\n                q.pop()\\n            dp[i] = max(dp[i],dp[q[-1]]+nums[i])\\n            while( len(q)>0 and dp[q[0]] <= dp[i] ):\\n                q.popleft()\\n            q.appendleft(i)\\n        return max(dp)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        dp = copy.deepcopy(nums)\\n        q = deque()\\n        q.append(0)\\n        for i in range(1,len(nums)):\\n            while(q[-1] < i-k ):\\n                q.pop()\\n            dp[i] = max(dp[i],dp[q[-1]]+nums[i])\\n            while( len(q)>0 and dp[q[0]] <= dp[i] ):\\n                q.popleft()\\n            q.appendleft(i)\\n        return max(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2652789,
                "title": "monotonic-queue-in-python-faster-than-98-47",
                "content": "This problem can be solved in O(N lg N) by using a heap or BST, and can also be solved in O(N) by using a monotonic queue instead of the tree structures. \\nThe idea is to maintain a queue that consists of up to previous k results for the current element to success. \\nThe queue is monotonic because the older the element in the queue should be the larger.\\n\\n```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        q = deque()\\n        for i, v in enumerate(nums):\\n            if len(q): \\n                nums[i] += nums[q[0]]\\n            if q and i - q[0] >= k:\\n                q.popleft()\\n            if nums[i] > 0:\\n                while q and nums[q[-1]] <= nums[i]:\\n                    q.pop()\\n                q.append(i)\\n        return max(nums)\\n                \\n",
                "solutionTags": [
                    "Python3",
                    "Monotonic Queue"
                ],
                "code": "This problem can be solved in O(N lg N) by using a heap or BST, and can also be solved in O(N) by using a monotonic queue instead of the tree structures. \\nThe idea is to maintain a queue that consists of up to previous k results for the current element to success. \\nThe queue is monotonic because the older the element in the queue should be the larger.\\n\\n```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        q = deque()\\n        for i, v in enumerate(nums):\\n            if len(q): \\n                nums[i] += nums[q[0]]\\n            if q and i - q[0] >= k:\\n                q.popleft()\\n            if nums[i] > 0:\\n                while q and nums[q[-1]] <= nums[i]:\\n                    q.pop()\\n                q.append(i)\\n        return max(nums)\\n                \\n",
                "codeTag": "Java"
            },
            {
                "id": 1489330,
                "title": "python-soln",
                "content": "Use a monotone decreasing deque. \\n* The deque stores (local_maxsum_i, i) tuples to indicate the local maximum subsequence sum using and ending at the nums[i]. \\n* The deque is decreasing because we want a maximum sum of sub-sequence with respect to the constrained index range bounded by k. So if we want to compute the \"local_maxsum_i\" at index i, we only need to check the \"local_maxsum_m\" at index m (m < i) such that:\\n\\t* The index m is as close to index i as possible and i - m <= k.\\n\\t* The \"local_maxsum_m\" is the maximum subsequence sum we have seen so far before we proceed to the index i.\\n\\t* If we keep proceeding to the next index n > i > m and found that local_maxsum_i >= local_maxsum_m, then local_maxsum_n = local_maxsum_i + nums[n] because \"local_maxsum_i\" is better than \"local_maxsum_m\" in both maximal value and index constraint aspects. This leads to the monotone decreasing deque.\\n\\n```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        # edge case\\n        if n == 1:\\n            return nums[0]\\n\\n        res = nums[0]\\n        dq = collections.deque([])\\n        dq.append((nums[0], 0))   # use a monotone decreasing deque\\n        for i in range(1, n):\\n            e = nums[i]\\n            # compliance with the index range constraint\\n            while dq and i - dq[0][1] > k:\\n                dq.popleft()\\n\\n            local_max = max(dq[0][0], 0) + e\\n            # maintain deque monotonicity\\n            while dq and local_max >= dq[-1][0]:\\n                dq.pop()\\n            dq.append((local_max, i))\\n            res = max(res, local_max)\\n\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        # edge case\\n        if n == 1:\\n            return nums[0]\\n\\n        res = nums[0]\\n        dq = collections.deque([])\\n        dq.append((nums[0], 0))   # use a monotone decreasing deque\\n        for i in range(1, n):\\n            e = nums[i]\\n            # compliance with the index range constraint\\n            while dq and i - dq[0][1] > k:\\n                dq.popleft()\\n\\n            local_max = max(dq[0][0], 0) + e\\n            # maintain deque monotonicity\\n            while dq and local_max >= dq[-1][0]:\\n                dq.pop()\\n            dq.append((local_max, i))\\n            res = max(res, local_max)\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1445396,
                "title": "dp-deque",
                "content": "Normal DP will give TLE. It is modified with monotonically increasing deque. \\n```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> dp(n);\\n        deque<int> dq;\\n        for(int j=0; j<n; j++) {\\n            while(!dq.empty()&&j-dq.front()>k) dq.pop_front();\\n            dp[j]=nums[j];\\n            if(!dq.empty()) dp[j]=max(dp[j], nums[j]+dp[dq.front()]);\\n            while(!dq.empty()&&dp[dq.back()]<dp[j]) dq.pop_back();\\n            dq.push_back(j);\\n            // cout<<dp[j]<<\" \";\\n        }\\n        return *max_element(dp.begin(), dp.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Queue",
                    "Monotonic Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> dp(n);\\n        deque<int> dq;\\n        for(int j=0; j<n; j++) {\\n            while(!dq.empty()&&j-dq.front()>k) dq.pop_front();\\n            dp[j]=nums[j];\\n            if(!dq.empty()) dp[j]=max(dp[j], nums[j]+dp[dq.front()]);\\n            while(!dq.empty()&&dp[dq.back()]<dp[j]) dq.pop_back();\\n            dq.push_back(j);\\n            // cout<<dp[j]<<\" \";\\n        }\\n        return *max_element(dp.begin(), dp.end());\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1369153,
                "title": "c-dp-solution-with-thinking-process-brute-force-priority-queue-mono-queue",
                "content": "The initial try is to approach this problem by DP: assuming dp[i] is the max subsequece sum ending at i; Then it\\'s straight forward to come up the dp relation:\\ndp[i] = nums[i] + max(dp[j], i-j <= k)\\n\\nNotice that there is no requirement on the left boundary, i.e we can have subsequence such as [i1, i2, ...] where i1 > k. So we can always initialize dp[i] as nums[i], which is a natrual subsequence with length 1 [i].\\n\\nThe time complexity is O(KN), and of course this will get TLE. Next step we will improve on getting max(dp[j], i-j<=k) using priority queue or mono queue. \\n```\\n// O(KN) solution, TLE\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        vector<int> dp(nums.size(), 0);\\n        dp[0] = nums[0];\\n        int ans = dp[0];\\n        for (int i = 1; i < nums.size(); ++i) {\\n            dp[i] = nums[i];\\n            for (int j = i-1; j>=0 && j+k >= i; --j) {\\n                dp[i] = std::max(dp[i], nums[i]+dp[j]);\\n            }\\n            ans = std::max(ans, dp[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPriority queue seems a very straightforward improvement on getting max, while maintaining the i-j<=k requirement. \\n```\\n// O(NlogN) solution\\nclass Solution_1 {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        auto cmp = [] (const pair<int,int>& lhs, const pair<int,int>& rhs) {\\n            return lhs.second < rhs.second;  \\n        };\\n        std::priority_queue<pair<int,int>, vector<pair<int,int>>, decltype(cmp)> pq(cmp);\\n        pq.push({0, nums[0]});\\n        int ans = nums[0];\\n        for (int i = 1; i < nums.size(); ++i) {\\n            int curr = nums[i];\\n            while (pq.size() && pq.top().first+k < i) pq.pop();\\n            curr = std::max(curr, nums[i]+pq.top().second);\\n            ans = std::max(ans, curr);\\n            pq.push({i, curr});\\n        }\\n        return ans;\\n    }\\n};\\n```\\nMono queue is relatively advanced: it\\'s a very effective structure to keep min/max value in a sliding window scenario. In this case, since we need the max value in the past, mono queue (decreasing order) can be utilized. \\nTo learn and understand mono queue, [leetcode 239. Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/) is your friend.\\nEverytime, when you need get min/max value in a sliding window, try mono queue (at least it always works for me.)\\n```\\n// O(N) solution\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        vector<int> dp(nums.size(), 0);\\n        dp[0] = nums[0];\\n        int ans = dp[0];\\n        deque<int> desc_dq;\\n        desc_dq.push_back(0);\\n        for (int i = 1; i < nums.size(); ++i) {\\n            dp[i] = nums[i];\\n            while(desc_dq.size() && desc_dq.front()+k < i) desc_dq.pop_front();\\n            dp[i] = std::max(dp[i], nums[i]+dp[desc_dq.front()]);\\n            ans = std::max(ans, dp[i]);\\n            while(desc_dq.size() && dp[i] >= dp[desc_dq.back()]) desc_dq.pop_back();\\n            desc_dq.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// O(KN) solution, TLE\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        vector<int> dp(nums.size(), 0);\\n        dp[0] = nums[0];\\n        int ans = dp[0];\\n        for (int i = 1; i < nums.size(); ++i) {\\n            dp[i] = nums[i];\\n            for (int j = i-1; j>=0 && j+k >= i; --j) {\\n                dp[i] = std::max(dp[i], nums[i]+dp[j]);\\n            }\\n            ans = std::max(ans, dp[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n// O(NlogN) solution\\nclass Solution_1 {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        auto cmp = [] (const pair<int,int>& lhs, const pair<int,int>& rhs) {\\n            return lhs.second < rhs.second;  \\n        };\\n        std::priority_queue<pair<int,int>, vector<pair<int,int>>, decltype(cmp)> pq(cmp);\\n        pq.push({0, nums[0]});\\n        int ans = nums[0];\\n        for (int i = 1; i < nums.size(); ++i) {\\n            int curr = nums[i];\\n            while (pq.size() && pq.top().first+k < i) pq.pop();\\n            curr = std::max(curr, nums[i]+pq.top().second);\\n            ans = std::max(ans, curr);\\n            pq.push({i, curr});\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n// O(N) solution\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        vector<int> dp(nums.size(), 0);\\n        dp[0] = nums[0];\\n        int ans = dp[0];\\n        deque<int> desc_dq;\\n        desc_dq.push_back(0);\\n        for (int i = 1; i < nums.size(); ++i) {\\n            dp[i] = nums[i];\\n            while(desc_dq.size() && desc_dq.front()+k < i) desc_dq.pop_front();\\n            dp[i] = std::max(dp[i], nums[i]+dp[desc_dq.front()]);\\n            ans = std::max(ans, dp[i]);\\n            while(desc_dq.size() && dp[i] >= dp[desc_dq.back()]) desc_dq.pop_back();\\n            desc_dq.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1335790,
                "title": "python-o-n-w-monoqueue-8-lines",
                "content": "```\\nfrom collections import deque\\n\\nclass Monoqueue:\\n    \\n    def __init__(self):\\n        self.dq = deque()\\n        self.data = list()\\n        \\n    def push(self, index, val):\\n        while len(self.dq) > 0 and val >= self.data[self.dq[-1]]:\\n            self.dq.pop()\\n        self.data.append(val)\\n        self.dq.append(index)\\n    \\n    def front(self, curr, k):\\n        if curr-self.dq[0] > k:\\n            self.dq.popleft()\\n        return self.data[self.dq[0]]\\n\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        \\n        \\'\\'\\'\\n        Algorithm:\\n            1. Define max_sum[i] := max{max_sum[i-j] for j e (1,k), 0} + nums[i]\\n            2. Define max_sum[0] = nums[0]\\n            3. Let M = max{max_sum[i-j] for j e (1,k)}.\\n                Then we can find M in constant time by maintaining a monoqueue which\\n                stores the maximum max_sum value within k of index i\\n        \\'\\'\\'\\n        n = len(nums)\\n        max_sum = nums\\n        mq = Monoqueue()\\n        mq.push(0,nums[0])\\n        \\n        for i in range(1,n):\\n            max_sum[i] = max(0,mq.front(i,k))+nums[i]\\n            mq.push(i,max_sum[i])      \\n        return max(max_sum)\\n\\t\\t",
                "solutionTags": [],
                "code": "class Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        \\n        \\'\\'\\'\\n        Algorithm:\\n            1. Define max_sum[i] := max{max_sum[i-j] for j e (1,k), 0}",
                "codeTag": "Java"
            },
            {
                "id": 1079569,
                "title": "java-dp-monoqueue",
                "content": "```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] A, int k) {\\n        int res=Integer.MIN_VALUE;\\n        LinkedList<int[]>mono=new LinkedList<>();\\n        int dp[]=new int[A.length];\\n        \\n        \\n        for(int i=0;i<A.length;i++){//decrease\\n            while(mono.size()>0&&mono.getFirst()[1]<i-k){\\n                mono.removeFirst();\\n            }\\n            dp[i]=A[i];\\n            \\n            if(mono.size()>0){\\n                int first=mono.getFirst()[0];\\n                dp[i]+=Math.max(first,0);\\n            }\\n            while(mono.size()>0&&dp[i]>mono.getLast()[0]){\\n                mono.removeLast();\\n            }\\n            \\n            \\n            mono.add(new int[]{dp[i],i});\\n            res=Math.max(res,dp[i]);\\n            \\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] A, int k) {\\n        int res=Integer.MIN_VALUE;\\n        LinkedList<int[]>mono=new LinkedList<>();\\n        int dp[]=new int[A.length];\\n        \\n        \\n        for(int i=0;i<A.length;i++){//decrease\\n            while(mono.size()>0&&mono.getFirst()[1]<i-k){\\n                mono.removeFirst();\\n            }\\n            dp[i]=A[i];\\n            \\n            if(mono.size()>0){\\n                int first=mono.getFirst()[0];\\n                dp[i]+=Math.max(first,0);\\n            }\\n            while(mono.size()>0&&dp[i]>mono.getLast()[0]){\\n                mono.removeLast();\\n            }\\n            \\n            \\n            mono.add(new int[]{dp[i],i});\\n            res=Math.max(res,dp[i]);\\n            \\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1050327,
                "title": "python-double-end-queue-and-dp-o-n-complexity",
                "content": "```\\n        n = len(nums)\\n        queue = deque()\\n        dp = [0] * n\\n        for i in range(0, n):\\n            # print(queue)\\n            while(queue and i - queue[0] > k):\\n                print(\"get in\")\\n                queue.popleft()\\n                \\n            if not queue:\\n                dp[i] = nums[i]\\n                if dp[i] > 0:\\n                    queue.append(i)\\n                continue\\n\\n            last = queue.pop()\\n            # print(\"just before:\", queue)\\n            while(queue and dp[queue[-1]] <= dp[last]):\\n                queue.pop()\\n            if queue:\\n                dp[i] = dp[queue[0]] + nums[i]\\n            else:\\n                dp[i] = dp[last] + nums[i]\\n            \\n            queue.append(last)\\n            \\n            if dp[i] > 0:\\n                queue.append(i)\\n        \\n        # print(dp)    \\n            \\n        return max(dp)\\n```\\n\\ndp[i] is the \"good\" subsequence containing the ith element with largest sum.\\nqueue[0] is the index such that i - index <= k and dp[index] is the largest.",
                "solutionTags": [],
                "code": "```\\n        n = len(nums)\\n        queue = deque()\\n        dp = [0] * n\\n        for i in range(0, n):\\n            # print(queue)\\n            while(queue and i - queue[0] > k):\\n                print(\"get in\")\\n                queue.popleft()\\n                \\n            if not queue:\\n                dp[i] = nums[i]\\n                if dp[i] > 0:\\n                    queue.append(i)\\n                continue\\n\\n            last = queue.pop()\\n            # print(\"just before:\", queue)\\n            while(queue and dp[queue[-1]] <= dp[last]):\\n                queue.pop()\\n            if queue:\\n                dp[i] = dp[queue[0]] + nums[i]\\n            else:\\n                dp[i] = dp[last] + nums[i]\\n            \\n            queue.append(last)\\n            \\n            if dp[i] > 0:\\n                queue.append(i)\\n        \\n        # print(dp)    \\n            \\n        return max(dp)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1027802,
                "title": "python-3-dp-and-heap",
                "content": "```\\nimport heapq\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        dp = [0 for _ in range(len(nums))] \\n        dp[0]=nums[0]\\n        heap = []\\n        heapq.heapify(heap)\\n        for i in range(1,len(nums)):\\n            while len(heap)>0 and heap[0][1]<i-k:\\n                heapq.heappop(heap)\\n            heapq.heappush(heap, (-dp[i-1],i-1))\\n            max_=-heap[0][0]\\n            dp[i] = max(0,max_)+nums[i]\\n        return max(dp)\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        dp = [0 for _ in range(len(nums))] \\n        dp[0]=nums[0]\\n        heap = []\\n        heapq.heapify(heap)\\n        for i in range(1,len(nums)):\\n            while len(heap)>0 and heap[0][1]<i-k:\\n                heapq.heappop(heap)\\n            heapq.heappush(heap, (-dp[i-1],i-1))\\n            max_=-heap[0][0]\\n            dp[i] = max(0,max_)+nums[i]\\n        return max(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1023925,
                "title": "dp-monotonic-deque-c",
                "content": "1. monotonic deque\\n```\\nTC: O(N)\\nSC: O(N)\\nint constrainedSubsetSum(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        vector<int> dp(n, 0);\\n        deque<int> dq{nums[0]};\\n        int res = nums[0];\\n        dp[0] = nums[0];\\n        \\n        for(int i = 1; i < n; i++){\\n            \\n            dp[i] = max(nums[i] + dq.front(), nums[i]); \\n            res = max(dp[i], res);\\n            while(!dq.empty() && dq.back() < dp[i])\\n                dq.pop_back();\\n            dq.push_back(dp[i]);\\n            if(i - k >= 0 && dq.front() == dp[i - k])\\n                dq.pop_front();\\n            \\n        }\\n        \\n        return res;\\n        \\n    }\\n```\\n\\n2. monotonic deque,  optimize the space\\n```\\nint constrainedSubsetSum(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        vector<int> dp(k+1, 0);\\n        deque<int> dq{nums[0]};\\n        int res = nums[0];\\n        dp[0] = nums[0];\\n\\n        for(int i = 1; i < n; i++){\\n\\n            int id = i % (k + 1);\\n            dp[id] = max(nums[i] + dq.front(), nums[i]);\\n            res = max(dp[id], res);\\n            while(!dq.empty() && dq.back() < dp[id])\\n                dq.pop_back();\\n            dq.push_back(dp[id]);\\n            if(i - k >= 0 && dq.front() == dp[(i - k) % (k + 1)])\\n                dq.pop_front();\\n\\n        }\\n        return res;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nTC: O(N)\\nSC: O(N)\\nint constrainedSubsetSum(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        vector<int> dp(n, 0);\\n        deque<int> dq{nums[0]};\\n        int res = nums[0];\\n        dp[0] = nums[0];\\n        \\n        for(int i = 1; i < n; i++){\\n            \\n            dp[i] = max(nums[i] + dq.front(), nums[i]); \\n            res = max(dp[i], res);\\n            while(!dq.empty() && dq.back() < dp[i])\\n                dq.pop_back();\\n            dq.push_back(dp[i]);\\n            if(i - k >= 0 && dq.front() == dp[i - k])\\n                dq.pop_front();\\n            \\n        }\\n        \\n        return res;\\n        \\n    }\\n```\n```\\nint constrainedSubsetSum(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        vector<int> dp(k+1, 0);\\n        deque<int> dq{nums[0]};\\n        int res = nums[0];\\n        dp[0] = nums[0];\\n\\n        for(int i = 1; i < n; i++){\\n\\n            int id = i % (k + 1);\\n            dp[id] = max(nums[i] + dq.front(), nums[i]);\\n            res = max(dp[id], res);\\n            while(!dq.empty() && dq.back() < dp[id])\\n                dq.pop_back();\\n            dq.push_back(dp[id]);\\n            if(i - k >= 0 && dq.front() == dp[(i - k) % (k + 1)])\\n                dq.pop_front();\\n\\n        }\\n        return res;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 998674,
                "title": "dynamic-programming-and-decreasing-queue",
                "content": "### Solution\\n\\nMy intution is to use dynamic programming to solve this problem, since most optimal (maximum or minimum) problem can be solved this way. Let dp[i] be the maximum constrained subsequence sum ending at nums[i] which satisfying the constraint. Then\\n\\n```python\\ndp[i] = max(dp[i - 1], ..., dp[i - k]) + nums[i]\\n\\nret = max(dp[i])\\n```\\n\\nSo a straightforward implementation is below.\\n\\n```python\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        \\'\\'\\'\\n        let dp[i] be the maximum subset sum with nums[i] as the last element in the subsequence\\n        then ret = max(dp[i]) for i in range(0,n)\\n        \\n        dp[i] = max(dp[i - 1], dp[i - 2], .., dp[i - k]) + nums[i]\\n        \\'\\'\\'\\n        n = len(nums)\\n        dp = [0 for i in range(n)]\\n        dp[0] = nums[0]\\n        for i in range(1, n):\\n            for j in range(1, k + 1):\\n                dp[i] = max(dp[i], dp[i - j])\\n            dp[i] += nums[i]\\n        return max(dp)\\n```\\n\\nThe time complexity is O(n\\\\*k)\\n\\nHowever, this does not pass the OJ. Could we optimize it further? The answer is yes. If we look at the innermost loop, acutally we are computing the maximum over a sliding window of size k + 1 ([i - k, i]). It is similar to problem [239](https://wenxu1024.github.io/2021/01/02/lc239.html). We can utilize a decreasing queue to solve it. That is when the front of queue went outside of the windowing, we pop it out. And if the end of the queue is smaller than the current val, we pop the end of the queue before appending the current val to the queue.\\n\\nBelow is the implementation\\n\\n```python\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        queue = collections.deque()\\n        n = len(nums)\\n        ret = [0 for i in range(n - k + 1)]\\n        for i in range(n):\\n            while len(queue) and i - queue[0] + 1 > k:\\n                queue.popleft()\\n            while len(queue) and nums[queue[-1]] < nums[i]:\\n                queue.pop()\\n            queue.append(i)\\n            if i >= k - 1:\\n                ret[i - k + 1] = nums[queue[0]]\\n        return ret\\n```\\n\\nTime complexity is O(3\\\\*n). Since element is added to and poppped out of the queue once. The last return max take O(n).",
                "solutionTags": [],
                "code": "```python\\ndp[i] = max(dp[i - 1], ..., dp[i - k]) + nums[i]\\n\\nret = max(dp[i])\\n```\n```python\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        \\'\\'\\'\\n        let dp[i] be the maximum subset sum with nums[i] as the last element in the subsequence\\n        then ret = max(dp[i]) for i in range(0,n)\\n        \\n        dp[i] = max(dp[i - 1], dp[i - 2], .., dp[i - k]) + nums[i]\\n        \\'\\'\\'\\n        n = len(nums)\\n        dp = [0 for i in range(n)]\\n        dp[0] = nums[0]\\n        for i in range(1, n):\\n            for j in range(1, k + 1):\\n                dp[i] = max(dp[i], dp[i - j])\\n            dp[i] += nums[i]\\n        return max(dp)\\n```\n```python\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        queue = collections.deque()\\n        n = len(nums)\\n        ret = [0 for i in range(n - k + 1)]\\n        for i in range(n):\\n            while len(queue) and i - queue[0] + 1 > k:\\n                queue.popleft()\\n            while len(queue) and nums[queue[-1]] < nums[i]:\\n                queue.pop()\\n            queue.append(i)\\n            if i >= k - 1:\\n                ret[i - k + 1] = nums[queue[0]]\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 984185,
                "title": "java-solution-dp-and-monotonic-queue-time-o-n",
                "content": "```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] f = new int[n];\\n        ArrayDeque<Integer> queue = new ArrayDeque<>();\\n        int ans = Integer.MIN_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            while (i > k && !queue.isEmpty() && queue.peekFirst() < i - k) {\\n                queue.pollFirst();\\n            }\\n            f[i] = Math.max(queue.isEmpty() ? 0 : f[queue.peekFirst()], 0) + nums[i];\\n            while (!queue.isEmpty() && f[i] >= f[queue.peekLast()]) {\\n                queue.pollLast();\\n            }\\n            queue.offer(i);\\n            ans = Math.max(ans, f[i]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] f = new int[n];\\n        ArrayDeque<Integer> queue = new ArrayDeque<>();\\n        int ans = Integer.MIN_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            while (i > k && !queue.isEmpty() && queue.peekFirst() < i - k) {\\n                queue.pollFirst();\\n            }\\n            f[i] = Math.max(queue.isEmpty() ? 0 : f[queue.peekFirst()], 0) + nums[i];\\n            while (!queue.isEmpty() && f[i] >= f[queue.peekLast()]) {\\n                queue.pollLast();\\n            }\\n            queue.offer(i);\\n            ans = Math.max(ans, f[i]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 949950,
                "title": "python3-explanation-runtime-and-space-analysis-o-n-time",
                "content": "**Explanation**\\nWe use a hashtable (DP) `index_to_maximum_sequence[<position>]` to store the sum of the best subsequence among all subsequences which include the element on the position `<position>` as their last element. The deque `window_maximum_indices` stores the indices of the best subsequences which end in an element within the window. Whenver a new element becomes part of the window, the best subsequence is calculated by adding the sum of the best subsequence among all best subsequences which end in an element within the window (or `0` if all sums are negative) to the current element. This new best subsequence replaces all best sequences which are smaller than or equal to the sum of this subsequence since it appears later index-wise (its last element) with a sum at least as high making it possible to combine more elements with this sequence later. This is achieved by removing the indices of the best subsequences up to the first one which is higher in `window_maximum_indices`. Due to the nature of this process, the stored indices are sorted in descending order. If the smallest index, which is the last element in the deque, becomes invalid (`current_index - smallest_max_index < k`), it will be removed and the corresponding best subsequence will not be considered anymore. In the end, we return the highest subsequence sum which is the highest value in `index_to_maximum_sequence`.\\n__________________\\n**Runtime Complexity**\\n`O(n)` since the indices of the input elements are visited twice at most.\\n_________________\\n**Space Complexity**\\n`O(n)` since our hashtable is of the same size as the input (this can be optimized since the subsequences which are not part of the window anymore can be ignored).\\n________________\\n**Python Implementation**\\n```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        window_maximum_indices    = collections.deque( [0] )\\n        index_to_maximum_sequence = [ nums[0] ]\\n        \\n        \\n        for i in range( 1, len(nums) ):\\n            if ( i - k > window_maximum_indices[-1] ):\\n                window_maximum_indices.pop()\\n\\n            index_to_maximum_sequence.append( nums[i] + max( 0, index_to_maximum_sequence[ window_maximum_indices[-1] ] ) )\\n            \\n            \\n            while ( len(window_maximum_indices) and index_to_maximum_sequence[-1] >= index_to_maximum_sequence[ window_maximum_indices[0] ] ):\\n                window_maximum_indices.popleft()\\n                \\n            window_maximum_indices.appendleft(i)\\n            \\n        return max(index_to_maximum_sequence)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        window_maximum_indices    = collections.deque( [0] )\\n        index_to_maximum_sequence = [ nums[0] ]\\n        \\n        \\n        for i in range( 1, len(nums) ):\\n            if ( i - k > window_maximum_indices[-1] ):\\n                window_maximum_indices.pop()\\n\\n            index_to_maximum_sequence.append( nums[i] + max( 0, index_to_maximum_sequence[ window_maximum_indices[-1] ] ) )\\n            \\n            \\n            while ( len(window_maximum_indices) and index_to_maximum_sequence[-1] >= index_to_maximum_sequence[ window_maximum_indices[0] ] ):\\n                window_maximum_indices.popleft()\\n                \\n            window_maximum_indices.appendleft(i)\\n            \\n        return max(index_to_maximum_sequence)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 835137,
                "title": "100-optimising-kaden-s-approach-of-o-n-k-to-linear-o-n-using-deque",
                "content": "# **Kaden\\'s Approach O(N*K)**\\n***12/15 Test case***\\n\\nState of dp[i]  = For the current element at i in nums, what would be the maxSum we can get if we include the nums[i]\\n\\nChoices : { Start new subsequence from nums , or include this value nums[i] int last j\\'th subsequence } j = [i-k , i-1]\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t`\\tmax( nums[i] , dp[j]+nums[i] )`\\n\\nNow find the maximum value that we Encountered => maxValue\\n\\n``` \\nclass Solution {\\npublic:\\n    Solution()\\n    {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        \\n    }\\n    int constrainedSubsetSum(vector<int>& nums, int k) { \\n\\t\\t // brute kaden\\'s\\n        \\n        vector<int> dp(nums.size(),-100000);\\n        \\n        int maxValue = nums[0];\\n        dp[0] = nums[0];\\n        \\n        for(int i=1;i<nums.size();i++)\\n        {\\n            for(int j=i-1 ; j>=0 && j>=i-k ; j--)\\n            {\\n                dp[i] = max({dp[i],dp[j]+nums[i],nums[i]});   \\n                maxValue = max(maxValue,dp[i]);\\n            }\\n        }\\n        \\n        return maxValue;\\n \\n    }\\n};\\n```\\n\\n# **Optimisation of finding the maximum for K size window** **O(N)**\\n**100% Time**\\n\\nPreviously what we were doing was to maximise the dp[j] + nums[i]\\nWhich can be done lineraly using Deque by mantainig the decreasing deque \\n( sliding window maximum - Leetcode)\\n\\n```\\nclass Solution {\\npublic:\\n    Solution()\\n    {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        \\n    }\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        \\n        // optimise using deque\\n        \\n        vector<int> dp(nums.size());\\n        \\n        deque<int> maxWindow;\\n        \\n        dp[0] = nums[0];\\n        maxWindow.push_back(0);\\n        \\n        int maxValue = nums[0];\\n        \\n        for(int i=1;i<nums.size();i++)\\n        {\\n            // the proximity for an element is only the last k characters so remove all the indexes which are less than i-k\\n            while(maxWindow.empty()==false && maxWindow.front() < i-k)\\n                maxWindow.pop_front();\\n\\n            // dp[i] = { max value from previous k size window + nums[i] , or nums[i] }\\n            dp[i] = max(dp[maxWindow.front()]+nums[i],nums[i]);\\n            maxValue = max(maxValue,dp[i]);\\n            \\n\\n            // now update the maxWindow Value from the current dp[i] value\\n            while(maxWindow.empty()==false && dp[i] > dp[maxWindow.back()])\\n                maxWindow.pop_back();\\n            maxWindow.push_back(i);\\n            \\n        }\\n        \\n        \\n        \\n        return maxValue;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "``` \\nclass Solution {\\npublic:\\n    Solution()\\n    {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        \\n    }\\n    int constrainedSubsetSum(vector<int>& nums, int k) { \\n\\t\\t // brute kaden\\'s\\n        \\n        vector<int> dp(nums.size(),-100000);\\n        \\n        int maxValue = nums[0];\\n        dp[0] = nums[0];\\n        \\n        for(int i=1;i<nums.size();i++)\\n        {\\n            for(int j=i-1 ; j>=0 && j>=i-k ; j--)\\n            {\\n                dp[i] = max({dp[i],dp[j]+nums[i],nums[i]});   \\n                maxValue = max(maxValue,dp[i]);\\n            }\\n        }\\n        \\n        return maxValue;\\n \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    Solution()\\n    {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        \\n    }\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        \\n        // optimise using deque\\n        \\n        vector<int> dp(nums.size());\\n        \\n        deque<int> maxWindow;\\n        \\n        dp[0] = nums[0];\\n        maxWindow.push_back(0);\\n        \\n        int maxValue = nums[0];\\n        \\n        for(int i=1;i<nums.size();i++)\\n        {\\n            // the proximity for an element is only the last k characters so remove all the indexes which are less than i-k\\n            while(maxWindow.empty()==false && maxWindow.front() < i-k)\\n                maxWindow.pop_front();\\n\\n            // dp[i] = { max value from previous k size window + nums[i] , or nums[i] }\\n            dp[i] = max(dp[maxWindow.front()]+nums[i],nums[i]);\\n            maxValue = max(maxValue,dp[i]);\\n            \\n\\n            // now update the maxWindow Value from the current dp[i] value\\n            while(maxWindow.empty()==false && dp[i] > dp[maxWindow.back()])\\n                maxWindow.pop_back();\\n            maxWindow.push_back(i);\\n            \\n        }\\n        \\n        \\n        \\n        return maxValue;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 806662,
                "title": "java-deque",
                "content": "```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int[] dp = new int[nums.length];\\n        dp[0] = nums[0];\\n        int max = Integer.MIN_VALUE;\\n        max = Math.max(dp[0], max);\\n        Deque<Integer> q = new ArrayDeque();\\n        q.offer(nums[0]);\\n        for(int i = 1; i < nums.length; i++){\\n            dp[i] = nums[i];\\n            dp[i]=nums[i];\\n            \\n            // element is out of range\\n            if(i>k && q.peekFirst() == dp[i-k-1]){\\n                q.removeFirst();\\n            }\\n            dp[i]=Math.max(dp[i],q.peek()+nums[i]);\\n            \\n            // remove untill currrent sum is greater than last element\\n            while(!q.isEmpty() && (q.peekLast()<dp[i])){\\n                q.pollLast();\\n            }\\n            q.offerLast(dp[i]);\\n            max=Math.max(max,dp[i]);\\n        }\\n        return max;\\n    }\\n}\\n\\n==============Timeout Solution=================\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int[] dp = new int[nums.length];\\n        dp[0] = nums[0];\\n        int max = Integer.MIN_VALUE;\\n        max = Math.max(dp[0], max);\\n        for(int i = 1; i < nums.length; ++i){\\n            dp[i] = nums[i];\\n            for(int j = i-1; i-k <= j && j >= 0; --j){\\n                dp[i] = Math.max(dp[i], dp[j]+nums[i]);\\n            }\\n            max = Math.max(dp[i], max);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int[] dp = new int[nums.length];\\n        dp[0] = nums[0];\\n        int max = Integer.MIN_VALUE;\\n        max = Math.max(dp[0], max);\\n        Deque<Integer> q = new ArrayDeque();\\n        q.offer(nums[0]);\\n        for(int i = 1; i < nums.length; i++){\\n            dp[i] = nums[i];\\n            dp[i]=nums[i];\\n            \\n            // element is out of range\\n            if(i>k && q.peekFirst() == dp[i-k-1]){\\n                q.removeFirst();\\n            }\\n            dp[i]=Math.max(dp[i],q.peek()+nums[i]);\\n            \\n            // remove untill currrent sum is greater than last element\\n            while(!q.isEmpty() && (q.peekLast()<dp[i])){\\n                q.pollLast();\\n            }\\n            q.offerLast(dp[i]);\\n            max=Math.max(max,dp[i]);\\n        }\\n        return max;\\n    }\\n}\\n\\n==============Timeout Solution=================\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int[] dp = new int[nums.length];\\n        dp[0] = nums[0];\\n        int max = Integer.MIN_VALUE;\\n        max = Math.max(dp[0], max);\\n        for(int i = 1; i < nums.length; ++i){\\n            dp[i] = nums[i];\\n            for(int j = i-1; i-k <= j && j >= 0; --j){\\n                dp[i] = Math.max(dp[i], dp[j]+nums[i]);\\n            }\\n            max = Math.max(dp[i], max);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 802792,
                "title": "c-top-down-dfs-dp-with-segment-tree-o-nlogn",
                "content": "```dp(i)=nums[i]+max(0,dp(i+1),dp(i+2),...,dp(i+k))```\\nSo, if we select the ith number , then we have to select only the first positive number in the range of ```[i+1,i+k]```. All subsequent positive numbers will be taken care of by the subproblem of the dp. We only have to look for positive numbers because adding a negative number will only reduce the sum. If we take a negative number, which inturn will give access to net positive numbers, for that case, if you can\\'t find a positive number in the given range, return the largest negative number in that range.\\n```\\nvector<int> tree;\\nint memo[100000];\\nint build(int start,int end,vector<int>& arr,int i)\\n{\\n    if(start==end)\\n        return tree[i]=start;\\n    else\\n    {\\n        int q=start+(end-start)/2;\\n        int left=build(start,q,arr,2*i+1),right=build(q+1,end,arr,2*i+2);\\n        if(arr[left]>0)\\n            return tree[i]=left;\\n        else if(arr[right]>0)\\n            return tree[i]=right;\\n        else\\n            return tree[i]=(arr[left]>arr[right]?left:right);\\n    }\\n}\\nint query(int start,int end,int lo,int hi,int i,vector<int>& arr)\\n{\\n    if(end<lo||start>hi)\\n        return -1;\\n    else if(start<=lo&&hi<=end)\\n        return tree[i];\\n    else\\n    {\\n        int q=lo+(hi-lo)/2;\\n        int left=query(start,end,lo,q,2*i+1,arr),right=query(start,end,q+1,hi,2*i+2,arr);\\n        if(left==-1)\\n            return right;\\n        if(right==-1)\\n            return left;\\n        if(arr[left]>0)\\n            return left;\\n        else if(arr[right]>0)\\n            return right;\\n        else\\n            return arr[left]>arr[right]?left:right;\\n    }\\n}\\nint dp(int i,vector<int>& arr,int k)\\n{\\n    if(i>=arr.size())\\n        return 0;\\n    else if(memo[i]!=-1)\\n        return memo[i];\\n    else\\n    {\\n        int q=0;\\n        if(i+1<arr.size())\\n        {\\n            int t=query(i+1,min(i+k,(int)arr.size()-1),0,arr.size()-1,0,arr);\\n            q=max(q,dp(t,arr,k));\\n        }\\n        return memo[i]=arr[i]+q;\\n    }\\n}\\nint constrainedSubsetSum(vector<int>& nums, int k) \\n{\\n    int n=nums.size();\\n    int x = (int)(ceil(log2(n)));  \\n    int max_size = 2*(int)pow(2, x) - 1;\\n    tree.resize(max_size);\\n    build(0,nums.size()-1,nums,0);\\n    memset(memo,-1,sizeof(memo));\\n    int ret=INT_MIN;\\n    for(int i=0;i<n;++i)\\n        ret=max(ret,dp(i,nums,k));\\n    return ret;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Tree"
                ],
                "code": "```dp(i)=nums[i]+max(0,dp(i+1),dp(i+2),...,dp(i+k))```\n```[i+1,i+k]```\n```\\nvector<int> tree;\\nint memo[100000];\\nint build(int start,int end,vector<int>& arr,int i)\\n{\\n    if(start==end)\\n        return tree[i]=start;\\n    else\\n    {\\n        int q=start+(end-start)/2;\\n        int left=build(start,q,arr,2*i+1),right=build(q+1,end,arr,2*i+2);\\n        if(arr[left]>0)\\n            return tree[i]=left;\\n        else if(arr[right]>0)\\n            return tree[i]=right;\\n        else\\n            return tree[i]=(arr[left]>arr[right]?left:right);\\n    }\\n}\\nint query(int start,int end,int lo,int hi,int i,vector<int>& arr)\\n{\\n    if(end<lo||start>hi)\\n        return -1;\\n    else if(start<=lo&&hi<=end)\\n        return tree[i];\\n    else\\n    {\\n        int q=lo+(hi-lo)/2;\\n        int left=query(start,end,lo,q,2*i+1,arr),right=query(start,end,q+1,hi,2*i+2,arr);\\n        if(left==-1)\\n            return right;\\n        if(right==-1)\\n            return left;\\n        if(arr[left]>0)\\n            return left;\\n        else if(arr[right]>0)\\n            return right;\\n        else\\n            return arr[left]>arr[right]?left:right;\\n    }\\n}\\nint dp(int i,vector<int>& arr,int k)\\n{\\n    if(i>=arr.size())\\n        return 0;\\n    else if(memo[i]!=-1)\\n        return memo[i];\\n    else\\n    {\\n        int q=0;\\n        if(i+1<arr.size())\\n        {\\n            int t=query(i+1,min(i+k,(int)arr.size()-1),0,arr.size()-1,0,arr);\\n            q=max(q,dp(t,arr,k));\\n        }\\n        return memo[i]=arr[i]+q;\\n    }\\n}\\nint constrainedSubsetSum(vector<int>& nums, int k) \\n{\\n    int n=nums.size();\\n    int x = (int)(ceil(log2(n)));  \\n    int max_size = 2*(int)pow(2, x) - 1;\\n    tree.resize(max_size);\\n    build(0,nums.size()-1,nums,0);\\n    memset(memo,-1,sizeof(memo));\\n    int ret=INT_MIN;\\n    for(int i=0;i<n;++i)\\n        ret=max(ret,dp(i,nums,k));\\n    return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 779631,
                "title": "c-14lines-code-with-priority-queue-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        vector<int> sums(nums);\\n        priority_queue<pair<int, int>> q;\\n        int ans = INT_MIN;\\n        for (int i = 0; i < sums.size(); i++) {\\n            while (!q.empty() && q.top().second < i-k)\\n                q.pop();\\n            int maximum = 0;\\n            if (!q.empty())\\n                maximum = q.top().first;\\n            sums[i] = maximum > 0 ? sums[i]+maximum : sums[i];\\n            ans = max(ans, sums[i]);\\n            q.push(make_pair(sums[i], i));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        vector<int> sums(nums);\\n        priority_queue<pair<int, int>> q;\\n        int ans = INT_MIN;\\n        for (int i = 0; i < sums.size(); i++) {\\n            while (!q.empty() && q.top().second < i-k)\\n                q.pop();\\n            int maximum = 0;\\n            if (!q.empty())\\n                maximum = q.top().first;\\n            sums[i] = maximum > 0 ? sums[i]+maximum : sums[i];\\n            ans = max(ans, sums[i]);\\n            q.push(make_pair(sums[i], i));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 769496,
                "title": "java-dp-mono-deque",
                "content": "Two key points\\n1. DP with the right ending points of the subarray.\\n2. To further reduce time complexity, use mononiticly decreasing deque to store the index of DP values. To design it, consider two aspects: recency and max value. If a DP value is both smaller and less recent than the current DP value, then it can be deleted, since it will be dominated by the current DP value.\\n\\n```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        // DP to store the max ending with current index\\n        int[] dp = new int[nums.length];\\n        // Monotonic decreasing deque to store the index of dp value\\n        Deque<Integer> deque = new ArrayDeque<>();\\n        \\n        for (int i = 0; i < nums.length; ++i) {\\n            dp[i] = nums[i];\\n            while (!deque.isEmpty() && i - deque.peekFirst() > k) {\\n                deque.pollFirst();\\n            }\\n            if (!deque.isEmpty())\\n                dp[i] = Math.max(dp[i], dp[i] + dp[deque.peekFirst()]);\\n            while (!deque.isEmpty() && dp[deque.peekLast()] <= dp[i]) {\\n                deque.pollLast();\\n            }\\n            deque.addLast(i);\\n        }\\n        int res = Integer.MIN_VALUE;\\n        for (int i = 0; i < dp.length; ++i)\\n            res = Math.max(dp[i], res);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        // DP to store the max ending with current index\\n        int[] dp = new int[nums.length];\\n        // Monotonic decreasing deque to store the index of dp value\\n        Deque<Integer> deque = new ArrayDeque<>();\\n        \\n        for (int i = 0; i < nums.length; ++i) {\\n            dp[i] = nums[i];\\n            while (!deque.isEmpty() && i - deque.peekFirst() > k) {\\n                deque.pollFirst();\\n            }\\n            if (!deque.isEmpty())\\n                dp[i] = Math.max(dp[i], dp[i] + dp[deque.peekFirst()]);\\n            while (!deque.isEmpty() && dp[deque.peekLast()] <= dp[i]) {\\n                deque.pollLast();\\n            }\\n            deque.addLast(i);\\n        }\\n        int res = Integer.MIN_VALUE;\\n        for (int i = 0; i < dp.length; ++i)\\n            res = Math.max(dp[i], res);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 748456,
                "title": "c-o-n-w-o-k-space",
                "content": "```\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        deque<std::pair<int,int>> seen;\\n        int ans = INT_MIN, l = 0, r = 0;\\n        while(r < nums.size()) {\\n            while(r - l <= k) {\\n                int current = seen.empty() ? nums[r] : seen.front().first + nums[r];\\n                ans = max(ans, current);\\n                while(!seen.empty() && seen.back().first < current) {\\n                    seen.pop_back();\\n                }\\n                if (current > 0) {\\n                    seen.push_back(std::make_pair(current, r));\\n                }\\n                r++;\\n            }\\n            if(seen.front().second == l) {\\n                seen.pop_front();\\n            }\\n            l++;\\n        }  \\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "```\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        deque<std::pair<int,int>> seen;\\n        int ans = INT_MIN, l = 0, r = 0;\\n        while(r < nums.size()) {\\n            while(r - l <= k) {\\n                int current = seen.empty() ? nums[r] : seen.front().first + nums[r];\\n                ans = max(ans, current);\\n                while(!seen.empty() && seen.back().first < current) {\\n                    seen.pop_back();\\n                }\\n                if (current > 0) {\\n                    seen.push_back(std::make_pair(current, r));\\n                }\\n                r++;\\n            }\\n            if(seen.front().second == l) {\\n                seen.pop_front();\\n            }\\n            l++;\\n        }  \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 651679,
                "title": "python-dp-using-deque-o-n-time-o-k-space-brief",
                "content": "```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        res, dp = nums[0], collections.deque([(0, nums[0])])\\n        for i in range(1, len(nums)):\\n            maxSeqSumEndsHere = nums[i] + max(0, dp[0][1])\\n            if dp[0][0] + k == i:\\n                dp.popleft()\\n            while dp and dp[-1][1] <= maxSeqSumEndsHere:\\n                dp.pop()\\n            dp.append((i, maxSeqSumEndsHere))\\n            res = max(res, maxSeqSumEndsHere)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        res, dp = nums[0], collections.deque([(0, nums[0])])\\n        for i in range(1, len(nums)):\\n            maxSeqSumEndsHere = nums[i] + max(0, dp[0][1])\\n            if dp[0][0] + k == i:\\n                dp.popleft()\\n            while dp and dp[-1][1] <= maxSeqSumEndsHere:\\n                dp.pop()\\n            dp.append((i, maxSeqSumEndsHere))\\n            res = max(res, maxSeqSumEndsHere)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 634603,
                "title": "c-kaden-s-with-priority-queue-time-o-nlogn-space-o-n",
                "content": "The idea is very similar to Kaden\\'s, however, instead of calculating the max-sum-so-far for the current index based solely on the last index, we greedily pick the maximum from the last k indices.\\n\\n```\\nclass Solution{\\n  public:\\n    int constrainedSubsetSum(vector<int>& nums, int k){\\n\\t  // max heap to store max sum so far for the last k elements \\n\\t  // the elements of the heap are pairs, {max sum for the index, index}\\n      priority_queue<pair<int, int>> pq;\\n\\t  // res = final result, cur = max sum so far for the current index\\n      int len = (int)nums.size(), res = 1 << 31, cur = 0;\\n      for(int idx = 0; idx < len; ++idx){\\n        while(!pq.empty() && idx - pq.top().second > k){\\n\\t\\t  // exclude the numbers which are not within k distance\\n          pq.pop();\\n        }\\n\\t\\t// kaden\\'s step, find the max sum for the current index and push it in the heap\\n        auto t = pq.empty() ? 0 : pq.top().first;\\t\\t\\n        cur = max(t + nums[idx], nums[idx]);                \\n        res = max(cur, res);\\n        pq.emplace(cur, idx);\\n      }\\n      return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution{\\n  public:\\n    int constrainedSubsetSum(vector<int>& nums, int k){\\n\\t  // max heap to store max sum so far for the last k elements \\n\\t  // the elements of the heap are pairs, {max sum for the index, index}",
                "codeTag": "Java"
            },
            {
                "id": 606666,
                "title": "simple-o-n-solution-with-decreasing-deque-and-without-using-extra-dp-array",
                "content": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        \\n        \\n        deque<pair<int, int>> q; // pair of <indexes, max subsequence sum ending at that index. We need not to have additional dp array \\n        \\n        \\n        \\n        int n = nums.size();\\n        \\n        int result = nums[0];\\n        \\n        q.push_back({0, nums[0]});\\n        \\n        for(int i = 1; i<n; i++)\\n        {\\n            if(q.front().first < i-k)\\n                q.pop_front();\\n            \\n            \\n            int maxSubSequenceSumEndingHere = max(q.front().second + nums[i], nums[i]);\\n            result = max(result, maxSubSequenceSumEndingHere);\\n            \\n            while(!q.empty() && q.back().second <= maxSubSequenceSumEndingHere)\\n            {\\n                q.pop_back();\\n            }\\n            q.push_back({i, maxSubSequenceSumEndingHere});\\n            \\n        }\\n        \\n        return result;\\n        \\n        \\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        \\n        \\n        deque<pair<int, int>> q; // pair of <indexes, max subsequence sum ending at that index. We need not to have additional dp array \\n        \\n        \\n        \\n        int n = nums.size();\\n        \\n        int result = nums[0];\\n        \\n        q.push_back({0, nums[0]});\\n        \\n        for(int i = 1; i<n; i++)\\n        {\\n            if(q.front().first < i-k)\\n                q.pop_front();\\n            \\n            \\n            int maxSubSequenceSumEndingHere = max(q.front().second + nums[i], nums[i]);\\n            result = max(result, maxSubSequenceSumEndingHere);\\n            \\n            while(!q.empty() && q.back().second <= maxSubSequenceSumEndingHere)\\n            {\\n                q.pop_back();\\n            }\\n            q.push_back({i, maxSubSequenceSumEndingHere});\\n            \\n        }\\n        \\n        return result;\\n        \\n        \\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 599195,
                "title": "thinking-process-of-why-we-need-decreasing-deque-monotonic-deque",
                "content": "There are brilliant answers in other post with similiar idea but I wish to share my thinking process here why decreasing deque was required. \\n\\nAfter reading the question, I think we need dp and I start to think about how to draw all states in tree. A good way might be ending with the current index being used. \\n\\nFor example, given input [10,2,-10,-8,5,20] and k = 2. When index is 4, we must use 5. If we want to connect to the begining of input 10, we cannot skip -10 or -8. \\n\\nTherefore, the state transfer method is something similar to dp[cur] = max(dp[cur], dp[i]+num[cur]) where i is from the range of `cur - k` to `cur`. \\n\\nAnswer must live in any end cur number is used. Therefore, we get the maximum value from dp array. \\n\\nTherefore, I have my first solution. \\n\\n```\\npublic int constrainedSubsetSum(int[] nums, int k) {\\n        int n = nums.length;\\n        int res = nums[0];\\n        int[] dp = new int[n]; // maximum using n-1 index \\n         dp[0] = nums[0];\\n        for (int i = 1; i < nums.length; i++){\\n            dp[i] = nums[i];\\n            for (int j = Math.max(0, i-k); j < i; j++){\\n                dp[i] = Math.max(dp[i], dp[j]+nums[i]);\\n            }\\n            res = Math.max(res, dp[i]);\\n        }\\n        \\n        \\n        return res;\\n    }\\n```\\n\\nHowever, this will give you \"Time Limit Exceeded\" as the time complexity can run up to N(nk) where n is the lenth of input array. \\n\\nWe need to optimize following step. \\n\\n```\\nfor (int j = Math.max(0, i-k); j < i; j++){\\n\\tdp[i] = Math.max(dp[i], dp[j]+nums[i]);\\n}\\n```\\n\\nThinking about what we did here is to get the best (largest) value in the range of i-k and i. If we can have an efficient data structure and query the best within a range while **maintaining it is not costly**. We need to maintain it when we travel across the array. We don\\'t need element that is smaller than i-k, for example,  [10,2,-10,-8,5,20] and k = 2, when we inspect 20, we only care dp[3], dp[4], other index must be poped from the data structure. \\n\\nHere we need to store the index in the data structure and not the value as we need to drop it easily. So the requirement is get max value efficiently and pop value when it is out of range. \\n\\nThis give you monotonic deque and of course you have to do this problem before. https://leetcode.com/problems/sliding-window-maximum/ \\n\\nTherefore, we can have the second solution and time will be optimized to O(N).\\n\\n```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int n = nums.length;\\n        int res = nums[0];\\n        int[] dp = new int[n]; // maximum using n-1 index \\n        dp[0] = nums[0];\\n        \\n        Deque<Integer> stack = new ArrayDeque<>();\\n        stack.offerLast(0);\\n        \\n        for (int i = 1; i < nums.length; i++){\\n            dp[i] = nums[i];\\n            \\n            // fulfill two conditions, query max and moving efficiently \\n            // make sure stack is valid \\n            while (!stack.isEmpty() && stack.peekFirst() < i - k){\\n                stack.pollFirst();\\n            }\\n            dp[i] = Math.max(dp[i], dp[stack.peekFirst()] + nums[i]);\\n            // for (int j = Math.max(0, i-k); j < i; j++){ // do this more efficiently \\n            //     dp[i] = Math.max(dp[i], dp[j]+nums[i]);\\n            // }\\n            \\n            // maintain stack \\n            while(!stack.isEmpty() && dp[i] > dp[stack.peekLast()]){\\n                stack.pollLast();\\n            }\\n            stack.offerLast(i);\\n            \\n            res = Math.max(res, dp[i]);\\n        }\\n        \\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int constrainedSubsetSum(int[] nums, int k) {\\n        int n = nums.length;\\n        int res = nums[0];\\n        int[] dp = new int[n]; // maximum using n-1 index \\n         dp[0] = nums[0];\\n        for (int i = 1; i < nums.length; i++){\\n            dp[i] = nums[i];\\n            for (int j = Math.max(0, i-k); j < i; j++){\\n                dp[i] = Math.max(dp[i], dp[j]+nums[i]);\\n            }\\n            res = Math.max(res, dp[i]);\\n        }\\n        \\n        \\n        return res;\\n    }\\n```\n```\\nfor (int j = Math.max(0, i-k); j < i; j++){\\n\\tdp[i] = Math.max(dp[i], dp[j]+nums[i]);\\n}\\n```\n```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int n = nums.length;\\n        int res = nums[0];\\n        int[] dp = new int[n]; // maximum using n-1 index \\n        dp[0] = nums[0];\\n        \\n        Deque<Integer> stack = new ArrayDeque<>();\\n        stack.offerLast(0);\\n        \\n        for (int i = 1; i < nums.length; i++){\\n            dp[i] = nums[i];\\n            \\n            // fulfill two conditions, query max and moving efficiently \\n            // make sure stack is valid \\n            while (!stack.isEmpty() && stack.peekFirst() < i - k){\\n                stack.pollFirst();\\n            }\\n            dp[i] = Math.max(dp[i], dp[stack.peekFirst()] + nums[i]);\\n            // for (int j = Math.max(0, i-k); j < i; j++){ // do this more efficiently \\n            //     dp[i] = Math.max(dp[i], dp[j]+nums[i]);\\n            // }\\n            \\n            // maintain stack \\n            while(!stack.isEmpty() && dp[i] > dp[stack.peekLast()]){\\n                stack.pollLast();\\n            }\\n            stack.offerLast(i);\\n            \\n            res = Math.max(res, dp[i]);\\n        }\\n        \\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 598436,
                "title": "simple-c-code-maximum-value-is-a-k-size-sliding-window",
                "content": "It\\'s not a hard question.\\n\\nBut just very curious how people could solve this kind of questions in less than 5 min in the contest....\\n\\n\\n```\\nint constrainedSubsetSum(vector<int>& nums, int k) {\\n\\n\\tint res = INT_MIN;\\n\\tvector<int> counter(nums.size(), 0);\\n\\tdeque<int> q;\\n\\n\\tfor (int i = 0; i < nums.size(); ++i) {\\n\\n\\t\\tint maxVal = 0;\\n\\n\\t\\tif (!q.empty()) maxVal = counter[q.front()];\\n\\n\\t\\tcounter[i] = max(nums[i], nums[i] + maxVal);\\n\\n\\t\\twhile(!q.empty() && counter[i] > counter[q.back()]) q.pop_back();\\n\\t\\tq.push_back(i);\\n\\n\\t\\tif (q.front() <= i - k) q.pop_front();\\n\\n\\t\\tres = max(res, counter[i]);\\n\\n\\t}\\n\\n\\treturn res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint constrainedSubsetSum(vector<int>& nums, int k) {\\n\\n\\tint res = INT_MIN;\\n\\tvector<int> counter(nums.size(), 0);\\n\\tdeque<int> q;\\n\\n\\tfor (int i = 0; i < nums.size(); ++i) {\\n\\n\\t\\tint maxVal = 0;\\n\\n\\t\\tif (!q.empty()) maxVal = counter[q.front()];\\n\\n\\t\\tcounter[i] = max(nums[i], nums[i] + maxVal);\\n\\n\\t\\twhile(!q.empty() && counter[i] > counter[q.back()]) q.pop_back();\\n\\t\\tq.push_back(i);\\n\\n\\t\\tif (q.front() <= i - k) q.pop_front();\\n\\n\\t\\tres = max(res, counter[i]);\\n\\n\\t}\\n\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 598237,
                "title": "simple-c-solution-with-multiset",
                "content": "```\\nclass Solution \\n{\\n    public:\\n    int constrainedSubsetSum(vector<int>& nums, int k) \\n    {\\n        int result=-2147483648;\\n        int n=nums.size();\\n        int dp[n+1];//dp[i+1] is the maximum sum of subarray nums[0]~nums[i]\\n        memset(dp,0,sizeof(dp));\\n        multiset<int> m={0};//maintain a list for last k states (for dp[i+1]: dp[i-k+1] to dp[i] are all feasible states)\\n        for(int i=0;i<n;i++)\\n        {\\n            dp[i+1]=nums[i];//nums[i] can always be the first element to start with\\n            dp[i+1]=max(dp[i+1],dp[i+1]+*m.rbegin());//*m.rbegin() is the largest among dp[i-k+1] to dp[i]\\n            if(m.size()<k)\\n            {\\n                m.insert(dp[i+1]);//still not reach the capacity\\n            }\\n            else\\n            {\\n                m.erase(m.find(dp[i+1-k]));//remove the state which is out of reach\\n                m.insert(dp[i+1]);//add the current state(it will be the previous state in the next round) instead\\n            }\\n        }\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            result=max(result,dp[i]);//all the nums[i] can be the last element\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public:\\n    int constrainedSubsetSum(vector<int>& nums, int k) \\n    {\\n        int result=-2147483648;\\n        int n=nums.size();\\n        int dp[n+1];//dp[i+1] is the maximum sum of subarray nums[0]~nums[i]\\n        memset(dp,0,sizeof(dp));\\n        multiset<int> m={0};//maintain a list for last k states (for dp[i+1]: dp[i-k+1] to dp[i] are all feasible states)\\n        for(int i=0;i<n;i++)\\n        {\\n            dp[i+1]=nums[i];//nums[i] can always be the first element to start with\\n            dp[i+1]=max(dp[i+1],dp[i+1]+*m.rbegin());//*m.rbegin() is the largest among dp[i-k+1] to dp[i]\\n            if(m.size()<k)\\n            {\\n                m.insert(dp[i+1]);//still not reach the capacity\\n            }\\n            else\\n            {\\n                m.erase(m.find(dp[i+1-k]));//remove the state which is out of reach\\n                m.insert(dp[i+1]);//add the current state(it will be the previous state in the next round) instead\\n            }\\n        }\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            result=max(result,dp[i]);//all the nums[i] can be the last element\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 598155,
                "title": "java-o-nlogk-easy-to-understand",
                "content": "Explanation: We can transform the problem into `dp[i]`, where `dp[i]` means the best sum we can do starting at position `i`, **obligatorily using** the element at `nums[i]`. Then, when we are computing for position `i`, we keep track of the the last `k` sums, and check if `nums[i]` plus the best sum among those is better than just `nums[i]`.\\n\\nI implement this using a `TreeMap` to find the best result in the last K and to also account for duplicates, and a `LinkedList` to keep track of the last K window.\\n\\n```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        TreeMap<Integer,Integer> count = new TreeMap<Integer,Integer>();\\n        LinkedList<Integer> window = new LinkedList<Integer>();\\n        \\n        int n = nums.length;\\n        int[] dp = new int[n];\\n        int ans = nums[0];\\n        \\n        for(int i = n-1; i >= 0; i--) {\\n            dp[i] = nums[i];\\n            Integer best = count.size()>0?count.lastKey():0;\\n            \\n            dp[i] = Math.max(dp[i],nums[i]+best);\\n            \\n            window.addFirst(dp[i]);\\n            count.put(dp[i],count.getOrDefault(dp[i],0)+1);\\n            \\n            ans = Math.max(ans,dp[i]);\\n            \\n            if (window.size() > k) {\\n                int tail = window.removeLast();\\n                if (count.get(tail) == 1) count.remove(tail);\\n                else count.put(tail,count.get(tail)-1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        TreeMap<Integer,Integer> count = new TreeMap<Integer,Integer>();\\n        LinkedList<Integer> window = new LinkedList<Integer>();\\n        \\n        int n = nums.length;\\n        int[] dp = new int[n];\\n        int ans = nums[0];\\n        \\n        for(int i = n-1; i >= 0; i--) {\\n            dp[i] = nums[i];\\n            Integer best = count.size()>0?count.lastKey():0;\\n            \\n            dp[i] = Math.max(dp[i],nums[i]+best);\\n            \\n            window.addFirst(dp[i]);\\n            count.put(dp[i],count.getOrDefault(dp[i],0)+1);\\n            \\n            ans = Math.max(ans,dp[i]);\\n            \\n            if (window.size() > k) {\\n                int tail = window.removeLast();\\n                if (count.get(tail) == 1) count.remove(tail);\\n                else count.put(tail,count.get(tail)-1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 597892,
                "title": "c-dp-with-priority-queue",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        vector <int> dp(nums.size(), 0);\\n        priority_queue <pair <int, int>> q;\\n        dp[0] = nums[0];\\n        q.emplace(dp[0], 0);\\n        for(int i = 1; i < nums.size(); i++){ \\n            while(q.size() && q.top().second < i-k) q.pop();\\n            dp[i] = max(q.top().first + nums[i], nums[i]);\\n            q.emplace(dp[i], i);\\n        }   \\n        return *max_element(dp.begin(), dp.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        vector <int> dp(nums.size(), 0);\\n        priority_queue <pair <int, int>> q;\\n        dp[0] = nums[0];\\n        q.emplace(dp[0], 0);\\n        for(int i = 1; i < nums.size(); i++){ \\n            while(q.size() && q.top().second < i-k) q.pop();\\n            dp[i] = max(q.top().first + nums[i], nums[i]);\\n            q.emplace(dp[i], i);\\n        }   \\n        return *max_element(dp.begin(), dp.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 597851,
                "title": "python-dp-maxheap",
                "content": "```\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        dp = [0]*len(nums) # dp[i] = max subset sum of nums[:i+1] when taking i-th value\\n        dp[0] = nums[0]\\n        heap = [(-dp[0],0)] # max heap of (-dp[i], i)\\n        for i in range(1, len(nums)):\\n            while i-heap[0][1] > k:\\n                heapq.heappop(heap)\\n            mdp = -heap[0][0]\\n            dp[i] = max(nums[i], nums[i]+mdp)\\n            heapq.heappush(heap, (-dp[i],i))\\n        return max(dp)\\n```",
                "solutionTags": [],
                "code": "```\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        dp = [0]*len(nums) # dp[i] = max subset sum of nums[:i+1] when taking i-th value\\n        dp[0] = nums[0]\\n        heap = [(-dp[0],0)] # max heap of (-dp[i], i)\\n        for i in range(1, len(nums)):\\n            while i-heap[0][1] > k:\\n                heapq.heappop(heap)\\n            mdp = -heap[0][0]\\n            dp[i] = max(nums[i], nums[i]+mdp)\\n            heapq.heappush(heap, (-dp[i],i))\\n        return max(dp)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 597844,
                "title": "segment-tree-c-solution",
                "content": "```\\nclass SegmentTree{\\n  long int n;   \\n  vector<long int> tree;\\n\\npublic:\\n  SegmentTree(long int v) : n(4*v){\\n    tree.resize(4*v);\\n  }\\n\\n  long int query(long int requiredLeft, long int requiredRight, long int left, long int right, long int current = 1){\\n    if(left > right)\\n      return 0;\\n\\n    if(requiredLeft > right || requiredRight < left)\\n      return 0;\\n\\n    if(left >= requiredLeft && right <= requiredRight)\\n      return tree[current];\\n\\n    long int mid = (left + right) / 2;\\n    return max(query(requiredLeft,requiredRight,left,mid,2*current) , query(requiredLeft,requiredRight,mid+1,right,2*current + 1));\\n  }\\n\\n  void update(long int idx, long int value, long int left, long int right, long int current = 1){\\n    if(idx < left || idx > right)\\n      return;\\n\\n    tree[current] = max(value,tree[current]);\\n    if(left != right){\\n      long int mid = (left + right) / 2;\\n      update(idx,value,left,mid,2*current);\\n      update(idx,value,mid+1,right,2*current + 1);\\n    }\\n  }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        \\n        long int n = nums.size();\\n        SegmentTree tree(n + 1);\\n        vector<long int> ans(n);\\n        \\n        for(long int i = 0; i < k; i++){\\n            ans[i] = max(tree.query(1,i,1,n),0L) + nums[i];\\n            tree.update(i + 1, ans[i],1,n);\\n        }\\n        \\n        for(long int i = k; i < n; i++){  \\n            ans[i] = tree.query(i - k + 1, i ,1,n) + nums[i];\\n            tree.update(i + 1, ans[i], 1, n);\\n        }\\n        return *max_element(ans.begin(),ans.end());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass SegmentTree{\\n  long int n;   \\n  vector<long int> tree;\\n\\npublic:\\n  SegmentTree(long int v) : n(4*v){\\n    tree.resize(4*v);\\n  }\\n\\n  long int query(long int requiredLeft, long int requiredRight, long int left, long int right, long int current = 1){\\n    if(left > right)\\n      return 0;\\n\\n    if(requiredLeft > right || requiredRight < left)\\n      return 0;\\n\\n    if(left >= requiredLeft && right <= requiredRight)\\n      return tree[current];\\n\\n    long int mid = (left + right) / 2;\\n    return max(query(requiredLeft,requiredRight,left,mid,2*current) , query(requiredLeft,requiredRight,mid+1,right,2*current + 1));\\n  }\\n\\n  void update(long int idx, long int value, long int left, long int right, long int current = 1){\\n    if(idx < left || idx > right)\\n      return;\\n\\n    tree[current] = max(value,tree[current]);\\n    if(left != right){\\n      long int mid = (left + right) / 2;\\n      update(idx,value,left,mid,2*current);\\n      update(idx,value,mid+1,right,2*current + 1);\\n    }\\n  }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        \\n        long int n = nums.size();\\n        SegmentTree tree(n + 1);\\n        vector<long int> ans(n);\\n        \\n        for(long int i = 0; i < k; i++){\\n            ans[i] = max(tree.query(1,i,1,n),0L) + nums[i];\\n            tree.update(i + 1, ans[i],1,n);\\n        }\\n        \\n        for(long int i = k; i < n; i++){  \\n            ans[i] = tree.query(i - k + 1, i ,1,n) + nums[i];\\n            tree.update(i + 1, ans[i], 1, n);\\n        }\\n        return *max_element(ans.begin(),ans.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 597824,
                "title": "dp-with-sliding-window-beats-100",
                "content": "```\\n public int constrainedSubsetSum(int[] nums, int k) {\\n        int[] dp = new int[nums.length];\\n        dp[0] = nums[0];\\n        int maxx = dp[0];\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(0);\\n        for (int i = 1; i < nums.length; i++) { \\n            int max = nums[i];\\n            if (!queue.isEmpty()) {\\n                max = Math.max(nums[i], nums[i] + dp[queue.peek()]);\\n            }\\n        \\n            if (!queue.isEmpty() && i - queue.peek() >= k) {\\n                queue.poll();\\n            }\\n            while (!queue.isEmpty() && max > dp[queue.peek()])\\n                queue.poll();\\n            queue.add(i);\\n            dp[i] = max;\\n            maxx = Math.max(maxx, max);\\n        }\\n        \\n        return maxx;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\n public int constrainedSubsetSum(int[] nums, int k) {\\n        int[] dp = new int[nums.length];\\n        dp[0] = nums[0];\\n        int maxx = dp[0];\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(0);\\n        for (int i = 1; i < nums.length; i++) { \\n            int max = nums[i];\\n            if (!queue.isEmpty()) {\\n                max = Math.max(nums[i], nums[i] + dp[queue.peek()]);\\n            }\\n        \\n            if (!queue.isEmpty() && i - queue.peek() >= k) {\\n                queue.poll();\\n            }\\n            while (!queue.isEmpty() && max > dp[queue.peek()])\\n                queue.poll();\\n            queue.add(i);\\n            dp[i] = max;\\n            maxx = Math.max(maxx, max);\\n        }\\n        \\n        return maxx;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 597800,
                "title": "java-dp-deque-solution",
                "content": "```\\n    public int constrainedSubsetSum(int[] a, int k) {\\n        int[] dp = new int[a.length+1];\\n        Deque<Integer> dq = new LinkedList<>();\\n        int res = Integer.MIN_VALUE;\\n        for(int i = 0; i < a.length; i++) {\\n            dp[i] = a[i];\\n            while(!dq.isEmpty() && i - dq.getFirst() > k) dq.removeFirst();\\n            if(!dq.isEmpty()) dp[i] = Math.max(dp[i], dp[dq.getFirst()] + a[i]);\\n            res = Math.max(res, dp[i]);\\n            while(!dq.isEmpty() && dp[i] > dp[dq.getLast()]) dq.removeLast();\\n            dq.addLast(i);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int constrainedSubsetSum(int[] a, int k) {\\n        int[] dp = new int[a.length+1];\\n        Deque<Integer> dq = new LinkedList<>();\\n        int res = Integer.MIN_VALUE;\\n        for(int i = 0; i < a.length; i++) {\\n            dp[i] = a[i];\\n            while(!dq.isEmpty() && i - dq.getFirst() > k) dq.removeFirst();\\n            if(!dq.isEmpty()) dp[i] = Math.max(dp[i], dp[dq.getFirst()] + a[i]);\\n            res = Math.max(res, dp[i]);\\n            while(!dq.isEmpty() && dp[i] > dp[dq.getLast()]) dq.removeLast();\\n            dq.addLast(i);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 597752,
                "title": "python-max-min-heap-with-explanation",
                "content": "We need to store previous sums. If they are negative use min-heap, otherwise use max-heap. For each element in nums store the max possible sum along with the index value. If the index value is violated remove it from the heap. Here is the python code:\\n\\n```\\nimport heapq\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        min_h = []\\n        heapq.heapify(min_h)\\n        max_h = []\\n        heapq.heapify(max_h)\\n        \\n        for i,e in enumerate(nums):\\n            if i==0:\\n                cum_sum = nums[0]\\n                max_sub = cum_sum\\n                if cum_sum>=0:\\n                    heapq.heappush(max_h, (-cum_sum,0))\\n                else:\\n                    heapq.heappush(min_h, (cum_sum, 0))    \\n            else:\\n                TT = []\\n                if min_h:\\n                    tmp = min_h[0]\\n                    while i-tmp[1]>k:\\n                        _ = heapq.heappop(min_h)\\n                        if not min_h:\\n                            break\\n                        tmp = min_h[0]\\n                if min_h:\\n                    TT.append(min_h[0][0] + nums[i])\\n                if max_h:\\n                    tmp = max_h[0]\\n                    while i-tmp[1]>k:\\n                        _ = heapq.heappop(max_h)\\n                        if not max_h:\\n                            break\\n                        tmp = max_h[0]\\n                if max_h:\\n                    TT.append(-max_h[0][0] + nums[i])\\n                TT.append(nums[i])\\n                \\n                cum_sum = max(TT)\\n                if cum_sum>=0:\\n                    heapq.heappush(max_h, (-cum_sum,i))\\n                else:\\n                    heapq.heappush(min_h, (cum_sum, i))    \\n                max_sub = max(max_sub, cum_sum)\\n                \\n        return max_sub\\n```",
                "solutionTags": [],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        min_h = []\\n        heapq.heapify(min_h)\\n        max_h = []\\n        heapq.heapify(max_h)\\n        \\n        for i,e in enumerate(nums):\\n            if i==0:\\n                cum_sum = nums[0]\\n                max_sub = cum_sum\\n                if cum_sum>=0:\\n                    heapq.heappush(max_h, (-cum_sum,0))\\n                else:\\n                    heapq.heappush(min_h, (cum_sum, 0))    \\n            else:\\n                TT = []\\n                if min_h:\\n                    tmp = min_h[0]\\n                    while i-tmp[1]>k:\\n                        _ = heapq.heappop(min_h)\\n                        if not min_h:\\n                            break\\n                        tmp = min_h[0]\\n                if min_h:\\n                    TT.append(min_h[0][0] + nums[i])\\n                if max_h:\\n                    tmp = max_h[0]\\n                    while i-tmp[1]>k:\\n                        _ = heapq.heappop(max_h)\\n                        if not max_h:\\n                            break\\n                        tmp = max_h[0]\\n                if max_h:\\n                    TT.append(-max_h[0][0] + nums[i])\\n                TT.append(nums[i])\\n                \\n                cum_sum = max(TT)\\n                if cum_sum>=0:\\n                    heapq.heappush(max_h, (-cum_sum,i))\\n                else:\\n                    heapq.heappush(min_h, (cum_sum, i))    \\n                max_sub = max(max_sub, cum_sum)\\n                \\n        return max_sub\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040252,
                "title": "just-lis-with-condition-on-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    typedef pair<int, int> P;\\n    int constrainedSubsetSum(vector<int>& nums, int k)\\n     {\\n        int n = nums.size();\\n        \\n        vector<int> t(n, 0);\\n        t = nums;\\n        priority_queue<P, vector<P>> pq;\\n        pq.push({t[0], 0});\\n        \\n        int maxR = t[0];\\n        \\n        for(int i = 1; i<n; i++) \\n        {\\n            \\n            while(!pq.empty() && pq.top().second + k  < i )\\n                pq.pop();\\n            \\n            t[i] = max(t[i], nums[i] + pq.top().first);\\n            pq.push({t[i], i});\\n            \\n            maxR = max(maxR, t[i]);\\n        }\\n        \\n        \\n        return maxR;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef pair<int, int> P;\\n    int constrainedSubsetSum(vector<int>& nums, int k)\\n     {\\n        int n = nums.size();\\n        \\n        vector<int> t(n, 0);\\n        t = nums;\\n        priority_queue<P, vector<P>> pq;\\n        pq.push({t[0], 0});\\n        \\n        int maxR = t[0];\\n        \\n        for(int i = 1; i<n; i++) \\n        {\\n            \\n            while(!pq.empty() && pq.top().second + k  < i )\\n                pq.pop();\\n            \\n            t[i] = max(t[i], nums[i] + pq.top().first);\\n            pq.push({t[i], i});\\n            \\n            maxR = max(maxR, t[i]);\\n        }\\n        \\n        \\n        return maxR;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4019780,
                "title": "c-using-dp-monotonic-queue-maxqueue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass MaxStack \\n{\\n    stack<pair<int,int>> S; //{val, max}\\npublic:\\n    void push(int val)\\n    {\\n        int mx = (S.empty()) ? val : max(val, S.top().second);\\n        S.push({val, mx});\\n    }\\n\\n    void pop()\\n    {\\n        S.pop();\\n    }\\n\\n    int top()\\n    {\\n        return S.top().first;\\n    }\\n\\n    int getMax()\\n    {\\n        return S.top().second;\\n    }\\n\\n    bool empty()\\n    {\\n        return S.empty();\\n    }\\n\\n    int size()\\n    {\\n        return S.size();\\n    }\\n};\\n\\nclass MaxQueue\\n{\\n    MaxStack S1, S2;\\npublic:\\n    void push(int val)\\n    {\\n        S1.push(val);\\n    }\\n    \\n    void tranferFromS1ToS2()\\n    {\\n        while(!S1.empty())\\n        {\\n            S2.push(S1.top());\\n            S1.pop();\\n        }\\n    }\\n\\n    void pop()\\n    {\\n        if(S2.empty()) tranferFromS1ToS2();\\n        S2.pop();\\n    }\\n\\n    int front()\\n    {\\n        if(S2.empty()) tranferFromS1ToS2();\\n        return S2.top();\\n    }\\n\\n    int getMax()\\n    {\\n        if(S2.empty()) return S1.getMax();\\n        if(S1.empty()) return S2.getMax();\\n        return max(S1.getMax(), S2.getMax());\\n    }\\n\\n    bool empty()\\n    {\\n        return S1.empty() && S2.empty();\\n    }\\n\\n    int size()\\n    {\\n        return S1.size() + S2.size();\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    //DP + Monotonic Queue (MaxQueue)\\n    // j <= i + k => next window of size : k (starting from i + 1 to i + k)\\n    //dp[i] = maxSum if i include a[i] + ...\\n    int constrainedSubsetSum(vector<int>& a, int k) \\n    {\\n        int n = a.size();\\n        MaxQueue Q;\\n        int dp[n]; memset(&dp, 0x00, sizeof(dp));\\n\\n        for(int i = n - 1; i >= 0; i--)\\n        {\\n            dp[i] = a[i];\\n\\n            if(!Q.empty()) dp[i] = max(dp[i], a[i] + Q.getMax());\\n\\n            Q.push(dp[i]);\\n\\n            while(!Q.empty() && Q.size() > k) Q.pop();\\n        }\\n\\n        int ans = dp[0];\\n        for(int i = 1; i < n; i++)\\n            ans = max(ans, dp[i]);\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass MaxStack \\n{\\n    stack<pair<int,int>> S; //{val, max}\\npublic:\\n    void push(int val)\\n    {\\n        int mx = (S.empty()) ? val : max(val, S.top().second);\\n        S.push({val, mx});\\n    }\\n\\n    void pop()\\n    {\\n        S.pop();\\n    }\\n\\n    int top()\\n    {\\n        return S.top().first;\\n    }\\n\\n    int getMax()\\n    {\\n        return S.top().second;\\n    }\\n\\n    bool empty()\\n    {\\n        return S.empty();\\n    }\\n\\n    int size()\\n    {\\n        return S.size();\\n    }\\n};\\n\\nclass MaxQueue\\n{\\n    MaxStack S1, S2;\\npublic:\\n    void push(int val)\\n    {\\n        S1.push(val);\\n    }\\n    \\n    void tranferFromS1ToS2()\\n    {\\n        while(!S1.empty())\\n        {\\n            S2.push(S1.top());\\n            S1.pop();\\n        }\\n    }\\n\\n    void pop()\\n    {\\n        if(S2.empty()) tranferFromS1ToS2();\\n        S2.pop();\\n    }\\n\\n    int front()\\n    {\\n        if(S2.empty()) tranferFromS1ToS2();\\n        return S2.top();\\n    }\\n\\n    int getMax()\\n    {\\n        if(S2.empty()) return S1.getMax();\\n        if(S1.empty()) return S2.getMax();\\n        return max(S1.getMax(), S2.getMax());\\n    }\\n\\n    bool empty()\\n    {\\n        return S1.empty() && S2.empty();\\n    }\\n\\n    int size()\\n    {\\n        return S1.size() + S2.size();\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    //DP + Monotonic Queue (MaxQueue)\\n    // j <= i + k => next window of size : k (starting from i + 1 to i + k)\\n    //dp[i] = maxSum if i include a[i] + ...\\n    int constrainedSubsetSum(vector<int>& a, int k) \\n    {\\n        int n = a.size();\\n        MaxQueue Q;\\n        int dp[n]; memset(&dp, 0x00, sizeof(dp));\\n\\n        for(int i = n - 1; i >= 0; i--)\\n        {\\n            dp[i] = a[i];\\n\\n            if(!Q.empty()) dp[i] = max(dp[i], a[i] + Q.getMax());\\n\\n            Q.push(dp[i]);\\n\\n            while(!Q.empty() && Q.size() > k) Q.pop();\\n        }\\n\\n        int ans = dp[0];\\n        for(int i = 1; i < n; i++)\\n            ans = max(ans, dp[i]);\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003556,
                "title": "swift-deque-clear-solution",
                "content": "\\n```\\nclass Solution {\\n    func constrainedSubsetSum(_ nums: [Int], _ k: Int) -> Int {\\n        let N = nums.count\\n        var dp = Array(repeating: 0, count: N)\\n        dp[0] = nums[0]\\n        var deque = Deque<Int>()\\n        deque.push(dp[0])\\n\\n        for i in 1..<N {\\n            dp[i] = max(nums[i], deque.max()! + nums[i])\\n\\n            if deque.count == k {\\n                deque.pop()\\n            }\\n            deque.push(dp[i])\\n        }\\n\\n        var res = Int.min\\n        for i in 0..<N {\\n            res = max(res, dp[i])\\n        }\\n        return res\\n    }\\n}\\n\\n//Default Deque Implementation\\nclass Deque<T:Comparable> {\\n    var q = [T]()\\n    var maxq = [T]()\\n    var minq = [T]()\\n    var count : Int { q.count }\\n    var isEmpty : Bool { q.isEmpty }\\n    func push(_ ele: T) {\\n        q.append(ele)\\n\\n        while !maxq.isEmpty, maxq.last! < ele {\\n            maxq.removeLast()\\n        }\\n        maxq.append(ele)\\n\\n        while !minq.isEmpty, minq.last! > ele {\\n            minq.removeLast()\\n        }\\n        minq.append(ele)\\n    }\\n\\n    func max() -> T? {\\n        return maxq.first\\n    }\\n\\n    func min() -> T? {\\n        return minq.first\\n    }\\n\\n    func pop() -> T? {\\n        var deleteVal = q.removeFirst()\\n        \\n        if deleteVal == maxq.first {\\n            maxq.removeFirst()\\n        }\\n\\n        if deleteVal == minq.first {\\n            minq.removeFirst()\\n        }\\n\\n        return deleteVal\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func constrainedSubsetSum(_ nums: [Int], _ k: Int) -> Int {\\n        let N = nums.count\\n        var dp = Array(repeating: 0, count: N)\\n        dp[0] = nums[0]\\n        var deque = Deque<Int>()\\n        deque.push(dp[0])\\n\\n        for i in 1..<N {\\n            dp[i] = max(nums[i], deque.max()! + nums[i])\\n\\n            if deque.count == k {\\n                deque.pop()\\n            }\\n            deque.push(dp[i])\\n        }\\n\\n        var res = Int.min\\n        for i in 0..<N {\\n            res = max(res, dp[i])\\n        }\\n        return res\\n    }\\n}\\n\\n//Default Deque Implementation\\nclass Deque<T:Comparable> {\\n    var q = [T]()\\n    var maxq = [T]()\\n    var minq = [T]()\\n    var count : Int { q.count }\\n    var isEmpty : Bool { q.isEmpty }\\n    func push(_ ele: T) {\\n        q.append(ele)\\n\\n        while !maxq.isEmpty, maxq.last! < ele {\\n            maxq.removeLast()\\n        }\\n        maxq.append(ele)\\n\\n        while !minq.isEmpty, minq.last! > ele {\\n            minq.removeLast()\\n        }\\n        minq.append(ele)\\n    }\\n\\n    func max() -> T? {\\n        return maxq.first\\n    }\\n\\n    func min() -> T? {\\n        return minq.first\\n    }\\n\\n    func pop() -> T? {\\n        var deleteVal = q.removeFirst()\\n        \\n        if deleteVal == maxq.first {\\n            maxq.removeFirst()\\n        }\\n\\n        if deleteVal == minq.first {\\n            minq.removeFirst()\\n        }\\n\\n        return deleteVal\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3987592,
                "title": "python-dp-heap-sliding-window",
                "content": "```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        dp=[0 for i in range(len(nums))]\\n        h=[]\\n        for i in range(len(nums)-1,-1,-1):\\n            if i+k+1<len(nums):\\n                while h and h[0][1]>=i+k+1:heappop(h)\\n            a=0\\n            if h:a=max(0,-h[0][0])\\n            dp[i]=nums[i]+a\\n            heappush(h,(-dp[i],i))\\n        return max(dp)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        dp=[0 for i in range(len(nums))]\\n        h=[]\\n        for i in range(len(nums)-1,-1,-1):\\n            if i+k+1<len(nums):\\n                while h and h[0][1]>=i+k+1:heappop(h)\\n            a=0\\n            if h:a=max(0,-h[0][0])\\n            dp[i]=nums[i]+a\\n            heappush(h,(-dp[i],i))\\n        return max(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979066,
                "title": "three-approaches",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    //reccusrion +memo(TLE)\\n\\n    //  unordered_map<string,int>m;\\n\\n    // int solve(int i,vector<int>&nums,int k,int p){\\n    //     if(i==nums.size())return 0;\\n\\n    //     int nottake=0;\\n    //     string temp=to_string(i)+\\',\\'+to_string(p);\\n    //     if(m.find(temp)!=m.end())return m[temp];\\n    //     if(p==-1||i-p<=k){\\n    //         nottake=solve(i+1,nums,k,p);\\n    //     }\\n    //     int take=0;\\n\\n    //     if(p==-1||i-p<=k){\\n    //         take=nums[i]+solve(i+1,nums,k,i);\\n    //     }\\n    //     return m[temp]= max(take,nottake);\\n    // }\\n   \\n\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n\\n\\n    //  if(k==1)return *max_element(nums.begin(),nums.end());\\n    \\n    //   int ans= solve(0,nums,k,-1);\\n    //   if(ans==0){\\n    //       return *max_element(nums.begin(),nums.end());\\n    //   }else{\\n    //       return ans;\\n    //   }\\n    \\n    //Tabulation(TLE)\\n\\n    // int n=nums.size();\\n    // vector<int>dp(n,0);\\n    // for(int i=0;i<nums.size();i++)dp[i]=nums[i];\\n    // int ans=dp[0];\\n    // for(int i=1;i<n;i++){\\n    //     for(int j=i-1;i-j<=k&&j>=0;j--){\\n    //         dp[i]=max(dp[i],nums[i]+dp[j]);\\n    //     }\\n    //     ans=max(ans,dp[i]);\\n    // }\\n\\n     //Using priority_queue(Accepted)\\n\\n     int n=nums.size();\\n    vector<int>dp(n,0);\\n\\n\\n    for(int i=0;i<nums.size();i++)dp[i]=nums[i];\\n    priority_queue<pair<int,int>,vector<pair<int,int>>>pq;\\n    pq.push({dp[0],0});\\n    int ans=dp[0];\\n    for(int i=1;i<n;i++){\\n        while(!pq.empty()&&pq.top().second<i-k)pq.pop();\\n\\n        dp[i]=max(dp[i],nums[i]+pq.top().first);\\n        pq.push({dp[i],i});\\n        ans=max(ans,dp[i]);\\n    }\\n    \\n    return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    //reccusrion +memo(TLE)\\n\\n    //  unordered_map<string,int>m;\\n\\n    // int solve(int i,vector<int>&nums,int k,int p){\\n    //     if(i==nums.size())return 0;\\n\\n    //     int nottake=0;\\n    //     string temp=to_string(i)+\\',\\'+to_string(p);\\n    //     if(m.find(temp)!=m.end())return m[temp];\\n    //     if(p==-1||i-p<=k){\\n    //         nottake=solve(i+1,nums,k,p);\\n    //     }\\n    //     int take=0;\\n\\n    //     if(p==-1||i-p<=k){\\n    //         take=nums[i]+solve(i+1,nums,k,i);\\n    //     }\\n    //     return m[temp]= max(take,nottake);\\n    // }\\n   \\n\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n\\n\\n    //  if(k==1)return *max_element(nums.begin(),nums.end());\\n    \\n    //   int ans= solve(0,nums,k,-1);\\n    //   if(ans==0){\\n    //       return *max_element(nums.begin(),nums.end());\\n    //   }else{\\n    //       return ans;\\n    //   }\\n    \\n    //Tabulation(TLE)\\n\\n    // int n=nums.size();\\n    // vector<int>dp(n,0);\\n    // for(int i=0;i<nums.size();i++)dp[i]=nums[i];\\n    // int ans=dp[0];\\n    // for(int i=1;i<n;i++){\\n    //     for(int j=i-1;i-j<=k&&j>=0;j--){\\n    //         dp[i]=max(dp[i],nums[i]+dp[j]);\\n    //     }\\n    //     ans=max(ans,dp[i]);\\n    // }\\n\\n     //Using priority_queue(Accepted)\\n\\n     int n=nums.size();\\n    vector<int>dp(n,0);\\n\\n\\n    for(int i=0;i<nums.size();i++)dp[i]=nums[i];\\n    priority_queue<pair<int,int>,vector<pair<int,int>>>pq;\\n    pq.push({dp[0],0});\\n    int ans=dp[0];\\n    for(int i=1;i<n;i++){\\n        while(!pq.empty()&&pq.top().second<i-k)pq.pop();\\n\\n        dp[i]=max(dp[i],nums[i]+pq.top().first);\\n        pq.push({dp[i],i});\\n        ans=max(ans,dp[i]);\\n    }\\n    \\n    return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954171,
                "title": "easy-to-understand-basic-solution-c-priority-queue-iit-roorkee",
                "content": "\\n# Complexity\\n- Time complexity: O(N)\\n- Space complexity: O(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k)\\n    {\\n        int maxi=INT_MIN;\\n        int n=nums.size();\\n        priority_queue<pair<int,int>>pq;\\n        pq.push({0,n-1});\\n        for(int i=0;i<n;i++)\\n        {\\n            while(!pq.empty())\\n            {\\n            int x=pq.top().first;\\n            int y=pq.top().second;\\n            if(i<=y)\\n            {\\n                int val=x+nums[i];\\n                if(val>nums[i])\\n                {\\n                    maxi=max(maxi,val);\\n                    pq.push({val,i+k});\\n                }\\n                else\\n                {\\n                    maxi=max(maxi,nums[i]);\\n                    pq.push({nums[i],i+k});\\n                }\\n                break;\\n            }\\n            else\\n            {\\n                pq.pop();\\n            }\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k)\\n    {\\n        int maxi=INT_MIN;\\n        int n=nums.size();\\n        priority_queue<pair<int,int>>pq;\\n        pq.push({0,n-1});\\n        for(int i=0;i<n;i++)\\n        {\\n            while(!pq.empty())\\n            {\\n            int x=pq.top().first;\\n            int y=pq.top().second;\\n            if(i<=y)\\n            {\\n                int val=x+nums[i];\\n                if(val>nums[i])\\n                {\\n                    maxi=max(maxi,val);\\n                    pq.push({val,i+k});\\n                }\\n                else\\n                {\\n                    maxi=max(maxi,nums[i]);\\n                    pq.push({nums[i],i+k});\\n                }\\n                break;\\n            }\\n            else\\n            {\\n                pq.pop();\\n            }\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3937248,
                "title": "c-easy-priority-queue-tc-o-nlogn-sc-o-n",
                "content": "# Intuition\\nQuestion is much similar to JUMP GAME(6);\\nJust the addition of little Kadane\\'s algo variation,\\n\\n# Approach\\n->It uses a priority queue to keep track of the maximum sum subsequence ending at each index. \\n->The queue only stores elements within the valid range (within \\'k\\' indices).\\n->At each step, the code updates the current maximum sum considering the current element and the maximum sum ending before it. \\n->The final result is the maximum subsequence sum respecting the given constraint.\\n\\n# Complexity\\n- Time complexity:\\nO(nlog(n))\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        priority_queue<pair<int,int>>pq;\\n        pq.push({nums[0],0});\\n        int c=nums[0];\\n        int maxi=nums[0];\\n        int ans=nums[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            while(pq.top().second<i-k)\\n            {\\n                pq.pop();\\n            }\\n           \\n            c=max(nums[i],pq.top().first+nums[i]);\\n            ans=max(ans,c);\\n            pq.push({c,i});         \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        priority_queue<pair<int,int>>pq;\\n        pq.push({nums[0],0});\\n        int c=nums[0];\\n        int maxi=nums[0];\\n        int ans=nums[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            while(pq.top().second<i-k)\\n            {\\n                pq.pop();\\n            }\\n           \\n            c=max(nums[i],pq.top().first+nums[i]);\\n            ans=max(ans,c);\\n            pq.push({c,i});         \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3922267,
                "title": "python-simple-with-priority-queue",
                "content": "# Intuition\\nKeep on max priority queue sums seen so far.\\nOn every step remove from top those that are out boundry i-k.\\nTake top and try to construct current candidate.\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def constrainedSubsetSum(self, A, k):\\n        pq, result = [], -inf\\n        for i, v in enumerate(A):\\n            while pq and (i - pq[0][1] > k): heappop(pq)\\n            if pq: v = max(v, v-pq[0][0])\\n            heappush(pq, (-v, i))\\n            result = max(result, v)    \\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def constrainedSubsetSum(self, A, k):\\n        pq, result = [], -inf\\n        for i, v in enumerate(A):\\n            while pq and (i - pq[0][1] > k): heappop(pq)\\n            if pq: v = max(v, v-pq[0][0])\\n            heappush(pq, (-v, i))\\n            result = max(result, v)    \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3921215,
                "title": "c-solution-with-intuition",
                "content": "# Intuition\\nith element will store maximum sum of subsequence (MSS) starting from it so it will choose MSS starting from  its next k elements this is idea of DP and for storing MSS we will use Monotonic queue(deque).\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(k)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        \\n        int n=nums.size();\\n        deque<int> q;\\n        int ans=nums[n-1];\\n       \\n        for(int i=n-1;i>=0;i--)\\n        {           \\n            nums[i]+=(q.size() ? q.front() : 0);\\n            if(q.size() && i+k<n && q.front() == nums[i+k])  q.pop_front();\\n            \\n            while(q.size() && q.back()<nums[i])\\n            {\\n               q.pop_back();\\n            }\\n           \\n            if(nums[i]>0)q.push_back(nums[i]);\\n            ans=max(nums[i],ans);\\n        }\\n        \\n       return ans;\\n      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Sliding Window",
                    "Monotonic Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        \\n        int n=nums.size();\\n        deque<int> q;\\n        int ans=nums[n-1];\\n       \\n        for(int i=n-1;i>=0;i--)\\n        {           \\n            nums[i]+=(q.size() ? q.front() : 0);\\n            if(q.size() && i+k<n && q.front() == nums[i+k])  q.pop_front();\\n            \\n            while(q.size() && q.back()<nums[i])\\n            {\\n               q.pop_back();\\n            }\\n           \\n            if(nums[i]>0)q.push_back(nums[i]);\\n            ans=max(nums[i],ans);\\n        }\\n        \\n       return ans;\\n      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865640,
                "title": "dp-pq",
                "content": "# Intuition\\nDp+ priorityQueue\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.Comparator;\\nimport java.util.PriorityQueue;\\n\\nclass Solution {\\n\\tpublic int constrainedSubsetSum(int[] nums, int k) {\\n\\n\\n\\t\\tPriorityQueue<int[]> q = new PriorityQueue<>(new Comparator<int[]>() {\\n\\t\\t\\t@Override\\n\\t\\t\\tpublic int compare(int[] o1, int[] o2) {\\n\\t\\t\\t\\tif(o2[1]!=o1[1]){\\n\\t\\t\\t\\t\\treturn o2[1]-o1[1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn o1[0]-o2[0];\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\t\\n\\t\\tint max=nums[0];\\n\\t\\tint n = nums.length;\\n\\t\\t\\n\\t\\tq.add(new int[]{0,nums[0]});\\n\\t\\t\\n\\t\\tfor (int i=1;i<n;i++){\\n\\t\\t\\t\\n\\t\\t\\twhile (!q.isEmpty()&&q.peek()[0]<i-k){\\n\\t\\t\\t\\tq.poll();\\n\\t\\t\\t}\\n\\t\\t\\tmax = Math.max(max,Math.max(nums[i], q.peek()[1]+nums[i]));\\n\\t\\t\\tq.add(new int[]{i,Math.max(nums[i], q.peek()[1]+nums[i])});\\n\\t\\t}\\n\\t\\t\\n\\t\\t\\n\\t\\treturn max;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.Comparator;\\nimport java.util.PriorityQueue;\\n\\nclass Solution {\\n\\tpublic int constrainedSubsetSum(int[] nums, int k) {\\n\\n\\n\\t\\tPriorityQueue<int[]> q = new PriorityQueue<>(new Comparator<int[]>() {\\n\\t\\t\\t@Override\\n\\t\\t\\tpublic int compare(int[] o1, int[] o2) {\\n\\t\\t\\t\\tif(o2[1]!=o1[1]){\\n\\t\\t\\t\\t\\treturn o2[1]-o1[1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn o1[0]-o2[0];\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\t\\n\\t\\tint max=nums[0];\\n\\t\\tint n = nums.length;\\n\\t\\t\\n\\t\\tq.add(new int[]{0,nums[0]});\\n\\t\\t\\n\\t\\tfor (int i=1;i<n;i++){\\n\\t\\t\\t\\n\\t\\t\\twhile (!q.isEmpty()&&q.peek()[0]<i-k){\\n\\t\\t\\t\\tq.poll();\\n\\t\\t\\t}\\n\\t\\t\\tmax = Math.max(max,Math.max(nums[i], q.peek()[1]+nums[i]));\\n\\t\\t\\tq.add(new int[]{i,Math.max(nums[i], q.peek()[1]+nums[i])});\\n\\t\\t}\\n\\t\\t\\n\\t\\t\\n\\t\\treturn max;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3860721,
                "title": "simple-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int arr[]=new int[nums.length];\\n        arr[arr.length-1]=nums[nums.length-1];\\n        ArrayList<Integer> l=new ArrayList<Integer>();\\n        l.add(nums[nums.length-1]);\\n        int p=nums.length-1;\\n        int max=arr[arr.length-1];\\n        for(int i=nums.length-2;i>=0;i--)\\n        {\\n            if(i+k>=nums.length-1)\\n            {\\n                if(nums[i]+l.get(l.size()-1)>nums[i])\\n                {\\n                   arr[i]=nums[i]+l.get(l.size()-1);\\n                }\\n                else\\n                {\\n                    arr[i]=nums[i];\\n                }\\n                if(l.size()==1)\\n                {\\n                    if(l.get(0)>arr[i])\\n                    {\\n                        l.add(0,arr[i]);\\n                    }\\n                    else\\n                    {\\n                        l.add(arr[i]);\\n                    }\\n                }\\n                else\\n                {\\n                    int low=0,high=l.size()-1;\\n                    int index=0;\\n                    while(low<=high)\\n                    {\\n                        int mid=(low+high)/2;\\n                        if(l.get(mid)>=arr[i])\\n                        {\\n                            index=mid;\\n                            high=mid-1;\\n                        }\\n                        else\\n                        {\\n                            low=mid+1;\\n                            index=mid+1;\\n                        }\\n                    }\\n                    l.add(index,arr[i]);\\n                }\\n            }\\n            else\\n            {\\n                 int low=0,high=l.size()-1;\\n                 while(low<=high)\\n                 {\\n                     int mid=(low+high)/2;\\n                     if(l.get(mid)==arr[p])\\n                     {\\n                         l.remove(mid);\\n                         break;\\n                     }\\n                     else if(l.get(mid)>arr[p])\\n                     {\\n                         high=mid-1;\\n                     }\\n                     else\\n                     {\\n                         low=mid+1;\\n                     }\\n                 }\\n                 p--;\\n                 if((nums[i]+l.get(l.size()-1))>nums[i])\\n                {\\n                   arr[i]=nums[i]+l.get(l.size()-1);\\n                }\\n                else\\n                {\\n                    arr[i]=nums[i];\\n                }\\n                if(l.size()==1)\\n                {\\n                    if(l.get(0)>arr[i])\\n                    {\\n                        l.add(0,arr[i]);\\n                    }\\n                    else\\n                    {\\n                        l.add(arr[i]);\\n                    }\\n                }\\n                else\\n                {\\n                    low=0;\\n                    high=l.size()-1;\\n                    int index=0;\\n                    while(low<=high)\\n                    {\\n                        int mid=(low+high)/2;\\n                        if(l.get(mid)>=arr[i])\\n                        {\\n                            index=mid;\\n                            high=mid-1;\\n                        }\\n                        else\\n                        {\\n                            low=mid+1;\\n                            index=mid+1;\\n                        }\\n                    }\\n                    l.add(index,arr[i]);\\n                }\\n\\n            }\\n            if(arr[i]>max)\\n            {\\n                max=arr[i];\\n            }\\n        }\\n\\n        return max;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int arr[]=new int[nums.length];\\n        arr[arr.length-1]=nums[nums.length-1];\\n        ArrayList<Integer> l=new ArrayList<Integer>();\\n        l.add(nums[nums.length-1]);\\n        int p=nums.length-1;\\n        int max=arr[arr.length-1];\\n        for(int i=nums.length-2;i>=0;i--)\\n        {\\n            if(i+k>=nums.length-1)\\n            {\\n                if(nums[i]+l.get(l.size()-1)>nums[i])\\n                {\\n                   arr[i]=nums[i]+l.get(l.size()-1);\\n                }\\n                else\\n                {\\n                    arr[i]=nums[i];\\n                }\\n                if(l.size()==1)\\n                {\\n                    if(l.get(0)>arr[i])\\n                    {\\n                        l.add(0,arr[i]);\\n                    }\\n                    else\\n                    {\\n                        l.add(arr[i]);\\n                    }\\n                }\\n                else\\n                {\\n                    int low=0,high=l.size()-1;\\n                    int index=0;\\n                    while(low<=high)\\n                    {\\n                        int mid=(low+high)/2;\\n                        if(l.get(mid)>=arr[i])\\n                        {\\n                            index=mid;\\n                            high=mid-1;\\n                        }\\n                        else\\n                        {\\n                            low=mid+1;\\n                            index=mid+1;\\n                        }\\n                    }\\n                    l.add(index,arr[i]);\\n                }\\n            }\\n            else\\n            {\\n                 int low=0,high=l.size()-1;\\n                 while(low<=high)\\n                 {\\n                     int mid=(low+high)/2;\\n                     if(l.get(mid)==arr[p])\\n                     {\\n                         l.remove(mid);\\n                         break;\\n                     }\\n                     else if(l.get(mid)>arr[p])\\n                     {\\n                         high=mid-1;\\n                     }\\n                     else\\n                     {\\n                         low=mid+1;\\n                     }\\n                 }\\n                 p--;\\n                 if((nums[i]+l.get(l.size()-1))>nums[i])\\n                {\\n                   arr[i]=nums[i]+l.get(l.size()-1);\\n                }\\n                else\\n                {\\n                    arr[i]=nums[i];\\n                }\\n                if(l.size()==1)\\n                {\\n                    if(l.get(0)>arr[i])\\n                    {\\n                        l.add(0,arr[i]);\\n                    }\\n                    else\\n                    {\\n                        l.add(arr[i]);\\n                    }\\n                }\\n                else\\n                {\\n                    low=0;\\n                    high=l.size()-1;\\n                    int index=0;\\n                    while(low<=high)\\n                    {\\n                        int mid=(low+high)/2;\\n                        if(l.get(mid)>=arr[i])\\n                        {\\n                            index=mid;\\n                            high=mid-1;\\n                        }\\n                        else\\n                        {\\n                            low=mid+1;\\n                            index=mid+1;\\n                        }\\n                    }\\n                    l.add(index,arr[i]);\\n                }\\n\\n            }\\n            if(arr[i]>max)\\n            {\\n                max=arr[i];\\n            }\\n        }\\n\\n        return max;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3843805,
                "title": "python-decreasing-queue-o-n",
                "content": "# Approach\\nThis is almost exactly the same as this problem: https://leetcode.com/problems/jump-game-vi/\\nOnly difference is we have an if condition at the beginning of the for loop in this one. If the number in the queue is negative, there is no point in adding it to our current number so we skip it.\\n\\n# Code\\n```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        q = deque([0])\\n        for i in range(1, n):\\n            # if the number we have at the beginning of the queue is less than 0 there is no point in including it in our result\\n            if nums[q[0]] > 0:\\n                nums[i] += nums[q[0]]\\n            # if what we have currently is greater than what we had before, we can continue building up on the current number and forget about the rest\\n            while q and nums[i] > nums[q[-1]]:\\n                q.pop()\\n            q.append(i)\\n            # we can jump a maximum of k units from any index so we pop from the beginning of the queue if we are outside that window\\n            if i - k >= q[0]:\\n                q.popleft()\\n        return max(nums)\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Monotonic Queue"
                ],
                "code": "```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        q = deque([0])\\n        for i in range(1, n):\\n            # if the number we have at the beginning of the queue is less than 0 there is no point in including it in our result\\n            if nums[q[0]] > 0:\\n                nums[i] += nums[q[0]]\\n            # if what we have currently is greater than what we had before, we can continue building up on the current number and forget about the rest\\n            while q and nums[i] > nums[q[-1]]:\\n                q.pop()\\n            q.append(i)\\n            # we can jump a maximum of k units from any index so we pop from the beginning of the queue if we are outside that window\\n            if i - k >= q[0]:\\n                q.popleft()\\n        return max(nums)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717849,
                "title": "o-nlogn-priority-queue-easy-to-understand",
                "content": "# Intuition\\nFor every index we will store the maximum constrained subsequence sum ending at that index. We only need to know the maximum of last k.\\n\\n# Approach\\nWe will use a priority queue to store the maximums ending at every index. If the difference between current index and index of the maximum is greater than k, then we will pop until the difference is less than k or there are no other elements in the priority queue.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        int ans = nums[0];\\n        priority_queue<pair<int,int>> pq;\\n        pq.push({nums[0],0});\\n        for(int i = 1; i<nums.size(); i++){\\n            if(i - pq.top().second > k){\\n                while(pq.empty() == false && i - pq.top().second > k) pq.pop();\\n                if(pq.empty()){\\n                    ans = max(ans,nums[i]);\\n                    pq.push({nums[i],i});\\n                }\\n                else{\\n                    int curr = nums[i] + pq.top().first;\\n                    ans = max(ans,max(curr,nums[i]));\\n                    pq.push({max(curr,nums[i]),i});\\n                }\\n            }\\n            else{\\n                int curr = nums[i] + pq.top().first;\\n                ans = max(ans,max(curr,nums[i]));\\n                pq.push({max(curr,nums[i]),i});\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        int ans = nums[0];\\n        priority_queue<pair<int,int>> pq;\\n        pq.push({nums[0],0});\\n        for(int i = 1; i<nums.size(); i++){\\n            if(i - pq.top().second > k){\\n                while(pq.empty() == false && i - pq.top().second > k) pq.pop();\\n                if(pq.empty()){\\n                    ans = max(ans,nums[i]);\\n                    pq.push({nums[i],i});\\n                }\\n                else{\\n                    int curr = nums[i] + pq.top().first;\\n                    ans = max(ans,max(curr,nums[i]));\\n                    pq.push({max(curr,nums[i]),i});\\n                }\\n            }\\n            else{\\n                int curr = nums[i] + pq.top().first;\\n                ans = max(ans,max(curr,nums[i]));\\n                pq.push({max(curr,nums[i]),i});\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3708290,
                "title": "easiest-hard-on-leetcode",
                "content": "```\\nint constrainedSubsetSum(vector<int>& nums, int k)\\n    {  \\n        int n=nums.size();\\n        vector<int>dp(n); // dp[i]:max subsequence sum provided that we take nums[i] \\n        priority_queue<pair<int,int>>pq; // max sum in the sliding window and the index \\n        int ans=dp[0]=nums[0];\\n        \\n        pq.push({dp[0],0});\\n        \\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            while(!pq.empty() and i-pq.top().second>k)\\n                pq.pop(); // index out of bounds\\n            \\n            dp[i]=nums[i]+max(pq.top().first,0); // if all negatives do not choose any\\n            pq.push({dp[i],i});\\n            ans=max(ans,dp[i]);\\n        }\\n        return ans;\\n        \\n    }\\n\\t```\\n\\t\\n\\tBy the way u can also implement the same logic using Deque(monotonic queue teachnique ,if u dont know u should)",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nint constrainedSubsetSum(vector<int>& nums, int k)\\n    {  \\n        int n=nums.size();\\n        vector<int>dp(n); // dp[i]:max subsequence sum provided that we take nums[i] \\n        priority_queue<pair<int,int>>pq; // max sum in the sliding window and the index \\n        int ans=dp[0]=nums[0];\\n        \\n        pq.push({dp[0],0});\\n        \\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            while(!pq.empty() and i-pq.top().second>k)\\n                pq.pop(); // index out of bounds\\n            \\n            dp[i]=nums[i]+max(pq.top().first,0); // if all negatives do not choose any\\n            pq.push({dp[i],i});\\n            ans=max(ans,dp[i]);\\n        }\\n        return ans;\\n        \\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 3480988,
                "title": "c-monotonic-queue-beat-100",
                "content": "Check the hints in problem description\\n\\n```\\npublic class Solution {\\n    public int ConstrainedSubsetSum(int[] nums, int k) {\\n        int n=nums.Length;\\n        LinkedList<(int i, int s)> l=new LinkedList<(int i, int s)>();\\n        int res=nums[0];\\n        int left=0;\\n        int sum=nums[0];\\n        l.AddLast((0,sum));\\n        for(int i=1;i<n;i++){\\n            while(l.Count>0 && l.First.Value.i<i-k)\\n                l.RemoveFirst();\\n            \\n            sum=nums[i]+(l.First.Value.s > 0 ? l.First.Value.s : 0);\\n            while(l.Count>0 && l.Last.Value.s<=sum)\\n                    l.RemoveLast();\\n                \\n            l.AddLast((i,sum));\\n            res=Math.Max(res,sum);\\n        }\\n        return res;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Monotonic Queue"
                ],
                "code": "```\\npublic class Solution {\\n    public int ConstrainedSubsetSum(int[] nums, int k) {\\n        int n=nums.Length;\\n        LinkedList<(int i, int s)> l=new LinkedList<(int i, int s)>();\\n        int res=nums[0];\\n        int left=0;\\n        int sum=nums[0];\\n        l.AddLast((0,sum));\\n        for(int i=1;i<n;i++){\\n            while(l.Count>0 && l.First.Value.i<i-k)\\n                l.RemoveFirst();\\n            \\n            sum=nums[i]+(l.First.Value.s > 0 ? l.First.Value.s : 0);\\n            while(l.Count>0 && l.Last.Value.s<=sum)\\n                    l.RemoveLast();\\n                \\n            l.AddLast((i,sum));\\n            res=Math.Max(res,sum);\\n        }\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3359967,
                "title": "alternative-to-find-max-in-sliding-window-situations",
                "content": "# Intuition\\n\\nThe problem can be solved by a simple Dynamic Programming implementation, the trick is that we need to find the max value in a range of cells.\\n\\nThis search is recurrent and follows a pattern very similar to a Sliding Window, as we want to find the max between the cell previous to the current (`i`) and K cells before (`i-k`).\\n\\nThe idea is that every time we update the current cell we check if it is greater or equal than the max value on the window, if it is simply set this as the max (set the maxIndex to point to it). If many slides happen and no new max is found the previous max will eventually fall outside the window we need to recalculate the new min.\\nThis can be done in multiple ways\\n- Mono Deque algorithm - Fastes Way in theory\\n  - Mono Deque allows us to keep track of global min/max and local min/max (if it is min or max depends on how it is implemented)\\n- Scan the window again - Slowest Way in theory\\n  - To recalculate the new min we simply need to scan the new window and and take note of the giggest value.\\n  - In the worst case we will have a sequence from 1000 to -1000 making us recalculate the max at each time we move the window.\\n- Log(n) Datastructures (segment trees, heaps, BST, etc)\\n\\n\\nNote: the description of the problem says that k can be between 1 and 10^5, but if you run the test cases you will notice that it doesnt accept values above 10005.\\n\\nNote: in case you want to know more about the Segment Tree, here you can read more: https://leetcode.com/problems/best-team-with-no-conflicts/solutions/3124655/fenwick-treebinary-indexed-tree-and-segment-tree-variation-to-find-max-or-min/\\n\\n# Approach\\n- Dynamic Programming\\n- MonoDeque\\n- Segment Tree\\n\\n# Complexity\\n- Time complexity:\\n  - Mono Deque: $$O(n)$$\\n  - Scan window: $$O(n*k)$$\\n  - Segment Tree: $$O(n*log(k))$$\\n\\n- Space complexity:\\n  - Mono Deque: $$O(n)$$\\n  - Scan window: $$O(n)$$\\n  - Segment Tree: $$O(n)$$\\n\\n# Codes\\n## Mono Deque\\n![image.png](https://assets.leetcode.com/users/images/5171476c-9f58-41ca-9dd9-72e27a5f1acf_1680196511.668469.png)\\n\\n```java\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int max=nums[0];\\n        int[] memo=new int[nums.length];\\n        memo[0]=nums[0];\\n        ArrayDeque<Integer> md=new ArrayDeque<>();\\n        md.push(0);\\n        for(int i=1;i<nums.length;i++) {\\n            // if the last number index (oldest added) is previous\\n            // to the window we remove it\\n            if(md.getLast()<i-k) md.removeLast();\\n            // The max sum with the curr numberis either with\\n            // it alone or with it and the prev max sum\\n            int v=nums[i], m=memo[i]=Math.max(v,memo[md.getLast()]+v);\\n            // Mono deque implementation to remove smaller values\\n            // than the tail (this is the magic/heart)\\n            while(!md.isEmpty()&&memo[md.peek()]<=m) md.pop();\\n            md.push(i);\\n            if(m>max) max=m;\\n        }\\n        return max;\\n    }\\n}\\n```\\n\\n## Scan window\\n![image.png](https://assets.leetcode.com/users/images/1d914899-4195-4001-a268-b61adac2dcec_1680194908.3771832.png)\\n\\n```java\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int max=nums[0], maxIndex=0;\\n        int[] memo=new int[nums.length];\\n        memo[0]=nums[0];\\n        for(int i=1;i<nums.length;i++) {\\n            // Window moved past maxIndex, lets recalculate\\n            if(maxIndex<i-k) {\\n                int v=Integer.MIN_VALUE;\\n                for(int j=i-1;i-j<=k;j--) {\\n                    if(memo[j]>v) {\\n                        v=memo[j];\\n                        maxIndex=j;\\n                    }\\n                }\\n            }\\n            // The max sum with the curr numberis either with\\n            // it alone or with it and the prev max sum\\n            int v=nums[i], m=memo[i]=Math.max(v,memo[maxIndex]+v);\\n            // found new position of the maxIndex, lets set it\\n            if(m>=max) {\\n                maxIndex=i;\\n                max=m;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```\\n\\n## Segment Tree\\n![image.png](https://assets.leetcode.com/users/images/7f2f2004-2a43-4d08-a3e9-f6c724aa6446_1680196568.3171434.png)\\n\\n```java\\nclass Solution {\\n    int[] st;\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int[] memo=new int[nums.length];\\n        st=new int[2*memo.length];\\n        int max=Integer.MIN_VALUE/2;\\n        for(int i=nums.length-1;i>-1;i--) {\\n            int v=nums[i], m=v;\\n            m=Math.max(v,v+get(i+1,i+k));\\n            max=Math.max(max,m);\\n            memo[i]=m;\\n            update(i,m);\\n        }\\n        return max;\\n    }\\n    void update(int pos, int val) {\\n        pos+=st.length>>1;\\n        st[pos]=val;\\n        for(int i=pos;i>0;i>>=1) {\\n            if(i%2==0) st[i>>1]=Math.max(st[i],i<st.length-1?st[i+1]:Integer.MIN_VALUE/2);\\n            else st[i>>1]=Math.max(st[i-1],st[i]);\\n        }\\n    }\\n    int get(int left, int right) {\\n        left+=st.length>>1;\\n        right+=st.length>>1;\\n        right=Math.min(right,st.length-1);\\n        int max=Integer.MIN_VALUE/2;\\n        while(left<right) {\\n            if(left%2==1) max=Math.max(max,st[left++]);\\n            max=Math.max(max,st[left]);\\n            left>>=1;\\n            if(right%2==0) max=Math.max(max,st[right--]);\\n            max=Math.max(max,st[right]);\\n            right>>=1;\\n        }\\n        return left==right?Math.max(max,st[left]): max;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int max=nums[0];\\n        int[] memo=new int[nums.length];\\n        memo[0]=nums[0];\\n        ArrayDeque<Integer> md=new ArrayDeque<>();\\n        md.push(0);\\n        for(int i=1;i<nums.length;i++) {\\n            // if the last number index (oldest added) is previous\\n            // to the window we remove it\\n            if(md.getLast()<i-k) md.removeLast();\\n            // The max sum with the curr numberis either with\\n            // it alone or with it and the prev max sum\\n            int v=nums[i], m=memo[i]=Math.max(v,memo[md.getLast()]+v);\\n            // Mono deque implementation to remove smaller values\\n            // than the tail (this is the magic/heart)\\n            while(!md.isEmpty()&&memo[md.peek()]<=m) md.pop();\\n            md.push(i);\\n            if(m>max) max=m;\\n        }\\n        return max;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int max=nums[0], maxIndex=0;\\n        int[] memo=new int[nums.length];\\n        memo[0]=nums[0];\\n        for(int i=1;i<nums.length;i++) {\\n            // Window moved past maxIndex, lets recalculate\\n            if(maxIndex<i-k) {\\n                int v=Integer.MIN_VALUE;\\n                for(int j=i-1;i-j<=k;j--) {\\n                    if(memo[j]>v) {\\n                        v=memo[j];\\n                        maxIndex=j;\\n                    }\\n                }\\n            }\\n            // The max sum with the curr numberis either with\\n            // it alone or with it and the prev max sum\\n            int v=nums[i], m=memo[i]=Math.max(v,memo[maxIndex]+v);\\n            // found new position of the maxIndex, lets set it\\n            if(m>=max) {\\n                maxIndex=i;\\n                max=m;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    int[] st;\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int[] memo=new int[nums.length];\\n        st=new int[2*memo.length];\\n        int max=Integer.MIN_VALUE/2;\\n        for(int i=nums.length-1;i>-1;i--) {\\n            int v=nums[i], m=v;\\n            m=Math.max(v,v+get(i+1,i+k));\\n            max=Math.max(max,m);\\n            memo[i]=m;\\n            update(i,m);\\n        }\\n        return max;\\n    }\\n    void update(int pos, int val) {\\n        pos+=st.length>>1;\\n        st[pos]=val;\\n        for(int i=pos;i>0;i>>=1) {\\n            if(i%2==0) st[i>>1]=Math.max(st[i],i<st.length-1?st[i+1]:Integer.MIN_VALUE/2);\\n            else st[i>>1]=Math.max(st[i-1],st[i]);\\n        }\\n    }\\n    int get(int left, int right) {\\n        left+=st.length>>1;\\n        right+=st.length>>1;\\n        right=Math.min(right,st.length-1);\\n        int max=Integer.MIN_VALUE/2;\\n        while(left<right) {\\n            if(left%2==1) max=Math.max(max,st[left++]);\\n            max=Math.max(max,st[left]);\\n            left>>=1;\\n            if(right%2==0) max=Math.max(max,st[right--]);\\n            max=Math.max(max,st[right]);\\n            right>>=1;\\n        }\\n        return left==right?Math.max(max,st[left]): max;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3280287,
                "title": "java-solution-using-deque",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int[] dp = new int[nums.length];\\n        dp[0] = nums[0];\\n        int max = dp[0];\\n        Deque<Integer> q = new ArrayDeque<>();\\n        q.offer(nums[0]);\\n        for(int i = 1; i < nums.length; i++){\\n            dp[i] = nums[i];\\n\\n            // if element is out of range, then remove the 1st element from queue\\n            if(i>k && q.getFirst() == dp[i-k-1]){\\n                q.removeFirst();\\n            }\\n            //update max value of i by comparing it with current element to first element of the \\n            // queue\\n            dp[i]=Math.max(dp[i],q.getFirst()+nums[i]);\\n\\n            // remove untill currrent sum is greater than last element\\n            //this monotonically decreasing queue\\n            while(!q.isEmpty() && (q.getLast()<dp[i])){\\n                q.removeLast();\\n            }\\n            q.addLast(dp[i]);\\n            max=Math.max(max,dp[i]);\\n        }\\n        \\n        return max;\\n    }\\n    \\n}\\n```\\n\\nRefer to the below problem which is similar\\n[Shortest Subarray with Sum at Least K](https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/description/)\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int[] dp = new int[nums.length];\\n        dp[0] = nums[0];\\n        int max = dp[0];\\n        Deque<Integer> q = new ArrayDeque<>();\\n        q.offer(nums[0]);\\n        for(int i = 1; i < nums.length; i++){\\n            dp[i] = nums[i];\\n\\n            // if element is out of range, then remove the 1st element from queue\\n            if(i>k && q.getFirst() == dp[i-k-1]){\\n                q.removeFirst();\\n            }\\n            //update max value of i by comparing it with current element to first element of the \\n            // queue\\n            dp[i]=Math.max(dp[i],q.getFirst()+nums[i]);\\n\\n            // remove untill currrent sum is greater than last element\\n            //this monotonically decreasing queue\\n            while(!q.isEmpty() && (q.getLast()<dp[i])){\\n                q.removeLast();\\n            }\\n            q.addLast(dp[i]);\\n            max=Math.max(max,dp[i]);\\n        }\\n        \\n        return max;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257221,
                "title": "c-dp-monoqueue-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nslight modification of jump vi as there jump can be of [1,k] steps here gap bw elements of subsequence can be of [1,k] .For that we maintain monoqueue to get the max sum in range of k and if adding to this sum increases the final sum then we add it otherwise not\\nAt last we get the all possible max sums that can be generated starting subseq at every index maximum out of those will be our ans \\nConsider my jump game 6 solution if required  \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\na dp and monoqueue is used to mintain the max sum ans sums in range of k res. \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(k)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        deque<int> dq;\\n        vector<int> dp(nums.size(),0);\\n        dq.push_back(nums.size()-1);\\n        dp.back()=nums.back();\\n        int ans=nums.back();\\n        for(int i=nums.size()-2;i>=0;i--){\\n            while(dq.size() && (dq.front()>i+k)){\\n                dq.pop_front();\\n            }\\n            dp[i]=max(nums[i],nums[i]+dp[dq.front()]);\\n            ans=max(ans,dp[i]);\\n            while(dq.size() && dp[i]>=dp[dq.back()]){\\n                dq.pop_back();\\n            }\\n            dq.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        deque<int> dq;\\n        vector<int> dp(nums.size(),0);\\n        dq.push_back(nums.size()-1);\\n        dp.back()=nums.back();\\n        int ans=nums.back();\\n        for(int i=nums.size()-2;i>=0;i--){\\n            while(dq.size() && (dq.front()>i+k)){\\n                dq.pop_front();\\n            }\\n            dp[i]=max(nums[i],nums[i]+dp[dq.front()]);\\n            ans=max(ans,dp[i]);\\n            while(dq.size() && dp[i]>=dp[dq.back()]){\\n                dq.pop_back();\\n            }\\n            dq.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3244226,
                "title": "python-simple-dp-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums, k):\\n        n = len(nums)\\n\\n        dp, stack = [nums[0]] + [0]*(n-1), []\\n\\n        for i in range(1,n):\\n            while stack and stack[0][1] + k < i:\\n                heappop(stack)\\n\\n            heappush(stack,(-dp[i-1],i-1))\\n\\n            dp[i] = max(0,-stack[0][0]) + nums[i]\\n\\n        return max(dp)\\n\\n\\n\\n\\n\\n            \\n\\n            \\n\\n            \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n\\n\\n\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums, k):\\n        n = len(nums)\\n\\n        dp, stack = [nums[0]] + [0]*(n-1), []\\n\\n        for i in range(1,n):\\n            while stack and stack[0][1] + k < i:\\n                heappop(stack)\\n\\n            heappush(stack,(-dp[i-1],i-1))\\n\\n            dp[i] = max(0,-stack[0][0]) + nums[i]\\n\\n        return max(dp)\\n\\n\\n\\n\\n\\n            \\n\\n            \\n\\n            \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n\\n\\n\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3242743,
                "title": "easy-c-solution",
                "content": "**Solution 1 (DP --TLE)**\\n\\nWe can use the simple bottom up Dp  concept.\\n\\n```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int dp[n+1];\\n        memset(dp,INT_MIN,sizeof dp);\\n        for(int i=0;i<n;i++)\\n        {\\n            int idx=max(i-k,0);\\n            dp[i]=nums[i];\\n            for(int j=i-1;j>=idx;j--)\\n            {\\n                dp[i]=max({dp[i],dp[j]+nums[i]});\\n            }\\n        }\\n        int ma=INT_MIN;\\n        for(int i=0;i<n;i++) ma=max(ma,dp[i]);\\n        return ma;\\n    }\\n};\\n```\\n\\n**Solution 2 (Max Priority Queue --- Accepted)**\\n\\nWe will take max priority queue with pair and store in form of ({val,index}). At every index if current index-index of top or priority queue is >k then we will pop that pair from priority queue otherwise we will take that accordingly.For more clearity check the code.\\n\\n```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        priority_queue<pair<int,int>>pq;\\n        int ma=INT_MIN,s=0;\\n        s=nums[0];\\n        ma=max(ma,s);\\n        pq.push({s,0});\\n        for(int i=1;i<n;i++)\\n        {\\n            while((i-pq.top().second)>k)\\n            {\\n                pq.pop();\\n            }\\n            auto it=pq.top();\\n            int val=it.first;\\n            s=max(0,val)+nums[i];\\n            ma=max(ma,s);\\n            pq.push({s,i});\\n            \\n        }\\n        return ma;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int dp[n+1];\\n        memset(dp,INT_MIN,sizeof dp);\\n        for(int i=0;i<n;i++)\\n        {\\n            int idx=max(i-k,0);\\n            dp[i]=nums[i];\\n            for(int j=i-1;j>=idx;j--)\\n            {\\n                dp[i]=max({dp[i],dp[j]+nums[i]});\\n            }\\n        }\\n        int ma=INT_MIN;\\n        for(int i=0;i<n;i++) ma=max(ma,dp[i]);\\n        return ma;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        priority_queue<pair<int,int>>pq;\\n        int ma=INT_MIN,s=0;\\n        s=nums[0];\\n        ma=max(ma,s);\\n        pq.push({s,0});\\n        for(int i=1;i<n;i++)\\n        {\\n            while((i-pq.top().second)>k)\\n            {\\n                pq.pop();\\n            }\\n            auto it=pq.top();\\n            int val=it.first;\\n            s=max(0,val)+nums[i];\\n            ma=max(ma,s);\\n            pq.push({s,i});\\n            \\n        }\\n        return ma;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3133756,
                "title": "short-and-easy-decreasing-subsequence-sum-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor every element we need to keep track of maximum subsequence sum ending at previous k elements only\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nkeep a Queue of size maximum k. The front of this queue will have the maximum subsequence sum ending at one of the last k elements. Keep moving the widow by one element and deleting the unwanted stuff from the queue created. \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(k)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    typedef pair<int,int> pii;\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int res=nums[0];\\n        deque<pii> dq;\\n        dq.push_back({nums[0],0});\\n        for(int i=1; i<n; i++){\\n            while(!dq.empty() && i-dq.front().second > k) dq.pop_front();\\n            int sum=max(dq.front().first,0)+nums[i];\\n            while(!dq.empty() && dq.back().first<=sum) dq.pop_back();\\n            dq.push_back({sum,i});\\n            res=max(res,sum);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Queue",
                    "Monotonic Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef pair<int,int> pii;\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int res=nums[0];\\n        deque<pii> dq;\\n        dq.push_back({nums[0],0});\\n        for(int i=1; i<n; i++){\\n            while(!dq.empty() && i-dq.front().second > k) dq.pop_front();\\n            int sum=max(dq.front().first,0)+nums[i];\\n            while(!dq.empty() && dq.back().first<=sum) dq.pop_back();\\n            dq.push_back({sum,i});\\n            res=max(res,sum);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111911,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn constrained_subset_sum(nums: Vec<i32>, k: i32) -> i32 {\\n        let mut dp = vec![0; nums.len()];\\n        let mut max = nums[0];\\n        let mut q = std::collections::VecDeque::new();\\n        for i in 0..nums.len() {\\n            dp[i] = nums[i];\\n            if let Some(&j) = q.front() {\\n                dp[i] = std::cmp::max(dp[i], dp[j] + nums[i]);\\n            }\\n            max = std::cmp::max(max, dp[i]);\\n            while let Some(&j) = q.back() {\\n                if dp[j] < dp[i] {\\n                    q.pop_back();\\n                } else {\\n                    break;\\n                }\\n            }\\n            q.push_back(i);\\n            if let Some(&j) = q.front() {\\n                if i as i32 - j as i32 >= k {\\n                    q.pop_front();\\n                }\\n            }\\n        }\\n        max\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn constrained_subset_sum(nums: Vec<i32>, k: i32) -> i32 {\\n        let mut dp = vec![0; nums.len()];\\n        let mut max = nums[0];\\n        let mut q = std::collections::VecDeque::new();\\n        for i in 0..nums.len() {\\n            dp[i] = nums[i];\\n            if let Some(&j) = q.front() {\\n                dp[i] = std::cmp::max(dp[i], dp[j] + nums[i]);\\n            }\\n            max = std::cmp::max(max, dp[i]);\\n            while let Some(&j) = q.back() {\\n                if dp[j] < dp[i] {\\n                    q.pop_back();\\n                } else {\\n                    break;\\n                }\\n            }\\n            q.push_back(i);\\n            if let Some(&j) = q.front() {\\n                if i as i32 - j as i32 >= k {\\n                    q.pop_front();\\n                }\\n            }\\n        }\\n        max\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3065962,
                "title": "heap-solution-python",
                "content": "# Code\\n```\\nimport heapq\\nfrom typing import List\\n\\n\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        q = [(0, -1)]\\n\\n        ans = nums[0]\\n        for i, num in enumerate(nums):\\n            while q and i - q[0][1] > k:\\n                heapq.heappop(q)\\n            s, idx = q[0]\\n            ans = max(ans, num, -s + num)\\n            heapq.heappush(q, (min(s - num, -num), i))\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport heapq\\nfrom typing import List\\n\\n\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        q = [(0, -1)]\\n\\n        ans = nums[0]\\n        for i, num in enumerate(nums):\\n            while q and i - q[0][1] > k:\\n                heapq.heappop(q)\\n            s, idx = q[0]\\n            ans = max(ans, num, -s + num)\\n            heapq.heappush(q, (min(s - num, -num), i))\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049591,
                "title": "js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar constrainedSubsetSum = function (nums, k) {\\n  const q = [];\\n  const sum = Array(nums.length).fill(0);\\n  let res = nums[0];\\n  for (let i = 0; i < nums.length; i++) {\\n    sum[i] = nums[i];\\n    if(q.length) sum[i] += sum[q[0]];\\n    res = Math.max(res, sum[i]);\\n    if (q.length && i - q[0] >= k) q.shift();\\n    while (q.length && sum[q[q.length - 1]] <= sum[i]) q.pop();\\n    if (sum[i] > 0) q.push(i);\\n  }\\n  return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar constrainedSubsetSum = function (nums, k) {\\n  const q = [];\\n  const sum = Array(nums.length).fill(0);\\n  let res = nums[0];\\n  for (let i = 0; i < nums.length; i++) {\\n    sum[i] = nums[i];\\n    if(q.length) sum[i] += sum[q[0]];\\n    res = Math.max(res, sum[i]);\\n    if (q.length && i - q[0] >= k) q.shift();\\n    while (q.length && sum[q[q.length - 1]] <= sum[i]) q.pop();\\n    if (sum[i] > 0) q.push(i);\\n  }\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3013906,
                "title": "c-easy-and-3-line-solution-only-priority-queue-nicely-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        priority_queue<pair<int,int>>q; // to store max sum so far and the corresponding index\\n        int n=nums.size(),ans=nums[0];\\n        q.push({nums[0],0});\\n        for(int i=1;i<n;i++){\\n            while((i-q.top().second)>k) q.pop(); // if the window size is exceeding k than pop- out the values from the queue \\n            ans=max(ans,max(nums[i],nums[i]+q.top().first));  // maximum result so far\\n            q.push({max(nums[i],nums[i]+q.top().first),i});   // storing the maximum result with corresponding index\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        priority_queue<pair<int,int>>q; // to store max sum so far and the corresponding index\\n        int n=nums.size(),ans=nums[0];\\n        q.push({nums[0],0});\\n        for(int i=1;i<n;i++){\\n            while((i-q.top().second)>k) q.pop(); // if the window size is exceeding k than pop- out the values from the queue \\n            ans=max(ans,max(nums[i],nums[i]+q.top().first));  // maximum result so far\\n            q.push({max(nums[i],nums[i]+q.top().first),i});   // storing the maximum result with corresponding index\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3010597,
                "title": "dp-monotonic-queue-beat-100-in-js",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar constrainedSubsetSum = function (nums, k) {\\n  const q = [];\\n  const sum = Array(nums.length).fill(0);\\n  let res = nums[0];\\n  for (let i = 0; i < nums.length; i++) {\\n    sum[i] = nums[i];\\n    if(q.length) sum[i] += sum[q[0]];\\n    res = Math.max(res, sum[i]);\\n    if (q.length && i - q[0] >= k) q.shift();\\n    while (q.length && sum[q[q.length - 1]] <= sum[i]) q.pop();\\n    if (sum[i] > 0) q.push(i);\\n  }\\n  return res;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Monotonic Queue"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar constrainedSubsetSum = function (nums, k) {\\n  const q = [];\\n  const sum = Array(nums.length).fill(0);\\n  let res = nums[0];\\n  for (let i = 0; i < nums.length; i++) {\\n    sum[i] = nums[i];\\n    if(q.length) sum[i] += sum[q[0]];\\n    res = Math.max(res, sum[i]);\\n    if (q.length && i - q[0] >= k) q.shift();\\n    while (q.length && sum[q[q.length - 1]] <= sum[i]) q.pop();\\n    if (sum[i] > 0) q.push(i);\\n  }\\n  return res;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2980962,
                "title": "dp-monotonic-queue",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        deque<pair<int,int>> dq;\\n        dq.push_back({0, nums[0]});\\n        int result = nums[0];\\n\\n        for(int i=1; i<nums.size(); i++) {\\n            // remove elements from front that are\\n            // more than k indices apart\\n            while(not dq.empty() and i-dq.front().first > k) {\\n                dq.pop_front();\\n            }\\n\\n            int val = nums[i] + max(0, dq.front().second);\\n            result = max(result, val);\\n\\n            // maintain a monotonically decreasing queue\\n            while(not dq.empty() and dq.back().second < val) {\\n                dq.pop_back();\\n            }\\n\\n            dq.push_back({i, val});\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Monotonic Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        deque<pair<int,int>> dq;\\n        dq.push_back({0, nums[0]});\\n        int result = nums[0];\\n\\n        for(int i=1; i<nums.size(); i++) {\\n            // remove elements from front that are\\n            // more than k indices apart\\n            while(not dq.empty() and i-dq.front().first > k) {\\n                dq.pop_front();\\n            }\\n\\n            int val = nums[i] + max(0, dq.front().second);\\n            result = max(result, val);\\n\\n            // maintain a monotonically decreasing queue\\n            while(not dq.empty() and dq.back().second < val) {\\n                dq.pop_back();\\n            }\\n\\n            dq.push_back({i, val});\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2979424,
                "title": "python-solution-using-monotone-queue-linear-time-faster-than-90",
                "content": "\\n# Code\\n```python []\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        sz = len(nums)\\n        dp, queue = [0] * sz, deque()\\n        dp[-1] = nums[-1]\\n        queue.append(sz - 1)\\n        for idx in range(sz - 2, -1, -1):\\n            if queue[0] - idx > k:\\n                queue.popleft()\\n            dp[idx] += (nums[idx] + dp[queue[0]])\\n            dp[idx] = max(dp[idx], nums[idx])\\n            while queue and dp[idx] > dp[queue[-1]]:\\n                queue.pop()\\n            queue.append(idx)\\n        return max(dp)\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Queue",
                    "Sliding Window",
                    "Monotonic Queue"
                ],
                "code": "```python []\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        sz = len(nums)\\n        dp, queue = [0] * sz, deque()\\n        dp[-1] = nums[-1]\\n        queue.append(sz - 1)\\n        for idx in range(sz - 2, -1, -1):\\n            if queue[0] - idx > k:\\n                queue.popleft()\\n            dp[idx] += (nums[idx] + dp[queue[0]])\\n            dp[idx] = max(dp[idx], nums[idx])\\n            while queue and dp[idx] > dp[queue[-1]]:\\n                queue.pop()\\n            queue.append(idx)\\n        return max(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2916618,
                "title": "no-extra-dp-easy-to-understand-deque",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ncompute sum and put in deque itself\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPush sum to the dq and the end till where the sum is calculated and perfrom monotonic queue operations for decreasing deque\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        int ans=INT_MIN;\\n        int sum=0;\\n        deque<pair<int,int>> dq;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            sum=nums[i];\\n            while(!dq.empty()&&dq.front().second<i-k)\\n                dq.pop_front();\\n            if(!dq.empty()&&dq.front().first>0){\\n                sum+=dq.front().first;\\n            }\\n            ans=max(ans,sum);\\n            while(!dq.empty()&&dq.back().first<sum){\\n                dq.pop_back();\\n            }\\n            dq.push_back({sum,i});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Monotonic Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        int ans=INT_MIN;\\n        int sum=0;\\n        deque<pair<int,int>> dq;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            sum=nums[i];\\n            while(!dq.empty()&&dq.front().second<i-k)\\n                dq.pop_front();\\n            if(!dq.empty()&&dq.front().first>0){\\n                sum+=dq.front().first;\\n            }\\n            ans=max(ans,sum);\\n            while(!dq.empty()&&dq.back().first<sum){\\n                dq.pop_back();\\n            }\\n            dq.push_back({sum,i});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2912457,
                "title": "c-very-simple-and-fast-max-heap-implementation",
                "content": "TC: O(N * LogN)    --> it will be slightly more than nlogn as we are poping using while loop\\nSC:O(K)\\n```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        \\n        priority_queue<int>pq;\\n        unordered_map<int,int>mp;\\n        int maxi=nums[0],ptr=0;\\n        pq.push(nums[0]);\\n        for(int i=1;i<nums.size();i++){\\n            //if ptr is not in the range of i\\n            if(i-k>ptr){\\n                mp[nums[ptr]]++;//make an entry to pop-out nums[ptr]\\n                ptr++;\\n            }\\n        //check if top value has some entry in map to pop , if yes\\n        //pop the top and decraese the pop-count in map\\n            while(mp[pq.top()]>0){  \\n                mp[pq.top()]--;\\n                pq.pop();\\n            }\\n            \\n            nums[i]+= max(0,pq.top());\\n            maxi=max(maxi,nums[i]);\\n            pq.push(nums[i]);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        \\n        priority_queue<int>pq;\\n        unordered_map<int,int>mp;\\n        int maxi=nums[0],ptr=0;\\n        pq.push(nums[0]);\\n        for(int i=1;i<nums.size();i++){\\n            //if ptr is not in the range of i\\n            if(i-k>ptr){\\n                mp[nums[ptr]]++;//make an entry to pop-out nums[ptr]\\n                ptr++;\\n            }\\n        //check if top value has some entry in map to pop , if yes\\n        //pop the top and decraese the pop-count in map\\n            while(mp[pq.top()]>0){  \\n                mp[pq.top()]--;\\n                pq.pop();\\n            }\\n            \\n            nums[i]+= max(0,pq.top());\\n            maxi=max(maxi,nums[i]);\\n            pq.push(nums[i]);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2904813,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\ntypedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\n    int constrainedSubsetSum(vector<int>&v, int k) {\\n        ll mx=*max_element(begin(v), end(v));\\n        if(mx<1){\\n            return mx;\\n        }\\n        ll n=v.size();\\n        vi(ll)dp(n);\\n        map<ll,ll>mp={{0, 1}};\\n        for(ll i=0;i<n;++i){\\n            if(i>k){\\n                --mp[dp[i-k-1]];\\n                if(!mp[dp[i-k-1]]){\\n                    mp.erase(dp[i-k-1]);\\n                }\\n            }\\n            dp[i]=v[i]+mp.rbegin()->first;\\n            ++mp[dp[i]];\\n        }\\n        return *max_element(begin(dp), end(dp));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\ntypedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\n    int constrainedSubsetSum(vector<int>&v, int k) {\\n        ll mx=*max_element(begin(v), end(v));\\n        if(mx<1){\\n            return mx;\\n        }\\n        ll n=v.size();\\n        vi(ll)dp(n);\\n        map<ll,ll>mp={{0, 1}};\\n        for(ll i=0;i<n;++i){\\n            if(i>k){\\n                --mp[dp[i-k-1]];\\n                if(!mp[dp[i-k-1]]){\\n                    mp.erase(dp[i-k-1]);\\n                }\\n            }\\n            dp[i]=v[i]+mp.rbegin()->first;\\n            ++mp[dp[i]];\\n        }\\n        return *max_element(begin(dp), end(dp));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2891898,
                "title": "monotonic-queue-dp-clean-code-o-n-time-and-o-k-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirstly I treated the question as lis problem and I came up with $$O(n^2)$$ solution but finally I realized that I can use monotonic queue to remove the inner loop and reduce the time complexity. \\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(k)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        ans = nums[0]\\n        queue = deque([(0, nums[0])])\\n        n = len(nums)\\n        for index in range(1, n):\\n            while queue and index - queue[0][0] > k:\\n                queue.popleft()\\n\\n            current = max(nums[index], nums[index]+queue[0][1])\\n            ans = max(ans, current)\\n            while queue and queue[-1][1] <= current:\\n                queue.pop()\\n            queue.append((index, current))\\n            \\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        ans = nums[0]\\n        queue = deque([(0, nums[0])])\\n        n = len(nums)\\n        for index in range(1, n):\\n            while queue and index - queue[0][0] > k:\\n                queue.popleft()\\n\\n            current = max(nums[index], nums[index]+queue[0][1])\\n            ans = max(ans, current)\\n            while queue and queue[-1][1] <= current:\\n                queue.pop()\\n            queue.append((index, current))\\n            \\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2856260,
                "title": "python3-using-monotonic-queue",
                "content": "class Solution:\\n\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        dec_q = collections.deque()\\n        dp = [0]*len(nums)\\n        \\n        for i,num in enumerate(nums):\\n            if i>k and dp[i-k-1] == dec_q[0]:\\n                dec_q.popleft()\\n            dp[i] = max(dec_q[0] if dec_q else 0,0)+num\\n            while dec_q and dec_q[-1]<dp[i]:\\n                dec_q.pop()\\n            dec_q.append(dp[i])\\n        \\n        return max(dp)",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        dec_q = collections.deque()\\n        dp = [0]*len(nums)\\n        \\n        for i,num in enumerate(nums):\\n            if i>k and dp[i-k-1] == dec_q[0]:\\n                dec_q.popleft()\\n            dp[i] = max(dec_q[0] if dec_q else 0,0)+num\\n            while dec_q and dec_q[-1]<dp[i]:\\n                dec_q.pop()\\n            dec_q.append(dp[i])\\n        \\n        return max(dp)",
                "codeTag": "Java"
            },
            {
                "id": 2851583,
                "title": "python-dp-monoqueue-o-n-2-o-n",
                "content": "Use monoqueue to store max(dp[i-k],...dp[i-1])\\n```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        # dp[i] = max sum of subseq(nums[:i+1]) s.t. j-i <= k\\n        # dp[i] = max(dp[j]) + nums[i] , j-i <= k\\n        \\n        n = len(nums)\\n        dp = [0 for i in range(n+1)]\\n        q = collections.deque()\\n        res = -math.inf\\n        left = 1\\n        \\n        for i in range(1, n+1):\\n            prev_max = q[0] if q else 0\\n            dp[i] = max(prev_max, 0) + nums[i-1]    # if prev dp is neg, start new subsequence here\\n            res = max(res, dp[i])\\n            \\n            while q and dp[i] > q[-1]:\\n                q.pop()\\n            q.append(dp[i])\\n            \\n            if i - left >= k:\\n                if q[0] == dp[left]:\\n                    q.popleft()\\n                left += 1\\n                       \\n        return res\\n```\\n\\nO(n^2) approach - TLE\\n```\\n for i in range(1, n+1):\\n            tmp = -math.inf\\n            for j in range(i-k, i):\\n                if j >= 0:\\n                    tmp = max(tmp, dp[j])\\n            dp[i] = max(tmp, 0) + nums[i-1]\\n            res = max(res, dp[i])\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        # dp[i] = max sum of subseq(nums[:i+1]) s.t. j-i <= k\\n        # dp[i] = max(dp[j]) + nums[i] , j-i <= k\\n        \\n        n = len(nums)\\n        dp = [0 for i in range(n+1)]\\n        q = collections.deque()\\n        res = -math.inf\\n        left = 1\\n        \\n        for i in range(1, n+1):\\n            prev_max = q[0] if q else 0\\n            dp[i] = max(prev_max, 0) + nums[i-1]    # if prev dp is neg, start new subsequence here\\n            res = max(res, dp[i])\\n            \\n            while q and dp[i] > q[-1]:\\n                q.pop()\\n            q.append(dp[i])\\n            \\n            if i - left >= k:\\n                if q[0] == dp[left]:\\n                    q.popleft()\\n                left += 1\\n                       \\n        return res\\n```\n```\\n for i in range(1, n+1):\\n            tmp = -math.inf\\n            for j in range(i-k, i):\\n                if j >= 0:\\n                    tmp = max(tmp, dp[j])\\n            dp[i] = max(tmp, 0) + nums[i-1]\\n            res = max(res, dp[i])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2810907,
                "title": "easy-c-solution-using-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        //use  a max heap\\n        priority_queue<pair<int,int>> pq;\\n        vector<int> dp(nums.size());\\n        int maxi=INT_MIN;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            //remove the indices which are less than i-k\\n            while(!pq.empty() && pq.top().second<i-k)\\n                pq.pop();\\n            dp[i]=nums[i];\\n            //get the max sum from previous i-k subarray \\n            if(!pq.empty())\\n                dp[i]=max(dp[i],nums[i]+pq.top().first);\\n            \\n            //update the maxi value\\n            maxi=max(maxi,dp[i]);\\n            pq.push({dp[i],i});\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        //use  a max heap\\n        priority_queue<pair<int,int>> pq;\\n        vector<int> dp(nums.size());\\n        int maxi=INT_MIN;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            //remove the indices which are less than i-k\\n            while(!pq.empty() && pq.top().second<i-k)\\n                pq.pop();\\n            dp[i]=nums[i];\\n            //get the max sum from previous i-k subarray \\n            if(!pq.empty())\\n                dp[i]=max(dp[i],nums[i]+pq.top().first);\\n            \\n            //update the maxi value\\n            maxi=max(maxi,dp[i]);\\n            pq.push({dp[i],i});\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2755787,
                "title": "c",
                "content": "Runtime: 225 ms, faster than 100.00% of C online submissions for Constrained Subsequence Sum.\\nMemory Usage: 21 MB, less than 100.00% of C online submissions for Constrained Subsequence Sum.\\n```\\nint BSF(int* nums, int n, int val){\\n    int left = 0, right = n-1;\\n    int mid;\\n    while(left < right){\\n        mid = left + (right - left) /2;\\n        if(nums[mid] >= val)\\n            left = mid + 1;\\n        else\\n            right = mid;\\n    }\\n    return left;\\n}\\n\\nint constrainedSubsetSum(int* nums, int numsSize, int k){\\n    int n = numsSize;\\n    int max = INT_MIN;\\n    int* queue = malloc((n+1) * sizeof(int) );\\n    int* dp = malloc((n+1) * sizeof(int));\\n    dp[0] = 0;\\n    int head = 0;\\n    int tail = 1;\\n    queue[head] = 0;\\n\\n    for(int i = 1; i <= k; i++){\\n        dp[i] = nums[i-1];\\n        if(queue[head] > 0)\\n            dp[i] += queue[head];   \\n        \\n        max = fmax(max, dp[i]);\\n        if(dp[i] < 0){\\n            continue;\\n        }\\n        else if(dp[i] > queue[head]){\\n             queue[head] = dp[i];\\n             tail = head + 1;   \\n        }\\n        else if(dp[i] <= queue[tail-1] ){\\n            queue[tail] = dp[i];\\n            tail++;\\n        }\\n        else{\\n            int z = BSF(&queue[head], tail - head , dp[i]);\\n            queue[head + z] = dp[i];\\n            tail = head + z+1;\\n        }\\n    }\\n\\n    for(int i = k+1; i <= n; i++){\\n        dp[i] = nums[i-1];\\n        if(queue[head] > 0)\\n            dp[i] += queue[head];\\n        max = fmax(max, dp[i]);\\n        if((queue[head] == dp[i-k]) && (dp[i-k] > 0)){\\n            head++;\\n            if(head == tail){\\n                queue[head] = 0;\\n                tail = head + 1;\\n            }\\n        }\\n        if(dp[i] < 0){\\n            continue;\\n        }         \\n        else if(dp[i] > queue[head]){\\n             queue[head] = dp[i];\\n             tail = head + 1;   \\n        }\\n        else if(dp[i] <= queue[tail-1]){\\n            queue[tail] = dp[i];\\n            tail++;\\n        }\\n        else{\\n            int z = BSF(&queue[head], tail - head , dp[i]);\\n            queue[head + z] = dp[i];\\n            tail = head + z+1;\\n        }        \\n    }\\n    return max;\\n}\\n```",
                "solutionTags": [
                    "Monotonic Queue"
                ],
                "code": "```\\nint BSF(int* nums, int n, int val){\\n    int left = 0, right = n-1;\\n    int mid;\\n    while(left < right){\\n        mid = left + (right - left) /2;\\n        if(nums[mid] >= val)\\n            left = mid + 1;\\n        else\\n            right = mid;\\n    }\\n    return left;\\n}\\n\\nint constrainedSubsetSum(int* nums, int numsSize, int k){\\n    int n = numsSize;\\n    int max = INT_MIN;\\n    int* queue = malloc((n+1) * sizeof(int) );\\n    int* dp = malloc((n+1) * sizeof(int));\\n    dp[0] = 0;\\n    int head = 0;\\n    int tail = 1;\\n    queue[head] = 0;\\n\\n    for(int i = 1; i <= k; i++){\\n        dp[i] = nums[i-1];\\n        if(queue[head] > 0)\\n            dp[i] += queue[head];   \\n        \\n        max = fmax(max, dp[i]);\\n        if(dp[i] < 0){\\n            continue;\\n        }\\n        else if(dp[i] > queue[head]){\\n             queue[head] = dp[i];\\n             tail = head + 1;   \\n        }\\n        else if(dp[i] <= queue[tail-1] ){\\n            queue[tail] = dp[i];\\n            tail++;\\n        }\\n        else{\\n            int z = BSF(&queue[head], tail - head , dp[i]);\\n            queue[head + z] = dp[i];\\n            tail = head + z+1;\\n        }\\n    }\\n\\n    for(int i = k+1; i <= n; i++){\\n        dp[i] = nums[i-1];\\n        if(queue[head] > 0)\\n            dp[i] += queue[head];\\n        max = fmax(max, dp[i]);\\n        if((queue[head] == dp[i-k]) && (dp[i-k] > 0)){\\n            head++;\\n            if(head == tail){\\n                queue[head] = 0;\\n                tail = head + 1;\\n            }\\n        }\\n        if(dp[i] < 0){\\n            continue;\\n        }         \\n        else if(dp[i] > queue[head]){\\n             queue[head] = dp[i];\\n             tail = head + 1;   \\n        }\\n        else if(dp[i] <= queue[tail-1]){\\n            queue[tail] = dp[i];\\n            tail++;\\n        }\\n        else{\\n            int z = BSF(&queue[head], tail - head , dp[i]);\\n            queue[head + z] = dp[i];\\n            tail = head + z+1;\\n        }        \\n    }\\n    return max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2753815,
                "title": "maxheap-with-lazy-popping",
                "content": "class Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        \\n     #create a heap with lazy popping\\n    \\n    \\n        myheap = []\\n\\n        dp = defaultdict(lambda : 0)\\n\\n        for i,num in enumerate(nums):\\n            \\n            #lazy popping, any index that is older than i -  k elements back can be popped\\n            while myheap and i - myheap[0][1] > k:\\n                heapq.heappop(myheap)\\n\\n            if myheap:\\n                dp[i] = max( nums[i],nums[i] + (myheap[0][0]*-1) )\\n            else:\\n                dp[i] = nums[i]\\n\\n            heapq.heappush( myheap,(dp[i]*-1,i) )\\n\\n        return max(dp.values())\\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        \\n     #create a heap with lazy popping\\n    \\n    \\n        myheap = []\\n\\n        dp = defaultdict(lambda : 0)\\n\\n        for i,num in enumerate(nums):\\n            \\n            #lazy popping, any index that is older than i -  k elements back can be popped\\n            while myheap and i - myheap[0][1] > k:\\n                heapq.heappop(myheap)\\n\\n            if myheap:\\n                dp[i] = max( nums[i],nums[i] + (myheap[0][0]*-1) )\\n            else:\\n                dp[i] = nums[i]\\n\\n            heapq.heappush( myheap,(dp[i]*-1,i) )\\n\\n        return max(dp.values())\\n",
                "codeTag": "Java"
            },
            {
                "id": 2731949,
                "title": "sliding-window-maximum",
                "content": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        q = deque()\\n        for i in range(n):\\n            if len(q) > 0:\\n                nums[i] = max(nums[i], nums[i] + nums[q[0]])\\n            while len(q) > 0 and q[0] <= i - k:\\n                q.popleft()\\n            while len(q) > 0 and nums[i] > nums[q[-1]]:\\n                q.pop()\\n            q.append(i)\\n        return max(nums)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        q = deque()\\n        for i in range(n):\\n            if len(q) > 0:\\n                nums[i] = max(nums[i], nums[i] + nums[q[0]])\\n            while len(q) > 0 and q[0] <= i - k:\\n                q.popleft()\\n            while len(q) > 0 and nums[i] > nums[q[-1]]:\\n                q.pop()\\n            q.append(i)\\n        return max(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2725190,
                "title": "monotonic-queue-and-keep-trying-when-tle-intuition-and-explanation",
                "content": "My first intuition was DP, but got me TLE as the `k` is quite huge in this case. It took me really long to come up with a monotonic queue solution. I will describe the thought process below.\\n\\n### Intuition\\nMaximum in a sliding window. \\n\\nNormally when I am struggling out how to keep track of the index of maximum, minumum or any particular item in `O(n)` time, monotonic queue seem to be the solution.\\nThe next is to think hard on how to fit into the intuition.\\n\\n### Explanation\\n\\nIn a monotonic queue problem, there are generally a few steps and patterns to follow.\\n\\nIn our case, the first element should be the maximum value we can obtain so far.\\n\\n**Clear the obsolete**\\nSince it is a sliding window, obsolete item should be cleared, in this case, at index `i` , any item index `< i-k` should be cleared.\\n\\n**Kickout items that need not to be considered**\\nNow every element is in the range, we can consider to add the current element `A[i]`  , making it `A[i]+q[0][0]` or not adding it, making it `A[i]` whichever is larger. After that, the smaller elements need to be kicked out to maintain the tip of the queue is the one we are looking for.\\n\\n**Record the answer**\\nRecord the current max at every index as every sliding window problem does.\\n\\n\\n### Implementation\\n\\n```\\nfrom collections import deque\\n\\nclass Solution:\\n    def constrainedSubsetSum(self, A: List[int], k: int) -> int:\\n        q = deque()\\n        ans = -float(\\'inf\\')\\n        for i, a in enumerate(A):\\n            while q and q[0][1] < i-k:\\n                q.popleft()\\n            v = max(A[i], A[i]+(q[0][0] if q else 0))\\n            while q and q[-1][0] < v:\\n                q.pop()\\n            q.append((v, i))\\n            ans = max(ans, q[0][0])\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def constrainedSubsetSum(self, A: List[int], k: int) -> int:\\n        q = deque()\\n        ans = -float(\\'inf\\')\\n        for i, a in enumerate(A):\\n            while q and q[0][1] < i-k:\\n                q.popleft()\\n            v = max(A[i], A[i]+(q[0][0] if q else 0))\\n            while q and q[-1][0] < v:\\n                q.pop()\\n            q.append((v, i))\\n            ans = max(ans, q[0][0])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2672473,
                "title": "python-deque",
                "content": "\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        dp = [0]*n\\n        q = deque()\\n\\n        for i, num in enumerate(nums):\\n            if i > k and q[0] == dp[i-k-1]:\\n                q.popleft()\\n            dp[i] = max(q[0] if q else 0, 0)+num\\n\\n            while q and q[-1] < dp[i]:\\n                q.pop()\\n            q.append(dp[i])\\n        return max(dp)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue",
                    "Monotonic Queue"
                ],
                "code": "```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        dp = [0]*n\\n        q = deque()\\n\\n        for i, num in enumerate(nums):\\n            if i > k and q[0] == dp[i-k-1]:\\n                q.popleft()\\n            dp[i] = max(q[0] if q else 0, 0)+num\\n\\n            while q and q[-1] < dp[i]:\\n                q.pop()\\n            q.append(dp[i])\\n        return max(dp)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2664591,
                "title": "python-monotonic-decreasing-queue-time-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- similar to 1696, nearly the same\\n- 1696. Jump Game VI\\n```python\\nimport collections\\nclass Solution:\\n    def maxResult(self, nums, k):\\n        n = len(nums)\\n        # store the max value in each index of nums\\n        dp = [nums[0]] * n \\n        # store the index of maximum dp values inside a window of k\\n        mono_dec_q = collections.deque([0]) \\n        for i in range(1, n):\\n            # the first value in queue is maximum\\n            dp[i] = nums[i] + dp[mono_dec_q[0]] \\n            # when iterate to dp[i], if it is higher than the end of queue, delete the end\\n            while mono_dec_q and dp[i] >= dp[mono_dec_q[-1]]: \\n                mono_dec_q.pop()\\n            # if index out of window, slide the window to the right\\n            if mono_dec_q and i - mono_dec_q[0] == k:\\n                mono_dec_q.popleft()\\n            mono_dec_q.append(i)\\n        return dp[-1]\\n```\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nmonotonic queue\\n- res is set to nums[0], it may be a result like nums = [-1, -2, -3]\\n- dp[i] = nums[i] + max(0, dp[mono_dec_q[0]]), dp store the max values, the result is the max of dp array\\n- max(0, dp[mono_dec_q[0]]) means the different from 1696, here not start from first jump to last, can start from any place and end to any place, only need to meet the condition of jump within k steps, here is subsequence of that array such that for every two consecutive integers in the subsequence, nums[i] and nums[j], where i < j\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        dp, mono_dec_q, res = [nums[0]] * n, deque([0]), nums[0]\\n        for i in range(1, n):\\n            dp[i] = nums[i] + max(0, dp[mono_dec_q[0]])\\n            while mono_dec_q and dp[i] >= dp[mono_dec_q[-1]]:\\n                mono_dec_q.pop()\\n            if mono_dec_q and i - mono_dec_q[0] == k:\\n                mono_dec_q.popleft()\\n            mono_dec_q.append(i)\\n            res = max(res, dp[i])\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nimport collections\\nclass Solution:\\n    def maxResult(self, nums, k):\\n        n = len(nums)\\n        # store the max value in each index of nums\\n        dp = [nums[0]] * n \\n        # store the index of maximum dp values inside a window of k\\n        mono_dec_q = collections.deque([0]) \\n        for i in range(1, n):\\n            # the first value in queue is maximum\\n            dp[i] = nums[i] + dp[mono_dec_q[0]] \\n            # when iterate to dp[i], if it is higher than the end of queue, delete the end\\n            while mono_dec_q and dp[i] >= dp[mono_dec_q[-1]]: \\n                mono_dec_q.pop()\\n            # if index out of window, slide the window to the right\\n            if mono_dec_q and i - mono_dec_q[0] == k:\\n                mono_dec_q.popleft()\\n            mono_dec_q.append(i)\\n        return dp[-1]\\n```\n```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        dp, mono_dec_q, res = [nums[0]] * n, deque([0]), nums[0]\\n        for i in range(1, n):\\n            dp[i] = nums[i] + max(0, dp[mono_dec_q[0]])\\n            while mono_dec_q and dp[i] >= dp[mono_dec_q[-1]]:\\n                mono_dec_q.pop()\\n            if mono_dec_q and i - mono_dec_q[0] == k:\\n                mono_dec_q.popleft()\\n            mono_dec_q.append(i)\\n            res = max(res, dp[i])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2640009,
                "title": "python-monotonic-queue",
                "content": "```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        q, r = deque(), -inf\\n        \\n        for i, num in enumerate(nums):     \\n            while q and i - q[0][1] > k: q.popleft()\\n            m = q[0][0] + num if q and q[0][0] > 0 else num\\n            if m > r: r = m\\n            while q and q[-1][0] < m: q.pop()\\n            q.append((m, i))\\n            \\n        return r  \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        q, r = deque(), -inf\\n        \\n        for i, num in enumerate(nums):     \\n            while q and i - q[0][1] > k: q.popleft()\\n            m = q[0][0] + num if q and q[0][0] > 0 else num\\n            if m > r: r = m\\n            while q and q[-1][0] < m: q.pop()\\n            q.append((m, i))\\n            \\n        return r  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2576524,
                "title": "python-3-simple-monotonic-o-n-solution",
                "content": "```\\nfrom collections import deque\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        que=deque([])\\n        dp=[0 for i in range(len(nums))]\\n        for i,val in enumerate(nums):\\n            while que and que[0][1] < i-k:\\n                que.popleft()\\n            dp[i]=max(val+(que[0][0] if que else 0),val) \\n            while que and dp[i] >= que[-1][0]:\\n                que.pop()\\n            que.append([dp[i],i])\\n        return max(dp)\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        que=deque([])\\n        dp=[0 for i in range(len(nums))]\\n        for i,val in enumerate(nums):\\n            while que and que[0][1] < i-k:\\n                que.popleft()\\n            dp[i]=max(val+(que[0][0] if que else 0),val) \\n            while que and dp[i] >= que[-1][0]:\\n                que.pop()\\n            que.append([dp[i],i])\\n        return max(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2549602,
                "title": "simple-solution-with-explanation-multiset-dp-very-easy",
                "content": "```\\nint constrainedSubsetSum(vector<int>& nums, int k) {\\n        multiset<int>s;\\n        int n=nums.size();\\n        vector<int>dp(n+1,0);\\n        // dp[i]=max sum we can make if we take index i\\n        s.insert(nums[0]);\\n        dp[0]=nums[0];\\n        int mx=dp[0];\\n        for(int i=1;i<n;i++){\\n            if(i<=k){\\n                auto x=s.end();\\n                x--;\\n//                 we take the max element of the set\\n                dp[i]=nums[i]+max(0,*x);\\n            }\\n            else{\\n                s.erase(s.find(dp[i-k-1]));\\n                auto x=s.end();\\n                x--;\\n//                 we take the max element of the set\\n                dp[i]=nums[i]+max(0,*x);\\n            }\\n            s.insert(dp[i]);\\n            mx=max(mx,dp[i]);\\n        }\\n        return mx;\\n    }\\n\\t",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nint constrainedSubsetSum(vector<int>& nums, int k) {\\n        multiset<int>s;\\n        int n=nums.size();\\n        vector<int>dp(n+1,0);\\n        // dp[i]=max sum we can make if we take index i\\n        s.insert(nums[0]);\\n        dp[0]=nums[0];\\n        int mx=dp[0];\\n        for(int i=1;i<n;i++){\\n            if(i<=k){\\n                auto x=s.end();\\n                x--;\\n//                 we take the max element of the set\\n                dp[i]=nums[i]+max(0,*x);\\n            }\\n            else{\\n                s.erase(s.find(dp[i-k-1]));\\n                auto x=s.end();\\n                x--;\\n//                 we take the max element of the set\\n                dp[i]=nums[i]+max(0,*x);\\n            }\\n            s.insert(dp[i]);\\n            mx=max(mx,dp[i]);\\n        }\\n        return mx;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 2542364,
                "title": "python-two-solutions-max-heap-mono-deque",
                "content": "max_heap solution: Time - O(NlogN)\\n\\n```\\ndef constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n\\tq, ans = [(-nums[0], 0)], nums[0]\\n\\tfor i in range(1, len(nums)):\\n\\t\\twhile(q and i-q[0][1]>k):\\n\\t\\t\\theappop(q)\\n\\t\\tcur = max(nums[i], nums[i]-q[0][0])\\n\\t\\tans = max(cur, ans)\\n\\t\\theappush(q, (-cur, i))\\n\\treturn ans\\n```\\n\\nmono-deque solution: Time - O(N)\\n\\n```\\ndef constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n\\tq, ans = deque([(nums[0], 0)]), nums[0]\\n\\tfor i in range(1, len(nums)):\\n\\t\\twhile(q and i-q[0][1]>k):\\n\\t\\t\\tq.popleft()\\n\\t\\tcur = max(nums[i], nums[i]+q[0][0])\\n\\t\\tans = max(cur, ans)\\n\\t\\twhile(q and q[-1][0]<=cur):\\n\\t\\t\\tq.pop()\\n\\t\\tq.append((cur, i))\\n\\treturn ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n\\tq, ans = [(-nums[0], 0)], nums[0]\\n\\tfor i in range(1, len(nums)):\\n\\t\\twhile(q and i-q[0][1]>k):\\n\\t\\t\\theappop(q)\\n\\t\\tcur = max(nums[i], nums[i]-q[0][0])\\n\\t\\tans = max(cur, ans)\\n\\t\\theappush(q, (-cur, i))\\n\\treturn ans\\n```\n```\\ndef constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n\\tq, ans = deque([(nums[0], 0)]), nums[0]\\n\\tfor i in range(1, len(nums)):\\n\\t\\twhile(q and i-q[0][1]>k):\\n\\t\\t\\tq.popleft()\\n\\t\\tcur = max(nums[i], nums[i]+q[0][0])\\n\\t\\tans = max(cur, ans)\\n\\t\\twhile(q and q[-1][0]<=cur):\\n\\t\\t\\tq.pop()\\n\\t\\tq.append((cur, i))\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2516511,
                "title": "c-two-approaches-using-set-and-using-monotonic-deque-with-explanation",
                "content": "### Solution using Set\\n\\n```\\n//Time Complexity : O(Nlogk) (Because there are atmost k element in the set)\\n//Spcae complexity: O(N)\\n\\nclass Solution\\n{\\n    public:\\n        int constrainedSubsetSum(vector<int> &nums, int k)\\n        {\\n            const int N = nums.size();\\n            vector<int> dp(N);\\n\\n            /**\\n            * dp[i] = Maximum sum of subsequence if we take the element at index i\\n            */\\n            \\n            dp[0] = nums[0];\\n            // We will use max_prev to store the previous k sum of subsequences\\n            \\n            set<pair<int, int>> max_prev;\\n            \\n            max_prev.insert({ dp[0], 0 });\\n            int ans = dp[0];\\n\\n            for (int i = 1; i < N; i++)\\n            {\\n                \\n                // We want elements in the range [i-k , i], since i-k-1 is out of bounds we remove it\\n                if (i - k - 1 >= 0)\\n                    max_prev.erase({ dp[i - k - 1],i - k - 1 });\\n\\n                \\n                int mx = max_prev.rbegin()->first; // We find the subsequence with maximum sum\\n\\n                // Here if we want to append nums[i] to the previous subsequence we will get sum mx + nums[i]\\n                // If we want to start a new subsequence from nums[i] we will get nums[i]\\n                // We take the best of two \\n                \\n                dp[i] = max(mx + nums[i], nums[i]);\\n                ans = max(ans, dp[i]);\\n                \\n                //We will use this value in the future\\n                max_prev.insert({ dp[i],i });\\n            }\\n\\n            return ans;\\n        }\\n};\\n```\\n\\n### Using Monotonic deque\\n\\n```\\n//Time Complexity : O(N) (Because we get maximum element in O(1))\\n//Spcae complexity: O(N)\\n\\nclass Solution\\n{\\n    public:\\n        int constrainedSubsetSum(vector<int> &nums, int k)\\n        {\\n            const int N = nums.size();\\n            vector<int> dp(N);\\n\\n            /**\\n            * dp[i] = Maximum sum of subsequence if we take the element at index i\\n            */\\n            \\n            dp[0] = nums[0];\\n            \\n            // dq will always store values in non-increasing (descending order)\\n            //So dq.front() will have greatest value in the range\\n            deque<int> dq;\\n            dq.push_back(dp[0]);\\n            \\n            int ans = dp[0];\\n\\n            for (int i = 1; i < N; i++)\\n            {\\n                \\n                // We want elements in the range [i-k , i], since i-k-1 is out of bounds we remove it\\n                if (i - k - 1 >= 0 and dq.front() == dp[i-k-1])\\n                    dq.pop_front();\\n\\n\\n                // Here if we want to append nums[i] to the previous subsequence we will get sum mx + nums[i]\\n                // If we want to start a new subsequence from nums[i] we will get nums[i]\\n                // We take the best of two \\n                \\n                dp[i] = max(dq.front() + nums[i], nums[i]);\\n                ans = max(ans, dp[i]);\\n                \\n                //If dp[i] is greater then dq.back() then the values in dq wont be non-increasing, so we remove them\\n                while(!dq.empty() and dp[i] > dq.back())\\n                    dq.pop_back();\\n                \\n                dq.push_back(dp[i]);\\n                \\n            }\\n\\n            return ans;\\n        }\\n};\\n```\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Ordered Set",
                    "Monotonic Queue"
                ],
                "code": "```\\n//Time Complexity : O(Nlogk) (Because there are atmost k element in the set)\\n//Spcae complexity: O(N)\\n\\nclass Solution\\n{\\n    public:\\n        int constrainedSubsetSum(vector<int> &nums, int k)\\n        {\\n            const int N = nums.size();\\n            vector<int> dp(N);\\n\\n            /**\\n            * dp[i] = Maximum sum of subsequence if we take the element at index i\\n            */\\n            \\n            dp[0] = nums[0];\\n            // We will use max_prev to store the previous k sum of subsequences\\n            \\n            set<pair<int, int>> max_prev;\\n            \\n            max_prev.insert({ dp[0], 0 });\\n            int ans = dp[0];\\n\\n            for (int i = 1; i < N; i++)\\n            {\\n                \\n                // We want elements in the range [i-k , i], since i-k-1 is out of bounds we remove it\\n                if (i - k - 1 >= 0)\\n                    max_prev.erase({ dp[i - k - 1],i - k - 1 });\\n\\n                \\n                int mx = max_prev.rbegin()->first; // We find the subsequence with maximum sum\\n\\n                // Here if we want to append nums[i] to the previous subsequence we will get sum mx + nums[i]\\n                // If we want to start a new subsequence from nums[i] we will get nums[i]\\n                // We take the best of two \\n                \\n                dp[i] = max(mx + nums[i], nums[i]);\\n                ans = max(ans, dp[i]);\\n                \\n                //We will use this value in the future\\n                max_prev.insert({ dp[i],i });\\n            }\\n\\n            return ans;\\n        }\\n};\\n```\n```\\n//Time Complexity : O(N) (Because we get maximum element in O(1))\\n//Spcae complexity: O(N)\\n\\nclass Solution\\n{\\n    public:\\n        int constrainedSubsetSum(vector<int> &nums, int k)\\n        {\\n            const int N = nums.size();\\n            vector<int> dp(N);\\n\\n            /**\\n            * dp[i] = Maximum sum of subsequence if we take the element at index i\\n            */\\n            \\n            dp[0] = nums[0];\\n            \\n            // dq will always store values in non-increasing (descending order)\\n            //So dq.front() will have greatest value in the range\\n            deque<int> dq;\\n            dq.push_back(dp[0]);\\n            \\n            int ans = dp[0];\\n\\n            for (int i = 1; i < N; i++)\\n            {\\n                \\n                // We want elements in the range [i-k , i], since i-k-1 is out of bounds we remove it\\n                if (i - k - 1 >= 0 and dq.front() == dp[i-k-1])\\n                    dq.pop_front();\\n\\n\\n                // Here if we want to append nums[i] to the previous subsequence we will get sum mx + nums[i]\\n                // If we want to start a new subsequence from nums[i] we will get nums[i]\\n                // We take the best of two \\n                \\n                dp[i] = max(dq.front() + nums[i], nums[i]);\\n                ans = max(ans, dp[i]);\\n                \\n                //If dp[i] is greater then dq.back() then the values in dq wont be non-increasing, so we remove them\\n                while(!dq.empty() and dp[i] > dq.back())\\n                    dq.pop_back();\\n                \\n                dq.push_back(dp[i]);\\n                \\n            }\\n\\n            return ans;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2497453,
                "title": "finally-omg",
                "content": "```\\nclass Solution:\\n    def monoque(self, stack, num, index):\\n        while len(stack) > 0 and num > stack[-1][0]:\\n            stack.pop()\\n        stack.append((num, index))\\n    \\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        dp = [0]*n\\n        dp[0] = nums[0]\\n        stack = collections.deque()\\n        stack.append((nums[0],0))\\n        \\n        for i in range(1,n):\\n            if i > stack[0][1] + k:\\n                stack.popleft()\\n                \\n            if stack[0][0] + nums[i] < nums[i]:\\n                dp[i] = nums[i]\\n                self.monoque(stack, nums[i], i)\\n            else:\\n                dp[i] = nums[i]+stack[0][0]\\n                self.monoque(stack, nums[i]+stack[0][0], i)\\n        return max(dp)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def monoque(self, stack, num, index):\\n        while len(stack) > 0 and num > stack[-1][0]:\\n            stack.pop()\\n        stack.append((num, index))\\n    \\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        dp = [0]*n\\n        dp[0] = nums[0]\\n        stack = collections.deque()\\n        stack.append((nums[0],0))\\n        \\n        for i in range(1,n):\\n            if i > stack[0][1] + k:\\n                stack.popleft()\\n                \\n            if stack[0][0] + nums[i] < nums[i]:\\n                dp[i] = nums[i]\\n                self.monoque(stack, nums[i], i)\\n            else:\\n                dp[i] = nums[i]+stack[0][0]\\n                self.monoque(stack, nums[i]+stack[0][0], i)\\n        return max(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2460030,
                "title": "c-monotonic-queue-deque-solution-in-o-n-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& a, int k) {\\n        int n=a.size();\\n        vector<int> dp(n,0);\\n        deque<int> dq;\\n        dp[n-1]=a[n-1];\\n        dq.push_back(n-1);\\n       \\n        for(int i=n-2;i>=0;i--)\\n        {\\n           \\n            if(dq.front()-i>k) dq.pop_front();\\n            \\n            dp[i]+=a[i];\\n            dp[i]+=dp[dq.front()];\\n            dp[i]=max(a[i],dp[i]);\\n            while(!dq.empty() and dp[i]>dp[dq.back()]) dq.pop_back();\\n            dq.push_back(i);\\n        }\\n        return *max_element(dp.begin(),dp.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Queue",
                    "Monotonic Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& a, int k) {\\n        int n=a.size();\\n        vector<int> dp(n,0);\\n        deque<int> dq;\\n        dp[n-1]=a[n-1];\\n        dq.push_back(n-1);\\n       \\n        for(int i=n-2;i>=0;i--)\\n        {\\n           \\n            if(dq.front()-i>k) dq.pop_front();\\n            \\n            dp[i]+=a[i];\\n            dp[i]+=dp[dq.front()];\\n            dp[i]=max(a[i],dp[i]);\\n            while(!dq.empty() and dp[i]>dp[dq.back()]) dq.pop_back();\\n            dq.push_back(i);\\n        }\\n        return *max_element(dp.begin(),dp.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2451905,
                "title": "c-solution-98-faster-using-deque",
                "content": "![image](https://assets.leetcode.com/users/images/f10cec1f-8ecb-4ec6-9330-2b8b5d427d66_1660975327.7448714.png)\\n```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        int n = nums.size(), res = INT_MIN;\\n        \\n        vector<int> dp(n);\\n        deque<int> sums;\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (sums.front() == i - k - 1) sums.pop_front();\\n            dp[i] = max(nums[i] + (sums.empty() ? 0 : dp[sums.front()]), nums[i]);\\n            res = max(res, dp[i]);\\n            while (!sums.empty() && dp[sums.back()] <= dp[i]) sums.pop_back();\\n            sums.push_back(i);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        int n = nums.size(), res = INT_MIN;\\n        \\n        vector<int> dp(n);\\n        deque<int> sums;\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (sums.front() == i - k - 1) sums.pop_front();\\n            dp[i] = max(nums[i] + (sums.empty() ? 0 : dp[sums.front()]), nums[i]);\\n            res = max(res, dp[i]);\\n            while (!sums.empty() && dp[sums.back()] <= dp[i]) sums.pop_back();\\n            sums.push_back(i);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2438433,
                "title": "simple-dp-c-solution-same-as-leetcode-239",
                "content": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int dp[n+1];\\n        memset(dp,0,sizeof(dp));\\n        \\n        //here we use leetcode 239 questions concept monotonic queue and simple dp ie kadanes algorithm approach that dp[i] = max((dp[i-k+1],....dp[i-1]),0) + currNum\\n        \\n        deque<int> dq;\\n        \\n        for(int i = 0;i<nums.size();i++)\\n        {\\n            if(dq.size() and dq.front()==i-k-1) dq.pop_front(); //out of boundary\\n            \\n            dp[i] = nums[i];\\n            if(dq.size())\\n                dp[i] = max(dp[dq.front()]+nums[i],nums[i]);\\n            \\n            while(dq.size() and dp[dq.back()]<=dp[i])\\n            {\\n                dq.pop_back();\\n            }\\n            \\n            dq.push_back(i);\\n        }\\n        return *max_element(dp,dp+n);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int dp[n+1];\\n        memset(dp,0,sizeof(dp));\\n        \\n        //here we use leetcode 239 questions concept monotonic queue and simple dp ie kadanes algorithm approach that dp[i] = max((dp[i-k+1],....dp[i-1]),0) + currNum\\n        \\n        deque<int> dq;\\n        \\n        for(int i = 0;i<nums.size();i++)\\n        {\\n            if(dq.size() and dq.front()==i-k-1) dq.pop_front(); //out of boundary\\n            \\n            dp[i] = nums[i];\\n            if(dq.size())\\n                dp[i] = max(dp[dq.front()]+nums[i],nums[i]);\\n            \\n            while(dq.size() and dp[dq.back()]<=dp[i])\\n            {\\n                dq.pop_back();\\n            }\\n            \\n            dq.push_back(i);\\n        }\\n        return *max_element(dp,dp+n);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2420628,
                "title": "simple-deque-approach-faster-than-100",
                "content": "class Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& arr, int k) {\\n        \\n        deque<pair<int,int>> dq;\\n        int n = arr.size();\\n        int ans = INT_MIN;\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            while(!dq.empty() && i-dq.front().second>k){\\n                dq.pop_front();\\n            }\\n            \\n            if(dq.empty()){\\n                dq.push_back({arr[i],i});\\n                ans = max(ans, arr[i]);\\n            }\\n            else{\\n                \\n                int x = dq.front().first+arr[i];\\n                x = max(x,arr[i]);\\n                ans = max(ans,x);\\n                while(!dq.empty() && dq.back().first<x)\\n                    dq.pop_back();\\n                dq.push_back({x,i});\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Queue"
                ],
                "code": "class Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& arr, int k) {\\n        \\n        deque<pair<int,int>> dq;\\n        int n = arr.size();\\n        int ans = INT_MIN;\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            while(!dq.empty() && i-dq.front().second>k){\\n                dq.pop_front();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2420380,
                "title": "python-similar-to-jump-game-vi-notes-dp-heap-beats-68",
                "content": "```\\n/*\\nproblem is very much similar to Jump Game VI\\n\\ncreate a dp[] array where dp[i] dentoes the maximum sum we can have \\nwhen we start from ith position and reach to end\\n\\nLet dp[i] be \"the maximum score to reach the end starting at index i\". \\nThe answer for dp[i] is nums[i] + max{dp[i+j]} for 1 <= j <= k. \\nThat gives an O(n*k) solution.\\n\\nInstead of checking every j for every i, keep track of the largest dp[i] \\nvalues in a heap and calculate dp[i] from right to left. \\nWhen the largest value in the heap is out of bounds of the current index, \\nremove it and keep checking.\\n\\nThe difference of this problem with Jump Game VI is, in the latter problem, we \\nhad to include the last element and the first element. However, in this problem we\\nmay or may not include it as part of the answer. \\n*/\\n```\\n```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        dp = [0 for _ in range(len(nums))]\\n        dp[-1] = nums[-1]\\n        heap = []\\n        heapq.heappush(heap, (-nums[-1], len(nums)-1))\\n        for i in range(len(nums)-2, -1, -1):\\n            while True:\\n                if i + k >= heap[0][1]:\\n                    dp[i] = max(nums[i], nums[i] + -1 * heap[0][0])\\n                    heapq.heappush(heap, (-dp[i], i))\\n                    break\\n                else:\\n                    heapq.heappop(heap)\\n        return max(dp)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\n/*\\nproblem is very much similar to Jump Game VI\\n\\ncreate a dp[] array where dp[i] dentoes the maximum sum we can have \\nwhen we start from ith position and reach to end\\n\\nLet dp[i] be \"the maximum score to reach the end starting at index i\". \\nThe answer for dp[i] is nums[i] + max{dp[i+j]} for 1 <= j <= k. \\nThat gives an O(n*k) solution.\\n\\nInstead of checking every j for every i, keep track of the largest dp[i] \\nvalues in a heap and calculate dp[i] from right to left. \\nWhen the largest value in the heap is out of bounds of the current index, \\nremove it and keep checking.\\n\\nThe difference of this problem with Jump Game VI is, in the latter problem, we \\nhad to include the last element and the first element. However, in this problem we\\nmay or may not include it as part of the answer. \\n*/\\n```\n```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        dp = [0 for _ in range(len(nums))]\\n        dp[-1] = nums[-1]\\n        heap = []\\n        heapq.heappush(heap, (-nums[-1], len(nums)-1))\\n        for i in range(len(nums)-2, -1, -1):\\n            while True:\\n                if i + k >= heap[0][1]:\\n                    dp[i] = max(nums[i], nums[i] + -1 * heap[0][0])\\n                    heapq.heappush(heap, (-dp[i], i))\\n                    break\\n                else:\\n                    heapq.heappop(heap)\\n        return max(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2404742,
                "title": "java-max-heap",
                "content": "At each index `i`, we check the maximum sum subsequence which can be formed by taking the previously formed subsequences within the window `i-k`. We can use a max heap to keep track of the previously formed subsequences, and also keep polling out the elements which are not in the desired window. \\n\\n```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int n = nums.length;\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a,b) -> nums[b] - nums[a]);\\n        \\n        maxHeap.add(0);\\n        int ans = nums[0];\\n        for(int i = 1; i<n;i++) {\\n            while(maxHeap.size() > 0 && maxHeap.peek() < i-k)\\n                maxHeap.poll();\\n            \\n            if(nums[maxHeap.peek()] >= 0)\\n                nums[i] += nums[maxHeap.peek()];\\n            \\n            ans = Math.max(ans, nums[i]);\\n            maxHeap.add(i);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int n = nums.length;\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a,b) -> nums[b] - nums[a]);\\n        \\n        maxHeap.add(0);\\n        int ans = nums[0];\\n        for(int i = 1; i<n;i++) {\\n            while(maxHeap.size() > 0 && maxHeap.peek() < i-k)\\n                maxHeap.poll();\\n            \\n            if(nums[maxHeap.peek()] >= 0)\\n                nums[i] += nums[maxHeap.peek()];\\n            \\n            ans = Math.max(ans, nums[i]);\\n            maxHeap.add(i);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390232,
                "title": "o-n-solution",
                "content": "```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        from collections import deque\\n        dq = deque()\\n        n = len(nums)\\n        \\n        dp = [nums[i - 1] if i > 0 else 0 for i in range(n + 1)]\\n        for i in range(1, n + 1):\\n            while (len(dq) > 0 and i - dq[0] > k):\\n                dq.popleft()\\n            if len(dq) > 0:\\n                dp[i] = max(dp[i], dp[dq[0]] + nums[i - 1])\\n            while (len(dq) > 0 and dp[dq[-1]] <= dp[i]):\\n                dq.pop()\\n            \\n            dq.append(i)\\n            \\n        return max([dp[i] for i in range(1, n + 1)])\\n        \\n        \\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        from collections import deque\\n        dq = deque()\\n        n = len(nums)\\n        \\n        dp = [nums[i - 1] if i > 0 else 0 for i in range(n + 1)]\\n        for i in range(1, n + 1):\\n            while (len(dq) > 0 and i - dq[0] > k):\\n                dq.popleft()\\n            if len(dq) > 0:\\n                dp[i] = max(dp[i], dp[dq[0]] + nums[i - 1])\\n            while (len(dq) > 0 and dp[dq[-1]] <= dp[i]):\\n                dq.pop()\\n            \\n            dq.append(i)\\n            \\n        return max([dp[i] for i in range(1, n + 1)])\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2384775,
                "title": "heap",
                "content": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& ar, int k) {\\n        priority_queue< pair<int,int>,vector< pair<int,int> >  > pq;\\n        int ans =*max_element(ar.begin(),ar.end());\\n        for(int idx=0; idx<ar.size();idx++){\\n            while(pq.size() >0 and idx - pq.top().second > k) pq.pop();\\n            if(pq.size() > 0)  pq.push({pq.top().first + ar[idx],idx});\\n            pq.push({ar[idx],idx});\\n        }\\n        return max(ans,pq.top().first);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& ar, int k) {\\n        priority_queue< pair<int,int>,vector< pair<int,int> >  > pq;\\n        int ans =*max_element(ar.begin(),ar.end());\\n        for(int idx=0; idx<ar.size();idx++){\\n            while(pq.size() >0 and idx - pq.top().second > k) pq.pop();\\n            if(pq.size() > 0)  pq.push({pq.top().first + ar[idx],idx});\\n            pq.push({ar[idx],idx});\\n        }\\n        return max(ans,pq.top().first);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2349490,
                "title": "java-dp-optimized-using-priority-queue",
                "content": "```\\nclass Solution {\\n    class pair implements Comparable<pair>{\\n        int ans;\\n        int i;\\n        pair(int ans , int i){\\n            this.ans = ans;\\n            this.i = i;\\n        }\\n        public int compareTo(pair o){\\n            return o.ans - this.ans;\\n        }\\n    }\\n    public int constrainedSubsetSum(int[] a, int k) {\\n        int n = a.length;\\n        int dp[] = new int[n];\\n        PriorityQueue<pair> pq = new PriorityQueue<>();\\n        int max = -1;\\n        for(int i = n - 1; i >= 0; i--){\\n            while(pq.size() > 0 && pq.peek().i > i + k){\\n                pq.poll();\\n            }\\n            if(pq.size() > 0){\\n                pair pp = pq.peek();\\n                dp[i] = a[i] + pq.peek().ans;\\n            }\\n            else{\\n                dp[i] = a[i];\\n            }\\n            if(dp[i] > 0){\\n                pq.add(new pair(dp[i] , i));\\n            }\\n            max = Math.max(max , dp[i]);\\n        }\\n        return max;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n    class pair implements Comparable<pair>{\\n        int ans;\\n        int i;\\n        pair(int ans , int i){\\n            this.ans = ans;\\n            this.i = i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2345557,
                "title": "understanding-the-assigment",
                "content": "my code:\\n```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        if k>1:\\n            k-=1\\n        f=nums[:]\\n        cur =[]\\n        for i in range(len(nums)):\\n            print(i,nums,cur,sum(nums))\\n            if nums[i]<=0:\\n                cur.append((i,nums.pop(i)))\\n                nums.insert(i,0)\\n            else:\\n                if cur and cur[-1][0]-cur[0][0]<=k :\\n                    cur = []\\n                else:\\n                    cur.sort(key = lambda x :x[1])\\n                    while len(cur)>k:\\n                        a,b=cur.pop()\\n                        nums[a]=b\\n                    cur = []\\n        print(nums)\\n        if  not sum(nums):\\n            return max(f)\\n        else:\\n            return sum(nums)\\n```\\n\\'\\'\\'\\n\\n\\n                           \\n\\'\\'\\'\\nIm not sure why is this failing , maybe i dont understand the assigment well enough, but for example \\nwhy for this input :\\n[-8,3,-4,-4,-6,6,-3,9,4,-3]\\n1\\n\\nI should get 16 and not 14 ? \\nIsn\\'t the array we wanna sum will look like that in the end :\\n[0, 3, -4, -4, 0, 6, 0, 9, 4, 0]",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        if k>1:\\n            k-=1\\n        f=nums[:]\\n        cur =[]\\n        for i in range(len(nums)):\\n            print(i,nums,cur,sum(nums))\\n            if nums[i]<=0:\\n                cur.append((i,nums.pop(i)))\\n                nums.insert(i,0)\\n            else:\\n                if cur and cur[-1][0]-cur[0][0]<=k :\\n                    cur = []\\n                else:\\n                    cur.sort(key = lambda x :x[1])\\n                    while len(cur)>k:\\n                        a,b=cur.pop()\\n                        nums[a]=b\\n                    cur = []\\n        print(nums)\\n        if  not sum(nums):\\n            return max(f)\\n        else:\\n            return sum(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2330842,
                "title": "python3-decreasing-monotonic-deque-without-copying-the-original-array",
                "content": "We maintain a monotonic decreasing deque to store the valid possible sums in the window with length (k-1). Why k-1 instead of k? Because in each iteration, we introduce new candidate, the new candidate along with the k-1 window form our k-length window. \\nAnother implementation trick here is that we store the index and possible sum pair so that we can pop the outdated (invalid) element in the deque. \\n\\n```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        max_dq = deque()\\n        max_sum = float(\\'-inf\\')\\n\\n        for i in range(len(nums)):\\n            local_max = nums[i]\\n            local_max += max_dq[0][1] if max_dq else 0\\n            \\n            max_sum = max(max_sum, local_max)\\n            \\n            while max_dq and max_dq[-1][1] < local_max:\\n                max_dq.pop()\\n            \\n\\t\\t\\t# max_dq can be empty. In this case, the new coming candidate is the new coming number itself\\n            if local_max > 0:\\n                max_dq.append((i, local_max))\\n            \\n\\t\\t\\t# remove updated element\\n            if max_dq and max_dq[0][0] == i-k:\\n                max_dq.popleft()\\n            \\n        return max_sum\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        max_dq = deque()\\n        max_sum = float(\\'-inf\\')\\n\\n        for i in range(len(nums)):\\n            local_max = nums[i]\\n            local_max += max_dq[0][1] if max_dq else 0\\n            \\n            max_sum = max(max_sum, local_max)\\n            \\n            while max_dq and max_dq[-1][1] < local_max:\\n                max_dq.pop()\\n            \\n\\t\\t\\t# max_dq can be empty. In this case, the new coming candidate is the new coming number itself\\n            if local_max > 0:\\n                max_dq.append((i, local_max))\\n            \\n\\t\\t\\t# remove updated element\\n            if max_dq and max_dq[0][0] == i-k:\\n                max_dq.popleft()\\n            \\n        return max_sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2289398,
                "title": "c-o-nlogn-multiset-dynamic-programming",
                "content": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n      vector < int > dp(nums.size()  , 0); \\n          multiset < int > st; \\n   int t = 0 , j =0 ; \\n        int mxSum = INT_MIN ; \\n     for(int i = 0 ; i < nums.size(); i++){ \\n         dp[i] = nums[i]; \\n         if(st.size() > 0) { auto it = st.end(); it--; \\n         dp[i] += max(0 , *it); }\\n         t++; \\n         if(t > k){ \\n         auto it = st.find(dp[j]); \\n            st.erase(it); \\n             j++; \\n         }\\n          st.insert(dp[i]); \\n       mxSum = max( mxSum , dp[i]);    \\n     }  \\n        return mxSum; \\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n      vector < int > dp(nums.size()  , 0); \\n          multiset < int > st; \\n   int t = 0 , j =0 ; \\n        int mxSum = INT_MIN ; \\n     for(int i = 0 ; i < nums.size(); i++){ \\n         dp[i] = nums[i]; \\n         if(st.size() > 0) { auto it = st.end(); it--; \\n         dp[i] += max(0 , *it); }\\n         t++; \\n         if(t > k){ \\n         auto it = st.find(dp[j]); \\n            st.erase(it); \\n             j++; \\n         }\\n          st.insert(dp[i]); \\n       mxSum = max( mxSum , dp[i]);    \\n     }  \\n        return mxSum; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2283151,
                "title": "python-2-solution-heap-and-monotonic-deque",
                "content": "#### Heap Solution:\\n* Time: O(Nlog(k))\\n* Space O(k)\\n```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        \\n        res = nums[0]\\n        hq = [(-nums[0], 0)] # (-dp[j],j) dp[j]: maximum sum until index j including nums[j]  \\n        \\n        for j, num in enumerate(nums[1:], start = 1):\\n    \\n            while hq and hq[0][1] < j-k: heapq.heappop(hq)\\n                \\n            cur = max(-hq[0][0], 0) + num\\n            heapq.heappush(hq,(-cur,j))\\n            res = max(res,cur)\\n\\n        return res\\n```\\n#### Deque Solution:\\n* Time: O(N)\\n* Space: O(k)\\n```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        \\n        res = nums[0]\\n        dq = deque([(0,nums[0])])\\n        \\n        for j, num in enumerate(nums[1:], start =1):\\n            cur = max(0, dq[0][1]) + num\\n            \\n            while dq and dq[-1][1] <= cur: dq.pop()\\n            \\n            dq.append((j, cur))\\n            \\n            if dq and dq[0][0] == j - k: dq.popleft()\\n            \\n            res = max(res,cur)\\n\\n        return res\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Queue",
                    "Heap (Priority Queue)",
                    "Monotonic Queue"
                ],
                "code": "```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        \\n        res = nums[0]\\n        hq = [(-nums[0], 0)] # (-dp[j],j) dp[j]: maximum sum until index j including nums[j]  \\n        \\n        for j, num in enumerate(nums[1:], start = 1):\\n    \\n            while hq and hq[0][1] < j-k: heapq.heappop(hq)\\n                \\n            cur = max(-hq[0][0], 0) + num\\n            heapq.heappush(hq,(-cur,j))\\n            res = max(res,cur)\\n\\n        return res\\n```\n```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        \\n        res = nums[0]\\n        dq = deque([(0,nums[0])])\\n        \\n        for j, num in enumerate(nums[1:], start =1):\\n            cur = max(0, dq[0][1]) + num\\n            \\n            while dq and dq[-1][1] <= cur: dq.pop()\\n            \\n            dq.append((j, cur))\\n            \\n            if dq and dq[0][0] == j - k: dq.popleft()\\n            \\n            res = max(res,cur)\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2273270,
                "title": "python3-decreasing-deque-o-n",
                "content": "```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        sw=deque()\\n        n=len(nums)\\n        currSum=0\\n        ans=-float(\\'inf\\')\\n        for i in range(n):\\n            if sw and i-k>sw[0][0]:\\n                sw.popleft()\\n            if len(sw):\\n                currSum=max(nums[i],nums[i]+sw[0][1])\\n            else:\\n                currSum=nums[i]\\n            #print(currSum,sw)\\n            while sw and sw[-1][1]<=currSum:\\n                sw.pop()\\n            sw.append([i,currSum])\\n            ans=max(ans,currSum)\\n        return ans\\n                    \\n                \\n                \\n```",
                "solutionTags": [
                    "Python3",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        sw=deque()\\n        n=len(nums)\\n        currSum=0\\n        ans=-float(\\'inf\\')\\n        for i in range(n):\\n            if sw and i-k>sw[0][0]:\\n                sw.popleft()\\n            if len(sw):\\n                currSum=max(nums[i],nums[i]+sw[0][1])\\n            else:\\n                currSum=nums[i]\\n            #print(currSum,sw)\\n            while sw and sw[-1][1]<=currSum:\\n                sw.pop()\\n            sw.append([i,currSum])\\n            ans=max(ans,currSum)\\n        return ans\\n                    \\n                \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2271735,
                "title": "c-easy-solution-using-double-ended-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        deque<pair<int,int>> dq;\\n        int result=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n            while(!dq.empty() && dq.front().second<i-k) dq.pop_front();\\n            int item=nums[i];\\n            if(!dq.empty()) item=max(item,nums[i]+dq.front().first);\\n            result=max(result,item);\\n            while(!dq.empty() && dq.back().first<item) dq.pop_back();\\n            dq.push_back({item,i});\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        deque<pair<int,int>> dq;\\n        int result=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n            while(!dq.empty() && dq.front().second<i-k) dq.pop_front();\\n            int item=nums[i];\\n            if(!dq.empty()) item=max(item,nums[i]+dq.front().first);\\n            result=max(result,item);\\n            while(!dq.empty() && dq.back().first<item) dq.pop_back();\\n            dq.push_back({item,i});\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2269353,
                "title": "python3-solution-dp-deque",
                "content": "`Time Complexity` : `O(n)`\\n`Space Complexity` : `O(k)`\\n\\n```\\nclass Solution:\\n    def constrainedSubsetSum(self, A, k):\\n        q = collections.deque()\\n        for i in reversed(range(len(A))):\\n            if q and q[-1] > i + k: q.pop()\\n            A[i] += A[q[-1]] if q else 0\\n            while q and A[q[0]] <= A[i]:\\n                q.popleft()\\n            if A[i] > 0: q.appendleft(i)\\n        return max(A)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def constrainedSubsetSum(self, A, k):\\n        q = collections.deque()\\n        for i in reversed(range(len(A))):\\n            if q and q[-1] > i + k: q.pop()\\n            A[i] += A[q[-1]] if q else 0\\n            while q and A[q[0]] <= A[i]:\\n                q.popleft()\\n            if A[i] > 0: q.appendleft(i)\\n        return max(A)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2246143,
                "title": "java-sliding-window",
                "content": "```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int start =0 ,end = 0,ans = Integer.MIN_VALUE ,currSum =0;\\n        List<Integer> prevKSum = new LinkedList<>();\\n        int[] dp = new int[nums.length];\\n        while(end < nums.length){\\n            currSum = Math.max(nums[end],nums[end]+(prevKSum.size()>0 ? prevKSum.get(0):0)); \\n            dp[end]= currSum;\\n            \\n             while(prevKSum.size() > 0 && prevKSum.get(prevKSum.size()-1) < currSum)\\n                prevKSum.remove(prevKSum.size()-1);\\n            \\n            prevKSum.add(currSum);\\n            \\n            if(end-start+1>k){\\n                  if(prevKSum.get(0)==dp[end-k])\\n                    prevKSum.remove(0);\\n            }\\n            ans = Math.max(ans,currSum);\\n            end++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int start =0 ,end = 0,ans = Integer.MIN_VALUE ,currSum =0;\\n        List<Integer> prevKSum = new LinkedList<>();\\n        int[] dp = new int[nums.length];\\n        while(end < nums.length){\\n            currSum = Math.max(nums[end],nums[end]+(prevKSum.size()>0 ? prevKSum.get(0):0)); \\n            dp[end]= currSum;\\n            \\n             while(prevKSum.size() > 0 && prevKSum.get(prevKSum.size()-1) < currSum)\\n                prevKSum.remove(prevKSum.size()-1);\\n            \\n            prevKSum.add(currSum);\\n            \\n            if(end-start+1>k){\\n                  if(prevKSum.get(0)==dp[end-k])\\n                    prevKSum.remove(0);\\n            }\\n            ans = Math.max(ans,currSum);\\n            end++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2215742,
                "title": "c-monotonic-queue",
                "content": "[self-use]\\nWe use an additional array:\\ndp[i] = maximum sum we can get using A[i] as the ending number of the subsequence.\\nThe subsequence also has to satisfy the condition that it cannot use any number outside of range [i-k,i] as required by the problem.\\n\\nWe use a monotonic q to store non-increasing sequence of sums (dp[i]) to help us derive each dp[i]\\n\\nSay we are at index i:\\n1. The front of the q is the largest sum possible using elements from [i-k, i].\\n2. The back of the q is the smallest sum possible ...\\n3. sum = A[i] + q.front() is the new largest possible sum using element i\\n4. with the monotonic queue logic, we just remove back of the q if sum is greater, since a smaller sum is no longer of interest.\\n\\nFor 1, we have to maintain the property by removing out of range element in the prior end of the loop [sliding window technique].\\nWe also don\\'t want to add negative or zero values to the queue because they don\\'t contribute to a larger sum.\\nAdding zeros to queue can still give a correct output because those values will be poped by the monotonic queue logic.\\nAdding negative values are harmful because it violates 1 mentioned above \"q front should be the largest sum...\". \\n\\nSay A is size of N, K=k\\nTime Complexity: \\nO(N) on average as the q only stores up to k elements (all dp[i]).\\nSpace Complexity:\\nO(N) for the dp.\\nO(K) for the deque.\\n```\\n    int constrainedSubsetSum(vector<int>& A, int k) {\\n        deque<int> q;\\n        vector<int> dp(A.size(), 0);\\n        int res = -1;\\n        for (int i = 0; i < A.size(); i++) {\\n            dp[i] = A[i] + (q.empty() ? 0 : q.front());\\n            res = max(dp[i], res);\\n            while (!q.empty() && dp[i] > q.back()) {\\n                q.pop_back();\\n            }\\n            if (dp[i] > 0) {\\n                q.push_back(dp[i]);\\n            }\\n            //next element cannot use i-k anymore\\n            if (i >= k) {\\n                if (!q.empty() && q.front() == dp[i-k]) {\\n                    q.pop_front();\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int constrainedSubsetSum(vector<int>& A, int k) {\\n        deque<int> q;\\n        vector<int> dp(A.size(), 0);\\n        int res = -1;\\n        for (int i = 0; i < A.size(); i++) {\\n            dp[i] = A[i] + (q.empty() ? 0 : q.front());\\n            res = max(dp[i], res);\\n            while (!q.empty() && dp[i] > q.back()) {\\n                q.pop_back();\\n            }\\n            if (dp[i] > 0) {\\n                q.push_back(dp[i]);\\n            }\\n            //next element cannot use i-k anymore\\n            if (i >= k) {\\n                if (!q.empty() && q.front() == dp[i-k]) {\\n                    q.pop_front();\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2204689,
                "title": "java-0-n-sliding-window-maxima",
                "content": "```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        //j-i <= k\\n        //dp(j) =max(dp(j-1),dp(j-2),....dp(j-k))+nums[j]\\n        /*\\n           10 2 -10 5 20\\n           10 12 0  17 37\\n           \\n           //sliding window maximum \\n        */\\n        int maxf=Integer.MIN_VALUE;\\n        List<Integer>l=new ArrayList<>();\\n        int[]dp=new int[nums.length];\\n        \\n        for(int i=0;i<=k-1;i++){\\n            int tmp=Math.max(nums[i],nums[i]+(l.size()==0?0:l.get(0)));\\n            maxf=Math.max(maxf,tmp);\\n            dp[i]=tmp;\\n                \\n            while(l.size() > 0 && l.get(l.size()-1) < tmp)\\n                l.remove(l.size()-1);\\n            \\n            l.add(tmp);\\n        }\\n        for(int i=k;i<nums.length;i++){\\n            int tmp=Math.max(nums[i],nums[i]+(l.size()==0?0:l.get(0)));\\n            maxf=Math.max(maxf,tmp);\\n            \\n             while(l.size() > 0 && l.get(l.size()-1) < tmp)\\n                l.remove(l.size()-1);\\n            \\n            l.add(tmp);\\n            dp[i]=tmp;\\n            \\n            if(l.get(0)==dp[i-k])\\n                l.remove(0);\\n        }\\n        return maxf;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        //j-i <= k\\n        //dp(j) =max(dp(j-1),dp(j-2),....dp(j-k))+nums[j]\\n        /*\\n           10 2 -10 5 20\\n           10 12 0  17 37\\n           \\n           //sliding window maximum \\n        */\\n        int maxf=Integer.MIN_VALUE;\\n        List<Integer>l=new ArrayList<>();\\n        int[]dp=new int[nums.length];\\n        \\n        for(int i=0;i<=k-1;i++){\\n            int tmp=Math.max(nums[i],nums[i]+(l.size()==0?0:l.get(0)));\\n            maxf=Math.max(maxf,tmp);\\n            dp[i]=tmp;\\n                \\n            while(l.size() > 0 && l.get(l.size()-1) < tmp)\\n                l.remove(l.size()-1);\\n            \\n            l.add(tmp);\\n        }\\n        for(int i=k;i<nums.length;i++){\\n            int tmp=Math.max(nums[i],nums[i]+(l.size()==0?0:l.get(0)));\\n            maxf=Math.max(maxf,tmp);\\n            \\n             while(l.size() > 0 && l.get(l.size()-1) < tmp)\\n                l.remove(l.size()-1);\\n            \\n            l.add(tmp);\\n            dp[i]=tmp;\\n            \\n            if(l.get(0)==dp[i-k])\\n                l.remove(0);\\n        }\\n        return maxf;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2194519,
                "title": "python-o-n-monotonic-queue-with-dp-solution-with-explanation",
                "content": "### About brute force with DP\\nthe problem is to find the subsequence sum, so dp is needed.\\n```dp[i]``` is maximum subsequence sum with ```i``` as the end point (must contain ```nums[i]```)\\nstate transition equation is ```dp[i] = max(nums[i], {dp[i-j] + nums[i], j in [1, k], if i-j >= 0})```\\n\\nbrute force with dp array is to use size k sliding window to find its max value, tc is O(kN)\\n\\n### monotonic queue with DP\\nso, we need a data struture to track max value of sliding window, the candidates have max heap (logN) and monotonic queue which is maintained in the decreasing order. the latter is more time efficient.\\n\\nAnd deque is used as monotonic queue\\'s data container, and stores dp array\\'s index instead of value.\\n\\n1. initiate ```dp[i]``` to ```nums[i]``` -> ```currentMaxSum[idx] = n```\\n2. ```dp[i] = nums[i] + max({dp[i-j] + nums[i], j in [1, k], if i-j >= 0}))```, the tail of queue is max value (>0) of sliding window if queue is not empty ->```if monoq: currentMaxSum[idx] += peekTailOfQ()```\\n3. find the max subsequence sum -> ```ans = max(ans, currentMaxSum[idx])```\\n4. start to process information used in ```dp[i+1]```\\n5. remove max value (index, actually) is out of sliding window from the tail (left remove) -> ```if monoq and idx - monoq[0] >= k: monoq.popleft()```\\n6. when ```dp[i]``` is greater than or equals to the top value, remove value from the top to keep the decreasing order -> ```while monoq and currentMaxSum[idx] >= peekTopOfQ(): monoq.pop()```\\n7. if ```dp[i]``` is greater than 0, put into the queue -> ```if currentMaxSum[idx] > 0: monoq.append(idx)``` (only interested in subsequence sum is >0)\\n\\ntc: O(N) element in dp array pop from/ push into monotonic queue once,  sc:O(N)\\n\\n```\\nfrom collections import deque\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        currentMaxSum, monoq, ans = [0]*len(nums), deque(), float(\\'-inf\\')\\n        peekTailOfQ, peekTopOfQ = lambda: currentMaxSum[monoq[0]], lambda: currentMaxSum[monoq[-1]]\\n        for idx, n in enumerate(nums):\\n            currentMaxSum[idx] = n\\n            if monoq: currentMaxSum[idx] += peekTailOfQ()\\n            ans = max(ans, currentMaxSum[idx])\\n            if monoq and idx - monoq[0] >= k: monoq.popleft()\\n            while monoq and currentMaxSum[idx] >= peekTopOfQ(): monoq.pop()\\n            if currentMaxSum[idx] > 0: monoq.append(idx)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```dp[i]```\n```i```\n```nums[i]```\n```dp[i] = max(nums[i], {dp[i-j] + nums[i], j in [1, k], if i-j >= 0})```\n```dp[i]```\n```nums[i]```\n```currentMaxSum[idx] = n```\n```dp[i] = nums[i] + max({dp[i-j] + nums[i], j in [1, k], if i-j >= 0}))```\n```if monoq: currentMaxSum[idx] += peekTailOfQ()```\n```ans = max(ans, currentMaxSum[idx])```\n```dp[i+1]```\n```if monoq and idx - monoq[0] >= k: monoq.popleft()```\n```dp[i]```\n```while monoq and currentMaxSum[idx] >= peekTopOfQ(): monoq.pop()```\n```dp[i]```\n```if currentMaxSum[idx] > 0: monoq.append(idx)```\n```\\nfrom collections import deque\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        currentMaxSum, monoq, ans = [0]*len(nums), deque(), float(\\'-inf\\')\\n        peekTailOfQ, peekTopOfQ = lambda: currentMaxSum[monoq[0]], lambda: currentMaxSum[monoq[-1]]\\n        for idx, n in enumerate(nums):\\n            currentMaxSum[idx] = n\\n            if monoq: currentMaxSum[idx] += peekTailOfQ()\\n            ans = max(ans, currentMaxSum[idx])\\n            if monoq and idx - monoq[0] >= k: monoq.popleft()\\n            while monoq and currentMaxSum[idx] >= peekTopOfQ(): monoq.pop()\\n            if currentMaxSum[idx] > 0: monoq.append(idx)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2154322,
                "title": "c-o-nlogk-solution-using-set-data-structure",
                "content": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        \\n        int n=nums.size();\\n        \\n        set<pair<int,int>> st;\\n        \\n        vector<int> maxPreSum=nums;\\n        \\n        int maxSum=nums[0], start=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(st.empty())\\n            {\\n                maxPreSum[i]=nums[i];\\n            }\\n            else\\n            {\\n                auto it = st.end();\\n                it--;\\n                \\n                pair<int,int> x = *it;\\n                \\n                maxPreSum[i]=max(maxPreSum[i],nums[i]+x.first);   \\n            }\\n            \\n            st.insert({maxPreSum[i],i});\\n            maxSum=max(maxPreSum[i],maxSum);\\n            \\n            if(st.size()>k)\\n            {\\n                int index = start, val = maxPreSum[start];\\n                start++;\\n                \\n                st.erase({val,index});\\n            }\\n        }\\n        \\n        return maxSum;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        \\n        int n=nums.size();\\n        \\n        set<pair<int,int>> st;\\n        \\n        vector<int> maxPreSum=nums;\\n        \\n        int maxSum=nums[0], start=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(st.empty())\\n            {\\n                maxPreSum[i]=nums[i];\\n            }\\n            else\\n            {\\n                auto it = st.end();\\n                it--;\\n                \\n                pair<int,int> x = *it;\\n                \\n                maxPreSum[i]=max(maxPreSum[i],nums[i]+x.first);   \\n            }\\n            \\n            st.insert({maxPreSum[i],i});\\n            maxSum=max(maxPreSum[i],maxSum);\\n            \\n            if(st.size()>k)\\n            {\\n                int index = start, val = maxPreSum[start];\\n                start++;\\n                \\n                st.erase({val,index});\\n            }\\n        }\\n        \\n        return maxSum;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2115333,
                "title": "monotonic-deque",
                "content": "```cpp\\ntypedef int ll;\\n\\nconst ll INF = 0x3f3f3f3f;\\n\\nstruct dq {\\n    ll st = 0;\\n    ll ed = -1;\\n    pair<ll, ll> arr[100001];\\n    \\n    inline bool empty() {\\n        return st > ed;\\n    }\\n    \\n    inline void popf() {\\n        st ++;\\n    }\\n    \\n    inline void popb() {\\n        ed --;\\n    }\\n    \\n    inline void pushb(ll f, ll s) {\\n        arr[++ed] ={f, s};\\n    }\\n    \\n    inline pair<ll, ll> &front() {\\n        return arr[st];\\n    }\\n    \\n    inline pair<ll, ll> &back() {\\n        return arr[ed];\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        ll N = nums.size();\\n        \\n        dq q;\\n        q.pushb(0, 0);\\n        \\n        ll ans = -INF;\\n        \\n        for (ll i = 1, v; i <= N; i ++) {\\n            while (!q.empty() && i - q.front().first > k) {\\n                q.popf();\\n            }\\n            v = max(q.front().second + nums[i-1], nums[i-1]);\\n            ans = max(ans, v);\\n            while (!q.empty() && v >= q.back().second) {\\n                q.popb();\\n            }\\n            q.pushb(i, v);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Monotonic Queue"
                ],
                "code": "```cpp\\ntypedef int ll;\\n\\nconst ll INF = 0x3f3f3f3f;\\n\\nstruct dq {\\n    ll st = 0;\\n    ll ed = -1;\\n    pair<ll, ll> arr[100001];\\n    \\n    inline bool empty() {\\n        return st > ed;\\n    }\\n    \\n    inline void popf() {\\n        st ++;\\n    }\\n    \\n    inline void popb() {\\n        ed --;\\n    }\\n    \\n    inline void pushb(ll f, ll s) {\\n        arr[++ed] ={f, s};\\n    }\\n    \\n    inline pair<ll, ll> &front() {\\n        return arr[st];\\n    }\\n    \\n    inline pair<ll, ll> &back() {\\n        return arr[ed];\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        ll N = nums.size();\\n        \\n        dq q;\\n        q.pushb(0, 0);\\n        \\n        ll ans = -INF;\\n        \\n        for (ll i = 1, v; i <= N; i ++) {\\n            while (!q.empty() && i - q.front().first > k) {\\n                q.popf();\\n            }\\n            v = max(q.front().second + nums[i-1], nums[i-1]);\\n            ans = max(ans, v);\\n            while (!q.empty() && v >= q.back().second) {\\n                q.popb();\\n            }\\n            q.pushb(i, v);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2081470,
                "title": "java-dp-monotonic-deque-compare-with-two-solutions",
                "content": "1. Index in the monotinic increasing Deque\\nThe first solution is that we add our index to the monotonic index increasing deque, if the distance between i and the smallest index in deque is greater than k, we remove the smallest index out of the deque. In this way, we can make sure that the deque\\'s length will always under k. Besides, we also remove the value which absolutely would not be the biggest subset sum in the deque by removing the last index in the deque that is smaller than current dp value.\\n```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] dp = new int[n];\\n        int res = nums[0];\\n        Deque<Integer> window = new LinkedList<>();\\n        window.offer(0);\\n        for(int i = 0; i < n; i++) dp[i] = nums[i];\\n        for(int i = 1; i < n; i++){\\n            dp[i] = Math.max(dp[i], nums[i] + dp[window.peek()]);\\n            res = Math.max(res, dp[i]);\\n            while(!window.isEmpty() && i - window.peekFirst() + 1 > k) window.pollFirst();\\n            while(!window.isEmpty() && dp[window.peekLast()] <= dp[i]) window.pollLast();\\n            window.offerLast(i);\\n        }\\n        return res;\\n    }\\n}\\n```\\n2. DP value in the monotonic value decreasing Deque\\nThe second solution is that we add our dp value to the monotonic decreasing deque, if the window length is greater than k we remove the greatest value in the deque, in order to maintain the length of the deque. Besides, we also remove the smallest value in the deque which is smaller than the current dp value, so that we can have the possible biggest subset sum in the deque.\\n```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] dp = new int[n];\\n        int res = nums[0];\\n        for(int i = 0; i < n; i++) dp[i] = nums[i];\\n        Deque<Integer> window = new LinkedList<>();\\n        window.offer(nums[0]);\\n        for(int i = 1; i < n; i++){\\n            if(i - k > 0 && window.peekFirst() == dp[i - k - 1]) window.pollFirst();\\n            dp[i] = Math.max(dp[i], nums[i] + window.peekFirst());\\n            while(!window.isEmpty() && window.peekLast() < dp[i]) window.pollLast();\\n            window.offerLast(dp[i]);\\n            res = Math.max(dp[i], res);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] dp = new int[n];\\n        int res = nums[0];\\n        Deque<Integer> window = new LinkedList<>();\\n        window.offer(0);\\n        for(int i = 0; i < n; i++) dp[i] = nums[i];\\n        for(int i = 1; i < n; i++){\\n            dp[i] = Math.max(dp[i], nums[i] + dp[window.peek()]);\\n            res = Math.max(res, dp[i]);\\n            while(!window.isEmpty() && i - window.peekFirst() + 1 > k) window.pollFirst();\\n            while(!window.isEmpty() && dp[window.peekLast()] <= dp[i]) window.pollLast();\\n            window.offerLast(i);\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] dp = new int[n];\\n        int res = nums[0];\\n        for(int i = 0; i < n; i++) dp[i] = nums[i];\\n        Deque<Integer> window = new LinkedList<>();\\n        window.offer(nums[0]);\\n        for(int i = 1; i < n; i++){\\n            if(i - k > 0 && window.peekFirst() == dp[i - k - 1]) window.pollFirst();\\n            dp[i] = Math.max(dp[i], nums[i] + window.peekFirst());\\n            while(!window.isEmpty() && window.peekLast() < dp[i]) window.pollLast();\\n            window.offerLast(dp[i]);\\n            res = Math.max(dp[i], res);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2055188,
                "title": "c-short-deque-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        int n = nums.size(), output = nums[0];\\n        deque<int> dp;\\n        for (int i = 1; i < n; ++i){\\n            while (!dp.empty() && nums[dp.back()] <= nums[i-1]){\\n                dp.pop_back();\\n            }\\n            if (nums[i - 1] > 0){\\n                dp.push_back(i-1);\\n            }\\n            if (!dp.empty()){\\n                nums[i] += nums[dp.front()];\\n                if (i - dp.front() >= k){\\n                    dp.pop_front();\\n                }\\n            }\\n            output = max(output,nums[i]);\\n        }\\n        return output; \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        int n = nums.size(), output = nums[0];\\n        deque<int> dp;\\n        for (int i = 1; i < n; ++i){\\n            while (!dp.empty() && nums[dp.back()] <= nums[i-1]){\\n                dp.pop_back();\\n            }\\n            if (nums[i - 1] > 0){\\n                dp.push_back(i-1);\\n            }\\n            if (!dp.empty()){\\n                nums[i] += nums[dp.front()];\\n                if (i - dp.front() >= k){\\n                    dp.pop_front();\\n                }\\n            }\\n            output = max(output,nums[i]);\\n        }\\n        return output; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2048733,
                "title": "python-monotonic-deque-solution-faster-than-99-11",
                "content": "```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        q = deque()\\n        for i in range(len(nums)) :\\n            nums[i] += q[0] if q else 0\\n            while q and q[-1] < nums[i] :\\n                q.pop()\\n            if nums[i] > 0 : q.append(nums[i]) \\n            if i >= k and q and q[0] == nums[i-k] :\\n                q.popleft()\\n            # print(nums)\\n        return max(nums)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Queue",
                    "Monotonic Queue"
                ],
                "code": "```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        q = deque()\\n        for i in range(len(nums)) :\\n            nums[i] += q[0] if q else 0\\n            while q and q[-1] < nums[i] :\\n                q.pop()\\n            if nums[i] > 0 : q.append(nums[i]) \\n            if i >= k and q and q[0] == nums[i-k] :\\n                q.popleft()\\n            # print(nums)\\n        return max(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2031318,
                "title": "c-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        int i, j, len = nums.size();\\n        deque<pair<int, int>> dq;\\n        int maxSum = INT_MIN;\\n        \\n        for(i = 0; i < len; i++){\\n            while(!dq.empty() && (i - dq.front().second > k || dq.front().first <= 0)){\\n                dq.pop_front();\\n            }\\n            \\n            if(dq.empty()){\\n                maxSum = max(maxSum, nums[i]);\\n                dq.push_back(make_pair(nums[i], i));\\n                continue;\\n            }\\n            \\n            j = dq.front().first + nums[i];            \\n            while(!dq.empty() && j >= dq.back().first){\\n                dq.pop_back();\\n            }\\n            \\n            dq.push_back(make_pair(j, i));\\n            maxSum = max(maxSum, j);\\n        }\\n        \\n        return maxSum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        int i, j, len = nums.size();\\n        deque<pair<int, int>> dq;\\n        int maxSum = INT_MIN;\\n        \\n        for(i = 0; i < len; i++){\\n            while(!dq.empty() && (i - dq.front().second > k || dq.front().first <= 0)){\\n                dq.pop_front();\\n            }\\n            \\n            if(dq.empty()){\\n                maxSum = max(maxSum, nums[i]);\\n                dq.push_back(make_pair(nums[i], i));\\n                continue;\\n            }\\n            \\n            j = dq.front().first + nums[i];            \\n            while(!dq.empty() && j >= dq.back().first){\\n                dq.pop_back();\\n            }\\n            \\n            dq.push_back(make_pair(j, i));\\n            maxSum = max(maxSum, j);\\n        }\\n        \\n        return maxSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2013384,
                "title": "85-faster-java-simple-solution",
                "content": "java code is:\\n```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n       Deque<int[]>queue=new ArrayDeque<>();\\n       int res=Integer.MIN_VALUE;\\n       for(int i=0,j=0;i<nums.length;i++){\\n            while(!queue.isEmpty()&&i-queue.peek()[0]>k)queue.poll();\\n             int val=Math.max(nums[i],nums[i]+(queue.isEmpty() ? 0 : queue.peek()[1]));\\n            while(!queue.isEmpty()&&queue.peekLast()[1]<=val)queue.pollLast();\\n           queue.add(new int[]{i,val});\\n           res=Math.max(res,val);\\n        }\\n        return res;\\n    }\\n}\\n```\\nTime : O(n) linear time\\nSpace: O(k) linear\\n\\nPlease upvote if this is helpful",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n       Deque<int[]>queue=new ArrayDeque<>();\\n       int res=Integer.MIN_VALUE;\\n       for(int i=0,j=0;i<nums.length;i++){\\n            while(!queue.isEmpty()&&i-queue.peek()[0]>k)queue.poll();\\n             int val=Math.max(nums[i],nums[i]+(queue.isEmpty() ? 0 : queue.peek()[1]));\\n            while(!queue.isEmpty()&&queue.peekLast()[1]<=val)queue.pollLast();\\n           queue.add(new int[]{i,val});\\n           res=Math.max(res,val);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1972549,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        priority_queue<pair<int,int>> pq;\\n        int ans = INT_MIN;\\n        for(int i=0; i<nums.size(); i++){\\n            if(i == 0){\\n                ans = nums[i];  \\n                pq.push({ans, i});\\n            }\\n            else{\\n                if(pq.top().second < i-k){\\n                    while(pq.top().second < i-k)\\n                        pq.pop();\\n                }\\n                if(pq.top().first >= 0){\\n                    pair<int,int> a = pq.top();\\n                    a.first += nums[i];\\n                    a.second = i;\\n                    pq.push(a);\\n                    ans = max(ans, a.first);\\n                }\\n                else{\\n                    ans = max(ans, nums[i]);\\n                    pq.push({nums[i], i});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        priority_queue<pair<int,int>> pq;\\n        int ans = INT_MIN;\\n        for(int i=0; i<nums.size(); i++){\\n            if(i == 0){\\n                ans = nums[i];  \\n                pq.push({ans, i});\\n            }\\n            else{\\n                if(pq.top().second < i-k){\\n                    while(pq.top().second < i-k)\\n                        pq.pop();\\n                }\\n                if(pq.top().first >= 0){\\n                    pair<int,int> a = pq.top();\\n                    a.first += nums[i];\\n                    a.second = i;\\n                    pq.push(a);\\n                    ans = max(ans, a.first);\\n                }\\n                else{\\n                    ans = max(ans, nums[i]);\\n                    pq.push({nums[i], i});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1971951,
                "title": "python-deque",
                "content": "```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        dp = [n for n in nums]\\n        res = float(\\'-inf\\')\\n        #dq[0] is the maximum Subsequence Sum before i\\n        dq = collections.deque()\\n        for i in range(len(nums)):\\n            #only keep positive and avaible Subsequence Sum before i\\n            while dq and (dq[0] < i-k or dp[dq[0]] <=0):\\n                dq.popleft()\\n            if dq:\\n                dp[i] = dp[dq[0]] + nums[i] \\n            res = max(res,dp[i])\\n            #update dq to keep it non-decreasing from left to right\\n            while dq and dp[dq[-1]] < dp[i]:\\n                dq.pop()\\n            dq.append(i)    \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        dp = [n for n in nums]\\n        res = float(\\'-inf\\')\\n        #dq[0] is the maximum Subsequence Sum before i\\n        dq = collections.deque()\\n        for i in range(len(nums)):\\n            #only keep positive and avaible Subsequence Sum before i\\n            while dq and (dq[0] < i-k or dp[dq[0]] <=0):\\n                dq.popleft()\\n            if dq:\\n                dp[i] = dp[dq[0]] + nums[i] \\n            res = max(res,dp[i])\\n            #update dq to keep it non-decreasing from left to right\\n            while dq and dp[dq[-1]] < dp[i]:\\n                dq.pop()\\n            dq.append(i)    \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1946350,
                "title": "c-decreasing-deque-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        deque<int> q;\\n        vector<int> dp(nums.size(),INT_MIN);\\n        dp[0] = nums[0];\\n        q.push_back(0); int re = dp[0];\\n        for(int i = 1;i<nums.size();++i){\\n            while(!q.empty() && i-q.front()>k) q.pop_front();\\n            if(q.size()) dp[i] = nums[i]+dp[q.front()];\\n            dp[i] = max(nums[i],dp[i]);\\n            while(!q.empty() && dp[q.back()]<=dp[i]) q.pop_back();\\n            q.push_back(i);\\n            re = max(re,dp[i]);\\n        }\\n        return re;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        deque<int> q;\\n        vector<int> dp(nums.size(),INT_MIN);\\n        dp[0] = nums[0];\\n        q.push_back(0); int re = dp[0];\\n        for(int i = 1;i<nums.size();++i){\\n            while(!q.empty() && i-q.front()>k) q.pop_front();\\n            if(q.size()) dp[i] = nums[i]+dp[q.front()];\\n            dp[i] = max(nums[i],dp[i]);\\n            while(!q.empty() && dp[q.back()]<=dp[i]) q.pop_back();\\n            q.push_back(i);\\n            re = max(re,dp[i]);\\n        }\\n        return re;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1784484,
                "title": "python-o-n-dp-sliding-window-explained",
                "content": "```\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        #consider\\n        #[5,-2,-1,-3,-1,-2,-3,4] and k = 3\\n        #[5,-2,-1,-3,-3,-3,4] and k = 3\\n        #[-1000,1,2,3,-1000] and k = 3\\n        \\n        #dp[i] stores max subsq starting from ith index\\n        #window keeps track of max subsq starting from next k elements\\n        \\n        n = len(nums)\\n        dp = [0]*n\\n        \\n        window = deque([[-1, n]])\\n        for i in range(n-1, -1, -1):\\n            #if next k subsq all lead to a negative val, no point combining with current element\\n            dp[i] = max(window[-1][0] + nums[i], nums[i])\\n            \\n            #element no longer belongs in window\\n            if window[-1][-1] - i >= k: window.pop()\\n            #no point keeping smaller subsq in window if latest is better\\n            while window and window[0][0] <= dp[i]: window.popleft()\\n            #include the latest subsq in the window\\n            window.appendleft([dp[i], i])\\n            \\n        return max(dp)\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Queue",
                    "Sliding Window",
                    "Monotonic Queue"
                ],
                "code": "```\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        #consider\\n        #[5,-2,-1,-3,-1,-2,-3,4] and k = 3\\n        #[5,-2,-1,-3,-3,-3,4] and k = 3\\n        #[-1000,1,2,3,-1000] and k = 3\\n        \\n        #dp[i] stores max subsq starting from ith index\\n        #window keeps track of max subsq starting from next k elements\\n        \\n        n = len(nums)\\n        dp = [0]*n\\n        \\n        window = deque([[-1, n]])\\n        for i in range(n-1, -1, -1):\\n            #if next k subsq all lead to a negative val, no point combining with current element\\n            dp[i] = max(window[-1][0] + nums[i], nums[i])\\n            \\n            #element no longer belongs in window\\n            if window[-1][-1] - i >= k: window.pop()\\n            #no point keeping smaller subsq in window if latest is better\\n            while window and window[0][0] <= dp[i]: window.popleft()\\n            #include the latest subsq in the window\\n            window.appendleft([dp[i], i])\\n            \\n        return max(dp)\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1763690,
                "title": "c-o-n-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        deque<pair<int, int>> dq;\\n        int maxS = nums[0], aux;\\n        dq.push_back(make_pair(maxS, 0));\\n        pair<int, int> p;\\n        \\n        for(int i = 1; i < nums.size(); i++)\\n        {\\n            p = dq.front();\\n            if(i - p.second > k)\\n            {\\n                dq.pop_front();\\n                if(dq.empty())\\n                {\\n                    if(nums[i] > maxS)\\n                        maxS = nums[i];\\n                    dq.push_back(make_pair(nums[i], i));\\n                    continue;\\n                }\\n                else\\n                    p = dq.front();\\n            }\\n            aux = max(nums[i], p.first + nums[i]);\\n            if(aux > maxS)\\n                maxS = aux;\\n            \\n            while(!dq.empty() && aux > dq.back().first)\\n            {\\n                dq.pop_back();                \\n            }\\n            dq.push_back(make_pair(aux, i));\\n        }\\n        return maxS;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        deque<pair<int, int>> dq;\\n        int maxS = nums[0], aux;\\n        dq.push_back(make_pair(maxS, 0));\\n        pair<int, int> p;\\n        \\n        for(int i = 1; i < nums.size(); i++)\\n        {\\n            p = dq.front();\\n            if(i - p.second > k)\\n            {\\n                dq.pop_front();\\n                if(dq.empty())\\n                {\\n                    if(nums[i] > maxS)\\n                        maxS = nums[i];\\n                    dq.push_back(make_pair(nums[i], i));\\n                    continue;\\n                }\\n                else\\n                    p = dq.front();\\n            }\\n            aux = max(nums[i], p.first + nums[i]);\\n            if(aux > maxS)\\n                maxS = aux;\\n            \\n            while(!dq.empty() && aux > dq.back().first)\\n            {\\n                dq.pop_back();                \\n            }\\n            dq.push_back(make_pair(aux, i));\\n        }\\n        return maxS;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1752322,
                "title": "c-o-n-solution-with-a-maximum-queue",
                "content": "[Source](https://cp-algorithms.com/data_structures/stack_queue_modification.html) about minimum queue, for which the implementation is equivalent to maximum queue.\\n\\n```\\nclass Solution {\\npublic:    \\n    int DP[100010];    \\n    \\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        deque<int> Q;\\n        Q.push_back(0);        \\n        int best = -INT_MAX;        \\n        int r = int(nums.size()) - 1;        \\n        for (int l = int(nums.size()) - 1; l >= 0; l--) {            \\n            DP[l] = nums[l] + max(0, Q.front());\\n            if (int(nums.size()) - l > k && Q.front() == DP[r--])           \\n                Q.pop_front();\\n            while (!Q.empty() && Q.back() < DP[l])\\n                Q.pop_back();\\n            Q.push_back(DP[l]);            \\n            best = max(best, DP[l]);\\n        }\\n        return best;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:    \\n    int DP[100010];    \\n    \\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        deque<int> Q;\\n        Q.push_back(0);        \\n        int best = -INT_MAX;        \\n        int r = int(nums.size()) - 1;        \\n        for (int l = int(nums.size()) - 1; l >= 0; l--) {            \\n            DP[l] = nums[l] + max(0, Q.front());\\n            if (int(nums.size()) - l > k && Q.front() == DP[r--])           \\n                Q.pop_front();\\n            while (!Q.empty() && Q.back() < DP[l])\\n                Q.pop_back();\\n            Q.push_back(DP[l]);            \\n            best = max(best, DP[l]);\\n        }\\n        return best;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1566602,
                "content": [
                    {
                        "username": "AaronHe7",
                        "content": "I\\'m having trouble understanding this because I\\'m used to consecutive meaning the difference between two numbers is one."
                    },
                    {
                        "username": "e8315402",
                        "content": "Although I haven't solved this yet, for those who have trouble understanding the question, I try my best to explain.\n\nThe question requires you to find a subsequence from a given array, whose sum should have a maximum sum.\n\nWhat is a subsequence? Meaning that you can remove any number from the array, or remove none of them, and then you can obtain a new array. This new array is called a subsequence.\nFor example, given an array [1,2,3], the subsequences could be [1, 2, 3] (remove no number), [2, 3] (remove 1), [1, 3] (remove 2), or [1] (remove 2 and 3).\n\nHowever, the subsequences you find from the array should obey a rule: for any two consecutive integers in a subsequence, the difference of their indexes `in the original array` should be less than or equal to k.\nFor example, given an array [1,2,3], k=1, the subsequence [1, 2, 3] is ok because each one has the diff 1 to their neighbors. But the subsequence [1, 3] is not ok because the index of int 1 is 0 and the index of int 3 is `2` and the diff is 2, which is over k.\n\nThe solution should find out what subsequence has a maximum sum. Hope the explanation above helps you."
                    },
                    {
                        "username": "rajeshtomar",
                        "content": "Maintain a sliding window of minimum elements(much like the sliding-window-maximum) problem which will give us the minimum of last k elements.\\n\\nThen, for each element:\\n1. if it\\'s +ve, just add it to the score. +ve element can only increase the score so take all of them.\\n2. if it\\'s -ve, get the minimum of this window and add that to the score.(minimum among last k elements including this one). This keeps the window moving.\\n\\nWill include code later.\\n"
                    },
                    {
                        "username": "Vmilica270",
                        "content": "I thought it would be easy, but then..."
                    },
                    {
                        "username": "stefan1096",
                        "content": "In fact,it is easier than a typical hard.Only a variation of kadane"
                    },
                    {
                        "username": "summi_r",
                        "content": "Can anybody explain how output of below is 2?\\n\\nnums=[-1000,-2000,-3000,-4000,2], k=2\\n\\nExpected O/p: 2\\n\\nI am unable to understand this question completely...Please help !"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "That\\'s the maximum sum, for the subsequence [2], compared to the other subsequences in that array."
                    }
                ]
            },
            {
                "id": 1889033,
                "content": [
                    {
                        "username": "AaronHe7",
                        "content": "I\\'m having trouble understanding this because I\\'m used to consecutive meaning the difference between two numbers is one."
                    },
                    {
                        "username": "e8315402",
                        "content": "Although I haven't solved this yet, for those who have trouble understanding the question, I try my best to explain.\n\nThe question requires you to find a subsequence from a given array, whose sum should have a maximum sum.\n\nWhat is a subsequence? Meaning that you can remove any number from the array, or remove none of them, and then you can obtain a new array. This new array is called a subsequence.\nFor example, given an array [1,2,3], the subsequences could be [1, 2, 3] (remove no number), [2, 3] (remove 1), [1, 3] (remove 2), or [1] (remove 2 and 3).\n\nHowever, the subsequences you find from the array should obey a rule: for any two consecutive integers in a subsequence, the difference of their indexes `in the original array` should be less than or equal to k.\nFor example, given an array [1,2,3], k=1, the subsequence [1, 2, 3] is ok because each one has the diff 1 to their neighbors. But the subsequence [1, 3] is not ok because the index of int 1 is 0 and the index of int 3 is `2` and the diff is 2, which is over k.\n\nThe solution should find out what subsequence has a maximum sum. Hope the explanation above helps you."
                    },
                    {
                        "username": "rajeshtomar",
                        "content": "Maintain a sliding window of minimum elements(much like the sliding-window-maximum) problem which will give us the minimum of last k elements.\\n\\nThen, for each element:\\n1. if it\\'s +ve, just add it to the score. +ve element can only increase the score so take all of them.\\n2. if it\\'s -ve, get the minimum of this window and add that to the score.(minimum among last k elements including this one). This keeps the window moving.\\n\\nWill include code later.\\n"
                    },
                    {
                        "username": "Vmilica270",
                        "content": "I thought it would be easy, but then..."
                    },
                    {
                        "username": "stefan1096",
                        "content": "In fact,it is easier than a typical hard.Only a variation of kadane"
                    },
                    {
                        "username": "summi_r",
                        "content": "Can anybody explain how output of below is 2?\\n\\nnums=[-1000,-2000,-3000,-4000,2], k=2\\n\\nExpected O/p: 2\\n\\nI am unable to understand this question completely...Please help !"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "That\\'s the maximum sum, for the subsequence [2], compared to the other subsequences in that array."
                    }
                ]
            },
            {
                "id": 1573673,
                "content": [
                    {
                        "username": "AaronHe7",
                        "content": "I\\'m having trouble understanding this because I\\'m used to consecutive meaning the difference between two numbers is one."
                    },
                    {
                        "username": "e8315402",
                        "content": "Although I haven't solved this yet, for those who have trouble understanding the question, I try my best to explain.\n\nThe question requires you to find a subsequence from a given array, whose sum should have a maximum sum.\n\nWhat is a subsequence? Meaning that you can remove any number from the array, or remove none of them, and then you can obtain a new array. This new array is called a subsequence.\nFor example, given an array [1,2,3], the subsequences could be [1, 2, 3] (remove no number), [2, 3] (remove 1), [1, 3] (remove 2), or [1] (remove 2 and 3).\n\nHowever, the subsequences you find from the array should obey a rule: for any two consecutive integers in a subsequence, the difference of their indexes `in the original array` should be less than or equal to k.\nFor example, given an array [1,2,3], k=1, the subsequence [1, 2, 3] is ok because each one has the diff 1 to their neighbors. But the subsequence [1, 3] is not ok because the index of int 1 is 0 and the index of int 3 is `2` and the diff is 2, which is over k.\n\nThe solution should find out what subsequence has a maximum sum. Hope the explanation above helps you."
                    },
                    {
                        "username": "rajeshtomar",
                        "content": "Maintain a sliding window of minimum elements(much like the sliding-window-maximum) problem which will give us the minimum of last k elements.\\n\\nThen, for each element:\\n1. if it\\'s +ve, just add it to the score. +ve element can only increase the score so take all of them.\\n2. if it\\'s -ve, get the minimum of this window and add that to the score.(minimum among last k elements including this one). This keeps the window moving.\\n\\nWill include code later.\\n"
                    },
                    {
                        "username": "Vmilica270",
                        "content": "I thought it would be easy, but then..."
                    },
                    {
                        "username": "stefan1096",
                        "content": "In fact,it is easier than a typical hard.Only a variation of kadane"
                    },
                    {
                        "username": "summi_r",
                        "content": "Can anybody explain how output of below is 2?\\n\\nnums=[-1000,-2000,-3000,-4000,2], k=2\\n\\nExpected O/p: 2\\n\\nI am unable to understand this question completely...Please help !"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "That\\'s the maximum sum, for the subsequence [2], compared to the other subsequences in that array."
                    }
                ]
            },
            {
                "id": 2063532,
                "content": [
                    {
                        "username": "AaronHe7",
                        "content": "I\\'m having trouble understanding this because I\\'m used to consecutive meaning the difference between two numbers is one."
                    },
                    {
                        "username": "e8315402",
                        "content": "Although I haven't solved this yet, for those who have trouble understanding the question, I try my best to explain.\n\nThe question requires you to find a subsequence from a given array, whose sum should have a maximum sum.\n\nWhat is a subsequence? Meaning that you can remove any number from the array, or remove none of them, and then you can obtain a new array. This new array is called a subsequence.\nFor example, given an array [1,2,3], the subsequences could be [1, 2, 3] (remove no number), [2, 3] (remove 1), [1, 3] (remove 2), or [1] (remove 2 and 3).\n\nHowever, the subsequences you find from the array should obey a rule: for any two consecutive integers in a subsequence, the difference of their indexes `in the original array` should be less than or equal to k.\nFor example, given an array [1,2,3], k=1, the subsequence [1, 2, 3] is ok because each one has the diff 1 to their neighbors. But the subsequence [1, 3] is not ok because the index of int 1 is 0 and the index of int 3 is `2` and the diff is 2, which is over k.\n\nThe solution should find out what subsequence has a maximum sum. Hope the explanation above helps you."
                    },
                    {
                        "username": "rajeshtomar",
                        "content": "Maintain a sliding window of minimum elements(much like the sliding-window-maximum) problem which will give us the minimum of last k elements.\\n\\nThen, for each element:\\n1. if it\\'s +ve, just add it to the score. +ve element can only increase the score so take all of them.\\n2. if it\\'s -ve, get the minimum of this window and add that to the score.(minimum among last k elements including this one). This keeps the window moving.\\n\\nWill include code later.\\n"
                    },
                    {
                        "username": "Vmilica270",
                        "content": "I thought it would be easy, but then..."
                    },
                    {
                        "username": "stefan1096",
                        "content": "In fact,it is easier than a typical hard.Only a variation of kadane"
                    },
                    {
                        "username": "summi_r",
                        "content": "Can anybody explain how output of below is 2?\\n\\nnums=[-1000,-2000,-3000,-4000,2], k=2\\n\\nExpected O/p: 2\\n\\nI am unable to understand this question completely...Please help !"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "That\\'s the maximum sum, for the subsequence [2], compared to the other subsequences in that array."
                    }
                ]
            },
            {
                "id": 1801886,
                "content": [
                    {
                        "username": "AaronHe7",
                        "content": "I\\'m having trouble understanding this because I\\'m used to consecutive meaning the difference between two numbers is one."
                    },
                    {
                        "username": "e8315402",
                        "content": "Although I haven't solved this yet, for those who have trouble understanding the question, I try my best to explain.\n\nThe question requires you to find a subsequence from a given array, whose sum should have a maximum sum.\n\nWhat is a subsequence? Meaning that you can remove any number from the array, or remove none of them, and then you can obtain a new array. This new array is called a subsequence.\nFor example, given an array [1,2,3], the subsequences could be [1, 2, 3] (remove no number), [2, 3] (remove 1), [1, 3] (remove 2), or [1] (remove 2 and 3).\n\nHowever, the subsequences you find from the array should obey a rule: for any two consecutive integers in a subsequence, the difference of their indexes `in the original array` should be less than or equal to k.\nFor example, given an array [1,2,3], k=1, the subsequence [1, 2, 3] is ok because each one has the diff 1 to their neighbors. But the subsequence [1, 3] is not ok because the index of int 1 is 0 and the index of int 3 is `2` and the diff is 2, which is over k.\n\nThe solution should find out what subsequence has a maximum sum. Hope the explanation above helps you."
                    },
                    {
                        "username": "rajeshtomar",
                        "content": "Maintain a sliding window of minimum elements(much like the sliding-window-maximum) problem which will give us the minimum of last k elements.\\n\\nThen, for each element:\\n1. if it\\'s +ve, just add it to the score. +ve element can only increase the score so take all of them.\\n2. if it\\'s -ve, get the minimum of this window and add that to the score.(minimum among last k elements including this one). This keeps the window moving.\\n\\nWill include code later.\\n"
                    },
                    {
                        "username": "Vmilica270",
                        "content": "I thought it would be easy, but then..."
                    },
                    {
                        "username": "stefan1096",
                        "content": "In fact,it is easier than a typical hard.Only a variation of kadane"
                    },
                    {
                        "username": "summi_r",
                        "content": "Can anybody explain how output of below is 2?\\n\\nnums=[-1000,-2000,-3000,-4000,2], k=2\\n\\nExpected O/p: 2\\n\\nI am unable to understand this question completely...Please help !"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "That\\'s the maximum sum, for the subsequence [2], compared to the other subsequences in that array."
                    }
                ]
            }
        ]
    }
]