[
    {
        "title": "Build a Matrix With Conditions",
        "question_content": "You are given a positive integer k. You are also given:\n\n\ta 2D integer array rowConditions of size n where rowConditions[i] = [abovei, belowi], and\n\ta 2D integer array colConditions of size m where colConditions[i] = [lefti, righti].\n\nThe two arrays contain integers from 1 to k.\nYou have to build a k x k matrix that contains each of the numbers from 1 to k exactly once. The remaining cells should have the value 0.\nThe matrix should also satisfy the following conditions:\n\n\tThe number abovei should appear in a row that is strictly above the row at which the number belowi appears for all i from 0 to n - 1.\n\tThe number lefti should appear in a column that is strictly left of the column at which the number righti appears for all i from 0 to m - 1.\n\nReturn any matrix that satisfies the conditions. If no answer exists, return an empty matrix.\n&nbsp;\nExample 1:\n\nInput: k = 3, rowConditions = [[1,2],[3,2]], colConditions = [[2,1],[3,2]]\nOutput: [[3,0,0],[0,0,1],[0,2,0]]\nExplanation: The diagram above shows a valid example of a matrix that satisfies all the conditions.\nThe row conditions are the following:\n- Number 1 is in row 1, and number 2 is in row 2, so 1 is above 2 in the matrix.\n- Number 3 is in row 0, and number 2 is in row 2, so 3 is above 2 in the matrix.\nThe column conditions are the following:\n- Number 2 is in column 1, and number 1 is in column 2, so 2 is left of 1 in the matrix.\n- Number 3 is in column 0, and number 2 is in column 1, so 3 is left of 2 in the matrix.\nNote that there may be multiple correct answers.\n\nExample 2:\n\nInput: k = 3, rowConditions = [[1,2],[2,3],[3,1],[2,3]], colConditions = [[2,1]]\nOutput: []\nExplanation: From the first two conditions, 3 has to be below 1 but the third conditions needs 3 to be above 1 to be satisfied.\nNo matrix can satisfy all the conditions, so we return the empty matrix.\n\n&nbsp;\nConstraints:\n\n\t2 <= k <= 400\n\t1 <= rowConditions.length, colConditions.length <= 104\n\trowConditions[i].length == colConditions[i].length == 2\n\t1 <= abovei, belowi, lefti, righti <= k\n\tabovei != belowi\n\tlefti != righti",
        "solutions": [
            {
                "id": 2492728,
                "title": "c-with-explanation-simple-topological-sort-implementation",
                "content": "**Overview**\\nThis problem was a standard **Topological Sort** problem. THANKYOU Leetcode for covering such concept after a long time! \\n\\n**How I figured it out as Topological Sort?**\\n* Ordering of numbers were required column wise and row wise.\\n* Ordering were given in pairs `a -> b`, which means `a` should come before `b`. Looks like Directed Graph.\\n\\n**Pre-requisite:**\\n* Knowledge of Topological Sort in Directed Acyclic Graph (DAG).\\n* The resources I used were:\\n\\t* \\t[First Video](https://www.youtube.com/watch?v=qQvylVxCgB4&list=PL5DyztRVgtRVLwNWS7Rpp4qzVVHJalt22&index=26)\\n\\t* \\t[Second Video](https://www.youtube.com/watch?v=eJEpWBieUy4&list=PL5DyztRVgtRVLwNWS7Rpp4qzVVHJalt22&index=27)\\n\\t* \\tThe above video is from [CodeNCode](https://www.youtube.com/channel/UCrR5BJxc1vZ0fmn0MOpuXQQ) Youtube Channel. You can look out his channel for the legendary Graph series (The best I could find).\\n\\t\\n**Algorithm**\\n1. Form Directed Graphs out of the orderings in `rowConditions` and `colConditions`\\n2. Check these graphs for Acyclicity.  If any of the graphs is cyclic, ordering is not possible. Hence, return `[]`.\\n3. Now, we are confirmed that the graphs are DAG. Form topological sorts for the  `rowConditions` and `colConditions`\\n4. Let the topological sort from `rowConditions` be `rowSort` and that from `colConditions` be `colSort`.\\n5. `rowSort` will determine the position of the element row-wise. \\n6. `colSort` will determine the position of the element col-wise. \\n\\n**Code**\\n```\\nclass Solution {\\n    \\n    /* 1. Checking if cycle is present - If YES, Topological Sort is not possible */\\n    vector<char> color;\\n    bool dfs(int v, vector<vector<int>>& graph) {\\n        color[v] = 1;\\n        for (int u : graph[v]) {\\n            if (color[u] == 0) {\\n                if (dfs(u, graph))\\n                    return true;\\n            } else if (color[u] == 1) {\\n                return true;\\n            }\\n        }\\n        color[v] = 2;\\n        return false;\\n    }\\n    bool find_cycle(vector<vector<int>>& graph, int n) {\\n        color.assign(n, 0);\\n\\n        for (int v = 0; v < n; v++) {\\n            if (color[v] == 0 && dfs(v, graph))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    /* 2. Forming the Topological Sort for DAG */\\n    vector<bool> visited;\\n    void dfs2(int v, vector<vector<int>>& graph, vector<int>& ans) {\\n        visited[v] = true;\\n        for (int u : graph[v]) {\\n            if (!visited[u])\\n                dfs2(u, graph, ans);\\n        }\\n        ans.push_back(v);\\n    }\\n\\n    void topological_sort(vector<vector<int>>& graph, int n, vector<int>& ans) {\\n        visited.assign(n, false);\\n        ans.clear();\\n        for (int i = 0; i < n; ++i) {\\n            if (!visited[i])\\n                dfs2(i, graph, ans);\\n        }\\n        reverse(ans.begin(), ans.end());\\n    }\\n    \\npublic:\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        vector<vector<int>> graph1(k);\\n        vector<vector<int>> graph2(k);\\n        \\n        for(auto x:rowConditions) {\\n            graph1[x[0] - 1].push_back(x[1] - 1);\\n        }\\n        for(auto x:colConditions) {\\n            graph2[x[0] - 1].push_back(x[1] - 1);\\n        }\\n        \\n        /* 3. Check if CYCLE present in any of the graphs */\\n        if(find_cycle(graph1, k) || find_cycle(graph2, k)) return vector<vector<int>>();\\n        \\n        /* 4. Forming Topological Sort for the DAGs */\\n        vector<int> ans1; vector<int> ans2;\\n        \\n        topological_sort(graph1, k, ans1);\\n        topological_sort(graph2, k, ans2);\\n        \\n        /* 5. Forming the answer from the rowPosition and colPosition for each element */\\n        vector<vector<int>> ans(k, vector<int>(k));\\n        \\n        map<int, int> m;\\n        for(int i = 0; i < k; i++) {\\n            m[ans2[i]] = i;\\n        }\\n        \\n        for(int i = 0; i < k; i++) {\\n            ans[i][m[ans1[i]]] = ans1[i] + 1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n**Comments:**\\n1. For faster implementation, I used the codes available from https://cp-algorithms.com/\\n2. Codes are as follows: [Checking cycle in Directed Graph](https://cp-algorithms.com/graph/finding-cycle.html) and [Topological Sort](https://cp-algorithms.com/graph/topological-sort.html)",
                "solutionTags": [
                    "C",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    \\n    /* 1. Checking if cycle is present - If YES, Topological Sort is not possible */\\n    vector<char> color;\\n    bool dfs(int v, vector<vector<int>>& graph) {\\n        color[v] = 1;\\n        for (int u : graph[v]) {\\n            if (color[u] == 0) {\\n                if (dfs(u, graph))\\n                    return true;\\n            } else if (color[u] == 1) {\\n                return true;\\n            }\\n        }\\n        color[v] = 2;\\n        return false;\\n    }\\n    bool find_cycle(vector<vector<int>>& graph, int n) {\\n        color.assign(n, 0);\\n\\n        for (int v = 0; v < n; v++) {\\n            if (color[v] == 0 && dfs(v, graph))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    /* 2. Forming the Topological Sort for DAG */\\n    vector<bool> visited;\\n    void dfs2(int v, vector<vector<int>>& graph, vector<int>& ans) {\\n        visited[v] = true;\\n        for (int u : graph[v]) {\\n            if (!visited[u])\\n                dfs2(u, graph, ans);\\n        }\\n        ans.push_back(v);\\n    }\\n\\n    void topological_sort(vector<vector<int>>& graph, int n, vector<int>& ans) {\\n        visited.assign(n, false);\\n        ans.clear();\\n        for (int i = 0; i < n; ++i) {\\n            if (!visited[i])\\n                dfs2(i, graph, ans);\\n        }\\n        reverse(ans.begin(), ans.end());\\n    }\\n    \\npublic:\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        vector<vector<int>> graph1(k);\\n        vector<vector<int>> graph2(k);\\n        \\n        for(auto x:rowConditions) {\\n            graph1[x[0] - 1].push_back(x[1] - 1);\\n        }\\n        for(auto x:colConditions) {\\n            graph2[x[0] - 1].push_back(x[1] - 1);\\n        }\\n        \\n        /* 3. Check if CYCLE present in any of the graphs */\\n        if(find_cycle(graph1, k) || find_cycle(graph2, k)) return vector<vector<int>>();\\n        \\n        /* 4. Forming Topological Sort for the DAGs */\\n        vector<int> ans1; vector<int> ans2;\\n        \\n        topological_sort(graph1, k, ans1);\\n        topological_sort(graph2, k, ans2);\\n        \\n        /* 5. Forming the answer from the rowPosition and colPosition for each element */\\n        vector<vector<int>> ans(k, vector<int>(k));\\n        \\n        map<int, int> m;\\n        for(int i = 0; i < k; i++) {\\n            m[ans2[i]] = i;\\n        }\\n        \\n        for(int i = 0; i < k; i++) {\\n            ans[i][m[ans1[i]]] = ans1[i] + 1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2492865,
                "title": "kahn-s-algo-topological-sort-bfs-c-short-and-easy-to-understand-code",
                "content": "```\\nvector<int> khansAlgo(vector<vector<int>> &r, int k){\\n        vector<int> cnt(k+1, 0);\\n        vector<int> adj[k+1];\\n        for(auto x:r){\\n            cnt[x[1]]++;\\n            adj[x[0]].push_back(x[1]);\\n        }\\n        vector<int> row;\\n        queue<int> q;\\n        for(int i=1;i<=k;i++){\\n            if(cnt[i]==0){\\n                q.push(i);\\n            }\\n        }\\n        while(!q.empty()){\\n            int t = q.front();\\n            q.pop();\\n            row.push_back(t);\\n            for(auto x:adj[t]){\\n                cnt[x]--;\\n                if(cnt[x]==0){\\n                    q.push(x);\\n                }\\n            }\\n        }\\n        return row;\\n    }\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& r, vector<vector<int>>& c) {\\n        vector<vector<int>> res(k, vector<int>(k, 0));\\n        \\n        vector<int> row = khansAlgo(r, k);\\n        if(row.size()!=k) return {};\\n        \\n        vector<int> col = khansAlgo(c, k);\\n        if(col.size()!=k) return {};\\n        \\n        vector<int> idx(k+1,0);\\n        for(int j=0;j<col.size();j++){\\n            idx[col[j]] = j;\\n        }\\n        for(int i=0;i<k;i++){\\n            res[i][idx[row[i]]] = row[i];\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nvector<int> khansAlgo(vector<vector<int>> &r, int k){\\n        vector<int> cnt(k+1, 0);\\n        vector<int> adj[k+1];\\n        for(auto x:r){\\n            cnt[x[1]]++;\\n            adj[x[0]].push_back(x[1]);\\n        }\\n        vector<int> row;\\n        queue<int> q;\\n        for(int i=1;i<=k;i++){\\n            if(cnt[i]==0){\\n                q.push(i);\\n            }\\n        }\\n        while(!q.empty()){\\n            int t = q.front();\\n            q.pop();\\n            row.push_back(t);\\n            for(auto x:adj[t]){\\n                cnt[x]--;\\n                if(cnt[x]==0){\\n                    q.push(x);\\n                }\\n            }\\n        }\\n        return row;\\n    }\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& r, vector<vector<int>>& c) {\\n        vector<vector<int>> res(k, vector<int>(k, 0));\\n        \\n        vector<int> row = khansAlgo(r, k);\\n        if(row.size()!=k) return {};\\n        \\n        vector<int> col = khansAlgo(c, k);\\n        if(col.size()!=k) return {};\\n        \\n        vector<int> idx(k+1,0);\\n        for(int j=0;j<col.size();j++){\\n            idx[col[j]] = j;\\n        }\\n        for(int i=0;i<k;i++){\\n            res[i][idx[row[i]]] = row[i];\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2492947,
                "title": "python-3-explanation-with-pictures-topological-sort",
                "content": "> Detect if a circle exists in DAG\\n\\nHere is the BFS solution: start with dequeue of nodes with 0 indegree, update the indegree and add those nodes with 0 indegree to dequeue. Once we are done, the sequence by which we pop the nodes are **one** workable order. \\n\\n![image](https://assets.leetcode.com/users/images/ff809462-2a9c-4919-857c-a21e67bc3843_1661659335.123167.png)\\n\\n![image](https://assets.leetcode.com/users/images/8abc7101-06c5-437c-8fb7-50fd7c5a0ffc_1661659339.089174.png)\\n\\n![image](https://assets.leetcode.com/users/images/51869dd3-39c5-4576-9a34-70f5f8c8edcf_1661659342.2771084.png)\\n\\n> If there exists a circle, the nodes on circle will never be visited. Thus we end up with a sequence shorter than the total number of nodes.\\n\\n![image](https://assets.leetcode.com/users/images/aad489c2-73ee-4f8c-8b50-273f6b75c057_1661659345.178224.png)\\n\\nOnce we find a proper order for both the rows and cols, just add the number back to an empty matrix accordingly.\\n\\n\\n**python**\\n\\n```\\ndef buildMatrix(self, k: int, R: List[List[int]], C: List[List[int]]) -> List[List[int]]:\\n        def helper(A):\\n            nxt, indegree = [set() for _ in range(k)], [0] * k\\n            dq, ans = collections.deque(), []\\n            A = set([tuple(a) for a in A])  \\n            for i, j in A:\\n                nxt[i - 1].add(j - 1)\\n                indegree[j - 1] += 1\\n            for i in range(k):\\n                if indegree[i] == 0:\\n                    dq.append(i)   \\n            while dq:\\n                cur = dq.popleft()\\n                ans.append(cur)\\n                for cand in nxt[cur]:\\n                    indegree[cand] -= 1\\n                    if indegree[cand] == 0:\\n                        dq.append(cand)       \\n            return ans if len(ans) == k else []\\n        \\n        ans1, ans2 = helper(R), helper(C)\\n        if not ans1 or not ans2: \\n            return []\\n\\n        A = [[0] * k for _ in range(k)]\\n        for i in range(k): \\n            A[ans1.index(i)][ans2.index(i)] = i + 1\\n        return A\\n```",
                "solutionTags": [],
                "code": "```\\ndef buildMatrix(self, k: int, R: List[List[int]], C: List[List[int]]) -> List[List[int]]:\\n        def helper(A):\\n            nxt, indegree = [set() for _ in range(k)], [0] * k\\n            dq, ans = collections.deque(), []\\n            A = set([tuple(a) for a in A])  \\n            for i, j in A:\\n                nxt[i - 1].add(j - 1)\\n                indegree[j - 1] += 1\\n            for i in range(k):\\n                if indegree[i] == 0:\\n                    dq.append(i)   \\n            while dq:\\n                cur = dq.popleft()\\n                ans.append(cur)\\n                for cand in nxt[cur]:\\n                    indegree[cand] -= 1\\n                    if indegree[cand] == 0:\\n                        dq.append(cand)       \\n            return ans if len(ans) == k else []\\n        \\n        ans1, ans2 = helper(R), helper(C)\\n        if not ans1 or not ans2: \\n            return []\\n\\n        A = [[0] * k for _ in range(k)]\\n        for i in range(k): \\n            A[ans1.index(i)][ans2.index(i)] = i + 1\\n        return A\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2492762,
                "title": "c-python-java-topological-sort",
                "content": "Topological ordering of a directed graph is a linear ordering of its vertices such that for every directed edge uv from vertex u to vertex v, u comes before v in the ordering.\\n\\nTopological sort steps:\\n* Find a vertex that has indegree = 0 (no incoming edges)\\n* Add that vertex to the array representing topological sorting of the graph\\n* Since we have reached this node decrease the indegree of all the nodes that are supposed to come after this node\\n* Repeat till there are no more vertices left.\\n\\n<iframe src=\"https://leetcode.com/playground/audDyjEZ/shared\" frameBorder=\"0\" width=\"900\" height=\"600\"></iframe>",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Topological Sort"
                ],
                "code": "Topological ordering of a directed graph is a linear ordering of its vertices such that for every directed edge uv from vertex u to vertex v, u comes before v in the ordering.\\n\\nTopological sort steps:\\n* Find a vertex that has indegree = 0 (no incoming edges)\\n* Add that vertex to the array representing topological sorting of the graph\\n* Since we have reached this node decrease the indegree of all the nodes that are supposed to come after this node\\n* Repeat till there are no more vertices left.\\n\\n<iframe src=\"https://leetcode.com/playground/audDyjEZ/shared\" frameBorder=\"0\" width=\"900\" height=\"600\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 2492754,
                "title": "topological-sort",
                "content": "We apply topological sort independently for both conditions. \\n\\nAs a refresher, we build a directed graph with `k` nodes, and each condition is a directed link between the corresponding nodes.\\n\\n> We represent the graph with the adjacency list (`al`). Note that we use a set to hold linked nodes as we may have duplicated conditions in the input.\\n\\nWe also track the number of conditions for each note in the `pre` array.\\n\\nTo get the sorted sequence, we do BFS starting from nodes with zero conditions.\\n\\nFor each node in the BFS queue `q`, we add it to the sequence, and then decrease the number of conditions for all connected notes. If the number of conditions for some node becomes zero, we add it to the BFS queue.\\n\\nIf there is a cycle, the topological sort would not produce all `k` elements.\\n\\nAfter we have an order of elements, we use it to sort indexes [0..k-1] to figure out where each element goes into the matrix.\\n\\n**C++**\\n```cpp\\nvector<int> top_sort(int k, vector<vector<int>>& conditions) {\\n    vector<int> sorted, id(k), pre(k + 1), q;\\n    vector<unordered_set<int>> al(k + 1);\\n    for (auto &c : conditions)\\n        if(al[c[0]].insert(c[1]).second)\\n            ++pre[c[1]];\\n    for (auto i = 1; i <= k; ++i)\\n        if (pre[i] == 0)\\n            q.push_back(i);\\n    while (!q.empty()) {\\n        vector<int> q1;\\n        for (auto i : q) {\\n            sorted.push_back(i);\\n            for (auto j : al[i])\\n                if (--pre[j] == 0)\\n                    q1.push_back(j);\\n        }\\n        swap(q, q1);\\n    }\\n    if (sorted.size() != k)\\n        return {};\\n    iota(begin(id), end(id), 0);\\n    sort(begin(id), end(id), [&](int a, int b){ return sorted[a] < sorted[b]; });    \\n    return id;\\n}\\nvector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n    auto rid = top_sort(k, rowConditions), cid = top_sort(k, colConditions);\\n    if (rid.empty() || cid.empty())\\n        return {};\\n    vector<vector<int>> res(k, vector<int>(k));    \\n    for (int i = 1; i <= k; ++i)\\n        res[rid[i - 1]][cid[i - 1]] = i;\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nvector<int> top_sort(int k, vector<vector<int>>& conditions) {\\n    vector<int> sorted, id(k), pre(k + 1), q;\\n    vector<unordered_set<int>> al(k + 1);\\n    for (auto &c : conditions)\\n        if(al[c[0]].insert(c[1]).second)\\n            ++pre[c[1]];\\n    for (auto i = 1; i <= k; ++i)\\n        if (pre[i] == 0)\\n            q.push_back(i);\\n    while (!q.empty()) {\\n        vector<int> q1;\\n        for (auto i : q) {\\n            sorted.push_back(i);\\n            for (auto j : al[i])\\n                if (--pre[j] == 0)\\n                    q1.push_back(j);\\n        }\\n        swap(q, q1);\\n    }\\n    if (sorted.size() != k)\\n        return {};\\n    iota(begin(id), end(id), 0);\\n    sort(begin(id), end(id), [&](int a, int b){ return sorted[a] < sorted[b]; });    \\n    return id;\\n}\\nvector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n    auto rid = top_sort(k, rowConditions), cid = top_sort(k, colConditions);\\n    if (rid.empty() || cid.empty())\\n        return {};\\n    vector<vector<int>> res(k, vector<int>(k));    \\n    for (int i = 1; i <= k; ++i)\\n        res[rid[i - 1]][cid[i - 1]] = i;\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2492803,
                "title": "c-topological-sort",
                "content": "* Perform **topological sort** on rowConditions & colConditions\\n* The index of element in topological sort of rowConditions will be the rowIndex. Similarly, for the index of element in topological sort of colConditions will the colIndex of the element in the result grid\\n* Time complexity of Topological sort is ```O(V + E)```, where V = No. of vertices = k and E = No. of Edges which can be atmost ```k * (k - 1) / 2```  \\n* So, Time complexity: ```O(k ^ 2)``` | Space complexity: ```O(k ^ 2)```\\n(Initialising the 2D vector also takes ```k ^ 2``` time complexity)\\n\\n![image](https://assets.leetcode.com/users/images/df9b108f-3f00-4484-b7f7-8e2ff758dfb2_1661658583.621787.png)\\n\\n```\\nclass Solution {\\npublic:\\n    // Same Code as Course Schedule - 2 \\n    vector<int> findOrder(int k, vector<vector<int>>& dependencies) {\\n                \\n        vector<vector<int>> adj(k + 1);\\n        vector<int> indegree(k + 1);\\n        for(auto dependency: dependencies) {\\n            adj[dependency[0]].push_back(dependency[1]);\\n            indegree[dependency[1]]++;\\n        }\\n        \\n        queue<int> q;\\n        for(int i = 1; i <= k; i++) {\\n            if(indegree[i] == 0) {\\n                q.push(i);\\n            }\\n        }\\n        \\n        int cnt = 0;\\n        vector<int> order;\\n        while(!q.empty()) {\\n            \\n            int cur = q.front();\\n            q.pop();\\n            \\n            cnt++;\\n            order.push_back(cur);\\n            \\n            for(int nbr: adj[cur]) {\\n                indegree[nbr]--;\\n                \\n                if(indegree[nbr] == 0) {\\n                    q.push(nbr);\\n                }\\n            }\\n        }\\n        \\n        if(cnt == k) return order;\\n        return {};\\n    }\\n    \\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        vector<int> rowArray = findOrder(k, rowConditions);  \\n        vector<int> colArray = findOrder(k, colConditions);\\n        \\n        // If one of the row conditions or col conditions has a cycle\\n        if(rowArray.size() == 0 || colArray.size() == 0) {\\n            return {};\\n        }\\n        \\n        vector<pair<int, int>> ind(k);   // list of indices (i, j) for k values\\n\\t\\t// from topological ordering deriving the indices for the values\\n        for(int i = 0; i < k; i++) {\\n            ind[rowArray[i] - 1].first = i;  \\n            ind[colArray[i] - 1].second = i;\\n        }\\n        \\n        vector<vector<int>> result(k, vector<int>(k, 0));\\n\\t\\t// iterate over the values and place then in the result grid\\n        for(int i = 0; i < k; i++) {\\n            result[ind[i].first][ind[i].second] = i + 1;\\n        }\\n        return result;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Topological Sort"
                ],
                "code": "```O(V + E)```\n```k * (k - 1) / 2```\n```O(k ^ 2)```\n```O(k ^ 2)```\n```k ^ 2```\n```\\nclass Solution {\\npublic:\\n    // Same Code as Course Schedule - 2 \\n    vector<int> findOrder(int k, vector<vector<int>>& dependencies) {\\n                \\n        vector<vector<int>> adj(k + 1);\\n        vector<int> indegree(k + 1);\\n        for(auto dependency: dependencies) {\\n            adj[dependency[0]].push_back(dependency[1]);\\n            indegree[dependency[1]]++;\\n        }\\n        \\n        queue<int> q;\\n        for(int i = 1; i <= k; i++) {\\n            if(indegree[i] == 0) {\\n                q.push(i);\\n            }\\n        }\\n        \\n        int cnt = 0;\\n        vector<int> order;\\n        while(!q.empty()) {\\n            \\n            int cur = q.front();\\n            q.pop();\\n            \\n            cnt++;\\n            order.push_back(cur);\\n            \\n            for(int nbr: adj[cur]) {\\n                indegree[nbr]--;\\n                \\n                if(indegree[nbr] == 0) {\\n                    q.push(nbr);\\n                }\\n            }\\n        }\\n        \\n        if(cnt == k) return order;\\n        return {};\\n    }\\n    \\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        vector<int> rowArray = findOrder(k, rowConditions);  \\n        vector<int> colArray = findOrder(k, colConditions);\\n        \\n        // If one of the row conditions or col conditions has a cycle\\n        if(rowArray.size() == 0 || colArray.size() == 0) {\\n            return {};\\n        }\\n        \\n        vector<pair<int, int>> ind(k);   // list of indices (i, j) for k values\\n\\t\\t// from topological ordering deriving the indices for the values\\n        for(int i = 0; i < k; i++) {\\n            ind[rowArray[i] - 1].first = i;  \\n            ind[colArray[i] - 1].second = i;\\n        }\\n        \\n        vector<vector<int>> result(k, vector<int>(k, 0));\\n\\t\\t// iterate over the values and place then in the result grid\\n        for(int i = 0; i < k; i++) {\\n            result[ind[i].first][ind[i].second] = i + 1;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2492822,
                "title": "python3-topological-sort",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/ea6bc01b091cbf032b9c7ac2d3c09cb4f5cd0d2d) for solutions of weekly 308. \\n\\n**Intuition**\\nThe workhorse of this problem is topological sort. The orders in `aboveConditions` and `leftConditions` construct two graphs. Via topological sort, the order becomes apparent. \\nSo the algo is summarized below:\\n1) topological sort the two graphs to get the row orders and column orders; \\n2) if no cycle is found in either row order or column order, an answer exists; otherwise, return empty matrix; \\n3) for each number from 1 to k, find its row number and column number from the results of the sorting; \\n4) fill the numbers into the matrix. \\n\\n**Analysis**\\nTime complexity `O(K^2)`\\nSpace complexity `O(K^2)`\\n\\n```\\nclass Solution:\\n    def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:\\n        \\n        def fn(cond): \\n            \"\"\"Return topological sort\"\"\"\\n            graph = [[] for _ in range(k)]\\n            indeg = [0]*k\\n            for u, v in cond: \\n                graph[u-1].append(v-1)\\n                indeg[v-1] += 1\\n            queue = deque(u for u, x in enumerate(indeg) if x == 0)\\n            ans = []\\n            while queue: \\n                u = queue.popleft()\\n                ans.append(u+1)\\n                for v in graph[u]: \\n                    indeg[v] -= 1\\n                    if indeg[v] == 0: queue.append(v)\\n            return ans \\n        \\n        row = fn(rowConditions)\\n        col = fn(colConditions)\\n        \\n        if len(row) < k or len(col) < k: return []\\n        ans = [[0]*k for _ in range(k)]\\n        row = {x : i for i, x in enumerate(row)}\\n        col = {x : j for j, x in enumerate(col)}\\n        for x in range(1, k+1): ans[row[x]][col[x]] = x\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:\\n        \\n        def fn(cond): \\n            \"\"\"Return topological sort\"\"\"\\n            graph = [[] for _ in range(k)]\\n            indeg = [0]*k\\n            for u, v in cond: \\n                graph[u-1].append(v-1)\\n                indeg[v-1] += 1\\n            queue = deque(u for u, x in enumerate(indeg) if x == 0)\\n            ans = []\\n            while queue: \\n                u = queue.popleft()\\n                ans.append(u+1)\\n                for v in graph[u]: \\n                    indeg[v] -= 1\\n                    if indeg[v] == 0: queue.append(v)\\n            return ans \\n        \\n        row = fn(rowConditions)\\n        col = fn(colConditions)\\n        \\n        if len(row) < k or len(col) < k: return []\\n        ans = [[0]*k for _ in range(k)]\\n        row = {x : i for i, x in enumerate(row)}\\n        col = {x : j for j, x in enumerate(col)}\\n        for x in range(1, k+1): ans[row[x]][col[x]] = x\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2506399,
                "title": "simple-and-easy-c-kahn-s-algorithm-topological-sort-bfs-oops",
                "content": "**Algorithm**\\n1. Create graph for both ```rowConditions``` and ```colConditions```.\\n2. Check if both graphs are acyclic using Kahn\\'s Algorithm. If either graph is cyclic, then return ```[]```.\\n3. Kahn\\'s Algorithm will give ```topological sorting (topo1 and topo2) ``` for both graphs.\\n4. ```topo1``` will give position of element according to row.\\n5. ```topo2``` will give position of element according to column.\\n\\n**Code**\\n```\\nclass graph{\\n    int n;\\n    vector<vector<int>> adj;\\npublic:\\n    graph(int n){\\n        this->n = n;\\n        adj.resize(n);\\n    }\\n    \\n    void add_edge(int u, int v){\\n        adj[u].push_back(v);\\n    }\\n    \\n    void make_adj(vector<vector<int>> arr){\\n        for(auto& x:arr){\\n            this->add_edge(x[0], x[1]);\\n        }\\n    }\\n    \\n    vector<int> kahn_algo(){\\n        vector<int> indeg(this->n, 0);\\n        queue<int> q;\\n        vector<int> topo;\\n        \\n        for(auto &x : this->adj){\\n            for(int &y: x){\\n                indeg[y]++;\\n            } \\n        }\\n\\n        for(int i=1; i<this->n; i++){\\n            if(indeg[i] == 0){\\n                q.push(i);\\n            }\\n        }\\n\\n        while(!q.empty()){\\n            int cur = q.front();\\n            q.pop();\\n\\n            topo.push_back(cur);\\n            \\n            for(auto& x : this->adj[cur]){\\n                indeg[x]--;\\n                if(indeg[x] == 0){\\n                    q.push(x);\\n                }\\n            }\\n        }\\n\\n        return topo;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> solve(int& n, vector<int>& topo1, vector<int>& topo2){\\n        if(topo1.size() != n || topo2.size() != n){\\n            return {};\\n        }\\n        \\n        vector<vector<int>> ans(n, vector<int>(n, 0));\\n\\n        unordered_map<int, int> mp;\\n        \\n        for(int i=0; i<topo1.size(); i++){\\n            mp[topo1[i]] = i;\\n        }\\n        \\n        for(int i=0; i<topo2.size(); i++){\\n            ans[mp[topo2[i]]][i] = topo2[i];\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    vector<vector<int>> buildMatrix(int n, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        \\n        graph g1(n+1), g2(n+1);\\n        \\n        g1.make_adj(rowConditions);\\n        g2.make_adj(colConditions);\\n                \\n        vector<int> topo1 = g1.kahn_algo(), topo2 = g2.kahn_algo();\\n        \\n        return solve(n, topo1, topo2);        \\n    }\\n};\\n```\\n\\nPlease upvote if you find it helpful :)",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```rowConditions```\n```colConditions```\n```[]```\n```topological sorting (topo1 and topo2) ```\n```topo1```\n```topo2```\n```\\nclass graph{\\n    int n;\\n    vector<vector<int>> adj;\\npublic:\\n    graph(int n){\\n        this->n = n;\\n        adj.resize(n);\\n    }\\n    \\n    void add_edge(int u, int v){\\n        adj[u].push_back(v);\\n    }\\n    \\n    void make_adj(vector<vector<int>> arr){\\n        for(auto& x:arr){\\n            this->add_edge(x[0], x[1]);\\n        }\\n    }\\n    \\n    vector<int> kahn_algo(){\\n        vector<int> indeg(this->n, 0);\\n        queue<int> q;\\n        vector<int> topo;\\n        \\n        for(auto &x : this->adj){\\n            for(int &y: x){\\n                indeg[y]++;\\n            } \\n        }\\n\\n        for(int i=1; i<this->n; i++){\\n            if(indeg[i] == 0){\\n                q.push(i);\\n            }\\n        }\\n\\n        while(!q.empty()){\\n            int cur = q.front();\\n            q.pop();\\n\\n            topo.push_back(cur);\\n            \\n            for(auto& x : this->adj[cur]){\\n                indeg[x]--;\\n                if(indeg[x] == 0){\\n                    q.push(x);\\n                }\\n            }\\n        }\\n\\n        return topo;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> solve(int& n, vector<int>& topo1, vector<int>& topo2){\\n        if(topo1.size() != n || topo2.size() != n){\\n            return {};\\n        }\\n        \\n        vector<vector<int>> ans(n, vector<int>(n, 0));\\n\\n        unordered_map<int, int> mp;\\n        \\n        for(int i=0; i<topo1.size(); i++){\\n            mp[topo1[i]] = i;\\n        }\\n        \\n        for(int i=0; i<topo2.size(); i++){\\n            ans[mp[topo2[i]]][i] = topo2[i];\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    vector<vector<int>> buildMatrix(int n, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        \\n        graph g1(n+1), g2(n+1);\\n        \\n        g1.make_adj(rowConditions);\\n        g2.make_adj(colConditions);\\n                \\n        vector<int> topo1 = g1.kahn_algo(), topo2 = g2.kahn_algo();\\n        \\n        return solve(n, topo1, topo2);        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2492931,
                "title": "topological-sort-cycle-detection-using-dfs-java-18ms-100",
                "content": "```\\nclass Solution {\\n    public int[][] buildMatrix(int k, int[][] rowConditions, int[][] colConditions) {\\n        \\n        int[][] ans = new int[k][k];\\n        \\n        // create adjacency List for the rows and columns\\n        Map<Integer, Set<Integer>> adjListRow = new HashMap<>();\\n        Map<Integer, Set<Integer>> adjListCol = new HashMap<>();\\n        for(int[] row : rowConditions){\\n            adjListRow.putIfAbsent(row[0], new HashSet<>());\\n            adjListRow.get(row[0]).add(row[1]);\\n        }\\n        for(int[] col : colConditions){\\n            adjListCol.putIfAbsent(col[0], new HashSet<>());\\n            adjListCol.get(col[0]).add(col[1]);\\n        }\\n        \\n        // run DFS with cycle detection while storing the finish order of the nodes\\n        Map<Integer, Integer> rowIndex = new HashMap<>();\\n        Map<Integer, Integer> colIndex = new HashMap<>();\\n        int[] visitedRow = new int[k+1];\\n        int[] visitedCol = new int[k+1];\\n        for(int i = 1; i <= k; i++){\\n            if(!(dfs(i, adjListRow, visitedRow, rowIndex) && dfs(i, adjListCol, visitedCol, colIndex)))\\n               return new int[0][0];\\n        }\\n       \\n\\t   // assign the correct position to the nodes according to the finish order\\n        for( int i = 1; i <= k; i++){\\n            int r = rowIndex.size() - rowIndex.get(i) - 1;\\n            int c = colIndex.size() - colIndex.get(i) - 1;\\n            ans[r][c] = i;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n\\t/** DFS with cycle detection (returns false in case of a cycle) \\n\\tState of a node can be one of the following\\n\\t\\t0 -> unvisited\\n\\t\\t1 -> visiting\\n\\t\\t2 -> visited\\n    On the DFS path visiting a node with value 1 means we are visiting a node on the path we came from -> hence it is a cycle(DFS returns false). When a visited node is encountered, we can return back to the caller node.\\n\\t*/\\n    private boolean dfs(int node, Map<Integer, Set<Integer>> adjList, int[] visited, Map<Integer, Integer>  map){\\n\\t \\n        if(visited[node] == 2) return true;\\n        if(visited[node] == 1) return false;\\n        visited[node] = 1;\\n\\t\\t\\n        Set<Integer> list = adjList.get(node);\\n        if(list != null)\\n            for(int ele : list)\\n                if(visited[ele] != 2)\\n                    if(!dfs(ele, adjList, visited, map)) return false;\\n                \\n\\t\\t// mark the node visited and add to the map of finished nodes with the finish number\\n        visited[node] = 2;\\n        map.put(node, map.size());\\n        return true;\\n    } \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] buildMatrix(int k, int[][] rowConditions, int[][] colConditions) {\\n        \\n        int[][] ans = new int[k][k];\\n        \\n        // create adjacency List for the rows and columns\\n        Map<Integer, Set<Integer>> adjListRow = new HashMap<>();\\n        Map<Integer, Set<Integer>> adjListCol = new HashMap<>();\\n        for(int[] row : rowConditions){\\n            adjListRow.putIfAbsent(row[0], new HashSet<>());\\n            adjListRow.get(row[0]).add(row[1]);\\n        }\\n        for(int[] col : colConditions){\\n            adjListCol.putIfAbsent(col[0], new HashSet<>());\\n            adjListCol.get(col[0]).add(col[1]);\\n        }\\n        \\n        // run DFS with cycle detection while storing the finish order of the nodes\\n        Map<Integer, Integer> rowIndex = new HashMap<>();\\n        Map<Integer, Integer> colIndex = new HashMap<>();\\n        int[] visitedRow = new int[k+1];\\n        int[] visitedCol = new int[k+1];\\n        for(int i = 1; i <= k; i++){\\n            if(!(dfs(i, adjListRow, visitedRow, rowIndex) && dfs(i, adjListCol, visitedCol, colIndex)))\\n               return new int[0][0];\\n        }\\n       \\n\\t   // assign the correct position to the nodes according to the finish order\\n        for( int i = 1; i <= k; i++){\\n            int r = rowIndex.size() - rowIndex.get(i) - 1;\\n            int c = colIndex.size() - colIndex.get(i) - 1;\\n            ans[r][c] = i;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n\\t/** DFS with cycle detection (returns false in case of a cycle) \\n\\tState of a node can be one of the following\\n\\t\\t0 -> unvisited\\n\\t\\t1 -> visiting\\n\\t\\t2 -> visited\\n    On the DFS path visiting a node with value 1 means we are visiting a node on the path we came from -> hence it is a cycle(DFS returns false). When a visited node is encountered, we can return back to the caller node.\\n\\t*/\\n    private boolean dfs(int node, Map<Integer, Set<Integer>> adjList, int[] visited, Map<Integer, Integer>  map){\\n\\t \\n        if(visited[node] == 2) return true;\\n        if(visited[node] == 1) return false;\\n        visited[node] = 1;\\n\\t\\t\\n        Set<Integer> list = adjList.get(node);\\n        if(list != null)\\n            for(int ele : list)\\n                if(visited[ele] != 2)\\n                    if(!dfs(ele, adjList, visited, map)) return false;\\n                \\n\\t\\t// mark the node visited and add to the map of finished nodes with the finish number\\n        visited[node] = 2;\\n        map.put(node, map.size());\\n        return true;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3301781,
                "title": "simple-and-clean-c-solution-using-kahn-s-algorithm",
                "content": "# Intuition\\nSimple idea behind the solution is if we take projections of non zero elements of matrix along the row and column , those projected rows and colums should be topologically sorted. \\nSo we will first find valid orders of row and columns. seperately and then we will form the matrix. \\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> validorder(vector<vector<int>> &conditions, int k){\\n        vector<int> indegree(k+1, 0);\\n        vector<vector<int>> adj(k+1);\\n        // we will first create an adj list\\n        for(int i = 0 ; i< conditions.size(); i++){\\n            int a = conditions[i][0];\\n            int b = conditions[i][1];\\n            indegree[b]++;\\n            adj[a].push_back(b);\\n        }\\n        //Kahn\\'s algo\\n        vector<int> order;\\n        queue<int> q;\\n        for(int i=1;i<=k;i++){\\n            if(indegree[i]==0){\\n                q.push(i);\\n            }\\n        }\\n        while(!q.empty()){\\n            int node = q.front();\\n            q.pop();\\n            order.push_back(node);\\n            for(int i = 0 ; i<adj[node].size(); i++){\\n                int x=adj[node][i];\\n                indegree[x]--;\\n                if(indegree[x]==0){\\n                    q.push(x);\\n                }\\n            }\\n        }\\n        return order;\\n    }\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        vector<int> validcol = validorder(rowConditions, k);\\n        vector<int> validrow = validorder(colConditions, k);\\n\\n        if(validcol.size()!=k||validrow.size()!=k) return {};\\n\\n        vector<vector<int>> validmatrix(k, vector<int>(k, 0));\\n        for(int i = 0;i<k;i++){\\n            for(int j = 0 ; j<k ; j++){\\n                if(validcol[i]==validrow[j]){\\n                    validmatrix[i][j]=validcol[i];\\n                }\\n            }\\n        }\\n        return validmatrix;\\n    }\\n};\\n\\n```\\n![image.jpg](https://assets.leetcode.com/users/images/2f82ab47-0d5d-4801-a24c-fc6d86a6dce1_1678910941.9007642.jpeg)\\n\\nSaw a lot of solutions using this approach to form matrix , thought it was a little complicated.\\n```\\nvector<int> idx(k+1,0);\\n        for(int j=0;j<validcol.size();j++){\\n            idx[validcol[j]] = j;\\n        }\\n\\n        vector<vector<int>> validmatrix(k, vector<int>(k, 0));\\n        for(int i=0;i<k;i++){\\n            validmatrix[i][idx[validrow[i]]] = validrow[i];\\n        }\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> validorder(vector<vector<int>> &conditions, int k){\\n        vector<int> indegree(k+1, 0);\\n        vector<vector<int>> adj(k+1);\\n        // we will first create an adj list\\n        for(int i = 0 ; i< conditions.size(); i++){\\n            int a = conditions[i][0];\\n            int b = conditions[i][1];\\n            indegree[b]++;\\n            adj[a].push_back(b);\\n        }\\n        //Kahn\\'s algo\\n        vector<int> order;\\n        queue<int> q;\\n        for(int i=1;i<=k;i++){\\n            if(indegree[i]==0){\\n                q.push(i);\\n            }\\n        }\\n        while(!q.empty()){\\n            int node = q.front();\\n            q.pop();\\n            order.push_back(node);\\n            for(int i = 0 ; i<adj[node].size(); i++){\\n                int x=adj[node][i];\\n                indegree[x]--;\\n                if(indegree[x]==0){\\n                    q.push(x);\\n                }\\n            }\\n        }\\n        return order;\\n    }\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        vector<int> validcol = validorder(rowConditions, k);\\n        vector<int> validrow = validorder(colConditions, k);\\n\\n        if(validcol.size()!=k||validrow.size()!=k) return {};\\n\\n        vector<vector<int>> validmatrix(k, vector<int>(k, 0));\\n        for(int i = 0;i<k;i++){\\n            for(int j = 0 ; j<k ; j++){\\n                if(validcol[i]==validrow[j]){\\n                    validmatrix[i][j]=validcol[i];\\n                }\\n            }\\n        }\\n        return validmatrix;\\n    }\\n};\\n\\n```\n```\\nvector<int> idx(k+1,0);\\n        for(int j=0;j<validcol.size();j++){\\n            idx[validcol[j]] = j;\\n        }\\n\\n        vector<vector<int>> validmatrix(k, vector<int>(k, 0));\\n        for(int i=0;i<k;i++){\\n            validmatrix[i][idx[validrow[i]]] = validrow[i];\\n        }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2499806,
                "title": "leetcode-the-hard-way-kahn-s-algorithm-with-explanation",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. If you like it, please give a star and watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way).\\n\\n---\\n\\n```cpp\\nclass Solution {\\npublic:\\n    // there is at least one vertex in the \\u201Cgraph\\u201D with an \\u201Cin-degree\\u201D of 0. \\n    // if all vertices in the \\u201Cgraph\\u201D have non-zero \\u201Cin-degree\\u201D, \\n    // then all vertices need at least one vertex as a predecessor. \\n    // In this case, no vertex can serve as the starting vertex.\\n    template<typename T_vector, typename T_vector_vector>\\n      T_vector kahn(int n, T_vector_vector &edges){\\n          vector<int> ordering, indegree(n, 0);\\n          vector<vector<int> > g(n);\\n          for (auto e : edges) {\\n            --e[0], --e[1];\\n            indegree[e[1]]++;\\n            g[e[0]].push_back(e[1]);\\n          }\\n          queue<int> q;\\n          for (int i = 0; i < n; i++) if (indegree[i] == 0) q.push(i);\\n          int visited = 0;\\n          while (!q.empty()) {\\n            int u = q.front(); q.pop();\\n            ordering.push_back(u);\\n            visited++;\\n            for (auto v : g[u]) {\\n              if (--indegree[v] == 0) q.push(v);\\n            }\\n          }\\n          if (visited != n) return T_vector{};\\n          return ordering;\\n      }\\n    \\n    // the idea is to topologically sort rowConditions & colConditions\\n    // then build the final matrix based on the order if possible\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        vector<vector<int>> ans(k, vector<int>(k));\\n        // in example 1, rowOrders would be [1, 3, 2]\\n        vector<int> rowOrders = kahn<vector<int>>(k, rowConditions);\\n        // in example 1, colOrders would be [3, 2, 1]\\n        vector<int> colOrders = kahn<vector<int>>(k, colConditions);\\n        // since we need to map to a `k x k` matrix, \\n        // we need to make sure that both got exact k elements\\n        if ((int) rowOrders.size() == k && (int) colOrders.size() == k) {\\n            // used to map the index of the given row / col value\\n            // i.e. given the value, which row / col idx should it belong to\\n            vector<int> rowIdx(k), colIdx(k);\\n            for (int i = 0; i < k; i++) rowIdx[rowOrders[i]] = i, colIdx[colOrders[i]] = i;\\n            // update the final matrix\\n            for (int i = 0; i < k; i++) ans[rowIdx[i]][colIdx[i]] = i + 1;\\n            return ans;\\n        }\\n        // else we don\\'t have a matrix that satisfies the conditions\\n        return vector<vector<int>>{};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    // there is at least one vertex in the \\u201Cgraph\\u201D with an \\u201Cin-degree\\u201D of 0. \\n    // if all vertices in the \\u201Cgraph\\u201D have non-zero \\u201Cin-degree\\u201D, \\n    // then all vertices need at least one vertex as a predecessor. \\n    // In this case, no vertex can serve as the starting vertex.\\n    template<typename T_vector, typename T_vector_vector>\\n      T_vector kahn(int n, T_vector_vector &edges){\\n          vector<int> ordering, indegree(n, 0);\\n          vector<vector<int> > g(n);\\n          for (auto e : edges) {\\n            --e[0], --e[1];\\n            indegree[e[1]]++;\\n            g[e[0]].push_back(e[1]);\\n          }\\n          queue<int> q;\\n          for (int i = 0; i < n; i++) if (indegree[i] == 0) q.push(i);\\n          int visited = 0;\\n          while (!q.empty()) {\\n            int u = q.front(); q.pop();\\n            ordering.push_back(u);\\n            visited++;\\n            for (auto v : g[u]) {\\n              if (--indegree[v] == 0) q.push(v);\\n            }\\n          }\\n          if (visited != n) return T_vector{};\\n          return ordering;\\n      }\\n    \\n    // the idea is to topologically sort rowConditions & colConditions\\n    // then build the final matrix based on the order if possible\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        vector<vector<int>> ans(k, vector<int>(k));\\n        // in example 1, rowOrders would be [1, 3, 2]\\n        vector<int> rowOrders = kahn<vector<int>>(k, rowConditions);\\n        // in example 1, colOrders would be [3, 2, 1]\\n        vector<int> colOrders = kahn<vector<int>>(k, colConditions);\\n        // since we need to map to a `k x k` matrix, \\n        // we need to make sure that both got exact k elements\\n        if ((int) rowOrders.size() == k && (int) colOrders.size() == k) {\\n            // used to map the index of the given row / col value\\n            // i.e. given the value, which row / col idx should it belong to\\n            vector<int> rowIdx(k), colIdx(k);\\n            for (int i = 0; i < k; i++) rowIdx[rowOrders[i]] = i, colIdx[colOrders[i]] = i;\\n            // update the final matrix\\n            for (int i = 0; i < k; i++) ans[rowIdx[i]][colIdx[i]] = i + 1;\\n            return ans;\\n        }\\n        // else we don\\'t have a matrix that satisfies the conditions\\n        return vector<vector<int>>{};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2493165,
                "title": "rust-kahn-s-algorithm-with-matrix-manipulation",
                "content": "Solution - [github](https://github.com/An7One/lc_soln_rust_leon/tree/main/src/leetcode/lvl4/lc2392)\\n\\n<b>Problem List</b>\\n#KahnsAlgorithm - [github](https://github.com/An7One/leetcode-problems-by-tag-an7one/blob/main/txt/by_algorithm/search/breath_first_search/by_algorithm/kahns_algorithm.txt)\\n#MatrixManipulation - [github](https://github.com/An7One/leetcode-problems-by-tag-an7one/tree/main/txt/by_data_structure/array/by_topic/manipulation/matrix)\\n\\n#DirectedGraph - [github](https://github.com/An7One/leetcode-problems-by-tag-an7one/tree/main/txt/by_data_structure/graph/by_data_structure/directed_graph)\\n#DetectCycle-Graph - [github](https://github.com/An7One/leetcode-problems-by-tag-an7one/blob/main/txt/by_data_structure/graph/by_topic/detect_cycle.txt)\\n#Graph - [github](https://github.com/An7One/leetcode-problems-by-tag-an7one/tree/main/txt/by_data_structure/graph)\\n\\n```\\nuse std::collections::{HashMap, VecDeque};\\n\\n/// @author: Leon\\n/// https://leetcode.com/problems/build-a-matrix-with-conditions/\\n/// Time Complexity:    O(V + E) + O(`k`) ~ O(`k` + `_len_rcs` + `_len_ccs`)\\n/// Space Complexity:   O(V + E) + O(`k`) ~ O(`k` + `_len_rcs` + `_len_ccs`)\\nimpl Solution {\\n    pub fn build_matrix(\\n        k: i32,\\n        row_conditions: Vec<Vec<i32>>,\\n        col_conditions: Vec<Vec<i32>>,\\n    ) -> Vec<Vec<i32>> {\\n\\t    let _len_rcs: usize = row_conditions.len();\\n        let _len_ccs: usize = col_conditions.len();\\n        let k: usize = k as usize;\\n        let n: usize = k + 1;\\n        let (is_cyclic_r, map_r) = {\\n            let (graph, mut indegrees) = Self::build_graph(&row_conditions, n);\\n            Self::is_cyclic(&graph, &mut indegrees)\\n        };\\n        if is_cyclic_r {\\n            return Vec::new();\\n        }\\n        let (is_cyclic_c, map_c) = {\\n            let (graph, mut indegrees) = Self::build_graph(&col_conditions, n);\\n            Self::is_cyclic(&graph, &mut indegrees)\\n        };\\n        if is_cyclic_c {\\n            return Vec::new();\\n        }\\n        return Self::build_mat_simple(&map_r, &map_c, k);\\n    }\\n    /// to be improved\\n    /// this could pass for now,\\n    /// because of test cases being weak\\n    fn build_mat_simple(\\n        map_r: &HashMap<i32, usize>,\\n        map_c: &HashMap<i32, usize>,\\n        k: usize,\\n    ) -> Vec<Vec<i32>> {\\n        let mut ans: Vec<Vec<i32>> = vec![vec![0; k]; k];\\n        for num in 1..=k as i32 {\\n            let r: usize = *map_r.get(&num).unwrap();\\n            let c: usize = *map_c.get(&num).unwrap();\\n            ans[r][c] = num;\\n        }\\n        return ans;\\n    }\\n    fn is_cyclic(graph: &Vec<Vec<usize>>, indegrees: &mut Vec<u16>) -> (bool, HashMap<i32, usize>) {\\n        let len_vs: usize = indegrees.len();\\n        let mut queue: VecDeque<usize> = {\\n            let mut queue = VecDeque::with_capacity(len_vs);\\n            for idx in 1..len_vs {\\n                if indegrees[idx] == 0 {\\n                    queue.push_back(idx);\\n                }\\n            }\\n            queue\\n        };\\n        let mut sorted: Vec<i32> = Vec::with_capacity(len_vs);\\n        while let Some(cur) = queue.pop_front() {\\n            sorted.push(cur as i32);\\n            for &nxt in &graph[cur] {\\n                indegrees[nxt] -= 1;\\n                if indegrees[nxt] == 0 {\\n                    queue.push_back(nxt);\\n                }\\n            }\\n        }\\n        if sorted.len() < len_vs - 1 {\\n            return (true, HashMap::new());\\n        }\\n        let num_to_idx: HashMap<i32, usize> = {\\n            let mut map: HashMap<i32, usize> = HashMap::with_capacity(len_vs);\\n            for (idx, num) in sorted.into_iter().enumerate() {\\n                map.insert(num, idx);\\n            }\\n            map\\n        };\\n        return (false, num_to_idx);\\n    }\\n    fn build_graph(edges: &Vec<Vec<i32>>, n: usize) -> (Vec<Vec<usize>>, Vec<u16>) {\\n        let mut graph: Vec<Vec<usize>> = vec![Vec::with_capacity(n); n];\\n        let mut indegrees: Vec<u16> = vec![0; n];\\n        for edge in edges {\\n            let from: usize = edge[0] as usize;\\n            let to: usize = edge[1] as usize;\\n            graph[from].push(to);\\n            indegrees[to] += 1;\\n        }\\n        return (graph, indegrees);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Topological Sort"
                ],
                "code": "```\\nuse std::collections::{HashMap, VecDeque};\\n\\n/// @author: Leon\\n/// https://leetcode.com/problems/build-a-matrix-with-conditions/\\n/// Time Complexity:    O(V + E) + O(`k`) ~ O(`k` + `_len_rcs` + `_len_ccs`)\\n/// Space Complexity:   O(V + E) + O(`k`) ~ O(`k` + `_len_rcs` + `_len_ccs`)\\nimpl Solution {\\n    pub fn build_matrix(\\n        k: i32,\\n        row_conditions: Vec<Vec<i32>>,\\n        col_conditions: Vec<Vec<i32>>,\\n    ) -> Vec<Vec<i32>> {\\n\\t    let _len_rcs: usize = row_conditions.len();\\n        let _len_ccs: usize = col_conditions.len();\\n        let k: usize = k as usize;\\n        let n: usize = k + 1;\\n        let (is_cyclic_r, map_r) = {\\n            let (graph, mut indegrees) = Self::build_graph(&row_conditions, n);\\n            Self::is_cyclic(&graph, &mut indegrees)\\n        };\\n        if is_cyclic_r {\\n            return Vec::new();\\n        }\\n        let (is_cyclic_c, map_c) = {\\n            let (graph, mut indegrees) = Self::build_graph(&col_conditions, n);\\n            Self::is_cyclic(&graph, &mut indegrees)\\n        };\\n        if is_cyclic_c {\\n            return Vec::new();\\n        }\\n        return Self::build_mat_simple(&map_r, &map_c, k);\\n    }\\n    /// to be improved\\n    /// this could pass for now,\\n    /// because of test cases being weak\\n    fn build_mat_simple(\\n        map_r: &HashMap<i32, usize>,\\n        map_c: &HashMap<i32, usize>,\\n        k: usize,\\n    ) -> Vec<Vec<i32>> {\\n        let mut ans: Vec<Vec<i32>> = vec![vec![0; k]; k];\\n        for num in 1..=k as i32 {\\n            let r: usize = *map_r.get(&num).unwrap();\\n            let c: usize = *map_c.get(&num).unwrap();\\n            ans[r][c] = num;\\n        }\\n        return ans;\\n    }\\n    fn is_cyclic(graph: &Vec<Vec<usize>>, indegrees: &mut Vec<u16>) -> (bool, HashMap<i32, usize>) {\\n        let len_vs: usize = indegrees.len();\\n        let mut queue: VecDeque<usize> = {\\n            let mut queue = VecDeque::with_capacity(len_vs);\\n            for idx in 1..len_vs {\\n                if indegrees[idx] == 0 {\\n                    queue.push_back(idx);\\n                }\\n            }\\n            queue\\n        };\\n        let mut sorted: Vec<i32> = Vec::with_capacity(len_vs);\\n        while let Some(cur) = queue.pop_front() {\\n            sorted.push(cur as i32);\\n            for &nxt in &graph[cur] {\\n                indegrees[nxt] -= 1;\\n                if indegrees[nxt] == 0 {\\n                    queue.push_back(nxt);\\n                }\\n            }\\n        }\\n        if sorted.len() < len_vs - 1 {\\n            return (true, HashMap::new());\\n        }\\n        let num_to_idx: HashMap<i32, usize> = {\\n            let mut map: HashMap<i32, usize> = HashMap::with_capacity(len_vs);\\n            for (idx, num) in sorted.into_iter().enumerate() {\\n                map.insert(num, idx);\\n            }\\n            map\\n        };\\n        return (false, num_to_idx);\\n    }\\n    fn build_graph(edges: &Vec<Vec<i32>>, n: usize) -> (Vec<Vec<usize>>, Vec<u16>) {\\n        let mut graph: Vec<Vec<usize>> = vec![Vec::with_capacity(n); n];\\n        let mut indegrees: Vec<u16> = vec![0; n];\\n        for edge in edges {\\n            let from: usize = edge[0] as usize;\\n            let to: usize = edge[1] as usize;\\n            graph[from].push(to);\\n            indegrees[to] += 1;\\n        }\\n        return (graph, indegrees);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2492759,
                "title": "python-topological-sort-explained",
                "content": "rows and cols are independent, just run 2 topological sorts on each direction. time complexity is O(k^2)\\n\\n```\\nclass Solution:\\n    def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:\\n        res = [[0 for _ in range(k)] for _ in range(k)]\\n        \\n        # build 2 graphs for row and col independently, count indegrees for each node \\n        # a node in each graph is a number between 1 to k\\n        row_graph, col_graph = defaultdict(set), defaultdict(set)\\n        row_indegrees, col_indegrees = defaultdict(int), defaultdict(int)\\n        for i, j in rowConditions:\\n            # note the input conditions could contain duplicates\\n            if j not in row_graph[i]:\\n                row_graph[i].add(j)\\n                row_indegrees[j] += 1\\n        for i, j in colConditions:\\n            if j not in col_graph[i]:\\n                col_graph[i].add(j)\\n                col_indegrees[j] += 1\\n        \\n        # run topological sort for nodes in row graph\\n        row_queue, col_queue = deque(), deque()\\n        row_order, col_order = {}, {}\\n        row_order_counter, col_order_counter = 0, 0\\n        row_visited, col_visited = set(), set()\\n        for i in range(1, k+1):\\n            # note that numbers did not appear in row conditions also have row_indegree = 0\\n            if row_indegrees[i] == 0:\\n                row_queue.append(i)\\n                row_visited.add(i)\\n        while row_queue:\\n            cur = row_queue.popleft()\\n            row_order[cur] = row_order_counter\\n            row_order_counter += 1\\n            for nxt in row_graph[cur]:\\n                if nxt in row_visited:\\n                    continue\\n                row_indegrees[nxt] -= 1\\n                if row_indegrees[nxt] <= 0:\\n                    row_visited.add(nxt)\\n                    row_queue.append(nxt)\\n        \\n        # same topological sort for col graph\\n        for i in range(1, k+1):\\n            if col_indegrees[i] == 0:\\n                col_queue.append(i)\\n                col_visited.add(i)\\n        while col_queue:\\n            cur = col_queue.popleft()\\n            col_order[cur] = col_order_counter\\n            col_order_counter += 1\\n            for nxt in col_graph[cur]:\\n                if nxt in col_visited:\\n                    continue\\n                col_indegrees[nxt] -= 1\\n                if col_indegrees[nxt] <= 0:\\n                    col_visited.add(nxt)\\n                    col_queue.append(nxt)\\n\\n        # check if either row conditions or col conditions contains cycle\\n        if not (len(row_order) == k and len(col_order) == k):\\n            return []\\n        \\n        # no cycle, build result with row and col independently\\n        for i in range(1, k+1):\\n            res[row_order[i]][col_order[i]] = i\\n        return res\\n            \\n        \\n            \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:\\n        res = [[0 for _ in range(k)] for _ in range(k)]\\n        \\n        # build 2 graphs for row and col independently, count indegrees for each node \\n        # a node in each graph is a number between 1 to k\\n        row_graph, col_graph = defaultdict(set), defaultdict(set)\\n        row_indegrees, col_indegrees = defaultdict(int), defaultdict(int)\\n        for i, j in rowConditions:\\n            # note the input conditions could contain duplicates\\n            if j not in row_graph[i]:\\n                row_graph[i].add(j)\\n                row_indegrees[j] += 1\\n        for i, j in colConditions:\\n            if j not in col_graph[i]:\\n                col_graph[i].add(j)\\n                col_indegrees[j] += 1\\n        \\n        # run topological sort for nodes in row graph\\n        row_queue, col_queue = deque(), deque()\\n        row_order, col_order = {}, {}\\n        row_order_counter, col_order_counter = 0, 0\\n        row_visited, col_visited = set(), set()\\n        for i in range(1, k+1):\\n            # note that numbers did not appear in row conditions also have row_indegree = 0\\n            if row_indegrees[i] == 0:\\n                row_queue.append(i)\\n                row_visited.add(i)\\n        while row_queue:\\n            cur = row_queue.popleft()\\n            row_order[cur] = row_order_counter\\n            row_order_counter += 1\\n            for nxt in row_graph[cur]:\\n                if nxt in row_visited:\\n                    continue\\n                row_indegrees[nxt] -= 1\\n                if row_indegrees[nxt] <= 0:\\n                    row_visited.add(nxt)\\n                    row_queue.append(nxt)\\n        \\n        # same topological sort for col graph\\n        for i in range(1, k+1):\\n            if col_indegrees[i] == 0:\\n                col_queue.append(i)\\n                col_visited.add(i)\\n        while col_queue:\\n            cur = col_queue.popleft()\\n            col_order[cur] = col_order_counter\\n            col_order_counter += 1\\n            for nxt in col_graph[cur]:\\n                if nxt in col_visited:\\n                    continue\\n                col_indegrees[nxt] -= 1\\n                if col_indegrees[nxt] <= 0:\\n                    col_visited.add(nxt)\\n                    col_queue.append(nxt)\\n\\n        # check if either row conditions or col conditions contains cycle\\n        if not (len(row_order) == k and len(col_order) == k):\\n            return []\\n        \\n        # no cycle, build result with row and col independently\\n        for i in range(1, k+1):\\n            res[row_order[i]][col_order[i]] = i\\n        return res\\n            \\n        \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2492732,
                "title": "topological-sort-bfs-dfs-short-and-easy-to-understand-c-code",
                "content": "It can be easily observed that the problem can be solved independently for rows and columns. First we can find the row number for each number from 1 to K and then find the column number for each of them. \\nHere, If we see the problem as a graph problem where we have nodes from 1 to K and edges as the dependencies given in **rowConditions** and **colConditions**.  \\nthen, after building the graph, we can see that there are a lot od dependencies like 2 should come before 3 and 3 should code after 5 and so on. So How can we find the order which can satisify these conditions. For this, we will use topological sort.\\n\\nSteps:\\n1. Build the graph using **rowConditions**\\n2. Find topological sorting order for this graph\\n3. Build one more graph using **colConditions**\\n4. Find topological sorting order for this graph\\n5. fill the matrix using the sorting order given by topological sort. \\n\\n```\\nclass Solution {\\npublic:\\n    \\n    \\n    \\n    // return false if the graph formed is cyclic in nature. \\n    //normal graph building and topological sort code\\n    bool buildGraph(vector<vector<int> >& arr, int n, vector<int>& data) {\\n        vector<int> adj[n + 1];\\n        vector<int> indeg(n + 1, 0);\\n        for(auto& curr: arr) {\\n            adj[curr[0]].push_back(curr[1]);\\n            indeg[curr[1]]++;\\n        }\\n        queue<int> q;\\n        for(int i = 1; i <= n; i++) {\\n            if(indeg[i] == 0) {\\n                q.push(i);\\n            }\\n        }\\n        while(!q.empty()) {\\n            int node = q.front();\\n            q.pop();\\n            data.push_back(node);\\n            for(auto& x: adj[node]) {\\n                if(--indeg[x] == 0) {\\n                    q.push(x);\\n                }\\n            }\\n        }\\n        return data.size() == n;\\n    }\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        vector<int> topoRow, topoCol;\\n        \\n        // if the graph formed by the two arrays is cyclic, then answer is not possible.\\n        if(!buildGraph(rowConditions, k, topoRow) || !buildGraph(colConditions, k, topoCol)) {\\n            return {};\\n        }\\n        \\n        int row[k + 1], col[k + 1];\\n    \\n        \\n        for(int i = 0; i < k; i++) {\\n            row[topoRow[i]] = i;\\n            col[topoCol[i]] = i;\\n        }\\n        \\n        vector<vector<int> > arr(k, vector<int>(k, 0));\\n        for(int i = 1; i <= k; i++) {\\n            arr[row[i]][col[i]] = i;\\n        }\\n        return arr;\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    \\n    // return false if the graph formed is cyclic in nature. \\n    //normal graph building and topological sort code\\n    bool buildGraph(vector<vector<int> >& arr, int n, vector<int>& data) {\\n        vector<int> adj[n + 1];\\n        vector<int> indeg(n + 1, 0);\\n        for(auto& curr: arr) {\\n            adj[curr[0]].push_back(curr[1]);\\n            indeg[curr[1]]++;\\n        }\\n        queue<int> q;\\n        for(int i = 1; i <= n; i++) {\\n            if(indeg[i] == 0) {\\n                q.push(i);\\n            }\\n        }\\n        while(!q.empty()) {\\n            int node = q.front();\\n            q.pop();\\n            data.push_back(node);\\n            for(auto& x: adj[node]) {\\n                if(--indeg[x] == 0) {\\n                    q.push(x);\\n                }\\n            }\\n        }\\n        return data.size() == n;\\n    }\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        vector<int> topoRow, topoCol;\\n        \\n        // if the graph formed by the two arrays is cyclic, then answer is not possible.\\n        if(!buildGraph(rowConditions, k, topoRow) || !buildGraph(colConditions, k, topoCol)) {\\n            return {};\\n        }\\n        \\n        int row[k + 1], col[k + 1];\\n    \\n        \\n        for(int i = 0; i < k; i++) {\\n            row[topoRow[i]] = i;\\n            col[topoCol[i]] = i;\\n        }\\n        \\n        vector<vector<int> > arr(k, vector<int>(k, 0));\\n        for(int i = 1; i <= k; i++) {\\n            arr[row[i]][col[i]] = i;\\n        }\\n        return arr;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3754078,
                "title": "heavely-commented-toposort-khan-s-algorithm-bfs-100-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n\\t// Function to create adjacency List and indegree of the graph\\n    void adjListCreator(vector<vector<int>>&conditions,vector<vector<int>>&adj,vector<int>& indegree){\\n        for(auto &it:conditions){\\n            int u=it[0];\\n            int v=it[1];\\n            adj[v].push_back(u);\\n            indegree[u]++;\\n        }\\n    }\\n    //Function of Khan\\'s Algorithm\\n    void kahnAlgo(vector<vector<int>>&adj,vector<int>& indegree,vector<int>&topoSort){\\n        queue<int>qu;\\n        for(int i=1;i<indegree.size();i++){\\n            if(indegree[i]==0)\\n                qu.push(i);\\n        }\\n        while(!qu.empty()){\\n            int k=qu.front();\\n            topoSort.push_back(k);\\n            qu.pop();\\n            for(auto &it:adj[k]){\\n                indegree[it]--;\\n                if(indegree[it]==0)qu.push(it);\\n            }\\n        }\\n        reverse(topoSort.begin(),topoSort.end());\\n    }\\n    \\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        vector<vector<int>>res(k,vector<int>(k,0));\\n    \\n        vector<vector<int>>adjRow(k+1);\\n        vector<vector<int>>adjCol(k+1);\\n        \\n        vector<int>indegreeRow(k+1,0);\\n        vector<int>indegreeCol(k+1,0);\\n\\t\\t\\n        //Create adjacency List for both condition matrices\\n\\t\\t//And calculate the indegree (i.e. number of incoming nodes) for each nodes\\n        adjListCreator(rowConditions,adjRow,indegreeRow);\\n        adjListCreator(colConditions,adjCol,indegreeCol);\\n        \\n        vector<int>topoSortRow,topoSortCol; //Store the REVERSE of topoSort (as work order is reverse of Topological sort) ordering of the two adjecency Lists\\n\\t\\t\\n\\t\\t//Apply khans algorithm to calculate the order of work\\n        kahnAlgo(adjRow,indegreeRow,topoSortRow);  \\n        kahnAlgo(adjCol,indegreeCol,topoSortCol);\\n\\t\\t\\n\\t\\t// If the size of these two arrays are not equal to k (i.e. the number of nodes) it means there is a cycle present in the graph .Hence we return the empty vector \\n        if(topoSortRow.size()!=k or topoSortCol.size()!=k)return {};\\n        \\n\\t\\t//Now we arrange the ordering of nodes into the resultant array by applying simple logic\\n\\t\\t//                index= 0  1  2\\n\\t\\t// Lets say topoSortRow= 1  3  2\\n\\t\\t//          topoSortCol= 3  2  1\\n\\t\\t// Since the topoSortRow[0]==topoSorCol[2]==1 , Hence  our res[0][2]=1, Similarly we fill other \\'res\\' values\\n        for(int i=0;i<k;i++){\\n            for(int j=0;j<k;j++){\\n                if(topoSortRow[i]==topoSortCol[j]){\\n                    res[i][j]=topoSortRow[i];\\n                    break;\\n                }\\n            }\\n        }\\n        //Finally return the resultant array\\n        return res;\\n    }\\n};\\n```\\n**Hope you find it helpful. If yes, kindly upvote!!**",
                "solutionTags": [
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n\\t// Function to create adjacency List and indegree of the graph\\n    void adjListCreator(vector<vector<int>>&conditions,vector<vector<int>>&adj,vector<int>& indegree){\\n        for(auto &it:conditions){\\n            int u=it[0];\\n            int v=it[1];\\n            adj[v].push_back(u);\\n            indegree[u]++;\\n        }\\n    }\\n    //Function of Khan\\'s Algorithm\\n    void kahnAlgo(vector<vector<int>>&adj,vector<int>& indegree,vector<int>&topoSort){\\n        queue<int>qu;\\n        for(int i=1;i<indegree.size();i++){\\n            if(indegree[i]==0)\\n                qu.push(i);\\n        }\\n        while(!qu.empty()){\\n            int k=qu.front();\\n            topoSort.push_back(k);\\n            qu.pop();\\n            for(auto &it:adj[k]){\\n                indegree[it]--;\\n                if(indegree[it]==0)qu.push(it);\\n            }\\n        }\\n        reverse(topoSort.begin(),topoSort.end());\\n    }\\n    \\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        vector<vector<int>>res(k,vector<int>(k,0));\\n    \\n        vector<vector<int>>adjRow(k+1);\\n        vector<vector<int>>adjCol(k+1);\\n        \\n        vector<int>indegreeRow(k+1,0);\\n        vector<int>indegreeCol(k+1,0);\\n\\t\\t\\n        //Create adjacency List for both condition matrices\\n\\t\\t//And calculate the indegree (i.e. number of incoming nodes) for each nodes\\n        adjListCreator(rowConditions,adjRow,indegreeRow);\\n        adjListCreator(colConditions,adjCol,indegreeCol);\\n        \\n        vector<int>topoSortRow,topoSortCol; //Store the REVERSE of topoSort (as work order is reverse of Topological sort) ordering of the two adjecency Lists\\n\\t\\t\\n\\t\\t//Apply khans algorithm to calculate the order of work\\n        kahnAlgo(adjRow,indegreeRow,topoSortRow);  \\n        kahnAlgo(adjCol,indegreeCol,topoSortCol);\\n\\t\\t\\n\\t\\t// If the size of these two arrays are not equal to k (i.e. the number of nodes) it means there is a cycle present in the graph .Hence we return the empty vector \\n        if(topoSortRow.size()!=k or topoSortCol.size()!=k)return {};\\n        \\n\\t\\t//Now we arrange the ordering of nodes into the resultant array by applying simple logic\\n\\t\\t//                index= 0  1  2\\n\\t\\t// Lets say topoSortRow= 1  3  2\\n\\t\\t//          topoSortCol= 3  2  1\\n\\t\\t// Since the topoSortRow[0]==topoSorCol[2]==1 , Hence  our res[0][2]=1, Similarly we fill other \\'res\\' values\\n        for(int i=0;i<k;i++){\\n            for(int j=0;j<k;j++){\\n                if(topoSortRow[i]==topoSortCol[j]){\\n                    res[i][j]=topoSortRow[i];\\n                    break;\\n                }\\n            }\\n        }\\n        //Finally return the resultant array\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2520006,
                "title": "easy-explanation-code-with-comments-doubt-of-building-matrix-at-end-java-bfs-topsort",
                "content": "From diffferent you might already know it is topological sort. But there is no harm in revising it.\\nApproach:\\nIn question, condition is given that a number should occur before other number in row/column and such conditions are many. This is cue for topological sort.\\n\\nNow, imagine we dont have to create 2D matrix at the end and simply a 1D matrix need to be form. Then only one array of conditions would be given in the question and we form a graph and perform topological sort.\\n**Example 1:** if given: k = 3, rowConditions = [[1,2],[3,2]]\\nthen this graph will be formed :\\n1 ---> 2 <--- 3\\nand its topological sorted array would be : 1, 3, 2 (we will use this further in explaination) or 3, 2, 1.\\nIn this we know position of 1 is at 0 index, position of 3 is at 1 index, position of 2 will be at 2 index.\\n\\nTill now all good.\\n\\nNow, if above is given for column then also, can perform similar.\\n**Example 2:** given inputs are : k = 3, colConditions = [[2,1],[3,2]]\\nGraph will be:\\n3 ---> 2 ---> 1\\nTopological sort will be 3, 2, 1\\nAlso, we know position of 3 is at 0 index, position of 2 is at 1 index, position of 1 will be at 2 index.\\n\\nNow comes the real question, **How to build matrix ?** \\nSimply assume the positions in Example 1 are row numbers, means in which row these need to be inserted or we are forming a 1D array in vertical form like:\\n![image](https://assets.leetcode.com/users/images/f732d735-2f5e-44f3-bb4d-1e976c6f6e00_1662136945.8450797.jpeg)\\n\\nFor Example 2 assume, positions are columns number and our 1D array will be in horizontal form like:\\n![image](https://assets.leetcode.com/users/images/f8aa9df7-c81b-476f-b40c-83a4e1c37da6_1662137146.3878105.jpeg)\\n\\nNow for each number we know its row index and its column index, so we can create the matrix using that:\\nPsuedoCode:\\n```\\nfor(int i = 1; i <=k ; i++){\\n\\tmatrix[position of i in row][position of i in column] = i\\n}\\n```\\n```\\nclass Solution {\\n    public int[][] buildMatrix(int k, int[][] rowConditions, int[][] colConditions) {\\n        Map<Integer, Set<Integer>> rowGraph = new HashMap<>();\\n        Map<Integer, Set<Integer>> colGraph = new HashMap<>();\\n        int[] inDegreeRow = new int[k+1];\\n        int[] inDegreeCol = new int[k+1];\\n\\n        // Initalizing the map so that we dont have to check for null\\n        for(int i = 0; i <= k; i++) {\\n            rowGraph.put(i, new HashSet<>());\\n            colGraph.put(i, new HashSet<>());\\n        }\\n\\n        // building a graph for row conditions along with populating the inDegree of each node.\\n        buildGraph(rowConditions, inDegreeRow, rowGraph);\\n        // building a graph for column conditions along with populating the inDegree of each node.\\n        buildGraph(colConditions, inDegreeCol, colGraph);\\n\\n        // Finding Topological sort\\n        // or mapping of node/numbers to its position where it should be in row (index). \\n        Map<Integer, Integer> rowTopoSort = getTopologicalSort(rowGraph, inDegreeRow, k);\\n        \\n        // Finding Topological sort\\n        // or mapping of node/numbers to its position where it should be in column (index). \\n        Map<Integer, Integer> colTopoSort = getTopologicalSort(colGraph, inDegreeCol, k);\\n\\n        // If we are not able to cover all nodes/numbers means there is cycle.\\n        if(rowTopoSort.size() != k || colTopoSort.size() != k) return new int[0][0];\\n\\n        // Building tha metric usinbg the mapping we get from topological sort.\\n        return buildMatrix(k, rowTopoSort, colTopoSort);\\n    }\\n\\n    private void buildGraph(int[][] conditions, int[] inDegree, Map<Integer, Set<Integer>> graph){\\n        for (int[] condition : conditions){\\n            int u = condition[0];\\n            int v = condition[1];\\n\\n            Set<Integer> s = graph.get(u);\\n            s.add(v);\\n            graph.put(u, s);\\n        }\\n\\n        for(int i = 1; i < inDegree.length; i++){\\n            for(int neighbour : graph.get(i)){\\n                inDegree[neighbour]++;\\n            }\\n        }\\n    }\\n\\n    private Map<Integer, Integer> getTopologicalSort(Map<Integer, Set<Integer>> graph, int[] inDegree, int k){\\n        Map<Integer, Integer> numToPoistionMap = new HashMap<>();\\n        Queue<Integer> queue = new LinkedList<>();\\n        for(int i = 1; i <= k; i++){\\n            if(inDegree[i] == 0) queue.offer(i);\\n        }\\n\\n        int position = 0;\\n        while(!queue.isEmpty()){\\n            int head = queue.poll();\\n            numToPoistionMap.put(head, position++);\\n\\n            for(int neighbour : graph.get(head)){\\n                inDegree[neighbour]--;\\n\\n                if(inDegree[neighbour] == 0) queue.offer(neighbour);\\n            }\\n        }\\n\\n        return numToPoistionMap;\\n    }\\n\\n    private int[][] buildMatrix(int k, Map<Integer, Integer> rowMap, Map<Integer, Integer> colMap){\\n        int[][] matrix = new int[k][k];\\n\\n        for(int i = 1 ; i <= k; i++){\\n            matrix[rowMap.get(i)][colMap.get(i)] = i;\\n        }\\n\\n        return matrix;\\n    }\\n}\\n```\\n\\nThanks for reading. If you like please upvote.",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nfor(int i = 1; i <=k ; i++){\\n\\tmatrix[position of i in row][position of i in column] = i\\n}\\n```\n```\\nclass Solution {\\n    public int[][] buildMatrix(int k, int[][] rowConditions, int[][] colConditions) {\\n        Map<Integer, Set<Integer>> rowGraph = new HashMap<>();\\n        Map<Integer, Set<Integer>> colGraph = new HashMap<>();\\n        int[] inDegreeRow = new int[k+1];\\n        int[] inDegreeCol = new int[k+1];\\n\\n        // Initalizing the map so that we dont have to check for null\\n        for(int i = 0; i <= k; i++) {\\n            rowGraph.put(i, new HashSet<>());\\n            colGraph.put(i, new HashSet<>());\\n        }\\n\\n        // building a graph for row conditions along with populating the inDegree of each node.\\n        buildGraph(rowConditions, inDegreeRow, rowGraph);\\n        // building a graph for column conditions along with populating the inDegree of each node.\\n        buildGraph(colConditions, inDegreeCol, colGraph);\\n\\n        // Finding Topological sort\\n        // or mapping of node/numbers to its position where it should be in row (index). \\n        Map<Integer, Integer> rowTopoSort = getTopologicalSort(rowGraph, inDegreeRow, k);\\n        \\n        // Finding Topological sort\\n        // or mapping of node/numbers to its position where it should be in column (index). \\n        Map<Integer, Integer> colTopoSort = getTopologicalSort(colGraph, inDegreeCol, k);\\n\\n        // If we are not able to cover all nodes/numbers means there is cycle.\\n        if(rowTopoSort.size() != k || colTopoSort.size() != k) return new int[0][0];\\n\\n        // Building tha metric usinbg the mapping we get from topological sort.\\n        return buildMatrix(k, rowTopoSort, colTopoSort);\\n    }\\n\\n    private void buildGraph(int[][] conditions, int[] inDegree, Map<Integer, Set<Integer>> graph){\\n        for (int[] condition : conditions){\\n            int u = condition[0];\\n            int v = condition[1];\\n\\n            Set<Integer> s = graph.get(u);\\n            s.add(v);\\n            graph.put(u, s);\\n        }\\n\\n        for(int i = 1; i < inDegree.length; i++){\\n            for(int neighbour : graph.get(i)){\\n                inDegree[neighbour]++;\\n            }\\n        }\\n    }\\n\\n    private Map<Integer, Integer> getTopologicalSort(Map<Integer, Set<Integer>> graph, int[] inDegree, int k){\\n        Map<Integer, Integer> numToPoistionMap = new HashMap<>();\\n        Queue<Integer> queue = new LinkedList<>();\\n        for(int i = 1; i <= k; i++){\\n            if(inDegree[i] == 0) queue.offer(i);\\n        }\\n\\n        int position = 0;\\n        while(!queue.isEmpty()){\\n            int head = queue.poll();\\n            numToPoistionMap.put(head, position++);\\n\\n            for(int neighbour : graph.get(head)){\\n                inDegree[neighbour]--;\\n\\n                if(inDegree[neighbour] == 0) queue.offer(neighbour);\\n            }\\n        }\\n\\n        return numToPoistionMap;\\n    }\\n\\n    private int[][] buildMatrix(int k, Map<Integer, Integer> rowMap, Map<Integer, Integer> colMap){\\n        int[][] matrix = new int[k][k];\\n\\n        for(int i = 1 ; i <= k; i++){\\n            matrix[rowMap.get(i)][colMap.get(i)] = i;\\n        }\\n\\n        return matrix;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2501791,
                "title": "c-independent-topological-sort",
                "content": "Topological sort for rows and cols independently and then combine the outcome.\\n\\n```\\n    static vector<vector<int>> buildMatrix(int k,\\n\\t        vector<vector<int>>& rowConditions,\\n\\t\\t    vector<vector<int>>& colConditions) {\\n        // Topological sort for rows and cols independently.\\n        const vector<int> row_order = tsort(k, rowConditions);\\n        if (empty(row_order)) return {};\\n        \\n        const vector<int> col_order = tsort(k, colConditions);\\n        if (empty(col_order)) return {};\\n        \\n        // Turnt the tsort into an index so we know in which column a\\n        // number should go.\\n        vector<int> col_index(k);\\n        for (int i = 0; i < size(col_order); ++i) {\\n            col_index[col_order[i] - 1] = i;\\n        }\\n\\n        // Build the answer based on the above.\\n        vector<vector<int>> ans(k, vector<int>(k));\\n        for (int i = 0; i < size(row_order); ++i) {\\n            int n = row_order[i];\\n            ans[i][col_index[n - 1]] = n;\\n        }\\n        \\n        return ans;\\n    }\\n```\\t\\n\\nFor topological sort we use the classic Kahn\\'s algorithm:\\n\\n```\\n    // Kahn\\'s algorithm for topological sort.\\n    static vector<int> tsort(int k, const vector<vector<int>>& conds) {\\n        // Build adjacency list and in-degree vector.\\n        vector<vector<int>> adj(k + 1);\\n        vector<int> in_deg(k + 1);\\n        for (const vector<int>& cond : conds) {\\n            const int before = cond[0];\\n            const int after = cond[1];\\n            adj[before].push_back(after);\\n            ++in_deg[after];\\n        }\\n        \\n        // Topological sort.\\n        queue<int> q;\\n        for (int i = 1; i <= k; ++i) {\\n            if (!in_deg[i]) q.push(i);\\n        }\\n        \\n        vector<int> ans;\\n        ans.reserve(k);\\n        while (!empty(q)) {\\n            const int node = q.front(); q.pop();\\n            ans.push_back(node);\\n            for (int next : adj[node]) {\\n                if (!--in_deg[next]) {\\n                    q.push(next);\\n                }\\n            }\\n        }\\n        \\n        if (size(ans) != k) return {};\\n\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Topological Sort"
                ],
                "code": "```\\n    static vector<vector<int>> buildMatrix(int k,\\n\\t        vector<vector<int>>& rowConditions,\\n\\t\\t    vector<vector<int>>& colConditions) {\\n        // Topological sort for rows and cols independently.\\n        const vector<int> row_order = tsort(k, rowConditions);\\n        if (empty(row_order)) return {};\\n        \\n        const vector<int> col_order = tsort(k, colConditions);\\n        if (empty(col_order)) return {};\\n        \\n        // Turnt the tsort into an index so we know in which column a\\n        // number should go.\\n        vector<int> col_index(k);\\n        for (int i = 0; i < size(col_order); ++i) {\\n            col_index[col_order[i] - 1] = i;\\n        }\\n\\n        // Build the answer based on the above.\\n        vector<vector<int>> ans(k, vector<int>(k));\\n        for (int i = 0; i < size(row_order); ++i) {\\n            int n = row_order[i];\\n            ans[i][col_index[n - 1]] = n;\\n        }\\n        \\n        return ans;\\n    }\\n```\n```\\n    // Kahn\\'s algorithm for topological sort.\\n    static vector<int> tsort(int k, const vector<vector<int>>& conds) {\\n        // Build adjacency list and in-degree vector.\\n        vector<vector<int>> adj(k + 1);\\n        vector<int> in_deg(k + 1);\\n        for (const vector<int>& cond : conds) {\\n            const int before = cond[0];\\n            const int after = cond[1];\\n            adj[before].push_back(after);\\n            ++in_deg[after];\\n        }\\n        \\n        // Topological sort.\\n        queue<int> q;\\n        for (int i = 1; i <= k; ++i) {\\n            if (!in_deg[i]) q.push(i);\\n        }\\n        \\n        vector<int> ans;\\n        ans.reserve(k);\\n        while (!empty(q)) {\\n            const int node = q.front(); q.pop();\\n            ans.push_back(node);\\n            for (int next : adj[node]) {\\n                if (!--in_deg[next]) {\\n                    q.push(next);\\n                }\\n            }\\n        }\\n        \\n        if (size(ans) != k) return {};\\n\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2498436,
                "title": "c-topological-sort-beats-100-in-both-time-and-space-complexity",
                "content": "By using topo sort we are generating the order of sequence of numbers in row,column and here we also check **whether there are any cycles in row,col directed graph**.\\nIf there is any cycle in row or col directed graph, then we return an empty array\\nWe are using topo sort because there is a **relation** between numbers. **eg: [1,2] means 1 must occur before 2, so there will be directed edge from 1 -> 2.**\\n```\\nbool findOrder(vector<vector<int>>& a, int k, unordered_map<int, int> &m){\\n        vector<int> adj[k+1];\\n        vector<int> indegree(k+1, 0);\\n        queue<int> q;\\n        int num = 0;\\n        \\n        for(int i=0;i< a.size();i++){\\n            adj[a[i][0]].push_back(a[i][1]);\\n            indegree[a[i][1]]++;\\n        }\\n        \\n        for(int i=1;i< k+1;i++){\\n            if(indegree[i] == 0) q.push(i);\\n        }\\n        \\n        if(!q.size()) return false;\\n        \\n        while(!q.empty()){\\n            int val = q.front();\\n            q.pop();\\n            indegree[val]--;\\n            \\n            m[val] = num;\\n            num++;\\n            \\n            for(auto i : adj[val]){\\n                indegree[i]--;\\n                if(indegree[i] == 0) q.push(i);\\n            }\\n        }\\n        \\n        return (m.size() != k) ? false : true;\\n    }\\n    \\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        vector<vector<int>> ans(k, vector<int>(k, 0));\\n        vector<vector<int>> temp;\\n        \\n        unordered_map<int, int> row, col;\\n        \\n        bool a = findOrder(rowConditions,k,row);\\n        bool b = findOrder(colConditions,k,col);\\n        \\n        if(!a | !b) return temp;\\n        \\n        for(int i=1;i<= k;i++){\\n            ans[row[i]][col[i]] = i;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Topological Sort"
                ],
                "code": "By using topo sort we are generating the order of sequence of numbers in row,column and here we also check **whether there are any cycles in row,col directed graph**.\\nIf there is any cycle in row or col directed graph, then we return an empty array\\nWe are using topo sort because there is a **relation** between numbers. **eg: [1,2] means 1 must occur before 2, so there will be directed edge from 1 -> 2.**\\n```\\nbool findOrder(vector<vector<int>>& a, int k, unordered_map<int, int> &m){\\n        vector<int> adj[k+1];\\n        vector<int> indegree(k+1, 0);\\n        queue<int> q;\\n        int num = 0;\\n        \\n        for(int i=0;i< a.size();i++){\\n            adj[a[i][0]].push_back(a[i][1]);\\n            indegree[a[i][1]]++;\\n        }\\n        \\n        for(int i=1;i< k+1;i++){\\n            if(indegree[i] == 0) q.push(i);\\n        }\\n        \\n        if(!q.size()) return false;\\n        \\n        while(!q.empty()){\\n            int val = q.front();\\n            q.pop();\\n            indegree[val]--;\\n            \\n            m[val] = num;\\n            num++;\\n            \\n            for(auto i : adj[val]){\\n                indegree[i]--;\\n                if(indegree[i] == 0) q.push(i);\\n            }\\n        }\\n        \\n        return (m.size() != k) ? false : true;\\n    }\\n    \\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        vector<vector<int>> ans(k, vector<int>(k, 0));\\n        vector<vector<int>> temp;\\n        \\n        unordered_map<int, int> row, col;\\n        \\n        bool a = findOrder(rowConditions,k,row);\\n        bool b = findOrder(colConditions,k,col);\\n        \\n        if(!a | !b) return temp;\\n        \\n        for(int i=1;i<= k;i++){\\n            ans[row[i]][col[i]] = i;\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2494715,
                "title": "topological-sorting-kahn-s-algorithm",
                "content": "We have hierarchy given to us by rowConditions and colConditions. We can map that hierarchy with a topological ordering algorithm.\\n\\nLet\\'s find the order we can place rows and columns separately by running the Kahn\\'s topsort algorithm. If there is a cycle detected we know we cannot have a valid order, we return `[]` as required.\\n\\nOtherwise we have a valid order, so for every node `[1,k]` we look it\\'s index position in the rows order and cols order and put it in the matrix.\\n\\n```\\nclass Solution:\\n    def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:\\n        try:\\n            row_conditions_topsort, row_node_to_index = self.top_sort(k, rowConditions)\\n            col_conditions_topsort, col_node_to_index = self.top_sort(k, colConditions)\\n            matrix = [[0 for _ in range(k)] for _ in range(k)]\\n            \\n            for n in range(1, k + 1):\\n                row, col = row_node_to_index[n], col_node_to_index[n]\\n                matrix[row][col] = n\\n            \\n            return matrix\\n            \\n            \\n        except:\\n            # If error thrown, kahn\\'s algorithm detected a cycle\\n            return []\\n        \\n    def top_sort(self, k, edges: tuple[int, int]) -> list[int]:\\n        indegree = defaultdict(int)\\n        graph = defaultdict(list)\\n        \\n        for n in range(1, k + 1):\\n            indegree[n] = 0\\n        \\n        for u, v in edges:\\n            graph[u].append(v)\\n            indegree[v] += 1\\n        \\n        queue = deque()\\n        topsort = []\\n        for n in range(1, k + 1):\\n            if indegree[n] == 0:\\n                queue.append(n)\\n        \\n        while queue:\\n            node = queue.popleft()\\n            topsort.append(node)\\n            \\n            for nei in graph[node]:\\n                indegree[nei] -= 1\\n                if indegree[nei] == 0:\\n                    queue.append(nei)\\n        \\n        if len(topsort) != k:\\n            raise Exception()\\n        \\n        node_to_index = {}\\n        for i, n in enumerate(topsort):\\n            node_to_index[n] = i\\n        \\n        return topsort, node_to_index\\n```\\n\\n\\n<hr />\\nTook the virtual contest today :).\\n\\n<img src=\"https://nadarsandbox-videocontent-sandbox.s3.amazonaws.com/raw-thumbnails/WhatsApp+Image+2022-08-28+at+11.48.29+AM.jpeg\" />",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:\\n        try:\\n            row_conditions_topsort, row_node_to_index = self.top_sort(k, rowConditions)\\n            col_conditions_topsort, col_node_to_index = self.top_sort(k, colConditions)\\n            matrix = [[0 for _ in range(k)] for _ in range(k)]\\n            \\n            for n in range(1, k + 1):\\n                row, col = row_node_to_index[n], col_node_to_index[n]\\n                matrix[row][col] = n\\n            \\n            return matrix\\n            \\n            \\n        except:\\n            # If error thrown, kahn\\'s algorithm detected a cycle\\n            return []\\n        \\n    def top_sort(self, k, edges: tuple[int, int]) -> list[int]:\\n        indegree = defaultdict(int)\\n        graph = defaultdict(list)\\n        \\n        for n in range(1, k + 1):\\n            indegree[n] = 0\\n        \\n        for u, v in edges:\\n            graph[u].append(v)\\n            indegree[v] += 1\\n        \\n        queue = deque()\\n        topsort = []\\n        for n in range(1, k + 1):\\n            if indegree[n] == 0:\\n                queue.append(n)\\n        \\n        while queue:\\n            node = queue.popleft()\\n            topsort.append(node)\\n            \\n            for nei in graph[node]:\\n                indegree[nei] -= 1\\n                if indegree[nei] == 0:\\n                    queue.append(nei)\\n        \\n        if len(topsort) != k:\\n            raise Exception()\\n        \\n        node_to_index = {}\\n        for i, n in enumerate(topsort):\\n            node_to_index[n] = i\\n        \\n        return topsort, node_to_index\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2492800,
                "title": "topological-sort-with-explanation-and-complexity-analysis",
                "content": "##### Rationale\\n* The row and column dependencies could be established with a directed graph, where any edge from vertex A to vertex B denotes that vertex A should come before vertex B in the matrix\\n* To resolve the dependencies, we could sort them topologically\\n* If the relationship is acyclic, we would have all the elements ordered. Otherwise, the sort would stop early (see Kahn\\'s Algorithm) with elements less than k\\n* Post the topological sort for both the dependencies, we could find out the required indexes for all the elements and put them in the matrix. Note that the index at which the candidate is present in the topological order for the row relationship would be its row index. The same goes for its column index\\n\\n##### Complexities\\n* Time: `O(k * k)`\\n* Space: `O(k * k)`\\n\\nThese are loose bounds based upon the fact that the runtime for the sort is `O(V + E)`. For this problem, `V = k`. In the worse case, `E` could be `(V * (V - 1)) / 2` or `(k * (k - 1)) / 2`. Thus, the total runtime would be `O(k + (k * k))` or `O(k * k)`. (Note that the other operations that we\\'ve done come under `O(k * k)` as well.)\\n\\n```\\nclass Solution:\\n    def topological_sort(self, k: int, relations: List[List[int]]) -> List[int]:\\n        graph = [[] for _ in range(k)]\\n        indegrees = [0] * k\\n        order = []\\n        \\n        for _from, to in items:\\n            _from -= 1\\n            to -= 1\\n            \\n            graph[_from].append(to)\\n            indegrees[to] += 1\\n\\n        queue = deque([vertex for vertex in range(k) if ind[vertex] == 0])\\n        \\n        while queue:\\n            curr = queue.popleft()\\n            \\n            order.append(curr)\\n            \\n            for neighbor in graph[curr]:     \\n                indegrees[neighbor] -= 1\\n                if indegrees[neighbor] == 0:\\n                    queue.append(neighbor)\\n                    \\n        return order     \\n        \\n    def buildMatrix(self, k: int, rows: List[List[int]], cols: List[List[int]]) -> List[List[int]]:\\n        topological_row = self.topological_sort(k, rows)\\n        topological_col = self.topological_sort(k, cols)\\n        \\n        # The dependencies couldn\\'t be resolved. Return early.\\n        if len(top_row) != k or len(top_col) != k:\\n            return []\\n\\n        # Based upon the relationships, find the row and column indices for every candidate.\\n        indexes = defaultdict(list)\\n        \\n        for row_index, candidate in enumerate(topological_row):\\n            indexes[candidate].append(row_index)\\n            \\n        for col_index, candidate in enumerate(topological_col):\\n            indexes[candidate].append(col_index)\\n        \\n        # Build the required matrix.\\n        matrix = [[0 for _ in range(k)] for __ in range(k)]\\n        for num in range(k):\\n            row, col = indexes[num]\\n            matrix[row][col] = num + 1\\n            \\n        return matrix\\n```\\n",
                "solutionTags": [
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution:\\n    def topological_sort(self, k: int, relations: List[List[int]]) -> List[int]:\\n        graph = [[] for _ in range(k)]\\n        indegrees = [0] * k\\n        order = []\\n        \\n        for _from, to in items:\\n            _from -= 1\\n            to -= 1\\n            \\n            graph[_from].append(to)\\n            indegrees[to] += 1\\n\\n        queue = deque([vertex for vertex in range(k) if ind[vertex] == 0])\\n        \\n        while queue:\\n            curr = queue.popleft()\\n            \\n            order.append(curr)\\n            \\n            for neighbor in graph[curr]:     \\n                indegrees[neighbor] -= 1\\n                if indegrees[neighbor] == 0:\\n                    queue.append(neighbor)\\n                    \\n        return order     \\n        \\n    def buildMatrix(self, k: int, rows: List[List[int]], cols: List[List[int]]) -> List[List[int]]:\\n        topological_row = self.topological_sort(k, rows)\\n        topological_col = self.topological_sort(k, cols)\\n        \\n        # The dependencies couldn\\'t be resolved. Return early.\\n        if len(top_row) != k or len(top_col) != k:\\n            return []\\n\\n        # Based upon the relationships, find the row and column indices for every candidate.\\n        indexes = defaultdict(list)\\n        \\n        for row_index, candidate in enumerate(topological_row):\\n            indexes[candidate].append(row_index)\\n            \\n        for col_index, candidate in enumerate(topological_col):\\n            indexes[candidate].append(col_index)\\n        \\n        # Build the required matrix.\\n        matrix = [[0 for _ in range(k)] for __ in range(k)]\\n        for num in range(k):\\n            row, col = indexes[num]\\n            matrix[row][col] = num + 1\\n            \\n        return matrix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2492785,
                "title": "java-topological-sort-no-cycle-no-conflict",
                "content": "#### Model\\nWe can model this as a directed graph, with `above -> below` and `left -> right`.\\nWe will need to verify that there is no cycle and find out where its supposed `row` and `col` position is.\\n\\n#### Strategy\\nOne crucial observation is that the grid size is `k x k` and we have `k` element to fill. \\nAny row and column has enough spaces to host all `k` elements.\\nThis means that if there is no cycle, then we will always be able to assign a unique `row` and a unique `col` value.\\nHere I use topological sort to make sure there is no cycle, and populate the order in which we should place it. \\nEach number will get its unique `row` and `column` value from `0` to `k-1`.\\nRun this topological once for each direction - row, column.\\n\\n`Time O(k^2 + R + C)`\\n`Space O(k^2 + max(R, C))`\\n```Java\\nclass Solution {\\n    public int[][] buildMatrix(int k, int[][] R, int[][] C) {\\n        int[][] ans = new int[k][k];\\n        int[] yp = new int[k+1]; // y position (col)\\n        int[] xp = new int[k+1]; // x position (row)\\n        Arrays.fill(xp, -1);\\n        Arrays.fill(yp, -1);\\n        if (!build(R, xp, k) || !build(C, yp, k)){ // if we can\\'t build it, there is a cycle, return empty.\\n            return new int[0][0];\\n        }\\n        for (int i = 1; i <= k; i++){ // otherwise, we fill it.\\n            ans[xp[i]][yp[i]] = i;\\n        }\\n        return ans;\\n    }\\n\\n    private boolean build(int[][] A, int[] pos, int k){\\n        List<Integer>[] map = new ArrayList[k+1];\\n        Arrays.setAll(map, o -> new ArrayList<>());\\n        int[] indg = new int[k+1];\\n        int depth = 0;\\n        for (int[] a : A){ // build the map and the indegree.\\n            map[a[0]].add(a[1]);\\n            indg[a[1]]++;\\n        }\\n\\t\\t// here we enqueue all the nodes with indegree 0.\\n        Deque<Integer> queue = new ArrayDeque<>(IntStream.range(1, k+1).filter(o -> indg[o] == 0).boxed().toList());\\n        while(!queue.isEmpty()){\\n            int y = queue.poll();\\n            pos[y] = depth++; // set its depth. each value gets a unique depth.\\n            for (int next : map[y]){\\n                if (--indg[next] == 0){\\n                    queue.offer(next);\\n                }\\n            }\\n        }\\n        if (Arrays.stream(indg).anyMatch(o -> o > 0)){\\n            return false; // If there is any node with indegree > 0, then there is a cycle.\\n        }\\n        for (int i = 1; i <= k; i++){\\n            if (pos[i] == -1){ // if there is any not filled yet, fill it\\n                pos[i] = depth++;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Topological Sort"
                ],
                "code": "```Java\\nclass Solution {\\n    public int[][] buildMatrix(int k, int[][] R, int[][] C) {\\n        int[][] ans = new int[k][k];\\n        int[] yp = new int[k+1]; // y position (col)\\n        int[] xp = new int[k+1]; // x position (row)\\n        Arrays.fill(xp, -1);\\n        Arrays.fill(yp, -1);\\n        if (!build(R, xp, k) || !build(C, yp, k)){ // if we can\\'t build it, there is a cycle, return empty.\\n            return new int[0][0];\\n        }\\n        for (int i = 1; i <= k; i++){ // otherwise, we fill it.\\n            ans[xp[i]][yp[i]] = i;\\n        }\\n        return ans;\\n    }\\n\\n    private boolean build(int[][] A, int[] pos, int k){\\n        List<Integer>[] map = new ArrayList[k+1];\\n        Arrays.setAll(map, o -> new ArrayList<>());\\n        int[] indg = new int[k+1];\\n        int depth = 0;\\n        for (int[] a : A){ // build the map and the indegree.\\n            map[a[0]].add(a[1]);\\n            indg[a[1]]++;\\n        }\\n\\t\\t// here we enqueue all the nodes with indegree 0.\\n        Deque<Integer> queue = new ArrayDeque<>(IntStream.range(1, k+1).filter(o -> indg[o] == 0).boxed().toList());\\n        while(!queue.isEmpty()){\\n            int y = queue.poll();\\n            pos[y] = depth++; // set its depth. each value gets a unique depth.\\n            for (int next : map[y]){\\n                if (--indg[next] == 0){\\n                    queue.offer(next);\\n                }\\n            }\\n        }\\n        if (Arrays.stream(indg).anyMatch(o -> o > 0)){\\n            return false; // If there is any node with indegree > 0, then there is a cycle.\\n        }\\n        for (int i = 1; i <= k; i++){\\n            if (pos[i] == -1){ // if there is any not filled yet, fill it\\n                pos[i] = depth++;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4015524,
                "title": "python3-topological-sort-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFind the order for row and col respectively and then assign them to the matrix. Note that there are only `k` number need to assign which is also the side of square matrix. Thus we can assign each number in each unique row and col\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(M + N)$$ with `N` is number of `rowConditions` and `M` is number of `colConditions`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(k)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:\\n        matrix = [[0 for _ in range(k)] for _ in range(k)]\\n        \\n        def topo_sort(condition: List[List[int]]) -> dict:\\n            order = {}\\n            in_degree = [0 for _ in range(k)]\\n            g = collections.defaultdict(list)\\n            for start, end in condition:\\n                g[start - 1].append(end - 1)\\n                in_degree[end - 1] += 1\\n            \\n            dq = collections.deque()\\n            for i in range(k):\\n                if in_degree[i] == 0: dq.append(i)\\n            \\n            i = 0\\n            while dq:\\n                u = dq.popleft()\\n                order[u] = i\\n                for v in g[u]:\\n                    in_degree[v] -= 1\\n                    if in_degree[v] == 0: dq.append(v)\\n                i += 1\\n            \\n            return order\\n        \\n        row_order, col_order = topo_sort(rowConditions), topo_sort(colConditions)\\n        if len(row_order) != k or len(col_order) != k: return []\\n        for u in row_order:\\n            r, c = row_order[u], col_order[u]\\n            matrix[r][c] = u + 1\\n        return matrix\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy",
                    "Graph",
                    "Topological Sort",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:\\n        matrix = [[0 for _ in range(k)] for _ in range(k)]\\n        \\n        def topo_sort(condition: List[List[int]]) -> dict:\\n            order = {}\\n            in_degree = [0 for _ in range(k)]\\n            g = collections.defaultdict(list)\\n            for start, end in condition:\\n                g[start - 1].append(end - 1)\\n                in_degree[end - 1] += 1\\n            \\n            dq = collections.deque()\\n            for i in range(k):\\n                if in_degree[i] == 0: dq.append(i)\\n            \\n            i = 0\\n            while dq:\\n                u = dq.popleft()\\n                order[u] = i\\n                for v in g[u]:\\n                    in_degree[v] -= 1\\n                    if in_degree[v] == 0: dq.append(v)\\n                i += 1\\n            \\n            return order\\n        \\n        row_order, col_order = topo_sort(rowConditions), topo_sort(colConditions)\\n        if len(row_order) != k or len(col_order) != k: return []\\n        for u in row_order:\\n            r, c = row_order[u], col_order[u]\\n            matrix[r][c] = u + 1\\n        return matrix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3600848,
                "title": "toposort",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n        vector<vector<int>> buildMatrix(int k, vector<vector<int>> &rowConditions, vector<vector<int>> &colConditions)\\n{\\n    vector<int> adj1[k], adj2[k];\\n    vector<int> indegree1(k, 0), indegree2(k, 0);\\n    for (auto it : rowConditions)\\n    {\\n        int u = it[0] - 1;\\n        int v = it[1] - 1;\\n        adj1[u].push_back(v);\\n        indegree1[v]++;\\n    }\\n\\n    for (auto it : colConditions)\\n    {\\n        int u = it[0] - 1;\\n        int v = it[1] - 1;\\n        adj2[u].push_back(v);\\n        indegree2[v]++;\\n    }\\n\\n    vector<int> order1, order2;\\n    queue<int> q;\\n    for (int i = 0; i < k; i++)\\n    {\\n        if (indegree1[i] == 0)\\n        {\\n            q.push(i);\\n        }\\n    }\\n\\n    while (!q.empty())\\n    {\\n        int node = q.front();\\n        q.pop();\\n        order1.push_back(node);\\n\\n        for (auto it : adj1[node])\\n        {\\n            indegree1[it]--;\\n            if (indegree1[it] == 0)\\n            {\\n                q.push(it);\\n            }\\n        }\\n    }\\n\\n    if (order1.size() < k)\\n    {\\n        return {};\\n    }\\n\\n    for (int i = 0; i < k; i++)\\n    {\\n        if (indegree2[i] == 0)\\n        {\\n            q.push(i);\\n        }\\n    }\\n\\n    while (!q.empty())\\n    {\\n        int node = q.front();\\n        q.pop();\\n        order2.push_back(node);\\n\\n        for (auto it : adj2[node])\\n        {\\n            indegree2[it]--;\\n            if (indegree2[it] == 0)\\n            {\\n                q.push(it);\\n            }\\n        }\\n    }\\n\\n    if (order2.size() < k)\\n    {\\n        return {};\\n    }\\n\\n    vector<pair<int, int>> v(k);\\n    for (int i = 0; i < order1.size(); i++)\\n    {\\n        v[order1[i]].first = i;\\n    }\\n\\n    for (int i = 0; i < order2.size(); i++)\\n    {\\n        v[order2[i]].second = i;\\n    }\\n\\n    vector<vector<int>> ans(k, vector<int>(k, 0));\\n    for (int i = 0; i < k; i++)\\n    {\\n        int x = v[i].first;\\n        int y = v[i].second;\\n        ans[x][y] = i + 1;\\n    }\\n\\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        vector<vector<int>> buildMatrix(int k, vector<vector<int>> &rowConditions, vector<vector<int>> &colConditions)\\n{\\n    vector<int> adj1[k], adj2[k];\\n    vector<int> indegree1(k, 0), indegree2(k, 0);\\n    for (auto it : rowConditions)\\n    {\\n        int u = it[0] - 1;\\n        int v = it[1] - 1;\\n        adj1[u].push_back(v);\\n        indegree1[v]++;\\n    }\\n\\n    for (auto it : colConditions)\\n    {\\n        int u = it[0] - 1;\\n        int v = it[1] - 1;\\n        adj2[u].push_back(v);\\n        indegree2[v]++;\\n    }\\n\\n    vector<int> order1, order2;\\n    queue<int> q;\\n    for (int i = 0; i < k; i++)\\n    {\\n        if (indegree1[i] == 0)\\n        {\\n            q.push(i);\\n        }\\n    }\\n\\n    while (!q.empty())\\n    {\\n        int node = q.front();\\n        q.pop();\\n        order1.push_back(node);\\n\\n        for (auto it : adj1[node])\\n        {\\n            indegree1[it]--;\\n            if (indegree1[it] == 0)\\n            {\\n                q.push(it);\\n            }\\n        }\\n    }\\n\\n    if (order1.size() < k)\\n    {\\n        return {};\\n    }\\n\\n    for (int i = 0; i < k; i++)\\n    {\\n        if (indegree2[i] == 0)\\n        {\\n            q.push(i);\\n        }\\n    }\\n\\n    while (!q.empty())\\n    {\\n        int node = q.front();\\n        q.pop();\\n        order2.push_back(node);\\n\\n        for (auto it : adj2[node])\\n        {\\n            indegree2[it]--;\\n            if (indegree2[it] == 0)\\n            {\\n                q.push(it);\\n            }\\n        }\\n    }\\n\\n    if (order2.size() < k)\\n    {\\n        return {};\\n    }\\n\\n    vector<pair<int, int>> v(k);\\n    for (int i = 0; i < order1.size(); i++)\\n    {\\n        v[order1[i]].first = i;\\n    }\\n\\n    for (int i = 0; i < order2.size(); i++)\\n    {\\n        v[order2[i]].second = i;\\n    }\\n\\n    vector<vector<int>> ans(k, vector<int>(k, 0));\\n    for (int i = 0; i < k; i++)\\n    {\\n        int x = v[i].first;\\n        int y = v[i].second;\\n        ans[x][y] = i + 1;\\n    }\\n\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2513689,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Topological Sort With BFS***\\n\\n* ***Time Complexity :- O(V + E)***\\n\\n* ***Space Complexity :- O(V + E)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // function for finding toposort of a graph\\n    \\n    vector<int> toposort(vector<vector<int>> adj)\\n    {\\n        int V = adj.size();\\n        \\n        // find the indegree of every node\\n        \\n        vector<int> indegree(V, 0);\\n        \\n        for(int u = 0; u < V; u++)\\n        {\\n            for(auto v : adj[u])\\n            {\\n                indegree[v]++;\\n            }\\n        }\\n        \\n        // res will store the toposort order of graph\\n        \\n        vector<int> res;\\n        \\n        // push the node with indegree = 0 into q\\n        \\n        queue<int> q;\\n        \\n        for(int u = 0; u < V; u++)\\n        {\\n            if(indegree[u] == 0)\\n            {\\n                q.push(u);\\n            }\\n        }\\n        \\n        while(!q.empty())\\n        {\\n            int size = q.size();\\n            \\n            for(int k = 0; k < size; k++)\\n            {\\n                int u = q.front();\\n                \\n                q.pop();\\n                \\n                res.push_back(u);\\n                \\n                // go to adjacent nodes\\n                \\n                for(auto v : adj[u])\\n                {\\n                    indegree[v]--;\\n                    \\n                    if(indegree[v] == 0)\\n                    {\\n                        q.push(v);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // res.size() != V, it means there is cycle\\n        \\n        if(res.size() != V)\\n            return {};\\n        \\n        return res;\\n    }\\n    \\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        \\n        int n = rowConditions.size();\\n        \\n        int m = colConditions.size();\\n        \\n        // create two adjacency list one for rowConditions and other for colConditions\\n        \\n        vector<vector<int>> adj_r(k);\\n        \\n        vector<vector<int>> adj_c(k);\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int u = rowConditions[i][0];\\n            \\n            int v = rowConditions[i][1];\\n            \\n            adj_r[u - 1].push_back(v - 1);\\n        }\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            int u = colConditions[i][0];\\n            \\n            int v = colConditions[i][1];\\n            \\n            adj_c[u - 1].push_back(v - 1);\\n        }\\n        \\n        // call for toposort\\n        \\n        vector<int> row = toposort(adj_r);\\n        \\n        if(row.size() == 0)\\n        {\\n            return {};\\n        }\\n        \\n        // call for toposort\\n        \\n        vector<int> col = toposort(adj_c);\\n        \\n        if(col.size() == 0)\\n        {\\n            return {};\\n        }\\n        \\n        // create matrix\\n        \\n        // store the index of number of col in mp array\\n        \\n        vector<int> mp(k, 0);\\n        \\n        for(int i = 0; i < col.size(); i++)\\n        {\\n            mp[col[i]] = i;\\n        }\\n        \\n        vector<vector<int>> res(k, vector<int> (k, 0));\\n        \\n        for(int i = 0; i < row.size(); i++)\\n        {\\n            // find the val\\n            \\n            int val = row[i] + 1;\\n            \\n            // find the row and col\\n            \\n            int r = i;\\n            \\n            int c = mp[row[i]];\\n            \\n            // put in res matrix\\n            \\n            res[r][c] = val;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // function for finding toposort of a graph\\n    \\n    vector<int> toposort(vector<vector<int>> adj)\\n    {\\n        int V = adj.size();\\n        \\n        // find the indegree of every node\\n        \\n        vector<int> indegree(V, 0);\\n        \\n        for(int u = 0; u < V; u++)\\n        {\\n            for(auto v : adj[u])\\n            {\\n                indegree[v]++;\\n            }\\n        }\\n        \\n        // res will store the toposort order of graph\\n        \\n        vector<int> res;\\n        \\n        // push the node with indegree = 0 into q\\n        \\n        queue<int> q;\\n        \\n        for(int u = 0; u < V; u++)\\n        {\\n            if(indegree[u] == 0)\\n            {\\n                q.push(u);\\n            }\\n        }\\n        \\n        while(!q.empty())\\n        {\\n            int size = q.size();\\n            \\n            for(int k = 0; k < size; k++)\\n            {\\n                int u = q.front();\\n                \\n                q.pop();\\n                \\n                res.push_back(u);\\n                \\n                // go to adjacent nodes\\n                \\n                for(auto v : adj[u])\\n                {\\n                    indegree[v]--;\\n                    \\n                    if(indegree[v] == 0)\\n                    {\\n                        q.push(v);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // res.size() != V, it means there is cycle\\n        \\n        if(res.size() != V)\\n            return {};\\n        \\n        return res;\\n    }\\n    \\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        \\n        int n = rowConditions.size();\\n        \\n        int m = colConditions.size();\\n        \\n        // create two adjacency list one for rowConditions and other for colConditions\\n        \\n        vector<vector<int>> adj_r(k);\\n        \\n        vector<vector<int>> adj_c(k);\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int u = rowConditions[i][0];\\n            \\n            int v = rowConditions[i][1];\\n            \\n            adj_r[u - 1].push_back(v - 1);\\n        }\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            int u = colConditions[i][0];\\n            \\n            int v = colConditions[i][1];\\n            \\n            adj_c[u - 1].push_back(v - 1);\\n        }\\n        \\n        // call for toposort\\n        \\n        vector<int> row = toposort(adj_r);\\n        \\n        if(row.size() == 0)\\n        {\\n            return {};\\n        }\\n        \\n        // call for toposort\\n        \\n        vector<int> col = toposort(adj_c);\\n        \\n        if(col.size() == 0)\\n        {\\n            return {};\\n        }\\n        \\n        // create matrix\\n        \\n        // store the index of number of col in mp array\\n        \\n        vector<int> mp(k, 0);\\n        \\n        for(int i = 0; i < col.size(); i++)\\n        {\\n            mp[col[i]] = i;\\n        }\\n        \\n        vector<vector<int>> res(k, vector<int> (k, 0));\\n        \\n        for(int i = 0; i < row.size(); i++)\\n        {\\n            // find the val\\n            \\n            int val = row[i] + 1;\\n            \\n            // find the row and col\\n            \\n            int r = i;\\n            \\n            int c = mp[row[i]];\\n            \\n            // put in res matrix\\n            \\n            res[r][c] = val;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2500855,
                "title": "c-topological-sort-100-faster-0ms-easy-code-to-follow",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        vector<vector<int>> v(k,vector<int>(k,0));\\n        auto p=topo(rowConditions,k);\\n        auto q=topo(colConditions,k);\\n        if(p.size()==0 || q.size()==0)// if any of both have cycle\\n            return {};\\n        for(int i=1;i<p.size();i++)\\n        {\\n            // p[i] gives row topological index for i and q[i] gives column topological index for i\\n            v[p[i]][q[i]]=i;\\n        }\\n        return v;\\n    }\\n    vector<int> topo(vector<vector<int>>& v,int k)\\n    {\\n        vector<vector<int>> adj(k+1);\\n        for(auto x:v)\\n        {\\n            adj[x[0]].push_back(x[1]);\\n        }\\n        \\n        stack<int> s;\\n        vector<int> vis(k+1,0);\\n        for(int i=1;i<=k;i++)\\n        {\\n            if(vis[i]==0)\\n                dfs(adj,vis,s,i);\\n        }\\n        vector<int> res(k+1);\\n        int ind=0;\\n        while(!s.empty())\\n        {\\n            res[s.top()]=ind;\\n            s.pop();\\n            ind++;\\n        }\\n        // check if cycle is there or not\\n        for(int i=1;i<=k;i++)\\n        {\\n            for(auto x:adj[i])\\n            {\\n                if(res[i]>res[x])// cycle exist\\n                    return {};\\n            }\\n        }\\n        return res;\\n    }\\n    void dfs(vector<vector<int>>& adj,vector<int>& vis,stack<int>& s,int i)\\n    {\\n        vis[i]=1;\\n        for(auto x:adj[i])\\n        {\\n            if(vis[x]==0)\\n                dfs(adj,vis,s,x);\\n        }\\n        s.push(i);// recursively put the parent in top of the child\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        vector<vector<int>> v(k,vector<int>(k,0));\\n        auto p=topo(rowConditions,k);\\n        auto q=topo(colConditions,k);\\n        if(p.size()==0 || q.size()==0)// if any of both have cycle\\n            return {};\\n        for(int i=1;i<p.size();i++)\\n        {\\n            // p[i] gives row topological index for i and q[i] gives column topological index for i\\n            v[p[i]][q[i]]=i;\\n        }\\n        return v;\\n    }\\n    vector<int> topo(vector<vector<int>>& v,int k)\\n    {\\n        vector<vector<int>> adj(k+1);\\n        for(auto x:v)\\n        {\\n            adj[x[0]].push_back(x[1]);\\n        }\\n        \\n        stack<int> s;\\n        vector<int> vis(k+1,0);\\n        for(int i=1;i<=k;i++)\\n        {\\n            if(vis[i]==0)\\n                dfs(adj,vis,s,i);\\n        }\\n        vector<int> res(k+1);\\n        int ind=0;\\n        while(!s.empty())\\n        {\\n            res[s.top()]=ind;\\n            s.pop();\\n            ind++;\\n        }\\n        // check if cycle is there or not\\n        for(int i=1;i<=k;i++)\\n        {\\n            for(auto x:adj[i])\\n            {\\n                if(res[i]>res[x])// cycle exist\\n                    return {};\\n            }\\n        }\\n        return res;\\n    }\\n    void dfs(vector<vector<int>>& adj,vector<int>& vis,stack<int>& s,int i)\\n    {\\n        vis[i]=1;\\n        for(auto x:adj[i])\\n        {\\n            if(vis[x]==0)\\n                dfs(adj,vis,s,x);\\n        }\\n        s.push(i);// recursively put the parent in top of the child\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2498926,
                "title": "c-kahn-s-algo-topological-sort-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> kahn(vector<vector<int>>conditions, int k)\\n    {\\n        vector<int>graph[k+1];\\n        vector<int>degree(k+1,0);\\n        vector<int>ans;\\n        queue<int>q;\\n        for(vector<int>condition : conditions)\\n        {\\n            graph[condition[0]].push_back(condition[1]);\\n            degree[condition[1]]++;\\n        }\\n        for(int i=1;i<k;i++) { if(degree[i]==0) q.push(i); }\\n        while(!q.empty())\\n        {\\n            int node = q.front(); \\n            ans.push_back(node); \\n            q.pop();\\n            for(int neighbour : graph[node]) \\n            {   \\n                degree[neighbour]--;   \\n                if(degree[neighbour]==0)\\n                {\\n                    q.push(neighbour);\\n                }\\n            }\\n        }\\n        \\n        return ans;       \\n    }\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        vector<int>row_order = kahn(rowConditions, k+1); \\n        vector<int>col_order = kahn(colConditions, k+1); \\n        \\n        unordered_map<int,int>m;\\n        if(row_order.size()<k || col_order.size() <k)return  {};\\n        vector<vector<int>>ans(k,vector<int>(k,0));\\n        \\n        for(int i=0;i<k;i++)\\n        {\\n            m[col_order[i]] = i;\\n        }\\n        \\n        for(int i=0;i<k;i++)\\n        {\\n            int column_position = m[row_order[i]]; \\n            ans[i][column_position] = row_order[i];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Please upvote if it was helpful for you, thank you!**",
                "solutionTags": [
                    "C",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> kahn(vector<vector<int>>conditions, int k)\\n    {\\n        vector<int>graph[k+1];\\n        vector<int>degree(k+1,0);\\n        vector<int>ans;\\n        queue<int>q;\\n        for(vector<int>condition : conditions)\\n        {\\n            graph[condition[0]].push_back(condition[1]);\\n            degree[condition[1]]++;\\n        }\\n        for(int i=1;i<k;i++) { if(degree[i]==0) q.push(i); }\\n        while(!q.empty())\\n        {\\n            int node = q.front(); \\n            ans.push_back(node); \\n            q.pop();\\n            for(int neighbour : graph[node]) \\n            {   \\n                degree[neighbour]--;   \\n                if(degree[neighbour]==0)\\n                {\\n                    q.push(neighbour);\\n                }\\n            }\\n        }\\n        \\n        return ans;       \\n    }\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        vector<int>row_order = kahn(rowConditions, k+1); \\n        vector<int>col_order = kahn(colConditions, k+1); \\n        \\n        unordered_map<int,int>m;\\n        if(row_order.size()<k || col_order.size() <k)return  {};\\n        vector<vector<int>>ans(k,vector<int>(k,0));\\n        \\n        for(int i=0;i<k;i++)\\n        {\\n            m[col_order[i]] = i;\\n        }\\n        \\n        for(int i=0;i<k;i++)\\n        {\\n            int column_position = m[row_order[i]]; \\n            ans[i][column_position] = row_order[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2498268,
                "title": "kotlin-topological-sort-kahn-s-algorithm",
                "content": "```\\nclass Solution {\\n    data class Node (var `val`: Int, val `in`: MutableList<Int>, val `out`: MutableList<Int>)\\n    fun buildMatrix(k: Int, rowConditions: Array<IntArray>, colConditions: Array<IntArray>): Array<IntArray> {\\n        var rowSorted = listOf<Int>()\\n        var colSorted = listOf<Int>()\\n        for (curr in 0 until 2) {\\n            val topoSorted = mutableListOf<Node>()\\n            val nodes = Array(k + 1) { Node(it, mutableListOf(), mutableListOf()) }\\n            val conditions = if (curr == 0) rowConditions else colConditions\\n            \\n            for (i in conditions) {\\n                nodes[i[0]].out.add(i[1])\\n                nodes[i[1]].`in`.add(i[0])\\n            }\\n            val set = mutableSetOf<Node>()\\n            for (i in nodes.indices) {\\n                if (nodes[i].`in`.isEmpty()) set.add(nodes[i])\\n            }\\n            \\n            while (set.isNotEmpty()) {\\n                val n = set.first()\\n                set.remove(n)\\n                topoSorted.add(n)\\n                val out = n.out.toList()\\n                for (node in out) {\\n                    val m = nodes[node]\\n                    nodes[n.`val`].out.remove(m.`val`)\\n                    nodes[m.`val`].`in`.remove(n.`val`)\\n                    if (m.`in`.isEmpty()) set.add(m)\\n                }\\n            }\\n            \\n            var cycle = false\\n            for (i in nodes) {\\n                if (i.`in`.isNotEmpty() || i.out.isNotEmpty()) {\\n                    cycle = true\\n                    break\\n                }\\n            }\\n            if (cycle) return arrayOf()\\n            var assign = topoSorted.subList(1, topoSorted.size).map { it.`val` }\\n            if (curr == 0) rowSorted = assign\\n            else colSorted = assign\\n        }\\n    \\n        val matrix = Array(k) { IntArray(k) { 0 } }\\n        val y = HashMap<Int, Int>()\\n        val x = HashMap<Int, Int>()\\n        for (i in rowSorted.indices) {\\n            y[rowSorted[i]] = i\\n        }\\n        for (i in colSorted.indices) {\\n            x[colSorted[i]] = i\\n        }\\n        for (i in y) {\\n            val yVal = i.value\\n            val xVal = x[i.key]!!\\n            matrix[yVal][xVal] = i.key\\n        }\\n        return matrix\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    data class Node (var `val`: Int, val `in`: MutableList<Int>, val `out`: MutableList<Int>)\\n    fun buildMatrix(k: Int, rowConditions: Array<IntArray>, colConditions: Array<IntArray>): Array<IntArray> {\\n        var rowSorted = listOf<Int>()\\n        var colSorted = listOf<Int>()\\n        for (curr in 0 until 2) {\\n            val topoSorted = mutableListOf<Node>()\\n            val nodes = Array(k + 1) { Node(it, mutableListOf(), mutableListOf()) }\\n            val conditions = if (curr == 0) rowConditions else colConditions\\n            \\n            for (i in conditions) {\\n                nodes[i[0]].out.add(i[1])\\n                nodes[i[1]].`in`.add(i[0])\\n            }\\n            val set = mutableSetOf<Node>()\\n            for (i in nodes.indices) {\\n                if (nodes[i].`in`.isEmpty()) set.add(nodes[i])\\n            }\\n            \\n            while (set.isNotEmpty()) {\\n                val n = set.first()\\n                set.remove(n)\\n                topoSorted.add(n)\\n                val out = n.out.toList()\\n                for (node in out) {\\n                    val m = nodes[node]\\n                    nodes[n.`val`].out.remove(m.`val`)\\n                    nodes[m.`val`].`in`.remove(n.`val`)\\n                    if (m.`in`.isEmpty()) set.add(m)\\n                }\\n            }\\n            \\n            var cycle = false\\n            for (i in nodes) {\\n                if (i.`in`.isNotEmpty() || i.out.isNotEmpty()) {\\n                    cycle = true\\n                    break\\n                }\\n            }\\n            if (cycle) return arrayOf()\\n            var assign = topoSorted.subList(1, topoSorted.size).map { it.`val` }\\n            if (curr == 0) rowSorted = assign\\n            else colSorted = assign\\n        }\\n    \\n        val matrix = Array(k) { IntArray(k) { 0 } }\\n        val y = HashMap<Int, Int>()\\n        val x = HashMap<Int, Int>()\\n        for (i in rowSorted.indices) {\\n            y[rowSorted[i]] = i\\n        }\\n        for (i in colSorted.indices) {\\n            x[colSorted[i]] = i\\n        }\\n        for (i in y) {\\n            val yVal = i.value\\n            val xVal = x[i.key]!!\\n            matrix[yVal][xVal] = i.key\\n        }\\n        return matrix\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2493862,
                "title": "c-graph-solution",
                "content": "```cpp\\nint rowIdx[500], colIdx[500];\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>> &rowConditions, vector<vector<int>> &colConditions) {\\n        int n = rowConditions.size(), m = colConditions.size();\\n        fill(rowIdx, rowIdx + k + 1, 0);\\n        fill(colIdx, colIdx + k + 1, 0);\\n        vector<vector<int>> rGraph(k + 1), cGraph(k + 1);\\n        for (int i = 0; i < n; i++) {\\n            rowIdx[rowConditions[i][1]]++;\\n            rGraph[rowConditions[i][0]].push_back(rowConditions[i][1]);\\n        }\\n        for (int i = 0; i < m; i++) {\\n            colIdx[colConditions[i][1]]++;\\n            cGraph[colConditions[i][0]].push_back(colConditions[i][1]);\\n        }\\n        queue<int> cq, rq;\\n        for (int i = 1; i <= k; i++) {\\n            if (rowIdx[i] == 0) rq.push(i);\\n            if (colIdx[i] == 0) cq.push(i);\\n        }\\n        vector<int> rows(k + 1), cols(k + 1);\\n        int cnt = 0;\\n        while (!cq.empty()) {\\n            int i = cq.front();\\n            cq.pop();\\n            cols[i] = cnt++;\\n            for (int j : cGraph[i]) {\\n                colIdx[j]--;\\n                if (colIdx[j] == 0) {\\n                    cq.push(j);\\n                }\\n            }\\n        }\\n        if (cnt != k) return {};\\n        cnt = 0;\\n        while (!rq.empty()) {\\n            int i = rq.front();\\n            rq.pop();\\n            rows[i] = cnt++;\\n            for (int j : rGraph[i]) {\\n                rowIdx[j]--;\\n                if (rowIdx[j] == 0) {\\n                    rq.push(j);\\n                }\\n            }\\n        }\\n        if (cnt != k) return {};\\n        vector<vector<int>> res(k, vector<int>(k, 0));\\n        for (int i = 1; i <= k; i++) {\\n            res[rows[i]][cols[i]] = i;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Graph"
                ],
                "code": "```cpp\\nint rowIdx[500], colIdx[500];\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>> &rowConditions, vector<vector<int>> &colConditions) {\\n        int n = rowConditions.size(), m = colConditions.size();\\n        fill(rowIdx, rowIdx + k + 1, 0);\\n        fill(colIdx, colIdx + k + 1, 0);\\n        vector<vector<int>> rGraph(k + 1), cGraph(k + 1);\\n        for (int i = 0; i < n; i++) {\\n            rowIdx[rowConditions[i][1]]++;\\n            rGraph[rowConditions[i][0]].push_back(rowConditions[i][1]);\\n        }\\n        for (int i = 0; i < m; i++) {\\n            colIdx[colConditions[i][1]]++;\\n            cGraph[colConditions[i][0]].push_back(colConditions[i][1]);\\n        }\\n        queue<int> cq, rq;\\n        for (int i = 1; i <= k; i++) {\\n            if (rowIdx[i] == 0) rq.push(i);\\n            if (colIdx[i] == 0) cq.push(i);\\n        }\\n        vector<int> rows(k + 1), cols(k + 1);\\n        int cnt = 0;\\n        while (!cq.empty()) {\\n            int i = cq.front();\\n            cq.pop();\\n            cols[i] = cnt++;\\n            for (int j : cGraph[i]) {\\n                colIdx[j]--;\\n                if (colIdx[j] == 0) {\\n                    cq.push(j);\\n                }\\n            }\\n        }\\n        if (cnt != k) return {};\\n        cnt = 0;\\n        while (!rq.empty()) {\\n            int i = rq.front();\\n            rq.pop();\\n            rows[i] = cnt++;\\n            for (int j : rGraph[i]) {\\n                rowIdx[j]--;\\n                if (rowIdx[j] == 0) {\\n                    rq.push(j);\\n                }\\n            }\\n        }\\n        if (cnt != k) return {};\\n        vector<vector<int>> res(k, vector<int>(k, 0));\\n        for (int i = 1; i <= k; i++) {\\n            res[rows[i]][cols[i]] = i;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2493516,
                "title": "c-quick-explained-code-topo-sort-kahn-s-algo",
                "content": "**Thought Process:**\\n* This is an interesting problem, specially to see how graph helps solve this.\\n* Reading the problem with the `rowConditions` and `columnConditions` does give the hint that applying topological sort would make sense here.\\n* So we do the topo sort, and sparsely set the index across columns. Together, we apply it on rows and get one of the possible combinations.\\n* **Edge case**: We can check if building matrix is not possible, which is when graph is cyclic i.e.  `topo output size != N`.\\n\\n```cpp\\nvector<int> topoSort(vector<vector<int>> conditions, int k){\\n    vector<int> indegree(k+1);\\n    unordered_map<int, vector<int>> graph;\\n\\n    //building graph and indegree\\n    for(auto cond: conditions){\\n        graph[cond[0]].push_back(cond[1]);\\n        indegree[cond[1]]++;\\n    }\\n\\n    //building the topo sort queue (0 degree nodes)\\n    queue<int> q;\\n    for(int i=1; i <= k; i++){\\n        if(indegree[i] == 0)\\n            q.push(i);\\n    }\\n\\n    //building the topo ordered output\\n    vector<int> res;\\n    while(!q.empty()){\\n        int node = q.front(); q.pop();\\n        res.push_back(node);\\n\\n        for(int child: graph[node]){\\n            indegree[child]--;\\n            if(indegree[child] == 0)\\n                q.push(child);\\n        }\\n    }\\n    return res;\\n}\\n\\nvector<vector<int>> buildMatrix(int k, vector<vector<int>>& RowConditions, vector<vector<int>>& ColConditions) {\\n    vector<int> rows = topoSort(RowConditions, k),\\n                cols = topoSort(ColConditions, k);\\n\\n    // Acc to Kahn\\'s algo, if topo output size != N, then it\\'s cyclic\\n    if(rows.size() != k || cols.size() != k) return {};\\n\\n    vector<vector<int>> res(k, vector<int>(k, 0));\\n    vector<int> colIdx(k+1, 0);\\n\\n    // The cols array has [most dependent,.. -> ..,least dependent elemts]\\n    // For colConditions = [[2,1],[3,2]], it will be [3,2,1]\\n    // val 3 -> idx 0\\n    // val 2 -> idx 1\\n    // val 1 -> idx 2\\n    for(int j=0; j < k; j++)\\n        colIdx[cols[j]] = j;\\n\\n    // In each row, place the \"row[i]\" value at the j th index, \\n    // we sparsely allocated just above.\\n    for(int i=0; i < k; i++)\\n        res[i][colIdx[rows[i]]] = rows[i];\\n\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```cpp\\nvector<int> topoSort(vector<vector<int>> conditions, int k){\\n    vector<int> indegree(k+1);\\n    unordered_map<int, vector<int>> graph;\\n\\n    //building graph and indegree\\n    for(auto cond: conditions){\\n        graph[cond[0]].push_back(cond[1]);\\n        indegree[cond[1]]++;\\n    }\\n\\n    //building the topo sort queue (0 degree nodes)\\n    queue<int> q;\\n    for(int i=1; i <= k; i++){\\n        if(indegree[i] == 0)\\n            q.push(i);\\n    }\\n\\n    //building the topo ordered output\\n    vector<int> res;\\n    while(!q.empty()){\\n        int node = q.front(); q.pop();\\n        res.push_back(node);\\n\\n        for(int child: graph[node]){\\n            indegree[child]--;\\n            if(indegree[child] == 0)\\n                q.push(child);\\n        }\\n    }\\n    return res;\\n}\\n\\nvector<vector<int>> buildMatrix(int k, vector<vector<int>>& RowConditions, vector<vector<int>>& ColConditions) {\\n    vector<int> rows = topoSort(RowConditions, k),\\n                cols = topoSort(ColConditions, k);\\n\\n    // Acc to Kahn\\'s algo, if topo output size != N, then it\\'s cyclic\\n    if(rows.size() != k || cols.size() != k) return {};\\n\\n    vector<vector<int>> res(k, vector<int>(k, 0));\\n    vector<int> colIdx(k+1, 0);\\n\\n    // The cols array has [most dependent,.. -> ..,least dependent elemts]\\n    // For colConditions = [[2,1],[3,2]], it will be [3,2,1]\\n    // val 3 -> idx 0\\n    // val 2 -> idx 1\\n    // val 1 -> idx 2\\n    for(int j=0; j < k; j++)\\n        colIdx[cols[j]] = j;\\n\\n    // In each row, place the \"row[i]\" value at the j th index, \\n    // we sparsely allocated just above.\\n    for(int i=0; i < k; i++)\\n        res[i][colIdx[rows[i]]] = rows[i];\\n\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2493258,
                "title": "java-topological-sort-14ms-50-7mb",
                "content": "As the best approach in 210. Course Schedule II, we can replace HashMap with ArrayList[].\\n```\\nclass Solution {\\n    public int[][] buildMatrix(int k, int[][] rowConditions, int[][] colConditions) {\\n        Map<Integer, List<Integer>> mapR = new HashMap<>();\\n        Map<Integer, List<Integer>> mapC = new HashMap<>();\\n        int[] indR = new int[k];\\n        int[] indC = new int[k];\\n        List<Integer> oR = new ArrayList<>();\\n        List<Integer> oC = new ArrayList<>();\\n        for (int i = 0; i < rowConditions.length; i++) {\\n            int f = rowConditions[i][0];\\n            int s = rowConditions[i][1];\\n            mapR.putIfAbsent(f, new ArrayList<>());\\n            mapR.get(f).add(s);\\n            indR[s - 1]++;\\n        }\\n        for (int i = 0; i < colConditions.length; i++) {\\n            int f = colConditions[i][0];\\n            int s = colConditions[i][1];\\n            mapC.putIfAbsent(f, new ArrayList<>());\\n            mapC.get(f).add(s);\\n            indC[s - 1]++;\\n        }\\n        for (int i = 0; i < indR.length; i++) {\\n            if (indR[i] == 0) {\\n                oR.add(i + 1);\\n            }\\n        }\\n        for (int i = 0; i < oR.size(); i++) {\\n            if (!mapR.containsKey(oR.get(i))) {\\n                continue;\\n            }\\n            for (int num : mapR.get(oR.get(i))) {\\n                if (--indR[num - 1] == 0) {\\n                    oR.add(num);\\n                }\\n            }\\n        }\\n        for (int i = 0; i < indC.length; i++) {\\n            if (indC[i] == 0) {\\n                oC.add(i + 1);\\n            }\\n        }\\n        for (int i = 0; i < oC.size(); i++) {\\n            if (!mapC.containsKey(oC.get(i))) {\\n                continue;\\n            }\\n            for (int num : mapC.get(oC.get(i))) {\\n                if (--indC[num - 1] == 0) {\\n                    oC.add(num);\\n                }\\n            }\\n        }\\n        if (oR.size() != k || oC.size() != k) {\\n            return new int[0][0];\\n        }\\n        int[][] ans = new int[k][k];\\n        Map<Integer, Integer> rel = new HashMap<>();\\n        for (int i = 0; i < k; i++) {\\n            ans[k - 1][i] = oC.get(i);\\n            rel.put(oC.get(i), i);\\n        }\\n        for (int i = 0; i < oR.size() - 1; i++) {\\n            int tmp = oR.get(i);\\n            int col = rel.get(tmp);\\n            ans[i][col] = tmp;\\n            ans[k - 1][col] = 0;\\n        }\\n        return ans;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] buildMatrix(int k, int[][] rowConditions, int[][] colConditions) {\\n        Map<Integer, List<Integer>> mapR = new HashMap<>();\\n        Map<Integer, List<Integer>> mapC = new HashMap<>();\\n        int[] indR = new int[k];\\n        int[] indC = new int[k];\\n        List<Integer> oR = new ArrayList<>();\\n        List<Integer> oC = new ArrayList<>();\\n        for (int i = 0; i < rowConditions.length; i++) {\\n            int f = rowConditions[i][0];\\n            int s = rowConditions[i][1];\\n            mapR.putIfAbsent(f, new ArrayList<>());\\n            mapR.get(f).add(s);\\n            indR[s - 1]++;\\n        }\\n        for (int i = 0; i < colConditions.length; i++) {\\n            int f = colConditions[i][0];\\n            int s = colConditions[i][1];\\n            mapC.putIfAbsent(f, new ArrayList<>());\\n            mapC.get(f).add(s);\\n            indC[s - 1]++;\\n        }\\n        for (int i = 0; i < indR.length; i++) {\\n            if (indR[i] == 0) {\\n                oR.add(i + 1);\\n            }\\n        }\\n        for (int i = 0; i < oR.size(); i++) {\\n            if (!mapR.containsKey(oR.get(i))) {\\n                continue;\\n            }\\n            for (int num : mapR.get(oR.get(i))) {\\n                if (--indR[num - 1] == 0) {\\n                    oR.add(num);\\n                }\\n            }\\n        }\\n        for (int i = 0; i < indC.length; i++) {\\n            if (indC[i] == 0) {\\n                oC.add(i + 1);\\n            }\\n        }\\n        for (int i = 0; i < oC.size(); i++) {\\n            if (!mapC.containsKey(oC.get(i))) {\\n                continue;\\n            }\\n            for (int num : mapC.get(oC.get(i))) {\\n                if (--indC[num - 1] == 0) {\\n                    oC.add(num);\\n                }\\n            }\\n        }\\n        if (oR.size() != k || oC.size() != k) {\\n            return new int[0][0];\\n        }\\n        int[][] ans = new int[k][k];\\n        Map<Integer, Integer> rel = new HashMap<>();\\n        for (int i = 0; i < k; i++) {\\n            ans[k - 1][i] = oC.get(i);\\n            rel.put(oC.get(i), i);\\n        }\\n        for (int i = 0; i < oR.size() - 1; i++) {\\n            int tmp = oR.get(i);\\n            int col = rel.get(tmp);\\n            ans[i][col] = tmp;\\n            ans[k - 1][col] = 0;\\n        }\\n        return ans;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969746,
                "title": "topo-sort-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1)concept is to find topo_sort for row and col...\\n2)iterate from topo_sort of row elements and find its corresponding pos in topo_sort of col\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: Time complexity of topo sort\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity: O(k*k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n \\n\\n# Code\\n```\\nclass Solution:\\n    def buildMatrix(self, k: int, row: List[List[int]], col: List[List[int]]) -> List[List[int]]:\\n        adj_l_A = [[] for i in range(k+1)]\\n        indegree_A = [0]*(k+1)\\n        for u,v in row:\\n            adj_l_A[u].append(v)\\n            indegree_A[v]+=1\\n        queue1 = []\\n        for i in range(1,k+1):\\n            if indegree_A[i]==0:\\n                queue1.append(i)\\n        adj_l_B = [[] for i in range(k+1)]\\n        indegree_B = [0]*(k+1)\\n        for u ,v in col:\\n            adj_l_B[u].append(v)\\n            indegree_B[v]+=1\\n        queue2 = []\\n        for i in range(1,k+1):\\n            if indegree_B[i]==0:\\n                queue2.append(i)\\n\\n\\n        \\n        def topo_sort(queue,res,adj_list,indegree):\\n            while queue:\\n                curr = queue.pop(0)\\n                res.append(curr)\\n                for i in adj_list[curr]:\\n                    indegree[i]-=1\\n                    if indegree[i]==0:\\n                        queue.append(i)\\n            return res\\n        Row = topo_sort(queue1,[],adj_l_A,indegree_A)\\n        Col = topo_sort(queue2,[],adj_l_B,indegree_B)\\n        if len(Row)==k and len(Col)==k:\\n            grid = [[0 for i in range(k)] for j in range(k)]\\n            ind = {}\\n            for i in range(k):\\n                ind[Col[i]] = i\\n            for i in range(k):\\n                j = ind[Row[i]]\\n                grid[i][j] = Row[i]\\n            return grid\\n        return []\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def buildMatrix(self, k: int, row: List[List[int]], col: List[List[int]]) -> List[List[int]]:\\n        adj_l_A = [[] for i in range(k+1)]\\n        indegree_A = [0]*(k+1)\\n        for u,v in row:\\n            adj_l_A[u].append(v)\\n            indegree_A[v]+=1\\n        queue1 = []\\n        for i in range(1,k+1):\\n            if indegree_A[i]==0:\\n                queue1.append(i)\\n        adj_l_B = [[] for i in range(k+1)]\\n        indegree_B = [0]*(k+1)\\n        for u ,v in col:\\n            adj_l_B[u].append(v)\\n            indegree_B[v]+=1\\n        queue2 = []\\n        for i in range(1,k+1):\\n            if indegree_B[i]==0:\\n                queue2.append(i)\\n\\n\\n        \\n        def topo_sort(queue,res,adj_list,indegree):\\n            while queue:\\n                curr = queue.pop(0)\\n                res.append(curr)\\n                for i in adj_list[curr]:\\n                    indegree[i]-=1\\n                    if indegree[i]==0:\\n                        queue.append(i)\\n            return res\\n        Row = topo_sort(queue1,[],adj_l_A,indegree_A)\\n        Col = topo_sort(queue2,[],adj_l_B,indegree_B)\\n        if len(Row)==k and len(Col)==k:\\n            grid = [[0 for i in range(k)] for j in range(k)]\\n            ind = {}\\n            for i in range(k):\\n                ind[Col[i]] = i\\n            for i in range(k):\\n                j = ind[Row[i]]\\n                grid[i][j] = Row[i]\\n            return grid\\n        return []\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3720663,
                "title": "c-basic-topological-sort-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn this problem we are given \\'k\\' number of elements that is 1 through k\\nalong with the relative order between some of the elements\\nthe order is given in two formats that is row-wise and column-wise which we need to maintain in the resultant matrix\\nIf we assume these k elements to be a part of two graphs:-\\nrowAdj & colAdj where rowConditions contains the directed edges {u, v} such that there is an edge from u to v for the graph rowAdj and colConditions contains the same for colAdj\\nThen this problem can be seen as a topological sorting problem\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst we create the graphs rowAdj and colAdj based on rowConditions and colConditions respectivly\\nAfter that we check for cycles in both the graphs\\nIf there exists any cycle in any of the newly obtained graphs, we will return an empty 2D matrix because topoSort is not possible in that case\\nafter we have obtained the topological sort for both the graphs, we record the appropriate positions of these elements in the vector rowOrder for rowAdj and colOrder for colAdj\\nNow that we have the positions for these elements in the matrix we can easily construct the matrix.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(rowConditions.length + colConditions.length + k)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(k * k)$$\\n\\n# Code\\n```\\nclass Compare {\\npublic:\\n    bool operator()(vector<int> below, vector<int> above) {\\n        return above[0] > below[0];\\n    }\\n};\\n\\nclass Solution {\\n\\n    bool isCyclic(vector<int>* adj, int cur, vector<bool>& dfsvis, vector<bool>& vis) {\\n        if(dfsvis[cur]) {\\n            return true;\\n        }\\n\\n        if(vis[cur]) {\\n            return false;\\n        }\\n        vis[cur] = true;\\n\\n        bool cyclic = false;\\n        dfsvis[cur] = true;\\n        for(int x: adj[cur]) {\\n            cyclic |= isCyclic(adj, x, dfsvis, vis);\\n        }\\n        dfsvis[cur] = false;\\n\\n        return cyclic;\\n    }\\n\\n    void topoSort(stack<int>& sortedElements, vector<int>* adj, int curr, vector<bool>& vis) {\\n        if(vis[curr]) {\\n            return;\\n        }\\n        vis[curr] = true;\\n\\n        for(int x: adj[curr]) {\\n            topoSort(sortedElements, adj, x, vis);\\n        }\\n        sortedElements.push(curr + 1);\\n    }\\n\\npublic:\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        \\n        vector<vector<int>> temp;\\n\\n\\n        vector<int> rowAdj[k];\\n        vector<int> rowOutDegree(k, 0);\\n        priority_queue<vector<int>, vector<vector<int>>, Compare> rowPQ;\\n        vector<bool> row1Vis(k, false);\\n        vector<bool> row1DfsVis(k, false);\\n        for(auto x: rowConditions) {\\n            rowAdj[x[0] - 1].push_back(x[1] - 1);\\n            rowOutDegree[x[0] - 1]++;\\n            rowOutDegree[x[1] - 1]--;\\n        }\\n\\n        for(int i = 0; i < k; i++) {\\n            if(isCyclic(rowAdj, i, row1DfsVis, row1Vis)) {\\n                return temp;\\n            }\\n        }\\n\\n        for(int i = 0; i < k; i++) {\\n            rowPQ.push({rowOutDegree[i], i});\\n        }\\n\\n        vector<int> colAdj[k];\\n        vector<int> colOutDegree(k, 0);\\n        priority_queue<vector<int>, vector<vector<int>>, Compare> colPQ;\\n        vector<bool> col1Vis(k, false);\\n        vector<bool> col1DfsVis(k, false);\\n        for(auto x: colConditions) {\\n            colAdj[x[0] - 1].push_back(x[1] - 1);\\n            colOutDegree[x[0] - 1]++;\\n            colOutDegree[x[1] - 1]--;\\n        }\\n\\n        for(int i = 0; i < k; i++) {\\n            if(isCyclic(colAdj, i, col1DfsVis, col1Vis)) {\\n                return temp;\\n            }\\n        }\\n\\n        for(int i = 0; i < k; i++) {\\n            colPQ.push({colOutDegree[i], i});\\n        }\\n\\n        stack<int> rowSortedElements;\\n        vector<bool> rowVis(k, false);\\n        stack<int> colSortedElements;\\n        vector<bool> colVis(k, false);\\n\\n        while(!rowPQ.empty()) {\\n            int node1 = rowPQ.top()[1];\\n            rowPQ.pop();\\n            if(!rowVis[node1]) {\\n                topoSort(rowSortedElements, rowAdj, node1, rowVis);\\n            }\\n            int node2 = colPQ.top()[1];\\n            colPQ.pop();\\n            if(!colVis[node2]) {\\n                topoSort(colSortedElements, colAdj, node2, colVis);\\n            }\\n        }\\n\\n        vector<int> rowOrder(k+1);\\n        vector<int> colOrder(k+1);\\n        while(!rowSortedElements.empty()) {\\n            rowOrder[rowSortedElements.top()] = k - rowSortedElements.size();\\n            rowSortedElements.pop();\\n            colOrder[colSortedElements.top()] = k - colSortedElements.size();\\n            colSortedElements.pop();\\n        }\\n        \\n        vector<vector<int>> ans(k, vector<int>(k, 0));\\n\\n        for(int i = 1; i <= k; i++) {\\n            ans[rowOrder[i]][colOrder[i]] = i;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph",
                    "Topological Sort",
                    "Matrix"
                ],
                "code": "```\\nclass Compare {\\npublic:\\n    bool operator()(vector<int> below, vector<int> above) {\\n        return above[0] > below[0];\\n    }\\n};\\n\\nclass Solution {\\n\\n    bool isCyclic(vector<int>* adj, int cur, vector<bool>& dfsvis, vector<bool>& vis) {\\n        if(dfsvis[cur]) {\\n            return true;\\n        }\\n\\n        if(vis[cur]) {\\n            return false;\\n        }\\n        vis[cur] = true;\\n\\n        bool cyclic = false;\\n        dfsvis[cur] = true;\\n        for(int x: adj[cur]) {\\n            cyclic |= isCyclic(adj, x, dfsvis, vis);\\n        }\\n        dfsvis[cur] = false;\\n\\n        return cyclic;\\n    }\\n\\n    void topoSort(stack<int>& sortedElements, vector<int>* adj, int curr, vector<bool>& vis) {\\n        if(vis[curr]) {\\n            return;\\n        }\\n        vis[curr] = true;\\n\\n        for(int x: adj[curr]) {\\n            topoSort(sortedElements, adj, x, vis);\\n        }\\n        sortedElements.push(curr + 1);\\n    }\\n\\npublic:\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        \\n        vector<vector<int>> temp;\\n\\n\\n        vector<int> rowAdj[k];\\n        vector<int> rowOutDegree(k, 0);\\n        priority_queue<vector<int>, vector<vector<int>>, Compare> rowPQ;\\n        vector<bool> row1Vis(k, false);\\n        vector<bool> row1DfsVis(k, false);\\n        for(auto x: rowConditions) {\\n            rowAdj[x[0] - 1].push_back(x[1] - 1);\\n            rowOutDegree[x[0] - 1]++;\\n            rowOutDegree[x[1] - 1]--;\\n        }\\n\\n        for(int i = 0; i < k; i++) {\\n            if(isCyclic(rowAdj, i, row1DfsVis, row1Vis)) {\\n                return temp;\\n            }\\n        }\\n\\n        for(int i = 0; i < k; i++) {\\n            rowPQ.push({rowOutDegree[i], i});\\n        }\\n\\n        vector<int> colAdj[k];\\n        vector<int> colOutDegree(k, 0);\\n        priority_queue<vector<int>, vector<vector<int>>, Compare> colPQ;\\n        vector<bool> col1Vis(k, false);\\n        vector<bool> col1DfsVis(k, false);\\n        for(auto x: colConditions) {\\n            colAdj[x[0] - 1].push_back(x[1] - 1);\\n            colOutDegree[x[0] - 1]++;\\n            colOutDegree[x[1] - 1]--;\\n        }\\n\\n        for(int i = 0; i < k; i++) {\\n            if(isCyclic(colAdj, i, col1DfsVis, col1Vis)) {\\n                return temp;\\n            }\\n        }\\n\\n        for(int i = 0; i < k; i++) {\\n            colPQ.push({colOutDegree[i], i});\\n        }\\n\\n        stack<int> rowSortedElements;\\n        vector<bool> rowVis(k, false);\\n        stack<int> colSortedElements;\\n        vector<bool> colVis(k, false);\\n\\n        while(!rowPQ.empty()) {\\n            int node1 = rowPQ.top()[1];\\n            rowPQ.pop();\\n            if(!rowVis[node1]) {\\n                topoSort(rowSortedElements, rowAdj, node1, rowVis);\\n            }\\n            int node2 = colPQ.top()[1];\\n            colPQ.pop();\\n            if(!colVis[node2]) {\\n                topoSort(colSortedElements, colAdj, node2, colVis);\\n            }\\n        }\\n\\n        vector<int> rowOrder(k+1);\\n        vector<int> colOrder(k+1);\\n        while(!rowSortedElements.empty()) {\\n            rowOrder[rowSortedElements.top()] = k - rowSortedElements.size();\\n            rowSortedElements.pop();\\n            colOrder[colSortedElements.top()] = k - colSortedElements.size();\\n            colSortedElements.pop();\\n        }\\n        \\n        vector<vector<int>> ans(k, vector<int>(k, 0));\\n\\n        for(int i = 1; i <= k; i++) {\\n            ans[rowOrder[i]][colOrder[i]] = i;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521088,
                "title": "python-3-topological-sorting",
                "content": "\\n\\n\\n```\\n\\ndef buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:\\n        ans = [[0] * k for _ in range(k)]\\n\\t\\t\\n        def topological(condition):\\n            graph = defaultdict(list)\\n            indegree = [0] * k\\n            for a, b in condition:\\n                graph[a].append(b)\\n                indegree[b - 1] += 1\\n            \\n            que = deque()\\n            for i, val in enumerate(indegree):\\n                if val == 0:\\n                    que.append(i + 1)\\n                    \\n            order = []\\n            \\n            while que:\\n                temp = que.popleft()\\n                order.append(temp)\\n                \\n                for child in graph[temp]:\\n                    indegree[child - 1] -= 1\\n                    if indegree[child - 1] == 0:\\n                        que.append(child)\\n                        \\n            return order\\n                        \\n        row_order = topological(rowConditions)\\n        col_order = topological(colConditions)\\n        \\n        #cycle detection\\n        if len(row_order) < k or len(col_order) < k:\\n            return []\\n        \\n        for row, val in enumerate(row_order):\\n            col = col_order.index(val)\\n            ans[row][col] = val\\n            \\n        return ans\\n",
                "solutionTags": [
                    "Python3",
                    "Topological Sort"
                ],
                "code": "\\n\\n\\n```\\n\\ndef buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:\\n        ans = [[0] * k for _ in range(k)]\\n\\t\\t\\n        def topological(condition):\\n            graph = defaultdict(list)\\n            indegree = [0] * k\\n            for a, b in condition:\\n                graph[a].append(b)\\n                indegree[b - 1] += 1\\n            \\n            que = deque()\\n            for i, val in enumerate(indegree):\\n                if val == 0:\\n                    que.append(i + 1)\\n                    \\n            order = []\\n            \\n            while que:\\n                temp = que.popleft()\\n                order.append(temp)\\n                \\n                for child in graph[temp]:\\n                    indegree[child - 1] -= 1\\n                    if indegree[child - 1] == 0:\\n                        que.append(child)\\n                        \\n            return order\\n                        \\n        row_order = topological(rowConditions)\\n        col_order = topological(colConditions)\\n        \\n        #cycle detection\\n        if len(row_order) < k or len(col_order) < k:\\n            return []\\n        \\n        for row, val in enumerate(row_order):\\n            col = col_order.index(val)\\n            ans[row][col] = val\\n            \\n        return ans\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2630556,
                "title": "c-easy-to-undersatand-step-by-step",
                "content": "```\\nclass Solution {\\n    vector<int> top_sorting(vector<vector<int>> con, int k) {\\n        vector<int> indegree(k+1, 0);\\n        vector<vector<int>> graph(k+1);\\n        for(auto &it: con) {\\n            indegree[it[1]] += 1;\\n            graph[it[0]].push_back(it[1]);\\n        }\\n        \\n        vector<int> ans;\\n        queue<int> q;\\n        for(int i = 1; i <= k; i++) {\\n            if(indegree[i] == 0)\\n                q.push(i);\\n        }\\n        \\n        while(!q.empty()) {\\n            int u = q.front();\\n            q.pop();\\n            ans.push_back(u);\\n            for(int v: graph[u]) {\\n                indegree[v]--;\\n                if(indegree[v] == 0) \\n                    q.push(v);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\npublic:\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowC, vector<vector<int>>& colC) {\\n        vector<int> rowOrder = top_sorting(rowC, k);\\n        vector<int> colOrder = top_sorting(colC, k);\\n        \\n        // check cycle\\n        if(rowOrder.size() != k || colOrder.size() != k)\\n            return {};        \\n\\t\\t\\t\\n        // row index and col index of i\\n        vector<int> r(k+1), c(k+1);\\n        for(int i = 0; i < k; i++) {\\n            r[rowOrder[i]] = i;\\n            c[colOrder[i]] = i;\\n        }\\n        \\n        vector<vector<int>> ans(k, vector<int>(k, 0));\\n        for(int i = 1; i <= k; i++) \\n            ans[r[i]][c[i]] = i;\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    vector<int> top_sorting(vector<vector<int>> con, int k) {\\n        vector<int> indegree(k+1, 0);\\n        vector<vector<int>> graph(k+1);\\n        for(auto &it: con) {\\n            indegree[it[1]] += 1;\\n            graph[it[0]].push_back(it[1]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2505868,
                "title": "c-unique-using-topological-sort-kahn-s-algo",
                "content": "I would say first go through topological sorting if you are unaware of that, then this question bacomes very easy\\n```\\nclass Solution {\\npublic:\\n//here bool function checks if cycle is present or not\\n    bool toposort(int n,unordered_map<int,pair<int,int>> &map,vector<int> adj[],int idx,int curr){\\n        queue<int> q;\\n        vector<int> indegree(n+1,0);\\n        for(int i=1;i<=n;i++){\\n            for(auto it:adj[i]){\\n                indegree[it]++;\\n            }\\n        }\\n        for(int i=1;i<=n;i++){\\n            if(indegree[i]==0)q.push(i);\\n        }\\n        int cnt=0;\\n        while(!q.empty()){\\n            int node=q.front();q.pop();\\n            cnt++;\\n            //topo.push_back(node);\\n            int x=map[node].first, y=map[node].second;\\n            if(curr==1){\\n                map[node].first=idx++;\\n            }\\n            else{\\n                map[node].second=idx++;\\n            }\\n            for(auto it:adj[node]){\\n                indegree[it]--;\\n                if(indegree[it]==0){\\n                    q.push(it);\\n                }\\n            }\\n        }\\n        if(cnt==n)return true;//cycle not present\\n        return false;//cycle present\\n    }\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& r, vector<vector<int>>& c) {\\n        //topological sort by kahn\\'s algorithm\\n        vector<vector<int>> mat(k,vector<int> (k,0)),ans;\\n        vector<int> adj[k+1],adj1[k+1];\\n        for(auto it:r){\\n            adj[it[0]].push_back(it[1]);\\n        }\\n        //vector<int> topoR,topoC;\\n        unordered_map<int,pair<int,int>> map;\\n        for(int i=1;i<=k;i++)map.insert({i,{-1,-1}});\\n        if(toposort(k,map,adj,0,1)==false){\\n            cout<<1;\\n            return ans;\\n        }\\n        for(auto it:c){\\n            adj1[it[0]].push_back(it[1]);\\n        }\\n        if(toposort(k,map,adj1,0,2)==false){\\n            cout<<2;\\n            return ans;\\n        }\\n        for(auto it:map){\\n            int node=it.first;\\n            int x=it.second.first, y=it.second.second;\\n            if(x>=0 && y>=0)mat[x][y]=node;\\n        }\\n        \\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//here bool function checks if cycle is present or not\\n    bool toposort(int n,unordered_map<int,pair<int,int>> &map,vector<int> adj[],int idx,int curr){\\n        queue<int> q;\\n        vector<int> indegree(n+1,0);\\n        for(int i=1;i<=n;i++){\\n            for(auto it:adj[i]){\\n                indegree[it]++;\\n            }\\n        }\\n        for(int i=1;i<=n;i++){\\n            if(indegree[i]==0)q.push(i);\\n        }\\n        int cnt=0;\\n        while(!q.empty()){\\n            int node=q.front();q.pop();\\n            cnt++;\\n            //topo.push_back(node);\\n            int x=map[node].first, y=map[node].second;\\n            if(curr==1){\\n                map[node].first=idx++;\\n            }\\n            else{\\n                map[node].second=idx++;\\n            }\\n            for(auto it:adj[node]){\\n                indegree[it]--;\\n                if(indegree[it]==0){\\n                    q.push(it);\\n                }\\n            }\\n        }\\n        if(cnt==n)return true;//cycle not present\\n        return false;//cycle present\\n    }\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& r, vector<vector<int>>& c) {\\n        //topological sort by kahn\\'s algorithm\\n        vector<vector<int>> mat(k,vector<int> (k,0)),ans;\\n        vector<int> adj[k+1],adj1[k+1];\\n        for(auto it:r){\\n            adj[it[0]].push_back(it[1]);\\n        }\\n        //vector<int> topoR,topoC;\\n        unordered_map<int,pair<int,int>> map;\\n        for(int i=1;i<=k;i++)map.insert({i,{-1,-1}});\\n        if(toposort(k,map,adj,0,1)==false){\\n            cout<<1;\\n            return ans;\\n        }\\n        for(auto it:c){\\n            adj1[it[0]].push_back(it[1]);\\n        }\\n        if(toposort(k,map,adj1,0,2)==false){\\n            cout<<2;\\n            return ans;\\n        }\\n        for(auto it:map){\\n            int node=it.first;\\n            int x=it.second.first, y=it.second.second;\\n            if(x>=0 && y>=0)mat[x][y]=node;\\n        }\\n        \\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2501164,
                "title": "c-with-explanation-topological-sort",
                "content": "**Idea** \\n\\nConsider the problem into a directed graph problem.\\n(Suppose we know how to implement topological sort here already.)\\n\\n**Create a function to get order (param : k, conditions)**\\n1. create a directed graph (by adj list), and calculate indegree\\n2. topology sort to get topology order\\n3.  check if there is cycle, if has cycle : return {} \\n\\t* if there is node **NOT** in the topology order => there\\'s cycle\\n\\t* what cycle means in this problem is for those contradict conditions \\n\\t(e.g. rowConditions = [[1,2],[2,1]])\\n4.  return topology order\\n\\n**For main function**\\n1. get row and col order repectively\\n2. if order is empty -> return {}\\n3. build matrix for the ans, return ans\\n\\n**Time and Space Complexity**\\n* TC : O(k+n), n = max(rowConditions.size, colConditions.size)\\n    * creating adj list : O(n), twice -> O(n) + O(n) = O(n)\\n    * topology sort : O(k), twice -> O(k) + O(k) = O(k)\\n    * creating ans : O(k)\\n* SC : O(k^2), ans size\\n\\n**Note**\\n* To avoid the trouble of 1 ~ k(num) and 0 ~ k-1(index), just shift it and not considering all idx == 0 element\\n* Store row and col order by \"vector[num] : its row or col index\", to make it better for us to build ans matrix\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> get_order(int k, vector<vector<int>>& theConditions){\\n        vector<vector<int>> adj(k+1,vector<int>()); // no use for adj[0]\\n        vector<int> indeg(k+1,0); // no use for indeg[0]\\n        \\n        // create adj list and calculate indegree\\n        for(auto& con : theConditions){\\n            adj[con[0]].push_back(con[1]);\\n            indeg[con[1]]++;\\n        }\\n        \\n        // topological sort \\n        queue<int> q;\\n        for(int i = 1 ; i <= k ; i++){\\n            if(indeg[i] == 0) q.push(i); \\n        }\\n        \\n        // ans[num] : its row/col index\\n        vector<int> ans(k+1, -1);\\n        int idx = 0;\\n        while(!q.empty()){\\n            int cur = q.front();\\n            q.pop();\\n            ans[cur] = idx;\\n            idx++;\\n            for(auto& nei : adj[cur]){\\n                indeg[nei]--;\\n                if(indeg[nei] == 0) q.push(nei);\\n            }\\n        }\\n        \\n        // no answer exsits when there\\'s cycle (contradiction)\\n        // check if there\\'s cycle, no use for ans[0]\\n        for(int i = 0 ; i < k+1 ; i++) if(i != 0 && ans[i] == -1) return {};\\n        \\n        return ans;\\n    }\\n    \\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        // get row and col order, vector[num] : its row / col index\\n        vector<int> row_order = get_order(k, rowConditions);\\n        vector<int> col_order = get_order(k, colConditions);\\n        \\n        // if there is no ans exists\\n        if(row_order.empty() || col_order.empty()) return {};\\n        \\n        // build ans matrix\\n        vector<vector<int>> ans(k, vector<int>(k,0));\\n        for(int i = 1 ; i <= k ; i++){\\n            int r_idx = row_order[i];\\n            int c_idx = col_order[i];\\n            ans[r_idx][c_idx] = i;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> get_order(int k, vector<vector<int>>& theConditions){\\n        vector<vector<int>> adj(k+1,vector<int>()); // no use for adj[0]\\n        vector<int> indeg(k+1,0); // no use for indeg[0]\\n        \\n        // create adj list and calculate indegree\\n        for(auto& con : theConditions){\\n            adj[con[0]].push_back(con[1]);\\n            indeg[con[1]]++;\\n        }\\n        \\n        // topological sort \\n        queue<int> q;\\n        for(int i = 1 ; i <= k ; i++){\\n            if(indeg[i] == 0) q.push(i); \\n        }\\n        \\n        // ans[num] : its row/col index\\n        vector<int> ans(k+1, -1);\\n        int idx = 0;\\n        while(!q.empty()){\\n            int cur = q.front();\\n            q.pop();\\n            ans[cur] = idx;\\n            idx++;\\n            for(auto& nei : adj[cur]){\\n                indeg[nei]--;\\n                if(indeg[nei] == 0) q.push(nei);\\n            }\\n        }\\n        \\n        // no answer exsits when there\\'s cycle (contradiction)\\n        // check if there\\'s cycle, no use for ans[0]\\n        for(int i = 0 ; i < k+1 ; i++) if(i != 0 && ans[i] == -1) return {};\\n        \\n        return ans;\\n    }\\n    \\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        // get row and col order, vector[num] : its row / col index\\n        vector<int> row_order = get_order(k, rowConditions);\\n        vector<int> col_order = get_order(k, colConditions);\\n        \\n        // if there is no ans exists\\n        if(row_order.empty() || col_order.empty()) return {};\\n        \\n        // build ans matrix\\n        vector<vector<int>> ans(k, vector<int>(k,0));\\n        for(int i = 1 ; i <= k ; i++){\\n            int r_idx = row_order[i];\\n            int c_idx = col_order[i];\\n            ans[r_idx][c_idx] = i;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2500319,
                "title": "c-100-fast-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rc, vector<vector<int>>& cc) {\\n        // basic idea is to find order for rows and cols\\n\\t\\t// it can be done easily by using topological sort\\n\\t\\tunordered_map<int, vector<int>>g1, g2; // 2 directed graphs for order in rows and cols\\n        vector<int>indeg1(k, 0), indeg2(k, 0);\\n        for(int i=0;i<rc.size();i++){\\n            g1[rc[i][0]-1].push_back(rc[i][1]-1);\\n            indeg1[rc[i][1]-1]++;\\n        }\\n        for(int i=0;i<cc.size();i++){\\n            g2[cc[i][0]-1].push_back(cc[i][1]-1);\\n            indeg2[cc[i][1]-1]++;\\n        }\\n\\t\\t// we will use kahn\\'s algorithm for finding topological sort\\n        queue<int>q;\\n        vector<int>ord1;\\n        for(int i=0;i<indeg1.size();i++){\\n            if(indeg1[i]==0){\\n                q.push(i);\\n                ord1.push_back(i);\\n            }\\n        }\\n        while(!q.empty()){\\n            int it=q.front();\\n            q.pop();\\n            for(auto i:g1[it]){\\n                indeg1[i]--;\\n                if(indeg1[i]==0){\\n                    q.push(i);\\n                    ord1.push_back(i);\\n                }\\n            }\\n        }\\n        // for(auto it:ord1)\\n        //     cout<<it<<\" \";\\n        vector<vector<int>>ans;\\n\\t\\t // if we can find a order then it will surely of size = k\\n        if(ord1.size()!=k)\\n            return ans;\\n        \\n        vector<int>ord2;\\n        for(int i=0;i<indeg2.size();i++){\\n            if(indeg2[i]==0){\\n                // cout<<i<<\"#\";\\n                q.push(i);\\n                ord2.push_back(i);\\n            }\\n        }\\n        while(!q.empty()){\\n            int it=q.front();\\n            q.pop();\\n            for(auto i:g2[it]){\\n                indeg2[i]--;\\n                if(indeg2[i]==0){\\n                    q.push(i);\\n                    ord2.push_back(i);\\n                }\\n            }\\n        }\\n        if(ord2.size()!=k)\\n            return ans;\\n         // for(auto it:ord2)\\n         //    cout<<it<<\" \";\\n        // cout<<\"\\\\n@\";\\n        ans.resize(k, vector<int>(k, 0));\\n        unordered_map<int, vector<int>>mp; // for storing the \\n\\t\\t\\t\\t\\t\\t\\t\\t// row & col values in matrix \\n        for(int i=0;i<k;i++){\\n            mp[ord1[i]].push_back(i);\\n        }\\n        for(int i=0;i<k;i++){\\n            mp[ord2[i]].push_back(i);\\n        }\\n        for(auto it:mp){\\n            // cout<<it.first<<\" \"<<it.second[0]<<\" \"<<it.second[1]<<\"\\\\n\";\\n            ans[it.second[0]][it.second[1]]=it.first+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rc, vector<vector<int>>& cc) {\\n        // basic idea is to find order for rows and cols\\n\\t\\t// it can be done easily by using topological sort\\n\\t\\tunordered_map<int, vector<int>>g1, g2; // 2 directed graphs for order in rows and cols\\n        vector<int>indeg1(k, 0), indeg2(k, 0);\\n        for(int i=0;i<rc.size();i++){\\n            g1[rc[i][0]-1].push_back(rc[i][1]-1);\\n            indeg1[rc[i][1]-1]++;\\n        }\\n        for(int i=0;i<cc.size();i++){\\n            g2[cc[i][0]-1].push_back(cc[i][1]-1);\\n            indeg2[cc[i][1]-1]++;\\n        }\\n\\t\\t// we will use kahn\\'s algorithm for finding topological sort\\n        queue<int>q;\\n        vector<int>ord1;\\n        for(int i=0;i<indeg1.size();i++){\\n            if(indeg1[i]==0){\\n                q.push(i);\\n                ord1.push_back(i);\\n            }\\n        }\\n        while(!q.empty()){\\n            int it=q.front();\\n            q.pop();\\n            for(auto i:g1[it]){\\n                indeg1[i]--;\\n                if(indeg1[i]==0){\\n                    q.push(i);\\n                    ord1.push_back(i);\\n                }\\n            }\\n        }\\n        // for(auto it:ord1)\\n        //     cout<<it<<\" \";\\n        vector<vector<int>>ans;\\n\\t\\t // if we can find a order then it will surely of size = k\\n        if(ord1.size()!=k)\\n            return ans;\\n        \\n        vector<int>ord2;\\n        for(int i=0;i<indeg2.size();i++){\\n            if(indeg2[i]==0){\\n                // cout<<i<<\"#\";\\n                q.push(i);\\n                ord2.push_back(i);\\n            }\\n        }\\n        while(!q.empty()){\\n            int it=q.front();\\n            q.pop();\\n            for(auto i:g2[it]){\\n                indeg2[i]--;\\n                if(indeg2[i]==0){\\n                    q.push(i);\\n                    ord2.push_back(i);\\n                }\\n            }\\n        }\\n        if(ord2.size()!=k)\\n            return ans;\\n         // for(auto it:ord2)\\n         //    cout<<it<<\" \";\\n        // cout<<\"\\\\n@\";\\n        ans.resize(k, vector<int>(k, 0));\\n        unordered_map<int, vector<int>>mp; // for storing the \\n\\t\\t\\t\\t\\t\\t\\t\\t// row & col values in matrix \\n        for(int i=0;i<k;i++){\\n            mp[ord1[i]].push_back(i);\\n        }\\n        for(int i=0;i<k;i++){\\n            mp[ord2[i]].push_back(i);\\n        }\\n        for(auto it:mp){\\n            // cout<<it.first<<\" \"<<it.second[0]<<\" \"<<it.second[1]<<\"\\\\n\";\\n            ans[it.second[0]][it.second[1]]=it.first+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2500144,
                "title": "amazing-topological-sort-question",
                "content": "use two topolical sorting, check is cycle exist on any of them or not and simply check the occcurance in both topo array for array construction:\\n\\nclass Solution {\\npublic:\\n    \\n    vector<int> adj1[10007], adj2[10007];\\n    \\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& R, vector<vector<int>>& C) {\\n        for(auto &it : R)\\n        {\\n            adj1[it[0]].push_back(it[1]);\\n        }\\n        \\n        for(auto &it : C)\\n        {\\n            adj2[it[0]].push_back(it[1]);\\n        }\\n        \\n//         topological sorting\\n        \\n        vector<int> topo1, topo2;\\n        \\n        queue<int> q1, q2;\\n        vector<int> in1(10007, 0), in2(10007, 0);\\n        \\n        for(int i=1; i<=k; i++)\\n        {\\n            for(auto it : adj1[i])\\n            {\\n                in1[it]++;\\n            }\\n            \\n            for(auto it : adj2[i])\\n            {\\n                in2[it]++;\\n            }\\n        }\\n        \\n        for(int i=1; i<=k; i++)\\n        {\\n            if(in1[i]==0)q1.push(i);\\n            if(in2[i]==0)q2.push(i);\\n        }\\n        \\n        while(!q1.empty())\\n        {\\n            int node=q1.front();\\n            q1.pop();\\n            \\n            topo1.push_back(node);\\n            for(auto it : adj1[node])\\n            {\\n                in1[it]--;\\n                if(in1[it]==0)q1.push(it);\\n            }\\n        }\\n        \\n        while(!q2.empty())\\n        {\\n            int node=q2.front();\\n            q2.pop();\\n            \\n            topo2.push_back(node);\\n            for(auto it : adj2[node])\\n            {\\n                in2[it]--;\\n                if(in2[it]==0)q2.push(it);\\n            }\\n        }\\n        \\n        \\n        vector<vector<int>> v(k, vector<int>(k, 0));\\n        \\n        if(topo1.size()==k && topo2.size()==k)\\n        {\\n            for(int i=0; i<k; i++)\\n            {\\n                for(int j=0; j<k; j++)\\n                {\\n                    if(topo1[i]==topo2[j])\\n                    {\\n                        v[i][j]=topo1[i];\\n                    }\\n                }\\n            }\\n            \\n            return v;\\n        }\\n        else\\n        {\\n            return vector<vector<int>>();\\n        }\\n        \\n        \\n    }\\n};``",
                "solutionTags": [
                    "Topological Sort"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    vector<int> adj1[10007], adj2[10007];\\n    \\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& R, vector<vector<int>>& C) {\\n        for(auto &it : R)\\n        {\\n            adj1[it[0]].push_back(it[1]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2496499,
                "title": "step-by-step-approach-easy-to-follow-c-implementation",
                "content": "Here is an explanation from post contest discussion meeting.\\n\\nhttps://www.youtube.com/watch?v=LDNMlgBi5vg&list=PLQ9cQ3JqeqU_T-Ic3384j4uWDxUnXjlVO&index=4",
                "solutionTags": [],
                "code": "Here is an explanation from post contest discussion meeting.\\n\\nhttps://www.youtube.com/watch?v=LDNMlgBi5vg&list=PLQ9cQ3JqeqU_T-Ic3384j4uWDxUnXjlVO&index=4",
                "codeTag": "Unknown"
            },
            {
                "id": 2496434,
                "title": "topological-sort-dfs-javascript-js-fast-than-100",
                "content": "\\n\\n```\\n/**\\n * @param {number} k\\n * @param {number[][]} rowConditions\\n * @param {number[][]} colConditions\\n * @return {number[][]}\\n */\\nvar buildMatrix = function(k, rowConditions, colConditions) {\\n    \\n    function getOrder(conditions) {\\n        // build graph\\n        const graph = Array(k+1).fill(0).map(r => []);\\n        for (const c of conditions) {\\n            const from = c[0], to = c[1];\\n            graph[from].push(to);\\n        }\\n        \\n        let hasCycle = false;\\n        const visited = Array(k+1).fill(false);\\n        const onPath = Array(k+1).fill(false);\\n        const postOrder = [];\\n        \\n        function findOrder() {\\n            for (let i = 1; i <= k; i++) {\\n                dfs(i);\\n                if (hasCycle) {\\n                    return [];\\n                }\\n            }\\n            return postOrder.reverse();\\n        }\\n        \\n        function dfs(i) {\\n            if (onPath[i]) {\\n                hasCycle = true;\\n                return;\\n            }\\n            if (hasCycle || visited[i]) {\\n                return true;\\n            }\\n            \\n            onPath[i] = true;\\n            visited[i] = true;\\n            \\n            for (const v of graph[i]) {\\n                dfs(v);\\n            }\\n            postOrder.push(i);\\n            onPath[i] = false;\\n        }\\n        \\n        return findOrder();\\n    }\\n    \\n    const rowOrder = getOrder(rowConditions);\\n    if (rowOrder.length == 0) {\\n        return [];\\n    }\\n    const colOrder = getOrder(colConditions);\\n    if (colOrder.length == 0) {\\n        return [];\\n    }\\n    \\n    const re = Array(k).fill(0).map(r => Array(k).fill(0));\\n    const colIndex = new Map();\\n    for (let i = 0; i < colOrder.length; i++) {\\n        colIndex.set(colOrder[i], i);\\n    }\\n    for (let i = 0; i < rowOrder.length; i++) {\\n        re[i][colIndex.get(rowOrder[i])] = rowOrder[i];\\n    }\\n    \\n    return re;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\n/**\\n * @param {number} k\\n * @param {number[][]} rowConditions\\n * @param {number[][]} colConditions\\n * @return {number[][]}\\n */\\nvar buildMatrix = function(k, rowConditions, colConditions) {\\n    \\n    function getOrder(conditions) {\\n        // build graph\\n        const graph = Array(k+1).fill(0).map(r => []);\\n        for (const c of conditions) {\\n            const from = c[0], to = c[1];\\n            graph[from].push(to);\\n        }\\n        \\n        let hasCycle = false;\\n        const visited = Array(k+1).fill(false);\\n        const onPath = Array(k+1).fill(false);\\n        const postOrder = [];\\n        \\n        function findOrder() {\\n            for (let i = 1; i <= k; i++) {\\n                dfs(i);\\n                if (hasCycle) {\\n                    return [];\\n                }\\n            }\\n            return postOrder.reverse();\\n        }\\n        \\n        function dfs(i) {\\n            if (onPath[i]) {\\n                hasCycle = true;\\n                return;\\n            }\\n            if (hasCycle || visited[i]) {\\n                return true;\\n            }\\n            \\n            onPath[i] = true;\\n            visited[i] = true;\\n            \\n            for (const v of graph[i]) {\\n                dfs(v);\\n            }\\n            postOrder.push(i);\\n            onPath[i] = false;\\n        }\\n        \\n        return findOrder();\\n    }\\n    \\n    const rowOrder = getOrder(rowConditions);\\n    if (rowOrder.length == 0) {\\n        return [];\\n    }\\n    const colOrder = getOrder(colConditions);\\n    if (colOrder.length == 0) {\\n        return [];\\n    }\\n    \\n    const re = Array(k).fill(0).map(r => Array(k).fill(0));\\n    const colIndex = new Map();\\n    for (let i = 0; i < colOrder.length; i++) {\\n        colIndex.set(colOrder[i], i);\\n    }\\n    for (let i = 0; i < rowOrder.length; i++) {\\n        re[i][colIndex.get(rowOrder[i])] = rowOrder[i];\\n    }\\n    \\n    return re;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2495453,
                "title": "c-toposort-implementation-well-explained",
                "content": "INTUTION : Since we have to arrange the following numbers(1 to k ) in a certain order based on the given criteria, so we can apply some sorting algorithm. On reading the problem well one can see that if they imagine the numbers as nodes then it would be easy for them to draw the relations between them. \\nAs stated in the problem above_i will be strictly in upper rows compared to the below_i . SO we can imagine them as nodes with directed edge \\nexample -> [above, below] = [1,2] \\nSO we can say that 1 will always be before 2   ->         1 ----------> 2 so we can do a directed edge from 1 to 2\\n\\nNow the sorting algorithm, in graphs we can easily sort the directed algorithms using toposort algorithm.\\nWe will traverse through the nodes and go the the depth of the subtree and then when we reach to the last node we start filling the topoSort array. As a result the node which will be executed at last will be stored in the topo sort array in the beginning. So after all this operation we have to reverse this array in order to get the desired output. And if the graph contains any cyclic dependency then the answer will not be possible, we will have to consider that condition also.\\n\\nYou can refer to any good Toposort article or any good Toposort youtube video to get a good knowledge\\n\\n\\n# methods used in the code :\\n**buildGraph** -> this method builds the graph for both the rowCondition as well as the colCondition, you can see the code I have called the function twice one for row, another one for the col.\\n\\n**topoSort** -> this method is responsible for the sorting of the graph according with the graph.\\n\\n***cycle finding*** -> if the node is visited in the same call then then visited[node] will have a value \"1\" and if the node is called in other call then it would have a value \"2\", and if it is not visited yet then it will be \"0\".\\nSo we can easily tell that if the next node which we will visit has a visited value of 1 then it is certain that graph contains a LOOP, so we return a FALSE from the function.\\n\\nIN the main function we call the topoSort function and maintain a boolean Possible variable which tracks there are any loop in the graph or not, and if any loop are seen then it will return an empty vector.\\n\\n**FINAL PART FILLING THE ANSWER VECTOR**\\nNow we have the ordering of the row as well as the ordering of the col, now we simply iterate over the numbers i.e. from 1 to k. And find the positions of them in the respective row and col array and put them in the answer vector.\\n\\n```\\nclass Solution {\\npublic:\\n    void buildGraph(vector<vector<int>>&condition, vector<vector<int>>&graph){\\n        for(auto &it :condition){\\n            int u = it[0] , v = it[1];\\n            graph[u].push_back(v);\\n        }\\n    }\\n    \\n    bool topoSort(int node, vector<vector<int>>&adj, vector<int>&vis, vector<int>&ordering){\\n        \\n        vis[node] = 1;\\n        for(auto &it : adj[node]){\\n            if(!vis[it]){\\n                topoSort(it, adj, vis, ordering);\\n            }\\n            if(vis[it] == 1) {// there is a loop\\n                return false;\\n            }\\n        }\\n        \\n        ordering.push_back(node);\\n        vis[node] = 2;\\n        return true;\\n    }\\n    \\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        // adj list of the graph\\n        vector<vector<int>>row(k+1), col(k+1);\\n        vector<int>visRow(k+1), visCol(k+1);\\n        buildGraph(rowConditions, row);\\n        buildGraph(colConditions, col);\\n        bool possible = true;\\n        vector<int>rowOrdering, colOrdering;\\n        for(int i=1;i<=k;i++)\\n            if(!visRow[i])\\n                possible &= topoSort(i, row, visRow, rowOrdering);\\n        // cout << \"possible= \"<<possible << \"\\\\n\";\\n        for(int i=1;i<=k;i++)\\n            if(!visCol[i])\\n                possible &= topoSort(i, col, visCol, colOrdering);\\n        // cout << \"possible= \"<<possible << \"\\\\n\";\\n        \\n        if(!possible)   return {};\\n        reverse(rowOrdering.begin(), rowOrdering.end());\\n        reverse(colOrdering.begin(), colOrdering.end());\\n        vector<vector<int>>ans(k, vector<int>(k));\\n        // for(auto &it : rowOrdering) cout << it << \" \";\\n        // cout << \"\\\\n\";\\n        // for(auto &it : colOrdering) cout << it << \" \";\\n        // cout << \"\\\\n\";\\n        \\n        \\n        if(rowOrdering.size()==0 or colOrdering.size()==0)  return {};\\n        int n = rowOrdering.size();\\n        int num = 1;\\n        while(num <= k){\\n            int i = 0, j = 0;\\n            while(i<n and rowOrdering[i] != num)    i++;\\n            while(j<n and colOrdering[j] != num)    j++;\\n            // cout << i << \" \" << j << \"\\\\n\";\\n            ans[i][j] = num;\\n            num++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nPLEASE UPVOTE IF THIS HAS HELPED YOU. THANKYOU",
                "solutionTags": [
                    "Depth-First Search",
                    "Topological Sort",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void buildGraph(vector<vector<int>>&condition, vector<vector<int>>&graph){\\n        for(auto &it :condition){\\n            int u = it[0] , v = it[1];\\n            graph[u].push_back(v);\\n        }\\n    }\\n    \\n    bool topoSort(int node, vector<vector<int>>&adj, vector<int>&vis, vector<int>&ordering){\\n        \\n        vis[node] = 1;\\n        for(auto &it : adj[node]){\\n            if(!vis[it]){\\n                topoSort(it, adj, vis, ordering);\\n            }\\n            if(vis[it] == 1) {// there is a loop\\n                return false;\\n            }\\n        }\\n        \\n        ordering.push_back(node);\\n        vis[node] = 2;\\n        return true;\\n    }\\n    \\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        // adj list of the graph\\n        vector<vector<int>>row(k+1), col(k+1);\\n        vector<int>visRow(k+1), visCol(k+1);\\n        buildGraph(rowConditions, row);\\n        buildGraph(colConditions, col);\\n        bool possible = true;\\n        vector<int>rowOrdering, colOrdering;\\n        for(int i=1;i<=k;i++)\\n            if(!visRow[i])\\n                possible &= topoSort(i, row, visRow, rowOrdering);\\n        // cout << \"possible= \"<<possible << \"\\\\n\";\\n        for(int i=1;i<=k;i++)\\n            if(!visCol[i])\\n                possible &= topoSort(i, col, visCol, colOrdering);\\n        // cout << \"possible= \"<<possible << \"\\\\n\";\\n        \\n        if(!possible)   return {};\\n        reverse(rowOrdering.begin(), rowOrdering.end());\\n        reverse(colOrdering.begin(), colOrdering.end());\\n        vector<vector<int>>ans(k, vector<int>(k));\\n        // for(auto &it : rowOrdering) cout << it << \" \";\\n        // cout << \"\\\\n\";\\n        // for(auto &it : colOrdering) cout << it << \" \";\\n        // cout << \"\\\\n\";\\n        \\n        \\n        if(rowOrdering.size()==0 or colOrdering.size()==0)  return {};\\n        int n = rowOrdering.size();\\n        int num = 1;\\n        while(num <= k){\\n            int i = 0, j = 0;\\n            while(i<n and rowOrdering[i] != num)    i++;\\n            while(j<n and colOrdering[j] != num)    j++;\\n            // cout << i << \" \" << j << \"\\\\n\";\\n            ans[i][j] = num;\\n            num++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2495149,
                "title": "c-faster-than-100",
                "content": "![image](https://assets.leetcode.com/users/images/b2134072-2fb5-4f5f-b284-367350806bae_1661683664.1233385.png)\\n\\n```\\nclass Solution {\\npublic:\\n    void dfs(bool &is_cycle, int cycle, int at, vector<bool> &visited, vector<int> &visitedNodes, vector<vector<int>> &graph){\\n\\t\\t// dfs to mark the nodes\\n        visited[at] = true;\\n        for(int i = 0 ; i<graph[at].size(); i++){\\n            if (graph[at][i]==1){\\n                if(cycle == i){\\n                    is_cycle = true;\\n                    return;\\n                }\\n                if(!visited[i]){\\n                    dfs(is_cycle, cycle, i, visited, visitedNodes, graph);\\n                }\\n            }\\n        }\\n        visitedNodes.push_back(at);\\n    }\\n    \\n    vector<int> topological_sort(vector<vector<int>>& Conditions, int k){\\n        vector<vector<int>> graph(k, vector<int>(k, 0));\\n        for(int i = 0 ; i < Conditions.size(); i++){\\n            graph[Conditions[i][0]-1][Conditions[i][1]-1] = 1; //subtract -1 to set as indexes\\n        }\\n        vector<bool> visited(k, false);\\n        vector<int> ordering(k, 0);\\n        int i = k-1; //start filling from the end nodes with most dependencies\\n        \\n        for(int at = 0; at<k; at++){\\n\\n            if (!visited[at]){\\n                vector<int> visitedNodes;\\n                bool is_cycle = false; //keep track of the value from which we started\\n                dfs(is_cycle, at, at, visited, visitedNodes, graph);\\n                if(is_cycle) {vector<int> empty_arr; return empty_arr;}\\n                \\n                for(auto nodeid: visitedNodes){\\n                    ordering[i] = nodeid;\\n                    i--;\\n                }\\n            }\\n        }\\n        return ordering;\\n    }\\n    \\n    \\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n\\t// do the topological sorting for both conditions\\n        vector<int> row_ordering = topological_sort(rowConditions, k);\\n        vector<int> col_ordering = topological_sort(colConditions, k);\\n        if (row_ordering.size() == 0 || col_ordering.size() == 0){vector<vector<int>> emp; return emp;} //if one of the conditions had cycle return empty array\\n        vector<vector<int>> res(k,vector<int>(k,0));\\n        for(int i = 0 ; i < k; i ++){\\n            for(int j = 0 ; j < k ; j ++){\\n\\t\\t\\t\\t// if row and col value matches at the index set the value\\n                if(row_ordering[i] == col_ordering[j]) res[i][j] = col_ordering[j]+1; //add 1 to return from indexes to order\\n            }\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "Depth-First Search",
                    "Topological Sort"
                ],
                "code": "class Solution {\\npublic:\\n    void dfs(bool &is_cycle, int cycle, int at, vector<bool> &visited, vector<int> &visitedNodes, vector<vector<int>> &graph){\\n\\t\\t// dfs to mark the nodes\\n        visited[at] = true;\\n        for(int i = 0 ; i<graph[at].size(); i++){\\n            if (graph[at][i]==1){\\n                if(cycle == i){\\n                    is_cycle = true;\\n                    return;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2495067,
                "title": "c-topological-sorting-explained-simple",
                "content": "This problem is based on topological sorting.\\nIdea:- see the question asked us to make a matrix, and give some relations between numbers. For example, say for numbers a,b and c; a should come above b, and b should be below c. So in such cases, to arrange the number in an order, topological sorting can be used. But for topological sorting, the graph should be directed acyclic graph.\\n\\nWe will make two separate graphs from rowConditions and colConditions; for each {a,b} in rowConditions and colConditions we will make an edge from a to b; thus, the graphs will be directed.\\nNow we will check if the graph is acyclic. If not, then we can\\'t form the matrix. Otherwise, get the nodes in topologically sorted order; say those arrays are rowarray and colarray. \\nIf the number a is on position x in rowaarray and at y in colarray.\\nThen for ans matrix ans[x][y]=a;\\nBelow is the implementation.\\n\\n\\nclass Solution {\\n    \\n    //Function to get the nodes in topological sorted order\\n    vector<int> topo(vector<vector<int>>&adj)\\n    {\\n        int n=adj.size();\\n        vector<int> in(n,0);\\n        for(int i=1;i<n;i++)\\n        {\\n             for(auto j:adj[i])\\n             {\\n                 in[j]++;\\n             }\\n        }\\n        queue<int>q;\\n        for(int i=1;i<n;i++) if(in[i]==0) q.push(i);\\n        vector<int>ans;\\n        while(q.size())\\n        {\\n            int x=q.front();\\n            q.pop();\\n            ans.push_back(x);\\n            for(auto j:adj[x])\\n            {\\n                in[j]--;\\n                if(in[j]==0) q.push(j);\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    bool dfs(vector<vector<int>>&adj, int i, vector<int>&visit)\\n    {\\n        visit[i]=1;\\n        for(auto j:adj[i])\\n        {\\n           if(visit[j]==0 and dfs(adj, j, visit)) return 1;\\n            else if(visit[j]==1) return 1;\\n        }\\n        visit[i]=2;\\n        return 0;\\n    }\\n    \\n    // Function to check cycle\\n    bool check(vector<vector<int>>&adj)\\n    {\\n        int n=adj.size();\\n        vector<int>visit(n,0);\\n       \\n        for(int i=0;i<n;i++)\\n        {\\n            if(visit[i]==0 and dfs(adj, i, visit))\\n            {\\n                \\n                return 0;\\n            \\n            }\\n        }\\n        return 1;\\n    }\\npublic:\\n    vector<vector<int>> buildMatrix(int n, vector<vector<int>>& r, vector<vector<int>>& c) {\\n        \\n        vector<vector<int>>adj(n+1);\\n        for(auto v:r)\\n        { \\n            adj[v[0]].push_back(v[1]);\\n        \\n        }\\n        if(check(adj)==0)\\n        {\\n            \\n            vector<vector<int>>ans;\\n            return ans;\\n        }\\n       \\n        auto row=topo(adj);\\n    //    cout<<row.size()<<\" \";\\n        adj.clear();\\n        adj.resize(n+1);\\n        for(auto v:c)\\n        { \\n            adj[v[0]].push_back(v[1]);\\n        \\n        }\\n         if(check(adj)==0)\\n        {\\n            vector<vector<int>>ans;\\n            return ans;\\n        }\\n        auto col=topo(adj);\\n      \\n        vector<vector<int>> v(n+1,vector<int>{-1,-1});\\n         \\n       \\n        for(int i=0;i<row.size();i++)\\n        {\\n           \\n           v[row[i]][0]=i;\\n      \\n        }\\n      \\n         for(int i=0;i<col.size();i++)\\n        {\\n          \\n           v[col[i]][1]=i;\\n            \\n        }\\n   \\n       \\n      \\n        vector<vector<int>>ans(n, vector<int>(n,0));\\n        for(int i=1;i<=n;i++)\\n        {\\n            int x=v[i][0], y=v[i][1];\\n        \\n            ans[x][y]=i;\\n        }\\n        \\n        \\n        return ans;\\n        \\n        \\n        \\n    }\\n};",
                "solutionTags": [
                    "Graph",
                    "Topological Sort"
                ],
                "code": "class Solution {\\n    \\n    //Function to get the nodes in topological sorted order\\n    vector<int> topo(vector<vector<int>>&adj)\\n    {\\n        int n=adj.size();\\n        vector<int> in(n,0);\\n        for(int i=1;i<n;i++)\\n        {\\n             for(auto j:adj[i])\\n             {\\n                 in[j]++;\\n             }",
                "codeTag": "Java"
            },
            {
                "id": 2494985,
                "title": "rust-topological-sort-with-comments",
                "content": "I tried to solve this for the 2022-08-28 Weekly Contest 308. The conditions for rows and columns are really edges in a dependency graph, and we can get the proper ordering to satisfy the conditions by performing a topological sort. Then we sort the vectors of numbers and their respective coordinates w.r.t. the numbers to get the numbers in the row and column vectors to line up. After that it\\'s just a matter of populating the matrix.\\n\\nComment: Too bad I ran out of time before completing this, as I was on the right track. But it was a couple of years since I did a toposort, and it took a while to do an implementation from scratch. But pratice makes perfect, and it was a fun experience to try a contest (my first).\\n\\n```\\npub type TopoSortGraph = [Vec<usize>];\\n#[derive(Copy, Clone)]\\nenum TopoSortMark {\\n    Cleared,\\n    Temporary,\\n    Permanent,\\n}\\n\\nuse std::collections::VecDeque;\\n\\nfn toposort_dfs(graph: &TopoSortGraph, marks: &mut [TopoSortMark], n: usize, mut rez: VecDeque<usize>) -> Option<VecDeque<usize>> {\\n    match marks[n] {\\n        TopoSortMark::Cleared => {\\n            marks[n] = TopoSortMark::Temporary;\\n            for m in &graph[n] {\\n                match toposort_dfs(graph, marks, *m, rez) {\\n                    Some(r) => rez = r,\\n                    None => return None,\\n                }\\n            }\\n            rez.push_front(n);\\n            marks[n] = TopoSortMark::Permanent;\\n            Some(rez)\\n        },\\n        TopoSortMark::Temporary => None,\\n        TopoSortMark::Permanent => Some(rez),\\n    }\\n}\\n\\npub fn toposort(graph: &TopoSortGraph) -> Option<Vec<usize>> {\\n    let mut marks = vec![TopoSortMark::Cleared; graph.len()];\\n    let mut rez = VecDeque::new();\\n    for n in 0..graph.len() {\\n        match toposort_dfs(graph, &mut marks, n, rez) {\\n            Some(r) => rez = r,\\n            None => return None,\\n        }\\n    }\\n    Some(rez.into_iter().collect())\\n}\\n\\nfn build_graph(conditions: &[Vec<i32>], k: i32) -> Vec<Vec<usize>> {\\n    let mut graph = vec![vec![]; k as usize];\\n    for condition in conditions {\\n        graph[(condition[0] - 1) as usize].push((condition[1] - 1) as usize);\\n    }\\n    graph\\n}\\n\\nimpl Solution {\\n    pub fn build_matrix(k: i32, row_conditions: Vec<Vec<i32>>, col_conditions: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\\n        match (toposort(&build_graph(&row_conditions, k)), toposort(&build_graph(&col_conditions, k))) {\\n            (Some(r), Some(c)) => {\\n                let mut rez = vec![vec![0; k as usize]; k as usize];\\n                let mut rows = r.into_iter().enumerate().map(|(i, n)| (n, i)).collect::<Vec<_>>();\\n                let mut cols = c.into_iter().enumerate().map(|(i, n)| (n, i)).collect::<Vec<_>>();\\n                rows.sort_unstable();\\n                cols.sort_unstable();\\n                rows.into_iter().zip(cols.into_iter()).for_each(|((n, row), (_, col))| rez[row][col] = (n + 1) as i32);\\n                rez\\n            }\\n            _ => vec![],\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\npub type TopoSortGraph = [Vec<usize>];\\n#[derive(Copy, Clone)]\\nenum TopoSortMark {\\n    Cleared,\\n    Temporary,\\n    Permanent,\\n}\\n\\nuse std::collections::VecDeque;\\n\\nfn toposort_dfs(graph: &TopoSortGraph, marks: &mut [TopoSortMark], n: usize, mut rez: VecDeque<usize>) -> Option<VecDeque<usize>> {\\n    match marks[n] {\\n        TopoSortMark::Cleared => {\\n            marks[n] = TopoSortMark::Temporary;\\n            for m in &graph[n] {\\n                match toposort_dfs(graph, marks, *m, rez) {\\n                    Some(r) => rez = r,\\n                    None => return None,\\n                }\\n            }\\n            rez.push_front(n);\\n            marks[n] = TopoSortMark::Permanent;\\n            Some(rez)\\n        },\\n        TopoSortMark::Temporary => None,\\n        TopoSortMark::Permanent => Some(rez),\\n    }\\n}\\n\\npub fn toposort(graph: &TopoSortGraph) -> Option<Vec<usize>> {\\n    let mut marks = vec![TopoSortMark::Cleared; graph.len()];\\n    let mut rez = VecDeque::new();\\n    for n in 0..graph.len() {\\n        match toposort_dfs(graph, &mut marks, n, rez) {\\n            Some(r) => rez = r,\\n            None => return None,\\n        }\\n    }\\n    Some(rez.into_iter().collect())\\n}\\n\\nfn build_graph(conditions: &[Vec<i32>], k: i32) -> Vec<Vec<usize>> {\\n    let mut graph = vec![vec![]; k as usize];\\n    for condition in conditions {\\n        graph[(condition[0] - 1) as usize].push((condition[1] - 1) as usize);\\n    }\\n    graph\\n}\\n\\nimpl Solution {\\n    pub fn build_matrix(k: i32, row_conditions: Vec<Vec<i32>>, col_conditions: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\\n        match (toposort(&build_graph(&row_conditions, k)), toposort(&build_graph(&col_conditions, k))) {\\n            (Some(r), Some(c)) => {\\n                let mut rez = vec![vec![0; k as usize]; k as usize];\\n                let mut rows = r.into_iter().enumerate().map(|(i, n)| (n, i)).collect::<Vec<_>>();\\n                let mut cols = c.into_iter().enumerate().map(|(i, n)| (n, i)).collect::<Vec<_>>();\\n                rows.sort_unstable();\\n                cols.sort_unstable();\\n                rows.into_iter().zip(cols.into_iter()).for_each(|((n, row), (_, col))| rez[row][col] = (n + 1) as i32);\\n                rez\\n            }\\n            _ => vec![],\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2494945,
                "title": "find-topo-sort-c",
                "content": "```\\nclass Solution {\\nprivate:\\n    vector<int> find_topo(vector<int> adj[],int k){\\n        queue<int> q;\\n        vector<int> inorder(k+1),ans;\\n        for(int i=1;i<=k;i++)\\n            for(auto ele : adj[i]) inorder[ele]++;\\n        \\n        for(int i=1;i<=k;i++) if(!inorder[i]) q.push(i);\\n        \\n        while(q.size()){\\n            auto ele = q.front(); q.pop();\\n            for(auto e : adj[ele]){\\n                if(--inorder[e] == 0) q.push(e);\\n            }\\n            ans.push_back(ele);\\n        }\\n        \\n        return ans;\\n    }\\npublic:\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& r, vector<vector<int>>& c) {\\n        vector<int> adj1[k+1], adj2[k+1];\\n        \\n        for(auto &vec : r) adj1[vec[0]].push_back(vec[1]);\\n        \\n        for(auto &vec : c) adj2[vec[0]].push_back(vec[1]);\\n        \\n        auto topo1 = find_topo(adj1,k), topo2 = find_topo(adj2,k);\\n        if(topo1.size() != k or topo2.size() != k) return {};\\n        \\n        vector<vector<int>> ans(k, vector<int> (k));\\n        \\n        vector<int> idx(k+1,0);\\n        \\n        for(int j=0;j<topo2.size();j++) idx[topo2[j]] = j;\\n        \\n        for(int i=0;i<k;i++) ans[i][idx[topo1[i]]] = topo1[i];\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<int> find_topo(vector<int> adj[],int k){\\n        queue<int> q;\\n        vector<int> inorder(k+1),ans;\\n        for(int i=1;i<=k;i++)\\n            for(auto ele : adj[i]) inorder[ele]++;\\n        \\n        for(int i=1;i<=k;i++) if(!inorder[i]) q.push(i);\\n        \\n        while(q.size()){\\n            auto ele = q.front(); q.pop();\\n            for(auto e : adj[ele]){\\n                if(--inorder[e] == 0) q.push(e);\\n            }\\n            ans.push_back(ele);\\n        }\\n        \\n        return ans;\\n    }\\npublic:\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& r, vector<vector<int>>& c) {\\n        vector<int> adj1[k+1], adj2[k+1];\\n        \\n        for(auto &vec : r) adj1[vec[0]].push_back(vec[1]);\\n        \\n        for(auto &vec : c) adj2[vec[0]].push_back(vec[1]);\\n        \\n        auto topo1 = find_topo(adj1,k), topo2 = find_topo(adj2,k);\\n        if(topo1.size() != k or topo2.size() != k) return {};\\n        \\n        vector<vector<int>> ans(k, vector<int> (k));\\n        \\n        vector<int> idx(k+1,0);\\n        \\n        for(int j=0;j<topo2.size();j++) idx[topo2[j]] = j;\\n        \\n        for(int i=0;i<k;i++) ans[i][idx[topo1[i]]] = topo1[i];\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2494660,
                "title": "simple-c-code-topological-sort-no-need-to-detect-cycles-again-160-ms",
                "content": "The question talks about a relative ordering of numbers in the matrix. This can be represented best using a Graph, where an edge from a vertex a to vertex b means that a should appear before b in order. \\nThe approach is simple. first we find a topological arrangement row wise and then we find a topological arrangement column wise and we combine both arrangements in final array.\\nThere can be one special case where there are cycles in the graph formed row-wise or column-wise and therefore there is no topological sort possible. We return empty array in case this case\\n\\nMy Code:\\n\\n```\\n#define vi vector<int>\\n#define vvi vector<vi>\\n#define sz(x) x.size()\\n#define rep(i,a,b) for(int i = a;i<b;i++)\\n\\nclass Solution {\\npublic:\\n\\n    vi topoSort(const vector<vi> gr) {\\n        vi indeg(sz(gr)), ret;\\n        for (auto& li : gr) for (int x : li) indeg[x]++;\\n        queue<int> q; \\n        rep(i,0,sz(gr)) if (indeg[i] == 0) q.push(i);\\n        while (!q.empty()) {\\n            int i = q.front(); \\n            ret.push_back(i);\\n            q.pop();\\n            for (int x : gr[i])\\n                if (--indeg[x] == 0) q.push(x);\\n        }\\n        return ret.size()==gr.size()?ret:vector<int>();\\n    }\\n\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& p, vector<vector<int>>& q) {\\n        vvi edges1(k),edges2(k);\\n        for(auto i:p)\\n            edges1[i[0]-1].push_back(i[1]-1);\\n        for(auto i:q)   \\n            edges2[i[0]-1].push_back(i[1]-1);\\n        \\n        vi xi = topoSort(edges1);\\n        vi yi = topoSort(edges2);\\n        if(yi.size()==0 or xi.size()==0) return {};\\n        \\n        unordered_map<int,int>xc;\\n        for(int i = 0;i<k;i++) xc[xi[i]] = i;\\n        \\n        unordered_map<int,int>yc;\\n        for(int i = 0;i<k;i++) yc[yi[i]] = i;\\n        vector<vector<int>> ans(k,vector<int>(k,0));\\n        \\n        for(int i = 0;i<k;i++) \\n            ans[xc[i]][yc[i]] = i+1;\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\n#define vi vector<int>\\n#define vvi vector<vi>\\n#define sz(x) x.size()\\n#define rep(i,a,b) for(int i = a;i<b;i++)\\n\\nclass Solution {\\npublic:\\n\\n    vi topoSort(const vector<vi> gr) {\\n        vi indeg(sz(gr)), ret;\\n        for (auto& li : gr) for (int x : li) indeg[x]++;\\n        queue<int> q; \\n        rep(i,0,sz(gr)) if (indeg[i] == 0) q.push(i);\\n        while (!q.empty()) {\\n            int i = q.front(); \\n            ret.push_back(i);\\n            q.pop();\\n            for (int x : gr[i])\\n                if (--indeg[x] == 0) q.push(x);\\n        }\\n        return ret.size()==gr.size()?ret:vector<int>();\\n    }\\n\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& p, vector<vector<int>>& q) {\\n        vvi edges1(k),edges2(k);\\n        for(auto i:p)\\n            edges1[i[0]-1].push_back(i[1]-1);\\n        for(auto i:q)   \\n            edges2[i[0]-1].push_back(i[1]-1);\\n        \\n        vi xi = topoSort(edges1);\\n        vi yi = topoSort(edges2);\\n        if(yi.size()==0 or xi.size()==0) return {};\\n        \\n        unordered_map<int,int>xc;\\n        for(int i = 0;i<k;i++) xc[xi[i]] = i;\\n        \\n        unordered_map<int,int>yc;\\n        for(int i = 0;i<k;i++) yc[yi[i]] = i;\\n        vector<vector<int>> ans(k,vector<int>(k,0));\\n        \\n        for(int i = 0;i<k;i++) \\n            ans[xc[i]][yc[i]] = i+1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2494658,
                "title": "c-code-short-and-simple",
                "content": "class Solution {\\npublic:\\n    \\n    vector<int> solve(int k, vector<vector<int>>& vr){\\n        \\n        vector<vector<int>> adjr(k+1);\\n        vector<int> cnt(k+1,0), pos(k+1);\\n        \\n        for(auto v:vr){\\n            adjr[v[0]].push_back(v[1]);\\n            cnt[v[1]]++;\\n        }\\n        \\n        queue<int> q;\\n        \\n        for(int i = 1; i <= k; i++){\\n            if(cnt[i]==0) q.push(i);\\n        }\\n        \\n        int n = 0, p = 0;\\n        \\n        while(q.size()){\\n            int u = q.front();\\n            q.pop();\\n            \\n            pos[u] = p++;\\n            n++;\\n            \\n            for(int v:adjr[u]){\\n                if(--cnt[v]==0){\\n                    q.push(v);\\n                }\\n            }\\n        }\\n        \\n        if(n!=k) return {};\\n        \\n        return pos;\\n    }\\n    \\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& vr, vector<vector<int>>& vc) {\\n        \\n        vector<int> v1 = solve(k,vr);\\n        if(!v1.size()) return {};\\n        vector<int> v2 = solve(k,vc);\\n        if(!v2.size()) return {};\\n        \\n        vector<vector<int>> ans(k,vector<int>(k,0));\\n        \\n        for(int x = 1; x <= k; x++){\\n            ans[v1[x]][v2[x]] = x;\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    vector<int> solve(int k, vector<vector<int>>& vr){\\n        \\n        vector<vector<int>> adjr(k+1);\\n        vector<int> cnt(k+1,0), pos(k+1);\\n        \\n        for(auto v:vr){\\n            adjr[v[0]].push_back(v[1]);\\n            cnt[v[1]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2494313,
                "title": "c-clean-code-topological-sort",
                "content": "**Code** : \\n```\\nclass Solution {\\npublic:\\n    \\n    bool dfs(int v,vector<int> adj[],vector<int> &visited,vector<int> &dfsVis,vector<int> &ans) {\\n        visited[v] = 1;dfsVis[v]=1;\\n        for (int u : adj[v]) {\\n            if (!visited[u]){\\n                if(!dfs(u,adj,visited,dfsVis,ans)) return false;\\n            }\\n            else if(dfsVis[u]) return false;\\n        }\\n        ans.push_back(v);\\n        dfsVis[v]=0;\\n        return true;\\n    }\\n    \\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rc, vector<vector<int>>& cc) {\\n        \\n        vector<int> adjr[k+1],adjc[k+1];\\n        for(auto &v:rc){\\n            adjr[v[0]].push_back(v[1]);\\n        }\\n        for(auto &v:cc){\\n            adjc[v[0]].push_back(v[1]);\\n        }       \\n        \\n        vector<int> vis(k+1,0),dfsVis(k+1,0);\\n        vector<int> ans;\\n        \\n        map<int,int> row,col;\\n        \\n        for (int i = 1; i <=k; ++i) {\\n            if (!vis[i])\\n                {if(!dfs(i,adjr,vis,dfsVis,ans)) return {};}\\n        }\\n        reverse(ans.begin(), ans.end());\\n        \\n        for(int i=0;i<ans.size();i++) row[ans[i]]=i;\\n        ans.clear();vis.clear();dfsVis.clear();\\n        \\n        vector<int> ans2;vector<int> vis2(k+1,0),dfsVis2(k+1,0);\\n        for (int i = 1; i <=k; ++i) {\\n            if (!vis2[i])\\n                {if(!dfs(i,adjc,vis2,dfsVis2,ans2)) return {};}\\n        }\\n        reverse(ans2.begin(), ans2.end());        \\n        \\n        for(int i=0;i<ans2.size();i++) col[ans2[i]]=i;\\n        \\n        \\n        vector<vector<int>> fin(k,vector<int>(k,0));\\n        \\n        for(int i=1;i<=k;i++){\\n            fin[row[i]][col[i]]=i;\\n        }\\n        return fin;\\n    }\\n};\\n```\\n\\nHope this helps :)",
                "solutionTags": [
                    "C",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool dfs(int v,vector<int> adj[],vector<int> &visited,vector<int> &dfsVis,vector<int> &ans) {\\n        visited[v] = 1;dfsVis[v]=1;\\n        for (int u : adj[v]) {\\n            if (!visited[u]){\\n                if(!dfs(u,adj,visited,dfsVis,ans)) return false;\\n            }\\n            else if(dfsVis[u]) return false;\\n        }\\n        ans.push_back(v);\\n        dfsVis[v]=0;\\n        return true;\\n    }\\n    \\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rc, vector<vector<int>>& cc) {\\n        \\n        vector<int> adjr[k+1],adjc[k+1];\\n        for(auto &v:rc){\\n            adjr[v[0]].push_back(v[1]);\\n        }\\n        for(auto &v:cc){\\n            adjc[v[0]].push_back(v[1]);\\n        }       \\n        \\n        vector<int> vis(k+1,0),dfsVis(k+1,0);\\n        vector<int> ans;\\n        \\n        map<int,int> row,col;\\n        \\n        for (int i = 1; i <=k; ++i) {\\n            if (!vis[i])\\n                {if(!dfs(i,adjr,vis,dfsVis,ans)) return {};}\\n        }\\n        reverse(ans.begin(), ans.end());\\n        \\n        for(int i=0;i<ans.size();i++) row[ans[i]]=i;\\n        ans.clear();vis.clear();dfsVis.clear();\\n        \\n        vector<int> ans2;vector<int> vis2(k+1,0),dfsVis2(k+1,0);\\n        for (int i = 1; i <=k; ++i) {\\n            if (!vis2[i])\\n                {if(!dfs(i,adjc,vis2,dfsVis2,ans2)) return {};}\\n        }\\n        reverse(ans2.begin(), ans2.end());        \\n        \\n        for(int i=0;i<ans2.size();i++) col[ans2[i]]=i;\\n        \\n        \\n        vector<vector<int>> fin(k,vector<int>(k,0));\\n        \\n        for(int i=1;i<=k;i++){\\n            fin[row[i]][col[i]]=i;\\n        }\\n        return fin;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2494236,
                "title": "topological-sort-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> toposort(int k, vector<vector<int> > &graph, vector<int> &indg) {\\n        vector<int> ans;\\n        queue<int> q;\\n        for(int i = 1; i <= k; i++) {\\n            if(indg[i] == 0) q.push(i);\\n        }\\n        while(!q.empty()) {\\n            int node = q.front();\\n            q.pop();\\n            ans.push_back(node);\\n            for(auto nbr : graph[node]) {\\n                indg[nbr]--;\\n                if(indg[nbr] == 0) {\\n                    q.push(nbr);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        vector<int> indgr(k+1, 0), indgc(k+1, 0);\\n        vector<vector<int> > graphr(k+1), graphc(k+1);\\n        for(auto v : rowConditions) {\\n            graphr[v[0]].push_back(v[1]);\\n            indgr[v[1]]++;\\n        }\\n        for(auto v : colConditions) {\\n            graphc[v[0]].push_back(v[1]);\\n            indgc[v[1]]++;\\n        }\\n        vector<int> order1 = toposort(k, graphr, indgr);\\n        vector<int> order2 = toposort(k, graphc, indgc);\\n        if(order1.size() != k || order2.size() != k) return {};\\n        vector<pair<int, int> > ans(k+1);\\n        for(int i = 0; i < k; i++) {\\n            ans[order1[i]].first = i;\\n            ans[order2[i]].second = i;\\n        }\\n        vector<vector<int> > res(k, vector<int>(k, 0));\\n        for(int i = 1; i <= k; i++) {\\n            res[ans[i].first][ans[i].second] = i;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> toposort(int k, vector<vector<int> > &graph, vector<int> &indg) {\\n        vector<int> ans;\\n        queue<int> q;\\n        for(int i = 1; i <= k; i++) {\\n            if(indg[i] == 0) q.push(i);\\n        }\\n        while(!q.empty()) {\\n            int node = q.front();\\n            q.pop();\\n            ans.push_back(node);\\n            for(auto nbr : graph[node]) {\\n                indg[nbr]--;\\n                if(indg[nbr] == 0) {\\n                    q.push(nbr);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        vector<int> indgr(k+1, 0), indgc(k+1, 0);\\n        vector<vector<int> > graphr(k+1), graphc(k+1);\\n        for(auto v : rowConditions) {\\n            graphr[v[0]].push_back(v[1]);\\n            indgr[v[1]]++;\\n        }\\n        for(auto v : colConditions) {\\n            graphc[v[0]].push_back(v[1]);\\n            indgc[v[1]]++;\\n        }\\n        vector<int> order1 = toposort(k, graphr, indgr);\\n        vector<int> order2 = toposort(k, graphc, indgc);\\n        if(order1.size() != k || order2.size() != k) return {};\\n        vector<pair<int, int> > ans(k+1);\\n        for(int i = 0; i < k; i++) {\\n            ans[order1[i]].first = i;\\n            ans[order2[i]].second = i;\\n        }\\n        vector<vector<int> > res(k, vector<int>(k, 0));\\n        for(int i = 1; i <= k; i++) {\\n            res[ans[i].first][ans[i].second] = i;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2494198,
                "title": "python-3-topological-sort-ez-to-understand",
                "content": "Intuition: For each row/col conditions, consider them as a directed edge. For example, in the given test case: ![image](https://assets.leetcode.com/users/images/02b8630c-10ae-416a-9240-64d30480a966_1661670161.2752652.png)\\n\\nrow_conditions could be represented as two edges: 1 -> 2 and 3 -> 2. This could work because there\\'s no cycle in the graph (consider if we have 1 -> 2 and 2 -> 1, it is not possible to come up with a valid matrix because we end up in a cycle). Also we need to know the order in which the numbers could be placed, which algorithm could do both? -> topological sort! \\n\\nThe DFS code below could be an easy template for all source of topological sort problems. \\n\\n```\\nclass Solution:\\n    def buildMatrix(self, n: int, rowC: List[List[int]], colC: List[List[int]]) -> List[List[int]]:\\n\\t\\t# create two graphs, one for row and one for columns\\n        row_adj = {i: [] for i in range(1, n + 1)}\\n        col_adj = {i: [] for i in range(1, n + 1)}\\n        for u, v in rowC:\\n            row_adj[u].append(v)\\n        for u, v in colC:\\n            col_adj[u].append(v)\\n            \\n        # inorder to do topological sort, we need to maintain two visit lists: one marks which node \\n        # we have already processed (because not all nodes are connected to each other and we do not \\n        # want to end up in a infinite loop), the other one marks nodes we are currently visiting(or in \\n        # our recursion stack). If we visit a node that we are currently visiting, that means there is \\n        # a loop, so we return False; if it is not in our current visit but has already been visited, we \\n        # can safely travel to the next node and return True. \\n\\n        row_stack = []\\n        row_visit = set()\\n        row_visiting = set()\\n        col_stack = []\\n        col_visit = set()\\n        col_visiting = set()\\n        \\n        def dfs(node, stack, visit, visiting, adj):\\n            if node in visiting:\\n                return False\\n            if node in visit:\\n                return True\\n            visit.add(node)\\n            visiting.add(node)\\n            for child in adj[node]:\\n                if not dfs(child, stack, visit, visiting, adj):\\n                    return False\\n            visiting.remove(node)\\n            stack.append(node)\\n            return True\\n        \\n        # do dfs on each row/col graph\\n        for i in range(1, n + 1):\\n            if i not in row_visit:\\n                if not dfs(i, row_stack, row_visit, row_visiting, row_adj):\\n                    return []\\n            if i not in col_visit:\\n                if not dfs(i, col_stack, col_visit, col_visiting, col_adj):\\n                    return []\\n\\n\\t\\t    \\n\\n        # After the dfs, we also need a stack to store which node has been entirely explored. That\\'s why we \\n        # append the current node to our stack after exploring all its neighbors. Remember we have to reverse \\n        # the stack after all DFS\\'s, because the first-explored node gets appended first. \\n        row_stack, col_stack = row_stack[::-1], col_stack[::-1]\\n        \\n        \\n        # mark position for each element\\n        row_memo, col_memo = {}, {}\\n        for idx, num in enumerate(row_stack):\\n            row_memo[num] = idx\\n        for idx, num in enumerate(col_stack):\\n            col_memo[num] = idx\\n            \\n        # create an empty matrix as our ans\\n        ans = [[0]*n for _ in range(n)]\\n        \\n        # plug in values from what we have discovered\\n        for i in range(1, n + 1):\\n            ans[row_memo[i]][col_memo[i]] = i\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution:\\n    def buildMatrix(self, n: int, rowC: List[List[int]], colC: List[List[int]]) -> List[List[int]]:\\n\\t\\t# create two graphs, one for row and one for columns\\n        row_adj = {i: [] for i in range(1, n + 1)}\\n        col_adj = {i: [] for i in range(1, n + 1)}\\n        for u, v in rowC:\\n            row_adj[u].append(v)\\n        for u, v in colC:\\n            col_adj[u].append(v)\\n            \\n        # inorder to do topological sort, we need to maintain two visit lists: one marks which node \\n        # we have already processed (because not all nodes are connected to each other and we do not \\n        # want to end up in a infinite loop), the other one marks nodes we are currently visiting(or in \\n        # our recursion stack). If we visit a node that we are currently visiting, that means there is \\n        # a loop, so we return False; if it is not in our current visit but has already been visited, we \\n        # can safely travel to the next node and return True. \\n\\n        row_stack = []\\n        row_visit = set()\\n        row_visiting = set()\\n        col_stack = []\\n        col_visit = set()\\n        col_visiting = set()\\n        \\n        def dfs(node, stack, visit, visiting, adj):\\n            if node in visiting:\\n                return False\\n            if node in visit:\\n                return True\\n            visit.add(node)\\n            visiting.add(node)\\n            for child in adj[node]:\\n                if not dfs(child, stack, visit, visiting, adj):\\n                    return False\\n            visiting.remove(node)\\n            stack.append(node)\\n            return True\\n        \\n        # do dfs on each row/col graph\\n        for i in range(1, n + 1):\\n            if i not in row_visit:\\n                if not dfs(i, row_stack, row_visit, row_visiting, row_adj):\\n                    return []\\n            if i not in col_visit:\\n                if not dfs(i, col_stack, col_visit, col_visiting, col_adj):\\n                    return []\\n\\n\\t\\t    \\n\\n        # After the dfs, we also need a stack to store which node has been entirely explored. That\\'s why we \\n        # append the current node to our stack after exploring all its neighbors. Remember we have to reverse \\n        # the stack after all DFS\\'s, because the first-explored node gets appended first. \\n        row_stack, col_stack = row_stack[::-1], col_stack[::-1]\\n        \\n        \\n        # mark position for each element\\n        row_memo, col_memo = {}, {}\\n        for idx, num in enumerate(row_stack):\\n            row_memo[num] = idx\\n        for idx, num in enumerate(col_stack):\\n            col_memo[num] = idx\\n            \\n        # create an empty matrix as our ans\\n        ans = [[0]*n for _ in range(n)]\\n        \\n        # plug in values from what we have discovered\\n        for i in range(1, n + 1):\\n            ans[row_memo[i]][col_memo[i]] = i\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2493965,
                "title": "simple-topological-sort-java",
                "content": "```\\n        class TopologicalSortOutput {\\n    \\n    boolean isPossible ;\\n    int [] order ;\\n}\\n\\n\\nclass Solution {\\n    public int[][] buildMatrix(int k, int[][] rowConditions, int[][] colConditions) {\\n        \\n        int[][] matrix = new int[k][k];\\n        \\n        \\n        TopologicalSortOutput output = sortTopological(k, rowConditions);\\n        if (!output.isPossible){\\n            return new int[0][0];\\n        }\\n        \\n        int[] rowOrder = output.order;\\n        int[] rowLocation = new int[k];\\n        int currInd= 0 ;\\n        \\n        for (int num : rowOrder){\\n            matrix[currInd][0] = num ;\\n            rowLocation[num-1] = currInd ;\\n            currInd++ ;\\n        }\\n        \\n        \\n        output = sortTopological(k, colConditions);\\n        if (!output.isPossible){\\n            return new int[0][0];\\n        }\\n        \\n        int[] colOrder = output.order ;\\n        for (int i=0; i < k ; i++){\\n            \\n            int currElementRowLocation = rowLocation[colOrder[i]-1] ;\\n            matrix[currElementRowLocation][0] = 0 ;\\n            matrix[currElementRowLocation][i] = colOrder[i];\\n        }\\n        \\n        \\n        return matrix ;\\n    }\\n    \\n    \\n    private TopologicalSortOutput sortTopological(int k , int [][] dependencies){\\n        \\n        \\n        Map<Integer, Set<Integer>> graph = new HashMap<>();\\n        int [] indegreeCount = new int[k+1] ;\\n        \\n        for (int [] edge :dependencies){\\n            \\n            graph.putIfAbsent(edge[0], new HashSet<>());\\n            graph.get(edge[0]).add(edge[1]);\\n        }\\n        \\n        \\n        for (Map.Entry<Integer, Set<Integer>> entry: graph.entrySet()){\\n            \\n            for (int node: entry.getValue()){\\n                indegreeCount[node]++ ;\\n            }\\n        }\\n        \\n        Queue<Integer> queue = new LinkedList<>();\\n        Set<Integer> visited = new HashSet<>();\\n        \\n        for (int i=1 ; i <=k; i++){\\n            if (indegreeCount[i] == 0) {\\n                queue.add(i);\\n                visited.add(i);\\n            }\\n        }\\n        \\n        int [] order = new int[k];\\n        int i= 0 ;\\n        while(!queue.isEmpty()){\\n            \\n            int node = queue.poll();\\n            order[i++] = node;\\n            \\n            Set<Integer> adjNodes = graph.get(node);\\n            if (adjNodes == null){\\n                continue ;\\n            }\\n            \\n            for(int adjNode : adjNodes) {\\n                \\n                if (!visited.contains(adjNode)) {\\n                    indegreeCount[adjNode]-- ;\\n                \\n                    if (indegreeCount[adjNode] == 0){\\n                        \\n                        queue.add(adjNode);\\n                        visited.add(adjNode);\\n                    }\\n                \\n                }\\n            }\\n            \\n        }\\n        \\n        TopologicalSortOutput output = new TopologicalSortOutput();\\n        output.order = order ;\\n        output.isPossible = visited.size() == k ;\\n        \\n        // System.out.println(Arrays.toString(order));\\n        \\n        return output ;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\n        class TopologicalSortOutput {\\n    \\n    boolean isPossible ;\\n    int [] order ;\\n}\\n\\n\\nclass Solution {\\n    public int[][] buildMatrix(int k, int[][] rowConditions, int[][] colConditions) {\\n        \\n        int[][] matrix = new int[k][k];\\n        \\n        \\n        TopologicalSortOutput output = sortTopological(k, rowConditions);\\n        if (!output.isPossible){\\n            return new int[0][0];\\n        }\\n        \\n        int[] rowOrder = output.order;\\n        int[] rowLocation = new int[k];\\n        int currInd= 0 ;\\n        \\n        for (int num : rowOrder){\\n            matrix[currInd][0] = num ;\\n            rowLocation[num-1] = currInd ;\\n            currInd++ ;\\n        }\\n        \\n        \\n        output = sortTopological(k, colConditions);\\n        if (!output.isPossible){\\n            return new int[0][0];\\n        }\\n        \\n        int[] colOrder = output.order ;\\n        for (int i=0; i < k ; i++){\\n            \\n            int currElementRowLocation = rowLocation[colOrder[i]-1] ;\\n            matrix[currElementRowLocation][0] = 0 ;\\n            matrix[currElementRowLocation][i] = colOrder[i];\\n        }\\n        \\n        \\n        return matrix ;\\n    }\\n    \\n    \\n    private TopologicalSortOutput sortTopological(int k , int [][] dependencies){\\n        \\n        \\n        Map<Integer, Set<Integer>> graph = new HashMap<>();\\n        int [] indegreeCount = new int[k+1] ;\\n        \\n        for (int [] edge :dependencies){\\n            \\n            graph.putIfAbsent(edge[0], new HashSet<>());\\n            graph.get(edge[0]).add(edge[1]);\\n        }\\n        \\n        \\n        for (Map.Entry<Integer, Set<Integer>> entry: graph.entrySet()){\\n            \\n            for (int node: entry.getValue()){\\n                indegreeCount[node]++ ;\\n            }\\n        }\\n        \\n        Queue<Integer> queue = new LinkedList<>();\\n        Set<Integer> visited = new HashSet<>();\\n        \\n        for (int i=1 ; i <=k; i++){\\n            if (indegreeCount[i] == 0) {\\n                queue.add(i);\\n                visited.add(i);\\n            }\\n        }\\n        \\n        int [] order = new int[k];\\n        int i= 0 ;\\n        while(!queue.isEmpty()){\\n            \\n            int node = queue.poll();\\n            order[i++] = node;\\n            \\n            Set<Integer> adjNodes = graph.get(node);\\n            if (adjNodes == null){\\n                continue ;\\n            }\\n            \\n            for(int adjNode : adjNodes) {\\n                \\n                if (!visited.contains(adjNode)) {\\n                    indegreeCount[adjNode]-- ;\\n                \\n                    if (indegreeCount[adjNode] == 0){\\n                        \\n                        queue.add(adjNode);\\n                        visited.add(adjNode);\\n                    }\\n                \\n                }\\n            }\\n            \\n        }\\n        \\n        TopologicalSortOutput output = new TopologicalSortOutput();\\n        output.order = order ;\\n        output.isPossible = visited.size() == k ;\\n        \\n        // System.out.println(Arrays.toString(order));\\n        \\n        return output ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2493751,
                "title": "topological-sort-and-similar-questions",
                "content": "similar questions list below from easy to hard for you to practice\\n\\n[310. Minimum Height Trees](https://leetcode.com/problems/minimum-height-trees/)\\n[207. Course Schedule](https://leetcode.com/problems/course-schedule/)\\n[210. Course Schedule II](https://leetcode.com/problems/course-schedule-ii/)\\n[1857. Largest Color Value in a Directed Graph](https://leetcode.com/problems/largest-color-value-in-a-directed-graph/)\\n[1203. Sort Items by Groups Respecting Dependencies](https://leetcode.com/problems/sort-items-by-groups-respecting-dependencies/)\\n\\nmy solution for this question\\n```C++\\nclass Solution\\n{\\npublic:\\n\\tvector<vector<int>> buildMatrix(int k, vector<vector<int>> &rowConditions, vector<vector<int>> &colConditions)\\n\\t{\\n\\t\\tvector<int> row, col;\\n\\t\\tbool r = topologicalSort(k, rowConditions, row);\\n\\t\\tif (!r)\\n\\t\\t\\treturn {};\\n\\t\\tbool c = topologicalSort(k, colConditions, col);\\n\\t\\tif (!c)\\n\\t\\t\\treturn {};\\n\\t\\tvector<vector<int>> res(k, vector<int>(k));\\n\\t\\tvector<pair<int, int>> pos(k + 1);\\n\\t\\tfor (int i = 0; i < k; ++i)\\n\\t\\t{\\n\\t\\t\\tpos[row[i]].first = i;\\n\\t\\t\\tpos[col[i]].second = i;\\n\\t\\t}\\n\\t\\tfor (int i = 1; i <= k; ++i)\\n\\t\\t\\tres[pos[i].first][pos[i].second] = i;\\n\\t\\treturn res;\\n\\t}\\n\\n\\tbool topologicalSort(int k, vector<vector<int>> &conditions, vector<int> &tp_order)\\n\\t{\\n\\t\\tvector<int> indegree(k + 1);\\n\\t\\tvector<vector<int>> graph(k + 1);\\n\\t\\tfor (auto &con : conditions)\\n\\t\\t{\\n\\t\\t\\t++indegree[con[1]];\\n\\t\\t\\tgraph[con[0]].push_back(con[1]);\\n\\t\\t}\\n\\t\\tfor (int i = 1; i <= k; ++i)\\n\\t\\t{\\n\\t\\t\\tif (indegree[i] == 0)\\n\\t\\t\\t\\ttp_order.push_back(i);\\n\\t\\t}\\n\\t\\t// tp_order size changes\\n\\t\\tfor (int i = 0; i < (int)tp_order.size(); ++i)\\n\\t\\t{\\n\\t\\t\\tint cur = tp_order[i];\\n\\t\\t\\tfor (auto next : graph[cur])\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (--indegree[next] == 0)\\n\\t\\t\\t\\t\\ttp_order.push_back(next);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn tp_order.size() == k;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "Topological Sort"
                ],
                "code": "```C++\\nclass Solution\\n{\\npublic:\\n\\tvector<vector<int>> buildMatrix(int k, vector<vector<int>> &rowConditions, vector<vector<int>> &colConditions)\\n\\t{\\n\\t\\tvector<int> row, col;\\n\\t\\tbool r = topologicalSort(k, rowConditions, row);\\n\\t\\tif (!r)\\n\\t\\t\\treturn {};\\n\\t\\tbool c = topologicalSort(k, colConditions, col);\\n\\t\\tif (!c)\\n\\t\\t\\treturn {};\\n\\t\\tvector<vector<int>> res(k, vector<int>(k));\\n\\t\\tvector<pair<int, int>> pos(k + 1);\\n\\t\\tfor (int i = 0; i < k; ++i)\\n\\t\\t{\\n\\t\\t\\tpos[row[i]].first = i;\\n\\t\\t\\tpos[col[i]].second = i;\\n\\t\\t}\\n\\t\\tfor (int i = 1; i <= k; ++i)\\n\\t\\t\\tres[pos[i].first][pos[i].second] = i;\\n\\t\\treturn res;\\n\\t}\\n\\n\\tbool topologicalSort(int k, vector<vector<int>> &conditions, vector<int> &tp_order)\\n\\t{\\n\\t\\tvector<int> indegree(k + 1);\\n\\t\\tvector<vector<int>> graph(k + 1);\\n\\t\\tfor (auto &con : conditions)\\n\\t\\t{\\n\\t\\t\\t++indegree[con[1]];\\n\\t\\t\\tgraph[con[0]].push_back(con[1]);\\n\\t\\t}\\n\\t\\tfor (int i = 1; i <= k; ++i)\\n\\t\\t{\\n\\t\\t\\tif (indegree[i] == 0)\\n\\t\\t\\t\\ttp_order.push_back(i);\\n\\t\\t}\\n\\t\\t// tp_order size changes\\n\\t\\tfor (int i = 0; i < (int)tp_order.size(); ++i)\\n\\t\\t{\\n\\t\\t\\tint cur = tp_order[i];\\n\\t\\t\\tfor (auto next : graph[cur])\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (--indegree[next] == 0)\\n\\t\\t\\t\\t\\ttp_order.push_back(next);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn tp_order.size() == k;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2493486,
                "title": "c-solution-graph-bfs",
                "content": "```C#\\npublic class Solution {\\n    public int[][] BuildMatrix(int k, int[][] rowConditions, int[][] colConditions) {\\n        Dictionary<int, HashSet<int>> rowMap = new (), rowDepsMap = new (), colMap = new (), colDepsMap = new ();\\n        for (int i = 0; i < k; i++)\\n        {\\n            rowMap[i] = new ();\\n            rowDepsMap[i] = new ();\\n            colMap[i] = new ();\\n            colDepsMap[i] = new ();\\n        }\\n\\n        FillData(rowConditions, rowMap, rowDepsMap);\\n        FillData(colConditions, colMap, colDepsMap);\\n\\n        int[] rows = new int[k], cols = new int[k];\\n        if (Iterate(rowMap, rowDepsMap, rows) == false || Iterate(colMap, colDepsMap, cols) == false) return new int[0][];\\n\\n        int[][] ans = new int[k][];\\n        for (int i = 0; i < k; i++) ans[i] = new int[k];\\n        for (int i = 0; i < k; i++) ans[rows[i]][cols[i]] = i + 1;\\n\\n        return ans;\\n\\n        void FillData(int[][] conditions, Dictionary<int, HashSet<int>> map, Dictionary<int, HashSet<int>> depsMap)\\n        {\\n            for (int i = 0; i < conditions.Length; i++)\\n            {\\n                map[conditions[i][0] - 1].Add(conditions[i][1] - 1);\\n                depsMap[conditions[i][1] - 1].Add(conditions[i][0] - 1);\\n            }\\n        }\\n\\n        bool Iterate(Dictionary<int, HashSet<int>> map, Dictionary<int, HashSet<int>> depsMap, int[] res)\\n        {\\n            Queue<int> q = new ();\\n            foreach (var (num, deps) in depsMap)\\n            {\\n                if (deps.Count == 0) q.Enqueue(num);\\n            }\\n\\n            if (q.Count == 0) return false;\\n\\n            int index = 0;\\n            while (q.Count > 0)\\n            {\\n                int current = q.Dequeue();\\n                res[current] = index;\\n\\n                foreach (var next in map[current])\\n                {\\n                    depsMap[next].Remove(current);\\n                    if (depsMap[next].Count == 0) q.Enqueue(next);\\n                }\\n\\n                index++;\\n            }\\n\\n            return index == k;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```C#\\npublic class Solution {\\n    public int[][] BuildMatrix(int k, int[][] rowConditions, int[][] colConditions) {\\n        Dictionary<int, HashSet<int>> rowMap = new (), rowDepsMap = new (), colMap = new (), colDepsMap = new ();\\n        for (int i = 0; i < k; i++)\\n        {\\n            rowMap[i] = new ();\\n            rowDepsMap[i] = new ();\\n            colMap[i] = new ();\\n            colDepsMap[i] = new ();\\n        }\\n\\n        FillData(rowConditions, rowMap, rowDepsMap);\\n        FillData(colConditions, colMap, colDepsMap);\\n\\n        int[] rows = new int[k], cols = new int[k];\\n        if (Iterate(rowMap, rowDepsMap, rows) == false || Iterate(colMap, colDepsMap, cols) == false) return new int[0][];\\n\\n        int[][] ans = new int[k][];\\n        for (int i = 0; i < k; i++) ans[i] = new int[k];\\n        for (int i = 0; i < k; i++) ans[rows[i]][cols[i]] = i + 1;\\n\\n        return ans;\\n\\n        void FillData(int[][] conditions, Dictionary<int, HashSet<int>> map, Dictionary<int, HashSet<int>> depsMap)\\n        {\\n            for (int i = 0; i < conditions.Length; i++)\\n            {\\n                map[conditions[i][0] - 1].Add(conditions[i][1] - 1);\\n                depsMap[conditions[i][1] - 1].Add(conditions[i][0] - 1);\\n            }\\n        }\\n\\n        bool Iterate(Dictionary<int, HashSet<int>> map, Dictionary<int, HashSet<int>> depsMap, int[] res)\\n        {\\n            Queue<int> q = new ();\\n            foreach (var (num, deps) in depsMap)\\n            {\\n                if (deps.Count == 0) q.Enqueue(num);\\n            }\\n\\n            if (q.Count == 0) return false;\\n\\n            int index = 0;\\n            while (q.Count > 0)\\n            {\\n                int current = q.Dequeue();\\n                res[current] = index;\\n\\n                foreach (var next in map[current])\\n                {\\n                    depsMap[next].Remove(current);\\n                    if (depsMap[next].Count == 0) q.Enqueue(next);\\n                }\\n\\n                index++;\\n            }\\n\\n            return index == k;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2493019,
                "title": "matrix-version-of-course-schedule-ii-bfs",
                "content": "https://leetcode.com/problems/course-schedule-ii/\\n\\n\\t\\tclass Solution:\\n\\t\\t\\tdef buildMatrix(self, kk: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:\\n\\t\\t\\t\\tres = [[0]*kk for i in range(kk)]\\n\\t\\t\\t\\tdef f(a):\\n\\t\\t\\t\\t\\tpreq = {i+1:set() for i in range(kk)}\\n\\t\\t\\t\\t\\tgraph = collections.defaultdict(set)\\n\\t\\t\\t\\t\\tfor i,j in a:\\n\\t\\t\\t\\t\\t\\tpreq[i].add(j)\\n\\t\\t\\t\\t\\t\\tgraph[j].add(i)\\n\\n\\t\\t\\t\\t\\tq = collections.deque([])\\n\\t\\t\\t\\t\\tfor k, v in preq.items():\\n\\t\\t\\t\\t\\t\\tif len(v) == 0:\\n\\t\\t\\t\\t\\t\\t\\tq.append(k)\\n\\t\\t\\t\\t\\ttaken = []\\n\\t\\t\\t\\t\\twhile q:\\n\\t\\t\\t\\t\\t\\tcourse = q.popleft()\\n\\t\\t\\t\\t\\t\\ttaken.append(course)\\n\\t\\t\\t\\t\\t\\tif len(taken) == k:\\n\\t\\t\\t\\t\\t\\t\\treturn taken\\n\\t\\t\\t\\t\\t\\tfor cor in graph[course]:\\n\\t\\t\\t\\t\\t\\t\\tpreq[cor].remove(course)\\n\\t\\t\\t\\t\\t\\t\\tif not preq[cor]:\\n\\t\\t\\t\\t\\t\\t\\t\\tq.append(cor)\\n\\t\\t\\t\\t\\treturn []\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\trow = f(rowConditions)  \\n\\t\\t\\t\\tif not row: return []\\n\\t\\t\\t\\tcol = f(colConditions)\\n\\t\\t\\t\\tif not col: return []\\n\\t\\t\\t\\trow.reverse()\\n\\t\\t\\t\\tcol.reverse() \\n\\t\\t\\t\\tdp1 = {}\\n\\t\\t\\t\\tdp2 = {}\\n\\t\\t\\t\\tfor i in range(len(row)):\\n\\t\\t\\t\\t\\tdp1[row[i]] = i \\n\\t\\t\\t\\tfor i in range(len(col)):\\n\\t\\t\\t\\t\\tdp2[col[i]] = i \\n\\t\\t\\t\\tfor i in range(kk): \\n\\t\\t\\t\\t\\tres[dp1[i+1]][dp2[i+1]] =i+1\\n\\t\\t\\t\\treturn res\\n",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "class Solution:\\n\\t\\t\\tdef buildMatrix(self, kk: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:\\n\\t\\t\\t\\tres = [[0]*kk for i in range(kk)]\\n\\t\\t\\t\\tdef f(a):\\n\\t\\t\\t\\t\\tpreq = {i+1:set() for i in range(kk)}",
                "codeTag": "Java"
            },
            {
                "id": 2492794,
                "title": "python-topological-sort-with-explanation",
                "content": "Use topological sort to compute the order for row and column separately, if there are cycle in row or column, then return []. Once we have the row and column index for each number, simplly fill the result matrix based on the index.\\n\\n```\\nclass Solution:\\n    def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:\\n        def findCon(conditions):\\n            graph = defaultdict(set)\\n            inOrder = defaultdict(int)\\n            for s,e in conditions:\\n                if e not in graph[s]:\\n                    graph[s].add(e)\\n                    inOrder[e]+=1\\n            row = []\\n            visited = set()\\n            for i in range(1,k+1):\\n                if i in graph and inOrder[i]==0 and i not in visited:\\n                    q = [i]\\n                    curArr = []\\n                    while q:\\n                        cur = q.pop(0)\\n                        if cur not in visited:\\n                            visited.add(cur)\\n                            curArr.append(cur)\\n                            for nei in graph[cur]:\\n                                inOrder[nei]-=1\\n                                if inOrder[nei]==0:\\n                                    q.append(nei)\\n                    row.extend(curArr)\\n                elif i not in visited and inOrder[i]==0:\\n                    row.append(i)\\n            return row if len(row)==k else []\\n        \\n        row = findCon(rowConditions)\\n        col = findCon(colConditions)\\n        if row==[] or col==[]:\\n            return []\\n        \\n        res = [[0 for _ in range(k)] for _ in range(k)]\\n        \\n        DictCol = defaultdict(int)\\n        for i,n in enumerate(col):\\n            DictCol[n] = i\\n            \\n        DictRow = defaultdict(int)\\n        for i,n in enumerate(row):\\n            DictRow[n] = i\\n\\n        for i in range(1,k+1):\\n            if i in DictRow and i in DictCol:\\n                res[DictRow[i]][DictCol[i]] = i\\n            elif i in DictRow:\\n                res[DictRow[i]][k-1] = i\\n            else:\\n                res[k-1][DictCol[i]] = i\\n\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:\\n        def findCon(conditions):\\n            graph = defaultdict(set)\\n            inOrder = defaultdict(int)\\n            for s,e in conditions:\\n                if e not in graph[s]:\\n                    graph[s].add(e)\\n                    inOrder[e]+=1\\n            row = []\\n            visited = set()\\n            for i in range(1,k+1):\\n                if i in graph and inOrder[i]==0 and i not in visited:\\n                    q = [i]\\n                    curArr = []\\n                    while q:\\n                        cur = q.pop(0)\\n                        if cur not in visited:\\n                            visited.add(cur)\\n                            curArr.append(cur)\\n                            for nei in graph[cur]:\\n                                inOrder[nei]-=1\\n                                if inOrder[nei]==0:\\n                                    q.append(nei)\\n                    row.extend(curArr)\\n                elif i not in visited and inOrder[i]==0:\\n                    row.append(i)\\n            return row if len(row)==k else []\\n        \\n        row = findCon(rowConditions)\\n        col = findCon(colConditions)\\n        if row==[] or col==[]:\\n            return []\\n        \\n        res = [[0 for _ in range(k)] for _ in range(k)]\\n        \\n        DictCol = defaultdict(int)\\n        for i,n in enumerate(col):\\n            DictCol[n] = i\\n            \\n        DictRow = defaultdict(int)\\n        for i,n in enumerate(row):\\n            DictRow[n] = i\\n\\n        for i in range(1,k+1):\\n            if i in DictRow and i in DictCol:\\n                res[DictRow[i]][DictCol[i]] = i\\n            elif i in DictRow:\\n                res[DictRow[i]][k-1] = i\\n            else:\\n                res[k-1][DictCol[i]] = i\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2492784,
                "title": "easy-topological-sort-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<int>& visited,vector<int> adj[],int src,vector<int>& topoorder){\\n        visited[src]=1;\\n        for(int &nbr:adj[src]){\\n            if(visited[nbr]==0)\\n                dfs(visited,adj,nbr,topoorder);\\n            if(visited[nbr]==1) return;\\n        }\\n        visited[src]=2;\\n        topoorder.push_back(src);\\n    }\\n    \\n    vector<int> topo(int n,vector<vector<int>>& edges){\\n        vector<int> visited(n+1,0);\\n        vector<int> adj[n+1];\\n        vector<int>  topoorder;\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        for(int i=1;i<=n;i++){\\n            if(visited[i]==0){\\n                dfs(visited,adj,i,topoorder);\\n            }\\n        }\\n        if(topoorder.size()!=n) return {};\\n        return topoorder;\\n    }\\n    \\n    vector<vector<int>> buildMatrix(int k,vector<vector<int>>& rowe,vector<vector<int>>& cole){\\n        vector<int> vert=topo(k,rowe);\\n        vector<int> hort=topo(k,cole);\\n        if(hort.empty() || vert.empty()) return {};\\n        vector<vector<int>> ans(k,vector<int> (k,0));\\n        map<int,pair<int,int>> mp;\\n        for(int i=0;i<k;i++){\\n            mp[vert[i]]={i,-1};\\n        }\\n        for(int i=0;i<k;i++){\\n            mp[hort[i]].second=i;\\n        }\\n        for(auto it=mp.begin();it!=mp.end();it++){\\n            int key=it->first;\\n            int x=it->second.first;\\n            int y=it->second.second;\\n            ans[x][y]=key;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<int>& visited,vector<int> adj[],int src,vector<int>& topoorder){\\n        visited[src]=1;\\n        for(int &nbr:adj[src]){\\n            if(visited[nbr]==0)\\n                dfs(visited,adj,nbr,topoorder);\\n            if(visited[nbr]==1) return;\\n        }\\n        visited[src]=2;\\n        topoorder.push_back(src);\\n    }\\n    \\n    vector<int> topo(int n,vector<vector<int>>& edges){\\n        vector<int> visited(n+1,0);\\n        vector<int> adj[n+1];\\n        vector<int>  topoorder;\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        for(int i=1;i<=n;i++){\\n            if(visited[i]==0){\\n                dfs(visited,adj,i,topoorder);\\n            }\\n        }\\n        if(topoorder.size()!=n) return {};\\n        return topoorder;\\n    }\\n    \\n    vector<vector<int>> buildMatrix(int k,vector<vector<int>>& rowe,vector<vector<int>>& cole){\\n        vector<int> vert=topo(k,rowe);\\n        vector<int> hort=topo(k,cole);\\n        if(hort.empty() || vert.empty()) return {};\\n        vector<vector<int>> ans(k,vector<int> (k,0));\\n        map<int,pair<int,int>> mp;\\n        for(int i=0;i<k;i++){\\n            mp[vert[i]]={i,-1};\\n        }\\n        for(int i=0;i<k;i++){\\n            mp[hort[i]].second=i;\\n        }\\n        for(auto it=mp.begin();it!=mp.end();it++){\\n            int key=it->first;\\n            int x=it->second.first;\\n            int y=it->second.second;\\n            ans[x][y]=key;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2492744,
                "title": "python-easy-topological-sort-solution",
                "content": "```\\n    # intuition: use graph to describe the dependency from the rules, \\n    # and then use topological sort to get the order for both row and col\\n    def buildMatrix(self, k, rowCond, colCond):\\n        \"\"\"\\n        :type k: int\\n        :type rowConditions: List[List[int]]\\n        :type colConditions: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        def topoSort(k, cond):\\n            nei = collections.defaultdict(list)\\n            for s, e in cond:\\n                nei[e].append(s)\\n            \\n            def helper(i):\\n                if i in visited and visited[i] == -1:\\n                    return False\\n                if i in visited and visited[i] == 1:\\n                    return True\\n                visited[i] = -1\\n                for n in nei[i]:\\n                    if not helper(n):\\n                        return False \\n                res.append(i)\\n                visited[i] = 1\\n                return True\\n            \\n            res = []\\n            visited = {}\\n            for i in range(1, k + 1):\\n                if not helper(i):\\n                    return []\\n            return res\\n    \\n        rowOrder = topoSort(k, rowCond)\\n        if rowOrder == []:\\n            return []\\n        colOrder = topoSort(k, colCond)\\n        if colOrder == []:\\n            return []\\n        colMap = {}\\n        for i in range(len(colOrder)):\\n            colMap[colOrder[i]] = i\\n        \\n        res = [[0 for j in range(k)] for i in range(k)]\\n        for i in range(len(rowOrder)):\\n            res[i][colMap[rowOrder[i]]] = rowOrder[i]\\n        return res\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Topological Sort"
                ],
                "code": "```\\n    # intuition: use graph to describe the dependency from the rules, \\n    # and then use topological sort to get the order for both row and col\\n    def buildMatrix(self, k, rowCond, colCond):\\n        \"\"\"\\n        :type k: int\\n        :type rowConditions: List[List[int]]\\n        :type colConditions: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        def topoSort(k, cond):\\n            nei = collections.defaultdict(list)\\n            for s, e in cond:\\n                nei[e].append(s)\\n            \\n            def helper(i):\\n                if i in visited and visited[i] == -1:\\n                    return False\\n                if i in visited and visited[i] == 1:\\n                    return True\\n                visited[i] = -1\\n                for n in nei[i]:\\n                    if not helper(n):\\n                        return False \\n                res.append(i)\\n                visited[i] = 1\\n                return True\\n            \\n            res = []\\n            visited = {}\\n            for i in range(1, k + 1):\\n                if not helper(i):\\n                    return []\\n            return res\\n    \\n        rowOrder = topoSort(k, rowCond)\\n        if rowOrder == []:\\n            return []\\n        colOrder = topoSort(k, colCond)\\n        if colOrder == []:\\n            return []\\n        colMap = {}\\n        for i in range(len(colOrder)):\\n            colMap[colOrder[i]] = i\\n        \\n        res = [[0 for j in range(k)] for i in range(k)]\\n        for i in range(len(rowOrder)):\\n            res[i][colMap[rowOrder[i]]] = rowOrder[i]\\n        return res\\n            \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3973285,
                "title": "best-solution-using-bfs-topological-sort",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> bfs(vector<vector<int>>& conditions, int k) {\\n        vector<vector<int>> adj(k + 1);\\n        vector<int> indegree(k + 1, 0);\\n\\n        for (int i = 0; i < conditions.size(); i++) {\\n            int above = conditions[i][0];\\n            int below = conditions[i][1];\\n            indegree[below]++;\\n            adj[above].push_back(below);\\n        }\\n        vector<int> ans;\\n        queue<int> q;\\n\\n        for (int i = 1; i <= k; i++) {\\n            if (indegree[i] == 0) {\\n                q.push(i);\\n            }\\n        }\\n\\n        while (!q.empty()) {\\n            int node = q.front();\\n            q.pop();\\n            ans.push_back(node);\\n\\n            for (auto x : adj[node]) {\\n                indegree[x]--;\\n                if (indegree[x] == 0) {\\n                    q.push(x);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        vector<int> rowOrder = bfs(rowConditions, k);\\n        vector<int> colOrder = bfs(colConditions, k);\\n\\n        if (colOrder.size() != k || rowOrder.size() != k)\\n            return {};\\n\\n        vector<vector<int>> validmatrix(k, vector<int>(k, 0));\\n        for (int i = 0; i < k; i++) {\\n            for (int j = 0; j < k; j++) {\\n                if (colOrder[i] == rowOrder[j]) {\\n                    validmatrix[j][i] = colOrder[i]; // Corrected indexing here\\n                }\\n            }\\n        }\\n        return validmatrix;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> bfs(vector<vector<int>>& conditions, int k) {\\n        vector<vector<int>> adj(k + 1);\\n        vector<int> indegree(k + 1, 0);\\n\\n        for (int i = 0; i < conditions.size(); i++) {\\n            int above = conditions[i][0];\\n            int below = conditions[i][1];\\n            indegree[below]++;\\n            adj[above].push_back(below);\\n        }\\n        vector<int> ans;\\n        queue<int> q;\\n\\n        for (int i = 1; i <= k; i++) {\\n            if (indegree[i] == 0) {\\n                q.push(i);\\n            }\\n        }\\n\\n        while (!q.empty()) {\\n            int node = q.front();\\n            q.pop();\\n            ans.push_back(node);\\n\\n            for (auto x : adj[node]) {\\n                indegree[x]--;\\n                if (indegree[x] == 0) {\\n                    q.push(x);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        vector<int> rowOrder = bfs(rowConditions, k);\\n        vector<int> colOrder = bfs(colConditions, k);\\n\\n        if (colOrder.size() != k || rowOrder.size() != k)\\n            return {};\\n\\n        vector<vector<int>> validmatrix(k, vector<int>(k, 0));\\n        for (int i = 0; i < k; i++) {\\n            for (int j = 0; j < k; j++) {\\n                if (colOrder[i] == rowOrder[j]) {\\n                    validmatrix[j][i] = colOrder[i]; // Corrected indexing here\\n                }\\n            }\\n        }\\n        return validmatrix;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3959444,
                "title": "c-using-topological-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nconsider each rowConditions,ColConditions as graph and find topological sort order using kahn\\'s algorithm for each, and place in that positions.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    vector<int> topo(int n,vector<vector<int>> &graph)\\n    {\\n        vector<vector<int>> adj(n+1);\\n        vector<int> indegree(n+1,0);\\n        for(auto i:graph)   {\\n            adj[i[0]].push_back(i[1]);\\n            indegree[i[1]]++;\\n        }\\n        queue<int> q;\\n        int count=0;\\n        for(int i=1;i<=n;i++)   if(indegree[i]==0)  q.push(i);\\n        vector<int> ans;\\n        while(!q.empty())\\n        {\\n            int i=q.front();\\n            q.pop();\\n            count++;\\n            ans.push_back(i);\\n            for(auto j:adj[i]){\\n                indegree[j]--;\\n                if(indegree[j]==0)  q.push(j);\\n            }\\n        }\\n        if(count!=n)    return {};\\n        return ans;\\n    }\\n\\n\\n\\n\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        vector<int> row(k+1),col(k+1);\\n        vector<int> v1=topo(k,rowConditions);\\n        if(v1.empty()) return {};\\n        vector<int> v2=topo(k,colConditions);\\n        if(v2.empty()) return {};\\n        vector<vector<int>> ans(k,vector<int> (k,0));\\n        unordered_map<int,int> m;\\n        for(int i=0;i<k;i++)    m[v2[i]]=i;\\n        for(int i=0;i<k;i++)\\n        {\\n            ans[i][m[v1[i]]]=v1[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Topological Sort",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<int> topo(int n,vector<vector<int>> &graph)\\n    {\\n        vector<vector<int>> adj(n+1);\\n        vector<int> indegree(n+1,0);\\n        for(auto i:graph)   {\\n            adj[i[0]].push_back(i[1]);\\n            indegree[i[1]]++;\\n        }\\n        queue<int> q;\\n        int count=0;\\n        for(int i=1;i<=n;i++)   if(indegree[i]==0)  q.push(i);\\n        vector<int> ans;\\n        while(!q.empty())\\n        {\\n            int i=q.front();\\n            q.pop();\\n            count++;\\n            ans.push_back(i);\\n            for(auto j:adj[i]){\\n                indegree[j]--;\\n                if(indegree[j]==0)  q.push(j);\\n            }\\n        }\\n        if(count!=n)    return {};\\n        return ans;\\n    }\\n\\n\\n\\n\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        vector<int> row(k+1),col(k+1);\\n        vector<int> v1=topo(k,rowConditions);\\n        if(v1.empty()) return {};\\n        vector<int> v2=topo(k,colConditions);\\n        if(v2.empty()) return {};\\n        vector<vector<int>> ans(k,vector<int> (k,0));\\n        unordered_map<int,int> m;\\n        for(int i=0;i<k;i++)    m[v2[i]]=i;\\n        for(int i=0;i<k;i++)\\n        {\\n            ans[i][m[v1[i]]]=v1[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3881180,
                "title": "understandable-98-efficient-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    // This funtion here check whether there is any cycle in the graph, So that it will be help full to return the empty matrix\\n    bool fact(int i,vector<int>adj[],unordered_map<int,bool>&vis,vector<int>&pathvis){\\n        vis[i]=1;\\n        pathvis[i]=1;\\n        for(auto x:adj[i]){\\n            if(!vis[x]){\\n                if(fact(x,adj,vis,pathvis)) return 1;\\n            }else if(pathvis[x]) return 1;\\n        }\\n        pathvis[i]=0;\\n        return 0;\\n    }\\n    // This function here gives the topological order of the row and col matrix given.\\n    void dfs(int i,vector<int>adj[],stack<int>&st,unordered_map<int,bool>&vis){\\n        vis[i]=1;\\n        for(auto x:adj[i]){\\n            if(!vis[x]){\\n                dfs(x,adj,st,vis);\\n            }\\n        }\\n        st.push(i);\\n    }\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        vector<int>r,c;\\n        stack<int>st1,st2;\\n        vector<int>adj1[k],adj2[k];\\n        vector<vector<int>>ans(k,vector<int>(k,0));\\n        for(auto x:rowConditions){\\n            adj1[x[0]-1].push_back(x[1]-1);\\n        }\\n        for(auto x:colConditions){\\n            adj2[x[0]-1].push_back(x[1]-1);\\n        }\\n        // This is for the cycle check for adj1\\n        unordered_map<int,bool>vis1,vis2,vis;\\n        vector<int>pathvis(k,0);\\n        for(int i=0;i<k;i++){\\n            if(!vis[i]){\\n                if(fact(i,adj1,vis,pathvis)==1) return {};\\n            }\\n        }\\n        vis.clear();\\n        pathvis.clear();\\n        // This is for the cycle check for adj2\\n         for(int i=0;i<k;i++){\\n            if(!vis[i]){\\n                if(fact(i,adj2,vis,pathvis)==1) return {};\\n            }\\n        }\\n        // This is for the topo sort\\n        for(int i=0;i<k;i++){\\n            if(!vis1[i]){\\n                dfs(i,adj1,st1,vis1);\\n            }\\n            if(!vis2[i]){\\n                dfs(i,adj2,st2,vis2);\\n            }\\n        }\\n        while(!st1.empty()){\\n            r.push_back(st1.top());\\n            st1.pop();\\n        }\\n        while(!st2.empty()){\\n            c.push_back(st2.top());\\n            st2.pop();\\n        }\\n        // This is for loading the values in the matrix at correct places.\\n        unordered_map<int,int>p,q;\\n        for(int i=0;i<k;i++){\\n            p[r[i]]=i;\\n            q[c[i]]=i;\\n        }\\n        for(int i=0;i<k;i++){\\n            ans[p[r[i]]][q[r[i]]]=r[i]+1;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    // This funtion here check whether there is any cycle in the graph, So that it will be help full to return the empty matrix\\n    bool fact(int i,vector<int>adj[],unordered_map<int,bool>&vis,vector<int>&pathvis){\\n        vis[i]=1;\\n        pathvis[i]=1;\\n        for(auto x:adj[i]){\\n            if(!vis[x]){\\n                if(fact(x,adj,vis,pathvis)) return 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3858786,
                "title": "easy-topo-sort-sol-c",
                "content": "# Intuition\\nsimple sa kaam karna hai row ke liye alag se topo sort nikal lo and column ke liye alag se aur unko store karlo vectors me and phir index decide karke ans me dal do\\n\\n# Approach\\nbasic topo sort for rows and column after that main thing was how to put them in correct place  row and col vector me toposorted order me h\\nsuppose           position    0 1 2\\n                row vector is 1 3 2\\n                col vector is 3 2 1\\nek map chala ke 1 ka row postion rakh lo and ek me col positon and at the end just put them in ans\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& r, vector<vector<int>>& c) {\\n        vector<vector<int>> ans(k,vector<int> (k,0));\\n        // handle the rows first\\n        vector<int> adj[k+1];\\n        vector<int> indegree(k+1,0);\\n        for(int i=0; i<r.size();i++){\\n             int x=r[i][0];\\n             int y=r[i][1];\\n             adj[x].push_back(y);\\n             indegree[y]++;\\n        }\\n        // pushing 0 indegree nodes\\n        queue<int> q;\\n        for(int i=1; i<=k; i++){\\n            if(indegree[i]==0){\\n                q.push(i);\\n            }\\n        }\\n        vector<int> v;\\n        while(!q.empty()){\\n           int  node=q.front();\\n           v.push_back(node);\\n           q.pop();\\n           for(int child:adj[node]){\\n               indegree[child]--;\\n               if(indegree[child]==0){\\n                   q.push(child);\\n               }\\n           }\\n        }\\n        for(int i=0; i<v.size(); i++){\\n            cout<<v[i]<<\" \";\\n        }  \\n        cout<<endl;\\n        // for col condition \\n         vector<int> adj1[k+1];\\n        vector<int> indegree1(k+1,0);\\n        for(int i=0; i<c.size();i++){\\n             int x=c[i][0];\\n             int y=c[i][1];\\n             adj1[x].push_back(y);\\n             indegree1[y]++;\\n        }\\n        // pushing 0 indegree nodes\\n        queue<int> q1;\\n        for(int i=1; i<=k; i++){\\n            if(indegree1[i]==0){\\n                q1.push(i);\\n            }\\n        }\\n        vector<int> v1;\\n        while(!q1.empty()){\\n           int  node=q1.front();\\n           v1.push_back(node);\\n           q1.pop();\\n           for(int child:adj1[node]){\\n               indegree1[child]--;\\n               if(indegree1[child]==0){\\n                   q1.push(child);\\n               }\\n           }\\n        }\\n        for(int i=0; i<v1.size(); i++){\\n            cout<<v1[i]<<\" \";\\n        }  \\n        cout<<endl;\\n        if(v1.size()!=k || v.size()!=k){\\n            return {};\\n        } \\n        map<int,int> rp;\\n        for(int i=0; i<v.size(); i++){\\n            rp[v[i]]=i;\\n        }\\n        map<int,int> cp;\\n        for(int i=0; i<v1.size(); i++){\\n            cp[v1[i]]=i;\\n        }\\n        for(int i=1; i<=k; i++){\\n            int x=rp[i];\\n            int y=cp[i];\\n            ans[x][y]=i;\\n        }\\n\\n        return ans;\\n    } \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& r, vector<vector<int>>& c) {\\n        vector<vector<int>> ans(k,vector<int> (k,0));\\n        // handle the rows first\\n        vector<int> adj[k+1];\\n        vector<int> indegree(k+1,0);\\n        for(int i=0; i<r.size();i++){\\n             int x=r[i][0];\\n             int y=r[i][1];\\n             adj[x].push_back(y);\\n             indegree[y]++;\\n        }\\n        // pushing 0 indegree nodes\\n        queue<int> q;\\n        for(int i=1; i<=k; i++){\\n            if(indegree[i]==0){\\n                q.push(i);\\n            }\\n        }\\n        vector<int> v;\\n        while(!q.empty()){\\n           int  node=q.front();\\n           v.push_back(node);\\n           q.pop();\\n           for(int child:adj[node]){\\n               indegree[child]--;\\n               if(indegree[child]==0){\\n                   q.push(child);\\n               }\\n           }\\n        }\\n        for(int i=0; i<v.size(); i++){\\n            cout<<v[i]<<\" \";\\n        }  \\n        cout<<endl;\\n        // for col condition \\n         vector<int> adj1[k+1];\\n        vector<int> indegree1(k+1,0);\\n        for(int i=0; i<c.size();i++){\\n             int x=c[i][0];\\n             int y=c[i][1];\\n             adj1[x].push_back(y);\\n             indegree1[y]++;\\n        }\\n        // pushing 0 indegree nodes\\n        queue<int> q1;\\n        for(int i=1; i<=k; i++){\\n            if(indegree1[i]==0){\\n                q1.push(i);\\n            }\\n        }\\n        vector<int> v1;\\n        while(!q1.empty()){\\n           int  node=q1.front();\\n           v1.push_back(node);\\n           q1.pop();\\n           for(int child:adj1[node]){\\n               indegree1[child]--;\\n               if(indegree1[child]==0){\\n                   q1.push(child);\\n               }\\n           }\\n        }\\n        for(int i=0; i<v1.size(); i++){\\n            cout<<v1[i]<<\" \";\\n        }  \\n        cout<<endl;\\n        if(v1.size()!=k || v.size()!=k){\\n            return {};\\n        } \\n        map<int,int> rp;\\n        for(int i=0; i<v.size(); i++){\\n            rp[v[i]]=i;\\n        }\\n        map<int,int> cp;\\n        for(int i=0; i<v1.size(); i++){\\n            cp[v1[i]]=i;\\n        }\\n        for(int i=1; i<=k; i++){\\n            int x=rp[i];\\n            int y=cp[i];\\n            ans[x][y]=i;\\n        }\\n\\n        return ans;\\n    } \\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3853485,
                "title": "easy-c-bfs-kahn-s-algorithm-topological-sort",
                "content": "# Intuition\\nApply BFS using Kahn\\'s Algorithm\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    vector<int> toposort(vector<vector<int>> &adj){\\n        int n=adj.size();\\n        vector<int> indegree(n,0);\\n        queue<int> q;\\n        vector<int> ans;\\n        for(auto i:adj){\\n            for(auto j:i){\\n                indegree[j]++;\\n            }\\n        }\\n        for(int i=1;i<indegree.size();i++){\\n            if(indegree[i]==0){\\n                q.push(i);\\n            }\\n        }\\n        while(!q.empty()){\\n            auto fro=q.front();\\n            q.pop();\\n            ans.push_back(fro);\\n            for(auto it:adj[fro]){\\n                indegree[it]--;\\n                if(indegree[it]==0){\\n                    q.push(it);\\n                }\\n            }\\n        }\\n        if(ans.size()<(n-1)) return {};\\n        return ans;\\n    }\\n\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        \\n        vector<vector<int>> adj1(k+1);\\n        vector<vector<int>> adj2(k+1);\\n        vector<vector<int>> ans;\\n        for(auto it:rowConditions){\\n            adj1[it[0]].push_back(it[1]);\\n        }\\n\\n        for(auto it:colConditions){\\n            adj2[it[0]].push_back(it[1]);\\n        }\\n\\n        vector<int> topo_row=toposort(adj1);\\n        if(topo_row.size()==0){\\n            return ans;\\n        }\\n        vector<int> topo_col=toposort(adj2);\\n        if(topo_col.size()==0){\\n            return ans;\\n        }\\n\\n        vector<int> row(k+1);\\n        vector<int> col(k+1);\\n        for(int i=0;i<k;i++){\\n            row[topo_row[i]]=i;\\n            col[topo_col[i]]=i;\\n        }\\n        vector<vector<int>> fin_ans(k,vector<int>(k,0));\\n\\n        for(int i=1;i<=k;i++){\\n            fin_ans[row[i]][col[i]]=i;\\n        }\\n        return fin_ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<int> toposort(vector<vector<int>> &adj){\\n        int n=adj.size();\\n        vector<int> indegree(n,0);\\n        queue<int> q;\\n        vector<int> ans;\\n        for(auto i:adj){\\n            for(auto j:i){\\n                indegree[j]++;\\n            }\\n        }\\n        for(int i=1;i<indegree.size();i++){\\n            if(indegree[i]==0){\\n                q.push(i);\\n            }\\n        }\\n        while(!q.empty()){\\n            auto fro=q.front();\\n            q.pop();\\n            ans.push_back(fro);\\n            for(auto it:adj[fro]){\\n                indegree[it]--;\\n                if(indegree[it]==0){\\n                    q.push(it);\\n                }\\n            }\\n        }\\n        if(ans.size()<(n-1)) return {};\\n        return ans;\\n    }\\n\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        \\n        vector<vector<int>> adj1(k+1);\\n        vector<vector<int>> adj2(k+1);\\n        vector<vector<int>> ans;\\n        for(auto it:rowConditions){\\n            adj1[it[0]].push_back(it[1]);\\n        }\\n\\n        for(auto it:colConditions){\\n            adj2[it[0]].push_back(it[1]);\\n        }\\n\\n        vector<int> topo_row=toposort(adj1);\\n        if(topo_row.size()==0){\\n            return ans;\\n        }\\n        vector<int> topo_col=toposort(adj2);\\n        if(topo_col.size()==0){\\n            return ans;\\n        }\\n\\n        vector<int> row(k+1);\\n        vector<int> col(k+1);\\n        for(int i=0;i<k;i++){\\n            row[topo_row[i]]=i;\\n            col[topo_col[i]]=i;\\n        }\\n        vector<vector<int>> fin_ans(k,vector<int>(k,0));\\n\\n        for(int i=1;i<=k;i++){\\n            fin_ans[row[i]][col[i]]=i;\\n        }\\n        return fin_ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3823352,
                "title": "easy-to-understand-topological-sort",
                "content": "\\n# Approach\\nOne important observation was that rows and columns are independent. We then simply run topological sort and assign the values to the matrix. Also if there are cycles in the graph then there is no valid arrangement. So handle that case seperately. \\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool dfs(int node,vector<int> &vis,vector<vector<int>> &adj){\\n        vis[node]=2;\\n        bool ok=false;  \\n        for(int it:adj[node]){\\n            if(vis[it]==0){\\n                ok=ok|dfs(it,vis,adj);\\n            }else if(vis[it]==2){\\n                ok=true;\\n            }\\n        }\\n        vis[node]=1;\\n        return ok;\\n    }\\n\\n    bool checkCycle(vector<vector<int>> &adj){\\n        int n=adj.size();\\n        vector<int> vis(n+1,0);\\n        for(int i=1;i<n;i++){\\n            if(vis[i]==0){\\n                if(dfs(i,vis,adj)==true){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    vector<int> toposort(vector<vector<int>> &adj){\\n        int n=adj.size();\\n        vector<int> indegree(n,0);\\n        queue<int> q;\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<adj[i].size();j++){\\n                indegree[adj[i][j]]++;\\n            }\\n        }\\n        for(int i=1;i<n;i++){\\n            if(indegree[i]==0){\\n                q.push(i);\\n            }\\n        }\\n        vector<int> ans;\\n        while(!q.empty()){\\n            auto it=q.front();\\n            q.pop();\\n            ans.push_back(it);\\n            for(auto it1:adj[it]){\\n                indegree[it1]--;\\n                if(indegree[it1]==0){\\n                    q.push(it1);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& row, vector<vector<int>>& col) {\\n        //row and col are independent\\n        vector<vector<int>> adjr(k+1),adjc(k+1);\\n        for(int i=0;i<row.size();i++){\\n            int x=row[i][0],y=row[i][1];\\n            adjr[x].push_back(y);\\n        }\\n        for(int i=0;i<col.size();i++){\\n            int x=col[i][0],y=col[i][1];\\n            adjc[x].push_back(y);\\n        }\\n        if(checkCycle(adjr) || checkCycle(adjc)){\\n            return {};\\n        }\\n        vector<int> topo1=toposort(adjr);\\n        vector<int> topo2=toposort(adjc);\\n        map<int,pair<int,int>> mp;\\n        for(int i=0;i<topo1.size();i++){\\n            mp[topo1[i]].first=i;\\n            mp[topo2[i]].second=i;\\n        }\\n        vector<vector<int>> ans(k,vector<int>(k,0));\\n        for(auto it=mp.begin();it!=mp.end();it++){\\n            ans[it->second.first][it->second.second]=it->first;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(int node,vector<int> &vis,vector<vector<int>> &adj){\\n        vis[node]=2;\\n        bool ok=false;  \\n        for(int it:adj[node]){\\n            if(vis[it]==0){\\n                ok=ok|dfs(it,vis,adj);\\n            }else if(vis[it]==2){\\n                ok=true;\\n            }\\n        }\\n        vis[node]=1;\\n        return ok;\\n    }\\n\\n    bool checkCycle(vector<vector<int>> &adj){\\n        int n=adj.size();\\n        vector<int> vis(n+1,0);\\n        for(int i=1;i<n;i++){\\n            if(vis[i]==0){\\n                if(dfs(i,vis,adj)==true){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    vector<int> toposort(vector<vector<int>> &adj){\\n        int n=adj.size();\\n        vector<int> indegree(n,0);\\n        queue<int> q;\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<adj[i].size();j++){\\n                indegree[adj[i][j]]++;\\n            }\\n        }\\n        for(int i=1;i<n;i++){\\n            if(indegree[i]==0){\\n                q.push(i);\\n            }\\n        }\\n        vector<int> ans;\\n        while(!q.empty()){\\n            auto it=q.front();\\n            q.pop();\\n            ans.push_back(it);\\n            for(auto it1:adj[it]){\\n                indegree[it1]--;\\n                if(indegree[it1]==0){\\n                    q.push(it1);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& row, vector<vector<int>>& col) {\\n        //row and col are independent\\n        vector<vector<int>> adjr(k+1),adjc(k+1);\\n        for(int i=0;i<row.size();i++){\\n            int x=row[i][0],y=row[i][1];\\n            adjr[x].push_back(y);\\n        }\\n        for(int i=0;i<col.size();i++){\\n            int x=col[i][0],y=col[i][1];\\n            adjc[x].push_back(y);\\n        }\\n        if(checkCycle(adjr) || checkCycle(adjc)){\\n            return {};\\n        }\\n        vector<int> topo1=toposort(adjr);\\n        vector<int> topo2=toposort(adjc);\\n        map<int,pair<int,int>> mp;\\n        for(int i=0;i<topo1.size();i++){\\n            mp[topo1[i]].first=i;\\n            mp[topo2[i]].second=i;\\n        }\\n        vector<vector<int>> ans(k,vector<int>(k,0));\\n        for(auto it=mp.begin();it!=mp.end();it++){\\n            ans[it->second.first][it->second.second]=it->first;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819540,
                "title": "simple-topo-sort-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void printvector(vector<int>&v){\\n        for(auto i:v)cout<<i<<\" \";\\n        cout<<endl;\\n    }\\n    bool iscycle(vector<int>adj[],int n){\\n        vector<int>in(n+1,0);\\n        for(int i=1;i<=n;i++){\\n            for(auto it:adj[i])\\n                in[it]++;\\n        }\\n        queue<int>q;\\n        int cnt=0;\\n        for(int i=1;i<=n;i++){\\n            if(in[i]==0)q.push(i);\\n        }\\n        while(!q.empty()){\\n            int node = q.front();\\n            cnt++;\\n            q.pop();\\n            for(auto it:adj[node]){\\n                in[it]--;\\n                if(in[it]==0)q.push(it);\\n            }\\n        }\\n        return cnt!=n;\\n    }\\n\\n    void dfs(int node, vector<int>adj[],stack<int>&st,vector<int>&vis){\\n        vis[node]=1;\\n        for(auto i:adj[node]){\\n            if(vis[i]==0)dfs(i,adj,st,vis);\\n        }\\n        st.push(node);\\n    }\\n    vector<int> topo(vector<int>adj[],int k){\\n        stack<int>st;\\n        vector<int>ans;\\n        vector<int>vis(k+1,0);\\n        for(int i=1;i<=k;i++){\\n            if(vis[i]==0)dfs(i,adj,st,vis);\\n        }\\n        while(st.empty()==false){\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        //reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        vector<vector<int>>ans(k,vector<int>(k,0));\\n        vector<int>row[k+1];\\n        vector<int>col[k+1];\\n        for(auto i:rowConditions){\\n            row[i[0]].push_back(i[1]);\\n        }\\n        for(auto i:colConditions){\\n            col[i[0]].push_back(i[1]);\\n        }\\n        //if cycle return no solution\\n        if(iscycle(row,k))return {};\\n        if(iscycle(col,k))return {};\\n        \\n        //find order of index\\n        vector<int> r = topo(row,k);\\n        vector<int> l = topo(col,k);\\n        \\n        //print topo order\\n        // printvector(r);\\n        // printvector(l);\\n\\n        unordered_map<int,int>mp;\\n        vector<int>vis(k+1,0);\\n        for(int i=0;i<l.size();i++)\\n            mp[l[i]] = i;\\n        \\n        for(int i=0;i<r.size();i++){\\n            int temp = r[i];\\n            vis[r[i]]=1;\\n            if(mp.find(temp)==mp.end()){\\n                for(int j=0;j<k;j++)if(ans[i][j]==0){ans[i][j]=temp;break;}\\n            }\\n            else{\\n                ans[i][mp[temp]] = temp;\\n                mp.erase(temp);\\n            }\\n        }\\n        for(int i=0;i<l.size();i++){\\n            int temp = l[i];\\n            if(mp.find(temp)!=mp.end()){\\n                for(int j=0;j<k;j++){\\n                    if(vis[mp[temp]]==0 and ans[j][mp[temp]]){\\n                        ans[j][mp[temp]] = temp;\\n                        vis[temp]=1;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void printvector(vector<int>&v){\\n        for(auto i:v)cout<<i<<\" \";\\n        cout<<endl;\\n    }\\n    bool iscycle(vector<int>adj[],int n){\\n        vector<int>in(n+1,0);\\n        for(int i=1;i<=n;i++){\\n            for(auto it:adj[i])\\n                in[it]++;\\n        }\\n        queue<int>q;\\n        int cnt=0;\\n        for(int i=1;i<=n;i++){\\n            if(in[i]==0)q.push(i);\\n        }\\n        while(!q.empty()){\\n            int node = q.front();\\n            cnt++;\\n            q.pop();\\n            for(auto it:adj[node]){\\n                in[it]--;\\n                if(in[it]==0)q.push(it);\\n            }\\n        }\\n        return cnt!=n;\\n    }\\n\\n    void dfs(int node, vector<int>adj[],stack<int>&st,vector<int>&vis){\\n        vis[node]=1;\\n        for(auto i:adj[node]){\\n            if(vis[i]==0)dfs(i,adj,st,vis);\\n        }\\n        st.push(node);\\n    }\\n    vector<int> topo(vector<int>adj[],int k){\\n        stack<int>st;\\n        vector<int>ans;\\n        vector<int>vis(k+1,0);\\n        for(int i=1;i<=k;i++){\\n            if(vis[i]==0)dfs(i,adj,st,vis);\\n        }\\n        while(st.empty()==false){\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        //reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        vector<vector<int>>ans(k,vector<int>(k,0));\\n        vector<int>row[k+1];\\n        vector<int>col[k+1];\\n        for(auto i:rowConditions){\\n            row[i[0]].push_back(i[1]);\\n        }\\n        for(auto i:colConditions){\\n            col[i[0]].push_back(i[1]);\\n        }\\n        //if cycle return no solution\\n        if(iscycle(row,k))return {};\\n        if(iscycle(col,k))return {};\\n        \\n        //find order of index\\n        vector<int> r = topo(row,k);\\n        vector<int> l = topo(col,k);\\n        \\n        //print topo order\\n        // printvector(r);\\n        // printvector(l);\\n\\n        unordered_map<int,int>mp;\\n        vector<int>vis(k+1,0);\\n        for(int i=0;i<l.size();i++)\\n            mp[l[i]] = i;\\n        \\n        for(int i=0;i<r.size();i++){\\n            int temp = r[i];\\n            vis[r[i]]=1;\\n            if(mp.find(temp)==mp.end()){\\n                for(int j=0;j<k;j++)if(ans[i][j]==0){ans[i][j]=temp;break;}\\n            }\\n            else{\\n                ans[i][mp[temp]] = temp;\\n                mp.erase(temp);\\n            }\\n        }\\n        for(int i=0;i<l.size();i++){\\n            int temp = l[i];\\n            if(mp.find(temp)!=mp.end()){\\n                for(int j=0;j<k;j++){\\n                    if(vis[mp[temp]]==0 and ans[j][mp[temp]]){\\n                        ans[j][mp[temp]] = temp;\\n                        vis[temp]=1;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3759795,
                "title": "cpp-topo-sort-kahn-s-algo-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> solve(vector<vector<int>> &edges,int n){\\n        vector<int> adj[n],indegree(n,0);\\n        for(auto it:edges){\\n            adj[it[0]-1].push_back(it[1]-1);\\n            indegree[it[1]-1]++;\\n        }\\n        \\n        queue<int> q;\\n        for(int i=0;i<n;i++){\\n            if(indegree[i]==0) q.push(i);\\n        }\\n        \\n        vector<int> topo;\\n        \\n        while(!q.empty()){\\n            int node = q.front();\\n            q.pop();\\n            \\n            topo.push_back(node);\\n            \\n            for(auto it:adj[node]){\\n                indegree[it]--;\\n                if(indegree[it]==0) q.push(it);\\n            }\\n        }\\n        \\n        return topo;\\n    }\\n    \\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        vector<int> row = solve(rowConditions,k);\\n        if(row.size()!=k) return {};\\n        vector<int> col = solve(colConditions,k);\\n        if(col.size()!=k) return {};\\n        \\n        vector<vector<int>> ans(k,vector<int>(k,0));\\n        unordered_map<int,int> mpp;\\n        for(int i=0;i<k;i++){\\n            mpp[col[i]]=i;\\n        }\\n        \\n        for(int i=0;i<k;i++){\\n            int ele = row[i];\\n            int colIdx = mpp[ele];\\n            ans[i][colIdx]=ele+1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> solve(vector<vector<int>> &edges,int n){\\n        vector<int> adj[n],indegree(n,0);\\n        for(auto it:edges){\\n            adj[it[0]-1].push_back(it[1]-1);\\n            indegree[it[1]-1]++;\\n        }\\n        \\n        queue<int> q;\\n        for(int i=0;i<n;i++){\\n            if(indegree[i]==0) q.push(i);\\n        }\\n        \\n        vector<int> topo;\\n        \\n        while(!q.empty()){\\n            int node = q.front();\\n            q.pop();\\n            \\n            topo.push_back(node);\\n            \\n            for(auto it:adj[node]){\\n                indegree[it]--;\\n                if(indegree[it]==0) q.push(it);\\n            }\\n        }\\n        \\n        return topo;\\n    }\\n    \\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        vector<int> row = solve(rowConditions,k);\\n        if(row.size()!=k) return {};\\n        vector<int> col = solve(colConditions,k);\\n        if(col.size()!=k) return {};\\n        \\n        vector<vector<int>> ans(k,vector<int>(k,0));\\n        unordered_map<int,int> mpp;\\n        for(int i=0;i<k;i++){\\n            mpp[col[i]]=i;\\n        }\\n        \\n        for(int i=0;i<k;i++){\\n            int ele = row[i];\\n            int colIdx = mpp[ele];\\n            ans[i][colIdx]=ele+1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3757293,
                "title": "simple-topo-sort-based-solution",
                "content": "# Approach\\n  Pefrom topological sorting for both rows & cols conditon.\\nYou will get the order of the elements that how they should be arranged in rows & cols of the matrix.\\n\\nBased on these ordering populate the result matrix.\\n# Complexity\\n- Time complexity:\\nO(k+N) n = Max number of conditions.\\n\\n- Space complexity:\\nO(k*k) + O(3k)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[][] BuildMatrix(int k, int[][] rowConditions, int[][] colConditions) {\\n        int[][] resultMatrix = new int[0][];\\n        var rowsAllignment = FindTopoSort(k, rowConditions);\\n        if(rowsAllignment is null)\\n            return resultMatrix;\\n\\n        var colsAllignment = FindTopoSort(k, colConditions);\\n        if(colsAllignment is null)\\n            return resultMatrix;\\n\\n        resultMatrix = new int[k][];\\n        for(int i = 0; i < k; i++)\\n            resultMatrix[i] = new int[k];\\n        \\n        Dictionary<int, int> tmpLookup = new Dictionary<int, int>();\\n        for(int i = 0; i < k; i++)\\n            tmpLookup.Add(colsAllignment[i], i);\\n        \\n        for(int i = 0; i < k; i++){\\n            int j = tmpLookup[rowsAllignment[i]];\\n            resultMatrix[i][j] = rowsAllignment[i];\\n        }\\n\\n        return resultMatrix;\\n    }\\n\\n    private int[] FindTopoSort(int k, int[][] conditions){\\n        //Prepare adjList\\n        Dictionary<int, List<int>> adjMatrix = new Dictionary<int, List<int>>();\\n        for(int i = 1; i <= k; i++)\\n            adjMatrix.Add(i, new List<int>());\\n\\n        foreach(int[] condition in conditions)            \\n            adjMatrix[condition[1]].Add(condition[0]);\\n\\n        //Check for Cycle\\n        bool[] isDFSSeen = new bool[k+1];\\n        for(int i = 1; i <= k; i++){\\n            if(CheckForCycle(i, adjMatrix, isDFSSeen, new bool[k+1]))\\n                return null;\\n        }\\n\\n        //Start topo sort\\n        int[] InDegree = new int[k+1];\\n        foreach(int[] condition in conditions)\\n            InDegree[condition[0]] += 1;\\n\\n        Queue<int> topoQueue = new Queue<int>();\\n        for(int i = 1; i <= k; i++){\\n            if(InDegree[i] == 0)\\n                topoQueue.Enqueue(i);\\n        }\\n\\n        int resultIndex = k-1;\\n        int[] result = new int[k];\\n        while(topoQueue.Count > 0){\\n            int node = topoQueue.Dequeue();\\n            result[resultIndex--] = node;\\n\\n            foreach(int adjNode in adjMatrix[node]){\\n                InDegree[adjNode] -= 1;\\n                if(InDegree[adjNode] == 0)\\n                    topoQueue.Enqueue(adjNode);\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    private bool CheckForCycle(int node, Dictionary<int, List<int>> adjList, bool[] isDFSSeen, bool[] isSeen){\\n        if(isSeen[node])\\n            return true;\\n        \\n        if(isDFSSeen[node])\\n            return false;\\n        \\n        isSeen[node] = true;\\n        isDFSSeen[node] = true;\\n\\n        bool isCycle = false;\\n        foreach(int nd in adjList[node])\\n            isCycle = isCycle | CheckForCycle(nd, adjList, isDFSSeen, isSeen);\\n        \\n        isSeen[node] = false;\\n        return isCycle;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\npublic class Solution {\\n    public int[][] BuildMatrix(int k, int[][] rowConditions, int[][] colConditions) {\\n        int[][] resultMatrix = new int[0][];\\n        var rowsAllignment = FindTopoSort(k, rowConditions);\\n        if(rowsAllignment is null)\\n            return resultMatrix;\\n\\n        var colsAllignment = FindTopoSort(k, colConditions);\\n        if(colsAllignment is null)\\n            return resultMatrix;\\n\\n        resultMatrix = new int[k][];\\n        for(int i = 0; i < k; i++)\\n            resultMatrix[i] = new int[k];\\n        \\n        Dictionary<int, int> tmpLookup = new Dictionary<int, int>();\\n        for(int i = 0; i < k; i++)\\n            tmpLookup.Add(colsAllignment[i], i);\\n        \\n        for(int i = 0; i < k; i++){\\n            int j = tmpLookup[rowsAllignment[i]];\\n            resultMatrix[i][j] = rowsAllignment[i];\\n        }\\n\\n        return resultMatrix;\\n    }\\n\\n    private int[] FindTopoSort(int k, int[][] conditions){\\n        //Prepare adjList\\n        Dictionary<int, List<int>> adjMatrix = new Dictionary<int, List<int>>();\\n        for(int i = 1; i <= k; i++)\\n            adjMatrix.Add(i, new List<int>());\\n\\n        foreach(int[] condition in conditions)            \\n            adjMatrix[condition[1]].Add(condition[0]);\\n\\n        //Check for Cycle\\n        bool[] isDFSSeen = new bool[k+1];\\n        for(int i = 1; i <= k; i++){\\n            if(CheckForCycle(i, adjMatrix, isDFSSeen, new bool[k+1]))\\n                return null;\\n        }\\n\\n        //Start topo sort\\n        int[] InDegree = new int[k+1];\\n        foreach(int[] condition in conditions)\\n            InDegree[condition[0]] += 1;\\n\\n        Queue<int> topoQueue = new Queue<int>();\\n        for(int i = 1; i <= k; i++){\\n            if(InDegree[i] == 0)\\n                topoQueue.Enqueue(i);\\n        }\\n\\n        int resultIndex = k-1;\\n        int[] result = new int[k];\\n        while(topoQueue.Count > 0){\\n            int node = topoQueue.Dequeue();\\n            result[resultIndex--] = node;\\n\\n            foreach(int adjNode in adjMatrix[node]){\\n                InDegree[adjNode] -= 1;\\n                if(InDegree[adjNode] == 0)\\n                    topoQueue.Enqueue(adjNode);\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    private bool CheckForCycle(int node, Dictionary<int, List<int>> adjList, bool[] isDFSSeen, bool[] isSeen){\\n        if(isSeen[node])\\n            return true;\\n        \\n        if(isDFSSeen[node])\\n            return false;\\n        \\n        isSeen[node] = true;\\n        isDFSSeen[node] = true;\\n\\n        bool isCycle = false;\\n        foreach(int nd in adjList[node])\\n            isCycle = isCycle | CheckForCycle(nd, adjList, isDFSSeen, isSeen);\\n        \\n        isSeen[node] = false;\\n        return isCycle;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3757183,
                "title": "topological-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> help(vector<int>adj[],int k){\\n        vector<int>indegree(k+1,0);\\n        for(int i=1;i<=k;i++){\\n             for(auto x:adj[i])\\n             {\\n                 cout<<i<<\" \"<<x<<endl;\\n                 indegree[x]++;\\n             }\\n        }\\n        vector<int>ans;queue<int>q;\\n        for(int i=1;i<=k;i++){\\n            if(indegree[i]==0)\\n              q.push(i);\\n        }\\n        while(!q.empty()){\\n            int y=q.front();q.pop();\\n            ans.push_back(y);\\n            for(auto x:adj[y]){\\n                indegree[x]--;\\n                if(indegree[x]==0)\\n                  q.push(x);\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& r, vector<vector<int>>& c) {\\n        int n=r.size(),m=c.size();\\n        vector<int>adj[k+1],adj1[k+1];\\n       for(int i=0;i<n;i++){\\n         adj[r[i][1]].push_back(r[i][0]);}\\n       for(int i=0;i<m;i++){\\n         adj1[c[i][1]].push_back(c[i][0]);}\\n       vector<int>ans=help(adj,k);\\n       reverse(ans.begin(),ans.end());\\n\\n       vector<int>ans1=help(adj1,k);\\n       reverse(ans1.begin(),ans1.end());\\n       vector<vector<int>>ans3(k,vector<int>(k,0));\\n       if(ans.size()<k || ans1.size()<k)\\n        {\\n            vector<vector<int>>b;\\n            return b;\\n        }\\n       vector<pair<int,int>>co_ordinates;\\n       for(int i=1;i<=k;i++){\\n           co_ordinates.push_back({INT_MAX,INT_MAX});}\\n        \\n       for(int i=0;i<k;i++){\\n           co_ordinates[ans[i]-1].first=i;\\n           co_ordinates[ans1[i]-1].second=i;\\n       }\\n       for(int i=0;i<k;i++){\\n          ans3[co_ordinates[i].first][co_ordinates[i].second]=i+1;\\n       }\\n       return ans3;\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> help(vector<int>adj[],int k){\\n        vector<int>indegree(k+1,0);\\n        for(int i=1;i<=k;i++){\\n             for(auto x:adj[i])\\n             {\\n                 cout<<i<<\" \"<<x<<endl;\\n                 indegree[x]++;\\n             }\\n        }\\n        vector<int>ans;queue<int>q;\\n        for(int i=1;i<=k;i++){\\n            if(indegree[i]==0)\\n              q.push(i);\\n        }\\n        while(!q.empty()){\\n            int y=q.front();q.pop();\\n            ans.push_back(y);\\n            for(auto x:adj[y]){\\n                indegree[x]--;\\n                if(indegree[x]==0)\\n                  q.push(x);\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& r, vector<vector<int>>& c) {\\n        int n=r.size(),m=c.size();\\n        vector<int>adj[k+1],adj1[k+1];\\n       for(int i=0;i<n;i++){\\n         adj[r[i][1]].push_back(r[i][0]);}\\n       for(int i=0;i<m;i++){\\n         adj1[c[i][1]].push_back(c[i][0]);}\\n       vector<int>ans=help(adj,k);\\n       reverse(ans.begin(),ans.end());\\n\\n       vector<int>ans1=help(adj1,k);\\n       reverse(ans1.begin(),ans1.end());\\n       vector<vector<int>>ans3(k,vector<int>(k,0));\\n       if(ans.size()<k || ans1.size()<k)\\n        {\\n            vector<vector<int>>b;\\n            return b;\\n        }\\n       vector<pair<int,int>>co_ordinates;\\n       for(int i=1;i<=k;i++){\\n           co_ordinates.push_back({INT_MAX,INT_MAX});}\\n        \\n       for(int i=0;i<k;i++){\\n           co_ordinates[ans[i]-1].first=i;\\n           co_ordinates[ans1[i]-1].second=i;\\n       }\\n       for(int i=0;i<k;i++){\\n          ans3[co_ordinates[i].first][co_ordinates[i].second]=i+1;\\n       }\\n       return ans3;\\n       \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3742650,
                "title": "c-readable-solution-leveraging-topological-sorting",
                "content": "# Complexity\\n- Time complexity: O(V+E)\\n\\n- Space complexity: O(V+E) //graph creation\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void getTopologicalSort(vector<vector<int>> &graph, int n, unordered_map<int,int> &nodeToPosition){\\n        //Kahn\\'s Algo\\n        vector<int> indegree(n);\\n\\n        for(int i=1; i<n; ++i){\\n            for(int child: graph[i])\\n                ++indegree[child];\\n        }\\n\\n        queue<int> q;\\n\\n        for(int i=1;i<n;++i){\\n            if(!indegree[i])\\n                q.push(i);\\n        }\\n\\n        int position = 0;\\n\\n        while(!q.empty()){\\n            int u = q.front(); q.pop();\\n            nodeToPosition[u] = position++;\\n            for(int v: graph[u]){\\n                --indegree[v];\\n                if(!indegree[v])\\n                    q.push(v);\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        //1. Construct graph from both row and column conditions\\n        vector<vector<int>> rowDependencyGraph(k+1);\\n        vector<vector<int>> columnDependencyGraph(k+1);\\n\\n        for(auto condition: rowConditions){\\n            int u = condition[0], v = condition[1];\\n            rowDependencyGraph[u].push_back(v);\\n        }\\n\\n        for(auto condition: colConditions){\\n            int u = condition[0], v = condition[1];\\n            columnDependencyGraph[u].push_back(v);\\n        }\\n\\n        //2. Check topo sort validity in both graphs. If cycles, return empty matrix\\n        unordered_map<int,int> nodeToRowPosition;\\n        getTopologicalSort(rowDependencyGraph, k+1, nodeToRowPosition);\\n        if(nodeToRowPosition.size() < k)\\n            return {};\\n\\n        unordered_map<int,int> nodeToColumnPosition;\\n        getTopologicalSort(columnDependencyGraph, k+1, nodeToColumnPosition);\\n        if(nodeToColumnPosition.size() < k)\\n            return {};\\n\\n        //3. Determine position in matrix\\n        vector<vector<int>> matrix(k, vector<int> (k,0));\\n        for(int i = 1; i<=k; ++i){\\n            int r = nodeToRowPosition[i];\\n            int c = nodeToColumnPosition[i];\\n            matrix[r][c] = i;\\n        }\\n\\n        return matrix;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void getTopologicalSort(vector<vector<int>> &graph, int n, unordered_map<int,int> &nodeToPosition){\\n        //Kahn\\'s Algo\\n        vector<int> indegree(n);\\n\\n        for(int i=1; i<n; ++i){\\n            for(int child: graph[i])\\n                ++indegree[child];\\n        }\\n\\n        queue<int> q;\\n\\n        for(int i=1;i<n;++i){\\n            if(!indegree[i])\\n                q.push(i);\\n        }\\n\\n        int position = 0;\\n\\n        while(!q.empty()){\\n            int u = q.front(); q.pop();\\n            nodeToPosition[u] = position++;\\n            for(int v: graph[u]){\\n                --indegree[v];\\n                if(!indegree[v])\\n                    q.push(v);\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        //1. Construct graph from both row and column conditions\\n        vector<vector<int>> rowDependencyGraph(k+1);\\n        vector<vector<int>> columnDependencyGraph(k+1);\\n\\n        for(auto condition: rowConditions){\\n            int u = condition[0], v = condition[1];\\n            rowDependencyGraph[u].push_back(v);\\n        }\\n\\n        for(auto condition: colConditions){\\n            int u = condition[0], v = condition[1];\\n            columnDependencyGraph[u].push_back(v);\\n        }\\n\\n        //2. Check topo sort validity in both graphs. If cycles, return empty matrix\\n        unordered_map<int,int> nodeToRowPosition;\\n        getTopologicalSort(rowDependencyGraph, k+1, nodeToRowPosition);\\n        if(nodeToRowPosition.size() < k)\\n            return {};\\n\\n        unordered_map<int,int> nodeToColumnPosition;\\n        getTopologicalSort(columnDependencyGraph, k+1, nodeToColumnPosition);\\n        if(nodeToColumnPosition.size() < k)\\n            return {};\\n\\n        //3. Determine position in matrix\\n        vector<vector<int>> matrix(k, vector<int> (k,0));\\n        for(int i = 1; i<=k; ++i){\\n            int r = nodeToRowPosition[i];\\n            int c = nodeToColumnPosition[i];\\n            matrix[r][c] = i;\\n        }\\n\\n        return matrix;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3737715,
                "title": "very-easy-c-kahn-s-algorithm",
                "content": "\\n\\n# Code C++\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        vector<int>v1=topo(rowConditions,k);\\n        vector<int>v2=topo(colConditions,k);\\n        if(v1.size()!=v2.size())return {};\\n        unordered_map<int,int>um;\\n        for(int i=0;i<v2.size();i++){\\n            um[v2[i]]=i;\\n        }\\n        vector<pair<int,pair<int,int>>>v;\\n        for(int i=0;i<v1.size();i++){\\n            if(um.find(v1[i])!=um.end()){\\n                v.push_back({v1[i],{i,um[v1[i]]}});\\n            }\\n        }\\n        if(v.size()==0)return{};\\n        vector<vector<int>>ans(k,vector<int>(k));\\n        for(int i=0;i<v.size();i++){\\n            int num=v[i].first;\\n            int x=v[i].second.first;\\n            int y=v[i].second.second;\\n            ans[x][y]=num;\\n        }\\n    return ans;\\n    }\\n\\n\\nvector<int>topo(vector<vector<int>>graph,int k){\\n    vector<int>adj[k];\\n    vector<int>indegree(k);\\n    for(int i=0;i<graph.size();i++){\\n        adj[graph[i][0]-1].push_back(graph[i][1]-1);\\n        indegree[graph[i][1]-1]++;\\n    }\\n    queue<int>q;\\n    for(int i=0;i<k;i++){\\n        if(indegree[i]==0)q.push(i);\\n    }\\n    vector<int>res;\\n    while(!q.empty()){\\n        int node=q.front();\\n        q.pop();\\n        res.push_back(node+1);\\n        for(auto it:adj[node]){\\n            indegree[it]--;\\n            if(indegree[it]==0)\\n            q.push(it);\\n        }\\n    }\\nreturn res;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        vector<int>v1=topo(rowConditions,k);\\n        vector<int>v2=topo(colConditions,k);\\n        if(v1.size()!=v2.size())return {};\\n        unordered_map<int,int>um;\\n        for(int i=0;i<v2.size();i++){\\n            um[v2[i]]=i;\\n        }\\n        vector<pair<int,pair<int,int>>>v;\\n        for(int i=0;i<v1.size();i++){\\n            if(um.find(v1[i])!=um.end()){\\n                v.push_back({v1[i],{i,um[v1[i]]}});\\n            }\\n        }\\n        if(v.size()==0)return{};\\n        vector<vector<int>>ans(k,vector<int>(k));\\n        for(int i=0;i<v.size();i++){\\n            int num=v[i].first;\\n            int x=v[i].second.first;\\n            int y=v[i].second.second;\\n            ans[x][y]=num;\\n        }\\n    return ans;\\n    }\\n\\n\\nvector<int>topo(vector<vector<int>>graph,int k){\\n    vector<int>adj[k];\\n    vector<int>indegree(k);\\n    for(int i=0;i<graph.size();i++){\\n        adj[graph[i][0]-1].push_back(graph[i][1]-1);\\n        indegree[graph[i][1]-1]++;\\n    }\\n    queue<int>q;\\n    for(int i=0;i<k;i++){\\n        if(indegree[i]==0)q.push(i);\\n    }\\n    vector<int>res;\\n    while(!q.empty()){\\n        int node=q.front();\\n        q.pop();\\n        res.push_back(node+1);\\n        for(auto it:adj[node]){\\n            indegree[it]--;\\n            if(indegree[it]==0)\\n            q.push(it);\\n        }\\n    }\\nreturn res;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731465,
                "title": "toposort-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] buildMatrix(int k, int[][] rows, int[][] cols) {\\n       Map<Integer,List<Integer>> map=new HashMap<>();\\n       Map<Integer,List<Integer>> map2=new HashMap<>();\\n       \\n       for(int i=1;i<=k;i++){\\n           List<Integer> t=new ArrayList<>();\\n           map.put(i,t);\\n           List<Integer> t2=new ArrayList<>();\\n           map2.put(i,t2);\\n       }\\n       \\n       for(int a[] : rows){\\n            map.get(a[0]).add(a[1]);\\n       }\\n       \\n       for(int a[] : cols){\\n            map2.get(a[0]).add(a[1]);         \\n       }\\n\\n       List<Integer> listR = topo(map,k);\\n       List<Integer> listC = topo(map2,k);\\n       System.out.println(listR);\\n       System.out.println(listC);\\n       \\n       if(listR.size() != k || listC.size() != k){\\n           int a[][]=new int[0][0]; return a;\\n       }\\n\\n       Map<Integer,List<Integer>> map3=new HashMap<>();\\n\\n       for(int i=0;i<k;i++){\\n           List<Integer> temp=new ArrayList<>(); temp.add(i);\\n           map3.put(listR.get(i),temp);\\n       }\\n\\n        for(int i=0;i<k;i++){\\n           map3.get(listC.get(i)).add(i);\\n       }\\n\\n       int mat[][]=new int [k][k];\\n\\n       for(Map.Entry<Integer,List<Integer>> mp : map3.entrySet()){\\n           List<Integer> ind=mp.getValue();\\n           int value=mp.getKey();\\n\\n           mat[ind.get(0)][ind.get(1)]=value;\\n       }\\n\\n\\n       return mat;\\n        \\n    }\\n    private List<Integer> topo(Map<Integer,List<Integer>> map, int n){\\n        int indegree[]=new int[n+1];\\n\\n        for(int i=1;i<=n ;i++){\\n            for(int a : map.get(i)){\\n                indegree[a]++;\\n            }\\n        }\\n\\n        List<Integer> ans=new ArrayList<>();\\n        Queue<Integer> Q=new LinkedList<>();\\n        for(int i=1;i<=n;i++){\\n            if(indegree[i]==0)Q.add(i);\\n        }\\n\\n        List<Integer> arr=new ArrayList<>();\\n\\n        while(!Q.isEmpty()){\\n             int node=Q.poll();\\n             arr.add(node);          \\n             List<Integer> temp=map.get(node);\\n             for(int edg : temp){\\n                 indegree[edg]--;\\n                 if(indegree[edg] == 0){\\n                     Q.add(edg);\\n                 }\\n             }            \\n        }\\n\\n        return arr;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] buildMatrix(int k, int[][] rows, int[][] cols) {\\n       Map<Integer,List<Integer>> map=new HashMap<>();\\n       Map<Integer,List<Integer>> map2=new HashMap<>();\\n       \\n       for(int i=1;i<=k;i++){\\n           List<Integer> t=new ArrayList<>();\\n           map.put(i,t);\\n           List<Integer> t2=new ArrayList<>();\\n           map2.put(i,t2);\\n       }\\n       \\n       for(int a[] : rows){\\n            map.get(a[0]).add(a[1]);\\n       }\\n       \\n       for(int a[] : cols){\\n            map2.get(a[0]).add(a[1]);         \\n       }\\n\\n       List<Integer> listR = topo(map,k);\\n       List<Integer> listC = topo(map2,k);\\n       System.out.println(listR);\\n       System.out.println(listC);\\n       \\n       if(listR.size() != k || listC.size() != k){\\n           int a[][]=new int[0][0]; return a;\\n       }\\n\\n       Map<Integer,List<Integer>> map3=new HashMap<>();\\n\\n       for(int i=0;i<k;i++){\\n           List<Integer> temp=new ArrayList<>(); temp.add(i);\\n           map3.put(listR.get(i),temp);\\n       }\\n\\n        for(int i=0;i<k;i++){\\n           map3.get(listC.get(i)).add(i);\\n       }\\n\\n       int mat[][]=new int [k][k];\\n\\n       for(Map.Entry<Integer,List<Integer>> mp : map3.entrySet()){\\n           List<Integer> ind=mp.getValue();\\n           int value=mp.getKey();\\n\\n           mat[ind.get(0)][ind.get(1)]=value;\\n       }\\n\\n\\n       return mat;\\n        \\n    }\\n    private List<Integer> topo(Map<Integer,List<Integer>> map, int n){\\n        int indegree[]=new int[n+1];\\n\\n        for(int i=1;i<=n ;i++){\\n            for(int a : map.get(i)){\\n                indegree[a]++;\\n            }\\n        }\\n\\n        List<Integer> ans=new ArrayList<>();\\n        Queue<Integer> Q=new LinkedList<>();\\n        for(int i=1;i<=n;i++){\\n            if(indegree[i]==0)Q.add(i);\\n        }\\n\\n        List<Integer> arr=new ArrayList<>();\\n\\n        while(!Q.isEmpty()){\\n             int node=Q.poll();\\n             arr.add(node);          \\n             List<Integer> temp=map.get(node);\\n             for(int edg : temp){\\n                 indegree[edg]--;\\n                 if(indegree[edg] == 0){\\n                     Q.add(edg);\\n                 }\\n             }            \\n        }\\n\\n        return arr;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730436,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n vector<vector<int>>ans(k,vector<int>(k,0));\\n            vector<vector<int>>an;\\n       vector<int>adjr[k+1],adjc[k+1];\\n       \\n        int n=rowConditions.size();\\n        int m=colConditions.size();\\n      \\n        map<int,int>mr,mc;\\n        pair<int,int>p[k+1];\\n\\n        for(int i=0;i<n;i++){\\n            int u=rowConditions[i][0];\\n            int v=rowConditions[i][1];\\n            mr[v]++;\\n            adjr[u].push_back(v);\\n            }\\n\\n            for(int i=0;i<m;i++){\\n            int u1=colConditions[i][0];\\n            int v1=colConditions[i][1];\\n            mc[v1]++;\\n            adjc[u1].push_back(v1);\\n        }\\n        vector<int>topc;\\n        vector<int>topr;\\n        queue<int>qr,qc;\\n        for(int i=1;i<=k;i++){\\n            if(mr[i]==0){\\n                // cout<<i<<endl;\\n            topr.push_back(i);\\n            mr.erase(i);\\n            qr.push(i);\\n            }\\n            if(mc[i]==0){\\n            topc.push_back(i);\\n            mc.erase(i);\\n            qc.push(i);\\n            }\\n        }\\n\\n      while(!qr.empty()){\\n          int i=qr.front();\\n         \\n          qr.pop();\\n          for(auto it:adjr[i]){\\n              mr[it]--;\\n              if(mr[it]==0){\\n                   topr.push_back(it);\\n                  mr.erase(it);\\n              qr.push(it);}\\n          }\\n      }\\n\\n       while(!qc.empty()){\\n          int i=qc.front();\\n         \\n          qc.pop();\\n          for(auto it:adjc[i]){\\n              mc[it]--;\\n              if(mc[it]==0){\\n                  mc.erase(it);\\n                   topc.push_back(it);\\n              qc.push(it);}\\n          }\\n      }\\n      if(mr.size()!=0||mc.size()!=0)\\n    return an;\\n      for(int i=0;i<topr.size();i++)\\n     {\\n         cout<<topr[i]<<\" \"<<topc[i]<<endl;\\n       p[topr[i]].first=i;\\n       p[topc[i]].second=i;\\n\\n     }\\n     for(int i=1;i<=k;i++){\\n       int x=p[i].first;\\n       int y=p[i].second;\\n       ans[x][y]=i;\\n     }\\n\\n\\n     \\n    \\n    return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n vector<vector<int>>ans(k,vector<int>(k,0));\\n            vector<vector<int>>an;\\n       vector<int>adjr[k+1],adjc[k+1];\\n       \\n        int n=rowConditions.size();\\n        int m=colConditions.size();\\n      \\n        map<int,int>mr,mc;\\n        pair<int,int>p[k+1];\\n\\n        for(int i=0;i<n;i++){\\n            int u=rowConditions[i][0];\\n            int v=rowConditions[i][1];\\n            mr[v]++;\\n            adjr[u].push_back(v);\\n            }\\n\\n            for(int i=0;i<m;i++){\\n            int u1=colConditions[i][0];\\n            int v1=colConditions[i][1];\\n            mc[v1]++;\\n            adjc[u1].push_back(v1);\\n        }\\n        vector<int>topc;\\n        vector<int>topr;\\n        queue<int>qr,qc;\\n        for(int i=1;i<=k;i++){\\n            if(mr[i]==0){\\n                // cout<<i<<endl;\\n            topr.push_back(i);\\n            mr.erase(i);\\n            qr.push(i);\\n            }\\n            if(mc[i]==0){\\n            topc.push_back(i);\\n            mc.erase(i);\\n            qc.push(i);\\n            }\\n        }\\n\\n      while(!qr.empty()){\\n          int i=qr.front();\\n         \\n          qr.pop();\\n          for(auto it:adjr[i]){\\n              mr[it]--;\\n              if(mr[it]==0){\\n                   topr.push_back(it);\\n                  mr.erase(it);\\n              qr.push(it);}\\n          }\\n      }\\n\\n       while(!qc.empty()){\\n          int i=qc.front();\\n         \\n          qc.pop();\\n          for(auto it:adjc[i]){\\n              mc[it]--;\\n              if(mc[it]==0){\\n                  mc.erase(it);\\n                   topc.push_back(it);\\n              qc.push(it);}\\n          }\\n      }\\n      if(mr.size()!=0||mc.size()!=0)\\n    return an;\\n      for(int i=0;i<topr.size();i++)\\n     {\\n         cout<<topr[i]<<\" \"<<topc[i]<<endl;\\n       p[topr[i]].first=i;\\n       p[topc[i]].second=i;\\n\\n     }\\n     for(int i=1;i<=k;i++){\\n       int x=p[i].first;\\n       int y=p[i].second;\\n       ans[x][y]=i;\\n     }\\n\\n\\n     \\n    \\n    return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3709355,
                "title": "topo-sort-c",
                "content": "Make the topo order of both the 2D array according to given condition and set matrix with the help of both topo order.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        vector<int>adj[k+1];\\n        vector<int>adj1[k+1];\\n        vector<int>in1(k+1),in2(k+1);\\n  for(auto edge:rowConditions)\\n  {\\n      adj[edge[0]].push_back(edge[1]);\\n      in1[edge[1]]++;\\n  }\\n      for(auto edge:colConditions)\\n  {\\n      adj1[edge[1]].push_back(edge[0]);\\n      in2[edge[0]]++;\\n  }\\n\\n  queue<int>q;\\nfor(int i=1;i<=k;i++)\\n{\\n    if(in1[i]==0)\\n    q.push(i);\\n}\\nvector<int>topo1;\\nwhile(!q.empty())\\n{\\n    int node=q.front();\\n    q.pop();\\n    topo1.push_back(node);\\n    for(auto child:adj[node])\\n    {\\n        in1[child]--;\\n        if(in1[child]==0)\\n        {\\n            q.push(child);\\n        }\\n    }\\n}\\n\\n queue<int>q1;\\nfor(int i=1;i<=k;i++)\\n{\\n    if(in2[i]==0)\\n   { q1.push(i);\\n\\n   }\\n\\n}\\nif(topo1.size()<k) return {};\\nunordered_map<int,int>mp;\\nvector<int>topo2;\\nwhile(!q1.empty())\\n{\\n    int node=q1.front();\\n    q1.pop();\\n    topo2.push_back(node);\\n    for(auto child:adj1[node])\\n    {\\n        in2[child]--;\\n        if(in2[child]==0)\\n        {\\n            q1.push(child);\\n        }\\n    }\\n}\\nreverse(topo2.begin(),topo2.end());\\nif(topo2.size()<k) return {};\\nint i=0;\\nfor(int j=0;j<k;j++)\\n{\\n    mp[topo2[j]]=i;\\n    i++;\\n}\\n// cout<<mp[1]<<\" \"<<mp[2]<<\" \"<<mp[3]<<\"\\\\n\";\\nvector<vector<int>>ans(k,vector<int>(k,0));\\n\\nfor(int i=0;i<topo1.size();i++)\\n{\\n    ans[i][mp[topo1[i]]]=topo1[i];\\n    // cout<<i<<\" \"<<topo1[i]<<\" \"<<mp[topo1[i]]<<\"\\\\n\";\\n}\\nreturn ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        vector<int>adj[k+1];\\n        vector<int>adj1[k+1];\\n        vector<int>in1(k+1),in2(k+1);\\n  for(auto edge:rowConditions)\\n  {\\n      adj[edge[0]].push_back(edge[1]);\\n      in1[edge[1]]++;\\n  }\\n      for(auto edge:colConditions)\\n  {\\n      adj1[edge[1]].push_back(edge[0]);\\n      in2[edge[0]]++;\\n  }\\n\\n  queue<int>q;\\nfor(int i=1;i<=k;i++)\\n{\\n    if(in1[i]==0)\\n    q.push(i);\\n}\\nvector<int>topo1;\\nwhile(!q.empty())\\n{\\n    int node=q.front();\\n    q.pop();\\n    topo1.push_back(node);\\n    for(auto child:adj[node])\\n    {\\n        in1[child]--;\\n        if(in1[child]==0)\\n        {\\n            q.push(child);\\n        }\\n    }\\n}\\n\\n queue<int>q1;\\nfor(int i=1;i<=k;i++)\\n{\\n    if(in2[i]==0)\\n   { q1.push(i);\\n\\n   }\\n\\n}\\nif(topo1.size()<k) return {};\\nunordered_map<int,int>mp;\\nvector<int>topo2;\\nwhile(!q1.empty())\\n{\\n    int node=q1.front();\\n    q1.pop();\\n    topo2.push_back(node);\\n    for(auto child:adj1[node])\\n    {\\n        in2[child]--;\\n        if(in2[child]==0)\\n        {\\n            q1.push(child);\\n        }\\n    }\\n}\\nreverse(topo2.begin(),topo2.end());\\nif(topo2.size()<k) return {};\\nint i=0;\\nfor(int j=0;j<k;j++)\\n{\\n    mp[topo2[j]]=i;\\n    i++;\\n}\\n// cout<<mp[1]<<\" \"<<mp[2]<<\" \"<<mp[3]<<\"\\\\n\";\\nvector<vector<int>>ans(k,vector<int>(k,0));\\n\\nfor(int i=0;i<topo1.size();i++)\\n{\\n    ans[i][mp[topo1[i]]]=topo1[i];\\n    // cout<<i<<\" \"<<topo1[i]<<\" \"<<mp[topo1[i]]<<\"\\\\n\";\\n}\\nreturn ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3680520,
                "title": "simple-topological-sort",
                "content": "# Intuition\\nFind the topological ordering of the rows and columns, and populate the matrix using them.\\n\\n# Code\\n```\\nclass Solution:\\n    def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:\\n\\n        adj1 = [[] for _ in range(k)]\\n        adj2 = [[] for _ in range(k)]\\n        indegree1 = [0]*k\\n        indegree2 = [0]*k\\n\\n        for u, v in rowConditions:\\n            adj1[u-1].append(v-1)\\n            indegree1[v-1] += 1\\n\\n        for u, v in colConditions:\\n            adj2[u-1].append(v-1)\\n            indegree2[v-1] += 1\\n\\n        rowOrder = self.top(adj1, indegree1, k)\\n        colOrder = self.top(adj2, indegree2, k) \\n\\n        if len(rowOrder) + len(colOrder) < 2*k:\\n            return []\\n\\n        ans = [[0 for _ in range(k)] for _ in range(k)]\\n\\n        for u in range(1, k+1):\\n            ans[rowOrder.index(u-1)][colOrder.index(u-1)] = u\\n\\n        return ans\\n\\n\\n        \\n\\n        \\n\\n    def top(self, adj, indegree, n):\\n\\n        from collections import deque\\n\\n        ans = []\\n        Q = deque([u for u in range(n) if indegree[u] ==0])\\n\\n        while Q:\\n\\n            u = Q.popleft()\\n            ans.append(u)\\n\\n            for v in adj[u]:\\n                indegree[v] -= 1\\n                if indegree[v] ==0:\\n                    Q.append(v)\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:\\n\\n        adj1 = [[] for _ in range(k)]\\n        adj2 = [[] for _ in range(k)]\\n        indegree1 = [0]*k\\n        indegree2 = [0]*k\\n\\n        for u, v in rowConditions:\\n            adj1[u-1].append(v-1)\\n            indegree1[v-1] += 1\\n\\n        for u, v in colConditions:\\n            adj2[u-1].append(v-1)\\n            indegree2[v-1] += 1\\n\\n        rowOrder = self.top(adj1, indegree1, k)\\n        colOrder = self.top(adj2, indegree2, k) \\n\\n        if len(rowOrder) + len(colOrder) < 2*k:\\n            return []\\n\\n        ans = [[0 for _ in range(k)] for _ in range(k)]\\n\\n        for u in range(1, k+1):\\n            ans[rowOrder.index(u-1)][colOrder.index(u-1)] = u\\n\\n        return ans\\n\\n\\n        \\n\\n        \\n\\n    def top(self, adj, indegree, n):\\n\\n        from collections import deque\\n\\n        ans = []\\n        Q = deque([u for u in range(n) if indegree[u] ==0])\\n\\n        while Q:\\n\\n            u = Q.popleft()\\n            ans.append(u)\\n\\n            for v in adj[u]:\\n                indegree[v] -= 1\\n                if indegree[v] ==0:\\n                    Q.append(v)\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3674696,
                "title": "best-explanation-so-far-kahn-s-algo",
                "content": "# Intuition\\nSimple idea behind the solution is if we take projections of non zero elements of matrix along the row and column , those projected rows and colums should be topologically sorted.\\n\\n# Approach\\nSo we will first find valid orders of row and columns. seperately and then we will form the matrix.\\n![Screenshot 2023-06-23 at 23.43.43.png](https://assets.leetcode.com/users/images/20030905-63d6-4971-a2f8-f02004ae01df_1687544123.263926.png)\\n\\n# Complexity\\n- Time complexity: \\ntopoSort function is O(n) and buildMatrix function  has O(k^2) time complexity.\\noverall time complexity : O(n + k^2)\\n\\n- Space complexity:\\nTopological Sorting O(k), where k is the size of the matrix.\\nBuilding the Matrix is also O(k).\\noverall space complexity: O(k)\\n\\n# Code\\n```\\n//Simple idea behind the solution is if we take projections of non zero elements of matrix along the row and column , those projected rows and colums should be topologically sorted.\\n// So we will first find valid orders of row and columns. seperately and then we will form the matrix.\\n\\nclass Solution {\\npublic:\\n    vector<int> validorder(vector<vector<int>> &conditions, int k){\\n        vector<int> indegree(k+1, 0);\\n        vector<vector<int>> adj(k+1);\\n        // we will first create an adj list\\n        for(int i = 0 ; i< conditions.size(); i++){\\n            int a = conditions[i][0];\\n            int b = conditions[i][1];\\n            indegree[b]++;\\n            adj[a].push_back(b);\\n        }\\n        //Kahn\\'s algo\\n        vector<int> order;\\n        queue<int> q;\\n        for(int i=1;i<=k;i++){\\n            if(indegree[i]==0){\\n                q.push(i);\\n            }\\n        }\\n        while(!q.empty()){\\n            int node = q.front();\\n            q.pop();\\n            order.push_back(node);\\n            for(int i = 0 ; i<adj[node].size(); i++){\\n                int x=adj[node][i];\\n                indegree[x]--;\\n                if(indegree[x]==0){\\n                    q.push(x);\\n                }\\n            }\\n        }\\n        return order;\\n    }\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n\\n        vector<int> validcol = validorder(rowConditions, k);\\n        vector<int> validrow = validorder(colConditions, k);\\n\\n        if(validcol.size()!=k||validrow.size()!=k) return {};\\n\\n        vector<vector<int>> validmatrix(k, vector<int>(k, 0));\\n        for(int i = 0;i<k;i++){\\n            for(int j = 0 ; j<k ; j++){\\n                if(validcol[i]==validrow[j]){\\n                    validmatrix[i][j]=validcol[i];\\n                }\\n            }\\n        }\\n        return validmatrix;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\n//Simple idea behind the solution is if we take projections of non zero elements of matrix along the row and column , those projected rows and colums should be topologically sorted.\\n// So we will first find valid orders of row and columns. seperately and then we will form the matrix.\\n\\nclass Solution {\\npublic:\\n    vector<int> validorder(vector<vector<int>> &conditions, int k){\\n        vector<int> indegree(k+1, 0);\\n        vector<vector<int>> adj(k+1);\\n        // we will first create an adj list\\n        for(int i = 0 ; i< conditions.size(); i++){\\n            int a = conditions[i][0];\\n            int b = conditions[i][1];\\n            indegree[b]++;\\n            adj[a].push_back(b);\\n        }\\n        //Kahn\\'s algo\\n        vector<int> order;\\n        queue<int> q;\\n        for(int i=1;i<=k;i++){\\n            if(indegree[i]==0){\\n                q.push(i);\\n            }\\n        }\\n        while(!q.empty()){\\n            int node = q.front();\\n            q.pop();\\n            order.push_back(node);\\n            for(int i = 0 ; i<adj[node].size(); i++){\\n                int x=adj[node][i];\\n                indegree[x]--;\\n                if(indegree[x]==0){\\n                    q.push(x);\\n                }\\n            }\\n        }\\n        return order;\\n    }\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n\\n        vector<int> validcol = validorder(rowConditions, k);\\n        vector<int> validrow = validorder(colConditions, k);\\n\\n        if(validcol.size()!=k||validrow.size()!=k) return {};\\n\\n        vector<vector<int>> validmatrix(k, vector<int>(k, 0));\\n        for(int i = 0;i<k;i++){\\n            for(int j = 0 ; j<k ; j++){\\n                if(validcol[i]==validrow[j]){\\n                    validmatrix[i][j]=validcol[i];\\n                }\\n            }\\n        }\\n        return validmatrix;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3636610,
                "title": "java-graph-topological-sort-detect-directed-graph-cycle-commented-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    Map<Integer, List<Integer>> graph;\\n    boolean[] visited;\\n    boolean[] recurStack;\\n\\n    int[][] createMatrix(int k, List<Integer> rowOrders, List<Integer> colOrders){\\n\\n        int[][] matrix = new int[k][k];\\n\\n        //generate cell[r][c] for each k-th value\\n        //cell[kth-val] = [row, col]\\n        int[][] cells = new int[k + 1][2];\\n\\n        //why doing (k - row - 1) or (k - col - 1)? \\n        //beacuse both rowOrders & colOrders saved k-value in dependent\\n        //orders in the stack wise order(in reverse order for both rowOrder and colOrders)\\n        //where their starting indexes value should be placed at last row or last col\\n        for(int row = 0; row < k; row++){\\n            int val = rowOrders.get(row);\\n            cells[val][0] = k - row - 1;\\n        }\\n\\n        for(int col = 0; col < k; col++){\\n            int val = colOrders.get(col);\\n            cells[val][1] = k - col - 1;\\n        }\\n\\n        for(int val = 1; val <= k; val++){\\n            int row = cells[val][0];\\n            int col = cells[val][1];\\n            matrix[row][col] = val;\\n        }\\n\\n        return matrix;\\n    }\\n\\n    void createGraph(int[][] edges){\\n        //create directed-graph for the row conditions\\n        for(int[] edge : edges){\\n            int u = edge[0];\\n            int v = edge[1];\\n\\n            //in order to place a value denoted as \\'u\\' we must first place\\n            //the value denoted as \\'v\\' \\n            graph.putIfAbsent(u, new ArrayList<>());\\n            graph.get(u).add(v);\\n        } \\n    }\\n\\n    boolean topoSort_DetectDirectedGraphCycleHelper(int node, List<Integer> orders){\\n\\n        if(recurStack[node]) return true;\\n        if(visited[node]) return false;\\n\\n        visited[node] = true;\\n        recurStack[node] = true;\\n\\n        for(int mandatoryNode : graph.getOrDefault(node, new ArrayList<>())){\\n            if(topoSort_DetectDirectedGraphCycleHelper(mandatoryNode, orders)) return true;\\n        }\\n        orders.add(node);\\n        recurStack[node] = false;\\n        return false;\\n    }\\n\\n    public int[][] buildMatrix(int k, int[][] rowConditions, int[][] colConditions) {\\n        \\n        graph = new HashMap<>();\\n        //as given 1 <= abovei, belowi, lefti, righti <= k\\n        visited = new boolean[k + 1];\\n        recurStack = new boolean[k + 1];\\n\\n        //create directed-graph for the row conditions\\n        createGraph(rowConditions);\\n\\n        //do topo sort to get the dependency order of placing all the above --> below\\n        //values from the rowConditions[]\\n        List<Integer> rowOrders = new ArrayList<>();\\n        for(int node = 1; node <= k; node++){\\n            if(visited[node]) continue;\\n            //return empty matrix[][], if there exist cycle\\n            if(topoSort_DetectDirectedGraphCycleHelper(node, rowOrders)) return new int[][]{};\\n        }\\n\\n        //perform the same operations on colConditions[] befor that reset\\n        graph.clear();\\n        //as given 1 <= abovei, belowi, lefti, righti <= k\\n        visited = new boolean[k + 1];\\n        recurStack = new boolean[k + 1];\\n\\n        //create directed-graph for the col conditions\\n        createGraph(colConditions);\\n\\n        //do topo sort to get the dependency order of placing all the left --> right\\n        //values from the colConditions[]\\n        List<Integer> colOrders = new ArrayList<>();\\n        for(int node = 1; node <= k; node++){\\n            if(visited[node]) continue;\\n            //return empty matrix[][], if there exist cycle\\n            if(topoSort_DetectDirectedGraphCycleHelper(node, colOrders)) return new int[][]{};\\n        }\\n\\n        return createMatrix(k, rowOrders, colOrders);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    Map<Integer, List<Integer>> graph;\\n    boolean[] visited;\\n    boolean[] recurStack;\\n\\n    int[][] createMatrix(int k, List<Integer> rowOrders, List<Integer> colOrders){\\n\\n        int[][] matrix = new int[k][k];\\n\\n        //generate cell[r][c] for each k-th value\\n        //cell[kth-val] = [row, col]\\n        int[][] cells = new int[k + 1][2];\\n\\n        //why doing (k - row - 1) or (k - col - 1)? \\n        //beacuse both rowOrders & colOrders saved k-value in dependent\\n        //orders in the stack wise order(in reverse order for both rowOrder and colOrders)\\n        //where their starting indexes value should be placed at last row or last col\\n        for(int row = 0; row < k; row++){\\n            int val = rowOrders.get(row);\\n            cells[val][0] = k - row - 1;\\n        }\\n\\n        for(int col = 0; col < k; col++){\\n            int val = colOrders.get(col);\\n            cells[val][1] = k - col - 1;\\n        }\\n\\n        for(int val = 1; val <= k; val++){\\n            int row = cells[val][0];\\n            int col = cells[val][1];\\n            matrix[row][col] = val;\\n        }\\n\\n        return matrix;\\n    }\\n\\n    void createGraph(int[][] edges){\\n        //create directed-graph for the row conditions\\n        for(int[] edge : edges){\\n            int u = edge[0];\\n            int v = edge[1];\\n\\n            //in order to place a value denoted as \\'u\\' we must first place\\n            //the value denoted as \\'v\\' \\n            graph.putIfAbsent(u, new ArrayList<>());\\n            graph.get(u).add(v);\\n        } \\n    }\\n\\n    boolean topoSort_DetectDirectedGraphCycleHelper(int node, List<Integer> orders){\\n\\n        if(recurStack[node]) return true;\\n        if(visited[node]) return false;\\n\\n        visited[node] = true;\\n        recurStack[node] = true;\\n\\n        for(int mandatoryNode : graph.getOrDefault(node, new ArrayList<>())){\\n            if(topoSort_DetectDirectedGraphCycleHelper(mandatoryNode, orders)) return true;\\n        }\\n        orders.add(node);\\n        recurStack[node] = false;\\n        return false;\\n    }\\n\\n    public int[][] buildMatrix(int k, int[][] rowConditions, int[][] colConditions) {\\n        \\n        graph = new HashMap<>();\\n        //as given 1 <= abovei, belowi, lefti, righti <= k\\n        visited = new boolean[k + 1];\\n        recurStack = new boolean[k + 1];\\n\\n        //create directed-graph for the row conditions\\n        createGraph(rowConditions);\\n\\n        //do topo sort to get the dependency order of placing all the above --> below\\n        //values from the rowConditions[]\\n        List<Integer> rowOrders = new ArrayList<>();\\n        for(int node = 1; node <= k; node++){\\n            if(visited[node]) continue;\\n            //return empty matrix[][], if there exist cycle\\n            if(topoSort_DetectDirectedGraphCycleHelper(node, rowOrders)) return new int[][]{};\\n        }\\n\\n        //perform the same operations on colConditions[] befor that reset\\n        graph.clear();\\n        //as given 1 <= abovei, belowi, lefti, righti <= k\\n        visited = new boolean[k + 1];\\n        recurStack = new boolean[k + 1];\\n\\n        //create directed-graph for the col conditions\\n        createGraph(colConditions);\\n\\n        //do topo sort to get the dependency order of placing all the left --> right\\n        //values from the colConditions[]\\n        List<Integer> colOrders = new ArrayList<>();\\n        for(int node = 1; node <= k; node++){\\n            if(visited[node]) continue;\\n            //return empty matrix[][], if there exist cycle\\n            if(topoSort_DetectDirectedGraphCycleHelper(node, colOrders)) return new int[][]{};\\n        }\\n\\n        return createMatrix(k, rowOrders, colOrders);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3602793,
                "title": "c-topological-sort-col-and-row",
                "content": "Perform textbook topolocal sort on both col and row dependencies. \\n```\\nclass Solution {\\npublic:\\n    bool canPlace(vector<int> &indeg, vector<vector<int>> &adj, vector<int> &ans) {\\n        queue<int> q;\\n        for (int i = 1; i < indeg.size(); i++) {\\n            if (indeg[i] == 0) q.push(i);\\n        }\\n\\n        while(!q.empty()) {\\n            int node = q.front();\\n            q.pop();\\n            ans.push_back(node);\\n            for (int nei: adj[node]) {\\n                indeg[nei]--;\\n                if (indeg[nei] == 0) q.push(nei);\\n            }\\n        }\\n\\n        // cycle detection\\n        for (int i = 1; i < indeg.size(); i++) {\\n            if (indeg[i] != 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        vector<int> indegR(k+1);\\n        vector<int> indegC(k+1);\\n        vector<vector<int>> adjR(k+1);\\n        vector<vector<int>> adjC(k+1);\\n\\n        for (auto& r: rowConditions) {\\n            adjR[r[0]].push_back(r[1]);\\n            indegR[r[1]]++;\\n        }\\n\\n        for (auto& c: colConditions) {\\n            adjC[c[0]].push_back(c[1]);\\n            indegC[c[1]]++;\\n        }\\n\\n        vector<int> rowOrder;\\n        vector<int> colOrder;\\n        if (!canPlace(indegR, adjR, rowOrder)) return {};\\n        if (!canPlace(indegC, adjC, colOrder)) return {};\\n\\n        vector<int> elementToRow(k+1);\\n        for (int i = 0; i < k; i++) {\\n            elementToRow[rowOrder[i]] = i;\\n        }\\n\\n        vector<vector<int>> matrix(k, vector<int>(k));\\n        for (int j = 0; j < k; j++) {\\n            int el = colOrder[j];\\n            matrix[elementToRow[el]][j] = el;\\n        }\\n\\n        return matrix;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canPlace(vector<int> &indeg, vector<vector<int>> &adj, vector<int> &ans) {\\n        queue<int> q;\\n        for (int i = 1; i < indeg.size(); i++) {\\n            if (indeg[i] == 0) q.push(i);\\n        }\\n\\n        while(!q.empty()) {\\n            int node = q.front();\\n            q.pop();\\n            ans.push_back(node);\\n            for (int nei: adj[node]) {\\n                indeg[nei]--;\\n                if (indeg[nei] == 0) q.push(nei);\\n            }\\n        }\\n\\n        // cycle detection\\n        for (int i = 1; i < indeg.size(); i++) {\\n            if (indeg[i] != 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        vector<int> indegR(k+1);\\n        vector<int> indegC(k+1);\\n        vector<vector<int>> adjR(k+1);\\n        vector<vector<int>> adjC(k+1);\\n\\n        for (auto& r: rowConditions) {\\n            adjR[r[0]].push_back(r[1]);\\n            indegR[r[1]]++;\\n        }\\n\\n        for (auto& c: colConditions) {\\n            adjC[c[0]].push_back(c[1]);\\n            indegC[c[1]]++;\\n        }\\n\\n        vector<int> rowOrder;\\n        vector<int> colOrder;\\n        if (!canPlace(indegR, adjR, rowOrder)) return {};\\n        if (!canPlace(indegC, adjC, colOrder)) return {};\\n\\n        vector<int> elementToRow(k+1);\\n        for (int i = 0; i < k; i++) {\\n            elementToRow[rowOrder[i]] = i;\\n        }\\n\\n        vector<vector<int>> matrix(k, vector<int>(k));\\n        for (int j = 0; j < k; j++) {\\n            int el = colOrder[j];\\n            matrix[elementToRow[el]][j] = el;\\n        }\\n\\n        return matrix;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3588562,
                "title": "c-first-toposort-by-kahn-algo-and-then-placed-them-in-matrix",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        vector<vector<int>>ans(k,vector<int>(k,0));\\n            vector<vector<int>>an;\\n            // vector<int>visr(k+1,-1);\\n            // vector<int>visc(k+1,-1);\\n    //    vector<int>col(k+1,-1),row(k+1,-1);\\n       vector<int>adjr[k+1],adjc[k+1];\\n       \\n        int n=rowConditions.size();\\n        int m=colConditions.size();\\n      \\n        map<int,int>mr,mc;\\n        pair<int,int>p[k+1];\\n\\n        for(int i=0;i<n;i++){\\n            int u=rowConditions[i][0];\\n            int v=rowConditions[i][1];\\n            mr[v]++;\\n            adjr[u].push_back(v);\\n            }\\n\\n            for(int i=0;i<m;i++){\\n            int u1=colConditions[i][0];\\n            int v1=colConditions[i][1];\\n            mc[v1]++;\\n            adjc[u1].push_back(v1);\\n        }\\n        vector<int>topc;\\n        vector<int>topr;\\n        queue<int>qr,qc;\\n        for(int i=1;i<=k;i++){\\n            if(mr[i]==0){\\n                // cout<<i<<endl;\\n            topr.push_back(i);\\n            mr.erase(i);\\n            qr.push(i);\\n            }\\n            if(mc[i]==0){\\n            topc.push_back(i);\\n            mc.erase(i);\\n            qc.push(i);\\n            }\\n        }\\n\\n      while(!qr.empty()){\\n          int i=qr.front();\\n         \\n          qr.pop();\\n          for(auto it:adjr[i]){\\n              mr[it]--;\\n              if(mr[it]==0){\\n                   topr.push_back(it);\\n                  mr.erase(it);\\n              qr.push(it);}\\n          }\\n      }\\n\\n       while(!qc.empty()){\\n          int i=qc.front();\\n         \\n          qc.pop();\\n          for(auto it:adjc[i]){\\n              mc[it]--;\\n              if(mc[it]==0){\\n                  mc.erase(it);\\n                   topc.push_back(it);\\n              qc.push(it);}\\n          }\\n      }\\n      if(mr.size()!=0||mc.size()!=0)\\n    return an;\\n      for(int i=0;i<topr.size();i++)\\n     {\\n         cout<<topr[i]<<\" \"<<topc[i]<<endl;\\n       p[topr[i]].first=i;\\n       p[topc[i]].second=i;\\n\\n     }\\n     for(int i=1;i<=k;i++){\\n       int x=p[i].first;\\n       int y=p[i].second;\\n       ans[x][y]=i;\\n     }\\n\\n\\n     \\n    \\n    return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        vector<vector<int>>ans(k,vector<int>(k,0));\\n            vector<vector<int>>an;\\n            // vector<int>visr(k+1,-1);\\n            // vector<int>visc(k+1,-1);\\n    //    vector<int>col(k+1,-1),row(k+1,-1);\\n       vector<int>adjr[k+1],adjc[k+1];\\n       \\n        int n=rowConditions.size();\\n        int m=colConditions.size();\\n      \\n        map<int,int>mr,mc;\\n        pair<int,int>p[k+1];\\n\\n        for(int i=0;i<n;i++){\\n            int u=rowConditions[i][0];\\n            int v=rowConditions[i][1];\\n            mr[v]++;\\n            adjr[u].push_back(v);\\n            }\\n\\n            for(int i=0;i<m;i++){\\n            int u1=colConditions[i][0];\\n            int v1=colConditions[i][1];\\n            mc[v1]++;\\n            adjc[u1].push_back(v1);\\n        }\\n        vector<int>topc;\\n        vector<int>topr;\\n        queue<int>qr,qc;\\n        for(int i=1;i<=k;i++){\\n            if(mr[i]==0){\\n                // cout<<i<<endl;\\n            topr.push_back(i);\\n            mr.erase(i);\\n            qr.push(i);\\n            }\\n            if(mc[i]==0){\\n            topc.push_back(i);\\n            mc.erase(i);\\n            qc.push(i);\\n            }\\n        }\\n\\n      while(!qr.empty()){\\n          int i=qr.front();\\n         \\n          qr.pop();\\n          for(auto it:adjr[i]){\\n              mr[it]--;\\n              if(mr[it]==0){\\n                   topr.push_back(it);\\n                  mr.erase(it);\\n              qr.push(it);}\\n          }\\n      }\\n\\n       while(!qc.empty()){\\n          int i=qc.front();\\n         \\n          qc.pop();\\n          for(auto it:adjc[i]){\\n              mc[it]--;\\n              if(mc[it]==0){\\n                  mc.erase(it);\\n                   topc.push_back(it);\\n              qc.push(it);}\\n          }\\n      }\\n      if(mr.size()!=0||mc.size()!=0)\\n    return an;\\n      for(int i=0;i<topr.size();i++)\\n     {\\n         cout<<topr[i]<<\" \"<<topc[i]<<endl;\\n       p[topr[i]].first=i;\\n       p[topc[i]].second=i;\\n\\n     }\\n     for(int i=1;i<=k;i++){\\n       int x=p[i].first;\\n       int y=p[i].second;\\n       ans[x][y]=i;\\n     }\\n\\n\\n     \\n    \\n    return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3547922,
                "title": "cycle-finding-and-topological-sort",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBuild two directed graph using rowConditions and colConditions.\\nIf any of the two graph contains cycle matrix can not be built.\\nSo return empty matrix.\\n\\nUsing topological sort assign rows and columns to every numbers\\nfrom 1 to k.\\n\\nUsing the row and column information build the matrix.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rc, vector<vector<int>>& cc) {\\n        vector< vector<int> > ans(k,vector<int>(k,0));\\n        vector<int> radj[k+1], cadj[k+1];\\n        //adjacency list\\n        for(auto& v:rc) {\\n            radj[v[0]].push_back(v[1]);\\n        }\\n        \\n        for(auto& v:cc) {\\n            cadj[v[0]].push_back(v[1]);\\n        }\\n        \\n        \\n        bool cycle = false;\\n        vector<int> taken(k+1,0), vis(k+1,0);\\n        vector<int> tops, tops2,df;\\n        \\n        // checking if is there any cycle or not\\n        for(int i=1;i<=k;i++) {\\n            if(!taken[i]) {\\n                isCycle(i,vis,taken,radj,tops,cycle);\\n            }\\n        }\\n        vector<int> taken2(k+1,0), vis2(k+1,0);\\n        for(int i=1;i<=k;i++) {\\n            if(!taken2[i]) {\\n                isCycle(i,vis2,taken2,cadj,tops2,cycle);\\n            }\\n        }\\n        \\n        \\n        vector<vector<int>> a;\\n        if(cycle) return a;\\n\\n        \\n        reverse(tops.begin(), tops.end());\\n        reverse(tops2.begin(),tops2.end());\\n        \\n        \\n        //if no cycle found then build the matrix using topsort\\n        vector<int> row(k+1), col(k+1);\\n        \\n        int c = 0;\\n        for(int i=0;i<tops.size();i++) {\\n            row[tops[i]] = c++;\\n        }\\n        c = 0;\\n        for(int i=0;i<tops2.size();i++) {\\n            col[tops2[i]] = c++;\\n        }\\n        \\n        for(int i=1;i<=k;i++) {\\n            ans[row[i]][col[i]] = i;\\n        }\\n        return ans;\\n        \\n    }\\n    \\n    \\n    void isCycle(int u,vector<int>& vis,vector<int>& taken,vector<int> adj[], vector<int>& tops, bool &ans) {\\n        vis[u] = taken[u] = 1;\\n\\n        for(auto& v: adj[u]) {\\n            if(!vis[v] and !taken[v]) {\\n                isCycle(v,vis,taken,adj,tops,ans) ;\\n            }\\n            else if(vis[v]) ans = true;\\n        }\\n\\n        tops.push_back(u);\\n        vis[u] = 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rc, vector<vector<int>>& cc) {\\n        vector< vector<int> > ans(k,vector<int>(k,0));\\n        vector<int> radj[k+1], cadj[k+1];\\n        //adjacency list\\n        for(auto& v:rc) {\\n            radj[v[0]].push_back(v[1]);\\n        }\\n        \\n        for(auto& v:cc) {\\n            cadj[v[0]].push_back(v[1]);\\n        }\\n        \\n        \\n        bool cycle = false;\\n        vector<int> taken(k+1,0), vis(k+1,0);\\n        vector<int> tops, tops2,df;\\n        \\n        // checking if is there any cycle or not\\n        for(int i=1;i<=k;i++) {\\n            if(!taken[i]) {\\n                isCycle(i,vis,taken,radj,tops,cycle);\\n            }\\n        }\\n        vector<int> taken2(k+1,0), vis2(k+1,0);\\n        for(int i=1;i<=k;i++) {\\n            if(!taken2[i]) {\\n                isCycle(i,vis2,taken2,cadj,tops2,cycle);\\n            }\\n        }\\n        \\n        \\n        vector<vector<int>> a;\\n        if(cycle) return a;\\n\\n        \\n        reverse(tops.begin(), tops.end());\\n        reverse(tops2.begin(),tops2.end());\\n        \\n        \\n        //if no cycle found then build the matrix using topsort\\n        vector<int> row(k+1), col(k+1);\\n        \\n        int c = 0;\\n        for(int i=0;i<tops.size();i++) {\\n            row[tops[i]] = c++;\\n        }\\n        c = 0;\\n        for(int i=0;i<tops2.size();i++) {\\n            col[tops2[i]] = c++;\\n        }\\n        \\n        for(int i=1;i<=k;i++) {\\n            ans[row[i]][col[i]] = i;\\n        }\\n        return ans;\\n        \\n    }\\n    \\n    \\n    void isCycle(int u,vector<int>& vis,vector<int>& taken,vector<int> adj[], vector<int>& tops, bool &ans) {\\n        vis[u] = taken[u] = 1;\\n\\n        for(auto& v: adj[u]) {\\n            if(!vis[v] and !taken[v]) {\\n                isCycle(v,vis,taken,adj,tops,ans) ;\\n            }\\n            else if(vis[v]) ans = true;\\n        }\\n\\n        tops.push_back(u);\\n        vis[u] = 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3540561,
                "title": "topological-sort-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> topoSort(vector<vector<int>> &r, int k) {\\n        vector<int> cnt(k + 1, 0);\\n        vector<vector<int>> adj(k + 1);\\n        for (const auto& x : r) {\\n            cnt[x[1]]++;\\n            adj[x[0]].push_back(x[1]);\\n        }\\n        \\n        vector<int> topoOrder;\\n        queue<int> q;\\n        for (int i = 1; i <= k; i++) {\\n            if (cnt[i] == 0) {\\n                q.push(i);\\n            }\\n        }\\n        \\n        while (!q.empty()) {\\n            int u = q.front();\\n            q.pop();\\n            topoOrder.push_back(u);\\n            \\n            for (int x : adj[u]) {\\n                cnt[x]--;\\n                if (cnt[x] == 0) {\\n                    q.push(x);\\n                }\\n            }\\n        }\\n        \\n        return topoOrder;\\n    }\\n\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        vector<int> rowO = topoSort(rowConditions,k);\\n        vector<int> colO = topoSort(colConditions,k);\\n\\n        if(rowO.size() != k) return {};\\n        if(colO.size() != k) return {};\\n\\n        vector<vector<int>> res(k, vector<int>(k, 0));\\n        unordered_map<int,int> m;\\n\\n        for(int i=0; i<rowO.size(); i++){\\n            m[rowO[i]] = i;\\n        }\\n        for(int j=0; j<colO.size(); j++){\\n            res[m[colO[j]]][j] = colO[j];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> topoSort(vector<vector<int>> &r, int k) {\\n        vector<int> cnt(k + 1, 0);\\n        vector<vector<int>> adj(k + 1);\\n        for (const auto& x : r) {\\n            cnt[x[1]]++;\\n            adj[x[0]].push_back(x[1]);\\n        }\\n        \\n        vector<int> topoOrder;\\n        queue<int> q;\\n        for (int i = 1; i <= k; i++) {\\n            if (cnt[i] == 0) {\\n                q.push(i);\\n            }\\n        }\\n        \\n        while (!q.empty()) {\\n            int u = q.front();\\n            q.pop();\\n            topoOrder.push_back(u);\\n            \\n            for (int x : adj[u]) {\\n                cnt[x]--;\\n                if (cnt[x] == 0) {\\n                    q.push(x);\\n                }\\n            }\\n        }\\n        \\n        return topoOrder;\\n    }\\n\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        vector<int> rowO = topoSort(rowConditions,k);\\n        vector<int> colO = topoSort(colConditions,k);\\n\\n        if(rowO.size() != k) return {};\\n        if(colO.size() != k) return {};\\n\\n        vector<vector<int>> res(k, vector<int>(k, 0));\\n        unordered_map<int,int> m;\\n\\n        for(int i=0; i<rowO.size(); i++){\\n            m[rowO[i]] = i;\\n        }\\n        for(int j=0; j<colO.size(); j++){\\n            res[m[colO[j]]][j] = colO[j];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3400988,
                "title": "topological-sorting-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGeneralized topological sorting for row and column!!\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool flg = 1;\\n    void help(int k,vector<vector<int>> &arr,map<int,int> &mp) {\\n        vector<int> in(k+1,0);\\n        vector<vector<int>> g(k+1);\\n        for(int i=0;i<arr.size();i++) {\\n            int u = arr[i][0];\\n            int v = arr[i][1];\\n            g[u].push_back(v);\\n            in[v]++;\\n        }\\n\\n        queue<int> q;\\n        int seen = 0;\\n\\n        for(int i=1;i<=k;i++) if(in[i] == 0) q.push(i);\\n        int idx = 1;\\n        while(!q.empty()) {\\n            int node = q.front();\\n            q.pop();\\n            mp[node] = idx++;\\n            seen++;\\n\\n            for(auto &it : g[node]) {\\n                if(--in[it] == 0) q.push(it);\\n            }\\n        }\\n        if(seen < k) flg = 0;        // there must be a cycle\\n    }\\n\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        map<int,int> row;\\n        map<int,int> col;\\n\\n        help(k,rowConditions,row);\\n        help(k,colConditions,col);\\n\\n        vector<vector<int>> ans(k,vector<int>(k));\\n\\n        if(!flg) return {};\\n\\n        for(int i=1;i<=k;i++) {\\n            ans[row[i]-1][col[i]-1] = i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool flg = 1;\\n    void help(int k,vector<vector<int>> &arr,map<int,int> &mp) {\\n        vector<int> in(k+1,0);\\n        vector<vector<int>> g(k+1);\\n        for(int i=0;i<arr.size();i++) {\\n            int u = arr[i][0];\\n            int v = arr[i][1];\\n            g[u].push_back(v);\\n            in[v]++;\\n        }\\n\\n        queue<int> q;\\n        int seen = 0;\\n\\n        for(int i=1;i<=k;i++) if(in[i] == 0) q.push(i);\\n        int idx = 1;\\n        while(!q.empty()) {\\n            int node = q.front();\\n            q.pop();\\n            mp[node] = idx++;\\n            seen++;\\n\\n            for(auto &it : g[node]) {\\n                if(--in[it] == 0) q.push(it);\\n            }\\n        }\\n        if(seen < k) flg = 0;        // there must be a cycle\\n    }\\n\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        map<int,int> row;\\n        map<int,int> col;\\n\\n        help(k,rowConditions,row);\\n        help(k,colConditions,col);\\n\\n        vector<vector<int>> ans(k,vector<int>(k));\\n\\n        if(!flg) return {};\\n\\n        for(int i=1;i<=k;i++) {\\n            ans[row[i]-1][col[i]-1] = i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3364801,
                "title": "java-topological-sort",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[][] buildMatrix(int k, int[][] rowConditions, int[][] colConditions) {\\n        List<Integer> rowTopologicalOrder = getTopologicalOrder(rowConditions, k);\\n        if (rowTopologicalOrder.isEmpty()) \\n            return new int[0][0]; // Cycle detected\\n\\n        List<Integer> colTopologicalOrder = getTopologicalOrder(colConditions, k);\\n        if (colTopologicalOrder.isEmpty()) \\n            return new int[0][0]; // Cycle detected\\n\\n        Map<Integer, Integer> colOrderIndexMap = new HashMap<>();\\n        for (int i = 0; i < k; i++)\\n            colOrderIndexMap.put(colTopologicalOrder.get(i), i);\\n\\n        int[][] result = new int[k][k];\\n        for (int i = 0; i < k; i++)\\n            result[i][colOrderIndexMap.get(rowTopologicalOrder.get(i))] = rowTopologicalOrder.get(i);\\n        return result;\\n    }\\n\\n    private List<Integer> getTopologicalOrder(int[][] edges, int k) {\\n        Map<Integer, List<Integer>> adjList = buildGraph(edges);\\n        List<Integer> topologicalOrder = new ArrayList<>();\\n        int[] visited = new int[k + 1];\\n        for (int i = 1; i <= k; i++)\\n            if (!dfs(i, adjList, visited, topologicalOrder)) \\n                return Collections.emptyList(); // Cycle detected\\n        return topologicalOrder;\\n    }\\n\\n    private Map<Integer, List<Integer>> buildGraph(int[][] edges) {\\n        Map<Integer, List<Integer>> adjList = new HashMap<>();\\n        for (int[] edge : edges) {\\n            adjList.putIfAbsent(edge[1], new ArrayList<>());\\n            adjList.get(edge[1]).add(edge[0]);\\n        }\\n        return adjList;\\n    }\\n\\n    // Topological order + Cycle detection\\n    private boolean dfs(int node, Map<Integer, List<Integer>> graph, int[] visited, List<Integer> topologicalOrder) {\\n        if (visited[node] == 1) return true;\\n        if (visited[node] == -1) return false;\\n        visited[node] = -1;\\n\\n        for (int neighbour : graph.getOrDefault(node, Collections.emptyList()))\\n            if (!dfs(neighbour, graph, visited, topologicalOrder)) return false;\\n\\n        visited[node] = 1;\\n        topologicalOrder.add(node);\\n        return true;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] buildMatrix(int k, int[][] rowConditions, int[][] colConditions) {\\n        List<Integer> rowTopologicalOrder = getTopologicalOrder(rowConditions, k);\\n        if (rowTopologicalOrder.isEmpty()) \\n            return new int[0][0]; // Cycle detected\\n\\n        List<Integer> colTopologicalOrder = getTopologicalOrder(colConditions, k);\\n        if (colTopologicalOrder.isEmpty()) \\n            return new int[0][0]; // Cycle detected\\n\\n        Map<Integer, Integer> colOrderIndexMap = new HashMap<>();\\n        for (int i = 0; i < k; i++)\\n            colOrderIndexMap.put(colTopologicalOrder.get(i), i);\\n\\n        int[][] result = new int[k][k];\\n        for (int i = 0; i < k; i++)\\n            result[i][colOrderIndexMap.get(rowTopologicalOrder.get(i))] = rowTopologicalOrder.get(i);\\n        return result;\\n    }\\n\\n    private List<Integer> getTopologicalOrder(int[][] edges, int k) {\\n        Map<Integer, List<Integer>> adjList = buildGraph(edges);\\n        List<Integer> topologicalOrder = new ArrayList<>();\\n        int[] visited = new int[k + 1];\\n        for (int i = 1; i <= k; i++)\\n            if (!dfs(i, adjList, visited, topologicalOrder)) \\n                return Collections.emptyList(); // Cycle detected\\n        return topologicalOrder;\\n    }\\n\\n    private Map<Integer, List<Integer>> buildGraph(int[][] edges) {\\n        Map<Integer, List<Integer>> adjList = new HashMap<>();\\n        for (int[] edge : edges) {\\n            adjList.putIfAbsent(edge[1], new ArrayList<>());\\n            adjList.get(edge[1]).add(edge[0]);\\n        }\\n        return adjList;\\n    }\\n\\n    // Topological order + Cycle detection\\n    private boolean dfs(int node, Map<Integer, List<Integer>> graph, int[] visited, List<Integer> topologicalOrder) {\\n        if (visited[node] == 1) return true;\\n        if (visited[node] == -1) return false;\\n        visited[node] = -1;\\n\\n        for (int neighbour : graph.getOrDefault(node, Collections.emptyList()))\\n            if (!dfs(neighbour, graph, visited, topologicalOrder)) return false;\\n\\n        visited[node] = 1;\\n        topologicalOrder.add(node);\\n        return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3359107,
                "title": "c-dfs-topo-beats-93-8-faster-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\narrangement due to r_cond and due to c_cond are independent of one another so simply creating a topo_sort for rows [1..k] nodes and topo_sort for cols arrangement [1..k] nodes will be enough to solve the problem\\nin final matrix[x][y]=i\\nx=(index of ith node in r_topo)-1\\ny=(index of ith node in c_topo)-1\\ni->(1-->k)\\nif any of the conditions leads to  cyclic arrangement of nodes then return empty matrix\\n\\nIn general using dfs the vector or stack arrangement we get is exactly reverse of actual topo sequence\\nbut by reversing the  direction of edges we can cope up with that problem and no need to reverse\\nlike ui->vi edge reverse vi->ui edge now by dfs first ui and its desendents will be pushed in the vector and then vi , exactly what we want using this saves the time that\\'swhy i have takn reversed edges in adjacency list\\nyou have to take care  of the 1 based  indexing also  \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ndfs topo_sort\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(v+e) (simple dfs  complexity)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nadj lists O(k*k)\\nvisited arrays and topo_arrays-O(k)\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool dfs(int& ind,int node,vector<int>& visited,vector<int>& vec,vector<vector<int>>& adj){\\n    visited[node]=0;\\n    bool ans=1;\\n    for(int& i: adj[node]){\\n        if(visited[i]==0){\\n            return false;\\n        }\\n        if(visited[i]==-1){\\n            ans=dfs(ind,i,visited,vec,adj);\\n            if(ans==0) return false;\\n        }\\n    }\\n    visited[node]=1;\\n    vec[node-1]=ind++;\\n    return true;\\n}\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& r_cond, vector<vector<int>>& c_cond) {\\n        vector<vector<int>> ans(k,vector<int>(k,0));\\n        vector<int> r_visited(k+1,-1);\\n        vector<int> c_visited(k+1,-1);\\n        vector<vector<int>> r_adj(k+1);\\n        vector<vector<int>> c_adj(k+1);\\n        for(auto& ele: r_cond){\\n            r_adj[ele[1]].push_back(ele[0]);\\n        }\\n        for(auto& ele: c_cond){\\n            c_adj[ele[1]].push_back(ele[0]);\\n        }\\n        \\n        vector<int> r_topo(k,-1);\\n        vector<int> c_topo(k,-1);\\n        int r_ind=0;\\n        int c_ind=0;\\n        for(int i=1;i<=k;i++){\\n            if(r_visited[i]==-1){\\n                if(!dfs(r_ind,i,r_visited,r_topo,r_adj)){\\n                    return {};\\n                }\\n            }\\n            if(c_visited[i]==-1){\\n                if(!dfs(c_ind,i,c_visited,c_topo,c_adj)){\\n                    return {};\\n                }\\n            }\\n        }\\n        for(int i=0;i<k;i++){\\n            ans[r_topo[i]][c_topo[i]]=i+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool dfs(int& ind,int node,vector<int>& visited,vector<int>& vec,vector<vector<int>>& adj){\\n    visited[node]=0;\\n    bool ans=1;\\n    for(int& i: adj[node]){\\n        if(visited[i]==0){\\n            return false;\\n        }\\n        if(visited[i]==-1){\\n            ans=dfs(ind,i,visited,vec,adj);\\n            if(ans==0) return false;\\n        }\\n    }\\n    visited[node]=1;\\n    vec[node-1]=ind++;\\n    return true;\\n}\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& r_cond, vector<vector<int>>& c_cond) {\\n        vector<vector<int>> ans(k,vector<int>(k,0));\\n        vector<int> r_visited(k+1,-1);\\n        vector<int> c_visited(k+1,-1);\\n        vector<vector<int>> r_adj(k+1);\\n        vector<vector<int>> c_adj(k+1);\\n        for(auto& ele: r_cond){\\n            r_adj[ele[1]].push_back(ele[0]);\\n        }\\n        for(auto& ele: c_cond){\\n            c_adj[ele[1]].push_back(ele[0]);\\n        }\\n        \\n        vector<int> r_topo(k,-1);\\n        vector<int> c_topo(k,-1);\\n        int r_ind=0;\\n        int c_ind=0;\\n        for(int i=1;i<=k;i++){\\n            if(r_visited[i]==-1){\\n                if(!dfs(r_ind,i,r_visited,r_topo,r_adj)){\\n                    return {};\\n                }\\n            }\\n            if(c_visited[i]==-1){\\n                if(!dfs(c_ind,i,c_visited,c_topo,c_adj)){\\n                    return {};\\n                }\\n            }\\n        }\\n        for(int i=0;i<k;i++){\\n            ans[r_topo[i]][c_topo[i]]=i+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3338105,
                "title": "simple-toposort-application",
                "content": "# Code\\n```\\nclass Solution {\\nprivate:\\n    vector<int> bfsTopo(int &k,unordered_map<int,vector<int>>&adj){\\n        vector<bool>vis(k+1,0);\\n        vector<int>ind(k+1,0);\\n        vector<int>v;\\n        queue<int>q;\\n\\n        // store indegree of ele bet 1 to k\\n        for(auto &x:adj){\\n            for(auto &i:x.second) ind[i]++;\\n        }\\n\\n        // push node with ind==0 in queue\\n        for(int i=1; i<=k; i++){\\n            if(ind[i]==0) q.push(i);\\n        }\\n\\n        while(!q.empty()){\\n            int node = q.front(); q.pop();\\n            v.push_back(node);\\n\\n            // reduce indegree of adj nodes of node\\n            for(auto &i:adj[node]){\\n                ind[i]--;\\n                if(ind[i]==0) q.push(i);\\n            } \\n        }\\n\\n        // if cycle\\n        if(v.size()!=k) return {-1};\\n\\n        return v;\\n    }    \\npublic:\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        // find index of Rows & Cols of elements using topoSort Algo\\n        unordered_map<int,vector<int> >adjr,adjc;\\n\\n        // build graph acc to row conditions\\n        for(auto &i:rowConditions){\\n            adjr[i[0]].push_back(i[1]);\\n        }\\n\\n        // build graph acc to col conditions\\n        for(auto &i:colConditions){\\n            adjc[i[0]].push_back(i[1]);\\n        }        \\n\\n        // do topoSort to get row indexes -> using kanhs Algo\\n        vector<int>rowIndexes = bfsTopo(k,adjr);\\n        if(rowIndexes[0]==-1) return {};    // if cycle\\n\\n\\n        // do topoSort to get col indexes -> using kanhs Algo\\n        vector<int>colIndexes = bfsTopo(k,adjc);\\n        if(colIndexes[0]==-1) return {};    // if cycle   \\n\\n        \\n        vector<vector<int>>ans(k,vector<int>(k,0));\\n\\n        unordered_map<int,int>r,c;\\n\\n        for(int i=0; i<k; i++){\\n            r[i] = rowIndexes[i];\\n            c[i] = colIndexes[i];\\n        }\\n\\n        // build matrix\\n        for(int i=0; i<k; i++){\\n            for(int j=0; j<k; j++){\\n                if(r[i]==c[j]) {\\n                    ans[i][j] = r[i];\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<int> bfsTopo(int &k,unordered_map<int,vector<int>>&adj){\\n        vector<bool>vis(k+1,0);\\n        vector<int>ind(k+1,0);\\n        vector<int>v;\\n        queue<int>q;\\n\\n        // store indegree of ele bet 1 to k\\n        for(auto &x:adj){\\n            for(auto &i:x.second) ind[i]++;\\n        }\\n\\n        // push node with ind==0 in queue\\n        for(int i=1; i<=k; i++){\\n            if(ind[i]==0) q.push(i);\\n        }\\n\\n        while(!q.empty()){\\n            int node = q.front(); q.pop();\\n            v.push_back(node);\\n\\n            // reduce indegree of adj nodes of node\\n            for(auto &i:adj[node]){\\n                ind[i]--;\\n                if(ind[i]==0) q.push(i);\\n            } \\n        }\\n\\n        // if cycle\\n        if(v.size()!=k) return {-1};\\n\\n        return v;\\n    }    \\npublic:\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        // find index of Rows & Cols of elements using topoSort Algo\\n        unordered_map<int,vector<int> >adjr,adjc;\\n\\n        // build graph acc to row conditions\\n        for(auto &i:rowConditions){\\n            adjr[i[0]].push_back(i[1]);\\n        }\\n\\n        // build graph acc to col conditions\\n        for(auto &i:colConditions){\\n            adjc[i[0]].push_back(i[1]);\\n        }        \\n\\n        // do topoSort to get row indexes -> using kanhs Algo\\n        vector<int>rowIndexes = bfsTopo(k,adjr);\\n        if(rowIndexes[0]==-1) return {};    // if cycle\\n\\n\\n        // do topoSort to get col indexes -> using kanhs Algo\\n        vector<int>colIndexes = bfsTopo(k,adjc);\\n        if(colIndexes[0]==-1) return {};    // if cycle   \\n\\n        \\n        vector<vector<int>>ans(k,vector<int>(k,0));\\n\\n        unordered_map<int,int>r,c;\\n\\n        for(int i=0; i<k; i++){\\n            r[i] = rowIndexes[i];\\n            c[i] = colIndexes[i];\\n        }\\n\\n        // build matrix\\n        for(int i=0; i<k; i++){\\n            for(int j=0; j<k; j++){\\n                if(r[i]==c[j]) {\\n                    ans[i][j] = r[i];\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3253528,
                "title": "toposort-dfs-c-line-by-line-explaination",
                "content": "**APPROACH --**\\nLet\\'s take first example after making it\\'s adjaency list for row and column seperately would be\\n**For row**\\n1-2\\n2-\\n3-2\\n**For Col**\\n1-\\n2-1\\n3-2\\n\\nafter topo sort the vector for row will be **2 1 3** and col would be  **1 2 3**\\nIf we mark their index from k-1 that would be it\\'s row number and column number in final answer array!\\nExample for row->   2     1      3\\n Row No.->              2     1      0\\n \\n Example for Col->  1     2      3\\n col No.->                2     1      0\\n**Now you have got the row no. and col. no. for every element mark it in the final array answer!**\\n**Suggestion are most Welcome !**\\n```\\nclass Solution\\n{\\npublic:\\n\\tvector<vector<int>> buildMatrix(int k, vector<vector<int>> &rowC, vector<vector<int>> &colC)\\n\\t{\\n\\t\\tvector<vector<int>> ans(k, vector<int>(k, 0));\\n\\t\\tvector<int> adj_row[k], adj_col[k];\\n\\t\\t// Create adjaency matrix for row and column seperately and remember it\\'s 1 based indexing\\n\\t\\tfor (auto it : rowC)\\n\\t\\t\\tadj_row[it[0] - 1].push_back(it[1] - 1);\\n\\t\\tfor (auto it : colC)\\n\\t\\t\\tadj_col[it[0] - 1].push_back(it[1] - 1);\\n\\t\\t// If it contains cycle return empty vector\\n\\t\\tif (isCyclic(k, adj_row) || isCyclic(k, adj_col))\\n\\t\\t{\\n\\t\\t\\tvector<vector<int>> v;\\n\\t\\t\\treturn v;\\n\\t\\t}\\n\\t\\t// dfs Topo-Sort seperately for row and column\\n\\t\\tstack<int> stR, stC;\\n\\t\\tvector<bool> visR(k, false), visC(k, false);\\n\\t\\tfor (int i = 0; i < k; i++)\\n\\t\\t{\\n\\t\\t\\tif (!visR[i])\\n\\t\\t\\t{\\n\\t\\t\\t\\tdfs(i, visR, adj_row, stR);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < k; i++)\\n\\t\\t{\\n\\t\\t\\tif (!visC[i])\\n\\t\\t\\t\\tdfs(i, visC, adj_col, stC);\\n\\t\\t}\\n\\t\\tvector<int> topoR, topoC;\\n\\t\\twhile (!stR.empty())\\n\\t\\t{\\n\\t\\t\\ttopoR.push_back(stR.top());\\n\\t\\t\\tstR.pop();\\n\\t\\t}\\n\\t\\twhile (!stC.empty())\\n\\t\\t{\\n\\t\\t\\ttopoC.push_back(stC.top());\\n\\t\\t\\tstC.pop();\\n\\t\\t}\\n\\t\\treverse(topoR.begin(), topoR.end());\\n\\t\\treverse(topoC.begin(), topoC.end());\\n\\t\\t// Till now i have created final topo sort vector for row and column\\n\\t\\t// data-structure for storing row and column for element\\n\\t\\tmap<int, vector<int>> mp;\\n\\t\\tint temp = k - 1;\\n\\t\\tfor (int i = 0; i < k; i++)\\n\\t\\t{\\n\\t\\t\\tmp[topoR[i]].push_back(temp--);\\n\\t\\t}\\n\\t\\t// Updation in final answer vector\\n\\t\\ttemp = k - 1;\\n\\t\\tfor (int i = 0; i < k; i++)\\n\\t\\t{\\n\\t\\t\\tmp[topoC[i]].push_back(temp--);\\n\\t\\t}\\n\\t\\tfor (auto it : mp)\\n\\t\\t{\\n\\t\\t\\tint val = it.first + 1;\\n\\t\\t\\tint r = it.second[0];\\n\\t\\t\\tint c = it.second[1];\\n\\t\\t\\tans[r][c] = val;\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n\\nprivate:\\n\\tvoid dfs(int i, vector<bool> &vis, vector<int> adj[], stack<int> &st)\\n\\t{\\n\\t\\tvis[i] = true;\\n\\t\\tfor (auto &it : adj[i])\\n\\t\\t{\\n\\t\\t\\tif (!vis[it])\\n\\t\\t\\t\\tdfs(it, vis, adj, st);\\n\\t\\t}\\n\\t\\tst.push(i);\\n\\t}\\n\\t// Cycle detection Template\\nprivate:\\n\\tbool isCyclic(int V, vector<int> adj[])\\n\\t{\\n\\t\\tvector<bool> vis(V, false);\\n\\t\\tvector<bool> pathVis(V, false);\\n\\t\\tfor (int i = 0; i < V; i++)\\n\\t\\t{\\n\\t\\t\\tif (!vis[i])\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (dfs(i, vis, pathVis, V, adj))\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n\\nprivate:\\n\\tbool dfs(int i, vector<bool> &vis, vector<bool> &pathVis, int V, vector<int> adj[])\\n\\t{\\n\\t\\tvis[i] = true;\\n\\t\\tpathVis[i] = true;\\n\\t\\tfor (auto it : adj[i])\\n\\t\\t{\\n\\t\\t\\tif (!vis[it])\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (dfs(it, vis, pathVis, V, adj))\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\telse if (pathVis[it])\\n\\t\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\tpathVis[i] = false;\\n\\t\\treturn false;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n\\tvector<vector<int>> buildMatrix(int k, vector<vector<int>> &rowC, vector<vector<int>> &colC)\\n\\t{\\n\\t\\tvector<vector<int>> ans(k, vector<int>(k, 0));\\n\\t\\tvector<int> adj_row[k], adj_col[k];\\n\\t\\t// Create adjaency matrix for row and column seperately and remember it\\'s 1 based indexing\\n\\t\\tfor (auto it : rowC)\\n\\t\\t\\tadj_row[it[0] - 1].push_back(it[1] - 1);\\n\\t\\tfor (auto it : colC)\\n\\t\\t\\tadj_col[it[0] - 1].push_back(it[1] - 1);\\n\\t\\t// If it contains cycle return empty vector\\n\\t\\tif (isCyclic(k, adj_row) || isCyclic(k, adj_col))\\n\\t\\t{\\n\\t\\t\\tvector<vector<int>> v;\\n\\t\\t\\treturn v;\\n\\t\\t}\\n\\t\\t// dfs Topo-Sort seperately for row and column\\n\\t\\tstack<int> stR, stC;\\n\\t\\tvector<bool> visR(k, false), visC(k, false);\\n\\t\\tfor (int i = 0; i < k; i++)\\n\\t\\t{\\n\\t\\t\\tif (!visR[i])\\n\\t\\t\\t{\\n\\t\\t\\t\\tdfs(i, visR, adj_row, stR);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < k; i++)\\n\\t\\t{\\n\\t\\t\\tif (!visC[i])\\n\\t\\t\\t\\tdfs(i, visC, adj_col, stC);\\n\\t\\t}\\n\\t\\tvector<int> topoR, topoC;\\n\\t\\twhile (!stR.empty())\\n\\t\\t{\\n\\t\\t\\ttopoR.push_back(stR.top());\\n\\t\\t\\tstR.pop();\\n\\t\\t}\\n\\t\\twhile (!stC.empty())\\n\\t\\t{\\n\\t\\t\\ttopoC.push_back(stC.top());\\n\\t\\t\\tstC.pop();\\n\\t\\t}\\n\\t\\treverse(topoR.begin(), topoR.end());\\n\\t\\treverse(topoC.begin(), topoC.end());\\n\\t\\t// Till now i have created final topo sort vector for row and column\\n\\t\\t// data-structure for storing row and column for element\\n\\t\\tmap<int, vector<int>> mp;\\n\\t\\tint temp = k - 1;\\n\\t\\tfor (int i = 0; i < k; i++)\\n\\t\\t{\\n\\t\\t\\tmp[topoR[i]].push_back(temp--);\\n\\t\\t}\\n\\t\\t// Updation in final answer vector\\n\\t\\ttemp = k - 1;\\n\\t\\tfor (int i = 0; i < k; i++)\\n\\t\\t{\\n\\t\\t\\tmp[topoC[i]].push_back(temp--);\\n\\t\\t}\\n\\t\\tfor (auto it : mp)\\n\\t\\t{\\n\\t\\t\\tint val = it.first + 1;\\n\\t\\t\\tint r = it.second[0];\\n\\t\\t\\tint c = it.second[1];\\n\\t\\t\\tans[r][c] = val;\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n\\nprivate:\\n\\tvoid dfs(int i, vector<bool> &vis, vector<int> adj[], stack<int> &st)\\n\\t{\\n\\t\\tvis[i] = true;\\n\\t\\tfor (auto &it : adj[i])\\n\\t\\t{\\n\\t\\t\\tif (!vis[it])\\n\\t\\t\\t\\tdfs(it, vis, adj, st);\\n\\t\\t}\\n\\t\\tst.push(i);\\n\\t}\\n\\t// Cycle detection Template\\nprivate:\\n\\tbool isCyclic(int V, vector<int> adj[])\\n\\t{\\n\\t\\tvector<bool> vis(V, false);\\n\\t\\tvector<bool> pathVis(V, false);\\n\\t\\tfor (int i = 0; i < V; i++)\\n\\t\\t{\\n\\t\\t\\tif (!vis[i])\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (dfs(i, vis, pathVis, V, adj))\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n\\nprivate:\\n\\tbool dfs(int i, vector<bool> &vis, vector<bool> &pathVis, int V, vector<int> adj[])\\n\\t{\\n\\t\\tvis[i] = true;\\n\\t\\tpathVis[i] = true;\\n\\t\\tfor (auto it : adj[i])\\n\\t\\t{\\n\\t\\t\\tif (!vis[it])\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (dfs(it, vis, pathVis, V, adj))\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\telse if (pathVis[it])\\n\\t\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\tpathVis[i] = false;\\n\\t\\treturn false;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3234253,
                "title": "by-kahn-algo",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    vector<int>kahns(vector<vector<int>>&conditions,int k){\\n           \\n\\n           vector<int>graph[k+1];\\n\\n           vector<int>indgree(k+1,0);\\n    /// building the graph it is directed \\n           for(vector<int>child: conditions){\\n\\n               int src=child[0];\\n               int dst=child[1];\\n\\n               graph[src].push_back(dst);\\n               indgree[dst]++;\\n\\n\\n           }\\n\\n\\n           queue<int>q;\\n\\n           for(int i=1;i<indgree.size();i++){\\n\\n               if(indgree[i]==0){\\n\\n                   q.push(i);\\n               }\\n\\n\\n           }\\n\\n\\n           vector<int>res;\\n\\n\\n           while(!q.empty()){\\n\\n               int node =q.front();\\n\\n               res.push_back(node);\\n               q.pop();\\n\\n\\n               for(int child: graph[node]){\\n\\n                   indgree[child]--;\\n\\n                   if(indgree[child]==0){\\n                       q.push(child);\\n                   }\\n               }\\n\\n\\n           }\\n\\n        \\n        return res;\\n\\n\\n    }\\n\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        \\n          vector<int>put_row=kahns(rowConditions,k);    // [1,4,3,2]\\n          vector<int>put_col=kahns(colConditions,k);     // [ 1,4,2,3]\\n\\n\\n          for(int i: put_row){\\n              cout<<i<<\" \";\\n          }cout<<endl;\\n\\n          for(int i: put_col){\\n              cout<<i<<\" \";\\n          }\\n\\n\\n          // check is there cycle or not\\n          vector<vector<int>>res(k,vector<int>(k,0));\\n          if(put_row.size()<k or put_col.size()<k){\\n\\n              return {};\\n          }\\n\\n\\n          //now built the matrix  \\n\\n\\n          unordered_map<int,int>mp;\\n\\n\\n          for(int i=1;i<k;i++){\\n\\n              mp[put_col[i]]=i;\\n          }\\n\\n\\n\\n          for(int i=0;i<k;i++){\\n\\n              int row=i;\\n              int col=mp[put_row[i]];\\n\\n              res[row][col]=put_row[i];\\n          }\\n \\n       return res;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<int>kahns(vector<vector<int>>&conditions,int k){\\n           \\n\\n           vector<int>graph[k+1];\\n\\n           vector<int>indgree(k+1,0);\\n    /// building the graph it is directed \\n           for(vector<int>child: conditions){\\n\\n               int src=child[0];\\n               int dst=child[1];\\n\\n               graph[src].push_back(dst);\\n               indgree[dst]++;\\n\\n\\n           }\\n\\n\\n           queue<int>q;\\n\\n           for(int i=1;i<indgree.size();i++){\\n\\n               if(indgree[i]==0){\\n\\n                   q.push(i);\\n               }\\n\\n\\n           }\\n\\n\\n           vector<int>res;\\n\\n\\n           while(!q.empty()){\\n\\n               int node =q.front();\\n\\n               res.push_back(node);\\n               q.pop();\\n\\n\\n               for(int child: graph[node]){\\n\\n                   indgree[child]--;\\n\\n                   if(indgree[child]==0){\\n                       q.push(child);\\n                   }\\n               }\\n\\n\\n           }\\n\\n        \\n        return res;\\n\\n\\n    }\\n\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        \\n          vector<int>put_row=kahns(rowConditions,k);    // [1,4,3,2]\\n          vector<int>put_col=kahns(colConditions,k);     // [ 1,4,2,3]\\n\\n\\n          for(int i: put_row){\\n              cout<<i<<\" \";\\n          }cout<<endl;\\n\\n          for(int i: put_col){\\n              cout<<i<<\" \";\\n          }\\n\\n\\n          // check is there cycle or not\\n          vector<vector<int>>res(k,vector<int>(k,0));\\n          if(put_row.size()<k or put_col.size()<k){\\n\\n              return {};\\n          }\\n\\n\\n          //now built the matrix  \\n\\n\\n          unordered_map<int,int>mp;\\n\\n\\n          for(int i=1;i<k;i++){\\n\\n              mp[put_col[i]]=i;\\n          }\\n\\n\\n\\n          for(int i=0;i<k;i++){\\n\\n              int row=i;\\n              int col=mp[put_row[i]];\\n\\n              res[row][col]=put_row[i];\\n          }\\n \\n       return res;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3135758,
                "title": "c-easy-hai-binod",
                "content": "\\n    bool valid=true;\\n    \\n    void traverse(int i,map<int,vector<int>> &Edge,vector<bool> &visit,vector<bool> &inc,stack<int> &st)\\n    {\\n        if(inc[i]==true)\\n        {\\n            valid=false;\\n            return;\\n        }\\n        if(visit[i]==true)\\n            return;\\n        visit[i]=true;\\n        inc[i]=true;\\n        \\n        for(int e:Edge[i])\\n        {\\n            traverse(e,Edge,visit,inc,st);\\n        }\\n        st.push(i);\\n        inc[i]=false;\\n    }\\n    \\n    \\n    vector<int> solve(int k,vector<vector<int>> side)\\n    {\\n        map<int,vector<int>> Edge;\\n        \\n        for(vector<int> s:side)\\n        {\\n            Edge[s[0]].push_back(s[1]);\\n        }\\n        \\n        stack<int> st;\\n        \\n        vector<bool> visit(k+1,false);\\n        vector<bool> inc(k+1,false);\\n        for(int i=1;i<=k;i++)\\n        {\\n            if(visit[i]==false)\\n                traverse(i,Edge,visit,inc,st);\\n        }\\n        vector<int> ans(k+1);\\n        int i=0;\\n        while(st.size()>0)\\n        {\\n            ans[st.top()]=i;\\n            i++;\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n    \\n    \\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) \\n    {\\n        vector<vector<int>> mat(k,vector<int> (k,0));\\n        \\n        vector<int> row=solve(k,rowConditions);\\n        vector<int> col=solve(k,colConditions);\\n        \\n        if(!valid)\\n        {\\n            vector<vector<int>> mat;\\n            return mat;\\n        }\\n        \\n        for(int i=1;i<=k;i++)\\n        {\\n            mat[row[i]][col[i]]=i;\\n        }\\n        \\n        return mat;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "\\n    bool valid=true;\\n    \\n    void traverse(int i,map<int,vector<int>> &Edge,vector<bool> &visit,vector<bool> &inc,stack<int> &st)\\n    {\\n        if(inc[i]==true)\\n        {\\n            valid=false;\\n            return;\\n        }\\n        if(visit[i]==true)\\n            return;\\n        visit[i]=true;\\n        inc[i]=true;\\n        \\n        for(int e:Edge[i])\\n        {\\n            traverse(e,Edge,visit,inc,st);\\n        }\\n        st.push(i);\\n        inc[i]=false;\\n    }\\n    \\n    \\n    vector<int> solve(int k,vector<vector<int>> side)\\n    {\\n        map<int,vector<int>> Edge;\\n        \\n        for(vector<int> s:side)\\n        {\\n            Edge[s[0]].push_back(s[1]);\\n        }\\n        \\n        stack<int> st;\\n        \\n        vector<bool> visit(k+1,false);\\n        vector<bool> inc(k+1,false);\\n        for(int i=1;i<=k;i++)\\n        {\\n            if(visit[i]==false)\\n                traverse(i,Edge,visit,inc,st);\\n        }\\n        vector<int> ans(k+1);\\n        int i=0;\\n        while(st.size()>0)\\n        {\\n            ans[st.top()]=i;\\n            i++;\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n    \\n    \\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) \\n    {\\n        vector<vector<int>> mat(k,vector<int> (k,0));\\n        \\n        vector<int> row=solve(k,rowConditions);\\n        vector<int> col=solve(k,colConditions);\\n        \\n        if(!valid)\\n        {\\n            vector<vector<int>> mat;\\n            return mat;\\n        }\\n        \\n        for(int i=1;i<=k;i++)\\n        {\\n            mat[row[i]][col[i]]=i;\\n        }\\n        \\n        return mat;\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3134480,
                "title": "java-explaination-easy-topological-sort",
                "content": "Why to use Topological Sort?\\nThere is ordering that a comes before b ( a->b) in both row and column which is like a directed graph and can be solved with topological sort.\\n\\nSome more questions on topological sort:\\n1. https://leetcode.com/problems/course-schedule/\\n2. https://leetcode.com/problems/course-schedule-ii/\\n\\n\\n**Algorithm**\\n1. Build the directed graph a->b where a comes before b for both rowCondition and colCondition\\n2. Calculate indegree of each node\\n3. [Topological sort] Iteratively take the nodes with indegree 0 and decrease the indegree of their neighbours by 1 and store them in list, this will give the order of nodes\\n4. Create a map for column values to its index\\n5. Using columnIndex map create the matrix in row and column order that we got from topological sorting\\n\\n\\n**Upvote is appreciated**\\n\\t\\n\\t\\n\\tclass Solution {\\n    public int[][] buildMatrix(int k, int[][] rowCondition, int[][] colCondition) {\\n        int rowindegree[]=new int[k+1];\\n        int colindegree[]=new int[k+1];\\n        \\n        HashMap<Integer,ArrayList<Integer>> rowmap=build(rowCondition,rowindegree,k);\\n        HashMap<Integer,ArrayList<Integer>> colmap=build(colCondition,colindegree,k);\\n        \\n        List<Integer> row=topsort(rowmap,rowindegree,k);\\n        List<Integer> col=topsort(colmap,colindegree,k);\\n        \\n        if(row==null || col==null)\\n            return new int[0][0];\\n        \\n        int matrix[][]=new int[k][k];\\n        HashMap<Integer,Integer> index=indexmap(col,k);\\n        \\n        for(int i=0;i<k;i++){\\n            matrix[i][index.get(row.get(i))]=row.get(i);\\n        }\\n        return matrix;\\n        \\n    }\\n    HashMap<Integer,ArrayList<Integer>> build(int[][] condition,int indegree[],int k){\\n        HashMap<Integer,ArrayList<Integer>> hm=new HashMap<>();\\n        for(int i=1;i<=k;i++){\\n            hm.put(i,new ArrayList<>());\\n        }\\n        for(int c[]:condition){\\n            hm.get(c[0]).add(c[1]);\\n            indegree[c[1]]++;\\n        }\\n        return hm;\\n    }\\n    \\n    List<Integer> topsort(HashMap<Integer,ArrayList<Integer>> hm, int indegree[],int k){\\n        List<Integer> res=new ArrayList<>();\\n        Queue<Integer> q=new LinkedList<>();\\n        \\n        for(int i=1;i<=k;i++){\\n            if(indegree[i]==0)\\n                q.add(i);\\n        }\\n        \\n        while(!q.isEmpty()){\\n            int c=q.remove();\\n            res.add(c);\\n            for(int nei:hm.get(c)){\\n                indegree[nei]--;\\n                if(indegree[nei]==0)\\n                    q.add(nei);\\n            }   \\n        }\\n        \\n        if(res.size()!=k)\\n            return null;\\n        \\n        return res;\\n    }\\n    \\n    HashMap<Integer,Integer> indexmap(List<Integer> list,int k){\\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n        for(int i=0;i<k;i++){\\n            hm.put(list.get(i),i);\\n        }\\n        return hm;\\n    }\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "class Solution {\\n    public int[][] buildMatrix(int k, int[][] rowCondition, int[][] colCondition) {\\n        int rowindegree[]=new int[k+1];\\n        int colindegree[]=new int[k+1];\\n        \\n        HashMap<Integer,ArrayList<Integer>> rowmap=build(rowCondition,rowindegree,k);\\n        HashMap<Integer,ArrayList<Integer>> colmap=build(colCondition,colindegree,k);\\n        \\n        List<Integer> row=topsort(rowmap,rowindegree,k);\\n        List<Integer> col=topsort(colmap,colindegree,k);\\n        \\n        if(row==null || col==null)\\n            return new int[0][0];\\n        \\n        int matrix[][]=new int[k][k];\\n        HashMap<Integer,Integer> index=indexmap(col,k);\\n        \\n        for(int i=0;i<k;i++){\\n            matrix[i][index.get(row.get(i))]=row.get(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3123981,
                "title": "c-toposort",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& r, vector<vector<int>>& c) {\\n         vector<vector<int>> ans ;\\n        \\n        map<vector<int> ,int > m ,mm  ; \\n        map<int, vector<int>>mr , mc;\\n        map<int, int> ir ,ic ;\\n      vector<int>tr, tc; \\n        for(auto it : r)\\n        {\\n            m[it]++; \\n        \\n        }\\n        for(auto it : c)\\n        {\\n            mm[it]++ ;\\n        }\\n        \\n        for(auto it : m )\\n        {\\n            mr[it.first[0]].push_back(it.first[1]) ; \\n          ir[it.first[1]]++ ;\\n        }\\n         for(auto it : mm )\\n        {\\n            mc[it.first[0]].push_back(it.first[1]) ; \\n         ic[it.first[1]]++ ;\\n         }\\n        queue<int>q ,q1 ; \\n        for(int i =1; i<=k ;i++)\\n        {\\n            if(ir[i]==0)\\n                q.push(i) ; \\n        }\\n        while(!q.empty())\\n        {\\n            int s = q.size() ; \\n            for(int i =0  ;i<s ;i++)\\n            {\\n            int node = q.front() ; \\n                q.pop() ; \\n            tr.push_back(node) ;\\n            for(auto it : mr[node])\\n            {\\n                ir[it]-- ; \\n                if(ir[it]==0)\\n                {\\n                    q.push(it) ; \\n                }\\n            }\\n        }\\n            \\n        }\\n        \\n        for(int i =1; i<=k ;i++)\\n        {\\n            if(ic[i]==0)\\n                q1.push(i) ; \\n        }\\n        while(!q1.empty())\\n        {\\n            int s = q1.size() ; \\n            for(int i =0  ;i<s ;i++)\\n            {\\n            int node = q1.front() ; \\n                q1.pop() ; \\n            tc.push_back(node) ;\\n            for(auto it : mc[node])\\n            {\\n                ic[it]-- ; \\n                if(ic[it]==0)\\n                {\\n                    q1.push(it) ; \\n                }\\n            }\\n        }\\n        }\\n        if(tr.size()!=k || tc.size()!=k)\\n            return ans ;\\n        ans.resize(k ,vector<int>(k ,0 )) ; \\n        map<int ,int > qq ; \\n        for(int i = 0 ;i<tr.size(); i++)\\n        {\\n            qq[tr[i]]= i ; \\n        }\\n        for(int i = 0; i<tc.size(); i++)\\n        {\\n            ans[qq[tc[i]]][i] = tc[i]; \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& r, vector<vector<int>>& c) {\\n         vector<vector<int>> ans ;\\n        \\n        map<vector<int> ,int > m ,mm  ; \\n        map<int, vector<int>>mr , mc;\\n        map<int, int> ir ,ic ;\\n      vector<int>tr, tc; \\n        for(auto it : r)\\n        {\\n            m[it]++; \\n        \\n        }\\n        for(auto it : c)\\n        {\\n            mm[it]++ ;\\n        }\\n        \\n        for(auto it : m )\\n        {\\n            mr[it.first[0]].push_back(it.first[1]) ; \\n          ir[it.first[1]]++ ;\\n        }\\n         for(auto it : mm )\\n        {\\n            mc[it.first[0]].push_back(it.first[1]) ; \\n         ic[it.first[1]]++ ;\\n         }\\n        queue<int>q ,q1 ; \\n        for(int i =1; i<=k ;i++)\\n        {\\n            if(ir[i]==0)\\n                q.push(i) ; \\n        }\\n        while(!q.empty())\\n        {\\n            int s = q.size() ; \\n            for(int i =0  ;i<s ;i++)\\n            {\\n            int node = q.front() ; \\n                q.pop() ; \\n            tr.push_back(node) ;\\n            for(auto it : mr[node])\\n            {\\n                ir[it]-- ; \\n                if(ir[it]==0)\\n                {\\n                    q.push(it) ; \\n                }\\n            }\\n        }\\n            \\n        }\\n        \\n        for(int i =1; i<=k ;i++)\\n        {\\n            if(ic[i]==0)\\n                q1.push(i) ; \\n        }\\n        while(!q1.empty())\\n        {\\n            int s = q1.size() ; \\n            for(int i =0  ;i<s ;i++)\\n            {\\n            int node = q1.front() ; \\n                q1.pop() ; \\n            tc.push_back(node) ;\\n            for(auto it : mc[node])\\n            {\\n                ic[it]-- ; \\n                if(ic[it]==0)\\n                {\\n                    q1.push(it) ; \\n                }\\n            }\\n        }\\n        }\\n        if(tr.size()!=k || tc.size()!=k)\\n            return ans ;\\n        ans.resize(k ,vector<int>(k ,0 )) ; \\n        map<int ,int > qq ; \\n        for(int i = 0 ;i<tr.size(); i++)\\n        {\\n            qq[tr[i]]= i ; \\n        }\\n        for(int i = 0; i<tc.size(); i++)\\n        {\\n            ans[qq[tc[i]]][i] = tc[i]; \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3088524,
                "title": "simple-topological-sorting-on-rowconditions-colconditions",
                "content": "```\\nclass Solution:\\n    def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:\\n        # create a graph from rowConditions and colConditions\\n        row_map = {i: set() for i in range(1, k+1)}\\n        row_indegree = {i: 0 for i in range(1, k+1)}\\n\\n        col_map = {i: set() for i in range(1, k+1)}\\n        col_indegree = {i: 0 for i in range(1, k+1)}\\n\\n        for row in rowConditions:\\n            row_map[row[0]].add(row[1])\\n        \\n        for key, value in row_map.items():\\n            for nei in value:\\n                row_indegree[nei]+=1\\n\\n        for col in colConditions:\\n            col_map[col[0]].add(col[1])\\n\\n        for key, value in col_map.items():\\n            for nei in value:\\n                col_indegree[nei]+=1\\n\\n        print(row_map)\\n        print(row_indegree)\\n        \\n        def get_topo_order(graph, indegree_map):\\n            que = deque([])\\n            order = []\\n\\n            for key, value in indegree_map.items():\\n                if value == 0:\\n                    que.append(key)\\n\\n            while len(que):\\n                node = que.popleft() \\n                order.append(node)\\n                for nei in graph[node]:\\n                    indegree_map[nei]-=1\\n                    if indegree_map[nei] == 0:\\n                        que.append(nei)\\n            return order\\n\\n        row_topo_ord = get_topo_order(row_map, row_indegree)\\n        col_topo_ord = get_topo_order(col_map, col_indegree)\\n\\n        if len(row_topo_ord) < len(row_map) or len(col_topo_ord) < len(col_map):\\n            return []\\n\\n        ans = [[0 for _ in range(k)] for _ in range(k)]\\n        for i, val in enumerate(row_topo_ord):\\n            col_idx = col_topo_ord.index(val)\\n            ans[i][col_idx] = val\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution:\\n    def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:\\n        # create a graph from rowConditions and colConditions\\n        row_map = {i: set() for i in range(1, k+1)}\\n        row_indegree = {i: 0 for i in range(1, k+1)}\\n\\n        col_map = {i: set() for i in range(1, k+1)}\\n        col_indegree = {i: 0 for i in range(1, k+1)}\\n\\n        for row in rowConditions:\\n            row_map[row[0]].add(row[1])\\n        \\n        for key, value in row_map.items():\\n            for nei in value:\\n                row_indegree[nei]+=1\\n\\n        for col in colConditions:\\n            col_map[col[0]].add(col[1])\\n\\n        for key, value in col_map.items():\\n            for nei in value:\\n                col_indegree[nei]+=1\\n\\n        print(row_map)\\n        print(row_indegree)\\n        \\n        def get_topo_order(graph, indegree_map):\\n            que = deque([])\\n            order = []\\n\\n            for key, value in indegree_map.items():\\n                if value == 0:\\n                    que.append(key)\\n\\n            while len(que):\\n                node = que.popleft() \\n                order.append(node)\\n                for nei in graph[node]:\\n                    indegree_map[nei]-=1\\n                    if indegree_map[nei] == 0:\\n                        que.append(nei)\\n            return order\\n\\n        row_topo_ord = get_topo_order(row_map, row_indegree)\\n        col_topo_ord = get_topo_order(col_map, col_indegree)\\n\\n        if len(row_topo_ord) < len(row_map) or len(col_topo_ord) < len(col_map):\\n            return []\\n\\n        ans = [[0 for _ in range(k)] for _ in range(k)]\\n        for i, val in enumerate(row_topo_ord):\\n            col_idx = col_topo_ord.index(val)\\n            ans[i][col_idx] = val\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052280,
                "title": "golang-topological-sorting-bfs-easy-understanding",
                "content": "```go\\nfunc buildMatrix(k int, rowConditions [][]int, colConditions [][]int) [][]int {\\n  // Let\\'s use Topological sorting on both conditions separately. That will\\n  // give us the row ordering and column ordering. With the row ordering\\n  // e.g [1, 3, 2], we know which row each element must go to. The column ordering\\n  // tells us which column in that row the element must be placed.\\n  rows := topoSort(k, rowConditions)\\n  cols := topoSort(k, colConditions)\\n  if len(rows) != k || len(cols) != k {\\n    return nil\\n  }\\n  mat := make([][]int, k)\\n  for i := 0; i < k; i++ {\\n    mat[i] = make([]int, k)\\n  }\\n  // Let\\'s make a map of element to its column index\\n  colMap := make(map[int]int)\\n  for i := 0; i < len(cols); i++ {\\n    colMap[cols[i]] = i\\n  }\\n  // For each row element, we\\'ll lookup its column index from the map we previously created\\n  // and place the element in the corresponding cell in the resuluting matrix.\\n  for i := 0; i < k; i++ {\\n    mat[i][colMap[rows[i]]] = rows[i]\\n  }\\n  return mat\\n}\\n\\nfunc topoSort(k int, conditions [][]int) []int {\\n  var order []int\\n  adjacencyList := make([][]int, k+1)\\n  indegree := make([]int, k+1)\\n  for _, cond := range conditions {\\n    adjacencyList[cond[0]] = append(adjacencyList[cond[0]], cond[1])\\n    indegree[cond[1]]++\\n  }\\n  var queue []int\\n  for i := 1; i <= k; i++ {\\n    if indegree[i] == 0 {\\n      queue = append(queue, i)\\n    }\\n  }\\n  for len(queue) > 0 {\\n    var newQueue []int\\n    for _, i := range queue {\\n      order = append(order, i)\\n      for _, nei := range adjacencyList[i] {\\n        indegree[nei]--\\n        if indegree[nei] == 0 {\\n          newQueue = append(newQueue, nei)\\n        }\\n      }\\n    }\\n    queue = newQueue\\n  }\\n  return order\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Topological Sort"
                ],
                "code": "```go\\nfunc buildMatrix(k int, rowConditions [][]int, colConditions [][]int) [][]int {\\n  // Let\\'s use Topological sorting on both conditions separately. That will\\n  // give us the row ordering and column ordering. With the row ordering\\n  // e.g [1, 3, 2], we know which row each element must go to. The column ordering\\n  // tells us which column in that row the element must be placed.\\n  rows := topoSort(k, rowConditions)\\n  cols := topoSort(k, colConditions)\\n  if len(rows) != k || len(cols) != k {\\n    return nil\\n  }\\n  mat := make([][]int, k)\\n  for i := 0; i < k; i++ {\\n    mat[i] = make([]int, k)\\n  }\\n  // Let\\'s make a map of element to its column index\\n  colMap := make(map[int]int)\\n  for i := 0; i < len(cols); i++ {\\n    colMap[cols[i]] = i\\n  }\\n  // For each row element, we\\'ll lookup its column index from the map we previously created\\n  // and place the element in the corresponding cell in the resuluting matrix.\\n  for i := 0; i < k; i++ {\\n    mat[i][colMap[rows[i]]] = rows[i]\\n  }\\n  return mat\\n}\\n\\nfunc topoSort(k int, conditions [][]int) []int {\\n  var order []int\\n  adjacencyList := make([][]int, k+1)\\n  indegree := make([]int, k+1)\\n  for _, cond := range conditions {\\n    adjacencyList[cond[0]] = append(adjacencyList[cond[0]], cond[1])\\n    indegree[cond[1]]++\\n  }\\n  var queue []int\\n  for i := 1; i <= k; i++ {\\n    if indegree[i] == 0 {\\n      queue = append(queue, i)\\n    }\\n  }\\n  for len(queue) > 0 {\\n    var newQueue []int\\n    for _, i := range queue {\\n      order = append(order, i)\\n      for _, nei := range adjacencyList[i] {\\n        indegree[nei]--\\n        if indegree[nei] == 0 {\\n          newQueue = append(newQueue, nei)\\n        }\\n      }\\n    }\\n    queue = newQueue\\n  }\\n  return order\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3031639,
                "title": "python-topological-sortt",
                "content": "# Intuition\\nThe question asks for certain ordering of the numbers based on 1) rows and 2) columns. There can be different ways of arranging the numbers but it doesn\\'t matter which one we choose as long as the conditions are met. This sounds like a DAG (directed acyclical graph) and yes we will use topological sort for this question\\n\\n# Approach\\nSimple enough. We just need to sort the rows and columns seperately and combine the two together. Since both sortings use the same function but different variables, we can create a function and pass in parameters to reflect what we are sorting. Note that we need to be able to detect cycles in the graph and here I use visited to indicate two scenarios: 1) a node has been visited and we will not go back to it, since all its children are visited. 2) we mark that a node is in the path. Case 2 is useful because if we encounter the same node that are in the path the second time, we know that a cycle is detected, and I use dfs to return True for that matter.\\n\\n# Complexity\\n- Time complexity:\\n$$O(max(m, n))$$ for building the graph and $$O(k)$$ for traversing the graph, $$O(k^2)$$ to construct the final matrix based on orderings. Time complexity will depend on which one\\'s greater.\\n- Space complexity:\\n$$O(k^2)$$ for constructing the matrix. $$O(max(m, n))$$ for the adjacency lists.\\n\\n# Code\\n```\\nclass Solution(object):\\n    def buildMatrix(self, k, rowConditions, colConditions):\\n        \"\"\"\\n        :type k: int\\n        :type rowConditions: List[List[int]]\\n        :type colConditions: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        # based on row conditions, topologically sort the indices so we know which number occupies which row\\n        # and then arrange the row based on columns, after topologically sorting the columns\\n        row_adj = {i+1: set() for i in range(k)}\\n        col_adj = {i+1: set() for i in range(k)}\\n\\n        # build a starting matrix\\n        matrix = [[0 for i in range(k)] for j in range(k)]\\n\\n        # build adjacency lists\\n        for above, below in rowConditions:\\n            row_adj[above].add(below)\\n        for left, right in colConditions:\\n            col_adj[left].add(right)\\n        \\n        visited = {} # false = visited, true = in the path\\n        col_order = []\\n        row_order = []\\n\\n        # dfs function for topological sort\\n        def dfs(curr, adj, arr):\\n            if curr in visited:\\n                return visited[curr]\\n            visited[curr] = True \\n            for neighbor in adj[curr]:\\n                if dfs(neighbor, adj, arr):\\n                    return True \\n            visited[curr] = False\\n            arr.append(curr)\\n            return False\\n        \\n        for curr in row_adj:\\n            if dfs(curr, row_adj, row_order):\\n                return []\\n        row_order.reverse()\\n        # print(row_order)\\n\\n        visited = {} # false = visited, true = in the path\\n        for curr in col_adj:\\n            if dfs(curr, col_adj, col_order):\\n                return []\\n        col_order.reverse()\\n        # print(col_order)\\n\\n        # construct the matrix based on conditions\\n        for idx in range(len(matrix)):\\n            num = row_order[idx]\\n            col_pos = col_order.index(num)\\n            matrix[idx][col_pos] = num\\n        return matrix\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution(object):\\n    def buildMatrix(self, k, rowConditions, colConditions):\\n        \"\"\"\\n        :type k: int\\n        :type rowConditions: List[List[int]]\\n        :type colConditions: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        # based on row conditions, topologically sort the indices so we know which number occupies which row\\n        # and then arrange the row based on columns, after topologically sorting the columns\\n        row_adj = {i+1: set() for i in range(k)}\\n        col_adj = {i+1: set() for i in range(k)}\\n\\n        # build a starting matrix\\n        matrix = [[0 for i in range(k)] for j in range(k)]\\n\\n        # build adjacency lists\\n        for above, below in rowConditions:\\n            row_adj[above].add(below)\\n        for left, right in colConditions:\\n            col_adj[left].add(right)\\n        \\n        visited = {} # false = visited, true = in the path\\n        col_order = []\\n        row_order = []\\n\\n        # dfs function for topological sort\\n        def dfs(curr, adj, arr):\\n            if curr in visited:\\n                return visited[curr]\\n            visited[curr] = True \\n            for neighbor in adj[curr]:\\n                if dfs(neighbor, adj, arr):\\n                    return True \\n            visited[curr] = False\\n            arr.append(curr)\\n            return False\\n        \\n        for curr in row_adj:\\n            if dfs(curr, row_adj, row_order):\\n                return []\\n        row_order.reverse()\\n        # print(row_order)\\n\\n        visited = {} # false = visited, true = in the path\\n        for curr in col_adj:\\n            if dfs(curr, col_adj, col_order):\\n                return []\\n        col_order.reverse()\\n        # print(col_order)\\n\\n        # construct the matrix based on conditions\\n        for idx in range(len(matrix)):\\n            num = row_order[idx]\\n            col_pos = col_order.index(num)\\n            matrix[idx][col_pos] = num\\n        return matrix\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3031637,
                "title": "python-topological-sortt",
                "content": "# Intuition\\nThe question asks for certain ordering of the numbers based on 1) rows and 2) columns. There can be different ways of arranging the numbers but it doesn\\'t matter which one we choose as long as the conditions are met. This sounds like a DAG (directed acyclical graph) and yes we will use topological sort for this question\\n\\n# Approach\\nSimple enough. We just need to sort the rows and columns seperately and combine the two together. Since both sortings use the same function but different variables, we can create a function and pass in parameters to reflect what we are sorting. Note that we need to be able to detect cycles in the graph and here I use visited to indicate two scenarios: 1) a node has been visited and we will not go back to it, since all its children are visited. 2) we mark that a node is in the path. Case 2 is useful because if we encounter the same node that are in the path the second time, we know that a cycle is detected, and I use dfs to return True for that matter.\\n\\n# Complexity\\n- Time complexity:\\n$$O(max(m, n))$$ for building the graph and $$O(k)$$ for traversing the graph, $$O(k^2)$$ to construct the final matrix based on orderings. Time complexity will depend on which one\\'s greater.\\n- Space complexity:\\n$$O(k^2)$$ for constructing the matrix. $$O(max(m, n))$$ for the adjacency lists.\\n\\n# Code\\n```\\nclass Solution(object):\\n    def buildMatrix(self, k, rowConditions, colConditions):\\n        \"\"\"\\n        :type k: int\\n        :type rowConditions: List[List[int]]\\n        :type colConditions: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        # based on row conditions, topologically sort the indices so we know which number occupies which row\\n        # and then arrange the row based on columns, after topologically sorting the columns\\n        row_adj = {i+1: set() for i in range(k)}\\n        col_adj = {i+1: set() for i in range(k)}\\n\\n        # build a starting matrix\\n        matrix = [[0 for i in range(k)] for j in range(k)]\\n\\n        # build adjacency lists\\n        for above, below in rowConditions:\\n            row_adj[above].add(below)\\n        for left, right in colConditions:\\n            col_adj[left].add(right)\\n        \\n        visited = {} # false = visited, true = in the path\\n        col_order = []\\n        row_order = []\\n\\n        # dfs function for topological sort\\n        def dfs(curr, adj, arr):\\n            if curr in visited:\\n                return visited[curr]\\n            visited[curr] = True \\n            for neighbor in adj[curr]:\\n                if dfs(neighbor, adj, arr):\\n                    return True \\n            visited[curr] = False\\n            arr.append(curr)\\n            return False\\n        \\n        for curr in row_adj:\\n            if dfs(curr, row_adj, row_order):\\n                return []\\n        row_order.reverse()\\n        # print(row_order)\\n\\n        visited = {} # false = visited, true = in the path\\n        for curr in col_adj:\\n            if dfs(curr, col_adj, col_order):\\n                return []\\n        col_order.reverse()\\n        # print(col_order)\\n\\n        # construct the matrix based on conditions\\n        for idx in range(len(matrix)):\\n            num = row_order[idx]\\n            col_pos = col_order.index(num)\\n            matrix[idx][col_pos] = num\\n        return matrix\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution(object):\\n    def buildMatrix(self, k, rowConditions, colConditions):\\n        \"\"\"\\n        :type k: int\\n        :type rowConditions: List[List[int]]\\n        :type colConditions: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        # based on row conditions, topologically sort the indices so we know which number occupies which row\\n        # and then arrange the row based on columns, after topologically sorting the columns\\n        row_adj = {i+1: set() for i in range(k)}\\n        col_adj = {i+1: set() for i in range(k)}\\n\\n        # build a starting matrix\\n        matrix = [[0 for i in range(k)] for j in range(k)]\\n\\n        # build adjacency lists\\n        for above, below in rowConditions:\\n            row_adj[above].add(below)\\n        for left, right in colConditions:\\n            col_adj[left].add(right)\\n        \\n        visited = {} # false = visited, true = in the path\\n        col_order = []\\n        row_order = []\\n\\n        # dfs function for topological sort\\n        def dfs(curr, adj, arr):\\n            if curr in visited:\\n                return visited[curr]\\n            visited[curr] = True \\n            for neighbor in adj[curr]:\\n                if dfs(neighbor, adj, arr):\\n                    return True \\n            visited[curr] = False\\n            arr.append(curr)\\n            return False\\n        \\n        for curr in row_adj:\\n            if dfs(curr, row_adj, row_order):\\n                return []\\n        row_order.reverse()\\n        # print(row_order)\\n\\n        visited = {} # false = visited, true = in the path\\n        for curr in col_adj:\\n            if dfs(curr, col_adj, col_order):\\n                return []\\n        col_order.reverse()\\n        # print(col_order)\\n\\n        # construct the matrix based on conditions\\n        for idx in range(len(matrix)):\\n            num = row_order[idx]\\n            col_pos = col_order.index(num)\\n            matrix[idx][col_pos] = num\\n        return matrix\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3031636,
                "title": "python-topological-sortt",
                "content": "# Intuition\\nThe question asks for certain ordering of the numbers based on 1) rows and 2) columns. There can be different ways of arranging the numbers but it doesn\\'t matter which one we choose as long as the conditions are met. This sounds like a DAG (directed acyclical graph) and yes we will use topological sort for this question\\n\\n# Approach\\nSimple enough. We just need to sort the rows and columns seperately and combine the two together. Since both sortings use the same function but different variables, we can create a function and pass in parameters to reflect what we are sorting. Note that we need to be able to detect cycles in the graph and here I use visited to indicate two scenarios: 1) a node has been visited and we will not go back to it, since all its children are visited. 2) we mark that a node is in the path. Case 2 is useful because if we encounter the same node that are in the path the second time, we know that a cycle is detected, and I use dfs to return True for that matter.\\n\\n# Complexity\\n- Time complexity:\\n$$O(max(m, n))$$ for building the graph and $$O(k)$$ for traversing the graph, $$O(k^2)$$ to construct the final matrix based on orderings. Time complexity will depend on which one\\'s greater.\\n- Space complexity:\\n$$O(k^2)$$ for constructing the matrix. $$O(max(m, n))$$ for the adjacency lists.\\n\\n# Code\\n```\\nclass Solution(object):\\n    def buildMatrix(self, k, rowConditions, colConditions):\\n        \"\"\"\\n        :type k: int\\n        :type rowConditions: List[List[int]]\\n        :type colConditions: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        # based on row conditions, topologically sort the indices so we know which number occupies which row\\n        # and then arrange the row based on columns, after topologically sorting the columns\\n        row_adj = {i+1: set() for i in range(k)}\\n        col_adj = {i+1: set() for i in range(k)}\\n\\n        # build a starting matrix\\n        matrix = [[0 for i in range(k)] for j in range(k)]\\n\\n        # build adjacency lists\\n        for above, below in rowConditions:\\n            row_adj[above].add(below)\\n        for left, right in colConditions:\\n            col_adj[left].add(right)\\n        \\n        visited = {} # false = visited, true = in the path\\n        col_order = []\\n        row_order = []\\n\\n        # dfs function for topological sort\\n        def dfs(curr, adj, arr):\\n            if curr in visited:\\n                return visited[curr]\\n            visited[curr] = True \\n            for neighbor in adj[curr]:\\n                if dfs(neighbor, adj, arr):\\n                    return True \\n            visited[curr] = False\\n            arr.append(curr)\\n            return False\\n        \\n        for curr in row_adj:\\n            if dfs(curr, row_adj, row_order):\\n                return []\\n        row_order.reverse()\\n        # print(row_order)\\n\\n        visited = {} # false = visited, true = in the path\\n        for curr in col_adj:\\n            if dfs(curr, col_adj, col_order):\\n                return []\\n        col_order.reverse()\\n        # print(col_order)\\n\\n        # construct the matrix based on conditions\\n        for idx in range(len(matrix)):\\n            num = row_order[idx]\\n            col_pos = col_order.index(num)\\n            matrix[idx][col_pos] = num\\n        return matrix\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution(object):\\n    def buildMatrix(self, k, rowConditions, colConditions):\\n        \"\"\"\\n        :type k: int\\n        :type rowConditions: List[List[int]]\\n        :type colConditions: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        # based on row conditions, topologically sort the indices so we know which number occupies which row\\n        # and then arrange the row based on columns, after topologically sorting the columns\\n        row_adj = {i+1: set() for i in range(k)}\\n        col_adj = {i+1: set() for i in range(k)}\\n\\n        # build a starting matrix\\n        matrix = [[0 for i in range(k)] for j in range(k)]\\n\\n        # build adjacency lists\\n        for above, below in rowConditions:\\n            row_adj[above].add(below)\\n        for left, right in colConditions:\\n            col_adj[left].add(right)\\n        \\n        visited = {} # false = visited, true = in the path\\n        col_order = []\\n        row_order = []\\n\\n        # dfs function for topological sort\\n        def dfs(curr, adj, arr):\\n            if curr in visited:\\n                return visited[curr]\\n            visited[curr] = True \\n            for neighbor in adj[curr]:\\n                if dfs(neighbor, adj, arr):\\n                    return True \\n            visited[curr] = False\\n            arr.append(curr)\\n            return False\\n        \\n        for curr in row_adj:\\n            if dfs(curr, row_adj, row_order):\\n                return []\\n        row_order.reverse()\\n        # print(row_order)\\n\\n        visited = {} # false = visited, true = in the path\\n        for curr in col_adj:\\n            if dfs(curr, col_adj, col_order):\\n                return []\\n        col_order.reverse()\\n        # print(col_order)\\n\\n        # construct the matrix based on conditions\\n        for idx in range(len(matrix)):\\n            num = row_order[idx]\\n            col_pos = col_order.index(num)\\n            matrix[idx][col_pos] = num\\n        return matrix\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3031635,
                "title": "python-topological-sortt",
                "content": "# Intuition\\nThe question asks for certain ordering of the numbers based on 1) rows and 2) columns. There can be different ways of arranging the numbers but it doesn\\'t matter which one we choose as long as the conditions are met. This sounds like a DAG (directed acyclical graph) and yes we will use topological sort for this question\\n\\n# Approach\\nSimple enough. We just need to sort the rows and columns seperately and combine the two together. Since both sortings use the same function but different variables, we can create a function and pass in parameters to reflect what we are sorting. Note that we need to be able to detect cycles in the graph and here I use visited to indicate two scenarios: 1) a node has been visited and we will not go back to it, since all its children are visited. 2) we mark that a node is in the path. Case 2 is useful because if we encounter the same node that are in the path the second time, we know that a cycle is detected, and I use dfs to return True for that matter.\\n\\n# Complexity\\n- Time complexity:\\n$$O(max(m, n))$$ for building the graph and $$O(k)$$ for traversing the graph, $$O(k^2)$$ to construct the final matrix based on orderings. Time complexity will depend on which one\\'s greater.\\n- Space complexity:\\n$$O(k^2)$$ for constructing the matrix. $$O(max(m, n))$$ for the adjacency lists.\\n\\n# Code\\n```\\nclass Solution(object):\\n    def buildMatrix(self, k, rowConditions, colConditions):\\n        \"\"\"\\n        :type k: int\\n        :type rowConditions: List[List[int]]\\n        :type colConditions: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        # based on row conditions, topologically sort the indices so we know which number occupies which row\\n        # and then arrange the row based on columns, after topologically sorting the columns\\n        row_adj = {i+1: set() for i in range(k)}\\n        col_adj = {i+1: set() for i in range(k)}\\n\\n        # build a starting matrix\\n        matrix = [[0 for i in range(k)] for j in range(k)]\\n\\n        # build adjacency lists\\n        for above, below in rowConditions:\\n            row_adj[above].add(below)\\n        for left, right in colConditions:\\n            col_adj[left].add(right)\\n        \\n        visited = {} # false = visited, true = in the path\\n        col_order = []\\n        row_order = []\\n\\n        # dfs function for topological sort\\n        def dfs(curr, adj, arr):\\n            if curr in visited:\\n                return visited[curr]\\n            visited[curr] = True \\n            for neighbor in adj[curr]:\\n                if dfs(neighbor, adj, arr):\\n                    return True \\n            visited[curr] = False\\n            arr.append(curr)\\n            return False\\n        \\n        for curr in row_adj:\\n            if dfs(curr, row_adj, row_order):\\n                return []\\n        row_order.reverse()\\n        # print(row_order)\\n\\n        visited = {} # false = visited, true = in the path\\n        for curr in col_adj:\\n            if dfs(curr, col_adj, col_order):\\n                return []\\n        col_order.reverse()\\n        # print(col_order)\\n\\n        # construct the matrix based on conditions\\n        for idx in range(len(matrix)):\\n            num = row_order[idx]\\n            col_pos = col_order.index(num)\\n            matrix[idx][col_pos] = num\\n        return matrix\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution(object):\\n    def buildMatrix(self, k, rowConditions, colConditions):\\n        \"\"\"\\n        :type k: int\\n        :type rowConditions: List[List[int]]\\n        :type colConditions: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        # based on row conditions, topologically sort the indices so we know which number occupies which row\\n        # and then arrange the row based on columns, after topologically sorting the columns\\n        row_adj = {i+1: set() for i in range(k)}\\n        col_adj = {i+1: set() for i in range(k)}\\n\\n        # build a starting matrix\\n        matrix = [[0 for i in range(k)] for j in range(k)]\\n\\n        # build adjacency lists\\n        for above, below in rowConditions:\\n            row_adj[above].add(below)\\n        for left, right in colConditions:\\n            col_adj[left].add(right)\\n        \\n        visited = {} # false = visited, true = in the path\\n        col_order = []\\n        row_order = []\\n\\n        # dfs function for topological sort\\n        def dfs(curr, adj, arr):\\n            if curr in visited:\\n                return visited[curr]\\n            visited[curr] = True \\n            for neighbor in adj[curr]:\\n                if dfs(neighbor, adj, arr):\\n                    return True \\n            visited[curr] = False\\n            arr.append(curr)\\n            return False\\n        \\n        for curr in row_adj:\\n            if dfs(curr, row_adj, row_order):\\n                return []\\n        row_order.reverse()\\n        # print(row_order)\\n\\n        visited = {} # false = visited, true = in the path\\n        for curr in col_adj:\\n            if dfs(curr, col_adj, col_order):\\n                return []\\n        col_order.reverse()\\n        # print(col_order)\\n\\n        # construct the matrix based on conditions\\n        for idx in range(len(matrix)):\\n            num = row_order[idx]\\n            col_pos = col_order.index(num)\\n            matrix[idx][col_pos] = num\\n        return matrix\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2992693,
                "title": "python-simple-topological-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def buildMatrix(self, k, rowConditions, colConditions):\\n        mat = [[0]*k for _ in range(k)]\\n\\n        dict1, indegree1, res1 = collections.defaultdict(list), [0]*k, []\\n        dict2, indegree2, res2 = collections.defaultdict(list), [0]*k, []\\n\\n        for i,j in rowConditions:\\n            dict1[i-1].append(j-1)\\n            indegree1[j-1] += 1\\n\\n\\n        for i,j in colConditions:\\n            dict2[i-1].append(j-1)\\n            indegree2[j-1] += 1\\n\\n        stack1 = [i for i in range(k) if indegree1[i] == 0]\\n\\n        while stack1:\\n            val1 = stack1.pop(0)\\n\\n            for neighbor in dict1[val1]:\\n                indegree1[neighbor] -= 1\\n                if indegree1[neighbor] == 0:\\n                    stack1.append(neighbor)\\n\\n            res1 += [val1+1]\\n        \\n        stack2 = [i for i in range(k) if indegree2[i] == 0]\\n\\n        while stack2:\\n            val2 = stack2.pop(0)\\n            \\n            for neighbor in dict2[val2]:\\n                indegree2[neighbor] -= 1\\n                if indegree2[neighbor] == 0:\\n                    stack2.append(neighbor)\\n\\n            res2 += [val2+1]\\n\\n\\n        ans1 = res1 if len(res1) == k else []\\n        ans2 = res2 if len(res2) == k else []\\n\\n        if not ans1 or not ans2:\\n            return []\\n\\n        for i in range(k):\\n            row = res1.index(i+1)\\n            col = res2.index(i+1)\\n            mat[row][col] = i+1\\n\\n        return mat\\n\\n\\n\\n        \\n\\n\\n\\n\\n\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def buildMatrix(self, k, rowConditions, colConditions):\\n        mat = [[0]*k for _ in range(k)]\\n\\n        dict1, indegree1, res1 = collections.defaultdict(list), [0]*k, []\\n        dict2, indegree2, res2 = collections.defaultdict(list), [0]*k, []\\n\\n        for i,j in rowConditions:\\n            dict1[i-1].append(j-1)\\n            indegree1[j-1] += 1\\n\\n\\n        for i,j in colConditions:\\n            dict2[i-1].append(j-1)\\n            indegree2[j-1] += 1\\n\\n        stack1 = [i for i in range(k) if indegree1[i] == 0]\\n\\n        while stack1:\\n            val1 = stack1.pop(0)\\n\\n            for neighbor in dict1[val1]:\\n                indegree1[neighbor] -= 1\\n                if indegree1[neighbor] == 0:\\n                    stack1.append(neighbor)\\n\\n            res1 += [val1+1]\\n        \\n        stack2 = [i for i in range(k) if indegree2[i] == 0]\\n\\n        while stack2:\\n            val2 = stack2.pop(0)\\n            \\n            for neighbor in dict2[val2]:\\n                indegree2[neighbor] -= 1\\n                if indegree2[neighbor] == 0:\\n                    stack2.append(neighbor)\\n\\n            res2 += [val2+1]\\n\\n\\n        ans1 = res1 if len(res1) == k else []\\n        ans2 = res2 if len(res2) == k else []\\n\\n        if not ans1 or not ans2:\\n            return []\\n\\n        for i in range(k):\\n            row = res1.index(i+1)\\n            col = res2.index(i+1)\\n            mat[row][col] = i+1\\n\\n        return mat\\n\\n\\n\\n        \\n\\n\\n\\n\\n\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2985866,
                "title": "java-toposort-solution-with-detailed-explanation",
                "content": "# Intuition\\nThis solution is attempting to build a matrix where the rows and columns are sorted according to certain conditions specified in the input.\\n\\nTo do this, it first generates a topological sort of the rows and columns. A topological sort is a linear ordering of the elements in a directed acyclic graph (DAG) such that for every edge u -> v, vertex u comes before vertex v in the ordering.\\n\\nThe topological sort is generated using a modified breadth-first search (BFS) algorithm. The BFS algorithm works by starting at a particular vertex and exploring all of its neighbors before moving on to the next level of vertices. In this case, the algorithm begins by adding all vertices with an in-degree of 0 (i.e., no incoming edges) to a queue. It then repeatedly removes the front element from the queue, decreases the in-degree of its neighbors, and adds any neighbors with an in-degree of 0 to the queue. This process is repeated until the queue is empty.\\n\\nOnce the topological sort has been generated, the solution uses it to build the matrix by setting each element in the ith row and jth column to be the value of the ith element in the row sort and the jth element in the column sort, respectively.\\n\\nThe overall idea is to use the topological sort to create an ordering of the rows and columns that satisfies the conditions specified in the input.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this solution is `O(n + m)` where n is the number of elements in the input matrix and m is the number of edges in the graph. This is because the topological sort is done using a modified breadth-first search (BFS) algorithm, which has a time complexity of `O(n + m)` for a graph with n nodes and m edges.\\n\\n- Space complexity:\\nThe space complexity of this solution is `O(k)`, because we create a graph, an in-degree array, and a queue, all of which have a size proportional to the number of elements in the matrix.\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] buildMatrix(int k, int[][] rowConditions, int[][] colConditions) {\\n        List<Integer> rowSort = generatTopologicalSort(rowConditions, k);\\n        List<Integer> colSort = generatTopologicalSort(colConditions, k);\\n        //If topological sort produce less than k result than there must be cycle in the graph, so we return blank\\n        if (rowSort.size() < k || colSort.size() < k) return new int[0][0];\\n\\n        int[][] res = new int[k][k];\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int i = 0; i < colSort.size(); i++){\\n            map.put(colSort.get(i), i);\\n        }\\n\\n        for(int i = 0; i < rowSort.size(); i++){\\n            res[i][map.get(rowSort.get(i))] = rowSort.get(i);\\n        }\\n\\n        return res;\\n    }\\n    private List<Integer> generatTopologicalSort(int[][] matrix, int k) {\\n        //In-degree array\\n        int[] in = new int[k];\\n        //Make graph from the matrix\\n        List<List<Integer>> graph = new ArrayList<>();\\n        for (int i = 0; i < k; i++)\\n            graph.add(new ArrayList<>());\\n\\n        for (int[] link : matrix) {\\n            //Create edge from link[0] to link[1]\\n            graph.get(link[0] - 1).add(link[1] - 1);\\n            //Increase in degree of vertex link[1]\\n            in[link[1] - 1]++;\\n        }\\n        //Add element in queue whose indegree is 0\\n        Queue<Integer> queue = new LinkedList<>();\\n        for (int i = 0; i < k; i++) {\\n            if (in[i] == 0)\\n                queue.offer(i);\\n        }\\n\\n        List<Integer> sortedList = new ArrayList<>();\\n        while (!queue.isEmpty()) {\\n            Integer topElement = queue.poll();\\n            sortedList.add(topElement + 1);\\n            //Decrease in-degree of neighbours\\n            List<Integer> neighbours = graph.get(topElement);\\n            for (int i = 0; i < neighbours.size(); i++) {\\n                in[neighbours.get(i)]--;\\n                if (in[neighbours.get(i)] == 0)\\n                    queue.offer(neighbours.get(i));\\n            }\\n        }\\n        return sortedList;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] buildMatrix(int k, int[][] rowConditions, int[][] colConditions) {\\n        List<Integer> rowSort = generatTopologicalSort(rowConditions, k);\\n        List<Integer> colSort = generatTopologicalSort(colConditions, k);\\n        //If topological sort produce less than k result than there must be cycle in the graph, so we return blank\\n        if (rowSort.size() < k || colSort.size() < k) return new int[0][0];\\n\\n        int[][] res = new int[k][k];\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int i = 0; i < colSort.size(); i++){\\n            map.put(colSort.get(i), i);\\n        }\\n\\n        for(int i = 0; i < rowSort.size(); i++){\\n            res[i][map.get(rowSort.get(i))] = rowSort.get(i);\\n        }\\n\\n        return res;\\n    }\\n    private List<Integer> generatTopologicalSort(int[][] matrix, int k) {\\n        //In-degree array\\n        int[] in = new int[k];\\n        //Make graph from the matrix\\n        List<List<Integer>> graph = new ArrayList<>();\\n        for (int i = 0; i < k; i++)\\n            graph.add(new ArrayList<>());\\n\\n        for (int[] link : matrix) {\\n            //Create edge from link[0] to link[1]\\n            graph.get(link[0] - 1).add(link[1] - 1);\\n            //Increase in degree of vertex link[1]\\n            in[link[1] - 1]++;\\n        }\\n        //Add element in queue whose indegree is 0\\n        Queue<Integer> queue = new LinkedList<>();\\n        for (int i = 0; i < k; i++) {\\n            if (in[i] == 0)\\n                queue.offer(i);\\n        }\\n\\n        List<Integer> sortedList = new ArrayList<>();\\n        while (!queue.isEmpty()) {\\n            Integer topElement = queue.poll();\\n            sortedList.add(topElement + 1);\\n            //Decrease in-degree of neighbours\\n            List<Integer> neighbours = graph.get(topElement);\\n            for (int i = 0; i < neighbours.size(); i++) {\\n                in[neighbours.get(i)]--;\\n                if (in[neighbours.get(i)] == 0)\\n                    queue.offer(neighbours.get(i));\\n            }\\n        }\\n        return sortedList;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2941506,
                "title": "c-with-very-easy-explanation-tree-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen I working on this question, I dont know about topological sort. But through observation, there will be two cases.\\n1. A matrix could be from.\\n2. A matrix could not be from.\\n\\nLets talk about the second case. It is obvious that the conditions will be satisfied when it is transitive (a > b and b > c) -> a > c. Therefore, if a -> b and b -> c and c -> a. The condition will not be formed. We could interpret it as follows. When a circuit is formed, the condition is not formed. As a result, we could check whether there is circuit or not to see whether which cases we are going in. \\n\\nBy building a tree and cutting the tree from the leave nodes, we can easily check whethere there is circle.\\n\\nIf there is no circle, we process to the first case. \\n\\nThe first case is less intuitive, when we building the tree, we take the uppest/ leftest number as leaf node. The method i used here is to use a map to count the parent nodes for each number and a counter the number of child for each node. If the counter == 0, it means it is a leave node. Then, we can just cut the leave and add to our queue and reduce all it parent nodes counter by 1. Until all the node is deleted. We then form the full sort for col/ row.  \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        unordered_map<int, multiset<int>> rowTree;\\n        vector<int> rowImmediateChild(k + 1, 0);\\n        unordered_map<int, multiset<int>> colTree;\\n        vector<int> colImmediateChild(k + 1, 0);\\n\\n        // Initiate the Tree for row conditions\\n        for (auto &row: rowConditions){\\n            rowImmediateChild[row[1]]++;\\n            rowTree[row[0]].insert(row[1]);\\n        }\\n        vector<int> rowAns;\\n        queue<int> tmp;\\n        for (int i = 1; i <= k; ++i){\\n            if (rowImmediateChild[i] == 0) {\\n                rowImmediateChild[i] = -1;\\n                tmp.push(i);\\n            }\\n        }\\n        while (!tmp.empty()){\\n            int current = tmp.front();\\n            cout << current << ends;\\n            tmp.pop();\\n            rowAns.push_back(current);\\n            for (auto &prt: rowTree[current]) {\\n                rowImmediateChild[prt]--;\\n                if (rowImmediateChild[prt] == 0){\\n                    rowImmediateChild[prt] = -1;\\n                    tmp.push(prt);\\n                }\\n            }\\n        }\\n        // If circle exists, condtion broke\\n        if (rowAns.size() != k) return {};\\n\\n        // Initiaite the Tree for col condtions\\n        for (auto &col: colConditions){\\n            colImmediateChild[col[1]]++;\\n            colTree[col[0]].insert(col[1]);\\n        }\\n        vector<int> colAns;\\n        for (int i = 1; i <= k; ++i){\\n            if (colImmediateChild[i] == 0) {\\n                colImmediateChild[i] = -1;\\n                tmp.push(i);\\n            }\\n        }\\n        while (!tmp.empty()){\\n            int current = tmp.front();\\n            tmp.pop();\\n            colAns.push_back(current);\\n            for (auto &prt: colTree[current]) {\\n                colImmediateChild[prt]--;\\n                if (colImmediateChild[prt] == 0){\\n                    colImmediateChild[prt] = -1;\\n                    tmp.push(prt);\\n                }\\n            }\\n        }\\n        // If circle exists, condtion broke\\n        if (colAns.size() != k) return {};\\n\\n        // Form matrix\\n        vector<vector<int>> ans(k, vector<int>(k));\\n        for (int i = 0; i < k; ++i){\\n            int key(rowAns[i]), flag(0);\\n            while (colAns[flag] != key) flag++;\\n            ans[i][flag] = key;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        unordered_map<int, multiset<int>> rowTree;\\n        vector<int> rowImmediateChild(k + 1, 0);\\n        unordered_map<int, multiset<int>> colTree;\\n        vector<int> colImmediateChild(k + 1, 0);\\n\\n        // Initiate the Tree for row conditions\\n        for (auto &row: rowConditions){\\n            rowImmediateChild[row[1]]++;\\n            rowTree[row[0]].insert(row[1]);\\n        }\\n        vector<int> rowAns;\\n        queue<int> tmp;\\n        for (int i = 1; i <= k; ++i){\\n            if (rowImmediateChild[i] == 0) {\\n                rowImmediateChild[i] = -1;\\n                tmp.push(i);\\n            }\\n        }\\n        while (!tmp.empty()){\\n            int current = tmp.front();\\n            cout << current << ends;\\n            tmp.pop();\\n            rowAns.push_back(current);\\n            for (auto &prt: rowTree[current]) {\\n                rowImmediateChild[prt]--;\\n                if (rowImmediateChild[prt] == 0){\\n                    rowImmediateChild[prt] = -1;\\n                    tmp.push(prt);\\n                }\\n            }\\n        }\\n        // If circle exists, condtion broke\\n        if (rowAns.size() != k) return {};\\n\\n        // Initiaite the Tree for col condtions\\n        for (auto &col: colConditions){\\n            colImmediateChild[col[1]]++;\\n            colTree[col[0]].insert(col[1]);\\n        }\\n        vector<int> colAns;\\n        for (int i = 1; i <= k; ++i){\\n            if (colImmediateChild[i] == 0) {\\n                colImmediateChild[i] = -1;\\n                tmp.push(i);\\n            }\\n        }\\n        while (!tmp.empty()){\\n            int current = tmp.front();\\n            tmp.pop();\\n            colAns.push_back(current);\\n            for (auto &prt: colTree[current]) {\\n                colImmediateChild[prt]--;\\n                if (colImmediateChild[prt] == 0){\\n                    colImmediateChild[prt] = -1;\\n                    tmp.push(prt);\\n                }\\n            }\\n        }\\n        // If circle exists, condtion broke\\n        if (colAns.size() != k) return {};\\n\\n        // Form matrix\\n        vector<vector<int>> ans(k, vector<int>(k));\\n        for (int i = 0; i < k; ++i){\\n            int key(rowAns[i]), flag(0);\\n            while (colAns[flag] != key) flag++;\\n            ans[i][flag] = key;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2921940,
                "title": "topo-sort-simple-approch-python",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n  rowFill() =>\\n- make graph on the basis of rowConditions\\n- Find Indegree\\n- Whose indegree is 0 we can put that 0th row (if there is multiple then put 1st node at 0th and 2nd at 1st and so on..)\\n- rowMap is used for row number for every node\\n- if there is a cycle then row number never reached to end\\n\\ncolFill()=>\\n- Exactly do the same thing as rowFill() does\\n- colMap is used for col number for every node\\n- if there is a cycle then col number never reached to end\\n\\nFinally we go rowMap, colMap and fill up the matrix\\n- If any of the node in rowMap already filled in matrix or not present in colMap then return []\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:\\n\\n        matrix = [[0 for j in range(k)] for i in range(k)]\\n        rowMap = {}\\n        colMap = {}\\n    \\n        def rowFill():\\n            graph = defaultdict(list)\\n            indegree = [0]*k\\n            for u, v in rowConditions:\\n                graph[u-1].append(v-1)\\n                indegree[v-1]+=1\\n\\n            q = deque()\\n            for i in range(k):\\n                if indegree[i] == 0:\\n                    q.append(i)\\n            row = 0\\n            while q:\\n                u = q.popleft()\\n                rowMap[u] = row\\n                for v in graph[u]:\\n                    indegree[v]-=1\\n                    if indegree[v] == 0:\\n                        q.append(v)\\n                \\n                row+=1\\n            #print(\"rowmap : \", rowMap, \" == \", row)\\n            if row<k:\\n                return False\\n            \\n            return True\\n        \\n        def colFill():\\n            graph = defaultdict(list)\\n            indegree = [0]*k\\n            for u, v in colConditions:\\n                graph[u-1].append(v-1)\\n                indegree[v-1]+=1\\n\\n            q = deque()\\n            for i in range(k):\\n                if indegree[i] == 0:\\n                    q.append(i)\\n            \\n            col = 0\\n            while q:\\n                u = q.popleft()\\n                colMap[u] = col\\n                for v in graph[u]:\\n                    indegree[v]-=1\\n                    if indegree[v] == 0:\\n                        q.append(v)\\n                \\n                col+=1\\n            \\n            if col<k:\\n                return False\\n            \\n            return True\\n        \\n        val = rowFill()\\n        if not val: return []\\n        \\n        val = colFill()\\n        if not val: return []\\n\\n        for key in rowMap:\\n            if key not in colMap or (matrix[rowMap[key]][colMap[key]] != 0):\\n                return []\\n            matrix[rowMap[key]][colMap[key]] = key+1\\n        \\n        return matrix\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution:\\n    def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:\\n\\n        matrix = [[0 for j in range(k)] for i in range(k)]\\n        rowMap = {}\\n        colMap = {}\\n    \\n        def rowFill():\\n            graph = defaultdict(list)\\n            indegree = [0]*k\\n            for u, v in rowConditions:\\n                graph[u-1].append(v-1)\\n                indegree[v-1]+=1\\n\\n            q = deque()\\n            for i in range(k):\\n                if indegree[i] == 0:\\n                    q.append(i)\\n            row = 0\\n            while q:\\n                u = q.popleft()\\n                rowMap[u] = row\\n                for v in graph[u]:\\n                    indegree[v]-=1\\n                    if indegree[v] == 0:\\n                        q.append(v)\\n                \\n                row+=1\\n            #print(\"rowmap : \", rowMap, \" == \", row)\\n            if row<k:\\n                return False\\n            \\n            return True\\n        \\n        def colFill():\\n            graph = defaultdict(list)\\n            indegree = [0]*k\\n            for u, v in colConditions:\\n                graph[u-1].append(v-1)\\n                indegree[v-1]+=1\\n\\n            q = deque()\\n            for i in range(k):\\n                if indegree[i] == 0:\\n                    q.append(i)\\n            \\n            col = 0\\n            while q:\\n                u = q.popleft()\\n                colMap[u] = col\\n                for v in graph[u]:\\n                    indegree[v]-=1\\n                    if indegree[v] == 0:\\n                        q.append(v)\\n                \\n                col+=1\\n            \\n            if col<k:\\n                return False\\n            \\n            return True\\n        \\n        val = rowFill()\\n        if not val: return []\\n        \\n        val = colFill()\\n        if not val: return []\\n\\n        for key in rowMap:\\n            if key not in colMap or (matrix[rowMap[key]][colMap[key]] != 0):\\n                return []\\n            matrix[rowMap[key]][colMap[key]] = key+1\\n        \\n        return matrix\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2895750,
                "title": "java-solution",
                "content": "# Intuition\\ntopo sort\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\ngraph indegree\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\nn*n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- n*n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] topo(int[][] edges, int indegree[]) {\\n        int[] ans = new int[indegree.length];\\n        boolean vis[] = new boolean[indegree.length];\\n        for(int i=0;i<indegree.length;i++) {\\n            int node = -1;\\n            for(int j=0;j<indegree.length;j++) {\\n                if(indegree[j] == 0 && !vis[j]) {\\n                    node = j;\\n                    break;\\n                }\\n            }\\n            if(node == -1) {\\n                return null;\\n            }\\n            ans[i] = node;\\n            vis[node] = true;\\n            for(int[] e:edges) {\\n                if( e[0]-1 == node ) {\\n                    indegree[e[1]-1]-=1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    public int[][] buildMatrix(int k, int[][] rowConditions, int[][] colConditions) {\\n        int ans[][] = new int[k][k];\\n        int ldegree[] = new int[k];\\n        int ddegree[] = new int[k];\\n        int rdegree[] = new int[k];\\n        int udegree[] = new int[k];\\n        for(int[] r:rowConditions) {\\n            udegree[r[0]-1]+=1;\\n            ddegree[r[1]-1]+=1;\\n        }\\n        for(int[] r:colConditions) {\\n            ldegree[r[0]-1]+=1;\\n            rdegree[r[1]-1]+=1;\\n        }\\n        int c[] = topo(colConditions,rdegree);\\n        int r[] = topo(rowConditions,ddegree);\\n        if( r == null || c == null ) {\\n            return new int[0][0];\\n        }\\n        for(int i=0;i<k;i++) {\\n            int row = -1;\\n            int col = -1;\\n            for(int j=0;j<k;j++) {\\n                if(r[j] == i) {\\n                    row = j;\\n                }\\n                if(c[j] == i) {\\n                    col = j;\\n                }\\n            }\\n            ans[row][col] = i+1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] topo(int[][] edges, int indegree[]) {\\n        int[] ans = new int[indegree.length];\\n        boolean vis[] = new boolean[indegree.length];\\n        for(int i=0;i<indegree.length;i++) {\\n            int node = -1;\\n            for(int j=0;j<indegree.length;j++) {\\n                if(indegree[j] == 0 && !vis[j]) {\\n                    node = j;\\n                    break;\\n                }\\n            }\\n            if(node == -1) {\\n                return null;\\n            }\\n            ans[i] = node;\\n            vis[node] = true;\\n            for(int[] e:edges) {\\n                if( e[0]-1 == node ) {\\n                    indegree[e[1]-1]-=1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    public int[][] buildMatrix(int k, int[][] rowConditions, int[][] colConditions) {\\n        int ans[][] = new int[k][k];\\n        int ldegree[] = new int[k];\\n        int ddegree[] = new int[k];\\n        int rdegree[] = new int[k];\\n        int udegree[] = new int[k];\\n        for(int[] r:rowConditions) {\\n            udegree[r[0]-1]+=1;\\n            ddegree[r[1]-1]+=1;\\n        }\\n        for(int[] r:colConditions) {\\n            ldegree[r[0]-1]+=1;\\n            rdegree[r[1]-1]+=1;\\n        }\\n        int c[] = topo(colConditions,rdegree);\\n        int r[] = topo(rowConditions,ddegree);\\n        if( r == null || c == null ) {\\n            return new int[0][0];\\n        }\\n        for(int i=0;i<k;i++) {\\n            int row = -1;\\n            int col = -1;\\n            for(int j=0;j<k;j++) {\\n                if(r[j] == i) {\\n                    row = j;\\n                }\\n                if(c[j] == i) {\\n                    col = j;\\n                }\\n            }\\n            ans[row][col] = i+1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2878382,
                "title": "simple-python-topological-sort-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe use topolgical order to find possible row order and column order and build matrix based on it\\n\\nTopological sort is performed using Indegree method\\n\\n\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nclass Solution(object):\\n    def buildMatrix(self, k, rowConditions, colConditions):\\n        \"\"\"\\n        :type k: int\\n        :type rowConditions: List[List[int]]\\n        :type colConditions: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n\\n        #Topological Sort\\n        def findOrder(conditions):\\n\\n            indeg = defaultdict(lambda:0)\\n            adj = defaultdict(set)\\n            conditions = set([tuple(edge) for edge in conditions])  \\n            \\n            for a,b in conditions:\\n                adj[a].add(b)\\n                indeg[b] = indeg[b] + 1\\n\\n            zero = list(set(range(1,k+1)) - set(indeg.keys()))\\n            order = []\\n\\n            while zero:\\n                cur = zero.pop(0)\\n                order.append(cur)\\n\\n                for b in adj[cur]:\\n                    indeg[b] = indeg[b] - 1\\n\\n                    if indeg[b] == 0:\\n                        zero.append(b)\\n\\n            if len(order) != k:\\n                return []\\n\\n            return order\\n\\n        rowOrder = findOrder(rowConditions)\\n        colOrder = findOrder(colConditions)\\n\\n        if not rowOrder or  not colOrder:\\n            return []\\n\\n        grid = [[0]*k  for _ in range(k)]\\n\\n        for value in range(1,k+1):\\n            grid[rowOrder.index(value)][colOrder.index(value)] = value\\n\\n        return grid\\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution(object):\\n    def buildMatrix(self, k, rowConditions, colConditions):\\n        \"\"\"\\n        :type k: int\\n        :type rowConditions: List[List[int]]\\n        :type colConditions: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n\\n        #Topological Sort\\n        def findOrder(conditions):\\n\\n            indeg = defaultdict(lambda:0)\\n            adj = defaultdict(set)\\n            conditions = set([tuple(edge) for edge in conditions])  \\n            \\n            for a,b in conditions:\\n                adj[a].add(b)\\n                indeg[b] = indeg[b] + 1\\n\\n            zero = list(set(range(1,k+1)) - set(indeg.keys()))\\n            order = []\\n\\n            while zero:\\n                cur = zero.pop(0)\\n                order.append(cur)\\n\\n                for b in adj[cur]:\\n                    indeg[b] = indeg[b] - 1\\n\\n                    if indeg[b] == 0:\\n                        zero.append(b)\\n\\n            if len(order) != k:\\n                return []\\n\\n            return order\\n\\n        rowOrder = findOrder(rowConditions)\\n        colOrder = findOrder(colConditions)\\n\\n        if not rowOrder or  not colOrder:\\n            return []\\n\\n        grid = [[0]*k  for _ in range(k)]\\n\\n        for value in range(1,k+1):\\n            grid[rowOrder.index(value)][colOrder.index(value)] = value\\n\\n        return grid\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2825669,
                "title": "easy-to-understand-documented-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    // Calculate the positon of a given row/colum conditons in the topological sort\\n    // We start distributing tokens as and when element\\'s indegree goes 0\\n    bool getPosition(int k, vector<vector<int>>& conditions, vector<int> &indexes) {\\n        vector<vector<int>> adj(k);\\n        vector<int> outDegree(k,0);\\n        // populate the adjancency list and outDegree of the nodes\\n        for (auto &d : conditions) {\\n            adj[d[0]-1].push_back(d[1]-1);\\n            outDegree[d[1]-1]++;\\n        }\\n        queue<int> q;\\n        int token = 0;\\n        // collect list of nodes with 0 indgree as they can be assigned first\\n        for (int i = 0; i < k; i++) {\\n            if (outDegree[i] == 0) {\\n                indexes[i] = token++;\\n                q.push(i);\\n            }\\n        }\\n        \\n        while(!q.empty()) {\\n            int sz = q.size();\\n            for (int i = 0; i < sz; i++) {\\n                int idx = q.front(); q.pop();\\n                for (auto &n : adj[idx]) {\\n                    outDegree[n]--;\\n                    // check if new indegree going to 0 distribute \\n                    // next available token\\n                    if (outDegree[n] == 0) {\\n                        indexes[n] = token++;\\n                        q.push(n);\\n                    }\\n                }\\n            }\\n        }\\n        //if all tokens were distributed then return true\\n        // else false indicating there is a cycle\\n        return (token == k);\\n    }\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        vector<int> rows(k,0);\\n        vector<int> cols(k,0);\\n        vector<vector<int>> result;\\n        // get row values from the row Adjanceny topological sort\\n        if (!getPosition(k,rowConditions,rows)) {\\n            return result;\\n        }\\n        \\n        // get row values from the column Adjanceny topological sort\\n        if (!getPosition(k,colConditions,cols)) {\\n            return result;\\n        }\\n        \\n        // populate the result after all tokens are collected for row and column\\n        result = vector<vector<int>>(k,vector<int>(k,0));\\n        for (int i = 0; i < k; i++) {\\n            result[rows[i]][cols[i]] = i+1;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // Calculate the positon of a given row/colum conditons in the topological sort\\n    // We start distributing tokens as and when element\\'s indegree goes 0\\n    bool getPosition(int k, vector<vector<int>>& conditions, vector<int> &indexes) {\\n        vector<vector<int>> adj(k);\\n        vector<int> outDegree(k,0);\\n        // populate the adjancency list and outDegree of the nodes\\n        for (auto &d : conditions) {\\n            adj[d[0]-1].push_back(d[1]-1);\\n            outDegree[d[1]-1]++;\\n        }\\n        queue<int> q;\\n        int token = 0;\\n        // collect list of nodes with 0 indgree as they can be assigned first\\n        for (int i = 0; i < k; i++) {\\n            if (outDegree[i] == 0) {\\n                indexes[i] = token++;\\n                q.push(i);\\n            }\\n        }\\n        \\n        while(!q.empty()) {\\n            int sz = q.size();\\n            for (int i = 0; i < sz; i++) {\\n                int idx = q.front(); q.pop();\\n                for (auto &n : adj[idx]) {\\n                    outDegree[n]--;\\n                    // check if new indegree going to 0 distribute \\n                    // next available token\\n                    if (outDegree[n] == 0) {\\n                        indexes[n] = token++;\\n                        q.push(n);\\n                    }\\n                }\\n            }\\n        }\\n        //if all tokens were distributed then return true\\n        // else false indicating there is a cycle\\n        return (token == k);\\n    }\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        vector<int> rows(k,0);\\n        vector<int> cols(k,0);\\n        vector<vector<int>> result;\\n        // get row values from the row Adjanceny topological sort\\n        if (!getPosition(k,rowConditions,rows)) {\\n            return result;\\n        }\\n        \\n        // get row values from the column Adjanceny topological sort\\n        if (!getPosition(k,colConditions,cols)) {\\n            return result;\\n        }\\n        \\n        // populate the result after all tokens are collected for row and column\\n        result = vector<vector<int>>(k,vector<int>(k,0));\\n        for (int i = 0; i < k; i++) {\\n            result[rows[i]][cols[i]] = i+1;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2805558,
                "title": "java-topological-sort",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[][] buildMatrix(int k, int[][] rowConditions, int[][] colConditions) {\\n        int[] row = topologicalSort(k, rowConditions);\\n        int[] col = topologicalSort(k, colConditions);\\n        if (row.length == 0 || col.length == 0) {\\n            return new int[][] {};\\n        }\\n        \\n        int[][] matrix = new int[k][k];\\n        for (int i = 1; i <= k; i++) {\\n            matrix[row[i]][col[i]] = i;\\n        }\\n\\n        return matrix;\\n    }\\n\\n    private int[] topologicalSort(int k, int[][] conditions) {\\n        int[] position = new int[k + 1];\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        int[] indegrees = new int[k + 1];\\n        for (int[] condition : conditions) {\\n            graph.computeIfAbsent(condition[0], key -> new ArrayList<>()).add(condition[1]);\\n            indegrees[condition[1]]++;\\n        }\\n        Queue<Integer> queue = new LinkedList<>();\\n        for (int i = 1; i < indegrees.length; i++) {\\n            if (indegrees[i] == 0) {\\n                queue.offer(i);\\n            }\\n        }\\n        int p = 0;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            Set<Integer> set = new HashSet<>();\\n            for (int i = 0; i < size; i++) {\\n                int node = queue.poll();\\n                position[node] = p++;\\n                k--;\\n                set.add(node);\\n                for (Integer child : graph.getOrDefault(node, new ArrayList<>())) {\\n                    indegrees[child]--;\\n                    if (indegrees[child] == 0) {\\n                        queue.offer(child);\\n                    }\\n                }\\n            }\\n        }\\n        return k == 0 ? position : new int[] {};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] buildMatrix(int k, int[][] rowConditions, int[][] colConditions) {\\n        int[] row = topologicalSort(k, rowConditions);\\n        int[] col = topologicalSort(k, colConditions);\\n        if (row.length == 0 || col.length == 0) {\\n            return new int[][] {};\\n        }\\n        \\n        int[][] matrix = new int[k][k];\\n        for (int i = 1; i <= k; i++) {\\n            matrix[row[i]][col[i]] = i;\\n        }\\n\\n        return matrix;\\n    }\\n\\n    private int[] topologicalSort(int k, int[][] conditions) {\\n        int[] position = new int[k + 1];\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        int[] indegrees = new int[k + 1];\\n        for (int[] condition : conditions) {\\n            graph.computeIfAbsent(condition[0], key -> new ArrayList<>()).add(condition[1]);\\n            indegrees[condition[1]]++;\\n        }\\n        Queue<Integer> queue = new LinkedList<>();\\n        for (int i = 1; i < indegrees.length; i++) {\\n            if (indegrees[i] == 0) {\\n                queue.offer(i);\\n            }\\n        }\\n        int p = 0;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            Set<Integer> set = new HashSet<>();\\n            for (int i = 0; i < size; i++) {\\n                int node = queue.poll();\\n                position[node] = p++;\\n                k--;\\n                set.add(node);\\n                for (Integer child : graph.getOrDefault(node, new ArrayList<>())) {\\n                    indegrees[child]--;\\n                    if (indegrees[child] == 0) {\\n                        queue.offer(child);\\n                    }\\n                }\\n            }\\n        }\\n        return k == 0 ? position : new int[] {};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792381,
                "title": "c-basic-search-idea-accepted",
                "content": "Actually the idea is simple (-_-;) Just be careful of the relations. Which row must be on top of whom, so do columns.\\n\\n```cpp\\ntypedef pair<int, int> p;\\nbool com(p& l, p& r) {\\n    return l.first > r.first;\\n}\\nclass Solution {\\npublic:\\n    int isP[2][404];\\n    int lvl[404];\\n\\n    bool valid(std::map<int, vector<int>>& M, int cur, int b) {\\n        if (cur == b)\\n            return false;\\n        if (lvl[cur])\\n            return true;\\n        lvl[cur] = 1;\\n        if (M.count(cur) == 0)\\n            return true;\\n        for (int par : M[cur]) {\\n            if (!valid(M, par, b))\\n                return false;\\n        }\\n        return true;\\n    }\\n    bool upperExist(std::map<int, vector<int>>& M, int cur, int a) {\\n        if (cur == a)\\n            return true;\\n        if (lvl[cur])\\n            return false;\\n        lvl[cur] = 1;\\n        if (M.count(cur) == 0)\\n            return false;\\n        for (int par : M[cur]) {\\n            if (upperExist(M, par, a))\\n                return true;\\n        }\\n        return false;\\n    }\\n    bool conditionsChecking(std::map<int, vector<int>>& M, vector<vector<int>>& cond, int pidx) {\\n        M.clear();\\n        for (int i = 0; i < 404; i++) {\\n            isP[pidx][i] = 0;\\n        }\\n        for (vector<int> c : cond) {\\n            memset(lvl, 0, sizeof(lvl));\\n            if (valid(M, c[0] ,c[1])) {\\n                memset(lvl, 0, sizeof(lvl));\\n                if (!upperExist(M, c[1], c[0])) {\\n                    if (M.find(c[1]) == M.end()) {\\n                        M[c[1]] = { c[0] };\\n                    }\\n                    else {\\n                        M[c[1]].push_back(c[0]);\\n                    }\\n                }\\n                isP[pidx][c[0]] = 1;\\n            }\\n            else {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    void valueAssignment(vector<int>& v, std::map<int, vector<int>>& M, int& MK, int pidx) {\\n        memset(lvl, 0, sizeof(lvl));\\n        queue<int> Q = {};\\n        int step, qlen;\\n        for (int k = 1; k <= MK; k++) {\\n            if (isP[pidx][k] == 0) {\\n                Q.push(k);\\n                step = 0;\\n                while (!Q.empty()) {\\n                    qlen = Q.size();\\n                    step++;\\n                    for (int i = 0; i < qlen; i++) {\\n                        int curk = Q.front(); Q.pop();\\n                        for (int des : M[curk]) {\\n                            if (step > lvl[des]) {\\n                                lvl[des] = step;\\n                                Q.push(des);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        vector<p> tmp = {};\\n        for (int k = 1; k <= MK; k++) {\\n            tmp.push_back({lvl[k], k});\\n        }\\n        sort(tmp.begin(), tmp.end(), com);\\n        for (auto val : tmp) {\\n            v.push_back(val.second);\\n        }\\n    }\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        std::map<int, vector<int>> MR, MC;\\n        std::vector<int> rr, cc;\\n        if (!conditionsChecking(MR, rowConditions, 0))\\n            return {};\\n        if (!conditionsChecking(MC, colConditions, 1))\\n            return {};\\n        valueAssignment(rr, MR, k, 0);\\n        valueAssignment(cc, MC, k, 1);\\n        for (int i = 0; i < rr.size(); i++) {\\n            isP[0][rr[i]] = i;\\n        }    \\n        for (int i = 0; i < cc.size(); i++) {\\n            isP[1][cc[i]] = i;\\n        }\\n        vector<vector<int>> res(k, vector<int>(k, 0));\\n        for (int ki = 1; ki <= k; ki++){\\n            res[isP[0][ki]][isP[1][ki]] = ki;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n*Side-note : this question looks like the typical \"relationship\" question as seen in most aptitude test (something like \"a like b, b don\\'t like c\", etc.), it just that there are (at most) 10000 such rules (-_-;) for both rows and columns.*\\n\\nSome talented ones out there might have come up with better implementation. Nonetheless, this is my first accepted code and I just post it here as a record of progress. (-_-;)",
                "solutionTags": [],
                "code": "```cpp\\ntypedef pair<int, int> p;\\nbool com(p& l, p& r) {\\n    return l.first > r.first;\\n}\\nclass Solution {\\npublic:\\n    int isP[2][404];\\n    int lvl[404];\\n\\n    bool valid(std::map<int, vector<int>>& M, int cur, int b) {\\n        if (cur == b)\\n            return false;\\n        if (lvl[cur])\\n            return true;\\n        lvl[cur] = 1;\\n        if (M.count(cur) == 0)\\n            return true;\\n        for (int par : M[cur]) {\\n            if (!valid(M, par, b))\\n                return false;\\n        }\\n        return true;\\n    }\\n    bool upperExist(std::map<int, vector<int>>& M, int cur, int a) {\\n        if (cur == a)\\n            return true;\\n        if (lvl[cur])\\n            return false;\\n        lvl[cur] = 1;\\n        if (M.count(cur) == 0)\\n            return false;\\n        for (int par : M[cur]) {\\n            if (upperExist(M, par, a))\\n                return true;\\n        }\\n        return false;\\n    }\\n    bool conditionsChecking(std::map<int, vector<int>>& M, vector<vector<int>>& cond, int pidx) {\\n        M.clear();\\n        for (int i = 0; i < 404; i++) {\\n            isP[pidx][i] = 0;\\n        }\\n        for (vector<int> c : cond) {\\n            memset(lvl, 0, sizeof(lvl));\\n            if (valid(M, c[0] ,c[1])) {\\n                memset(lvl, 0, sizeof(lvl));\\n                if (!upperExist(M, c[1], c[0])) {\\n                    if (M.find(c[1]) == M.end()) {\\n                        M[c[1]] = { c[0] };\\n                    }\\n                    else {\\n                        M[c[1]].push_back(c[0]);\\n                    }\\n                }\\n                isP[pidx][c[0]] = 1;\\n            }\\n            else {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    void valueAssignment(vector<int>& v, std::map<int, vector<int>>& M, int& MK, int pidx) {\\n        memset(lvl, 0, sizeof(lvl));\\n        queue<int> Q = {};\\n        int step, qlen;\\n        for (int k = 1; k <= MK; k++) {\\n            if (isP[pidx][k] == 0) {\\n                Q.push(k);\\n                step = 0;\\n                while (!Q.empty()) {\\n                    qlen = Q.size();\\n                    step++;\\n                    for (int i = 0; i < qlen; i++) {\\n                        int curk = Q.front(); Q.pop();\\n                        for (int des : M[curk]) {\\n                            if (step > lvl[des]) {\\n                                lvl[des] = step;\\n                                Q.push(des);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        vector<p> tmp = {};\\n        for (int k = 1; k <= MK; k++) {\\n            tmp.push_back({lvl[k], k});\\n        }\\n        sort(tmp.begin(), tmp.end(), com);\\n        for (auto val : tmp) {\\n            v.push_back(val.second);\\n        }\\n    }\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        std::map<int, vector<int>> MR, MC;\\n        std::vector<int> rr, cc;\\n        if (!conditionsChecking(MR, rowConditions, 0))\\n            return {};\\n        if (!conditionsChecking(MC, colConditions, 1))\\n            return {};\\n        valueAssignment(rr, MR, k, 0);\\n        valueAssignment(cc, MC, k, 1);\\n        for (int i = 0; i < rr.size(); i++) {\\n            isP[0][rr[i]] = i;\\n        }    \\n        for (int i = 0; i < cc.size(); i++) {\\n            isP[1][cc[i]] = i;\\n        }\\n        vector<vector<int>> res(k, vector<int>(k, 0));\\n        for (int ki = 1; ki <= k; ki++){\\n            res[isP[0][ki]][isP[1][ki]] = ki;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2721001,
                "title": "c-code-for-beginners-reference-for-future-me",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool dfs(vector<bool> &vis, stack<int> &s, int node, vector<int> adj[], vector<bool> &rec){ \\n\\t// MAKES TOPOSORT AND ALSO CHECKS FOR CYCLES\\n\\t    vis[node]=true;\\n        rec[node]=true;\\n\\t    for(auto nei: adj[node]){\\n\\t        if(vis[nei]==false){\\n                if(dfs(vis,s,nei,adj,rec)==true){\\n                    return true;\\n                }\\n\\t        }\\n            else if(rec[nei]==true){\\n                return true;\\n            }\\n\\t    }\\n\\t    s.push(node);\\n        rec[node]=false;\\n        return false;\\n\\t}\\n\\t\\n\\tvector<int> topoSort(int V, vector<int> adj[]) {\\n        stack<int> s;\\n        vector<bool> vis(V+1,false);\\n        vector<bool> rec(V+1,false);\\n\\t    for(int v=1;v<=V;v++){\\n            if(vis[v]==false && dfs(vis,s,v,adj,rec)==true){\\n                return {};\\n\\t        }\\n\\t    }\\n        vector<int> tSort;\\n        while(!s.empty()){\\n            tSort.push_back(s.top());\\n            s.pop();\\n        }\\n        return tSort;\\n\\t}\\n    \\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        vector<int> adjR[k+1];\\n        vector<int> adjC[k+1];\\n        for(auto edge: rowConditions){\\n            adjR[edge[0]].push_back(edge[1]);\\n        }\\n        for(auto edge: colConditions){\\n            adjC[edge[0]].push_back(edge[1]);\\n        }\\n        vector<int> rows,cols;\\n        rows=topoSort(k,adjR);\\n        if(rows.size()==0){\\n            return vector<vector<int>>();;\\n        }\\n        cols=topoSort(k,adjC);\\n        if(cols.size()==0){\\n            return vector<vector<int>>();;\\n        }\\n        \\n        vector<vector<int>> res(k,vector<int>(k,0));\\n        unordered_map<int,pair<int,int>> mpp;\\n        for(int i=0;i<rows.size();i++){\\n            mpp[rows[i]].first=i;\\n        }\\n        for(int i=0;i<cols.size();i++){\\n            mpp[cols[i]].second=i;\\n        }\\n        for(auto coor: mpp){\\n            int x=coor.second.first;\\n            int y=coor.second.second;\\n            int data=coor.first;\\n            res[x][y]=data;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool dfs(vector<bool> &vis, stack<int> &s, int node, vector<int> adj[], vector<bool> &rec){ \\n\\t// MAKES TOPOSORT AND ALSO CHECKS FOR CYCLES\\n\\t    vis[node]=true;\\n        rec[node]=true;\\n\\t    for(auto nei: adj[node]){\\n\\t        if(vis[nei]==false){\\n                if(dfs(vis,s,nei,adj,rec)==true){\\n                    return true;\\n                }\\n\\t        }\\n            else if(rec[nei]==true){\\n                return true;\\n            }\\n\\t    }\\n\\t    s.push(node);\\n        rec[node]=false;\\n        return false;\\n\\t}\\n\\t\\n\\tvector<int> topoSort(int V, vector<int> adj[]) {\\n        stack<int> s;\\n        vector<bool> vis(V+1,false);\\n        vector<bool> rec(V+1,false);\\n\\t    for(int v=1;v<=V;v++){\\n            if(vis[v]==false && dfs(vis,s,v,adj,rec)==true){\\n                return {};\\n\\t        }\\n\\t    }\\n        vector<int> tSort;\\n        while(!s.empty()){\\n            tSort.push_back(s.top());\\n            s.pop();\\n        }\\n        return tSort;\\n\\t}\\n    \\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        vector<int> adjR[k+1];\\n        vector<int> adjC[k+1];\\n        for(auto edge: rowConditions){\\n            adjR[edge[0]].push_back(edge[1]);\\n        }\\n        for(auto edge: colConditions){\\n            adjC[edge[0]].push_back(edge[1]);\\n        }\\n        vector<int> rows,cols;\\n        rows=topoSort(k,adjR);\\n        if(rows.size()==0){\\n            return vector<vector<int>>();;\\n        }\\n        cols=topoSort(k,adjC);\\n        if(cols.size()==0){\\n            return vector<vector<int>>();;\\n        }\\n        \\n        vector<vector<int>> res(k,vector<int>(k,0));\\n        unordered_map<int,pair<int,int>> mpp;\\n        for(int i=0;i<rows.size();i++){\\n            mpp[rows[i]].first=i;\\n        }\\n        for(int i=0;i<cols.size();i++){\\n            mpp[cols[i]].second=i;\\n        }\\n        for(auto coor: mpp){\\n            int x=coor.second.first;\\n            int y=coor.second.second;\\n            int data=coor.first;\\n            res[x][y]=data;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2700091,
                "title": "c-concise-topological-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        unordered_map<int, array<int,2>> m; //k, pos\\n        auto vrow = topoSort(k, rowConditions), vcol = topoSort(k, colConditions);\\n        if(vrow.size() < k || vcol.size() < k) return {};\\n        for(int i=0;i<k;i++){\\n            m[vrow[i]][0] = i;\\n            m[vcol[i]][1] = i;\\n        }\\n        auto res = vector(k, vector(k, 0));\\n        for(auto& [x, v] : m)\\n            res[v[0]][v[1]] = x+1;\\n        return res;\\n    }    \\n    \\n    vector<int> topoSort(int k, const vector<vector<int>>& edges){\\n        auto g = vector(k, vector<int>());\\n        vector<int> indegree(k);\\n        for(auto e : edges){\\n            g[e[0]-1].push_back(e[1]-1);\\n            indegree[e[1]-1]++;\\n        }\\n        \\n        vector<int> res;\\n        queue<int> q;\\n        for(int i=0;i<k;i++) if(indegree[i] == 0) q.push(i);\\n        while(!q.empty()){\\n            auto i = q.front(); q.pop();\\n            res.push_back(i);\\n            for(auto j : g[i]){\\n                if(--indegree[j] == 0) q.push(j);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        unordered_map<int, array<int,2>> m; //k, pos\\n        auto vrow = topoSort(k, rowConditions), vcol = topoSort(k, colConditions);\\n        if(vrow.size() < k || vcol.size() < k) return {}",
                "codeTag": "Java"
            },
            {
                "id": 2680301,
                "title": "c-solution",
                "content": "```\\nclass Graph {\\nprivate:\\n    vector<int> cnt;\\n    vector<vector<int>> edges;\\npublic:\\n    Graph(vector<vector<int>>& conditions, int k) {\\n        cnt.resize(k + 1, 0);\\n        edges.resize(k + 1);\\n        \\n        for(vector<int>& edge: conditions) {\\n            int x = edge[0];\\n            int y = edge[1];\\n            \\n            cnt[y]++;\\n            edges[x].push_back(y);\\n        }\\n    }\\n    \\n    vector<int> getPosition(int k) {\\n        queue<int> q;\\n        \\n        for(int i = 1; i <= k; i++) \\n            if(!cnt[i]) q.push(i);\\n        \\n        vector<int> res;\\n        if(q.empty()) return {};\\n        res.resize(k + 1);\\n        int pos = 0;\\n        \\n        while(!q.empty()) {\\n            int x = q.front();\\n            q.pop();\\n\\n            res[x] = pos++;\\n            \\n            for(int y: edges[x]) \\n                if(!(--cnt[y])) q.push(y);\\n        }\\n        \\n        for(int i = 1; i <= k; i++)\\n            if(cnt[i]) return {};\\n        \\n        return res;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        Graph row(rowConditions, k);\\n        Graph col(colConditions, k);\\n        \\n        vector<vector<int>> res(k, vector<int>(k, 0));\\n        vector<int> rowPos = row.getPosition(k);\\n        vector<int> colPos = col.getPosition(k);\\n        \\n        if(!rowPos.size() || !colPos.size()) return {};\\n        for(int i = 1; i <= k; i++) res[rowPos[i]][colPos[i]] = i;\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Graph"
                ],
                "code": "```\\nclass Graph {\\nprivate:\\n    vector<int> cnt;\\n    vector<vector<int>> edges;\\npublic:\\n    Graph(vector<vector<int>>& conditions, int k) {\\n        cnt.resize(k + 1, 0);\\n        edges.resize(k + 1);\\n        \\n        for(vector<int>& edge: conditions) {\\n            int x = edge[0];\\n            int y = edge[1];\\n            \\n            cnt[y]++;\\n            edges[x].push_back(y);\\n        }\\n    }\\n    \\n    vector<int> getPosition(int k) {\\n        queue<int> q;\\n        \\n        for(int i = 1; i <= k; i++) \\n            if(!cnt[i]) q.push(i);\\n        \\n        vector<int> res;\\n        if(q.empty()) return {};\\n        res.resize(k + 1);\\n        int pos = 0;\\n        \\n        while(!q.empty()) {\\n            int x = q.front();\\n            q.pop();\\n\\n            res[x] = pos++;\\n            \\n            for(int y: edges[x]) \\n                if(!(--cnt[y])) q.push(y);\\n        }\\n        \\n        for(int i = 1; i <= k; i++)\\n            if(cnt[i]) return {};\\n        \\n        return res;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        Graph row(rowConditions, k);\\n        Graph col(colConditions, k);\\n        \\n        vector<vector<int>> res(k, vector<int>(k, 0));\\n        vector<int> rowPos = row.getPosition(k);\\n        vector<int> colPos = col.getPosition(k);\\n        \\n        if(!rowPos.size() || !colPos.size()) return {};\\n        for(int i = 1; i <= k; i++) res[rowPos[i]][colPos[i]] = i;\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2675288,
                "title": "python3-toposort-kahn-s-algorithm",
                "content": "```\\nclass Solution:\\n    def buildMatrix(self, k: int, rc: List[List[int]], cc: List[List[int]]) -> List[List[int]]:\\n        def toposortBFS(cond):\\n            adj=[[] for i in range(k+1)]\\n            for u,v in cond:\\n                adj[u].append(v)\\n            inDegree=[0 for i in range(k+1)]\\n            topoArray=[]\\n            q=[]\\n            for i in range(1,k+1):\\n                for j in adj[i]:\\n                    inDegree[j]+=1\\n            for i in range(1,k+1):\\n                if inDegree[i]==0:\\n                    q.append(i)\\n            while q:\\n                ele=q.pop(0)\\n                topoArray.append(ele)\\n                for it in adj[ele]:\\n                    inDegree[it]-=1\\n                    if inDegree[it]==0:\\n                        q.append(it)\\n            return topoArray\\n        t1=toposortBFS(rc)\\n        t2=toposortBFS(cc)\\n        if len(t1)<k or len(t2)<k:\\n            return []\\n        ans=[[0 for i in range(k)] for i in range(k)]\\n        hmap=defaultdict(list)\\n        for ind,x in enumerate(t1):\\n            hmap[x].append(ind)\\n        for ind,x in enumerate(t2):\\n            hmap[x].append(ind)\\n        for key in hmap.keys():\\n            x,y=hmap[key]\\n            ans[x][y]=key\\n        return ans\\n            \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution:\\n    def buildMatrix(self, k: int, rc: List[List[int]], cc: List[List[int]]) -> List[List[int]]:\\n        def toposortBFS(cond):\\n            adj=[[] for i in range(k+1)]\\n            for u,v in cond:\\n                adj[u].append(v)\\n            inDegree=[0 for i in range(k+1)]\\n            topoArray=[]\\n            q=[]\\n            for i in range(1,k+1):\\n                for j in adj[i]:\\n                    inDegree[j]+=1\\n            for i in range(1,k+1):\\n                if inDegree[i]==0:\\n                    q.append(i)\\n            while q:\\n                ele=q.pop(0)\\n                topoArray.append(ele)\\n                for it in adj[ele]:\\n                    inDegree[it]-=1\\n                    if inDegree[it]==0:\\n                        q.append(it)\\n            return topoArray\\n        t1=toposortBFS(rc)\\n        t2=toposortBFS(cc)\\n        if len(t1)<k or len(t2)<k:\\n            return []\\n        ans=[[0 for i in range(k)] for i in range(k)]\\n        hmap=defaultdict(list)\\n        for ind,x in enumerate(t1):\\n            hmap[x].append(ind)\\n        for ind,x in enumerate(t2):\\n            hmap[x].append(ind)\\n        for key in hmap.keys():\\n            x,y=hmap[key]\\n            ans[x][y]=key\\n        return ans\\n            \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2669333,
                "title": "c",
                "content": "(```)  class Solution {\\npublic:\\n    \\n    vector<int> topo_sort(vector<vector<int>>&v, int k)\\n    {\\n        vector<vector<int>> graph(k+1);\\n        vector<int> indegree(k+1, 0);\\n        \\n        vector<int> ans;\\n        \\n        for(auto &x: v)\\n        {\\n            graph[x[0]].push_back(x[1]);\\n            indegree[x[1]]++;\\n        }\\n        \\n        queue<int> q;\\n        \\n        for(int i=1; i<=k; i++)\\n        {\\n            if(indegree[i] == 0)\\n            {\\n                q.push(i);\\n            }\\n        }\\n        \\n        while(!q.empty())\\n        {\\n            int n = q.size();\\n            \\n            while(n--)\\n            {\\n                auto it = q.front();\\n                q.pop();\\n                \\n                ans.push_back(it);\\n                \\n                for(auto &x: graph[it])\\n                {\\n                    if(--indegree[x] == 0)\\n                    {\\n                        q.push(x);\\n                    }\\n                }\\n         \\n            }\\n        }\\n        \\n        return ans.size() == k?ans : vector<int>{};\\n    }\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        \\n        vector<int> row_order = topo_sort(rowConditions, k);\\n        vector<int> col_order = topo_sort(colConditions, k);\\n        \\n        if(row_order.size() != k || col_order.size() != k)\\n        {\\n            return {};\\n        }\\n        \\n        vector<int> r(k+1), c(k+1);\\n        \\n        for(int i=0; i<k; i++)\\n        {\\n            r[row_order[i]] = i;\\n            c[col_order[i]] = i;\\n        }\\n        \\n        vector<vector<int>> ans(k,vector<int>(k,0));\\n        \\n        for(int i=1; i<=k; i++)\\n        {\\n            ans[r[i]][c[i]] = i;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    vector<int> topo_sort(vector<vector<int>>&v, int k)\\n    {\\n        vector<vector<int>> graph(k+1);\\n        vector<int> indegree(k+1, 0);\\n        \\n        vector<int> ans;\\n        \\n        for(auto &x: v)\\n        {\\n            graph[x[0]].push_back(x[1]);\\n            indegree[x[1]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2663841,
                "title": "kahn-s-algo-topo-sort-short-and-easy-to-understand-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nSince each rowConditions and colConditions is of type (a,b) : It looks like a directed edge i.e, a->b\\n\\nAnd rowConditions gives how elements should be arranged rowwise and colCondition can be arranged column wise. So, we can try Topological sorting here.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nGet the topological Sort arrangement of all nodes (1 to k) in rowwise and columnwise separately using Kahn\\'s Algo.\\n\\nNow, we check if rowwise and columnwise arrangement has all nodes. If not, return empty array i.e, the graph wasn\\'t Directed Acyclic one.\\n\\nind[i] will store the index of column where any particular node will lie\\n\\nNow fill up the res array using ind[] and row[] and return res.\\n\\n\\n\\n# Complexity\\n- Time complexity: $$O(k)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(k)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] buildMatrix(int k, int[][] rowConditions, int[][] colConditions) {\\n\\n        List<Integer> row=kahn_algo(rowConditions,k);\\n        if(row.size()!=k) return new int[][] {};\\n\\n         List<Integer> col=kahn_algo(colConditions,k);\\n        if(col.size()!=k) return new int[][] {};\\n\\n        int[] ind=new int[k+1];\\n        for(int i=0;i<col.size();i++){\\n            ind[col.get(i)]=i;\\n        }\\n\\n        int[][] res=new int[k][k];\\n\\n        for(int i=0;i<row.size();i++){\\n            int val=row.get(i);\\n            int c=ind[val];\\n            res[i][c]=val;\\n        }\\n        return res;\\n\\n        \\n    }\\n    static List<Integer> kahn_algo(int[][] cond, int k){\\n\\n        List<Integer> ans=new ArrayList<Integer>();\\n\\n        int[] indegree=new int[k+1];\\n\\n        List<List<Integer>> adj=new ArrayList<>();\\n        for(int i=0;i<=k;i++) adj.add(new ArrayList<Integer>());\\n\\n        for(int[] c: cond){\\n            indegree[c[1]]++;\\n            adj.get(c[0]).add(c[1]);\\n        }\\n\\n        Queue<Integer> q=new LinkedList<Integer>();\\n        for(int i=1;i<=k;i++) if(indegree[i]==0) q.add(i);\\n\\n        while(!q.isEmpty()){\\n            int x=q.poll();\\n            ans.add(x);\\n\\n            for(int nbr:adj.get(x)){\\n                indegree[nbr]--;\\n                if(indegree[nbr]==0) q.add(nbr);\\n            }\\n\\n        }\\n\\n        return ans;\\n\\n\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] buildMatrix(int k, int[][] rowConditions, int[][] colConditions) {\\n\\n        List<Integer> row=kahn_algo(rowConditions,k);\\n        if(row.size()!=k) return new int[][] {};\\n\\n         List<Integer> col=kahn_algo(colConditions,k);\\n        if(col.size()!=k) return new int[][] {};\\n\\n        int[] ind=new int[k+1];\\n        for(int i=0;i<col.size();i++){\\n            ind[col.get(i)]=i;\\n        }\\n\\n        int[][] res=new int[k][k];\\n\\n        for(int i=0;i<row.size();i++){\\n            int val=row.get(i);\\n            int c=ind[val];\\n            res[i][c]=val;\\n        }\\n        return res;\\n\\n        \\n    }\\n    static List<Integer> kahn_algo(int[][] cond, int k){\\n\\n        List<Integer> ans=new ArrayList<Integer>();\\n\\n        int[] indegree=new int[k+1];\\n\\n        List<List<Integer>> adj=new ArrayList<>();\\n        for(int i=0;i<=k;i++) adj.add(new ArrayList<Integer>());\\n\\n        for(int[] c: cond){\\n            indegree[c[1]]++;\\n            adj.get(c[0]).add(c[1]);\\n        }\\n\\n        Queue<Integer> q=new LinkedList<Integer>();\\n        for(int i=1;i<=k;i++) if(indegree[i]==0) q.add(i);\\n\\n        while(!q.isEmpty()){\\n            int x=q.poll();\\n            ans.add(x);\\n\\n            for(int nbr:adj.get(x)){\\n                indegree[nbr]--;\\n                if(indegree[nbr]==0) q.add(nbr);\\n            }\\n\\n        }\\n\\n        return ans;\\n\\n\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2661177,
                "title": "c-topo-sort-graph-bfs-simple",
                "content": "**<< UPVOTE >>**\\n\\n\\tclass Solution {\\n\\t\\tvector<int> TopoSort(vector<vector<int>>& edges , int k){\\n\\t\\t\\tvector<int> adj[k+1];\\n\\t\\t\\tfor(auto it : edges){\\n\\t\\t\\t\\tint u = it[0] , v = it[1];\\n\\t\\t\\t\\tadj[u].push_back(v);\\n\\t\\t\\t}\\n\\n\\t\\t\\tvector<int> indegree(k+1,0);\\n\\t\\t\\tfor(auto it : edges){\\n\\t\\t\\t\\tindegree[it[1]]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tqueue<int> q;\\n\\t\\t\\tfor(int i = 1 ; i <= k ; i++) {\\n\\t\\t\\t\\tif(indegree[i] == 0) q.push(i);\\n\\t\\t\\t}\\n\\n\\t\\t\\tvector<int> ans;\\n\\n\\t\\t\\twhile(!q.empty()){\\n\\t\\t\\t\\tint node = q.front();\\n\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\tans.push_back(node);\\n\\t\\t\\t\\tfor(auto it : adj[node]){\\n\\t\\t\\t\\t\\tindegree[it]--;\\n\\t\\t\\t\\t\\tif(indegree[it] == 0) q.push(it);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(ans.size() == k) return ans;\\n\\t\\t\\telse return {};\\n\\n\\t\\t}\\n\\n\\n\\n\\tpublic:\\n\\t\\tvector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n\\t\\t\\tint n = rowConditions.size();\\n\\t\\t\\tint m = colConditions.size();\\n\\n\\t\\t\\tvector<int> topoRow = TopoSort(rowConditions,k);\\n\\t\\t\\tvector<int> topoCol = TopoSort(colConditions,k);\\n\\n\\t\\t\\tif(topoRow.size() == 0 or topoCol.size() == 0) return {};\\n\\n\\t\\t\\tvector<vector<int>> ans(k,vector<int>(k,0));\\n\\t\\t\\tunordered_map<int,int> location;\\n\\t\\t\\tfor(int i = 0 ; i < topoCol.size() ; i++){\\n\\t\\t\\t\\tlocation[topoCol[i]] = i;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(int i = 0 ; i < k ; i++){\\n\\t\\t\\t\\tans[i][location[topoRow[i]]] = topoRow[i];\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tvector<int> TopoSort(vector<vector<int>>& edges , int k){\\n\\t\\t\\tvector<int> adj[k+1];\\n\\t\\t\\tfor(auto it : edges){\\n\\t\\t\\t\\tint u = it[0] , v = it[1];\\n\\t\\t\\t\\tadj[u].push_back(v);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2660635,
                "title": "sorting-bfs-c",
                "content": "```\\nvector<vector<int>> buildMatrix(int k, vector<vector<int>>& R_c, vector<vector<int>>& C_c) {\\n\\t\\n\\tvector<pair<int, int>> assign(k + 1, make_pair(-1, -1));\\n\\tvector<vector<int>> ans(k, vector<int>(k));\\n\\tvector<int> g[k + 1];\\n\\n\\tvector<int> degree(k + 1);\\n\\tfor(auto p : R_c) {\\t\\t\\n\\t\\tint u = p[0];\\n\\t\\tint v = p[1];\\n\\t\\tdegree[v]++;\\n\\t\\tg[u].push_back(v);\\n\\t}\\n\\n\\tqueue<int> q;\\t\\n\\tfor(int i = 1; i <= k; i++) {\\n\\t\\tif(degree[i] == 0) {\\n\\t\\t\\tq.push(i);\\n\\t\\t}\\n\\t}\\n    int C_R = 0;\\n\\twhile(q.size() > 0) {\\n\\t\\tint node = q.front();\\n\\t\\tassign[node].first = C_R++;\\n\\t\\tq.pop();\\n\\t\\tfor(int child : g[node]) {\\n\\t\\t\\tdegree[child]--;\\n\\t\\t\\tif(degree[child] == 0) {\\n\\t\\t\\t\\tq.push(child);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfor(int i = 1; i <= k; i++) {\\n\\t\\tdegree[i] = 0;\\n\\t\\tg[i].clear();\\n\\t}\\n\\tfor(auto p : C_c) {\\n\\t\\tint u = p[0];\\n\\t\\tint v = p[1];\\n\\t\\tdegree[v]++;\\n\\t\\tg[u].push_back(v);\\n\\t}\\n    int C_C = 0;\\n\\tfor(int i = 1; i <= k; i++) {\\n\\t\\tif(degree[i] == 0) {\\n            q.push(i);\\n\\t\\t}\\n\\t}\\n\\twhile(q.size() > 0) {\\n\\t\\tint node = q.front();\\n\\t\\tassign[node].second = C_C++;\\n        q.pop();\\n\\t\\tfor(int child : g[node]) {\\n\\t\\t\\tdegree[child]--;\\n\\t\\t\\tif(degree[child] == 0) {\\n\\t\\t\\t\\tq.push(child);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfor(int i = 1; i <= k; i++) {\\n\\t\\tif(assign[i].second == -1 || assign[i].first == -1) {\\n            ans.clear();\\n\\t\\t\\treturn ans;\\n\\t\\t} \\n\\t\\tans[assign[i].first][assign[i].second] = i;\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nvector<vector<int>> buildMatrix(int k, vector<vector<int>>& R_c, vector<vector<int>>& C_c) {\\n\\t\\n\\tvector<pair<int, int>> assign(k + 1, make_pair(-1, -1));\\n\\tvector<vector<int>> ans(k, vector<int>(k));\\n\\tvector<int> g[k + 1];\\n\\n\\tvector<int> degree(k + 1);\\n\\tfor(auto p : R_c) {\\t\\t\\n\\t\\tint u = p[0];\\n\\t\\tint v = p[1];\\n\\t\\tdegree[v]++;\\n\\t\\tg[u].push_back(v);\\n\\t}\\n\\n\\tqueue<int> q;\\t\\n\\tfor(int i = 1; i <= k; i++) {\\n\\t\\tif(degree[i] == 0) {\\n\\t\\t\\tq.push(i);\\n\\t\\t}\\n\\t}\\n    int C_R = 0;\\n\\twhile(q.size() > 0) {\\n\\t\\tint node = q.front();\\n\\t\\tassign[node].first = C_R++;\\n\\t\\tq.pop();\\n\\t\\tfor(int child : g[node]) {\\n\\t\\t\\tdegree[child]--;\\n\\t\\t\\tif(degree[child] == 0) {\\n\\t\\t\\t\\tq.push(child);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfor(int i = 1; i <= k; i++) {\\n\\t\\tdegree[i] = 0;\\n\\t\\tg[i].clear();\\n\\t}\\n\\tfor(auto p : C_c) {\\n\\t\\tint u = p[0];\\n\\t\\tint v = p[1];\\n\\t\\tdegree[v]++;\\n\\t\\tg[u].push_back(v);\\n\\t}\\n    int C_C = 0;\\n\\tfor(int i = 1; i <= k; i++) {\\n\\t\\tif(degree[i] == 0) {\\n            q.push(i);\\n\\t\\t}\\n\\t}\\n\\twhile(q.size() > 0) {\\n\\t\\tint node = q.front();\\n\\t\\tassign[node].second = C_C++;\\n        q.pop();\\n\\t\\tfor(int child : g[node]) {\\n\\t\\t\\tdegree[child]--;\\n\\t\\t\\tif(degree[child] == 0) {\\n\\t\\t\\t\\tq.push(child);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfor(int i = 1; i <= k; i++) {\\n\\t\\tif(assign[i].second == -1 || assign[i].first == -1) {\\n            ans.clear();\\n\\t\\t\\treturn ans;\\n\\t\\t} \\n\\t\\tans[assign[i].first][assign[i].second] = i;\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2621151,
                "title": "cpp-topological-sort-solution",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        vector<unordered_set<int>> rowRef(k + 1, unordered_set<int>());\\n        vector<unordered_set<int>> colRef(k + 1, unordered_set<int>());\\n        vector<int> rowInd(k + 1, 0);\\n        vector<int> colInd(k + 1, 0);\\n        \\n        for (auto &rc : rowConditions) {\\n            if (rowRef[rc[0]].find(rc[1]) != rowRef[rc[0]].end()) continue;\\n            rowRef[rc[0]].insert(rc[1]);\\n            rowInd[rc[1]]++;\\n        }\\n        \\n        for (auto& cc : colConditions) {\\n            if (colRef[cc[0]].find(cc[1]) != colRef[cc[0]].end()) continue;\\n            colRef[cc[0]].insert(cc[1]);\\n            colInd[cc[1]]++;\\n        }\\n        \\n        queue<int> queue;\\n        unordered_map<int, int> rows;\\n        unordered_map<int, int> cols;\\n        \\n        process(rowInd, rowRef, queue, rows);\\n        process(colInd, colRef, queue, cols);\\n\\n        if (rows.size() < k || cols.size() < k) return {};\\n        \\n        vector<vector<int>> ans(k, vector<int>(k, 0));\\n        for (int i = 1; i <= k; i++) {\\n            ans[rows[i]][cols[i]] = i;\\n        }\\n        return ans;\\n    }\\nprivate:\\n    void process(vector<int> &ind, vector<unordered_set<int>> &ref, queue<int> &queue, unordered_map<int, int> &map) {\\n        for (int i = 1; i < ind.size(); i++) {\\n            if (ind[i] == 0) queue.push(i);\\n        }\\n        int cnt = 0;\\n        while (!queue.empty()) {\\n            for (int i = queue.size(); i > 0; i--) {\\n                int cur = queue.front();\\n                map[cur] = cnt;\\n                cnt++;\\n                queue.pop();\\n                for (int j : ref[cur]) {\\n                    ind[j]--;\\n                    if (ind[j] == 0) queue.push(j);\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "Topological Sort"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        vector<unordered_set<int>> rowRef(k + 1, unordered_set<int>());\\n        vector<unordered_set<int>> colRef(k + 1, unordered_set<int>());\\n        vector<int> rowInd(k + 1, 0);\\n        vector<int> colInd(k + 1, 0);\\n        \\n        for (auto &rc : rowConditions) {\\n            if (rowRef[rc[0]].find(rc[1]) != rowRef[rc[0]].end()) continue;\\n            rowRef[rc[0]].insert(rc[1]);\\n            rowInd[rc[1]]++;\\n        }\\n        \\n        for (auto& cc : colConditions) {\\n            if (colRef[cc[0]].find(cc[1]) != colRef[cc[0]].end()) continue;\\n            colRef[cc[0]].insert(cc[1]);\\n            colInd[cc[1]]++;\\n        }\\n        \\n        queue<int> queue;\\n        unordered_map<int, int> rows;\\n        unordered_map<int, int> cols;\\n        \\n        process(rowInd, rowRef, queue, rows);\\n        process(colInd, colRef, queue, cols);\\n\\n        if (rows.size() < k || cols.size() < k) return {};\\n        \\n        vector<vector<int>> ans(k, vector<int>(k, 0));\\n        for (int i = 1; i <= k; i++) {\\n            ans[rows[i]][cols[i]] = i;\\n        }\\n        return ans;\\n    }\\nprivate:\\n    void process(vector<int> &ind, vector<unordered_set<int>> &ref, queue<int> &queue, unordered_map<int, int> &map) {\\n        for (int i = 1; i < ind.size(); i++) {\\n            if (ind[i] == 0) queue.push(i);\\n        }\\n        int cnt = 0;\\n        while (!queue.empty()) {\\n            for (int i = queue.size(); i > 0; i--) {\\n                int cur = queue.front();\\n                map[cur] = cnt;\\n                cnt++;\\n                queue.pop();\\n                for (int j : ref[cur]) {\\n                    ind[j]--;\\n                    if (ind[j] == 0) queue.push(j);\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2618811,
                "title": "topological-sort-python-time-o-v-2-e-space-o-v-2-e",
                "content": "```\\nclass Solution:\\n    def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:\\n        \\n        def topologicalSort(t):\\n            res = []\\n            indegrees = {i: 0 for i in range(1, k + 1)}\\n            noPrereqs = set()\\n            prereqs = rowConditions if t == \\'R\\' else colConditions\\n            \\n            for prereq, num in prereqs:\\n                indegrees[num] += 1\\n                \\n            for num in indegrees.keys():\\n                if indegrees[num] == 0:\\n                    noPrereqs.add(num)\\n\\n            while noPrereqs:\\n                curr = noPrereqs.pop()\\n                res.append(curr)\\n                for prereq, num in prereqs:\\n                    if curr == prereq:\\n                        indegrees[num] -= 1\\n                        if indegrees[num] == 0:\\n                            noPrereqs.add(num)\\n            return res if len(res) == k else None\\n\\n        topOrdRows = topologicalSort(\\'R\\')\\n        topOrdCols = topologicalSort(\\'C\\')\\n        if topOrdRows is None or topOrdCols is None:\\n            return []\\n             \\n        ans = [[0] * k for _ in range(k)]\\n        for i in range(k): \\n            ans[topOrdRows.index(i + 1)][topOrdCols.index(i + 1)] = i + 1\\n        return ans\\n    # Time: O(V^2 + E) where V is k and E is the number of conditions\\n    # Space: O(V^2 + E)\\n```",
                "solutionTags": [
                    "Python",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution:\\n    def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:\\n        \\n        def topologicalSort(t):\\n            res = []\\n            indegrees = {i: 0 for i in range(1, k + 1)}\\n            noPrereqs = set()\\n            prereqs = rowConditions if t == \\'R\\' else colConditions\\n            \\n            for prereq, num in prereqs:\\n                indegrees[num] += 1\\n                \\n            for num in indegrees.keys():\\n                if indegrees[num] == 0:\\n                    noPrereqs.add(num)\\n\\n            while noPrereqs:\\n                curr = noPrereqs.pop()\\n                res.append(curr)\\n                for prereq, num in prereqs:\\n                    if curr == prereq:\\n                        indegrees[num] -= 1\\n                        if indegrees[num] == 0:\\n                            noPrereqs.add(num)\\n            return res if len(res) == k else None\\n\\n        topOrdRows = topologicalSort(\\'R\\')\\n        topOrdCols = topologicalSort(\\'C\\')\\n        if topOrdRows is None or topOrdCols is None:\\n            return []\\n             \\n        ans = [[0] * k for _ in range(k)]\\n        for i in range(k): \\n            ans[topOrdRows.index(i + 1)][topOrdCols.index(i + 1)] = i + 1\\n        return ans\\n    # Time: O(V^2 + E) where V is k and E is the number of conditions\\n    # Space: O(V^2 + E)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2607138,
                "title": "99-8-faster-java-solution-heavily-commented-clean-code-t-c-o-k-e",
                "content": "```\\nclass Solution {        // k = n = no. of vertices\\n   public int[][] buildMatrix(int k, int[][] rowConditions, int[][] colConditions) {\\n\\n        List<Integer> topo_row = topo_sorting(k , rowConditions) ;      // T.C. = O(k+E_rowConditions)\\n        if(topo_row.size()==0) return new int[0][] ;        \\n\\n       List<Integer> topo_col = topo_sorting(k , colConditions) ;   // T.C. = O(k+E_colConditions)\\n        if(topo_col.size() == 0) return new int[0][] ;\\n      \\n        int [] row_order = new int[k];      // row_order[i] stores which row should (i+1) be put in\\n        int [] col_order = new int[k];       // col_order[i] stores which col should (i+1) be put in\\n\\n        for (int i = 0; i < k; i++) {       // T.C. = O(k)\\n            int r = topo_row.get(i) ;\\n            row_order[r] = i ;\\n\\n            int c = topo_col.get(i) ;\\n            col_order[c] = i ;\\n        }\\n        int [][] matrix = new int[k][k] ;       // S.C. = O(k^2)\\n        for (int i = 0; i < k; i++) {       // T.C. = O(k)\\n            int r = row_order[i] ;\\n            int c = col_order[i] ;\\n            matrix[r][c] = i+1 ;\\n        }\\n        return matrix ;\\n    }\\n    /*******************************************************************************/\\n    private List<Integer> topo_sorting(int n , int [][]graph){\\n        List[] adj_list = new List[n] ;\\n\\n        for (int i = 0; i < n; i++) {       // O(N)\\n            adj_list[i] = new ArrayList<>() ;\\n        }\\n        for (int i = 0; i < graph.length ; i++) {       // O(E)\\n            int node = graph[i][1] -1 ;             // nodes : 0_to_k-1 instead of 1_to_k\\n            adj_list[node].add(graph[i][0] -1);\\n        }\\n        // now adj_list created , move ahead and do sorting\\n        List<Integer> sorted = new ArrayList<>() ;\\n        int visited[] = new int[n] ;\\n        \\n        // running for_loop to cover disconnected components of graph\\n        // T.C. = O(E) visiting all the edges\\n        for (int i = 0; i < n; i++) {       \\n            dfs(i , adj_list , visited , sorted)  ;\\n        }\\n        \\n        if(sorted.size() <n) return new ArrayList<>() ;     // unable to sort all nodes\\n        return sorted ;\\n    }\\n/*************************************************************************************************/\\n    private boolean dfs(int node, List []adj_list , int[] visited , List<Integer> sorted) {\\n        if(visited[node] == 2) return true ;\\n        if(visited[node] == 1) return false ;\\n\\n        // visited[node] == 0\\n        visited[node] = 1 ;\\n        List<Integer> li =  adj_list[node] ;\\n        for(int i: li){\\n            if(! dfs(i , adj_list , visited , sorted )) return false ;\\n        }\\n\\n        visited[node] = 2 ;\\n        sorted.add(node) ;\\n        return true ;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Topological Sort",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {        // k = n = no. of vertices\\n   public int[][] buildMatrix(int k, int[][] rowConditions, int[][] colConditions) {\\n\\n        List<Integer> topo_row = topo_sorting(k , rowConditions) ;      // T.C. = O(k+E_rowConditions)\\n        if(topo_row.size()==0) return new int[0][] ;        \\n\\n       List<Integer> topo_col = topo_sorting(k , colConditions) ;   // T.C. = O(k+E_colConditions)\\n        if(topo_col.size() == 0) return new int[0][] ;\\n      \\n        int [] row_order = new int[k];      // row_order[i] stores which row should (i+1) be put in\\n        int [] col_order = new int[k];       // col_order[i] stores which col should (i+1) be put in\\n\\n        for (int i = 0; i < k; i++) {       // T.C. = O(k)\\n            int r = topo_row.get(i) ;\\n            row_order[r] = i ;\\n\\n            int c = topo_col.get(i) ;\\n            col_order[c] = i ;\\n        }\\n        int [][] matrix = new int[k][k] ;       // S.C. = O(k^2)\\n        for (int i = 0; i < k; i++) {       // T.C. = O(k)\\n            int r = row_order[i] ;\\n            int c = col_order[i] ;\\n            matrix[r][c] = i+1 ;\\n        }\\n        return matrix ;\\n    }\\n    /*******************************************************************************/\\n    private List<Integer> topo_sorting(int n , int [][]graph){\\n        List[] adj_list = new List[n] ;\\n\\n        for (int i = 0; i < n; i++) {       // O(N)\\n            adj_list[i] = new ArrayList<>() ;\\n        }\\n        for (int i = 0; i < graph.length ; i++) {       // O(E)\\n            int node = graph[i][1] -1 ;             // nodes : 0_to_k-1 instead of 1_to_k\\n            adj_list[node].add(graph[i][0] -1);\\n        }\\n        // now adj_list created , move ahead and do sorting\\n        List<Integer> sorted = new ArrayList<>() ;\\n        int visited[] = new int[n] ;\\n        \\n        // running for_loop to cover disconnected components of graph\\n        // T.C. = O(E) visiting all the edges\\n        for (int i = 0; i < n; i++) {       \\n            dfs(i , adj_list , visited , sorted)  ;\\n        }\\n        \\n        if(sorted.size() <n) return new ArrayList<>() ;     // unable to sort all nodes\\n        return sorted ;\\n    }\\n/*************************************************************************************************/\\n    private boolean dfs(int node, List []adj_list , int[] visited , List<Integer> sorted) {\\n        if(visited[node] == 2) return true ;\\n        if(visited[node] == 1) return false ;\\n\\n        // visited[node] == 0\\n        visited[node] = 1 ;\\n        List<Integer> li =  adj_list[node] ;\\n        for(int i: li){\\n            if(! dfs(i , adj_list , visited , sorted )) return false ;\\n        }\\n\\n        visited[node] = 2 ;\\n        sorted.add(node) ;\\n        return true ;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2596287,
                "title": "c-topological-sorting",
                "content": "```\\nclass Solution {\\n    vector<int> top_sorting(vector<vector<int>> con, int k) {\\n        vector<int> indegree(k+1, 0);\\n        vector<vector<int>> graph(k+1);\\n        for(auto &it: con) {\\n            indegree[it[1]] += 1;\\n            graph[it[0]].push_back(it[1]);\\n        }\\n        \\n        vector<int> ans;\\n        queue<int> q;\\n        for(int i = 1; i <= k; i++) {\\n            if(indegree[i] == 0)\\n                q.push(i);\\n        }\\n        \\n        while(!q.empty()) {\\n            int u = q.front();\\n            q.pop();\\n            ans.push_back(u);\\n            for(int v: graph[u]) {\\n                indegree[v]--;\\n                if(indegree[v] == 0) \\n                    q.push(v);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\npublic:\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowC, vector<vector<int>>& colC) {\\n        vector<int> rowOrder = top_sorting(rowC, k);\\n        vector<int> colOrder = top_sorting(colC, k);\\n        \\n        // check cycle\\n        if(rowOrder.size() != k || colOrder.size() != k)\\n            return {};        \\n\\t\\t\\t\\n        // row index and col index of i\\n        vector<int> r(k+1), c(k+1);\\n        for(int i = 0; i < k; i++) {\\n            r[rowOrder[i]] = i;\\n            c[colOrder[i]] = i;\\n        }\\n        \\n        vector<vector<int>> ans(k, vector<int>(k, 0));\\n        for(int i = 1; i <= k; i++) \\n            ans[r[i]][c[i]] = i;\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    vector<int> top_sorting(vector<vector<int>> con, int k) {\\n        vector<int> indegree(k+1, 0);\\n        vector<vector<int>> graph(k+1);\\n        for(auto &it: con) {\\n            indegree[it[1]] += 1;\\n            graph[it[0]].push_back(it[1]);\\n        }\\n        \\n        vector<int> ans;\\n        queue<int> q;\\n        for(int i = 1; i <= k; i++) {\\n            if(indegree[i] == 0)\\n                q.push(i);\\n        }\\n        \\n        while(!q.empty()) {\\n            int u = q.front();\\n            q.pop();\\n            ans.push_back(u);\\n            for(int v: graph[u]) {\\n                indegree[v]--;\\n                if(indegree[v] == 0) \\n                    q.push(v);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\npublic:\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowC, vector<vector<int>>& colC) {\\n        vector<int> rowOrder = top_sorting(rowC, k);\\n        vector<int> colOrder = top_sorting(colC, k);\\n        \\n        // check cycle\\n        if(rowOrder.size() != k || colOrder.size() != k)\\n            return {};        \\n\\t\\t\\t\\n        // row index and col index of i\\n        vector<int> r(k+1), c(k+1);\\n        for(int i = 0; i < k; i++) {\\n            r[rowOrder[i]] = i;\\n            c[colOrder[i]] = i;\\n        }\\n        \\n        vector<vector<int>> ans(k, vector<int>(k, 0));\\n        for(int i = 1; i <= k; i++) \\n            ans[r[i]][c[i]] = i;\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2595858,
                "title": "kahn-s-algo-bfs-c-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> topoSort(vector<vector<int>>& adj, vector<bool>& vis, int k) {\\n        vector<int> inDeg(k, 0);\\n        vector<int> res;\\n        \\n        for(int i=0; i<k; ++i) {\\n            for(auto it : adj[i]) inDeg[it]++;\\n        }\\n        \\n        queue<int> q;\\n        for(int i=0; i<k; ++i) {\\n            if(inDeg[i]==0) q.push(i);\\n        }\\n        \\n        while(!q.empty()) {\\n            int u = q.front();\\n            q.pop();\\n            \\n            if(!vis[u]) {\\n                vis[u]=1;\\n                res.push_back(u);\\n            }\\n            \\n            for(auto v : adj[u]) {\\n                inDeg[v]--;\\n                if(inDeg[v]==0) q.push(v);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowCond, vector<vector<int>>& colCond) {\\n        int n = rowCond.size(), m = colCond.size();\\n        \\n        vector<vector<int>> rowAdj(k), colAdj(k);\\n        vector<bool> rowVis(k,0), colVis(k,0);\\n        \\n        for(int i=0; i<n; ++i) rowAdj[rowCond[i][0]-1].push_back(rowCond[i][1]-1);\\n        \\n        for(int j=0; j<m; ++j) colAdj[colCond[j][0]-1].push_back(colCond[j][1]-1);\\n        \\n        \\n        // topo-sorting the rows & columns and getting the row & col arragements\\n        vector<int> rowArr = topoSort(rowAdj, rowVis, k);\\n        vector<int> colArr = topoSort(colAdj, colVis, k);\\n        \\n        // checking for cycles as we know that while toposorting if the final output have less vertices then the cycle is present otherwise not\\n        if(rowArr.size()<k || colArr.size()<k) return vector<vector<int>>();\\n        \\n        // forming the final result using the rowArr and colArr\\n        vector<vector<int>> res(k, vector<int>(k, 0));\\n        \\n        map<int,int> mp;\\n        for(int i=0; i<k; ++i) {\\n            mp[colArr[i]]=i;\\n        }\\n        \\n        for(int i=0; i<k; ++i) {\\n            res[i][mp[rowArr[i]]] = rowArr[i]+1;\\n        }\\n        \\n        return res;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> topoSort(vector<vector<int>>& adj, vector<bool>& vis, int k) {\\n        vector<int> inDeg(k, 0);\\n        vector<int> res;\\n        \\n        for(int i=0; i<k; ++i) {\\n            for(auto it : adj[i]) inDeg[it]++;\\n        }\\n        \\n        queue<int> q;\\n        for(int i=0; i<k; ++i) {\\n            if(inDeg[i]==0) q.push(i);\\n        }\\n        \\n        while(!q.empty()) {\\n            int u = q.front();\\n            q.pop();\\n            \\n            if(!vis[u]) {\\n                vis[u]=1;\\n                res.push_back(u);\\n            }\\n            \\n            for(auto v : adj[u]) {\\n                inDeg[v]--;\\n                if(inDeg[v]==0) q.push(v);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowCond, vector<vector<int>>& colCond) {\\n        int n = rowCond.size(), m = colCond.size();\\n        \\n        vector<vector<int>> rowAdj(k), colAdj(k);\\n        vector<bool> rowVis(k,0), colVis(k,0);\\n        \\n        for(int i=0; i<n; ++i) rowAdj[rowCond[i][0]-1].push_back(rowCond[i][1]-1);\\n        \\n        for(int j=0; j<m; ++j) colAdj[colCond[j][0]-1].push_back(colCond[j][1]-1);\\n        \\n        \\n        // topo-sorting the rows & columns and getting the row & col arragements\\n        vector<int> rowArr = topoSort(rowAdj, rowVis, k);\\n        vector<int> colArr = topoSort(colAdj, colVis, k);\\n        \\n        // checking for cycles as we know that while toposorting if the final output have less vertices then the cycle is present otherwise not\\n        if(rowArr.size()<k || colArr.size()<k) return vector<vector<int>>();\\n        \\n        // forming the final result using the rowArr and colArr\\n        vector<vector<int>> res(k, vector<int>(k, 0));\\n        \\n        map<int,int> mp;\\n        for(int i=0; i<k; ++i) {\\n            mp[colArr[i]]=i;\\n        }\\n        \\n        for(int i=0; i<k; ++i) {\\n            res[i][mp[rowArr[i]]] = rowArr[i]+1;\\n        }\\n        \\n        return res;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2580635,
                "title": "python-topo-sort-bfs",
                "content": "```\\nclass Solution:\\n    def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:\\n        returner = [[0 for _ in range(k)] for _ in range(k)]\\n        \\n        first =[[0 for _ in range(k)] for _ in range(k)]\\n        second = [[0 for _ in range(k)] for _ in range(k)]\\n        \\n        vertical = defaultdict(list)\\n        horizontal = defaultdict(list)\\n        vertical_in = defaultdict(int)\\n        horizontal_in = defaultdict(int)\\n        \\n        ## initialize in-degrees\\n        for i in range(1, k + 1):\\n            vertical_in[i] = 0\\n            horizontal_in[i] = 0\\n            \\n        ## initialize directed graph\\n        for row in rowConditions:\\n            vertical[row[0]].append(row[1])\\n            vertical_in[row[1]] += 1\\n        for col in colConditions:\\n            horizontal[col[0]].append(col[1])\\n            horizontal_in[col[1]] += 1\\n        \\n        verti_order = []\\n        verti_queue = deque()\\n        verti_visited = set()\\n        for key in vertical_in.keys():\\n            if (vertical_in[key] == 0):\\n                verti_queue.append(key)\\n        \\n        if (len(verti_queue) == 0):\\n            return []\\n        \\n        ## find the vertical ordering\\n        cycle = False\\n        while (verti_queue):\\n            cur = verti_queue.popleft()\\n            \\n            verti_order.append(cur)\\n            verti_visited.add(cur)\\n            for neighbour in vertical[cur]:\\n                if (neighbour in verti_visited):\\n                    cycle = True\\n                    break\\n                vertical_in[neighbour] -= 1\\n                if (vertical_in[neighbour] == 0):\\n                    verti_queue.append(neighbour)\\n            if (cycle):\\n                break        \\n        if (cycle):\\n            return []\\n        \\n        ## find the horizontal ordering\\n        hori_order = []\\n        hori_queue = deque()\\n        hori_visited = set()\\n        for key in horizontal_in.keys():\\n            if (horizontal_in[key] == 0):\\n                hori_queue.append(key)\\n        if (len(hori_queue) == 0):\\n            return []\\n        cycle = False\\n        \\n        while (hori_queue):\\n            cur = hori_queue.popleft()\\n            hori_order.append(cur)\\n            hori_visited.add(cur)\\n            for neighbour in horizontal[cur]:\\n                if (neighbour in hori_visited):\\n                    cycle = True\\n                    break\\n                horizontal_in[neighbour] -= 1\\n                if (horizontal_in[neighbour] == 0):\\n                    hori_queue.append(neighbour)\\n            if (cycle):\\n                break\\n        \\n        if (cycle):\\n            return []\\n       \\n        if (len(verti_order) != k or len(hori_order) != k):\\n            return []\\n        \\n        ## fill the vertical and horizontal matrix\\n        for i in range(k):\\n            for j in range(k):\\n                first[i][j] = verti_order[i]\\n                second[i][j] = hori_order[j]\\n        \\n        ## overlap the vertical and horizontal matrix to get the final matrix\\n        for i in range(k):\\n            for j in range(k):\\n                if (first[i][j] == second[i][j]):\\n                    returner[i][j] = first[i][j]\\n        return returner\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution:\\n    def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:\\n        returner = [[0 for _ in range(k)] for _ in range(k)]\\n        \\n        first =[[0 for _ in range(k)] for _ in range(k)]\\n        second = [[0 for _ in range(k)] for _ in range(k)]\\n        \\n        vertical = defaultdict(list)\\n        horizontal = defaultdict(list)\\n        vertical_in = defaultdict(int)\\n        horizontal_in = defaultdict(int)\\n        \\n        ## initialize in-degrees\\n        for i in range(1, k + 1):\\n            vertical_in[i] = 0\\n            horizontal_in[i] = 0\\n            \\n        ## initialize directed graph\\n        for row in rowConditions:\\n            vertical[row[0]].append(row[1])\\n            vertical_in[row[1]] += 1\\n        for col in colConditions:\\n            horizontal[col[0]].append(col[1])\\n            horizontal_in[col[1]] += 1\\n        \\n        verti_order = []\\n        verti_queue = deque()\\n        verti_visited = set()\\n        for key in vertical_in.keys():\\n            if (vertical_in[key] == 0):\\n                verti_queue.append(key)\\n        \\n        if (len(verti_queue) == 0):\\n            return []\\n        \\n        ## find the vertical ordering\\n        cycle = False\\n        while (verti_queue):\\n            cur = verti_queue.popleft()\\n            \\n            verti_order.append(cur)\\n            verti_visited.add(cur)\\n            for neighbour in vertical[cur]:\\n                if (neighbour in verti_visited):\\n                    cycle = True\\n                    break\\n                vertical_in[neighbour] -= 1\\n                if (vertical_in[neighbour] == 0):\\n                    verti_queue.append(neighbour)\\n            if (cycle):\\n                break        \\n        if (cycle):\\n            return []\\n        \\n        ## find the horizontal ordering\\n        hori_order = []\\n        hori_queue = deque()\\n        hori_visited = set()\\n        for key in horizontal_in.keys():\\n            if (horizontal_in[key] == 0):\\n                hori_queue.append(key)\\n        if (len(hori_queue) == 0):\\n            return []\\n        cycle = False\\n        \\n        while (hori_queue):\\n            cur = hori_queue.popleft()\\n            hori_order.append(cur)\\n            hori_visited.add(cur)\\n            for neighbour in horizontal[cur]:\\n                if (neighbour in hori_visited):\\n                    cycle = True\\n                    break\\n                horizontal_in[neighbour] -= 1\\n                if (horizontal_in[neighbour] == 0):\\n                    hori_queue.append(neighbour)\\n            if (cycle):\\n                break\\n        \\n        if (cycle):\\n            return []\\n       \\n        if (len(verti_order) != k or len(hori_order) != k):\\n            return []\\n        \\n        ## fill the vertical and horizontal matrix\\n        for i in range(k):\\n            for j in range(k):\\n                first[i][j] = verti_order[i]\\n                second[i][j] = hori_order[j]\\n        \\n        ## overlap the vertical and horizontal matrix to get the final matrix\\n        for i in range(k):\\n            for j in range(k):\\n                if (first[i][j] == second[i][j]):\\n                    returner[i][j] = first[i][j]\\n        return returner\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2565851,
                "title": "c-why-topological-sort-full-explanation",
                "content": "```\\n /* we ought to detect an order in whcih we have to place elemnt and also if some cycle is present no ans can be formed which can be done very smoothly by Kahns algo */\\n    \\n    vector<int> kahn(int n,vector<vector<int>> edge)\\n    {\\n        map<int,vector<int>> adj;\\n        map<int,int> indegree;\\n        for(auto i:edge)\\n        {\\n            adj[i[0]].push_back(i[1]);\\n            indegree[i[1]]++;\\n        }\\n        \\n        queue<int> q;\\n        \\n        for(int i=1;i<=n;i++)\\n            if(indegree[i]==0)\\n                q.push(i);\\n        \\n        vector<int> ans;\\n        int visited=0;\\n        while(!q.empty())\\n        {\\n            auto temp=q.front();\\n            q.pop();\\n            \\n            ans.push_back(temp);\\n            visited++;\\n            \\n            for(auto child:adj[temp])\\n            {\\n                indegree[child]--;\\n                if(indegree[child]==0)  //if indegree 0 then push in queue\\n                    q.push(child);\\n            }\\n        }\\n        \\n        if(visited!=n)  //cycle detected empty vector returned\\n            return {};\\n        \\n        return ans;\\n    }\\n    \\n    \\nvector<vector<int>> buildMatrix(int n, vector<vector<int>>& row, vector<vector<int>>& col) {\\n    \\n    vector<int> rowOrder=kahn(n,row); //rowOrder ye btayega kaunsi row me kaunsa ele ayega\\n    vector<int> colOrder=kahn(n,col); //colOrder ye btayega kaunsi col me kaunsa ele ayega\\n    \\n    if(!rowOrder.size() or !colOrder.size())\\n        return {};\\n    \\n    map<int,int> m;\\n    for(int i=0;i<rowOrder.size();i++)\\n       m[rowOrder[i]]=i;     //is row pe ayunga mai map me store krwaliya\\n    \\n    vector<vector<int>> ans(n,vector<int>(n,0));\\n    \\n    for(int j=0;j<colOrder.size();j++)\\n    {\\n        int ele=colOrder[j];  //ele kaunsa dalna\\n        int rowToPlace=m[ele]; //kaunsi row pe dalna\\n        ans[rowToPlace][j]=ele; //row,col wali jgh pe ele daldo\\n    }\\n    return ans;\\n}",
                "solutionTags": [],
                "code": "```\\n /* we ought to detect an order in whcih we have to place elemnt and also if some cycle is present no ans can be formed which can be done very smoothly by Kahns algo */\\n    \\n    vector<int> kahn(int n,vector<vector<int>> edge)\\n    {\\n        map<int,vector<int>> adj;\\n        map<int,int> indegree;\\n        for(auto i:edge)\\n        {\\n            adj[i[0]].push_back(i[1]);\\n            indegree[i[1]]++;\\n        }\\n        \\n        queue<int> q;\\n        \\n        for(int i=1;i<=n;i++)\\n            if(indegree[i]==0)\\n                q.push(i);\\n        \\n        vector<int> ans;\\n        int visited=0;\\n        while(!q.empty())\\n        {\\n            auto temp=q.front();\\n            q.pop();\\n            \\n            ans.push_back(temp);\\n            visited++;\\n            \\n            for(auto child:adj[temp])\\n            {\\n                indegree[child]--;\\n                if(indegree[child]==0)  //if indegree 0 then push in queue\\n                    q.push(child);\\n            }\\n        }\\n        \\n        if(visited!=n)  //cycle detected empty vector returned\\n            return {};\\n        \\n        return ans;\\n    }\\n    \\n    \\nvector<vector<int>> buildMatrix(int n, vector<vector<int>>& row, vector<vector<int>>& col) {\\n    \\n    vector<int> rowOrder=kahn(n,row); //rowOrder ye btayega kaunsi row me kaunsa ele ayega\\n    vector<int> colOrder=kahn(n,col); //colOrder ye btayega kaunsi col me kaunsa ele ayega\\n    \\n    if(!rowOrder.size() or !colOrder.size())\\n        return {};\\n    \\n    map<int,int> m;\\n    for(int i=0;i<rowOrder.size();i++)\\n       m[rowOrder[i]]=i;     //is row pe ayunga mai map me store krwaliya\\n    \\n    vector<vector<int>> ans(n,vector<int>(n,0));\\n    \\n    for(int j=0;j<colOrder.size();j++)\\n    {\\n        int ele=colOrder[j];  //ele kaunsa dalna\\n        int rowToPlace=m[ele]; //kaunsi row pe dalna\\n        ans[rowToPlace][j]=ele; //row,col wali jgh pe ele daldo\\n    }\\n    return ans;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2557868,
                "title": "topological-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> topologicalSort(vector<int> adj[],int k,int indeg[],int count){\\n        queue<int> q;\\n        for(int i=0;i<k;i++){\\n            if(indeg[i]==0){q.push(i);}\\n        }\\n        vector<int> ans={};\\n        while(!q.empty()){\\n            int u=q.front();q.pop();\\n            ans.push_back(u);\\n            for(int v:adj[u]){\\n                indeg[v]--;\\n                if(indeg[v]==0){\\n                    q.push(v);\\n                }\\n            }\\n        }\\n        if(ans.size()==count){return ans;}\\n        return {};\\n    }\\n    \\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        vector<int> adjr[k];\\n        vector<int> adjc[k];\\n        for(int i=0;i<rowConditions.size();i++){\\n            adjr[rowConditions[i][0]-1].push_back(rowConditions[i][1]-1);\\n        }\\n        for(int i=0;i<colConditions.size();i++){\\n            adjc[colConditions[i][0]-1].push_back(colConditions[i][1]-1);\\n        }\\n        int countr=0,countc=0;\\n        bool visited[k];\\n        int indeg[k];\\n        for(int i=0;i<k;i++){\\n            visited[i]=false;indeg[i]=-1;\\n        }\\n        for(int i=0;i<k;i++){\\n            if(adjr[i].size()==0){continue;}\\n            visited[i]=true;\\n         for(int u:adjr[i]){\\n             visited[u]=true;\\n             if(indeg[u]<0){indeg[u]=0;}\\n             indeg[u]++;\\n         }   \\n        }\\n        for(int i=0;i<k;i++){\\n            if(visited[i]){\\n                countr++;\\n            }\\n        }\\n        vector<int> v1=topologicalSort(adjr,k,indeg,countr);\\n        if(v1.size()==0){return {};}\\n        for(int i=0;i<k;i++){\\n            visited[i]=false;indeg[i]=-1;\\n        }\\n        for(int i=0;i<k;i++){\\n            if(adjc[i].size()==0){continue;}\\n            visited[i]=true;\\n         for(int u:adjc[i]){\\n             visited[u]=true;\\n             if(indeg[u]<0){indeg[u]=0;}\\n             indeg[u]++;\\n         }   \\n        }\\n        for(int i=0;i<k;i++){\\n            if(visited[i]){\\n                countc++;\\n            }\\n        }\\n        vector<int> v2=topologicalSort(adjc,k,indeg,countc);\\n        if(v2.size()==0){return {};}\\n        vector<vector<int>> res;\\n        vector<int> v;\\n        for(int i=0;i<k;i++){v.push_back(0);}\\n        for(int i=0;i<k;i++){\\n            res.push_back(v);}\\n        pair<int,int> arr[k];\\n        for(int i=0;i<k;i++){\\n            arr[i].first=-1;\\n            arr[i].second=-1;\\n        }\\n        for(int i=0;i<v1.size();i++){\\n            arr[v1[i]].first=i;\\n        }\\n        for(int i=0;i<v2.size();i++){\\n            arr[v2[i]].second=i;\\n        }\\n        int indr=0,indc=0;\\n        for(int i=0;i<k;i++){\\n            if(arr[i].first==-1){\\n                arr[i].first=indr;\\n                indr++;\\n            }\\n            if(arr[i].second==-1){\\n                arr[i].second=indc;\\n                indc++;\\n            }\\n        }\\n        for(int i=0;i<k;i++){\\n            res[arr[i].first][arr[i].second]=i+1;\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> topologicalSort(vector<int> adj[],int k,int indeg[],int count){\\n        queue<int> q;\\n        for(int i=0;i<k;i++){\\n            if(indeg[i]==0){q.push(i);}",
                "codeTag": "Java"
            },
            {
                "id": 2557848,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    //We will create an adjacency matrix that stores the connections between the various nodes\\n    public int[][] buildMatrix(int k, int[][] rowConditions, int[][] colConditions) {\\n        int[][] toret = new int[k][k];\\n        \\n        List<Integer> rowOrder = orderedNo(k, rowConditions);\\n        List<Integer> colOrder = orderedNo(k, colConditions);\\n        if(rowOrder.size() != k || colOrder.size() != k){\\n            return new int[0][];\\n        }\\n        \\n        HashMap<Integer, int[]> hMap = new HashMap<>();\\n        for(int i = 1; i <= k; i++){\\n            hMap.put(i, new int[2]);\\n        }\\n        \\n        for(int i = 0; i < rowOrder.size(); i++){\\n            int currNo = rowOrder.get(i);\\n            hMap.get(currNo)[0] = i;\\n        }\\n        \\n        for(int i = 0; i < colOrder.size(); i++){\\n            int currNo = colOrder.get(i);\\n            hMap.get(currNo)[1] = i;\\n        }\\n        \\n        for(int key: hMap.keySet()){\\n            int row = hMap.get(key)[0];\\n            int col = hMap.get(key)[1];\\n            toret[row][col] = key;\\n        }\\n        \\n        return toret;\\n    }\\n    \\n    public List<Integer> orderedNo(int k, int[][] conditions){\\n        //An array contains integers from 1 to k\\n        int[] store = new int[k+1];\\n        HashMap<Integer, ArrayList<Integer>> hMap = new HashMap<>();\\n        for(int i = 1; i <= k; i++){\\n            hMap.put(i, new ArrayList<Integer>());\\n        }\\n        \\n        for(int[] condition: conditions){\\n            int source = condition[0];\\n            int target = condition[1];\\n            \\n            store[target]++; //There is a source connected to it\\n            hMap.get(source).add(target); //Have to add the target to the ArrayList to clear later\\n        }\\n        \\n        ArrayList<Integer> inputOrder = new ArrayList<>();\\n        ArrayList<Integer> toClear = new ArrayList<>();\\n        for(int i = 1; i < store.length; i++){\\n            if(store[i] == 0){\\n                toClear.add(i);\\n            }\\n        }\\n        \\n        //Clear the toClear\\n        while(toClear.size() != 0){\\n            //clear the next vertices that are connected to next\\n            ArrayList<Integer> temp = new ArrayList<>();\\n            for(int next: toClear){\\n                //add next because to maintain the order\\n                inputOrder.add(next);\\n                \\n                List<Integer> targets = hMap.get(next);\\n                for(int target: targets){\\n                    store[target] --;\\n                    if(store[target] == 0){\\n                        temp.add(target);\\n                    }\\n                }\\n            }\\n            \\n            toClear = temp;\\n        }\\n        \\n        return inputOrder;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    //We will create an adjacency matrix that stores the connections between the various nodes\\n    public int[][] buildMatrix(int k, int[][] rowConditions, int[][] colConditions) {\\n        int[][] toret = new int[k][k];\\n        \\n        List<Integer> rowOrder = orderedNo(k, rowConditions);\\n        List<Integer> colOrder = orderedNo(k, colConditions);\\n        if(rowOrder.size() != k || colOrder.size() != k){\\n            return new int[0][];\\n        }\\n        \\n        HashMap<Integer, int[]> hMap = new HashMap<>();\\n        for(int i = 1; i <= k; i++){\\n            hMap.put(i, new int[2]);\\n        }\\n        \\n        for(int i = 0; i < rowOrder.size(); i++){\\n            int currNo = rowOrder.get(i);\\n            hMap.get(currNo)[0] = i;\\n        }\\n        \\n        for(int i = 0; i < colOrder.size(); i++){\\n            int currNo = colOrder.get(i);\\n            hMap.get(currNo)[1] = i;\\n        }\\n        \\n        for(int key: hMap.keySet()){\\n            int row = hMap.get(key)[0];\\n            int col = hMap.get(key)[1];\\n            toret[row][col] = key;\\n        }\\n        \\n        return toret;\\n    }\\n    \\n    public List<Integer> orderedNo(int k, int[][] conditions){\\n        //An array contains integers from 1 to k\\n        int[] store = new int[k+1];\\n        HashMap<Integer, ArrayList<Integer>> hMap = new HashMap<>();\\n        for(int i = 1; i <= k; i++){\\n            hMap.put(i, new ArrayList<Integer>());\\n        }\\n        \\n        for(int[] condition: conditions){\\n            int source = condition[0];\\n            int target = condition[1];\\n            \\n            store[target]++; //There is a source connected to it\\n            hMap.get(source).add(target); //Have to add the target to the ArrayList to clear later\\n        }\\n        \\n        ArrayList<Integer> inputOrder = new ArrayList<>();\\n        ArrayList<Integer> toClear = new ArrayList<>();\\n        for(int i = 1; i < store.length; i++){\\n            if(store[i] == 0){\\n                toClear.add(i);\\n            }\\n        }\\n        \\n        //Clear the toClear\\n        while(toClear.size() != 0){\\n            //clear the next vertices that are connected to next\\n            ArrayList<Integer> temp = new ArrayList<>();\\n            for(int next: toClear){\\n                //add next because to maintain the order\\n                inputOrder.add(next);\\n                \\n                List<Integer> targets = hMap.get(next);\\n                for(int target: targets){\\n                    store[target] --;\\n                    if(store[target] == 0){\\n                        temp.add(target);\\n                    }\\n                }\\n            }\\n            \\n            toClear = temp;\\n        }\\n        \\n        return inputOrder;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2548996,
                "title": "c-topological-sort-using-bfs",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& r, vector<vector<int>>& c) \\n    {\\n        vector<vector<int>> a(k, vector<int>(k,0));\\n        \\n        vector<vector<int>> tmp;\\n        \\n        vector<int> rt, ct;\\n        \\n        vector<int> adjr[k+1], adjc[k+1];\\n        \\n        for(int i=0;i<r.size();i++)\\n        {\\n            adjr[r[i][0]].push_back(r[i][1]);\\n        }\\n        \\n        for(int i=0;i<c.size();i++)\\n        {\\n            adjc[c[i][0]].push_back(c[i][1]);\\n        }\\n        \\n        unordered_map<int,int> indegr, indegc;\\n        \\n        for(int i=0;i<r.size();i++)\\n        {\\n            indegr[r[i][1]]++;\\n        }\\n        \\n        for(int i=0;i<c.size();i++)\\n        {\\n            indegc[c[i][1]]++;\\n        }\\n        \\n        queue<int> q,q1;\\n        \\n        for(int i=1;i<=k;i++)\\n        {\\n            if(indegr[i] == 0)\\n            {\\n                q.push(i);\\n            }\\n        }\\n        \\n        for(int i=1;i<=k;i++)\\n        {\\n            if(indegc[i] == 0)\\n            {\\n                q1.push(i);\\n            }\\n        }\\n        \\n        int cnt = 0;\\n        \\n        while(!q.empty())\\n        {\\n            int v = q.front();\\n            cnt++;\\n            rt.push_back(v);\\n            q.pop();\\n            \\n            for(auto it:adjr[v])\\n            {\\n                indegr[it]--;\\n                \\n                if(indegr[it] == 0)\\n                    q.push(it);\\n            }\\n        }\\n        \\n        if(cnt != k) return tmp;\\n        \\n        cnt = 0;\\n        \\n        while(!q1.empty())\\n        {\\n            int v = q1.front();\\n            cnt++;\\n            ct.push_back(v);\\n            q1.pop();\\n            \\n            for(auto it:adjc[v])\\n            {\\n                indegc[it]--;\\n                \\n                if(indegc[it] == 0)\\n                    q1.push(it);\\n            }\\n        }\\n        \\n        if(cnt != k) return tmp;\\n\\n        for(int i=0;i<rt.size();i++)\\n        {\\n            int x = rt[i];\\n            \\n            for(int j=0;j<ct.size();j++)\\n            {\\n                if(ct[j] == x)\\n                {\\n                    a[i][j] = x;\\n                }\\n            }\\n        }\\n        \\n        return a;\\n    }\\n\\t};",
                "solutionTags": [
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& r, vector<vector<int>>& c) \\n    {\\n        vector<vector<int>> a(k, vector<int>(k,0));\\n        \\n        vector<vector<int>> tmp;\\n        \\n        vector<int> rt, ct;\\n        \\n        vector<int> adjr[k+1], adjc[k+1];\\n        \\n        for(int i=0;i<r.size();i++)\\n        {\\n            adjr[r[i][0]].push_back(r[i][1]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2546812,
                "title": "c-topological-sort-checking-cycle-while-building-the-sorted-array",
                "content": "The idea is to use a topological sort for row and col\\n- Check cycle while doing the topological sort\\n\\n```\\nclass Solution {\\npublic:\\n    vector<bool> onPath;\\n    vector<bool> visited;\\n    bool hasCycle = false;\\n    \\n    void topSort(unordered_map<int, set<int>>& adj, int s, vector<int>& ans) {\\n        if (onPath[s] or hasCycle) {\\n            hasCycle = 1;\\n            return;\\n        }\\n        if (visited[s]) {\\n            return;\\n        }\\n        visited[s] = 1;\\n        onPath[s] = 1;\\n        for (int t : adj[s]) {\\n            topSort(adj, t, ans);\\n        }\\n        onPath[s] = 0;\\n        ans.push_back(s);\\n    }\\n    \\n    \\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        unordered_map<int, set<int>> rowAdj;\\n        unordered_map<int, set<int>> colAdj;\\n        visited.assign(k+1, 0);\\n        onPath.assign(k+1, 0);\\n        \\n        for(int i = 1; i <= k; i++){\\n            rowAdj[i] = set<int>();\\n            colAdj[i] = set<int>();\\n        }\\n        for(auto &vec : rowConditions){\\n            rowAdj[vec[1]].insert(vec[0]);\\n        }\\n        for(auto &vec : colConditions){\\n            colAdj[vec[1]].insert(vec[0]);\\n        }\\n        \\n        vector<vector<int>>res;\\n        vector<int> postorderR;\\n        vector<int> postorderC;\\n        \\n        for(auto &it : rowAdj){\\n            topSort(rowAdj, it.first, postorderR);\\n            if(hasCycle) return res; \\n        }\\n        \\n        visited.assign(k+1, 0);\\n        onPath.assign(k+1, 0);\\n        \\n        for(auto &it : colAdj){\\n            topSort(colAdj, it.first, postorderC);\\n            if(hasCycle) return res; \\n        }\\n        \\n        map<int, int> mapR;\\n        \\n        for(int i = 0; i < postorderR.size(); i++){\\n            mapR[postorderR[i]] = i;\\n        }\\n     \\n        vector<vector<int>> ans(k, vector<int>(k, 0));\\n        \\n        for(int i = 0; i < postorderC.size(); i++){\\n            ans[mapR[postorderC[i]]][i] = postorderC[i];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool> onPath;\\n    vector<bool> visited;\\n    bool hasCycle = false;\\n    \\n    void topSort(unordered_map<int, set<int>>& adj, int s, vector<int>& ans) {\\n        if (onPath[s] or hasCycle) {\\n            hasCycle = 1;\\n            return;\\n        }\\n        if (visited[s]) {\\n            return;\\n        }\\n        visited[s] = 1;\\n        onPath[s] = 1;\\n        for (int t : adj[s]) {\\n            topSort(adj, t, ans);\\n        }\\n        onPath[s] = 0;\\n        ans.push_back(s);\\n    }\\n    \\n    \\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        unordered_map<int, set<int>> rowAdj;\\n        unordered_map<int, set<int>> colAdj;\\n        visited.assign(k+1, 0);\\n        onPath.assign(k+1, 0);\\n        \\n        for(int i = 1; i <= k; i++){\\n            rowAdj[i] = set<int>();\\n            colAdj[i] = set<int>();\\n        }\\n        for(auto &vec : rowConditions){\\n            rowAdj[vec[1]].insert(vec[0]);\\n        }\\n        for(auto &vec : colConditions){\\n            colAdj[vec[1]].insert(vec[0]);\\n        }\\n        \\n        vector<vector<int>>res;\\n        vector<int> postorderR;\\n        vector<int> postorderC;\\n        \\n        for(auto &it : rowAdj){\\n            topSort(rowAdj, it.first, postorderR);\\n            if(hasCycle) return res; \\n        }\\n        \\n        visited.assign(k+1, 0);\\n        onPath.assign(k+1, 0);\\n        \\n        for(auto &it : colAdj){\\n            topSort(colAdj, it.first, postorderC);\\n            if(hasCycle) return res; \\n        }\\n        \\n        map<int, int> mapR;\\n        \\n        for(int i = 0; i < postorderR.size(); i++){\\n            mapR[postorderR[i]] = i;\\n        }\\n     \\n        vector<vector<int>> ans(k, vector<int>(k, 0));\\n        \\n        for(int i = 0; i < postorderC.size(); i++){\\n            ans[mapR[postorderC[i]]][i] = postorderC[i];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2540671,
                "title": "topological-sort-explanations",
                "content": "# Topological Sort\\n\\n\\n## Prerequisites\\n\\nEquiped with knowledge and confident of perform Depth-First-search, Hashmap, Vector.\\n\\n## Intuition\\n\\nTopological Sort is a graph algorithm that can only implement on a DAG(Directed Acyclic Graph). If it\\'s not a DAG, it will therefore unable to sort.\\n\\nIt deals with problems that have given one-to-one relations, and use that information to sort.\\n\\nEg. a is at the right of b, c is at the right of b.\\nTherefore, there\\'s two answers, one is `[b, a, c]`, and other is `[b, c, a]`.\\n\\n## Implementation\\n\\n1. Build an Ajacency List.\\n2. use DFS to find the end of this directed part of graph.\\n3. return false if the graph is asylic. (using hashmap, since if one node is visited twice in the same search, it\\'s asylic.)\\n4. make sure all parts of graph is visited.\\n5. and you\\'re all set.\\n\\n## Example Problems 1: \\n\\n[210. Course Schedule II](https://leetcode.com/problems/course-schedule-ii/)\\n\\n```cpp\\nvector<vector<int>> prereq;\\nvector<bool> vis;\\nunordered_set<int> st;\\nvector<int> res;\\nvector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n    prereq.resize(numCourses);\\n    vis.resize(numCourses, false);\\n    for(auto it : prerequisites){\\n        prereq[it[0]].push_back(it[1]);\\n    }\\n    for(int i = 0; i < numCourses; i++){\\n        st.clear();\\n        if(vis[i])continue;\\n        if(dfs(i)) res.push_back(i);\\n        else return {};\\n    }\\n    return res;\\n}\\n\\nbool dfs(int num) {\\n    if(st.find(num) != st.end()) return false;\\n    st.insert(num);\\n    for(auto it : prereq[num]) {\\n        if(vis[it])continue;\\n        if(dfs(it)) res.push_back(it);\\n        else return false;\\n    }\\n    vis[num] = true;\\n    return true;\\n    \\n}\\n```\\n\\n## Expample Problem 2:\\n\\n[2392. Build a Matrix With Conditions](https://leetcode.com/problems/build-a-matrix-with-conditions/)\\n\\n```cpp\\nvector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n\\tvector<int> row(topologicalSort(k, rowConditions));\\n\\tvector<int> col(topologicalSort(k, colConditions));\\n\\tif(row.size() != k || col.size() != k) return {};\\n\\tvector<vector<int>> rc(k+1, vector<int>(2,0));\\n\\tfor(int i = 0; i < k; i++) {\\n\\t\\trc[row[i]][0] = i;\\n\\t\\trc[col[i]][1] = i;\\n\\t}\\n\\tvector<vector<int>> result(k, vector<int> (k, 0));\\n\\tfor(int i = 1; i <= k; i++)\\n\\t\\tresult[rc[i][0]][rc[i][1]] = i;\\n\\treturn result;\\n}\\n\\nvector<int> res;\\nvector<int> topologicalSort(int k, vector<vector<int>>& conditions) {\\n\\tres.clear();\\n\\tvector<vector<int>> adj(k+1); // adjacency list\\n\\tfor(auto i : conditions) {\\n\\t\\tadj[i[0]].push_back(i[1]);\\n\\t}\\n\\tvector<bool> vis(k+1, false);\\n\\tunordered_set<int> st;\\n\\tfor(int i = 1; i <= k; i++) {\\n\\t\\tst.clear();\\n\\t\\tif(!vis[i] && !dfs(i,adj,vis,st))\\n\\t\\t\\treturn {};\\n\\t}\\n\\treverse(res.begin(), res.end());\\n\\treturn res;\\n}\\n\\nbool dfs(int num, vector<vector<int>>& adj, vector<bool>& vis, unordered_set<int>& st) {\\n\\tif(st.find(num) != st.end()) return false;\\n\\tst.insert(num);\\n\\tfor(int i : adj[num]) {\\n\\t\\tif(!vis[i] && !dfs(i,adj,vis,st)) \\n\\t\\t\\treturn false;\\n\\t}\\n\\tvis[num] = true;\\n\\tres.push_back(num);\\n\\treturn true;\\n}\\n```\\n",
                "solutionTags": [
                    "Topological Sort"
                ],
                "code": "```cpp\\nvector<vector<int>> prereq;\\nvector<bool> vis;\\nunordered_set<int> st;\\nvector<int> res;\\nvector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n    prereq.resize(numCourses);\\n    vis.resize(numCourses, false);\\n    for(auto it : prerequisites){\\n        prereq[it[0]].push_back(it[1]);\\n    }\\n    for(int i = 0; i < numCourses; i++){\\n        st.clear();\\n        if(vis[i])continue;\\n        if(dfs(i)) res.push_back(i);\\n        else return {};\\n    }\\n    return res;\\n}\\n\\nbool dfs(int num) {\\n    if(st.find(num) != st.end()) return false;\\n    st.insert(num);\\n    for(auto it : prereq[num]) {\\n        if(vis[it])continue;\\n        if(dfs(it)) res.push_back(it);\\n        else return false;\\n    }\\n    vis[num] = true;\\n    return true;\\n    \\n}\\n```\n```cpp\\nvector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n\\tvector<int> row(topologicalSort(k, rowConditions));\\n\\tvector<int> col(topologicalSort(k, colConditions));\\n\\tif(row.size() != k || col.size() != k) return {};\\n\\tvector<vector<int>> rc(k+1, vector<int>(2,0));\\n\\tfor(int i = 0; i < k; i++) {\\n\\t\\trc[row[i]][0] = i;\\n\\t\\trc[col[i]][1] = i;\\n\\t}\\n\\tvector<vector<int>> result(k, vector<int> (k, 0));\\n\\tfor(int i = 1; i <= k; i++)\\n\\t\\tresult[rc[i][0]][rc[i][1]] = i;\\n\\treturn result;\\n}\\n\\nvector<int> res;\\nvector<int> topologicalSort(int k, vector<vector<int>>& conditions) {\\n\\tres.clear();\\n\\tvector<vector<int>> adj(k+1); // adjacency list\\n\\tfor(auto i : conditions) {\\n\\t\\tadj[i[0]].push_back(i[1]);\\n\\t}\\n\\tvector<bool> vis(k+1, false);\\n\\tunordered_set<int> st;\\n\\tfor(int i = 1; i <= k; i++) {\\n\\t\\tst.clear();\\n\\t\\tif(!vis[i] && !dfs(i,adj,vis,st))\\n\\t\\t\\treturn {};\\n\\t}\\n\\treverse(res.begin(), res.end());\\n\\treturn res;\\n}\\n\\nbool dfs(int num, vector<vector<int>>& adj, vector<bool>& vis, unordered_set<int>& st) {\\n\\tif(st.find(num) != st.end()) return false;\\n\\tst.insert(num);\\n\\tfor(int i : adj[num]) {\\n\\t\\tif(!vis[i] && !dfs(i,adj,vis,st)) \\n\\t\\t\\treturn false;\\n\\t}\\n\\tvis[num] = true;\\n\\tres.push_back(num);\\n\\treturn true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2540574,
                "title": "topological-sort-concise-and-elegant",
                "content": "```\\nvector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n\\tvector<int> row(topologicalSort(k, rowConditions));\\n\\tvector<int> col(topologicalSort(k, colConditions));\\n\\tif(row.size() != k || col.size() != k) return {};\\n\\tvector<vector<int>> rc(k+1, vector<int>(2,0));\\n\\tfor(int i = 0; i < k; i++) {\\n\\t\\trc[row[i]][0] = i;\\n\\t\\trc[col[i]][1] = i;\\n\\t}\\n\\tvector<vector<int>> result(k, vector<int> (k, 0));\\n\\tfor(int i = 1; i <= k; i++)\\n\\t\\tresult[rc[i][0]][rc[i][1]] = i;\\n\\treturn result;\\n}\\n\\nvector<int> res;\\nvector<int> topologicalSort(int k, vector<vector<int>>& conditions) {\\n\\tres.clear();\\n\\tvector<vector<int>> adj(k+1); // adjacency list\\n\\tfor(auto i : conditions) {\\n\\t\\tadj[i[0]].push_back(i[1]);\\n\\t}\\n\\tvector<bool> vis(k+1, false);\\n\\tunordered_set<int> st;\\n\\tfor(int i = 1; i <= k; i++) {\\n\\t\\tst.clear();\\n\\t\\tif(!vis[i] && !dfs(i,adj,vis,st))\\n\\t\\t\\treturn {};\\n\\t}\\n\\treverse(res.begin(), res.end());\\n\\treturn res;\\n}\\n\\nbool dfs(int num, vector<vector<int>>& adj, vector<bool>& vis, unordered_set<int>& st) {\\n\\tif(st.find(num) != st.end()) return false;\\n\\tst.insert(num);\\n\\tfor(int i : adj[num]) {\\n\\t\\tif(!vis[i] && !dfs(i,adj,vis,st)) \\n\\t\\t\\treturn false;\\n\\t}\\n\\tvis[num] = true;\\n\\tres.push_back(num);\\n\\treturn true;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n\\tvector<int> row(topologicalSort(k, rowConditions));\\n\\tvector<int> col(topologicalSort(k, colConditions));\\n\\tif(row.size() != k || col.size() != k) return {};\\n\\tvector<vector<int>> rc(k+1, vector<int>(2,0));\\n\\tfor(int i = 0; i < k; i++) {\\n\\t\\trc[row[i]][0] = i;\\n\\t\\trc[col[i]][1] = i;\\n\\t}\\n\\tvector<vector<int>> result(k, vector<int> (k, 0));\\n\\tfor(int i = 1; i <= k; i++)\\n\\t\\tresult[rc[i][0]][rc[i][1]] = i;\\n\\treturn result;\\n}\\n\\nvector<int> res;\\nvector<int> topologicalSort(int k, vector<vector<int>>& conditions) {\\n\\tres.clear();\\n\\tvector<vector<int>> adj(k+1); // adjacency list\\n\\tfor(auto i : conditions) {\\n\\t\\tadj[i[0]].push_back(i[1]);\\n\\t}\\n\\tvector<bool> vis(k+1, false);\\n\\tunordered_set<int> st;\\n\\tfor(int i = 1; i <= k; i++) {\\n\\t\\tst.clear();\\n\\t\\tif(!vis[i] && !dfs(i,adj,vis,st))\\n\\t\\t\\treturn {};\\n\\t}\\n\\treverse(res.begin(), res.end());\\n\\treturn res;\\n}\\n\\nbool dfs(int num, vector<vector<int>>& adj, vector<bool>& vis, unordered_set<int>& st) {\\n\\tif(st.find(num) != st.end()) return false;\\n\\tst.insert(num);\\n\\tfor(int i : adj[num]) {\\n\\t\\tif(!vis[i] && !dfs(i,adj,vis,st)) \\n\\t\\t\\treturn false;\\n\\t}\\n\\tvis[num] = true;\\n\\tres.push_back(num);\\n\\treturn true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2535796,
                "title": "kahn-s-algorithm-topological-sort",
                "content": "```\\nclass Solution:\\n    def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:\\n        \\n        rowIndegree, rowAdajency = self.buildIndegree(k, rowConditions)\\n        colIndegree, colAdajency = self.buildIndegree(k, colConditions)\\n        topoRowOrder = self.kahnAlgorithm(rowIndegree, rowAdajency)\\n        topoColOrder = self.kahnAlgorithm(colIndegree, colAdajency)\\n        #print(topoRowOrder, topoColOrder)\\n        if(len(topoRowOrder)!=k or len(topoColOrder)!=k):\\n            return []\\n        order = [[0,0] for i in range(k)]\\n        for i in range(k):\\n            order[topoRowOrder[i]-1][0]=i\\n            order[topoColOrder[i]-1][1]=i\\n        matrix = [[0 for j in range(k)] for i in range(k)]\\n        \\n        for i in range(len(order)):\\n            u, v = order[i]\\n            matrix[u][v]=i+1\\n        return matrix\\n        \\n    def kahnAlgorithm(self, indegree, adajency):\\n        queue = []\\n        for i, j in indegree.items():\\n            #print(i,j)\\n            if(j==0):\\n                queue.append(i)\\n        result = []\\n        while(len(queue)):\\n            n=len(queue)\\n            \\n            for i in range(n):\\n                node = queue.pop(0)\\n                result.append(node)\\n                for j in adajency[node]:\\n                    indegree[j]-=1\\n                    if(indegree[j]==0):\\n                        queue.append(j)\\n        return result\\n        \\n    def buildIndegree(self, k, matrix):\\n        \\n        indegree = dict()\\n        adajencyList = dict()\\n        for i in range(k):\\n            indegree[i+1]=0\\n            adajencyList[i+1]=[]\\n        for u, v in matrix:\\n            indegree[v]+=1\\n            adajencyList[u].append(v)\\n    \\n        return (indegree, adajencyList)\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution:\\n    def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:\\n        \\n        rowIndegree, rowAdajency = self.buildIndegree(k, rowConditions)\\n        colIndegree, colAdajency = self.buildIndegree(k, colConditions)\\n        topoRowOrder = self.kahnAlgorithm(rowIndegree, rowAdajency)\\n        topoColOrder = self.kahnAlgorithm(colIndegree, colAdajency)\\n        #print(topoRowOrder, topoColOrder)\\n        if(len(topoRowOrder)!=k or len(topoColOrder)!=k):\\n            return []\\n        order = [[0,0] for i in range(k)]\\n        for i in range(k):\\n            order[topoRowOrder[i]-1][0]=i\\n            order[topoColOrder[i]-1][1]=i\\n        matrix = [[0 for j in range(k)] for i in range(k)]\\n        \\n        for i in range(len(order)):\\n            u, v = order[i]\\n            matrix[u][v]=i+1\\n        return matrix\\n        \\n    def kahnAlgorithm(self, indegree, adajency):\\n        queue = []\\n        for i, j in indegree.items():\\n            #print(i,j)\\n            if(j==0):\\n                queue.append(i)\\n        result = []\\n        while(len(queue)):\\n            n=len(queue)\\n            \\n            for i in range(n):\\n                node = queue.pop(0)\\n                result.append(node)\\n                for j in adajency[node]:\\n                    indegree[j]-=1\\n                    if(indegree[j]==0):\\n                        queue.append(j)\\n        return result\\n        \\n    def buildIndegree(self, k, matrix):\\n        \\n        indegree = dict()\\n        adajencyList = dict()\\n        for i in range(k):\\n            indegree[i+1]=0\\n            adajencyList[i+1]=[]\\n        for u, v in matrix:\\n            indegree[v]+=1\\n            adajencyList[u].append(v)\\n    \\n        return (indegree, adajencyList)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2528517,
                "title": "java-solution-graph-topological-sort-detect-cycle-in-a-graph",
                "content": "class Solution {\\n    public int[][] buildMatrix(int k, int[][] rowConditions, int[][] colConditions) {\\n        Graph row = new Graph(k+1);\\n        \\n        for (int i=0; i<rowConditions.length; i++) {\\n            row.addEdge(rowConditions[i][0], rowConditions[i][1]);\\n        }\\n        \\n        Graph col = new Graph(k+1);\\n        \\n        for (int i=0; i<colConditions.length; i++) {\\n            col.addEdge(colConditions[i][0], colConditions[i][1]);\\n        }\\n        \\n        if (isCyclic(row, k) || isCyclic(col, k)) {\\n            return new int[0][0];\\n        }\\n        \\n        Stack<Integer> getRow = topo(row, k);\\n        Stack<Integer> getCol = topo(col, k);\\n        \\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for (int i=0; i<k; i++) {\\n            map.put(getCol.get(k-1-i), i);\\n        }\\n        \\n        int[][] ans = new int[k][k];\\n        \\n        for (int i=0; i<k; i++) {\\n            ans[i][map.get(getRow.get(k-1-i))] = getRow.get(k-1-i);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    public Stack<Integer> topo(Graph g, int k) {\\n        Stack<Integer> s1 = new Stack<>();\\n        \\n        boolean[] visited = new boolean[k+1];\\n        \\n        for (int i=1; i<=k; i++) {\\n            if (!visited[i])\\n                DFS(g, i, visited, s1);\\n        }\\n        \\n        return s1;\\n    }\\n    \\n    public void DFS(Graph g, int current, boolean[] visited, Stack<Integer> s1) {\\n        visited[current] = true;\\n        \\n        for (int i=0; i<g.arr.get(current).size(); i++) {\\n            int v = g.arr.get(current).get(i);\\n            \\n            if (!visited[v]) {\\n                DFS(g, v, visited, s1);\\n            }\\n        }\\n        \\n        s1.push(current);\\n    }\\n    \\n    private boolean isCyclic(Graph g, int k) {\\n        boolean[] visited = new boolean[k+1];\\n        boolean[] recStack = new boolean[k+1];\\n          \\n        for (int i = 1; i <= k; i++)\\n            if (isCyclicUtil(g, i, visited, recStack))\\n                return true;\\n  \\n        return false;\\n    }\\n    \\n    public boolean isCyclicUtil(Graph g, int i, boolean[] visited, boolean[] recStack) {\\n        if (recStack[i])\\n            return true;\\n  \\n        if (visited[i])\\n            return false;\\n              \\n        visited[i] = true;\\n  \\n        recStack[i] = true;\\n        List<Integer> children = g.arr.get(i);\\n          \\n        for (Integer c: children)\\n            if (isCyclicUtil(g, c, visited, recStack))\\n                return true;\\n                  \\n        recStack[i] = false;\\n  \\n        return false;\\n    }\\n}\\n\\nclass Graph {\\n    int V;\\n    List<List<Integer>> arr = new ArrayList<>();\\n    \\n    public Graph(int V) {\\n        this.V = V;\\n        \\n        arr = new ArrayList<>();\\n        \\n        for (int i=0; i<V; i++) {\\n            arr.add(new ArrayList<>());\\n        }\\n    }\\n    \\n    public void addEdge(int u, int v) {\\n        arr.get(u).add(v);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "class Solution {\\n    public int[][] buildMatrix(int k, int[][] rowConditions, int[][] colConditions) {\\n        Graph row = new Graph(k+1);\\n        \\n        for (int i=0; i<rowConditions.length; i++) {\\n            row.addEdge(rowConditions[i][0], rowConditions[i][1]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2526890,
                "title": "c-dfs-based-topological-sort-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n  struct Node {\\n    int val = -1;\\n    int row = -1, col = -1;\\n    int maxRow = -1;\\n    int maxCol = -1;\\n    vector<int> up, down, left, right;\\n  };\\n  \\n  // Performs a depth first search based on the column conditions to determine what\\n  // the maximum column for a node could be.\\n  // Returns false if there is a cycle in the graph.\\n  bool dfsRight(int i, vector<Node>& graph, vector<bool>& inPath,\\n                vector<bool>& visited) {\\n    if (inPath[i]) {\\n      // Cycle detected.\\n      return false;\\n    }\\n    if (visited[i]) {\\n      return true;;\\n    }\\n    // The node is in the current dfs path now.\\n    inPath[i] = true;\\n    auto& node = graph[i];\\n    for (int childIdx : node.right) {\\n      auto& child = graph[childIdx];\\n      if (!dfsRight(childIdx, graph, inPath, visited)) return false;\\n      node.maxCol = min(node.maxCol, child.maxCol - 1);\\n    }\\n    // The node is not in the current dfs path anymore.\\n    inPath[i] = false;\\n    \\n    // This node has been processed now.\\n    visited[i] = true;\\n    return true;\\n  }\\n     \\n  // Performs a depth first search based on the row conditions to determine what\\n  // the maximum row for a node could be.\\n  // Returns false if there is a cycle in the graph.\\n  bool dfsDown(int i, vector<Node>& graph, vector<bool>& inPath,\\n                vector<bool>& visited) {\\n    if (inPath[i]) {\\n      // Cycle detected.\\n      return false;\\n    }\\n    if (visited[i]) {\\n      return true;\\n    }\\n    \\n    // The node is in the current dfs path now.\\n    inPath[i] = true;\\n    auto& node = graph[i];\\n    for (int childIdx : node.down) {\\n      auto& child = graph[childIdx];\\n      if (!dfsDown(childIdx, graph, inPath, visited)) return false;\\n      node.maxRow = min(node.maxRow, child.maxRow - 1);\\n    }\\n    // The node is not in the current dfs path anymore.\\n    inPath[i] = false;\\n    \\n    // This node has been processed now.\\n    visited[i] = true;\\n    return true;\\n  }\\n  \\n  vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n    vector<vector<int>> mat(k, vector<int>(k, 0));\\n    vector<Node> graph(k + 1);\\n    for (int i = 1; i <= k; ++i) {\\n      graph[i].val = i;\\n      graph[i].maxRow = k - 1;\\n      graph[i].maxCol = k - 1;\\n    }\\n\\n    // Build the graph for row conditions.\\n    for (auto& cond : rowConditions) {\\n      graph[cond[0]].down.push_back(cond[1]);\\n      graph[cond[1]].up.push_back(cond[0]);\\n    }\\n    // Build the graph for col conditions.\\n    for (auto& cond : colConditions) {\\n      graph[cond[0]].right.push_back(cond[1]);\\n      graph[cond[1]].left.push_back(cond[0]);\\n    }\\n\\n    // Whether the current node is in path while performing DFS, to detect cycles.\\n    vector<bool> inPathRight(k + 1, false), inPathDown(k + 1, false);\\n    // Whether the current node has already been processed.\\n    vector<bool> visitedRight(k + 1, false), visitedDown(k + 1, false);\\n    \\n    for (int i = 1; i <= k; ++i) {\\n      auto& node = graph[i];\\n      // Start a dfs from all the start points of the row graph.\\n      if (node.left.empty()) {\\n        node.maxCol = k - 1;\\n        // Return empty matrix if conditions cannot be satisfied.\\n        if (!dfsRight(i, graph, inPathRight, visitedRight))\\n          return vector<vector<int>>();\\n      }\\n      // Start a dfs from all the start points of the col graph.\\n      if (node.up.empty()) {\\n        node.maxRow = k - 1;\\n        // Return empty matrix if conditions cannot be satisfied.\\n        if (!dfsDown(i, graph, inPathDown, visitedDown))\\n          return vector<vector<int>>();\\n      }\\n    }\\n\\n    // Sort based on how far the node is supposed to be from the bottom edge\\n    // of the matrix so that we can appropriately assign a row value.\\n    sort(graph.begin(), graph.end(), [] (const auto& a, const auto& b) {\\n      return a.maxRow < b.maxRow;\\n    });\\n    for (int i = 1; i <= k; ++i) {\\n      graph[i].row = i - 1;\\n    }\\n\\n\\n    // Sort based on how far the node is supposed to be from the right edge\\n    // of the matrix so that we can appropriately assign a row value.\\n    sort(graph.begin(), graph.end(), [] (const auto& a, const auto& b) {\\n      return a.maxCol < b.maxCol;\\n    });\\n    for (int i = 1; i <= k; ++i) {\\n      graph[i].col = i - 1;\\n    }\\n\\n    // Place the nodes in the assigned rows and col.\\n    for (int i = 1; i <= k; ++i) {\\n      auto& node = graph[i];\\n      // The graph had a cycle if any node was unvisited.\\n      if (!visitedRight[node.val] || !visitedDown[node.val])\\n        return vector<vector<int>>();\\n      mat[node.row][node.col] = node.val;\\n    }\\n    return mat;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  struct Node {\\n    int val = -1;\\n    int row = -1, col = -1;\\n    int maxRow = -1;\\n    int maxCol = -1;\\n    vector<int> up, down, left, right;\\n  };\\n  \\n  // Performs a depth first search based on the column conditions to determine what\\n  // the maximum column for a node could be.\\n  // Returns false if there is a cycle in the graph.\\n  bool dfsRight(int i, vector<Node>& graph, vector<bool>& inPath,\\n                vector<bool>& visited) {\\n    if (inPath[i]) {\\n      // Cycle detected.\\n      return false;\\n    }\\n    if (visited[i]) {\\n      return true;;\\n    }\\n    // The node is in the current dfs path now.\\n    inPath[i] = true;\\n    auto& node = graph[i];\\n    for (int childIdx : node.right) {\\n      auto& child = graph[childIdx];\\n      if (!dfsRight(childIdx, graph, inPath, visited)) return false;\\n      node.maxCol = min(node.maxCol, child.maxCol - 1);\\n    }\\n    // The node is not in the current dfs path anymore.\\n    inPath[i] = false;\\n    \\n    // This node has been processed now.\\n    visited[i] = true;\\n    return true;\\n  }\\n     \\n  // Performs a depth first search based on the row conditions to determine what\\n  // the maximum row for a node could be.\\n  // Returns false if there is a cycle in the graph.\\n  bool dfsDown(int i, vector<Node>& graph, vector<bool>& inPath,\\n                vector<bool>& visited) {\\n    if (inPath[i]) {\\n      // Cycle detected.\\n      return false;\\n    }\\n    if (visited[i]) {\\n      return true;\\n    }\\n    \\n    // The node is in the current dfs path now.\\n    inPath[i] = true;\\n    auto& node = graph[i];\\n    for (int childIdx : node.down) {\\n      auto& child = graph[childIdx];\\n      if (!dfsDown(childIdx, graph, inPath, visited)) return false;\\n      node.maxRow = min(node.maxRow, child.maxRow - 1);\\n    }\\n    // The node is not in the current dfs path anymore.\\n    inPath[i] = false;\\n    \\n    // This node has been processed now.\\n    visited[i] = true;\\n    return true;\\n  }\\n  \\n  vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n    vector<vector<int>> mat(k, vector<int>(k, 0));\\n    vector<Node> graph(k + 1);\\n    for (int i = 1; i <= k; ++i) {\\n      graph[i].val = i;\\n      graph[i].maxRow = k - 1;\\n      graph[i].maxCol = k - 1;\\n    }\\n\\n    // Build the graph for row conditions.\\n    for (auto& cond : rowConditions) {\\n      graph[cond[0]].down.push_back(cond[1]);\\n      graph[cond[1]].up.push_back(cond[0]);\\n    }\\n    // Build the graph for col conditions.\\n    for (auto& cond : colConditions) {\\n      graph[cond[0]].right.push_back(cond[1]);\\n      graph[cond[1]].left.push_back(cond[0]);\\n    }\\n\\n    // Whether the current node is in path while performing DFS, to detect cycles.\\n    vector<bool> inPathRight(k + 1, false), inPathDown(k + 1, false);\\n    // Whether the current node has already been processed.\\n    vector<bool> visitedRight(k + 1, false), visitedDown(k + 1, false);\\n    \\n    for (int i = 1; i <= k; ++i) {\\n      auto& node = graph[i];\\n      // Start a dfs from all the start points of the row graph.\\n      if (node.left.empty()) {\\n        node.maxCol = k - 1;\\n        // Return empty matrix if conditions cannot be satisfied.\\n        if (!dfsRight(i, graph, inPathRight, visitedRight))\\n          return vector<vector<int>>();\\n      }\\n      // Start a dfs from all the start points of the col graph.\\n      if (node.up.empty()) {\\n        node.maxRow = k - 1;\\n        // Return empty matrix if conditions cannot be satisfied.\\n        if (!dfsDown(i, graph, inPathDown, visitedDown))\\n          return vector<vector<int>>();\\n      }\\n    }\\n\\n    // Sort based on how far the node is supposed to be from the bottom edge\\n    // of the matrix so that we can appropriately assign a row value.\\n    sort(graph.begin(), graph.end(), [] (const auto& a, const auto& b) {\\n      return a.maxRow < b.maxRow;\\n    });\\n    for (int i = 1; i <= k; ++i) {\\n      graph[i].row = i - 1;\\n    }\\n\\n\\n    // Sort based on how far the node is supposed to be from the right edge\\n    // of the matrix so that we can appropriately assign a row value.\\n    sort(graph.begin(), graph.end(), [] (const auto& a, const auto& b) {\\n      return a.maxCol < b.maxCol;\\n    });\\n    for (int i = 1; i <= k; ++i) {\\n      graph[i].col = i - 1;\\n    }\\n\\n    // Place the nodes in the assigned rows and col.\\n    for (int i = 1; i <= k; ++i) {\\n      auto& node = graph[i];\\n      // The graph had a cycle if any node was unvisited.\\n      if (!visitedRight[node.val] || !visitedDown[node.val])\\n        return vector<vector<int>>();\\n      mat[node.row][node.col] = node.val;\\n    }\\n    return mat;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524421,
                "title": "python-topological-sorting",
                "content": "```\\nclass Solution:\\n    def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:\\n        row_indegree,col_indegree=[0]*(k+1),[0]*(k+1)\\n        row,col=[0]*(k+1),[0]*(k+1)\\n        row_graph,col_graph=defaultdict(list),defaultdict(list)\\n        for u,v in rowConditions:\\n            row_indegree[v]+=1\\n            row_graph[u].append(v)\\n        q=deque()\\n        for i in range(1,k+1):\\n            if not row_indegree[i]:\\n                q.append(i)\\n        if not q:\\n            return []\\n        seen=set()\\n        i=0\\n        while q:\\n            node=q.popleft()\\n            seen.add(node)\\n            row[node]=i\\n            i+=1\\n            for nei in row_graph[node]:\\n                row_indegree[nei]-=1\\n                if row_indegree[nei]==0:\\n                    q.append(nei)\\n        if len(seen)!=k:\\n            return []\\n        for u,v in colConditions:\\n            col_indegree[v]+=1\\n            col_graph[u].append(v)\\n        q=deque()\\n        for i in range(1,k+1):\\n            if not col_indegree[i]:\\n                q.append(i)\\n        if not q:\\n            return []\\n        seen=set()\\n        i=0\\n        while q:\\n            node=q.popleft()\\n            seen.add(node)\\n            col[node]=i\\n            i+=1\\n            for nei in col_graph[node]:\\n                col_indegree[nei]-=1\\n                if col_indegree[nei]==0:\\n                    q.append(nei)\\n        if len(seen)!=k:\\n            return []\\n        ans=[[0]*k for _ in range(k)]\\n        # print(row,col)\\n        for i in range(1,k+1):\\n            ans[row[i]][col[i]]=i\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution:\\n    def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:\\n        row_indegree,col_indegree=[0]*(k+1),[0]*(k+1)\\n        row,col=[0]*(k+1),[0]*(k+1)\\n        row_graph,col_graph=defaultdict(list),defaultdict(list)\\n        for u,v in rowConditions:\\n            row_indegree[v]+=1\\n            row_graph[u].append(v)\\n        q=deque()\\n        for i in range(1,k+1):\\n            if not row_indegree[i]:\\n                q.append(i)\\n        if not q:\\n            return []\\n        seen=set()\\n        i=0\\n        while q:\\n            node=q.popleft()\\n            seen.add(node)\\n            row[node]=i\\n            i+=1\\n            for nei in row_graph[node]:\\n                row_indegree[nei]-=1\\n                if row_indegree[nei]==0:\\n                    q.append(nei)\\n        if len(seen)!=k:\\n            return []\\n        for u,v in colConditions:\\n            col_indegree[v]+=1\\n            col_graph[u].append(v)\\n        q=deque()\\n        for i in range(1,k+1):\\n            if not col_indegree[i]:\\n                q.append(i)\\n        if not q:\\n            return []\\n        seen=set()\\n        i=0\\n        while q:\\n            node=q.popleft()\\n            seen.add(node)\\n            col[node]=i\\n            i+=1\\n            for nei in col_graph[node]:\\n                col_indegree[nei]-=1\\n                if col_indegree[nei]==0:\\n                    q.append(nei)\\n        if len(seen)!=k:\\n            return []\\n        ans=[[0]*k for _ in range(k)]\\n        # print(row,col)\\n        for i in range(1,k+1):\\n            ans[row[i]][col[i]]=i\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2520415,
                "title": "c-easy-understandabel-code-clean-code-topological-sort",
                "content": "**Simple Code and everthing point is explained with code and please upvote me if you like**\\n```\\nclass Solution {\\npublic:\\n    //function for cheking topological sort\\n    bool topo(vector<vector<int>>&adj, vector<int>&v, unordered_map<int,int>&m)\\n    {\\n        int k=v.size()-1;\\n        \\n        queue<int>q;\\n        for(int i=1;i<v.size();i++)\\n        {\\n            if(v[i]==0)\\n                q.push(i);\\n        }\\n        \\n        int count=0,ind=0;\\n        while(!q.empty())\\n        {\\n            int cu=q.front();\\n            q.pop();\\n            \\n            count++;\\n            m[cu]=ind;\\n            ind++;\\n            \\n            for(auto it:adj[cu])\\n            {\\n                v[it]--;\\n                if(v[it]==0)\\n                    q.push(it);\\n            }\\n        }\\n        \\n        return count==k;\\n    }\\n    \\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        //edges of graph\\n        vector<vector<int>>rowedge(k+1);\\n        vector<vector<int>>coloumedge(k+1);\\n        \\n        //indegree of graph\\n        vector<int>rowin(k+1);\\n        vector<int>coloumin(k+1);\\n        \\n        for(auto it:rowConditions)\\n        {\\n            rowin[it[1]]++;\\n            rowedge[it[0]].push_back(it[1]);\\n        }\\n        \\n        for(auto it:colConditions)\\n        {\\n            coloumin[it[1]]++;\\n            coloumedge[it[0]].push_back(it[1]);\\n        }\\n        \\n        //store row number and coloum number for particular number\\n        unordered_map<int,int>mrow,mcoloum;\\n        \\n        //if topological sort is exist or not\\n        bool ok1=topo(rowedge,rowin,mrow);\\n        bool ok2=topo(coloumedge,coloumin,mcoloum);\\n        \\n        //if any graph have cycle than we can\\'t find our answer\\n        if(ok1==false || ok2==false)\\n        {\\n            vector<vector<int>>ans;\\n            return ans;\\n        }\\n        \\n        //our answer\\n        vector<vector<int>>ans(k,vector<int>(k,0));\\n        for(int i=1;i<k+1;i++)\\n        {\\n            int r=mrow[i],c=mcoloum[i];\\n            ans[r][c]=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //function for cheking topological sort\\n    bool topo(vector<vector<int>>&adj, vector<int>&v, unordered_map<int,int>&m)\\n    {\\n        int k=v.size()-1;\\n        \\n        queue<int>q;\\n        for(int i=1;i<v.size();i++)\\n        {\\n            if(v[i]==0)\\n                q.push(i);\\n        }\\n        \\n        int count=0,ind=0;\\n        while(!q.empty())\\n        {\\n            int cu=q.front();\\n            q.pop();\\n            \\n            count++;\\n            m[cu]=ind;\\n            ind++;\\n            \\n            for(auto it:adj[cu])\\n            {\\n                v[it]--;\\n                if(v[it]==0)\\n                    q.push(it);\\n            }\\n        }\\n        \\n        return count==k;\\n    }\\n    \\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        //edges of graph\\n        vector<vector<int>>rowedge(k+1);\\n        vector<vector<int>>coloumedge(k+1);\\n        \\n        //indegree of graph\\n        vector<int>rowin(k+1);\\n        vector<int>coloumin(k+1);\\n        \\n        for(auto it:rowConditions)\\n        {\\n            rowin[it[1]]++;\\n            rowedge[it[0]].push_back(it[1]);\\n        }\\n        \\n        for(auto it:colConditions)\\n        {\\n            coloumin[it[1]]++;\\n            coloumedge[it[0]].push_back(it[1]);\\n        }\\n        \\n        //store row number and coloum number for particular number\\n        unordered_map<int,int>mrow,mcoloum;\\n        \\n        //if topological sort is exist or not\\n        bool ok1=topo(rowedge,rowin,mrow);\\n        bool ok2=topo(coloumedge,coloumin,mcoloum);\\n        \\n        //if any graph have cycle than we can\\'t find our answer\\n        if(ok1==false || ok2==false)\\n        {\\n            vector<vector<int>>ans;\\n            return ans;\\n        }\\n        \\n        //our answer\\n        vector<vector<int>>ans(k,vector<int>(k,0));\\n        for(int i=1;i<k+1;i++)\\n        {\\n            int r=mrow[i],c=mcoloum[i];\\n            ans[r][c]=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2519035,
                "title": "can-someone-tell-me-what-is-wrong-with-my-implementation",
                "content": "It fails at one of the last test cases. It\\'s a huge test case so hard to reason about where it\\'s going wrong.\\n\\n```class Solution {\\n    public int[][] buildMatrix(int k, int[][] rowConditions, int[][] colConditions) {\\n        int[][] matrix = new int[k][k];\\n        List<Integer> cols = findTopologicalOrder(colConditions, k);\\n        if(cols.size() < k) {\\n            return new int[0][0];\\n        }\\n        \\n        List<Integer> rows = findTopologicalOrder(rowConditions, k);\\n        if(rows.size() < k) {\\n            return new int[0][0];\\n        }\\n        \\n        for(int i = 0; i < k; i++) {\\n            for(int j = 0; j < k; j++) {\\n                if(rows.get(i) == cols.get(j)) {\\n                    if(matrix[i][j] != 0) {\\n                        return new int[0][0];\\n                    }\\n                    \\n                    matrix[i][j] = rows.get(i);\\n                }\\n            }\\n        }\\n                \\n        return matrix;\\n    }\\n    \\n    private List<Integer> findTopologicalOrder(int[][] input, int k) {\\n        HashMap<Integer, List<Integer>> graph = new HashMap<>();\\n        HashMap<Integer, Integer> indegrees = new HashMap<>();\\n        for(int i = 1; i <= k; i++) {\\n            graph.put(i, new ArrayList<>());\\n            indegrees.put(i, 0);\\n        }\\n        \\n        for(int i = 0; i < input.length; i++) {\\n            int parent = input[i][0], child = input[i][1];\\n            graph.get(parent).add(child);\\n            indegrees.put(child, indegrees.get(child) + 1);\\n        }\\n        \\n        Queue<Integer> sources = new LinkedList<>();\\n        for(Map.Entry<Integer, Integer> entry : indegrees.entrySet()) {\\n            if(entry.getValue() == 0) {\\n                sources.add(entry.getKey());\\n            }\\n        }\\n        \\n        List<Integer> result = new ArrayList<>();\\n        while(!sources.isEmpty()) {\\n            int current = sources.poll();\\n            result.add(current);\\n            \\n            for(int child : graph.get(current)) {\\n                indegrees.put(child, indegrees.get(child) - 1);\\n                if(indegrees.get(child) == 0) {\\n                    sources.add(child);\\n                }\\n            }\\n        }\\n         \\n        return result;\\n    }\\n}```",
                "solutionTags": [],
                "code": "```class Solution {\\n    public int[][] buildMatrix(int k, int[][] rowConditions, int[][] colConditions) {\\n        int[][] matrix = new int[k][k];\\n        List<Integer> cols = findTopologicalOrder(colConditions, k);\\n        if(cols.size() < k) {\\n            return new int[0][0];\\n        }\\n        \\n        List<Integer> rows = findTopologicalOrder(rowConditions, k);\\n        if(rows.size() < k) {\\n            return new int[0][0];\\n        }\\n        \\n        for(int i = 0; i < k; i++) {\\n            for(int j = 0; j < k; j++) {\\n                if(rows.get(i) == cols.get(j)) {\\n                    if(matrix[i][j] != 0) {\\n                        return new int[0][0];\\n                    }\\n                    \\n                    matrix[i][j] = rows.get(i);\\n                }\\n            }\\n        }\\n                \\n        return matrix;\\n    }\\n    \\n    private List<Integer> findTopologicalOrder(int[][] input, int k) {\\n        HashMap<Integer, List<Integer>> graph = new HashMap<>();\\n        HashMap<Integer, Integer> indegrees = new HashMap<>();\\n        for(int i = 1; i <= k; i++) {\\n            graph.put(i, new ArrayList<>());\\n            indegrees.put(i, 0);\\n        }\\n        \\n        for(int i = 0; i < input.length; i++) {\\n            int parent = input[i][0], child = input[i][1];\\n            graph.get(parent).add(child);\\n            indegrees.put(child, indegrees.get(child) + 1);\\n        }\\n        \\n        Queue<Integer> sources = new LinkedList<>();\\n        for(Map.Entry<Integer, Integer> entry : indegrees.entrySet()) {\\n            if(entry.getValue() == 0) {\\n                sources.add(entry.getKey());\\n            }\\n        }\\n        \\n        List<Integer> result = new ArrayList<>();\\n        while(!sources.isEmpty()) {\\n            int current = sources.poll();\\n            result.add(current);\\n            \\n            for(int child : graph.get(current)) {\\n                indegrees.put(child, indegrees.get(child) - 1);\\n                if(indegrees.get(child) == 0) {\\n                    sources.add(child);\\n                }\\n            }\\n        }\\n         \\n        return result;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 2515522,
                "title": "c-elegant-understandable-code-bfs-toposort",
                "content": "\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    bool topoSort(int k, vector<vector<int>> &graph, unordered_map<int,int> &Map){\\n        vector<int> indeg(k+1, 0);\\n        for(int i=0;i<graph.size();i++){\\n            for(auto nbr: graph[i]){\\n                indeg[nbr]++;\\n            }\\n        }\\n        \\n        queue<int> q;\\n        for(int i=1;i<indeg.size();i++){\\n            if(indeg[i] == 0) q.push(i);\\n        }\\n        \\n        int count = 0;      //for cycle detection\\n        int number = 0;     //for row/col number\\n        while(!q.empty()){\\n            int curNode = q.front();\\n            q.pop();\\n            \\n            count++;\\n            Map[curNode] = number;  //assign row/col number\\n            number++;\\n            \\n            for(auto nbr: graph[curNode]){\\n                indeg[nbr]--;\\n                if(indeg[nbr] == 0) q.push(nbr);\\n            }\\n        }\\n        \\n        if(count != k) return false;\\n        return true;\\n    }\\n    \\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        \\n        //graph building:\\n        vector<vector<int>> rowGraph(k+1);\\n        vector<vector<int>> colGraph(k+1);\\n        \\n        for(auto edge: rowConditions){\\n            rowGraph[edge[0]].push_back(edge[1]);\\n        }\\n        for(auto edge: colConditions){\\n            colGraph[edge[0]].push_back(edge[1]);\\n        }\\n        \\n        //map for coordinates of all elements:\\n        unordered_map<int,int> row; // ele, row\\n        unordered_map<int,int> col; // ele, col\\n        \\n        //toposort:\\n        bool x = topoSort(k, rowGraph, row);        \\n        bool y = topoSort(k, colGraph, col);\\n        \\n        //if cycle formed:\\n        if(!x or !y){\\n            vector<vector<int>> matrix;\\n            return matrix;\\n        }\\n        \\n        //ans:\\n        vector<vector<int>> matrix(k, vector<int>(k, 0));\\n        for(int ele=1;ele<k+1;ele++){\\n            int r = row[ele], c = col[ele];\\n            matrix[r][c] = ele;\\n        }\\n        \\n        return matrix;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool topoSort(int k, vector<vector<int>> &graph, unordered_map<int,int> &Map){\\n        vector<int> indeg(k+1, 0);\\n        for(int i=0;i<graph.size();i++){\\n            for(auto nbr: graph[i]){\\n                indeg[nbr]++;\\n            }\\n        }\\n        \\n        queue<int> q;\\n        for(int i=1;i<indeg.size();i++){\\n            if(indeg[i] == 0) q.push(i);\\n        }\\n        \\n        int count = 0;      //for cycle detection\\n        int number = 0;     //for row/col number\\n        while(!q.empty()){\\n            int curNode = q.front();\\n            q.pop();\\n            \\n            count++;\\n            Map[curNode] = number;  //assign row/col number\\n            number++;\\n            \\n            for(auto nbr: graph[curNode]){\\n                indeg[nbr]--;\\n                if(indeg[nbr] == 0) q.push(nbr);\\n            }\\n        }\\n        \\n        if(count != k) return false;\\n        return true;\\n    }\\n    \\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        \\n        //graph building:\\n        vector<vector<int>> rowGraph(k+1);\\n        vector<vector<int>> colGraph(k+1);\\n        \\n        for(auto edge: rowConditions){\\n            rowGraph[edge[0]].push_back(edge[1]);\\n        }\\n        for(auto edge: colConditions){\\n            colGraph[edge[0]].push_back(edge[1]);\\n        }\\n        \\n        //map for coordinates of all elements:\\n        unordered_map<int,int> row; // ele, row\\n        unordered_map<int,int> col; // ele, col\\n        \\n        //toposort:\\n        bool x = topoSort(k, rowGraph, row);        \\n        bool y = topoSort(k, colGraph, col);\\n        \\n        //if cycle formed:\\n        if(!x or !y){\\n            vector<vector<int>> matrix;\\n            return matrix;\\n        }\\n        \\n        //ans:\\n        vector<vector<int>> matrix(k, vector<int>(k, 0));\\n        for(int ele=1;ele<k+1;ele++){\\n            int r = row[ele], c = col[ele];\\n            matrix[r][c] = ele;\\n        }\\n        \\n        return matrix;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2511682,
                "title": "python",
                "content": "row and col are independent\\n```\\nclass Solution:\\n    def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:\\n        def find_idx(cond):\\n            deg, adj, res = [0]*(k+1), defaultdict(list), [0]*k\\n            for from_, to_ in cond:\\n                deg[to_]+=1\\n                adj[from_].append(to_)\\n            q, idx = deque(i for i in range(1, k+1) if not deg[i]), 0\\n            while q:\\n                cur = q.popleft()\\n                res[cur-1], idx = idx, idx+1\\n                for next_ in adj[cur]:\\n                    deg[next_]-=1\\n                    if not deg[next_]:\\n                        q.append(next_)\\n            return res if idx==k else None\\n        row_idx = find_idx(rowConditions)\\n        if not row_idx:\\n            return []\\n        col_idx = find_idx(colConditions)\\n        if not col_idx:\\n            return []\\n        res = [[0]*k for _ in range(k)]\\n        for i in range(k):\\n            res[row_idx[i]][col_idx[i]] = i+1\\n        return res\\n",
                "solutionTags": [],
                "code": "row and col are independent\\n```\\nclass Solution:\\n    def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:\\n        def find_idx(cond):\\n            deg, adj, res = [0]*(k+1), defaultdict(list), [0]*k\\n            for from_, to_ in cond:\\n                deg[to_]+=1\\n                adj[from_].append(to_)\\n            q, idx = deque(i for i in range(1, k+1) if not deg[i]), 0\\n            while q:\\n                cur = q.popleft()\\n                res[cur-1], idx = idx, idx+1\\n                for next_ in adj[cur]:\\n                    deg[next_]-=1\\n                    if not deg[next_]:\\n                        q.append(next_)\\n            return res if idx==k else None\\n        row_idx = find_idx(rowConditions)\\n        if not row_idx:\\n            return []\\n        col_idx = find_idx(colConditions)\\n        if not col_idx:\\n            return []\\n        res = [[0]*k for _ in range(k)]\\n        for i in range(k):\\n            res[row_idx[i]][col_idx[i]] = i+1\\n        return res\\n",
                "codeTag": "Java"
            },
            {
                "id": 2509391,
                "title": "c-topological-sort-with-cycle-check-simple-implementation",
                "content": "The intuition for using topological sort comes from the fact that we have to get an ordering where one number occurs before another in row or column number.\\nIf you prefer quick video to understand this, please refer: \\nhttps://youtu.be/KAbqmDu_vhU\\n\\nSimple Implementation C++ Code below for reference\\n```\\nclass Solution {\\npublic:  \\n    void topoSort(int node, vector<vector<int>> row_conditions_graph,\\n                  vector<bool>& visited, stack<int>& topo_order,\\n                  vector<bool>& current_dfs_nodes) {\\n      \\n      visited[node] = true;\\n      current_dfs_nodes[node] = true;\\n      \\n      for (int i = 0; i < row_conditions_graph[node].size(); ++i) {\\n        int child = row_conditions_graph[node][i];\\n        if (!visited[child]) {\\n          topoSort(child, row_conditions_graph, visited, topo_order, current_dfs_nodes);\\n        } else {\\n          // current child node is visited, check if its a back edge to detect cycle or not.\\n          if (current_dfs_nodes[child]) {\\n            // if visited child is visited in same dfs then cycle exists, return and do not\\n            // add current node in stack\\n            return;\\n          }\\n        }\\n      }\\n      // dfs for node is completed, so we should unmark it from current dfs nodes.\\n      current_dfs_nodes[node] = false;\\n      topo_order.push(node);\\n    }\\n  \\n    vector<int> getOrderingForGraph(int k, vector<vector<int>>& conditions) {\\n      vector<vector<int>> row_conditions_graph(k+1, vector<int>());\\n      // set to true if current node dfs is in progress.\\n      vector<bool> current_dfs_nodes(k+1, false);\\n      vector<bool> visited(k+1, false);\\n      // create adjacency lists from conditions\\n      for (const auto& x : conditions) {\\n        row_conditions_graph[x[0]].push_back(x[1]);\\n      }\\n      \\n      // Now that the graph does not have cycle, we create ordering vector\\n      vector<int> ordering(k+1, -1);\\n\\n      stack<int> topo_order;\\n      for (int i = 1; i <= k; ++i) {\\n        if (!visited[i]) {\\n          topoSort(i, row_conditions_graph, visited, topo_order, current_dfs_nodes);\\n        }\\n      }\\n      \\n      // some nodes are involved in cycle.\\n      if (topo_order.size() != k) {\\n        return {};\\n      }\\n      \\n      int counter = 1;\\n      while (!topo_order.empty()) {\\n        ordering[topo_order.top()] = counter++;\\n        topo_order.pop();\\n      }\\n      \\n      return ordering;\\n    }\\n  \\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions,\\n                                    vector<vector<int>>& colConditions) {\\n      \\n      \\n      auto ans = vector<vector<int>>();\\n      auto row_ordering = getOrderingForGraph(k, rowConditions);\\n      auto col_ordering = getOrderingForGraph(k, colConditions);\\n      \\n      // this will only happen if one of the graph has cycle.\\n      if (row_ordering.size() != k+1 || col_ordering.size() != k+1) {\\n        return ans;\\n      }\\n      \\n      ans = vector<vector<int>>(k, vector<int>(k, 0));\\n      for (int i = 1; i <= k; ++i) {\\n        ans[row_ordering[i] - 1][col_ordering[i] - 1] = i;\\n      }\\n      \\n      return ans;\\n    }\\n};\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:  \\n    void topoSort(int node, vector<vector<int>> row_conditions_graph,\\n                  vector<bool>& visited, stack<int>& topo_order,\\n                  vector<bool>& current_dfs_nodes) {\\n      \\n      visited[node] = true;\\n      current_dfs_nodes[node] = true;\\n      \\n      for (int i = 0; i < row_conditions_graph[node].size(); ++i) {\\n        int child = row_conditions_graph[node][i];\\n        if (!visited[child]) {\\n          topoSort(child, row_conditions_graph, visited, topo_order, current_dfs_nodes);\\n        } else {\\n          // current child node is visited, check if its a back edge to detect cycle or not.\\n          if (current_dfs_nodes[child]) {\\n            // if visited child is visited in same dfs then cycle exists, return and do not\\n            // add current node in stack\\n            return;\\n          }\\n        }\\n      }\\n      // dfs for node is completed, so we should unmark it from current dfs nodes.\\n      current_dfs_nodes[node] = false;\\n      topo_order.push(node);\\n    }\\n  \\n    vector<int> getOrderingForGraph(int k, vector<vector<int>>& conditions) {\\n      vector<vector<int>> row_conditions_graph(k+1, vector<int>());\\n      // set to true if current node dfs is in progress.\\n      vector<bool> current_dfs_nodes(k+1, false);\\n      vector<bool> visited(k+1, false);\\n      // create adjacency lists from conditions\\n      for (const auto& x : conditions) {\\n        row_conditions_graph[x[0]].push_back(x[1]);\\n      }\\n      \\n      // Now that the graph does not have cycle, we create ordering vector\\n      vector<int> ordering(k+1, -1);\\n\\n      stack<int> topo_order;\\n      for (int i = 1; i <= k; ++i) {\\n        if (!visited[i]) {\\n          topoSort(i, row_conditions_graph, visited, topo_order, current_dfs_nodes);\\n        }\\n      }\\n      \\n      // some nodes are involved in cycle.\\n      if (topo_order.size() != k) {\\n        return {};\\n      }\\n      \\n      int counter = 1;\\n      while (!topo_order.empty()) {\\n        ordering[topo_order.top()] = counter++;\\n        topo_order.pop();\\n      }\\n      \\n      return ordering;\\n    }\\n  \\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions,\\n                                    vector<vector<int>>& colConditions) {\\n      \\n      \\n      auto ans = vector<vector<int>>();\\n      auto row_ordering = getOrderingForGraph(k, rowConditions);\\n      auto col_ordering = getOrderingForGraph(k, colConditions);\\n      \\n      // this will only happen if one of the graph has cycle.\\n      if (row_ordering.size() != k+1 || col_ordering.size() != k+1) {\\n        return ans;\\n      }\\n      \\n      ans = vector<vector<int>>(k, vector<int>(k, 0));\\n      for (int i = 1; i <= k; ++i) {\\n        ans[row_ordering[i] - 1][col_ordering[i] - 1] = i;\\n      }\\n      \\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2508780,
                "title": "python-comments-explanation-toposort-clean",
                "content": "Below pyhton code contains the comments for your refernce of the same idea discussed here\\n\\nInitially this problem looked amnigous to me to think but as soon as i found something(values) is dependent on someother thing(values) it striked to me as a toposort also given matrix i have enough confident to think in terms of topo sort and \\n\\n\\nI tried to do a dry run with the result of the topo sort i found it actually give the index of (vals). I tried to prove the above idea.\\n\\n**Proof**\\nIn topo sort of the **rowConditions** graph the element with hightest indegree will come first in the toposort array hence last in the matrix which in turn is the max row in which we can put since all the values after it in the topo sort array is aleady satisfied in the above rows and same is the case with **colConditions** graph hence we always put our elements in the max possible row and column in out resultant **matrix**.\\n\\n\\n\\nHope this clarifies.\\n\\nIf you have any queries the please tag me in the comment section with you query.\\n\\n**Writing my first descriptive solution. If you liked it please upvote**.\\uD83E\\uDD76\\uD83E\\uDD76\\uD83E\\uDD76\\uD83E\\uDD76\\n\\n\\n\\n\\n```\\nclass Solution:\\n    def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:\\n        #build the directed graph since k is given to be max 400 we can take 401 for indexs from 1 to 400\\n        row = [[] for _ in range(401)]\\n        for i,j in rowConditions:\\n            row[i].append(j)\\n        col = [[] for _ in range(401)]\\n        for i,j in colConditions:\\n            col[i].append(j)\\n        \\n        #simple topo sorting with cycle detection\\n        def topo(node,g,arr,visited):\\n            visited[node] = 1\\n            for nei in g[node]:\\n                if visited.get(nei,0) == 0:\\n                    if topo(nei,g,arr,visited):\\n                        return True\\n                elif visited[nei] == 1:\\n                        return True\\n            visited[node] = 2   \\n            arr.append(node)\\n            return False\\n            \\n        r = []\\n        visited = {}\\n        #toposort the row graph\\n        for node in range(1,k+1):\\n            if not (node in visited):\\n                #if cycle found we can tell there is no possible solution\\n                if topo(node,row,r,visited):\\n                    return []\\n        #topo sort the col graph\\n        c = []\\n        visited = {}\\n        for node in range(1,k+1):\\n            if not (node in visited):\\n                  #if cycle found we can tell there is no possible solution\\n                if topo(node,col,c,visited):\\n                    return []\\n        \\n        #finally contruct the matrix with the resultant topo sorts result\\n        matrix = [[0 for _ in range(k)] for _ in range(k)]\\n        for i in range(1,k+1):\\n            rd = len(r) - r.index(i) - 1\\n            cl = len(c) - c.index(i) - 1\\n            matrix[rd][cl] = i     \\n        return matrix\\n            \\n                \\n                \\n        \\n            \\n",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Topological Sort"
                ],
                "code": "class Solution:\\n    def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:\\n        #build the directed graph since k is given to be max 400 we can take 401 for indexs from 1 to 400\\n        row = [[] for _ in range(401)]\\n        for i,j in rowConditions:\\n            row[i].append(j)\\n        col = [[] for _ in range(401)]\\n        for i,j in colConditions:\\n            col[i].append(j)\\n        \\n        #simple topo sorting with cycle detection\\n        def topo(node,g,arr,visited):\\n            visited[node] = 1\\n            for nei in g[node]:\\n                if visited.get(nei,0) == 0:\\n                    if topo(nei,g,arr,visited):\\n                        return True\\n                elif visited[nei] == 1:\\n                        return True\\n            visited[node] = 2   \\n            arr.append(node)\\n            return False\\n            \\n        r = []\\n        visited = {}",
                "codeTag": "Java"
            },
            {
                "id": 2508046,
                "title": "java-topological-sort",
                "content": "```\\nclass Solution {\\n    public int[][] buildMatrix(int k, int[][] rowConditions, int[][] colConditions) {\\n       \\n        int[][] answer = new int[k][k];\\n        \\n        HashMap<Integer,Integer> rowOrder = getOrderFromConditions(k,rowConditions);\\n        \\n        if(rowOrder==null)\\n            return new int[0][0];\\n        \\n        HashMap<Integer,Integer> colOrder = getOrderFromConditions(k,colConditions);\\n                \\n        if(colOrder==null)\\n            return new int[0][0];\\n        \\n        \\n        rowOrder.forEach((z,v)->{\\n            answer[v][colOrder.get(z)]=z; \\n        });\\n        \\n        return answer;\\n    \\n    }\\n    \\n    HashMap<Integer,Integer> getOrderFromConditions(int k, int[][] conditions)\\n    {        \\n        Graph<Integer> g = new Graph<>();\\n        \\n        for(int i=0;i<conditions.length;i++)\\n        {\\n            g.addEdge(new DirectedEdge<Integer>(conditions[i][0],conditions[i][1]));\\n        }\\n\\n        \\n        TopologicalSort<Integer> ts = new TopologicalSort<>(g);\\n        \\n        if(ts.hasCycle()) return null;\\n        \\n        HashMap<Integer,Integer> order = ts.order();\\n        \\n        updateOrderForMissingValues(k, order);\\n        \\n        return order;\\n    }\\n    \\n    void updateOrderForMissingValues(int k, HashMap<Integer,Integer> order)\\n    {\\n        List<Integer> r = new ArrayList<>(order.keySet());\\n        Collections.sort(r);\\n        int last=1;\\n        List<Integer> remaining = new ArrayList<>();\\n        \\n        for(int i=0;i<r.size();i++)\\n        {\\n            if(r.get(i)!=last && last<=k)\\n            {\\n                remaining.add(last);\\n                i=i-1;\\n            }\\n\\n            last++;\\n\\n            if(last>k)\\n                    break;\\n        }\\n            while(last<=k)\\n            {                \\n                remaining.add(last);\\n                last++;\\n            }\\n\\n        int count=order.size();\\n        \\n        for(int i=0;i<remaining.size();i++)\\n        {\\n            order.put(remaining.get(i),count++);\\n        }\\n    }\\n    \\n    \\n    public class DirectedEdge<K extends Comparable>\\n    {\\n        K from,to;\\n        \\n        public DirectedEdge(K v, K w)\\n        {\\n            this.from=v;\\n            this.to=w;\\n        }\\n        \\n        public K from()\\n        {\\n            return from;\\n        }\\n                \\n        public K to()\\n        {\\n            return to;\\n        }\\n    }\\n    \\n    public class Graph<K extends Comparable>\\n    {\\n        private HashMap<K,HashSet<K>> adjacent = new HashMap<>();\\n        private HashSet<K> vertices=new HashSet<>();\\n        \\n        public void addEdge(DirectedEdge<K> e)\\n        {\\n            K v = e.from();\\n            K w = e.to();\\n            this.adjacent.putIfAbsent(v,new HashSet<K>());\\n            this.adjacent.get(v).add(w);\\n            this.vertices.add(v);\\n            this.vertices.add(w);\\n            \\n        }\\n        \\n        public Iterable<K> vertices()\\n        {\\n            return vertices;\\n        }\\n        \\n        public HashSet<K> adj(K v)\\n        {\\n            HashSet<K> ret = this.adjacent.get(v);\\n            if(ret==null)\\n                return new HashSet<K>();\\n            else\\n                return ret;\\n        }\\n        \\n\\n        \\n    }\\n    \\n    public class TopologicalSort<K extends Comparable>\\n    {\\n        Stack<K> stack = new Stack<>();\\n        HashSet<K> onStack = new HashSet<>();\\n        boolean hasCycle=false;\\n        \\n        public TopologicalSort(Graph<K> g)\\n        {\\n            HashSet<K> marked = new HashSet<>();\\n            for(K v:g.vertices())\\n            {\\n                if(!marked.contains(v))\\n                dfs(v,marked,g);\\n            }\\n        }\\n        \\n        public boolean hasCycle()\\n        {\\n            return hasCycle;\\n        }\\n        \\n        private void dfs(K v,HashSet<K> marked, Graph<K> g)\\n        {\\n            marked.add(v);\\n            onStack.add(v);\\n            for(K w:g.adj(v))\\n            {\\n                if(!marked.contains(w))\\n                {\\n                    dfs(w,marked,g);\\n                }\\n                else if(onStack.contains(w))\\n                {\\n                    hasCycle=true;\\n                    break;\\n                }\\n            }\\n            onStack.remove(v);\\n            \\n            stack.push(v);        \\n        }\\n        \\n        public HashMap<K,Integer> order()\\n        {\\n            HashMap<K,Integer> order = new HashMap<>();\\n            int count=0;\\n            \\n            while(!stack.isEmpty())\\n            {\\n                K x=stack.pop();\\n                order.put(x,count);\\n                count++;\\n            }\\n            return order;\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] buildMatrix(int k, int[][] rowConditions, int[][] colConditions) {\\n       \\n        int[][] answer = new int[k][k];\\n        \\n        HashMap<Integer,Integer> rowOrder = getOrderFromConditions(k,rowConditions);\\n        \\n        if(rowOrder==null)\\n            return new int[0][0];\\n        \\n        HashMap<Integer,Integer> colOrder = getOrderFromConditions(k,colConditions);\\n                \\n        if(colOrder==null)\\n            return new int[0][0];\\n        \\n        \\n        rowOrder.forEach((z,v)->{\\n            answer[v][colOrder.get(z)]=z; \\n        });\\n        \\n        return answer;\\n    \\n    }\\n    \\n    HashMap<Integer,Integer> getOrderFromConditions(int k, int[][] conditions)\\n    {        \\n        Graph<Integer> g = new Graph<>();\\n        \\n        for(int i=0;i<conditions.length;i++)\\n        {\\n            g.addEdge(new DirectedEdge<Integer>(conditions[i][0],conditions[i][1]));\\n        }\\n\\n        \\n        TopologicalSort<Integer> ts = new TopologicalSort<>(g);\\n        \\n        if(ts.hasCycle()) return null;\\n        \\n        HashMap<Integer,Integer> order = ts.order();\\n        \\n        updateOrderForMissingValues(k, order);\\n        \\n        return order;\\n    }\\n    \\n    void updateOrderForMissingValues(int k, HashMap<Integer,Integer> order)\\n    {\\n        List<Integer> r = new ArrayList<>(order.keySet());\\n        Collections.sort(r);\\n        int last=1;\\n        List<Integer> remaining = new ArrayList<>();\\n        \\n        for(int i=0;i<r.size();i++)\\n        {\\n            if(r.get(i)!=last && last<=k)\\n            {\\n                remaining.add(last);\\n                i=i-1;\\n            }\\n\\n            last++;\\n\\n            if(last>k)\\n                    break;\\n        }\\n            while(last<=k)\\n            {                \\n                remaining.add(last);\\n                last++;\\n            }\\n\\n        int count=order.size();\\n        \\n        for(int i=0;i<remaining.size();i++)\\n        {\\n            order.put(remaining.get(i),count++);\\n        }\\n    }\\n    \\n    \\n    public class DirectedEdge<K extends Comparable>\\n    {\\n        K from,to;\\n        \\n        public DirectedEdge(K v, K w)\\n        {\\n            this.from=v;\\n            this.to=w;\\n        }\\n        \\n        public K from()\\n        {\\n            return from;\\n        }\\n                \\n        public K to()\\n        {\\n            return to;\\n        }\\n    }\\n    \\n    public class Graph<K extends Comparable>\\n    {\\n        private HashMap<K,HashSet<K>> adjacent = new HashMap<>();\\n        private HashSet<K> vertices=new HashSet<>();\\n        \\n        public void addEdge(DirectedEdge<K> e)\\n        {\\n            K v = e.from();\\n            K w = e.to();\\n            this.adjacent.putIfAbsent(v,new HashSet<K>());\\n            this.adjacent.get(v).add(w);\\n            this.vertices.add(v);\\n            this.vertices.add(w);\\n            \\n        }\\n        \\n        public Iterable<K> vertices()\\n        {\\n            return vertices;\\n        }\\n        \\n        public HashSet<K> adj(K v)\\n        {\\n            HashSet<K> ret = this.adjacent.get(v);\\n            if(ret==null)\\n                return new HashSet<K>();\\n            else\\n                return ret;\\n        }\\n        \\n\\n        \\n    }\\n    \\n    public class TopologicalSort<K extends Comparable>\\n    {\\n        Stack<K> stack = new Stack<>();\\n        HashSet<K> onStack = new HashSet<>();\\n        boolean hasCycle=false;\\n        \\n        public TopologicalSort(Graph<K> g)\\n        {\\n            HashSet<K> marked = new HashSet<>();\\n            for(K v:g.vertices())\\n            {\\n                if(!marked.contains(v))\\n                dfs(v,marked,g);\\n            }\\n        }\\n        \\n        public boolean hasCycle()\\n        {\\n            return hasCycle;\\n        }\\n        \\n        private void dfs(K v,HashSet<K> marked, Graph<K> g)\\n        {\\n            marked.add(v);\\n            onStack.add(v);\\n            for(K w:g.adj(v))\\n            {\\n                if(!marked.contains(w))\\n                {\\n                    dfs(w,marked,g);\\n                }\\n                else if(onStack.contains(w))\\n                {\\n                    hasCycle=true;\\n                    break;\\n                }\\n            }\\n            onStack.remove(v);\\n            \\n            stack.push(v);        \\n        }\\n        \\n        public HashMap<K,Integer> order()\\n        {\\n            HashMap<K,Integer> order = new HashMap<>();\\n            int count=0;\\n            \\n            while(!stack.isEmpty())\\n            {\\n                K x=stack.pop();\\n                order.put(x,count);\\n                count++;\\n            }\\n            return order;\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2507842,
                "title": "c-topological-sort-easy-to-understand-brief-explanation",
                "content": "Thinking Process-\\n1. Every vertex is below/after some vertex(dependency on some other vertex). So topo sort can be applied.\\n2. If there is a cycle , for example , \\'1\\' is after \\'2\\' , \\'2\\' is after \\'3\\' and \\'3\\' is after \\'1\\' , then desired matrix can\\'t be constructed. This case will give a cycle during topo sort and we can simply return empty vector.\\n3. If there is no cycle, means matrix can be constructed. \\n4. With the order of execution generated from topo sort, we can generate the matrix.\\n```\\nclass Solution {\\npublic:\\n    void topoSort(vector<int>& result , vector<vector<int>>& data , int& k)\\n    {\\n        vector<vector<int>>adj(k+1);\\n        vector<int>indeg(k+1 , 0);\\n        for(auto& d : data)\\n        {\\n            adj[d[0]].push_back(d[1]);\\n            indeg[d[1]]++;\\n        }\\n        queue<int>q;\\n        for(int i = 1; i <= k ; i++)\\n        {\\n            if(indeg[i] == 0)\\n                q.push(i);\\n        }\\n        while(q.size())\\n        {\\n            int top = q.front(); q.pop();\\n            result.push_back(top);\\n            for(auto& nbr : adj[top])\\n            {\\n                indeg[nbr]--;\\n                if(indeg[nbr] == 0)\\n                    q.push(nbr);\\n            }\\n        }\\n    }\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        vector<int>rowOrder;\\n        vector<int>colOrder;\\n        topoSort(rowOrder , rowConditions , k);\\n        topoSort(colOrder , colConditions , k);\\n        if(rowOrder.size() != k) return {};\\n        if(colOrder.size() != k) return {};\\n        vector<vector<int>>ans(k , vector<int>(k , 0));\\n        unordered_map<int , int>rowno; //stores the rowno of number\\n        for(int i = 0 ; i < k ; i++)\\n        {\\n            rowno[rowOrder[i]] = i;\\n        }\\n        for(int j = 0 ; j < k ; j++)\\n        {\\n            ans[rowno[colOrder[j]]][j] = colOrder[j];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void topoSort(vector<int>& result , vector<vector<int>>& data , int& k)\\n    {\\n        vector<vector<int>>adj(k+1);\\n        vector<int>indeg(k+1 , 0);\\n        for(auto& d : data)\\n        {\\n            adj[d[0]].push_back(d[1]);\\n            indeg[d[1]]++;\\n        }\\n        queue<int>q;\\n        for(int i = 1; i <= k ; i++)\\n        {\\n            if(indeg[i] == 0)\\n                q.push(i);\\n        }\\n        while(q.size())\\n        {\\n            int top = q.front(); q.pop();\\n            result.push_back(top);\\n            for(auto& nbr : adj[top])\\n            {\\n                indeg[nbr]--;\\n                if(indeg[nbr] == 0)\\n                    q.push(nbr);\\n            }\\n        }\\n    }\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        vector<int>rowOrder;\\n        vector<int>colOrder;\\n        topoSort(rowOrder , rowConditions , k);\\n        topoSort(colOrder , colConditions , k);\\n        if(rowOrder.size() != k) return {};\\n        if(colOrder.size() != k) return {};\\n        vector<vector<int>>ans(k , vector<int>(k , 0));\\n        unordered_map<int , int>rowno; //stores the rowno of number\\n        for(int i = 0 ; i < k ; i++)\\n        {\\n            rowno[rowOrder[i]] = i;\\n        }\\n        for(int j = 0 ; j < k ; j++)\\n        {\\n            ans[rowno[colOrder[j]]][j] = colOrder[j];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2507438,
                "title": "topological-sort-introduction-to-algorithm-version-implementation",
                "content": "```\\nclass Solution {\\n    Map<Integer, int[]> map = new HashMap<>();\\n    int row;\\n    int col;\\n    public int[][] buildMatrix(int k, int[][] rowConditions, int[][] colConditions) {\\n        int [][] res = new int[k][k]; \\n        \\n        if (k == 1) {\\n            res[0][0] = 1;\\n            return res;\\n        }\\n        this.row = k - 1;\\n        this.col = k - 1;\\n        Node[] rowGraph = buildGraph(rowConditions, k);\\n        Node[] colGraph = buildGraph(colConditions, k);\\n        \\n        \\n        for (int i = 1; i <= k; i ++) {\\n            if (topo(rowGraph, rowGraph[i], true)) return new int[0][0];\\n        }\\n        \\n        for (int i = 1; i <= k; i ++) {\\n            if (topo(colGraph, colGraph[i], false)) return new int[0][0];\\n        }\\n        for (int key : map.keySet()) {\\n            int[] cur = map.get(key);\\n            res[cur[0]][cur[1]] = key;\\n        }\\n        return res;\\n    }\\n    \\n    private boolean topo (Node[] graph, Node cur, boolean flag) {\\n\\t\\t// Black color (integer 2) for pruning\\n        if (cur.color == 2) return false;\\n\\t\\t// Grey color (integer 1) for cycle detection\\n        if (cur.color == 1) return true;\\n        cur.color = 1;\\n        for (int next : cur.neis) {\\n            if (topo(graph, graph[next], flag)) return true;\\n        }\\n        cur.color = 2;\\n        if (!map.containsKey(cur.val)) {\\n            map.put(cur.val, new int[2]);\\n        }\\n        if (flag) {\\n            map.get(cur.val)[0] = row;\\n            row -= 1;\\n        } else {\\n            map.get(cur.val)[1] = col;\\n            col -= 1;\\n        }\\n        return false;\\n    }\\n    \\n    private Node[] buildGraph(int[][] edges, int k) {\\n        Node[] graph = new Node[k + 1];\\n        for (int i = 1; i <= k; i ++) {\\n            graph[i] = new Node(i);\\n        }\\n        for (int[] edge : edges) {\\n            graph[edge[0]].neis.add(edge[1]);\\n        }\\n        return graph;\\n    }\\n}\\n\\nclass Node {\\n    int val;\\n    List<Integer> neis;\\n\\t// Initial node mark as white(integer 0) as unvisited.\\n    int color;\\n    public Node(int val) {\\n        this.val = val;\\n        this.color = 0;\\n        this.neis = new ArrayList<>();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Map<Integer, int[]> map = new HashMap<>();\\n    int row;\\n    int col;\\n    public int[][] buildMatrix(int k, int[][] rowConditions, int[][] colConditions) {\\n        int [][] res = new int[k][k]; \\n        \\n        if (k == 1) {\\n            res[0][0] = 1;\\n            return res;\\n        }\\n        this.row = k - 1;\\n        this.col = k - 1;\\n        Node[] rowGraph = buildGraph(rowConditions, k);\\n        Node[] colGraph = buildGraph(colConditions, k);\\n        \\n        \\n        for (int i = 1; i <= k; i ++) {\\n            if (topo(rowGraph, rowGraph[i], true)) return new int[0][0];\\n        }\\n        \\n        for (int i = 1; i <= k; i ++) {\\n            if (topo(colGraph, colGraph[i], false)) return new int[0][0];\\n        }\\n        for (int key : map.keySet()) {\\n            int[] cur = map.get(key);\\n            res[cur[0]][cur[1]] = key;\\n        }\\n        return res;\\n    }\\n    \\n    private boolean topo (Node[] graph, Node cur, boolean flag) {\\n\\t\\t// Black color (integer 2) for pruning\\n        if (cur.color == 2) return false;\\n\\t\\t// Grey color (integer 1) for cycle detection\\n        if (cur.color == 1) return true;\\n        cur.color = 1;\\n        for (int next : cur.neis) {\\n            if (topo(graph, graph[next], flag)) return true;\\n        }\\n        cur.color = 2;\\n        if (!map.containsKey(cur.val)) {\\n            map.put(cur.val, new int[2]);\\n        }\\n        if (flag) {\\n            map.get(cur.val)[0] = row;\\n            row -= 1;\\n        } else {\\n            map.get(cur.val)[1] = col;\\n            col -= 1;\\n        }\\n        return false;\\n    }\\n    \\n    private Node[] buildGraph(int[][] edges, int k) {\\n        Node[] graph = new Node[k + 1];\\n        for (int i = 1; i <= k; i ++) {\\n            graph[i] = new Node(i);\\n        }\\n        for (int[] edge : edges) {\\n            graph[edge[0]].neis.add(edge[1]);\\n        }\\n        return graph;\\n    }\\n}\\n\\nclass Node {\\n    int val;\\n    List<Integer> neis;\\n\\t// Initial node mark as white(integer 0) as unvisited.\\n    int color;\\n    public Node(int val) {\\n        this.val = val;\\n        this.color = 0;\\n        this.neis = new ArrayList<>();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2507028,
                "title": "scala-functional-solution",
                "content": "```\\n  def buildMatrix(k: Int, rowConditions: Array[Array[Int]], colConditions: Array[Array[Int]]): Array[Array[Int]] = {\\n    def topologicalSort(edges: Array[Seq[Int]]): Option[Seq[Int]] = {\\n      val (graph, indegree) =\\n        edges.foldLeft(Map.empty[Int, Set[Int]].withDefaultValue(Set.empty), Map.empty[Int, Int].withDefaultValue(0)) {\\n          case ((graph, indegree), Seq(before, after)) =>\\n            (graph.updated(before, graph(before) + after), indegree.updated(after, indegree(after) + 1))\\n        }\\n        \\n      def dfs(toVisit: Seq[Int], indegree: Map[Int, Int]): Seq[Int] =\\n        toVisit.headOption match {\\n          case None => Seq.empty\\n          case Some(curr) =>\\n            curr +: (dfs _).tupled(graph(curr).foldLeft(toVisit.tail, indegree) {\\n              case ((toVisit, indegree), next) =>\\n                if (indegree(next) == 1) (toVisit :+ next, indegree.removed(next))\\n                else (toVisit, indegree.updated(next, indegree(next) - 1))\\n            })\\n        }\\n\\n      Option(dfs(toVisit = (1 to k).filter(n => indegree(n) == 0), indegree)).filter(_.length == k)\\n    }\\n\\n    val maybeResult = for {\\n      order1 <- topologicalSort(rowConditions.map(_.toSeq).distinct)\\n      order2 <- topologicalSort(colConditions.map(_.toSeq).distinct)\\n    } yield Array.tabulate(k, k) { case (r, c) => if (order1(r) == order2(c)) order1(r) else 0 }\\n\\n    maybeResult.getOrElse(Array.empty)\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\n  def buildMatrix(k: Int, rowConditions: Array[Array[Int]], colConditions: Array[Array[Int]]): Array[Array[Int]] = {\\n    def topologicalSort(edges: Array[Seq[Int]]): Option[Seq[Int]] = {\\n      val (graph, indegree) =\\n        edges.foldLeft(Map.empty[Int, Set[Int]].withDefaultValue(Set.empty), Map.empty[Int, Int].withDefaultValue(0)) {\\n          case ((graph, indegree), Seq(before, after)) =>\\n            (graph.updated(before, graph(before) + after), indegree.updated(after, indegree(after) + 1))\\n        }\\n        \\n      def dfs(toVisit: Seq[Int], indegree: Map[Int, Int]): Seq[Int] =\\n        toVisit.headOption match {\\n          case None => Seq.empty\\n          case Some(curr) =>\\n            curr +: (dfs _).tupled(graph(curr).foldLeft(toVisit.tail, indegree) {\\n              case ((toVisit, indegree), next) =>\\n                if (indegree(next) == 1) (toVisit :+ next, indegree.removed(next))\\n                else (toVisit, indegree.updated(next, indegree(next) - 1))\\n            })\\n        }\\n\\n      Option(dfs(toVisit = (1 to k).filter(n => indegree(n) == 0), indegree)).filter(_.length == k)\\n    }\\n\\n    val maybeResult = for {\\n      order1 <- topologicalSort(rowConditions.map(_.toSeq).distinct)\\n      order2 <- topologicalSort(colConditions.map(_.toSeq).distinct)\\n    } yield Array.tabulate(k, k) { case (r, c) => if (order1(r) == order2(c)) order1(r) else 0 }\\n\\n    maybeResult.getOrElse(Array.empty)\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2506802,
                "title": "java-topological-sort-two-times",
                "content": "1) First do the topological sort on the row conditions. Place numbers 1 through k in the first column of the matrix according to the topological order of the row conditions (we could place them in any column, but I\\'m placing them in the first column just for convenience). What matters at this point is that all numbers are placed in the correct row based on the row conditions;\\n2) Do the topological sort on the column conditions. For each number 1 through k, keep track of the column number in which it meeds to be placed (use hash map for this);\\n3) After the second topological sort is done, go through each number 1 through k, get the correct column number from the map and place this number into that correct column. \\n```\\nclass Solution {\\n    Map<Integer, Integer> colMap = new HashMap<>();\\n    public int[][] buildMatrix(int k, int[][] rowConditions, int[][] colConditions) {\\n        int[][] mat = new int[k][k];\\n\\t\\t// if either of the two topological sorts cannot be performed return empty matrix\\n        if(!topoSort(mat, rowConditions, true) || !topoSort(mat, colConditions, false))\\n            return new int[0][0];\\n\\t\\t// place each number into the correct column\\n        for(int i = 0; i < k; i ++) {\\n            int num = mat[i][0];\\n            mat[i][0] = 0;\\n            mat[i][colMap.get(num)] = num;\\n        }\\n        return mat;\\n    }\\n    \\n    public boolean topoSort(int[][] mat, int[][] conditions, boolean flag) {\\n\\t\\t// topological sort using a standard BFS approach\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        int[] inDegree = new int[mat.length+1];\\n        for(int[] cond: conditions) {\\n            map.putIfAbsent(cond[0], new ArrayList<>());\\n            map.get(cond[0]).add(cond[1]);\\n            inDegree[cond[1]] ++ ;\\n        }\\n         Queue<Integer> que = new LinkedList<>();\\n         Set<Integer> set = new HashSet<>();\\n         int row = 0; \\n         for(int i = 1; i < inDegree.length; i ++) {\\n            if(inDegree[i] == 0)\\n                que.add(i);\\n        }\\n        while(!que.isEmpty()) {\\n            int cur = que.poll();\\n            set.add(cur);\\n\\t\\t\\t// if topological sort is performed on row conditions, place the number in a correct row\\n            if(flag)\\n                 mat[row++][0] = cur;\\n\\t\\t\\t// if topological sort is performed on column conditions put the number and its correct column in a map so later we can update its column placement\\n            else\\n                colMap.put(cur, row++);\\n            List<Integer> l = map.get(cur);\\n            if(l == null) continue;\\n            for(int next: l) {\\n                if(--inDegree[next] == 0)\\n                    que.add(next);\\n            }\\n        }\\n        return set.size() < mat.length ? false : true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Map<Integer, Integer> colMap = new HashMap<>();\\n    public int[][] buildMatrix(int k, int[][] rowConditions, int[][] colConditions) {\\n        int[][] mat = new int[k][k];\\n\\t\\t// if either of the two topological sorts cannot be performed return empty matrix\\n        if(!topoSort(mat, rowConditions, true) || !topoSort(mat, colConditions, false))\\n            return new int[0][0];\\n\\t\\t// place each number into the correct column\\n        for(int i = 0; i < k; i ++) {\\n            int num = mat[i][0];\\n            mat[i][0] = 0;\\n            mat[i][colMap.get(num)] = num;\\n        }\\n        return mat;\\n    }\\n    \\n    public boolean topoSort(int[][] mat, int[][] conditions, boolean flag) {\\n\\t\\t// topological sort using a standard BFS approach\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        int[] inDegree = new int[mat.length+1];\\n        for(int[] cond: conditions) {\\n            map.putIfAbsent(cond[0], new ArrayList<>());\\n            map.get(cond[0]).add(cond[1]);\\n            inDegree[cond[1]] ++ ;\\n        }\\n         Queue<Integer> que = new LinkedList<>();\\n         Set<Integer> set = new HashSet<>();\\n         int row = 0; \\n         for(int i = 1; i < inDegree.length; i ++) {\\n            if(inDegree[i] == 0)\\n                que.add(i);\\n        }\\n        while(!que.isEmpty()) {\\n            int cur = que.poll();\\n            set.add(cur);\\n\\t\\t\\t// if topological sort is performed on row conditions, place the number in a correct row\\n            if(flag)\\n                 mat[row++][0] = cur;\\n\\t\\t\\t// if topological sort is performed on column conditions put the number and its correct column in a map so later we can update its column placement\\n            else\\n                colMap.put(cur, row++);\\n            List<Integer> l = map.get(cur);\\n            if(l == null) continue;\\n            for(int next: l) {\\n                if(--inDegree[next] == 0)\\n                    que.add(next);\\n            }\\n        }\\n        return set.size() < mat.length ? false : true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2506761,
                "title": "java-what-a-nice-question-reminding-me-the-topo-sort-thank-you-leetcode",
                "content": "```\\nclass Solution {\\n    //Using topological sort to solve this problem\\n    public int[][] buildMatrix(int k, int[][] rowC, int[][] colC) {\\n        //First, get the topo-sorted of row and col\\n        List<Integer> row = toposort(k, rowC);\\n        List<Integer> col = toposort(k, colC);\\n        //base case: when the length of row or col is less than k, return empty.\\n        //That is: there is a loop in established graph\\n        if(row.size() < k || col.size() < k) return new int[0][0];\\n        \\n        int[][] res = new int[k][k];\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int i = 0; i < k; i++){\\n            //we record the number corresbonding to each column:\\n            //[number, column index]\\n            map.put(col.get(i), i); \\n        }\\n        //col: 3 2 1 \\n        //row: 1 3 2 \\n        for(int i = 0; i < k; i++){\\n            //For each row: we have number row.get(i). And we need to know \\n            // which column we need to assign, which is from map.get(row.get(i))\\n            //known by map.get()\\n            res[i][map.get(row.get(i))] = row.get(i);\\n        }\\n        return res;\\n    }\\n    \\n    private List<Integer> toposort(int k, int[][] A){\\n        //need a int[] to record the indegree of each number [1, k]\\n        int[] deg = new int[k+1];\\n        //need a list to record the order of each number, then return this list\\n        List<Integer> res = new ArrayList<>();\\n        //need a 2-D list to be the graph, and fill the graph\\n        List<List<Integer>> graph = new ArrayList<>();\\n        for(int i = 0; i<k; i++){\\n            graph.add(new ArrayList<Integer>());\\n        }\\n        //need a queue to do the BFS\\n        Queue<Integer> queue = new LinkedList<>();\\n        \\n        //First, we need to establish the graph, following the given A\\n        for(int[] a : A){\\n            int from = a[0];\\n            int to = a[1];\\n            graph.get(from-1).add(to);\\n            deg[to]++;\\n        }\\n        //Second, after building a graph, we start the bfs,\\n        //that is, traverse the node with 0 degree\\n        for(int i = 1; i<= k; i++){\\n            if(deg[i] == 0){\\n                queue.offer(i);\\n                res.add(i);\\n            }\\n        }\\n        //Third, start the topo sort\\n        while(!queue.isEmpty()){\\n            int node = queue.poll();\\n            List<Integer> list = graph.get(node-1);\\n            for(int i : list){\\n                if(--deg[i] == 0){\\n                    queue.offer(i);\\n                    res.add(i);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    //Using topological sort to solve this problem\\n    public int[][] buildMatrix(int k, int[][] rowC, int[][] colC) {\\n        //First, get the topo-sorted of row and col\\n        List<Integer> row = toposort(k, rowC);\\n        List<Integer> col = toposort(k, colC);\\n        //base case: when the length of row or col is less than k, return empty.\\n        //That is: there is a loop in established graph\\n        if(row.size() < k || col.size() < k) return new int[0][0];\\n        \\n        int[][] res = new int[k][k];\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int i = 0; i < k; i++){\\n            //we record the number corresbonding to each column:\\n            //[number, column index]\\n            map.put(col.get(i), i); \\n        }\\n        //col: 3 2 1 \\n        //row: 1 3 2 \\n        for(int i = 0; i < k; i++){\\n            //For each row: we have number row.get(i). And we need to know \\n            // which column we need to assign, which is from map.get(row.get(i))\\n            //known by map.get()\\n            res[i][map.get(row.get(i))] = row.get(i);\\n        }\\n        return res;\\n    }\\n    \\n    private List<Integer> toposort(int k, int[][] A){\\n        //need a int[] to record the indegree of each number [1, k]\\n        int[] deg = new int[k+1];\\n        //need a list to record the order of each number, then return this list\\n        List<Integer> res = new ArrayList<>();\\n        //need a 2-D list to be the graph, and fill the graph\\n        List<List<Integer>> graph = new ArrayList<>();\\n        for(int i = 0; i<k; i++){\\n            graph.add(new ArrayList<Integer>());\\n        }\\n        //need a queue to do the BFS\\n        Queue<Integer> queue = new LinkedList<>();\\n        \\n        //First, we need to establish the graph, following the given A\\n        for(int[] a : A){\\n            int from = a[0];\\n            int to = a[1];\\n            graph.get(from-1).add(to);\\n            deg[to]++;\\n        }\\n        //Second, after building a graph, we start the bfs,\\n        //that is, traverse the node with 0 degree\\n        for(int i = 1; i<= k; i++){\\n            if(deg[i] == 0){\\n                queue.offer(i);\\n                res.add(i);\\n            }\\n        }\\n        //Third, start the topo sort\\n        while(!queue.isEmpty()){\\n            int node = queue.poll();\\n            List<Integer> list = graph.get(node-1);\\n            for(int i : list){\\n                if(--deg[i] == 0){\\n                    queue.offer(i);\\n                    res.add(i);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2505158,
                "title": "python-3-tarjan-s-algo-for-topological-sort-and-numpy-for-smart-indexing",
                "content": "```\\nimport numpy as np\\n\\nclass NotADag(Exception):\\n    pass\\n\\nclass Solution:\\n    def __init__(self):\\n        outEdge = {}\\n        visited = []\\n        ret = []\\n        \\n    def topoSort(self, cond, k):\\n        # turn into a dependency graph\\n        #inEdge = {} # dict of sets\\n        self.outEdge = {}\\n        self.ret = []\\n        self.visited = [0] * (k+1)\\n        for sm, gt in cond:\\n            try:\\n                self.outEdge[sm].add(gt)\\n            except KeyError:\\n                self.outEdge[sm] = set((gt,))\\n        for v in range(1, k+1):\\n            self.helper(v)  # modifies ret\\n        self.ret.reverse()\\n        return self.ret\\n    \\n    def helper(self, v):\\n        if self.visited[v] == 2:\\n            return\\n        if self.visited[v] == 1:\\n            raise NotADag\\n        self.visited[v] = 1\\n        try:\\n            for node in self.outEdge[v]:\\n                self.helper(node)\\n        except KeyError:\\n            pass\\n        self.visited[v] = 2\\n        self.ret.append(v)\\n        return\\n        \\n    def buildMatrix(self, k: int, rowC: List[List[int]], colC: List[List[int]]) -> List[List[int]]:\\n        try:\\n            rt = np.array(self.topoSort(rowC, k), dtype=\"int\")\\n            ct = np.array(self.topoSort(colC, k), dtype=\"int\")\\n        except NotADag:\\n            return []\\n        ret = np.zeros((k, k), dtype=\"int\")\\n        ret[np.argsort(rt-1), np.argsort(ct-1)] = range(1, k+1)\\n        return ret.tolist()\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Topological Sort"
                ],
                "code": "```\\nimport numpy as np\\n\\nclass NotADag(Exception):\\n    pass\\n\\nclass Solution:\\n    def __init__(self):\\n        outEdge = {}\\n        visited = []\\n        ret = []\\n        \\n    def topoSort(self, cond, k):\\n        # turn into a dependency graph\\n        #inEdge = {} # dict of sets\\n        self.outEdge = {}\\n        self.ret = []\\n        self.visited = [0] * (k+1)\\n        for sm, gt in cond:\\n            try:\\n                self.outEdge[sm].add(gt)\\n            except KeyError:\\n                self.outEdge[sm] = set((gt,))\\n        for v in range(1, k+1):\\n            self.helper(v)  # modifies ret\\n        self.ret.reverse()\\n        return self.ret\\n    \\n    def helper(self, v):\\n        if self.visited[v] == 2:\\n            return\\n        if self.visited[v] == 1:\\n            raise NotADag\\n        self.visited[v] = 1\\n        try:\\n            for node in self.outEdge[v]:\\n                self.helper(node)\\n        except KeyError:\\n            pass\\n        self.visited[v] = 2\\n        self.ret.append(v)\\n        return\\n        \\n    def buildMatrix(self, k: int, rowC: List[List[int]], colC: List[List[int]]) -> List[List[int]]:\\n        try:\\n            rt = np.array(self.topoSort(rowC, k), dtype=\"int\")\\n            ct = np.array(self.topoSort(colC, k), dtype=\"int\")\\n        except NotADag:\\n            return []\\n        ret = np.zeros((k, k), dtype=\"int\")\\n        ret[np.argsort(rt-1), np.argsort(ct-1)] = range(1, k+1)\\n        return ret.tolist()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2504847,
                "title": "c-kahn-s-algorithm-implementation",
                "content": "**Idea**\\nFor numbers 1, ..., k, find their \"row positions\" and \"col positions\" respectively by using **topological sort**.\\nTo find topological order, we use the concept of **Kahn\\'s Algo**.\\n\\n*( Some details I also referred to other solutions on discussion and internet resources, so I don\\'t explain here but still leave comments FYI. \\nI mainly want to share my code to those who get stuck in coding. )*\\n\\n**C++**\\n```\\nclass Solution {\\n    //Kahn\\'s Algorithm\\n    vector<int> topologicalSort(int k, vector<vector<int>> &conditions){\\n        vector<vector<int> > adjacent(k + 1); \\n        vector<int> inDegree(k + 1, 0);\\n        vector<int> order;\\n        vector<int> res(k + 1);\\n        queue<int> q;\\n        \\n        //Build adjacent list & count degrees of each node\\n        for(auto &c : conditions){\\n            int a = c[0], b = c[1];\\n            adjacent[a].push_back(b);\\n            inDegree[b]++;\\n        }\\n        //Push nodes with 0 degree into queue and update neighbors\\' degree, loop until q.empty()\\n        //Queue q keeps all nodes with 0 degree currently\\n        for(int i = 1; i <= k; i++){\\n            if(inDegree[i] == 0) q.push(i);\\n        }\\n        while(!q.empty()){\\n            int curr = q.front(); q.pop();\\n            order.push_back(curr);\\n            for(int &i : adjacent[curr]){\\n                if(--inDegree[i] == 0) q.push(i);\\n            }\\n        }\\n        //*If order.size() != k, it means there\\'s a cycle in the graph\\n        if(order.size() != k) return vector<int> ();\\n        \\n        //Otherwise, generate the order of every node, and store the result in res\\n        int cnt = 0;\\n        for(int &num : order){\\n            res[num] = cnt++;    \\n        }\\n        return res;\\n        \\n    }\\npublic:\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        vector<vector<int> > res(k, vector<int> (k, 0));\\n        vector<int> rowNums = topologicalSort(k, rowConditions);\\n        vector<int> colNums = topologicalSort(k, colConditions);\\n        if(rowNums.empty() || colNums.empty()) return vector<vector<int> > ();\\n        for(int i = 1; i <= k; i++){\\n            res[rowNums[i]][colNums[i]] = i; //i will put on the rowNums[i]-th row, colNums[i]-th column\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    //Kahn\\'s Algorithm\\n    vector<int> topologicalSort(int k, vector<vector<int>> &conditions){\\n        vector<vector<int> > adjacent(k + 1); \\n        vector<int> inDegree(k + 1, 0);\\n        vector<int> order;\\n        vector<int> res(k + 1);\\n        queue<int> q;\\n        \\n        //Build adjacent list & count degrees of each node\\n        for(auto &c : conditions){\\n            int a = c[0], b = c[1];\\n            adjacent[a].push_back(b);\\n            inDegree[b]++;\\n        }\\n        //Push nodes with 0 degree into queue and update neighbors\\' degree, loop until q.empty()\\n        //Queue q keeps all nodes with 0 degree currently\\n        for(int i = 1; i <= k; i++){\\n            if(inDegree[i] == 0) q.push(i);\\n        }\\n        while(!q.empty()){\\n            int curr = q.front(); q.pop();\\n            order.push_back(curr);\\n            for(int &i : adjacent[curr]){\\n                if(--inDegree[i] == 0) q.push(i);\\n            }\\n        }\\n        //*If order.size() != k, it means there\\'s a cycle in the graph\\n        if(order.size() != k) return vector<int> ();\\n        \\n        //Otherwise, generate the order of every node, and store the result in res\\n        int cnt = 0;\\n        for(int &num : order){\\n            res[num] = cnt++;    \\n        }\\n        return res;\\n        \\n    }\\npublic:\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        vector<vector<int> > res(k, vector<int> (k, 0));\\n        vector<int> rowNums = topologicalSort(k, rowConditions);\\n        vector<int> colNums = topologicalSort(k, colConditions);\\n        if(rowNums.empty() || colNums.empty()) return vector<vector<int> > ();\\n        for(int i = 1; i <= k; i++){\\n            res[rowNums[i]][colNums[i]] = i; //i will put on the rowNums[i]-th row, colNums[i]-th column\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2504729,
                "title": "topological-sort-best-solution",
                "content": "\\n\\t\\n\\t// Topo Sort\\n    vector<int> topo(int arr[],int k,vector<int> graph[]){\\n        \\n        queue<int> q;\\n        for(int i=0;i<k;i++){\\n            if(arr[i] == 0){\\n                q.push(i);\\n            }\\n        }\\n        vector<int> ans;\\n        int cnt = 0;\\n\\t\\t\\n        while(!q.empty()){\\n            \\n            auto f = q.front();\\n            ans.push_back(f);\\n            q.pop();\\n            for(auto i:graph[f]){\\n                if(--arr[i] == 0){\\n                    q.push(i);\\n                }\\n            }\\n            cnt++;\\n        }\\n        if(cnt == k){\\n            return ans;\\n        }\\n        return {};\\n    }\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowCon, vector<vector<int>>& colCon) {\\n        \\n\\t\\t// Indegree Arrays\\n        int rowInd[k];\\n        int colInd[k];\\n        for(int i=0;i<k;i++){\\n            rowInd[i] = 0;\\n            colInd[i] = 0;\\n        }\\n\\t\\t// Graphs \\n        vector<int> graph1[k];\\n        vector<int> graph2[k];\\n        for(auto i:rowCon){\\n             rowInd[i[1]-1]++;\\n             graph1[i[0]-1].push_back(i[1]-1);\\n        }\\n        for(auto i:colCon){\\n            colInd[i[1]-1]++;\\n            graph2[i[0]-1].push_back(i[1]-1);\\n        }\\n        // Topo Sort to Individuals\\n        vector<int> r = topo(rowInd,k,graph1);\\n        vector<int> c = topo(colInd,k,graph2);\\n        if(r.size() == 0 || c.size() == 0){\\n            return {};\\n        }\\n        else{\\n            vector<vector<int>> ans(k,vector<int>(k,0));\\n            // Finding Indices \\n            for(int i=0;i<k;i++){\\n                auto it1 = find(r.begin(),r.end(),i) - r.begin();\\n                auto it2 = find(c.begin(),c.end(),i) - c.begin();\\n                //Setting Values\\n                ans[it1][it2] = i+1;\\n            }\\n            return ans;\\n        }\\n        return {};\\n       }",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "\\n\\t\\n\\t// Topo Sort\\n    vector<int> topo(int arr[],int k,vector<int> graph[]){\\n        \\n        queue<int> q;\\n        for(int i=0;i<k;i++){\\n            if(arr[i] == 0){\\n                q.push(i);\\n            }\\n        }\\n        vector<int> ans;\\n        int cnt = 0;\\n\\t\\t\\n        while(!q.empty()){\\n            \\n            auto f = q.front();\\n            ans.push_back(f);\\n            q.pop();\\n            for(auto i:graph[f]){\\n                if(--arr[i] == 0){\\n                    q.push(i);\\n                }\\n            }\\n            cnt++;\\n        }\\n        if(cnt == k){\\n            return ans;\\n        }\\n        return {};\\n    }\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowCon, vector<vector<int>>& colCon) {\\n        \\n\\t\\t// Indegree Arrays\\n        int rowInd[k];\\n        int colInd[k];\\n        for(int i=0;i<k;i++){\\n            rowInd[i] = 0;\\n            colInd[i] = 0;\\n        }\\n\\t\\t// Graphs \\n        vector<int> graph1[k];\\n        vector<int> graph2[k];\\n        for(auto i:rowCon){\\n             rowInd[i[1]-1]++;\\n             graph1[i[0]-1].push_back(i[1]-1);\\n        }\\n        for(auto i:colCon){\\n            colInd[i[1]-1]++;\\n            graph2[i[0]-1].push_back(i[1]-1);\\n        }\\n        // Topo Sort to Individuals\\n        vector<int> r = topo(rowInd,k,graph1);\\n        vector<int> c = topo(colInd,k,graph2);\\n        if(r.size() == 0 || c.size() == 0){\\n            return {};\\n        }\\n        else{\\n            vector<vector<int>> ans(k,vector<int>(k,0));\\n            // Finding Indices \\n            for(int i=0;i<k;i++){\\n                auto it1 = find(r.begin(),r.end(),i) - r.begin();\\n                auto it2 = find(c.begin(),c.end(),i) - c.begin();\\n                //Setting Values\\n                ans[it1][it2] = i+1;\\n            }\\n            return ans;\\n        }\\n        return {};\\n       }",
                "codeTag": "Unknown"
            },
            {
                "id": 2502817,
                "title": "simple-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    bool Kahn(vector<int> adj[],vector<int> &res,int k)\\n    {   \\n        vector<int> indegree(k+1,0);\\n        \\n        for(int i=1;i<=k;i++)\\n        {\\n            for(auto &v : adj[i])\\n                indegree[v]++;\\n        }\\n        \\n        queue<int> q;\\n        \\n        for(int i=1;i<=k;i++)\\n        {\\n            if(indegree[i]==0)\\n                q.push(i);\\n        }\\n        \\n        while(!q.empty())\\n        {\\n            int u=q.front();\\n            q.pop();\\n            \\n            res.push_back(u);\\n            \\n            for(auto &v : adj[u])\\n            {\\n                indegree[v]--;\\n                if(indegree[v]==0)\\n                    q.push(v);\\n            }\\n        }\\n        \\n        reverse(res.begin(),res.end());\\n        \\n        return (res.size()==k);\\n    }\\n    \\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rows, vector<vector<int>>& cols) {\\n        \\n        vector<int> adjr[k+1];\\n        vector<int> adjc[k+1];\\n        \\n        for(auto &v : rows)\\n        {\\n            adjr[v[1]].push_back(v[0]);\\n        }\\n        \\n        for(auto &v : cols)\\n        {\\n            adjc[v[1]].push_back(v[0]);\\n        }\\n        \\n        vector<int> ansr,ansc;\\n        \\n        bool resr=Kahn(adjr,ansr,k);\\n        bool resc=Kahn(adjc,ansc,k);\\n        \\n        if(resr==false or resc==false)\\n            return {};\\n        \\n        unordered_map<int,vector<int>> mp;\\n        \\n        for(int i=0;i<k;i++)\\n        {\\n            mp[ansr[i]].push_back(i);\\n        }\\n        \\n        for(int i=0;i<k;i++)\\n        {\\n            mp[ansc[i]].push_back(i);\\n        }\\n        \\n        vector<vector<int>> res(k,vector<int>(k,0));\\n        \\n        for(auto &p : mp)\\n        {\\n            vector<int> v=p.second;\\n            int ele=p.first;\\n            \\n            res[v[0]][v[1]]=ele;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool Kahn(vector<int> adj[],vector<int> &res,int k)\\n    {   \\n        vector<int> indegree(k+1,0);\\n        \\n        for(int i=1;i<=k;i++)\\n        {\\n            for(auto &v : adj[i])\\n                indegree[v]++;\\n        }\\n        \\n        queue<int> q;\\n        \\n        for(int i=1;i<=k;i++)\\n        {\\n            if(indegree[i]==0)\\n                q.push(i);\\n        }\\n        \\n        while(!q.empty())\\n        {\\n            int u=q.front();\\n            q.pop();\\n            \\n            res.push_back(u);\\n            \\n            for(auto &v : adj[u])\\n            {\\n                indegree[v]--;\\n                if(indegree[v]==0)\\n                    q.push(v);\\n            }\\n        }\\n        \\n        reverse(res.begin(),res.end());\\n        \\n        return (res.size()==k);\\n    }\\n    \\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rows, vector<vector<int>>& cols) {\\n        \\n        vector<int> adjr[k+1];\\n        vector<int> adjc[k+1];\\n        \\n        for(auto &v : rows)\\n        {\\n            adjr[v[1]].push_back(v[0]);\\n        }\\n        \\n        for(auto &v : cols)\\n        {\\n            adjc[v[1]].push_back(v[0]);\\n        }\\n        \\n        vector<int> ansr,ansc;\\n        \\n        bool resr=Kahn(adjr,ansr,k);\\n        bool resc=Kahn(adjc,ansc,k);\\n        \\n        if(resr==false or resc==false)\\n            return {};\\n        \\n        unordered_map<int,vector<int>> mp;\\n        \\n        for(int i=0;i<k;i++)\\n        {\\n            mp[ansr[i]].push_back(i);\\n        }\\n        \\n        for(int i=0;i<k;i++)\\n        {\\n            mp[ansc[i]].push_back(i);\\n        }\\n        \\n        vector<vector<int>> res(k,vector<int>(k,0));\\n        \\n        for(auto &p : mp)\\n        {\\n            vector<int> v=p.second;\\n            int ele=p.first;\\n            \\n            res[v[0]][v[1]]=ele;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2502631,
                "title": "python-based-on-q207-simple-topological-sort-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:\\n        returner = [[0 for _ in range(k)] for _ in range(k)]\\n        \\n        first =[[0 for _ in range(k)] for _ in range(k)]\\n        second = [[0 for _ in range(k)] for _ in range(k)]\\n        \\n        vertical = defaultdict(list)\\n        horizontal = defaultdict(list)\\n        vertical_in = defaultdict(int)\\n        horizontal_in = defaultdict(int)\\n        for i in range(1, k + 1):\\n            vertical_in[i] = 0\\n            horizontal_in[i] = 0\\n        for row in rowConditions:\\n            vertical[row[0]].append(row[1])\\n            vertical_in[row[1]] += 1\\n        for col in colConditions:\\n            horizontal[col[0]].append(col[1])\\n            horizontal_in[col[1]] += 1\\n        \\n        verti_order = []\\n        verti_queue = deque()\\n        verti_visited = set()\\n        for key in vertical_in.keys():\\n            if (vertical_in[key] == 0):\\n                verti_queue.append(key)\\n        \\n        if (len(verti_queue) == 0):\\n            return []\\n        \\n        cycle = False\\n        while (verti_queue):\\n            cur = verti_queue.popleft()\\n            \\n            verti_order.append(cur)\\n            verti_visited.add(cur)\\n            for neighbour in vertical[cur]:\\n                if (neighbour in verti_visited):\\n                    cycle = True\\n                    break\\n                print(neighbour, vertical_in[neighbour])\\n                vertical_in[neighbour] -= 1\\n                if (vertical_in[neighbour] == 0):\\n                    verti_queue.append(neighbour)\\n            if (cycle):\\n                break        \\n        if (cycle):\\n            return []\\n        \\n        hori_order = []\\n        hori_queue = deque()\\n        hori_visited = set()\\n        for key in horizontal_in.keys():\\n            if (horizontal_in[key] == 0):\\n                hori_queue.append(key)\\n        if (len(hori_queue) == 0):\\n            return []\\n        cycle = False\\n        \\n        while (hori_queue):\\n            cur = hori_queue.popleft()\\n            hori_order.append(cur)\\n            hori_visited.add(cur)\\n            for neighbour in horizontal[cur]:\\n                if (neighbour in hori_visited):\\n                    cycle = True\\n                    break\\n                horizontal_in[neighbour] -= 1\\n                if (horizontal_in[neighbour] == 0):\\n                    hori_queue.append(neighbour)\\n            if (cycle):\\n                break\\n        \\n        if (cycle):\\n            return []\\n       \\n        if (len(verti_order) != k or len(hori_order) != k):\\n            return []\\n        \\n        for i in range(k):\\n            for j in range(k):\\n                first[i][j] = verti_order[i]\\n                second[i][j] = hori_order[j]\\n                \\n        for i in range(k):\\n            for j in range(k):\\n                if (first[i][j] == second[i][j]):\\n                    returner[i][j] = first[i][j]\\n        return returner\\n```\\n\\nThe problem can be broken down into three parts:\\n1. According to the vertical order, fill Matrix A row by row, from top to bottom, with each row having the same number\\n2. Accroding to the horizontal order, fill Matrix B col by col, from left to right, with each col having the same number\\n3. \"OVERLAP\" Matrix A with Matirx B, fill the result with the following logic:\\n\\t`\\n\\tif (MatrixA[i][j] == MatrixB[i][j]):\\n\\t\\tresult[i][j] = MatrixA[i][j]\\n\\t`\\n\\nAnd finding the vertical and horizontal order is basically identital to the [Course Schedule Question ](https://leetcode.com/problems/course-schedule/), where you need to do some additional check:\\n1. No cycle\\n2.`len(vertical_order) == len(horizontal_order), and len(vertical_order) == k` (in terms of the Course Schedule problem, it is identical to the expression \"You can take all courses\")",
                "solutionTags": [
                    "Python",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution:\\n    def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:\\n        returner = [[0 for _ in range(k)] for _ in range(k)]\\n        \\n        first =[[0 for _ in range(k)] for _ in range(k)]\\n        second = [[0 for _ in range(k)] for _ in range(k)]\\n        \\n        vertical = defaultdict(list)\\n        horizontal = defaultdict(list)\\n        vertical_in = defaultdict(int)\\n        horizontal_in = defaultdict(int)\\n        for i in range(1, k + 1):\\n            vertical_in[i] = 0\\n            horizontal_in[i] = 0\\n        for row in rowConditions:\\n            vertical[row[0]].append(row[1])\\n            vertical_in[row[1]] += 1\\n        for col in colConditions:\\n            horizontal[col[0]].append(col[1])\\n            horizontal_in[col[1]] += 1\\n        \\n        verti_order = []\\n        verti_queue = deque()\\n        verti_visited = set()\\n        for key in vertical_in.keys():\\n            if (vertical_in[key] == 0):\\n                verti_queue.append(key)\\n        \\n        if (len(verti_queue) == 0):\\n            return []\\n        \\n        cycle = False\\n        while (verti_queue):\\n            cur = verti_queue.popleft()\\n            \\n            verti_order.append(cur)\\n            verti_visited.add(cur)\\n            for neighbour in vertical[cur]:\\n                if (neighbour in verti_visited):\\n                    cycle = True\\n                    break\\n                print(neighbour, vertical_in[neighbour])\\n                vertical_in[neighbour] -= 1\\n                if (vertical_in[neighbour] == 0):\\n                    verti_queue.append(neighbour)\\n            if (cycle):\\n                break        \\n        if (cycle):\\n            return []\\n        \\n        hori_order = []\\n        hori_queue = deque()\\n        hori_visited = set()\\n        for key in horizontal_in.keys():\\n            if (horizontal_in[key] == 0):\\n                hori_queue.append(key)\\n        if (len(hori_queue) == 0):\\n            return []\\n        cycle = False\\n        \\n        while (hori_queue):\\n            cur = hori_queue.popleft()\\n            hori_order.append(cur)\\n            hori_visited.add(cur)\\n            for neighbour in horizontal[cur]:\\n                if (neighbour in hori_visited):\\n                    cycle = True\\n                    break\\n                horizontal_in[neighbour] -= 1\\n                if (horizontal_in[neighbour] == 0):\\n                    hori_queue.append(neighbour)\\n            if (cycle):\\n                break\\n        \\n        if (cycle):\\n            return []\\n       \\n        if (len(verti_order) != k or len(hori_order) != k):\\n            return []\\n        \\n        for i in range(k):\\n            for j in range(k):\\n                first[i][j] = verti_order[i]\\n                second[i][j] = hori_order[j]\\n                \\n        for i in range(k):\\n            for j in range(k):\\n                if (first[i][j] == second[i][j]):\\n                    returner[i][j] = first[i][j]\\n        return returner\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2502575,
                "title": "java-topological-sort-o-v-e",
                "content": "```\\nclass Solution {\\n    public int[][] buildMatrix(int k, int[][] rowConditions, int[][] colConditions) {\\n        List<Integer> row = new ArrayList<>();\\n        List<Integer> col = new ArrayList<>();\\n        helper(row, rowConditions, k);\\n        helper(col, colConditions, k);\\n        \\n        Collections.reverse(row);\\n        Collections.reverse(col);\\n        \\n        if(row.size() != k || col.size() != k) return new int[0][];\\n        \\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for(int i=0; i<k; i++){\\n            map.putIfAbsent(row.get(i), new ArrayList<>());\\n            map.get(row.get(i)).add(i);\\n        }\\n        for(int i=0; i<k; i++){\\n            map.get(col.get(i)).add(i);\\n        }\\n        int[][] rst = new int[k][k];\\n        for(Map.Entry<Integer, List<Integer>> entry : map.entrySet()){\\n            int x = entry.getValue().get(0);\\n            int y = entry.getValue().get(1);\\n            rst[x][y] = entry.getKey();\\n        }\\n        return rst;\\n    }\\n    boolean isCycle;\\n    private void helper(List<Integer> list, int[][] conditions, int k){\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        for(int i=1; i<=k; i++){\\n            graph.put(i, new ArrayList<>());\\n        }\\n        for(int[] c : conditions){\\n            if(!graph.get(c[0]).contains(c[1]))\\n                graph.get(c[0]).add(c[1]);\\n        }\\n        \\n        isCycle = false;\\n        boolean[] visited = new boolean[k+1];\\n        boolean[] path = new boolean[k+1];\\n        \\n        for(int i=1; i<=k; i++){\\n            if(!visited[i]){\\n                dfs(i, visited, path, list, graph);\\n                if(isCycle){\\n                    list.clear();\\n                    return;\\n                }\\n            }\\n        }  \\n    }\\n    \\n    private void dfs(int num, boolean[] visited, boolean[] path, List<Integer> list, Map<Integer, List<Integer>> graph){\\n        if(path[num]) isCycle = true;\\n        if(isCycle || visited[num]) return;\\n        visited[num] = true;\\n        path[num] = true;\\n        if(graph.get(num).size() > 0){\\n            for(int next : graph.get(num)){\\n                dfs(next, visited, path, list, graph);\\n                if(isCycle) return;\\n            }\\n        }\\n        path[num] = false;\\n        list.add(num);   \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] buildMatrix(int k, int[][] rowConditions, int[][] colConditions) {\\n        List<Integer> row = new ArrayList<>();\\n        List<Integer> col = new ArrayList<>();\\n        helper(row, rowConditions, k);\\n        helper(col, colConditions, k);\\n        \\n        Collections.reverse(row);\\n        Collections.reverse(col);\\n        \\n        if(row.size() != k || col.size() != k) return new int[0][];\\n        \\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for(int i=0; i<k; i++){\\n            map.putIfAbsent(row.get(i), new ArrayList<>());\\n            map.get(row.get(i)).add(i);\\n        }\\n        for(int i=0; i<k; i++){\\n            map.get(col.get(i)).add(i);\\n        }\\n        int[][] rst = new int[k][k];\\n        for(Map.Entry<Integer, List<Integer>> entry : map.entrySet()){\\n            int x = entry.getValue().get(0);\\n            int y = entry.getValue().get(1);\\n            rst[x][y] = entry.getKey();\\n        }\\n        return rst;\\n    }\\n    boolean isCycle;\\n    private void helper(List<Integer> list, int[][] conditions, int k){\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        for(int i=1; i<=k; i++){\\n            graph.put(i, new ArrayList<>());\\n        }\\n        for(int[] c : conditions){\\n            if(!graph.get(c[0]).contains(c[1]))\\n                graph.get(c[0]).add(c[1]);\\n        }\\n        \\n        isCycle = false;\\n        boolean[] visited = new boolean[k+1];\\n        boolean[] path = new boolean[k+1];\\n        \\n        for(int i=1; i<=k; i++){\\n            if(!visited[i]){\\n                dfs(i, visited, path, list, graph);\\n                if(isCycle){\\n                    list.clear();\\n                    return;\\n                }\\n            }\\n        }  \\n    }\\n    \\n    private void dfs(int num, boolean[] visited, boolean[] path, List<Integer> list, Map<Integer, List<Integer>> graph){\\n        if(path[num]) isCycle = true;\\n        if(isCycle || visited[num]) return;\\n        visited[num] = true;\\n        path[num] = true;\\n        if(graph.get(num).size() > 0){\\n            for(int next : graph.get(num)){\\n                dfs(next, visited, path, list, graph);\\n                if(isCycle) return;\\n            }\\n        }\\n        path[num] = false;\\n        list.add(num);   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2501955,
                "title": "easy",
                "content": "```\\nclass Solution {\\npublic:  \\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& row, vector<vector<int>>& col) {\\n        vector<int >row_degree(k+1,0),col_degree(k+1,0);\\n         queue<int >row_bfs,col_bfs;\\n        unordered_map<int,int>row_idx,col_idx;\\n        unordered_map<int,vector<int>>row_adj,col_adj;\\n        for(auto& i:row)\\n        {\\n            row_degree[i[1]]++;\\n            row_adj[i[0]].push_back(i[1]);\\n        }\\n        for(int i=1;i<=k;i++)\\n        {\\n            //cout<<i<<\" \";\\n            if(row_degree[i]==0)row_bfs.push(i);\\n        }\\n        //cout<<row_bfs.size();\\n        if(row_bfs.size()==0)return{};\\n        \\n        for(auto& i:col)\\n        {\\n            col_degree[i[1]]++;\\n            col_adj[i[0]].push_back(i[1]);\\n        }\\n         for(int i=1;i<=k;i++)\\n        {\\n            if(col_degree[i]==0)col_bfs.push(i);\\n        }\\n        if(col_bfs.size()==0)return{};\\n        int p=0;\\n        while(!row_bfs.empty())\\n        {\\n           int temp=row_bfs.front();\\n            row_bfs.pop();\\n            row_idx[temp]=p++;\\n            for(auto& pq:row_adj[temp])\\n            {\\n                --row_degree[pq];\\n              if(row_degree[pq]==0)\\n               row_bfs.push(pq);\\n            }\\n             \\n            \\n        }\\n        if(p!=k)return {};\\n        p=0;\\n        while(!col_bfs.empty())\\n        {\\n           int temp=col_bfs.front();\\n            col_bfs.pop();\\n            col_idx[temp]=p++;\\n        for(auto& pq:col_adj[temp])\\n            {\\n                --col_degree[pq];\\n              if(col_degree[pq]==0)\\n               col_bfs.push(pq);\\n            }\\n            \\n        }\\n        if(p!=k)return {};\\n        vector<vector<int>>res(k,vector<int>(k,0));\\n        for(int i=1;i<=k;i++)\\n        {\\n           // cout<<col_idx[i]<<\" \";\\n            \\n            res[row_idx[i]][col_idx[i]]=i;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:  \\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& row, vector<vector<int>>& col) {\\n        vector<int >row_degree(k+1,0),col_degree(k+1,0);\\n         queue<int >row_bfs,col_bfs;\\n        unordered_map<int,int>row_idx,col_idx;\\n        unordered_map<int,vector<int>>row_adj,col_adj;\\n        for(auto& i:row)\\n        {\\n            row_degree[i[1]]++;\\n            row_adj[i[0]].push_back(i[1]);\\n        }\\n        for(int i=1;i<=k;i++)\\n        {\\n            //cout<<i<<\" \";\\n            if(row_degree[i]==0)row_bfs.push(i);\\n        }\\n        //cout<<row_bfs.size();\\n        if(row_bfs.size()==0)return{};\\n        \\n        for(auto& i:col)\\n        {\\n            col_degree[i[1]]++;\\n            col_adj[i[0]].push_back(i[1]);\\n        }\\n         for(int i=1;i<=k;i++)\\n        {\\n            if(col_degree[i]==0)col_bfs.push(i);\\n        }\\n        if(col_bfs.size()==0)return{};\\n        int p=0;\\n        while(!row_bfs.empty())\\n        {\\n           int temp=row_bfs.front();\\n            row_bfs.pop();\\n            row_idx[temp]=p++;\\n            for(auto& pq:row_adj[temp])\\n            {\\n                --row_degree[pq];\\n              if(row_degree[pq]==0)\\n               row_bfs.push(pq);\\n            }\\n             \\n            \\n        }\\n        if(p!=k)return {};\\n        p=0;\\n        while(!col_bfs.empty())\\n        {\\n           int temp=col_bfs.front();\\n            col_bfs.pop();\\n            col_idx[temp]=p++;\\n        for(auto& pq:col_adj[temp])\\n            {\\n                --col_degree[pq];\\n              if(col_degree[pq]==0)\\n               col_bfs.push(pq);\\n            }\\n            \\n        }\\n        if(p!=k)return {};\\n        vector<vector<int>>res(k,vector<int>(k,0));\\n        for(int i=1;i<=k;i++)\\n        {\\n           // cout<<col_idx[i]<<\" \";\\n            \\n            res[row_idx[i]][col_idx[i]]=i;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2501796,
                "title": "c-must-see-solution-toposort-explained-with-example",
                "content": "\\n1) Check for Cycles in Rows and Columns array.\\n2) If no cycle detected , form the topological order of both the rows and columns.\\n3) Now , with the formed order , create the matrix.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n\\t//Code to check if cycle exists\\n\\t\\n    bool cycleCheck(vector<int> adj[] , vector<bool>& vis , vector<bool>& pathVis , int node) {\\n        vis[node] = true;\\n        pathVis[node] = true;\\n        \\n        for(auto x : adj[node]) {\\n            if(!vis[x]) {\\n                if(cycleCheck(adj , vis , pathVis , x))\\n                    return true;\\n            }\\n            else {\\n                if(pathVis[x] == true) {\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        pathVis[node] = false;\\n        return false;\\n    }\\n    \\n\\t\\n\\t// Create Topological order \\n    vector<int> topo(vector<int> adj[] , int k , vector<int> indeg) { \\n        \\n        queue<int> q;\\n        vector<int> tp;\\n        \\n        for(int i = 1 ; i <= k ; i++) {\\n            if(indeg[i] == 0) {\\n                q.push(i);\\n            }\\n        }\\n        \\n        while(!q.empty()) {\\n            int gh = q.front();\\n            \\n            tp.push_back(gh);\\n            q.pop();\\n            \\n            for(auto x : adj[gh]) {\\n                indeg[x]--;\\n                if(indeg[x] == 0) {\\n                    q.push(x);\\n                }\\n            }\\n        }\\n        \\n        return tp;\\n     }\\n    \\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        vector<int> rowAdj[k + 1] , colAdj[k + 1]; // Adjacency matrix for row and columns\\n         \\n        vector<vector<int>> res(k , vector<int>(k , 0));\\n        \\n        vector<int> Cindegree(k + 1 , 0)  , Rindegree(k + 1, 0); //indegree for row and column graph\\n        \\n        for(auto x : rowConditions) { //constructing row graph\\n            rowAdj[x[0]].push_back(x[1]);\\n            Rindegree[x[1]]++;\\n        }\\n        \\n        for(auto x : colConditions) { //Constructing Column graph\\n            colAdj[x[0]].push_back(x[1]);\\n            Cindegree[x[1]]++;\\n        }\\n        \\n        vector<bool> Rvis(k + 1, false) , RpathVis(k + 1 , false) , Cvis(k + 1 , false) , CpathVis(k + 1 , false);\\n        \\n\\t\\t//Check for cycle for row & Column\\n        if(cycleCheck(colAdj , Cvis , CpathVis , 1) || cycleCheck(rowAdj , Rvis , RpathVis , 1))\\n            return {}; // If any cycle , there cannot be any answer\\n        \\n\\t\\t\\n\\t\\t//Find topological order of rows and column\\n\\t\\t\\n        vector<int> Rtop = topo(rowAdj , k , Rindegree);\\n        vector<int> Ctop = topo(colAdj , k , Cindegree);\\n        \\n        if(Rtop.size() != k || Ctop.size() != k) {\\n            return {};\\n        }\\n        \\n\\t\\t// For Eg:\\n\\t\\t// Column Order : 3 2 1\\n\\t\\t// Row Order : 1 3 2\\n\\t\\t// Take Any of the order as the reference. Lets take Row for example.\\n\\t\\t// Position of 1 in row is 0 , position of 1 in column is 2 , therefore position in matrix should be res[0][2]. Do similarly for others.\\n\\t\\t\\n        unordered_map<int , int> mp;\\n        \\n        for(int i=0;i<Ctop.size();i++) {\\n            mp[Ctop[i]] = i;\\n        }\\n        // Create the matrix now.\\n        for(int k = 0 ; k < Rtop.size(); k++) {\\n            res[k][mp[Rtop[k]]] = Rtop[k];\\n        }\\n                   \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n\\t//Code to check if cycle exists\\n\\t\\n    bool cycleCheck(vector<int> adj[] , vector<bool>& vis , vector<bool>& pathVis , int node) {\\n        vis[node] = true;\\n        pathVis[node] = true;\\n        \\n        for(auto x : adj[node]) {\\n            if(!vis[x]) {\\n                if(cycleCheck(adj , vis , pathVis , x))\\n                    return true;\\n            }\\n            else {\\n                if(pathVis[x] == true) {\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        pathVis[node] = false;\\n        return false;\\n    }\\n    \\n\\t\\n\\t// Create Topological order \\n    vector<int> topo(vector<int> adj[] , int k , vector<int> indeg) { \\n        \\n        queue<int> q;\\n        vector<int> tp;\\n        \\n        for(int i = 1 ; i <= k ; i++) {\\n            if(indeg[i] == 0) {\\n                q.push(i);\\n            }\\n        }\\n        \\n        while(!q.empty()) {\\n            int gh = q.front();\\n            \\n            tp.push_back(gh);\\n            q.pop();\\n            \\n            for(auto x : adj[gh]) {\\n                indeg[x]--;\\n                if(indeg[x] == 0) {\\n                    q.push(x);\\n                }\\n            }\\n        }\\n        \\n        return tp;\\n     }\\n    \\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        vector<int> rowAdj[k + 1] , colAdj[k + 1]; // Adjacency matrix for row and columns\\n         \\n        vector<vector<int>> res(k , vector<int>(k , 0));\\n        \\n        vector<int> Cindegree(k + 1 , 0)  , Rindegree(k + 1, 0); //indegree for row and column graph\\n        \\n        for(auto x : rowConditions) { //constructing row graph\\n            rowAdj[x[0]].push_back(x[1]);\\n            Rindegree[x[1]]++;\\n        }\\n        \\n        for(auto x : colConditions) { //Constructing Column graph\\n            colAdj[x[0]].push_back(x[1]);\\n            Cindegree[x[1]]++;\\n        }\\n        \\n        vector<bool> Rvis(k + 1, false) , RpathVis(k + 1 , false) , Cvis(k + 1 , false) , CpathVis(k + 1 , false);\\n        \\n\\t\\t//Check for cycle for row & Column\\n        if(cycleCheck(colAdj , Cvis , CpathVis , 1) || cycleCheck(rowAdj , Rvis , RpathVis , 1))\\n            return {}; // If any cycle , there cannot be any answer\\n        \\n\\t\\t\\n\\t\\t//Find topological order of rows and column\\n\\t\\t\\n        vector<int> Rtop = topo(rowAdj , k , Rindegree);\\n        vector<int> Ctop = topo(colAdj , k , Cindegree);\\n        \\n        if(Rtop.size() != k || Ctop.size() != k) {\\n            return {};\\n        }\\n        \\n\\t\\t// For Eg:\\n\\t\\t// Column Order : 3 2 1\\n\\t\\t// Row Order : 1 3 2\\n\\t\\t// Take Any of the order as the reference. Lets take Row for example.\\n\\t\\t// Position of 1 in row is 0 , position of 1 in column is 2 , therefore position in matrix should be res[0][2]. Do similarly for others.\\n\\t\\t\\n        unordered_map<int , int> mp;\\n        \\n        for(int i=0;i<Ctop.size();i++) {\\n            mp[Ctop[i]] = i;\\n        }\\n        // Create the matrix now.\\n        for(int k = 0 ; k < Rtop.size(); k++) {\\n            res[k][mp[Rtop[k]]] = Rtop[k];\\n        }\\n                   \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2501659,
                "title": "c-with-dfs-topological-sort-cycle-detection-o-k-r-c",
                "content": "Build 2 directed graphs, use topological sorting to get the order of direction.\\nIn case of cycles, its impossible to get the matrix, so return empty array\\n\\n```\\npublic class Solution \\n{\\n  public int[][] BuildMatrix(int k, int[][] rowConditions, int[][] colConditions) \\n  {\\n    int[][] res = new int[k][];\\n    List<int>[] gRows = new List<int>[k+1];\\n    List<int>[] gColumns = new List<int>[k+1];\\n    \\n    for(int i = 0; i < rowConditions.Length; i++)\\n    {\\n      var edge = rowConditions[i];\\n      if(gRows[edge[0]] == null) gRows[edge[0]] = new List<int>();\\n      gRows[edge[0]].Add(edge[1]);\\n    }\\n    \\n    for(int i = 0; i < colConditions.Length; i++)\\n    {\\n      var edge = colConditions[i];\\n      if(gColumns[edge[0]] == null) gColumns[edge[0]] = new List<int>();\\n      gColumns[edge[0]].Add(edge[1]);\\n    }\\n    \\n    var rowStack = new Stack<int>(k+1);\\n    var columnStack = new Stack<int>(k+1);\\n    if(!TopologicalSort(gRows, rowStack)) return new int[0][];\\n    if(!TopologicalSort(gColumns, columnStack)) return new int[0][];\\n    \\n    int[][] matrixOrder = new int[k+1][]; \\n    int lastRow = BuildMatrixOrder(matrixOrder, rowStack, 0);\\n    int lastColumn = BuildMatrixOrder(matrixOrder, columnStack, 1);\\n\\n    for(int i = 1; i <= k; i++)\\n    {\\n      var pos = matrixOrder[i];\\n      var r = pos[0] >= 0 ? pos[0]: lastRow++;\\n      var c = pos[1] >= 0 ? pos[1]: lastColumn++;\\n      if(res[r] == null) res[r] = new int[k];\\n      res[r][c] = i;\\n    }\\n    \\n    return res;\\n  }\\n  \\n  // pos0=row, pos1=column\\n  private int BuildMatrixOrder(int[][] matrixOrder, Stack<int> stack, int pos)\\n  {\\n    int c = 0;\\n    while(stack.Count > 0)\\n    {\\n      var v = stack.Pop();\\n      if(matrixOrder[v] == null) matrixOrder[v] = new int[2]{ -1, -1 };\\n      matrixOrder[v][pos] = c++;\\n    }\\n    \\n    return c-1;\\n  }\\n  \\n  private bool TopologicalSort(List<int>[] g, Stack<int> stack)\\n  {\\n    bool[] visited = new bool[g.Length];\\n    bool[] cycle = new bool[g.Length];\\n    \\n    bool dfs(int v)\\n    {\\n      if(cycle[v]) return false;\\n      if(visited[v]) return true;\\n      \\n      visited[v] = true;\\n      cycle[v] = true;\\n      \\n      if(g[v] != null)\\n        foreach(var adjv in g[v])\\n        {\\n          if(!dfs(adjv))\\n            return false;\\n        }\\n      \\n      stack.Push(v);\\n      cycle[v] = false;\\n      return true;\\n    }\\n    \\n    for(int i = 1; i < g.Length; i++)\\n    {\\n      if(!dfs(i)) return false;\\n    }\\n    return true;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Topological Sort",
                    "Recursion"
                ],
                "code": "```\\npublic class Solution \\n{\\n  public int[][] BuildMatrix(int k, int[][] rowConditions, int[][] colConditions) \\n  {\\n    int[][] res = new int[k][];\\n    List<int>[] gRows = new List<int>[k+1];\\n    List<int>[] gColumns = new List<int>[k+1];\\n    \\n    for(int i = 0; i < rowConditions.Length; i++)\\n    {\\n      var edge = rowConditions[i];\\n      if(gRows[edge[0]] == null) gRows[edge[0]] = new List<int>();\\n      gRows[edge[0]].Add(edge[1]);\\n    }\\n    \\n    for(int i = 0; i < colConditions.Length; i++)\\n    {\\n      var edge = colConditions[i];\\n      if(gColumns[edge[0]] == null) gColumns[edge[0]] = new List<int>();\\n      gColumns[edge[0]].Add(edge[1]);\\n    }\\n    \\n    var rowStack = new Stack<int>(k+1);\\n    var columnStack = new Stack<int>(k+1);\\n    if(!TopologicalSort(gRows, rowStack)) return new int[0][];\\n    if(!TopologicalSort(gColumns, columnStack)) return new int[0][];\\n    \\n    int[][] matrixOrder = new int[k+1][]; \\n    int lastRow = BuildMatrixOrder(matrixOrder, rowStack, 0);\\n    int lastColumn = BuildMatrixOrder(matrixOrder, columnStack, 1);\\n\\n    for(int i = 1; i <= k; i++)\\n    {\\n      var pos = matrixOrder[i];\\n      var r = pos[0] >= 0 ? pos[0]: lastRow++;\\n      var c = pos[1] >= 0 ? pos[1]: lastColumn++;\\n      if(res[r] == null) res[r] = new int[k];\\n      res[r][c] = i;\\n    }\\n    \\n    return res;\\n  }\\n  \\n  // pos0=row, pos1=column\\n  private int BuildMatrixOrder(int[][] matrixOrder, Stack<int> stack, int pos)\\n  {\\n    int c = 0;\\n    while(stack.Count > 0)\\n    {\\n      var v = stack.Pop();\\n      if(matrixOrder[v] == null) matrixOrder[v] = new int[2]{ -1, -1 };\\n      matrixOrder[v][pos] = c++;\\n    }\\n    \\n    return c-1;\\n  }\\n  \\n  private bool TopologicalSort(List<int>[] g, Stack<int> stack)\\n  {\\n    bool[] visited = new bool[g.Length];\\n    bool[] cycle = new bool[g.Length];\\n    \\n    bool dfs(int v)\\n    {\\n      if(cycle[v]) return false;\\n      if(visited[v]) return true;\\n      \\n      visited[v] = true;\\n      cycle[v] = true;\\n      \\n      if(g[v] != null)\\n        foreach(var adjv in g[v])\\n        {\\n          if(!dfs(adjv))\\n            return false;\\n        }\\n      \\n      stack.Push(v);\\n      cycle[v] = false;\\n      return true;\\n    }\\n    \\n    for(int i = 1; i < g.Length; i++)\\n    {\\n      if(!dfs(i)) return false;\\n    }\\n    return true;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2501546,
                "title": "214-ms-c-solution-faster-than-100-topological-sort-2392",
                "content": "![image](https://assets.leetcode.com/users/images/9cd0ea9e-bd58-4205-b1f0-c77abaca9395_1661798548.5525796.png)\\n\\nGiven row Conditions and col Conditions can be treated as edges where each edge represents \\'u\\' should come before \\'v\\' in the edge u -> v.\\nHence the node with least incming edges should be at the bottom or at the right end of the result. Which is nothing but sorting the nodes in topological order.\\n\\nProblem can be broken down into two steps:\\n1. Finding whether graph is Acyclic or not (Topological sort is not applicable for Cyclic graph)\\n2. Finding topological order of the nodes\\n\\nHere smart way is to combine these two steps in a single traversal as they both can be achieved using dfs traversal of graph.\\n```\\nclass Solution {\\npublic:\\n    bool isCyclicTopoUtil(int curr,vector<vector<int>>& graph,vector<int>& vis,vector<int>& order){\\n        if(vis[curr] == 1){return false;}\\n        if(vis[curr] == 2){return true;}\\n        vis[curr] = 2;\\n        for(int child : graph[curr]){\\n            if(isCyclicTopoUtil(child,graph,vis,order)){return true;}\\n        }\\n        order.push_back(curr);\\n        vis[curr] = 1;\\n        return false;\\n    }\\n    bool isCyclicTopological(vector<vector<int>>& graph,vector<int>& order){\\n        int n = graph.size();\\n        vector<int>vis(n,0);\\n        for(int i=1;i<n;i++){\\n            if(vis[i]){continue;}\\n            if(isCyclicTopoUtil(i,graph,vis,order)){return true;}\\n        }\\n        return false;\\n    }\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        vector<vector<int>>rowGraph(k+1),colGraph(k+1);\\n        for(auto& v : rowConditions){\\n            rowGraph[v[0]].push_back(v[1]);\\n        }\\n        for(auto& v : colConditions){\\n            colGraph[v[0]].push_back(v[1]);\\n        }\\n        vector<int>rowOrder,colOrder;\\n        if(isCyclicTopological(rowGraph,rowOrder) || isCyclicTopological(colGraph,colOrder)){return {};}\\n        vector<vector<int>>res(k,vector<int>(k,0));\\n        vector<int>rowId(k+1),colId(k+1);\\n        for(int i=0;i<k;i++){rowId[rowOrder[i]] = k-(i+1); colId[colOrder[i]] = k-(i+1);}\\n        for(int i=1;i<=k;i++){res[rowId[i]][colId[i]] = i;}\\n        return res;\\n    }\\n};\\n```\\n\\nComment your queries if any\\n**Upvote** if found useful\\nThank You :)",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isCyclicTopoUtil(int curr,vector<vector<int>>& graph,vector<int>& vis,vector<int>& order){\\n        if(vis[curr] == 1){return false;}\\n        if(vis[curr] == 2){return true;}\\n        vis[curr] = 2;\\n        for(int child : graph[curr]){\\n            if(isCyclicTopoUtil(child,graph,vis,order)){return true;}\\n        }\\n        order.push_back(curr);\\n        vis[curr] = 1;\\n        return false;\\n    }\\n    bool isCyclicTopological(vector<vector<int>>& graph,vector<int>& order){\\n        int n = graph.size();\\n        vector<int>vis(n,0);\\n        for(int i=1;i<n;i++){\\n            if(vis[i]){continue;}\\n            if(isCyclicTopoUtil(i,graph,vis,order)){return true;}\\n        }\\n        return false;\\n    }\\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {\\n        vector<vector<int>>rowGraph(k+1),colGraph(k+1);\\n        for(auto& v : rowConditions){\\n            rowGraph[v[0]].push_back(v[1]);\\n        }\\n        for(auto& v : colConditions){\\n            colGraph[v[0]].push_back(v[1]);\\n        }\\n        vector<int>rowOrder,colOrder;\\n        if(isCyclicTopological(rowGraph,rowOrder) || isCyclicTopological(colGraph,colOrder)){return {};}\\n        vector<vector<int>>res(k,vector<int>(k,0));\\n        vector<int>rowId(k+1),colId(k+1);\\n        for(int i=0;i<k;i++){rowId[rowOrder[i]] = k-(i+1); colId[colOrder[i]] = k-(i+1);}\\n        for(int i=1;i<=k;i++){res[rowId[i]][colId[i]] = i;}\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1719035,
                "content": [
                    {
                        "username": "Dip143",
                        "content": "I think it can be solved by using the logic of NQueen problem.\\n"
                    },
                    {
                        "username": "ranjithreddy-31",
                        "content": "I think complexity would be too high for given constraints"
                    },
                    {
                        "username": "sk0822",
                        "content": "In which company it was asked any idea?\\n"
                    },
                    {
                        "username": "hanzok3c",
                        "content": "find the row and col order by topo sort then arrange them, it should be medium, not hard"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Don\\'t I need to check for every possible topological order. As for one topological order other may not be make valid matrix but for some other order it can do maybe. How is this situation handled?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Note that [[3,0,0],[0,0,1],[0,2,0]] & [[0,0,1],[3,0,0],[0,2,0]] are both valid matrices for example 1. Opening the possibility of having multiple valid answers. Just keep that in mind while solving."
                    }
                ]
            },
            {
                "id": 2069290,
                "content": [
                    {
                        "username": "Dip143",
                        "content": "I think it can be solved by using the logic of NQueen problem.\\n"
                    },
                    {
                        "username": "ranjithreddy-31",
                        "content": "I think complexity would be too high for given constraints"
                    },
                    {
                        "username": "sk0822",
                        "content": "In which company it was asked any idea?\\n"
                    },
                    {
                        "username": "hanzok3c",
                        "content": "find the row and col order by topo sort then arrange them, it should be medium, not hard"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Don\\'t I need to check for every possible topological order. As for one topological order other may not be make valid matrix but for some other order it can do maybe. How is this situation handled?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Note that [[3,0,0],[0,0,1],[0,2,0]] & [[0,0,1],[3,0,0],[0,2,0]] are both valid matrices for example 1. Opening the possibility of having multiple valid answers. Just keep that in mind while solving."
                    }
                ]
            },
            {
                "id": 2065465,
                "content": [
                    {
                        "username": "Dip143",
                        "content": "I think it can be solved by using the logic of NQueen problem.\\n"
                    },
                    {
                        "username": "ranjithreddy-31",
                        "content": "I think complexity would be too high for given constraints"
                    },
                    {
                        "username": "sk0822",
                        "content": "In which company it was asked any idea?\\n"
                    },
                    {
                        "username": "hanzok3c",
                        "content": "find the row and col order by topo sort then arrange them, it should be medium, not hard"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Don\\'t I need to check for every possible topological order. As for one topological order other may not be make valid matrix but for some other order it can do maybe. How is this situation handled?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Note that [[3,0,0],[0,0,1],[0,2,0]] & [[0,0,1],[3,0,0],[0,2,0]] are both valid matrices for example 1. Opening the possibility of having multiple valid answers. Just keep that in mind while solving."
                    }
                ]
            },
            {
                "id": 2025305,
                "content": [
                    {
                        "username": "Dip143",
                        "content": "I think it can be solved by using the logic of NQueen problem.\\n"
                    },
                    {
                        "username": "ranjithreddy-31",
                        "content": "I think complexity would be too high for given constraints"
                    },
                    {
                        "username": "sk0822",
                        "content": "In which company it was asked any idea?\\n"
                    },
                    {
                        "username": "hanzok3c",
                        "content": "find the row and col order by topo sort then arrange them, it should be medium, not hard"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Don\\'t I need to check for every possible topological order. As for one topological order other may not be make valid matrix but for some other order it can do maybe. How is this situation handled?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Note that [[3,0,0],[0,0,1],[0,2,0]] & [[0,0,1],[3,0,0],[0,2,0]] are both valid matrices for example 1. Opening the possibility of having multiple valid answers. Just keep that in mind while solving."
                    }
                ]
            },
            {
                "id": 1966859,
                "content": [
                    {
                        "username": "Dip143",
                        "content": "I think it can be solved by using the logic of NQueen problem.\\n"
                    },
                    {
                        "username": "ranjithreddy-31",
                        "content": "I think complexity would be too high for given constraints"
                    },
                    {
                        "username": "sk0822",
                        "content": "In which company it was asked any idea?\\n"
                    },
                    {
                        "username": "hanzok3c",
                        "content": "find the row and col order by topo sort then arrange them, it should be medium, not hard"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Don\\'t I need to check for every possible topological order. As for one topological order other may not be make valid matrix but for some other order it can do maybe. How is this situation handled?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Note that [[3,0,0],[0,0,1],[0,2,0]] & [[0,0,1],[3,0,0],[0,2,0]] are both valid matrices for example 1. Opening the possibility of having multiple valid answers. Just keep that in mind while solving."
                    }
                ]
            }
        ]
    }
]