[
    {
        "title": "Distinct Echo Substrings",
        "question_content": "Return the number of distinct non-empty substrings of text&nbsp;that can be written as the concatenation of some string with itself (i.e. it can be written as a + a&nbsp;where a is some string).\n&nbsp;\nExample 1:\n\nInput: text = \"abcabcabc\"\nOutput: 3\nExplanation: The 3 substrings are \"abcabc\", \"bcabca\" and \"cabcab\".\n\nExample 2:\n\nInput: text = \"leetcodeleetcode\"\nOutput: 2\nExplanation: The 2 substrings are \"ee\" and \"leetcodeleetcode\".\n\n&nbsp;\nConstraints:\n\n\t1 <= text.length <= 2000\n\ttext&nbsp;has only lowercase English letters.",
        "solutions": [
            {
                "id": 492704,
                "title": "intuitive-100-sliding-counter-with-pictures",
                "content": "**Overview**\\nYou can find here 2 solutions: 1st - Sliding Counter (72%), 2nd - Sliding Counter + Rolling Hash (100%). \\nIf you know similar problems or think of any improvements please let me know in the comments.\\n\\n**Solution I. Sliding Counter**\\n* ***Idea***\\nWe will use 2 pointers `l` and `r` to count equal characters for different lengths of substrings (`len`).\\nLet\\'s consider these 3 cases:\\n\\t* If counter reaches window length (`len`) then we record a substring.\\n<img src=\"https://assets.leetcode.com/users/jkyncmeg2h86/image_1580237915.png\" width=\"350\" height=\"150\" />\\n\\t* We disregard current substring when we encounter chars that are not equal (\\'b\\' and \\'c\\' for example), thus we reset the counter.\\n<img src=\"https://assets.leetcode.com/users/jkyncmeg2h86/image_1580238662.png\" width=\"350\" height=\"210\" />\\n\\t* When we record a substring, we move windows thus leaving a character behind, this means we have to decrease the counter.\\n<img src=\"https://assets.leetcode.com/users/jkyncmeg2h86/image_1580237916.png\" width=\"350\" height=\"150\" />\\n\\n\\n* ***Implementation***\\n\\t```java\\n\\tpublic int distinctEchoSubstrings(String s) {\\n\\t\\tSet<String> set = new HashSet<>();\\n\\t\\tfor (int len = 1; len <= s.length() / 2; len++) {\\n\\t\\t\\tfor (int l = 0, r = len, count = 0; l < s.length() - len; l++, r++) {\\n\\t\\t\\t\\tif (s.charAt(l) == s.charAt(r)) count++;\\n\\t\\t\\t\\telse count = 0;\\n\\n\\t\\t\\t\\tif (count == len) {\\n\\t\\t\\t\\t\\tset.add(s.substring(l - len + 1, l + 1));\\n\\t\\t\\t\\t\\tcount--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn set.size();\\n\\t}\\n\\t```\\n\\n**Solution II. Rolling Hash**\\n* ***Idea***\\nExtended previous solution with rolling hash.\\n\\n* ***Implementation***\\n\\t```java\\n\\timport java.math.*;\\n\\tpublic class Solution {\\n\\t\\tprivate int R = 256; // radix\\n\\t\\tprivate long Q; // large prime\\n\\t\\tprivate long[] powers; // precomputed powers of R\\n\\t\\tprivate long[] hashes; // precomputed hashes of prefixes\\n\\n\\t\\tpublic int distinctEchoSubstrings(String s) {\\n\\t\\t\\tSet<Long> set = new HashSet<>();\\n\\t\\t\\tpreprocess(s.length(), s);\\n\\n\\t\\t\\tfor (int len = 1; len <= s.length() / 2; len++) {\\n\\t\\t\\t\\tfor (int l = 0, r = len, count = 0; l < s.length() - len; l++, r++) {\\n\\t\\t\\t\\t\\tif (s.charAt(l) == s.charAt(r)) count++;\\n\\t\\t\\t\\t\\telse count = 0;\\n\\n\\t\\t\\t\\t\\tif (count == len) {\\n\\t\\t\\t\\t\\t\\tset.add(getHash(l - len + 1, l + 1));\\n\\t\\t\\t\\t\\t\\tcount--;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn set.size();\\n\\t\\t}\\n\\n\\t\\tprivate void preprocess(int n, String text) {\\n\\t\\t\\tQ = calculateRandomPrime();\\n\\t\\t\\thashes = new long[n + 1];\\n\\t\\t\\tpowers = new long[n + 1];\\n\\t\\t\\tpowers[0] = 1;\\n\\t\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\t\\thashes[i] = (hashes[i - 1] * R + text.charAt(i - 1)) % Q;\\n\\t\\t\\t\\tpowers[i] = (powers[i - 1] * R) % Q;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tprivate long calculateRandomPrime() {\\n\\t\\t\\tBigInteger prime = BigInteger.probablePrime(31, new Random());\\n\\t\\t\\treturn prime.longValue();\\n\\t\\t}\\n\\n\\t\\tprivate long getHash(int l, int r) {\\n\\t\\t\\treturn (hashes[r] + Q - hashes[l] * powers[r - l] % Q) % Q;\\n\\t\\t}\\n\\t}\\n\\t```\\n\\t\\n\\t\\n**Somewhat similar problems:**\\n* [Longest Duplicate Substring](https://leetcode.com/problems/longest-duplicate-substring/)\\n* [Repeated String Match](https://leetcode.com/problems/repeated-string-match/)\\n* [Permutation in String](https://leetcode.com/problems/permutation-in-string/)\\n* [Shortest Palindrome](https://leetcode.com/problems/shortest-palindrome/)",
                "solutionTags": [],
                "code": "```java\\n\\tpublic int distinctEchoSubstrings(String s) {\\n\\t\\tSet<String> set = new HashSet<>();\\n\\t\\tfor (int len = 1; len <= s.length() / 2; len++) {\\n\\t\\t\\tfor (int l = 0, r = len, count = 0; l < s.length() - len; l++, r++) {\\n\\t\\t\\t\\tif (s.charAt(l) == s.charAt(r)) count++;\\n\\t\\t\\t\\telse count = 0;\\n\\n\\t\\t\\t\\tif (count == len) {\\n\\t\\t\\t\\t\\tset.add(s.substring(l - len + 1, l + 1));\\n\\t\\t\\t\\t\\tcount--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn set.size();\\n\\t}\\n\\t```\n```java\\n\\timport java.math.*;\\n\\tpublic class Solution {\\n\\t\\tprivate int R = 256; // radix\\n\\t\\tprivate long Q; // large prime\\n\\t\\tprivate long[] powers; // precomputed powers of R\\n\\t\\tprivate long[] hashes; // precomputed hashes of prefixes\\n\\n\\t\\tpublic int distinctEchoSubstrings(String s) {\\n\\t\\t\\tSet<Long> set = new HashSet<>();\\n\\t\\t\\tpreprocess(s.length(), s);\\n\\n\\t\\t\\tfor (int len = 1; len <= s.length() / 2; len++) {\\n\\t\\t\\t\\tfor (int l = 0, r = len, count = 0; l < s.length() - len; l++, r++) {\\n\\t\\t\\t\\t\\tif (s.charAt(l) == s.charAt(r)) count++;\\n\\t\\t\\t\\t\\telse count = 0;\\n\\n\\t\\t\\t\\t\\tif (count == len) {\\n\\t\\t\\t\\t\\t\\tset.add(getHash(l - len + 1, l + 1));\\n\\t\\t\\t\\t\\t\\tcount--;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn set.size();\\n\\t\\t}\\n\\n\\t\\tprivate void preprocess(int n, String text) {\\n\\t\\t\\tQ = calculateRandomPrime();\\n\\t\\t\\thashes = new long[n + 1];\\n\\t\\t\\tpowers = new long[n + 1];\\n\\t\\t\\tpowers[0] = 1;\\n\\t\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\t\\thashes[i] = (hashes[i - 1] * R + text.charAt(i - 1)) % Q;\\n\\t\\t\\t\\tpowers[i] = (powers[i - 1] * R) % Q;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tprivate long calculateRandomPrime() {\\n\\t\\t\\tBigInteger prime = BigInteger.probablePrime(31, new Random());\\n\\t\\t\\treturn prime.longValue();\\n\\t\\t}\\n\\n\\t\\tprivate long getHash(int l, int r) {\\n\\t\\t\\treturn (hashes[r] + Q - hashes[l] * powers[r - l] % Q) % Q;\\n\\t\\t}\\n\\t}\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 477217,
                "title": "java-brute-force-hash-solution-clean-code",
                "content": "**1. Brute force Solution**\\n```java\\nclass Solution {\\n    public int distinctEchoSubstrings(String str) {\\n        HashSet<String> set = new HashSet<>();\\n        int n = str.length();\\n        for (int i = 0; i < n; i++) {\\n            for (int len = 2; i + len <= n; len += 2) {\\n                int mid = i + len / 2;\\n                String subStr1 = str.substring(i, mid);\\n                String subStr2 = str.substring(mid, i + len);\\n                if (subStr1.equals(subStr2)) set.add(subStr1);\\n            }\\n        }\\n        return set.size();\\n    }\\n}\\n```\\n**Complexity:**\\n- Time: O(n^3), `n` is length of string `str`\\n- Space: O(n)\\n\\n**2. Hash Solution**\\n```java\\nclass Solution {\\n    long BASE = 29L, MOD = 1000000007L;\\n    public int distinctEchoSubstrings(String str) {\\n        HashSet<Long> set = new HashSet<>();\\n        int n = str.length();\\n        long[] hash = new long[n + 1]; // hash[i] is hash value from str[0..i]\\n        long[] pow = new long[n + 1]; // pow[i] = BASE^i\\n        pow[0] = 1;\\n        for (int i = 1; i <= n; i++) {\\n            hash[i] = (hash[i - 1] * BASE + str.charAt(i - 1)) % MOD;\\n            pow[i] = pow[i - 1] * BASE % MOD;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            for (int len = 2; i + len <= n; len += 2) {\\n                int mid = i + len / 2;\\n                long hash1 = getHash(i, mid, hash, pow);\\n                long hash2 = getHash(mid, i + len, hash, pow);\\n                if (hash1 == hash2) set.add(hash1);\\n            }\\n        }\\n        return set.size();\\n    }\\n\\n    long getHash(int l, int r, long[] hash, long[] pow) {\\n        return (hash[r] - hash[l] * pow[r - l] % MOD + MOD) % MOD;\\n    }\\n}\\n```\\n**Complexity**\\n- Time: O(n^2), `n` is length of string `str`\\n- Space: O(n)",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int distinctEchoSubstrings(String str) {\\n        HashSet<String> set = new HashSet<>();\\n        int n = str.length();\\n        for (int i = 0; i < n; i++) {\\n            for (int len = 2; i + len <= n; len += 2) {\\n                int mid = i + len / 2;\\n                String subStr1 = str.substring(i, mid);\\n                String subStr2 = str.substring(mid, i + len);\\n                if (subStr1.equals(subStr2)) set.add(subStr1);\\n            }\\n        }\\n        return set.size();\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    long BASE = 29L, MOD = 1000000007L;\\n    public int distinctEchoSubstrings(String str) {\\n        HashSet<Long> set = new HashSet<>();\\n        int n = str.length();\\n        long[] hash = new long[n + 1]; // hash[i] is hash value from str[0..i]\\n        long[] pow = new long[n + 1]; // pow[i] = BASE^i\\n        pow[0] = 1;\\n        for (int i = 1; i <= n; i++) {\\n            hash[i] = (hash[i - 1] * BASE + str.charAt(i - 1)) % MOD;\\n            pow[i] = pow[i - 1] * BASE % MOD;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            for (int len = 2; i + len <= n; len += 2) {\\n                int mid = i + len / 2;\\n                long hash1 = getHash(i, mid, hash, pow);\\n                long hash2 = getHash(mid, i + len, hash, pow);\\n                if (hash1 == hash2) set.add(hash1);\\n            }\\n        }\\n        return set.size();\\n    }\\n\\n    long getHash(int l, int r, long[] hash, long[] pow) {\\n        return (hash[r] - hash[l] * pow[r - l] % MOD + MOD) % MOD;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477643,
                "title": "rolling-equality-counter",
                "content": "I use two adjacent sliding windows. But instead of two rolling hashes (one for each window), I keep track of at how many places the windows are equal. It\\'s simple and there are no collisions (different strings mistaken for being the same, as can happen with hashes).\\n\\nFor example with string \"xbcabca\":\\n```\\n  0  1  2  3  4  5  6\\n (x  b  c)(a  b  c) a   => 2 places in the windows are the same (middle and right)\\n  x (b  c  a)(b  c  a)  => 3 places in the windows are the same\\n```\\nIn the first row, we were interested in equality at the index pairs (0, 3), (1, 4) and (2, 5).\\nAfter the shift, we are interested in equality at the index pairs (1, 4), (2, 5) and (3, 6).\\nSo the pairs (1, 4) and (2, 5) stayed, we only lost interest in whether (0, 3) were equal, and we gained interest in whether (3, 6) are equal.\\n```\\ndef distinctEchoSubstrings(self, s):\\n    n = len(s)\\n    s += \\'.\\'\\n    some_string = set()\\n    for k in range(1, n//2+1):\\n        same = sum(c == d for c, d in zip(s, s[k:k+k]))\\n        for i in range(n - 2*k + 1):\\n            if same == k:\\n                some_string.add(s[i:i+k])\\n            same += (s[i+k] == s[i+k+k]) - (s[i] == s[i+k])\\n    return len(some_string)\\n```",
                "solutionTags": [],
                "code": "```\\n  0  1  2  3  4  5  6\\n (x  b  c)(a  b  c) a   => 2 places in the windows are the same (middle and right)\\n  x (b  c  a)(b  c  a)  => 3 places in the windows are the same\\n```\n```\\ndef distinctEchoSubstrings(self, s):\\n    n = len(s)\\n    s += \\'.\\'\\n    some_string = set()\\n    for k in range(1, n//2+1):\\n        same = sum(c == d for c, d in zip(s, s[k:k+k]))\\n        for i in range(n - 2*k + 1):\\n            if same == k:\\n                some_string.add(s[i:i+k])\\n            same += (s[i+k] == s[i+k+k]) - (s[i] == s[i+k])\\n    return len(some_string)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 477444,
                "title": "c-with-hash-240ms-without-hash-550ms-but-simpler",
                "content": "Simple brute force without hash:\\n```\\nint distinctEchoSubstrings(string text) {\\n\\tunordered_set<string_view> res;\\n\\tconst char *p = text.c_str();\\n\\tfor (int i=0; i<text.size(); ++i) {\\n\\t\\tfor (int len=1; i+len+len<=text.size(); ++len) {\\n\\t\\t\\tconst string_view a(p+i    , len);\\n\\t\\t\\tconst string_view b(p+i+len, len);\\n\\t\\t\\tif (a==b) {\\n\\t\\t\\t\\tres.insert(a);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res.size();\\n}\\n```\\n\\nWith hash:\\n```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    static constexpr int A = 1000000007, B = 1000000037;\\n    \\n    class Hash {\\n    public:\\n        Hash(const string &s) {\\n            h[0] = s[0] % B;\\n            p[0] = 1;\\n            for (int i=1; i<s.size(); ++i) {\\n                h[i] = (h[i-1]*A + s[i]) % B;\\n                p[i] = (p[i-1]*A) % B;\\n            }\\n        }\\n        \\n        // a and b are inclusive\\n        ll hash(const int a, const int b) {\\n            if (a) {\\n                const auto res = (h[b] - h[a-1] * p[b-a+1]) % B;\\n                return res < 0 ? B + res : res;\\n            }   else {\\n                return h[b];\\n            }\\n        }\\n    private:\\n        ll h[2000], p[2000];\\n    };\\n    \\n    int distinctEchoSubstrings(string text) {\\n        Hash h(text);\\n        \\n        unordered_set<string_view> res;\\n        const char *p = text.c_str();\\n        for (int i=0; i<text.size(); ++i) {\\n            for (int len=1; i+len+len<=text.size(); ++len) {\\n                if (h.hash(i, i+len-1) == h.hash(i+len, i+len+len-1)) {\\n                    res.insert(string_view(p+i, len));\\n                }\\n            }\\n        }\\n        return res.size();\\n    }\\n};\\n```\\nA and B can be any prime numbers. Bigger values reduce probability of collision. After the hash is initialized, comparing two substrings takes constant time by comparing hashes of the substrings. See https://en.wikipedia.org/wiki/Rolling_hash or book \"Guide to Competitive Programming\" by Antti Laaksonen. He explains it well in half a page. IMHO: this is by far the best book about C++ algorithms.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint distinctEchoSubstrings(string text) {\\n\\tunordered_set<string_view> res;\\n\\tconst char *p = text.c_str();\\n\\tfor (int i=0; i<text.size(); ++i) {\\n\\t\\tfor (int len=1; i+len+len<=text.size(); ++len) {\\n\\t\\t\\tconst string_view a(p+i    , len);\\n\\t\\t\\tconst string_view b(p+i+len, len);\\n\\t\\t\\tif (a==b) {\\n\\t\\t\\t\\tres.insert(a);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res.size();\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    static constexpr int A = 1000000007, B = 1000000037;\\n    \\n    class Hash {\\n    public:\\n        Hash(const string &s) {\\n            h[0] = s[0] % B;\\n            p[0] = 1;\\n            for (int i=1; i<s.size(); ++i) {\\n                h[i] = (h[i-1]*A + s[i]) % B;\\n                p[i] = (p[i-1]*A) % B;\\n            }\\n        }\\n        \\n        // a and b are inclusive\\n        ll hash(const int a, const int b) {\\n            if (a) {\\n                const auto res = (h[b] - h[a-1] * p[b-a+1]) % B;\\n                return res < 0 ? B + res : res;\\n            }   else {\\n                return h[b];\\n            }\\n        }\\n    private:\\n        ll h[2000], p[2000];\\n    };\\n    \\n    int distinctEchoSubstrings(string text) {\\n        Hash h(text);\\n        \\n        unordered_set<string_view> res;\\n        const char *p = text.c_str();\\n        for (int i=0; i<text.size(); ++i) {\\n            for (int len=1; i+len+len<=text.size(); ++len) {\\n                if (h.hash(i, i+len-1) == h.hash(i+len, i+len+len-1)) {\\n                    res.insert(string_view(p+i, len));\\n                }\\n            }\\n        }\\n        return res.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477060,
                "title": "accepted-o-n-2-rolling-hash-solution",
                "content": "Looking for two neighboring segments that are identical. \\nIf length is l, we are checking i..i+l and i+l-1...i+2*l\\nIf we move from i to i+1, we can use rolling hash to get the new string hashes for them in O(1)\\n```\\n\\n\\npublic class Solution {\\n    long mod = 100000000000007L;\\n\\n    public int distinctEchoSubstrings(String s) {\\n        int n = s.length();\\n        char[] cs = s.toCharArray();\\n        Set<Long> set = new HashSet<>();\\n        long headexp = 1L;\\n        for (int l = 1; 2 * l - 1 < n; l++) {\\n            headexp *= 26;\\n            headexp %= mod;\\n            long hash1 = initialHash(cs, 0, l - 1);\\n            long hash2 = initialHash(cs, l, 2 * l - 1);\\n            if (hash1 == hash2) {\\n                set.add(hash1);\\n            }\\n            for (int i = 1; i + 2 * l - 1 < n; i++) {\\n                // rolling hash\\n                hash1 = updateHash(cs, hash1, headexp, i - 1, i + l - 1);\\n                hash2 = updateHash(cs, hash2, headexp, i - 1 + l, i + 2 * l - 1);\\n                if (hash1 == hash2) {\\n                    set.add(hash1);\\n                }\\n            }\\n        }\\n        return set.size();\\n    }\\n\\n    private long initialHash(char[] cs, int i, int j) {\\n        long hash = 0L;\\n        for (int k = i; k <= j; k++) {\\n            hash = hash * 26 + (tocode(cs[k]));\\n            hash %= mod;\\n        }\\n        return hash;\\n    }\\n\\n    private long updateHash(char[] cs, long hash, long headexp, int index1, int index2) {\\n        hash = hash * 26 + (tocode(cs[index2]));\\n        hash = (hash - headexp * tocode(cs[index1])) % mod;\\n        hash = (hash + mod) % mod; // in case hash turns negative from above minus...\\n        return hash;\\n    }\\n\\n    private int tocode(char c) {\\n        return c - \\'a\\' + 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\npublic class Solution {\\n    long mod = 100000000000007L;\\n\\n    public int distinctEchoSubstrings(String s) {\\n        int n = s.length();\\n        char[] cs = s.toCharArray();\\n        Set<Long> set = new HashSet<>();\\n        long headexp = 1L;\\n        for (int l = 1; 2 * l - 1 < n; l++) {\\n            headexp *= 26;\\n            headexp %= mod;\\n            long hash1 = initialHash(cs, 0, l - 1);\\n            long hash2 = initialHash(cs, l, 2 * l - 1);\\n            if (hash1 == hash2) {\\n                set.add(hash1);\\n            }\\n            for (int i = 1; i + 2 * l - 1 < n; i++) {\\n                // rolling hash\\n                hash1 = updateHash(cs, hash1, headexp, i - 1, i + l - 1);\\n                hash2 = updateHash(cs, hash2, headexp, i - 1 + l, i + 2 * l - 1);\\n                if (hash1 == hash2) {\\n                    set.add(hash1);\\n                }\\n            }\\n        }\\n        return set.size();\\n    }\\n\\n    private long initialHash(char[] cs, int i, int j) {\\n        long hash = 0L;\\n        for (int k = i; k <= j; k++) {\\n            hash = hash * 26 + (tocode(cs[k]));\\n            hash %= mod;\\n        }\\n        return hash;\\n    }\\n\\n    private long updateHash(char[] cs, long hash, long headexp, int index1, int index2) {\\n        hash = hash * 26 + (tocode(cs[index2]));\\n        hash = (hash - headexp * tocode(cs[index1])) % mod;\\n        hash = (hash + mod) % mod; // in case hash turns negative from above minus...\\n        return hash;\\n    }\\n\\n    private int tocode(char c) {\\n        return c - \\'a\\' + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 479342,
                "title": "silly-and-fast",
                "content": "#### Silly ...\\nFor each split point, we are going left and right increasing the size. When the left and right string matches - we add it to the hash set.\\n\\nThis solution gets accepted with ~800 ms runtime. Not bad for a simple idea! Note that I am using string `compare` to make sure we are not creating new strings.\\n```CPP\\nint distinctEchoSubstrings(string tx) {\\n    unordered_set<string> s;\\n    for (auto split = 1; split < tx.size() - 1; ++split) {\\n        for (auto sz = 1; split - sz >= 0 && split + sz - 1 < tx.size(); ++sz) {\\n            if (tx.compare(split - sz, sz, tx, split, sz) == 0)\\n                s.insert(tx.substr(split, sz));\\n        }\\n    }\\n    return s.size();\\n}\\n```\\n#### ... and ...\\nSo, what is hurting the runtime in the solution above? For each candidate, we need up to O(sz) comparisons. If we use a rolling hash approach, it takes O(1) to add a character to the hash, and O(1) to compare the string.\\n\\nFrom the split point, we are rolling hash left (add the next char multiplied by 26 * sz) and right (multiply the hash by 26 and add the next character). When the left and right hashes match, we add the string to the result set.\\n\\n```CPP\\nint distinctEchoSubstrings(string tx) {\\n    unordered_set<string> s;\\n    for (auto split = 1; split < tx.size() - 1; ++split) {\\n        long long sh_l = 0, sh_r = 0, base = 1;\\n        for (auto sz = 1; split - sz >= 0 && split + sz - 1 < tx.size(); ++sz) {\\n            sh_r = ((sh_r * 26) + tx[split + sz - 1]) % 1000000007;\\n            sh_l = (sh_l + tx[split - sz] * base) % 1000000007;\\n            base = (base * 26) % 1000000007;\\n            if (sh_r == sh_l) s.insert(tx.substr(split, sz));\\n        }\\n    }\\n    return s.size();\\n}\\n```\\nThis brings the runtime down to ~500 ms... it\\'s faster but quite disappointing for the amount of extra work we\\'ve done to the first solution.\\n#### ... Fast!\\nWhat is eating our runtime? When we add a string to the hash set, we need to create a substring - O(sz) - and the hash set internally computes a hash - also O(sz). Why do we need to compute a hash again if we already have our rolling hash? So, we can change our hash set to store integers instead of strings.\\n```CPP\\nint distinctEchoSubstrings(string tx) {\\n    unordered_set<int> s;\\n    for (auto split = 1; split < tx.size() - 1; ++split) {\\n        long long sh_l = 0, sh_r = 0, base = 1;\\n        for (auto sz = 1; split - sz >= 0 && split + sz - 1 < tx.size(); ++sz) {\\n            sh_r = ((sh_r * 26) + tx[split + sz - 1]) % 1000000007;\\n            sh_l = (sh_l + tx[split - sz] * base) % 1000000007;\\n            base = (base * 26) % 1000000007;\\n            if (sh_r == sh_l) s.insert(sh_l);\\n        }\\n    }\\n    return s.size();\\n}\\n```\\nThe runtime of this solution is ~72 ms, so our hard work finally paid off! We can do more clever tricks with rolling hash to optimize, but here I wanted to keep the same simple concept as in the initial solution.",
                "solutionTags": [],
                "code": "```CPP\\nint distinctEchoSubstrings(string tx) {\\n    unordered_set<string> s;\\n    for (auto split = 1; split < tx.size() - 1; ++split) {\\n        for (auto sz = 1; split - sz >= 0 && split + sz - 1 < tx.size(); ++sz) {\\n            if (tx.compare(split - sz, sz, tx, split, sz) == 0)\\n                s.insert(tx.substr(split, sz));\\n        }\\n    }\\n    return s.size();\\n}\\n```\n```CPP\\nint distinctEchoSubstrings(string tx) {\\n    unordered_set<string> s;\\n    for (auto split = 1; split < tx.size() - 1; ++split) {\\n        long long sh_l = 0, sh_r = 0, base = 1;\\n        for (auto sz = 1; split - sz >= 0 && split + sz - 1 < tx.size(); ++sz) {\\n            sh_r = ((sh_r * 26) + tx[split + sz - 1]) % 1000000007;\\n            sh_l = (sh_l + tx[split - sz] * base) % 1000000007;\\n            base = (base * 26) % 1000000007;\\n            if (sh_r == sh_l) s.insert(tx.substr(split, sz));\\n        }\\n    }\\n    return s.size();\\n}\\n```\n```CPP\\nint distinctEchoSubstrings(string tx) {\\n    unordered_set<int> s;\\n    for (auto split = 1; split < tx.size() - 1; ++split) {\\n        long long sh_l = 0, sh_r = 0, base = 1;\\n        for (auto sz = 1; split - sz >= 0 && split + sz - 1 < tx.size(); ++sz) {\\n            sh_r = ((sh_r * 26) + tx[split + sz - 1]) % 1000000007;\\n            sh_l = (sh_l + tx[split - sz] * base) % 1000000007;\\n            base = (base * 26) % 1000000007;\\n            if (sh_r == sh_l) s.insert(sh_l);\\n        }\\n    }\\n    return s.size();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 478854,
                "title": "c-dp-solution-o-n-3-with-explanation",
                "content": "I found most posts are talking about rolling hash and code is pretty long. So I would like to share my DP solution.\\n`dp[i][j] = k ` stands for two sub strings that start from text[i] and text[j] respectively, are same to at most k characters. \\nLet\\'s say we\\'ve known string s1 starting from i+1 and string s2 starting from j+1 are identical up to dp[i+1][j+1] characters. So for string s1\\' and s2\\' starting from i and j position, if `ch[i] != ch[j]` then this number becomes 0, otherwise we added this current one into account. and recurrence backward until dp table is all computed.\\n\\n`dp[i][j]=dp[i+1][j+1]`\\nThe critical condition for this question is when i +k == j, which means these two strings are \"concatenated\" together without any other character. A little debug actually fix that condition to j-i <= dp[i][j] = k as strings are still valid but k could be greater than j-i. \\n\\nThanks to @vortrubac in below comment. I originally use ordered_set than unordered_set, which takes twice the time.\\n\\n```\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        if (text.size() <= 1) return 0;\\n        int N = text.size();\\n        // dp[i][j] = k means strcmp (text.data () + i, text.data() + j, k) == 0\\n        vector<vector<int>> dp (N + 1, vector<int> (N + 1, 0));\\n        unordered_set<string> res;\\n        auto &ch = text;\\n        for (int j = N-1; j > 0; j--) {\\n            for (int i = j-1; i >= 0; i--) {\\n                dp[i][j] = ch[i] == ch[j] ? 1 + dp[i+1][j+1] : 0;\\n                if (dp[i][j] >= j-i) {\\n                    res.insert ( ch.substr(i, j-i)); \\n                }\\n            }\\n        }\\n        return res.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        if (text.size() <= 1) return 0;\\n        int N = text.size();\\n        // dp[i][j] = k means strcmp (text.data () + i, text.data() + j, k) == 0\\n        vector<vector<int>> dp (N + 1, vector<int> (N + 1, 0));\\n        unordered_set<string> res;\\n        auto &ch = text;\\n        for (int j = N-1; j > 0; j--) {\\n            for (int i = j-1; i >= 0; i--) {\\n                dp[i][j] = ch[i] == ch[j] ? 1 + dp[i+1][j+1] : 0;\\n                if (dp[i][j] >= j-i) {\\n                    res.insert ( ch.substr(i, j-i)); \\n                }\\n            }\\n        }\\n        return res.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477503,
                "title": "c-simple-solution-100ms-without-rolling-hash",
                "content": "update: got around 90 - 100ms, with additional check for repeating patterns.\\n\\n```\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text)\\n    {\\n        unordered_set<string_view> ddw;\\n        const char* cstr = text.c_str();\\n        int n = text.size() / 2;\\n        for(int i = 1; i <= n; i++)\\n        {\\n            int l = 0, r = i, c = 0;\\n            while(r < text.size())\\n            {\\n                if(cstr[l++] == cstr[r++])\\n                {\\n                    c++;\\n                }\\n                else\\n                {\\n                    c = 0;\\n                }\\n                if(c >= i && c < i * 2) // for c >= i * 2 : \"ababab\" same string repeating\\n                {\\n\\t\\t\\t\\t\\tddw.insert(string_view(cstr + l, i));\\n                }\\n            }\\n        }\\n        return ddw.size();\\n    }\\n};\\n```\\n\\nupdate: 88ms solution without using set\\n\\n```\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text)\\n    {\\n        int n = text.size();\\n        vector<int> copy(n + 1, 0);\\n        int res = 0;\\n        for(int i = 1; i < n; i++)\\n        {\\n            int l = 0, r = i, c = 0;\\n            while(r < n)\\n            {\\n                if(text[l++] == text[r++])\\n                {\\n                    c++;\\n                }\\n                else\\n                {\\n                    c = 0;\\n                }\\n                copy[r] = max(copy[r], c);\\n            }\\n        }\\n        for(int i = 1; i <= n / 2; i++)\\n        {\\n            int l = 0, r = i, c = 0;\\n            while(r < n)\\n            {\\n                if(text[l++] == text[r++])\\n                {\\n                    c++;\\n                }\\n                else\\n                {\\n                    c = 0;\\n                }\\n                if(c >= i && copy[r] < i * 2)\\n                {\\n                    res++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text)\\n    {\\n        unordered_set<string_view> ddw;\\n        const char* cstr = text.c_str();\\n        int n = text.size() / 2;\\n        for(int i = 1; i <= n; i++)\\n        {\\n            int l = 0, r = i, c = 0;\\n            while(r < text.size())\\n            {\\n                if(cstr[l++] == cstr[r++])\\n                {\\n                    c++;\\n                }\\n                else\\n                {\\n                    c = 0;\\n                }\\n                if(c >= i && c < i * 2) // for c >= i * 2 : \"ababab\" same string repeating\\n                {\\n\\t\\t\\t\\t\\tddw.insert(string_view(cstr + l, i));\\n                }\\n            }\\n        }\\n        return ddw.size();\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text)\\n    {\\n        int n = text.size();\\n        vector<int> copy(n + 1, 0);\\n        int res = 0;\\n        for(int i = 1; i < n; i++)\\n        {\\n            int l = 0, r = i, c = 0;\\n            while(r < n)\\n            {\\n                if(text[l++] == text[r++])\\n                {\\n                    c++;\\n                }\\n                else\\n                {\\n                    c = 0;\\n                }\\n                copy[r] = max(copy[r], c);\\n            }\\n        }\\n        for(int i = 1; i <= n / 2; i++)\\n        {\\n            int l = 0, r = i, c = 0;\\n            while(r < n)\\n            {\\n                if(text[l++] == text[r++])\\n                {\\n                    c++;\\n                }\\n                else\\n                {\\n                    c = 0;\\n                }\\n                if(c >= i && copy[r] < i * 2)\\n                {\\n                    res++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477279,
                "title": "1-liners-python",
                "content": "We want *\"non-empty substrings of text that can be written as the concatenation of **some string** with itself\"*. So I go through each possible **some string** `s[i:j]` and check whether it\\'s followed by itself. And collect the successful **some string**s in a set for uniqueness, whose size I return. Slow but gets accepted.\\n```\\ndef distinctEchoSubstrings(self, s):\\n    return len({s[i:j] for j in range(len(s)) for i in range(j) if s[i:j] == s[j:j+j-i]})\\n```\\nSlight variation:\\n```\\ndef distinctEchoSubstrings(self, s):\\n    return len({s[i:j] for j in range(len(s)) for i in range(j) if s.startswith(s[i:j], j)})\\n```\\nLoop version:\\n```\\ndef distinctEchoSubstrings(self, s):\\n    some_strings = set()\\n    for j in range(len(s)):\\n        for i in range(j):\\n            if s.startswith(s[i:j], j):\\n                some_strings.add(s[i:j])\\n    return len(some_strings)\\n```\\nNote I make `j` the *outer* loop, because that\\'s a bit simpler than the equivalent other way around:\\n```\\n    for i in range(len(s) - 1):\\n        for j in range(i + 1, len(s)):\\n```",
                "solutionTags": [],
                "code": "```\\ndef distinctEchoSubstrings(self, s):\\n    return len({s[i:j] for j in range(len(s)) for i in range(j) if s[i:j] == s[j:j+j-i]})\\n```\n```\\ndef distinctEchoSubstrings(self, s):\\n    return len({s[i:j] for j in range(len(s)) for i in range(j) if s.startswith(s[i:j], j)})\\n```\n```\\ndef distinctEchoSubstrings(self, s):\\n    some_strings = set()\\n    for j in range(len(s)):\\n        for i in range(j):\\n            if s.startswith(s[i:j], j):\\n                some_strings.add(s[i:j])\\n    return len(some_strings)\\n```\n```\\n    for i in range(len(s) - 1):\\n        for j in range(i + 1, len(s)):\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 478515,
                "title": "simple-java-dp-solution",
                "content": "```\\nclass Solution {   \\n    public int distinctEchoSubstrings(String text) {\\n        int n = text.length();\\n        int dp[][] = new int[n][n];\\n        Set<String> set = new LinkedHashSet<>();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i+1; j < n; j++) {\\n                if (text.charAt(i) ==  text.charAt(j)) {\\n                    if (i == 0) {\\n                        dp[i][j] = 1;\\n                    } else {\\n                        dp[i][j] = dp[i - 1][j - 1] + 1;\\n                    }\\n                }\\n                if (dp[i][j] >= j - i) {\\n\\t\\t\\t\\t\\t// take substring i- (j-i) +1 to j+1 \\n                    set.add(text.substring(2 * i - j+1, j+1));\\n                }\\n            }\\n        }\\n        return set.size();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {   \\n    public int distinctEchoSubstrings(String text) {\\n        int n = text.length();\\n        int dp[][] = new int[n][n];\\n        Set<String> set = new LinkedHashSet<>();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i+1; j < n; j++) {\\n                if (text.charAt(i) ==  text.charAt(j)) {\\n                    if (i == 0) {\\n                        dp[i][j] = 1;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 779620,
                "title": "c-string-hashing-solution-with-explanation",
                "content": "Simple Brute force will be to check every 2 adjacent substring of all lengths. We can improve our solution to O(n^2) using string Hashing. \\nI would recommend reading string hashing in cp-algo website to easily understand this important concept.\\nThe steps followed are:\\n1) Select 2 primes, for many cases based on simple text, p=31 works. The other big prime is taken to be 1000000009.\\n2) Pre calculate the power of p upto n.\\n3) Calculate the hash for all prefix substring of the string. \\n4) Now we consider all substring of length L. We check if the hash of both half of this substring is equal. If yes, we can mark this hash in a map. This handles all the duplicates. \\nRest of the explanation is in code. Comment for any doubt.\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll p=31;\\n    ll m=1000000009;\\n    int distinctEchoSubstrings(string text) {\\n        ll n=text.size();\\n        vector <ll> p_pow(n);\\n        p_pow[0]=1;\\n        for(ll i=1;i<n;i++)\\n            p_pow[i]=(p_pow[i-1]*p)%m;\\n        vector <ll> hash(n+1,0);\\n        for(ll i=0;i<n;i++)\\n        {\\n\\t\\t   hash[i+1]= (hash[i] + (text[i]-\\'a\\'+1)*p_pow[i])%m; //dont forget the 1 here, or else \"aa\" and \"aaa\" will map to the same value\\n        }\\n        //for(int i=0;i<=n;i++)\\n           // cout<<hash[i]<< \" \";\\n        unordered_map <ll ,ll > um;\\n        for(ll l=2;l<=n;l+=2)\\n        {\\n            for(ll i=0;i+l<=n;i++)\\n            {\\n                ll curr1= (hash[i+l/2]+m-hash[i])%m; // +m for ensuring +ve remainder\\n                curr1=(curr1*p_pow[n-i-1])%m; \\n                ll curr2= (hash[i+ l] +m - hash[i+l/2])%m; \\n                curr2=(curr2*p_pow[n-i-1-l/2])%m;\\n                //cout<<curr1<<\" \"<<curr2<<endl;\\n                if(curr1==curr2)\\n                {\\n                    um[curr1]++; //mark this substring\\'s hash as visited\\n                }\\n            }\\n        }\\n        return um.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Rolling Hash"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll p=31;\\n    ll m=1000000009;\\n    int distinctEchoSubstrings(string text) {\\n        ll n=text.size();\\n        vector <ll> p_pow(n);\\n        p_pow[0]=1;\\n        for(ll i=1;i<n;i++)\\n            p_pow[i]=(p_pow[i-1]*p)%m;\\n        vector <ll> hash(n+1,0);\\n        for(ll i=0;i<n;i++)\\n        {\\n\\t\\t   hash[i+1]= (hash[i] + (text[i]-\\'a\\'+1)*p_pow[i])%m; //dont forget the 1 here, or else \"aa\" and \"aaa\" will map to the same value\\n        }\\n        //for(int i=0;i<=n;i++)\\n           // cout<<hash[i]<< \" \";\\n        unordered_map <ll ,ll > um;\\n        for(ll l=2;l<=n;l+=2)\\n        {\\n            for(ll i=0;i+l<=n;i++)\\n            {\\n                ll curr1= (hash[i+l/2]+m-hash[i])%m; // +m for ensuring +ve remainder\\n                curr1=(curr1*p_pow[n-i-1])%m; \\n                ll curr2= (hash[i+ l] +m - hash[i+l/2])%m; \\n                curr2=(curr2*p_pow[n-i-1-l/2])%m;\\n                //cout<<curr1<<\" \"<<curr2<<endl;\\n                if(curr1==curr2)\\n                {\\n                    um[curr1]++; //mark this substring\\'s hash as visited\\n                }\\n            }\\n        }\\n        return um.size();\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 477042,
                "title": "python-brute-force",
                "content": "```python\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        res = set()\\n        n = len(text)\\n        def check(s):\\n            l = len(s)\\n            if l % 2 == 0 and s[:l//2] == s[l//2:]:\\n                return True\\n            return False\\n        for i in range(n):\\n            for j in range(i+1, n+1):\\n                if check(text[i:j]):\\n                    res.add(text[i:j])\\n        #print(res)\\n        return len(res)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        res = set()\\n        n = len(text)\\n        def check(s):\\n            l = len(s)\\n            if l % 2 == 0 and s[:l//2] == s[l//2:]:\\n                return True\\n            return False\\n        for i in range(n):\\n            for j in range(i+1, n+1):\\n                if check(text[i:j]):\\n                    res.add(text[i:j])\\n        #print(res)\\n        return len(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 831379,
                "title": "python-presum-hash-sliding-window-beats-100-11-lines",
                "content": "**Step-by-step:**\\nThe numbers match the annotations in the code.  \\n\\n**1. Optimization**\\n(#1) Whenever the string consists of only one character, there will be **len(string) // 2** distinct substrings that match the criteria.  \\n```python\\n\"a\" -> {}                      # 1 // 2 = 0\\n\"aa\" -> {\"a\"}                  # 2 // 2 = 1\\n\"aaa\" -> {\"a\"}                 # 3 // 2 = 1\\n\"aaaa\" -> {\"a\", \"aa\"}          # 4 // 2 = 2\\n\"aaaaa\" -> {\"a\", \"aa\"}         # 5 // 2 = 2\\n\"aaaaaa\" -> {\"a\", \"aa\", \"aaa\"} # 6 // 2 = 3\\n```\\n**2. Presum Hash**\\nYou can think of the presum hash as the Rabin-Karp algorithm **(hash = &Sigma; ord(char) &middot; d<sup>i</sup>)** where d = 1 so **hash = &Sigma; ord(char)**.  If you are unfamiliar with the Rabin-Karp algorithm check out this link: <a href=\"https://www.youtube.com/watch?v=BfUejqd07yo\">Rolling Hash Function Tutorial</a>\\n\\n(#2) Next, calculate the hash for **text[:i]** for all indices **(i)** in text, and store them in the array presum.  \\n(#2.1) The hash for string **text[i:j]** can now be found in O(1) time  **hash(text[i:j]) = presum[j] - presum[i]**. \\n\\n**3. Find Echos**\\nFor all echo string lengths **(w)** from 1 to half the length of the text.  Slide **i** along text where **i** is the first index of the echo string.  \\n```python\\n   echo    echo\\n |<--w-->|<--w-->|\\n i      i+w     i+2w\\n\\'abcababcabcabcabcaaabcabc\\'\\n```\\nUse the presum hash described in part 2, to decide if **hash(text[i:i+w]) == hash(text[i+w: i+2*w])** in O(1) time... almost.\\n\\nI say almost because the hash is just **&Sigma; ord(char)** for each echo string.  So when the first and second echo contain the same characters, like **\"cababc\"**, then **text[i:i+w] = \"cab\"** and **text[i+w:i+2*w] = \"abc\"**, the strings are not equal but they will have the same hash: **hash(\\'abc\\') = hash(\\'cab\\') = 97 + 98 + 99 = 294**.  This is called a collision.  \\n\\nTo double check that **text[i+w: i+2*w]** is an echo of **text[i:i+w]**, whenever **hash(text[i:i+w]) == hash(text[i+w: i+2*w])** we must also check that **text[i:i+w] == text[i+w: i+2*w]** (#3).  If the two echo strings are equal, then it is safe to add the full string to our result **(res)**.  \\n\\n```python\\ndef distinctEchoSubstrings(self, text: str) -> int:\\n\\n\\tif len(set(text)) == 1: return len(text)//2 # 1\\n\\n\\tpresum = [0] # 2\\n\\tfor char in text:\\n\\t\\tpresum.append(presum[-1] + ord(char))\\n\\n\\tres = set()\\n\\tfor w in range(1,(2 + len(text)) // 2):\\n\\t\\tfor i in range(len(text) + 1 - 2*w):\\n\\t\\t\\tif presum[i+w] - presum[i] == presum[i+2*w] - presum[i+w]: # 2.1\\n\\t\\t\\t\\tif text[i:i+w] == text[i+w:i+2*w]: # 3\\n\\t\\t\\t\\t\\tres.add(text[i:i+w])\\n\\n\\treturn len(res)\\n```\\n<img src=\"https://assets.leetcode.com/users/images/b38ec8da-b700-44be-95e7-9d52e79e00fc_1599371717.705521.png\" width=\"50%\">\\n\\n",
                "solutionTags": [],
                "code": "```python\\n\"a\" -> {}                      # 1 // 2 = 0\\n\"aa\" -> {\"a\"}                  # 2 // 2 = 1\\n\"aaa\" -> {\"a\"}                 # 3 // 2 = 1\\n\"aaaa\" -> {\"a\", \"aa\"}          # 4 // 2 = 2\\n\"aaaaa\" -> {\"a\", \"aa\"}         # 5 // 2 = 2\\n\"aaaaaa\" -> {\"a\", \"aa\", \"aaa\"} # 6 // 2 = 3\\n```\n```python\\n   echo    echo\\n |<--w-->|<--w-->|\\n i      i+w     i+2w\\n\\'abcababcabcabcabcaaabcabc\\'\\n```\n```python\\ndef distinctEchoSubstrings(self, text: str) -> int:\\n\\n\\tif len(set(text)) == 1: return len(text)//2 # 1\\n\\n\\tpresum = [0] # 2\\n\\tfor char in text:\\n\\t\\tpresum.append(presum[-1] + ord(char))\\n\\n\\tres = set()\\n\\tfor w in range(1,(2 + len(text)) // 2):\\n\\t\\tfor i in range(len(text) + 1 - 2*w):\\n\\t\\t\\tif presum[i+w] - presum[i] == presum[i+2*w] - presum[i+w]: # 2.1\\n\\t\\t\\t\\tif text[i:i+w] == text[i+w:i+2*w]: # 3\\n\\t\\t\\t\\t\\tres.add(text[i:i+w])\\n\\n\\treturn len(res)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 478284,
                "title": "c-using-a-trie-o-n-without-hash-collision-issues",
                "content": "There are some very fast rolling hash solutions out there. But as many have pointed out, those are not 100% reliable because of possible hash collisions. And to store and double-check every match char-by-char would increase worst-case runtime complexity to O(n\\xB3).\\n\\nAn alternative approach is to build a trie, and use the identity (memory address) of the trie nodes to uniquely identify a substring. This is O(n\\xB2) and there can\\'t be any collisions that way, but at the cost of speed. Memory access takes time, and we don\\'t even get the benefit of cache locality. It runs at about 350 ms. Double that if we clean up our Trie nodes afterwards.\\n\\n```C++\\nclass Solution {\\npublic:\\n  int distinctEchoSubstrings(string const& text) {\\n    SSIDStore ssids = constructSubstringIdentifiers(text);\\n    return distinctEchoSubstrings(text, ssids);\\n  }\\n\\nprivate:\\n  /////////// Types ///////////\\n  \\n  struct Trie {\\n    array<Trie*, 26> children_ {};\\n    Trie* append(char c) { return children_[c-\\'a\\'] ? children_[c-\\'a\\'] : (children_[c-\\'a\\'] = new Trie); }\\n    // ~Trie() { for (Trie* child : children_) delete child; } // cleaning up adds about 350ms to the runtime\\n  };\\n  \\n  using SSID      = uint64_t;             // Substring ID\\n  using SSIDStore = vector<vector<SSID>>; // index \\u2192 length \\u2192 id\\n  \\n  /////////// Functions ///////////\\n  \\n  /* For every relevant substring, assign a unique number derived from a Trie address: O(n\\xB2) */\\n  static SSIDStore constructSubstringIdentifiers(string const& text) {\\n    int const N = text.size();\\n    SSIDStore result(N, vector<SSID>(N/2+1));\\n    Trie root;\\n    for (int l = 0; l < N; ++l) {\\n      Trie* node = &root;\\n      int const maxLen = max(min(l, N-l), (N-l)/2);\\n      for (int len = 1; len <= maxLen; ++len) {\\n        node = node->append(text[l+len-1]);\\n        result[l][len] = (SSID)node; // interpret memory address as integer\\n      }\\n    }\\n    return result;\\n  }\\n  \\n  /* Count the number of distinct echo substrings: O(n\\xB2) */\\n  static int distinctEchoSubstrings(string const& text, SSIDStore const& ssids) {\\n    int const N = text.size();\\n    unordered_set<SSID> found;\\n    for (int l = 0; l < N; ++l)\\n      for (int len = 1; len <= (N-l)/2; ++len)\\n        if (ssids[l][len] == ssids[l+len][len])\\n          found.insert(ssids[l][len]);\\n    return found.size();\\n  }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n  int distinctEchoSubstrings(string const& text) {\\n    SSIDStore ssids = constructSubstringIdentifiers(text);\\n    return distinctEchoSubstrings(text, ssids);\\n  }\\n\\nprivate:\\n  /////////// Types ///////////\\n  \\n  struct Trie {\\n    array<Trie*, 26> children_ {};\\n    Trie* append(char c) { return children_[c-\\'a\\'] ? children_[c-\\'a\\'] : (children_[c-\\'a\\'] = new Trie); }\\n    // ~Trie() { for (Trie* child : children_) delete child; } // cleaning up adds about 350ms to the runtime\\n  };\\n  \\n  using SSID      = uint64_t;             // Substring ID\\n  using SSIDStore = vector<vector<SSID>>; // index \\u2192 length \\u2192 id\\n  \\n  /////////// Functions ///////////\\n  \\n  /* For every relevant substring, assign a unique number derived from a Trie address: O(n\\xB2) */\\n  static SSIDStore constructSubstringIdentifiers(string const& text) {\\n    int const N = text.size();\\n    SSIDStore result(N, vector<SSID>(N/2+1));\\n    Trie root;\\n    for (int l = 0; l < N; ++l) {\\n      Trie* node = &root;\\n      int const maxLen = max(min(l, N-l), (N-l)/2);\\n      for (int len = 1; len <= maxLen; ++len) {\\n        node = node->append(text[l+len-1]);\\n        result[l][len] = (SSID)node; // interpret memory address as integer\\n      }\\n    }\\n    return result;\\n  }\\n  \\n  /* Count the number of distinct echo substrings: O(n\\xB2) */\\n  static int distinctEchoSubstrings(string const& text, SSIDStore const& ssids) {\\n    int const N = text.size();\\n    unordered_set<SSID> found;\\n    for (int l = 0; l < N; ++l)\\n      for (int len = 1; len <= (N-l)/2; ++len)\\n        if (ssids[l][len] == ssids[l+len][len])\\n          found.insert(ssids[l][len]);\\n    return found.size();\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2530137,
                "title": "c-simple-c-code-rolling-hashing",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string s) {\\n        int mod = INT_MAX, base = 28, n = s.size();\\n        unordered_map<long long, int> um;\\n        vector<long long> ChkVal(n+1);\\n        long long remove = 1;\\n        for(int i = 1; i <= n/2; i++)\\n        {\\n            long long hash = 0;\\n            int l = 0, appear = 0;\\n            for(int j = 0; j < n; j++)\\n            {\\n                 hash = (( hash * base ) % mod  + (s[j] - \\'a\\' + 1))%mod;\\n                 if(j-l == i-1) \\n                 {\\n                     ChkVal[j]=hash;\\n                     if(appear > 0) \\n                     {\\n                         if(ChkVal[j-i]==hash)\\n                            um[hash]++;\\n                     }\\n                     appear++;\\n                     hash = (hash - ((s[l] - \\'a\\' + 1)*remove)%mod)%mod;\\n                     if(hash<0) hash+=mod;\\n                     l++;\\n                }\\n            }\\n            // cout << i << \" \" << um.size() << endl; \\n            remove = (remove * base)%mod;\\n        }\\n        return um.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Rolling Hash"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string s) {\\n        int mod = INT_MAX, base = 28, n = s.size();\\n        unordered_map<long long, int> um;\\n        vector<long long> ChkVal(n+1);\\n        long long remove = 1;\\n        for(int i = 1; i <= n/2; i++)\\n        {\\n            long long hash = 0;\\n            int l = 0, appear = 0;\\n            for(int j = 0; j < n; j++)\\n            {\\n                 hash = (( hash * base ) % mod  + (s[j] - \\'a\\' + 1))%mod;\\n                 if(j-l == i-1) \\n                 {\\n                     ChkVal[j]=hash;\\n                     if(appear > 0) \\n                     {\\n                         if(ChkVal[j-i]==hash)\\n                            um[hash]++;\\n                     }\\n                     appear++;\\n                     hash = (hash - ((s[l] - \\'a\\' + 1)*remove)%mod)%mod;\\n                     if(hash<0) hash+=mod;\\n                     l++;\\n                }\\n            }\\n            // cout << i << \" \" << um.size() << endl; \\n            remove = (remove * base)%mod;\\n        }\\n        return um.size();\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1244285,
                "title": "c-solution-rolling-hash-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    static const int N=2005;\\n    int mod=1e9+7;\\n    int B=31;\\n    long long h[N],p[N],invp[N];\\n    int modexp(int x,int y){\\n        int res=1;\\n        while(y>0){\\n            if(y&1) res=((long long)res*x)%mod;\\n            x=((long long)x*x)%mod;\\n            y=y>>1;\\n        }\\n        return res;\\n    }\\n    int sub_hash(int l,int r){\\n        int ans=h[r];\\n        if(l>0)\\n            ans=((ans+mod-h[l-1])*invp[l]*1LL)%mod;\\n        return ans;\\n    }\\n    int distinctEchoSubstrings(string text) {\\n        set<int> res;\\n        int ans=0;\\n        p[0]=1;invp[0]=1;\\n        for(int i=1;i<2005;i++){\\n            p[i]=(p[i-1]*B)%mod;\\n        }\\n        for(int i=1;i<N;i++){\\n            invp[i]=(invp[i-1]*modexp(B,mod-2))%mod;\\n        }\\n        int n=text.size();\\n        h[0]=(text[0]-\\'a\\'+1);\\n        for(int i=1;i<n;i++){\\n            h[i]=(h[i-1]+((text[i]-\\'a\\'+1)*p[i])*1LL)%mod;\\n        }\\n        for(int len=1;len<=n/2;len++){\\n            for(int i=0;i<n+1-2*len;i++){\\n                int a=sub_hash(i,i+len-1);\\n                int b=sub_hash(i+len,i+2*len-1);\\n                if(a==b){\\n                    if(res.find(a)==res.end()){\\n                        res.insert(a);\\n                        ans++;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static const int N=2005;\\n    int mod=1e9+7;\\n    int B=31;\\n    long long h[N],p[N],invp[N];\\n    int modexp(int x,int y){\\n        int res=1;\\n        while(y>0){\\n            if(y&1) res=((long long)res*x)%mod;\\n            x=((long long)x*x)%mod;\\n            y=y>>1;\\n        }\\n        return res;\\n    }\\n    int sub_hash(int l,int r){\\n        int ans=h[r];\\n        if(l>0)\\n            ans=((ans+mod-h[l-1])*invp[l]*1LL)%mod;\\n        return ans;\\n    }\\n    int distinctEchoSubstrings(string text) {\\n        set<int> res;\\n        int ans=0;\\n        p[0]=1;invp[0]=1;\\n        for(int i=1;i<2005;i++){\\n            p[i]=(p[i-1]*B)%mod;\\n        }\\n        for(int i=1;i<N;i++){\\n            invp[i]=(invp[i-1]*modexp(B,mod-2))%mod;\\n        }\\n        int n=text.size();\\n        h[0]=(text[0]-\\'a\\'+1);\\n        for(int i=1;i<n;i++){\\n            h[i]=(h[i-1]+((text[i]-\\'a\\'+1)*p[i])*1LL)%mod;\\n        }\\n        for(int len=1;len<=n/2;len++){\\n            for(int i=0;i<n+1-2*len;i++){\\n                int a=sub_hash(i,i+len-1);\\n                int b=sub_hash(i+len,i+2*len-1);\\n                if(a==b){\\n                    if(res.find(a)==res.end()){\\n                        res.insert(a);\\n                        ans++;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477896,
                "title": "no-rolling-hash-trie-with-optimization-and-explanation",
                "content": "## **Explanation**\\nUse a trie to find if there is a substring that is exactly same as another substring left adjacent to it. If we find such a pair of substrings, increment result by 1, and in the trie mark the substring as \"found\" so we don\\'t count duplicates.\\nThere is an optimization:\\n```\\nif i - start + 1 > len(text) - i and i - start + 1 > start:\\n    break\\n```\\nWhile we are looking for apair of adjacent substrings `str1 str2`,\\n\\nif `i - start + 1 > len(text) - i`: it will be impossilbe to find a long enough `str2` that matches the `str1` we are looking at,\\nand if `i - start + 1 > start`: it will be impossible to find a long enough `str1` that matches the `str2` we are looking at\\n\\nthen we don\\'t have to look further on the substrings that started from `start`.\\n\\n## **Python code**\\n\\n```\\nimport collections\\nclass Solution(object):\\n    def distinctEchoSubstrings(self, text):\\n        T = lambda: collections.defaultdict(T)\\n        trie = T()\\n        res = 0\\n        for start in xrange(len(text)):\\n            t = trie\\n            for i in xrange(start, len(text)):\\n                t = t[text[i]]\\n                if \"found\" in t:\\n                    continue\\n                if i - start + 1 > len(text) - i and i - start + 1 > start:\\n                    break\\n                t.setdefault(\"indexes\", set()).add(i)\\n                if start - 1 in t[\"indexes\"]:\\n                    res += 1\\n                    t[\"found\"] = True\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nif i - start + 1 > len(text) - i and i - start + 1 > start:\\n    break\\n```\n```\\nimport collections\\nclass Solution(object):\\n    def distinctEchoSubstrings(self, text):\\n        T = lambda: collections.defaultdict(T)\\n        trie = T()\\n        res = 0\\n        for start in xrange(len(text)):\\n            t = trie\\n            for i in xrange(start, len(text)):\\n                t = t[text[i]]\\n                if \"found\" in t:\\n                    continue\\n                if i - start + 1 > len(text) - i and i - start + 1 > start:\\n                    break\\n                t.setdefault(\"indexes\", set()).add(i)\\n                if start - 1 in t[\"indexes\"]:\\n                    res += 1\\n                    t[\"found\"] = True\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 606380,
                "title": "o-n-2-36ms-solution-with-easy-rolling-hash-c",
                "content": "```\\nconst int p = 1e9 + 7;\\nstruct RollingHash {\\n    vector<long> hash;\\n    vector<long> power;\\n    RollingHash(string &s):hash(s.size() + 1), power(s.size() + 1, 1) {\\n        for(int i = 1; i <= s.size(); i++) {\\n            char c = s[i - 1];\\n            hash[i] = (hash[i - 1] * 257 + c) % p;\\n            power[i] = (power[i - 1] * 257 ) % p;\\n        }\\n    }\\n    \\n    int getHash(int i, int j) {\\n        long h = hash[j + 1];\\n        h -= (power[j - i + 1] * hash[i]) % p;\\n        h = (h + p) % p;\\n        return h;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        RollingHash hash(text);\\n        int n = text.size();\\n        int ans = 0;\\n        unordered_set<int> hashes;\\n        for(int i = 0; i < n; i++)\\n            for(int d = (n - i) / 2; d >= 1; d--) {\\n                int h1 = hash.getHash(i, i + d - 1);\\n                if(h1 == hash.getHash(i + d, i + 2 * d - 1)) {\\n                    if(hashes.count(h1))break;\\n                    hashes.insert(h1);\\n                }\\n            }\\n                 \\n        return hashes.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst int p = 1e9 + 7;\\nstruct RollingHash {\\n    vector<long> hash;\\n    vector<long> power;\\n    RollingHash(string &s):hash(s.size() + 1), power(s.size() + 1, 1) {\\n        for(int i = 1; i <= s.size(); i++) {\\n            char c = s[i - 1];\\n            hash[i] = (hash[i - 1] * 257 + c) % p;\\n            power[i] = (power[i - 1] * 257 ) % p;\\n        }\\n    }\\n    \\n    int getHash(int i, int j) {\\n        long h = hash[j + 1];\\n        h -= (power[j - i + 1] * hash[i]) % p;\\n        h = (h + p) % p;\\n        return h;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        RollingHash hash(text);\\n        int n = text.size();\\n        int ans = 0;\\n        unordered_set<int> hashes;\\n        for(int i = 0; i < n; i++)\\n            for(int d = (n - i) / 2; d >= 1; d--) {\\n                int h1 = hash.getHash(i, i + d - 1);\\n                if(h1 == hash.getHash(i + d, i + 2 * d - 1)) {\\n                    if(hashes.count(h1))break;\\n                    hashes.insert(h1);\\n                }\\n            }\\n                 \\n        return hashes.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 565625,
                "title": "java-rolling-haha",
                "content": "```\\nclass Solution {\\n    int mod=1000000007;\\n    long hash[];\\n    long pow[];\\n    public int distinctEchoSubstrings(String text) {\\n        hash=new long[text.length()];\\n        pow=new long[text.length()];\\n        pow[0]=1;\\n        hash[0]=text.charAt(0)%mod;\\n        Set<String>res=new HashSet<>();\\n        for(int i=1;i<text.length();i++){\\n            hash[i]=(hash[i-1]*26+text.charAt(i))%mod;\\n            pow[i]=(pow[i-1]*26)%mod;\\n        }\\n        for(int i=0;i<text.length();i++){\\n            for(int len=1;i+len*2<=text.length();len++){\\n                long hash1=0;long hash2=0;\\n                hash1=gethash(text,i,i+len-1);\\n                hash2=gethash(text,i+len,i+len*2-1);\\n                if(hash1==hash2&&text.substring(i,i+len).equals(text.substring(i+len,i+len*2))){\\n                    res.add(text.substring(i,i+len));\\n                }\\n            }\\n        }\\n        return res.size();\\n    }\\n\\t//similar idea as prefix sum\\n    public long gethash(int left,int right){\\n        if(left==0)return hash[right];\\n        long res=(hash[right]-hash[left-1]*pow[right-left+1])%mod;\\n        if(res<0)res+=mod;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int mod=1000000007;\\n    long hash[];\\n    long pow[];\\n    public int distinctEchoSubstrings(String text) {\\n        hash=new long[text.length()];\\n        pow=new long[text.length()];\\n        pow[0]=1;\\n        hash[0]=text.charAt(0)%mod;\\n        Set<String>res=new HashSet<>();\\n        for(int i=1;i<text.length();i++){\\n            hash[i]=(hash[i-1]*26+text.charAt(i))%mod;\\n            pow[i]=(pow[i-1]*26)%mod;\\n        }\\n        for(int i=0;i<text.length();i++){\\n            for(int len=1;i+len*2<=text.length();len++){\\n                long hash1=0;long hash2=0;\\n                hash1=gethash(text,i,i+len-1);\\n                hash2=gethash(text,i+len,i+len*2-1);\\n                if(hash1==hash2&&text.substring(i,i+len).equals(text.substring(i+len,i+len*2))){\\n                    res.add(text.substring(i,i+len));\\n                }\\n            }\\n        }\\n        return res.size();\\n    }\\n\\t//similar idea as prefix sum\\n    public long gethash(int left,int right){\\n        if(left==0)return hash[right];\\n        long res=(hash[right]-hash[left-1]*pow[right-left+1])%mod;\\n        if(res<0)res+=mod;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477277,
                "title": "c-concise-dp-solution",
                "content": "```\\npublic class Solution {\\n    public int DistinctEchoSubstrings(string text) {\\n        int mod = (int)Math.Pow(10,9) + 7;\\n        int[,] dp = new int[text.Length+1, text.Length+1];\\n        HashSet<int> res = new HashSet<int>();\\n        for (int i = 1; i <= text.Length; i++)\\n        {\\n            for (int j = i; j <= text.Length; j++)\\n            {\\n                dp[i, j] = dp[i, j - 1] * 26 % mod + text[j - 1] - \\'a\\' + 1;\\n                if (i * 2 - j - 1 >= 0 && dp[i * 2 - j - 1, i - 1] == dp[i, j])\\n                    res.Add(dp[i, j]);\\n            }\\n        }\\n        \\n        return res.Count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int DistinctEchoSubstrings(string text) {\\n        int mod = (int)Math.Pow(10,9) + 7;\\n        int[,] dp = new int[text.Length+1, text.Length+1];\\n        HashSet<int> res = new HashSet<int>();\\n        for (int i = 1; i <= text.Length; i++)\\n        {\\n            for (int j = i; j <= text.Length; j++)\\n            {\\n                dp[i, j] = dp[i, j - 1] * 26 % mod + text[j - 1] - \\'a\\' + 1;\\n                if (i * 2 - j - 1 >= 0 && dp[i * 2 - j - 1, i - 1] == dp[i, j])\\n                    res.Add(dp[i, j]);\\n            }\\n        }\\n        \\n        return res.Count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2691157,
                "title": "i-am-dumb-i-can-t-understand-this-task",
                "content": "I can\\'t understand this line, `that can be written as the concatenation of some string with itself (i.e. it can be written as a + a where a is some string).`\\n\\nEvery string can be written as the concatenation of some string with itself.... WTF is this task? I wasted 24+ hours just to understand the test cases but couldn\\'t get anything. \\n\\n\\nSomebody please kill me, I no longer feel the reason to stay alive.",
                "solutionTags": [],
                "code": "I can\\'t understand this line, `that can be written as the concatenation of some string with itself (i.e. it can be written as a + a where a is some string).`\\n\\nEvery string can be written as the concatenation of some string with itself.... WTF is this task? I wasted 24+ hours just to understand the test cases but couldn\\'t get anything. \\n\\n\\nSomebody please kill me, I no longer feel the reason to stay alive.",
                "codeTag": "Unknown"
            },
            {
                "id": 1341886,
                "title": "python-3-rolling-hash-5780ms",
                "content": "```\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        n = len(text)\\n\\t\\t\\n        def helper(size):\\n            base = 1 << 5\\n            M = 10 ** 9 + 7\\n            a = pow(base, size, M)\\n            t = 0\\n            vis = defaultdict(set)\\n            vis_pattern = set()\\n            ans = 0\\n            for i in range(n):\\n                t = (base * t + ord(text[i]) - ord(\\'a\\')) % M\\n                if i >= size:\\n                    t -= a * (ord(text[i - size]) - ord(\\'a\\'))\\n                    t %= M\\n                    if t not in vis_pattern and (i - size * 2 + 1) in vis[t]:\\n                        ans += 1\\n                        vis_pattern.add(t)\\n                if i >= size - 1:\\n                    vis[t].add(i - size + 1)\\n            return ans\\n\\n        return sum(helper(size) for size in range(1, n//2+1))",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Rolling Hash"
                ],
                "code": "```\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        n = len(text)\\n\\t\\t\\n        def helper(size):\\n            base = 1 << 5\\n            M = 10 ** 9 + 7\\n            a = pow(base, size, M)\\n            t = 0\\n            vis = defaultdict(set)\\n            vis_pattern = set()\\n            ans = 0\\n            for i in range(n):\\n                t = (base * t + ord(text[i]) - ord(\\'a\\')) % M\\n                if i >= size:\\n                    t -= a * (ord(text[i - size]) - ord(\\'a\\'))\\n                    t %= M\\n                    if t not in vis_pattern and (i - size * 2 + 1) in vis[t]:\\n                        ans += 1\\n                        vis_pattern.add(t)\\n                if i >= size - 1:\\n                    vis[t].add(i - size + 1)\\n            return ans\\n\\n        return sum(helper(size) for size in range(1, n//2+1))",
                "codeTag": "Java"
            },
            {
                "id": 1181698,
                "title": "java-clean-o-n-2-rolling-hash-dynamic-programming-solution-with-comments",
                "content": "For those who are not familiar with Rabin-Karp rolling-hash method, I strongly recommand you try this question first. \\n* [28. Implement strStr()](https://leetcode.com/problems/implement-strstr/)\\n\\nYou might also want to try and compare these questions to realize the power of Rabin-Karp\\'s:\\n* [214. Shortest Palindrome](https://leetcode.com/problems/shortest-palindrome/)\\n* [718. Maximum Length of Repeated Subarray](https://leetcode.com/problems/maximum-length-of-repeated-subarray/discuss/1181612/Java-Clean-O(N-logN)-Rolling-Hash-Solution-oror-with-comments)\\n* [1044. Longest Duplicate Substring (collision)](https://leetcode.com/problems/longest-duplicate-substring/discuss/1260058/Java-Rabin-Karp-O(N-logN)-Solution-oror-with-comments)\\n* [1316. Distinct Echo Substrings](https://leetcode.com/problems/distinct-echo-substrings/discuss/1181698/Java-clean-O(n2)-Rolling-Hash-Solution-oror-with-comments)\\n* [1698. Number of Distinct Substrings in a String](https://leetcode.com/problems/number-of-distinct-substrings-in-a-string/discuss/1196782/Java-clean-O(N2)-Rabin-Karp-Solution)\\n\\nAgain, everytime we calculate hash values when implementing Rabin-Karp\\'s, there\\'s some issue to worry about. There are some good practices that will make this algorithm stable: \\n1. taking modulus to avoid overflow\\n2. each time adding a positive number when updating hash value\\n\\nConsider these two ways of updating hash values: \\n``` \\nhash = hash * PRIME + text.charAt(j);\\nhash = hash * PRIME + text.charAt(j) - \\'a\\' + 1;\\nhash = hash * PRIME + text.charAt(j) - \\'a\\';\\n```\\nThe third one will not work here since encountering \\'a\\' leads to adding 0 to hash value. Thus \"a\", \"aa\", \"aa....a\"  will share the same hash value. \\n\\n```\\nclass Solution {\\n    private static final int PRIME = 101;\\n    private static final int MOD = 1_000_000_007;\\n    public int distinctEchoSubstrings(String text) {\\n        int n = text.length();\\n        \\n        // dp[i][j] : hash value of text[i:j]\\n        int[][] dp = new int[n][n];\\n        for (int i = 0; i < n; i++) {\\n            long hash = 0;\\n            for (int j = i; j < n; j++) {\\n                hash = hash * PRIME + (text.charAt(j) - \\'a\\' + 1);\\n                hash %= MOD;\\n                dp[i][j] = (int) hash;\\n            }\\n        }\\n        \\n        Set<Integer> set = new HashSet<>();\\n        int res = 0;\\n        for (int i = 0; i < n-1; i++) {\\n            // compare text[i:j] with text[j+1: 2j-i+1]\\n            for (int j = i; 2*j - i + 1 < n; j++) {\\n                if (dp[i][j] == dp[j+1][2*j - i+1] && set.add(dp[i][j])) res++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n\\nNote: this Solution is induced by a [Monte Carlo Algorithm](http://people.seas.harvard.edu/~cs125/fall16/section-notes/09.pdf), which might leads to unwanted results due to hash collision. However in real practice, the probability of hash collision is very low due to our choice of PRIME & MOD. If we want to absolutely eliminate any possibility of unwanted results caused by the algorithm, we might compare two String if they have the same hash value; Namely, this solution will be induced by a [Las Vegas Algorithm](http://people.seas.harvard.edu/~cs125/fall16/section-notes/09.pdf).",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Rolling Hash"
                ],
                "code": "``` \\nhash = hash * PRIME + text.charAt(j);\\nhash = hash * PRIME + text.charAt(j) - \\'a\\' + 1;\\nhash = hash * PRIME + text.charAt(j) - \\'a\\';\\n```\n```\\nclass Solution {\\n    private static final int PRIME = 101;\\n    private static final int MOD = 1_000_000_007;\\n    public int distinctEchoSubstrings(String text) {\\n        int n = text.length();\\n        \\n        // dp[i][j] : hash value of text[i:j]\\n        int[][] dp = new int[n][n];\\n        for (int i = 0; i < n; i++) {\\n            long hash = 0;\\n            for (int j = i; j < n; j++) {\\n                hash = hash * PRIME + (text.charAt(j) - \\'a\\' + 1);\\n                hash %= MOD;\\n                dp[i][j] = (int) hash;\\n            }\\n        }\\n        \\n        Set<Integer> set = new HashSet<>();\\n        int res = 0;\\n        for (int i = 0; i < n-1; i++) {\\n            // compare text[i:j] with text[j+1: 2j-i+1]\\n            for (int j = i; 2*j - i + 1 < n; j++) {\\n                if (dp[i][j] == dp[j+1][2*j - i+1] && set.add(dp[i][j])) res++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 616900,
                "title": "c-accepted-o-n-2-method-with-kmp-algorithms",
                "content": "The idea is to use KMP algorithm for finding the cycle period, the vanilla implement is as follows:\\n```\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        unordered_set<string> rnt;\\n        while(text.length() >= 2){\\n            helper(text, rnt);\\n            text = text.substr(1, text.length() - 1);\\n        }\\n        return rnt.size();\\n    }\\n    \\n    void helper(string& text, unordered_set<string>& rnt){\\n        vector<int> nexts(text.size() + 1, -1);\\n        int pt = 0, k = -1;\\n        while(pt < text.size()){\\n            if(k == -1 || text[pt] == text[k]){\\n                pt++; k++;\\n                nexts[pt] = k;\\n            }\\n            else\\n                k = nexts[k];\\n        }\\n        for(int i = 2; i <= text.size(); i += 2)\\n            if(i % (i - nexts[i]) == 0 && (i / (i - nexts[i])) % 2 == 0)\\n                rnt.insert(text.substr(0, (i + 1) / 2));\\n        return;\\n    }\\n};\\n```\\n\\nHere, kmp algorithms used to find prefix cost O(N^2) but the \\'unordered_set<string>\\' used to keep distinct substrings is the bottlenect O(N^3) (thank @gorokhovsky for the reminder). A direct optimization may be string hashing to convert the \\'unordered_set<string>\\' to \\'unordered_set<int>\\' (in this way, the complexity is O(N^2)) as in the following hashing solution:\\n\\n```\\nclass Solution {\\npublic:\\n    using LL = unsigned long long;\\n    int distinctEchoSubstrings(string text) {\\n        int n = text.length();\\n        vector<vector<LL>> dp(n, vector<LL>(n, 0));\\n        for(int i = 0; i < n; i ++){\\n            LL tmp = 0;\\n            for(int j = i; j < n; j ++){\\n                tmp = tmp * 29 + (text[j] - \\'a\\' + 1);\\n                dp[i][j] = tmp;\\n            }\\n        }\\n        unordered_set<int> rnt;\\n        for(int i = 0; i < n - 1; i ++){\\n            for(int w = 1; i + 2 * w <= n; w ++)\\n                if(dp[i][i + w - 1] == dp[i + w][i + 2 * w - 1])\\n                    rnt.insert(dp[i][i + w - 1]);\\n        }\\n        return rnt.size();\\n    }\\n};\\n```\\n\\nThe direct use of string hashing can be a simpler solution. But, as far as I am concerned, the KMP solution can be more general for problems like \\'a + a + ... + a\\' rather than the original special case \\'a + a\\'.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        unordered_set<string> rnt;\\n        while(text.length() >= 2){\\n            helper(text, rnt);\\n            text = text.substr(1, text.length() - 1);\\n        }\\n        return rnt.size();\\n    }\\n    \\n    void helper(string& text, unordered_set<string>& rnt){\\n        vector<int> nexts(text.size() + 1, -1);\\n        int pt = 0, k = -1;\\n        while(pt < text.size()){\\n            if(k == -1 || text[pt] == text[k]){\\n                pt++; k++;\\n                nexts[pt] = k;\\n            }\\n            else\\n                k = nexts[k];\\n        }\\n        for(int i = 2; i <= text.size(); i += 2)\\n            if(i % (i - nexts[i]) == 0 && (i / (i - nexts[i])) % 2 == 0)\\n                rnt.insert(text.substr(0, (i + 1) / 2));\\n        return;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using LL = unsigned long long;\\n    int distinctEchoSubstrings(string text) {\\n        int n = text.length();\\n        vector<vector<LL>> dp(n, vector<LL>(n, 0));\\n        for(int i = 0; i < n; i ++){\\n            LL tmp = 0;\\n            for(int j = i; j < n; j ++){\\n                tmp = tmp * 29 + (text[j] - \\'a\\' + 1);\\n                dp[i][j] = tmp;\\n            }\\n        }\\n        unordered_set<int> rnt;\\n        for(int i = 0; i < n - 1; i ++){\\n            for(int w = 1; i + 2 * w <= n; w ++)\\n                if(dp[i][i + w - 1] == dp[i + w][i + 2 * w - 1])\\n                    rnt.insert(dp[i][i + w - 1]);\\n        }\\n        return rnt.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477038,
                "title": "java-easy-to-understand-solution-n-3",
                "content": "```\\nclass Solution {\\n    public int distinctEchoSubstrings(String text) {\\n        HashSet<String> results = new HashSet<>();\\n        for (int i = 0; i < text.length(); i++) {\\n            for (int j = i+1; j < text.length(); j++) {\\n                if (text.charAt(i) == text.charAt(j) && check(text, i, j)) {\\n\\t\\t\\t\\t\\t// if you find the same solution twice, HashSet only registers it once\\n                    results.add(text.substring(i, j));\\n                }\\n            }\\n        }\\n        return results.size();\\n    }\\n    \\n\\t// two running indeces: a, b\\n\\t// check if the substring of text from a to b index, can be repeated after the index b\\n    private boolean check(String text, int a, int b) {\\n        for (int i = 0; i < b-a; i++) {\\n            if (b+i >= text.length()) {\\t// exceeded the length of the text\\n                return false;\\n            }\\n            if (text.charAt(a+i) != text.charAt(b+i)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int distinctEchoSubstrings(String text) {\\n        HashSet<String> results = new HashSet<>();\\n        for (int i = 0; i < text.length(); i++) {\\n            for (int j = i+1; j < text.length(); j++) {\\n                if (text.charAt(i) == text.charAt(j) && check(text, i, j)) {\\n\\t\\t\\t\\t\\t// if you find the same solution twice, HashSet only registers it once\\n                    results.add(text.substring(i, j));\\n                }\\n            }\\n        }\\n        return results.size();\\n    }\\n    \\n\\t// two running indeces: a, b\\n\\t// check if the substring of text from a to b index, can be repeated after the index b\\n    private boolean check(String text, int a, int b) {\\n        for (int i = 0; i < b-a; i++) {\\n            if (b+i >= text.length()) {\\t// exceeded the length of the text\\n                return false;\\n            }\\n            if (text.charAt(a+i) != text.charAt(b+i)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2614328,
                "title": "cpp-brute-force",
                "content": "```\\nclass Solution {\\npublic:  \\n    bool check(string &s){\\n        int j=s.size()/2;\\n        \\n        for(int i=0;i<(s.size()/2);i++){\\n            if(s[i]!=s[j])return false;\\n            j++;\\n        }\\n        return true;\\n    }\\n    \\n    int distinctEchoSubstrings(string text) {\\n               \\n        unordered_set<string>s;\\n        \\n        for(int i=0;i<text.size();i++){\\n            string ans=\"\";\\n            for(int j=i;j<text.size();j+=2){\\n                ans+=text[j];\\n                if(j+1<text.size())ans+=text[j+1];\\n                else break;\\n                \\n                if(check(ans))s.insert(ans);\\n            }\\n        }\\n        \\n        return s.size();\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:  \\n    bool check(string &s){\\n        int j=s.size()/2;\\n        \\n        for(int i=0;i<(s.size()/2);i++){\\n            if(s[i]!=s[j])return false;\\n            j++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1779507,
                "title": "regex-solution",
                "content": "```\\nimport re\\n\\n\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        return len(set(re.findall(\"(?=(.+)\\\\\\\\1)\", text)))\\n```\\n\\nJust simple solution of a problem..",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport re\\n\\n\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        return len(set(re.findall(\"(?=(.+)\\\\\\\\1)\", text)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1616142,
                "title": "java-solution",
                "content": "```\\npublic int distinctEchoSubstrings(String text) {\\n        HashSet<String> hs=new HashSet<>();\\n        \\n        for(int len=1;len<=(text.length()/2);len++)\\n        {\\n            int count=0;\\n            for(int i=0,j=len;j<text.length();i++,j++)\\n            {\\n                if(text.charAt(i)==text.charAt(j))\\n                    count++;\\n                else\\n                    count=0;\\n                \\n                if(count==len)\\n                {\\n                 String s=text.substring(i,j+1);\\n                    hs.add(s);\\n                    count--;\\n                    //abcabca ke liye abc count 3 len then bca-bca coun tnhi hoga \\n                    //as count keeps increasing so decrease count jisse bcabca bhi count ho\\n                    //problem when echo substirngs judi hui ho\\n                    //else nhi toh count=0 aur phirse shuru check\\n                }\\n            }\\n        }\\n        \\n        return hs.size();\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int distinctEchoSubstrings(String text) {\\n        HashSet<String> hs=new HashSet<>();\\n        \\n        for(int len=1;len<=(text.length()/2);len++)\\n        {\\n            int count=0;\\n            for(int i=0,j=len;j<text.length();i++,j++)\\n            {\\n                if(text.charAt(i)==text.charAt(j))\\n                    count++;\\n                else\\n                    count=0;\\n                \\n                if(count==len)\\n                {\\n                 String s=text.substring(i,j+1);\\n                    hs.add(s);\\n                    count--;\\n                    //abcabca ke liye abc count 3 len then bca-bca coun tnhi hoga \\n                    //as count keeps increasing so decrease count jisse bcabca bhi count ho\\n                    //problem when echo substirngs judi hui ho\\n                    //else nhi toh count=0 aur phirse shuru check\\n                }\\n            }\\n        }\\n        \\n        return hs.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1464269,
                "title": "a-different-idea-with-hashmap",
                "content": "First, using a HashMap to store where each character appears. Then for the same character located in i and j respectively, checking if there is a substring starting with j which is equal to the substring from i to j.\\n```\\nclass Solution {\\n    public int distinctEchoSubstrings(String text) {\\n        char[] arr = text.toCharArray();\\n        Map<Character, List<Integer>> map = new HashMap<>();\\n        for(int i=0; i<arr.length; i++)\\n            map.computeIfAbsent(arr[i], c->new ArrayList<>()).add(i);\\n        if(map.size() == 1) return arr.length/2;\\n        \\n        Set<String> set = new HashSet<>();\\n        for(int i=0; i<arr.length; i++){\\n            for(int idx : map.get(arr[i])){\\n                if(idx > i){\\n                    String subStr = text.substring(i, idx);\\n                    if(text.indexOf(subStr, idx) == idx)\\n                        set.add(subStr+subStr);\\n                }\\n            }\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int distinctEchoSubstrings(String text) {\\n        char[] arr = text.toCharArray();\\n        Map<Character, List<Integer>> map = new HashMap<>();\\n        for(int i=0; i<arr.length; i++)\\n            map.computeIfAbsent(arr[i], c->new ArrayList<>()).add(i);\\n        if(map.size() == 1) return arr.length/2;\\n        \\n        Set<String> set = new HashSet<>();\\n        for(int i=0; i<arr.length; i++){\\n            for(int idx : map.get(arr[i])){\\n                if(idx > i){\\n                    String subStr = text.substring(i, idx);\\n                    if(text.indexOf(subStr, idx) == idx)\\n                        set.add(subStr+subStr);\\n                }\\n            }\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1235445,
                "title": "c-brute-force-easy-to-understand",
                "content": "I was getting TLE initially, but after using string_view in place of string, the solution got accepted.\\n\\n```\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        int n=text.length();\\n        if(n==1) return 0;\\n        if(n==2){\\n            if(text[0]==text[1]) return true;\\n            return false;\\n        }\\n        set<string_view>s;\\n        string_view str=text;\\n        for(int i=0;i<n;i++){\\n           for(int len=2;i+len-1<n;len+=2){\\n               string_view a1=str.substr(i,len/2);\\n               string_view a2=str.substr(i+len/2,len/2);\\n               if(a1==a2){\\n                   \\n                   s.insert(a1);\\n               }\\n                   \\n           }\\n        }\\n        return s.size();\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        int n=text.length();\\n        if(n==1) return 0;\\n        if(n==2){\\n            if(text[0]==text[1]) return true;\\n            return false;\\n        }\\n        set<string_view>s;\\n        string_view str=text;\\n        for(int i=0;i<n;i++){\\n           for(int len=2;i+len-1<n;len+=2){\\n               string_view a1=str.substr(i,len/2);\\n               string_view a2=str.substr(i+len/2,len/2);\\n               if(a1==a2){\\n                   \\n                   s.insert(a1);\\n               }\\n                   \\n           }\\n        }\\n        return s.size();\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1019836,
                "title": "rolling-hash-resource-link",
                "content": "[link](https://cp-algorithms.com/string/string-hashing.html)\\n```\\nclass Solution {\\npublic:\\n    \\n    int distinctEchoSubstrings(string s) {\\n        \\n    int n = s.size();\\n    const int p = 31;\\n    const int m = 1e9 + 9;\\n    vector<long long> p_pow(n);\\n    p_pow[0] = 1;\\n    for (int i = 1; i < n; i++)\\n        p_pow[i] = (p_pow[i-1] * p) % m;\\n\\n    vector<long long> h(n + 1, 0);\\n    for (int i = 0; i < n; i++)\\n        h[i+1] = (h[i] + (s[i] - \\'a\\' + 1) * p_pow[i]) % m;\\n\\n    int ans = 0;\\n    unordered_map<int,bool> mp;\\n    for(int len = 2;len<=n;len+=2){\\n        for(int i = 0;i+len-1<n;i++){\\n            int hash_l = (h[i+len/2] - h[i] + m)%m;\\n            int hash_r = (h[i+len] - h[i+len/2] + m)%m;\\n            if(hash_l*p_pow[n-i-1]%m == hash_r * p_pow[n-i-len/2-1]%m && mp[hash_l*p_pow[n-i-1]%m] == false) {\\n                ans++;\\n                mp[hash_l*p_pow[n-i-1]%m] = true;\\n            }\\n        }\\n    }\\n        \\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int distinctEchoSubstrings(string s) {\\n        \\n    int n = s.size();\\n    const int p = 31;\\n    const int m = 1e9 + 9;\\n    vector<long long> p_pow(n);\\n    p_pow[0] = 1;\\n    for (int i = 1; i < n; i++)\\n        p_pow[i] = (p_pow[i-1] * p) % m;\\n\\n    vector<long long> h(n + 1, 0);\\n    for (int i = 0; i < n; i++)\\n        h[i+1] = (h[i] + (s[i] - \\'a\\' + 1) * p_pow[i]) % m;\\n\\n    int ans = 0;\\n    unordered_map<int,bool> mp;\\n    for(int len = 2;len<=n;len+=2){\\n        for(int i = 0;i+len-1<n;i++){\\n            int hash_l = (h[i+len/2] - h[i] + m)%m;\\n            int hash_r = (h[i+len] - h[i+len/2] + m)%m;\\n            if(hash_l*p_pow[n-i-1]%m == hash_r * p_pow[n-i-len/2-1]%m && mp[hash_l*p_pow[n-i-1]%m] == false) {\\n                ans++;\\n                mp[hash_l*p_pow[n-i-1]%m] = true;\\n            }\\n        }\\n    }\\n        \\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 821378,
                "title": "java-straight-forward-solution",
                "content": "```\\nclass Solution {\\n    public int distinctEchoSubstrings(String text) {\\n        Set<String> result = new HashSet<>();\\n        for (int i = 2; i <= text.length(); i=i+2) {\\n            for (int j = 0; j < text.length() - i+1; j++) {\\n                String sub = text.substring(j, j+i);\\n                if (sub.substring(0,sub.length()/2).equals(sub.substring(sub.length()/2))) {\\n                        result.add(sub);\\n                }\\n            }\\n        }\\n        return result.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int distinctEchoSubstrings(String text) {\\n        Set<String> result = new HashSet<>();\\n        for (int i = 2; i <= text.length(); i=i+2) {\\n            for (int j = 0; j < text.length() - i+1; j++) {\\n                String sub = text.substring(j, j+i);\\n                if (sub.substring(0,sub.length()/2).equals(sub.substring(sub.length()/2))) {\\n                        result.add(sub);\\n                }\\n            }\\n        }\\n        return result.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 479264,
                "title": "python-204ms-simple-solution-with-explanations",
                "content": "**Improvements** over brute force solution. \\n* For every character, we only need to check previous occurences of itself\\n* Input like `\"a\"*2000` leads to O(n^3), so we handle them seperately in O(1) time.\\n\\n```\\nfrom collections import defaultdict, deque\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        if all(x==text[0] for x in text):\\n            # handle worst case seperately\\n            return len(text)//2\\n        \\n        res = set()\\n        character_locations = defaultdict(lambda:deque())\\n        for i, c in enumerate(text):\\n            for j in character_locations[c]:\\n                if i + (i - j) > len(text): break\\n                    \\n                # Use startswith to improve result slightly                    \\n                if text.startswith(text[i:i+i-j], j):\\n                    res.add(text[j:i+i-j])\\n                    \\n            character_locations[c].appendleft(i)\\n            \\n        return len(res)\\n        # AC: 204 ms\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import defaultdict, deque\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        if all(x==text[0] for x in text):\\n            # handle worst case seperately\\n            return len(text)//2\\n        \\n        res = set()\\n        character_locations = defaultdict(lambda:deque())\\n        for i, c in enumerate(text):\\n            for j in character_locations[c]:\\n                if i + (i - j) > len(text): break\\n                    \\n                # Use startswith to improve result slightly                    \\n                if text.startswith(text[i:i+i-j], j):\\n                    res.add(text[j:i+i-j])\\n                    \\n            character_locations[c].appendleft(i)\\n            \\n        return len(res)\\n        # AC: 204 ms\\n```",
                "codeTag": "Java"
            },
            {
                "id": 478340,
                "title": "c-dp-rolling-hash-solution",
                "content": "Steps:\\n1.  Two contiguous equal string have this form \"abcabc\", so if you know text[i] == text[j] then probably you are at the end of two contiguos equal sequences. Let l = j - i, this will be the length of the equal strings, so to check if the condition hold you have to check if text[i - l + 1, i] == text[j - l + 1, j], this is a O(n)  linear check, so we will get TLE because your overall time is (n^3) just checking contiguous equal strings. The insight here is: if text[i - l + 1, i] == text[j - l + 1, j] then text[i] == text[j] && text[i - 1] == text[j - 1] &&  text[i - 2] == text[j - 2] ...  text[i - l + 1] == text[j - l + 1], having this info stored you can just check if mem[i, j] == j - i in O(1), but you can have the following case \"abcabcabc\", so position mem[6, 9] = 6 not 3 as we expected, this is because mem[i, j] has all the info of previous suffixs, so the right condition to check if text[i - l + 1, i] == text[j - l + 1, j] is mem[i, j] >= j - i.\\n2.   Now you have to check the number of differents contiguous strings, inserting text.Substring(i + 1, j - i) into a HashSet every time you have mem[i, j] >= j - i will give you the number of different substrings, unfortunately this will end in tle, because text.Substring method is O(l) be l the substring length, so we will end with a O(n^3) algorithm, to tackle this problem we can use Rolling Hash [https://stackoverflow.com/questions/711770/fast-implementation-of-rolling-hash](http://), this will allow to get rid off the substring method, so our algorithm will end up with a overall time of O(n^2).\\n\\n```\\npublic class Solution {\\n    \\n    const long PRIME_BASE = 29;\\n    const long PRIME_MOD = 1000000007;\\n    \\n    public int DistinctEchoSubstrings(string text) {\\n        int n = text.Length;\\n        int[,] mem = new int[n + 1, n + 1];\\n        for(int i = 1; i < n; ++i)\\n            for(int j = i + 1; j <= n; ++j)\\n                mem[i, j] = text[i - 1] == text[j - 1] ? 1 + mem[i - 1, j - 1] : 0;\\n        \\n        int md = n / 2;\\n        HashSet<long> st = new HashSet<long>();\\n    \\n        long power = 1;\\n        for(int i = 1; i <= md; ++i)\\n        {\\n            long hs = 0;\\n            power = (power * PRIME_BASE) % PRIME_MOD;\\n            for(int j = 1; j <= n; ++j)\\n            {\\n                hs = (hs * PRIME_BASE + text[j - 1] - \\'a\\' + 1) % PRIME_MOD;\\n                \\n                if(j > i)\\n                    hs -= power * (text[j - i - 1] - \\'a\\' + 1) % PRIME_MOD;\\n                \\n                if(hs < 0)\\n                    hs += PRIME_MOD;    \\n                \\n                if(j - i >= 1 && mem[j - i, j] >= i)\\n                    st.Add(hs);\\n            }       \\n        }\\n                    \\n        return st.Count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\npublic class Solution {\\n    \\n    const long PRIME_BASE = 29;\\n    const long PRIME_MOD = 1000000007;\\n    \\n    public int DistinctEchoSubstrings(string text) {\\n        int n = text.Length;\\n        int[,] mem = new int[n + 1, n + 1];\\n        for(int i = 1; i < n; ++i)\\n            for(int j = i + 1; j <= n; ++j)\\n                mem[i, j] = text[i - 1] == text[j - 1] ? 1 + mem[i - 1, j - 1] : 0;\\n        \\n        int md = n / 2;\\n        HashSet<long> st = new HashSet<long>();\\n    \\n        long power = 1;\\n        for(int i = 1; i <= md; ++i)\\n        {\\n            long hs = 0;\\n            power = (power * PRIME_BASE) % PRIME_MOD;\\n            for(int j = 1; j <= n; ++j)\\n            {\\n                hs = (hs * PRIME_BASE + text[j - 1] - \\'a\\' + 1) % PRIME_MOD;\\n                \\n                if(j > i)\\n                    hs -= power * (text[j - i - 1] - \\'a\\' + 1) % PRIME_MOD;\\n                \\n                if(hs < 0)\\n                    hs += PRIME_MOD;    \\n                \\n                if(j - i >= 1 && mem[j - i, j] >= i)\\n                    st.Add(hs);\\n            }       \\n        }\\n                    \\n        return st.Count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477418,
                "title": "sha1",
                "content": "Here I use SHA1 hashes. It\\'s O(n<sup>2</sup>) but still horribly slow (accepted in 4164 ms), but maybe still interesting.\\n\\n* First I build hashers for all one-character substrings. Each `hasher[i]` will hash the substrings starting at index `i`.\\n* Then in the loop I compute the digests and use them to find the good substrings (those that are a concatenation of some string with itself). For example for input=\"abcabcabc\" and when I\\'m at length=3, my `hasher[1]` will have hashed `text[1:1+3]`=\"bca\" and my `hasher[4]` will have hashed `text[4:4+3]`=\"bca\". So they have the same digest and I store that digest in a set.\\n* Then pop the last hasher, it\\'s not needed anymore because it has already hashed until the end of the string.\\n* Then update each hasher with their next character for the next higher length.\\n* In the end, return how many different good digests were found.\\n```\\ndef distinctEchoSubstrings(self, text):\\n    import hashlib\\n    hashers = map(hashlib.sha1, text)\\n    good_digests = set()\\n    for length in range(1, len(text) / 2 + 1):\\n        digests = [h.digest() for h in hashers]\\n        for d1, d2 in zip(digests, digests[length:]):\\n            if d1 == d2:\\n                good_digests.add(d1)\\n        hashers.pop()\\n        for hasher, char in zip(hashers, text[length:]):\\n            hasher.update(char)\\n    return len(good_digests)\\n```",
                "solutionTags": [],
                "code": "```\\ndef distinctEchoSubstrings(self, text):\\n    import hashlib\\n    hashers = map(hashlib.sha1, text)\\n    good_digests = set()\\n    for length in range(1, len(text) / 2 + 1):\\n        digests = [h.digest() for h in hashers]\\n        for d1, d2 in zip(digests, digests[length:]):\\n            if d1 == d2:\\n                good_digests.add(d1)\\n        hashers.pop()\\n        for hasher, char in zip(hashers, text[length:]):\\n            hasher.update(char)\\n    return len(good_digests)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 477091,
                "title": "java-hash-set-brute-force",
                "content": "Slightly better than n^3 on average I think\\n```\\n    public static int distinctEchoSubstrings(String text) {\\n        final Set<String> found = new HashSet<>();\\n        final char[] chars = text.toCharArray();\\n        for (int i = 0; i < chars.length; i++) {\\n            for (int j = i + 1; j < text.length(); j++) {\\n                if (chars[i] == chars[j]) {\\n                    if (j + j - i <= text.length()) {\\n                        final String first = text.substring(i, j);\\n                        final String second = text.substring(j, j + j - i);\\n                        if (first.equals(second)) {\\n                            found.add(first + second);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return found.size();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public static int distinctEchoSubstrings(String text) {\\n        final Set<String> found = new HashSet<>();\\n        final char[] chars = text.toCharArray();\\n        for (int i = 0; i < chars.length; i++) {\\n            for (int j = i + 1; j < text.length(); j++) {\\n                if (chars[i] == chars[j]) {\\n                    if (j + j - i <= text.length()) {\\n                        final String first = text.substring(i, j);\\n                        final String second = text.substring(j, j + j - i);\\n                        if (first.equals(second)) {\\n                            found.add(first + second);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return found.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2252342,
                "title": "c-rolling-hash-solution-time-o-n-2-n-log-n-space-o-n-2",
                "content": "```\\nclass Solution {\\npublic:\\n    long long base = 31 , mod = 1011001110001111;\\n    long long prev[2001];\\n    unordered_map<long long,int> mp;\\n    int distinctEchoSubstrings(string s) {\\n         int n = s.size();\\n         for(int i=1; i<=n/2; i++) {\\n               long long hash = 0 , limit = 1;\\n               int l = 0;\\n               for(int k=0; k<n; k++) {\\n                     hash = (( hash * base ) % mod  + (s[k] - \\'a\\' + 1))%mod;\\n                     if(k>=i-1) {\\n                         prev[k]=hash;\\n                         if(k >= 2*i - 1 && prev[k-i]==hash) {\\n                              mp[hash]++;\\n                         }\\n                         hash = (hash - ((s[l] - \\'a\\' + 1)*limit)%mod)%mod;\\n                         if(hash<0) hash+=mod;\\n                         l++;\\n                     }else {\\n                         limit =( limit * base ) % mod;\\n                     }\\n               }\\n         }\\n        return mp.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "String",
                    "Sliding Window",
                    "Rolling Hash"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long base = 31 , mod = 1011001110001111;\\n    long long prev[2001];\\n    unordered_map<long long,int> mp;\\n    int distinctEchoSubstrings(string s) {\\n         int n = s.size();\\n         for(int i=1; i<=n/2; i++) {\\n               long long hash = 0 , limit = 1;\\n               int l = 0;\\n               for(int k=0; k<n; k++) {\\n                     hash = (( hash * base ) % mod  + (s[k] - \\'a\\' + 1))%mod;\\n                     if(k>=i-1) {\\n                         prev[k]=hash;\\n                         if(k >= 2*i - 1 && prev[k-i]==hash) {\\n                              mp[hash]++;\\n                         }\\n                         hash = (hash - ((s[l] - \\'a\\' + 1)*limit)%mod)%mod;\\n                         if(hash<0) hash+=mod;\\n                         l++;\\n                     }else {\\n                         limit =( limit * base ) % mod;\\n                     }\\n               }\\n         }\\n        return mp.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2029758,
                "title": "c-kmp-o-n-2",
                "content": "**Idea** from Problem: [459. Repeated Substring Pattern](https://leetcode.com/problems/repeated-substring-pattern/).\\nIf a `s` string is made from another string `t`, such that `s` is formed by concatenating `t` by even no. of times, then we can spilt `s` into 2 equal halves. Try to generate all substring, check the validity of substring and store into MAP.\\n```\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string s) {\\n        unordered_map<string,int> mp;\\n        for(int i = 0; i<s.size();++i){\\n            string re;\\n            vector<int> nums = {0}; int l = 0;\\n            for(int j = i+1; j<s.size();++j){\\n                re+=string(1,s[j]);\\n                while(l>0 && s[i+l]!=s[j])  l = nums[l-1];\\n                if(s[l+i]==s[j]) {nums.push_back(l+1); l++;}\\n                else nums.push_back(0);\\n                int p = j-i+1 - nums[nums.size()-1];\\n                if((j-i)%2!=0 && (p && (j-i+1)%p==0 && ((j-i+1)/p)%2==0)) mp[re]++; \\n            }\\n        }\\n        return mp.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string s) {\\n        unordered_map<string,int> mp;\\n        for(int i = 0; i<s.size();++i){\\n            string re;\\n            vector<int> nums = {0}; int l = 0;\\n            for(int j = i+1; j<s.size();++j){\\n                re+=string(1,s[j]);\\n                while(l>0 && s[i+l]!=s[j])  l = nums[l-1];\\n                if(s[l+i]==s[j]) {nums.push_back(l+1); l++;}\\n                else nums.push_back(0);\\n                int p = j-i+1 - nums[nums.size()-1];\\n                if((j-i)%2!=0 && (p && (j-i+1)%p==0 && ((j-i+1)/p)%2==0)) mp[re]++; \\n            }\\n        }\\n        return mp.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1627969,
                "title": "c-hash-solution-clean-code-easy-understand",
                "content": "\\tusing ll = long long;\\n\\tconst int MOD = 1e9 + 7;\\n\\tconst int base = 131;\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint p[2005];\\n\\t\\tint hash[2005];\\n\\n\\t\\tint get(int l, int r){\\n\\t\\t\\treturn (hash[r] - 1LL * hash[l] * p[r-l] % MOD + MOD) % MOD;\\n\\t\\t}\\n\\t\\tint distinctEchoSubstrings(string s) {\\n\\t\\t\\tint n = s.length();\\n\\t\\t\\tp[0] = 1;\\n\\t\\t\\thash[0] = 0;\\n\\t\\t\\tfor (int i = 1; i <= n; i++){\\n\\t\\t\\t\\thash[i] = (1LL * hash[i-1] * base + s[i-1] - \\'a\\' + 1) % MOD;\\n\\t\\t\\t\\tp[i] = (1LL * p[i-1] * base) % MOD;\\n\\t\\t\\t}\\n\\t\\t\\t//for (int i = 1; i <= n; i++) cout << hash[i] << \" \";\\n\\t\\t\\tunordered_set<int> st;\\n\\t\\t\\tfor (int i = 0; i < n; i++){\\n\\t\\t\\t\\tfor (int l = 2; i + l <= n; l += 2){\\n\\t\\t\\t\\t\\tint mid = i + l / 2;\\n\\t\\t\\t\\t\\tint a = get(i, mid);\\n\\t\\t\\t\\t\\tint b = get(mid, i + l);\\n\\t\\t\\t\\t\\t//cout << a << \" \" << b << endl;\\n\\t\\t\\t\\t\\tif (a == b) st.insert(a);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn st.size();\\n\\t\\t}\\n\\t};\\n\\n**Complexity**\\n* Time: O(n ^ 2) - n is length of string s;\\n* Space: O(n)",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint p[2005];\\n\\t\\tint hash[2005];\\n\\n\\t\\tint get(int l, int r){\\n\\t\\t\\treturn (hash[r] - 1LL * hash[l] * p[r-l] % MOD + MOD) % MOD;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1278602,
                "title": "java-rolling-hash",
                "content": "```\\nclass Solution {\\n    int count = 0;\\n    int p = 31;\\n    int mod = (int) (1e9+9);\\n    Set<String> set = new HashSet();\\n    public int distinctEchoSubstrings(String text) {\\n        if(text == null || text.isEmpty())\\n            return 0;\\n        for (int len = 1; 2* len <= text.length(); len ++){\\n            count += getEchoSubstring(text, len);\\n        }\\n        return count;\\n    }\\n\\n\\n    private int getEchoSubstring(String str, int len){\\n\\n        int i = 0,j = i+ len;\\n        long power1 = 1, power2 = 1;\\n        long hashVal1 = 0, hashval2 = 0;\\n        Map<Integer, Long> map1 = new HashMap();\\n        Map<Integer, Long> map2 = new HashMap();\\n        int count = 0;\\n\\n        for (; j < str.length(); i++, j++){\\n            if(i >= len){\\n                hashVal1 = (hashVal1 - (str.charAt(i-len)-\\'a\\') * map1.get(i-len)) % mod;\\n                hashval2 = (hashval2 - (str.charAt(j-len)-\\'a\\') * map2.get(j-len)) % mod;\\n            }\\n\\n            map1.put(i, power1);\\n            map2.put(j, power2);\\n            hashVal1 = (hashVal1 + ((str.charAt(i)-\\'a\\'+1) * power1)) % mod;\\n            hashval2 = (hashval2 + ((str.charAt(j)-\\'a\\'+1) * power2)) % mod;\\n            power1 = (power1 * p) % mod;\\n            power2 = (power2 * p) % mod;\\n\\n            if(i >= len-1){\\n                if(hashVal1 == hashval2){\\n                    String ans = str.substring(i+1-len, i+1);\\n                    System.out.println(ans);\\n                    if(!set.contains(ans)){\\n                        set.add(ans);\\n                        ++count;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int count = 0;\\n    int p = 31;\\n    int mod = (int) (1e9+9);\\n    Set<String> set = new HashSet();\\n    public int distinctEchoSubstrings(String text) {\\n        if(text == null || text.isEmpty())\\n            return 0;\\n        for (int len = 1; 2* len <= text.length(); len ++){\\n            count += getEchoSubstring(text, len);\\n        }\\n        return count;\\n    }\\n\\n\\n    private int getEchoSubstring(String str, int len){\\n\\n        int i = 0,j = i+ len;\\n        long power1 = 1, power2 = 1;\\n        long hashVal1 = 0, hashval2 = 0;\\n        Map<Integer, Long> map1 = new HashMap();\\n        Map<Integer, Long> map2 = new HashMap();\\n        int count = 0;\\n\\n        for (; j < str.length(); i++, j++){\\n            if(i >= len){\\n                hashVal1 = (hashVal1 - (str.charAt(i-len)-\\'a\\') * map1.get(i-len)) % mod;\\n                hashval2 = (hashval2 - (str.charAt(j-len)-\\'a\\') * map2.get(j-len)) % mod;\\n            }\\n\\n            map1.put(i, power1);\\n            map2.put(j, power2);\\n            hashVal1 = (hashVal1 + ((str.charAt(i)-\\'a\\'+1) * power1)) % mod;\\n            hashval2 = (hashval2 + ((str.charAt(j)-\\'a\\'+1) * power2)) % mod;\\n            power1 = (power1 * p) % mod;\\n            power2 = (power2 * p) % mod;\\n\\n            if(i >= len-1){\\n                if(hashVal1 == hashval2){\\n                    String ans = str.substring(i+1-len, i+1);\\n                    System.out.println(ans);\\n                    if(!set.contains(ans)){\\n                        set.add(ans);\\n                        ++count;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1161604,
                "title": "using-kmp-a-bit-overkill-though",
                "content": "```\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        \\n       int n=text.size(),cnt=0;\\n        \\n        if(n==0)return 0;\\n        \\n        //for hashing\\n        long long hash=0,t=31,pw=1,mod=1e9+7;\\n        unordered_map<int,int>m;\\n        \\n        for(int i=0;i<n;i++)\\n        {   \\n            vector<int>pi(n,i);//prefix array for kmp\\n            pw=1;//resetting pw\\n            hash=text[i]-\\'a\\'+1;//hash\\n            pw=(pw*t)%mod;//hash\\n            for(int j=i+1;j<n;j++)\\n            {      \\n                \\n                int c=text[j]-\\'a\\'+1;//hash\\n                hash=(pw*c%mod+hash)%mod;//hash\\n                pw=(pw*t)%mod;//hash\\n                \\n                //running kmp prefix function\\n                \\n                int p=pi[j-1];\\n                while(p>i&&text[j]!=text[p])\\n                    p=pi[p-1];\\n                if(text[j]==text[p])\\n                    p++;\\n                pi[j]=p;\\n                \\n                \\n                int u=pi[j]-i;//resetting size as i>0\\n                \\n                if((j-i+1)%2==0&&u&&m[hash]==0)\\n                {\\n                    int k=(j-i+1)/2;\\n                    if(k%(j-i+1-u)==0){\\n                        m[hash]++;\\n                        cnt++;\\n                    }\\n                }\\n            }\\n        }\\n        return cnt++;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        \\n       int n=text.size(),cnt=0;\\n        \\n        if(n==0)return 0;\\n        \\n        //for hashing\\n        long long hash=0,t=31,pw=1,mod=1e9+7;\\n        unordered_map<int,int>m;\\n        \\n        for(int i=0;i<n;i++)\\n        {   \\n            vector<int>pi(n,i);//prefix array for kmp\\n            pw=1;//resetting pw\\n            hash=text[i]-\\'a\\'+1;//hash\\n            pw=(pw*t)%mod;//hash\\n            for(int j=i+1;j<n;j++)\\n            {      \\n                \\n                int c=text[j]-\\'a\\'+1;//hash\\n                hash=(pw*c%mod+hash)%mod;//hash\\n                pw=(pw*t)%mod;//hash\\n                \\n                //running kmp prefix function\\n                \\n                int p=pi[j-1];\\n                while(p>i&&text[j]!=text[p])\\n                    p=pi[p-1];\\n                if(text[j]==text[p])\\n                    p++;\\n                pi[j]=p;\\n                \\n                \\n                int u=pi[j]-i;//resetting size as i>0\\n                \\n                if((j-i+1)%2==0&&u&&m[hash]==0)\\n                {\\n                    int k=(j-i+1)/2;\\n                    if(k%(j-i+1-u)==0){\\n                        m[hash]++;\\n                        cnt++;\\n                    }\\n                }\\n            }\\n        }\\n        return cnt++;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 941313,
                "title": "java-o-n-2-time-o-n-space-constant-solution",
                "content": "```\\nclass Solution {\\n    //constant(n) window size scan. use hashmap to map what the next substring should be. clear map after each iteration. O(n) space and O(n^2) time\\n    \\n    public int distinctEchoSubstrings(String text) {\\n        HashMap<Integer, String> distinctMap = new HashMap();\\n        Set<String> answers = new HashSet();\\n        int counter = 0;\\n        for(int n = 1; n < 1+text.length()/2; n++)\\n        {\\n            for(int i = 0; i < text.length()-n+1; i++)\\n            {\\n                String sub = text.substring(i, i+n);\\n                if(distinctMap.containsKey(i) && distinctMap.get(i).equals(sub))\\n                {\\n                    answers.add(sub);\\n                }\\n                distinctMap.put(i+n, sub);\\n            }\\n            counter += answers.size();\\n            answers.clear();\\n            distinctMap.clear();\\n        }\\n        return counter;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    //constant(n) window size scan. use hashmap to map what the next substring should be. clear map after each iteration. O(n) space and O(n^2) time\\n    \\n    public int distinctEchoSubstrings(String text) {\\n        HashMap<Integer, String> distinctMap = new HashMap();\\n        Set<String> answers = new HashSet();\\n        int counter = 0;\\n        for(int n = 1; n < 1+text.length()/2; n++)\\n        {\\n            for(int i = 0; i < text.length()-n+1; i++)\\n            {\\n                String sub = text.substring(i, i+n);\\n                if(distinctMap.containsKey(i) && distinctMap.get(i).equals(sub))\\n                {\\n                    answers.add(sub);\\n                }\\n                distinctMap.put(i+n, sub);\\n            }\\n            counter += answers.size();\\n            answers.clear();\\n            distinctMap.clear();\\n        }\\n        return counter;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 790851,
                "title": "cpp14-solution-using-hashing",
                "content": "```\\n#include<bits/stdc++.h>\\nusing namespace std;\\ntypedef long long ll;\\nconst ll p = 31;\\nconst ll mod = 1e9 + 7 ;\\nconst ll maxx = 2005;\\nll has[maxx] , mmi[maxx] ;\\n\\nll exp(ll x , ll y)\\n{\\n    if(y == 0) return 1;\\n    if(y == 1) return x % mod ;\\n    ll t = exp(x , y/2) % mod;\\n    if(y & 1) {\\n        return ((x%mod) * (((t % mod) * (t%mod))%mod))%mod;\\n    }\\n    else return ((t % mod) * (t % mod))%mod;\\n}\\n\\nll findhash(ll i , ll j)\\n{\\n    if(i == 0){\\n        ll foo = has[j] % mod ;\\n        return foo ;\\n    }\\n    else {\\n        ll res = has[j] - has[i-1] ;\\n        res%= mod ;\\n        res*=mmi[i];\\n        res%=mod;\\n        return res;\\n    }\\n}\\n\\n\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        string s = \"\" ; \\n        s = text; \\n        ll n = s.length() ;\\n    has[0] = s[0] - \\'a\\' + 1;\\n    ll power = p;\\n    for(ll i = 1 ; i < n ; ++i){\\n        ll foo = s[i] - \\'a\\' + 1;\\n        foo = foo * power;\\n        foo = foo % mod;\\n        power = power * p;\\n        power = power % mod ;\\n        has[i] = has[i-1] + foo ;\\n    }\\n    for(int i = 0 ; i < n ; ++i){\\n        ll a = exp(p,i) % mod ;\\n        ll foo = exp(a , mod - 2) % mod ;\\n        mmi[i] = foo ;\\n    }\\n    ll count = 0 ;\\n    unordered_map<ll,ll> occured;\\n    occured.clear();\\n    for(ll i = 0 ; i < n ; ++i){\\n        for(ll j = 0 ; j < i ; ++j){\\n            ll diff = i - j + 1;\\n            if(diff % 2 == 0 ) {\\n                ll from1 = j , to1 = j + (diff / 2) - 1;\\n                ll from2 = j + (diff/2) , to2 = i ;\\n                ll hash1 = findhash(from1 , to1) ;\\n                ll hash2 = findhash(from2 , to2) ;\\n                if(hash1 == hash2 and !occured[hash1]){\\n                    occured[hash1] = 1;\\n                    ++count;\\n                }\\n            }\\n        }\\n    }\\n    return count ; \\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n#include<bits/stdc++.h>\\nusing namespace std;\\ntypedef long long ll;\\nconst ll p = 31;\\nconst ll mod = 1e9 + 7 ;\\nconst ll maxx = 2005;\\nll has[maxx] , mmi[maxx] ;\\n\\nll exp(ll x , ll y)\\n{\\n    if(y == 0) return 1;\\n    if(y == 1) return x % mod ;\\n    ll t = exp(x , y/2) % mod;\\n    if(y & 1) {\\n        return ((x%mod) * (((t % mod) * (t%mod))%mod))%mod;\\n    }\\n    else return ((t % mod) * (t % mod))%mod;\\n}\\n\\nll findhash(ll i , ll j)\\n{\\n    if(i == 0){\\n        ll foo = has[j] % mod ;\\n        return foo ;\\n    }\\n    else {\\n        ll res = has[j] - has[i-1] ;\\n        res%= mod ;\\n        res*=mmi[i];\\n        res%=mod;\\n        return res;\\n    }\\n}\\n\\n\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        string s = \"\" ; \\n        s = text; \\n        ll n = s.length() ;\\n    has[0] = s[0] - \\'a\\' + 1;\\n    ll power = p;\\n    for(ll i = 1 ; i < n ; ++i){\\n        ll foo = s[i] - \\'a\\' + 1;\\n        foo = foo * power;\\n        foo = foo % mod;\\n        power = power * p;\\n        power = power % mod ;\\n        has[i] = has[i-1] + foo ;\\n    }\\n    for(int i = 0 ; i < n ; ++i){\\n        ll a = exp(p,i) % mod ;\\n        ll foo = exp(a , mod - 2) % mod ;\\n        mmi[i] = foo ;\\n    }\\n    ll count = 0 ;\\n    unordered_map<ll,ll> occured;\\n    occured.clear();\\n    for(ll i = 0 ; i < n ; ++i){\\n        for(ll j = 0 ; j < i ; ++j){\\n            ll diff = i - j + 1;\\n            if(diff % 2 == 0 ) {\\n                ll from1 = j , to1 = j + (diff / 2) - 1;\\n                ll from2 = j + (diff/2) , to2 = i ;\\n                ll hash1 = findhash(from1 , to1) ;\\n                ll hash2 = findhash(from2 , to2) ;\\n                if(hash1 == hash2 and !occured[hash1]){\\n                    occured[hash1] = 1;\\n                    ++count;\\n                }\\n            }\\n        }\\n    }\\n    return count ; \\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 752641,
                "title": "my-rolling-hash-solution-in-c",
                "content": "```\\nusing ll=long long int;\\nconst ll mod=1000000009;\\nclass Solution {\\npublic:\\n    ll sum(ll a,ll b)\\n    {\\n        return ((a%mod)+(b%mod))%mod;\\n    }\\n    ll mul(ll a,ll b)\\n    {\\n        return (((a%mod)*(b%mod))%mod);\\n    }\\n    ll sub(ll a,ll b)\\n    {\\n        return (((a%mod)-(b%mod))+mod)%mod;\\n    }\\ninline ll power(ll n,ll x){ll p=1;while(x!=0){if(x%2==0){n=mul(n,n);x=x/2;}p=mul(p,n);x--;}return p;}\\n    ll checkhash(int st,int en)\\n    {\\n        ll a1=sub(hash[en],hash[st-1]);\\n        a1=mul(a1,inv[st-1]);\\n        a1=a1%mod;\\n        return a1;\\n    }\\n    ll p=31;\\n    ll hash[2005];\\n    int po[2005];\\n    int inv[2005];\\n    int distinctEchoSubstrings(string text) {\\n        ll k=1;\\n        po[0]=1;\\n        inv[0]=power(po[0],mod-2);\\n        for(int i=1;i<=2001;i++)\\n        {\\n            k=mul(k,p);\\n            po[i]=k;\\n            inv[i]=power(po[i],mod-2);\\n        } \\n        hash[0]=0;\\n        ll z=1;\\n        int n=text.length();\\n    for(int i=1;i<=n;i++)\\n    {\\n        hash[i]=sum(hash[i-1],mul((text[i-1]-\\'a\\')+1,z));\\n        z=mul(z,p);\\n    }\\n        int ans=0;\\n        unordered_map<ll,ll>mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j+=2)\\n            {\\n                ll h1=checkhash(i+1,(j+i)/2+1);\\n                ll h2=checkhash((j+i)/2+2,j+1);\\n                if(h1==h2 && mp[h1]==0)\\n                {\\n                    ans++;\\n                    mp[h1]=1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nusing ll=long long int;\\nconst ll mod=1000000009;\\nclass Solution {\\npublic:\\n    ll sum(ll a,ll b)\\n    {\\n        return ((a%mod)+(b%mod))%mod;\\n    }\\n    ll mul(ll a,ll b)\\n    {\\n        return (((a%mod)*(b%mod))%mod);\\n    }\\n    ll sub(ll a,ll b)\\n    {\\n        return (((a%mod)-(b%mod))+mod)%mod;\\n    }\\ninline ll power(ll n,ll x){ll p=1;while(x!=0){if(x%2==0){n=mul(n,n);x=x/2;}p=mul(p,n);x--;}return p;}\\n    ll checkhash(int st,int en)\\n    {\\n        ll a1=sub(hash[en],hash[st-1]);\\n        a1=mul(a1,inv[st-1]);\\n        a1=a1%mod;\\n        return a1;\\n    }\\n    ll p=31;\\n    ll hash[2005];\\n    int po[2005];\\n    int inv[2005];\\n    int distinctEchoSubstrings(string text) {\\n        ll k=1;\\n        po[0]=1;\\n        inv[0]=power(po[0],mod-2);\\n        for(int i=1;i<=2001;i++)\\n        {\\n            k=mul(k,p);\\n            po[i]=k;\\n            inv[i]=power(po[i],mod-2);\\n        } \\n        hash[0]=0;\\n        ll z=1;\\n        int n=text.length();\\n    for(int i=1;i<=n;i++)\\n    {\\n        hash[i]=sum(hash[i-1],mul((text[i-1]-\\'a\\')+1,z));\\n        z=mul(z,p);\\n    }\\n        int ans=0;\\n        unordered_map<ll,ll>mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j+=2)\\n            {\\n                ll h1=checkhash(i+1,(j+i)/2+1);\\n                ll h2=checkhash((j+i)/2+2,j+1);\\n                if(h1==h2 && mp[h1]==0)\\n                {\\n                    ans++;\\n                    mp[h1]=1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 688691,
                "title": "python3-rolling-hash",
                "content": "How to calculate hash with rare probability of collision -\\nThere are multiple ways to do so, but I have used simplest one ->\\n\\nFor string ab ->\\nWe have \\na=> 0 * 128 + ord(\"a\") => 0 * 128 + 97 => 97\\nab => ans of a * 128 + ord(\"b\") => 97 * 128 + 98 => 12514\\nAs this number can become very large we can use a large prime to take modulo, I have taken 10^9 + 7. \\nThe reason I have chose 128 as multiplier is for the fact that the total ascii values can be 128. But we can choose other numbers as well.\\nThere are chances that these hashes can collide, but the chances of that are rare and doesn\\'t occur in the problem.\\n```\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        mod = 1_000_000_007\\n        # Dict for storing hashes for all substrings\\n        hashed = {}\\n        for i in range(len(text)):\\n            sm = 0\\n            for j in range(i, len(text)):\\n                sm = (sm*128 + ord(text[j]))%mod\\n                hashed[(i, j)] = sm\\n        \\n        ans = 0\\n        st = {}\\n        for i in range(len(text)):\\n            for j in range(i+1, len(text), 2):\\n                # For each even length substring check if hash of first half\\n                # matches the hash of second half\\n                # Also check if the full string already exists as stored map\\n                if hashed[(i, i-1+(j + 1 - i)//2)] == hashed[(i+(j + 1 - i)//2, j)]:\\n                    if hashed[(i, j)] not in st:\\n                        ans += 1\\n                        st[hashed[(i,j)]] = 1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        mod = 1_000_000_007\\n        # Dict for storing hashes for all substrings\\n        hashed = {}\\n        for i in range(len(text)):\\n            sm = 0\\n            for j in range(i, len(text)):\\n                sm = (sm*128 + ord(text[j]))%mod\\n                hashed[(i, j)] = sm\\n        \\n        ans = 0\\n        st = {}\\n        for i in range(len(text)):\\n            for j in range(i+1, len(text), 2):\\n                # For each even length substring check if hash of first half\\n                # matches the hash of second half\\n                # Also check if the full string already exists as stored map\\n                if hashed[(i, i-1+(j + 1 - i)//2)] == hashed[(i+(j + 1 - i)//2, j)]:\\n                    if hashed[(i, j)] not in st:\\n                        ans += 1\\n                        st[hashed[(i,j)]] = 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 541627,
                "title": "c-beginner-friendly-rolling-hash",
                "content": "```\\n#define mod (long)(1e9+7)\\n\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        int n = text.size();\\n        long hash[n][n];\\n        \\n        unordered_map<long,int>mp;\\n        for(int i=0;i<n;i++){\\n            long pow = 117;\\n            hash[i][i] = pow*(text[i]-\\'a\\' + 1);\\n            for(int j=i+1;j<n;j++){\\n                pow = pow*117;\\n                pow %= mod;\\n                \\n                long ch = text[j]-\\'a\\'+1;\\n                \\n                hash[i][j] = hash[i][j-1] + pow*ch;\\n                hash[i][j] %= mod;\\n            }\\n        }\\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            for(int j=i;j<n;j++){\\n                int len = j-i+1;\\n                \\n                if(j+len >=n)\\n                    continue;\\n                \\n                if(hash[i][j] == hash[j+1][j+len]){\\n                    if(mp[hash[i][j]] == 0)\\n                    ans++;\\n                    \\n                    mp[hash[i][j]] = 1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        int n = text.size();\\n        long hash[n][n];\\n        \\n        unordered_map<long,int>mp;\\n        for(int i=0;i<n;i++){\\n            long pow = 117;\\n            hash[i][i] = pow*(text[i]-\\'a\\' + 1);\\n            for(int j=i+1;j<n;j++){\\n                pow = pow*117;\\n                pow %= mod;\\n                \\n                long ch = text[j]-\\'a\\'+1;\\n                \\n                hash[i][j] = hash[i][j-1] + pow*ch;\\n                hash[i][j] %= mod;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 538841,
                "title": "c-rolling-hash-solution",
                "content": "```\\n    int distinctEchoSubstrings(string txt) {\\n        long mod = 1e10 + 7, d = 26, base = 1;\\n        \\n        auto getCode = [](char c) {\\n            return c-\\'a\\'+1;\\n        };\\n        \\n        auto getHash = [&](string & s, int l, int h) {\\n            long res = 0;\\n            for(int i = l; i <= h; i++) res = (res*d + getCode(s[i]))%mod;\\n            return res;\\n        };\\n        \\n        auto updateHash = [&](long h, char pre, char cur) {\\n            return ((h*d-getCode(pre)*base)%mod + mod + getCode(cur))%mod;\\n        };\\n        \\n        \\n        unordered_set<int> res;\\n        for(int l = 1; l + l <= txt.length(); l++) {\\n            base *= 26, base %= mod;\\n            \\n            int idx = 0;\\n            long h1 = getHash(txt, idx, idx + l-1);\\n            long h2 = getHash(txt, idx + l, idx + l+ l-1);\\n            if(h1 == h2 && !res.count(h1)) res.insert(h1);\\n            \\n            while(idx + l + l < txt.length()) {\\n                h1 = updateHash(h1, txt[idx], txt[idx+l]);\\n                h2 = updateHash(h2, txt[idx+l], txt[idx+l+l]);\\n                if(h1 == h2 && !res.count(h1)) res.insert(h1);\\n                idx++;\\n            }\\n        }\\n        return res.size();\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    int distinctEchoSubstrings(string txt) {\\n        long mod = 1e10 + 7, d = 26, base = 1;\\n        \\n        auto getCode = [](char c) {\\n            return c-\\'a\\'+1;\\n        };\\n        \\n        auto getHash = [&](string & s, int l, int h) {\\n            long res = 0;\\n            for(int i = l; i <= h; i++) res = (res*d + getCode(s[i]))%mod;\\n            return res;\\n        };\\n        \\n        auto updateHash = [&](long h, char pre, char cur) {\\n            return ((h*d-getCode(pre)*base)%mod + mod + getCode(cur))%mod;\\n        };\\n        \\n        \\n        unordered_set<int> res;\\n        for(int l = 1; l + l <= txt.length(); l++) {\\n            base *= 26, base %= mod;\\n            \\n            int idx = 0;\\n            long h1 = getHash(txt, idx, idx + l-1);\\n            long h2 = getHash(txt, idx + l, idx + l+ l-1);\\n            if(h1 == h2 && !res.count(h1)) res.insert(h1);\\n            \\n            while(idx + l + l < txt.length()) {\\n                h1 = updateHash(h1, txt[idx], txt[idx+l]);\\n                h2 = updateHash(h2, txt[idx+l], txt[idx+l+l]);\\n                if(h1 == h2 && !res.count(h1)) res.insert(h1);\\n                idx++;\\n            }\\n        }\\n        return res.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 483328,
                "title": "python-one-line-code",
                "content": "```\\nimport re\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        return len(set(re.findall(r\\'(?=([a-z]+)\\\\1)\\', text)))\\n```",
                "solutionTags": [],
                "code": "```\\nimport re\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        return len(set(re.findall(r\\'(?=([a-z]+)\\\\1)\\', text)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 478435,
                "title": "o-n-2-slide-window-java-solution",
                "content": "```\\nclass Solution {\\n    public int distinctEchoSubstrings(String text) {\\n        int len = text.length(), result = 0;\\n        char[] s = text.toCharArray();\\n        HashSet<String> set = new HashSet<>();\\n        \\n        // Echo String echo = A + A\\n        for (int w = 1; w <= len / 2; w++) {    // w is A\\'s length\\n            int start1 = 0, start2 = w, end1 = 0, end2 = w;\\n            StringBuilder sb = new StringBuilder(); // store current A\\n            while (end2 < len) {\\n                sb.append(s[end2]);\\n                if (s[end2] == s[end1]) {\\n                    if (end2 - start2 > w - 1) {    // move start point\\n                        start1++;\\n                        start2++;\\n                        sb.deleteCharAt(0);\\n                    }\\n                    if (end2 - start2 == w - 1 && set.add(sb.toString())) {\\n                        result++;\\n                    }\\n                } else {\\n                    start1 = end1 + 1;\\n                    start2 = end2 + 1;\\n                    sb = new StringBuilder();\\n                }\\n                \\n                end1++;\\n                end2++;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int distinctEchoSubstrings(String text) {\\n        int len = text.length(), result = 0;\\n        char[] s = text.toCharArray();\\n        HashSet<String> set = new HashSet<>();\\n        \\n        // Echo String echo = A + A\\n        for (int w = 1; w <= len / 2; w++) {    // w is A\\'s length\\n            int start1 = 0, start2 = w, end1 = 0, end2 = w;\\n            StringBuilder sb = new StringBuilder(); // store current A\\n            while (end2 < len) {\\n                sb.append(s[end2]);\\n                if (s[end2] == s[end1]) {\\n                    if (end2 - start2 > w - 1) {    // move start point\\n                        start1++;\\n                        start2++;\\n                        sb.deleteCharAt(0);\\n                    }\\n                    if (end2 - start2 == w - 1 && set.add(sb.toString())) {\\n                        result++;\\n                    }\\n                } else {\\n                    start1 = end1 + 1;\\n                    start2 = end2 + 1;\\n                    sb = new StringBuilder();\\n                }\\n                \\n                end1++;\\n                end2++;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477935,
                "title": "python-hash-1068ms",
                "content": "```python\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        res = set()\\n        ix = {}\\n        for i, c in enumerate(text):\\n            if c in ix:\\n                for j in ix[c][::-1]:\\n                    if i + i - j > len(text): break # Early stopping \\n                    if text[j:i] == text[i:i+i-j]:\\n                        res.add(text[j:i+i-j])\\n                ix[c].append(i)\\n            else:\\n                ix[c] = [i]\\n        return len(res) \\n```\\nThis is the best method I can think of, but it is still O(n^3). Any idea on improving this method is welcome. \\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        res = set()\\n        ix = {}\\n        for i, c in enumerate(text):\\n            if c in ix:\\n                for j in ix[c][::-1]:\\n                    if i + i - j > len(text): break # Early stopping \\n                    if text[j:i] == text[i:i+i-j]:\\n                        res.add(text[j:i+i-j])\\n                ix[c].append(i)\\n            else:\\n                ix[c] = [i]\\n        return len(res) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 477559,
                "title": "why-n-3-solution-tle-in-c-but-accepted-by-other-languages",
                "content": "It is not fair as a contest question.\\n\\n```\\npublic class Solution {\\n    public int DistinctEchoSubstrings(string text) {\\n        HashSet<string> set = new HashSet<string>();\\n        int n = text.Length;\\n        for (int i = 0; i < n; i++) {\\n            for (int len = 2; i + len <= n; len += 2) {\\n                int mid = i + len / 2;\\n                string subStr1 = text.Substring(i, mid-i);\\n                string subStr2 = text.Substring(mid, i + len - mid);\\n                if (subStr1.Equals(subStr2)) \\n                    set.Add(subStr1);\\n            }\\n        }\\n        return set.Count;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int DistinctEchoSubstrings(string text) {\\n        HashSet<string> set = new HashSet<string>();\\n        int n = text.Length;\\n        for (int i = 0; i < n; i++) {\\n            for (int len = 2; i + len <= n; len += 2) {\\n                int mid = i + len / 2;\\n                string subStr1 = text.Substring(i, mid-i);\\n                string subStr2 = text.Substring(mid, i + len - mid);\\n                if (subStr1.Equals(subStr2)) \\n                    set.Add(subStr1);\\n            }\\n        }\\n        return set.Count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477486,
                "title": "24ms-kmp-based-solution-c-with-pruning",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_set<string> sstr;\\n    int kmp(string& t,int l)\\n    {\\n        vector<int> f(t.length()-l,0);\\n        int len = f.size();\\n        auto s = &t[l];\\n        int pos = 0;\\n        for(int i = 1; i<len; i++)\\n        {\\n            while(pos>0&&s[i]!=s[pos]) pos = f[pos-1];\\n            if(s[i]==s[pos])        pos++;\\n            f[i] = pos;\\n            if(pos&&((i+1)%(i+1-pos)==0)){\\n                if(((i+1)/(i+1-pos))%2==0)  sstr.insert(t.substr(l,(i+1)/2));\\n            }\\n        }\\n        return (f[len-1]&&(len%(len-f[len-1])==0))?(len-f[len-1]):INT_MAX;\\n    }\\n    \\n    int distinctEchoSubstrings(string text) {\\n        int l = text.length()-1;\\n        for(int i = 0; i<=l; i++)   l = min(l,kmp(text,i));\\n        return sstr.size();\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    unordered_set<string> sstr;\\n    int kmp(string& t,int l)\\n    {\\n        vector<int> f(t.length()-l,0);\\n        int len = f.size();\\n        auto s = &t[l];\\n        int pos = 0;\\n        for(int i = 1; i<len; i++)\\n        {\\n            while(pos>0&&s[i]!=s[pos]) pos = f[pos-1];\\n            if(s[i]==s[pos])        pos++;\\n            f[i] = pos;\\n            if(pos&&((i+1)%(i+1-pos)==0)){\\n                if(((i+1)/(i+1-pos))%2==0)  sstr.insert(t.substr(l,(i+1)/2));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 477252,
                "title": "concise-rolling-hash-dp-c",
                "content": "First of all, I didn\\'t like the hardship it took me to make the soultion overcome the time limitation despite having roughly same time complexity.\\n\\n**Intuition:**\\n* Compute rolling hash of each substring. \\n* Then compare the hash of adjacent strings\\n\\t* If hashes match then compare character by character.\\n\\n**Implementation details:**\\n* Used a 2D table to store rolling hash where `Hash[i][l]` stores the rolling hash of substring starting at `i` with length `l`\\n* Compute `Hash[i][l]` from `Hash[i][l-1]` by adding current character\\n\\n**Code:**\\n```\\nint distinctEchoSubstrings(string text) {\\n\\tint N = text.size();\\n\\tint Mod = 1000000007;\\n\\tunordered_set<string> distinct;\\n\\n\\t/* Hash[i][l] = rolling hash of substring starting at i with length l */\\n\\tvector<vector<int>> Hash(N, vector<int>(N+1, 0));\\n\\n\\tfor(int l = 1; l <= N ; ++l) {\\n\\t\\tfor(int i = 0 ; i + l <= N ; ++i) {\\n\\t\\t\\t/* Build Hash[i][l] on Hash[i][l-1] and current character. */\\n\\t\\t\\tHash[i][l] = (Hash[i][l-1] + text[i + l - 1]) % Mod;\\n\\n\\t\\t\\t/* Now check if previous adjacent substring of same length matches */\\n\\t\\t\\tif(i >= l && Hash[i-l][l] == Hash[i][l]) { //Hash matches\\n\\t\\t\\t\\tstring sub = text.substr(i, l);\\n\\n\\t\\t\\t\\t/* Now check if not found and actual character by character match */\\n\\t\\t\\t\\tif(distinct.find(sub) == distinct.end() && sub == text.substr(i - l, l)) {\\n\\t\\t\\t\\t\\tdistinct.emplace(sub);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn distinct.size();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint distinctEchoSubstrings(string text) {\\n\\tint N = text.size();\\n\\tint Mod = 1000000007;\\n\\tunordered_set<string> distinct;\\n\\n\\t/* Hash[i][l] = rolling hash of substring starting at i with length l */\\n\\tvector<vector<int>> Hash(N, vector<int>(N+1, 0));\\n\\n\\tfor(int l = 1; l <= N ; ++l) {\\n\\t\\tfor(int i = 0 ; i + l <= N ; ++i) {\\n\\t\\t\\t/* Build Hash[i][l] on Hash[i][l-1] and current character. */\\n\\t\\t\\tHash[i][l] = (Hash[i][l-1] + text[i + l - 1]) % Mod;\\n\\n\\t\\t\\t/* Now check if previous adjacent substring of same length matches */\\n\\t\\t\\tif(i >= l && Hash[i-l][l] == Hash[i][l]) { //Hash matches\\n\\t\\t\\t\\tstring sub = text.substr(i, l);\\n\\n\\t\\t\\t\\t/* Now check if not found and actual character by character match */\\n\\t\\t\\t\\tif(distinct.find(sub) == distinct.end() && sub == text.substr(i - l, l)) {\\n\\t\\t\\t\\t\\tdistinct.emplace(sub);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn distinct.size();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 477137,
                "title": "another-java-solution",
                "content": "```\\nclass Solution {\\n    public int distinctEchoSubstrings(String text) {\\n        char[] word = text.toCharArray();\\n        Set<String> result = new HashSet<>();\\n        \\n        for (int L = 0; L < word.length - 1; L++) {\\n            for (int R = L + 1; R < word.length; R++) {\\n                if (isConCat(L, R, word)) {\\n                    String candidate = text.substring(L, R + 1);\\n                    result.add(candidate);\\n                }    \\n            }\\n        }\\n        return result.size();\\n    }\\n    \\n    private boolean isConCat(int l, int r, char[] word) {\\n        if ((r - l) % 2 == 0) return false;\\n        \\n        int mid = l + (r - l) / 2 + 1;\\n        \\n        while (mid <= r) {\\n            if (word[l] != word[mid]) {\\n                return false;\\n            }\\n            mid++;\\n            l++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int distinctEchoSubstrings(String text) {\\n        char[] word = text.toCharArray();\\n        Set<String> result = new HashSet<>();\\n        \\n        for (int L = 0; L < word.length - 1; L++) {\\n            for (int R = L + 1; R < word.length; R++) {\\n                if (isConCat(L, R, word)) {\\n                    String candidate = text.substring(L, R + 1);\\n                    result.add(candidate);\\n                }    \\n            }\\n        }\\n        return result.size();\\n    }\\n    \\n    private boolean isConCat(int l, int r, char[] word) {\\n        if ((r - l) % 2 == 0) return false;\\n        \\n        int mid = l + (r - l) / 2 + 1;\\n        \\n        while (mid <= r) {\\n            if (word[l] != word[mid]) {\\n                return false;\\n            }\\n            mid++;\\n            l++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477117,
                "title": "java-rolling-hash-and-tire-solutions-trie-get-tle",
                "content": "Rolling hash got passed. Worst case would be O(n ^ 3) because we need to compare two strings to prevent collision even if they have the same hashcode.\\n```\\nclass Solution {\\n    public int distinctEchoSubstrings(String text) {\\n        int n = text.length(); \\n        long mod = 1000000007;\\n        long[] hash = new long[n + 1];\\n        long[] pow = new long[n + 1];\\n        pow[0] = 1;\\n        for (int i = 1; i <= n; i++) {\\n            hash[i] = (hash[i - 1] * 26 + text.charAt(i - 1) - \\'a\\') % mod;\\n            pow[i] = (pow[i - 1] * 26) % mod;\\n        }\\n        \\n        int res = 0;\\n        for (int j = 2; j <= n; j += 2) {\\n            Set<String> set = new HashSet<>();\\n            for (int i = 0; i + j <= n; i ++) {\\n                //[i, i + j/2 - 1], [i + j/2, i + j - 1]\\n                int a = i, b = i + j / 2 - 1, c = i + j / 2, d = i + j - 1;\\n                long hash1 = (hash[b + 1] + mod - hash[a] * pow[b - a + 1] % mod) % mod;\\n                long hash2 = (hash[d + 1] + mod - hash[c] * pow[d - c + 1] % mod) % mod;\\n                if (hash1 == hash2 && text.substring(a, b + 1).equals(text.substring(c, d + 1))) {\\n                    set.add(text.substring(a, b + 1));\\n                } \\n            }\\n            res += set.size();\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n\\nTrie solution. Worst case O(n ^ 2). Don\\'t know why it gets TLE.\\n```\\nclass Trie {\\n    boolean counted;\\n    Set<Integer> end;\\n    Trie[] child;\\n    public Trie() {\\n        counted = false;\\n        end = new HashSet<>();\\n        child = new Trie[26];\\n    }\\n}\\n\\nclass Solution {\\n    public int distinctEchoSubstrings(String text) {\\n        char[] arr = text.toCharArray();\\n        int n = text.length(), res = 0;\\n        Trie root = new Trie();\\n        for (int i = 0; i < n; i++) {\\n            Trie p = root;\\n            for (int j = i; j < n && (j - i + 1) <= n / 2; j++) {\\n                if (p.child[arr[j] - \\'a\\'] == null) p.child[arr[j] - \\'a\\'] = new Trie();\\n                p = p.child[arr[j] - \\'a\\'];\\n                if (!p.counted && p.end.contains(i - 1)) {\\n                    res++;\\n                    p.counted = true;\\n                }\\n                p.end.add(j);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int distinctEchoSubstrings(String text) {\\n        int n = text.length(); \\n        long mod = 1000000007;\\n        long[] hash = new long[n + 1];\\n        long[] pow = new long[n + 1];\\n        pow[0] = 1;\\n        for (int i = 1; i <= n; i++) {\\n            hash[i] = (hash[i - 1] * 26 + text.charAt(i - 1) - \\'a\\') % mod;\\n            pow[i] = (pow[i - 1] * 26) % mod;\\n        }\\n        \\n        int res = 0;\\n        for (int j = 2; j <= n; j += 2) {\\n            Set<String> set = new HashSet<>();\\n            for (int i = 0; i + j <= n; i ++) {\\n                //[i, i + j/2 - 1], [i + j/2, i + j - 1]\\n                int a = i, b = i + j / 2 - 1, c = i + j / 2, d = i + j - 1;\\n                long hash1 = (hash[b + 1] + mod - hash[a] * pow[b - a + 1] % mod) % mod;\\n                long hash2 = (hash[d + 1] + mod - hash[c] * pow[d - c + 1] % mod) % mod;\\n                if (hash1 == hash2 && text.substring(a, b + 1).equals(text.substring(c, d + 1))) {\\n                    set.add(text.substring(a, b + 1));\\n                } \\n            }\\n            res += set.size();\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Trie {\\n    boolean counted;\\n    Set<Integer> end;\\n    Trie[] child;\\n    public Trie() {\\n        counted = false;\\n        end = new HashSet<>();\\n        child = new Trie[26];\\n    }\\n}\\n\\nclass Solution {\\n    public int distinctEchoSubstrings(String text) {\\n        char[] arr = text.toCharArray();\\n        int n = text.length(), res = 0;\\n        Trie root = new Trie();\\n        for (int i = 0; i < n; i++) {\\n            Trie p = root;\\n            for (int j = i; j < n && (j - i + 1) <= n / 2; j++) {\\n                if (p.child[arr[j] - \\'a\\'] == null) p.child[arr[j] - \\'a\\'] = new Trie();\\n                p = p.child[arr[j] - \\'a\\'];\\n                if (!p.counted && p.end.contains(i - 1)) {\\n                    res++;\\n                    p.counted = true;\\n                }\\n                p.end.add(j);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477100,
                "title": "python-rolling-hash",
                "content": "```python\\ndef distinctEchoSubstrings(text: str) -> int:\\n\\tn = len(text)\\n\\tk, q = 26, 2**26 - 1   # rolling hash parameters\\n\\ttab = [0] * n\\n\\tout = 0\\n\\tfor m in range(1, n // 2 + 1):\\n\\t\\tfor i in range(n - m + 1):\\n\\t\\t\\ttab[i] = (tab[i] * k + ord(text[i + m - 1]) - ord(\\'a\\')) % q\\n\\t\\tseen = set()\\n\\t\\tfor i in range(n - m + 1 - m):\\n\\t\\t\\tif tab[i] == tab[i + m] and text[i:i + m] == text[i + m:i + m * 2]:\\n\\t\\t\\t\\tif text[i:i + m] not in seen:\\n\\t\\t\\t\\t\\tseen.add(text[i:i + m])\\n\\t\\t\\t\\t\\tout += 1\\n\\treturn out\\n```",
                "solutionTags": [],
                "code": "```python\\ndef distinctEchoSubstrings(text: str) -> int:\\n\\tn = len(text)\\n\\tk, q = 26, 2**26 - 1   # rolling hash parameters\\n\\ttab = [0] * n\\n\\tout = 0\\n\\tfor m in range(1, n // 2 + 1):\\n\\t\\tfor i in range(n - m + 1):\\n\\t\\t\\ttab[i] = (tab[i] * k + ord(text[i + m - 1]) - ord(\\'a\\')) % q\\n\\t\\tseen = set()\\n\\t\\tfor i in range(n - m + 1 - m):\\n\\t\\t\\tif tab[i] == tab[i + m] and text[i:i + m] == text[i + m:i + m * 2]:\\n\\t\\t\\t\\tif text[i:i + m] not in seen:\\n\\t\\t\\t\\t\\tseen.add(text[i:i + m])\\n\\t\\t\\t\\t\\tout += 1\\n\\treturn out\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 477039,
                "title": "c-sliding-window-set",
                "content": "```\\nint distinctEchoSubstrings(string text) {\\n      set<string> ans;\\n      int l=0,prev=0;\\n      while (l<text.size()-1) {\\n        int start=l+1;\\n        while(start-l<=(text.size()-start)) {\\n          while(start<text.size() and text[start]!=text[l]) {\\n              start++;\\n          }\\n          if (start<text.size()) {\\n            int len=start-l;\\n            string s1=text.substr(l,len),s2=text.substr(start,len);\\n            if (s1==s2) ans.insert(s1);\\n            start++;\\n          }\\n       }\\n       l++;\\n      }\\n      return ans.size();\\n   }\\n   ```",
                "solutionTags": [],
                "code": "```\\nint distinctEchoSubstrings(string text) {\\n      set<string> ans;\\n      int l=0,prev=0;\\n      while (l<text.size()-1) {\\n        int start=l+1;\\n        while(start-l<=(text.size()-start)) {\\n          while(start<text.size() and text[start]!=text[l]) {\\n              start++;\\n          }\\n          if (start<text.size()) {\\n            int len=start-l;\\n            string s1=text.substr(l,len),s2=text.substr(start,len);\\n            if (s1==s2) ans.insert(s1);\\n            start++;\\n          }\\n       }\\n       l++;\\n      }\\n      return ans.size();\\n   }\\n   ```",
                "codeTag": "Unknown"
            },
            {
                "id": 4086725,
                "title": "dart",
                "content": "# Code\\n```\\nimport \\'dart:collection\\';\\n\\nclass Solution {\\n  int distinctEchoSubstrings(String text) {\\n    final int N = text.length;\\n    final memo = List.generate(N, (_) => List.filled(N, 0));\\n    for (int j = N - 1; j >= 0; j--)\\n      for (int i = j - 1; i >= 0; i--)\\n        if (text[i] == text[j])\\n          memo[i][j] = j + 1 == N ? 1 : 1 + memo[i + 1][j + 1];\\n    final db = HashSet<String>();\\n    \\n    for (int i = 0; i < text.length; i++) {\\n      for (int j = i + 1; j < text.length; j++) {\\n        if (memo[i][j] >= j - i)\\n          db.add(text.substring(i, j));\\n      }\\n    }\\n    return db.length;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nimport \\'dart:collection\\';\\n\\nclass Solution {\\n  int distinctEchoSubstrings(String text) {\\n    final int N = text.length;\\n    final memo = List.generate(N, (_) => List.filled(N, 0));\\n    for (int j = N - 1; j >= 0; j--)\\n      for (int i = j - 1; i >= 0; i--)\\n        if (text[i] == text[j])\\n          memo[i][j] = j + 1 == N ? 1 : 1 + memo[i + 1][j + 1];\\n    final db = HashSet<String>();\\n    \\n    for (int i = 0; i < text.length; i++) {\\n      for (int j = i + 1; j < text.length; j++) {\\n        if (memo[i][j] >= j - i)\\n          db.add(text.substring(i, j));\\n      }\\n    }\\n    return db.length;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960267,
                "title": "simple-python-code-1231ms",
                "content": "# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\nbeats ~ 70%\\n\\n- Space complexity:\\n$$O(n)$$\\nbeats ~ 31%\\n\\n# Code\\n```\\nimport math\\nclass Solution:\\n    def distinctEchoSubstrings(self, text) :\\n        n = len(text)\\n        m = 0\\n        max_n = math.floor(n/2)\\n        substrs = set()\\n        for i in range(1, max_n+1) :\\n            for j in range(n-i-m) :\\n                substr = text[j:j+2*i]\\n                if substr[0:i] == substr[i:] :\\n                    substrs.add(substr)\\n            m += 1\\n        return len(substrs)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def distinctEchoSubstrings(self, text) :\\n        n = len(text)\\n        m = 0\\n        max_n = math.floor(n/2)\\n        substrs = set()\\n        for i in range(1, max_n+1) :\\n            for j in range(n-i-m) :\\n                substr = text[j:j+2*i]\\n                if substr[0:i] == substr[i:] :\\n                    substrs.add(substr)\\n            m += 1\\n        return len(substrs)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956320,
                "title": "python3-rolling-hash-o-n-2-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        text_arr = [ord(val)-97 for val in text]\\n        hash_map = {}\\n        pow_arr = [1]\\n        for i in range(1,len(text)+1):\\n            pow_arr.append(pow_arr[i-1]*26)\\n            \\n\\n        for substr_len in range(1,len(text_arr)//2 + 1):\\n            cur_hash = 0\\n            for k in range(0,substr_len):\\n                cur_hash = cur_hash*26+text_arr[k]\\n            hash_map[(0,substr_len)] = cur_hash\\n            for start_ind in range(1,len(text_arr)-substr_len+1):\\n                cur_hash -= text_arr[start_ind-1]*pow_arr[substr_len-1]\\n                cur_hash = cur_hash*26 + text_arr[start_ind+substr_len-1]\\n                hash_map[(start_ind, start_ind+substr_len)] = cur_hash\\n\\n\\n        substr_set = set()\\n        for pair in hash_map:\\n                first_pair = pair\\n                second_pair = (pair[1],pair[1]+(first_pair[1]-first_pair[0]))\\n                if first_pair in hash_map and second_pair in hash_map and hash_map[first_pair] == hash_map[second_pair]:\\n                    substr_set.add((first_pair[1]-first_pair[0], hash_map[first_pair]))\\n                    \\n        return len(substr_set)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        text_arr = [ord(val)-97 for val in text]\\n        hash_map = {}\\n        pow_arr = [1]\\n        for i in range(1,len(text)+1):\\n            pow_arr.append(pow_arr[i-1]*26)\\n            \\n\\n        for substr_len in range(1,len(text_arr)//2 + 1):\\n            cur_hash = 0\\n            for k in range(0,substr_len):\\n                cur_hash = cur_hash*26+text_arr[k]\\n            hash_map[(0,substr_len)] = cur_hash\\n            for start_ind in range(1,len(text_arr)-substr_len+1):\\n                cur_hash -= text_arr[start_ind-1]*pow_arr[substr_len-1]\\n                cur_hash = cur_hash*26 + text_arr[start_ind+substr_len-1]\\n                hash_map[(start_ind, start_ind+substr_len)] = cur_hash\\n\\n\\n        substr_set = set()\\n        for pair in hash_map:\\n                first_pair = pair\\n                second_pair = (pair[1],pair[1]+(first_pair[1]-first_pair[0]))\\n                if first_pair in hash_map and second_pair in hash_map and hash_map[first_pair] == hash_map[second_pair]:\\n                    substr_set.add((first_pair[1]-first_pair[0], hash_map[first_pair]))\\n                    \\n        return len(substr_set)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3915472,
                "title": "my-attempt-towards-an-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhenever there exists a substring that meets the condition, the leading char in the second half must have been seen previously.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs we traverse the text char by char, recall where the same char exists before, and check if the suffix starting from those two positions matches.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nBest scenario: Not much duplicates (abcdefghij) -> O(n)\\nWorst scenario: Too many duplicates (aaaaaaaaaa) -> O(n**2/2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        seenCharAt = defaultdict(list)\\n        res = set()\\n        for i, char in enumerate(text):\\n            if char in seenCharAt:\\n                for prevPos in seenCharAt[char]:\\n                    suffixLen = i - prevPos\\n                    if text[prevPos:i] == text[i:i+suffixLen]:\\n                        res.add(text[prevPos:i+suffixLen])\\n            seenCharAt[char].append(i)\\n        return len(res)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        seenCharAt = defaultdict(list)\\n        res = set()\\n        for i, char in enumerate(text):\\n            if char in seenCharAt:\\n                for prevPos in seenCharAt[char]:\\n                    suffixLen = i - prevPos\\n                    if text[prevPos:i] == text[i:i+suffixLen]:\\n                        res.add(text[prevPos:i+suffixLen])\\n            seenCharAt[char].append(i)\\n        return len(res)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766168,
                "title": "python-beats-100-in-memory-and-runtime-string-hashing-with-pointer-crawlers",
                "content": "# Intuition\\nIn order to cut down runtime, we must decrease the number of comparisons needed to find new echos. I realized that for an echo made  with 2 substring of length l, at indexes [i; i + 2l], we can easily determine that the substring at [i + 1; i + 21 + 1] is an echo if arr[i + l + 1] = arr[i + 2l + 1].\\n\\nFor example: \\n\"appleapplea\"\\nOnce we find that \"appleapple\" is an echo, we can know that \"ppleapplea\" is an echo by just comparing the a at index 5 and at index 10.\\n\\n# Approach\\nUsing this approach, we just have to build a program that finds the first echo with substring length l, and then checks consecutive ones. This can be done be checking if index i and i + l are the same up until we\\'ve have l characters in a row that are the same. \\n\\n# Complexity\\n- Time complexity: O(n ^ 2)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def distinctEchoSubstrings(self, text):\\n\\n        //count of echos\\n        ret = 0\\n\\n        //dictionary keeping track of distinct substrings so we don\\'t count any echoes twice\\n        distinct = defaultdict(int)\\n\\n        //iterating through possible lengths of substrings\\n        for i in range (1, len(text) / 2 + 1):\\n            //number of characters in row that have echos a distance i away\\n            count = 0\\n            \\n            //every possible index containing an echo with substring length i\\n            for j in range(0, len(text) - i):\\n                if text[j] == text[i + j]:\\n                    if count == i - 1:\\n                        if distinct[text[j:j + i]] == 0:\\n                            ret += 1\\n                            distinct[text[j:j + i]] = 1\\n                    else:\\n                        count += 1\\n                else:\\n                    count = 0\\n        \\n        return ret\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def distinctEchoSubstrings(self, text):\\n\\n        //count of echos\\n        ret = 0\\n\\n        //dictionary keeping track of distinct substrings so we don\\'t count any echoes twice\\n        distinct = defaultdict(int)\\n\\n        //iterating through possible lengths of substrings\\n        for i in range (1, len(text) / 2 + 1):\\n            //number of characters in row that have echos a distance i away\\n            count = 0\\n            \\n            //every possible index containing an echo with substring length i\\n            for j in range(0, len(text) - i):\\n                if text[j] == text[i + j]:\\n                    if count == i - 1:\\n                        if distinct[text[j:j + i]] == 0:\\n                            ret += 1\\n                            distinct[text[j:j + i]] = 1\\n                    else:\\n                        count += 1\\n                else:\\n                    count = 0\\n        \\n        return ret\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3604220,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        unordered_set<string> result;\\n        int l = text.length() - 1;\\n        for (int i = 0; i < l; ++i)  {\\n            const auto& substr_len = KMP(text, i, &result);\\n            if (substr_len != numeric_limits<int>::max()) {\\n                l = min(l, i + substr_len);\\n            }\\n        }\\n        return result.size();\\n    }\\nprivate:\\n    int KMP(const string& text, int l, unordered_set<string> *result) {\\n        vector<int> prefix(text.length() - l, -1);\\n        int j = -1;\\n        for (int i = 1; i < prefix.size(); ++i) {\\n            while (j > -1 && text[l + j + 1] != text[l + i]) {\\n                j = prefix[j];\\n            }\\n            if (text[l + j + 1] == text[l + i]) {\\n                ++j;\\n            }\\n            prefix[i] = j;\\n            if ((j + 1) && (i + 1) % ((i + 1) - (j + 1)) == 0 &&\\n                (i + 1) / ((i + 1) - (j + 1)) % 2 == 0) {\\n                result->emplace(text.substr(l, i + 1));\\n            }\\n        }\\n        return (prefix.back() + 1 && (prefix.size() % (prefix.size() - (prefix.back() + 1)) == 0))\\n               ? (prefix.size() - (prefix.back() + 1))\\n               : numeric_limits<int>::max();\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        d = {}\\n        visited = set()\\n        ans = 0\\n        if all([t == text[0] for t in text]):\\n            return len(text) //2\\n        for (i, s) in enumerate(text):\\n            if s not in d:\\n                d[s] = [i]\\n            else:\\n                for k in d[s]:\\n                    if text[k:i] == text[i:(2 * i - k)]:\\n                        visited.add(text[k:i])\\n                        break\\n                d[s].append(i)\\n        return len(visited)\\n```\\n\\n```Java []\\nclass Solution {\\n    public int distinctEchoSubstrings(String text) {\\n        Set<Long> st = new HashSet<>();\\n        RollingHash rh = new RollingHash(text);\\n        for(int i = 0; i < text.length(); i++){\\n            for(int j = i; j < text.length(); j++){\\n                if( (j-i+1) % 2 == 0){\\n                    int mid = (i+1)+(j+1-(i+1))/2;\\n                    if(rh.get(i+1, mid) == rh.get(mid+1, j+1)){\\n                        st.add(rh.get(i+1, j+1));\\n                    }\\n                }\\n            }\\n        }\\n        return st.size();\\n    }\\n}\\nclass RollingHash{\\n    int n;\\n    int base = 31;\\n    long[] p;\\n    long[] h;\\n    \\n    public RollingHash(String text){\\n        n = text.length();\\n        p = new long[n+2];\\n        h = new long[n+2];\\n        \\n        p[0] = 1;\\n        \\n        for(int i = 1; i <= n; i++){\\n            p[i] = p[i-1]*base;\\n            h[i] = h[i-1]*base + text.charAt(i-1);\\n        }\\n    }\\n    public long get(int l, int r){\\n        return h[r]-h[l-1]*p[r-l+1];\\n    }   \\n} \\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        unordered_set<string> result;\\n        int l = text.length() - 1;\\n        for (int i = 0; i < l; ++i)  {\\n            const auto& substr_len = KMP(text, i, &result);\\n            if (substr_len != numeric_limits<int>::max()) {\\n                l = min(l, i + substr_len);\\n            }\\n        }\\n        return result.size();\\n    }\\nprivate:\\n    int KMP(const string& text, int l, unordered_set<string> *result) {\\n        vector<int> prefix(text.length() - l, -1);\\n        int j = -1;\\n        for (int i = 1; i < prefix.size(); ++i) {\\n            while (j > -1 && text[l + j + 1] != text[l + i]) {\\n                j = prefix[j];\\n            }\\n            if (text[l + j + 1] == text[l + i]) {\\n                ++j;\\n            }\\n            prefix[i] = j;\\n            if ((j + 1) && (i + 1) % ((i + 1) - (j + 1)) == 0 &&\\n                (i + 1) / ((i + 1) - (j + 1)) % 2 == 0) {\\n                result->emplace(text.substr(l, i + 1));\\n            }\\n        }\\n        return (prefix.back() + 1 && (prefix.size() % (prefix.size() - (prefix.back() + 1)) == 0))\\n               ? (prefix.size() - (prefix.back() + 1))\\n               : numeric_limits<int>::max();\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        d = {}\\n        visited = set()\\n        ans = 0\\n        if all([t == text[0] for t in text]):\\n            return len(text) //2\\n        for (i, s) in enumerate(text):\\n            if s not in d:\\n                d[s] = [i]\\n            else:\\n                for k in d[s]:\\n                    if text[k:i] == text[i:(2 * i - k)]:\\n                        visited.add(text[k:i])\\n                        break\\n                d[s].append(i)\\n        return len(visited)\\n```\n```Java []\\nclass Solution {\\n    public int distinctEchoSubstrings(String text) {\\n        Set<Long> st = new HashSet<>();\\n        RollingHash rh = new RollingHash(text);\\n        for(int i = 0; i < text.length(); i++){\\n            for(int j = i; j < text.length(); j++){\\n                if( (j-i+1) % 2 == 0){\\n                    int mid = (i+1)+(j+1-(i+1))/2;\\n                    if(rh.get(i+1, mid) == rh.get(mid+1, j+1)){\\n                        st.add(rh.get(i+1, j+1));\\n                    }\\n                }\\n            }\\n        }\\n        return st.size();\\n    }\\n}\\nclass RollingHash{\\n    int n;\\n    int base = 31;\\n    long[] p;\\n    long[] h;\\n    \\n    public RollingHash(String text){\\n        n = text.length();\\n        p = new long[n+2];\\n        h = new long[n+2];\\n        \\n        p[0] = 1;\\n        \\n        for(int i = 1; i <= n; i++){\\n            p[i] = p[i-1]*base;\\n            h[i] = h[i-1]*base + text.charAt(i-1);\\n        }\\n    }\\n    public long get(int l, int r){\\n        return h[r]-h[l-1]*p[r-l+1];\\n    }   \\n} \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3560215,
                "title": "fast-python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        n = len(text)\\n\\t\\t\\n        def helper(size):\\n            base = 1 << 5\\n            M = 10 ** 9 + 7\\n            a = pow(base, size, M)\\n            t = 0\\n            vis = defaultdict(set)\\n            vis_pattern = set()\\n            ans = 0\\n            for i in range(n):\\n                t = (base * t + ord(text[i]) - ord(\\'a\\')) % M\\n                if i >= size:\\n                    t -= a * (ord(text[i - size]) - ord(\\'a\\'))\\n                    t %= M\\n                    if t not in vis_pattern and (i - size * 2 + 1) in vis[t]:\\n                        ans += 1\\n                        vis_pattern.add(t)\\n                if i >= size - 1:\\n                    vis[t].add(i - size + 1)\\n            return ans\\n\\n        return sum(helper(size) for size in range(1, n//2+1))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        n = len(text)\\n\\t\\t\\n        def helper(size):\\n            base = 1 << 5\\n            M = 10 ** 9 + 7\\n            a = pow(base, size, M)\\n            t = 0\\n            vis = defaultdict(set)\\n            vis_pattern = set()\\n            ans = 0\\n            for i in range(n):\\n                t = (base * t + ord(text[i]) - ord(\\'a\\')) % M\\n                if i >= size:\\n                    t -= a * (ord(text[i - size]) - ord(\\'a\\'))\\n                    t %= M\\n                    if t not in vis_pattern and (i - size * 2 + 1) in vis[t]:\\n                        ans += 1\\n                        vis_pattern.add(t)\\n                if i >= size - 1:\\n                    vis[t].add(i - size + 1)\\n            return ans\\n\\n        return sum(helper(size) for size in range(1, n//2+1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3532296,
                "title": "python-o-n-2-easy-to-understand",
                "content": "# Approach\\necho substring is a + a. so for each text[i] for i from 0 -> len(text) -1 and for j from i -> len(text). get prefix = text[i: j + 1], suffix = text[j + 1: j + 1 + len(prefix)]. if prefix == suffix: ans.add(prefix)\\n\\nthen return len(ans)\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        ans = set()\\n\\n        for i in range(len(text)):\\n            for j in range(i, len(text)):\\n                prefix = text[i : j + 1]\\n                suffix = text[j + 1: j + 1 + len(prefix)]\\n\\n                if prefix == suffix: \\n                    ans.add(prefix)\\n\\n        # print(ans) \\n        return len(ans)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        ans = set()\\n\\n        for i in range(len(text)):\\n            for j in range(i, len(text)):\\n                prefix = text[i : j + 1]\\n                suffix = text[j + 1: j + 1 + len(prefix)]\\n\\n                if prefix == suffix: \\n                    ans.add(prefix)\\n\\n        # print(ans) \\n        return len(ans)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3501060,
                "title": "golang-slightly-faster-using-bool",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc distinctEchoSubstrings(text string) int {\\n   ans := make(map[string]bool)\\n\\tfor i := range text {\\n\\t\\tfor j := i + 1; j-i <= len(text)-j; j++ {\\n\\t\\t\\tif t:=text[i:j]; t == text[j:2*j-i] {\\n\\t\\t\\t\\tans[t] = true\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn len(ans) \\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc distinctEchoSubstrings(text string) int {\\n   ans := make(map[string]bool)\\n\\tfor i := range text {\\n\\t\\tfor j := i + 1; j-i <= len(text)-j; j++ {\\n\\t\\t\\tif t:=text[i:j]; t == text[j:2*j-i] {\\n\\t\\t\\t\\tans[t] = true\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn len(ans) \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3473161,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(string &str,int start1,int end1,int start2,int end2)\\n    {\\n        for (int i=start1,j=start2;i<=end1,j<=end2;i++,j++)\\n        {\\n            if (str[i]!=str[j]) return false;\\n        }\\n        return true;\\n    }\\n    int distinctEchoSubstrings(string text) {\\n        int n=text.size();\\n        set<string>st;\\n        for (int i=0;i<n-1;i++)\\n        {\\n            for (int l=1;i+2*l<=n;l++)\\n            {\\n                if (check(text,i,i+l-1,i+l,i+2*l-1)) \\n                {\\n                    st.insert(text.substr(i,2*l));\\n                }\\n            }\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(string &str,int start1,int end1,int start2,int end2)\\n    {\\n        for (int i=start1,j=start2;i<=end1,j<=end2;i++,j++)\\n        {\\n            if (str[i]!=str[j]) return false;\\n        }\\n        return true;\\n    }\\n    int distinctEchoSubstrings(string text) {\\n        int n=text.size();\\n        set<string>st;\\n        for (int i=0;i<n-1;i++)\\n        {\\n            for (int l=1;i+2*l<=n;l++)\\n            {\\n                if (check(text,i,i+l-1,i+l,i+2*l-1)) \\n                {\\n                    st.insert(text.substr(i,2*l));\\n                }\\n            }\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442136,
                "title": "go-easy-solution-o-n-2",
                "content": "# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc distinctEchoSubstrings(text string) int {\\n\\techo := make(map[string]struct{})\\n\\tfor i := range text {\\n\\t\\tfor j := i + 1; j-i <= len(text)-j; j++ {\\n\\t\\t\\tif t := text[i:j]; t == text[j:2*j-i] {\\n\\t\\t\\t\\techo[t] = struct{}{}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn len(echo)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc distinctEchoSubstrings(text string) int {\\n\\techo := make(map[string]struct{})\\n\\tfor i := range text {\\n\\t\\tfor j := i + 1; j-i <= len(text)-j; j++ {\\n\\t\\t\\tif t := text[i:j]; t == text[j:2*j-i] {\\n\\t\\t\\t\\techo[t] = struct{}{}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn len(echo)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3339776,
                "title": "distinct-echo-substrings-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private long[] h;\\n    private long[] p;\\n\\n    public int distinctEchoSubstrings(String text) {\\n        int n = text.length();\\n        int base = 131;\\n        h = new long[n + 10];\\n        p = new long[n + 10];\\n        p[0] = 1;\\n        for (int i = 0; i < n; ++i) {\\n            int t = text.charAt(i) - \\'a\\' + 1;\\n            h[i + 1] = h[i] * base + t;\\n            p[i + 1] = p[i] * base;\\n        }\\n        Set<Long> vis = new HashSet<>();\\n        for (int i = 0; i < n - 1; ++i) {\\n            for (int j = i + 1; j < n; j += 2) {\\n                int k = (i + j) >> 1;\\n                long a = get(i + 1, k + 1);\\n                long b = get(k + 2, j + 1);\\n                if (a == b) {\\n                    vis.add(a);\\n                }\\n            }\\n        }\\n        return vis.size();\\n    }\\n\\n    private long get(int i, int j) {\\n        return h[j] - h[i - 1] * p[j - i + 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Rolling Hash"
                ],
                "code": "```\\nclass Solution {\\n    private long[] h;\\n    private long[] p;\\n\\n    public int distinctEchoSubstrings(String text) {\\n        int n = text.length();\\n        int base = 131;\\n        h = new long[n + 10];\\n        p = new long[n + 10];\\n        p[0] = 1;\\n        for (int i = 0; i < n; ++i) {\\n            int t = text.charAt(i) - \\'a\\' + 1;\\n            h[i + 1] = h[i] * base + t;\\n            p[i + 1] = p[i] * base;\\n        }\\n        Set<Long> vis = new HashSet<>();\\n        for (int i = 0; i < n - 1; ++i) {\\n            for (int j = i + 1; j < n; j += 2) {\\n                int k = (i + j) >> 1;\\n                long a = get(i + 1, k + 1);\\n                long b = get(k + 2, j + 1);\\n                if (a == b) {\\n                    vis.add(a);\\n                }\\n            }\\n        }\\n        return vis.size();\\n    }\\n\\n    private long get(int i, int j) {\\n        return h[j] - h[i - 1] * p[j - i + 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3225395,
                "title": "rust-solution",
                "content": "Just a rust implementation of Stefan\\'s approach\\n# Code\\n```\\nimpl Solution {\\n    pub fn distinct_echo_substrings(text: String) -> i32 {\\n        fn sliding_window(text: String) -> i32 {\\n            use std::collections::*;\\n            let mut set = HashSet::new();\\n            let text = text.chars().collect::<Vec<_>>();\\n            for window_size in 1..=text.len() / 2 {\\n                let mut same_count = 0;\\n                for i in 0..window_size {\\n                    if text[i] == text[i + window_size] {\\n                        same_count += 1i32;\\n                    }\\n                }\\n                for i in 0..=text.len() - window_size * 2 {\\n                    if same_count == window_size as i32 {\\n                        set.insert(&text[i..i + window_size]);\\n                    }\\n                    if i == text.len() - window_size * 2 {\\n                        break;\\n                    }\\n                    same_count += (text[i + window_size] == text[i + window_size * 2]) as i32\\n                        - (text[i] == text[i + window_size]) as i32;\\n                }\\n            }\\n            set.len() as i32\\n        }\\n\\n        sliding_window(text)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn distinct_echo_substrings(text: String) -> i32 {\\n        fn sliding_window(text: String) -> i32 {\\n            use std::collections::*;\\n            let mut set = HashSet::new();\\n            let text = text.chars().collect::<Vec<_>>();\\n            for window_size in 1..=text.len() / 2 {\\n                let mut same_count = 0;\\n                for i in 0..window_size {\\n                    if text[i] == text[i + window_size] {\\n                        same_count += 1i32;\\n                    }\\n                }\\n                for i in 0..=text.len() - window_size * 2 {\\n                    if same_count == window_size as i32 {\\n                        set.insert(&text[i..i + window_size]);\\n                    }\\n                    if i == text.len() - window_size * 2 {\\n                        break;\\n                    }\\n                    same_count += (text[i + window_size] == text[i + window_size * 2]) as i32\\n                        - (text[i] == text[i + window_size]) as i32;\\n                }\\n            }\\n            set.len() as i32\\n        }\\n\\n        sliding_window(text)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3188623,
                "title": "chal-bhai",
                "content": "class Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) \\n    {\\n        set<string> st;\\n        int n=text.size();\\n        \\n        for(int len=1;len<=n/2;len++)\\n        {\\n            int count=0;\\n            \\n            for(int l=0,r=len;r<n;l++,r++)\\n            {\\n                if(text[l]==text[r])\\n                    count++;\\n                else\\n                    count=0;\\n                \\n                if(count==len)\\n                {\\n                     st.insert(text.substr(l,len));\\n                     count--;\\n                }\\n            }\\n        }\\n            \\n        return st.size();\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) \\n    {\\n        set<string> st;\\n        int n=text.size();\\n        \\n        for(int len=1;len<=n/2;len++)\\n        {\\n            int count=0;\\n            \\n            for(int l=0,r=len;r<n;l++,r++)\\n            {\\n                if(text[l]==text[r])\\n                    count++;\\n                else\\n                    count=0;\\n                \\n                if(count==len)\\n                {\\n                     st.insert(text.substr(l,len));\\n                     count--;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3116927,
                "title": "c-solution-hashset",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int DistinctEchoSubstrings(string text) {\\n        if(text.Length == 1){\\n            return 0;\\n        }\\n\\n        HashSet<string> echos = new();\\n        int lastIndex = text.Length - 1;\\n\\n        for(int i=0; i<lastIndex; i++){\\n            int mid = (text.Length-i)/2;\\n\\n            for(int len=1; len<=mid; len++){\\n                int j = i+len;\\n\\n                if(text.Substring(i, len).Equals(text.Substring(j, len))){\\n                    echos.Add(text.Substring(i, (len*2)));\\n                }\\n            }\\n        }\\n\\n        return echos.Count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\npublic class Solution {\\n    public int DistinctEchoSubstrings(string text) {\\n        if(text.Length == 1){\\n            return 0;\\n        }\\n\\n        HashSet<string> echos = new();\\n        int lastIndex = text.Length - 1;\\n\\n        for(int i=0; i<lastIndex; i++){\\n            int mid = (text.Length-i)/2;\\n\\n            for(int len=1; len<=mid; len++){\\n                int j = i+len;\\n\\n                if(text.Substring(i, len).Equals(text.Substring(j, len))){\\n                    echos.Add(text.Substring(i, (len*2)));\\n                }\\n            }\\n        }\\n\\n        return echos.Count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3114158,
                "title": "brute-force-java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic static int distinctEchoSubstrings(String text) {\\n    \\n    Set<String> s = new HashSet<>();\\n    \\n    for (int i = 0; i < text.length(); i++)\\n        \\n    for (int j = i + 1; j < text.length(); j++)\\n        \\n    if (text.charAt(i) == text.charAt(j) && j + j - i <= text.length())\\n        \\n    if (text.substring(i, j).equals(text.substring(j, j + j - i)))\\n        \\n    s.add(text.substring(i, j) + text.substring(j, j + j - i));\\n    \\n    return s.size();\\n    \\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic static int distinctEchoSubstrings(String text) {\\n    \\n    Set<String> s = new HashSet<>();\\n    \\n    for (int i = 0; i < text.length(); i++)\\n        \\n    for (int j = i + 1; j < text.length(); j++)\\n        \\n    if (text.charAt(i) == text.charAt(j) && j + j - i <= text.length())\\n        \\n    if (text.substring(i, j).equals(text.substring(j, j + j - i)))\\n        \\n    s.add(text.substring(i, j) + text.substring(j, j + j - i));\\n    \\n    return s.size();\\n    \\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3113780,
                "title": "python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        count=0\\n        dic=dict()\\n        for i in range(len(text)):\\n            a=i\\n            b=a+1\\n            for j in range(len(text[i:])):\\n                if text[a:b]==text[b:len(text[a:b])+b]:\\n                    if not text[a:b] in dic:\\n                        count+=1\\n                    dic[text[a:b]]=0\\n                b+=1\\n        \\n        return count \\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        count=0\\n        dic=dict()\\n        for i in range(len(text)):\\n            a=i\\n            b=a+1\\n            for j in range(len(text[i:])):\\n                if text[a:b]==text[b:len(text[a:b])+b]:\\n                    if not text[a:b] in dic:\\n                        count+=1\\n                    dic[text[a:b]]=0\\n                b+=1\\n        \\n        return count \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096867,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn distinct_echo_substrings(text: String) -> i32 {\\n        fn check(s: &[u8]) -> bool {\\n            let mut j = s.len() / 2;\\n            for i in 0..(s.len() / 2) {\\n                if s[i] != s[j] {\\n                    return false;\\n                }\\n                j += 1;\\n            }\\n            true\\n        }\\n\\n        let mut s = std::collections::HashSet::new();\\n        let text = text.as_bytes();\\n        for i in 0..text.len() {\\n            let mut ans = vec![];\\n            for j in (i..text.len()).step_by(2) {\\n                ans.push(text[j]);\\n                if j + 1 < text.len() {\\n                    ans.push(text[j + 1]);\\n                } else {\\n                    break;\\n                }\\n                if check(&ans) {\\n                    s.insert(ans.clone());\\n                }\\n            }\\n        }\\n        s.len() as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn distinct_echo_substrings(text: String) -> i32 {\\n        fn check(s: &[u8]) -> bool {\\n            let mut j = s.len() / 2;\\n            for i in 0..(s.len() / 2) {\\n                if s[i] != s[j] {\\n                    return false;\\n                }\\n                j += 1;\\n            }\\n            true\\n        }\\n\\n        let mut s = std::collections::HashSet::new();\\n        let text = text.as_bytes();\\n        for i in 0..text.len() {\\n            let mut ans = vec![];\\n            for j in (i..text.len()).step_by(2) {\\n                ans.push(text[j]);\\n                if j + 1 < text.len() {\\n                    ans.push(text[j + 1]);\\n                } else {\\n                    break;\\n                }\\n                if check(&ans) {\\n                    s.insert(ans.clone());\\n                }\\n            }\\n        }\\n        s.len() as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3095390,
                "title": "c-2-approach-improved-brute-rolling-hash-google-asked-well-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI tried classic rolling hash, but it gave TLE. So, I tried all possible substring, and check for the condition. But there is a cache !!\\nI tried only substring whose length is possible :\\n```\\nfor (int len = 1; i + 2 * len <= s.size(); len++){\\n    ...\\n}\\n```\\nFocus on ```i + 2 * len <= s.size();``` because if I consider ith index as starting of echo string then len can go upto only (n-i)/2, no more than that. So, it won\\'t give TLE and will help to reduce time. \\n\\n\\n# Approach 1 :\\n<!-- Describe your approach to solving the problem. -->\\nAssume ith index as start of substring and compare string for **all possible length** which can be made starting from ith index.\\nFor length len, compares s[i ... i+len-1] and s[i+len ... 1+2*len-1]. \\nAnd store possible substring in a set to avoid duplicates.\\n[ Note :- Use compare() in c++, to avoid creating a new substring each time.].\\n\\n\\n# Complexity \\n- Time complexity: $$O(N^3)$$ where N is size of string, as One extra $$O(N)$$ requirred to compare two substring. but it will be accepted. \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N^2)$$ where N is size of string, as in the worst case we have to store every substring.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll                 long long\\n\\nclass Solution {\\npublic:\\n\\n    // brute force // accepted\\n    int distinctEchoSubstrings(string& s) {\\n        unordered_set<string> st;\\n        for (int i = 0; i < s.size(); i++) {\\n            // assume ith index as start of string, so first substring s[i...i+len-1] and second is s[i+len...i+len+len-1]\\n            for (int len = 1; i + 2 * len <= s.size(); len++) {\\n                // compare both by compare()\\n                if (s.compare(i, len, s, i + len, len) == 0) st.insert(s.substr(i, len));\\n            }\\n        }\\n        return st.size();\\n    }\\n};\\n```\\n\\n---\\n\\n\\n# Approach 2 :\\nHere approach is same as the previous one, but this time we compare hashes of two substring instead of comparing two substring.\\nAlso, store hashes of possible substring instead of substring, so that we can reduce our time. \\n\\n# Complexity \\n- Time complexity: $$O(N^2)$$ where N is size of string.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$ where N is size of string, we need space only to store hashes of substring.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll                 long long\\n\\nclass Solution {\\npublic:\\n\\n    // by hashing // accepted\\n    int distinctEchoSubstrings(string s) {\\n        ll n = s.size(), prm = 31, mod = 1000000007;\\n        // h[i] : store hash of s[0....i] // p[i] store prem^i\\n        vector<ll> h(n, 0), p(n, 0);\\n\\n        // preprocessing : calculate hash array and prime power\\n        h[0] = s[0] % mod;\\n        p[0] = 1;\\n        for (int i = 1; i < n; i++) {\\n            h[i] = (h[i - 1] * prm + s[i]) % mod;\\n            p[i] = (p[i - 1] * prm) % mod;\\n        }\\n\\n\\n        // cal hash of s[i...j]  // inclusive\\n        auto calHash = [&](int i, int j) {\\n            auto res = (h[j] - (i >= 1 ? h[i - 1] * p[j - i + 1] : 0)) % mod;\\n            return (res + mod) % mod;\\n        };\\n\\n\\n        // store hashes instead of string to reduce the time\\n        unordered_set<ll> st;\\n        for (int i = 0; i < n; i++) {\\n            // assume ith index as start of string, so first substring s[i...i+len-1] and second is s[i+len...i+len+len-1]\\n            for (int len = 1; i + 2 * len <= n; len++) {\\n                // compare both by hashing\\n                if (calHash(i, i + len - 1) == calHash(i + len, i + 2 * len - 1))\\n                    st.insert(calHash(i, i + len - 1));\\n            }\\n        }\\n        return st.size();\\n    }\\n\\n};\\n",
                "solutionTags": [
                    "C++",
                    "String",
                    "Sliding Window",
                    "Rolling Hash",
                    "Hash Function"
                ],
                "code": "```\\nfor (int len = 1; i + 2 * len <= s.size(); len++){\\n    ...\\n}\\n```\n```i + 2 * len <= s.size();```\n```\\n#define ll                 long long\\n\\nclass Solution {\\npublic:\\n\\n    // brute force // accepted\\n    int distinctEchoSubstrings(string& s) {\\n        unordered_set<string> st;\\n        for (int i = 0; i < s.size(); i++) {\\n            // assume ith index as start of string, so first substring s[i...i+len-1] and second is s[i+len...i+len+len-1]\\n            for (int len = 1; i + 2 * len <= s.size(); len++) {\\n                // compare both by compare()\\n                if (s.compare(i, len, s, i + len, len) == 0) st.insert(s.substr(i, len));\\n            }\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3094042,
                "title": "simple-c-easy-full-algorithm-explained",
                "content": "\\n\\n# Approach\\n1.We are taking a set for storing distinct substrings.\\n2.We are running a loop of len(1->n/2) i.e. max length for an echo substring can be n/2 and keep a count at 0.\\n3.We position the left pt on 0 and right pt on len and run the loop till right reaches n .\\n4.When same characters is found we increment the count and if different characters are found we make count = 0 i.e we have start again searching.\\n5.If the count reaches len we will store the certain substring into the set.\\n6.We will decrease the count to remove the first element occurence and start checking from 1st index for a new sequence.\\n7.finally we will return set size.\\n\\n# Complexity\\n- Time complexity:\\nO(n*3)\\n\\n- Space complexity:\\nO(n) - set\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        int n = text.size();\\n        unordered_set<string>st;\\n        for(int len=1;len<=n/2;len++){\\n            int count =0;\\n            for(int left=0,right=len;right<n;right++,left++){\\n                if(text[left]==text[right])count++;\\n                else count=0;\\n\\n                if(count==len){\\n                    string str = text.substr(left,right-left+1);\\n                    st.insert(str);\\n                    count--;\\n                }\\n            }\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        int n = text.size();\\n        unordered_set<string>st;\\n        for(int len=1;len<=n/2;len++){\\n            int count =0;\\n            for(int left=0,right=len;right<n;right++,left++){\\n                if(text[left]==text[right])count++;\\n                else count=0;\\n\\n                if(count==len){\\n                    string str = text.substr(left,right-left+1);\\n                    st.insert(str);\\n                    count--;\\n                }\\n            }\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3018168,
                "title": "rolling-hash",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    long[] hash;\\n    long[] power;\\n    long mod = (int)1e9 + 7;\\n    long radix = 256;\\n    void _hashing(String s, int n) {\\n        hash = new long[n];\\n        power = new long[n];\\n        power[0] = 1;\\n        for(int i = 1; i < n; i++) {\\n            hash[i] = (hash[i - 1] * radix + s.charAt(i)) % mod;\\n            power[i] = (power[i - 1] * radix) % mod;\\n        }\\n    }\\n    long calculateHash(int l, int r) {\\n        long val = (hash[r] - hash[l] * power[r - l] % mod + mod ) % mod;\\n        return val;\\n    }\\n    public int distinctEchoSubstrings(String text) {\\n        int n = text.length();\\n        _hashing(text, n);\\n        Set<Long> set = new HashSet<>();\\n        for(int len = 1; len <= n / 2; len++) {\\n            int count = 0;\\n            for(int i = 0, j = len; j < n; i++, j++) {\\n                char ci = text.charAt(i);\\n                char cj = text.charAt(j);\\n                if(ci == cj)\\n                    count++;\\n                else count = 0;\\n                if(count == len){\\n                    long _hash = calculateHash(i, j);\\n                    set.add(_hash);\\n                    count--;\\n                }    \\n            }\\n        }\\n        return set.size();\\n    }\\n}\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Rolling Hash"
                ],
                "code": "```\\nclass Solution {\\n    long[] hash;\\n    long[] power;\\n    long mod = (int)1e9 + 7;\\n    long radix = 256;\\n    void _hashing(String s, int n) {\\n        hash = new long[n];\\n        power = new long[n];\\n        power[0] = 1;\\n        for(int i = 1; i < n; i++) {\\n            hash[i] = (hash[i - 1] * radix + s.charAt(i)) % mod;\\n            power[i] = (power[i - 1] * radix) % mod;\\n        }\\n    }\\n    long calculateHash(int l, int r) {\\n        long val = (hash[r] - hash[l] * power[r - l] % mod + mod ) % mod;\\n        return val;\\n    }\\n    public int distinctEchoSubstrings(String text) {\\n        int n = text.length();\\n        _hashing(text, n);\\n        Set<Long> set = new HashSet<>();\\n        for(int len = 1; len <= n / 2; len++) {\\n            int count = 0;\\n            for(int i = 0, j = len; j < n; i++, j++) {\\n                char ci = text.charAt(i);\\n                char cj = text.charAt(j);\\n                if(ci == cj)\\n                    count++;\\n                else count = 0;\\n                if(count == len){\\n                    long _hash = calculateHash(i, j);\\n                    set.add(_hash);\\n                    count--;\\n                }    \\n            }\\n        }\\n        return set.size();\\n    }\\n}\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3009423,
                "title": "string-hashing-brute-force",
                "content": "```\\nclass Solution:\\n    def powers(self, n, p, ip, M):\\n        pw = 1\\n        invpw = 1\\n        ppow = []\\n        invppow = []\\n        for _ in range(n):\\n            ppow.append(pw)\\n            invppow.append(invpw)\\n            pw = (pw * p) % M\\n            invpw = (invpw * ip) % M\\n        return ppow, invppow\\n    \\n    def hashes(self, s, p, M):\\n        n = len(s)\\n        h = [0] * (n + 1)\\n        for i in range(n):\\n            h[i + 1] = (h[i] + self.ppow[i] * (ord(s[i]) - ord(\\'a\\'))) % M\\n        return h\\n    \\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        n = len(text)\\n        M = 10 ** 9 + 9\\n        p = 31\\n        self.ppow, self.invppow = self.powers(n + 1, p, pow(p, M - 2, M), M)\\n        subhash = lambda h, i, j: (self.invppow[i] * (h[j + 1] + M - h[i])) % M\\n        hashes = self.hashes(text, p, M)\\n        res = set()\\n        for i in range(n):\\n            for j in range(i, (i + n) // 2):\\n                if subhash(hashes, i, j) == subhash(hashes, j + 1, 2 * j - i + 1):\\n                    res.add(text[i:j+1])\\n        return len(res)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def powers(self, n, p, ip, M):\\n        pw = 1\\n        invpw = 1\\n        ppow = []\\n        invppow = []\\n        for _ in range(n):\\n            ppow.append(pw)\\n            invppow.append(invpw)\\n            pw = (pw * p) % M\\n            invpw = (invpw * ip) % M\\n        return ppow, invppow\\n    \\n    def hashes(self, s, p, M):\\n        n = len(s)\\n        h = [0] * (n + 1)\\n        for i in range(n):\\n            h[i + 1] = (h[i] + self.ppow[i] * (ord(s[i]) - ord(\\'a\\'))) % M\\n        return h\\n    \\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        n = len(text)\\n        M = 10 ** 9 + 9\\n        p = 31\\n        self.ppow, self.invppow = self.powers(n + 1, p, pow(p, M - 2, M), M)\\n        subhash = lambda h, i, j: (self.invppow[i] * (h[j + 1] + M - h[i])) % M\\n        hashes = self.hashes(text, p, M)\\n        res = set()\\n        for i in range(n):\\n            for j in range(i, (i + n) // 2):\\n                if subhash(hashes, i, j) == subhash(hashes, j + 1, 2 * j - i + 1):\\n                    res.add(text[i:j+1])\\n        return len(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2949173,
                "title": "python-hashing-memo-solution-easy-to-understand-faster-than-60",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n```dp[start][end]``` contains the hashing value of substring ```text[start: end + 1]```\\n\\nIf ```text[start: start + substrLen]``` is equal to ```text[start + substrLen: start + substrLen * 2]```, we will have ```dp[start][start + substrLen-1] == dp[start + substrLen][start + substrLen * 2 - 1]```\\n\\nNow the things will be very simple. We just need to iterate in dp to find the differnet hash value with this condition.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```python []\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        if len(set(text)) == 1:\\n            return len(text) // 2\\n        nums = [ord(char) - ord(\\'a\\') + 1 for char in text]\\n        hashMemo = [[0] * len(text) for _ in text]\\n        hashMod, ans = 10 ** 10 + 7, set()\\n        for start in range(len(nums)):\\n            hashMemo[start][start] = nums[start]\\n            for end in range(start + 1, len(nums)):\\n                hashMemo[start][end] = (hashMemo[start][end - 1] * 26 + nums[end]) % hashMod\\n        for start in range(len(nums)):\\n            for substrLen in range(1, (len(nums) - start) // 2 + 1):\\n                if hashMemo[start][start + substrLen - 1] == hashMemo[start + substrLen][start + substrLen * 2 - 1]:\\n                    ans.add(hashMemo[start][start + substrLen - 1])\\n        return len(ans)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Dynamic Programming",
                    "Hash Function"
                ],
                "code": "```dp[start][end]```\n```text[start: end + 1]```\n```text[start: start + substrLen]```\n```text[start + substrLen: start + substrLen * 2]```\n```dp[start][start + substrLen-1] == dp[start + substrLen][start + substrLen * 2 - 1]```\n```python []\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        if len(set(text)) == 1:\\n            return len(text) // 2\\n        nums = [ord(char) - ord(\\'a\\') + 1 for char in text]\\n        hashMemo = [[0] * len(text) for _ in text]\\n        hashMod, ans = 10 ** 10 + 7, set()\\n        for start in range(len(nums)):\\n            hashMemo[start][start] = nums[start]\\n            for end in range(start + 1, len(nums)):\\n                hashMemo[start][end] = (hashMemo[start][end - 1] * 26 + nums[end]) % hashMod\\n        for start in range(len(nums)):\\n            for substrLen in range(1, (len(nums) - start) // 2 + 1):\\n                if hashMemo[start][start + substrLen - 1] == hashMemo[start + substrLen][start + substrLen * 2 - 1]:\\n                    ans.add(hashMemo[start][start + substrLen - 1])\\n        return len(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2844529,
                "title": "solution-using-sliding-window-for-for-all-length-substrings",
                "content": "Hope this might be of some help :\\n\\nApproach 1: using HashSet and Sliding window using left right pointers.\\n   \\n         public int distinctEchoSubstrings(String text) \\n\\t\\t   {\\n\\t\\t   HashSet<String> set = new HashSet();\\n         int n = text.length();\\n         for(int len = 1; len<  n/2 +1; len++){\\n             int count=0;\\n             for(int l =0,r=len;r<n;l++,r++){\\n                 if(text.charAt(l)==text.charAt(r)){\\n                     count++;\\n                 }else{\\n                     count=0;\\n                 }\\n\\n                 if(count ==len){\\n                     String str = text.substring(l,r+1);\\n                     set.add(str);\\n                     count--; //Remove first character of found echo string to check next substings of length\\n                 }\\n             }\\n         }\\n         return set.size();\\n\\t\\t }\\n\\nApproach 2 : using HashMap\\n     \\n\\t \\n         public int distinctEchoSubstrings1(String text) \\n\\t\\t {\\n\\t\\t HashMap<Integer, String> distinctMap = new HashMap();\\n         int str_len = text.length();\\n         Set<String> answers = new HashSet();\\n         int counter = 0;\\n         for(int n = 1; n < 1+str_len/2; n++)\\n         {\\n             for(int i = 0; i < str_len-n+1; i++)\\n             {\\n                 String sub = text.substring(i, i+n);\\n                 if(distinctMap.containsKey(i) && distinctMap.get(i).equals(sub))\\n                 {\\n                     answers.add(sub);\\n                 }\\n                 distinctMap.put(i+n, sub);\\n             }\\n             distinctMap.clear();\\n         }\\n         return answers.size();\\n     }",
                "solutionTags": [
                    "Java",
                    "String",
                    "Sliding Window"
                ],
                "code": "Hope this might be of some help :\\n\\nApproach 1: using HashSet and Sliding window using left right pointers.\\n   \\n         public int distinctEchoSubstrings(String text) \\n\\t\\t   {\\n\\t\\t   HashSet<String> set = new HashSet();\\n         int n = text.length();\\n         for(int len = 1; len<  n/2 +1; len++){\\n             int count=0;\\n             for(int l =0,r=len;r<n;l++,r++){\\n                 if(text.charAt(l)==text.charAt(r)){\\n                     count++;\\n                 }else{\\n                     count=0;\\n                 }\\n\\n                 if(count ==len){\\n                     String str = text.substring(l,r+1);\\n                     set.add(str);\\n                     count--; //Remove first character of found echo string to check next substings of length\\n                 }\\n             }\\n         }\\n         return set.size();\\n\\t\\t }\\n\\nApproach 2 : using HashMap\\n     \\n\\t \\n         public int distinctEchoSubstrings1(String text) \\n\\t\\t {\\n\\t\\t HashMap<Integer, String> distinctMap = new HashMap();\\n         int str_len = text.length();\\n         Set<String> answers = new HashSet();\\n         int counter = 0;\\n         for(int n = 1; n < 1+str_len/2; n++)\\n         {\\n             for(int i = 0; i < str_len-n+1; i++)\\n             {\\n                 String sub = text.substring(i, i+n);\\n                 if(distinctMap.containsKey(i) && distinctMap.get(i).equals(sub))\\n                 {\\n                     answers.add(sub);\\n                 }\\n                 distinctMap.put(i+n, sub);\\n             }\\n             distinctMap.clear();\\n         }\\n         return answers.size();\\n     }",
                "codeTag": "Unknown"
            },
            {
                "id": 2776903,
                "title": "python-simple-and-intuitive-solution-dp-hash-time-o-n-2",
                "content": "```\\ndp[i][j] means the hashing value of substring text[i:j+1]\\nIf text[i:i+w] == text[i+w:i+w*2], we will have dp[i][i+w-1] == dp[i+w][i+w*2-1]\\nNow the things will be very simple.\\nWe just need to iterate in dp to find the differnet hash value with this condition.\\n```\\n\\n```\\ndef distinctEchoSubstrings(self, text: str) -> int:\\n\\tif len(set(text)) == 1:\\n\\t\\treturn len(text)//2\\n\\n\\tnums = [ord(c)-ord(\\'a\\')+1 for c in text]\\n\\tdp = [[0]*len(text) for _ in text]\\n\\tmod, ans = 10**10+7, set()\\n\\t\\n\\t# pre-caching the hash value with all possibilities\\n\\tfor i in range(len(nums)):\\n\\t\\tdp[i][i] = nums[i]\\n\\t\\tfor j in range(i+1, len(nums)):\\n\\t\\t\\tdp[i][j] = (dp[i][j-1]*26+nums[j])%mod\\n\\t\\n\\t# finding different hash value in specific conditions\\n\\tfor i in range(len(nums)):\\n\\t\\tfor w in range(1, (len(nums)-i)//2+1):\\n\\t\\t\\tif dp[i][i+w-1] == dp[i+w][i+w*2-1]:\\n\\t\\t\\t\\tans.add(dp[i][i+w-1])\\n\\treturn len(ans)\\n```",
                "solutionTags": [],
                "code": "```\\ndp[i][j] means the hashing value of substring text[i:j+1]\\nIf text[i:i+w] == text[i+w:i+w*2], we will have dp[i][i+w-1] == dp[i+w][i+w*2-1]\\nNow the things will be very simple.\\nWe just need to iterate in dp to find the differnet hash value with this condition.\\n```\n```\\ndef distinctEchoSubstrings(self, text: str) -> int:\\n\\tif len(set(text)) == 1:\\n\\t\\treturn len(text)//2\\n\\n\\tnums = [ord(c)-ord(\\'a\\')+1 for c in text]\\n\\tdp = [[0]*len(text) for _ in text]\\n\\tmod, ans = 10**10+7, set()\\n\\t\\n\\t# pre-caching the hash value with all possibilities\\n\\tfor i in range(len(nums)):\\n\\t\\tdp[i][i] = nums[i]\\n\\t\\tfor j in range(i+1, len(nums)):\\n\\t\\t\\tdp[i][j] = (dp[i][j-1]*26+nums[j])%mod\\n\\t\\n\\t# finding different hash value in specific conditions\\n\\tfor i in range(len(nums)):\\n\\t\\tfor w in range(1, (len(nums)-i)//2+1):\\n\\t\\t\\tif dp[i][i+w-1] == dp[i+w][i+w*2-1]:\\n\\t\\t\\t\\tans.add(dp[i][i+w-1])\\n\\treturn len(ans)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2633629,
                "title": "python-solution-hash-wisely",
                "content": "Initially I thought this problem is similar to [1044. Longest Duplicate Substring](https://leetcode.com/problems/longest-duplicate-substring/), but it is actually quite different.\\n\\nI felt annoyed because the Rabin-Karp algorithm, although correct, is just slow and even loses to the brute force string comparison solutions. In the end I used the known position of each starting character and just brute force test every possible pairs.\\n\\n```\\n# Rabin-Karp: TLE\\nclass Solution:\\n    # Use Rabin-Karp rolling hash to solve the problem\\n    # So the rolling hash function can convert a substring with any length into a hash value\\n    # Therefore, the art is to check all possible substring length (1 to n//2)\\n    # Use a hash table to store appeared hash value and index\\n    # If see a match, check if text[i:i+l] == text[i+l:i+2*l]\\n    # add length of hash set to result\\n    \\n    # Calculate rolling hash value according Rabin-Karp\\n    def rolling_hash(self, i, size, seed):\\n        h = seed\\n        if i == 0:\\n            for j in range(size):\\n                h *= self.base\\n                h += ord(self.string[i+j])-ord(\\'a\\')\\n                h %= self.MOD\\n        else:\\n            h -= (ord(self.string[i-1])-ord(\\'a\\'))*self.lookup[size-1]\\n            h *= self.base\\n            h += ord(self.string[i+size-1])-ord(\\'a\\')\\n            h %= self.MOD\\n        return h\\n    \\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        # Base chosen: must be larger than maximum of value of s, preferably prime; Mod: large enough to avoid overflow, should be prime\\n        self.base, self.MOD, n, self.string, result = 29, pow(2,31)-1, len(text), text, 0\\n        # Generate a lookup table for pow(self.base, 0:len(s)) % self.MOD\\n        self.lookup = []\\n        seed = 1\\n        for i in range(n):\\n            self.lookup.append(seed)\\n            seed *= self.base\\n            seed %= self.MOD\\n        first_hash_value = [0]\\n        \\n        for l in range(1,n//2+1,1):\\n            hash_table, result_set = {}, set()\\n            for j in range(n-l+1):\\n                if j > 0:\\n                    hash_value = self.rolling_hash(j, l, hash_value)\\n                else:\\n                    hash_value = first_hash_value[-1]\\n                    hash_value *= self.base\\n                    hash_value += ord(self.string[l-1])-ord(\\'a\\')\\n                    hash_value %= self.MOD\\n                    first_hash_value.append(hash_value)\\n                \\n                if hash_value not in hash_table:\\n                    hash_table[hash_value] = set()\\n                hash_table[hash_value].add(j)\\n                if j - l in hash_table[hash_value] and text[j-l:j] == text[j:j+l]:\\n                    result_set.add(text[j-l:j])\\n            result += len(result_set)\\n        return result\\n\\n# Smart hashing\\nclass Solution:\\n    # As Rabin-Karp is kind of brute-forceish and slow, I use another approach to handle the problem\\n    # For example like \"abcabcabc\", any echo substrings must have the same first letter at the starts of the repeats\\n    # So I first record the appearance of each letter.\\n    # Then if len(occur[letter]) > 1, I ask all pairwise occurences of letter if the two back-to-back strings starting at each position are the same\\n    \\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        occur, n = [[] for i in range(26)], len(text)\\n        for i, c in enumerate(text):\\n            occur[ord(c) - ord(\\'a\\')].append(i)\\n        \\n        result_set = set()\\n        for letter in range(26):\\n            l = len(occur[letter])\\n            if l <= 1:\\n                continue\\n            for i in range(l-1):\\n                for j in range(i+1,l):\\n                    start, end = occur[letter][i], occur[letter][j]\\n                    if 2*end - start > n:\\n                        break\\n                    if text[start:end] == text[end:2*end-start]:\\n                        result_set.add(text[start:end])\\n        return len(result_set)\\n```",
                "solutionTags": [],
                "code": "```\\n# Rabin-Karp: TLE\\nclass Solution:\\n    # Use Rabin-Karp rolling hash to solve the problem\\n    # So the rolling hash function can convert a substring with any length into a hash value\\n    # Therefore, the art is to check all possible substring length (1 to n//2)\\n    # Use a hash table to store appeared hash value and index\\n    # If see a match, check if text[i:i+l] == text[i+l:i+2*l]\\n    # add length of hash set to result\\n    \\n    # Calculate rolling hash value according Rabin-Karp\\n    def rolling_hash(self, i, size, seed):\\n        h = seed\\n        if i == 0:\\n            for j in range(size):\\n                h *= self.base\\n                h += ord(self.string[i+j])-ord(\\'a\\')\\n                h %= self.MOD\\n        else:\\n            h -= (ord(self.string[i-1])-ord(\\'a\\'))*self.lookup[size-1]\\n            h *= self.base\\n            h += ord(self.string[i+size-1])-ord(\\'a\\')\\n            h %= self.MOD\\n        return h\\n    \\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        # Base chosen: must be larger than maximum of value of s, preferably prime; Mod: large enough to avoid overflow, should be prime\\n        self.base, self.MOD, n, self.string, result = 29, pow(2,31)-1, len(text), text, 0\\n        # Generate a lookup table for pow(self.base, 0:len(s)) % self.MOD\\n        self.lookup = []\\n        seed = 1\\n        for i in range(n):\\n            self.lookup.append(seed)\\n            seed *= self.base\\n            seed %= self.MOD\\n        first_hash_value = [0]\\n        \\n        for l in range(1,n//2+1,1):\\n            hash_table, result_set = {}, set()\\n            for j in range(n-l+1):\\n                if j > 0:\\n                    hash_value = self.rolling_hash(j, l, hash_value)\\n                else:\\n                    hash_value = first_hash_value[-1]\\n                    hash_value *= self.base\\n                    hash_value += ord(self.string[l-1])-ord(\\'a\\')\\n                    hash_value %= self.MOD\\n                    first_hash_value.append(hash_value)\\n                \\n                if hash_value not in hash_table:\\n                    hash_table[hash_value] = set()\\n                hash_table[hash_value].add(j)\\n                if j - l in hash_table[hash_value] and text[j-l:j] == text[j:j+l]:\\n                    result_set.add(text[j-l:j])\\n            result += len(result_set)\\n        return result\\n\\n# Smart hashing\\nclass Solution:\\n    # As Rabin-Karp is kind of brute-forceish and slow, I use another approach to handle the problem\\n    # For example like \"abcabcabc\", any echo substrings must have the same first letter at the starts of the repeats\\n    # So I first record the appearance of each letter.\\n    # Then if len(occur[letter]) > 1, I ask all pairwise occurences of letter if the two back-to-back strings starting at each position are the same\\n    \\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        occur, n = [[] for i in range(26)], len(text)\\n        for i, c in enumerate(text):\\n            occur[ord(c) - ord(\\'a\\')].append(i)\\n        \\n        result_set = set()\\n        for letter in range(26):\\n            l = len(occur[letter])\\n            if l <= 1:\\n                continue\\n            for i in range(l-1):\\n                for j in range(i+1,l):\\n                    start, end = occur[letter][i], occur[letter][j]\\n                    if 2*end - start > n:\\n                        break\\n                    if text[start:end] == text[end:2*end-start]:\\n                        result_set.add(text[start:end])\\n        return len(result_set)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2614683,
                "title": "python-trie-clean-short",
                "content": "```\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        tr={}\\n        n=len(text)\\n        ans=set()\\n        for i in range(n):\\n            cur=tr\\n            for j in range(i,n):\\n                ch=text[j]\\n                cur=cur.setdefault(ch,{})\\n                cur[j]=True\\n                if i-1 in cur:\\n                    ans.add(text[i:j+1])\\n        return len(ans)\\n",
                "solutionTags": [
                    "Trie"
                ],
                "code": "class Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        tr={}",
                "codeTag": "Java"
            },
            {
                "id": 2592489,
                "title": "dynamic-programming-rolling-hash-easy-to-understand",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        int n = text.size();\\n        ll dp[n][n];\\n        memset(dp, -1, sizeof(dp));\\n        for(int k = 0; k < n; k++){\\n            dp[k][0] = text[k] - \\'a\\' + 1;\\n        }\\n        ll p = 71, m = 1e9+7;\\n        ll pows[n+1];\\n        pows[0] = 1;\\n        for(int i = 1; i <= n; i++){\\n            pows[i] = (p * pows[i-1])%m;\\n        }\\n        for(int k = 1; k < n; k++){\\n            for(int i = 0; i + k < n; i++){\\n                dp[i][k] = (dp[i][k-1] + pows[k]*(dp[i+k][0]))%m;\\n            }\\n        }\\n        int count = 0;\\n        set<int> st;\\n        for(int i = 0; i < n; i++){\\n            for(int k = 0; k+i+1< n; k++){\\n                if ((dp[i][k] == dp[i+k+1][k]) && dp[i][k] >= 0){\\n                    st.insert(dp[i][k]);\\n                }\\n            }\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        int n = text.size();\\n        ll dp[n][n];\\n        memset(dp, -1, sizeof(dp));\\n        for(int k = 0; k < n; k++){\\n            dp[k][0] = text[k] - \\'a\\' + 1;\\n        }\\n        ll p = 71, m = 1e9+7;\\n        ll pows[n+1];\\n        pows[0] = 1;\\n        for(int i = 1; i <= n; i++){\\n            pows[i] = (p * pows[i-1])%m;\\n        }\\n        for(int k = 1; k < n; k++){\\n            for(int i = 0; i + k < n; i++){\\n                dp[i][k] = (dp[i][k-1] + pows[k]*(dp[i+k][0]))%m;\\n            }\\n        }\\n        int count = 0;\\n        set<int> st;\\n        for(int i = 0; i < n; i++){\\n            for(int k = 0; k+i+1< n; k++){\\n                if ((dp[i][k] == dp[i+k+1][k]) && dp[i][k] >= 0){\\n                    st.insert(dp[i][k]);\\n                }\\n            }\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2569065,
                "title": "java-faster-than-97-hash-code-of-substrings",
                "content": "```\\nclass Solution {\\n    long hash[];\\n    long pow[];\\n    long r=256;\\n    long mod=(long)Math.pow(10,9)+7;\\n    public void process(String s,int n)\\n    {\\n        hash=new long[n];\\n        pow=new long[n];\\n        pow[0]=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            hash[i]=(hash[i-1]*r+s.charAt(i))%mod;\\n            pow[i]=(pow[i-1]*r)%mod;\\n        }\\n    }\\n    public long calc(int l,int r)\\n    {\\n        long hashValue=(hash[r]-hash[l]*pow[r-l]%mod+mod)%mod;\\n        return hashValue;\\n    }\\n    public int distinctEchoSubstrings(String text) {\\n        int n=text.length();\\n        process(text,n);\\n        HashSet<Long> hset=new HashSet<>();\\n        for(int len=1;len<=n/2;len++)\\n        {\\n            int c=0;\\n            for(int l=0,r=len;r<n;l++,r++)\\n            {\\n                if(text.charAt(l)==text.charAt(r))\\n                {\\n                   c++; \\n                }\\n                else\\n                {\\n                    c=0;\\n                }\\n                if(c==len)\\n                {\\n                    long hv=calc(l,r);\\n                    hset.add(hv);\\n                    c--;\\n                }\\n            }\\n        }\\n        return hset.size();\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    long hash[];\\n    long pow[];\\n    long r=256;\\n    long mod=(long)Math.pow(10,9)+7;\\n    public void process(String s,int n)\\n    {\\n        hash=new long[n];\\n        pow=new long[n];\\n        pow[0]=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            hash[i]=(hash[i-1]*r+s.charAt(i))%mod;\\n            pow[i]=(pow[i-1]*r)%mod;\\n        }\\n    }\\n    public long calc(int l,int r)\\n    {\\n        long hashValue=(hash[r]-hash[l]*pow[r-l]%mod+mod)%mod;\\n        return hashValue;\\n    }\\n    public int distinctEchoSubstrings(String text) {\\n        int n=text.length();\\n        process(text,n);\\n        HashSet<Long> hset=new HashSet<>();\\n        for(int len=1;len<=n/2;len++)\\n        {\\n            int c=0;\\n            for(int l=0,r=len;r<n;l++,r++)\\n            {\\n                if(text.charAt(l)==text.charAt(r))\\n                {\\n                   c++; \\n                }\\n                else\\n                {\\n                    c=0;\\n                }\\n                if(c==len)\\n                {\\n                    long hv=calc(l,r);\\n                    hset.add(hv);\\n                    c--;\\n                }\\n            }\\n        }\\n        return hset.size();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2467581,
                "title": "clean-java-sliding-window",
                "content": "```Java\\nclass Solution {\\n    public int distinctEchoSubstrings(String text) {\\n        int ans = 0, n = text.length()/2;\\n        for (int i = 1; i <= n; i++){ // i = length\\n            Set<String> seen = new HashSet<>();\\n            for (int j = 0, k = j+i, ok = 0; k < text.length(); j++, k++){ // j = start of 1st part, k = start of 2nd part.\\n                if (text.charAt(j) == text.charAt(k)){ // matched\\n                    ok++;\\n                }\\n                if (j >= i && text.charAt(j-i) == text.charAt(k-i)){ // was matched, but out of bound now, so delete 1\\n                    ok--;\\n                }\\n                if (j >= i-1 && ok == i && seen.add(text.substring(j-i+1,j+1))){ // if it echoes and we\\'ve not seen it, add 1 to ans\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```Java\\nclass Solution {\\n    public int distinctEchoSubstrings(String text) {\\n        int ans = 0, n = text.length()/2;\\n        for (int i = 1; i <= n; i++){ // i = length\\n            Set<String> seen = new HashSet<>();\\n            for (int j = 0, k = j+i, ok = 0; k < text.length(); j++, k++){ // j = start of 1st part, k = start of 2nd part.\\n                if (text.charAt(j) == text.charAt(k)){ // matched\\n                    ok++;\\n                }\\n                if (j >= i && text.charAt(j-i) == text.charAt(k-i)){ // was matched, but out of bound now, so delete 1\\n                    ok--;\\n                }\\n                if (j >= i-1 && ok == i && seen.add(text.substring(j-i+1,j+1))){ // if it echoes and we\\'ve not seen it, add 1 to ans\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2418959,
                "title": "python-just-brute-force",
                "content": "```\\n    def distinctEchoSubstrings(self, text):\\n        seen = set()\\n        for i in range(len(text)):\\n            for j in range(i+1, len(text), 2):\\n                s = text[i:(i+j)//2+1]\\n                if s not in seen and s == text[(i+j)//2+1:j+1]:\\n                    seen.add(s)\\n        return len(seen)\\n```",
                "solutionTags": [],
                "code": "```\\n    def distinctEchoSubstrings(self, text):\\n        seen = set()\\n        for i in range(len(text)):\\n            for j in range(i+1, len(text), 2):\\n                s = text[i:(i+j)//2+1]\\n                if s not in seen and s == text[(i+j)//2+1:j+1]:\\n                    seen.add(s)\\n        return len(seen)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2392957,
                "title": "rust-solution-using-rolling-hash",
                "content": "We can compare two strings O(1) using the rolling hash.\\nThe max string size is 2000, it\\'s enough small to memorize all substring hash.\\n\\n```\\nuse std::collections::*;\\nimpl Solution {\\n    pub fn distinct_echo_substrings(text: String) -> i32 {\\n        const MOD:usize = 2usize.pow(61)-1;  // big prime number\\n\\n        let n = text.len();\\n        let s = text.chars().collect::<Vec<char>>();\\n        let s = s.into_iter().map(|v| (v as u8 - \\'a\\' as u8) as usize).collect::<Vec<usize>>();\\n\\n        let value_pattern = 26; // a-z\\n        // memo[start][end]\\n        let mut memo = vec![vec![0;n];n];\\n        for i in 0..n {\\n            let mut hash = 0usize;\\n            for j in i..n {\\n                let c = s[j];\\n                hash = (hash * (value_pattern+1) + c+1) % MOD;\\n                memo[i][j] = hash;\\n            }\\n        }\\n\\n        let mut set = HashSet::new();\\n        for firat_start in 0..n {\\n            for first_end in firat_start..n {\\n                let len = first_end - firat_start + 1;\\n                let second_start = first_end+1;\\n                let second_end = first_end+len;\\n                if n <= second_end { break }\\n                let v1 = memo[firat_start][first_end];\\n                let v2 = memo[second_start][second_end];\\n                if v1 == v2 {\\n                    set.insert(v1);\\n                }\\n            }\\n        }\\n\\n        set.len() as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Rolling Hash"
                ],
                "code": "```\\nuse std::collections::*;\\nimpl Solution {\\n    pub fn distinct_echo_substrings(text: String) -> i32 {\\n        const MOD:usize = 2usize.pow(61)-1;  // big prime number\\n\\n        let n = text.len();\\n        let s = text.chars().collect::<Vec<char>>();\\n        let s = s.into_iter().map(|v| (v as u8 - \\'a\\' as u8) as usize).collect::<Vec<usize>>();\\n\\n        let value_pattern = 26; // a-z\\n        // memo[start][end]\\n        let mut memo = vec![vec![0;n];n];\\n        for i in 0..n {\\n            let mut hash = 0usize;\\n            for j in i..n {\\n                let c = s[j];\\n                hash = (hash * (value_pattern+1) + c+1) % MOD;\\n                memo[i][j] = hash;\\n            }\\n        }\\n\\n        let mut set = HashSet::new();\\n        for firat_start in 0..n {\\n            for first_end in firat_start..n {\\n                let len = first_end - firat_start + 1;\\n                let second_start = first_end+1;\\n                let second_end = first_end+len;\\n                if n <= second_end { break }\\n                let v1 = memo[firat_start][first_end];\\n                let v2 = memo[second_start][second_end];\\n                if v1 == v2 {\\n                    set.insert(v1);\\n                }\\n            }\\n        }\\n\\n        set.len() as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2351050,
                "title": "easy-c-solution-two-pointer",
                "content": "Time complexity : O ( N ^ 3 )\\nSpace complexity : O ( N ) \\n```\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        set<string> s ;\\n        int n = text.size() ;\\n        \\n        for(int len = 1 ; len <= n / 2 ; len++){\\n            int cnt = 0 ;\\n            for(int l = 0 , r = len ; r < n ; l++,r++){\\n                if ( text[l] == text[r] ){\\n                    cnt++;\\n                }\\n                else cnt = 0;\\n                \\n                if( cnt == len ){\\n                    string t = text.substr(l - len + 1, len);\\n                    s.insert(t);\\n                    cnt--;\\n                }\\n            }\\n        }\\n        \\n        return s.size();\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        set<string> s ;\\n        int n = text.size() ;\\n        \\n        for(int len = 1 ; len <= n / 2 ; len++){\\n            int cnt = 0 ;\\n            for(int l = 0 , r = len ; r < n ; l++,r++){\\n                if ( text[l] == text[r] ){\\n                    cnt++;\\n                }\\n                else cnt = 0;\\n                \\n                if( cnt == len ){\\n                    string t = text.substr(l - len + 1, len);\\n                    s.insert(t);\\n                    cnt--;\\n                }\\n            }\\n        }\\n        \\n        return s.size();\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2316787,
                "title": "java-simple-working-solution-with-comments",
                "content": "```\\nimport java.util.Map.Entry;\\npublic class Solution {\\n    public int distinctEchoSubstrings(String text) {\\n        HashSet<String> ans = new HashSet<>();\\n        int length = text.length();\\n\\n        HashMap<Character, ArrayList<Integer>> characterPositionMap = new HashMap<>(); // Map to store the position of each characters                                                                                       \\n\\n        for (int i = 0; i < length; i++) {\\n            characterPositionMap.computeIfAbsent(text.charAt(i), x -> new ArrayList<>()).add(i);\\n        }\\n\\n        for (Entry<Character, ArrayList<Integer>> entry : characterPositionMap.entrySet()) { // Iterate through each character in the map\\n            ArrayList<Integer> positions = entry.getValue(); // Get the positions of the character\\n            for (int i = 0; i < positions.size(); i++) { // Iterate through each position of the character\\n                int first = positions.get(i); // Get the first position of the character\\n                for (int j = i + 1; j < positions.size(); j++) { // Iterate through each position of the remaining character\\n                    int mid = positions.get(j);// Get the second position of the character\\n                    int last = mid + mid - first; // Get the last position of the character\\n                    String subString1 = text.substring(first, mid);// Get the first substring of the character\\n                    if (last <= length) {// Check if the last position is within the length of the string\\n                        String subString2 = text.substring(mid, last);// Get the second substring of the character\\n                        if (subString1.equals(subString2)) {// Check if the two substrings are equal\\n                            ans.add(subString1);// Add the substring to the set\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans.size();// Return the size of the set\\n\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.Map.Entry;\\npublic class Solution {\\n    public int distinctEchoSubstrings(String text) {\\n        HashSet<String> ans = new HashSet<>();\\n        int length = text.length();\\n\\n        HashMap<Character, ArrayList<Integer>> characterPositionMap = new HashMap<>(); // Map to store the position of each characters                                                                                       \\n\\n        for (int i = 0; i < length; i++) {\\n            characterPositionMap.computeIfAbsent(text.charAt(i), x -> new ArrayList<>()).add(i);\\n        }\\n\\n        for (Entry<Character, ArrayList<Integer>> entry : characterPositionMap.entrySet()) { // Iterate through each character in the map\\n            ArrayList<Integer> positions = entry.getValue(); // Get the positions of the character\\n            for (int i = 0; i < positions.size(); i++) { // Iterate through each position of the character\\n                int first = positions.get(i); // Get the first position of the character\\n                for (int j = i + 1; j < positions.size(); j++) { // Iterate through each position of the remaining character\\n                    int mid = positions.get(j);// Get the second position of the character\\n                    int last = mid + mid - first; // Get the last position of the character\\n                    String subString1 = text.substring(first, mid);// Get the first substring of the character\\n                    if (last <= length) {// Check if the last position is within the length of the string\\n                        String subString2 = text.substring(mid, last);// Get the second substring of the character\\n                        if (subString1.equals(subString2)) {// Check if the two substrings are equal\\n                            ans.add(subString1);// Add the substring to the set\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans.size();// Return the size of the set\\n\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2304171,
                "title": "c-solution-based-on-sliding-window-and-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        \\n        int n = text.size();\\n        int max_sliding;\\n        if (n % 2 == 0){\\n            max_sliding = n;\\n        }\\n        else{\\n            max_sliding = n - 1;\\n        }\\n        char max_c = text[0], min_c = text[0];\\n        for (int i = 1; i < n; i++){\\n            max_c = max(max_c, text[i]);\\n            min_c = min(min_c, text[i]);\\n        }\\n        if (max_c == min_c){\\n            return max_sliding / 2;\\n        }\\n        \\n        unordered_set<string> records;\\n        for (int sliding = max_sliding; sliding >= 2; sliding = sliding - 2){\\n            int half_sliding = sliding / 2;\\n            for (int start = 0; start <= n - sliding; start++){\\n                int back = start + sliding - 1;\\n                int middle = start + half_sliding - 1;\\n                // [start, back], whether the substring is echo?\\n                bool is_echo = true;\\n                for (int i = 0; i < half_sliding; i++){\\n                    if (text[start + i] != text[middle + 1 + i]){\\n                        is_echo = false;\\n                        break;\\n                    }\\n                }\\n                if (is_echo){\\n                    string sub = text.substr(start, half_sliding);\\n                    if (records.count(sub) == 0){\\n                        records.insert(sub);       \\n                    }                    \\n                }\\n            }\\n        }\\n        return records.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        \\n        int n = text.size();\\n        int max_sliding;\\n        if (n % 2 == 0){\\n            max_sliding = n;\\n        }\\n        else{\\n            max_sliding = n - 1;\\n        }\\n        char max_c = text[0], min_c = text[0];\\n        for (int i = 1; i < n; i++){\\n            max_c = max(max_c, text[i]);\\n            min_c = min(min_c, text[i]);\\n        }\\n        if (max_c == min_c){\\n            return max_sliding / 2;\\n        }\\n        \\n        unordered_set<string> records;\\n        for (int sliding = max_sliding; sliding >= 2; sliding = sliding - 2){\\n            int half_sliding = sliding / 2;\\n            for (int start = 0; start <= n - sliding; start++){\\n                int back = start + sliding - 1;\\n                int middle = start + half_sliding - 1;\\n                // [start, back], whether the substring is echo?\\n                bool is_echo = true;\\n                for (int i = 0; i < half_sliding; i++){\\n                    if (text[start + i] != text[middle + 1 + i]){\\n                        is_echo = false;\\n                        break;\\n                    }\\n                }\\n                if (is_echo){\\n                    string sub = text.substr(start, half_sliding);\\n                    if (records.count(sub) == 0){\\n                        records.insert(sub);       \\n                    }                    \\n                }\\n            }\\n        }\\n        return records.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260249,
                "title": "python-simple-maths",
                "content": "\\n    def distinctEchoSubstrings(self, text):\\n        count, seen = 0, set()\\n        \\n        for k in range(1, len(text)//2 + 1):\\n            for i in range(len(text) - k):\\n                s1 = text[i:i+k]\\n                s2 = text[i+k:i+2*k]\\n                \\n                if s1 == s2 and s1 not in seen:\\n                    count += 1\\n                    seen.add(s1)\\n                    \\n            seen = set()\\n\\t\\t\\n        return count",
                "solutionTags": [],
                "code": "\\n    def distinctEchoSubstrings(self, text):\\n        count, seen = 0, set()\\n        \\n        for k in range(1, len(text)//2 + 1):\\n            for i in range(len(text) - k):\\n                s1 = text[i:i+k]\\n                s2 = text[i+k:i+2*k]\\n                \\n                if s1 == s2 and s1 not in seen:\\n                    count += 1\\n                    seen.add(s1)\\n                    \\n            seen = set()\\n\\t\\t\\n        return count",
                "codeTag": "Python3"
            },
            {
                "id": 2245656,
                "title": "roling-hash-prefix-sum-easy-to-understand",
                "content": "Check Echo string of Every length 1 2 3 ........... n\\nThen caluculate the hash value of every substring of length L. \\nS[0],S[1].....S[L].........S[2*L-1] ..............S[n-1]\\nif hash value of S[2L-1]==S[L] then we got the ECHO string and insert the hash value in set, then return the size of set.\\n*\\n**Then add all the length of Echo string and return it:**\\n\\n\\n\\t\\t\\t\\t\\t\\tclass Solution {\\n\\t\\t\\t\\t\\t\\tpublic:\\n\\t\\t\\t\\t\\t\\t\\tconst long long int p=1299827;\\n\\t\\t\\t\\t\\t\\t\\tconst long long int mod=1e11+7;\\n\\t\\t\\t\\t\\t\\t\\tint fn(int l,string &s){\\n\\t\\t\\t\\t\\t\\t\\t\\tlong long int crr_hash=0,pow=1,tmp;\\n\\t\\t\\t\\t\\t\\t\\t\\tint n=s.size();\\n\\t\\t\\t\\t\\t\\t\\t\\t set<long long int>ans;\\n\\t\\t\\t\\t\\t\\t\\t\\tvector<long long int> v(n);\\n\\t\\t\\t\\t\\t\\t\\t\\tfor(int i=0;i<(l);i++){\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcrr_hash=(crr_hash*p)%mod;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcrr_hash+=(s[i]-\\'a\\'+1);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcrr_hash%=mod;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(i!=l-1) pow=(pow*p)%mod;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tv[i]=crr_hash;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tv[l-1]=crr_hash;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tfor(int i=l;i<n;i++){\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcrr_hash+=mod;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcrr_hash-=((s[i-l]-\\'a\\'+1)*(pow))%mod;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcrr_hash+=mod; crr_hash%=mod;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcrr_hash=(crr_hash*p)%mod;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcrr_hash+=(s[i]-\\'a\\'+1);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcrr_hash%=mod;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tv[i]=crr_hash;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(i-2*l+1>=0){\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tlong long int s1=0,s2=0;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\ts1=v[i];\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\ts2=v[i-l];\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif(s1==s2) { ans.insert(s1);}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\treturn ans.size();\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tint distinctEchoSubstrings(string s) {\\n\\t\\t\\t\\t\\t\\t\\t\\tint n=s.size();\\n\\t\\t\\t\\t\\t\\t\\t\\tint ans=0;\\n\\t\\t\\t\\t\\t\\t\\t\\tfor(int i=1;i<=n/2;i++){\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tint k=fn(i,s);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tans+=k;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// cout<<k<<\" \";\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\treturn ans;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t};",
                "solutionTags": [
                    "Rolling Hash"
                ],
                "code": "class Solution {\\n\\t\\t\\t\\t\\t\\tpublic:\\n\\t\\t\\t\\t\\t\\t\\tconst long long int p=1299827;\\n\\t\\t\\t\\t\\t\\t\\tconst long long int mod=1e11+7;\\n\\t\\t\\t\\t\\t\\t\\tint fn(int l,string &s){\\n\\t\\t\\t\\t\\t\\t\\t\\tlong long int crr_hash=0,pow=1,tmp;\\n\\t\\t\\t\\t\\t\\t\\t\\tint n=s.size();\\n\\t\\t\\t\\t\\t\\t\\t\\t set<long long int>ans;\\n\\t\\t\\t\\t\\t\\t\\t\\tvector<long long int> v(n);\\n\\t\\t\\t\\t\\t\\t\\t\\tfor(int i=0;i<(l);i++){\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcrr_hash=(crr_hash*p)%mod;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcrr_hash+=(s[i]-\\'a\\'+1);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcrr_hash%=mod;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(i!=l-1) pow=(pow*p)%mod;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tv[i]=crr_hash;\\n\\t\\t\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2207514,
                "title": "rabin-karp-map-set-self-explanatory-easy-code-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        int n = text.size();\\n        unordered_set<string> st;\\n        int ans = 0;\\n        for (int i = 1; i < n; i++)\\n            if (text[i - 1] == text[i]) {\\n                string h;\\n                h.push_back(text[i - 1]);\\n                st.insert(h);\\n            }\\n        unordered_map<long long int, int> mp;\\n        for (int k = 2; 2 * k <= n; k++) {\\n            long long int temp1 = 0, temp2 = 0, t = 1, p = 31, mod = 1000000007;\\n            int i = 0, j = k - 1, r = 2 * k - 1;\\n            for (int y = 0; y < k; y++) {\\n                temp1 = temp1 + t * (text[y] - \\'a\\' + 1);\\n                temp2 = temp2 + t * (text[y + k] - \\'a\\' + 1);\\n                temp1 = temp1 % mod;\\n                temp2 = temp2 % mod;\\n                t = t * p;\\n                t = t % mod;\\n            }\\n            t /= p;\\n            while (r < n) {\\n                if (temp1 == temp2 && mp[temp1] == 0) {\\n                    mp[temp1]++;\\n                    // cout << text.substr(i, k) << endl;\\n                    string w1 = text.substr(i, k) , w2 = text.substr(i + k, k);\\n                    if (w1 == w2)\\n                        st.insert(w1);\\n                }\\n                // cout << \"temp1 = \" << temp1 << \" temp2 = \" << temp2 << \" s1 = \" << text.substr(i, k) << \" s2 = \" << text.substr(i + k, k) << endl;\\n                \\n                temp1 -= (text[i] - \\'a\\' + 1);\\n                temp2 -= (text[i + k] - \\'a\\' + 1);\\n                // cout << \"1 temp1 = \"<< temp1 << \" temp2 = \" << temp2 << endl;\\n                temp1 /= p;\\n                temp2 /= p;\\n                // cout << \"2 temp1 = \"<< temp1 << \" temp2 = \" << temp2 << endl;\\n                \\n                i++;\\n                j++;\\n                r++;\\n                \\n                if (r < n) {\\n                    temp1 += t * (text[j] - \\'a\\' + 1);\\n                    temp2 += t * (text[r] - \\'a\\' + 1);\\n                    // cout << \"3 - temp1add = \"<< t * (text[j] - \\'a\\' + 1) << \" temp2add = \" << t * (text[r] - \\'a\\' + 1) << endl;\\n                    temp1 %= mod;\\n                    temp2 %= mod;\\n                }\\n            }\\n        }\\n        // for (string g : st)\\n        //     cout << g << endl;\\n        return st.size();// + mp.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        int n = text.size();\\n        unordered_set<string> st;\\n        int ans = 0;\\n        for (int i = 1; i < n; i++)\\n            if (text[i - 1] == text[i]) {\\n                string h;\\n                h.push_back(text[i - 1]);\\n                st.insert(h);\\n            }\\n        unordered_map<long long int, int> mp;\\n        for (int k = 2; 2 * k <= n; k++) {\\n            long long int temp1 = 0, temp2 = 0, t = 1, p = 31, mod = 1000000007;\\n            int i = 0, j = k - 1, r = 2 * k - 1;\\n            for (int y = 0; y < k; y++) {\\n                temp1 = temp1 + t * (text[y] - \\'a\\' + 1);\\n                temp2 = temp2 + t * (text[y + k] - \\'a\\' + 1);\\n                temp1 = temp1 % mod;\\n                temp2 = temp2 % mod;\\n                t = t * p;\\n                t = t % mod;\\n            }\\n            t /= p;\\n            while (r < n) {\\n                if (temp1 == temp2 && mp[temp1] == 0) {\\n                    mp[temp1]++;\\n                    // cout << text.substr(i, k) << endl;\\n                    string w1 = text.substr(i, k) , w2 = text.substr(i + k, k);\\n                    if (w1 == w2)\\n                        st.insert(w1);\\n                }\\n                // cout << \"temp1 = \" << temp1 << \" temp2 = \" << temp2 << \" s1 = \" << text.substr(i, k) << \" s2 = \" << text.substr(i + k, k) << endl;\\n                \\n                temp1 -= (text[i] - \\'a\\' + 1);\\n                temp2 -= (text[i + k] - \\'a\\' + 1);\\n                // cout << \"1 temp1 = \"<< temp1 << \" temp2 = \" << temp2 << endl;\\n                temp1 /= p;\\n                temp2 /= p;\\n                // cout << \"2 temp1 = \"<< temp1 << \" temp2 = \" << temp2 << endl;\\n                \\n                i++;\\n                j++;\\n                r++;\\n                \\n                if (r < n) {\\n                    temp1 += t * (text[j] - \\'a\\' + 1);\\n                    temp2 += t * (text[r] - \\'a\\' + 1);\\n                    // cout << \"3 - temp1add = \"<< t * (text[j] - \\'a\\' + 1) << \" temp2add = \" << t * (text[r] - \\'a\\' + 1) << endl;\\n                    temp1 %= mod;\\n                    temp2 %= mod;\\n                }\\n            }\\n        }\\n        // for (string g : st)\\n        //     cout << g << endl;\\n        return st.size();// + mp.size();\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2195128,
                "title": "cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        \\n        int p=31;\\n        int m=1e9+9;\\n        int len=text.size();\\n        \\n        vector<long long int> p_pow(len,1);\\n        for(int i=1;i<len;i++)\\n            p_pow[i]=(p_pow[i-1]*p)%m;\\n        \\n        vector<long long int> h(len+1,0);\\n        for(int i=0;i<len;i++)\\n            h[i+1]=(h[i]+(text[i]-\\'a\\'+1)*p_pow[i])%m;\\n        \\n       unordered_set<string>st;\\n        for(int i=0;i<len;i++)\\n        {\\n            string s;\\n            for(int j=i;j<len;j++)\\n            {\\n                s+=text[j];\\n                if(s.size()%2==0)\\n                {\\n                    int len1=s.size()/2;\\n                    long long int h1=(h[i+len1]+m-h[i])%m;\\n                    long long int h2=(h[j+1]+m-h[i+len1])%m;\\n                \\n                    if(h2== (h1*p_pow[len1])%m)\\n                        st.insert(s);\\n                }\\n            }\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        \\n        int p=31;\\n        int m=1e9+9;\\n        int len=text.size();\\n        \\n        vector<long long int> p_pow(len,1);\\n        for(int i=1;i<len;i++)\\n            p_pow[i]=(p_pow[i-1]*p)%m;\\n        \\n        vector<long long int> h(len+1,0);\\n        for(int i=0;i<len;i++)\\n            h[i+1]=(h[i]+(text[i]-\\'a\\'+1)*p_pow[i])%m;\\n        \\n       unordered_set<string>st;\\n        for(int i=0;i<len;i++)\\n        {\\n            string s;\\n            for(int j=i;j<len;j++)\\n            {\\n                s+=text[j];\\n                if(s.size()%2==0)\\n                {\\n                    int len1=s.size()/2;\\n                    long long int h1=(h[i+len1]+m-h[i])%m;\\n                    long long int h2=(h[j+1]+m-h[i+len1])%m;\\n                \\n                    if(h2== (h1*p_pow[len1])%m)\\n                        st.insert(s);\\n                }\\n            }\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2178921,
                "title": "string-hashing-solution",
                "content": "class Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        const int p=31;\\n        const long long m=1e9+9;\\n        int sz=text.size();\\n        const int SZ=2005;\\n        long long h[SZ];\\n        long long p_pow[SZ];\\n        p_pow[0]=1;\\n        for (int i=1;i<SZ;i++){\\n            p_pow[i]=(p_pow[i-1]*p)%m;\\n        }\\n        for (int i=0;i<sz;i++){\\n            if (i==0){\\n                h[i]=text[0]-\\'a\\'+1;\\n            }else{\\n                h[i]=h[i-1]+(text[i]-\\'a\\'+1)*p_pow[i];\\n                h[i]%=m;\\n            }\\n        }\\n        int res=0;\\n        for (int l=1;l<=sz/2;l++){\\n            set<long long> nums;\\n            for (int i=0;i+2*l-1<sz;i++){\\n                //i,i+l-1\\n                //i+l,i+l+l-1\\n                long long h1=(h[i+l-1]-(i>=1?h[i-1]:0)+m)%m;\\n                long long h2=(h[i+2*l-1]-h[i+l-1]+m)%m;\\n                if ((h1*p_pow[l])%m==h2){\\n                    nums.insert((h1*p_pow[sz-i])%m);\\n                }\\n            }\\n            res+=nums.size();\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        const int p=31;\\n        const long long m=1e9+9;\\n        int sz=text.size();\\n        const int SZ=2005;\\n        long long h[SZ];\\n        long long p_pow[SZ];\\n        p_pow[0]=1;\\n        for (int i=1;i<SZ;i++){\\n            p_pow[i]=(p_pow[i-1]*p)%m;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2133981,
                "title": "c-rolling-hash-solution",
                "content": "```\\nclass hash_substring\\n{\\n    typedef unsigned long long hash1;\\n    const hash1 BASE = 137;\\n    vector<hash1>h,hPow;\\n    int N;\\n    string S;\\n    public:\\n    hash_substring( string a )\\n    {\\n        S = a;\\n        N = S.length();\\n        h.resize(N+1);\\n        hPow.resize(N+1);\\n        \\n        hPow[0] = 1;\\n        for (int i = 1; i <= N; ++i)\\n            hPow[i] = hPow[i - 1] * BASE;\\n\\n        h[N] = 0;\\n        for (int i = N - 1; i >= 0; --i)\\n            h[i] = h[i + 1] * BASE + S[i];\\n    }\\n    \\n    hash1 getHash( int lo , int size )\\n    {\\n        return (h[lo] - h[(lo) + (size)] * hPow[size]);\\n    }\\n        \\n};\\n\\nbool check( hash_substring &h , int l , int r , int x , int y)\\n{\\n    return h.getHash(l,r-l+1) == h.getHash(x,y-x+1);\\n}\\n\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        hash_substring h(text);\\n        unordered_map<int,int>m;\\n        int ans=0;\\n        for(int i=0;i<text.length();i++)\\n        {\\n            for(int j=i+1;j<text.length();j++)\\n            {\\n                if((j-i+1)%2)\\n                    continue;\\n                int mid=(i+j)/2;\\n                if(check(h,i,mid,mid+1,j))\\n                {\\n                    int val=h.getHash(i,j-i+1);\\n                    if(!m[val])\\n                    {\\n                        m[val]++,ans++;\\n                        \\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Rolling Hash"
                ],
                "code": "```\\nclass hash_substring\\n{\\n    typedef unsigned long long hash1;\\n    const hash1 BASE = 137;\\n    vector<hash1>h,hPow;\\n    int N;\\n    string S;\\n    public:\\n    hash_substring( string a )\\n    {\\n        S = a;\\n        N = S.length();\\n        h.resize(N+1);\\n        hPow.resize(N+1);\\n        \\n        hPow[0] = 1;\\n        for (int i = 1; i <= N; ++i)\\n            hPow[i] = hPow[i - 1] * BASE;\\n\\n        h[N] = 0;\\n        for (int i = N - 1; i >= 0; --i)\\n            h[i] = h[i + 1] * BASE + S[i];\\n    }\\n    \\n    hash1 getHash( int lo , int size )\\n    {\\n        return (h[lo] - h[(lo) + (size)] * hPow[size]);\\n    }\\n        \\n};\\n\\nbool check( hash_substring &h , int l , int r , int x , int y)\\n{\\n    return h.getHash(l,r-l+1) == h.getHash(x,y-x+1);\\n}\\n\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        hash_substring h(text);\\n        unordered_map<int,int>m;\\n        int ans=0;\\n        for(int i=0;i<text.length();i++)\\n        {\\n            for(int j=i+1;j<text.length();j++)\\n            {\\n                if((j-i+1)%2)\\n                    continue;\\n                int mid=(i+j)/2;\\n                if(check(h,i,mid,mid+1,j))\\n                {\\n                    int val=h.getHash(i,j-i+1);\\n                    if(!m[val])\\n                    {\\n                        m[val]++,ans++;\\n                        \\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111617,
                "title": "clean-javascript-solution",
                "content": "```\\nfunction distinctEchoSubstrings(w, ans = new Set()) {\\n    for (let i = 0; i< w.length - 2; i++) {\\n        for (let size = 1; size <= (w.length - i) / 2; size++) {\\n            if (w.substr(i, size) === w.substr(i + size, size)) {\\n                ans.add(w.substr(i, size))\\n            }\\n        }\\n    }\\n    return ans.size\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction distinctEchoSubstrings(w, ans = new Set()) {\\n    for (let i = 0; i< w.length - 2; i++) {\\n        for (let size = 1; size <= (w.length - i) / 2; size++) {\\n            if (w.substr(i, size) === w.substr(i + size, size)) {\\n                ans.add(w.substr(i, size))\\n            }\\n        }\\n    }\\n    return ans.size\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2083432,
                "title": "simple-hashing-on-string-rabin-karp",
                "content": "```\\n#define ll long\\n\\nclass Solution {\\npublic:\\n    \\n    // 1-indexed string needed\\n    struct Hashs\\n    {\\n        vector<ll> hash;\\n        vector<ll> pows;\\n        ll P;\\n        ll mod;\\n\\n        Hashs() {}\\n\\n        Hashs(string &s,ll P,ll M) : P(P), mod(M)\\n        {\\n            ll n=s.size();\\n            pows.resize(n+1, 0);\\n            hash.resize(n+1, 0);\\n            pows[0] = 1;\\n            for(ll i=1;i<=n;i++)\\n            {\\n                pows[i]=(pows[i-1]*P)%mod;\\n                hash[i]=(hash[i-1]*P+(s[i-1]-\\'a\\'+1))%mod;\\n            }\\n        }\\n\\n        ll get_hash(ll l,ll r)  // [l,r]\\n        {\\n            return ( hash[r] - (hash[l-1]*pows[r-l+1])%mod + mod ) % mod;\\n        }\\n    };\\n\\n\\n\\n    int distinctEchoSubstrings(string s) \\n    {\\n        int n=s.length();\\n        Hashs hs(s,31,1e9+7);\\n        int ans=0;\\n        map<int,int> mp;\\n        for(int i=1;i<=n;i++)\\n            for(int j=i+1;j<=n;j+=2)\\n                if(hs.get_hash(i,i+(j-i)/2)==hs.get_hash(i+(j-i)/2+1,j) && !mp.count(hs.get_hash(i,i+(j-i)/2)))\\n                    ans++,mp[hs.get_hash(i,i+(j-i)/2)]++;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n#define ll long\\n\\nclass Solution {\\npublic:\\n    \\n    // 1-indexed string needed\\n    struct Hashs\\n    {\\n        vector<ll> hash;\\n        vector<ll> pows;\\n        ll P;\\n        ll mod;\\n\\n        Hashs() {}\\n\\n        Hashs(string &s,ll P,ll M) : P(P), mod(M)\\n        {\\n            ll n=s.size();\\n            pows.resize(n+1, 0);\\n            hash.resize(n+1, 0);\\n            pows[0] = 1;\\n            for(ll i=1;i<=n;i++)\\n            {\\n                pows[i]=(pows[i-1]*P)%mod;\\n                hash[i]=(hash[i-1]*P+(s[i-1]-\\'a\\'+1))%mod;\\n            }\\n        }\\n\\n        ll get_hash(ll l,ll r)  // [l,r]\\n        {\\n            return ( hash[r] - (hash[l-1]*pows[r-l+1])%mod + mod ) % mod;\\n        }\\n    };\\n\\n\\n\\n    int distinctEchoSubstrings(string s) \\n    {\\n        int n=s.length();\\n        Hashs hs(s,31,1e9+7);\\n        int ans=0;\\n        map<int,int> mp;\\n        for(int i=1;i<=n;i++)\\n            for(int j=i+1;j<=n;j+=2)\\n                if(hs.get_hash(i,i+(j-i)/2)==hs.get_hash(i+(j-i)/2+1,j) && !mp.count(hs.get_hash(i,i+(j-i)/2)))\\n                    ans++,mp[hs.get_hash(i,i+(j-i)/2)]++;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2067558,
                "title": "c-rolling-hash-explanation",
                "content": "```\\nconst int64_t p = 31;\\nconst int64_t MOD = 1e9+9;\\n    \\nclass Solution {\\npublic:\\n    \\n    int distinctEchoSubstrings(string text) {\\n        int n = (int)text.length();\\n        vector<int64_t> pow(n);\\n        vector<int64_t> hash(n);\\n        pow[0] = 1;\\n        for (int i = 1; i < n; i++) {\\n            pow[i] = (pow[i-1] * p) % MOD;\\n        }\\n        hash[0] = text[0];\\n        for (int i = 1; i < n; i++) {\\n            hash[i] = (hash[i-1] + text[i]*pow[i]) % MOD;\\n        }\\n        \\n        unordered_set<int64_t> seen;\\n        // For each length\\n        for (int len = 2; len <= n; len += 2) {\\n            for (int l = 0; l <= n-len; l++) {\\n                int r = l + len - 1;\\n                int a = l, b = a + len/2 - 1;       // First half\\n                int x = a + len/2, y = r;           // Second half\\n                \\n                int64_t part1Hash = (hash[b] - (a-1 >= 0 ? hash[a-1] : 0) + MOD) % MOD;\\n                part1Hash = (part1Hash * pow[n-1-a]) % MOD;\\n                \\n                int64_t part2Hash = (hash[y] - hash[x-1] + MOD) % MOD;\\n                part2Hash = (part2Hash * pow[n-1-x]) % MOD;\\n                \\n                if (part1Hash == part2Hash) \\n                    seen.insert(part1Hash);\\n            }\\n        }\\n        return (int)seen.size();\\n    }\\n};\\n\\n/**\\n\\nFact 1: We have to check all even length substrings 2, 4, 6, 8, 10, 12...\\nFact 2: For each length traverse the string using sliding window. \\nSo overall complexity is O(n^2). But....\\n\\nSuppose len = 6. \\nYou got l = 0, r = 5\\nString = abcabc\\n\\nNow question is how to check \"abcabc\" satisfy given conditon. It would take O(n) time if you manually check first half == second half.\\n\\nSo leverage rolling hash. At first find rolling hash of all prefix of text.\\n         \\n         L                   R\\n 0   1   2   3   4   5   6   7   8\\n a   b   c   a   b   c   a   b   c\\np^0 p^1 p^2 p^3 p^4 p^5 p^6 p^7 p^8\\n       |           |           |\\n       |           |           |\\nDivide by p^2 for first half\\nDivide by p^5 for second half\\n\\n        p^0 p^1 p^2 p^0 p^1 p^2\\n\\n\\n**/\\n```",
                "solutionTags": [
                    "Rolling Hash"
                ],
                "code": "```\\nconst int64_t p = 31;\\nconst int64_t MOD = 1e9+9;\\n    \\nclass Solution {\\npublic:\\n    \\n    int distinctEchoSubstrings(string text) {\\n        int n = (int)text.length();\\n        vector<int64_t> pow(n);\\n        vector<int64_t> hash(n);\\n        pow[0] = 1;\\n        for (int i = 1; i < n; i++) {\\n            pow[i] = (pow[i-1] * p) % MOD;\\n        }\\n        hash[0] = text[0];\\n        for (int i = 1; i < n; i++) {\\n            hash[i] = (hash[i-1] + text[i]*pow[i]) % MOD;\\n        }\\n        \\n        unordered_set<int64_t> seen;\\n        // For each length\\n        for (int len = 2; len <= n; len += 2) {\\n            for (int l = 0; l <= n-len; l++) {\\n                int r = l + len - 1;\\n                int a = l, b = a + len/2 - 1;       // First half\\n                int x = a + len/2, y = r;           // Second half\\n                \\n                int64_t part1Hash = (hash[b] - (a-1 >= 0 ? hash[a-1] : 0) + MOD) % MOD;\\n                part1Hash = (part1Hash * pow[n-1-a]) % MOD;\\n                \\n                int64_t part2Hash = (hash[y] - hash[x-1] + MOD) % MOD;\\n                part2Hash = (part2Hash * pow[n-1-x]) % MOD;\\n                \\n                if (part1Hash == part2Hash) \\n                    seen.insert(part1Hash);\\n            }\\n        }\\n        return (int)seen.size();\\n    }\\n};\\n\\n/**\\n\\nFact 1: We have to check all even length substrings 2, 4, 6, 8, 10, 12...\\nFact 2: For each length traverse the string using sliding window. \\nSo overall complexity is O(n^2). But....\\n\\nSuppose len = 6. \\nYou got l = 0, r = 5\\nString = abcabc\\n\\nNow question is how to check \"abcabc\" satisfy given conditon. It would take O(n) time if you manually check first half == second half.\\n\\nSo leverage rolling hash. At first find rolling hash of all prefix of text.\\n         \\n         L                   R\\n 0   1   2   3   4   5   6   7   8\\n a   b   c   a   b   c   a   b   c\\np^0 p^1 p^2 p^3 p^4 p^5 p^6 p^7 p^8\\n       |           |           |\\n       |           |           |\\nDivide by p^2 for first half\\nDivide by p^5 for second half\\n\\n        p^0 p^1 p^2 p^0 p^1 p^2\\n\\n\\n**/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1989341,
                "title": "fastest-js-solution",
                "content": "```\\n/**\\n * @param {string} text\\n * @return {number}\\n */\\nvar distinctEchoSubstrings = function(text) {\\n    const result = new Set();\\n    for (let i = 0; i< text.length - 2; i++) {\\n        \\n        for (let length = 1; length <= (text.length - i) / 2; length++) {\\n            if (text.substr(i, length) === text.substr(i+length, length)) {\\n                result.add(text.substr(i, length));\\n            }\\n        }\\n    }\\n    return result.size;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} text\\n * @return {number}\\n */\\nvar distinctEchoSubstrings = function(text) {\\n    const result = new Set();\\n    for (let i = 0; i< text.length - 2; i++) {\\n        \\n        for (let length = 1; length <= (text.length - i) / 2; length++) {\\n            if (text.substr(i, length) === text.substr(i+length, length)) {\\n                result.add(text.substr(i, length));\\n            }\\n        }\\n    }\\n    return result.size;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1766331,
                "title": "c-brute-force-solution",
                "content": "```\\n\\tpublic int DistinctEchoSubstrings(string text) {\\n        var hashSet = new HashSet<string>();\\n        for (int n = 1; n <= text.Length/2; n++) {\\n            for (int i=0; i<=text.Length-2*n; i++) {\\n                if (AreEqualSubstrings(text, i, n+i, n)) // compare current and next substrings of length n\\n                    hashSet.Add(text.Substring(i, n));\\n            }\\n        }\\n        return hashSet.Count;\\n    }\\n    \\n    bool AreEqualSubstrings(string text, int start1, int start2, int length) {\\n        for (int i=0; i<length; i++) {\\n            if (text[start1+i] != text[start2+i])\\n                return false;\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic int DistinctEchoSubstrings(string text) {\\n        var hashSet = new HashSet<string>();\\n        for (int n = 1; n <= text.Length/2; n++) {\\n            for (int i=0; i<=text.Length-2*n; i++) {\\n                if (AreEqualSubstrings(text, i, n+i, n)) // compare current and next substrings of length n\\n                    hashSet.Add(text.Substring(i, n));\\n            }\\n        }\\n        return hashSet.Count;\\n    }\\n    \\n    bool AreEqualSubstrings(string text, int start1, int start2, int length) {\\n        for (int i=0; i<length; i++) {\\n            if (text[start1+i] != text[start2+i])\\n                return false;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1754656,
                "title": "python-brute-force",
                "content": "\\n```\\nclass Solution:\\n    def distinctEchoSubstrings(self, s: str) -> int:\\n        hash=set()\\n        n=len(s)\\n        for i in range(n):\\n            for j in range(i):\\n                \\n                if (i-j)&1==1:\\n                    \\n                    k=(i-j)//2\\n                    \\n                    if s[j:j+k+1]==s[j+k+1:i+1]:\\n                        hash.add(s[j:j+k+1]+s[j+k+1:i+1])\\n        return len(hash)\\n                    \\n                    \\n                    \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def distinctEchoSubstrings(self, s: str) -> int:\\n        hash=set()\\n        n=len(s)\\n        for i in range(n):\\n            for j in range(i):\\n                \\n                if (i-j)&1==1:\\n                    \\n                    k=(i-j)//2\\n                    \\n                    if s[j:j+k+1]==s[j+k+1:i+1]:\\n                        hash.add(s[j:j+k+1]+s[j+k+1:i+1])\\n        return len(hash)\\n                    \\n                    \\n                    \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1739662,
                "title": "python-faster-than-99",
                "content": "```\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        #indexes candidate to be the middle of substrings can only be chars that appear more than once\\n\\t\\tcandidate_indexes = set()\\n        \\n        #build hashmap keeping indexes of each chars\\n        hash_alph = {}\\n        for i, c in enumerate(text):\\n            if not c in hash_alph:\\n                hash_alph[c] = []\\n            else:\\n                candidate_indexes.add(i)\\n            hash_alph[c].append(i)\\n      \\n        #case input is all same letter\\n        if len(hash_alph.keys()) == 1 and len(text) > 1:\\n            return len(text) // 2\\n    \\n        return_set = set()\\n        for i in candidate_indexes:\\n            c = text[i]\\n\\t\\t\\t#sequence can only start at the same char in a position preceding\\n            for j in [x for x in hash_alph[c] if x < i]:\\n                length = i - j\\n                #too close from end\\n                if len(text) - i < length:\\n                    continue\\n                \\n                #verify if substring meets condition\\n                l = text[i-length:i] \\n                r = text[i:i+length]\\n                if l == r:\\n                    return_set.add(l+r)\\n                    \\n        return len(return_set)\\n                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        #indexes candidate to be the middle of substrings can only be chars that appear more than once\\n\\t\\tcandidate_indexes = set()\\n        \\n        #build hashmap keeping indexes of each chars\\n        hash_alph = {}\\n        for i, c in enumerate(text):\\n            if not c in hash_alph:\\n                hash_alph[c] = []\\n            else:\\n                candidate_indexes.add(i)\\n            hash_alph[c].append(i)\\n      \\n        #case input is all same letter\\n        if len(hash_alph.keys()) == 1 and len(text) > 1:\\n            return len(text) // 2\\n    \\n        return_set = set()\\n        for i in candidate_indexes:\\n            c = text[i]\\n\\t\\t\\t#sequence can only start at the same char in a position preceding\\n            for j in [x for x in hash_alph[c] if x < i]:\\n                length = i - j\\n                #too close from end\\n                if len(text) - i < length:\\n                    continue\\n                \\n                #verify if substring meets condition\\n                l = text[i-length:i] \\n                r = text[i:i+length]\\n                if l == r:\\n                    return_set.add(l+r)\\n                    \\n        return len(return_set)\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1717835,
                "title": "java-dp",
                "content": "```\\nclass Solution {\\n    public int distinctEchoSubstrings(String s) {\\n        HashSet<String>set=new HashSet();\\n        int dp[][]=new int[s.length()+1][s.length()+1];\\n        for(int i=s.length()-1;i>=0;i--)\\n        {\\n            for(int j=i+1;j<s.length() && (j-i<=s.length()/2);j++)\\n            {\\n                if(s.charAt(i)==s.charAt(j))\\n                {\\n                    dp[i][j]=1+dp[i+1][j+1];\\n                    if(dp[i+1][j+1]>=j-i-1)\\n                        set.add(s.substring(i,j));\\n                }\\n            }\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int distinctEchoSubstrings(String s) {\\n        HashSet<String>set=new HashSet();\\n        int dp[][]=new int[s.length()+1][s.length()+1];\\n        for(int i=s.length()-1;i>=0;i--)\\n        {\\n            for(int j=i+1;j<s.length() && (j-i<=s.length()/2);j++)\\n            {\\n                if(s.charAt(i)==s.charAt(j))\\n                {\\n                    dp[i][j]=1+dp[i+1][j+1];\\n                    if(dp[i+1][j+1]>=j-i-1)\\n                        set.add(s.substring(i,j));\\n                }\\n            }\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1691605,
                "title": "javascript-brute-force-1332ms",
                "content": "```\\nconst distinctEchoSubstrings = (s) => {\\n    let n = s.length, res = new Set();\\n    for (let len = 1; len <= n >> 1; len++) {\\n        for (let i = 0; i + len <= n; i++) {\\n           let left = s.substr(i, len), right = s.substr(i + len, len);\\n           if (left == right) res.add(s.substr(i, 2 * len));\\n        }\\n    }\\n    return res.size;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst distinctEchoSubstrings = (s) => {\\n    let n = s.length, res = new Set();\\n    for (let len = 1; len <= n >> 1; len++) {\\n        for (let i = 0; i + len <= n; i++) {\\n           let left = s.substr(i, len), right = s.substr(i + len, len);\\n           if (left == right) res.add(s.substr(i, 2 * len));\\n        }\\n    }\\n    return res.size;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1567532,
                "title": "java-solution-same-logic-doesn-t-work-in-c",
                "content": "```\\nclass Solution {\\n    \\n    public int distinctEchoSubstrings(String s) {\\n        \\n        int n = s.length();\\n        \\n        int ans = 0;\\n        \\n        HashSet<String> set = new HashSet<>();\\n        \\n        for(int g = 1 ; g < n ; g++){\\n            \\n            for(int i = 0 , j = g ; j < n ; i++, j++){\\n                \\n                if(g%2 == 1){\\n                    \\n                    String left = s.substring(i,i+(g/2)+1);\\n                    String right = s.substring(i+(g/2)+1,j+1);\\n                    \\n                    if(left.equals(right) && set.contains(left+right) == false){\\n                        ans++;\\n                        set.add(left + right);\\n                    }\\n                    \\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public int distinctEchoSubstrings(String s) {\\n        \\n        int n = s.length();\\n        \\n        int ans = 0;\\n        \\n        HashSet<String> set = new HashSet<>();\\n        \\n        for(int g = 1 ; g < n ; g++){\\n            \\n            for(int i = 0 , j = g ; j < n ; i++, j++){\\n                \\n                if(g%2 == 1){\\n                    \\n                    String left = s.substring(i,i+(g/2)+1);\\n                    String right = s.substring(i+(g/2)+1,j+1);\\n                    \\n                    if(left.equals(right) && set.contains(left+right) == false){\\n                        ans++;\\n                        set.add(left + right);\\n                    }\\n                    \\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1558448,
                "title": "o-n-2-try-every-possible-duplicate-substring-recursively",
                "content": "```\\nvar distinctEchoSubstrings = function(text) {\\n    let count = 0;\\n    function solve(indices, length) {\\n        if (indices.length <= 1) {\\n            return;\\n        }\\n        const set = new Set(indices);\\n        for (let j = 0; j < indices.length - 1; j++) {\\n            if (set.has(indices[j] + length)) {\\n                count++\\n                break;\\n            }\\n        }\\n        const options = new Set(indices.map(i => text[i + length]));\\n        for (const c of options) {\\n            if (!c) continue;\\n            const next = indices.filter(i => text[i + length] === c);\\n            solve(next, length + 1)\\n        }\\n    }\\n    \\n    for (const c of \\'abcdefghijklmnopqrstuvwxyz\\') {\\n        const indices = text\\n            .split(\\'\\')\\n            .map((x, i) => x === c ? i : null)\\n            .filter(d => d !== null);\\n        solve(indices, 1)\\n    }\\n    \\n    return count;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar distinctEchoSubstrings = function(text) {\\n    let count = 0;\\n    function solve(indices, length) {\\n        if (indices.length <= 1) {\\n            return;\\n        }\\n        const set = new Set(indices);\\n        for (let j = 0; j < indices.length - 1; j++) {\\n            if (set.has(indices[j] + length)) {\\n                count++\\n                break;\\n            }\\n        }\\n        const options = new Set(indices.map(i => text[i + length]));\\n        for (const c of options) {\\n            if (!c) continue;\\n            const next = indices.filter(i => text[i + length] === c);\\n            solve(next, length + 1)\\n        }\\n    }\\n    \\n    for (const c of \\'abcdefghijklmnopqrstuvwxyz\\') {\\n        const indices = text\\n            .split(\\'\\')\\n            .map((x, i) => x === c ? i : null)\\n            .filter(d => d !== null);\\n        solve(indices, 1)\\n    }\\n    \\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1419989,
                "title": "python-better-than-100-simple-bruteforce",
                "content": "```\\nclass Solution(object):\\n    def distinctEchoSubstrings(self, text):\\n        n=len(text)\\n        ans=0\\n        s=set()\\n        for i in range(1,n):\\n            for j in range(i//2+1,i+1):\\n                l=i+1-j\\n                temp=text[j-l:j]\\n                if temp==text[j:i+1]:\\n                    s.add(temp)\\n        return len(s)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def distinctEchoSubstrings(self, text):\\n        n=len(text)\\n        ans=0\\n        s=set()\\n        for i in range(1,n):\\n            for j in range(i//2+1,i+1):\\n                l=i+1-j\\n                temp=text[j-l:j]\\n                if temp==text[j:i+1]:\\n                    s.add(temp)\\n        return len(s)\\n",
                "codeTag": "Java"
            },
            {
                "id": 1343699,
                "title": "why-does-my-code-not-work",
                "content": "Please exclude the modulo part. I have not included it yet. It fails on testcase : \"tiduxtiduxtiduxtiduxtiduxtiduxtiduxtidux\"\\nOutput : 15\\nExpected: 16\\n\\n```\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        hasharray = []\\n        BASE = 7\\n        \\n        for i in range(len(text)):\\n            if i==0:\\n                hasharray.append(ord(text[i]))\\n            else:\\n                hasharray.append(ord(text[i])*(BASE**i)+hasharray[-1])\\n        \\n        \\n        echos = set()\\n        i = 0\\n        while i<len(text):\\n            length = 2\\n            while i+length <= len(text):\\n                mid = i + length//2\\n                hash1 = (hasharray[mid-1] - hasharray[i-1])/BASE**i if i>0 else hasharray[mid-1]\\n                hash2 = (hasharray[i+length-1] - hasharray[mid-1])/BASE**mid\\n                if hash1==hash2:\\n                    echos.add(text[i:i+length])\\n                length+=2\\n            i+=1\\n        return len(echos)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        hasharray = []\\n        BASE = 7\\n        \\n        for i in range(len(text)):\\n            if i==0:\\n                hasharray.append(ord(text[i]))\\n            else:\\n                hasharray.append(ord(text[i])*(BASE**i)+hasharray[-1])\\n        \\n        \\n        echos = set()\\n        i = 0\\n        while i<len(text):\\n            length = 2\\n            while i+length <= len(text):\\n                mid = i + length//2\\n                hash1 = (hasharray[mid-1] - hasharray[i-1])/BASE**i if i>0 else hasharray[mid-1]\\n                hash2 = (hasharray[i+length-1] - hasharray[mid-1])/BASE**mid\\n                if hash1==hash2:\\n                    echos.add(text[i:i+length])\\n                length+=2\\n            i+=1\\n        return len(echos)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1322425,
                "title": "amazed-to-see-brute-brute-force-solution-working-python",
                "content": "```\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        sets = set()\\n        for i in range(len(text)-1):\\n            for j in range(i+1,len(text)):\\n                sub_str = text[i:j+1]\\n                if len(sub_str)%2==0:\\n                    l = len(sub_str)//2 \\n                    if sub_str[:l] == sub_str[l:]:\\n                        sets.add(sub_str)\\n        return len(sets)\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        sets = set()\\n        for i in range(len(text)-1):\\n            for j in range(i+1,len(text)):\\n                sub_str = text[i:j+1]\\n                if len(sub_str)%2==0:\\n                    l = len(sub_str)//2 \\n                    if sub_str[:l] == sub_str[l:]:\\n                        sets.add(sub_str)\\n        return len(sets)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1293621,
                "title": "java-easy-solution",
                "content": "class Solution {\\n    public int distinctEchoSubstrings(String text) {\\n        Set<String> a=new HashSet<String>();\\n        for(int i=0;i<text.length();i++)\\n        {\\n            for(int j=i+1;j<text.length();j++)\\n            {\\n                if(text.charAt(i)==text.charAt(j))\\n                {\\n                    if(j+j-i<=text.length())\\n                    {\\n                    String s1=text.substring(i,j);\\n                    String s2=text.substring(j,j+j-i);\\n                    if(s1.equals(s2))\\n                    {\\n                        a.add(s1);\\n                    }\\n                    }\\n                }\\n            }\\n        }\\n        return a.size();\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int distinctEchoSubstrings(String text) {\\n        Set<String> a=new HashSet<String>();\\n        for(int i=0;i<text.length();i++)\\n        {\\n            for(int j=i+1;j<text.length();j++)\\n            {\\n                if(text.charAt(i)==text.charAt(j))\\n                {\\n                    if(j+j-i<=text.length())\\n                    {\\n                    String s1=text.substring(i,j);\\n                    String s2=text.substring(j,j+j-i);\\n                    if(s1.equals(s2))\\n                    {\\n                        a.add(s1);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1231850,
                "title": "c-250ms",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long int\\n    ll q=1000000037;\\n    vector<ll>h;\\n    vector<ll>p;\\n    void build_hash(string &s)\\n    {\\n        ll n=s.size(),d=1000000007;\\n        h.resize(n+1);\\n        p.resize(n+1);\\n        p[0]=1,h[0]=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            h[i]=(h[i-1]*d+s[i-1])%q;\\n            p[i]=(p[i-1]*d)%q;\\n        }\\n    }\\n    ll hash(int i,int j)\\n    {\\n        ll res=(h[j+1]-h[i]*p[j-i+1])%q;\\n        if(res<0)\\n            res+=q;\\n        return res;\\n    }\\n    int distinctEchoSubstrings(string s) \\n    {\\n        unordered_set<int>res;\\n        build_hash(s);\\n        int n=s.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i;j<n;j++)\\n            {\\n                int len=j-i+1;\\n                if(j+len<n)\\n                {\\n                    if(hash(i,j)==hash(j+1,j+len))\\n                    {\\n                        res.insert(hash(i,j));\\n                    }\\n                }\\n            }\\n        }\\n        return res.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long int\\n    ll q=1000000037;\\n    vector<ll>h;\\n    vector<ll>p;\\n    void build_hash(string &s)\\n    {\\n        ll n=s.size(),d=1000000007;\\n        h.resize(n+1);\\n        p.resize(n+1);\\n        p[0]=1,h[0]=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            h[i]=(h[i-1]*d+s[i-1])%q;\\n            p[i]=(p[i-1]*d)%q;\\n        }\\n    }\\n    ll hash(int i,int j)\\n    {\\n        ll res=(h[j+1]-h[i]*p[j-i+1])%q;\\n        if(res<0)\\n            res+=q;\\n        return res;\\n    }\\n    int distinctEchoSubstrings(string s) \\n    {\\n        unordered_set<int>res;\\n        build_hash(s);\\n        int n=s.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i;j<n;j++)\\n            {\\n                int len=j-i+1;\\n                if(j+len<n)\\n                {\\n                    if(hash(i,j)==hash(j+1,j+len))\\n                    {\\n                        res.insert(hash(i,j));\\n                    }\\n                }\\n            }\\n        }\\n        return res.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1221492,
                "title": "rust-brute-force-o-n-3-beats-100-100-nevertheless",
                "content": "```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn distinct_echo_substrings(text: String) -> i32 {\\n        let bytes = text.as_bytes();\\n        let n = bytes.len();\\n        let mut ans = HashSet::new();\\n        let mut cnt = 0;\\n        for l in 1..=n/2 {\\n            for start in l..=n-l {\\n                let seg = &bytes[start..start+l];\\n                if &bytes[start-l..start] == seg {\\n                    ans.insert(seg.clone());\\n                }\\n            }\\n            cnt += ans.len();\\n            ans.clear();\\n        }\\n        cnt as i32\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn distinct_echo_substrings(text: String) -> i32 {\\n        let bytes = text.as_bytes();\\n        let n = bytes.len();\\n        let mut ans = HashSet::new();\\n        let mut cnt = 0;\\n        for l in 1..=n/2 {\\n            for start in l..=n-l {\\n                let seg = &bytes[start..start+l];\\n                if &bytes[start-l..start] == seg {\\n                    ans.insert(seg.clone());\\n                }\\n            }\\n            cnt += ans.len();\\n            ans.clear();\\n        }\\n        cnt as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1067673,
                "title": "typescript-solution-100-speed-memory",
                "content": "```\\nconst distinctEchoSubstrings = (text: string): number => {\\n    const hashTable: { [key: string]: boolean } = {};\\n    // Iterate over all combinations of start (s1) and end (e1) positions.\\n    for (let s1=0; s1< text.length - 1; s1++) {\\n        for (let e1=s1+1; e1 < text.length; e1++) {\\n            const s2 = e1;\\n            const e2 = s2 + (e1 - s1);\\n            if (e2 > text.length) {\\n                // If e2 is out of bounds, move on to the next s1 position\\n                break;\\n            }\\n            // Check if the string from s1 to e1 (exclusive)\\n            // is equal to the string on the right of equal length (from s2 to e2).\\n            const stringToCheck = text.slice(s1, e1);\\n            if (stringToCheck === text.slice(s2, e2)) {\\n                // If the strings are equal,\\n                // then place string in hashTable.\\n                hashTable[stringToCheck] = true;\\n            }\\n        }\\n    }\\n    return Object.keys(hashTable).length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nconst distinctEchoSubstrings = (text: string): number => {\\n    const hashTable: { [key: string]: boolean } = {};\\n    // Iterate over all combinations of start (s1) and end (e1) positions.\\n    for (let s1=0; s1< text.length - 1; s1++) {\\n        for (let e1=s1+1; e1 < text.length; e1++) {\\n            const s2 = e1;\\n            const e2 = s2 + (e1 - s1);\\n            if (e2 > text.length) {\\n                // If e2 is out of bounds, move on to the next s1 position\\n                break;\\n            }\\n            // Check if the string from s1 to e1 (exclusive)\\n            // is equal to the string on the right of equal length (from s2 to e2).\\n            const stringToCheck = text.slice(s1, e1);\\n            if (stringToCheck === text.slice(s2, e2)) {\\n                // If the strings are equal,\\n                // then place string in hashTable.\\n                hashTable[stringToCheck] = true;\\n            }\\n        }\\n    }\\n    return Object.keys(hashTable).length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1047124,
                "title": "java-simple-brute-force-got-accepted-surprised-me",
                "content": "\\tpublic int distinctEchoSubstrings(String text) {\\n\\t\\t\\tif (text == null || text.length() == 0) return 0;\\n\\t\\t\\tSet<String> stringSet = new HashSet<>();\\n\\n\\t\\t\\tfor (int right = 1; right <= text.length(); ++right)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor (int left = 0; left < right; ++left)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (right - left <= 1) continue;\\n\\t\\t\\t\\t\\tString subStr = text.substring(left, right);\\n\\t\\t\\t\\t\\tif (isEchoString(subStr)) {\\n\\t\\t\\t\\t\\t\\tstringSet.add(subStr);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn stringSet.size();\\n\\t\\t}\\n\\n\\t\\tprivate boolean isEchoString(String subStr)\\n\\t\\t{\\n\\t\\t\\tif (subStr.length() % 2 != 0) return false;\\n\\n\\t\\t\\tif (subStr.substring(0, subStr.length()/2).equals(subStr.substring(subStr.length()/2, subStr.length())))\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\treturn false;\\n\\t\\t}",
                "solutionTags": [],
                "code": "\\tpublic int distinctEchoSubstrings(String text) {\\n\\t\\t\\tif (text == null || text.length() == 0) return 0;\\n\\t\\t\\tSet<String> stringSet = new HashSet<>();\\n\\n\\t\\t\\tfor (int right = 1; right <= text.length(); ++right)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor (int left = 0; left < right; ++left)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (right - left <= 1) continue;\\n\\t\\t\\t\\t\\tString subStr = text.substring(left, right);\\n\\t\\t\\t\\t\\tif (isEchoString(subStr)) {\\n\\t\\t\\t\\t\\t\\tstringSet.add(subStr);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn stringSet.size();\\n\\t\\t}\\n\\n\\t\\tprivate boolean isEchoString(String subStr)\\n\\t\\t{\\n\\t\\t\\tif (subStr.length() % 2 != 0) return false;\\n\\n\\t\\t\\tif (subStr.substring(0, subStr.length()/2).equals(subStr.substring(subStr.length()/2, subStr.length())))\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\treturn false;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 993806,
                "title": "rolling-hash-86",
                "content": "```\\n#define ll long long int\\nconst ll m = 1e9 + 9;\\nconst int p = 31;\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string s){\\n        int i, l = s.length();\\n        int mx = (l + 1);\\n        unordered_map<ll, bool> pre;\\n        ll pw[mx+1];\\n        pw[0] = 1;\\n        if(l==1)\\n            return 0;\\n        if(l==2){\\n            if(s[0]==s[1])\\n                return 1;\\n            return 0;\\n        }\\n        \\n        ll cnt = 0;\\n        for(i=1;i<=mx;i++)\\n            pw[i] = (pw[i-1]*31)%m;\\n        \\n        ll dp[l+1][l+1];\\n        memset(dp, -1, sizeof(dp));\\n        \\n        for(i=0;i<l;i++){\\n            ll h1 = 0;\\n            for(ll len = 1;len<=l;len++){\\n                if(i+len>l)\\n                    break;\\n                h1 = (h1 + ((s[i+len-1]-\\'a\\'+1)*pw[len-1])%m)%m;\\n                dp[i][len] = h1;\\n            }\\n        }\\n        \\n        for(i=0;i<l;i++){\\n            for(ll len =1;len<=l;len++){\\n                if(i+len>=l)\\n                    break;        \\n                if(dp[i][len]==dp[i+len][len]){\\n                    if(pre.find(dp[i][len])==pre.end()){\\n                        pre[dp[i][len]] = 1;\\n                        cnt++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Rolling Hash"
                ],
                "code": "```\\n#define ll long long int\\nconst ll m = 1e9 + 9;\\nconst int p = 31;\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string s){\\n        int i, l = s.length();\\n        int mx = (l + 1);\\n        unordered_map<ll, bool> pre;\\n        ll pw[mx+1];\\n        pw[0] = 1;\\n        if(l==1)\\n            return 0;\\n        if(l==2){\\n            if(s[0]==s[1])\\n                return 1;\\n            return 0;\\n        }\\n        \\n        ll cnt = 0;\\n        for(i=1;i<=mx;i++)\\n            pw[i] = (pw[i-1]*31)%m;\\n        \\n        ll dp[l+1][l+1];\\n        memset(dp, -1, sizeof(dp));\\n        \\n        for(i=0;i<l;i++){\\n            ll h1 = 0;\\n            for(ll len = 1;len<=l;len++){\\n                if(i+len>l)\\n                    break;\\n                h1 = (h1 + ((s[i+len-1]-\\'a\\'+1)*pw[len-1])%m)%m;\\n                dp[i][len] = h1;\\n            }\\n        }\\n        \\n        for(i=0;i<l;i++){\\n            for(ll len =1;len<=l;len++){\\n                if(i+len>=l)\\n                    break;        \\n                if(dp[i][len]==dp[i+len][len]){\\n                    if(pre.find(dp[i][len])==pre.end()){\\n                        pre[dp[i][len]] = 1;\\n                        cnt++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 956349,
                "title": "c-string-hashing",
                "content": "```\\npublic class Solution\\n{\\n  public int DistinctEchoSubstrings(string text)\\n  {\\n    const int A = 911382323;\\n    const int B = 972663749;\\n\\n    var h = new int[text.Length];\\n    var p = new int[text.Length];\\n\\n    h[0] = text[0] % B;\\n    p[0] = 1;\\n\\n    for (var i = 1; i < text.Length; i++)\\n    {\\n      h[i] = (Mod(h[i - 1], A, B) + text[i]) % B;\\n      p[i] = (Mod(p[i - 1], A, B)) % B;\\n    }\\n\\n    var set = new HashSet<int>();\\n\\n    for (var i = 0; i < text.Length; i++)\\n    {\\n      for (var j = i + 1; j < text.Length; j += 2)\\n      {\\n        var hash1 = Hash(h, p, i, (i + j) / 2, B);\\n        var hash2 = Hash(h, p, (i + j) / 2 + 1, j, B);\\n\\n        if (hash1 == hash2)\\n          set.Add(Hash(h, p, i, j, B));\\n      }\\n    }\\n\\n    return set.Count;\\n  }\\n\\n  private int Hash(int[] h, int[] p, int a, int b, int B)\\n  {\\n    if (a == 0)\\n      return h[b];\\n\\n    return ((h[b] + B) - Mod(h[a - 1], p[b - a + 1], B)) % B;\\n  }\\n\\n  private int Mod(int a, int b, int mod)\\n  {\\n    var res = 0;\\n    a %= mod;\\n\\n    while (b > 0)\\n    {\\n      if ((b & 1) > 0)\\n        res = (res + a) % mod;\\n\\n      a = (2 * a) % mod;\\n      b >>= 1;\\n    }\\n\\n    return res;\\n  }\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\npublic class Solution\\n{\\n  public int DistinctEchoSubstrings(string text)\\n  {\\n    const int A = 911382323;\\n    const int B = 972663749;\\n\\n    var h = new int[text.Length];\\n    var p = new int[text.Length];\\n\\n    h[0] = text[0] % B;\\n    p[0] = 1;\\n\\n    for (var i = 1; i < text.Length; i++)\\n    {\\n      h[i] = (Mod(h[i - 1], A, B) + text[i]) % B;\\n      p[i] = (Mod(p[i - 1], A, B)) % B;\\n    }\\n\\n    var set = new HashSet<int>();\\n\\n    for (var i = 0; i < text.Length; i++)\\n    {\\n      for (var j = i + 1; j < text.Length; j += 2)\\n      {\\n        var hash1 = Hash(h, p, i, (i + j) / 2, B);\\n        var hash2 = Hash(h, p, (i + j) / 2 + 1, j, B);\\n\\n        if (hash1 == hash2)\\n          set.Add(Hash(h, p, i, j, B));\\n      }\\n    }\\n\\n    return set.Count;\\n  }\\n\\n  private int Hash(int[] h, int[] p, int a, int b, int B)\\n  {\\n    if (a == 0)\\n      return h[b];\\n\\n    return ((h[b] + B) - Mod(h[a - 1], p[b - a + 1], B)) % B;\\n  }\\n\\n  private int Mod(int a, int b, int mod)\\n  {\\n    var res = 0;\\n    a %= mod;\\n\\n    while (b > 0)\\n    {\\n      if ((b & 1) > 0)\\n        res = (res + a) % mod;\\n\\n      a = (2 * a) % mod;\\n      b >>= 1;\\n    }\\n\\n    return res;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 939323,
                "title": "python3-short-brute-force-solution",
                "content": "```\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        ret = set()\\n\\n        \\n        for i in range(len(text)):\\n            for j in range(i + 1, len(text), 2):\\n                middle = i + (j - i + 1) // 2\\n                candidate = text[i:middle]\\n                \\n                \\n                if (candidate == text[middle:j + 1]):\\n                    ret.add(candidate)\\n                    \\n        return len(ret)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        ret = set()\\n\\n        \\n        for i in range(len(text)):\\n            for j in range(i + 1, len(text), 2):\\n                middle = i + (j - i + 1) // 2\\n                candidate = text[i:middle]\\n                \\n                \\n                if (candidate == text[middle:j + 1]):\\n                    ret.add(candidate)\\n                    \\n        return len(ret)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 861153,
                "title": "distinct-echo-substring-simple-brute-force-solution",
                "content": "\\'\\'\\'\\'\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        \\n        \\n        subs=set()\\n        \\n        for i in range(len(text)):\\n            for j in range(i+1,len(text)):\\n                \\n                temp=text[i:j]\\n                \\n                #print(\"\\\\t\\\\t temp:\",temp,\"\\\\t\\\\t \",temp==text.startswith(temp,j))\\n                if text[i:j]==text[j:j+j-i] :#text.startswith(text[i:j],j):\\n                    subs.add(text[i:j])\\n                \\n        #print(subs)\\n        return len(subs)\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\'\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        \\n        \\n        subs=set()\\n        \\n        for i in range(len(text)):\\n            for j in range(i+1,len(text)):\\n                \\n                temp=text[i:j]\\n                \\n                #print(\"\\\\t\\\\t temp:\",temp,\"\\\\t\\\\t \",temp==text.startswith(temp,j))\\n                if text[i:j]==text[j:j+j-i] :#text.startswith(text[i:j],j):\\n                    subs.add(text[i:j])\\n                \\n        #print(subs)\\n        return len(subs)\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 847050,
                "title": "java-rolling-hash",
                "content": "```\\nclass Solution {\\n    public int distinctEchoSubstrings(String text) {\\n        int n = text.length();\\n        long mod = 1_000_000_009L;\\n        int[] a = new int[n];\\n        for(int i = 0; i < n; i++) a[i] = text.charAt(i) - \\'a\\';\\n        \\n        // modular exps of 26\\n        long[] exp = new long[n+1];\\n        exp[0] = 1;\\n        for(int i = 0; i < n; i++) exp[i+1] = (exp[i] % mod * 26) % mod;\\n        \\n        Set<String> res = new HashSet<>();\\n        for(int i = 1; i <= n/2; i++) {\\n            int p = 0, q = i;\\n            long h0 = 0, h1 = 0;\\n            while(p < i) {\\n                h0 = ((h0 % mod * 26) % mod + a[p]) % mod;\\n                h1 = ((h1 % mod * 26) % mod + a[q]) % mod;\\n                p++;\\n                q++;\\n            }\\n            \\n            while(q < n) {\\n                if(h0 == h1) {\\n                    res.add(text.substring(p, q));\\n                }\\n                h0 = ((h0 % mod * 26) % mod + a[p]) % mod;\\n                h1 = ((h1 % mod * 26) % mod + a[q]) % mod;\\n                h0 = (h0 % mod - (exp[i] * a[p - i]) % mod) % mod;\\n                h1 = (h1 % mod - (exp[i] * a[q - i]) % mod) % mod;\\n                p++;\\n                q++;\\n            }\\n\\n            if(h0 == h1) {\\n                res.add(text.substring(p, q));\\n            }\\n        }\\n        return res.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int distinctEchoSubstrings(String text) {\\n        int n = text.length();\\n        long mod = 1_000_000_009L;\\n        int[] a = new int[n];\\n        for(int i = 0; i < n; i++) a[i] = text.charAt(i) - \\'a\\';\\n        \\n        // modular exps of 26\\n        long[] exp = new long[n+1];\\n        exp[0] = 1;\\n        for(int i = 0; i < n; i++) exp[i+1] = (exp[i] % mod * 26) % mod;\\n        \\n        Set<String> res = new HashSet<>();\\n        for(int i = 1; i <= n/2; i++) {\\n            int p = 0, q = i;\\n            long h0 = 0, h1 = 0;\\n            while(p < i) {\\n                h0 = ((h0 % mod * 26) % mod + a[p]) % mod;\\n                h1 = ((h1 % mod * 26) % mod + a[q]) % mod;\\n                p++;\\n                q++;\\n            }\\n            \\n            while(q < n) {\\n                if(h0 == h1) {\\n                    res.add(text.substring(p, q));\\n                }\\n                h0 = ((h0 % mod * 26) % mod + a[p]) % mod;\\n                h1 = ((h1 % mod * 26) % mod + a[q]) % mod;\\n                h0 = (h0 % mod - (exp[i] * a[p - i]) % mod) % mod;\\n                h1 = (h1 % mod - (exp[i] * a[q - i]) % mod) % mod;\\n                p++;\\n                q++;\\n            }\\n\\n            if(h0 == h1) {\\n                res.add(text.substring(p, q));\\n            }\\n        }\\n        return res.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 843570,
                "title": "rolling-hash-with-dp-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        int n=text.size();\\n        long long hash[n][n];\\n        int mod=1e9+7;\\n        unordered_map<long long,int> MP;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            long long pow=31;\\n            hash[i][i]=pow*(text[i]-\\'a\\'+1);\\n            for(int j=i+1;j<n;j++)\\n            {\\n                pow=(pow*31)%mod;\\n                hash[i][j]=(hash[i][j-1]%mod+pow*(text[j]-\\'a\\'+1)%mod)%mod;\\n            }\\n        }\\n        \\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i;j<n;j++)\\n            {\\n                int sz=j-i+1;\\n                if(j+sz>=n) continue;\\n                if(hash[i][j]==hash[j+1][j+sz])\\n                {\\n                    if(MP[hash[i][j]]==0) ans++;\\n                    MP[hash[i][j]]++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Rolling Hash"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        int n=text.size();\\n        long long hash[n][n];\\n        int mod=1e9+7;\\n        unordered_map<long long,int> MP;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            long long pow=31;\\n            hash[i][i]=pow*(text[i]-\\'a\\'+1);\\n            for(int j=i+1;j<n;j++)\\n            {\\n                pow=(pow*31)%mod;\\n                hash[i][j]=(hash[i][j-1]%mod+pow*(text[j]-\\'a\\'+1)%mod)%mod;\\n            }\\n        }\\n        \\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i;j<n;j++)\\n            {\\n                int sz=j-i+1;\\n                if(j+sz>=n) continue;\\n                if(hash[i][j]==hash[j+1][j+sz])\\n                {\\n                    if(MP[hash[i][j]]==0) ans++;\\n                    MP[hash[i][j]]++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 823967,
                "title": "python-3-utilize-dictionary",
                "content": "```\\n def distinctEchoSubstrings(self, text: str) -> int:\\n        l = len(text)\\n        dic = {}\\n        if l == 0:\\n            return 0\\n        for start in range(l-1):    \\n            for end in range(l, start, -1):  \\n                diff = end - start\\n                if (diff %2) == 0 and text[start:diff//2 + start] == text[diff//2 + start:end]:\\n                    dic[text[start:end]] = 1              \\n        return len(list(dic.keys()))",
                "solutionTags": [],
                "code": "```\\n def distinctEchoSubstrings(self, text: str) -> int:\\n        l = len(text)\\n        dic = {}\\n        if l == 0:\\n            return 0\\n        for start in range(l-1):    \\n            for end in range(l, start, -1):  \\n                diff = end - start\\n                if (diff %2) == 0 and text[start:diff//2 + start] == text[diff//2 + start:end]:\\n                    dic[text[start:end]] = 1              \\n        return len(list(dic.keys()))",
                "codeTag": "Python3"
            },
            {
                "id": 798864,
                "title": "ruby-beats-100",
                "content": "* Record every char\\'s indexes.\\n* Use **sum[i]** the record the sum from **index 0** to **index i** in ord.\\n* For every **index i** of every char, find the **index j** in the rest:\\n\\t* compare the sum[i..j] with sum[j..l]\\n\\t* compare the text[i..j] with sum[j..l]\\n\\t* mark the text[i..j]\\n\\n```\\nA_ORD = \\'a\\'.ord\\n\\ndef distinct_echo_substrings(text)\\n  hash, sum = {}, [0]\\n  text.chars.each_with_index do |char, i|\\n    hash[char] ||= []\\n    hash[char] << i\\n    sum[i+1] = sum[i] + (char.ord - A_ORD + 1)\\n  end\\n\\n  mark = {}\\n  hash.each do |char, indexes|\\n    (0..indexes.size-2).each do |i|\\n      (i+1..indexes.size-1).each do |j|\\n        l = indexes[j] - indexes[i]\\n        sum1 = sum[indexes[j]] - sum[indexes[i]]\\n        next if indexes[i]+l > text.size\\n        sum2 = sum[indexes[i]+l] - sum[indexes[i]]\\n        next if sum1 != sum2\\n        s1 = text[indexes[i], l]\\n        next if mark[s1]\\n        s2 = text[indexes[j], l]\\n        mark[s1] = true if s1 == s2\\n      end\\n    end\\n  end\\n  mark.size\\nend\\n```\\n",
                "solutionTags": [],
                "code": "```\\nA_ORD = \\'a\\'.ord\\n\\ndef distinct_echo_substrings(text)\\n  hash, sum = {}, [0]\\n  text.chars.each_with_index do |char, i|\\n    hash[char] ||= []\\n    hash[char] << i\\n    sum[i+1] = sum[i] + (char.ord - A_ORD + 1)\\n  end\\n\\n  mark = {}\\n  hash.each do |char, indexes|\\n    (0..indexes.size-2).each do |i|\\n      (i+1..indexes.size-1).each do |j|\\n        l = indexes[j] - indexes[i]\\n        sum1 = sum[indexes[j]] - sum[indexes[i]]\\n        next if indexes[i]+l > text.size\\n        sum2 = sum[indexes[i]+l] - sum[indexes[i]]\\n        next if sum1 != sum2\\n        s1 = text[indexes[i], l]\\n        next if mark[s1]\\n        s2 = text[indexes[j], l]\\n        mark[s1] = true if s1 == s2\\n      end\\n    end\\n  end\\n  mark.size\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 786428,
                "title": "python3-illustrated-one-line-solution",
                "content": "![image](https://assets.leetcode.com/users/images/352db6f8-f5e1-453b-b247-0039670e2462_1597175114.4900339.png)\\n\\n![image](https://assets.leetcode.com/users/images/c1f070f5-1cf7-4652-84b9-7b796d5cdf77_1597175124.2101493.png)\\n\\n\\n```\\n    def distinctEchoSubstrings(self, text: str) -> int:  # pylint: disable=invalid-name\\n\\n        variants = [text[x:y] for x, y in itertools.combinations(range(len(text) + 1), r=2) if y - x > 1 and (y - x) % 2 == 0 and (size := (y - x) // 2) > 0 and text[x:x + size] == text[x + size:y]]\\n        return len(set(variants))\\n```",
                "solutionTags": [],
                "code": "```\\n    def distinctEchoSubstrings(self, text: str) -> int:  # pylint: disable=invalid-name\\n\\n        variants = [text[x:y] for x, y in itertools.combinations(range(len(text) + 1), r=2) if y - x > 1 and (y - x) % 2 == 0 and (size := (y - x) // 2) > 0 and text[x:x + size] == text[x + size:y]]\\n        return len(set(variants))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 726795,
                "title": "python-accepted-simple-brute-force",
                "content": "Simple brute works. Given substring size of 1 to (n/2) , \\n- find all substrings, compare\\n- Add to set if left == right\\n- Return length\\n```\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        st = set()\\n        for s in range(1, 1 + len(text) // 2):\\n            for start in range(len(text)):\\n                l = text[start:start+s]\\n                r = text[start+s:start+s+s]\\n                if l == r and (l+r) not in st and len(l) != 0:\\n                    st.add(l+r)\\n        return len(st)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        st = set()\\n        for s in range(1, 1 + len(text) // 2):\\n            for start in range(len(text)):\\n                l = text[start:start+s]\\n                r = text[start+s:start+s+s]\\n                if l == r and (l+r) not in st and len(l) != 0:\\n                    st.add(l+r)\\n        return len(st)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 644173,
                "title": "python-accepted-solution-iterating-on-indexes-having-same-character",
                "content": "```\\nclass Solution(object):\\n    def distinctEchoSubstrings(self, text):\\n        \"\"\"\\n        :type text: str\\n        :rtype: int\\n        \"\"\"\\n        if not text: return 0\\n        \\n        prefixSum = [0]\\n        \\n        for char in text:\\n            prefixSum.append(prefixSum[-1] + ord(char))\\n        \\n        from collections import defaultdict\\n        indexes = defaultdict(list)\\n        \\n        for i in range(len(text)):\\n            indexes[text[i]].append(i)\\n        \\n        seen = set()\\n        for char in sorted(indexes.keys()):\\n            for i in range(len(indexes[char]) - 1):\\n                for j in range(i+1, len(indexes[char])):\\n                    ind1 = indexes[char][i]\\n                    ind2 = indexes[char][j]\\n                    length = ind2 - ind1\\n                    if ind2 + length > len(text):\\n                        break\\n                    if (prefixSum[ind2] - prefixSum[ind1]) == (prefixSum[ind2+length] - prefixSum[ind2]):\\n                        if text[ind1: ind2] == text[ind2:ind2+length]:\\n                            seen.add(text[ind1:ind2+length])\\n        return len(seen)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def distinctEchoSubstrings(self, text):\\n        \"\"\"\\n        :type text: str\\n        :rtype: int\\n        \"\"\"\\n        if not text: return 0\\n        \\n        prefixSum = [0]\\n        \\n        for char in text:\\n            prefixSum.append(prefixSum[-1] + ord(char))\\n        \\n        from collections import defaultdict\\n        indexes = defaultdict(list)\\n        \\n        for i in range(len(text)):\\n            indexes[text[i]].append(i)\\n        \\n        seen = set()\\n        for char in sorted(indexes.keys()):\\n            for i in range(len(indexes[char]) - 1):\\n                for j in range(i+1, len(indexes[char])):\\n                    ind1 = indexes[char][i]\\n                    ind2 = indexes[char][j]\\n                    length = ind2 - ind1\\n                    if ind2 + length > len(text):\\n                        break\\n                    if (prefixSum[ind2] - prefixSum[ind1]) == (prefixSum[ind2+length] - prefixSum[ind2]):\\n                        if text[ind1: ind2] == text[ind2:ind2+length]:\\n                            seen.add(text[ind1:ind2+length])\\n        return len(seen)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 627432,
                "title": "easy-python-solution-with-comments-incl-time-space-complexity-analysis",
                "content": "```\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        count = 0\\n\\t\\t# prevents overcounting\\n        seen = set()\\n\\t\\t# try every possible repeating substring length; e.g.\\n\\t\\t# substring \\'abcabcabc\\' has a repeating substring length of 3\\n\\t\\t# note: the maximum length of such a substring is len(text) // 2\\n        for k in range(1, len(text) // 2 + 1):\\n\\t\\t\\t# search every possible starting position in `text` for \\n\\t\\t\\t# our repeating substring\\n            for i in range(len(text) - k):\\n\\t\\t\\t\\t# we *only* need to know that the substring repeats at\\n\\t\\t\\t\\t# *least* twice in order to count it, so we check for two\\n\\t\\t\\t\\t# repetitions\\n                s1 = text[i:i+k]\\n                s2 = text[i+k:i+2*k]\\n                if s1 == s2 and s1 not in seen:\\n                    count += 1\\n\\t\\t\\t\\t\\t# in the case where a substring repeats more than twice,\\n\\t\\t\\t\\t\\t# we must ensure we don\\'t overcount\\n                    seen.add(s1)\\n\\t\\t\\t# reset `seen` every time we start searching for subsets of a different size\\n\\t\\t\\tseen = set()\\n        return count\\n```\\n\\n**Time-complexity**\\nLet *n* be the length of our input text. The number of times the inner loop is executed is: (n - 1) + (n - 2) + (n - 3) + ... + (n - n/2) ... further, the comparison of `s1` and `s2` costs `k`. The total \"steps\" taken by the algorithm is thus: (n - 1) + 2*(n - 2) + 3*(n - 3) + ... + n/2(n - n/2) = sum_{i}^{n/2} (i\\\\*n - i^2) which, when you apply the various rules of summations, you get O(n^3). Note that this algorithm could be made O(n^2) (expected) if instead of doing a direct string comparison, we first hash `s1` and `s2`.\\n\\n**Space-complexity**\\nWe empty `seen` every time we start searching for a substring of a different length. Worst case, in terms of space complexity, is when `text` looks something like this: \"aabbccddeeff\" in which case seen, at the end of iteration where n == 1 will look like this: {\"aa\", \"bb\", \"cc\", \"dd\", \"ee\", \"ff\"}. That is, space complexity is O(n).",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        count = 0\\n\\t\\t# prevents overcounting\\n        seen = set()\\n\\t\\t# try every possible repeating substring length; e.g.\\n\\t\\t# substring \\'abcabcabc\\' has a repeating substring length of 3\\n\\t\\t# note: the maximum length of such a substring is len(text) // 2\\n        for k in range(1, len(text) // 2 + 1):\\n\\t\\t\\t# search every possible starting position in `text` for \\n\\t\\t\\t# our repeating substring\\n            for i in range(len(text) - k):\\n\\t\\t\\t\\t# we *only* need to know that the substring repeats at\\n\\t\\t\\t\\t# *least* twice in order to count it, so we check for two\\n\\t\\t\\t\\t# repetitions\\n                s1 = text[i:i+k]\\n                s2 = text[i+k:i+2*k]\\n                if s1 == s2 and s1 not in seen:\\n                    count += 1\\n\\t\\t\\t\\t\\t# in the case where a substring repeats more than twice,\\n\\t\\t\\t\\t\\t# we must ensure we don\\'t overcount\\n                    seen.add(s1)\\n\\t\\t\\t# reset `seen` every time we start searching for subsets of a different size\\n\\t\\t\\tseen = set()\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 585104,
                "title": "c-solution-24ms-clear-explanation",
                "content": "### Solution:\\n\\nIntuitively, solution is to compare every substrings and check whether a substring is a concatenation of a original string: `abcabc` from `abc` .\\n\\n1. Traverse every slots between characters of the string.\\n2. From the current slot, keep checking the left string and the right string with the equal length.\\n3. If the left string equals to the right string, put the string to an `unoredered_set` for removing the duplicates.\\n\\nNoted, consider to use `string_view` instead of `string` to reduce the complexity of creating new substrings.\\n\\n    class Solution {\\n    public:\\n        int distinctEchoSubstrings(string text) {\\n            int len = text.size();\\n            unordered_set<string_view> count;\\n            const char *p = text.c_str();\\n            for (int i = 1; i < len - 1; ++i) {\\n                int diff = min(i, len - i);\\n                int start = i - diff;\\n                for (int j = start; j < i; ++j) {\\n                    const string_view left(p + j, i - j);\\n                    const string_view right(p + i, i - j);\\n                    // auto left = text.substr(j, i - j);\\n                    // auto right = text.substr(i, i - j);\\n                    // cout << left << \", \" << right << endl;\\n                    if (left == right) {\\n                        count.insert(left);\\n                    }\\n                }\\n            }\\n            \\n            return count.size();\\n        }\\n    };\\n\\nThe solution results in `672 ms` for time and `7.1 mb` for space.\\n\\nFirst optimization is to reduce the number of created `string_view` substrings. To accomplish this, just simply check one-by-one character between the left substring and the right substring of the current slot.\\n\\n                ...\\n                for (int j = start; j < i; ++j) {\\n                    int l = j;\\n                    int r = i;\\n                    int c = 0;\\n                    while (l < i) {\\n                        if (p[l++] == p[r++]) {\\n                            ++c;\\n                        } else {\\n                            break;\\n                        }\\n                    }\\n    \\n                    if (c == i - j) {\\n                        count.insert(string_view(p + j, c)); // (*)\\n                    }\\n                }\\n                ...\\n\\nThis optimization is good, but we can do better. Further optimization is at asterisk `(*)` line. Here we just insert a new string into the `unordered_set` and use the set\\'s characteristic to remove the duplicates. However, there are still duplicated works. For example, given string:\\n\\n    string s = \"aaaaaa\";\\n\\nThere will be several times that we will compare multiple substrings with the same value as `aa` followed by many times processing the substrings `a`. So, we can early terminate here and the full final solution is below.\\n\\n    class Solution {\\n    public:\\n        int distinctEchoSubstrings(string text) {\\n            int len = text.size();\\n            unordered_set<string_view> count;\\n            const char *p = text.c_str();\\n            for (int i = 0; i < len; ++i) {\\n                int diff = min(i, len - i);\\n                int start = i - diff;\\n                for (int j = start; j < i; ++j) {\\n                    int l = j;\\n                    int r = i;\\n                    int c = 0;\\n                    while (l < i) {\\n                        if (p[l++] == p[r++]) {\\n                            ++c;\\n                        } else {\\n                            break;\\n                        }\\n                    }\\n                    \\n                    if (c == i - j) {\\n                        auto s = string_view(p + j, c);\\n                        if (count.count(s) == 0) {\\n                            count.insert(s);\\n                        } else {\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n            \\n            return count.size();\\n        }\\n    };\\n\\nNew result: `24 ms` and `7.3 mb` . Done !!!",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int distinctEchoSubstrings(string text) {\\n            int len = text.size();\\n            unordered_set<string_view> count;\\n            const char *p = text.c_str();\\n            for (int i = 1; i < len - 1; ++i) {\\n                int diff = min(i, len - i);\\n                int start = i - diff;\\n                for (int j = start; j < i; ++j) {\\n                    const string_view left(p + j, i - j);\\n                    const string_view right(p + i, i - j);\\n                    // auto left = text.substr(j, i - j);\\n                    // auto right = text.substr(i, i - j);\\n                    // cout << left << \", \" << right << endl;\\n                    if (left == right) {\\n                        count.insert(left);\\n                    }",
                "codeTag": "C++"
            },
            {
                "id": 563429,
                "title": "rust-hash-solution",
                "content": "```\\nuse std::collections::HashSet;\\nuse std::ops::RangeInclusive;\\n\\nconst PRIME: u128 = 29;\\n\\n#[derive(Debug)]\\nstruct RabinKarp {\\n    arr: Vec<u128>,\\n}\\n\\nimpl RabinKarp {\\n    fn new(data: &str) -> Self {\\n        let arr = data\\n            .chars()\\n            .enumerate()\\n            .scan(0, |acc, (ind, chr)| {\\n                let cur = (chr as u128) - (\\'a\\' as u128) + 1;\\n                *acc = *acc + cur * PRIME.pow(ind as u32);\\n                Some(*acc)\\n            })\\n            .collect();\\n\\n        RabinKarp { arr }\\n    }\\n\\n    fn get_hash(&self, range: RangeInclusive<usize>) -> u128 {\\n        let hash = if *range.start() > 0 {\\n            self.arr[*range.end()] - self.arr[*range.start() - 1]\\n        } else {\\n            self.arr[*range.end()]\\n        };\\n\\n        hash * PRIME.pow((self.arr.len() - *range.start()) as u32)\\n    }\\n\\n    fn is_same(&self, first: RangeInclusive<usize>, second: RangeInclusive<usize>) -> bool {\\n        self.get_hash(first) == self.get_hash(second)\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn distinct_echo_substrings(text: String) -> i32 {\\n        let hash = RabinKarp::new(&text);\\n        let mut answer = 0;\\n\\n        for len in (2..=text.len()).step_by(2) {\\n            let mut substrings: HashSet<u128> = HashSet::new();\\n            for i in (len - 1)..text.len() {\\n                let mid = (i + i - len) / 2;\\n                let left = (i - len + 1)..=mid;\\n                let right = mid + 1..=i;\\n                if hash.is_same(left, right) {\\n                    let slice = (i - len + 1)..=i;\\n                    substrings.insert(hash.get_hash(slice));\\n                }\\n            }\\n            answer += substrings.len() as i32;\\n        }\\n\\n        answer\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nuse std::collections::HashSet;\\nuse std::ops::RangeInclusive;\\n\\nconst PRIME: u128 = 29;\\n\\n#[derive(Debug)]\\nstruct RabinKarp {\\n    arr: Vec<u128>,\\n}\\n\\nimpl RabinKarp {\\n    fn new(data: &str) -> Self {\\n        let arr = data\\n            .chars()\\n            .enumerate()\\n            .scan(0, |acc, (ind, chr)| {\\n                let cur = (chr as u128) - (\\'a\\' as u128) + 1;\\n                *acc = *acc + cur * PRIME.pow(ind as u32);\\n                Some(*acc)\\n            })\\n            .collect();\\n\\n        RabinKarp { arr }\\n    }\\n\\n    fn get_hash(&self, range: RangeInclusive<usize>) -> u128 {\\n        let hash = if *range.start() > 0 {\\n            self.arr[*range.end()] - self.arr[*range.start() - 1]\\n        } else {\\n            self.arr[*range.end()]\\n        };\\n\\n        hash * PRIME.pow((self.arr.len() - *range.start()) as u32)\\n    }\\n\\n    fn is_same(&self, first: RangeInclusive<usize>, second: RangeInclusive<usize>) -> bool {\\n        self.get_hash(first) == self.get_hash(second)\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn distinct_echo_substrings(text: String) -> i32 {\\n        let hash = RabinKarp::new(&text);\\n        let mut answer = 0;\\n\\n        for len in (2..=text.len()).step_by(2) {\\n            let mut substrings: HashSet<u128> = HashSet::new();\\n            for i in (len - 1)..text.len() {\\n                let mid = (i + i - len) / 2;\\n                let left = (i - len + 1)..=mid;\\n                let right = mid + 1..=i;\\n                if hash.is_same(left, right) {\\n                    let slice = (i - len + 1)..=i;\\n                    substrings.insert(hash.get_hash(slice));\\n                }\\n            }\\n            answer += substrings.len() as i32;\\n        }\\n\\n        answer\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 561453,
                "title": "faster-than-100-rust-solutions-116ms-o-n-2-hashing-solution",
                "content": "```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn distinct_echo_substrings(text: String) -> i32 {\\n        const P1 : i32 = 127;\\n        const M1 : i32 = 75798632;\\n        const P2 : i32 = 1007;\\n        const M2 : i32 = 665729789;\\n        \\n        let data = text.as_bytes();\\n        let N = data.len();\\n        let mut hash = vec![vec![(0, 0); N]; N];\\n        \\n        for i in 0..N {\\n            hash[i][i] = (data[i] as i32, data[i] as i32);\\n            for j in (i+1)..N {\\n                hash[i][j] = (\\n                    (hash[i][j-1].0 * P1 + data[j] as i32) % M1,\\n                    (hash[i][j-1].0 * P2 + data[j] as i32) % M2\\n                );\\n            }\\n        }\\n        \\n        let mut ans = 0;\\n        \\n        for len in 1..=(N/2) {\\n            let mut exists = HashSet::new();\\n            for i in 0..=(N-len*2) {\\n                if hash[i][i+len-1] == hash[i+len][i+len*2-1] {\\n                    exists.insert(hash[i][i+len-1]);\\n                }\\n            }\\n            ans += exists.len() as i32;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn distinct_echo_substrings(text: String) -> i32 {\\n        const P1 : i32 = 127;\\n        const M1 : i32 = 75798632;\\n        const P2 : i32 = 1007;\\n        const M2 : i32 = 665729789;\\n        \\n        let data = text.as_bytes();\\n        let N = data.len();\\n        let mut hash = vec![vec![(0, 0); N]; N];\\n        \\n        for i in 0..N {\\n            hash[i][i] = (data[i] as i32, data[i] as i32);\\n            for j in (i+1)..N {\\n                hash[i][j] = (\\n                    (hash[i][j-1].0 * P1 + data[j] as i32) % M1,\\n                    (hash[i][j-1].0 * P2 + data[j] as i32) % M2\\n                );\\n            }\\n        }\\n        \\n        let mut ans = 0;\\n        \\n        for len in 1..=(N/2) {\\n            let mut exists = HashSet::new();\\n            for i in 0..=(N-len*2) {\\n                if hash[i][i+len-1] == hash[i+len][i+len*2-1] {\\n                    exists.insert(hash[i][i+len-1]);\\n                }\\n            }\\n            ans += exists.len() as i32;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 557415,
                "title": "accepted-c-hashing-solution",
                "content": "```\\npublic class Solution\\n    {\\n        public int DistinctEchoSubstrings(string str)\\n        {\\n            checked\\n            {\\n                int n = str.Length;\\n                int @base = 27;\\n                long modulus = (long)Math.Pow(2, 31);\\n\\n                long[] aL = new long[n + 1];\\n                long al = 1;\\n                long h = 0;\\n                long[] hLeftToRight = new long[n];\\n\\n                for (int i = 0; i < n; ++i)\\n                {\\n                    var num = (long)(str[i] - \\'a\\' + 1);\\n                    al = (al * @base) % modulus;\\n                    aL[i + 1] = al;\\n\\n                    h = (h * @base + num) % modulus;\\n                    hLeftToRight[i] = h;\\n                }\\n\\n                ISet<long> res = new HashSet<long>();\\n\\n                for (int start = 0; start < str.Length - 1; start++)\\n                {\\n                    for (int end = start + 1; end < str.Length; end+=2)\\n                    {\\n                        int length = end - start + 1;\\n                        int halfLength = length / 2;\\n                        int leftEnd = start + halfLength - 1;\\n\\n                        long leftSubstr = hLeftToRight[leftEnd];\\n                        int excludeIdx = start - 1;\\n\\n                        if (excludeIdx >= 0)\\n                        {\\n                            long longExclude = hLeftToRight[excludeIdx] * aL[halfLength] % modulus;\\n\\n                            leftSubstr -= longExclude;\\n                            leftSubstr += modulus;\\n                            leftSubstr %= modulus;\\n                        }\\n\\n\\n                        long rightSubstr = hLeftToRight[end];\\n                        excludeIdx = leftEnd;\\n\\n                        if (excludeIdx >= 0)\\n                        {\\n                            long longExclude = hLeftToRight[excludeIdx] * aL[halfLength] % modulus;\\n\\n                            rightSubstr -= longExclude;\\n                            rightSubstr += modulus;\\n                            rightSubstr %= modulus;\\n                        }\\n\\n                        if (leftSubstr == rightSubstr)\\n                        {\\n                            res.Add(leftSubstr);\\n                        }\\n                    }\\n                }\\n\\n                return res.Count;\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n    {\\n        public int DistinctEchoSubstrings(string str)\\n        {\\n            checked\\n            {\\n                int n = str.Length;\\n                int @base = 27;\\n                long modulus = (long)Math.Pow(2, 31);\\n\\n                long[] aL = new long[n + 1];\\n                long al = 1;\\n                long h = 0;\\n                long[] hLeftToRight = new long[n];\\n\\n                for (int i = 0; i < n; ++i)\\n                {\\n                    var num = (long)(str[i] - \\'a\\' + 1);\\n                    al = (al * @base) % modulus;\\n                    aL[i + 1] = al;\\n\\n                    h = (h * @base + num) % modulus;\\n                    hLeftToRight[i] = h;\\n                }\\n\\n                ISet<long> res = new HashSet<long>();\\n\\n                for (int start = 0; start < str.Length - 1; start++)\\n                {\\n                    for (int end = start + 1; end < str.Length; end+=2)\\n                    {\\n                        int length = end - start + 1;\\n                        int halfLength = length / 2;\\n                        int leftEnd = start + halfLength - 1;\\n\\n                        long leftSubstr = hLeftToRight[leftEnd];\\n                        int excludeIdx = start - 1;\\n\\n                        if (excludeIdx >= 0)\\n                        {\\n                            long longExclude = hLeftToRight[excludeIdx] * aL[halfLength] % modulus;\\n\\n                            leftSubstr -= longExclude;\\n                            leftSubstr += modulus;\\n                            leftSubstr %= modulus;\\n                        }\\n\\n\\n                        long rightSubstr = hLeftToRight[end];\\n                        excludeIdx = leftEnd;\\n\\n                        if (excludeIdx >= 0)\\n                        {\\n                            long longExclude = hLeftToRight[excludeIdx] * aL[halfLength] % modulus;\\n\\n                            rightSubstr -= longExclude;\\n                            rightSubstr += modulus;\\n                            rightSubstr %= modulus;\\n                        }\\n\\n                        if (leftSubstr == rightSubstr)\\n                        {\\n                            res.Add(leftSubstr);\\n                        }\\n                    }\\n                }\\n\\n                return res.Count;\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 554241,
                "title": "c-record-the-previous-position",
                "content": "~~~\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        vector<int> alp(26,-1);\\n        vector<int> hmap(text.size(), -1);\\n        for(int i=0; i<text.size(); i++){\\n            hmap[i] = alp[text[i]-\\'a\\'];   //Record the Previous Position\\n            alp[text[i]-\\'a\\'] = i;\\n        }\\n        unordered_set<string> hset;\\n        vector<int> consec(26,0);\\n        \\n        int res = 0;\\n        for(int i=0; i<text.size(); i++){\\n            if(hmap[i]==-1) continue;\\n            int cur = i;\\n            while(cur>=0 && text.at(cur)==text.at(i))\\n                cur--;      //record the longest single-letter-repeated substring\\n            consec[text.at(i)-\\'a\\'] = max(consec[text.at(i)-\\'a\\'], i-cur);\\n            cur++;\\n            int ind = hmap[cur];\\n            while(ind!=-1){\\n                if(ind+1< i-ind)    break;\\n                int dis = i - ind;\\n                string s1 = text.substr(ind-(dis-1), dis);\\n                string s2 = text.substr(ind+1, dis);\\n                if(s1==s2 && !hset.count(s1)){\\n                    hset.insert(s1);\\n                    res++;\\n                }\\n                ind = hmap[ind];\\n            }\\n        }\\n        \\n        for(int ele:consec) // deal with the single-letter-repeated cases\\n            res += ele/2;\\n        return res;\\n    }\\n};\\n~~~",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        vector<int> alp(26,-1);\\n        vector<int> hmap(text.size(), -1);\\n        for(int i=0; i<text.size(); i++){\\n            hmap[i] = alp[text[i]-\\'a\\'];   //Record the Previous Position\\n            alp[text[i]-\\'a\\'] = i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 550823,
                "title": "testcase-doubt",
                "content": "One of the test case is failing but cannot understand why\\n\"aaaaaaaaaa\"\\nOutput is showing 5, can anyone explain how?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 539575,
                "title": "trie-solution-o-n-2-but-fails-one-test-case",
                "content": "Idea is to put all suffix of `text` to a trie, the dfs on the trie. For each node on the trie, the path from root to that node represents a unique substring. Just need to store the ending positions of these substrings, then we can check if a substring appears twice in a row.\\n\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        # n^2 Trie. Fails one test case.\\n        trie = {\\'pos\\': set()}\\n        n = len(text)\\n        def add_trie(text, s):\\n            p = trie\\n            for i in range(s, n):\\n                c = text[i]\\n                if c not in p:\\n                    p[c] = {\\'pos\\': set()}\\n                p = p[c]\\n                p[\\'pos\\'].add(i)\\n                \\n        def dfs(node, l):\\n            for p in node[\\'pos\\']:\\n                if p + l in node[\\'pos\\']:\\n                    self.res += 1\\n                    break\\n            for c in node:\\n                if c != \\'pos\\' and len(node[c][\\'pos\\']) >= 2:\\n                    dfs(node[c], l+1)\\n            \\n        \\n        for i in range(n):\\n            add_trie(text, i)\\n        self.res = 0\\n        dfs(trie, 0)\\n        return self.res\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        # n^2 Trie. Fails one test case.\\n        trie = {\\'pos\\': set()}\\n        n = len(text)\\n        def add_trie(text, s):\\n            p = trie\\n            for i in range(s, n):\\n                c = text[i]\\n                if c not in p:\\n                    p[c] = {\\'pos\\': set()}\\n                p = p[c]\\n                p[\\'pos\\'].add(i)\\n                \\n        def dfs(node, l):\\n            for p in node[\\'pos\\']:\\n                if p + l in node[\\'pos\\']:\\n                    self.res += 1\\n                    break\\n            for c in node:\\n                if c != \\'pos\\' and len(node[c][\\'pos\\']) >= 2:\\n                    dfs(node[c], l+1)\\n            \\n        \\n        for i in range(n):\\n            add_trie(text, i)\\n        self.res = 0\\n        dfs(trie, 0)\\n        return self.res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 523343,
                "title": "simple-java-solution-easy-to-understand",
                "content": "Use a hashmap to record the positions of each character and find same string with same first character.\\n```\\nclass Solution {\\n    public int distinctEchoSubstrings(String text) {\\n        HashMap<Character, List<Integer>> map = new HashMap<>();\\n        char[] chars = text.toCharArray();\\n        for (int i = 0; i < chars.length; i++) {\\n            if (!map.containsKey(chars[i])) {\\n                map.put(chars[i], new LinkedList<Integer>());\\n            }\\n            map.get(chars[i]).add(i);\\n        }// O(n)\\n        HashSet<String> set = new HashSet<>();\\n        for (char c: map.keySet()) {\\n            List<Integer> list = map.get(c);\\n            if (list.size() <= 1)\\n                continue;\\n            StringBuilder sb = new StringBuilder();\\n            for (int i: list) {\\n                for (int j: list) {\\n                    int tmpLen = j - i;\\n                    if (i >= j || j + tmpLen > text.length())\\n                        continue;\\n                    if (text.substring(i, j).equals(text.substring(j, j +tmpLen))) {\\n                        set.add(text.substring(i, j)); \\n                    }\\n                }\\n            }\\n        }// O(n2)\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int distinctEchoSubstrings(String text) {\\n        HashMap<Character, List<Integer>> map = new HashMap<>();\\n        char[] chars = text.toCharArray();\\n        for (int i = 0; i < chars.length; i++) {\\n            if (!map.containsKey(chars[i])) {\\n                map.put(chars[i], new LinkedList<Integer>());\\n            }\\n            map.get(chars[i]).add(i);\\n        }// O(n)\\n        HashSet<String> set = new HashSet<>();\\n        for (char c: map.keySet()) {\\n            List<Integer> list = map.get(c);\\n            if (list.size() <= 1)\\n                continue;\\n            StringBuilder sb = new StringBuilder();\\n            for (int i: list) {\\n                for (int j: list) {\\n                    int tmpLen = j - i;\\n                    if (i >= j || j + tmpLen > text.length())\\n                        continue;\\n                    if (text.substring(i, j).equals(text.substring(j, j +tmpLen))) {\\n                        set.add(text.substring(i, j)); \\n                    }\\n                }\\n            }\\n        }// O(n2)\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 510415,
                "title": "o-n-2-solution-using-trie-without-rolling-hash",
                "content": "The idea is simple. We look for valid substrings of length **1,2...N** .\\n\\nOur final answer will reside in variable **ans**.\\nNow for say some length say **l**,\\nWe maintain a **Trie T** which will hold valid substrings to avoid duplicates.\\nWe compare characters starting at \\n**i = 0, j = i + l**\\nand as long as they are equal, we increment a count **c** and also add it to a buffer **buf**.\\nIf the **c** goes all the way till **l**, then we have a valid substring and add **buf** to **T** (only if it\\'s not already there) and increment the **ans** variable. \\nWhen we slide the window, we keep the amount of match we had in previous window (*both buf and c are kept as it is, just that we remove one character from buf and decrement c by 1 to account for the outgoing character from the window*).\\nThis way we can simply solve in one iteration per length l.\\n\\n***TC = O(n^2)\\nSC = O(n^2)*\\n\\n```\\nclass Solution {\\n    \\n\\t// CODE FOR TRIE\\n    public static class Trie { \\n      \\n    // Alphabet size (# of symbols) \\n    static final int ALPHABET_SIZE = 26; \\n      \\n    // trie node \\n    public static class TrieNode \\n    { \\n        TrieNode[] children = new TrieNode[ALPHABET_SIZE]; \\n       \\n        // isEndOfWord is true if the node represents \\n        // end of a word \\n        boolean isEndOfWord; \\n          \\n        TrieNode(){ \\n            isEndOfWord = false; \\n            for (int i = 0; i < ALPHABET_SIZE; i++) \\n                children[i] = null; \\n        } \\n    }; \\n       \\n    static TrieNode root;  \\n      \\n    // If not present, inserts key into trie \\n    // If the key is prefix of trie node,  \\n    // just marks leaf node \\n    static void insert(String key) \\n    { \\n        int level; \\n        int length = key.length(); \\n        int index; \\n       \\n        TrieNode pCrawl = root; \\n       \\n        for (level = 0; level < length; level++) \\n        { \\n            index = key.charAt(level) - \\'a\\'; \\n            if (pCrawl.children[index] == null) \\n                pCrawl.children[index] = new TrieNode(); \\n       \\n            pCrawl = pCrawl.children[index]; \\n        } \\n       \\n        // mark last node as leaf \\n        pCrawl.isEndOfWord = true; \\n    } \\n       \\n    // Returns true if key presents in trie, else false \\n    static boolean search(String key) \\n    { \\n        int level; \\n        int length = key.length(); \\n        int index; \\n        TrieNode pCrawl = root; \\n       \\n        for (level = 0; level < length; level++) \\n        { \\n            index = key.charAt(level) - \\'a\\'; \\n       \\n            if (pCrawl.children[index] == null) \\n                return false; \\n       \\n            pCrawl = pCrawl.children[index]; \\n        } \\n       \\n        return (pCrawl != null && pCrawl.isEndOfWord); \\n    } \\n} \\n    \\n\\t\\n\\t// ACTUAL SOLUTION\\n    public int distinctEchoSubstrings(String text) {\\n        int ans = 0;\\n        int N = text.length();\\n        for(int l=1;l<=N;l++) {\\n            // System.out.println(\"l: \" + l);\\n            \\n            int i = 0;\\n            int c = 0;\\n            StringBuilder buf = new StringBuilder();\\n            Trie.root = new Trie.TrieNode();\\n            while(i < N) {\\n                int start = i;\\n                int j = i + l;\\n                // System.out.println(\"i: \" + i + \", j: \" + j);\\n                \\n                if(j < N) {\\n                    while(j < N && c < l && text.charAt(j) == text.charAt(i)) {\\n                        buf.append(text.charAt(i));\\n                        i++;\\n                        j++;\\n                        c++;\\n                    }\\n                    \\n                    // System.out.println(\"c: \" + c);\\n                    if(c == l) {\\n                        String str = buf.toString();\\n                        if(!Trie.search(str)) {\\n                            Trie.insert(str);\\n                            ans++;\\n                        }\\n                    }\\n                    if(c == 0) {\\n                        i++;\\n                    }\\n                    else {\\n                        buf = buf.deleteCharAt(0);\\n                        c--;\\n                    }\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n\\t// CODE FOR TRIE\\n    public static class Trie { \\n      \\n    // Alphabet size (# of symbols) \\n    static final int ALPHABET_SIZE = 26; \\n      \\n    // trie node \\n    public static class TrieNode \\n    { \\n        TrieNode[] children = new TrieNode[ALPHABET_SIZE]; \\n       \\n        // isEndOfWord is true if the node represents \\n        // end of a word \\n        boolean isEndOfWord; \\n          \\n        TrieNode(){ \\n            isEndOfWord = false; \\n            for (int i = 0; i < ALPHABET_SIZE; i++) \\n                children[i] = null; \\n        } \\n    }; \\n       \\n    static TrieNode root;  \\n      \\n    // If not present, inserts key into trie \\n    // If the key is prefix of trie node,  \\n    // just marks leaf node \\n    static void insert(String key) \\n    { \\n        int level; \\n        int length = key.length(); \\n        int index; \\n       \\n        TrieNode pCrawl = root; \\n       \\n        for (level = 0; level < length; level++) \\n        { \\n            index = key.charAt(level) - \\'a\\'; \\n            if (pCrawl.children[index] == null) \\n                pCrawl.children[index] = new TrieNode(); \\n       \\n            pCrawl = pCrawl.children[index]; \\n        } \\n       \\n        // mark last node as leaf \\n        pCrawl.isEndOfWord = true; \\n    } \\n       \\n    // Returns true if key presents in trie, else false \\n    static boolean search(String key) \\n    { \\n        int level; \\n        int length = key.length(); \\n        int index; \\n        TrieNode pCrawl = root; \\n       \\n        for (level = 0; level < length; level++) \\n        { \\n            index = key.charAt(level) - \\'a\\'; \\n       \\n            if (pCrawl.children[index] == null) \\n                return false; \\n       \\n            pCrawl = pCrawl.children[index]; \\n        } \\n       \\n        return (pCrawl != null && pCrawl.isEndOfWord); \\n    } \\n} \\n    \\n\\t\\n\\t// ACTUAL SOLUTION\\n    public int distinctEchoSubstrings(String text) {\\n        int ans = 0;\\n        int N = text.length();\\n        for(int l=1;l<=N;l++) {\\n            // System.out.println(\"l: \" + l);\\n            \\n            int i = 0;\\n            int c = 0;\\n            StringBuilder buf = new StringBuilder();\\n            Trie.root = new Trie.TrieNode();\\n            while(i < N) {\\n                int start = i;\\n                int j = i + l;\\n                // System.out.println(\"i: \" + i + \", j: \" + j);\\n                \\n                if(j < N) {\\n                    while(j < N && c < l && text.charAt(j) == text.charAt(i)) {\\n                        buf.append(text.charAt(i));\\n                        i++;\\n                        j++;\\n                        c++;\\n                    }\\n                    \\n                    // System.out.println(\"c: \" + c);\\n                    if(c == l) {\\n                        String str = buf.toString();\\n                        if(!Trie.search(str)) {\\n                            Trie.insert(str);\\n                            ans++;\\n                        }\\n                    }\\n                    if(c == 0) {\\n                        i++;\\n                    }\\n                    else {\\n                        buf = buf.deleteCharAt(0);\\n                        c--;\\n                    }\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 492546,
                "title": "scala-rolling-hash",
                "content": "i: denotes the hash and power values for the strings that ends at i-indexed char\\n\\n```Scala\\n  def distinctEchoSubstrings(text: String): Int = {\\n    \\n    val len = text.length\\n    val hash, power = Array.ofDim[Long](len)\\n    val base = 29L\\n    val mod = 1000000007L\\n    hash(0) = text.charAt(0)\\n    power(0) = base\\n\\n    for (i <- 1 until len) {\\n      hash(i) = ((hash(i - 1) * base) + text.charAt(i)) % mod\\n      power(i) = (base * power(i - 1)) % mod\\n    }\\n\\n    def h(start: Int, end: Int): Long = (hash(end) - (if (start - 1 >= 0) hash(start - 1) else 0) * power(end - start) % mod + mod) % mod\\n\\n\\n    import scala.collection.mutable.Set\\n    val counter = Set[Long]()\\n    for (d <- 1 to len - 1 by 2) {\\n      for (i <- 0 to len - 2 if (i + d < len)) {\\n        val mid = i + d / 2\\n        val h1 = h(i, mid)\\n        val h2 = h(mid + 1, i + d)\\n        if (h1 == h2) counter add h1\\n      }\\n    }\\n    counter.size\\n  }\\n```",
                "solutionTags": [],
                "code": "```Scala\\n  def distinctEchoSubstrings(text: String): Int = {\\n    \\n    val len = text.length\\n    val hash, power = Array.ofDim[Long](len)\\n    val base = 29L\\n    val mod = 1000000007L\\n    hash(0) = text.charAt(0)\\n    power(0) = base\\n\\n    for (i <- 1 until len) {\\n      hash(i) = ((hash(i - 1) * base) + text.charAt(i)) % mod\\n      power(i) = (base * power(i - 1)) % mod\\n    }\\n\\n    def h(start: Int, end: Int): Long = (hash(end) - (if (start - 1 >= 0) hash(start - 1) else 0) * power(end - start) % mod + mod) % mod\\n\\n\\n    import scala.collection.mutable.Set\\n    val counter = Set[Long]()\\n    for (d <- 1 to len - 1 by 2) {\\n      for (i <- 0 to len - 2 if (i + d < len)) {\\n        val mid = i + d / 2\\n        val h1 = h(i, mid)\\n        val h2 = h(mid + 1, i + d)\\n        if (h1 == h2) counter add h1\\n      }\\n    }\\n    counter.size\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 490113,
                "title": "c-o-n-2-rabin-karp-fingerprint-substring-search-from-algs4-not-faster-but-more-readable",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        // return func1(text);\\n        return func2(text.c_str(), text.length());\\n    }\\n\\n    // 1. Basic string compare solution, use hash-set do cache\\n    // Time: O(n^3) time, Space: O(n^2)\\n    int func1(string& text) {\\n        int N = text.length();\\n        unordered_set<string> set;\\n\\n        for (int len = 1; len <= N/2; len++) {\\n            for (int i = 0; i+2*len-1 < N; i++) {\\n                string s = text.substr(i, len);\\n                if (set.count(s) > 0) {\\n                    continue;\\n                }\\n                bool same = true;\\n                for (int j = 0; j < len; j++) {\\n                    if (text[i+j] != text[i+j+len]) {\\n                        same = false;\\n                        break;\\n                    }\\n                }\\n                if (same) {\\n                    set.emplace(s);\\n                }\\n            }\\n        }\\n        return set.size();\\n    }\\n\\n    /*\\n     * 2. Rabin-Karp substring search, Time: O(n^2), Space: O(1)\\n     * According to \"Algorithms, 4th Edition => 5.3 Substring Search => Rabin-Karp fingerprint search\"\\n     * Onile implement: https://algs4.cs.princeton.edu/53substring/  => RabinKarp.java\\n     *\\n     * My notes:\\n     * #1 Use `const char*` instead `string&` for text to pass into the functions.\\n     * #2 Should use string type `unordered_set<string> set` not `long type` to avoid collision.\\n     * #3 Base on #2, should do `RK_Recheck` when hash value is equal for sure.\\n     * #4 Do #2 and #3 will make the code too slow to pass.\\n     * #5 There are a lot of thing can be done to speed up my implement, for readable, I just leave it this way.\\n     */\\n    const int R = 26;        // There are only low letter in string\\n    const long Q = 1e13 + 7; // Random chose some big prime\\n\\n    int func2(const char* text, int N) {\\n        long RM = 1;\\n        // unordered_set<string> set;\\n        unordered_set<long> set;\\n\\n        for (int len = 1; len <= N/2; len++) {\\n            // M == len, use \\'M\\' to keep same to algs4\\'s implement\\n            int M = len;\\n            // long RM = RK_RM(M, R, Q);\\n            if (M > 1) {\\n                RM = RM * R % Q;\\n            }\\n            long curr_hash1 = 0;\\n            long curr_hash2 = 0;\\n            \\n            for (int i = 0; i+2*len-1 < N; i++) {\\n                if (i == 0) {\\n                    curr_hash1 = RK_Hash(text, i, M, R, Q);\\n                    curr_hash2 = RK_Hash(text, i+M, M, R, Q);\\n                } else {\\n                    curr_hash1 = RK_Shift(text, i-1, M, R, Q, RM, curr_hash1);\\n                    curr_hash2 = RK_Shift(text, i-1+M, M, R, Q, RM, curr_hash2);\\n                }\\n                if (curr_hash1 == curr_hash2 && RK_Recheck(text, i, i+M)) {\\n                    // set.emplace(text.substr(i, M));\\n                    set.emplace(curr_hash1);\\n                }\\n            }\\n        }\\n        return set.size();\\n    }\\n\\n    long RK_RM(int M, int R, long Q) {\\n        long RM = 1;\\n        for (int i = 1; i <= M-1; i++) {\\n            RM = (R * RM) % Q;\\n        }\\n        return RM;\\n    }\\n    long RK_Hash(const char* text, int i, int M, int R, long Q) {\\n        long h = 0;\\n        for (int j = 0; j < M; j++) {\\n            h = (R * h + text[i+j]) % Q;\\n        }\\n        return h;\\n    }\\n    long RK_Shift(const char* text, int i, int M, int R, long Q, long RM, long last_hash) {\\n        last_hash = (last_hash + Q - RM * text[i] % Q) % Q;\\n        last_hash = (last_hash * R + text[i+M]) % Q;\\n        return last_hash;\\n    }\\n    // Honest, we should always do Recheck, but will make \"a.....a\" case Time-Limit-Exceeded\\n    bool RK_Recheck(const char* text, int i, int j) {\\n        return true;\\n        for (int len = 0; len < j - i; len++) {\\n            if (text[i+len] != text[j+len]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int distinctEchoSubstrings(string text) {\\n        // return func1(text);\\n        return func2(text.c_str(), text.length());\\n    }\\n\\n    // 1. Basic string compare solution, use hash-set do cache\\n    // Time: O(n^3) time, Space: O(n^2)\\n    int func1(string& text) {\\n        int N = text.length();\\n        unordered_set<string> set;\\n\\n        for (int len = 1; len <= N/2; len++) {\\n            for (int i = 0; i+2*len-1 < N; i++) {\\n                string s = text.substr(i, len);\\n                if (set.count(s) > 0) {\\n                    continue;\\n                }\\n                bool same = true;\\n                for (int j = 0; j < len; j++) {\\n                    if (text[i+j] != text[i+j+len]) {\\n                        same = false;\\n                        break;\\n                    }\\n                }\\n                if (same) {\\n                    set.emplace(s);\\n                }\\n            }\\n        }\\n        return set.size();\\n    }\\n\\n    /*\\n     * 2. Rabin-Karp substring search, Time: O(n^2), Space: O(1)\\n     * According to \"Algorithms, 4th Edition => 5.3 Substring Search => Rabin-Karp fingerprint search\"\\n     * Onile implement: https://algs4.cs.princeton.edu/53substring/  => RabinKarp.java\\n     *\\n     * My notes:\\n     * #1 Use `const char*` instead `string&` for text to pass into the functions.\\n     * #2 Should use string type `unordered_set<string> set` not `long type` to avoid collision.\\n     * #3 Base on #2, should do `RK_Recheck` when hash value is equal for sure.\\n     * #4 Do #2 and #3 will make the code too slow to pass.\\n     * #5 There are a lot of thing can be done to speed up my implement, for readable, I just leave it this way.\\n     */\\n    const int R = 26;        // There are only low letter in string\\n    const long Q = 1e13 + 7; // Random chose some big prime\\n\\n    int func2(const char* text, int N) {\\n        long RM = 1;\\n        // unordered_set<string> set;\\n        unordered_set<long> set;\\n\\n        for (int len = 1; len <= N/2; len++) {\\n            // M == len, use \\'M\\' to keep same to algs4\\'s implement\\n            int M = len;\\n            // long RM = RK_RM(M, R, Q);\\n            if (M > 1) {\\n                RM = RM * R % Q;\\n            }\\n            long curr_hash1 = 0;\\n            long curr_hash2 = 0;\\n            \\n            for (int i = 0; i+2*len-1 < N; i++) {\\n                if (i == 0) {\\n                    curr_hash1 = RK_Hash(text, i, M, R, Q);\\n                    curr_hash2 = RK_Hash(text, i+M, M, R, Q);\\n                } else {\\n                    curr_hash1 = RK_Shift(text, i-1, M, R, Q, RM, curr_hash1);\\n                    curr_hash2 = RK_Shift(text, i-1+M, M, R, Q, RM, curr_hash2);\\n                }\\n                if (curr_hash1 == curr_hash2 && RK_Recheck(text, i, i+M)) {\\n                    // set.emplace(text.substr(i, M));\\n                    set.emplace(curr_hash1);\\n                }\\n            }\\n        }\\n        return set.size();\\n    }\\n\\n    long RK_RM(int M, int R, long Q) {\\n        long RM = 1;\\n        for (int i = 1; i <= M-1; i++) {\\n            RM = (R * RM) % Q;\\n        }\\n        return RM;\\n    }\\n    long RK_Hash(const char* text, int i, int M, int R, long Q) {\\n        long h = 0;\\n        for (int j = 0; j < M; j++) {\\n            h = (R * h + text[i+j]) % Q;\\n        }\\n        return h;\\n    }\\n    long RK_Shift(const char* text, int i, int M, int R, long Q, long RM, long last_hash) {\\n        last_hash = (last_hash + Q - RM * text[i] % Q) % Q;\\n        last_hash = (last_hash * R + text[i+M]) % Q;\\n        return last_hash;\\n    }\\n    // Honest, we should always do Recheck, but will make \"a.....a\" case Time-Limit-Exceeded\\n    bool RK_Recheck(const char* text, int i, int j) {\\n        return true;\\n        for (int len = 0; len < j - i; len++) {\\n            if (text[i+len] != text[j+len]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 487989,
                "title": "c-suffix-trie-got-tle-help",
                "content": "Hi,\\nI thought about using suffix trie for this problem, but it gets TLE for the final test cases (37/38 passed).\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.....aaaaaaaaa\"\\n\\nThe idea is very similar to this \\nhttps://leetcode.com/problems/distinct-echo-substrings/discuss/477896/No-rolling-hashTrie-with-optimization-and-explanation\\nThe code is also quite similar.\\n\\n\\nThe complexity for this is obviously O(n^2), I just don\\'t know how to improve that.\\n\\n\\n\\n```\\npublic class Solution {\\n    public int DistinctEchoSubstrings(string text) {\\n        var trie = new Trie();\\n        for(var i=0; i<text.Length; i++){\\n            trie.Add(text, i);\\n        }\\n        return trie.total;\\n    }\\n}\\n\\nclass Node{\\n    public Node[] children = new Node[26];\\n    public HashSet<int> starts = new HashSet<int>();\\n    public bool counted;\\n}\\n\\nclass Trie{\\n    Node root = new Node();\\n    public int total;\\n    public void Add(string s, int start){\\n        var curr = root;\\n        for(var i=start; i<s.Length&& (i-start+1<=s.Length-i || i-start+1<=start); i++){\\n            var j = s[i]-\\'a\\';\\n            if(curr.children[j]==null){\\n                curr.children[j] = new Node();\\n            }\\n            curr = curr.children[j];\\n            \\n            if(curr.counted)\\n                continue;\\n            \\n            if(curr.starts.Contains(start-(i-start+1))){\\n                curr.counted = true;\\n                total++;\\n            }\\n            curr.starts.Add(start);\\n        }\\n    }    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int DistinctEchoSubstrings(string text) {\\n        var trie = new Trie();\\n        for(var i=0; i<text.Length; i++){\\n            trie.Add(text, i);\\n        }\\n        return trie.total;\\n    }\\n}\\n\\nclass Node{\\n    public Node[] children = new Node[26];\\n    public HashSet<int> starts = new HashSet<int>();\\n    public bool counted;\\n}\\n\\nclass Trie{\\n    Node root = new Node();\\n    public int total;\\n    public void Add(string s, int start){\\n        var curr = root;\\n        for(var i=start; i<s.Length&& (i-start+1<=s.Length-i || i-start+1<=start); i++){\\n            var j = s[i]-\\'a\\';\\n            if(curr.children[j]==null){\\n                curr.children[j] = new Node();\\n            }\\n            curr = curr.children[j];\\n            \\n            if(curr.counted)\\n                continue;\\n            \\n            if(curr.starts.Contains(start-(i-start+1))){\\n                curr.counted = true;\\n                total++;\\n            }\\n            curr.starts.Add(start);\\n        }\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 482765,
                "title": "python-rolling-checksum-and-xor",
                "content": "/!\\\\ There is some probality this doesn\\'t work.\\n\\nThe idea is to calculate the rolling checksum _H_ from the begining til the end element in the string _H &leftarrow; h<sub>0</sub> &bigoplus; ... &bigoplus; h<sub>i</sub>_ ; the function &bigoplus; is chosen so that it is commutative and _h &bigoplus; h = 0_. At any point if the checksum comes back to a previous value it means there is some repeative representation in the string.\\n\\nFor example: With string `text=\\'ABAB\\'`, we have\\n`h_0 = 0`\\n`h_1 = hash(\\'A\\')`\\n`h_2 = hash(\\'A\\')`&bigoplus;`hash(\\'B\\')`\\n`h_3 = hash(\\'A\\')`&bigoplus;`hash(\\'B\\')`&bigoplus;`hash(\\'A\\') = hash(\\'B\\')`\\n`h_4 = hash(\\'A\\')`&bigoplus;`hash(\\'B\\')`&bigoplus;`hash(\\'A\\')` &bigoplus;`hash(\\'B\\') = 0 = h_0`\\n\\nOf course this applies to other ways of repeative as well: `ABCCBA`, `ABACBC`, but we can easily filter out these cases.\\n\\nWe can pick `XOR` to use as &bigoplus; but there is some probability just xor\\'ing the bits doesn\\'t work; increasing the length of the hash can reduce the likelihood.\\n\\n```\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        def verify(st):\\n            i = len(st) // 2\\n            return and st[:i] == st[i:]\\n        \\n        hdict = dict([[0, [-1]]]) # dictionary of rolling hash values, hash_value -> locations of the value\\n        sdict = set() # set of found \\'echo\\' subsequences\\n        echo_count = 0\\n        hash_total = 0\\n        for i in range(len(text)):\\n            hash_total ^= hash(text[i])\\n            if hash_total in hdict:\\n\\t\\t\\t\\t# hash found before, there must be some repeatition between this and the previous locations of the hash\\n                for j in hdict[hash_total]:\\n                    esub = text[j + 1:i + 1]\\n                    if esub not in sdict and verify(esub):\\n                        sdict.add(esub)\\n                        echo_count += 1\\n                hdict[hash_total].append(i)\\n            else:\\n                hdict[hash_total] = [i]\\n        return echo_count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def distinctEchoSubstrings(self, text: str) -> int:\\n        def verify(st):\\n            i = len(st) // 2\\n            return and st[:i] == st[i:]\\n        \\n        hdict = dict([[0, [-1]]]) # dictionary of rolling hash values, hash_value -> locations of the value\\n        sdict = set() # set of found \\'echo\\' subsequences\\n        echo_count = 0\\n        hash_total = 0\\n        for i in range(len(text)):\\n            hash_total ^= hash(text[i])\\n            if hash_total in hdict:\\n\\t\\t\\t\\t# hash found before, there must be some repeatition between this and the previous locations of the hash\\n                for j in hdict[hash_total]:\\n                    esub = text[j + 1:i + 1]\\n                    if esub not in sdict and verify(esub):\\n                        sdict.add(esub)\\n                        echo_count += 1\\n                hdict[hash_total].append(i)\\n            else:\\n                hdict[hash_total] = [i]\\n        return echo_count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 482206,
                "title": "java-solution-finish",
                "content": "public static int distinctEchoSubstrings(String text) {\\n        final Set<String> found = new HashSet<>();\\n        final char[] chars = text.toCharArray();\\n        for (int i = 0; i < chars.length; i++) {\\n            for (int j = i + 1; j < text.length(); j++) {\\n                if (chars[i] == chars[j]) {\\n                    if (j + j - i <= text.length()) {\\n                        final String first = text.substring(i, j);\\n                        final String second = text.substring(j, j + j - i);\\n                        if (first.equals(second)) {\\n                            found.add(first + second);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return found.size();\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "public static int distinctEchoSubstrings(String text) {\\n        final Set<String> found = new HashSet<>();\\n        final char[] chars = text.toCharArray();\\n        for (int i = 0; i < chars.length; i++) {\\n            for (int j = i + 1; j < text.length(); j++) {\\n                if (chars[i] == chars[j]) {\\n                    if (j + j - i <= text.length()) {\\n                        final String first = text.substring(i, j);\\n                        final String second = text.substring(j, j + j - i);\\n                        if (first.equals(second)) {\\n                            found.add(first + second);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return found.size();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 482080,
                "title": "python3-brute-force-will-work-c-brute-force-will-not",
                "content": "I submitted a C++ brute force solution and it fails on the biggest test case taking about 900ms. Then with python3 I applied the same logic and it passed with around 1000ms. Didn\\'t realize that is how leetcode works.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 481811,
                "title": "javascript-nothing-fancy",
                "content": "```javascript\\n/**\\n * @param {string} text\\n * @return {number}\\n */\\nvar distinctEchoSubstrings = function(text) {\\n    const store = new Set();\\n    for (let i = 0; i < text.length; i++) {\\n        for (let j = i + 1; j < text.length; j++) {\\n            const left = text.substring(i,j);\\n\\t\\t\\tconst right = text.substring(j, j + j - i);\\n            if (left === right) store.add(left);\\n        }\\n    }\\n    return store.size;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {string} text\\n * @return {number}\\n */\\nvar distinctEchoSubstrings = function(text) {\\n    const store = new Set();\\n    for (let i = 0; i < text.length; i++) {\\n        for (let j = i + 1; j < text.length; j++) {\\n            const left = text.substring(i,j);\\n\\t\\t\\tconst right = text.substring(j, j + j - i);\\n            if (left === right) store.add(left);\\n        }\\n    }\\n    return store.size;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 479109,
                "title": "solution-with-sliding-window",
                "content": "Solution with Sliding WIndow technique:\\n\\nIdea: keep the \"last\" as the value of smallest index such that text[last:i] == text[last+len:i+len]\\n\\n```\\nlast is the left pointer;\\ni    is the right pointer;\\n```\\n```\\n    int distinctEchoSubstrings(string text) {\\n        unordered_set<string> s;\\n        for(int len=1;len<=text.size()/2;len++) {\\n            int last = 0;\\n            for(int i=0;i+len<text.size();i++) {\\n                if(text[i]!=text[i+len]) {\\n                    last = i+1;\\n                } else {\\n                    if(i-last+1>=len) {\\n                        // now, we have a substring text.substr(i-len+1, len) == text.substr(i+1, len)\\n                        s.insert(text.substr(i-len+1, len));\\n                    }\\n                }\\n            }\\n        }\\n        return s.size();\\n    }\\n```\\nTime: O(n^2)\\nfaster than 61.30% of C++ online submissions",
                "solutionTags": [],
                "code": "```\\nlast is the left pointer;\\ni    is the right pointer;\\n```\n```\\n    int distinctEchoSubstrings(string text) {\\n        unordered_set<string> s;\\n        for(int len=1;len<=text.size()/2;len++) {\\n            int last = 0;\\n            for(int i=0;i+len<text.size();i++) {\\n                if(text[i]!=text[i+len]) {\\n                    last = i+1;\\n                } else {\\n                    if(i-last+1>=len) {\\n                        // now, we have a substring text.substr(i-len+1, len) == text.substr(i+1, len)\\n                        s.insert(text.substr(i-len+1, len));\\n                    }\\n                }\\n            }\\n        }\\n        return s.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 478960,
                "title": "c-hash-solution-just-o-n-2",
                "content": "In other solution, they use string_view to reduce time.but i think just storage hashvalue is better good.\\n\\nfor example\\n```cpp\\nclass Hash{\\ntypedef long long ll;\\nprivate:\\n  vector<ll> table1,table2;\\n  vector<ll> store1,store2;\\n  const ll Mod1 = 1e9+7,Mod2 = 998244353;\\n  const ll B1 = 131,B2 = 13131;\\npublic:\\n  Hash(const string &str){\\n    table1.resize(str.size());\\n    table2.resize(str.size());\\n    store1.resize(str.size());\\n    store2.resize(str.size());\\n    for(int i=0;i<str.size();++i){\\n      if(i == 0){\\n        table1[i] = table2[i] = str[i];\\n        store1[i] = store2[i] = 1;\\n      }else{\\n        table1[i] = (table1[i-1]*B1 + str[i])%Mod1;\\n        store1[i] = (store1[i-1]*B1)%Mod1;\\n        \\n        table2[i] = (table2[i-1]*B2 + str[i])%Mod2;\\n        store2[i] = (store2[i-1]*B2)%Mod2;\\n      }\\n    }\\n  }\\n  ll getHashValue1(int l,int r){\\n    if(l == 0){\\n      return table1[r];\\n    }else{\\n      ll value1 = (table1[r]-table1[l-1]*store1[r-l+1])%Mod1;\\n      value1 = (value1+Mod1)%Mod1;\\n      return value1;\\n    }\\n  }\\n  ll getHashValue2(int l,int r){\\n    if(l == 0){\\n      return table2[r];\\n    }else{\\n      ll value2 = (table2[r]-table2[l-1]*store2[r-l+1])%Mod2;\\n      value2 = (value2+Mod2)%Mod2;\\n      return value2;\\n    }\\n  }\\n};\\n\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    int distinctEchoSubstrings(string text) {\\n        Hash h(text);\\n        unordered_set<ll> st;\\n        const char* p = text.c_str();\\n        for(int i=0;i<text.size();++i){\\n            for(int j=1;i+2*j<=text.size();++j){\\n                ll h1 = h.getHashValue1(i,i+j-1);\\n                ll h2 = h.getHashValue1(i+j,i+2*j-1);\\n                if(h1 == h2){\\n                    st.insert(h1);\\n                }\\n            }\\n        }\\n        return (int)st.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Hash{\\ntypedef long long ll;\\nprivate:\\n  vector<ll> table1,table2;\\n  vector<ll> store1,store2;\\n  const ll Mod1 = 1e9+7,Mod2 = 998244353;\\n  const ll B1 = 131,B2 = 13131;\\npublic:\\n  Hash(const string &str){\\n    table1.resize(str.size());\\n    table2.resize(str.size());\\n    store1.resize(str.size());\\n    store2.resize(str.size());\\n    for(int i=0;i<str.size();++i){\\n      if(i == 0){\\n        table1[i] = table2[i] = str[i];\\n        store1[i] = store2[i] = 1;\\n      }else{\\n        table1[i] = (table1[i-1]*B1 + str[i])%Mod1;\\n        store1[i] = (store1[i-1]*B1)%Mod1;\\n        \\n        table2[i] = (table2[i-1]*B2 + str[i])%Mod2;\\n        store2[i] = (store2[i-1]*B2)%Mod2;\\n      }\\n    }\\n  }\\n  ll getHashValue1(int l,int r){\\n    if(l == 0){\\n      return table1[r];\\n    }else{\\n      ll value1 = (table1[r]-table1[l-1]*store1[r-l+1])%Mod1;\\n      value1 = (value1+Mod1)%Mod1;\\n      return value1;\\n    }\\n  }\\n  ll getHashValue2(int l,int r){\\n    if(l == 0){\\n      return table2[r];\\n    }else{\\n      ll value2 = (table2[r]-table2[l-1]*store2[r-l+1])%Mod2;\\n      value2 = (value2+Mod2)%Mod2;\\n      return value2;\\n    }\\n  }\\n};\\n\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    int distinctEchoSubstrings(string text) {\\n        Hash h(text);\\n        unordered_set<ll> st;\\n        const char* p = text.c_str();\\n        for(int i=0;i<text.size();++i){\\n            for(int j=1;i+2*j<=text.size();++j){\\n                ll h1 = h.getHashValue1(i,i+j-1);\\n                ll h2 = h.getHashValue1(i+j,i+2*j-1);\\n                if(h1 == h2){\\n                    st.insert(h1);\\n                }\\n            }\\n        }\\n        return (int)st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 478829,
                "title": "java-solution-460ms",
                "content": "```\\nclass Solution {\\n    public int distinctEchoSubstrings(String text) {\\n        if(text.length()==0) return 0;\\n\\t\\t\\n        int[] ht = new int[text.length()]; \\t\\t// a good hash table maybe better\\n        ht[0] = text.charAt(0);\\n        for(int i=1; i<text.length(); i++) ht[i]=ht[i-1]+text.charAt(i);\\n        \\n        Set<String> set = new HashSet<>();\\n        \\n        for(int i=0; i<text.length()-1; i++){\\n            for(int len=1; len<text.length(); len++){\\n                int j = i+len;\\n                if(j+len>text.length()) break;\\n \\n                int a = (i==0?ht[j-1]:ht[j-1]-ht[i-1]);\\n                int b = ht[j+len-1]-ht[j-1];\\n\\n                if(a==b){ \\t// if a<>b, not impossible match\\n                    String s1 = text.substring(i, j);\\n                    String s2 = text.substring(j, j+len);\\n                    if(s1.equals(s2)) set.add(s1);\\n                }\\n            }\\n        }\\n        \\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int distinctEchoSubstrings(String text) {\\n        if(text.length()==0) return 0;\\n\\t\\t\\n        int[] ht = new int[text.length()]; \\t\\t// a good hash table maybe better\\n        ht[0] = text.charAt(0);\\n        for(int i=1; i<text.length(); i++) ht[i]=ht[i-1]+text.charAt(i);\\n        \\n        Set<String> set = new HashSet<>();\\n        \\n        for(int i=0; i<text.length()-1; i++){\\n            for(int len=1; len<text.length(); len++){\\n                int j = i+len;\\n                if(j+len>text.length()) break;\\n \\n                int a = (i==0?ht[j-1]:ht[j-1]-ht[i-1]);\\n                int b = ht[j+len-1]-ht[j-1];\\n\\n                if(a==b){ \\t// if a<>b, not impossible match\\n                    String s1 = text.substring(i, j);\\n                    String s2 = text.substring(j, j+len);\\n                    if(s1.equals(s2)) set.add(s1);\\n                }\\n            }\\n        }\\n        \\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 478086,
                "title": "easy-to-understand-hashing",
                "content": "```\\n#define hell 1000000007\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll power(ll x,ll y)\\n    {\\n        ll res=1;\\n        while(y>0)\\n        {\\n            if(y&1)\\n            res=res*x%hell;\\n            y=y>>1;\\n            x=x*x%hell;\\n        }\\n        return res;\\n    }\\n    int distinctEchoSubstrings(string s) {\\n        ll n=s.size();\\n        ll h[n+1]={0},p[n+1];\\n        p[0]=1;\\n        for(ll i=1;i<=n;i++)p[i]=p[i-1]*53%hell;\\n        for(ll i=0;i<n;i++){\\n            h[i+1]=(h[i]+(s[i]-\\'a\\'+1)*p[i+1]%hell)%hell;\\n        }\\n        set<ll> ss;\\n        for(ll i=0;i<n;i++){\\n            for(ll j=i+1;j<n;j++){\\n                if((j-i+1)%2==0){\\n                    ll l=i,r=(i+j-1)/2;\\n                    ll L=(i+j+1)/2,R=j;\\n                    ll x=((h[r+1]-h[l]+hell)%hell*power(power(53,l),hell-2))%hell;\\n                    ll y=((h[R+1]-h[L]+hell)%hell*power(power(53,L),hell-2))%hell;\\n                    if(x==y)ss.insert(x);\\n                }\\n            }\\n        }\\n        return ss.size();\\n    }\\n};\\n   ```",
                "solutionTags": [],
                "code": "```\\n#define hell 1000000007\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll power(ll x,ll y)\\n    {\\n        ll res=1;\\n        while(y>0)\\n        {\\n            if(y&1)\\n            res=res*x%hell;\\n            y=y>>1;\\n            x=x*x%hell;\\n        }\\n        return res;\\n    }\\n    int distinctEchoSubstrings(string s) {\\n        ll n=s.size();\\n        ll h[n+1]={0},p[n+1];\\n        p[0]=1;\\n        for(ll i=1;i<=n;i++)p[i]=p[i-1]*53%hell;\\n        for(ll i=0;i<n;i++){\\n            h[i+1]=(h[i]+(s[i]-\\'a\\'+1)*p[i+1]%hell)%hell;\\n        }\\n        set<ll> ss;\\n        for(ll i=0;i<n;i++){\\n            for(ll j=i+1;j<n;j++){\\n                if((j-i+1)%2==0){\\n                    ll l=i,r=(i+j-1)/2;\\n                    ll L=(i+j+1)/2,R=j;\\n                    ll x=((h[r+1]-h[l]+hell)%hell*power(power(53,l),hell-2))%hell;\\n                    ll y=((h[R+1]-h[L]+hell)%hell*power(power(53,L),hell-2))%hell;\\n                    if(x==y)ss.insert(x);\\n                }\\n            }\\n        }\\n        return ss.size();\\n    }\\n};\\n   ```",
                "codeTag": "Java"
            },
            {
                "id": 478078,
                "title": "is-o-n-3-better-than-o-n-2",
                "content": "I have two solutions . Solution A looks like O(N^3) and  Solution B looks like O(N^2).\\nBoth have been accepted.\\nThe interesting thing is  Solution A use 179ms to pass all cases while  Solution B use 358ms.\\nSolution A: https://leetcode.com/submissions/detail/293466213/\\nSolution B: https://leetcode.com/submissions/detail/293472536/\\n\\n```\\n//Solution A\\nclass Solution {\\n    public int distinctEchoSubstrings(String text) { \\n        Set<String>set= new HashSet<String>(); \\n        distinctEchoSubstrings(text, set);\\n        return set.size();\\n    }\\n    public void distinctEchoSubstrings(String text, Set<String>set) { \\n        //System.out.println(text);\\n        if(text.length()<=1) return ;\\n        char[]chars = text.toCharArray(); \\n        List[] pos = pos(chars);\\n        //Arrays.sort(pos, (a,b)->{\\n        //    if(a.size()==b.size()) return 0;\\n        //    if(a.size()==0) return 1;\\n        //    if(b.size()==0) return -1;\\n        //    if(a.size()>b.size()) return 1;\\n        //    return -1;\\n        //});\\n        for(int j=0;j<26;j++) {\\n            if(pos[j].size()==0) {\\n                continue;\\n            }\\n            //System.out.println(j+\": \" +pos[j].size());\\n            if(pos[j].size()==1) {\\n                int t = (Integer)(pos[j].get(0));\\n                //System.out.println(new String(chars, 0, t)+\" \"+new String(chars, t + 1, chars.length - t - 1));\\n                distinctEchoSubstrings(new String(chars, 0, t), set);\\n                distinctEchoSubstrings(new String(chars, t + 1, chars.length - t - 1), set);\\n                return;\\n            }\\n            if(pos[j].size()==2) {\\n                int t1 = (Integer)(pos[j].get(0));\\n                int t2 = (Integer)(pos[j].get(1));\\n                //System.out.println(Arrays.toString(pos));\\n                if(t2 - t1==1) set.add(new String(chars,t1 , 1));\\n                if(t2-t1>chars.length/2) {\\n                    if(t1>1)distinctEchoSubstrings(new String(chars, 0, t1), set);\\n                    if(t2 - t1>1)distinctEchoSubstrings(new String(chars, t1+1, t2 - t1 - 1), set);\\n                    if(chars.length - t2>1)distinctEchoSubstrings(new String(chars, t2 + 1, chars.length - t2 - 1), set);\\n                    return;\\n                }  \\n            } else if(pos[j].size()==chars.length) {\\n                for(int i=chars.length/2;i>0;i--) {\\n                    set.add(new String(chars,0 , i));\\n                }\\n                return ;\\n            }\\n        }\\n        \\n        //System.out.println(Arrays.toString(pos));\\n        //pos = pos(chars);\\n\\n        for(int i=0;i<chars.length;i++) {\\n            char c = chars[i];\\n            pos[c-\\'a\\'].remove(0); // remove first, that should be i\\n            if(pos[c-\\'a\\'].size()==0) continue;\\n            Iterator<Integer> it = pos[c-\\'a\\'].iterator(); \\n            for(;it.hasNext(); ) {\\n                Integer next = it.next();\\n                if(next + next - i > chars.length) {\\n                    break;\\n                }  \\n                if(check(chars, i, next)) { \\n                    set.add(new String(chars, i, next - i));\\n                }\\n            }\\n        } \\n    }\\n    List[] pos(char[]chars) {\\n        List[] pos = new List[26];\\n        for(int i = 0 ; i < 26; i++) {\\n            pos[i] = new ArrayList<Integer>();\\n        }\\n        for(int i = 0 ; i < chars.length; i++) {\\n            pos[chars[i] - \\'a\\'].add(i);\\n        }\\n        return pos;\\n    }\\n    boolean check(char[]c, int first, int next) {\\n        int len = next - first;\\n        if(len == 1) return true;\\n        int mid = (next + first) / 2;\\n        return c[mid]==c[mid+len]&&check(c, first+1, mid, len) && check(c, mid+1, next, len);\\n    }\\n    boolean check(char[]c, int first, int next, int len) {\\n        int len2 = next - first;\\n        if(len2 <= 0) return true;\\n        int mid = (next + first) / 2;\\n        return c[mid]==c[mid+len]&&check(c, first, mid, len) && check(c, mid+1, next, len);\\n    }\\n}\\n```\\n```\\n//Solution B\\nclass Solution {\\n    public int distinctEchoSubstrings(String text) { \\n        char[] t=text.toCharArray();\\n        int[] dif= dif(t); \\n        //System.out.println(Arrays.toString(dif));\\n        \\n        Set<String>set= new HashSet<String>(); \\n        for(int i=dif.length;--i>=0;) {\\n            if(dif[i]==0)\\n                set.add(new String(t, i, 1));\\n        }\\n        int[] bp= dif.clone();\\n        for(int j=1;j<t.length/2;j++) {\\n            int zero = 0;\\n            for(int i=dif.length-j;--i>=0;) {\\n                bp[i] += dif[i+j];\\n                if(bp[i]==0){\\n                    zero++;\\n                    if(zero>j)\\n                        set.add(new String(t, i, j+1));\\n                } else {\\n                    zero = 0;\\n                }\\n            }            \\n        }\\n        //distinctEchoSubstrings(text, set);\\n        return set.size();\\n    }\\n    int[] dif(char[] text) { \\n        int[] t = new int[text.length-1];\\n        for(int i=text.length-1;--i>=0;){\\n            t[i] = text[i+1]-text[i];\\n        }\\n        return t;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n//Solution A\\nclass Solution {\\n    public int distinctEchoSubstrings(String text) { \\n        Set<String>set= new HashSet<String>(); \\n        distinctEchoSubstrings(text, set);\\n        return set.size();\\n    }\\n    public void distinctEchoSubstrings(String text, Set<String>set) { \\n        //System.out.println(text);\\n        if(text.length()<=1) return ;\\n        char[]chars = text.toCharArray(); \\n        List[] pos = pos(chars);\\n        //Arrays.sort(pos, (a,b)->{\\n        //    if(a.size()==b.size()) return 0;\\n        //    if(a.size()==0) return 1;\\n        //    if(b.size()==0) return -1;\\n        //    if(a.size()>b.size()) return 1;\\n        //    return -1;\\n        //});\\n        for(int j=0;j<26;j++) {\\n            if(pos[j].size()==0) {\\n                continue;\\n            }\\n            //System.out.println(j+\": \" +pos[j].size());\\n            if(pos[j].size()==1) {\\n                int t = (Integer)(pos[j].get(0));\\n                //System.out.println(new String(chars, 0, t)+\" \"+new String(chars, t + 1, chars.length - t - 1));\\n                distinctEchoSubstrings(new String(chars, 0, t), set);\\n                distinctEchoSubstrings(new String(chars, t + 1, chars.length - t - 1), set);\\n                return;\\n            }\\n            if(pos[j].size()==2) {\\n                int t1 = (Integer)(pos[j].get(0));\\n                int t2 = (Integer)(pos[j].get(1));\\n                //System.out.println(Arrays.toString(pos));\\n                if(t2 - t1==1) set.add(new String(chars,t1 , 1));\\n                if(t2-t1>chars.length/2) {\\n                    if(t1>1)distinctEchoSubstrings(new String(chars, 0, t1), set);\\n                    if(t2 - t1>1)distinctEchoSubstrings(new String(chars, t1+1, t2 - t1 - 1), set);\\n                    if(chars.length - t2>1)distinctEchoSubstrings(new String(chars, t2 + 1, chars.length - t2 - 1), set);\\n                    return;\\n                }  \\n            } else if(pos[j].size()==chars.length) {\\n                for(int i=chars.length/2;i>0;i--) {\\n                    set.add(new String(chars,0 , i));\\n                }\\n                return ;\\n            }\\n        }\\n        \\n        //System.out.println(Arrays.toString(pos));\\n        //pos = pos(chars);\\n\\n        for(int i=0;i<chars.length;i++) {\\n            char c = chars[i];\\n            pos[c-\\'a\\'].remove(0); // remove first, that should be i\\n            if(pos[c-\\'a\\'].size()==0) continue;\\n            Iterator<Integer> it = pos[c-\\'a\\'].iterator(); \\n            for(;it.hasNext(); ) {\\n                Integer next = it.next();\\n                if(next + next - i > chars.length) {\\n                    break;\\n                }  \\n                if(check(chars, i, next)) { \\n                    set.add(new String(chars, i, next - i));\\n                }\\n            }\\n        } \\n    }\\n    List[] pos(char[]chars) {\\n        List[] pos = new List[26];\\n        for(int i = 0 ; i < 26; i++) {\\n            pos[i] = new ArrayList<Integer>();\\n        }\\n        for(int i = 0 ; i < chars.length; i++) {\\n            pos[chars[i] - \\'a\\'].add(i);\\n        }\\n        return pos;\\n    }\\n    boolean check(char[]c, int first, int next) {\\n        int len = next - first;\\n        if(len == 1) return true;\\n        int mid = (next + first) / 2;\\n        return c[mid]==c[mid+len]&&check(c, first+1, mid, len) && check(c, mid+1, next, len);\\n    }\\n    boolean check(char[]c, int first, int next, int len) {\\n        int len2 = next - first;\\n        if(len2 <= 0) return true;\\n        int mid = (next + first) / 2;\\n        return c[mid]==c[mid+len]&&check(c, first, mid, len) && check(c, mid+1, next, len);\\n    }\\n}\\n```\n```\\n//Solution B\\nclass Solution {\\n    public int distinctEchoSubstrings(String text) { \\n        char[] t=text.toCharArray();\\n        int[] dif= dif(t); \\n        //System.out.println(Arrays.toString(dif));\\n        \\n        Set<String>set= new HashSet<String>(); \\n        for(int i=dif.length;--i>=0;) {\\n            if(dif[i]==0)\\n                set.add(new String(t, i, 1));\\n        }\\n        int[] bp= dif.clone();\\n        for(int j=1;j<t.length/2;j++) {\\n            int zero = 0;\\n            for(int i=dif.length-j;--i>=0;) {\\n                bp[i] += dif[i+j];\\n                if(bp[i]==0){\\n                    zero++;\\n                    if(zero>j)\\n                        set.add(new String(t, i, j+1));\\n                } else {\\n                    zero = 0;\\n                }\\n            }            \\n        }\\n        //distinctEchoSubstrings(text, set);\\n        return set.size();\\n    }\\n    int[] dif(char[] text) { \\n        int[] t = new int[text.length-1];\\n        for(int i=text.length-1;--i>=0;){\\n            t[i] = text[i+1]-text[i];\\n        }\\n        return t;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564834,
                "content": [
                    {
                        "username": "infmount",
                        "content": "Spent 30 minutes trying to decipher the 2 examples, still don\\'t understand. In the first example, why is \"abc\" not a echo substring? The explanation in the description didn\\'t really explain anything like why \"abcabc\" is an echo substring of \"abcabcabc\"."
                    },
                    {
                        "username": "NaoJoeMiao",
                        "content": "Most accepted answers are rolling hash. Can we solve without?"
                    },
                    {
                        "username": "Leoooooo",
                        "content": "The reason is simple, the number of unique substring could exceed the MOD value. Then the hash will casue collisions and it is not easy to handle the collisions.\\nFor example:\\nLet\\'s say substring A and B have the same hash remainder.\\nHow to handle the case like AABB ?\\nAA should be counted\\nAB should not\\nBB shoud be counted as a different one from AA but BB has the same hash as AA. \\n\\nAnd if we write extra logic to handle the collisions, the time complexity may not be n^2 anymore.\\n"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Brutal force is accepted, so it is not hard."
                    },
                    {
                        "username": "user9733OY",
                        "content": "I have wrong answer at test number 25. Input: text =\"leeleetleeleeleclec\"\\n\\nOutput: 4\\n\\nExpected: 5 \\n\\nWhat is the 5th string I am missing??\\n\\nMaybe I am blind, but I can find only 4, as the code does:\\n\"ee\", \"leelee\", \"eeleel\", \"leclec\""
                    },
                    {
                        "username": "Saiteja6",
                        "content": "\"eleele\""
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Andrei](/user9733OY) \\n\\nThe one you are missing is eleele. Check near the second instance of leelee"
                    }
                ]
            },
            {
                "id": 1569735,
                "content": [
                    {
                        "username": "infmount",
                        "content": "Spent 30 minutes trying to decipher the 2 examples, still don\\'t understand. In the first example, why is \"abc\" not a echo substring? The explanation in the description didn\\'t really explain anything like why \"abcabc\" is an echo substring of \"abcabcabc\"."
                    },
                    {
                        "username": "NaoJoeMiao",
                        "content": "Most accepted answers are rolling hash. Can we solve without?"
                    },
                    {
                        "username": "Leoooooo",
                        "content": "The reason is simple, the number of unique substring could exceed the MOD value. Then the hash will casue collisions and it is not easy to handle the collisions.\\nFor example:\\nLet\\'s say substring A and B have the same hash remainder.\\nHow to handle the case like AABB ?\\nAA should be counted\\nAB should not\\nBB shoud be counted as a different one from AA but BB has the same hash as AA. \\n\\nAnd if we write extra logic to handle the collisions, the time complexity may not be n^2 anymore.\\n"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Brutal force is accepted, so it is not hard."
                    },
                    {
                        "username": "user9733OY",
                        "content": "I have wrong answer at test number 25. Input: text =\"leeleetleeleeleclec\"\\n\\nOutput: 4\\n\\nExpected: 5 \\n\\nWhat is the 5th string I am missing??\\n\\nMaybe I am blind, but I can find only 4, as the code does:\\n\"ee\", \"leelee\", \"eeleel\", \"leclec\""
                    },
                    {
                        "username": "Saiteja6",
                        "content": "\"eleele\""
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Andrei](/user9733OY) \\n\\nThe one you are missing is eleele. Check near the second instance of leelee"
                    }
                ]
            },
            {
                "id": 1569736,
                "content": [
                    {
                        "username": "infmount",
                        "content": "Spent 30 minutes trying to decipher the 2 examples, still don\\'t understand. In the first example, why is \"abc\" not a echo substring? The explanation in the description didn\\'t really explain anything like why \"abcabc\" is an echo substring of \"abcabcabc\"."
                    },
                    {
                        "username": "NaoJoeMiao",
                        "content": "Most accepted answers are rolling hash. Can we solve without?"
                    },
                    {
                        "username": "Leoooooo",
                        "content": "The reason is simple, the number of unique substring could exceed the MOD value. Then the hash will casue collisions and it is not easy to handle the collisions.\\nFor example:\\nLet\\'s say substring A and B have the same hash remainder.\\nHow to handle the case like AABB ?\\nAA should be counted\\nAB should not\\nBB shoud be counted as a different one from AA but BB has the same hash as AA. \\n\\nAnd if we write extra logic to handle the collisions, the time complexity may not be n^2 anymore.\\n"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Brutal force is accepted, so it is not hard."
                    },
                    {
                        "username": "user9733OY",
                        "content": "I have wrong answer at test number 25. Input: text =\"leeleetleeleeleclec\"\\n\\nOutput: 4\\n\\nExpected: 5 \\n\\nWhat is the 5th string I am missing??\\n\\nMaybe I am blind, but I can find only 4, as the code does:\\n\"ee\", \"leelee\", \"eeleel\", \"leclec\""
                    },
                    {
                        "username": "Saiteja6",
                        "content": "\"eleele\""
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Andrei](/user9733OY) \\n\\nThe one you are missing is eleele. Check near the second instance of leelee"
                    }
                ]
            },
            {
                "id": 1966194,
                "content": [
                    {
                        "username": "infmount",
                        "content": "Spent 30 minutes trying to decipher the 2 examples, still don\\'t understand. In the first example, why is \"abc\" not a echo substring? The explanation in the description didn\\'t really explain anything like why \"abcabc\" is an echo substring of \"abcabcabc\"."
                    },
                    {
                        "username": "NaoJoeMiao",
                        "content": "Most accepted answers are rolling hash. Can we solve without?"
                    },
                    {
                        "username": "Leoooooo",
                        "content": "The reason is simple, the number of unique substring could exceed the MOD value. Then the hash will casue collisions and it is not easy to handle the collisions.\\nFor example:\\nLet\\'s say substring A and B have the same hash remainder.\\nHow to handle the case like AABB ?\\nAA should be counted\\nAB should not\\nBB shoud be counted as a different one from AA but BB has the same hash as AA. \\n\\nAnd if we write extra logic to handle the collisions, the time complexity may not be n^2 anymore.\\n"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Brutal force is accepted, so it is not hard."
                    },
                    {
                        "username": "user9733OY",
                        "content": "I have wrong answer at test number 25. Input: text =\"leeleetleeleeleclec\"\\n\\nOutput: 4\\n\\nExpected: 5 \\n\\nWhat is the 5th string I am missing??\\n\\nMaybe I am blind, but I can find only 4, as the code does:\\n\"ee\", \"leelee\", \"eeleel\", \"leclec\""
                    },
                    {
                        "username": "Saiteja6",
                        "content": "\"eleele\""
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Andrei](/user9733OY) \\n\\nThe one you are missing is eleele. Check near the second instance of leelee"
                    }
                ]
            },
            {
                "id": 1821015,
                "content": [
                    {
                        "username": "infmount",
                        "content": "Spent 30 minutes trying to decipher the 2 examples, still don\\'t understand. In the first example, why is \"abc\" not a echo substring? The explanation in the description didn\\'t really explain anything like why \"abcabc\" is an echo substring of \"abcabcabc\"."
                    },
                    {
                        "username": "NaoJoeMiao",
                        "content": "Most accepted answers are rolling hash. Can we solve without?"
                    },
                    {
                        "username": "Leoooooo",
                        "content": "The reason is simple, the number of unique substring could exceed the MOD value. Then the hash will casue collisions and it is not easy to handle the collisions.\\nFor example:\\nLet\\'s say substring A and B have the same hash remainder.\\nHow to handle the case like AABB ?\\nAA should be counted\\nAB should not\\nBB shoud be counted as a different one from AA but BB has the same hash as AA. \\n\\nAnd if we write extra logic to handle the collisions, the time complexity may not be n^2 anymore.\\n"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Brutal force is accepted, so it is not hard."
                    },
                    {
                        "username": "user9733OY",
                        "content": "I have wrong answer at test number 25. Input: text =\"leeleetleeleeleclec\"\\n\\nOutput: 4\\n\\nExpected: 5 \\n\\nWhat is the 5th string I am missing??\\n\\nMaybe I am blind, but I can find only 4, as the code does:\\n\"ee\", \"leelee\", \"eeleel\", \"leclec\""
                    },
                    {
                        "username": "Saiteja6",
                        "content": "\"eleele\""
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Andrei](/user9733OY) \\n\\nThe one you are missing is eleele. Check near the second instance of leelee"
                    }
                ]
            }
        ]
    }
]