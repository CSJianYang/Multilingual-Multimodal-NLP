[
    {
        "title": "Diameter of Binary Tree",
        "question_content": "Given the root of a binary tree, return the length of the diameter of the tree.\nThe diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.\nThe length of a path between two nodes is represented by the number of edges between them.\n&nbsp;\nExample 1:\n\nInput: root = [1,2,3,4,5]\nOutput: 3\nExplanation: 3 is the length of the path [4,2,1,3] or [5,2,1,3].\n\nExample 2:\n\nInput: root = [1,2]\nOutput: 1\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the tree is in the range [1, 104].\n\t-100 <= Node.val <= 100",
        "solutions": [
            {
                "id": 575172,
                "title": "worst-solution-ever-worse-than-100-of-submissions-in-both-time-and-memory",
                "content": "Well. I was doing the problem for this 30 day challenge thing. And got kinda carried away with what was, in hindsight, a terrible idea. I\\'m not very good at recursion so immidiately discarded the posibility of doing anything like the more optimal solutions (figured they would be too high time complexity...), and I was left with. Um. This. It speaks for itself: \\n\\n(I\\'m sorry if it\\'s complety unreadable. I never write good code and I was getting pretty frustrated with this problem so I just abandoned any pretense of making code that could ever be deciphered again. I also don\\'t know how to post code on this site. Whoops.)\\n\\n```\\nimport java.util.*;\\nimport java.lang.*;\\nimport java.math.*;\\nclass Solution {\\n    public int diameterOfBinaryTree(TreeNode root) {\\n        if(root == null){\\n            return 0;\\n        }\\n        HashMap<BigInteger[], TreeNode> treeMap = new HashMap<BigInteger[], TreeNode>();\\n        treeMap.put(new BigInteger[]{BigInteger.ZERO,BigInteger.ZERO}, root);\\n        int maxY = 0;\\n        int maxDistance = 0;\\n        boolean going = true;\\n        Set<BigInteger[]> fakeSet;\\n        ArrayList<BigInteger> topSet = new ArrayList<BigInteger>();\\n        ArrayList<BigInteger[]> finalSet = new ArrayList<BigInteger[]>();\\n        while(going){\\n            going = false;\\n            ArrayList<BigInteger> newTopSet = new ArrayList<BigInteger>();\\n            Iterator<BigInteger[]> itrKeys = treeMap.keySet().iterator();\\n            HashMap<BigInteger[], TreeNode> newTreeMap = new HashMap<BigInteger[], TreeNode>();\\n            while(itrKeys.hasNext()){\\n                BigInteger[] coord = itrKeys.next();\\n                TreeNode nd = treeMap.get(coord);\\n                if(nd.left != null || nd.right != null){      \\n                    going = true;\\n                    BigInteger base = coord[0].multiply(BigInteger.valueOf(2L));\\n                    if(nd.left == null){\\n                        newTreeMap.put(new BigInteger[]{base.add(BigInteger.ONE), coord[1].add(BigInteger.ONE)}, nd.right);  \\n                        newTopSet.add(base.add(BigInteger.ONE));\\n                    }else{\\n                        newTreeMap.put(new BigInteger[]{base.subtract(BigInteger.ONE), coord[1].add(BigInteger.ONE)}, nd.left);  \\n                        newTopSet.add(base.subtract(BigInteger.ONE));\\n                        if(nd.right != null){\\n                            newTreeMap.put(new BigInteger[]{base.add(BigInteger.ONE), coord[1].add(BigInteger.ONE)}, nd.right);  \\n                        }\\n                    }\\n                }else{\\n                    \\n                    finalSet.add(coord);\\n                }\\n            }\\n            \\n            if(going){\\n                treeMap = newTreeMap;\\n                maxY++;\\n                topSet = newTopSet;\\n                \\n            }\\n        }\\n        finalSet.add(new BigInteger[]{BigInteger.ZERO,BigInteger.ZERO});\\n        for(BigInteger xTop: topSet){\\n            System.out.println(xTop);\\n            for(BigInteger[] loc: finalSet){\\n                BigInteger power = loc[0];\\n                for(int j = 0; j < maxY - loc[1].intValue(); j++){\\n                    power = power.multiply(new BigInteger(\"2\"));\\n                }\\n                BigInteger xLeft = power;\\n                BigInteger xRight = power;\\n                int twos = 0;\\n                int dist = 0;\\n                if(xTop.compareTo(xLeft) < 0){\\n                    xLeft = xTop;\\n                }\\n                if(xTop.compareTo(xRight) > 0){\\n                    xRight = xTop;\\n                }\\n                \\n                for(double i = xLeft.doubleValue(); i < xRight.doubleValue() + 1; i += 0){\\n                    BigDecimal testD = new BigDecimal(i);\\n                    BigInteger test = testD.toBigInteger();\\n                    twos = 0;\\n                    BigInteger compare = test.mod(new BigInteger(\"2\"));\\n                    while(compare.equals(new BigInteger(\"0\"))){\\n                        if(test.equals(BigInteger.ZERO)){\\n                            twos = maxY;\\n                            break;\\n                            \\n                        }\\n                        twos ++;\\n                        test = test.divide(new BigInteger(\"2\"));\\n                        compare = test.mod(new BigInteger(\"2\"));            \\n                    }\\n                    i += Math.pow(2,twos); \\n                    dist = twos * 2 - maxY + loc[1].intValue();\\n                    if(dist > maxDistance){\\n                        maxDistance = dist;\\n                    }\\n                }\\n            }\\n        }\\n        return maxDistance;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nimport java.util.*;\\nimport java.lang.*;\\nimport java.math.*;\\nclass Solution {\\n    public int diameterOfBinaryTree(TreeNode root) {\\n        if(root == null){\\n            return 0;\\n        }\\n        HashMap<BigInteger[], TreeNode> treeMap = new HashMap<BigInteger[], TreeNode>();\\n        treeMap.put(new BigInteger[]{BigInteger.ZERO,BigInteger.ZERO}, root);\\n        int maxY = 0;\\n        int maxDistance = 0;\\n        boolean going = true;\\n        Set<BigInteger[]> fakeSet;\\n        ArrayList<BigInteger> topSet = new ArrayList<BigInteger>();\\n        ArrayList<BigInteger[]> finalSet = new ArrayList<BigInteger[]>();\\n        while(going){\\n            going = false;\\n            ArrayList<BigInteger> newTopSet = new ArrayList<BigInteger>();\\n            Iterator<BigInteger[]> itrKeys = treeMap.keySet().iterator();\\n            HashMap<BigInteger[], TreeNode> newTreeMap = new HashMap<BigInteger[], TreeNode>();\\n            while(itrKeys.hasNext()){\\n                BigInteger[] coord = itrKeys.next();\\n                TreeNode nd = treeMap.get(coord);\\n                if(nd.left != null || nd.right != null){      \\n                    going = true;\\n                    BigInteger base = coord[0].multiply(BigInteger.valueOf(2L));\\n                    if(nd.left == null){\\n                        newTreeMap.put(new BigInteger[]{base.add(BigInteger.ONE), coord[1].add(BigInteger.ONE)}, nd.right);  \\n                        newTopSet.add(base.add(BigInteger.ONE));\\n                    }else{\\n                        newTreeMap.put(new BigInteger[]{base.subtract(BigInteger.ONE), coord[1].add(BigInteger.ONE)}, nd.left);  \\n                        newTopSet.add(base.subtract(BigInteger.ONE));\\n                        if(nd.right != null){\\n                            newTreeMap.put(new BigInteger[]{base.add(BigInteger.ONE), coord[1].add(BigInteger.ONE)}, nd.right);  \\n                        }\\n                    }\\n                }else{\\n                    \\n                    finalSet.add(coord);\\n                }\\n            }\\n            \\n            if(going){\\n                treeMap = newTreeMap;\\n                maxY++;\\n                topSet = newTopSet;\\n                \\n            }\\n        }\\n        finalSet.add(new BigInteger[]{BigInteger.ZERO,BigInteger.ZERO});\\n        for(BigInteger xTop: topSet){\\n            System.out.println(xTop);\\n            for(BigInteger[] loc: finalSet){\\n                BigInteger power = loc[0];\\n                for(int j = 0; j < maxY - loc[1].intValue(); j++){\\n                    power = power.multiply(new BigInteger(\"2\"));\\n                }\\n                BigInteger xLeft = power;\\n                BigInteger xRight = power;\\n                int twos = 0;\\n                int dist = 0;\\n                if(xTop.compareTo(xLeft) < 0){\\n                    xLeft = xTop;\\n                }\\n                if(xTop.compareTo(xRight) > 0){\\n                    xRight = xTop;\\n                }\\n                \\n                for(double i = xLeft.doubleValue(); i < xRight.doubleValue() + 1; i += 0){\\n                    BigDecimal testD = new BigDecimal(i);\\n                    BigInteger test = testD.toBigInteger();\\n                    twos = 0;\\n                    BigInteger compare = test.mod(new BigInteger(\"2\"));\\n                    while(compare.equals(new BigInteger(\"0\"))){\\n                        if(test.equals(BigInteger.ZERO)){\\n                            twos = maxY;\\n                            break;\\n                            \\n                        }\\n                        twos ++;\\n                        test = test.divide(new BigInteger(\"2\"));\\n                        compare = test.mod(new BigInteger(\"2\"));            \\n                    }\\n                    i += Math.pow(2,twos); \\n                    dist = twos * 2 - maxY + loc[1].intValue();\\n                    if(dist > maxDistance){\\n                        maxDistance = dist;\\n                    }\\n                }\\n            }\\n        }\\n        return maxDistance;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 101132,
                "title": "java-solution-maxdepth",
                "content": "For ```every``` node, length of longest path which ```pass it``` = MaxDepth of its left subtree + MaxDepth of its right subtree.\\n\\n```\\npublic class Solution {\\n    int max = 0;\\n    \\n    public int diameterOfBinaryTree(TreeNode root) {\\n        maxDepth(root);\\n        return max;\\n    }\\n    \\n    private int maxDepth(TreeNode root) {\\n        if (root == null) return 0;\\n        \\n        int left = maxDepth(root.left);\\n        int right = maxDepth(root.right);\\n        \\n        max = Math.max(max, left + right);\\n        \\n        return Math.max(left, right) + 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```every```\n```pass it```\n```\\npublic class Solution {\\n    int max = 0;\\n    \\n    public int diameterOfBinaryTree(TreeNode root) {\\n        maxDepth(root);\\n        return max;\\n    }\\n    \\n    private int maxDepth(TreeNode root) {\\n        if (root == null) return 0;\\n        \\n        int left = maxDepth(root.left);\\n        int right = maxDepth(root.right);\\n        \\n        max = Math.max(max, left + right);\\n        \\n        return Math.max(left, right) + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 573591,
                "title": "c-5-lines-o-n-solution",
                "content": "The question can be solved by small modification to program of Height of tree.\\nThe idea is quite simple. Max value of Height(leftSubtree)+Height(rightSubtree) (at any node ) is the diameter. Keep track of maxium diameter duing traversal and find the height of the tree.\\n\\n d=max(d,ld+rd);    => This line maintains the max diameter.\\n \\n```\\nint diameterOfBinaryTree(TreeNode* root) {\\n        int d=0;\\n        rec(root, d);\\n        return d;\\n    }\\n    \\n    int rec(TreeNode* root, int &d) {\\n        if(root == NULL) return 0;\\n        int ld = rec(root->left, d);\\n        int rd = rec(root->right, d);\\n        d=max(d,ld+rd);\\n        return max(ld,rd)+1;\\n    }\\n\\t\\n\\t\\n\\t",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "The question can be solved by small modification to program of Height of tree.\\nThe idea is quite simple. Max value of Height(leftSubtree)+Height(rightSubtree) (at any node ) is the diameter. Keep track of maxium diameter duing traversal and find the height of the tree.\\n\\n d=max(d,ld+rd);    => This line maintains the max diameter.\\n \\n```\\nint diameterOfBinaryTree(TreeNode* root) {\\n        int d=0;\\n        rec(root, d);\\n        return d;\\n    }\\n    \\n    int rec(TreeNode* root, int &d) {\\n        if(root == NULL) return 0;\\n        int ld = rec(root->left, d);\\n        int rd = rec(root->right, d);\\n        d=max(d,ld+rd);\\n        return max(ld,rd)+1;\\n    }\\n\\t\\n\\t\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 101145,
                "title": "simple-python",
                "content": "Just go through the tree.\\n```\\nclass Solution(object):\\n    def diameterOfBinaryTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        self.ans = 0\\n        \\n        def depth(p):\\n            if not p: return 0\\n            left, right = depth(p.left), depth(p.right)\\n            self.ans = max(self.ans, left+right)\\n            return 1 + max(left, right)\\n            \\n        depth(root)\\n        return self.ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def diameterOfBinaryTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        self.ans = 0\\n        \\n        def depth(p):\\n            if not p: return 0\\n            left, right = depth(p.left), depth(p.right)\\n            self.ans = max(self.ans, left+right)\\n            return 1 + max(left, right)\\n            \\n        depth(root)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1515564,
                "title": "python-easy-to-understand-solution-w-explanation",
                "content": "### Introduction\\nConsider the first given example in the problem description:\\n\\n![image](https://assets.leetcode.com/users/images/90e976f1-7da7-4f56-914f-749ff330029f_1633924958.2044275.png)\\n\\nThe maximum depth of the left side of the tree is 2 (1 -> 2 -> 4/5), while the maximum depth of the right side of the tree is 1 (1 -> 3). This, coincidentally, matches well with the given diameter, since we can traverse from the leaf node(s) of one side of the tree to the leaf node(s) of the other side of the tree to obtain the diameter (for example, 3 -> 1 -> 2 -> 4).\\n\\n---\\n\\n### Idea 1\\n\\nThe diameter of a given tree is the **maximum depth of the left side of the tree**, plus the **maximum depth of the right side of the tree**. We can write the following pseudocode:\\n\\n```python\\n# depth() is a pseudocode function we have to implement later\\ndiameter = depth(root.left) + depth(root.right)\\n```\\n\\nTo actually write this, we need to find the maximum depth of a given tree. This is simple; for any given tree, we can find the maximum depth of the left side of the tree, the maximum depth of the right side of the tree, and +1 to the maximum of the two depths.\\n\\n```python\\ndef depth(node: Optional[TreeNode]) -> int:\\n    \"\"\"\\n\\tTo find the maximum depth of a given tree.\\n\\t:param node: The (root) node of the tree.\\n\\t:returns: The maximum depth of the tree, at the specified node.\\n\\t\"\"\"\\n\\t# return 1 + max(depth(node.left), depth(node.right)) if node else 0  # one-liner\\n\\tif not node:\\n\\t    return 0  # the depth of a non-existent node is 0\\n\\tleft = depth(node.left)  # get the depth of the left side of the tree\\n\\tright = depth(node.right)  # get the depth of the right side of the tree\\n\\treturn 1 + (left if left > right else right)  # take the maximum, and +1 for the current node\\n```\\n\\nWe now have everything our pseudocode needs. To put it all together, make sure that we are calculating the diameter from the root node, not the depth.\\n\\n```python\\n# Idea 1 Implementation!\\nclass Solution:\\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n\\t    # Implement depth\\n\\t    def depth(node: Optional[TreeNode]) -> int:\\n\\t\\t    return 1 + max(depth(node.left), depth(node.right)) if node else 0\\n\\t\\treturn depth(root.left) + depth(root.right)  # calculate diameter\\n```\\n\\nAnd that\\'s it! Run the code and... WA. >:)\\n\\n---\\n\\n### Idea 2\\n\\nAs it turns out, the maximum diameter of a given tree **need not involve the root node of the tree**. That means, if we only calculated the diamter of a tree from the root node, as our 1st implementation does, we might miss out on another pathway that does not pass through the root node but has a longer diameter. To visualise this, consider the following tree:\\n\\n![image](https://assets.leetcode.com/users/images/75774378-bb57-4468-802b-bc021439da9b_1633927697.2095265.png)\\n\\nIf we were to calculate the diameter as per the 1st implementation, the diameter would be 5 (2 -> 1 -> 3 -> 4 -> 6 -> 8). At first glance, this might seem correct, but there is actually a longer pathway with diameter 6 (9 -> 7 -> 5 -> 3 -> 4 -> 6 -> 8)! This is a problem for our 1st implementation since we assume the left side of the tree is involved with the diameter calculation.\\n\\nThe solution? We need to **calculate the diameter at each node and find the maximum diameter**. This is a simple fix because we just need to account for diameter calculation per call of depth(). This guarantees that we loop through each node in the tree and find the maximum possible diameter.\\n\\nNote that we **still need to calculate the depth as per 1st implementation**. Since the diameter formula requires the depth value, each node still needs to know the maximum depth of its left side and the maximum depth of its right side.\\n\\n```python\\nclass Solution:\\n    def __init__(self):\\n\\t    self.diameter = 0  # stores the maximum diameter calculated\\n\\t\\n    def depth(self, node: Optional[TreeNode]) -> int:\\n        \"\"\"\\n        This function needs to do the following:\\n            1. Calculate the maximum depth of the left and right sides of the given node\\n            2. Determine the diameter at the given node and check if its the maximum\\n        \"\"\"\\n        # Calculate maximum depth\\n        left = self.depth(node.left) if node.left else 0\\n        right = self.depth(node.right) if node.right else 0\\n        # Calculate diameter\\n        if left + right > self.diameter:\\n            self.diameter = left + right\\n        # Make sure the parent node(s) get the correct depth from this node\\n        return 1 + (left if left > right else right)\\n    \\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        # if not root:\\n        #     return 0\\n        self.depth(root)  # root is guaranteed to be a TreeNode object\\n        return self.diameter\\n```\\n\\n---\\n\\n### Final result\\n\\n![image](https://assets.leetcode.com/users/images/00535fc1-8fab-42d8-9797-d6a10f94c7aa_1633929113.2661655.png)\\n\\n\\nPlease upvote if this has helped you! Appreciate any comments as well :)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```python\\n# depth() is a pseudocode function we have to implement later\\ndiameter = depth(root.left) + depth(root.right)\\n```\n```python\\ndef depth(node: Optional[TreeNode]) -> int:\\n    \"\"\"\\n\\tTo find the maximum depth of a given tree.\\n\\t:param node: The (root) node of the tree.\\n\\t:returns: The maximum depth of the tree, at the specified node.\\n\\t\"\"\"\\n\\t# return 1 + max(depth(node.left), depth(node.right)) if node else 0  # one-liner\\n\\tif not node:\\n\\t    return 0  # the depth of a non-existent node is 0\\n\\tleft = depth(node.left)  # get the depth of the left side of the tree\\n\\tright = depth(node.right)  # get the depth of the right side of the tree\\n\\treturn 1 + (left if left > right else right)  # take the maximum, and +1 for the current node\\n```\n```python\\n# Idea 1 Implementation!\\nclass Solution:\\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n\\t    # Implement depth\\n\\t    def depth(node: Optional[TreeNode]) -> int:\\n\\t\\t    return 1 + max(depth(node.left), depth(node.right)) if node else 0\\n\\t\\treturn depth(root.left) + depth(root.right)  # calculate diameter\\n```\n```python\\nclass Solution:\\n    def __init__(self):\\n\\t    self.diameter = 0  # stores the maximum diameter calculated\\n\\t\\n    def depth(self, node: Optional[TreeNode]) -> int:\\n        \"\"\"\\n        This function needs to do the following:\\n            1. Calculate the maximum depth of the left and right sides of the given node\\n            2. Determine the diameter at the given node and check if its the maximum\\n        \"\"\"\\n        # Calculate maximum depth\\n        left = self.depth(node.left) if node.left else 0\\n        right = self.depth(node.right) if node.right else 0\\n        # Calculate diameter\\n        if left + right > self.diameter:\\n            self.diameter = left + right\\n        # Make sure the parent node(s) get the correct depth from this node\\n        return 1 + (left if left > right else right)\\n    \\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        # if not root:\\n        #     return 0\\n        self.depth(root)  # root is guaranteed to be a TreeNode object\\n        return self.diameter\\n```",
                "codeTag": "Java"
            },
            {
                "id": 101120,
                "title": "java-easy-to-understand-solution",
                "content": "``` \\npublic class Solution {\\n    public int diameterOfBinaryTree(TreeNode root) {\\n        if(root == null){\\n            return 0;\\n        }\\n       int dia = depth(root.left) + depth(root.right);\\n       int ldia = diameterOfBinaryTree(root.left);\\n       int rdia = diameterOfBinaryTree(root.right);\\n       return Math.max(dia,Math.max(ldia,rdia));\\n        \\n    }\\n    public int depth(TreeNode root){\\n        if(root == null){\\n            return 0;\\n        }\\n        return 1+Math.max(depth(root.left), depth(root.right));\\n    }\\n    \\n}\\n\\n ```",
                "solutionTags": [],
                "code": "``` \\npublic class Solution {\\n    public int diameterOfBinaryTree(TreeNode root) {\\n        if(root == null){\\n            return 0;\\n        }\\n       int dia = depth(root.left) + depth(root.right);\\n       int ldia = diameterOfBinaryTree(root.left);\\n       int rdia = diameterOfBinaryTree(root.right);\\n       return Math.max(dia,Math.max(ldia,rdia));\\n        \\n    }\\n    public int depth(TreeNode root){\\n        if(root == null){\\n            return 0;\\n        }\\n        return 1+Math.max(depth(root.left), depth(root.right));\\n    }\\n    \\n}\\n\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 124198,
                "title": "iterative-accepted-java-solution",
                "content": "The idea is to use Post order traversal which means make sure the node is there till the left and right childs are processed that\\'s the reason you use peek method in the stack to not pop it off without being done with the left and right child nodes. Then for each node calculate the max of the left and right sub trees depth and also simultaneouslt caluculate the overall max of the left and right subtrees count.\\n\\n```\\npublic int diameterOfBinaryTree(TreeNode root) {\\n        if( root == null){\\n            return 0;\\n        }\\n        if(root == null){\\n            return 0;\\n        }\\n        int overallNodeMax = 0;\\n        Stack<TreeNode> nodeStack = new Stack<>();\\n        Map<TreeNode,Integer> nodePathCountMap = new HashMap<>();\\n        nodeStack.push(root);\\n        while(!nodeStack.isEmpty()){\\n            TreeNode node = nodeStack.peek();\\n            if(node.left != null && !nodePathCountMap.containsKey(node.left)){\\n                nodeStack.push(node.left);\\n            }else if(node.right!=null && !nodePathCountMap.containsKey(node.right)){\\n                nodeStack.push(node.right);\\n            }else {\\n                TreeNode rootNodeEndofPostOrder = nodeStack.pop();\\n                int leftMax = nodePathCountMap.getOrDefault(rootNodeEndofPostOrder.left,0);\\n                int rightMax = nodePathCountMap.getOrDefault(rootNodeEndofPostOrder.right,0);\\n                int nodeMax = 1 + Math.max(leftMax,rightMax);\\n                nodePathCountMap.put(rootNodeEndofPostOrder,nodeMax);\\n                overallNodeMax = Math.max(overallNodeMax,leftMax + rightMax );\\n            }\\n            \\n        }\\n        return overallNodeMax;\\n        \\n    } \\n```",
                "solutionTags": [],
                "code": "```\\npublic int diameterOfBinaryTree(TreeNode root) {\\n        if( root == null){\\n            return 0;\\n        }\\n        if(root == null){\\n            return 0;\\n        }\\n        int overallNodeMax = 0;\\n        Stack<TreeNode> nodeStack = new Stack<>();\\n        Map<TreeNode,Integer> nodePathCountMap = new HashMap<>();\\n        nodeStack.push(root);\\n        while(!nodeStack.isEmpty()){\\n            TreeNode node = nodeStack.peek();\\n            if(node.left != null && !nodePathCountMap.containsKey(node.left)){\\n                nodeStack.push(node.left);\\n            }else if(node.right!=null && !nodePathCountMap.containsKey(node.right)){\\n                nodeStack.push(node.right);\\n            }else {\\n                TreeNode rootNodeEndofPostOrder = nodeStack.pop();\\n                int leftMax = nodePathCountMap.getOrDefault(rootNodeEndofPostOrder.left,0);\\n                int rightMax = nodePathCountMap.getOrDefault(rootNodeEndofPostOrder.right,0);\\n                int nodeMax = 1 + Math.max(leftMax,rightMax);\\n                nodePathCountMap.put(rootNodeEndofPostOrder,nodeMax);\\n                overallNodeMax = Math.max(overallNodeMax,leftMax + rightMax );\\n            }\\n            \\n        }\\n        return overallNodeMax;\\n        \\n    } \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1039281,
                "title": "3-java-solutions-with-explanation-o-n-100-fast",
                "content": "Only 3 cases occur while finding diameter:\\n* the maximum diameter lies in left sub tree entirely (as in the below image)\\n* the maximum diameter lies in right sub tree entirely\\n* the maximum diameter passes through the root node(height of lhs +height of rhs+2)\\n\\n![image](https://assets.leetcode.com/users/images/e3b0dbb9-048f-4ac2-9f44-514b18f6dc13_1611853732.514355.png)\\n\\n\\n\\n**Method 1: Intuitive | O(n^2) | Recursion inside recursion**\\n\\n```\\n//O(n^2) complexity because we are making recursive call to height inside the recursive calls of diameter.\\n    public int diameterOfBinaryTree(TreeNode root) {  \\n        if(root==null)return 0;\\n        int lhs=diameterOfBinaryTree(root.left);\\n        int rhs=diameterOfBinaryTree(root.right);\\n        \\n        return Math.max(height(root.left)+height(root.right)+2, Math.max(lhs, rhs));\\n    }\\n    public int height(TreeNode root){\\n        if(root==null)return -1;\\n        \\n        int lhs=height(root.left);\\n        int rhs=height(root.right);\\n        \\n        return Math.max(lhs, rhs)+1;\\n    }\\n```\\n\\n\\n**Method 2: O(n) recursive solution | making a single recursive call and computing diameter and height simultaneously.**\\n\\n\\n```\\nclass Solution {\\n    public int diameterOfBinaryTree(TreeNode root) {\\n        if(root==null)return 0;\\n   \\n        DiaPair ans=findDiameter(root);\\n        \\n        return ans.diameter;\\n    }\\n    \\n    public DiaPair findDiameter(TreeNode root ){  //O(n)\\n        if(root==null){\\n            return new DiaPair(-1, 0);\\n        }\\n        \\n        DiaPair lhs=findDiameter(root.left);\\n        DiaPair rhs=findDiameter(root.right);\\n        \\n        DiaPair myPair=new DiaPair();\\n        myPair.diameter=Math.max(lhs.height+rhs.height+2, Math.max(lhs.diameter, rhs.diameter));\\n        myPair.height=Math.max(lhs.height, rhs.height)+1;\\n        \\n        return myPair;\\n    }\\n}\\nclass DiaPair{\\n    int height;\\n    int diameter;\\n    \\n    public DiaPair(){}\\n    \\n    public DiaPair(int height, int diameter){\\n        this.height=height;\\n        this.diameter=diameter;\\n    }\\n}\\n```\\n\\n\\n**Method 3: Clean O(n) solution without custom class**\\n* Find sum of height of LST+ RST (find global max)\\n* For\\xA0every\\xA0node, length of longest path which\\xA0pass it\\xA0= MaxDepth of its left subtree + MaxDepth of its right subtree+2.\\n```\\n    int ans=0;\\n    public int diameterOfBinaryTree(TreeNode root) {\\n        if(root==null )return 0;\\n        height(root);\\n        return ans;\\n    }\\n    \\n    public int height(TreeNode root){\\n        //if root==null height==0\\n        if(root==null)return -1;\\n        \\n        int L=height(root.left);\\n        int R=height(root.right);\\n        //ans signfies(no. of nodes farthest apart) or the DIAMETER\\n        ans=Math.max(ans,L+R+2);\\n        //height of the tree is max of LST & RST +1\\n        return 1+Math.max(L,R);\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n//O(n^2) complexity because we are making recursive call to height inside the recursive calls of diameter.\\n    public int diameterOfBinaryTree(TreeNode root) {  \\n        if(root==null)return 0;\\n        int lhs=diameterOfBinaryTree(root.left);\\n        int rhs=diameterOfBinaryTree(root.right);\\n        \\n        return Math.max(height(root.left)+height(root.right)+2, Math.max(lhs, rhs));\\n    }\\n    public int height(TreeNode root){\\n        if(root==null)return -1;\\n        \\n        int lhs=height(root.left);\\n        int rhs=height(root.right);\\n        \\n        return Math.max(lhs, rhs)+1;\\n    }\\n```\n```\\nclass Solution {\\n    public int diameterOfBinaryTree(TreeNode root) {\\n        if(root==null)return 0;\\n   \\n        DiaPair ans=findDiameter(root);\\n        \\n        return ans.diameter;\\n    }\\n    \\n    public DiaPair findDiameter(TreeNode root ){  //O(n)\\n        if(root==null){\\n            return new DiaPair(-1, 0);\\n        }\\n        \\n        DiaPair lhs=findDiameter(root.left);\\n        DiaPair rhs=findDiameter(root.right);\\n        \\n        DiaPair myPair=new DiaPair();\\n        myPair.diameter=Math.max(lhs.height+rhs.height+2, Math.max(lhs.diameter, rhs.diameter));\\n        myPair.height=Math.max(lhs.height, rhs.height)+1;\\n        \\n        return myPair;\\n    }\\n}\\nclass DiaPair{\\n    int height;\\n    int diameter;\\n    \\n    public DiaPair(){}\\n    \\n    public DiaPair(int height, int diameter){\\n        this.height=height;\\n        this.diameter=diameter;\\n    }\\n}\\n```\n```\\n    int ans=0;\\n    public int diameterOfBinaryTree(TreeNode root) {\\n        if(root==null )return 0;\\n        height(root);\\n        return ans;\\n    }\\n    \\n    public int height(TreeNode root){\\n        //if root==null height==0\\n        if(root==null)return -1;\\n        \\n        int L=height(root.left);\\n        int R=height(root.right);\\n        //ans signfies(no. of nodes farthest apart) or the DIAMETER\\n        ans=Math.max(ans,L+R+2);\\n        //height of the tree is max of LST & RST +1\\n        return 1+Math.max(L,R);\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 101148,
                "title": "intuitive-javascript-solution",
                "content": "```\\nvar diameterOfBinaryTree = function(root) {\\n    let diameter = 0;\\n    \\n    dfs(root);\\n    \\n    return diameter;\\n    \\n    function dfs(node, level) {\\n        if (!node) return 0;\\n        \\n        const left = dfs(node.left);\\n        const right = dfs(node.right);\\n        \\n        // update diameter at every node\\n        diameter = Math.max(diameter, left + right);\\n\\n        // update the largest number of edge so far\\n        return 1 + Math.max(left, right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nvar diameterOfBinaryTree = function(root) {\\n    let diameter = 0;\\n    \\n    dfs(root);\\n    \\n    return diameter;\\n    \\n    function dfs(node, level) {\\n        if (!node) return 0;\\n        \\n        const left = dfs(node.left);\\n        const right = dfs(node.right);\\n        \\n        // update diameter at every node\\n        diameter = Math.max(diameter, left + right);\\n\\n        // update the largest number of edge so far\\n        return 1 + Math.max(left, right);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 101130,
                "title": "c-java-clean-code",
                "content": "**C++**\\n```\\nclass Solution {\\npublic:\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        int diameter = 0;\\n        height(root, diameter);\\n        return diameter;\\n    }\\nprivate:\\n    int height(TreeNode* node, int& diameter) {\\n        if (!node) {\\n            return 0;\\n        }\\n        int lh = height(node->left, diameter);\\n        int rh = height(node->right, diameter);\\n        diameter = max(diameter, lh + rh);\\n        return 1 + max(lh, rh);\\n    }\\n};\\n```\\n**Java**\\n```\\npublic class Solution {\\n    public int diameterOfBinaryTree(TreeNode root) {\\n        int[] diameter = new int[1];\\n        height(root, diameter);\\n        return diameter[0];        \\n    }\\n\\n    private int height(TreeNode node, int[] diameter) {\\n        if (node == null) {\\n            return 0;\\n        }\\n        int lh = height(node.left, diameter);\\n        int rh = height(node.right, diameter);\\n        diameter[0] = Math.max(diameter[0], lh + rh);\\n        return 1 + Math.max(lh, rh);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        int diameter = 0;\\n        height(root, diameter);\\n        return diameter;\\n    }\\nprivate:\\n    int height(TreeNode* node, int& diameter) {\\n        if (!node) {\\n            return 0;\\n        }\\n        int lh = height(node->left, diameter);\\n        int rh = height(node->right, diameter);\\n        diameter = max(diameter, lh + rh);\\n        return 1 + max(lh, rh);\\n    }\\n};\\n```\n```\\npublic class Solution {\\n    public int diameterOfBinaryTree(TreeNode root) {\\n        int[] diameter = new int[1];\\n        height(root, diameter);\\n        return diameter[0];        \\n    }\\n\\n    private int height(TreeNode node, int[] diameter) {\\n        if (node == null) {\\n            return 0;\\n        }\\n        int lh = height(node.left, diameter);\\n        int rh = height(node.right, diameter);\\n        diameter[0] = Math.max(diameter[0], lh + rh);\\n        return 1 + Math.max(lh, rh);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 101118,
                "title": "python-simple-with-explanation",
                "content": "Let's calculate the depth of a node in the usual way: max(depth of node.left, depth of node.right) + 1.  While we do, a path \"through\" this node uses 1 + (depth of node.left) + (depth of node.right) nodes.  Let's search each node and remember the highest number of nodes used in some path.  The desired length is 1 minus this number.\\n```\\ndef diameterOfBinaryTree(self, root):\\n    self.best = 1\\n    def depth(root):\\n        if not root: return 0\\n        ansL = depth(root.left)\\n        ansR = depth(root.right)\\n        self.best = max(self.best, ansL + ansR + 1)\\n        return 1 + max(ansL, ansR)\\n        \\n    depth(root)\\n    return self.best - 1\\n```",
                "solutionTags": [],
                "code": "```\\ndef diameterOfBinaryTree(self, root):\\n    self.best = 1\\n    def depth(root):\\n        if not root: return 0\\n        ansL = depth(root.left)\\n        ansR = depth(root.right)\\n        self.best = max(self.best, ansL + ansR + 1)\\n        return 1 + max(ansL, ansR)\\n        \\n    depth(root)\\n    return self.best - 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 480877,
                "title": "543-diameter-of-binary-tree-and-124-binary-tree-maximum-path-sum",
                "content": "To me, this problem is the same as https://leetcode.com/problems/binary-tree-maximum-path-sum/. That problem is at a hard level, but this is at an easy level, interesting. You can compare the code for better learning.\\n```\\nclass Solution:\\n    def diameterOfBinaryTree(self, root: TreeNode) -> int:\\n        def height(root):\\n            nonlocal diameter\\n            if not root:\\n                return 0\\n            \\n            left = height(root.left)\\n            right = height(root.right)\\n            diameter = max(diameter, left + right)\\n            return max(left, right) + 1\\n        \\n        diameter = 0\\n        height(root)\\n        return diameter\\n```\\n\\n```\\nclass Solution:\\n    def maxPathSum(self, root: TreeNode) -> int:\\n        def maxPath(root):\\n            nonlocal maxSum\\n            if not root:\\n                return 0\\n            \\n            left = maxPath(root.left)\\n            right = maxPath(root.right)\\n            maxSum = max(maxSum, left + right + root.val)\\n            return max(left + root.val, right + root.val, 0)\\n        \\n        maxSum = -math.inf  \\n        maxPath(root)\\n        return maxSum\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def diameterOfBinaryTree(self, root: TreeNode) -> int:\\n        def height(root):\\n            nonlocal diameter\\n            if not root:\\n                return 0\\n            \\n            left = height(root.left)\\n            right = height(root.right)\\n            diameter = max(diameter, left + right)\\n            return max(left, right) + 1\\n        \\n        diameter = 0\\n        height(root)\\n        return diameter\\n```\n```\\nclass Solution:\\n    def maxPathSum(self, root: TreeNode) -> int:\\n        def maxPath(root):\\n            nonlocal maxSum\\n            if not root:\\n                return 0\\n            \\n            left = maxPath(root.left)\\n            right = maxPath(root.right)\\n            maxSum = max(maxSum, left + right + root.val)\\n            return max(left + root.val, right + root.val, 0)\\n        \\n        maxSum = -math.inf  \\n        maxPath(root)\\n        return maxSum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 706724,
                "title": "c-solution-with-explanation",
                "content": "\\nApproach:- \\n Please draw a sample tree first. You will see that a diameter is nothing but  maximum( left height +right height+1) for a node. Keep updating this value for every node.\\n \\n You can calculate height of the tree for every node and then compare it with the value (in this case \"ans\" ). The return value is the height of the tree for a node. \\n \\n It will take O( N^2 ) if we write a separate height function, as we are visiting each node twice. Why not, visit the tree once and calculate height in the same recursion keep a check on \"ans\".\\n \\n Time Comp - O(N)\\n \\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n    int ans=0;\\n    \\n    int height(TreeNode* root)\\n    {\\n        if(!root) return 0;\\n        \\n        int lHeight = height(root->left);\\n        int rHeight = height(root->right);\\n        \\n        ans= max(ans, 1 + lHeight + rHeight);\\n        return 1+ max( lHeight , rHeight);\\n\\n    }\\n    \\n    int diameterOfBinaryTree(TreeNode* root) {\\n        if(!root) return 0;\\n        height(root);\\n        return ans-1;\\n    }\\n};\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n    int ans=0;\\n    \\n    int height(TreeNode* root)\\n    {\\n        if(!root) return 0;\\n        \\n        int lHeight = height(root->left);\\n        int rHeight = height(root->right);\\n        \\n        ans= max(ans, 1 + lHeight + rHeight);\\n        return 1+ max( lHeight , rHeight);\\n\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3362822,
                "title": "java-100-faster-detailed-explaination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/b4a98a6d-7576-4566-95c3-999265588fe4_1680268895.8929434.png)\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int diameterOfBinaryTree(TreeNode root) {\\n\\n        // Create an array to hold the diameter of the tree\\n        int diameter[] = new int[1];\\n\\n        // Recursively calculate the height of the tree and update the diameter array\\n        height(root,diameter);\\n\\n        // Return the diameter of the tree\\n      return diameter[0];\\n    }\\n\\n    public int height(TreeNode root, int diameter[]){\\n        \\n        // Base case: if the root is null, the height is 0\\n        if(root == null){\\n            return 0;\\n        }\\n\\n        // Recursively calculate the height of the left and right subtrees\\n        int left = height(root.left,diameter);\\n        int right = height(root.right,diameter);\\n\\n        // Update the diameter array by taking the maximum diameter that passes through the current node\\n        diameter[0] = Math.max(diameter[0],left + right);\\n\\n        // Return the maximum depth of the current node by adding 1 to the maximum depth of its deepest subtree\\n        return Math.max(left,right)+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int diameterOfBinaryTree(TreeNode root) {\\n\\n        // Create an array to hold the diameter of the tree\\n        int diameter[] = new int[1];\\n\\n        // Recursively calculate the height of the tree and update the diameter array\\n        height(root,diameter);\\n\\n        // Return the diameter of the tree\\n      return diameter[0];\\n    }\\n\\n    public int height(TreeNode root, int diameter[]){\\n        \\n        // Base case: if the root is null, the height is 0\\n        if(root == null){\\n            return 0;\\n        }\\n\\n        // Recursively calculate the height of the left and right subtrees\\n        int left = height(root.left,diameter);\\n        int right = height(root.right,diameter);\\n\\n        // Update the diameter array by taking the maximum diameter that passes through the current node\\n        diameter[0] = Math.max(diameter[0],left + right);\\n\\n        // Return the maximum depth of the current node by adding 1 to the maximum depth of its deepest subtree\\n        return Math.max(left,right)+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1539484,
                "title": "easy-trick-interviewers-don-t-want-you-to-know",
                "content": "let length(a,b) = number of edges between nodes a, b\\nour objective is to maximize the diameter = maximize path length between two nodes\\n\\nintuition: recognize that the longest path must include two leaf nodes, towards contradiction suppose longest path of length L starts at node a and ends at node b, we can increase this path by including children of a and b\\n\\nstandard tree question format:\\n```\\ndef solution(self, root):\\n\\tdef solve(root):\\n\\t\\tif not root:\\n\\t\\t\\t# do something\\n\\t\\tsolve(root.left)\\n\\t\\tsolve(root.right)\\n\\t\\treturn # something\\n\\tsolve(root)\\n\\treturn # something\\n```\\n\\nStart by looking at simplest tree case with 1 leaf node (written as [1]), diameter is 0\\nNext simplest tree case with parent node 1 and two children 2, 3 (written as [1,2,3], diameter is 2\\n\\nWe are trying to maximize some variable so lets keep track of it as `self.diameter`\\nAt node A we care about my left child\\'s longest path to leaf (`lclp2l`) and my right child\\'s longest path to leaf (`rclp2l`), if I add the two then I get the diameter which is \"centered\" on node A\\n\\nThe only information we still need is lclp2l and rclp2l, in recursion we `return` to pass information up the tree\\n\\nAssume we\\'re at node V somewhere in the tree and that V is the left child of its parent node P, then by returning `max(lclp2l, rclp2l) + 1` node P will know what the longest path in the tree (such that the path goes through node V and ends at a leaf) is from its left child, it will get the same information from its right child and update `self.diameter` in case the sum of those two lengths is larger\\n\\n```\\ndef diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        self.diameter = 0\\n        \\n        def dfs(node):\\n            if not node:\\n\\t\\t\\t\\t# my parent is a leaf (and the leaf base case has diameter = 0)\\n                return 0 \\n\\t\\t\\t\\t\\n            # len(longest path from r.left/right to some leaf)\\n            lclp2l, rclp2l = dfs(node.left), dfs(node.right) \\n            \\n            # diameter including this node is # edges on left path + #E(right)\\n            d = lclp2l + rclp2l\\n            self.diameter = max(d, self.diameter)\\n            \\n            # tell my parent the length of the longest path to a leaf that goes through me\\n\\t\\t\\t# this is just the maximum of the same problem but for each of my children and +1  \\n\\t\\t\\t#  to include the edge from me to the longest child \\n            return max(lclp2l, rclp2l) + 1     \\n        dfs(root)\\n        return self.diameter\\n```",
                "solutionTags": [
                    "Python",
                    "Tree"
                ],
                "code": "```\\ndef solution(self, root):\\n\\tdef solve(root):\\n\\t\\tif not root:\\n\\t\\t\\t# do something\\n\\t\\tsolve(root.left)\\n\\t\\tsolve(root.right)\\n\\t\\treturn # something\\n\\tsolve(root)\\n\\treturn # something\\n```\n```\\ndef diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        self.diameter = 0\\n        \\n        def dfs(node):\\n            if not node:\\n\\t\\t\\t\\t# my parent is a leaf (and the leaf base case has diameter = 0)\\n                return 0 \\n\\t\\t\\t\\t\\n            # len(longest path from r.left/right to some leaf)\\n            lclp2l, rclp2l = dfs(node.left), dfs(node.right) \\n            \\n            # diameter including this node is # edges on left path + #E(right)\\n            d = lclp2l + rclp2l\\n            self.diameter = max(d, self.diameter)\\n            \\n            # tell my parent the length of the longest path to a leaf that goes through me\\n\\t\\t\\t# this is just the maximum of the same problem but for each of my children and +1  \\n\\t\\t\\t#  to include the edge from me to the longest child \\n            return max(lclp2l, rclp2l) + 1     \\n        dfs(root)\\n        return self.diameter\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 574778,
                "title": "python3-dfs-bottom-up-to-calculate-the-height-of-the-node",
                "content": "*   [Height of node](http://typeocaml.com/2014/11/26/height-depth-and-level-of-a-tree/)  The height of a node is the number of edges on the longest downward path between that node and a leaf.\\ndfs function calculates the height of the node, i.e, the longest downward path between the node and a leaf.\\n* For a node, the length of longest path going through the node is the sum of left child\\'s height plus right child\\'s height.\\n* For each node in the binary tree, we calculate the length of the longest length going through the node, the maximum length is the diameter of the binary tree according to the definition --The diameter of a binary tree is the length of the longest path between any two nodes in a tree.\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def diameterOfBinaryTree(self, root: TreeNode) -> int:\\n        self.diameter = 0\\n        self.dfs(root)\\n        return self.diameter\\n    \\n    def dfs(self, node):\\n        # base case:\\n        if node == None:\\n            return 0\\n\\t\\t# recursive cases\\n        left_height = self.dfs(node.left)\\n        right_height = self.dfs(node.right)\\n        self.diameter = max(self.diameter,left_height + right_height )\\n        return max(left_height,right_height) + 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def diameterOfBinaryTree(self, root: TreeNode) -> int:\\n        self.diameter = 0\\n        self.dfs(root)\\n        return self.diameter\\n    \\n    def dfs(self, node):\\n        # base case:\\n        if node == None:\\n            return 0\\n\\t\\t# recursive cases\\n        left_height = self.dfs(node.left)\\n        right_height = self.dfs(node.right)\\n        self.diameter = max(self.diameter,left_height + right_height )\\n        return max(left_height,right_height) + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1515773,
                "title": "c-simple-and-clean-recursive-solution",
                "content": "**Idea:**\\nFor each node, the diameter is the height of the left node + the height of the right node.\\nSo we use DFS to get the heights recursively, and keep in `diameter` the maximum seen.\\n\\n**Time Complexity:** O(n)\\n**Space Complexity:** O(n) - for the recursive calls.\\n```\\nclass Solution {\\npublic:\\n    int dfs(TreeNode* root) {\\n        if (!root) return 0;\\n        int left = dfs(root->left), right = dfs(root->right);\\n        diameter = max(diameter, left + right);\\n        return max(left, right) + 1;\\n    }\\n    \\n    int diameterOfBinaryTree(TreeNode* root) {\\n        dfs(root);\\n        return diameter;\\n    }\\n    \\nprivate:\\n    int diameter = 0;\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(TreeNode* root) {\\n        if (!root) return 0;\\n        int left = dfs(root->left), right = dfs(root->right);\\n        diameter = max(diameter, left + right);\\n        return max(left, right) + 1;\\n    }\\n    \\n    int diameterOfBinaryTree(TreeNode* root) {\\n        dfs(root);\\n        return diameter;\\n    }\\n    \\nprivate:\\n    int diameter = 0;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1394464,
                "title": "un-optimized-to-optimized-solution-c-recursion-explained-solution",
                "content": "This question was initially very difficult to understant but then i looked through a couple of leetcode discussions and then  finally figured out the trick behind the question.\\n\\nThe most important fundamental is that the diameter will always be equal to the **sum of max left height and max right height** always so we will take this formula and apply this to every single node in the tree and just get the value of the diameter.\\n\\n```\\nint height(TreeNode* root)\\n    {\\n        if(!root)return 0;\\n        return max(height(root->left),height(root->right))+1;\\n    }\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        if(!root){return 0;}\\n        int h=height(root->right)+height(root->left);\\n        int leftDiameter=diameterOfBinaryTree(root->left);\\n        int rightDiameter=diameterOfBinaryTree(root->right);\\n        return max(h,max(leftDiameter,rightDiameter));   \\n    }\\n```\\n\\nthis solution is pretty neat that we are just finding the height and always storing the max of height sum we got. But the problem with this solution is that its time complexity is O(N*H) in the case of skewed trees the time complexity may go upto O(N^2) and in the case of a perfectly balanced tree with all nodes having 2 childrens expect the leaf node then the time complexity wil be O(nlogN).\\n\\n\\n\\nBut we can optimise this code and bring down the time complexity from O(N*H) to O(N).\\nBut how? \\nActually we can see a flaws in the above solution that acutally we are trying to find the height every single time and that is kindof repetitive so what we can do is we can just calculate the height of the tree as we did in the question number 104 leetcode with a very minute modification, actually we will just keep on updating the value of diameter and as i have explained earlier that the diameter is equal to the (max left height + max right height) we will keep on updating the diameter with the maximum value of the diameter.\\n\\n```\\nint diameter=INT_MIN;\\n    int helper(TreeNode* root)\\n    {\\n        if(!root)return 0;\\n        int leftHeight=helper(root->left);\\n        int rightHeight=helper(root->right);\\n        diameter=max(diameter,leftHeight+rightHeight);\\n        return max(leftHeight,rightHeight)+1;\\n    }\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        helper(root);\\n        return diameter;\\n    }\\n```\\n\\nAnd this is how we can reduce the time complexity from O(N*H) to O(N)\\n\\n**Please upvote of you liked my solution it gives me a lot of motivation to make more such detailed explainations.**\\n\\n**#happy_coding**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint height(TreeNode* root)\\n    {\\n        if(!root)return 0;\\n        return max(height(root->left),height(root->right))+1;\\n    }\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        if(!root){return 0;}\\n        int h=height(root->right)+height(root->left);\\n        int leftDiameter=diameterOfBinaryTree(root->left);\\n        int rightDiameter=diameterOfBinaryTree(root->right);\\n        return max(h,max(leftDiameter,rightDiameter));   \\n    }\\n```\n```\\nint diameter=INT_MIN;\\n    int helper(TreeNode* root)\\n    {\\n        if(!root)return 0;\\n        int leftHeight=helper(root->left);\\n        int rightHeight=helper(root->right);\\n        diameter=max(diameter,leftHeight+rightHeight);\\n        return max(leftHeight,rightHeight)+1;\\n    }\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        helper(root);\\n        return diameter;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 234397,
                "title": "c-recursive-and-iterative",
                "content": "The diameter of a tree is the maximum sum of the depths of left and right subtrees among its nodes. So we can compute the depths of the left and right subtrees of each node (recursively) and use these depths to compute the diameter at the current node.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        int diameter = 0;\\n        depth(root, diameter);\\n        return diameter;\\n    }\\nprivate:\\n    int depth(TreeNode* root, int& diameter) {\\n        if (!root) {\\n            return 0;\\n        }\\n        int l = depth(root -> left, diameter), r = depth(root -> right, diameter);\\n        diameter = max(diameter, l + r);\\n        return max(l, r) + 1;\\n    }\\n};\\n```\\n\\nAs this is a relatively easy recursive solution, if time allowed, the interviewer may still ask for an iterative solution. [This post](https://leetcode.com/problems/diameter-of-binary-tree/discuss/124198/Iterative-Accepted-Java-Solution) shares a very clean iterative one using postorder traversal, which I rewrote in C++ below.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        if (!root) {\\n            return 0;\\n        }\\n        int diameter = 0;\\n        unordered_map<TreeNode*, int> depths;\\n        stack<TreeNode*> todo;\\n        todo.push(root);\\n        while (!todo.empty()) {\\n            TreeNode* node = todo.top();\\n            if (node -> left && depths.find(node -> left) == depths.end()) {\\n                todo.push(node -> left);\\n            } else if (node -> right && depths.find(node -> right) == depths.end()) {\\n                todo.push(node -> right);\\n            } else {\\n                todo.pop();\\n                int l = depths[node -> left], r = depths[node -> right];\\n                depths[node] = max(l, r) + 1;\\n                diameter = max(diameter, l + r);\\n            }\\n        }\\n        return diameter;\\n    }\\n};\\n```\\n\\nNote that the following two lines\\n\\n```cpp\\ndepths[node] = max(l, r) + 1;\\ndiameter = max(diameter, l + r);\\n```\\n\\nare quite similar to what the recursive `depth` function does.",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        int diameter = 0;\\n        depth(root, diameter);\\n        return diameter;\\n    }\\nprivate:\\n    int depth(TreeNode* root, int& diameter) {\\n        if (!root) {\\n            return 0;\\n        }\\n        int l = depth(root -> left, diameter), r = depth(root -> right, diameter);\\n        diameter = max(diameter, l + r);\\n        return max(l, r) + 1;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        if (!root) {\\n            return 0;\\n        }\\n        int diameter = 0;\\n        unordered_map<TreeNode*, int> depths;\\n        stack<TreeNode*> todo;\\n        todo.push(root);\\n        while (!todo.empty()) {\\n            TreeNode* node = todo.top();\\n            if (node -> left && depths.find(node -> left) == depths.end()) {\\n                todo.push(node -> left);\\n            } else if (node -> right && depths.find(node -> right) == depths.end()) {\\n                todo.push(node -> right);\\n            } else {\\n                todo.pop();\\n                int l = depths[node -> left], r = depths[node -> right];\\n                depths[node] = max(l, r) + 1;\\n                diameter = max(diameter, l + r);\\n            }\\n        }\\n        return diameter;\\n    }\\n};\\n```\n```cpp\\ndepths[node] = max(l, r) + 1;\\ndiameter = max(diameter, l + r);\\n```",
                "codeTag": "Java"
            },
            {
                "id": 112275,
                "title": "python-simple-and-logical-idea",
                "content": "The diameter is the maximum of either:\\n1. Passing through the root (in which case the longest path would be using the maximum depth of left and right child)\\n2. The diameter of the left child\\n3. The diameter of the right child\\n\\n```python\\nclass Solution(object):\\n    def diameterOfBinaryTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        return self.diameter_rec(root)[0]\\n    \\n    def diameter_rec(self, root):\\n        if not root:\\n            return 0, -1\\n        \\n        left_diameter, left_height = self.diameter_rec(root.left)\\n        right_diameter, right_height = self.diameter_rec(root.right)\\n        return (max(left_diameter, right_diameter, left_height + right_height + 2), max(left_height, right_height) + 1)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def diameterOfBinaryTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        return self.diameter_rec(root)[0]\\n    \\n    def diameter_rec(self, root):\\n        if not root:\\n            return 0, -1\\n        \\n        left_diameter, left_height = self.diameter_rec(root.left)\\n        right_diameter, right_height = self.diameter_rec(root.right)\\n        return (max(left_diameter, right_diameter, left_height + right_height + 2), max(left_height, right_height) + 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 101115,
                "title": "543-diameter-of-binary-tree-c-recursive-with-brief-explanation",
                "content": "We can solve this problem with two different cases:\\n1. If the longest path will include the root node, then the longest path must be the depth(root->right) + depth (root->left)\\n2. If the longest path does not include the root node, this problem is divided into 2 sub-problem: set left child and right child as the new root separately, and repeat step1.\\n\\nWe could get the solution by returning the max path of 1 and 2.\\n\\nUPDATED: \\n\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint diameterOfBinaryTree(TreeNode* root) {\\n\\t\\t\\tif(root == nullptr) return 0;\\n\\t\\t\\tint res = 0;\\n\\t\\t\\tdfs(root, res);\\n\\t\\t\\treturn res - 1;\\n\\t\\t}\\n\\n\\t\\tvector<int> dfs(TreeNode* root, int& res){\\n\\t\\t\\tif(root == nullptr) return {0, 0};\\n\\t\\t\\tauto l = dfs(root->left, res);\\n\\t\\t\\tauto r = dfs(root->right, res);\\n\\t\\t\\tint path = max(l[0], l[1]) + 1 + max(r[0], r[1]);\\n\\t\\t\\tres = max(res, path);\\n\\t\\t\\treturn {max(l[0], l[1]) + 1, 1 + max(r[0], r[1])};\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint diameterOfBinaryTree(TreeNode* root) {\\n\\t\\t\\tif(root == nullptr) return 0;\\n\\t\\t\\tint res = 0;\\n\\t\\t\\tdfs(root, res);\\n\\t\\t\\treturn res - 1;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 101222,
                "title": "c-solution-dfs",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int maxdiadepth = 0;\\n    \\n    int dfs(TreeNode* root){        \\n        if(root == NULL) return 0;\\n        \\n        int leftdepth = dfs(root->left);\\n        int rightdepth = dfs(root->right);\\n        \\n        if(leftdepth + rightdepth > maxdiadepth) maxdiadepth = leftdepth + rightdepth;\\n        return max(leftdepth +1, rightdepth + 1);     \\n    }\\n    \\n    int diameterOfBinaryTree(TreeNode* root) {        \\n        dfs(root);\\n        \\n        return maxdiadepth;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxdiadepth = 0;\\n    \\n    int dfs(TreeNode* root){        \\n        if(root == NULL) return 0;\\n        \\n        int leftdepth = dfs(root->left);\\n        int rightdepth = dfs(root->right);\\n        \\n        if(leftdepth + rightdepth > maxdiadepth) maxdiadepth = leftdepth + rightdepth;\\n        return max(leftdepth +1, rightdepth + 1);     \\n    }\\n    \\n    int diameterOfBinaryTree(TreeNode* root) {        \\n        dfs(root);\\n        \\n        return maxdiadepth;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 240383,
                "title": "java-solution-from-pratik",
                "content": "**Solution 1: Recursive Approach - DFS**\\n\\n**Explanation:**\\n- The **diameter of a binary tree** is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.\\n- The longest path must be between two leaf nodes.\\n- We search each node and remember the maximum number of nodes used in some path.\\n- Moreover, we know that in a tree, nodes are only connected with their parent node and `2` children. Therefore we know that the longest path in the tree would consist of a node, its longest left branch, and its longest right branch. So, our algorithm to solve this problem will find the node where the sum of its longest left and right branches is maximized.\\n\\n**Algorithm:**\\n1. Initalize an integer variable `diameter` to keep track of the longest path we find from the DFS.\\n1. Implement a recursive method `longestPath()` which takes a `TreeNode` as input. It should recursively explore the entire tree rooted at the given node. Once it is finished, it should return the longest path out of its left and right branches:\\n\\t- If the input `node` is `null`, we have reached the end of the tree, hence we should return `0`\\n\\t- We want to recursively explore the children of a `node`, so we call `longestPath()` method again with the left and right children of the `node`. In return, we get the longest path of its left and right children `leftPath` and `rightPath`\\n\\t- If `leftPath` plus `rightPath` is longer than the current longest diameter found, then we need to update `diameter`\\n\\t- Finally, we return the longer one of `leftPath` and `rightPath`. Remember to add `1` as the edge connecting it with its parent.\\n1. Call this implemented `longestPath()` method with root as a parameter.\\n\\n**Time complexity:** `O(N)` - since every node in the tree is visited\\n**Space complexity:** `O(H)` - space required for the recursive function call stack.\\n\\n```\\nclass Solution {\\n    int diameter = 0;\\n\\n    public int diameterOfBinaryTree(TreeNode root) {\\n        longestPath(root);\\n        return diameter;\\n    }\\n\\n    private int longestPath(TreeNode node) {\\n        if (node == null) {\\n            return 0;\\n        } else {\\n            int leftDepth = longestPath(node.left);\\n            int rightDepth = longestPath(node.right);\\n            diameter = Math.max(diameter, leftDepth + rightDepth);\\n            return 1 + Math.max(leftDepth, rightDepth);\\n        }\\n    }\\n}\\n```\\n\\n**Solution 2: Iterative Approach**\\n\\n- The idea is to use `PostOrder` traversal which to ensure the availability of the `node` until its left and right sub-trees are processed. \\n- For this reason, we use `peek()` method to keep the node on the stack until its left and right sub-trees gets processed. \\n- Then for each `node`, find the `maximum-depth` of the left and right sub-trees. Using this `maximum-depth`, we update `diameter` if required.\\n\\n**Time complexity:** `O(N)` - since every node in the tree is visited\\n**Space complexity:** `O(N)` - space required for the `HashMap` and `Stack`\\n\\n```\\nclass Solution {\\n    public int diameterOfBinaryTree(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n\\n        Map<TreeNode, Integer> map = new HashMap<>();\\n        Deque<TreeNode> stack = new ArrayDeque<>();\\n        stack.push(root);\\n        int diameter = 0;\\n\\n        while (!stack.isEmpty()) {\\n            TreeNode node = stack.peek();\\n\\n            if (node.left != null && !map.containsKey(node.left)) {\\n                stack.push(node.left);\\n            } else if (node.right != null && !map.containsKey(node.right)) {\\n                stack.push(node.right);\\n            } else {\\n                stack.pop();\\n                int leftDepth = map.getOrDefault(node.left, 0);\\n                int rightDepth = map.getOrDefault(node.right, 0);\\n                map.put(node, 1 + Math.max(leftDepth, rightDepth));\\n                diameter = Math.max(diameter, leftDepth + rightDepth);\\n            }\\n        }\\n        return diameter;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int diameter = 0;\\n\\n    public int diameterOfBinaryTree(TreeNode root) {\\n        longestPath(root);\\n        return diameter;\\n    }\\n\\n    private int longestPath(TreeNode node) {\\n        if (node == null) {\\n            return 0;\\n        } else {\\n            int leftDepth = longestPath(node.left);\\n            int rightDepth = longestPath(node.right);\\n            diameter = Math.max(diameter, leftDepth + rightDepth);\\n            return 1 + Math.max(leftDepth, rightDepth);\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int diameterOfBinaryTree(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n\\n        Map<TreeNode, Integer> map = new HashMap<>();\\n        Deque<TreeNode> stack = new ArrayDeque<>();\\n        stack.push(root);\\n        int diameter = 0;\\n\\n        while (!stack.isEmpty()) {\\n            TreeNode node = stack.peek();\\n\\n            if (node.left != null && !map.containsKey(node.left)) {\\n                stack.push(node.left);\\n            } else if (node.right != null && !map.containsKey(node.right)) {\\n                stack.push(node.right);\\n            } else {\\n                stack.pop();\\n                int leftDepth = map.getOrDefault(node.left, 0);\\n                int rightDepth = map.getOrDefault(node.right, 0);\\n                map.put(node, 1 + Math.max(leftDepth, rightDepth));\\n                diameter = Math.max(diameter, leftDepth + rightDepth);\\n            }\\n        }\\n        return diameter;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 133736,
                "title": "iterative-and-recursive-python-solutions",
                "content": "```\\nclass Solution:\\n    def diameterOfBinaryTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        max_length = 0\\n        depth = {None: -1}\\n        stack = [(root, 0)]\\n        while stack:\\n            node, visited = stack.pop()\\n            if node is None:\\n                continue\\n            if visited == 0:\\n                stack.extend([(node, 1), (node.left, 0), (node.right, 0)])\\n            else:\\n                left_d = depth[node.left] + 1\\n                right_d = depth[node.right] + 1\\n                depth[node] = max(left_d, right_d)\\n                max_length = max(max_length, left_d + right_d)\\n        return max_length\\n```\\n\\n```\\nclass Solution:\\n    def diameterOfBinaryTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        max_length = 0\\n        def depthOfTree(root):\\n            nonlocal max_length\\n            if root is None:\\n                return 0\\n            depth_left = depthOfTree(root.left)\\n            depth_right = depthOfTree(root.right)\\n            max_length = max(max_length, depth_left + depth_right + 1)\\n            return max(depth_left, depth_right) + 1\\n        \\n        depthOfTree(root)\\n        if max_length > 0:\\n            max_length -= 1\\n        return max_length\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def diameterOfBinaryTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        max_length = 0\\n        depth = {None: -1}\\n        stack = [(root, 0)]\\n        while stack:\\n            node, visited = stack.pop()\\n            if node is None:\\n                continue\\n            if visited == 0:\\n                stack.extend([(node, 1), (node.left, 0), (node.right, 0)])\\n            else:\\n                left_d = depth[node.left] + 1\\n                right_d = depth[node.right] + 1\\n                depth[node] = max(left_d, right_d)\\n                max_length = max(max_length, left_d + right_d)\\n        return max_length\\n```\n```\\nclass Solution:\\n    def diameterOfBinaryTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        max_length = 0\\n        def depthOfTree(root):\\n            nonlocal max_length\\n            if root is None:\\n                return 0\\n            depth_left = depthOfTree(root.left)\\n            depth_right = depthOfTree(root.right)\\n            max_length = max(max_length, depth_left + depth_right + 1)\\n            return max(depth_left, depth_right) + 1\\n        \\n        depthOfTree(root)\\n        if max_length > 0:\\n            max_length -= 1\\n        return max_length\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678310,
                "title": "python-recursion-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        self.max_diameter = 0\\n        self.getDiameter(root)\\n        return self.max_diameter\\n    \\n    def getDiameter(self, root):\\n        if not root:\\n            return 0\\n        \\n        left_depth = self.getDiameter(root.left)\\n        right_depth = self.getDiameter(root.right)\\n        # get the diameter between two nodes\\n        diameter = left_depth + right_depth\\n        \\n        # get the maximum diameter\\n        self.max_diameter = max(self.max_diameter, diameter)\\n        return max(left_depth, right_depth) + 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        self.max_diameter = 0\\n        self.getDiameter(root)\\n        return self.max_diameter\\n    \\n    def getDiameter(self, root):\\n        if not root:\\n            return 0\\n        \\n        left_depth = self.getDiameter(root.left)\\n        right_depth = self.getDiameter(root.right)\\n        # get the diameter between two nodes\\n        diameter = left_depth + right_depth\\n        \\n        # get the maximum diameter\\n        self.max_diameter = max(self.max_diameter, diameter)\\n        return max(left_depth, right_depth) + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 573103,
                "title": "easy-javascript-solution-with-comments",
                "content": "```\\nfunction diameterOfBinaryTree(root) {\\n    let max = 0\\n     \\n     function maxDepth(root) {\\n         if (root === null) return 0 // if our root(num) is null then there is no path. return 0/null\\n         let left = maxDepth(root.left) // Assign the left  of tree to LEFT; this will be easier to call it instead of writing \"maxDepth(root.left)\" each time\\n         let right = maxDepth(root.right) //Same above\\n     \\n         \\n         max = Math.max(max, left + right) //if the path doesn\\'t go through the root we just get the max of them\\n         return Math.max(left, right) + 1 // the path goes through the root so we add 1(for the root)\\n     }\\n     //since we don\\'t know if the path will go through the root or not we will have to get the max between(path that visits the root, or the path that doesn\\'t go through the root.)\\n     maxDepth(root)\\n     return max\\n };\\n ```\\n\\nRuntime: 64 ms,\\nFaster than: 67.89% \\nMemory Usage: 37.5 MB\\nless than 12.50%",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\nfunction diameterOfBinaryTree(root) {\\n    let max = 0\\n     \\n     function maxDepth(root) {\\n         if (root === null) return 0 // if our root(num) is null then there is no path. return 0/null\\n         let left = maxDepth(root.left) // Assign the left  of tree to LEFT; this will be easier to call it instead of writing \"maxDepth(root.left)\" each time\\n         let right = maxDepth(root.right) //Same above\\n     \\n         \\n         max = Math.max(max, left + right) //if the path doesn\\'t go through the root we just get the max of them\\n         return Math.max(left, right) + 1 // the path goes through the root so we add 1(for the root)\\n     }\\n     //since we don\\'t know if the path will go through the root or not we will have to get the max between(path that visits the root, or the path that doesn\\'t go through the root.)\\n     maxDepth(root)\\n     return max\\n };\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 188175,
                "title": "python-clear-solution",
                "content": "```\\nclass Solution(object):\\n    def diameterOfBinaryTree(self, root):\\n        self.d = 0\\n        def dfs(node):\\n            if not node: return 0\\n            l, r = dfs(node.left), dfs(node.right)\\n            self.d = max(l + r, self.d)\\n            return 1 + max(l, r)\\n        dfs(root)\\n        return self.d\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def diameterOfBinaryTree(self, root):\\n        self.d = 0\\n        def dfs(node):\\n            if not node: return 0\\n            l, r = dfs(node.left), dfs(node.right)\\n            self.d = max(l + r, self.d)\\n            return 1 + max(l, r)\\n        dfs(root)\\n        return self.d\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1515775,
                "title": "python-short-dfs-explained",
                "content": "Use auxiliary dfs function, which for each node return the longest left and the longest right paths. Also update the global `self.diam`, where we evaluate left + right.\\n\\n#### Complexity\\nTime complexity is `O(n)`, space complexity is `O(h)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def diameterOfBinaryTree(self, root):\\n        self.diam = 0\\n        def dfs(root):\\n            if not root: return (0, 0)\\n            left = max(dfs(root.left))\\n            right = max(dfs(root.right))\\n            self.diam = max(self.diam, left + right)\\n            return (left + 1, right + 1)\\n        \\n        dfs(root)\\n        return self.diam\\n```\\n\\nIf you have any questoins, feel free to ask. If you like the solution and explanation, please **upvote!**",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def diameterOfBinaryTree(self, root):\\n        self.diam = 0\\n        def dfs(root):\\n            if not root: return (0, 0)\\n            left = max(dfs(root.left))\\n            right = max(dfs(root.right))\\n            self.diam = max(self.diam, left + right)\\n            return (left + 1, right + 1)\\n        \\n        dfs(root)\\n        return self.diam\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1283084,
                "title": "simple-to-under-stand-and-implement-with-explanatation",
                "content": "\\n## Solution approach\\n\\nThere are three cases \\n***case 1*** :- The Diameter may completely lie on the left sub tree\\n***case 2*** :- The Diameter may completely lie on the right sub tree\\n***case 3*** :- The Diameter may pass through the root of the tree.\\nso we have to see for all the probable cases here.\\nApproach: we are going to use recursion\\nh1 = calculate the height of the left sub tree.\\nh2 = calculate the height of the right sub tree.\\nop1 = h1+h2(as discussed the diameter may paas through the root.)\\nop2 = diameter(root->left)// recursively.\\nop3 = diameter(root->right) //recursively.\\n\\nreturn max of op1,op2,op3;\\n\"\"\"\\n\\n## ***Code***\\n```\\nclass TreeNode:\\n    def __init__(self, val=0, left=None, right=None):\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n\\n\\nclass Solution:\\n    def diameterOfBinaryTree(self, root: TreeNode) -> int:\\n\\n        def height(root: TreeNode):\\n            if root == None:\\n                return 0\\n            left = height(root.left)\\n            right = height(root.right)\\n            return 1 + max(left, right)\\n\\n        def FindBinary(root: TreeNode):\\n            if root == None:\\n                return 0\\n            h1 = height(root.left)\\n            h2 = height(root.right)\\n            op1 = h1+h2\\n            op2 = FindBinary(root.left)\\n            op3 = FindBinary(root.right)\\n            return max(op1, op2, op3)\\n\\n        return FindBinary(root)\\n```\\n\\nIf in case you liked the post please give it a up vote so that it could also be visible to other\\n***Happy Coding***",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass TreeNode:\\n    def __init__(self, val=0, left=None, right=None):\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n\\n\\nclass Solution:\\n    def diameterOfBinaryTree(self, root: TreeNode) -> int:\\n\\n        def height(root: TreeNode):\\n            if root == None:\\n                return 0\\n            left = height(root.left)\\n            right = height(root.right)\\n            return 1 + max(left, right)\\n\\n        def FindBinary(root: TreeNode):\\n            if root == None:\\n                return 0\\n            h1 = height(root.left)\\n            h2 = height(root.right)\\n            op1 = h1+h2\\n            op2 = FindBinary(root.left)\\n            op3 = FindBinary(root.right)\\n            return max(op1, op2, op3)\\n\\n        return FindBinary(root)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 574598,
                "title": "python-simple-recursive-solution-36-ms-faster-than-96-53",
                "content": "```\\nclass Solution:\\n    def path_length(self, root: TreeNode):\\n        if root:\\n            left_path = self.path_length(root.left)\\n            right_path = self.path_length(root.right)\\n            path = left_path + right_path\\n            if path > self.diameter:\\n                self.diameter = path    \\n            return max(left_path, right_path)+1\\n        return 0\\n        \\n    def diameterOfBinaryTree(self, root: TreeNode) -> int:\\n        self.diameter = 0\\n        self.path_length(root)\\n        return self.diameter\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def path_length(self, root: TreeNode):\\n        if root:\\n            left_path = self.path_length(root.left)\\n            right_path = self.path_length(root.right)\\n            path = left_path + right_path\\n            if path > self.diameter:\\n                self.diameter = path    \\n            return max(left_path, right_path)+1\\n        return 0\\n        \\n    def diameterOfBinaryTree(self, root: TreeNode) -> int:\\n        self.diameter = 0\\n        self.path_length(root)\\n        return self.diameter\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1291511,
                "title": "c-explained-longest-path-o-n",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\n// Algo: Find the node where the sum of its longest left and right branches is maximized.\\n//           10\\n//          / \\\\\\n//         3   1\\n//        / \\\\ \\n//       5   4\\n//      /   /\\n//     2   9\\n//    /   /\\n//   8   7\\n  \\n// Take the tree for example, \\n// diameter = 0, root= 10\\n// longestPath(8)=max(0,0)+1 = 1, diameter = 0\\n// longestPath(7)=max(0,0)+1 = 1, diameter = 0\\n// longestPath(2)=max(1,0)+1 = 2, diameter = max(2,3+3)=1\\n// longestPath(9)=max(1,0)+1 = 2, diameter = max(1,1+0)=1\\n// longestPath(5)=max(2,0)+1 = 3, diameter = max(1,2+0)=2\\n// longestPath(4)=max(2,0)+1 = 3, diameter = max(2,2+0)=2\\n// longestPath(3)=max(3,3)+1 = 4, diameter = max(2,3+3)=6\\n// longestPath(1)=max(0,0)+1 = 1, diameter = max(6,0+0)=6\\n// longestPath(1)=max(4,1)+1 = 5, diameter = max(6,4+1)=6\\n\\n// Notes:\\n//  1. Diamter is maximum of leftPath+rightPath for ALL the NODES (not just root)\\n//  2. The leftPath and rightPath are calculated by the max path of their child+1\\n// 3. Basically we are iterating over the whole tree calculating the longestPath, diameter is just calculated amidst all that.\\n\\nclass Solution {\\nprivate:\\n    int diameter;\\npublic:\\n    \\n    // longestPath takes a TreeNode as input and returns the longest path from it to the leaf node.\\n    // It will recursively visit children nodes and retrieve the longest paths from them to the leaf first, and then add 1 to the longer one before returning it as the longest path.\\n    // The return type of this fn has nothing to do with the diameter.\\n    // diameter is calculated in between as the leftPath+rightPath for every node.\\n    int longestPath(TreeNode* node){\\n        if(node == NULL)\\n            return 0;\\n        \\n        // recursively find the longest path in both left child and right child\\n        int leftPath = longestPath(node->left);\\n        int rightPath = longestPath(node->right);\\n        \\n        // update the diameter if left_path plus right_path is larger\\n        diameter = max(diameter, leftPath+rightPath);\\n        \\n        // return the longest one between left_path and right_path; \\n        // remember to add 1 for the path connecting the node and its parent\\n        return max(leftPath,rightPath)+1;\\n        \\n    }\\n    \\n    int diameterOfBinaryTree(TreeNode* root) {\\n        diameter = 0;\\n        longestPath(root);\\n        return diameter;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\n// Algo: Find the node where the sum of its longest left and right branches is maximized.\\n//           10\\n//          / \\\\\\n//         3   1\\n//        / \\\\ \\n//       5   4\\n//      /   /\\n//     2   9\\n//    /   /\\n//   8   7\\n  \\n// Take the tree for example, \\n// diameter = 0, root= 10\\n// longestPath(8)=max(0,0)+1 = 1, diameter = 0\\n// longestPath(7)=max(0,0)+1 = 1, diameter = 0\\n// longestPath(2)=max(1,0)+1 = 2, diameter = max(2,3+3)=1\\n// longestPath(9)=max(1,0)+1 = 2, diameter = max(1,1+0)=1\\n// longestPath(5)=max(2,0)+1 = 3, diameter = max(1,2+0)=2\\n// longestPath(4)=max(2,0)+1 = 3, diameter = max(2,2+0)=2\\n// longestPath(3)=max(3,3)+1 = 4, diameter = max(2,3+3)=6\\n// longestPath(1)=max(0,0)+1 = 1, diameter = max(6,0+0)=6\\n// longestPath(1)=max(4,1)+1 = 5, diameter = max(6,4+1)=6\\n\\n// Notes:\\n//  1. Diamter is maximum of leftPath+rightPath for ALL the NODES (not just root)\\n//  2. The leftPath and rightPath are calculated by the max path of their child+1\\n// 3. Basically we are iterating over the whole tree calculating the longestPath, diameter is just calculated amidst all that.\\n\\nclass Solution {\\nprivate:\\n    int diameter;\\npublic:\\n    \\n    // longestPath takes a TreeNode as input and returns the longest path from it to the leaf node.\\n    // It will recursively visit children nodes and retrieve the longest paths from them to the leaf first, and then add 1 to the longer one before returning it as the longest path.\\n    // The return type of this fn has nothing to do with the diameter.\\n    // diameter is calculated in between as the leftPath+rightPath for every node.\\n    int longestPath(TreeNode* node){\\n        if(node == NULL)\\n            return 0;\\n        \\n        // recursively find the longest path in both left child and right child\\n        int leftPath = longestPath(node->left);\\n        int rightPath = longestPath(node->right);\\n        \\n        // update the diameter if left_path plus right_path is larger\\n        diameter = max(diameter, leftPath+rightPath);\\n        \\n        // return the longest one between left_path and right_path; \\n        // remember to add 1 for the path connecting the node and its parent\\n        return max(leftPath,rightPath)+1;\\n        \\n    }\\n    \\n    int diameterOfBinaryTree(TreeNode* root) {\\n        diameter = 0;\\n        longestPath(root);\\n        return diameter;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2344583,
                "title": "simple-solution-using-recursive-traversal-of-tree-c-o-n-with-comments-and-explanation",
                "content": "The idea is nothing different from finding height of a tree. Infact there is only one line code change in function of \"Finding height of a tree\".\\n\\n1. We will just write Finding height of tree code.\\n2. We will make a global variable named \"maxDia\" that will keep track of maximum diameter of tree till now.\\n3. We will keep updating this maxDIa variable while finding height itself.\\n\\nLook in code comments for better understanding.\\n\\n```\\nclass Solution {\\npublic:\\n\\t\\n\\t// GLobal variable to keep track of maximum diameter calculated.\\n    int maxDia = 0;\\n\\t\\n\\t\\n    int diameterOfBinaryTree(TreeNode* root)\\n    {\\n\\t\\t// Calling our new modified height of tree function.\\n\\t\\t// This function will return height of tree but we are not using it\\'s returned value as we are not intrested in getting height of tree.\\n        heightModified(root);\\n\\t\\t\\n\\t\\t// Above function will have updated maxDia variable. \\n\\t\\t//We always get one greater ans so we have subtracted 1.\\n\\t\\t// (No need to worry much about subtraction, we don\\'t need to subtract 1 if we modify our function little bit. But that\\'s not an issue).\\n        return maxDia-1;\\n    }\\n    \\n\\t\\n\\t// This modified height function will return height of tree like normal height function but will also keep update of maxDia value.\\n    int heightModified(TreeNode* root)\\n    {\\n\\t\\t// If root is null, Height is zero.\\n        if(root==NULL)\\n            return 0;\\n        \\n\\t\\t// Get left subtree height & store it in a variable.\\n        int leftHt = heightModified(root->left);\\n\\t\\t\\n\\t\\t// Get right subtree height & store it in a variable.\\n        int rightHt = heightModified(root->right);\\n        \\n\\t\\t// This is the only extra line added in function of finding height of a tree. \\n\\t\\t// Diameter of tree is left tree height + right tree height + 1 for counting current node in it.\\n        maxDia = max(maxDia, leftHt + rightHt + 1);\\n        \\n\\t\\t\\n\\t\\t// Return max of left & subtree height + 1 to return current node\\'s height.\\n        return max(leftHt, rightHt) + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t\\n\\t// GLobal variable to keep track of maximum diameter calculated.\\n    int maxDia = 0;\\n\\t\\n\\t\\n    int diameterOfBinaryTree(TreeNode* root)\\n    {\\n\\t\\t// Calling our new modified height of tree function.\\n\\t\\t// This function will return height of tree but we are not using it\\'s returned value as we are not intrested in getting height of tree.\\n        heightModified(root);\\n\\t\\t\\n\\t\\t// Above function will have updated maxDia variable. \\n\\t\\t//We always get one greater ans so we have subtracted 1.\\n\\t\\t// (No need to worry much about subtraction, we don\\'t need to subtract 1 if we modify our function little bit. But that\\'s not an issue).\\n        return maxDia-1;\\n    }\\n    \\n\\t\\n\\t// This modified height function will return height of tree like normal height function but will also keep update of maxDia value.\\n    int heightModified(TreeNode* root)\\n    {\\n\\t\\t// If root is null, Height is zero.\\n        if(root==NULL)\\n            return 0;\\n        \\n\\t\\t// Get left subtree height & store it in a variable.\\n        int leftHt = heightModified(root->left);\\n\\t\\t\\n\\t\\t// Get right subtree height & store it in a variable.\\n        int rightHt = heightModified(root->right);\\n        \\n\\t\\t// This is the only extra line added in function of finding height of a tree. \\n\\t\\t// Diameter of tree is left tree height + right tree height + 1 for counting current node in it.\\n        maxDia = max(maxDia, leftHt + rightHt + 1);\\n        \\n\\t\\t\\n\\t\\t// Return max of left & subtree height + 1 to return current node\\'s height.\\n        return max(leftHt, rightHt) + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 574083,
                "title": "python3-post-order-dfs",
                "content": "Algorithm:\\nRecursively traverse the tree and keep track of max diameter of each node.\\n\\nImplementation:\\n```\\nclass Solution:\\n    def diameterOfBinaryTree(self, root: TreeNode) -> int:\\n        \\n        def fn(node):\\n            \"\"\"Return length+1 and diameter rooted at node\"\"\"\\n            if not node: return (0, 0)\\n            l1, d1 = fn(node.left)\\n            l2, d2 = fn(node.right)\\n            return 1 + max(l1, l2), max(d1, d2, l1+l2)\\n        \\n        return fn(root)[1]\\n```\\n\\nAnalysis:\\nTime complexity `O(N)`\\nSpace complexity `O(1)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def diameterOfBinaryTree(self, root: TreeNode) -> int:\\n        \\n        def fn(node):\\n            \"\"\"Return length+1 and diameter rooted at node\"\"\"\\n            if not node: return (0, 0)\\n            l1, d1 = fn(node.left)\\n            l2, d2 = fn(node.right)\\n            return 1 + max(l1, l2), max(d1, d2, l1+l2)\\n        \\n        return fn(root)[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 503380,
                "title": "python-solution-with-explanation-for-counting-edges",
                "content": "In this problem, we\\'re trying to ascertain the maximum number of edges between any two nodes, regardless of whether it includes the root node. \\n\\nThe first step here is to think how can this be broken down recursively. The subproblem of a single node tree gives us a diameter of 0, since there are no edges in this tree. the subproblem of a node with root and one left child gives us a diameter of 1, since there is one edge between the two nodes. \\n\\nThe second thing to think about is that for any node we\\'re currently at, the max diameter upto that tree is the sum of edges on the left side and the right side (for example the number of edges of a tree with 2 children, a right and a left, is 2). We need to keep track of this value as we traverse the tree, by comparing it first with an instantiated 0 and subsequently with every diameter at every node `maxDiameter = max(currentDiameter, maxDiameter)`. \\n\\nThe third point, which took me a while to get, is that when we\\'re done processing a node, we only return either the left or the right no of edges, because if you are to look at including the parent node, we can only take one of the children. For our case, the choice between the children is the child with the max no of edges `return max(left, right) + 1` \\n\\n\\n```\\ndef diameterOfBinaryTree(self, root: TreeNode) -> int: \\n        def depth(root):\\n            \\n            nonlocal maxDiameter\\n            if not root: \\n                return 0\\n            left = depth(root.left)\\n            right = depth(root.right)\\n            \\n            #get the no of edges in both children\\n            currentDiameter = left + right\\n            \\n            #track max diameter\\n            maxDiameter = max(maxDiameter, currentDiameter)\\n            \\n            #we can only return one of the children\\n            #we add a one to represent the edge \\n            #between node and parent above\\n            return max(left, right) + 1\\n        \\n        maxDiameter = 0\\n        depth(root)\\n        return maxDiameter\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\ndef diameterOfBinaryTree(self, root: TreeNode) -> int: \\n        def depth(root):\\n            \\n            nonlocal maxDiameter\\n            if not root: \\n                return 0\\n            left = depth(root.left)\\n            right = depth(root.right)\\n            \\n            #get the no of edges in both children\\n            currentDiameter = left + right\\n            \\n            #track max diameter\\n            maxDiameter = max(maxDiameter, currentDiameter)\\n            \\n            #we can only return one of the children\\n            #we add a one to represent the edge \\n            #between node and parent above\\n            return max(left, right) + 1\\n        \\n        maxDiameter = 0\\n        depth(root)\\n        return maxDiameter\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 329022,
                "title": "python-bottom-up-dfs-solution",
                "content": "Please see and vote for my solutions for these similar problems.\\n[250. Count Univalue Subtrees](https://leetcode.com/problems/count-univalue-subtrees/discuss/329039/Python-bottom-up-DFS-solution)\\n[508. Most Frequent Subtree Sum](https://leetcode.com/problems/most-frequent-subtree-sum/discuss/329045/Python-bottom-up-DFS)\\n[543. Diameter of Binary Tree](https://leetcode.com/problems/diameter-of-binary-tree/discuss/329022/Python-DFS-solution%3A-return-values-and-update-global-result-from-bottom-to-top)\\n[1245. Tree Diameter](https://leetcode.com/problems/tree-diameter/discuss/418906/Python-bottom-up-DFS-solution-(similar-problems-listed))\\n[687. Longest Univalue Path](https://leetcode.com/problems/longest-univalue-path/discuss/329031/Python-bottom-up-DFS-solution)\\n[124. Binary Tree Maximum Path Sum](https://leetcode.com/problems/binary-tree-maximum-path-sum/discuss/329033/Python-bottom-up-DFS-solution)\\n[Max Path Sum in a Grid](https://leetcode.com/discuss/interview-question/391278/google-phone-screen-maximal-path-sum/351744)\\n[298. Binary Tree Longest Consecutive Sequence](https://leetcode.com/problems/binary-tree-longest-consecutive-sequence/discuss/389208/Python-bottom-up-DFS-solution)\\n[549. Binary Tree Longest Consecutive Sequence II](https://leetcode.com/problems/binary-tree-longest-consecutive-sequence-ii/discuss/389210/Python-bottom-up-DFS-solution-(56-ms-beat-93.37))\\n\\nA path may or may not pass through the root.\\nAll paths = {all paths passing through a node and its desendants | for each node in tree}.\\nBottom-up DFS: from bottom to top,\\nfind the longest path passing through a node and its descendants,\\nand updade the global longest path.\\n```\\n    def diameterOfBinaryTree(self, root: TreeNode) -> int:\\n        def depth(root):\\n            if not root:\\n                return 0\\n            l_depth = depth(root.left)\\n            r_depth = depth(root.right)\\n            res[0] = max(res[0], l_depth + r_depth)\\n            return 1 + max(l_depth, r_depth)\\n        \\n        res = [0]\\n        depth(root)\\n        return res[0]\\n```",
                "solutionTags": [],
                "code": "```\\n    def diameterOfBinaryTree(self, root: TreeNode) -> int:\\n        def depth(root):\\n            if not root:\\n                return 0\\n            l_depth = depth(root.left)\\n            r_depth = depth(root.right)\\n            res[0] = max(res[0], l_depth + r_depth)\\n            return 1 + max(l_depth, r_depth)\\n        \\n        res = [0]\\n        depth(root)\\n        return res[0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1515516,
                "title": "c-python-java-easy-solution-using-height-of-tree",
                "content": "**IDEA** \\n*Max value* of `Height(leftSubtree) + Height(rightSubtree)`(at any node) is the `diameter`. \\nWe find the maximum diameter during traversal and find the height of the tree.\\n\\n**[GITHUB REPO LINK](https://github.com/bhaumikmaan/Competitve-Programming-Solutions/tree/main/LeetCode)**\\n\\n**SOLUTIONS**\\n`IN C++`\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        int d = 0;\\n        height(root, d) ;\\n        return d;\\n    }\\n    \\n    int height(TreeNode* root, int &d){\\n        if(root == NULL) \\n            return 0;\\n        \\n        int lh = height(root->left, d) ;\\n        int rh = height(root->right, d) ;\\n        d = max(d, lh + rh) ;\\n        \\n        return max(lh , rh) + 1;\\n    }\\n};\\n```\\n\\n`IN PYTHON`\\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def diameterOfBinaryTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        self.dia = 0\\n        \\n        def height(root):\\n            if not root: \\n                return 0\\n            left, right = height(root.left), height(root.right)\\n            self.dia = max(self.dia, left + right)\\n            return 1 + max(left, right)\\n            \\n        height(root)\\n        return self.dia\\n```\\n\\n`IN JAVA`\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int dia = 0 ;\\n    public int diameterOfBinaryTree(TreeNode root) {\\n        maxheight(root) ;\\n        return dia ;\\n    }\\n    private int maxheight(TreeNode root) {\\n        if (root == null) \\n            return 0;\\n    \\n        int left = maxheight(root.left);\\n        int right = maxheight(root.right);    \\n        dia = Math.max(dia , left + right) ;\\n        \\n        return Math.max(left, right) + 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        int d = 0;\\n        height(root, d) ;\\n        return d;\\n    }\\n    \\n    int height(TreeNode* root, int &d){\\n        if(root == NULL) \\n            return 0;\\n        \\n        int lh = height(root->left, d) ;\\n        int rh = height(root->right, d) ;\\n        d = max(d, lh + rh) ;\\n        \\n        return max(lh , rh) + 1;\\n    }\\n};\\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def diameterOfBinaryTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        self.dia = 0\\n        \\n        def height(root):\\n            if not root: \\n                return 0\\n            left, right = height(root.left), height(root.right)\\n            self.dia = max(self.dia, left + right)\\n            return 1 + max(left, right)\\n            \\n        height(root)\\n        return self.dia\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int dia = 0 ;\\n    public int diameterOfBinaryTree(TreeNode root) {\\n        maxheight(root) ;\\n        return dia ;\\n    }\\n    private int maxheight(TreeNode root) {\\n        if (root == null) \\n            return 0;\\n    \\n        int left = maxheight(root.left);\\n        int right = maxheight(root.right);    \\n        dia = Math.max(dia , left + right) ;\\n        \\n        return Math.max(left, right) + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1351854,
                "title": "python-iterative-solution-40-ms-faster-than-90-06-15-2-mb-less-than-99-95",
                "content": "```\\nclass Solution:\\n    def diameterOfBinaryTree(self, root: TreeNode) -> int:\\n        ans = 0\\n        hm = {}\\n        stack = [(root, False)]\\n        \\n        while stack:\\n            node, visited = stack.pop()\\n            if node:\\n                if visited:\\n                    lh = 0 if node.left is None else hm.pop(node.left)\\n                    rh = 0 if node.right is None else hm.pop(node.right)\\n                    ans = max(ans, lh + rh)\\n                    hm[node] = max(lh, rh) + 1\\n                else:\\n                    stack.append((node, True))\\n                    stack.append((node.left, False))\\n                    stack.append((node.right, False))\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def diameterOfBinaryTree(self, root: TreeNode) -> int:\\n        ans = 0\\n        hm = {}\\n        stack = [(root, False)]\\n        \\n        while stack:\\n            node, visited = stack.pop()\\n            if node:\\n                if visited:\\n                    lh = 0 if node.left is None else hm.pop(node.left)\\n                    rh = 0 if node.right is None else hm.pop(node.right)\\n                    ans = max(ans, lh + rh)\\n                    hm[node] = max(lh, rh) + 1\\n                else:\\n                    stack.append((node, True))\\n                    stack.append((node.left, False))\\n                    stack.append((node.right, False))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 521977,
                "title": "c-postorder-dfs-solution-faster-than-93-48-commented-and-simple",
                "content": "I tried for a while to make an iterative solution, but keeping the depth of each subtree makes that significantly harder.\\n\\nComments should make code easy to read. Drop a like or comment so that more people can see this solution!\\n\\n```cpp\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        // Check if tree exists\\n        if (root == NULL) return 0;\\n        \\n        // Find depths of left and right subtrees\\n        int leftDepth = DFS(root->left);\\n        int rightDepth = DFS(root->right);\\n        \\n        // Return largest diameter (maybe not through root)\\n        return max(diam, leftDepth + rightDepth);\\n    }\\n    \\n// Good practice to make internal methods and class variables private\\nprivate:\\n    \\n    // Class variable to save max diameter found\\n    int diam = 0;\\n    \\n    // Recursive DFS method\\n    int DFS(TreeNode* root) {\\n        // Check for leaf node\\n        if (root == NULL) return 0;\\n        \\n        // Find depths of left and right subtrees\\n        int leftDepth = DFS(root->left);\\n        int rightDepth = DFS(root->right);\\n        \\n        // Diameter is the number of edges between the farthest nodes\\n        diam = max(diam, leftDepth + rightDepth);\\n        \\n        // Return the depth of the current subtree\\n        return max(leftDepth, rightDepth) + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```cpp\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        // Check if tree exists\\n        if (root == NULL) return 0;\\n        \\n        // Find depths of left and right subtrees\\n        int leftDepth = DFS(root->left);\\n        int rightDepth = DFS(root->right);\\n        \\n        // Return largest diameter (maybe not through root)\\n        return max(diam, leftDepth + rightDepth);\\n    }\\n    \\n// Good practice to make internal methods and class variables private\\nprivate:\\n    \\n    // Class variable to save max diameter found\\n    int diam = 0;\\n    \\n    // Recursive DFS method\\n    int DFS(TreeNode* root) {\\n        // Check for leaf node\\n        if (root == NULL) return 0;\\n        \\n        // Find depths of left and right subtrees\\n        int leftDepth = DFS(root->left);\\n        int rightDepth = DFS(root->right);\\n        \\n        // Diameter is the number of edges between the farthest nodes\\n        diam = max(diam, leftDepth + rightDepth);\\n        \\n        // Return the depth of the current subtree\\n        return max(leftDepth, rightDepth) + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2250501,
                "title": "java-solution-2-approaches",
                "content": "**Approach 1 : Naive Method ( Time Complexity : O(n^2) )**\\n```\\nclass Solution {\\n\\n    public int getHeight(TreeNode root) {\\n        if (root == null) return 0;\\n        return 1 + Math.max(getHeight(root.left),getHeight(root.right));\\n    }\\n\\n    public int diameterOfBinaryTree(TreeNode root) {\\n        if (root == null) return 0;\\n        int d1 = getHeight(root.left) + getHeight(root.right);\\n        int d2 = diameterOfBinaryTree(root.left);\\n        int d3 = diameterOfBinaryTree(root.right);\\n        return Math.max(d1, Math.max(d2, d3));\\n    }\\n}\\n```\\n\\n**Approach 2 : O(n) solution**\\n\\n```\\nclass Solution {\\n    int res = 0;\\n\\n    public int height(TreeNode root) {\\n        if (root == null) return 0;\\n        int lh = height(root.left);\\n        int rh = height(root.right);\\n        res = Math.max(res, lh + rh);\\n        return 1 + Math.max(lh, rh);\\n    }\\n\\n    public int diameterOfBinaryTree(TreeNode root) {\\n        height(root);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int getHeight(TreeNode root) {\\n        if (root == null) return 0;\\n        return 1 + Math.max(getHeight(root.left),getHeight(root.right));\\n    }\\n\\n    public int diameterOfBinaryTree(TreeNode root) {\\n        if (root == null) return 0;\\n        int d1 = getHeight(root.left) + getHeight(root.right);\\n        int d2 = diameterOfBinaryTree(root.left);\\n        int d3 = diameterOfBinaryTree(root.right);\\n        return Math.max(d1, Math.max(d2, d3));\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int res = 0;\\n\\n    public int height(TreeNode root) {\\n        if (root == null) return 0;\\n        int lh = height(root.left);\\n        int rh = height(root.right);\\n        res = Math.max(res, lh + rh);\\n        return 1 + Math.max(lh, rh);\\n    }\\n\\n    public int diameterOfBinaryTree(TreeNode root) {\\n        height(root);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1654276,
                "title": "two-solutions-approachs",
                "content": "**One Solution**\\n*here simple traversal, we are finding each node height throught calling height function as utility function*\\n\\n```\\nclass Solution {\\npublic:\\n    int height(TreeNode*root){\\n        if(!root) return 0;\\n        return 1+max(height(root->left),height(root->right));   \\n    }\\n//     preorder traversal\\n    void solve(TreeNode*root,int &ans){\\n          if(!root) return;\\n        int left = height(root->left);\\n        int right = height(root->right);\\n       ans = max(ans,(left+right));  //as question mention about edges\\n        solve(root->left,ans);\\n        solve(root->right,ans);\\n    }\\n    int diameterOfBinaryTree(TreeNode* root) {\\n      int ans = 0;\\n        solve(root,ans);\\n        return ans;\\n    }\\n};\\n```\\n\\n**TC : O(N^2)**\\n\\n**Let Optimize Above Solution**\\n*from above code it is be clear that we are calling the height function which is redundant as we can do in one single function*\\n\\n*Code:*\\n```\\n    int solve(TreeNode*root,int &ans){\\n        if(!root) return 0;\\n        int left = solve(root->left,ans);\\n        int right = solve(root->right,ans);\\n        int temp = 1+max(left,right);\\n        ans = max({ans,temp,1+left+right});\\n        return temp;\\n    }\\n    \\n    int diameterOfBinaryTree(TreeNode* root) {\\n        int ans = INT_MIN;\\n        solve(root,ans);\\n        return ans-1;  //here they have ask for edges\\n    }\\n```\\n\\n**TC : O(N)**\\n*If you liked this post then please upvote it keeps me motivating*\\uD83C\\uDF88\\uD83D\\uDE01\\n**:)Happy Coding**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int height(TreeNode*root){\\n        if(!root) return 0;\\n        return 1+max(height(root->left),height(root->right));   \\n    }\\n//     preorder traversal\\n    void solve(TreeNode*root,int &ans){\\n          if(!root) return;\\n        int left = height(root->left);\\n        int right = height(root->right);\\n       ans = max(ans,(left+right));  //as question mention about edges\\n        solve(root->left,ans);\\n        solve(root->right,ans);\\n    }\\n    int diameterOfBinaryTree(TreeNode* root) {\\n      int ans = 0;\\n        solve(root,ans);\\n        return ans;\\n    }\\n};\\n```\n```\\n    int solve(TreeNode*root,int &ans){\\n        if(!root) return 0;\\n        int left = solve(root->left,ans);\\n        int right = solve(root->right,ans);\\n        int temp = 1+max(left,right);\\n        ans = max({ans,temp,1+left+right});\\n        return temp;\\n    }\\n    \\n    int diameterOfBinaryTree(TreeNode* root) {\\n        int ans = INT_MIN;\\n        solve(root,ans);\\n        return ans-1;  //here they have ask for edges\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1318264,
                "title": "java-0ms-with-explanation-o-n",
                "content": "```\\nclass Solution \\n{\\n    int max;\\n    public int getDiameter(TreeNode root)\\n    {\\n        int h= 0;\\n        \\n        if(root == null)//base case \\n           return 0;\\n        \\n        int l= getDiameter(root.left);//recursing down and calculating the Height \\n        int r= getDiameter(root.right);\\n        \\n        h= Math.max(l,r);//maximum height \\n        \\n        max= Math.max(max,l+r+1);//updating the maximum diameter \\n        \\n        h=h+1;//increasing heigh covering every node \\n        return h; //returning the maximum height \\n    }\\n    public int diameterOfBinaryTree(TreeNode root) \\n    {\\n        max= Integer.MIN_VALUE;//identity \\n        getDiameter(root);\\n        return max-1; //node=edge+1, i.e; edge=node-1\\n    }\\n}//Please do Upvote, It helps a lot\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution \\n{\\n    int max;\\n    public int getDiameter(TreeNode root)\\n    {\\n        int h= 0;\\n        \\n        if(root == null)//base case \\n           return 0;\\n        \\n        int l= getDiameter(root.left);//recursing down and calculating the Height \\n        int r= getDiameter(root.right);\\n        \\n        h= Math.max(l,r);//maximum height \\n        \\n        max= Math.max(max,l+r+1);//updating the maximum diameter \\n        \\n        h=h+1;//increasing heigh covering every node \\n        return h; //returning the maximum height \\n    }\\n    public int diameterOfBinaryTree(TreeNode root) \\n    {\\n        max= Integer.MIN_VALUE;//identity \\n        getDiameter(root);\\n        return max-1; //node=edge+1, i.e; edge=node-1\\n    }\\n}//Please do Upvote, It helps a lot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2253278,
                "title": "python-dfs-2-solutions-explained-time-o-n-space-o-n",
                "content": "# Explaination:\\nThis problem wants us to find the max diameter of a binary tree, the diameter is simply the sum of height of the left tree and the height of the right tree.\\n\\n**Lets take this example:**\\nThe **diamater for this circled area is 5**, because for `1`, its left height is `4` and its right height is `1`. So we do `4+1` and that is a diameter of 5.\\n![image](https://assets.leetcode.com/users/images/fd9fd5ca-914b-4acf-b03e-f5fbae4036ac_1657254607.2313876.png)\\n**But this is not the max diamater, lets look at our second example for this tree**\\n\\n**Second Example:**\\nThe **diameter for this circled area is 6.** `2` has a left height of 3 and a right height of 3. `3+3` is a diameter of 6.\\nThis is why they say `the diameter may or may not pass through the root`, because there could be other bigger diameters in other subtrees within our tree, like in this example below.\\n![image](https://assets.leetcode.com/users/images/b3a267a8-bbaa-404f-8b21-81224b073860_1657254574.3808472.png)\\n\\nTo find the height of a tree we just return `max(left, right) + 1` everytime. Also, the height of a leaf node is always 0 because it has no children. So for this problem all we need to do is use the heights we find and add them up. So if you find the sum of the `left` height and the `right` height, that will be the `diameter` of whichever node you\\'re on. `left` height means the biggest height of the left subtree, and `right` height means the biggest height of the right subtree.\\n\\n**Array Reference Solution Breakdown:**\\n1. We will keep track of our answer using an array with a single value in it, we will modify the value inside that array by passing it into a helper function and modifying the value from there. The value in the array will represent the max diameter we found so far.\\n2. We run our `findDiameter` helper function and pass the `root` and `result` array.\\n3. Inside our helper function `findDiameter` we have a base case. If the `root`, also known as the current node we are on is `None`, we just return 0 as the height. Since as we know, leaf knows have a height of `0`.\\n4. We create variables `left` and `right` and traverse through the left and right subtrees. After we traversed through both we should have the height of the left and right of the subtree we are on. Usually we will keep going until we reach our first leaf node, so the `left` and `right` should be `0`. Then we keep going.\\n5. Before we return, we always check the diameter and compare it to the max diameter we have seen so far and have saved in our `result` array. We take the max of the diameter we saved in `result[0]` and compare it to the sum of the `left` and `right` heights of our current subtree to get the current diameter. Then we save the biggest diameter.\\n6. Now we return the height of the current subtree and pass it up to the parent by taking the biggest height from our `left` and `right` heights and adding `1` to that biggest height, then returning it.\\n7. After we finish the DFS through the tree, we return `result[0]` which will hold the max diameter we found.\\n\\nTime O(N) | Space O(N):\\nTime is O(N) because we must traverse through all nodes in the tree\\nSpace is O(N) because in the worst case we can have a skewed tree which looks like a linked list and our recursive stack can end up holding `N` which represents the total nodes in the skewed tree.\\n\\n**Passing an array reference and modifying its value to keep track of max diameter :**\\n```\\nclass Solution:\\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        result = [0] # Global result variable\\n        self.findDiameter(root, result)\\n        return result[0]\\n    \\n    def findDiameter(self, root, result):\\n        if not root:\\n            return 0\\n        \\n        left = self.findDiameter(root.left, result)\\n        right = self.findDiameter(root.right, result)\\n        \\n        result[0] = max(result[0], left + right)\\n        \\n        return max(left, right) + 1\\n```\\n\\n**Solution With No Reference Array Breakdown:**\\n1. For this solution we wont keep a `result` array to modify. We will do it all in our helper function and return a `tuple`.\\n2. For the helper function, the base case will return a tuple of `(0, 0)` instead of a single `0`. The first value represents the **height** and the second value represents the **current max diameter**.\\n3. We will create `left` and `right` variables and traverse the left and right of our tree.\\n4. After traversing the tree we will have our tuple values for both `left` and `right`. Remember, the get the `currentDiameter` we need the sum of the left and right heights and we saved those heights in the first value in our tuple. So we do `left[0] + right[0]` to get the `currentDiameter`.\\n5. Now the `maxDiameter`, we will always keep saving the max diameter seen in our tuples for both the `left` and `right`, the max diameter value is in the second number in our tuple. We want to compare the `maxDiameter` we have seen from our left subtree, our right subtree, and our current and keep the max out of all 3. So we do `max(left[1], right[1], currentDiameter)`\\n6. Now we want to pass the height and the `maxDiameter` up to our parent node. So remember, to get the height we pick the max height by comparing our left height and right height and taking the biggest, then adding 1. `max(left[0], right[0]) + 1`, we save that as our first value for the tuple, then we pass the `maxDiameter` as the second value.\\n7. Once we finish and break out of the helper function, we return the second value, which is why we have a `[1]` at the end of our function call `return self.findDiameter(root)[1]`, because we will be getting back a tuple and we know we keep our `maxDiameter` as the second value in that tuple.\\n\\nThe time and space complexity is exactly the same, the point of this solution is it doesn\\'t use any global variables or modifies any reference arrays which the interviewer may like, this solution could be a bit trickier to come up with for some people, so pick whichever solution you want. If the interviewer ever asks you to solve it with no global variable or reference array, you can use this solution.\\n\\n**No array reference or global variables**\\n```\\nclass Solution:\\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        return self.findDiameter(root)[1]\\n    \\n    def findDiameter(self, root):\\n        if not root:\\n            return (0, 0)\\n        \\n        left = self.findDiameter(root.left)\\n        right = self.findDiameter(root.right)\\n        \\n        currentDiameter = left[0] + right[0]\\n        maxDiameter = max(left[1], right[1], currentDiameter)\\n        \\n        return (max(left[0], right[0]) + 1, maxDiameter)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        result = [0] # Global result variable\\n        self.findDiameter(root, result)\\n        return result[0]\\n    \\n    def findDiameter(self, root, result):\\n        if not root:\\n            return 0\\n        \\n        left = self.findDiameter(root.left, result)\\n        right = self.findDiameter(root.right, result)\\n        \\n        result[0] = max(result[0], left + right)\\n        \\n        return max(left, right) + 1\\n```\n```\\nclass Solution:\\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        return self.findDiameter(root)[1]\\n    \\n    def findDiameter(self, root):\\n        if not root:\\n            return (0, 0)\\n        \\n        left = self.findDiameter(root.left)\\n        right = self.findDiameter(root.right)\\n        \\n        currentDiameter = left[0] + right[0]\\n        maxDiameter = max(left[1], right[1], currentDiameter)\\n        \\n        return (max(left[0], right[0]) + 1, maxDiameter)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 594820,
                "title": "clean-recursive-post-order-traversal-beats-99",
                "content": "I only got to this solution after reading a couple of others to understand the mechanics of the algorithm. I post this here because this solution is cleaner than others I\\'ve seen, and avoids having several +/- 1s which can be confusing.\\n\\nAt the time I submitted it the solution was faster than 99.8% of other Python 3 submissions.\\n\\n---\\n\\n## Idea\\n\\nThe key idea is to answer the question \"what is the longest path that _goes through_ the current node\"? \"Goes through\" here means \"includes\", so not necessarily \"goes in from one children and out through the other\", but also \"begins/ends on\". Draw a few trees and for each subtree, compute the longest path that goes through the root node of that subtree.\\n\\nThe longest path that goes through a given node is the depth of the left tree plus the depth of the right tree. Drawing some simple cases:\\n\\n```\\n  1\\n /\\n2\\n```\\n\\nFor the root node `1`, the depth of the left subtree is 1 and that of the right subtree is 0. You can see in the diagram that the longest path is 1, and indeed adding the subtree depths gives `1 + 0 = 1`. Maybe this is a lucky guess? Trying another example:\\n\\n```\\n  1\\n /  \\\\\\n2    3\\n```\\n\\nHere the left and right subtrees both have depths of 1, and you can see that the longest path (`2 -> 1 -> 3`) has length 2. Indeed, the sum of the depths gives `1 + 1 = 2`.\\n\\nI had to draw a few other examples to convince myself that the sum of subtree depths was correct, and that this wasn\\'t just a lucky guess. Any more formal proofs would be welcome!\\n\\n## Computing tree depth\\n\\nSo, we know we\\'ll need to compute depths of the subtrees, and we know that we can only compute the longest path that goes through a given \\'root\\' node only _after_ we know the subtree depths. Given this, post-order traversal is a natural fit.\\n\\n```python\\ndef depth(root : TreeNode):\\n    if root is None:\\n\\t    return 0\\n\\t\\t\\n    d_left = depth(root.left)\\n\\td_right = depth(root.right)\\n\\td = max(d_left, d_right) + 1\\n\\treturn d\\n```\\n\\nThis implementation\\'s terminal condition is \\'node is `None`\\'. For a node with no children, this will then evaluate `d_left = d_right = 0`, giving `d = max(0, 0) + 1 = 1`. This fits the definition of \\'tree depth\\', where a node with no children has depth 1.\\n\\nNote that this implementation is indeed post-order. We visit the left subtree first, then then right, then compute the value we want for the root.\\n\\n## Computing the longest path\\n\\nNow all we need to do is augment this code to additionally compute the longest path.\\n\\nThe tricky part is figuring out how to keep track of the longest path for all subtrees, because it may be that the longest path does not go through the current \\'root\\' node, but the root node in some sub(sub,\\u2026)tree.\\n\\nI chose to add an additional argument `longest`, and have the method return the longest path it found so far (as well as the depth). This variable is passed to the computation for subtrees and then updated, so if a subtree finds a longer path than we can make going through the current node, we can just take the maximum.\\n\\nRemember from above that the longest path through the current root node is the sum of the depths of the subtrees. We\\'ve already computed these, so the changes are just adding the `longest` variable, propagating, computing it, and returning it.\\n\\n```python\\ndef depth_and_longest_path(root : TreeNode, longest : int):\\n    \"\"\"Return the depth of the tree rooted at this node and the longest path within it.\"\"\"\\n    if root is None:\\n\\t    return 0, longest\\n\\t\\t\\n    d_left, longest = depth(root.left, longest)\\n\\td_right, longest = depth(root.right, longest)\\n\\td = max(d_left, d_right) + 1\\n\\t# See if we can form a longer path through this node,\\n\\t# otherwise take the longest path found in the subtrees\\n\\tlongest = max(longest, d_left + d_right)\\n\\treturn d, longest\\n```\\n\\nIn the LeetCode problem, one can just delegate to this method.\\n\\n```python\\nclass Solution:\\n    def _depth_and_longest_path(self, root: TreeNode, longest: int):\\n       # See implementation above\\n\\t   # ...\\n    \\n    def diameterOfBinaryTree(self, root: TreeNode) -> int:\\n        _, diameter = self._depth_and_longest_path(root, 0)\\n        return diameter\\n```\\n\\nWe explicitly start with `longest = 0` here, as an empty tree or a node with no children has diameter zero.\\n\\nBecause we\\'re just doing a post-order traversal, the time complexity is `O(n)`, where `n` is the number of nodes in the tree. The space complexity is likewise `O(n)`, as we\\'ll need `n` recursive calls on the stack in the worst case (a maximally unbalanced tree, e.g. every node is to the left of its parent).",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\n  1\\n /\\n2\\n```\n```\\n  1\\n /  \\\\\\n2    3\\n```\n```python\\ndef depth(root : TreeNode):\\n    if root is None:\\n\\t    return 0\\n\\t\\t\\n    d_left = depth(root.left)\\n\\td_right = depth(root.right)\\n\\td = max(d_left, d_right) + 1\\n\\treturn d\\n```\n```python\\ndef depth_and_longest_path(root : TreeNode, longest : int):\\n    \"\"\"Return the depth of the tree rooted at this node and the longest path within it.\"\"\"\\n    if root is None:\\n\\t    return 0, longest\\n\\t\\t\\n    d_left, longest = depth(root.left, longest)\\n\\td_right, longest = depth(root.right, longest)\\n\\td = max(d_left, d_right) + 1\\n\\t# See if we can form a longer path through this node,\\n\\t# otherwise take the longest path found in the subtrees\\n\\tlongest = max(longest, d_left + d_right)\\n\\treturn d, longest\\n```\n```python\\nclass Solution:\\n    def _depth_and_longest_path(self, root: TreeNode, longest: int):\\n       # See implementation above\\n\\t   # ...\\n    \\n    def diameterOfBinaryTree(self, root: TreeNode) -> int:\\n        _, diameter = self._depth_and_longest_path(root, 0)\\n        return diameter\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1143907,
                "title": "python-thought-process",
                "content": "The idea that\\'s tricky here is our recursive function is doing two things at once:\\n\\n1. It is calculating the \"diameter.\"\\n2. It is calculating the the length of a path\\n\\nIf you look at a path, there will be a \"peak\" node (it could be the root) where the left and right lines join together. Given a peak node, we simply add the length of the `left` path and the `right` path together: `left+right`.\\n\\nIf we\\'re exploring a left or right path, we simply want the maximum number of edges, so we just need to return `1 + max(recurse(node.left), recurse(node.right))`.\\n\\nThus, we try to combine these two different types of logic together in our single recursive function. By using `self.result`, our recursive function can update our variable, and the return value can be for calculating `2.`, i.e, the length of a given path.\\n\\nThis in my opinion is a super tricky problem!\\n\\n```python\\ndef diameterOfBinaryTree(self, root):\\n\\n    def recurse(node):\\n        if not node: return 0\\n        left, right = recurse(node.left), recurse(node.right)\\n        self.result = max(self.result, left+right)\\n        return 1 + max(left, right)\\n\\n    self.result = 0\\n    recurse(root)\\n    return self.result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\ndef diameterOfBinaryTree(self, root):\\n\\n    def recurse(node):\\n        if not node: return 0\\n        left, right = recurse(node.left), recurse(node.right)\\n        self.result = max(self.result, left+right)\\n        return 1 + max(left, right)\\n\\n    self.result = 0\\n    recurse(root)\\n    return self.result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 993792,
                "title": "java-easy-to-understand-code-with-comments",
                "content": "```\\nclass Solution {\\n    public int height(TreeNode root){\\n        if(root==null) return 0;\\n        return 1+Math.max(height(root.left), height(root.right));// height will be max of right and left, +1\\n    }\\n    public int diameterOfBinaryTree(TreeNode root) {\\n        if(root==null) return 0;\\n        int withRoot= height(root.left)+ height(root.right);// if max diameter goes through root node we will just add height of left and height of right\\n        int leftRoot= diameterOfBinaryTree(root.left);// if max diameter lies in left child, than just apply the diameter function in the left part\\n        int rightRoot= diameterOfBinaryTree(root.right);// similarly if lies in right go for right\\n        return Math.max(withRoot,Math.max(leftRoot,rightRoot));// find max of all 3\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int height(TreeNode root){\\n        if(root==null) return 0;\\n        return 1+Math.max(height(root.left), height(root.right));// height will be max of right and left, +1\\n    }\\n    public int diameterOfBinaryTree(TreeNode root) {\\n        if(root==null) return 0;\\n        int withRoot= height(root.left)+ height(root.right);// if max diameter goes through root node we will just add height of left and height of right\\n        int leftRoot= diameterOfBinaryTree(root.left);// if max diameter lies in left child, than just apply the diameter function in the left part\\n        int rightRoot= diameterOfBinaryTree(root.right);// similarly if lies in right go for right\\n        return Math.max(withRoot,Math.max(leftRoot,rightRoot));// find max of all 3\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 573581,
                "title": "c-two-approaches-well-explained",
                "content": "As mentioned, The diameter of a binary tree is the length of the longest path between any two nodes in a tree, which may or may not pass from root. So, diameter may pass from root or may be present entirely in left or right subtree.\\n\\n**APPROACH 1**  First approch is to traverse through all the nodes, find left and right heights of subtree and return maximum of (sum of left and right heights , maxDia of left subtree , maxDia of right subtree). But it is not optimal as we have to call a function to find height at each node.\\n```\\n   int height(TreeNode* root){\\n        if(root==NULL)\\n            return 0;\\n        \\n        return 1+max(height(root->left),height(root->right));\\n        \\n    }\\n    int diameterOfBinaryTree(TreeNode* root) {\\n      \\n\\tif(root==NULL){\\n\\t\\treturn 0;\\n\\t}\\n\\n\\tint op1 = height(root->left) + height(root->right);\\n\\tint op2 = max(diameterOfBinaryTree(root->left),diameterOfBinaryTree(root->right));\\n\\treturn max(op1,op2);\\n}\\n\\n```\\n\\n**APPROACH 2** By optimising first approach ,instead of finding height at each node we can store the value of heights and diameters of left and right subtree and return them as a pair of integers. This approach eliminates the need of a call to find height for each node\\nIn the code below, first value of pair stores height and  second value stores the diameter.\\n```\\n int diameterOfBinaryTree(TreeNode* root) {\\n       \\n        return diameterOfBinaryTreeHelper(root).second;\\n    }\\n      pair<int,int> diameterOfBinaryTreeHelper(TreeNode* root) {\\n\\n        if(root==NULL)\\n            return {0,0};\\n        \\n         pair<int,int> p;\\n        \\n        pair l=diameterOfBinaryTreeHelper(root->left);\\n         pair r=diameterOfBinaryTreeHelper(root->right);\\n        \\n        p.first=1+max(l.first,r.first);\\n        p.second = max(max(l.second,r.second),l.first+r.first);\\n        return p;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n   int height(TreeNode* root){\\n        if(root==NULL)\\n            return 0;\\n        \\n        return 1+max(height(root->left),height(root->right));\\n        \\n    }\\n    int diameterOfBinaryTree(TreeNode* root) {\\n      \\n\\tif(root==NULL){\\n\\t\\treturn 0;\\n\\t}\\n\\n\\tint op1 = height(root->left) + height(root->right);\\n\\tint op2 = max(diameterOfBinaryTree(root->left),diameterOfBinaryTree(root->right));\\n\\treturn max(op1,op2);\\n}\\n\\n```\n```\\n int diameterOfBinaryTree(TreeNode* root) {\\n       \\n        return diameterOfBinaryTreeHelper(root).second;\\n    }\\n      pair<int,int> diameterOfBinaryTreeHelper(TreeNode* root) {\\n\\n        if(root==NULL)\\n            return {0,0};\\n        \\n         pair<int,int> p;\\n        \\n        pair l=diameterOfBinaryTreeHelper(root->left);\\n         pair r=diameterOfBinaryTreeHelper(root->right);\\n        \\n        p.first=1+max(l.first,r.first);\\n        p.second = max(max(l.second,r.second),l.first+r.first);\\n        return p;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 481151,
                "title": "easy-javascript-python-solutions",
                "content": "## JavaScript \\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar diameterOfBinaryTree = function(root) {\\n    let max = 0\\n    \\n    const maxDepth = (root) => {\\n        if (root === null) return 0\\n        const left = maxDepth(root.left)\\n        const right = maxDepth(root.right)\\n        max = Math.max(max, left + right)\\n        return Math.max(left, right) + 1\\n    }\\n    maxDepth(root)\\n    return max\\n};\\n\\n```\\n\\n## Python \\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def diameterOfBinaryTree(self, root: TreeNode) -> int:\\n        self.result = 0 \\n        \\n        def max_depth(root):\\n            if not root: return 0\\n            \\n            left = max_depth(root.left)\\n            right = max_depth(root.right)\\n            self.result = max(self.result, left + right)\\n            return 1+ max(left, right)\\n    \\n        max_depth(root)\\n        return self.result \\n```",
                "solutionTags": [
                    "Python3",
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar diameterOfBinaryTree = function(root) {\\n    let max = 0\\n    \\n    const maxDepth = (root) => {\\n        if (root === null) return 0\\n        const left = maxDepth(root.left)\\n        const right = maxDepth(root.right)\\n        max = Math.max(max, left + right)\\n        return Math.max(left, right) + 1\\n    }\\n    maxDepth(root)\\n    return max\\n};\\n\\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def diameterOfBinaryTree(self, root: TreeNode) -> int:\\n        self.result = 0 \\n        \\n        def max_depth(root):\\n            if not root: return 0\\n            \\n            left = max_depth(root.left)\\n            right = max_depth(root.right)\\n            self.result = max(self.result, left + right)\\n            return 1+ max(left, right)\\n    \\n        max_depth(root)\\n        return self.result \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2531276,
                "title": "python-recursive-easy-39ms-99-06-faster",
                "content": "```\\nclass Solution:\\n    dia = 0\\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        if root == None: return True\\n        self.height(root)\\n        return self.dia\\n\\n    def height(self, root):\\n        if (root == None): return 0\\n        l = self.height(root.left)\\n        r = self.height(root.right)\\n        if l+r > self.dia:\\n            self.dia = l+r\\n        return max(l, r)+1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    dia = 0\\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        if root == None: return True\\n        self.height(root)\\n        return self.dia\\n\\n    def height(self, root):\\n        if (root == None): return 0\\n        l = self.height(root.left)\\n        r = self.height(root.right)\\n        if l+r > self.dia:\\n            self.dia = l+r\\n        return max(l, r)+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1230723,
                "title": "java-0ms-100-solution-t-c-o-n-s-c-o-n-recursive-space",
                "content": "```\\nclass Solution {\\n    public int longestPath = 0;\\n    public int diameterOfBinaryTree(TreeNode root) {\\n        longestPath(root);\\n        return longestPath;\\n    }\\n    \\n    public int longestPath(TreeNode root){\\n        if(root == null){\\n            return 0;\\n        }\\n        \\n        int lheight = longestPath(root.left);\\n        int rheight = longestPath(root.right);\\n        \\n        longestPath = Math.max(longestPath, lheight + rheight);\\n        \\n        return Math.max(lheight, rheight) + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int longestPath = 0;\\n    public int diameterOfBinaryTree(TreeNode root) {\\n        longestPath(root);\\n        return longestPath;\\n    }\\n    \\n    public int longestPath(TreeNode root){\\n        if(root == null){\\n            return 0;\\n        }\\n        \\n        int lheight = longestPath(root.left);\\n        int rheight = longestPath(root.right);\\n        \\n        longestPath = Math.max(longestPath, lheight + rheight);\\n        \\n        return Math.max(lheight, rheight) + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 101127,
                "title": "simple-swift-solution",
                "content": "The diameter is either:\\n1. The height of left subtree + height of right subtree\\n2. The diameter of left subtree or diameter of right subtree\\n\\nTake the max of either above.\\n\\n```\\nclass Solution {\\n    func heightOfBinaryTree(_ root: TreeNode?) -> Int {\\n        guard let node = root else { return 0 }\\n        return 1 + max(heightOfBinaryTree(node.left), heightOfBinaryTree(node.right));\\n    }\\n    \\n    func diameterOfBinaryTree(_ root: TreeNode?) -> Int {\\n        guard let node = root else { return 0 }\\n        let hl = heightOfBinaryTree(node.left)\\n        let hr = heightOfBinaryTree(node.right)\\n        \\n        return max(hl + hr, max(diameterOfBinaryTree(node.left), diameterOfBinaryTree(node.right)))\\n    }\\n}\\n````",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func heightOfBinaryTree(_ root: TreeNode?) -> Int {\\n        guard let node = root else { return 0 }\\n        return 1 + max(heightOfBinaryTree(node.left), heightOfBinaryTree(node.right));\\n    }\\n    \\n    func diameterOfBinaryTree(_ root: TreeNode?) -> Int {\\n        guard let node = root else { return 0 }\\n        let hl = heightOfBinaryTree(node.left)\\n        let hr = heightOfBinaryTree(node.right)\\n        \\n        return max(hl + hr, max(diameterOfBinaryTree(node.left), diameterOfBinaryTree(node.right)))\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 101129,
                "title": "solution-by-minions",
                "content": "\\n#### Approach #1 Brute Force [Time Limit Exceeded]\\n\\n**Intuition**\\n\\nBrute Force Approach would be to list out all possible permutation of paths between two nodes\\nI.e. take all pairs of two nodes and find distance between them and finally print the largest distance.\\n\\n\\n**Complexity Analysis**\\n\\n* Time complexity : $$O(n^3)$$.\\n\\nTaking permutation of two nodes will be O(n^2) and per two node finding distance would be O(n)\\nSo total would be O(n^3).\\n\\n* Space complexity : $$O(n)$$.\\n\\n---\\n#### Approach #2 O(n^2) [Accepted]\\n\\n**Intuition**\\n\\nComputing height of left and right subtree at each node\\nNote\\nheight =number of vertices on the longest path from the node to a leaf\\nOr recursively height = max(left subtree height , right subtree height) + 1\\nWhere NULL nodes have height 0 and leaf nodes have height 1\\nFor example:\\n(![0_1506392292167_1.png](/assets/uploads/files/1506392293595-1.png) \\n**[img1.png]**\\n\\nthis tree have height as 3 for path 1 - 2 - 4 comprising of three nodes.\\n\\n**Algorithm**\\nFor each node there would be two cases\\n1. the diameter passes through the node\\n2. the diameter doesn\\u2019t passes through the node\\n\\n\\nCase 1 : diameter passes through the node\\n    Then diameter would be height of left subtree + height of right subtree\\n![0_1506392310862_2.png](/assets/uploads/files/1506392312388-2.png) \\n**[img2.png]**\\n\\n\\nFor e.g. in above figure diameter is 3 as node 1 is part of path of diameter which is\\n4 - 2 - 1 - 3\\nDiameter = left subtree height (2) + right subtree height (1)\\n\\nCase 2 : diameter does not passes through the node\\nIf this is the case, then diameter would be\\nmaximum of (diameter of left subtree , diameter of right subtree)\\nIt is because there is some path in lower parts of tree which is longer than including\\ncurrent node.\\n\\n![0_1506621609740_3.png](/assets/uploads/files/1506621607833-3.png) \\n\\nFor example in above figure diameter is 8 [10-8-6-4-2-5-7-9-11] and it is not passing through 1. Which is maximum of diameter of left tree (8) and right tree (0).\\n\\nSo, for each node recursive formula would be maximum of three quantity\\n1. Diameter of left subtree\\n2. Diameter of right subtree\\n3. Left subtree height + right subtree height\\n\\nWhere first two point assumes that diameter doesn\\u2019t passes through that node\\nAnd third point assumes that diameter passes through that node.\\n\\n\\n**C++**\\n\\n```C++\\nclass Solution {\\npublic:\\n\\n    int height(TreeNode *root)\\n    {\\n        if(!root) // if node is null\\n            return 0;\\n        return max(height(root->left),height(root->right))+1;\\n    }\\n\\n    int diameterOfBinaryTree(TreeNode* root) {\\n\\n        if(!root)return 0;\\n    // computing left subtree height and right subtree height at each node\\n        int lh = height(root->left);\\n        int rh = height(root->right);\\n\\n        return max(max(diameterOfBinaryTree(root->left),diameterOfBinaryTree(root->right)),lh+rh);\\n\\n    }\\n\\n};\\n```\\n\\n**Complexity Analysis**\\n\\n* Time complexity : $$O(n^2)$$.\\n\\nAt each node we are calculating height for left and right subtree\\nheight()    ----->   $$O(n)$$\\nWe are calculating height for each node\\nSo complexity =$$ O(n*n) = O(n^2)$$\\n\\n\\n* Space complexity : $$O(n)$$.\\n\\n\\n#### Approach #2 O(n) [Accepted]\\nStoring height at each node\\n**Intuition**\\n\\nHere main concern is calculation of height at each node.\\nWhat we can do is to save height calculated so far and use that to calculate height of the parent node. For that we need to return height of child to its parent in recursive call.\\n\\nAs we are calculating diameter by return statement we can pass a variable by reference so that its value is changed and seen by the calling parent.\\n\\n\\n\\nWe pass another variable to the function\\ndia(node ptr, var height passed by reference )\\n\\nConsidering base case for leaf nodes : left child and right child are NULL\\nHeight of left subtree = 0\\nHeight of right subtree = 0\\nAs variable is passed by reference\\nLeft height = 0\\nRight height = 0\\nSo height = 0+0+1 = 1\\nAs this variable is also passed by reference the parent of leaf node will get its left subtree or right subtree(depending on whether leaf node is left child or right child) height as 1. Same process goes on recursively.\\n\\nIntuitively, there are basically two variables which are changing with each call\\n\\n1. Diameter calculated till that node so far (by return statement)\\n2. Height (by passed by reference variable)\\n\\nFinally, logic for diameter is same as above algo i.e. maximum of three quantities\\n1. Diameter of left subtree\\n2. Diameter of right subtree\\n3. Left subtree height + right subtree height\\n\\n\\n\\nVisualization\\n\\n[Gif Here]\\n\\nTest Case\\n[4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]\\nOutput - 8\\n\\n\\n\\n\\n\\n\\n[GIF Link]\\nhttp://gph.is/2fTc9FJ\\n\\n![alt text](![0_1506392342853_leetcode diameter.gif](Uploading 100%) image url)\\n[0_1506620484882_diaporama(1).zip](Uploading 100%) \\n[Gif here]\\n\\n**Solution**\\n```\\nclass Solution {\\npublic:\\n    int dia(TreeNode * root, int &height)\\n    {\\n        int lh=0,rh=0,ld,rd;\\n        if(!root)\\n        {\\n            height=0;\\n            return 0; // dia = 0\\n        }\\n        ld = dia(root->left,lh); // lh passed as a reference\\n        rd = dia(root->right,rh); // rh passed as a reference\\n        height = max(lh,rh)+1;\\n\\n        return max(max(ld,rd),lh+rh);\\n\\n    }\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        int h=0;\\n        if(!root)return 0;\\n        return dia(root,h);\\n    }\\n};\\n```\\n***Complexity Analysis***\\n* Time complexity : $$O(n)$$\\nFor each node, height is calculated in O(1) and recursion goes for all nodes in the tree. Therefore complexity is O(n).\\n* Space complexity : $$O(n)$$.",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\npublic:\\n\\n    int height(TreeNode *root)\\n    {\\n        if(!root) // if node is null\\n            return 0;\\n        return max(height(root->left),height(root->right))+1;\\n    }\\n\\n    int diameterOfBinaryTree(TreeNode* root) {\\n\\n        if(!root)return 0;\\n    // computing left subtree height and right subtree height at each node\\n        int lh = height(root->left);\\n        int rh = height(root->right);\\n\\n        return max(max(diameterOfBinaryTree(root->left),diameterOfBinaryTree(root->right)),lh+rh);\\n\\n    }\\n\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int dia(TreeNode * root, int &height)\\n    {\\n        int lh=0,rh=0,ld,rd;\\n        if(!root)\\n        {\\n            height=0;\\n            return 0; // dia = 0\\n        }\\n        ld = dia(root->left,lh); // lh passed as a reference\\n        rd = dia(root->right,rh); // rh passed as a reference\\n        height = max(lh,rh)+1;\\n\\n        return max(max(ld,rd),lh+rh);\\n\\n    }\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        int h=0;\\n        if(!root)return 0;\\n        return dia(root,h);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634687,
                "title": "beats-100-recursion",
                "content": "```\\nclass Solution {\\n    int res = 0;\\n\\npublic:\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        maxHeight(root);\\n        return res;\\n    }\\n\\n    int maxHeight(TreeNode* root) {\\n        if (!root) return 0;\\n\\n        int x = maxHeight(root->left);\\n        int y = maxHeight(root->right);\\n\\n        res = max(res, x+y);\\n\\n        return max(x,y) + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int res = 0;\\n\\npublic:\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        maxHeight(root);\\n        return res;\\n    }\\n\\n    int maxHeight(TreeNode* root) {\\n        if (!root) return 0;\\n\\n        int x = maxHeight(root->left);\\n        int y = maxHeight(root->right);\\n\\n        res = max(res, x+y);\\n\\n        return max(x,y) + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2057851,
                "title": "c-iterative-first-post",
                "content": "First post :\\n\\nThe Post-Order traversal of a tree (left, right, root) is more difficult than the other traversals.\\n\\nI found the following trick in the discussions of  [145. Binary Tree Postorder Traversal](https://leetcode.com/problems/binary-tree-postorder-traversal/discuss/?currentPage=1&orderBy=hot&query=), but I don\\'t know which post anymore.\\n\\nThe trick is to push twice each node to the stack. \\n\\n=> During the loop : \\n* There are two options : either the node we just popped off is the same as the one at the top of the stack or they are different.\\n* If they are the same, then it means we added them at the previous iteration, hence the left and right child have not been processed yet so we add them both to the stack (each two times).\\n* If they are not the same, then it means both child have been processed, we can now process the current node. The rest of the idea is the same as in the recursive code except we need ``` unordered_map<TreeNode*,int> depth```  to keep track of the longest branch from a given Node.\\n\\nThere exists other ways to do an iterative Post-Order traversal , but I think it is the most easy-to-understand solution.\\n\\n```\\nint diameterOfBinaryTree(TreeNode* root) {\\n\\tint ans = 0;\\n\\tunordered_map<TreeNode*,int> depth;\\n\\tstack<TreeNode*> s;\\n\\ts.push(root);\\n\\ts.push(root);\\n\\twhile( !s.empty() ) {\\n\\t\\tauto cur = s.top();\\n\\t\\ts.pop();\\n\\t\\tif(!cur)    continue;\\n\\t\\tif(!s.empty() && s.top() == cur) {\\n\\t\\t\\tdepth[cur] = 0;\\n\\t\\t\\ts.push(cur->right);\\n\\t\\t\\ts.push(cur->right);\\n\\t\\t\\ts.push(cur->left);\\n\\t\\t\\ts.push(cur->left);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tdepth[cur] = max(depth[cur->right], depth[cur->left]) +1;\\n\\t\\t\\tans = max(depth[cur->right] + depth[cur->left], ans);\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```\\n\\nThat was my first post ever, so if you could give me some feedback , I would appreciate it  :)",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "``` unordered_map<TreeNode*,int> depth```\n```\\nint diameterOfBinaryTree(TreeNode* root) {\\n\\tint ans = 0;\\n\\tunordered_map<TreeNode*,int> depth;\\n\\tstack<TreeNode*> s;\\n\\ts.push(root);\\n\\ts.push(root);\\n\\twhile( !s.empty() ) {\\n\\t\\tauto cur = s.top();\\n\\t\\ts.pop();\\n\\t\\tif(!cur)    continue;\\n\\t\\tif(!s.empty() && s.top() == cur) {\\n\\t\\t\\tdepth[cur] = 0;\\n\\t\\t\\ts.push(cur->right);\\n\\t\\t\\ts.push(cur->right);\\n\\t\\t\\ts.push(cur->left);\\n\\t\\t\\ts.push(cur->left);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tdepth[cur] = max(depth[cur->right], depth[cur->left]) +1;\\n\\t\\t\\tans = max(depth[cur->right] + depth[cur->left], ans);\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1381102,
                "title": "golang-using-closure-to-do-postorder-traverse-time-o-n",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc diameterOfBinaryTree(root *TreeNode) int {\\n    //post order traverse\\n    // for each recursion we want to get what is the largest number of nodes single sided\\n    res := 0\\n    var postorder func(*TreeNode) int\\n    postorder = func(node *TreeNode) int {\\n        if node == nil {\\n            return 0\\n        }\\n        left := postorder(node.Left)\\n        right := postorder(node.Right)\\n        if left + right > res {\\n            res = left + right\\n        }\\n        if left > right {\\n            return left+1\\n        } else {\\n            return right+1\\n        }\\n    }\\n    postorder(root)\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc diameterOfBinaryTree(root *TreeNode) int {\\n    //post order traverse\\n    // for each recursion we want to get what is the largest number of nodes single sided\\n    res := 0\\n    var postorder func(*TreeNode) int\\n    postorder = func(node *TreeNode) int {\\n        if node == nil {\\n            return 0\\n        }\\n        left := postorder(node.Left)\\n        right := postorder(node.Right)\\n        if left + right > res {\\n            res = left + right\\n        }\\n        if left > right {\\n            return left+1\\n        } else {\\n            return right+1\\n        }\\n    }\\n    postorder(root)\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1320416,
                "title": "c-easy-solution-clean-and-concise",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        int res=0;\\n        findMaxPath(root,res);\\n        return res;\\n        \\n    }\\n    int findMaxPath(TreeNode* curr,int& res)\\n    {\\n        if(!curr)\\n            return 0 ;\\n        int left= findMaxPath(curr->left,res);\\n        int right=findMaxPath(curr->right,res);\\n        \\n        //calculate the max distance\\n        res=max(res,left+right);\\n        return max(left,right)+1;\\n    }\\n};\\n```\\n**Upvote if this helps you:)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        int res=0;\\n        findMaxPath(root,res);\\n        return res;\\n        \\n    }\\n    int findMaxPath(TreeNode* curr,int& res)\\n    {\\n        if(!curr)\\n            return 0 ;\\n        int left= findMaxPath(curr->left,res);\\n        int right=findMaxPath(curr->right,res);\\n        \\n        //calculate the max distance\\n        res=max(res,left+right);\\n        return max(left,right)+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 573675,
                "title": "concise-java-solution-better-than-100-submission-0ms",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    int diameter=0;\\n    private int maxHeight(TreeNode root){\\n        if(root==null)\\n            return 0;\\n        int left = maxHeight(root.left);\\n        int right = maxHeight(root.right);\\n        diameter = Math.max(left+right,diameter);\\n        return Math.max(left,right)+1;\\n        \\n    }\\n    public int diameterOfBinaryTree(TreeNode root) {\\n        maxHeight(root);\\n        return diameter ;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    int diameter=0;\\n    private int maxHeight(TreeNode root){\\n        if(root==null)\\n            return 0;\\n        int left = maxHeight(root.left);\\n        int right = maxHeight(root.right);\\n        diameter = Math.max(left+right,diameter);\\n        return Math.max(left,right)+1;\\n        \\n    }\\n    public int diameterOfBinaryTree(TreeNode root) {\\n        maxHeight(root);\\n        return diameter ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 180586,
                "title": "java-python-with-explanations",
                "content": "Diameter is actually `max(node.leftDepth + node.rightDepth)` for `node` can be any one in the tree. \\nSo we build a helper method `getDepth` to get depth of a subtree recursively and update `diameter` all the way.\\n****\\n**Java**\\n```\\n    private static int diameter;\\n    \\n    public int diameterOfBinaryTree(TreeNode root) {\\n        diameter = 0;\\n        getDepth(root);\\n        return diameter;\\n    }\\n    \\n    private int getDepth(TreeNode root) {\\n        // Base case.\\n        if (root == null)\\n            return 0;\\n        \\n        int leftDepth = getDepth(root.left);\\n        int rightDepth = getDepth(root.right);\\n        \\n        diameter = Math.max(diameter, leftDepth + rightDepth);\\n        \\n        return Math.max(leftDepth, rightDepth) + 1;\\n    }\\n```\\n**Python**\\n```\\n    diameter = 0\\n    \\n    def diameterOfBinaryTree(self, root):      \\n        self.getDepth(root)\\n        return self.diameter\\n       \\n        \\n    def getDepth(self, root):\\n        \"\"\"Get depth of a tree rooted at root.\"\"\"\\n        if root is None:  # Base case.\\n            return 0\\n        \\n        leftDepth = self.getDepth(root.left)\\n        rightDepth = self.getDepth(root.right)\\n              \\n        self.diameter = max(leftDepth + rightDepth, self.diameter)\\n        \\n        return max(leftDepth, rightDepth) + 1\\n```\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [],
                "code": "```\\n    private static int diameter;\\n    \\n    public int diameterOfBinaryTree(TreeNode root) {\\n        diameter = 0;\\n        getDepth(root);\\n        return diameter;\\n    }\\n    \\n    private int getDepth(TreeNode root) {\\n        // Base case.\\n        if (root == null)\\n            return 0;\\n        \\n        int leftDepth = getDepth(root.left);\\n        int rightDepth = getDepth(root.right);\\n        \\n        diameter = Math.max(diameter, leftDepth + rightDepth);\\n        \\n        return Math.max(leftDepth, rightDepth) + 1;\\n    }\\n```\n```\\n    diameter = 0\\n    \\n    def diameterOfBinaryTree(self, root):      \\n        self.getDepth(root)\\n        return self.diameter\\n       \\n        \\n    def getDepth(self, root):\\n        \"\"\"Get depth of a tree rooted at root.\"\"\"\\n        if root is None:  # Base case.\\n            return 0\\n        \\n        leftDepth = self.getDepth(root.left)\\n        rightDepth = self.getDepth(root.right)\\n              \\n        self.diameter = max(leftDepth + rightDepth, self.diameter)\\n        \\n        return max(leftDepth, rightDepth) + 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3469115,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDia(TreeNode* root, int& d) {\\n        if (!root)\\n            return 0;\\n\\n        int left = maxDia(root->left, d);\\n        int right = maxDia(root->right, d);\\n        d = max(d, left + right);\\n            \\n        return 1 + max(left, right);\\n    }\\n\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        if (!root)\\n            return 0;\\n\\n        int d = 0;\\n        maxDia(root, d);\\n        return d;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDia(TreeNode* root, int& d) {\\n        if (!root)\\n            return 0;\\n\\n        int left = maxDia(root->left, d);\\n        int right = maxDia(root->right, d);\\n        d = max(d, left + right);\\n            \\n        return 1 + max(left, right);\\n    }\\n\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        if (!root)\\n            return 0;\\n\\n        int d = 0;\\n        maxDia(root, d);\\n        return d;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3294669,
                "title": "543-space-97-96-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Initialize a variable \"ans\" to 0 to store the maximum diameter found so far.\\n2. Define a helper function \"dfs\" which takes a node as an input and returns the maximum height of the node.\\n3. Within the \"dfs\" function:\\na. Check if the node is null, return 0 if it is.\\nb. Recursively call \"dfs\" on the left child of the node and store the result in the \"left\" variable.\\nc. Recursively call \"dfs\" on the right child of the node and store the result in the \"right\" variable.\\nd. Update the \"ans\" variable with the maximum diameter found so far, which is the sum of the maximum height of the left and right subtrees.\\ne. Return the maximum height of the node, which is the maximum between the height of the left and right subtrees plus 1.\\n4. Call the \"dfs\" function on the root node.\\n5. Return the \"ans\" variable.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def diameterOfBinaryTree(self, root: TreeNode) -> int:\\n        self.ans = 0  # variable to store the maximum diameter found so far\\n        \\n        def dfs(node):\\n            if not node:\\n                return 0\\n            left = dfs(node.left)\\n            right = dfs(node.right)\\n            self.ans = max(self.ans, left + right)  # update ans if new diameter is found\\n            return max(left, right) + 1  # return the maximum height of the node\\n            \\n        dfs(root)\\n        return self.ans\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def diameterOfBinaryTree(self, root: TreeNode) -> int:\\n        self.ans = 0  # variable to store the maximum diameter found so far\\n        \\n        def dfs(node):\\n            if not node:\\n                return 0\\n            left = dfs(node.left)\\n            right = dfs(node.right)\\n            self.ans = max(self.ans, left + right)  # update ans if new diameter is found\\n            return max(left, right) + 1  # return the maximum height of the node\\n            \\n        dfs(root)\\n        return self.ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3170066,
                "title": "js-recursion-dfs",
                "content": "# Intuition\\nDFS to traverse and at each node find the length of the longest path through that node. Max depth of left and right subtrees plus one for the current node\\n\\n# Complexity\\n- Time complexity:\\nO(n) where n is the number of nodes in the tree\\n\\n- Space complexity:\\nO(h) where h is the height of the tree. This is because the max number of function calls in the stack will equal the height of the tree.\\n\\n# Code\\n```\\nconst diameterOfBinaryTree = (root) => {\\n    // handle empty tree\\n    if (!root) return 0\\n\\n    // initialize to track max\\n    let maxDiameter = 0\\n\\n    const dfs = (node) => {\\n        // return 0 if node is null\\n        if (!node) return 0\\n\\n        // recursively call dfs on left and right\\n        let left = dfs(node.left)\\n        let right = dfs(node.right)\\n\\n        // Get higher between current max diameter or the heights of the left and right subtrees\\n        maxDiameter = Math.max(maxDiameter, left + right)\\n\\n        // return height of current node by taking max of left or right and adding 1 to account for current node\\n        return Math.max(left, right) + 1\\n    }\\n\\n    // call the dfs function\\n    dfs(root)\\n\\n    \\n    return maxDiameter\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst diameterOfBinaryTree = (root) => {\\n    // handle empty tree\\n    if (!root) return 0\\n\\n    // initialize to track max\\n    let maxDiameter = 0\\n\\n    const dfs = (node) => {\\n        // return 0 if node is null\\n        if (!node) return 0\\n\\n        // recursively call dfs on left and right\\n        let left = dfs(node.left)\\n        let right = dfs(node.right)\\n\\n        // Get higher between current max diameter or the heights of the left and right subtrees\\n        maxDiameter = Math.max(maxDiameter, left + right)\\n\\n        // return height of current node by taking max of left or right and adding 1 to account for current node\\n        return Math.max(left, right) + 1\\n    }\\n\\n    // call the dfs function\\n    dfs(root)\\n\\n    \\n    return maxDiameter\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1640869,
                "title": "java-aditya-verma-dp-on-trees-solution",
                "content": "```\\nclass Solution {\\n    int result =Integer.MIN_VALUE; // declaring initially\\n    public int diameterOfBinaryTree(TreeNode root) {\\n        solve(root);\\n        return result-1; // since we are just counting the paths not the nodes. Paths will always be #Nodes - 1\\n    }\\n    public int solve(TreeNode root){\\n        if(root == null)return 0; // base condition\\n        int left = solve(root.left); //hypothetical solution\\n        int right = solve(root.right); //hypothetical solution\\n        \\n        int temp = Math.max(left,right)+1; // to calculate max length for that particular root node\\n        int ans = Math.max(left+right+1,temp); // to take max for that node or the total sum which will be given to the upper node \\n        result = Math.max(result,ans); // taking the max result \\n        return temp; // returning to the next upper node this temp value\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int result =Integer.MIN_VALUE; // declaring initially\\n    public int diameterOfBinaryTree(TreeNode root) {\\n        solve(root);\\n        return result-1; // since we are just counting the paths not the nodes. Paths will always be #Nodes - 1\\n    }\\n    public int solve(TreeNode root){\\n        if(root == null)return 0; // base condition\\n        int left = solve(root.left); //hypothetical solution\\n        int right = solve(root.right); //hypothetical solution\\n        \\n        int temp = Math.max(left,right)+1; // to calculate max length for that particular root node\\n        int ans = Math.max(left+right+1,temp); // to take max for that node or the total sum which will be given to the upper node \\n        result = Math.max(result,ans); // taking the max result \\n        return temp; // returning to the next upper node this temp value\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1515583,
                "title": "beginner-friendly-java-javascript-python-solution",
                "content": "\\n```java []\\nclass Solution {\\n    private int longestPath = 0;\\n    public int diameterOfBinaryTree(TreeNode root) {\\n        diameter(root);\\n        return longestPath;\\n    }\\n    private int diameter(TreeNode root){\\n        if (root == null)   return 0;\\n        int left_height = diameter(root.left);\\n        int right_height = diameter(root.right);\\n        longestPath = Math.max(longestPath , left_height+right_height);\\n        return Math.max(left_height , right_height) + 1;\\n    }\\n}\\n```\\n\\n``` javascript []\\nvar diameterOfBinaryTree = function(root) {\\n    let longestPath = 0\\n    diameter(root)\\n    function diameter(root){\\n        if(!root)   return null\\n        let left_height = diameter(root.left)\\n        let right_height = diameter(root.right)\\n        longestPath = Math.max(longestPath, left_height + right_height)\\n        return Math.max(left_height, right_height)+ 1;\\n    }\\n    return longestPath\\n     \\n};\\n```",
                "solutionTags": [
                    "Java",
                    "JavaScript"
                ],
                "code": "```java []\\nclass Solution {\\n    private int longestPath = 0;\\n    public int diameterOfBinaryTree(TreeNode root) {\\n        diameter(root);\\n        return longestPath;\\n    }\\n    private int diameter(TreeNode root){\\n        if (root == null)   return 0;\\n        int left_height = diameter(root.left);\\n        int right_height = diameter(root.right);\\n        longestPath = Math.max(longestPath , left_height+right_height);\\n        return Math.max(left_height , right_height) + 1;\\n    }\\n}\\n```\n``` javascript []\\nvar diameterOfBinaryTree = function(root) {\\n    let longestPath = 0\\n    diameter(root)\\n    function diameter(root){\\n        if(!root)   return null\\n        let left_height = diameter(root.left)\\n        let right_height = diameter(root.right)\\n        longestPath = Math.max(longestPath, left_height + right_height)\\n        return Math.max(left_height, right_height)+ 1;\\n    }\\n    return longestPath\\n     \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 580526,
                "title": "distinction-betwen-height-and-depth",
                "content": "As noted by top comments, the use of the term `depth` in the official solution is confusing. However, even when we use `height`, the term is problematic, because returning 0 as a height for null nodes imply that the leaves have height of 1.\\n\\nHowever, by the definition, in the subtree rooted at the leaves, leaves themselves have height of 0 rather than 1. (Height is the maximum depth of the tree, and depth is the number of links from a node to the root).\\n\\nTherefore, I think it is much more appropriate to return a sentinel value of `-1` as a height for null nodes, so that leaves can have the height of 0. Below is a suggested solution:\\n\\n```java\\nclass Solution {\\n    private int diameter = 0;\\n\\n    public int diameterOfBinaryTree(TreeNode root) {\\n        height(root);\\n        return diameter;\\n    }\\n    \\n    private int height(TreeNode n) {\\n        if (n == null) return -1;\\n        \\n        int left = height(n.left) + 1;\\n        int right = height(n.right) + 1;\\n        \\n        diameter = Math.max(diameter, left+right);\\n        \\n        return Math.max(left, right);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    private int diameter = 0;\\n\\n    public int diameterOfBinaryTree(TreeNode root) {\\n        height(root);\\n        return diameter;\\n    }\\n    \\n    private int height(TreeNode n) {\\n        if (n == null) return -1;\\n        \\n        int left = height(n.left) + 1;\\n        int right = height(n.right) + 1;\\n        \\n        diameter = Math.max(diameter, left+right);\\n        \\n        return Math.max(left, right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 397308,
                "title": "java-recursive-no-global-variables",
                "content": "```\\nclass Solution {\\n    public int diameterOfBinaryTree(TreeNode root) {\\n        if (root==null) return 0;\\n        int[] maxDiameter= new int[]{0};\\n        treeDepth(root, maxDiameter);\\n        return maxDiameter[0];\\n    }\\n    private int treeDepth(TreeNode node, int[] maxDiameter){\\n        if (node==null) return 0;\\n        int leftDepth= treeDepth(node.left, maxDiameter);\\n        int rightDepth= treeDepth(node.right, maxDiameter);\\n        maxDiameter[0]= Math.max(leftDepth+rightDepth, maxDiameter[0]);\\n        return 1+Math.max(leftDepth, rightDepth);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int diameterOfBinaryTree(TreeNode root) {\\n        if (root==null) return 0;\\n        int[] maxDiameter= new int[]{0}",
                "codeTag": "Java"
            },
            {
                "id": 285647,
                "title": "detailed-explanation-using-recursion",
                "content": "# Height of a Binary Tree\\n\\nLet us see how to calculate the height of a binary tree using post order traversal.\\n* Suppose we know the height of the left and right subtree. What is the height of the root? Clearly, it is **max(leftHeight,rightHeight) + 1**.\\n* This gives us the algorithm. Recursively calculate the height of the subtrees and update the height of the root. All that is left is to handle the corner cases.\\n* If both the subtrees are non empty, we are done, as the formula is correct. \\n* Suppose, exactly one subtree is empty. Then the result would be **nonEmptyTreeHeight + 1**. This is also valid.\\n* What happens if both the subtree is empty? This means that the root is a leaf node. According to the formula, the height of the root is 1.\\n* Conclusion ===> **We are assuming the height of a leaf node as 1**.\\n\\n# Calculating the diameter\\n* The final diameter has the following form. It goes up certain nodes and after a specific node, say **head**, it comes down. \\n* Recall that while calculating the height of the tree, the height was computed for each and every node due to recursion. \\n* As soon as the height of the node **head** is computed, we can get the diameter as **leftHeight + rightHeight**. Observe that we didn\\'t account for the fact that there are 2 extra edges to reach the left and right subtree. However, this is taken care of by the assumption that leaf nodes have height 1. There is 1 leaf node in each tree which compensates the lost edges. Moreover, this also gives us that the diameter of a leaf node is 0, while its height is 1.\\n\\n# Algorithm\\n* Calculate the height of each node and in the meanwhile, update the diameter at each node.\\n* This ensures that the correct diameter is captured at some stage.\\n\\n# Credits\\nThe idea was borrowed from [here](https://leetcode.com/problems/diameter-of-binary-tree/discuss/101130/C%2B%2B-Java-Clean-Code)\\n\\n```\\nclass Solution\\n{\\n    int diameter = 0;\\npublic:\\n    int diameterOfBinaryTree(TreeNode* root);\\n    int height(TreeNode* root);\\n};\\n\\n/* Returns the height of the tree */\\nint Solution :: height(TreeNode* root)\\n{\\n    // If the tree is empty, diameter is 0\\n    if(!root) return 0;\\n    \\n    // Recursively calculate the height of left and right subtree\\n    int leftHeight  = height(root->left);\\n    int rightHeight = height(root->right);\\n\\n    // Update the longest path\\n    diameter = max(diameter, leftHeight + rightHeight);\\n\\n    // Return the height of the tree\\n    return max(leftHeight,rightHeight) + 1;\\n}\\n\\n/* Returns the diameter of the binary tree */\\nint Solution :: diameterOfBinaryTree(TreeNode* root)\\n{\\n    // Calculate the height and update the diameter\\n    height(root);\\n\\n    // Return the updated diameter\\n    return diameter;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    int diameter = 0;\\npublic:\\n    int diameterOfBinaryTree(TreeNode* root);\\n    int height(TreeNode* root);\\n};\\n\\n/* Returns the height of the tree */\\nint Solution :: height(TreeNode* root)\\n{\\n    // If the tree is empty, diameter is 0\\n    if(!root) return 0;\\n    \\n    // Recursively calculate the height of left and right subtree\\n    int leftHeight  = height(root->left);\\n    int rightHeight = height(root->right);\\n\\n    // Update the longest path\\n    diameter = max(diameter, leftHeight + rightHeight);\\n\\n    // Return the height of the tree\\n    return max(leftHeight,rightHeight) + 1;\\n}\\n\\n/* Returns the diameter of the binary tree */\\nint Solution :: diameterOfBinaryTree(TreeNode* root)\\n{\\n    // Calculate the height and update the diameter\\n    height(root);\\n\\n    // Return the updated diameter\\n    return diameter;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 101214,
                "title": "simple-java-recursive-solution",
                "content": "```\\nprivate int maxDiameter = 0;\\npublic int diameterOfBinaryTree(TreeNode root) {\\n    if(root==null) return 0;\\n    maxDepth(root);\\n    return this.maxDiameter;\\n}\\npublic int maxDepth(TreeNode root) {\\n    int leftDepth = root.left==null ? 0 : maxDepth(root.left)+1;\\n    int rightDepth = root.right==null ? 0 : maxDepth(root.right)+1;\\n    this.maxDiameter = Math.max(this.maxDiameter, leftDepth+rightDepth);\\n    return Math.max(leftDepth,rightDepth);\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nprivate int maxDiameter = 0;\\npublic int diameterOfBinaryTree(TreeNode root) {\\n    if(root==null) return 0;\\n    maxDepth(root);\\n    return this.maxDiameter;\\n}\\npublic int maxDepth(TreeNode root) {\\n    int leftDepth = root.left==null ? 0 : maxDepth(root.left)+1;\\n    int rightDepth = root.right==null ? 0 : maxDepth(root.right)+1;\\n    this.maxDiameter = Math.max(this.maxDiameter, leftDepth+rightDepth);\\n    return Math.max(leftDepth,rightDepth);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3217588,
                "title": "best-o-n-solution",
                "content": "# Approach 1\\nBrute-Force\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$ \\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        if (root == NULL)\\n            return 0;\\n        int lh = height(root->left);  \\n        int rh = height(root->right);   \\n        maxi = max (maxi, lh + rh);\\n        int ldiameter = diameterOfBinaryTree(root->left);\\n        int rdiameter = diameterOfBinaryTree(root->right);\\n        return max (maxi, max (ldiameter, rdiameter));\\n    }\\nprivate:\\n    int height(TreeNode* root) {\\n        if (root == NULL)\\n            return 0;\\n        int lh = height(root->left);  \\n        int rh = height(root->right); \\n        return 1 + max (lh, rh);     \\n    }    \\n};\\n```\\n# Approach 2\\nOptimal\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ \\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        int diameter = 0;\\n        height(root, diameter);\\n        return diameter;\\n    }\\nprivate:\\n    int height(TreeNode* root, int& diameter) {\\n        if (root == NULL)\\n            return 0;\\n        int lh = height(root->left, diameter);  \\n        int rh = height(root->right, diameter);   \\n        diameter = max (diameter, lh + rh);    \\n        return 1 + max (lh, rh);    \\n    } \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        if (root == NULL)\\n            return 0;\\n        int lh = height(root->left);  \\n        int rh = height(root->right);   \\n        maxi = max (maxi, lh + rh);\\n        int ldiameter = diameterOfBinaryTree(root->left);\\n        int rdiameter = diameterOfBinaryTree(root->right);\\n        return max (maxi, max (ldiameter, rdiameter));\\n    }\\nprivate:\\n    int height(TreeNode* root) {\\n        if (root == NULL)\\n            return 0;\\n        int lh = height(root->left);  \\n        int rh = height(root->right); \\n        return 1 + max (lh, rh);     \\n    }    \\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        int diameter = 0;\\n        height(root, diameter);\\n        return diameter;\\n    }\\nprivate:\\n    int height(TreeNode* root, int& diameter) {\\n        if (root == NULL)\\n            return 0;\\n        int lh = height(root->left, diameter);  \\n        int rh = height(root->right, diameter);   \\n        diameter = max (diameter, lh + rh);    \\n        return 1 + max (lh, rh);    \\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176373,
                "title": "c-solution-using-multiple-approaches",
                "content": "**APPROACH 1 : O(N^2)**\\n```\\nclass Solution {\\npublic:\\n\\n    int height(TreeNode* node){\\n\\n        if(node == NULL) return 0;\\n\\n        int h1 = height(node->left);\\n        int h2 = height(node->right);\\n\\n        return max(h1,h2)+1;\\n\\n    }\\n\\n    int dia(TreeNode* node){\\n        if(node == NULL) return 0;\\n\\n        int l = height(node->left);\\n        int r = height(node->right);\\n\\n        int op1 = dia(node->left);\\n        int op2 = dia(node->right);\\n        int op3 = l+r+1;\\n\\n        return max(op1,max(op2,op3));\\n\\n    }\\n    int diameterOfBinaryTree(TreeNode* root) {\\n\\n        int ans = dia(root); // ans gives no. of nodes , but in this ques it is asked no . of edges\\n        return ans-1;\\n       \\n    }\\n};\\n```\\n\\n**APPROACH 2 : O(N)**\\n```\\nclass Solution {\\npublic:\\n\\n    pair<int,int> dia(TreeNode* node){\\n\\n        pair<int,int> p = make_pair(0,0);\\n\\n        if(node == NULL) return p;\\n\\n        pair<int,int> left = dia(node->left);\\n        pair<int,int> right = dia(node->right);\\n\\n        int op1 = left.first;\\n        int op2 = right.first;\\n        int op3 = 1 + left.second + right.second;\\n\\n\\n        p.first =  max( op1, max(op2,op3) );\\n        p.second = 1 + max( left.second , right.second);\\n\\n        return p;\\n\\n    }\\n    int diameterOfBinaryTree(TreeNode* root) {\\n\\n        int ans = dia(root).first; // ans gives no. of nodes , but in this ques it is asked no . of edges\\n        return ans-1;\\n       \\n    }\\n};\\n```\\n\\n**APPROACH 3 : O(N)**\\n```\\nclass Solution {\\npublic:\\n\\n    int solve(TreeNode* root , int &res){\\n        if(root == NULL) return 0;\\n\\n        int l = solve(root->left , res);\\n        int r = solve(root->right , res);\\n\\n        int temp = max(l,r) + 1;\\n        int ans = max(temp , l+r+1);\\n        res = max(res,ans);\\n\\n        return temp;\\n\\n    }\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        int res = INT_MIN;\\n        solve(root,res);\\n\\n        // res gives no. of nodes , but in this ques it is asked no . of edges\\n        return res-1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int height(TreeNode* node){\\n\\n        if(node == NULL) return 0;\\n\\n        int h1 = height(node->left);\\n        int h2 = height(node->right);\\n\\n        return max(h1,h2)+1;\\n\\n    }\\n\\n    int dia(TreeNode* node){\\n        if(node == NULL) return 0;\\n\\n        int l = height(node->left);\\n        int r = height(node->right);\\n\\n        int op1 = dia(node->left);\\n        int op2 = dia(node->right);\\n        int op3 = l+r+1;\\n\\n        return max(op1,max(op2,op3));\\n\\n    }\\n    int diameterOfBinaryTree(TreeNode* root) {\\n\\n        int ans = dia(root); // ans gives no. of nodes , but in this ques it is asked no . of edges\\n        return ans-1;\\n       \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\n    pair<int,int> dia(TreeNode* node){\\n\\n        pair<int,int> p = make_pair(0,0);\\n\\n        if(node == NULL) return p;\\n\\n        pair<int,int> left = dia(node->left);\\n        pair<int,int> right = dia(node->right);\\n\\n        int op1 = left.first;\\n        int op2 = right.first;\\n        int op3 = 1 + left.second + right.second;\\n\\n\\n        p.first =  max( op1, max(op2,op3) );\\n        p.second = 1 + max( left.second , right.second);\\n\\n        return p;\\n\\n    }\\n    int diameterOfBinaryTree(TreeNode* root) {\\n\\n        int ans = dia(root).first; // ans gives no. of nodes , but in this ques it is asked no . of edges\\n        return ans-1;\\n       \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\n    int solve(TreeNode* root , int &res){\\n        if(root == NULL) return 0;\\n\\n        int l = solve(root->left , res);\\n        int r = solve(root->right , res);\\n\\n        int temp = max(l,r) + 1;\\n        int ans = max(temp , l+r+1);\\n        res = max(res,ans);\\n\\n        return temp;\\n\\n    }\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        int res = INT_MIN;\\n        solve(root,res);\\n\\n        // res gives no. of nodes , but in this ques it is asked no . of edges\\n        return res-1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3123024,
                "title": "java-recursive-approach-using-dfs-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe will use what we learned in the max & min depth tree problems to calculate the height (The max # of levels from the root node). \\nAnother way to think of the diameter is similar to the diameter of a circle. So, in this problem, the left and right subtrees are the radius\\' and you add them together to get the diameter. (might not be the best example, but it\\'s more for understanding)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We need to declare a global diameter variable.\\n2. We need a base case to check if the root node is equal to null. If it is, then we return 0. \\n3. We need to call up a DFS method and pass in the root to calculate the height & max diameter.\\n4. Once a DFS method is created, we need to check to see if the current node we are at is equal to null. If it is, then we return -1. The reason we return -1 is to simplify calculation of the diameter. So, null nodes are -1 and non-null nodes are 0. \\n5. We need to declare variables to store the heights of the left & right recursive calls. \\n6. We will compute the max diameter by taking the max of the current diameter and the new diameter calculation (left height + right height + 2). The 2 in the diameter calculation represents the number of edges a node has. \\n7. We return the height of the root node by taking the max of the left subtree and right subtree. We add 1 to compensate for the root node level. \\n8. Finally, we return the max diameter.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) - we visit every node of the tree\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    //step 1\\n    int diameter=0;\\n    public int diameterOfBinaryTree(TreeNode root) {\\n        //step 2\\n        if(root==null) return 0;\\n        //step 3\\n        DFS(root);\\n        //step 8\\n        return diameter;\\n    }\\n\\n    public int DFS(TreeNode root){\\n        //step 4\\n        if(root==null) return -1;\\n        //step 5\\n        int left = DFS(root.left);\\n        int right = DFS(root.right);\\n        //step 6\\n        diameter = Math.max(diameter, left + right + 2);\\n        //step 7\\n        return 1 + Math.max(left, right);\\n    }\\n}\\n```\\n***Thank you for reading! If you found this solution helpful, please give me an upvote. Feel free to add suggestions.***",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    //step 1\\n    int diameter=0;\\n    public int diameterOfBinaryTree(TreeNode root) {\\n        //step 2\\n        if(root==null) return 0;\\n        //step 3\\n        DFS(root);\\n        //step 8\\n        return diameter;\\n    }\\n\\n    public int DFS(TreeNode root){\\n        //step 4\\n        if(root==null) return -1;\\n        //step 5\\n        int left = DFS(root.left);\\n        int right = DFS(root.right);\\n        //step 6\\n        diameter = Math.max(diameter, left + right + 2);\\n        //step 7\\n        return 1 + Math.max(left, right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3045517,
                "title": "c-o-n-very-short-n-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust use the concept of finding  the height of tree . And in case of diameter check at each node where height of left subtree + right subtree is maximum.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUpdate the dis with max at each step  using:\\n` dis=max(dis,l+r);`\\nheight of left subtree:\\n```\\nint l =height(root->left,dis);\\n```\\nheight of right subtree\\n```\\nint r =height(root->right,dis);\\n\\n```\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nint height(TreeNode*root,int &dis){\\n    if(!root)return 0;\\n    int l =height(root->left,dis);\\n    int r =height(root->right,dis);\\n     dis=max(dis,l+r);\\n     return max(l,r)+1;\\n}\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        if(!root)return 0;\\n        int dis=0;\\n        height(root,dis);\\n        return dis;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nint l =height(root->left,dis);\\n```\n```\\nint r =height(root->right,dis);\\n\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nint height(TreeNode*root,int &dis){\\n    if(!root)return 0;\\n    int l =height(root->left,dis);\\n    int r =height(root->right,dis);\\n     dis=max(dis,l+r);\\n     return max(l,r)+1;\\n}\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        if(!root)return 0;\\n        int dis=0;\\n        height(root,dis);\\n        return dis;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3044202,
                "title": "simple-c-recursive",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nActually find the height of left subtree and right subtree at each node then keep the max count stored and return that.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAt each step return the  maximum height of left subtree+right subtree .\\n# Complexity\\n- Time complexity:O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint height(TreeNode*root){\\n    if(!root)return 0;\\n    int l=height(root->left);\\n    int r=height(root->right);\\n    return max(l,r)+1;\\n}\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        if(!root)return 0;\\n        int l=height(root->left);\\n        int r=height(root->right);\\n        int ld=diameterOfBinaryTree(root->left);\\n        int rd=diameterOfBinaryTree(root->right);\\n        return max({l+r,ld,rd});\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint height(TreeNode*root){\\n    if(!root)return 0;\\n    int l=height(root->left);\\n    int r=height(root->right);\\n    return max(l,r)+1;\\n}\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        if(!root)return 0;\\n        int l=height(root->left);\\n        int r=height(root->right);\\n        int ld=diameterOfBinaryTree(root->left);\\n        int rd=diameterOfBinaryTree(root->right);\\n        return max({l+r,ld,rd});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3041457,
                "title": "c-o-n-soln",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int height(TreeNode* root, int& ans)\\n    {\\n        if(root == NULL)\\n        return 0;\\n        int left = height(root->left, ans);\\n        int right = height(root->right, ans);\\n        ans = max(ans, 1 + left + right);\\n        return 1 + max(left, right);  \\n    }\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        int ans = 0;\\n        if(root == NULL)\\n        return 0;\\n        height(root, ans);\\n        return ans - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int height(TreeNode* root, int& ans)\\n    {\\n        if(root == NULL)\\n        return 0;\\n        int left = height(root->left, ans);\\n        int right = height(root->right, ans);\\n        ans = max(ans, 1 + left + right);\\n        return 1 + max(left, right);  \\n    }\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        int ans = 0;\\n        if(root == NULL)\\n        return 0;\\n        height(root, ans);\\n        return ans - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2539848,
                "title": "simple-java-solution-recursive",
                "content": "```\\nclass Solution {\\n    public int diameterOfBinaryTree(TreeNode root) {\\n        if (root == null) return 0;\\n        int dia1 = diameterOfBinaryTree(root.right);\\n        int dia2 = diameterOfBinaryTree(root.left);\\n        int dia3 = depth(root.left) + depth(root.right);\\n        return Math.max(dia3, Math.max(dia1, dia2));\\n    }\\n    \\n    public int depth (TreeNode root) {\\n        if (root == null) return 0;\\n        int leftone = depth(root.left);\\n        int rightone = depth(root.right);\\n        return Math.max(leftone, rightone) + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int diameterOfBinaryTree(TreeNode root) {\\n        if (root == null) return 0;\\n        int dia1 = diameterOfBinaryTree(root.right);\\n        int dia2 = diameterOfBinaryTree(root.left);\\n        int dia3 = depth(root.left) + depth(root.right);\\n        return Math.max(dia3, Math.max(dia1, dia2));\\n    }\\n    \\n    public int depth (TreeNode root) {\\n        if (root == null) return 0;\\n        int leftone = depth(root.left);\\n        int rightone = depth(root.right);\\n        return Math.max(leftone, rightone) + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2222455,
                "title": "recursive-dfs-solution-in-python-with-detailed-comments-explanation",
                "content": "For those struggling to understand the top-voted solutions like I did, here\\'s a different way to think about it.\\n\\nIntuitively, it didn\\'t make sense to me how to account for depth vs height (or even what the difference between the two were), why an empty node was -1 and not 0, etc. \\n\\nBut everything sort of clicked for me when I reframed the question as simply:\\n1. finding the longest path in the tree using dfs\\n2. counting the nodes along that path\\n3. subtracting 1 to get the number of edges. \\n\\nI\\'ll assume y\\'all are familiar with what a dfs (depth-first search) is, though for those that aren\\'t, it\\'s where you basically count from the bottom-up. \\n\\nThe key insight to this then is simply recognizing that the number of edges along a given path is ALWAYS exactly one less than the number of nodes along that same path.\\n\\nWith that said, hopefully this solution helps!\\n\\nPs, if you\\'re still struggling to understand this solution, try implementing it on [Problem #104 (Maximum Depth of a Binary Tree)](https://leetcode.com/problems/maximum-depth-of-binary-tree/), using this exact framework.\\n\\n```\\nclass Solution:\\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        # Initialize a variable to keep track of the max diameter as we recursively traverse through each node in the tree\\n        max_diameter = 0\\n        # Define a depth-first search function to count the number of nodes along a given path, including the current node\\n        def dfs(node):\\n            # Use the nonlocal keyword to access the max_diameter parameter\\n            nonlocal max_diameter\\n            # If the current node is null, return 0\\n            if not node:\\n                return 0\\n            # Otherwise, recursively call the function on the left and right child nodes \\n            left, right = dfs(node.left), dfs(node.right)\\n            # Update max_diameter if the current diameter is greater than max_diameter \\n\\t\\t\\t# Note, we don\\'t need to account for the current node in our current diameter, \\n\\t\\t\\t# since the diameter is defined as the number of edges, \\n\\t\\t\\t# which is always 1 less than the number of nodes)\\n            max_diameter = max(max_diameter, left + right)\\n            # Return the current node count by taking the subtree with the greater number of nodes, and adding 1 to account for itself\\n            return 1 + max(left, right)\\n        # Call the depth-first search function on the current head node\\n        dfs(root)\\n        # Return the max_diameter parameter\\n        return max_diameter\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        # Initialize a variable to keep track of the max diameter as we recursively traverse through each node in the tree\\n        max_diameter = 0\\n        # Define a depth-first search function to count the number of nodes along a given path, including the current node\\n        def dfs(node):\\n            # Use the nonlocal keyword to access the max_diameter parameter\\n            nonlocal max_diameter\\n            # If the current node is null, return 0\\n            if not node:\\n                return 0\\n            # Otherwise, recursively call the function on the left and right child nodes \\n            left, right = dfs(node.left), dfs(node.right)\\n            # Update max_diameter if the current diameter is greater than max_diameter \\n\\t\\t\\t# Note, we don\\'t need to account for the current node in our current diameter, \\n\\t\\t\\t# since the diameter is defined as the number of edges, \\n\\t\\t\\t# which is always 1 less than the number of nodes)\\n            max_diameter = max(max_diameter, left + right)\\n            # Return the current node count by taking the subtree with the greater number of nodes, and adding 1 to account for itself\\n            return 1 + max(left, right)\\n        # Call the depth-first search function on the current head node\\n        dfs(root)\\n        # Return the max_diameter parameter\\n        return max_diameter\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1667695,
                "title": "python-simple-recursive-dfs-explained",
                "content": "```\\nclass Solution:\\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        self.diameter = 0\\n            \\n        def dfs(root):\\n            if not root: return 0\\n            leftLongestPath = dfs(root.left)\\n            rightLongestPath = dfs(root.right)\\n            \\n            # keep track of the longest path that goes through the current\\n            # node i.e. the longest path from it\\'s left child to leaf\\n            # through to its right child to a leaf and return that\\n            self.diameter = max(self.diameter, (leftLongestPath + rightLongestPath))\\n            \\n            # this is the standard recursive procedure\\n            # for calculating maximum height for a tree\\n            # i.e. longest path recursively from either \\n            # left or right subtree + 1 for the current\\n            # level. For instance, if there\\'s just one node\\n            # we\\'ll check its left and right subtree, both of\\n            # which will return 0 from our base condition\\n            # and then max(0, 0) + 1 => 1 the correct height\\n            return max(leftLongestPath, rightLongestPath) + 1\\n        \\n        dfs(root)\\n        return self.diameter\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        self.diameter = 0\\n            \\n        def dfs(root):\\n            if not root: return 0\\n            leftLongestPath = dfs(root.left)\\n            rightLongestPath = dfs(root.right)\\n            \\n            # keep track of the longest path that goes through the current\\n            # node i.e. the longest path from it\\'s left child to leaf\\n            # through to its right child to a leaf and return that\\n            self.diameter = max(self.diameter, (leftLongestPath + rightLongestPath))\\n            \\n            # this is the standard recursive procedure\\n            # for calculating maximum height for a tree\\n            # i.e. longest path recursively from either \\n            # left or right subtree + 1 for the current\\n            # level. For instance, if there\\'s just one node\\n            # we\\'ll check its left and right subtree, both of\\n            # which will return 0 from our base condition\\n            # and then max(0, 0) + 1 => 1 the correct height\\n            return max(leftLongestPath, rightLongestPath) + 1\\n        \\n        dfs(root)\\n        return self.diameter\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1516409,
                "title": "typescript-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * class TreeNode {\\n *     val: number\\n *     left: TreeNode | null\\n *     right: TreeNode | null\\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.left = (left===undefined ? null : left)\\n *         this.right = (right===undefined ? null : right)\\n *     }\\n * }\\n */\\n\\nfunction diameterOfBinaryTree(root: TreeNode | null): number {\\n    let ans = 0\\n    function dfs(node: TreeNode | null): number {\\n        if (node === null) {\\n            return 0;\\n        }\\n        let left = dfs(node.left);\\n        let right = dfs(node.right);\\n        ans = Math.max(ans, left + right);\\n\\n        return Math.max(left, right) + 1;\\n    }\\n    dfs(root);\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * class TreeNode {\\n *     val: number\\n *     left: TreeNode | null\\n *     right: TreeNode | null\\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.left = (left===undefined ? null : left)\\n *         this.right = (right===undefined ? null : right)\\n *     }\\n * }\\n */\\n\\nfunction diameterOfBinaryTree(root: TreeNode | null): number {\\n    let ans = 0\\n    function dfs(node: TreeNode | null): number {\\n        if (node === null) {\\n            return 0;\\n        }\\n        let left = dfs(node.left);\\n        let right = dfs(node.right);\\n        ans = Math.max(ans, left + right);\\n\\n        return Math.max(left, right) + 1;\\n    }\\n    dfs(root);\\n    return ans;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1516136,
                "title": "easy-c-solution",
                "content": "**UPVOTE IS U LIKE**\\n\\nclass Solution {\\npublic:\\n    \\n    int d = 0;\\n    \\n    int solve(TreeNode* root)\\n    {\\n        if(root == NULL) return 0;\\n        \\n        int l = solve(root->left);\\n        int r = solve(root->right);\\n        \\n        \\n        d = max(d , l+r+1);\\n        \\n        return max(l,r)+1;\\n    }\\n    \\n    int diameterOfBinaryTree(TreeNode* root) {\\n        \\n        solve(root);\\n        return d-1;\\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    int d = 0;\\n    \\n    int solve(TreeNode* root)\\n    {\\n        if(root == NULL) return 0;\\n        \\n        int l = solve(root->left);\\n        int r = solve(root->right);\\n        \\n        \\n        d = max(d , l+r+1);\\n        \\n        return max(l,r)+1;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1224226,
                "title": "c-easy-to-understand-straight-forward-recursive-solution",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)**\\nclass Solution {\\npublic:\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        if(root==NULL)\\n         return 0;\\n        \\n     int option1=height(root->left)+height(root->right);\\n     int option2=diameterOfBinaryTree(root->left);\\n     int option3=diameterOfBinaryTree(root->right);\\n        return max(option1,max(option2,option3));\\n    }\\n    int height(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        {\\n            return 0;\\n        }\\n        return 1+max(height(root->left),height(root->right));\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        if(root==NULL)\\n         return 0;\\n        \\n     int option1=height(root->left)+height(root->right);\\n     int option2=diameterOfBinaryTree(root->left);\\n     int option3=diameterOfBinaryTree(root->right);\\n        return max(option1,max(option2,option3));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 935354,
                "title": "python-kadane-s-algorithm",
                "content": "The algorithm is a variant of Kadane\\'s algorithm.\\n1. base case:\\n\\t- max is -inf, local mx is 0\\n2. maintain a global and local max\\n\\t- global max computes the global maximum of the entire tree: max(max from left, max from right, passing through the CURRENT root and using both left and right branches)\\n\\t\\t- `global_mx = max(left_global, right_global, 1 + left_local + right_local)`\\n\\t- local max holds the value of using the current root and the max branch from left or right (this value can be included on a path from a higher parent in the tree)\\n\\t\\t- `local_mx = 1 + max(left_local, right_local)`\\n3. At the end, we subtract 1 from the global max as we double count the root when we take `global_mx = max(left_global, right_global, 1 + left_local + right_local)`\\n```\\nclass Solution:\\n    def diameterOfBinaryTree(self, root: TreeNode) -> int:\\n        def depth(root):\\n            if not root:\\n                return float(\\'-inf\\'), 0\\n            left_global, left_local = depth(root.left)\\n            right_global, right_local = depth(root.right)\\n            global_mx = max(left_global, right_global, 1 + left_local + right_local)\\n            local_mx = 1 + max(left_local, right_local)\\n            return global_mx, local_mx\\n        if not root: \\n            return 0\\n        global_mx, local_mx = depth(root)\\n        return global_mx - 1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def diameterOfBinaryTree(self, root: TreeNode) -> int:\\n        def depth(root):\\n            if not root:\\n                return float(\\'-inf\\'), 0\\n            left_global, left_local = depth(root.left)\\n            right_global, right_local = depth(root.right)\\n            global_mx = max(left_global, right_global, 1 + left_local + right_local)\\n            local_mx = 1 + max(left_local, right_local)\\n            return global_mx, local_mx\\n        if not root: \\n            return 0\\n        global_mx, local_mx = depth(root)\\n        return global_mx - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 408017,
                "title": "python-recursive-solution",
                "content": "```\\ndef diameterOfBinaryTree(self, root: TreeNode) -> int:\\n        h=0\\n        if not root:\\n            return 0\\n        def height(node):\\n            if not node:\\n                return 0\\n            left=height(node.left)# left subtree height\\n            right=height(node.right) # right subtree height\\n            if left>right:\\n                h=1+left\\n            else:\\n                h=1+right\\n            return h\\n        leftheight=height(root.left)#0\\n        rightheight=height(root.right)#0\\n        ldiameter=self.diameterOfBinaryTree(root.left)#0\\n        rdiameter=self.diameterOfBinaryTree(root.right)#0\\n        return max(leftheight+rightheight,max(ldiameter,rdiameter)) \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef diameterOfBinaryTree(self, root: TreeNode) -> int:\\n        h=0\\n        if not root:\\n            return 0\\n        def height(node):\\n            if not node:\\n                return 0\\n            left=height(node.left)# left subtree height\\n            right=height(node.right) # right subtree height\\n            if left>right:\\n                h=1+left\\n            else:\\n                h=1+right\\n            return h\\n        leftheight=height(root.left)#0\\n        rightheight=height(root.right)#0\\n        ldiameter=self.diameterOfBinaryTree(root.left)#0\\n        rdiameter=self.diameterOfBinaryTree(root.right)#0\\n        return max(leftheight+rightheight,max(ldiameter,rdiameter)) \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3923310,
                "title": "diameter-of-binary-tree-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int getdiameter(TreeNode* root, int &diameter)\\n    {\\n        if(root==NULL)\\n            return 0;\\n        \\n        int lh = getdiameter(root->left, diameter);\\n        int rh = getdiameter(root->right, diameter);\\n\\n        diameter = max(diameter, lh+rh);\\n        return max(lh, rh)+1;\\n    }\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        int diameter=0;\\n        getdiameter(root, diameter);\\n        return diameter;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/bb6b2c0a-84e9-43b9-bd47-286f00dda507_1692289570.3362932.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int getdiameter(TreeNode* root, int &diameter)\\n    {\\n        if(root==NULL)\\n            return 0;\\n        \\n        int lh = getdiameter(root->left, diameter);\\n        int rh = getdiameter(root->right, diameter);\\n\\n        diameter = max(diameter, lh+rh);\\n        return max(lh, rh)+1;\\n    }\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        int diameter=0;\\n        getdiameter(root, diameter);\\n        return diameter;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3726054,
                "title": "smart-approach",
                "content": "```\\nclass Solution:\\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        ans=0\\n        def dia(root):\\n            nonlocal ans\\n            if not root:\\n                return 0\\n            left=dia(root.left)\\n            right=dia(root.right)\\n            ans=max(ans,left+right)\\n            return 1+max(right,left)\\n        dia(root)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        ans=0\\n        def dia(root):\\n            nonlocal ans\\n            if not root:\\n                return 0\\n            left=dia(root.left)\\n            right=dia(root.right)\\n            ans=max(ans,left+right)\\n            return 1+max(right,left)\\n        dia(root)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3637169,
                "title": "c-recursive-easy-understanding",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe diameter can come from the -:\\n- The **left subtree** alone\\n```\\n        int op1 = diameterOfBinaryTree(root -> left) ; \\n\\n```\\n- The **right subtree** alone\\n```\\n        int op2 = diameterOfBinaryTree(root -> right) ; \\n\\n```\\n- OR from the **combination of left & right subtree**\\n```\\n        int op3 = height(root -> left) + height (root -> right) ; \\n\\n```\\n\\nWe find the individual diameters in all these cases & the ***maximum out of these 3 will be the final diameter of the tree***\\n```\\n        return max(op1, max(op2, op3)) ; \\n\\n```\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nint height (TreeNode* root)\\n{\\n    if (root == NULL)\\n    {\\n        return 0 ; \\n    }\\n    int left = height(root -> left) ; \\n    int right = height(root -> right) ;\\n\\n    return max(left, right) + 1 ;\\n}\\n\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        if (root == NULL)\\n        {\\n            return 0 ; \\n        }\\n\\n        int op1 = diameterOfBinaryTree(root -> left) ; \\n        int op2 = diameterOfBinaryTree(root -> right) ; \\n        int op3 = height(root -> left) + height (root -> right) ; \\n\\n        return max(op1, max(op2, op3)) ; \\n    }\\n};\\n```\\n![815a317f-9cdf-46e2-a397-af8869dafa2e_1673498197.3721023.png](https://assets.leetcode.com/users/images/b5bfff15-97d7-4e09-a25f-26c0295d278e_1686744075.2895732.png)\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n        int op1 = diameterOfBinaryTree(root -> left) ; \\n\\n```\n```\\n        int op2 = diameterOfBinaryTree(root -> right) ; \\n\\n```\n```\\n        int op3 = height(root -> left) + height (root -> right) ; \\n\\n```\n```\\n        return max(op1, max(op2, op3)) ; \\n\\n```\n```C++ []\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nint height (TreeNode* root)\\n{\\n    if (root == NULL)\\n    {\\n        return 0 ; \\n    }\\n    int left = height(root -> left) ; \\n    int right = height(root -> right) ;\\n\\n    return max(left, right) + 1 ;\\n}\\n\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        if (root == NULL)\\n        {\\n            return 0 ; \\n        }\\n\\n        int op1 = diameterOfBinaryTree(root -> left) ; \\n        int op2 = diameterOfBinaryTree(root -> right) ; \\n        int op3 = height(root -> left) + height (root -> right) ; \\n\\n        return max(op1, max(op2, op3)) ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3486492,
                "title": "java",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    private int depth = 0;\\n    public int diameterOfBinaryTree(TreeNode root) {\\n\\n        dfs(root);\\n\\n        return depth;        \\n    }\\n\\n    private int dfs(TreeNode node) {\\n        if (node == null) {\\n            return 0;\\n        }\\n\\n        int left = dfs(node.left);\\n        int right = dfs(node.right);\\n\\n        depth = Math.max(depth, left + right);\\n\\n        return Math.max(right, left) + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    private int depth = 0;\\n    public int diameterOfBinaryTree(TreeNode root) {\\n\\n        dfs(root);\\n\\n        return depth;        \\n    }\\n\\n    private int dfs(TreeNode node) {\\n        if (node == null) {\\n            return 0;\\n        }\\n\\n        int left = dfs(node.left);\\n        int right = dfs(node.right);\\n\\n        depth = Math.max(depth, left + right);\\n\\n        return Math.max(right, left) + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3389878,
                "title": "best-and-easy-solution-100",
                "content": "\\n\\n# Code\\n```\\n\\nclass Solution {\\n    int ans=0;\\n    public int diameterOfBinaryTree(TreeNode root) {\\n        height(root);\\n        return ans-1;\\n    }\\n\\n    public int height( TreeNode root) {\\n        if(root==null)return 0;\\n        int lh = height(root.left);\\n        int rh = height(root.right);\\n        ans = Math.max(ans, lh+rh+1);\\n        return Math.max(lh,rh)+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n\\nclass Solution {\\n    int ans=0;\\n    public int diameterOfBinaryTree(TreeNode root) {\\n        height(root);\\n        return ans-1;\\n    }\\n\\n    public int height( TreeNode root) {\\n        if(root==null)return 0;\\n        int lh = height(root.left);\\n        int rh = height(root.right);\\n        ans = Math.max(ans, lh+rh+1);\\n        return Math.max(lh,rh)+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3293294,
                "title": "java-dfs-beats-100-8-lines",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ on the stack\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int ans = 0;\\n\\n  private int dfs(TreeNode node) {\\n    if (node == null) return 0;\\n\\n    var left = dfs(node.left);\\n    var right = dfs(node.right);\\n\\n    ans = Math.max(ans, left + right);\\n    return 1 + Math.max(left, right);\\n  }\\n\\n  public int diameterOfBinaryTree(TreeNode root) {\\n    dfs(root);\\n    return ans;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n  int ans = 0;\\n\\n  private int dfs(TreeNode node) {\\n    if (node == null) return 0;\\n\\n    var left = dfs(node.left);\\n    var right = dfs(node.right);\\n\\n    ans = Math.max(ans, left + right);\\n    return 1 + Math.max(left, right);\\n  }\\n\\n  public int diameterOfBinaryTree(TreeNode root) {\\n    dfs(root);\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141387,
                "title": "c-97-faster-recursion-clear-explanation",
                "content": "# Intuition\\nBottom-up approach.\\n\\n![image.png](https://assets.leetcode.com/users/images/ab8e3f47-ad4d-44b4-905e-e230f4dff7e4_1675523140.2333436.png)\\n\\nTake a look at this tree. The diameter is the orange path. \\n\\n**Observation 1:** Every path that is a possible diameter must have three components: left path, right path, and a connecting node between left path and right path. In our case, left path has 4 nodes, right path has 1 node, and the connecting node is the tree root.\\n\\n**Observation 2:** The left path is the longest path on the left. Same for the right path.\\n\\n# Approach\\n\\nThus, to find the diameter of the tree, we repeatedly do these steps:\\n- Find left subtree\\'s longest path.\\n- Find right subtree\\'s longest path.\\n- Calculate current tree\\'s diameter (current tree could be yet another subtree, or the whole tree): left longest path + right longest path + 1 (connecting node, aka current tree\\'s root). Update max if diameter > max.\\n- Return max(left longest path, right longest path) + 1. That is the longest path of this current tree, which the parent node of the current tree could use to continue the calculation.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n Helper takes constant time O(1). There are roughly n total calls of Helper(each call triggers 2 more calls for left and right children and this process only stop when encoutering null, which is basically equivalent to traversing the tree from top to bottom). O(1) x O(n) = O(n).\\n\\n- Space complexity: $$O(n)$$\\nHelper takes constant space O(1). There may be a maximum of roughly n stacks for n recursive calls. O(1) x O(n) = O(n).\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    int max = 0;\\n    public int DiameterOfBinaryTree(TreeNode root) {\\n        this.Helper(root);\\n        return max;\\n    }\\n\\n    public int Helper(TreeNode root) {\\n        if (root==null) return 0;\\n        int left = this.Helper(root.left);\\n        int right = this.Helper(root.right);\\n        max = Math.Max(max, left+right);\\n        return Math.Max(left, right) + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    int max = 0;\\n    public int DiameterOfBinaryTree(TreeNode root) {\\n        this.Helper(root);\\n        return max;\\n    }\\n\\n    public int Helper(TreeNode root) {\\n        if (root==null) return 0;\\n        int left = this.Helper(root.left);\\n        int right = this.Helper(root.right);\\n        max = Math.Max(max, left+right);\\n        return Math.Max(left, right) + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2373744,
                "title": "c-easy-explanation-recursion-unoptimized-optimized-3-ways",
                "content": "# Ist Way\\n- This is a simple `brute force solution`. Its **TC is O(N^2)** and **SC is O(N)**.\\n- In this method we are traversing a node two times ,\\n\\t- First time for finding the height.\\n\\t- Second time for finding diameter.\\n\\n### Implementation\\n```cpp\\nint Height(TreeNode *root)\\n{\\n    if (root == NULL)\\n        return 0;\\n    return 1 + max(Height(root->left), Height(root->right));\\n}\\nint diameterOfBinaryTree(TreeNode *root)\\n{\\n    if (root == NULL)\\n        return 0;\\n    int lh = Height(root->left);\\n    int rh = Height(root->right);\\n    return max(lh + rh, max(diameterOfBinaryTree(root->left), diameterOfBinaryTree(root->right)));\\n}\\n```\\n- **Note :-** Normally `we add 1 in return of diameterOfBinaryTree()` i.e. *1+lh+rh* in place of *lh+rh*. But here according to the question we are taking root level as 0 and hence we are not couting it separately in diameter.\\n# 2nd Way\\n- While optimising the first way we will **create a hashmap** for ***precomputing the heights*** of respective subtree in the process by calling Height() function.\\n - This way in the diameterOfBinaryTree() function we can access the `height of subtree in O(1) time.` And we don\\'t have to call the Height() function for calculating height while calculating diameter.\\n - Now this becomes a normal tree traversal function for finding max value.\\n - **TC will be O(N)** but there will be **extra O(N) besides the O(N) due to recursive callstacks** space for storing in a hashmap and there will be **extra overhead** for looking in the hashtable and storing in the hashtable.\\n \\n # 3rd Way\\n - This is the **Most optimized solution** . Its **TC is O(N)** and **SC is O(N){recursive calls}**.\\n - In this solution we are calculating **height and diameter simultaneously** without having to traverse again and again.\\n ### Implementation\\n```cpp\\nint result = 0;\\nint modifiedHeight(TreeNode *root)\\n{\\n    // This is the modified Height formula where we are calculating\\n    // height and checking diameter simultaneously\\n    if (root == NULL)\\n        return 0;\\n    int lh = modifiedHeight(root->left);\\n    // Height of left subtree\\n    int rh = modifiedHeight(root->right);\\n    // Height of right subtree\\n    result = max(result,lh + rh);\\n    // Calculating max diameter\\n    return 1 + max(lh, rh);\\n    // Calculating height\\n}\\nint diameterOfBinaryTree(TreeNode *root)\\n{\\n    modifiedHeight(root);\\n    return result;\\n}\\n```\\n**Thank You!** for reading . Do upvote\\uD83D\\uDC4Dif you like the explanation and if there is any scope of improvement do mention in the comments\\uD83D\\uDE01.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```cpp\\nint Height(TreeNode *root)\\n{\\n    if (root == NULL)\\n        return 0;\\n    return 1 + max(Height(root->left), Height(root->right));\\n}\\nint diameterOfBinaryTree(TreeNode *root)\\n{\\n    if (root == NULL)\\n        return 0;\\n    int lh = Height(root->left);\\n    int rh = Height(root->right);\\n    return max(lh + rh, max(diameterOfBinaryTree(root->left), diameterOfBinaryTree(root->right)));\\n}\\n```\n```cpp\\nint result = 0;\\nint modifiedHeight(TreeNode *root)\\n{\\n    // This is the modified Height formula where we are calculating\\n    // height and checking diameter simultaneously\\n    if (root == NULL)\\n        return 0;\\n    int lh = modifiedHeight(root->left);\\n    // Height of left subtree\\n    int rh = modifiedHeight(root->right);\\n    // Height of right subtree\\n    result = max(result,lh + rh);\\n    // Calculating max diameter\\n    return 1 + max(lh, rh);\\n    // Calculating height\\n}\\nint diameterOfBinaryTree(TreeNode *root)\\n{\\n    modifiedHeight(root);\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2332098,
                "title": "simple-python-recursive-solution",
                "content": "Easy to understand and neat code but slow\\n\\n```class Solution:\\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        if root == None:\\n            return 0\\n        def height(node):\\n            if node == None:\\n                return 0\\n            return max(height(node.left),height(node.right)) + 1 \\n        \\n        return max(height(root.left) + height(root.right),self.diameterOfBinaryTree(root.left),self.diameterOfBinaryTree(root.right))",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "Easy to understand and neat code but slow\\n\\n```class Solution:\\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        if root == None:\\n            return 0\\n        def height(node):\\n            if node == None:\\n                return 0\\n            return max(height(node.left),height(node.right)) + 1 \\n        \\n        return max(height(root.left) + height(root.right),self.diameterOfBinaryTree(root.left),self.diameterOfBinaryTree(root.right))",
                "codeTag": "Java"
            },
            {
                "id": 2128444,
                "title": "go-dfs-clear-solution",
                "content": "```\\nfunc diameterOfBinaryTree(root *TreeNode) int {\\n    max := 0\\n    var dfs func(node *TreeNode) int\\n    dfs = func(node *TreeNode) int {\\n        if node == nil { return 0 }\\n        left, right := dfs(node.Left), dfs(node.Right)\\n        max = Max(max, left+right)\\n        return 1+Max(left, right)\\n    }\\n    dfs(root)\\n    return max\\n}\\n\\nfunc Max(a, b int) int { if a > b { return a }; return b }\\n```",
                "solutionTags": [
                    "Go",
                    "Depth-First Search"
                ],
                "code": "```\\nfunc diameterOfBinaryTree(root *TreeNode) int {\\n    max := 0\\n    var dfs func(node *TreeNode) int\\n    dfs = func(node *TreeNode) int {\\n        if node == nil { return 0 }\\n        left, right := dfs(node.Left), dfs(node.Right)\\n        max = Max(max, left+right)\\n        return 1+Max(left, right)\\n    }\\n    dfs(root)\\n    return max\\n}\\n\\nfunc Max(a, b int) int { if a > b { return a }; return b }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2041610,
                "title": "javascript-recursive-clean-code",
                "content": "```\\nvar diameterOfBinaryTree = function (root) {\\n    let dia = 0;\\n    function helper(root) {\\n        if (!root) return -1;\\n\\n        const lh = 1 + helper(root.left);\\n        const rh = 1 + helper(root.right);\\n        dia = Math.max(dia, lh + rh);\\n        return Math.max(lh, rh);\\n    }\\n    helper(root);\\n    return dia;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar diameterOfBinaryTree = function (root) {\\n    let dia = 0;\\n    function helper(root) {\\n        if (!root) return -1;\\n\\n        const lh = 1 + helper(root.left);\\n        const rh = 1 + helper(root.right);\\n        dia = Math.max(dia, lh + rh);\\n        return Math.max(lh, rh);\\n    }\\n    helper(root);\\n    return dia;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1965263,
                "title": "java-o-n-time-complexity-0ms-100-faster",
                "content": "```\\nclass Solution {\\n    int max = 0;\\n    // The diamater is left height + right height \\n    // The height is Math.max(left height, right height) + 1\\n    public int diameterOfBinaryTree(TreeNode root) {\\n        height(root);\\n        return max;\\n    }\\n    public int height(TreeNode root) {\\n        if (root == null) return 0;\\n        int left = height(root.left);\\n        int right = height(root.right);\\n        max = Math.max(left + right, max);\\n        return 1 + Math.max(left, right);\\n    }\\n}\\n```\\nThey may ask not to put max as a property of a class. Unlike c# or c++, java does not allow pass parameter by reference for primitive values. So we can create a wrapper.\\n```\\nclass Solution {\\n    // The diamater is left + right height \\n    // The height is Math.max(left, right) + 1\\n    public int diameterOfBinaryTree(TreeNode root) {\\n        if (root == null) return 0;\\n        Self<Integer> max = new Self(0);\\n        height(root, max);\\n        return max.v;\\n    }\\n    private int height(TreeNode root, Self<Integer> max) {\\n        if (root == null) return 0;\\n        int left = height(root.left, max);\\n        int right = height(root.right, max);\\n        max.v = Math.max(left + right, max.v);\\n        return 1 + Math.max(left, right);\\n    }\\n    public class Self<E> {\\n        public E v;\\n        public Self(E e) {\\n            v = e;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int max = 0;\\n    // The diamater is left height + right height \\n    // The height is Math.max(left height, right height) + 1\\n    public int diameterOfBinaryTree(TreeNode root) {\\n        height(root);\\n        return max;\\n    }\\n    public int height(TreeNode root) {\\n        if (root == null) return 0;\\n        int left = height(root.left);\\n        int right = height(root.right);\\n        max = Math.max(left + right, max);\\n        return 1 + Math.max(left, right);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    // The diamater is left + right height \\n    // The height is Math.max(left, right) + 1\\n    public int diameterOfBinaryTree(TreeNode root) {\\n        if (root == null) return 0;\\n        Self<Integer> max = new Self(0);\\n        height(root, max);\\n        return max.v;\\n    }\\n    private int height(TreeNode root, Self<Integer> max) {\\n        if (root == null) return 0;\\n        int left = height(root.left, max);\\n        int right = height(root.right, max);\\n        max.v = Math.max(left + right, max.v);\\n        return 1 + Math.max(left, right);\\n    }\\n    public class Self<E> {\\n        public E v;\\n        public Self(E e) {\\n            v = e;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1891120,
                "title": "sweet-and-simple-c",
                "content": "Quite simple and easy to understand code\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int height(TreeNode* root){\\n        if(root==NULL) return 0;\\n        \\n        return (1+max(height(root->left), height(root->right)));\\n    }\\n    \\n    \\n    \\n    int diameterOfBinaryTree(TreeNode* root) {\\n        if(root==NULL) return 0;\\n        \\n        \\n        int op1= height(root->left) + height(root->right);\\n        \\n        int op2 = diameterOfBinaryTree(root->left);\\n        \\n        int op3 = diameterOfBinaryTree(root->right);\\n        \\n        \\n      \\n        \\n        return max(op1,max(op2,op3));\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int height(TreeNode* root){\\n        if(root==NULL) return 0;\\n        \\n        return (1+max(height(root->left), height(root->right)));\\n    }\\n    \\n    \\n    \\n    int diameterOfBinaryTree(TreeNode* root) {\\n        if(root==NULL) return 0;\\n        \\n        \\n        int op1= height(root->left) + height(root->right);\\n        \\n        int op2 = diameterOfBinaryTree(root->left);\\n        \\n        int op3 = diameterOfBinaryTree(root->right);\\n        \\n        \\n      \\n        \\n        return max(op1,max(op2,op3));\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1818699,
                "title": "cpp-diameter-recusive-solution",
                "content": "**According to question:**\\nGiven the root of a binary tree, return the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.\\n\\n![image](https://assets.leetcode.com/users/images/d52a3065-286f-4529-847b-0cd7fededb9b_1646385479.906607.jpeg)\\n\\n\\n\\n**Approach**\\n\\n![image](https://assets.leetcode.com/users/images/12c6028d-3369-4a73-bb1b-38356206f545_1646384390.3240323.jpeg)\\n\\n**BASE CASE:**\\nIf we are at leaf node then its left and right subtree is NULL i.e  diameter=0, height/depth=0 \\n\\nIn the following code:\\nop1 stores diameter of left subtree\\nop2 stores diamter of right subtree\\nop3 stores sum of height of left & right subtree\\n\\nans.first denotes diameter of subtree\\nans.second denotes height of subtrees\\n```\\nclass Solution {\\npublic:\\n   \\n    pair<int,int> diameter(TreeNode* root){\\n        //base condition \\n        if(root==NULL) {\\n            pair<int,int> p=make_pair(0,0);\\n            return p;\\n        }\\n        //recursive call for left subtree to find diameter and height\\n        pair<int,int> left=diameter(root->left) ;\\n        //recursive call for right subtree to find diameter and height\\n        pair<int,int> right=diameter(root->right);\\n        \\n        // fisrt denotes diameter and second denotes height of subtree\\n        int op1=left.first;\\n        int op2=right.first;\\n        int op3=left.second + right.second;\\n        \\n        pair<int,int> ans;\\n        ans.first=max(op1, max(op2, op3)) ;\\n        ans.second=max(left.second,right.second)+1;\\n        return ans;\\n    }\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        \\n        return diameter(root).first;\\n   }\\n};\\n\\n```\\n**time complexity= O(number of nodes) \\nspace complexity=O(height) for using recursive stack**\\n\\n\\nApproach 2\\n\\n```\\nclass Solution {\\npublic:\\n     int height(TreeNode* root) {\\n         // base condition- if current node is leaf node i.e depth=0\\n        if(root==NULL) return 0;\\n        \\n         \\n        int lefth=height(root->left) ;  //recursive call for finding height of left subtree\\n        int righth=height(root->right) ;  //recursive call for finding height of right subtree\\n        int res=max(lefth, righth) +1;  //maximum height is sum of heights of left & right subtree + root node\\n        return res;\\n        }\\n    \\n    int diameterOfBinaryTree(TreeNode* root) {\\n        //base condition \\n        if(root==NULL) return 0;\\n        \\n        //recursive call for left subtree to find diameter\\n        int op1=diameterOfBinaryTree(root->left) ;\\n        //recursive call for right subtree to find diameter\\n        int op2=diameterOfBinaryTree(root->right) ;\\n        \\n        // length of longest path about current node is sum of height of left and right subtrees\\n        int op3=height(root->left) + height(root->right) ;\\n        \\n        int ans=max(op1, max(op2, op3)) ;\\n        return ans;\\n   }\\n};\\n```\\n\\n**time complexity= O(n^2) because we are calling two functions - height() & diameterOfBinaryTree**\\n\\n\\n**Please upvote it, if you find it useful.**\\n",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    pair<int,int> diameter(TreeNode* root){\\n        //base condition \\n        if(root==NULL) {\\n            pair<int,int> p=make_pair(0,0);\\n            return p;\\n        }\\n        //recursive call for left subtree to find diameter and height\\n        pair<int,int> left=diameter(root->left) ;\\n        //recursive call for right subtree to find diameter and height\\n        pair<int,int> right=diameter(root->right);\\n        \\n        // fisrt denotes diameter and second denotes height of subtree\\n        int op1=left.first;\\n        int op2=right.first;\\n        int op3=left.second + right.second;\\n        \\n        pair<int,int> ans;\\n        ans.first=max(op1, max(op2, op3)) ;\\n        ans.second=max(left.second,right.second)+1;\\n        return ans;\\n    }\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        \\n        return diameter(root).first;\\n   }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n     int height(TreeNode* root) {\\n         // base condition- if current node is leaf node i.e depth=0\\n        if(root==NULL) return 0;\\n        \\n         \\n        int lefth=height(root->left) ;  //recursive call for finding height of left subtree\\n        int righth=height(root->right) ;  //recursive call for finding height of right subtree\\n        int res=max(lefth, righth) +1;  //maximum height is sum of heights of left & right subtree + root node\\n        return res;\\n        }\\n    \\n    int diameterOfBinaryTree(TreeNode* root) {\\n        //base condition \\n        if(root==NULL) return 0;\\n        \\n        //recursive call for left subtree to find diameter\\n        int op1=diameterOfBinaryTree(root->left) ;\\n        //recursive call for right subtree to find diameter\\n        int op2=diameterOfBinaryTree(root->right) ;\\n        \\n        // length of longest path about current node is sum of height of left and right subtrees\\n        int op3=height(root->left) + height(root->right) ;\\n        \\n        int ans=max(op1, max(op2, op3)) ;\\n        return ans;\\n   }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1570404,
                "title": "golang-solution-with-explanation-and-images",
                "content": "I feel that enough people have explained the first type of solution, so I will not explain this.\\n\\n**Most People Do This:**\\n\\n``` go\\nvar maximum = 0\\n\\nfunc diameterOfBinaryTree(root *TreeNode) int {\\n    maximum = 0\\n    helper(root)\\n    return maximum\\n}\\n\\nfunc helper(root *TreeNode) int {\\n    if root == nil { return 0 }\\n    \\n    leftHeight, rightHeight := helper(root.Left), helper(root.Right)\\n    \\n    maximum = max(leftHeight + rightHeight, maximum)\\n    \\n    return 1 + max(leftHeight, rightHeight)\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n```\\n\\n**The Second Solution Explanation:**\\n\\nI would say that the hardest part to understand in the second solution is `maximum = max(leftHeight + rightHeight + 2, maximum)`. \\nI think simplifying would help with the explanation, so:\\n\\n``` go\\nmaximum = max(leftHeight + rightHeight + 2, maximum)\\n\\nwhich equals:\\n\\nmaximum = max((leftHeight + 1) + (rightHeight + 1), maximum)\\n```\\n\\nI think that the easiest way to explain this is to use an image (Something to remember as we return `-1` when we find a `nil` node):\\n\\n![image](https://assets.leetcode.com/users/images/297d1f43-fb86-45bb-a4fd-8a417cb8c5ce_1636559558.8982306.jpeg)\\n\\n\\n* We can start with the simple input, `[1, nil, 2]`\\n* Since this is a recursive solution, we can start from the bottom up.\\n* In the image, the orange boxes are `nil` nodes, and the dotted line represents the edge to the `nil` node.\\n* In the second image, we can see that we add `1` because of the edge and subtract `1` because the edge is pointing to `nil`, so the height is `0`.\\n* Then, in the third image, we can see that the left node is `nil`, so we can add `1` for the edge and subtract `1` for the `nil`. Then on the right child, we can add `1` for the edge and add `0` because the right child\\'s height is `0`.\\n\\nAs you can see we are doing `(leftHeight + 1) + (rightHeight + 1)`. The plus `1` is for adding the edge. I didn\\'t do the `maximum = max(, maximum)` part because I feel it is pretty easy to understand.\\n\\n**This is the Code I Prefer:** *(The only things that are different from the first solution are we return `-1` instead of `0` if `root == nil`, and we add `2` to `leftHeight + rightHeight` when calculating `maximum`)*\\n\\n``` go\\nvar maximum = 0\\n\\nfunc diameterOfBinaryTree(root *TreeNode) int {\\n    maximum = 0\\n    helper(root)\\n    return maximum\\n}\\n\\nfunc helper(root *TreeNode) int {\\n    if root == nil { return -1 }\\n    \\n    leftHeight, rightHeight := helper(root.Left), helper(root.Right)\\n    \\n    maximum = max(leftHeight + rightHeight + 2, maximum)\\n    \\n    return 1 + max(leftHeight, rightHeight)\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n```",
                "solutionTags": [],
                "code": "``` go\\nvar maximum = 0\\n\\nfunc diameterOfBinaryTree(root *TreeNode) int {\\n    maximum = 0\\n    helper(root)\\n    return maximum\\n}\\n\\nfunc helper(root *TreeNode) int {\\n    if root == nil { return 0 }\\n    \\n    leftHeight, rightHeight := helper(root.Left), helper(root.Right)\\n    \\n    maximum = max(leftHeight + rightHeight, maximum)\\n    \\n    return 1 + max(leftHeight, rightHeight)\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n```\n``` go\\nmaximum = max(leftHeight + rightHeight + 2, maximum)\\n\\nwhich equals:\\n\\nmaximum = max((leftHeight + 1) + (rightHeight + 1), maximum)\\n```\n``` go\\nvar maximum = 0\\n\\nfunc diameterOfBinaryTree(root *TreeNode) int {\\n    maximum = 0\\n    helper(root)\\n    return maximum\\n}\\n\\nfunc helper(root *TreeNode) int {\\n    if root == nil { return -1 }\\n    \\n    leftHeight, rightHeight := helper(root.Left), helper(root.Right)\\n    \\n    maximum = max(leftHeight + rightHeight + 2, maximum)\\n    \\n    return 1 + max(leftHeight, rightHeight)\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 984860,
                "title": "faster-than-98-easy-well-explained-c",
                "content": "The idea is to check at every node, if sum of left subtree\\'s depth and right subtree\\'s depth is maximum. I am storing that in \\'res\\' variable and updating it whenever required.\\nNow to get depth, it is a simple recursive function that adds one to maximum height between left and right subtree, and returns it.\\nFeel free to ask if you need any help :)\\n```\\n    int height( TreeNode* root , int& res)\\n    {\\n        if( !root ) return 0;\\n        int l =  height(root->left, res);\\n        int r = height(root->right, res);\\n        if ( l + r > res ) res = l+r;\\n        return 1 + max(l,r);\\n    }\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        if( !root ) return 0;\\n        int res = -1;\\n        height( root , res );\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int height( TreeNode* root , int& res)\\n    {\\n        if( !root ) return 0;\\n        int l =  height(root->left, res);\\n        int r = height(root->right, res);\\n        if ( l + r > res ) res = l+r;\\n        return 1 + max(l,r);\\n    }\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        if( !root ) return 0;\\n        int res = -1;\\n        height( root , res );\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 924835,
                "title": "java-solution-beats-100-with-explanation",
                "content": "class Solution {\\n    int ans = 1;\\n    public int diameterOfBinaryTree(TreeNode root) {\\n        \\n        dfs(root);\\n        return ans-1; // ans depicts number of nodes| we want to find edges so for n nodes in graph you need n-1 edges as connection. Hence you subtract 1.\\n    }\\n    \\n    public int dfs(TreeNode root){\\n        \\n        if(root == null)\\n            return 0;\\n        \\n        int ld = dfs(root.left);\\n        int rd = dfs(root.right);\\n        ans = Math.max(ans, 1+ld+rd); // this accounts for counting the number of nodes in the path. all left nodes, right and the root node itself, so we add 1.\\n        return 1+ Math.max(ld,rd);\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    int ans = 1;\\n    public int diameterOfBinaryTree(TreeNode root) {\\n        \\n        dfs(root);\\n        return ans-1; // ans depicts number of nodes| we want to find edges so for n nodes in graph you need n-1 edges as connection. Hence you subtract 1.\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 637354,
                "title": "easy-python-solution-with-details-from-o-n-2-to-o-n",
                "content": "Here is a clear concise solution \\n\\n```\\nclass Solution(object):\\n    \\n    def getHeight(self, node):\\n        if not node:\\n            return 0\\n        \\n        return 1 + max(self.getHeight(node.left) , self.getHeight(node.right))\\n    \\n    def diameterOfBinaryTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        \\n        if not root:\\n            return 0\\n        \\n        \\n        lheight = self.getHeight(root.left)\\n        ldiameter = self.diameterOfBinaryTree(root.left)\\n                   \\n        rheight = self.getHeight(root.right)\\n        rdiameter = self.diameterOfBinaryTree(root.right)\\n       \\n        return max(lheight + rheight, ldiameter, rdiameter)\\n```\\n\\n\\nThis is O(n^2) though because of the recursive call to compute the height. From that solution, we can make it O(n) by computing the  height in the same recursive function.\\n\\n```\\nclass Solution(object):   \\n    def diameterOfBinaryTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        \\n        diameter, height = self.getDiameterAndHeight(root)\\n        return diameter\\n        \\n    \\n    def getDiameterAndHeight(self, node):\\n        if not node:\\n            return 0, 0            \\n        ldiameter, lheight = self.getDiameterAndHeight(node.left)\\n        rdiameter, rheight = self.getDiameterAndHeight(node.right)\\n        \\n        # Compute the height of the current node\\n        height = 1 + max(lheight, rheight)\\n\\t\\t\\n        # The diameter is the max between lheight + rheight , ldiameter and rdiamter\\n        diameter = max(lheight + rheight, ldiameter, rdiameter)\\n        return diameter, height\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution(object):\\n    \\n    def getHeight(self, node):\\n        if not node:\\n            return 0\\n        \\n        return 1 + max(self.getHeight(node.left) , self.getHeight(node.right))\\n    \\n    def diameterOfBinaryTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        \\n        if not root:\\n            return 0\\n        \\n        \\n        lheight = self.getHeight(root.left)\\n        ldiameter = self.diameterOfBinaryTree(root.left)\\n                   \\n        rheight = self.getHeight(root.right)\\n        rdiameter = self.diameterOfBinaryTree(root.right)\\n       \\n        return max(lheight + rheight, ldiameter, rdiameter)\\n```\n```\\nclass Solution(object):   \\n    def diameterOfBinaryTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        \\n        diameter, height = self.getDiameterAndHeight(root)\\n        return diameter\\n        \\n    \\n    def getDiameterAndHeight(self, node):\\n        if not node:\\n            return 0, 0            \\n        ldiameter, lheight = self.getDiameterAndHeight(node.left)\\n        rdiameter, rheight = self.getDiameterAndHeight(node.right)\\n        \\n        # Compute the height of the current node\\n        height = 1 + max(lheight, rheight)\\n\\t\\t\\n        # The diameter is the max between lheight + rheight , ldiameter and rdiamter\\n        diameter = max(lheight + rheight, ldiameter, rdiameter)\\n        return diameter, height\\n```",
                "codeTag": "Java"
            },
            {
                "id": 611951,
                "title": "in-c",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\n\\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\\n\\nint bt_diameter(struct TreeNode* root, int *diameter)\\n{   \\n    if (root == NULL)\\n        return 0;\\n    \\n    int left_h = bt_diameter(root->left, diameter);\\n    int right_h = bt_diameter(root->right, diameter);\\n    int curr_dia = left_h + right_h;\\n    \\n    *diameter = MAX(*diameter, curr_dia);\\n    return 1 + MAX(left_h, right_h);\\n}\\n\\nint diameterOfBinaryTree(struct TreeNode* root)\\n{\\n    int diameter = 0;\\n    bt_diameter(root, &diameter);\\n    return diameter;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\n\\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\\n\\nint bt_diameter(struct TreeNode* root, int *diameter)\\n{   \\n    if (root == NULL)\\n        return 0;\\n    \\n    int left_h = bt_diameter(root->left, diameter);\\n    int right_h = bt_diameter(root->right, diameter);\\n    int curr_dia = left_h + right_h;\\n    \\n    *diameter = MAX(*diameter, curr_dia);\\n    return 1 + MAX(left_h, right_h);\\n}\\n\\nint diameterOfBinaryTree(struct TreeNode* root)\\n{\\n    int diameter = 0;\\n    bt_diameter(root, &diameter);\\n    return diameter;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 574440,
                "title": "python-o-n-intuitive-recursive-no-global-variable-with-comments",
                "content": "I didn\\'t see this kind of approach in discussion. Maybe I have overcomplicated things.\\n\\n```\\ndef diameterOfBinaryTree(self, root: TreeNode) -> int:\\n\\tdef d(r):\\n\\t\\t\"\"\"\\n\\t\\treturns: (   \\n\\t\\t\\tmax height including r, \\n\\t\\t\\tlongest diameter assuming r is root\\n\\t\\t)\\n\\t\\t\"\"\"\\n\\n\\t\\tif not r or (not r.left and not r.right):\\n\\t\\t\\t# null or single node, base case\\n\\t\\t\\treturn 0, 0\\n\\n\\t\\t# handling missing one child\\n\\t\\tif not r.left:\\n\\t\\t\\tk, l = d(r.right)\\n\\t\\t\\treturn k + 1, l\\n\\t\\tif not r.right:\\n\\t\\t\\tk, l = d(r.left)\\n\\t\\t\\treturn k + 1, l\\n\\n\\t\\tkl, ll = d(r.left)\\n\\t\\tkr, lr = d(r.right)\\n\\n\\t\\t# 1.  extends the max height\\n\\t\\t# 2a. maximizes any child max diameter\\n\\t\\t# 2b. assumes r is the \"final\" root\\n\\t\\treturn max(kl, kr) + 1, max(max(ll, lr), kl + kr + 2)\\n\\n\\treturn max(d(root))\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\ndef diameterOfBinaryTree(self, root: TreeNode) -> int:\\n\\tdef d(r):\\n\\t\\t\"\"\"\\n\\t\\treturns: (   \\n\\t\\t\\tmax height including r, \\n\\t\\t\\tlongest diameter assuming r is root\\n\\t\\t)\\n\\t\\t\"\"\"\\n\\n\\t\\tif not r or (not r.left and not r.right):\\n\\t\\t\\t# null or single node, base case\\n\\t\\t\\treturn 0, 0\\n\\n\\t\\t# handling missing one child\\n\\t\\tif not r.left:\\n\\t\\t\\tk, l = d(r.right)\\n\\t\\t\\treturn k + 1, l\\n\\t\\tif not r.right:\\n\\t\\t\\tk, l = d(r.left)\\n\\t\\t\\treturn k + 1, l\\n\\n\\t\\tkl, ll = d(r.left)\\n\\t\\tkr, lr = d(r.right)\\n\\n\\t\\t# 1.  extends the max height\\n\\t\\t# 2a. maximizes any child max diameter\\n\\t\\t# 2b. assumes r is the \"final\" root\\n\\t\\treturn max(kl, kr) + 1, max(max(ll, lr), kl + kr + 2)\\n\\n\\treturn max(d(root))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 573623,
                "title": "java-o-n-solution-beats-100-easy-to-understand",
                "content": "The logic is simple. While finding the depth of each node , find the diameter of that node as well.\\nIf the diameter of current node is larger than the global diameter. then set current diameter as the global diameter;\\n```\\nclass Solution {\\n    int maxDiameter = 0;\\n    public int diameterOfBinaryTree(TreeNode root) {\\n        findDepth(root);\\n        return maxDiameter;\\n    }\\n    private int findDepth(TreeNode root){\\n        if(root == null)\\n            return -1;\\n        int left = findDepth(root.left);\\n        int right = findDepth(root.right);\\n        int depth = Math.max(left,right)+1;\\n        int diameter = left+right+2;\\n        maxDiameter = Math.max(maxDiameter,diameter);\\n        return depth;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int maxDiameter = 0;\\n    public int diameterOfBinaryTree(TreeNode root) {\\n        findDepth(root);\\n        return maxDiameter;\\n    }\\n    private int findDepth(TreeNode root){\\n        if(root == null)\\n            return -1;\\n        int left = findDepth(root.left);\\n        int right = findDepth(root.right);\\n        int depth = Math.max(left,right)+1;\\n        int diameter = left+right+2;\\n        maxDiameter = Math.max(maxDiameter,diameter);\\n        return depth;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 455920,
                "title": "java-dfs-maxdepth-method",
                "content": "```\\n\\tpublic int diameterOfBinaryTree(TreeNode root) {\\n\\t\\tif(root == null) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n        int diameter = maxDepth(root.left) + maxDepth(root.right);\\n\\t\\treturn Math.max(diameter, Math.max(diameterOfBinaryTree(root.left), diameterOfBinaryTree(root.right)));\\n    }\\n\\t// DFS\\n\\tprivate int maxDepth(TreeNode root) {\\n\\t\\tif(root == null) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\treturn 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic int diameterOfBinaryTree(TreeNode root) {\\n\\t\\tif(root == null) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n        int diameter = maxDepth(root.left) + maxDepth(root.right);\\n\\t\\treturn Math.max(diameter, Math.max(diameterOfBinaryTree(root.left), diameterOfBinaryTree(root.right)));\\n    }\\n\\t// DFS\\n\\tprivate int maxDepth(TreeNode root) {\\n\\t\\tif(root == null) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\treturn 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 328480,
                "title": "python3-solution-beats-89",
                "content": "\\tclass Solution:\\n\\t\\tdef diameterOfBinaryTree(self, root: TreeNode) -> int:\\n\\t\\t\\tself.res=0\\n\\t\\t\\tself.depth(root)\\n\\t\\t\\treturn self.res        \\n\\t\\tdef depth(self,root):        \\n\\t\\t\\tif root==None:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\tl=self.depth(root.left)\\n\\t\\t\\tr=self.depth(root.right)\\n\\t\\t\\tself.res=max(self.res,l+r)\\n\\t\\t\\treturn max(l,r)+1",
                "solutionTags": [
                    "Python3",
                    "Tree",
                    "Recursion"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef diameterOfBinaryTree(self, root: TreeNode) -> int:\\n\\t\\t\\tself.res=0\\n\\t\\t\\tself.depth(root)\\n\\t\\t\\treturn self.res        \\n\\t\\tdef depth(self,root):        \\n\\t\\t\\tif root==None:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\tl=self.depth(root.left)\\n\\t\\t\\tr=self.depth(root.right)\\n\\t\\t\\tself.res=max(self.res,l+r)\\n\\t\\t\\treturn max(l,r)+1",
                "codeTag": "Java"
            },
            {
                "id": 253095,
                "title": "python-recursion",
                "content": "I used a global variable self.d to keep track the longest diameter in recursion.\\n\\nIn each recursion, we are at the root node **X** of a subtree and get its diameter by calling a helper function **diameter**. Then we update self.d with its diameter if necessary. \\n\\nThen we need to return the longer side (between left side and right side) as the component of **X**\\'s parent subtree\\'s diameter. We also need to plus one to the length of the longer side as the edge between **X** and its parent node.\\n```\\nclass Solution:\\n    def diameterOfBinaryTree(self, root):\\n        self.d = 0\\n        self.diameter(root)\\n        return self.d\\n        \\n    def diameter(self, node):\\n        if not node: return 0\\n        l, r = self.diameter(node.left), self.diameter(node.right)\\n        self.d = max(self.d, l+r)\\n        return max(l, r) + 1\\n```\\nIt\\'s a O(n) time complexity(T(n) = 2T(n/2)+c) O(1) space complexity solution.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def diameterOfBinaryTree(self, root):\\n        self.d = 0\\n        self.diameter(root)\\n        return self.d\\n        \\n    def diameter(self, node):\\n        if not node: return 0\\n        l, r = self.diameter(node.left), self.diameter(node.right)\\n        self.d = max(self.d, l+r)\\n        return max(l, r) + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 241145,
                "title": "ruby-2-solutions-with-explanation",
                "content": "**Brute Force - O(n^2)**\\nBasic idea is that we visit every node and calculate the longest left and right route from that node and then add up the lengths from each side. Then we simply return the greatest value.\\n```\\ndef diameter_of_binary_tree(root)\\n    return 0 if !root\\n\\t\\n    d = nodes(root.left) + nodes(root.right)\\n    r = diameter_of_binary_tree(root.right)\\n    l = diameter_of_binary_tree(root.left)\\n\\t\\n    [d, r, l].max\\nend\\n\\ndef nodes(node)\\n    return 0 if !node\\n\\t\\n    l = nodes(node.left)\\n\\tr = nodes(node.right)\\n\\t\\n    [l, r].max + 1\\nend\\n```\\n\\n**Optimized - O(n)**\\nInstead of recalculating the height of each side at every node, if we maintain an instance variable to keep track of the longest string of nodes while we\\'re traversing, we can actually do this in one iteration through our tree. We\\'ll start at the bottom, and then pass up the longer side just like we were doing before, but we\\'ll also update our instance variable as we traverse to keep track of our longest string of nodes. Finally, since the number of edges for the diameter is one less than the number of nodes, we subtract one from the result.\\n```\\ndef diameter_of_binary_tree(root)\\n    return 0 if !root\\n\\t\\n    @result = 1\\n    nodes_while_tracking(root)\\n\\t\\n    @result - 1\\nend\\n\\ndef nodes_while_tracking(node)\\n    return 0 if !node\\n\\t\\n    l = nodes_while_tracking(node.left)\\n\\tr = nodes_while_tracking(node.right)\\n\\t\\n    @result = [@result, l + r + 1].max\\n\\t\\n    [l, r].max + 1\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef diameter_of_binary_tree(root)\\n    return 0 if !root\\n\\t\\n    d = nodes(root.left) + nodes(root.right)\\n    r = diameter_of_binary_tree(root.right)\\n    l = diameter_of_binary_tree(root.left)\\n\\t\\n    [d, r, l].max\\nend\\n\\ndef nodes(node)\\n    return 0 if !node\\n\\t\\n    l = nodes(node.left)\\n\\tr = nodes(node.right)\\n\\t\\n    [l, r].max + 1\\nend\\n```\n```\\ndef diameter_of_binary_tree(root)\\n    return 0 if !root\\n\\t\\n    @result = 1\\n    nodes_while_tracking(root)\\n\\t\\n    @result - 1\\nend\\n\\ndef nodes_while_tracking(node)\\n    return 0 if !node\\n\\t\\n    l = nodes_while_tracking(node.left)\\n\\tr = nodes_while_tracking(node.right)\\n\\t\\n    @result = [@result, l + r + 1].max\\n\\t\\n    [l, r].max + 1\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3948657,
                "title": "3-easy-c-solutions-dfs-recursive-approach-beats-100",
                "content": "\\n\\n# Code\\n```\\n// Recursive solution O(n^2)\\nclass Solution {\\npublic:\\n    int height(TreeNode* root){\\n        if(root == NULL)\\n            return 0;\\n\\n        int left = height(root->left);\\n        int right = height(root->right);\\n        return max(left, right) + 1;\\n    }\\n\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        if(root == NULL)\\n            return 0;\\n\\n        int op1 = diameterOfBinaryTree(root->left);\\n        int op2 = diameterOfBinaryTree(root->right);\\n        int op3 = height(root->left) + height(root->right);\\n\\n        return max(op1, max(op2, op3));\\n    }\\n};\\n\\n// Recursive solution O(n)\\nclass Solution {\\npublic:\\n    pair<int, int> diameterpair(TreeNode *root){\\n        if(root == NULL){\\n            pair<int, int> p = make_pair(0,0);\\n            return p;\\n        }\\n\\n        pair<int, int> left = diameterpair(root->left);\\n        pair<int, int> right = diameterpair(root->right);\\n\\n        int op1 = left.first;\\n        int op2 = right.first;\\n        int op3 = left.second + right.second;\\n\\n        pair<int, int> ans;\\n        ans.first = max(op1, max(op2, op3));\\n        ans.second = max(left.second, right.second) + 1;\\n\\n        return ans;\\n    }\\n\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        return diameterpair(root).first;\\n    }\\n};\\n\\n// Recursive solution O(N)\\nclass Solution {\\npublic:\\n    int ans=0;\\n\\n    int height(TreeNode* root){\\n            if(root == NULL) \\n                return 0;\\n    \\n        int lHeight = height(root->left);\\n        int rHeight = height(root->right);\\n    \\n        ans= max(ans, 1 + lHeight + rHeight);\\n        return 1 + max(lHeight , rHeight);\\n    }\\n\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        if(root == NULL) \\n            return 0;\\n        height(root);\\n        return ans-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n// Recursive solution O(n^2)\\nclass Solution {\\npublic:\\n    int height(TreeNode* root){\\n        if(root == NULL)\\n            return 0;\\n\\n        int left = height(root->left);\\n        int right = height(root->right);\\n        return max(left, right) + 1;\\n    }\\n\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        if(root == NULL)\\n            return 0;\\n\\n        int op1 = diameterOfBinaryTree(root->left);\\n        int op2 = diameterOfBinaryTree(root->right);\\n        int op3 = height(root->left) + height(root->right);\\n\\n        return max(op1, max(op2, op3));\\n    }\\n};\\n\\n// Recursive solution O(n)\\nclass Solution {\\npublic:\\n    pair<int, int> diameterpair(TreeNode *root){\\n        if(root == NULL){\\n            pair<int, int> p = make_pair(0,0);\\n            return p;\\n        }\\n\\n        pair<int, int> left = diameterpair(root->left);\\n        pair<int, int> right = diameterpair(root->right);\\n\\n        int op1 = left.first;\\n        int op2 = right.first;\\n        int op3 = left.second + right.second;\\n\\n        pair<int, int> ans;\\n        ans.first = max(op1, max(op2, op3));\\n        ans.second = max(left.second, right.second) + 1;\\n\\n        return ans;\\n    }\\n\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        return diameterpair(root).first;\\n    }\\n};\\n\\n// Recursive solution O(N)\\nclass Solution {\\npublic:\\n    int ans=0;\\n\\n    int height(TreeNode* root){\\n            if(root == NULL) \\n                return 0;\\n    \\n        int lHeight = height(root->left);\\n        int rHeight = height(root->right);\\n    \\n        ans= max(ans, 1 + lHeight + rHeight);\\n        return 1 + max(lHeight , rHeight);\\n    }\\n\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        if(root == NULL) \\n            return 0;\\n        height(root);\\n        return ans-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3733255,
                "title": "easy-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    int depth(int &maxdepth,TreeNode* root)\\n    {\\n        if(root==NULL)return 0;\\n        int lh=depth(maxdepth,root->left);\\n        int rh=depth(maxdepth,root->right);\\n        maxdepth=max(maxdepth,lh+rh);\\n        return 1+max(lh,rh);\\n    }\\npublic:\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        int maxdepth=0;\\n        int ans=depth(maxdepth,root);\\n        return maxdepth;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    int depth(int &maxdepth,TreeNode* root)\\n    {\\n        if(root==NULL)return 0;\\n        int lh=depth(maxdepth,root->left);\\n        int rh=depth(maxdepth,root->right);\\n        maxdepth=max(maxdepth,lh+rh);\\n        return 1+max(lh,rh);\\n    }\\npublic:\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        int maxdepth=0;\\n        int ans=depth(maxdepth,root);\\n        return maxdepth;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691013,
                "title": "easy-c-solution-beats-99-vividly-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code calculates the diameter of a binary tree. The diameter of a binary tree is defined as the number of nodes on the longest path between any two leaf nodes.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code defines a helper function dfs() that takes a TreeNode pointer root and a reference to an integer result as arguments. Within this function, it performs the following steps:\\n\\nIf the root is NULL (i.e., there are no nodes), it returns 0.\\nIt recursively calls the dfs() function on the left subtree of the current node (root->left) and stores the result in the variable left.\\nIt recursively calls the dfs() function on the right subtree of the current node (root->right) and stores the result in the variable right.\\nIt calculates the diameter of the binary tree passing through the current node by adding the lengths of the left and right subtrees. If this diameter is greater than the current result, it updates result.\\nIt returns the maximum depth of the current node\\'s subtree by adding 1 to the maximum of left and right.\\nThe diameterOfBinaryTree() function initializes a variable result to store the diameter of the binary tree. It calls the dfs() function with the root of the binary tree and the result variable as arguments. Finally, i\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe code visits each node exactly once, so the time complexity is O(n), where n is the number of nodes in the binary tree.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(h), where h is the height of the binary tree. This is because the recursive calls consume space on the call stack, and in the worst case, the height of the tree is equal to the number of nodes in the tree, resulting in O(n) space complexity.\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int dfs(TreeNode* root,int &result){\\n        if(root==NULL){\\n            return 0;\\n        }\\n        int left= dfs(root->left,result);\\n        int right= dfs(root->right,result);\\n        result=max(result,left+right);\\n        return 1+(max(left,right));\\n    }\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        int result=0;\\n        dfs(root,result);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int dfs(TreeNode* root,int &result){\\n        if(root==NULL){\\n            return 0;\\n        }\\n        int left= dfs(root->left,result);\\n        int right= dfs(root->right,result);\\n        result=max(result,left+right);\\n        return 1+(max(left,right));\\n    }\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        int result=0;\\n        dfs(root,result);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3564341,
                "title": "solution-in-java-simple",
                "content": "# Intuition\\n//find height and calculate the diameter based on the height\\n\\n# Approach\\n//Finding the l height and r height to find the diameter using the max function\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int diameterOfBinaryTree(TreeNode root) {\\n        if(root==null)\\n        {\\n            return 0;\\n        }\\n        else\\n        {\\n            int lh=height(root.left);\\n            int rh=height(root.right);\\n            int ldia=diameterOfBinaryTree(root.left);\\n            int rdia=diameterOfBinaryTree(root.right);\\n            return Math.max(lh+rh,Math.max(ldia,rdia));\\n        }\\n    }\\n    public int height(TreeNode temp)\\n    {\\n        if(temp!=null)\\n        {\\n            int lh=height(temp.left);\\n            int rh=height(temp.right);\\n            if(lh>rh)\\n            {\\n                return lh+1;\\n            }\\n            else\\n            {\\n                return rh+1;\\n            }\\n        }\\n        else\\n        {\\n            return 0;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int diameterOfBinaryTree(TreeNode root) {\\n        if(root==null)\\n        {\\n            return 0;\\n        }\\n        else\\n        {\\n            int lh=height(root.left);\\n            int rh=height(root.right);\\n            int ldia=diameterOfBinaryTree(root.left);\\n            int rdia=diameterOfBinaryTree(root.right);\\n            return Math.max(lh+rh,Math.max(ldia,rdia));\\n        }\\n    }\\n    public int height(TreeNode temp)\\n    {\\n        if(temp!=null)\\n        {\\n            int lh=height(temp.left);\\n            int rh=height(temp.right);\\n            if(lh>rh)\\n            {\\n                return lh+1;\\n            }\\n            else\\n            {\\n                return rh+1;\\n            }\\n        }\\n        else\\n        {\\n            return 0;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3482812,
                "title": "best-c-solution-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    int heightTree(TreeNode* root) {\\n        if (!root) return 0;\\n        int l = heightTree(root->left);\\n        int r = heightTree(root->right);\\n        ans = max(ans, l + r);\\n        return max(l, r) + 1;\\n    }\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        heightTree(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    int heightTree(TreeNode* root) {\\n        if (!root) return 0;\\n        int l = heightTree(root->left);\\n        int r = heightTree(root->right);\\n        ans = max(ans, l + r);\\n        return max(l, r) + 1;\\n    }\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        heightTree(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443234,
                "title": "python-simple-clean-recursive-solution",
                "content": "\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def __init__(self, maxi = 0):\\n        self.maxi = maxi\\n\\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        def helper(root):\\n            if not root:\\n                return 0\\n            \\n            lh = helper(root.left)\\n            rh = helper(root.right)\\n        \\n            self.maxi = max(self.maxi, lh + rh)\\n\\n            return 1 + max(lh, rh)\\n        \\n        helper(root)\\n        return self.maxi\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def __init__(self, maxi = 0):\\n        self.maxi = maxi\\n\\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        def helper(root):\\n            if not root:\\n                return 0\\n            \\n            lh = helper(root.left)\\n            rh = helper(root.right)\\n        \\n            self.maxi = max(self.maxi, lh + rh)\\n\\n            return 1 + max(lh, rh)\\n        \\n        helper(root)\\n        return self.maxi\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396281,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        int d = 0;\\n        findHeight(root, d);\\n        return d;\\n    }\\n    int findHeight(TreeNode* root, int &d){\\n        if(root==NULL) return 0;\\n        int lh = max(findHeight(root->left, d), 0);\\n        int rh = max(findHeight(root->right, d), 0);\\n        d = max(d, lh+rh);\\n        return max(lh, rh)+1;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        self.diameter = 0\\n        def height(node=root):\\n            if not node:\\n                return 0\\n            if not node.left and not node.right:\\n                return 0\\n            chord = le = ri = 0\\n            if node.left:\\n                le = height(node.left)\\n                chord += 1 + le\\n            if node.right:\\n                ri = height(node.right)\\n                chord += 1 + ri\\n            self.diameter = max(chord, self.diameter)\\n            return 1+max(le, ri)\\n        height()\\n        return self.diameter\\n```\\n\\n```Java []\\nclass Solution {\\n    int result = -1;\\n    public int diameterOfBinaryTree(TreeNode root) {\\n        dfs(root);\\n        return result;\\n    }\\n    private int dfs(TreeNode current) {\\n        if (current == null) {\\n            return -1;\\n        }\\n        int left = 1 + dfs(current.left);\\n        int right = 1 + dfs(current.right);\\n        result = Math.max(result, (left + right));\\n        return Math.max(left, right);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        int d = 0;\\n        findHeight(root, d);\\n        return d;\\n    }\\n    int findHeight(TreeNode* root, int &d){\\n        if(root==NULL) return 0;\\n        int lh = max(findHeight(root->left, d), 0);\\n        int rh = max(findHeight(root->right, d), 0);\\n        d = max(d, lh+rh);\\n        return max(lh, rh)+1;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        self.diameter = 0\\n        def height(node=root):\\n            if not node:\\n                return 0\\n            if not node.left and not node.right:\\n                return 0\\n            chord = le = ri = 0\\n            if node.left:\\n                le = height(node.left)\\n                chord += 1 + le\\n            if node.right:\\n                ri = height(node.right)\\n                chord += 1 + ri\\n            self.diameter = max(chord, self.diameter)\\n            return 1+max(le, ri)\\n        height()\\n        return self.diameter\\n```\n```Java []\\nclass Solution {\\n    int result = -1;\\n    public int diameterOfBinaryTree(TreeNode root) {\\n        dfs(root);\\n        return result;\\n    }\\n    private int dfs(TreeNode current) {\\n        if (current == null) {\\n            return -1;\\n        }\\n        int left = 1 + dfs(current.left);\\n        int right = 1 + dfs(current.right);\\n        result = Math.max(result, (left + right));\\n        return Math.max(left, right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257292,
                "title": "easy-recursive-code",
                "content": "code\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    private:\\n    int height(TreeNode* root){\\n        if(root==NULL){\\n            return 0;\\n        }\\n        int left = height(root->left);\\n        int right = height(root->right);\\n        return 1+max(left,right);\\n\\n    }\\npublic:\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        if(root==NULL){\\n            return 0;\\n        }\\n        int opt1 = diameterOfBinaryTree(root->left);\\n        int opt2 = diameterOfBinaryTree(root->right);\\n        int opt3 = height(root->left) + height(root->right);\\n        return max(opt1 ,max(opt2,opt3));\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    private:\\n    int height(TreeNode* root){\\n        if(root==NULL){\\n            return 0;\\n        }\\n        int left = height(root->left);\\n        int right = height(root->right);\\n        return 1+max(left,right);\\n\\n    }\\npublic:\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        if(root==NULL){\\n            return 0;\\n        }\\n        int opt1 = diameterOfBinaryTree(root->left);\\n        int opt2 = diameterOfBinaryTree(root->right);\\n        int opt3 = height(root->left) + height(root->right);\\n        return max(opt1 ,max(opt2,opt3));\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3035278,
                "title": "rust-simple-recursion-0ms",
                "content": "\\n# Code\\n```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn diameter_of_binary_tree(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\\n        fn dfs(root: Option<Rc<RefCell<TreeNode>>>) -> (i32, i32) {\\n            match root {\\n                None => (0, 0),\\n                Some(node) => {\\n                    let (ld, ldia) = dfs(node.borrow().left.clone());\\n                    let (rd, rdia) = dfs(node.borrow().right.clone());\\n                    (i32::max(ld, rd) + 1, i32::max(ldia, i32::max(rdia, ld+rd)))\\n                }\\n            }\\n        }\\n        dfs(root).1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn diameter_of_binary_tree(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\\n        fn dfs(root: Option<Rc<RefCell<TreeNode>>>) -> (i32, i32) {\\n            match root {\\n                None => (0, 0),\\n                Some(node) => {\\n                    let (ld, ldia) = dfs(node.borrow().left.clone());\\n                    let (rd, rdia) = dfs(node.borrow().right.clone());\\n                    (i32::max(ld, rd) + 1, i32::max(ldia, i32::max(rdia, ld+rd)))\\n                }\\n            }\\n        }\\n        dfs(root).1\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3019387,
                "title": "java-0ms-dfs",
                "content": "# Intuition\\nWe will use heigth of tree. Will make sure we keep on updating our max. In the end we will just return the max value.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int diameterOfBinaryTree(TreeNode root) {\\n         int[] diameter=new int[1];\\n        height(root,diameter);\\n        return diameter[0];\\n    }\\n    int height(TreeNode root, int[] diameter) {\\n        if (root==null){\\n            return 0;\\n        }\\n        int left=height(root.left,diameter);\\n        int right=height(root.right,diameter);\\n        diameter[0]= Math.max(diameter[0],left+right);\\n        return Math.max(left,right)+1;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int diameterOfBinaryTree(TreeNode root) {\\n         int[] diameter=new int[1];\\n        height(root,diameter);\\n        return diameter[0];\\n    }\\n    int height(TreeNode root, int[] diameter) {\\n        if (root==null){\\n            return 0;\\n        }\\n        int left=height(root.left,diameter);\\n        int right=height(root.right,diameter);\\n        diameter[0]= Math.max(diameter[0],left+right);\\n        return Math.max(left,right)+1;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947449,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        if(root == NULL){\\n            return 0;\\n        }\\n\\n        int dia = 0;\\n        height(root, dia);\\n        return dia;\\n    }\\n\\n    int height(TreeNode* node, int &dia){\\n        if(!node){\\n            return 0;\\n        }\\n\\n        int lh = height(node->left, dia);\\n        int rh = height(node->right, dia);\\n        dia  = max(dia, lh+rh);\\n        \\n        return 1 + max(lh, rh);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        if(root == NULL){\\n            return 0;\\n        }\\n\\n        int dia = 0;\\n        height(root, dia);\\n        return dia;\\n    }\\n\\n    int height(TreeNode* node, int &dia){\\n        if(!node){\\n            return 0;\\n        }\\n\\n        int lh = height(node->left, dia);\\n        int rh = height(node->right, dia);\\n        dia  = max(dia, lh+rh);\\n        \\n        return 1 + max(lh, rh);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2925451,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int dfs(TreeNode* root, int &d)\\n    {\\n        if(!root)\\n            return 0;\\n        int lh=dfs(root->left, d);\\n        int rh=dfs(root->right, d);\\n        d=max(d, lh+rh);\\n        return max(lh,rh)+1;\\n    }\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        int d=0;\\n        dfs(root, d);\\n        return d;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int dfs(TreeNode* root, int &d)\\n    {\\n        if(!root)\\n            return 0;\\n        int lh=dfs(root->left, d);\\n        int rh=dfs(root->right, d);\\n        d=max(d, lh+rh);\\n        return max(lh,rh)+1;\\n    }\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        int d=0;\\n        dfs(root, d);\\n        return d;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2816628,
                "title": "c-simple-recursive-approach",
                "content": "**Diamter of Binary Tree:**\\n```\\nclass Solution {\\npublic:\\n    // using height function for option3 of diameter function\\n    int height(TreeNode* node){\\n        if(node == NULL){\\n            return 0;\\n        }\\n        \\n        int leftHeight = height(node->left);\\n        int rightHeight = height(node->right);\\n        \\n        return 1 + max(leftHeight, rightHeight);\\n    }\\n    \\n    int diameterOfBinaryTree(TreeNode* root){\\n        // base case\\n        if(root == NULL){\\n            return 0;\\n        }\\n        \\n        // diameter will of either of these:- either in left only, either in right only, either combination of both\\n        \\n        int option1 = diameterOfBinaryTree(root->left); // either in left\\n        \\n        int option2 = diameterOfBinaryTree(root->right); // either in right\\n        \\n        int option3 = height(root->left) + height(root->right); // either combination of both\\n        \\n        int ans = max(option1, max(option2, option3));\\n        \\n        return ans;\\n    }\\n};\\n```\\n***TC:*** *O(n^2) - as we calling height function also in between of two calls*\\n**Sumission status:** *Accepted with 50ms of Runtime*\\n\\n**Do upvote !!!**",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // using height function for option3 of diameter function\\n    int height(TreeNode* node){\\n        if(node == NULL){\\n            return 0;\\n        }\\n        \\n        int leftHeight = height(node->left);\\n        int rightHeight = height(node->right);\\n        \\n        return 1 + max(leftHeight, rightHeight);\\n    }\\n    \\n    int diameterOfBinaryTree(TreeNode* root){\\n        // base case\\n        if(root == NULL){\\n            return 0;\\n        }\\n        \\n        // diameter will of either of these:- either in left only, either in right only, either combination of both\\n        \\n        int option1 = diameterOfBinaryTree(root->left); // either in left\\n        \\n        int option2 = diameterOfBinaryTree(root->right); // either in right\\n        \\n        int option3 = height(root->left) + height(root->right); // either combination of both\\n        \\n        int ans = max(option1, max(option2, option3));\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2749008,
                "title": "easy-c-solution-o-n-time-complexity",
                "content": "Here is my C++ Solution\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int maxi=0;\\n    int demo(TreeNode* root){\\n        if (root==NULL)return 0;\\n        int lh= demo(root->left);\\n        int rh= demo(root->right);\\n        maxi= max(maxi,lh+rh);\\n        return 1+max(lh,rh);\\n    }\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        demo(root);\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int maxi=0;\\n    int demo(TreeNode* root){\\n        if (root==NULL)return 0;\\n        int lh= demo(root->left);\\n        int rh= demo(root->right);\\n        maxi= max(maxi,lh+rh);\\n        return 1+max(lh,rh);\\n    }\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        demo(root);\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2747857,
                "title": "easy-java-sol-o-n-complexity",
                "content": "```\\nint max=0;\\npublic int diameterOfBinaryTree(TreeNode root) {\\n\\tmaxDepth(root);\\n\\treturn max;\\n}\\nprivate int maxDepth(TreeNode root) {\\n\\tif (root == null) return 0;\\n\\n\\tint left = maxDepth(root.left);\\n\\tint right = maxDepth(root.right);\\n\\n\\tmax = Math.max(max, left + right);\\n\\n\\treturn Math.max(left, right) + 1;\\n}\\n```\\n**O(n)^2 Approach**\\n\\nint diameter(Node root) {\\n         if(root == null){\\n            return 0;\\n        }\\n      int op1 = diameter(root.left);\\n      int op2 = diameter(root.right);\\n      int op3 = height(root.left)+ 1 + height(root.right);\\n      \\n      int ans = Math.max(op1,Math.max(op2,op3));\\n      return ans;\\n    }\\n    int height(Node root){\\n        if(root == null){\\n            return 0;\\n        }\\n        int left=height(root.left);\\n        int right=height(root.right);\\n        int maxheight=Math.max(left,right)+1;\\n        return maxheight;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nint max=0;\\npublic int diameterOfBinaryTree(TreeNode root) {\\n\\tmaxDepth(root);\\n\\treturn max;\\n}\\nprivate int maxDepth(TreeNode root) {\\n\\tif (root == null) return 0;\\n\\n\\tint left = maxDepth(root.left);\\n\\tint right = maxDepth(root.right);\\n\\n\\tmax = Math.max(max, left + right);\\n\\n\\treturn Math.max(left, right) + 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2677080,
                "title": "java-solution",
                "content": "```\\n    public int diameterOfBinaryTree(TreeNode root) {\\n        int[] diameter=new int[1];\\n        findHeight(root,diameter);\\n        return diameter[0];\\n    }\\n    private int findHeight(TreeNode root,int[] dia){\\n        if(root==null) return 0;\\n        int left=findHeight(root.left,dia);\\n        int right=findHeight(root.right,dia);\\n        dia[0]=Math.max(dia[0],left+right);\\n        return 1+Math.max(left,right);\\n    }\\n",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\n    public int diameterOfBinaryTree(TreeNode root) {\\n        int[] diameter=new int[1];\\n        findHeight(root,diameter);\\n        return diameter[0];\\n    }\\n    private int findHeight(TreeNode root,int[] dia){\\n        if(root==null) return 0;\\n        int left=findHeight(root.left,dia);\\n        int right=findHeight(root.right,dia);\\n        dia[0]=Math.max(dia[0],left+right);\\n        return 1+Math.max(left,right);\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2635935,
                "title": "100-fastest-solution-with-explain-best-approach-easy-to-understand",
                "content": "**Read the below approach to understand the logic.**\\n\\n***Please upvote if you like it***\\n\\n**Approach :** \\n\\n* Start traversing the tree recursively and do work in Post Order.\\n* In the Post Order of every node , calculate diameter and height of the current node.\\n* If current diameter is maximum then update the variable used to store the maximum diameter.\\n* Return height of current node to the previous recursive call.\\n\\n\\n**Dry Run :**\\nIn Post Order, Start traversing the tree:\\n![image](https://assets.leetcode.com/users/images/0c33cd3b-7085-4cfd-8473-a490f99f0824_1664391919.663714.png)\\n\\n**C++Code:**\\n```\\nclass Solution {\\npublic:\\n    int solve(TreeNode* root,int& daimeter){\\n        if(!root) return 0;\\n        \\n        int left=solve(root->left,daimeter);\\n        int right=solve(root->right,daimeter);\\n        daimeter = max(daimeter,left+right);\\n        \\n        return 1+max(left,right);\\n    }\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        int daimeter=INT_MIN;\\n        solve(root,daimeter);\\n        return daimeter;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(TreeNode* root,int& daimeter){\\n        if(!root) return 0;\\n        \\n        int left=solve(root->left,daimeter);\\n        int right=solve(root->right,daimeter);\\n        daimeter = max(daimeter,left+right);\\n        \\n        return 1+max(left,right);\\n    }\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        int daimeter=INT_MIN;\\n        solve(root,daimeter);\\n        return daimeter;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2417518,
                "title": "simple-java-solution-0-ms",
                "content": "```\\nclass Solution {\\n    int diameter = 0;\\n    \\n    public int computeHeight(TreeNode root){\\n        if(root == null){\\n            return 0;\\n        }\\n        \\n        int leftHeight = computeHeight(root.left), rightHeight = computeHeight(root.right);\\n        diameter = Math.max(diameter, leftHeight + rightHeight);\\n        return 1 + Math.max(leftHeight, rightHeight);\\n    }\\n    \\n    public int diameterOfBinaryTree(TreeNode root) {\\n        computeHeight(root);\\n        return diameter;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int diameter = 0;\\n    \\n    public int computeHeight(TreeNode root){\\n        if(root == null){\\n            return 0;\\n        }\\n        \\n        int leftHeight = computeHeight(root.left), rightHeight = computeHeight(root.right);\\n        diameter = Math.max(diameter, leftHeight + rightHeight);\\n        return 1 + Math.max(leftHeight, rightHeight);\\n    }\\n    \\n    public int diameterOfBinaryTree(TreeNode root) {\\n        computeHeight(root);\\n        return diameter;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2123764,
                "title": "c-recursion-diameter-of-binary-tree",
                "content": "```\\nclass Solution {\\npublic:\\n    int max_dia=0;\\n    int find_dia(TreeNode* root){\\n        if(!root)   return 0;\\n        int leftdia = find_dia(root->left);\\n        int rightdia = find_dia(root->right);\\n        int curr_dia = leftdia+rightdia;\\n        max_dia=max(max_dia,curr_dia);\\n        cout<<max_dia<<\" \";\\n        return max(leftdia,rightdia)+1;\\n    }\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        int dia=find_dia(root);\\n        return max_dia;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int max_dia=0;\\n    int find_dia(TreeNode* root){\\n        if(!root)   return 0;\\n        int leftdia = find_dia(root->left);\\n        int rightdia = find_dia(root->right);\\n        int curr_dia = leftdia+rightdia;\\n        max_dia=max(max_dia,curr_dia);\\n        cout<<max_dia<<\" \";\\n        return max(leftdia,rightdia)+1;\\n    }\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        int dia=find_dia(root);\\n        return max_dia;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1973394,
                "title": "iterative-python-solution-o-n-beats-99-52-memory",
                "content": "This is an iterative solution that hopefully makes sense. It beats **99.52%** of Python solutions in terms of memory.\\n\\nGeneral Approach\\n---------------------------------------------\\nThe general approach is similar to the recursive approach. Namely, we test each node as being the \"corner\"(where both the left and right nodes are part of this path) of the longest path. This is because the longest path will involve a node being its corner, so if we test every node we will eventually find the right one. \\nNow, if the heights of the left and right children sum to a value greater than the current longest path, this new value is the longest path. We note that the height of any node equals one plus the height of whichever child node has a longer height.\\n\\nWe utilize a dictionary to store the heights of every node. As long as we only look at a node after we have gotten height values for its children, then we will have no issue. Now, how do we revisit nodes iteratively?\\n\\nRevisiting Nodes\\n------------------------\\nThe key insight here is that when we add a node to the stack, we also add a counter indiciating how many of its children we have seen. We shall use the following mapping:\\n\\n**0**: no children have been seen\\n**1**: if left child exists, it has already been seen\\n**2**: if right child exists, it has already been seen\\n\\nAs an example, here is how we insert the root node\\n```\\nstack = [[root, 0]]\\n```\\nWe shall loop over the stack, but **only** pop an element once we have considered both possible children. Namely, if the counter for the last element in the stack has a value of **2**\\n\\nWhen this happens, we know for a fact that we have finishing visiting both children. Thus, their heights will be in the dictionary of height values. We access this dictionary to both calculate the height of the current node, as well as if it is the \"corner\" of the longest path. Finally, once our stack is empty, we shall return the variable that stores the lenght of the longest path.\\n\\nPutting it All Together\\n----------------\\n\\nHere is the final code combining these ideas:\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        lp = 0\\n        stack = [[root, 0]]\\n        heights = {}\\n        while stack:\\n            node, counter = stack[-1]\\n            if counter == 0:\\n                stack[-1][1] = 1\\n                if node.left:\\n                    stack.append([node.left, 0])\\n            elif counter == 1:\\n                stack[-1][1] = 2\\n                if node.right:\\n                    stack.append([node.right, 0])\\n            elif counter == 2:\\n                left = heights.get(node.left, 0)\\n                right = heights.get(node.right, 0)\\n                if left + right > lp:\\n                    lp = left + right\\n                heights[node] = max(left, right) + 1\\n                stack.pop()\\n        return lp\\n```\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```\\nstack = [[root, 0]]\\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        lp = 0\\n        stack = [[root, 0]]\\n        heights = {}\\n        while stack:\\n            node, counter = stack[-1]\\n            if counter == 0:\\n                stack[-1][1] = 1\\n                if node.left:\\n                    stack.append([node.left, 0])\\n            elif counter == 1:\\n                stack[-1][1] = 2\\n                if node.right:\\n                    stack.append([node.right, 0])\\n            elif counter == 2:\\n                left = heights.get(node.left, 0)\\n                right = heights.get(node.right, 0)\\n                if left + right > lp:\\n                    lp = left + right\\n                heights[node] = max(left, right) + 1\\n                stack.pop()\\n        return lp\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1920442,
                "title": "easy-to-understand-and-simple-java-solution-for-beginners",
                "content": "public class Solution {\\n    \\n    // Don\\'t declare global variable.\\n    // It won\\'t be allowed in interview\\n    \\n    public int diameterOfBinaryTree(TreeNode root) {\\n        int[] result = new int[1];\\n        maxDepth(root,result);\\n        return result[0];\\n    }\\n    \\n    private int maxDepth(TreeNode root, int[] result) {\\n        if (root == null) \\n            return 0;\\n        \\n        // Getting the height of left and right sub tree\\n        int leftHeight = maxDepth(root.left, result);\\n        int rightHeight = maxDepth(root.right, result);\\n        \\n        //Storing the result of maximum out of left + right height and result  \\n        result[0] = Math.max(result[0], leftHeight + rightHeight);\\n        \\n        return 1 + Math.max(leftHeight, rightHeight);\\n    }\\n}",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\n    \\n    // Don\\'t declare global variable.\\n    // It won\\'t be allowed in interview\\n    \\n    public int diameterOfBinaryTree(TreeNode root) {\\n        int[] result = new int[1];\\n        maxDepth(root,result);\\n        return result[0];\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1781151,
                "title": "java-code-with-notes",
                "content": "```\\nclass Solution {\\n    public int diameterOfBinaryTree(TreeNode root) {\\n        int[] diameter = new int[1];\\n        height(root, diameter);\\n        return diameter[0];\\n    }\\n\\n    private int height(TreeNode root, int[] diameter){\\n        if(root == null) return 0;\\n\\n        int lh = height(node.left, diameter);\\n        int rh = height(node.right, diameter);\\n        diameter[0] = Math.max(diameter[0], lh + rh);\\n        return 1 + Math.max(lh, rh);\\n    }\\n}\\n```\\n\\nNotes Link \\nhttps://github.com/rizonkumar/LeetCode-Notes/blob/main/543.pdf",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int diameterOfBinaryTree(TreeNode root) {\\n        int[] diameter = new int[1];\\n        height(root, diameter);\\n        return diameter[0];\\n    }\\n\\n    private int height(TreeNode root, int[] diameter){\\n        if(root == null) return 0;\\n\\n        int lh = height(node.left, diameter);\\n        int rh = height(node.right, diameter);\\n        diameter[0] = Math.max(diameter[0], lh + rh);\\n        return 1 + Math.max(lh, rh);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1501348,
                "title": "c-solution-for-543-diameter-of-binary-tree",
                "content": "```\\nclass Solution {\\npublic:\\n    int diameterOfBinaryTree(TreeNode* root) \\n    {\\n        int diameter = 0;\\n        helper(root, diameter);\\n        return diameter;\\n    }\\n    int helper(TreeNode* root, int& diameter)\\n    {   if(root == NULL){return 0;}\\n        int lh = helper(root->left, diameter) ;\\n        int rh = helper(root->right, diameter) ;\\n        diameter = max(diameter, lh+rh);\\n        \\n        return 1 + max(lh, rh) ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int diameterOfBinaryTree(TreeNode* root) \\n    {\\n        int diameter = 0;\\n        helper(root, diameter);\\n        return diameter;\\n    }\\n    int helper(TreeNode* root, int& diameter)\\n    {   if(root == NULL){return 0;}\\n        int lh = helper(root->left, diameter) ;\\n        int rh = helper(root->right, diameter) ;\\n        diameter = max(diameter, lh+rh);\\n        \\n        return 1 + max(lh, rh) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1466766,
                "title": "c-recursive",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int getDiameter(TreeNode *root, int &diameter)\\n    {\\n        // base case: tree is empty\\n        if (root == NULL)\\n        {\\n            return 0;\\n        }\\n\\n        // get heights of left and right subtrees\\n        int left_height = getDiameter(root->left, diameter);\\n        int right_height = getDiameter(root->right, diameter);\\n\\n        // calculate diameter \"through\" the current node\\n        int max_diameter = left_height + right_height;\\n\\n        diameter = max(diameter, max_diameter);\\n\\n        // it is important to return the height of the subtree rooted at the current node\\n        return max(left_height, right_height) + 1;\\n    }\\n\\n    int diameterOfBinaryTree(TreeNode *root)\\n    {\\n        int diameter = 0;\\n        getDiameter(root, diameter);\\n\\n        return diameter;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution\\n{\\npublic:\\n    int getDiameter(TreeNode *root, int &diameter)\\n    {\\n        // base case: tree is empty\\n        if (root == NULL)\\n        {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1296242,
                "title": "python-96-83-faster",
                "content": "```\\nclass Solution:\\n   \\n    def diameterOfBinaryTree(self, root: TreeNode) -> int:\\n        if not root:\\n            return 0\\n        ans = []\\n        def dfs(node: TreeNode) -> int:\\n            if not node:\\n                return 0\\n            l = dfs(node.left)   #max depth of node.left\\n            r =  dfs(node.right) #max depth of node.right\\n            ans.append(l + r) #array for paths of each root\\n            return 1 + max(l, r)\\n        dfs(root)\\n        return max(ans)\\n```\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n   \\n    def diameterOfBinaryTree(self, root: TreeNode) -> int:\\n        if not root:\\n            return 0\\n        ans = []\\n        def dfs(node: TreeNode) -> int:\\n            if not node:\\n                return 0\\n            l = dfs(node.left)   #max depth of node.left\\n            r =  dfs(node.right) #max depth of node.right\\n            ans.append(l + r) #array for paths of each root\\n            return 1 + max(l, r)\\n        dfs(root)\\n        return max(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1241954,
                "title": "maximum-depth-approach-java",
                "content": "```\\nclass Solution {\\n    int result=0;\\n    public int diameterOfBinaryTree(TreeNode root) {\\n        findDiaTemp(root);\\n        return result;\\n    }\\n    \\n    public int findDiaTemp(TreeNode root){\\n        if(root==null)\\n            return 0;\\n        int left=findDiaTemp(root.left);\\n        int right=findDiaTemp(root.right);\\n        int curr_sum=left+right;\\n        int max_l_r=Math.max(left,right)+1;\\n        result=Math.max(result,curr_sum);\\n        return max_l_r;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int result=0;\\n    public int diameterOfBinaryTree(TreeNode root) {\\n        findDiaTemp(root);\\n        return result;\\n    }\\n    \\n    public int findDiaTemp(TreeNode root){\\n        if(root==null)\\n            return 0;\\n        int left=findDiaTemp(root.left);\\n        int right=findDiaTemp(root.right);\\n        int curr_sum=left+right;\\n        int max_l_r=Math.max(left,right)+1;\\n        result=Math.max(result,curr_sum);\\n        return max_l_r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1215884,
                "title": "c-simple-recursion",
                "content": "``` c#\\n\\npublic class Solution {\\n    public int Solve(TreeNode root, ref int current){\\n        if (root == null) return 0;\\n        \\n        var left  = Solve(root.left, ref current);\\n        var right = Solve(root.right, ref current);\\n        current = Math.Max(current, left + right);\\n      \\n        return Math.Max(left, right) +1;\\n    }\\n    \\n    public int DiameterOfBinaryTree(TreeNode root) {\\n        var current = int.MinValue;\\n        Solve(root, ref current);\\n        return current;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "``` c#\\n\\npublic class Solution {\\n    public int Solve(TreeNode root, ref int current){\\n        if (root == null) return 0;\\n        \\n        var left  = Solve(root.left, ref current);\\n        var right = Solve(root.right, ref current);\\n        current = Math.Max(current, left + right);\\n      \\n        return Math.Max(left, right) +1;\\n    }\\n    \\n    public int DiameterOfBinaryTree(TreeNode root) {\\n        var current = int.MinValue;\\n        Solve(root, ref current);\\n        return current;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1130567,
                "title": "c-clean-and-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int height(TreeNode*root)\\n    {\\n        if(root==NULL)\\n            return 0;\\n        return max(height(root->left),height(root->right))+1;\\n    }\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        if(root==NULL)\\n            return 0;\\n        int h1=height(root->left)+height(root->right);\\n        int h2=diameterOfBinaryTree(root->left);\\n        int h3=diameterOfBinaryTree(root->right);\\n        \\n        return max(h1,max(h2,h3));\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int height(TreeNode*root)\\n    {\\n        if(root==NULL)\\n            return 0;\\n        return max(height(root->left),height(root->right))+1;\\n    }\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        if(root==NULL)\\n            return 0;\\n        int h1=height(root->left)+height(root->right);\\n        int h2=diameterOfBinaryTree(root->left);\\n        int h3=diameterOfBinaryTree(root->right);\\n        \\n        return max(h1,max(h2,h3));\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935694,
                "title": "recursion-js-solution",
                "content": "```\\nvar diameterOfBinaryTree = function(root) {\\n  if (!root) return null;\\n  let max = 0;\\n  getHeight(root);\\n  return max;\\n  function getHeight(root) {\\n    if (!root) return 0; // height is defined to be the number of nodes in the path in this particular question instead of the number of edges\\n    let leftHeight = getHeight(root.left);\\n    let rightHeight = getHeight(root.right);\\n    max = Math.max(max, leftHeight + rightHeight);\\n    return Math.max(leftHeight, rightHeight) + 1;\\n  }\\n}; \\n\\n// Diameter: Height of left subtree + Height of right subtree\\n// Height: Max(Height of left subtree, Height of right subtree) + 1                                     \\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar diameterOfBinaryTree = function(root) {\\n  if (!root) return null;\\n  let max = 0;\\n  getHeight(root);\\n  return max;\\n  function getHeight(root) {\\n    if (!root) return 0; // height is defined to be the number of nodes in the path in this particular question instead of the number of edges\\n    let leftHeight = getHeight(root.left);\\n    let rightHeight = getHeight(root.right);\\n    max = Math.max(max, leftHeight + rightHeight);\\n    return Math.max(leftHeight, rightHeight) + 1;\\n  }\\n}; \\n\\n// Diameter: Height of left subtree + Height of right subtree\\n// Height: Max(Height of left subtree, Height of right subtree) + 1                                     \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 902903,
                "title": "java-dfs-postorder-with-detailed-explanation-after-i-struggled-for-a-long-time",
                "content": "**Important concept to note : maxNumOfNode = The Max of the following 3 values:**\\n\\n- (i) leftchild\\'s maxNumOfNode + rightchild\\'s maxNumOfNode + 1(due to including current node) (`^` shaped (i.e two legs))\\n- (ii) leftnode\\'s maxNumOfNode (`linear` shaped  (i.e one leg))\\n- (iii) rightnode\\'s maxNumOfNode (`linear` shaped  (i.e one leg))\\n\\n**=> (i) is used to find the `global maxNumOfNode`**\\n**=> (ii) and (iii) are used in the `getMaxNumOfNode` helper function as a returned value for their mom node to use**\\n\\n**Note**\\n- The `global maxNumOfNode` means the value that we are going to directly use to process the answer of this leetcode question (i.e (i) of the above 3 situations)\\n- The `local maxNumOfNode`(i.e in `getMaxNumOfNode`)  RETURNED only means (ii) or (iii) of the above 3 situations\\n\\n\\n       \\n\\t   \\n```\\n    private int maxNumOfNode = 0;  // global maxNumOfNode\\n    \\n    public int diameterOfBinaryTree(TreeNode root) {\\n\\t\\t// Calculate the global maxNumOfNode\\n        getMaxNumOfNode(root);\\n        \\n        // Get diameter here (i.e numOfNode - 1);\\n        return maxNumOfNode == 0 ? 0 : maxNumOfNode - 1; // -1 here because 5 nodes give a diameter of 4 (i.e edges)\\n    }\\n    \\n    public int getMaxNumOfNode(TreeNode node) { //postorder DFS\\n        if (node == null) return 0;\\n        int L = getMaxNumOfNode(node.left);\\n        int R = getMaxNumOfNode(node.right);\\n        maxNumOfNode = Math.max(maxNumOfNode, L+R+1);  //update global maxNumOfNode\\n        return Math.max(L, R) + 1;  // update its maxNumOfNode (i.e (left or right) + 1) for the mom node to use \\n    }\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "**Important concept to note : maxNumOfNode = The Max of the following 3 values:**\\n\\n- (i) leftchild\\'s maxNumOfNode + rightchild\\'s maxNumOfNode + 1(due to including current node) (`^` shaped (i.e two legs))\\n- (ii) leftnode\\'s maxNumOfNode (`linear` shaped  (i.e one leg))\\n- (iii) rightnode\\'s maxNumOfNode (`linear` shaped  (i.e one leg))\\n\\n**=> (i) is used to find the `global maxNumOfNode`**\\n**=> (ii) and (iii) are used in the `getMaxNumOfNode` helper function as a returned value for their mom node to use**\\n\\n**Note**\\n- The `global maxNumOfNode` means the value that we are going to directly use to process the answer of this leetcode question (i.e (i) of the above 3 situations)\\n- The `local maxNumOfNode`(i.e in `getMaxNumOfNode`)  RETURNED only means (ii) or (iii) of the above 3 situations\\n\\n\\n       \\n\\t   \\n```\\n    private int maxNumOfNode = 0;  // global maxNumOfNode\\n    \\n    public int diameterOfBinaryTree(TreeNode root) {\\n\\t\\t// Calculate the global maxNumOfNode\\n        getMaxNumOfNode(root);\\n        \\n        // Get diameter here (i.e numOfNode - 1);\\n        return maxNumOfNode == 0 ? 0 : maxNumOfNode - 1; // -1 here because 5 nodes give a diameter of 4 (i.e edges)\\n    }\\n    \\n    public int getMaxNumOfNode(TreeNode node) { //postorder DFS\\n        if (node == null) return 0;\\n        int L = getMaxNumOfNode(node.left);\\n        int R = getMaxNumOfNode(node.right);\\n        maxNumOfNode = Math.max(maxNumOfNode, L+R+1);  //update global maxNumOfNode\\n        return Math.max(L, R) + 1;  // update its maxNumOfNode (i.e (left or right) + 1) for the mom node to use \\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 881498,
                "title": "simple-cpp-solution-using-concept-of-height-of-a-node",
                "content": "```\\nclass Solution {\\npublic:\\n    int check(TreeNode* root,int &ma)\\n    {   if(root==NULL) return 0;\\n        int l=check(root->left,ma);\\n        int r=check(root->right,ma);\\n        ma=max(ma,(l+r));\\n        return max(l,r)+1;\\n    }\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        int ma=INT_MIN;\\n        if(root==NULL)  return 0;\\n        check(root,ma);\\n        return ma;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int check(TreeNode* root,int &ma)\\n    {   if(root==NULL) return 0;\\n        int l=check(root->left,ma);\\n        int r=check(root->right,ma);\\n        ma=max(ma,(l+r));\\n        return max(l,r)+1;\\n    }\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        int ma=INT_MIN;\\n        if(root==NULL)  return 0;\\n        check(root,ma);\\n        return ma;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 768202,
                "title": "disregard-the-official-solution-it-is-confusing-check-this-instead",
                "content": "This is a question that 90% of people code it wrong, including the official solution provided.\\nEven though the above code calculates the diameter correctly, the height is all messed up.\\n\\nFor tree of just one node, i.e. root, the code provided in solution will calculate\\n**Height as 1**(woww ...) ... This should be 0.\\n**Diameter as 0**\\n\\n**Since we have to find the diameter only, no one cares what height finally reaches the root or a calling node.\\nThis is BAD!!**\\n\\nThe following is the correct way, that calculates height and diameter correctly.\\n\\n```\\nclass Solution \\n{\\n    // We need this so that we can access the recursive function\\n    private int diameter = 0;\\n    \\n    public int diameterOfBinaryTree(TreeNode root) \\n    {\\n        heightAndDiameter(root);\\n        return diameter;\\n    }\\n    \\n    private int heightAndDiameter(TreeNode current)\\n    {\\n        if(current == null) return -1;\\n        \\n        int leftHeight = 1 + heightAndDiameter(current.left);\\n        int rightHeight = 1 + heightAndDiameter(current.right);\\n        \\n        diameter = Math.max(diameter, leftHeight + rightHeight);\\n        \\n        return Math.max(leftHeight, rightHeight);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    // We need this so that we can access the recursive function\\n    private int diameter = 0;\\n    \\n    public int diameterOfBinaryTree(TreeNode root) \\n    {\\n        heightAndDiameter(root);\\n        return diameter;\\n    }\\n    \\n    private int heightAndDiameter(TreeNode current)\\n    {\\n        if(current == null) return -1;\\n        \\n        int leftHeight = 1 + heightAndDiameter(current.left);\\n        int rightHeight = 1 + heightAndDiameter(current.right);\\n        \\n        diameter = Math.max(diameter, leftHeight + rightHeight);\\n        \\n        return Math.max(leftHeight, rightHeight);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 585466,
                "title": "java-iterative-based-on-awesome-idea-of-universal-iterative-binary-tree-traversals",
                "content": "it is easier to learn new things by associating them with things you already know.\\n\\nthe universal idea of traversing binary trees iteratively:\\nhttps://leetcode.com/problems/binary-tree-postorder-traversal/discuss/45559/My-Accepted-code-with-explaination.-Does-anyone-have-a-better-idea/45086\\n\\n```java\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public int diameterOfBinaryTree(TreeNode root) {\\n        if (root == null)\\n            return 0;\\n        Map<TreeNode, Integer> map = new HashMap<>();\\n        int res = 0;\\n        Deque<TreeNode> s = new ArrayDeque<>();\\n        s.push(root);    \\n        TreeNode last_pop = root;\\n        while ( ! s.isEmpty() )\\n        {        \\n            TreeNode top = s.peek();\\n            if ( // push_left\\n                top.left != null && \\n                top.left != last_pop && \\n                top.right != last_pop && \\n                ! map.containsKey(top.left) \\n            ) {\\n                s.push(top.left);\\n            } else if ( // push_right\\n                top.right != null && \\n                top.right != last_pop && \\n                (top.left == null || top.left == last_pop) &&\\n                !map.containsKey(top.right)\\n            ) {\\n                s.push(top.right);\\n            } else { // pop\\n                s.pop();\\n                last_pop = top;\\n                int leftDepth = map.getOrDefault(top.left, 0);\\n\\t\\t\\t\\tint rightDepth = map.getOrDefault(top.right, 0);\\n                map.put(top, 1 + Math.max(leftDepth, rightDepth));\\n                res = Math.max(res, leftDepth + rightDepth);\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```\\n\\nP.S. I was looking for a good iterative tree traversal solutions here on leetcode and I couln\\'t find better one yet.\\nP.P.S. That universal approach is good because it is written for all traversal types.\\nThe code is interlinked and looks very similar in all of them.",
                "solutionTags": [],
                "code": "```java\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public int diameterOfBinaryTree(TreeNode root) {\\n        if (root == null)\\n            return 0;\\n        Map<TreeNode, Integer> map = new HashMap<>();\\n        int res = 0;\\n        Deque<TreeNode> s = new ArrayDeque<>();\\n        s.push(root);    \\n        TreeNode last_pop = root;\\n        while ( ! s.isEmpty() )\\n        {        \\n            TreeNode top = s.peek();\\n            if ( // push_left\\n                top.left != null && \\n                top.left != last_pop && \\n                top.right != last_pop && \\n                ! map.containsKey(top.left) \\n            ) {\\n                s.push(top.left);\\n            } else if ( // push_right\\n                top.right != null && \\n                top.right != last_pop && \\n                (top.left == null || top.left == last_pop) &&\\n                !map.containsKey(top.right)\\n            ) {\\n                s.push(top.right);\\n            } else { // pop\\n                s.pop();\\n                last_pop = top;\\n                int leftDepth = map.getOrDefault(top.left, 0);\\n\\t\\t\\t\\tint rightDepth = map.getOrDefault(top.right, 0);\\n                map.put(top, 1 + Math.max(leftDepth, rightDepth));\\n                res = Math.max(res, leftDepth + rightDepth);\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 574381,
                "title": "python-3-leaner-and-faster-than-most-yet-readable",
                "content": "I think this solution is reasonably \"Pythonic\"--in a modern sense--while refraining from too much cleverness (according to long-time Java wrangler). It\\'s faster than nearly all of the Python solutions submitted so far, and somehow manages to beat 100% on space.\\n```\\nclass Solution:\\n\\n    def diameterOfBinaryTree(self, root: TreeNode) -> int:\\n        self.__length = 0       # modified directly by __do_dfs()\\n        if root:\\n            self.__do_dfs(root)\\n        return self.__length\\n\\t\\t\\n    def __do_dfs(self, root: TreeNode) -> int:\\n        # Recursive postorder traversal\\n        left = self.__do_dfs(root.left) if root.left else 0\\n        right = self.__do_dfs(root.right) if root.right else 0\\n        # Record the longest path seen so far\\n        self.__length = max(self.__length, left + right)\\n        # Return the longest path through this subtree root\\n        return max(left, right) + 1\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n\\n    def diameterOfBinaryTree(self, root: TreeNode) -> int:\\n        self.__length = 0       # modified directly by __do_dfs()\\n        if root:\\n            self.__do_dfs(root)\\n        return self.__length\\n\\t\\t\\n    def __do_dfs(self, root: TreeNode) -> int:\\n        # Recursive postorder traversal\\n        left = self.__do_dfs(root.left) if root.left else 0\\n        right = self.__do_dfs(root.right) if root.right else 0\\n        # Record the longest path seen so far\\n        self.__length = max(self.__length, left + right)\\n        # Return the longest path through this subtree root\\n        return max(left, right) + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 574091,
                "title": "c-simple-recursive-solution",
                "content": "```\\npublic class Solution {\\n    private int diam;\\n    \\n    public int DiameterOfBinaryTree(TreeNode root) {\\n        diam = 0;\\n        DFS(root);\\n        return diam;\\n    }\\n    \\n    private int DFS(TreeNode root) {\\n        if (root == null)\\n            return 0;\\n        \\n        int left = DFS(root.left);\\n        int right = DFS(root.right);\\n        \\n        diam = Math.Max(diam, left + right);\\n                                  \\n        return Math.Max(left, right) + 1;\\n    } \\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Recursion"
                ],
                "code": "```\\npublic class Solution {\\n    private int diam;\\n    \\n    public int DiameterOfBinaryTree(TreeNode root) {\\n        diam = 0;\\n        DFS(root);\\n        return diam;\\n    }\\n    \\n    private int DFS(TreeNode root) {\\n        if (root == null)\\n            return 0;\\n        \\n        int left = DFS(root.left);\\n        int right = DFS(root.right);\\n        \\n        diam = Math.Max(diam, left + right);\\n                                  \\n        return Math.Max(left, right) + 1;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 573577,
                "title": "easy-c-solution",
                "content": "For any node, diameter of the tree located at this node is\\n* Maximum of (diameter of left subtree, diameter of right subtree, sum of longest root to leaf path in left and right subtree)\\n* As every node of a tree is root of some other subtree we\\'ll use RECURSION to solve this problem\\n\\nCODE:\\n```\\nclass Solution {\\npublic:\\n    int max_ans = -1;    //This stores the maximum diameter of any subtree in the given tree\\n    int diameter(TreeNode* root){\\n        if(!root)                            return 0;\\n        if(!root->left && !root->right)      return 0;     //leaf node\\n        \\n        int leftMax = 0;\\n        if(root->left)\\n            leftMax =  1 + diameter(root->left);     //longest root to leaf path in left subtree\\n        \\n        int rightMax = 0;\\n        if(root->right)\\n            rightMax = 1 + diameter(root->right);   //longest root to leaf path in right subtree\\n        \\n        if(max_ans < leftMax+rightMax)       \\n            max_ans = leftMax + rightMax;\\n        \\n        return max(leftMax,rightMax);       //to parent we return longest path of left and right subtree\\n    }\\n    \\n    int diameterOfBinaryTree(TreeNode* root) {\\n     return max(max_ans,diameter(root));   \\n\\t /*\\n\\t Above statement will be more clear if you think of these two cases yourselves:\\n   ![image](https://assets.leetcode.com/users/chronoviser/image_1586591208.png)\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int max_ans = -1;    //This stores the maximum diameter of any subtree in the given tree\\n    int diameter(TreeNode* root){\\n        if(!root)                            return 0;\\n        if(!root->left && !root->right)      return 0;     //leaf node\\n        \\n        int leftMax = 0;\\n        if(root->left)\\n            leftMax =  1 + diameter(root->left);     //longest root to leaf path in left subtree\\n        \\n        int rightMax = 0;\\n        if(root->right)\\n            rightMax = 1 + diameter(root->right);   //longest root to leaf path in right subtree\\n        \\n        if(max_ans < leftMax+rightMax)       \\n            max_ans = leftMax + rightMax;\\n        \\n        return max(leftMax,rightMax);       //to parent we return longest path of left and right subtree\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 488724,
                "title": "kotlin-recursive-and-iterative",
                "content": "```\\n// backtracking\\n/**\\n * Traverse the tree in dfs, and while backtrack, keep track of 2 things\\n * 1. Farthest leaf node distance from current node, return it to caller adding 1 more edge\\n * 2. Max diameter under this node\\n *\\n * Every node will return max length path available under it.\\n * For every node calculate max distance by adding max length on left and right side of it,\\n * and keep track\\'of max found so far.\\n */\\nfun diameterOfBinaryTree(root: TreeNode?): Int {\\n    var ans = 0\\n    fun dfs(root: TreeNode?): Int {\\n        if (root == null) return 0\\n        var l = dfs(root.left)\\n        var r = dfs(root.right)\\n        ans = maxOf(ans, l + r)\\n        return maxOf(l, r) + 1\\n    }\\n    dfs(root)\\n    return ans\\n}\\n```\\n\\n```\\nfun diameterOfBinaryTree(root: TreeNode?): Int {\\n    if (root == null) return 0\\n    var maxSoFar = 0\\n    val s = Stack<TreeNode>()\\n    val map = mutableMapOf<TreeNode, Int>()\\n    s.push(root)\\n    while (!s.isEmpty()) {\\n        val node = s.peek() // kotlin ArrayDeque doesn\\'t have peek yet, so experimental\\n        if (node.left != null && !map.containsKey(node.left!!)) {\\n            s.push(node.left)\\n        } else if (node.right != null && !map.containsKey(node.right!!)) {\\n            s.push(node.right)\\n        } else {\\n            val cur = s.pop()\\n            val lmax = if(cur.left != null) map.getOrDefault(cur.left!!, 0) else 0\\n            val rmax = if(cur.right != null) map.getOrDefault(cur.right!!, 0) else 0\\n            val nodeMax = maxOf(lmax, rmax) + 1\\n            map[cur] = nodeMax\\n            maxSoFar = maxOf(maxSoFar, lmax + rmax)\\n        }\\n    }\\n    return maxSoFar\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// backtracking\\n/**\\n * Traverse the tree in dfs, and while backtrack, keep track of 2 things\\n * 1. Farthest leaf node distance from current node, return it to caller adding 1 more edge\\n * 2. Max diameter under this node\\n *\\n * Every node will return max length path available under it.\\n * For every node calculate max distance by adding max length on left and right side of it,\\n * and keep track\\'of max found so far.\\n */\\nfun diameterOfBinaryTree(root: TreeNode?): Int {\\n    var ans = 0\\n    fun dfs(root: TreeNode?): Int {\\n        if (root == null) return 0\\n        var l = dfs(root.left)\\n        var r = dfs(root.right)\\n        ans = maxOf(ans, l + r)\\n        return maxOf(l, r) + 1\\n    }\\n    dfs(root)\\n    return ans\\n}\\n```\n```\\nfun diameterOfBinaryTree(root: TreeNode?): Int {\\n    if (root == null) return 0\\n    var maxSoFar = 0\\n    val s = Stack<TreeNode>()\\n    val map = mutableMapOf<TreeNode, Int>()\\n    s.push(root)\\n    while (!s.isEmpty()) {\\n        val node = s.peek() // kotlin ArrayDeque doesn\\'t have peek yet, so experimental\\n        if (node.left != null && !map.containsKey(node.left!!)) {\\n            s.push(node.left)\\n        } else if (node.right != null && !map.containsKey(node.right!!)) {\\n            s.push(node.right)\\n        } else {\\n            val cur = s.pop()\\n            val lmax = if(cur.left != null) map.getOrDefault(cur.left!!, 0) else 0\\n            val rmax = if(cur.right != null) map.getOrDefault(cur.right!!, 0) else 0\\n            val nodeMax = maxOf(lmax, rmax) + 1\\n            map[cur] = nodeMax\\n            maxSoFar = maxOf(maxSoFar, lmax + rmax)\\n        }\\n    }\\n    return maxSoFar\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 479269,
                "title": "rust",
                "content": "```\\nimpl Solution {\\n    pub fn diameter_of_binary_tree(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\\n        let mut d = 1;\\n        Self::h(&root, &mut d);\\n        d - 1\\n    }\\n\\n    fn h(r: &Option<Rc<RefCell<TreeNode>>>, d: &mut i32) -> i32 {\\n        if let Some(r) = r {\\n            let r = r.borrow();\\n            let p = Self::h(&r.left, d);\\n            let q = Self::h(&r.right, d);\\n            *d = d.to_owned().max(p + q + 1);\\n            1 + p.max(q)\\n        } else {\\n            0\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn diameter_of_binary_tree(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\\n        let mut d = 1;\\n        Self::h(&root, &mut d);\\n        d - 1\\n    }\\n\\n    fn h(r: &Option<Rc<RefCell<TreeNode>>>, d: &mut i32) -> i32 {\\n        if let Some(r) = r {\\n            let r = r.borrow();\\n            let p = Self::h(&r.left, d);\\n            let q = Self::h(&r.right, d);\\n            *d = d.to_owned().max(p + q + 1);\\n            1 + p.max(q)\\n        } else {\\n            0\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 427729,
                "title": "javascript-w-comments",
                "content": "```\\nvar diameterOfBinaryTree = function(root) {\\n    if (!root) return 0\\n    let retVal = 0\\n    \\n    const dfs = node => {\\n        if (!node) return 0 // off the tree\\n        const left = dfs(node.left) // get left depth\\n        const right = dfs(node.right) // get right depth\\n        retVal = Math.max(retVal, left+right) // check if path is longer than max\\n        return Math.max(left,right) + 1 // return the length of the deepest path\\n    }\\n    dfs(root)\\n    \\n    return retVal\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar diameterOfBinaryTree = function(root) {\\n    if (!root) return 0\\n    let retVal = 0\\n    \\n    const dfs = node => {\\n        if (!node) return 0 // off the tree\\n        const left = dfs(node.left) // get left depth\\n        const right = dfs(node.right) // get right depth\\n        retVal = Math.max(retVal, left+right) // check if path is longer than max\\n        return Math.max(left,right) + 1 // return the length of the deepest path\\n    }\\n    dfs(root)\\n    \\n    return retVal\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 396715,
                "title": "c-recursive-readable-solution-using-local-function",
                "content": "```\\n public int DiameterOfBinaryTree(TreeNode root)\\n        {\\n            int max = 0;\\n            MaxHeight(root);\\n\\n            return max;\\n\\n            int MaxHeight(TreeNode node)\\n            {\\n                if (node == null)\\n                    return 0;\\n\\n                int left = MaxHeight(node.left) + 1;\\n                int right = MaxHeight(node.right) + 1;\\n                max = Math.Max(max, left + right - 2);\\n\\n                return Math.Max(left, right);\\n            }\\n        }\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\n public int DiameterOfBinaryTree(TreeNode root)\\n        {\\n            int max = 0;\\n            MaxHeight(root);\\n\\n            return max;\\n\\n            int MaxHeight(TreeNode node)\\n            {\\n                if (node == null)\\n                    return 0;\\n\\n                int left = MaxHeight(node.left) + 1;\\n                int right = MaxHeight(node.right) + 1;\\n                max = Math.Max(max, left + right - 2);\\n\\n                return Math.Max(left, right);\\n            }\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 324097,
                "title": "python-greedy-bfs-approach",
                "content": "Intuition:\\n1. let \\'n\\' = any node in the tree\\n2. let \\'a\\' = furthest node from \\'n\\' (via bfs)\\n3. let \\'b\\' = furthest node from \\'a\\' (via bfs)\\n4. Result:  Distance from \\'a\\' -> \\'b\\' is the diameter\\n\\nApproach:\\n1. We need to root any arbitrary node in the tree so we construct a graph.\\n2. After completing 1, we can run standard breadth-first-search to get find the diameter.\\n\\n\\n```\\nfrom collections import defaultdict, deque\\n\\nclass Solution:\\n\\ndef diameterOfBinaryTree(self, root: TreeNode) -> int:\\n\\tif not root: return 0\\n\\tgraph = defaultdict(list)\\n\\tself.construct_graph(graph, root, parent=None)\\n\\t_, target = self.bfs(graph, root)\\n\\tdiameter, _ = self.bfs(graph, target)\\n\\treturn diameter\\n\\ndef construct_graph(self, graph, root, parent):\\n\\tif not root:\\n\\t\\treturn\\n\\tif parent:\\n\\t\\tgraph[root].append(parent)\\n\\tif root.left:\\n\\t\\tgraph[root].append(root.left)\\n\\t\\tself.construct_graph(graph, root.left, root)\\n\\tif root.right:\\n\\t\\tgraph[root].append(root.right)\\n\\t\\tself.construct_graph(graph, root.right, root)\\n\\ndef bfs(self, graph, root):\\n\\tque, visited = deque([root]), set([root])\\n\\tlevel, ret = -1, 0\\n\\twhile que:\\n\\t\\tsize = len(que)\\n\\t\\tfor _ in range(size):\\n\\t\\t\\tcurr = que.popleft()\\n\\t\\t\\tret = curr\\n\\t\\t\\tfor nxt in graph[curr]:\\n\\t\\t\\t\\tif nxt not in visited:\\n\\t\\t\\t\\t\\tvisited.add(nxt)\\n\\t\\t\\t\\t\\tque.append(nxt)\\n\\t\\tlevel += 1\\n\\treturn level, ret\\n```\\n",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict, deque\\n\\nclass Solution:\\n\\ndef diameterOfBinaryTree(self, root: TreeNode) -> int:\\n\\tif not root: return 0\\n\\tgraph = defaultdict(list)\\n\\tself.construct_graph(graph, root, parent=None)\\n\\t_, target = self.bfs(graph, root)\\n\\tdiameter, _ = self.bfs(graph, target)\\n\\treturn diameter\\n\\ndef construct_graph(self, graph, root, parent):\\n\\tif not root:\\n\\t\\treturn\\n\\tif parent:\\n\\t\\tgraph[root].append(parent)\\n\\tif root.left:\\n\\t\\tgraph[root].append(root.left)\\n\\t\\tself.construct_graph(graph, root.left, root)\\n\\tif root.right:\\n\\t\\tgraph[root].append(root.right)\\n\\t\\tself.construct_graph(graph, root.right, root)\\n\\ndef bfs(self, graph, root):\\n\\tque, visited = deque([root]), set([root])\\n\\tlevel, ret = -1, 0\\n\\twhile que:\\n\\t\\tsize = len(que)\\n\\t\\tfor _ in range(size):\\n\\t\\t\\tcurr = que.popleft()\\n\\t\\t\\tret = curr\\n\\t\\t\\tfor nxt in graph[curr]:\\n\\t\\t\\t\\tif nxt not in visited:\\n\\t\\t\\t\\t\\tvisited.add(nxt)\\n\\t\\t\\t\\t\\tque.append(nxt)\\n\\t\\tlevel += 1\\n\\treturn level, ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 195958,
                "title": "javascript",
                "content": "```\\nvar diameterOfBinaryTree = function(root) {\\n    let result = 1;\\n    dfs(root)\\n    \\n    function dfs(root) {\\n        if(!root) {\\n            return 0;\\n        }\\n        let l = dfs(root.left);\\n        let r = dfs(root.right);\\n        result = Math.max(result, l + r + 1);\\n        return Math.max(l, r) + 1;\\n    }\\n    \\n    return result - 1;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar diameterOfBinaryTree = function(root) {\\n    let result = 1;\\n    dfs(root)\\n    \\n    function dfs(root) {\\n        if(!root) {\\n            return 0;\\n        }\\n        let l = dfs(root.left);\\n        let r = dfs(root.right);\\n        result = Math.max(result, l + r + 1);\\n        return Math.max(l, r) + 1;\\n    }\\n    \\n    return result - 1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 179597,
                "title": "iterative-java-solution-using-stack",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public int diameterOfBinaryTree(TreeNode root) {\\n        \\n        Stack<TreeNode> stack = new Stack<>();\\n        Map<TreeNode, Integer> lmap = new HashMap<>(); //Keeps track of the height each node\\n        stack.push(root);\\n        int maxL = 0;\\n        int length=0;\\n        while(!stack.isEmpty()){\\n            \\n            TreeNode t = stack.pop();\\n            if (t!=null){\\n                Integer left = lmap.get(t.left);\\n                Integer right = lmap.get(t.right);\\n                if (left!= null && right!=null){\\n                    lmap.put(t, Math.max(left, right)+1);//updates the height in lmap\\n                    maxL = Math.max(maxL, left + right); \\n                }\\n                else{\\n                    stack.push(t); //save and continue if current node hasn\\'t been visited before\\n                    stack.push(t.right);\\n                    stack.push(t.left);\\n                }\\n            }\\n            else\\n                lmap.put(null, 0);\\n        }\\n        return maxL;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public int diameterOfBinaryTree(TreeNode root) {\\n        \\n        Stack<TreeNode> stack = new Stack<>();\\n        Map<TreeNode, Integer> lmap = new HashMap<>(); //Keeps track of the height each node\\n        stack.push(root);\\n        int maxL = 0;\\n        int length=0;\\n        while(!stack.isEmpty()){\\n            \\n            TreeNode t = stack.pop();\\n            if (t!=null){\\n                Integer left = lmap.get(t.left);\\n                Integer right = lmap.get(t.right);\\n                if (left!= null && right!=null){\\n                    lmap.put(t, Math.max(left, right)+1);//updates the height in lmap\\n                    maxL = Math.max(maxL, left + right); \\n                }\\n                else{\\n                    stack.push(t); //save and continue if current node hasn\\'t been visited before\\n                    stack.push(t.right);\\n                    stack.push(t.left);\\n                }\\n            }\\n            else\\n                lmap.put(null, 0);\\n        }\\n        return maxL;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 120003,
                "title": "python-3-recursive-and-iterative-solution",
                "content": "```\\nclass Solution_iterative:\\n    def diameterOfBinaryTree(self, root):\\n        stack = [(1, root)]\\n        d = {None: -1}\\n        diameter = 0\\n        while stack:\\n            indicator, node = stack.pop()\\n            if node is None:\\n                continue\\n            if indicator:\\n                # doing post-order traversal here\\n                stack.extend([(0, node), (1, node.right), (1, node.left)])\\n            else:\\n                left = d[node.left] + 1\\n                right = d[node.right] + 1\\n                d[node] = max(left, right)\\n                # build the hashtable from bottom up\\n                # the key is the node, the value is the node\\'s max depth\\n                diameter = max(diameter, left + right)\\n        return diameter\\n\\n\\nclass Solution_recursive:\\n    def diameterOfBinaryTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        def depth(root):\\n            if root is None:\\n                return 0\\n            left = depth(root.left)\\n            right = depth(root.right)\\n            self.diameter = max(self.diameter, left + right)\\n            return max(left, right) + 1\\n        self.diameter = 0\\n        depth(root)\\n        return self.diameter\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution_iterative:\\n    def diameterOfBinaryTree(self, root):\\n        stack = [(1, root)]\\n        d = {None: -1}\\n        diameter = 0\\n        while stack:\\n            indicator, node = stack.pop()\\n            if node is None:\\n                continue\\n            if indicator:\\n                # doing post-order traversal here\\n                stack.extend([(0, node), (1, node.right), (1, node.left)])\\n            else:\\n                left = d[node.left] + 1\\n                right = d[node.right] + 1\\n                d[node] = max(left, right)\\n                # build the hashtable from bottom up\\n                # the key is the node, the value is the node\\'s max depth\\n                diameter = max(diameter, left + right)\\n        return diameter\\n\\n\\nclass Solution_recursive:\\n    def diameterOfBinaryTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        def depth(root):\\n            if root is None:\\n                return 0\\n            left = depth(root.left)\\n            right = depth(root.right)\\n            self.diameter = max(self.diameter, left + right)\\n            return max(left, right) + 1\\n        self.diameter = 0\\n        depth(root)\\n        return self.diameter\\n```",
                "codeTag": "Java"
            },
            {
                "id": 115019,
                "title": "a-few-solutions",
                "content": "Post-order traversal of the tree and accumulate the (L)eft and (R)ight subtree lengths as the recursive stack unwinds.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun diameterOfBinaryTree(root: TreeNode?): Int {\\n        var best = 0\\n        fun go(root: TreeNode?): Int {\\n            if (root == null)\\n                return 0\\n            var (L, R) = listOf(go(root?.left), go(root?.right))\\n            best = Math.max(best, L + R)\\n            return 1 + Math.max(L, R)\\n        }\\n        go(root)\\n        return best\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet diameterOfBinaryTree = (root, best = 0) => {\\n    let go = root => {\\n        if (!root)\\n            return 0;\\n        let [L, R] = [go(root.left), go(root.right)];\\n        best = Math.max(best, L + R);\\n        return 1 + Math.max(L, R);\\n    };\\n    go(root);\\n    return best;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def diameterOfBinaryTree(self, root: Optional[TreeNode], best = 0) -> int:\\n        def go(root):\\n            nonlocal best\\n            if not root:\\n                return 0\\n            L, R = go(root.left), go(root.right)\\n            best = max(best, L + R)\\n            return 1 + max(L, R)\\n        go(root)\\n        return best\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using fun = function<int(TreeNode*)>;\\n    int diameterOfBinaryTree(TreeNode* root, int best = 0) {\\n        fun go = [&](auto root) {\\n            if (!root)\\n                return 0;\\n            auto L = go(root->left),\\n                 R = go(root->right);\\n            best = max(best, L + R);\\n            return 1 + max(L, R);\\n        };\\n        go(root);\\n        return best;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun diameterOfBinaryTree(root: TreeNode?): Int {\\n        var best = 0\\n        fun go(root: TreeNode?): Int {\\n            if (root == null)\\n                return 0\\n            var (L, R) = listOf(go(root?.left), go(root?.right))\\n            best = Math.max(best, L + R)\\n            return 1 + Math.max(L, R)\\n        }\\n        go(root)\\n        return best\\n    }\\n}\\n```\n```\\nlet diameterOfBinaryTree = (root, best = 0) => {\\n    let go = root => {\\n        if (!root)\\n            return 0;\\n        let [L, R] = [go(root.left), go(root.right)];\\n        best = Math.max(best, L + R);\\n        return 1 + Math.max(L, R);\\n    };\\n    go(root);\\n    return best;\\n};\\n```\n```\\nclass Solution:\\n    def diameterOfBinaryTree(self, root: Optional[TreeNode], best = 0) -> int:\\n        def go(root):\\n            nonlocal best\\n            if not root:\\n                return 0\\n            L, R = go(root.left), go(root.right)\\n            best = max(best, L + R)\\n            return 1 + max(L, R)\\n        go(root)\\n        return best\\n```\n```\\nclass Solution {\\npublic:\\n    using fun = function<int(TreeNode*)>;\\n    int diameterOfBinaryTree(TreeNode* root, int best = 0) {\\n        fun go = [&](auto root) {\\n            if (!root)\\n                return 0;\\n            auto L = go(root->left),\\n                 R = go(root->right);\\n            best = max(best, L + R);\\n            return 1 + max(L, R);\\n        };\\n        go(root);\\n        return best;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1575770,
                "content": [
                    {
                        "username": "SouthernHumor",
                        "content": "How the hek is this problem/program marked easy ? Solutions I\\'m seeing involve 2 recursive functions and this is just not quick or straightforward"
                    },
                    {
                        "username": "gbiems",
                        "content": "This one one of the first tree problems I tried to do on leetcode, since I was looking for \"easy\" tree problems. Oof. Now that I have some more experience, I feel a lot better about how hard I found it when I was starting out. This isn\\'t an easy problem. I come back to it and re-solve it every now and then.\\n\\nI think what makes it difficult is that (in the most common solution I\\'ve seen) you need to return a value from a recursive function (the max length of left or right branch from each node) but you need to set a class variable or other way of tracking the maximum value of the left + right branches.\\n\\nThat\\'s a lot to wrap your head around when you\\'re first looking for recursive tree problems. But hey, if you stick with it, you\\'ll get this, and it\\'s a great problem for tracking variable values in recursive functions. \\n\\nBut having solved a bunch of leetcode problems, I\\'d definitely say this one is medium, not easy. If I didn\\'t know the answer, I think I\\'d still struggle to get this one. "
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "[@eduard92](/eduard92) \"laid off already\" LMFAOOOO \\uD83D\\uDE02\\uD83D\\uDC80"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its easy for those who already know.. maybe they are in uni and already solved in there and they solve it here too.\nSome of us just come here with an empty mind to push forward and is hard if you have no background. I approached this month DP and Trees for the first time in my life, it surely developed a way of thinking of data in terms of a Tree and Recursion in my mind works now as a Stack, isn't something hard to explain anymore, but I still check discuss and other websites for pseudocode.\n\nI know the comment is old, dude probably got at google and laid off already but for future people who feel stuck I think its about pushing into unkown.\n"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I agree. Unless you\\'ve seen the style of this solution somewhere before (it\\'s similar to the divide-and-conquer solution of the Maximum Subarray problem), you\\'ll probably have a tough time when coming into this problem with an empty mind."
                    },
                    {
                        "username": "chidam333",
                        "content": "here you have to just go through every node and find sum of heights of it\\'s left and right node , which is way easier than knowing the exact path... ig lol "
                    },
                    {
                        "username": "alvinato",
                        "content": "[4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]\\n\\n^ the above test case expects an answer of 8.  But I only count 7 edges between every node.  Between which two nodes are there 8 edges?"
                    },
                    {
                        "username": "suraj21209",
                        "content": "https://leetcode.com/problems/diameter-of-binary-tree/submissions/995832822/"
                    },
                    {
                        "username": "chidam333",
                        "content": "Note that the path does not need to pass through the root"
                    },
                    {
                        "username": "toho42",
                        "content": "copy and paste that to the test case to view the binary tree.  The node with a root of -9 has a maxDepth(left) of 4, and a maxDepth(right) of 4.  Thus, the diameter is 8.  This is case where the maxDiameter of a child node exceeds the maxDepth of the parent node\\'s left and right branches.\\n"
                    },
                    {
                        "username": "mascomen4",
                        "content": "see my comment below: https://leetcode.com/problems/diameter-of-binary-tree/discussion/comments/1629510"
                    },
                    {
                        "username": "OBAAT",
                        "content": "Bullshit problem description. \\nBullshit definition for \"diameter\". \\nIs it so difficult to say instead \"longest path\"? \\nProblem writers are morons. "
                    },
                    {
                        "username": "xclusive102",
                        "content": "[@ahmedtsalem9](/ahmedtsalem9) But this is not the world of circles. I agree that using \\'longest path\\' is more appropriate in the world of trees."
                    },
                    {
                        "username": "chumaumenze",
                        "content": "[@ahmedtsalem9](/ahmedtsalem9) The description is not a good one. I could not implement this because I had a problem understanding the question. When they say diameter, it implies the logic of how the diameter of a circle works - the length of the line through the center that touches two points on the edge of the circle. I was calculating the height of the tree from root to leaf."
                    },
                    {
                        "username": "ahmedtsalem9",
                        "content": "Technically, \"Diameter\" is a precise term. In the world of circles, the diameter is the longest line that can ever be drawn within a circle.\\n\\nThe same exact definition applies to trees; it\\'s the longest \"path\" that can ever be drawn within a tree through its nodes."
                    },
                    {
                        "username": "rana_afifi",
                        "content": "Rather tricky. Don\\'t think it is considered easy "
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Me too."
                    },
                    {
                        "username": "myih",
                        "content": "Scrolling down the discussions and most of the solutions are basically the same as the solution for no.124, yet this one is marked as easy and 124 is hard? Is there a easier way for this problem?"
                    },
                    {
                        "username": "suraj21209",
                        "content": "[@dragon1105](/dragon1105) https://leetcode.com/problems/diameter-of-binary-tree/submissions/995832822/"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "This one feels more like a medium to me. But 124 has a waaaay stricter time limit. My solution for 124 is getting TLEd to oblivion even with caching("
                    },
                    {
                        "username": "dragon1105",
                        "content": "Yeah I think this should be labeled as medium. This can only be easy when you\\'ve known the solution of some similar problems like Maximum Subarray (especially the divide-and-conquer one)."
                    },
                    {
                        "username": "WizTheProgrammer",
                        "content": "\"Easy\""
                    },
                    {
                        "username": "Dummyy",
                        "content": "sdcs jhfb wi wiufhw eiu uhweofuwe hfowe fowefowe fhwoe"
                    },
                    {
                        "username": "jonathanferraro75",
                        "content": "banging his head on the keyboard out of frustration"
                    },
                    {
                        "username": "rajat_171",
                        "content": "I agree"
                    },
                    {
                        "username": "techpromulgator",
                        "content": "How is the diameter of the below test case is 8?\\n\\n[4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]\\n\\nWhen I visualize, I see that it\\'s 7 and I\\'m getting 7. But, the expected answer is 8"
                    },
                    {
                        "username": "gauravkumar125",
                        "content": "i got it as 8 "
                    },
                    {
                        "username": "stephanauwerda000",
                        "content": "Because you should calculate max diameter of EVERY node, not just the root.\\nThe node (-9) has a diameter of 8. \\nSo this is the max diameter which the function should return."
                    },
                    {
                        "username": "ande_ka_funda",
                        "content": "The solution to just find the maximum width is rather simple. \\n\\nHowever I was asked to also print the path (and not just find the diameter).\\n\\nTotally fumbled. I have been trying but I am unable to come up with an O(n) solution"
                    },
                    {
                        "username": "JustBored",
                        "content": "Can do a second dfs from the root node with the max diameter. Just memoise which child node leads to the max height for each node  which will tell you which direction to go beforehand. But you have to make sure you go in both directions in the first iteration of the 2nd dfs from the starting node. This will give you the best path in O(n).\n\nThe O(n^2) approach would be to store the maximum height path for each node and combine the child left and right path at the max diameter node to get the optimal path. You can do this in one dfs but the tc is still O(n^2)\n    "
                    },
                    {
                        "username": "dhruvpithwa1999",
                        "content": "[@uchihahardik](/uchihahardik) You can refer to my soln, https://leetcode.com/problems/diameter-of-binary-tree/submissions/869730789/\\n\\nI have tried to solve and find path using ArrayList, same approach but different return type\\n\\nmay be this can help you.."
                    },
                    {
                        "username": "uchihahardik",
                        "content": "\"The solution to just find the maximum width is rather simple.\"\\nI am not able to think of an approch any tip?"
                    },
                    {
                        "username": "keJum",
                        "content": "# Example 1\\n![image](https://assets.leetcode.com/users/images/9f86a81d-aef1-4090-a327-14071d450001_1634631307.9913106.png)\\n\\nResult 3, expected 3\\n\\n# Example 100\\n![image](https://assets.leetcode.com/users/images/e671990e-09a1-4deb-b605-5bd4c15419cb_1634631254.7966447.png)\\n\\nResult 7, expected 8.\\n\\nWhy is the result expected to be 8 and not 7?"
                    },
                    {
                        "username": "ishananchit",
                        "content": "because of the path -4, 6, 6, 9, -9, -7, -6, 9, -2"
                    },
                    {
                        "username": "howhowone",
                        "content": "-2 9 -6 -7 -9 9 6 0 -1"
                    },
                    {
                        "username": "Geetanjali_Gupta",
                        "content": "path should be from -1 to -2 then ans would be 8"
                    },
                    {
                        "username": "deeponsubhro",
                        "content": "go from -1 to -2"
                    },
                    {
                        "username": "duchemin01",
                        "content": "[@VigneshwarVG](/VigneshwarVG)  then, expected should be 9"
                    },
                    {
                        "username": "VigneshwarVG",
                        "content": "it isn\\'t a rule that edge must always pass through the root of the tree\\nit might be its left or right or left\\'s (left or right ) or the right\\'s( left or right )and so on \\nhope you get it\\n"
                    },
                    {
                        "username": "RayanYI",
                        "content": "[@mascomen4](/mascomen4)  Thanks, very helpful. Thanks to you I\\'ve solved it :)"
                    },
                    {
                        "username": "Boyka800",
                        "content": "Because you are considering the wrong path, the correct one is from -4 to -2 of lenght 8."
                    },
                    {
                        "username": "mascomen4",
                        "content": "One year later, but may be it'll save some time for the others struggling the problem.\n\nUnfortunately, the assumption that the longest path comes through the root is not right for the unbalanced tree. So, they say `This path may or may not pass through the root`. \n\n*Hint:* try to find the path of 8 edges in the right subtree. "
                    }
                ]
            },
            {
                "id": 1566534,
                "content": [
                    {
                        "username": "SouthernHumor",
                        "content": "How the hek is this problem/program marked easy ? Solutions I\\'m seeing involve 2 recursive functions and this is just not quick or straightforward"
                    },
                    {
                        "username": "gbiems",
                        "content": "This one one of the first tree problems I tried to do on leetcode, since I was looking for \"easy\" tree problems. Oof. Now that I have some more experience, I feel a lot better about how hard I found it when I was starting out. This isn\\'t an easy problem. I come back to it and re-solve it every now and then.\\n\\nI think what makes it difficult is that (in the most common solution I\\'ve seen) you need to return a value from a recursive function (the max length of left or right branch from each node) but you need to set a class variable or other way of tracking the maximum value of the left + right branches.\\n\\nThat\\'s a lot to wrap your head around when you\\'re first looking for recursive tree problems. But hey, if you stick with it, you\\'ll get this, and it\\'s a great problem for tracking variable values in recursive functions. \\n\\nBut having solved a bunch of leetcode problems, I\\'d definitely say this one is medium, not easy. If I didn\\'t know the answer, I think I\\'d still struggle to get this one. "
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "[@eduard92](/eduard92) \"laid off already\" LMFAOOOO \\uD83D\\uDE02\\uD83D\\uDC80"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its easy for those who already know.. maybe they are in uni and already solved in there and they solve it here too.\nSome of us just come here with an empty mind to push forward and is hard if you have no background. I approached this month DP and Trees for the first time in my life, it surely developed a way of thinking of data in terms of a Tree and Recursion in my mind works now as a Stack, isn't something hard to explain anymore, but I still check discuss and other websites for pseudocode.\n\nI know the comment is old, dude probably got at google and laid off already but for future people who feel stuck I think its about pushing into unkown.\n"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I agree. Unless you\\'ve seen the style of this solution somewhere before (it\\'s similar to the divide-and-conquer solution of the Maximum Subarray problem), you\\'ll probably have a tough time when coming into this problem with an empty mind."
                    },
                    {
                        "username": "chidam333",
                        "content": "here you have to just go through every node and find sum of heights of it\\'s left and right node , which is way easier than knowing the exact path... ig lol "
                    },
                    {
                        "username": "alvinato",
                        "content": "[4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]\\n\\n^ the above test case expects an answer of 8.  But I only count 7 edges between every node.  Between which two nodes are there 8 edges?"
                    },
                    {
                        "username": "suraj21209",
                        "content": "https://leetcode.com/problems/diameter-of-binary-tree/submissions/995832822/"
                    },
                    {
                        "username": "chidam333",
                        "content": "Note that the path does not need to pass through the root"
                    },
                    {
                        "username": "toho42",
                        "content": "copy and paste that to the test case to view the binary tree.  The node with a root of -9 has a maxDepth(left) of 4, and a maxDepth(right) of 4.  Thus, the diameter is 8.  This is case where the maxDiameter of a child node exceeds the maxDepth of the parent node\\'s left and right branches.\\n"
                    },
                    {
                        "username": "mascomen4",
                        "content": "see my comment below: https://leetcode.com/problems/diameter-of-binary-tree/discussion/comments/1629510"
                    },
                    {
                        "username": "OBAAT",
                        "content": "Bullshit problem description. \\nBullshit definition for \"diameter\". \\nIs it so difficult to say instead \"longest path\"? \\nProblem writers are morons. "
                    },
                    {
                        "username": "xclusive102",
                        "content": "[@ahmedtsalem9](/ahmedtsalem9) But this is not the world of circles. I agree that using \\'longest path\\' is more appropriate in the world of trees."
                    },
                    {
                        "username": "chumaumenze",
                        "content": "[@ahmedtsalem9](/ahmedtsalem9) The description is not a good one. I could not implement this because I had a problem understanding the question. When they say diameter, it implies the logic of how the diameter of a circle works - the length of the line through the center that touches two points on the edge of the circle. I was calculating the height of the tree from root to leaf."
                    },
                    {
                        "username": "ahmedtsalem9",
                        "content": "Technically, \"Diameter\" is a precise term. In the world of circles, the diameter is the longest line that can ever be drawn within a circle.\\n\\nThe same exact definition applies to trees; it\\'s the longest \"path\" that can ever be drawn within a tree through its nodes."
                    },
                    {
                        "username": "rana_afifi",
                        "content": "Rather tricky. Don\\'t think it is considered easy "
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Me too."
                    },
                    {
                        "username": "myih",
                        "content": "Scrolling down the discussions and most of the solutions are basically the same as the solution for no.124, yet this one is marked as easy and 124 is hard? Is there a easier way for this problem?"
                    },
                    {
                        "username": "suraj21209",
                        "content": "[@dragon1105](/dragon1105) https://leetcode.com/problems/diameter-of-binary-tree/submissions/995832822/"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "This one feels more like a medium to me. But 124 has a waaaay stricter time limit. My solution for 124 is getting TLEd to oblivion even with caching("
                    },
                    {
                        "username": "dragon1105",
                        "content": "Yeah I think this should be labeled as medium. This can only be easy when you\\'ve known the solution of some similar problems like Maximum Subarray (especially the divide-and-conquer one)."
                    },
                    {
                        "username": "WizTheProgrammer",
                        "content": "\"Easy\""
                    },
                    {
                        "username": "Dummyy",
                        "content": "sdcs jhfb wi wiufhw eiu uhweofuwe hfowe fowefowe fhwoe"
                    },
                    {
                        "username": "jonathanferraro75",
                        "content": "banging his head on the keyboard out of frustration"
                    },
                    {
                        "username": "rajat_171",
                        "content": "I agree"
                    },
                    {
                        "username": "techpromulgator",
                        "content": "How is the diameter of the below test case is 8?\\n\\n[4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]\\n\\nWhen I visualize, I see that it\\'s 7 and I\\'m getting 7. But, the expected answer is 8"
                    },
                    {
                        "username": "gauravkumar125",
                        "content": "i got it as 8 "
                    },
                    {
                        "username": "stephanauwerda000",
                        "content": "Because you should calculate max diameter of EVERY node, not just the root.\\nThe node (-9) has a diameter of 8. \\nSo this is the max diameter which the function should return."
                    },
                    {
                        "username": "ande_ka_funda",
                        "content": "The solution to just find the maximum width is rather simple. \\n\\nHowever I was asked to also print the path (and not just find the diameter).\\n\\nTotally fumbled. I have been trying but I am unable to come up with an O(n) solution"
                    },
                    {
                        "username": "JustBored",
                        "content": "Can do a second dfs from the root node with the max diameter. Just memoise which child node leads to the max height for each node  which will tell you which direction to go beforehand. But you have to make sure you go in both directions in the first iteration of the 2nd dfs from the starting node. This will give you the best path in O(n).\n\nThe O(n^2) approach would be to store the maximum height path for each node and combine the child left and right path at the max diameter node to get the optimal path. You can do this in one dfs but the tc is still O(n^2)\n    "
                    },
                    {
                        "username": "dhruvpithwa1999",
                        "content": "[@uchihahardik](/uchihahardik) You can refer to my soln, https://leetcode.com/problems/diameter-of-binary-tree/submissions/869730789/\\n\\nI have tried to solve and find path using ArrayList, same approach but different return type\\n\\nmay be this can help you.."
                    },
                    {
                        "username": "uchihahardik",
                        "content": "\"The solution to just find the maximum width is rather simple.\"\\nI am not able to think of an approch any tip?"
                    },
                    {
                        "username": "keJum",
                        "content": "# Example 1\\n![image](https://assets.leetcode.com/users/images/9f86a81d-aef1-4090-a327-14071d450001_1634631307.9913106.png)\\n\\nResult 3, expected 3\\n\\n# Example 100\\n![image](https://assets.leetcode.com/users/images/e671990e-09a1-4deb-b605-5bd4c15419cb_1634631254.7966447.png)\\n\\nResult 7, expected 8.\\n\\nWhy is the result expected to be 8 and not 7?"
                    },
                    {
                        "username": "ishananchit",
                        "content": "because of the path -4, 6, 6, 9, -9, -7, -6, 9, -2"
                    },
                    {
                        "username": "howhowone",
                        "content": "-2 9 -6 -7 -9 9 6 0 -1"
                    },
                    {
                        "username": "Geetanjali_Gupta",
                        "content": "path should be from -1 to -2 then ans would be 8"
                    },
                    {
                        "username": "deeponsubhro",
                        "content": "go from -1 to -2"
                    },
                    {
                        "username": "duchemin01",
                        "content": "[@VigneshwarVG](/VigneshwarVG)  then, expected should be 9"
                    },
                    {
                        "username": "VigneshwarVG",
                        "content": "it isn\\'t a rule that edge must always pass through the root of the tree\\nit might be its left or right or left\\'s (left or right ) or the right\\'s( left or right )and so on \\nhope you get it\\n"
                    },
                    {
                        "username": "RayanYI",
                        "content": "[@mascomen4](/mascomen4)  Thanks, very helpful. Thanks to you I\\'ve solved it :)"
                    },
                    {
                        "username": "Boyka800",
                        "content": "Because you are considering the wrong path, the correct one is from -4 to -2 of lenght 8."
                    },
                    {
                        "username": "mascomen4",
                        "content": "One year later, but may be it'll save some time for the others struggling the problem.\n\nUnfortunately, the assumption that the longest path comes through the root is not right for the unbalanced tree. So, they say `This path may or may not pass through the root`. \n\n*Hint:* try to find the path of 8 edges in the right subtree. "
                    }
                ]
            },
            {
                "id": 1768427,
                "content": [
                    {
                        "username": "SouthernHumor",
                        "content": "How the hek is this problem/program marked easy ? Solutions I\\'m seeing involve 2 recursive functions and this is just not quick or straightforward"
                    },
                    {
                        "username": "gbiems",
                        "content": "This one one of the first tree problems I tried to do on leetcode, since I was looking for \"easy\" tree problems. Oof. Now that I have some more experience, I feel a lot better about how hard I found it when I was starting out. This isn\\'t an easy problem. I come back to it and re-solve it every now and then.\\n\\nI think what makes it difficult is that (in the most common solution I\\'ve seen) you need to return a value from a recursive function (the max length of left or right branch from each node) but you need to set a class variable or other way of tracking the maximum value of the left + right branches.\\n\\nThat\\'s a lot to wrap your head around when you\\'re first looking for recursive tree problems. But hey, if you stick with it, you\\'ll get this, and it\\'s a great problem for tracking variable values in recursive functions. \\n\\nBut having solved a bunch of leetcode problems, I\\'d definitely say this one is medium, not easy. If I didn\\'t know the answer, I think I\\'d still struggle to get this one. "
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "[@eduard92](/eduard92) \"laid off already\" LMFAOOOO \\uD83D\\uDE02\\uD83D\\uDC80"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its easy for those who already know.. maybe they are in uni and already solved in there and they solve it here too.\nSome of us just come here with an empty mind to push forward and is hard if you have no background. I approached this month DP and Trees for the first time in my life, it surely developed a way of thinking of data in terms of a Tree and Recursion in my mind works now as a Stack, isn't something hard to explain anymore, but I still check discuss and other websites for pseudocode.\n\nI know the comment is old, dude probably got at google and laid off already but for future people who feel stuck I think its about pushing into unkown.\n"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I agree. Unless you\\'ve seen the style of this solution somewhere before (it\\'s similar to the divide-and-conquer solution of the Maximum Subarray problem), you\\'ll probably have a tough time when coming into this problem with an empty mind."
                    },
                    {
                        "username": "chidam333",
                        "content": "here you have to just go through every node and find sum of heights of it\\'s left and right node , which is way easier than knowing the exact path... ig lol "
                    },
                    {
                        "username": "alvinato",
                        "content": "[4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]\\n\\n^ the above test case expects an answer of 8.  But I only count 7 edges between every node.  Between which two nodes are there 8 edges?"
                    },
                    {
                        "username": "suraj21209",
                        "content": "https://leetcode.com/problems/diameter-of-binary-tree/submissions/995832822/"
                    },
                    {
                        "username": "chidam333",
                        "content": "Note that the path does not need to pass through the root"
                    },
                    {
                        "username": "toho42",
                        "content": "copy and paste that to the test case to view the binary tree.  The node with a root of -9 has a maxDepth(left) of 4, and a maxDepth(right) of 4.  Thus, the diameter is 8.  This is case where the maxDiameter of a child node exceeds the maxDepth of the parent node\\'s left and right branches.\\n"
                    },
                    {
                        "username": "mascomen4",
                        "content": "see my comment below: https://leetcode.com/problems/diameter-of-binary-tree/discussion/comments/1629510"
                    },
                    {
                        "username": "OBAAT",
                        "content": "Bullshit problem description. \\nBullshit definition for \"diameter\". \\nIs it so difficult to say instead \"longest path\"? \\nProblem writers are morons. "
                    },
                    {
                        "username": "xclusive102",
                        "content": "[@ahmedtsalem9](/ahmedtsalem9) But this is not the world of circles. I agree that using \\'longest path\\' is more appropriate in the world of trees."
                    },
                    {
                        "username": "chumaumenze",
                        "content": "[@ahmedtsalem9](/ahmedtsalem9) The description is not a good one. I could not implement this because I had a problem understanding the question. When they say diameter, it implies the logic of how the diameter of a circle works - the length of the line through the center that touches two points on the edge of the circle. I was calculating the height of the tree from root to leaf."
                    },
                    {
                        "username": "ahmedtsalem9",
                        "content": "Technically, \"Diameter\" is a precise term. In the world of circles, the diameter is the longest line that can ever be drawn within a circle.\\n\\nThe same exact definition applies to trees; it\\'s the longest \"path\" that can ever be drawn within a tree through its nodes."
                    },
                    {
                        "username": "rana_afifi",
                        "content": "Rather tricky. Don\\'t think it is considered easy "
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Me too."
                    },
                    {
                        "username": "myih",
                        "content": "Scrolling down the discussions and most of the solutions are basically the same as the solution for no.124, yet this one is marked as easy and 124 is hard? Is there a easier way for this problem?"
                    },
                    {
                        "username": "suraj21209",
                        "content": "[@dragon1105](/dragon1105) https://leetcode.com/problems/diameter-of-binary-tree/submissions/995832822/"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "This one feels more like a medium to me. But 124 has a waaaay stricter time limit. My solution for 124 is getting TLEd to oblivion even with caching("
                    },
                    {
                        "username": "dragon1105",
                        "content": "Yeah I think this should be labeled as medium. This can only be easy when you\\'ve known the solution of some similar problems like Maximum Subarray (especially the divide-and-conquer one)."
                    },
                    {
                        "username": "WizTheProgrammer",
                        "content": "\"Easy\""
                    },
                    {
                        "username": "Dummyy",
                        "content": "sdcs jhfb wi wiufhw eiu uhweofuwe hfowe fowefowe fhwoe"
                    },
                    {
                        "username": "jonathanferraro75",
                        "content": "banging his head on the keyboard out of frustration"
                    },
                    {
                        "username": "rajat_171",
                        "content": "I agree"
                    },
                    {
                        "username": "techpromulgator",
                        "content": "How is the diameter of the below test case is 8?\\n\\n[4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]\\n\\nWhen I visualize, I see that it\\'s 7 and I\\'m getting 7. But, the expected answer is 8"
                    },
                    {
                        "username": "gauravkumar125",
                        "content": "i got it as 8 "
                    },
                    {
                        "username": "stephanauwerda000",
                        "content": "Because you should calculate max diameter of EVERY node, not just the root.\\nThe node (-9) has a diameter of 8. \\nSo this is the max diameter which the function should return."
                    },
                    {
                        "username": "ande_ka_funda",
                        "content": "The solution to just find the maximum width is rather simple. \\n\\nHowever I was asked to also print the path (and not just find the diameter).\\n\\nTotally fumbled. I have been trying but I am unable to come up with an O(n) solution"
                    },
                    {
                        "username": "JustBored",
                        "content": "Can do a second dfs from the root node with the max diameter. Just memoise which child node leads to the max height for each node  which will tell you which direction to go beforehand. But you have to make sure you go in both directions in the first iteration of the 2nd dfs from the starting node. This will give you the best path in O(n).\n\nThe O(n^2) approach would be to store the maximum height path for each node and combine the child left and right path at the max diameter node to get the optimal path. You can do this in one dfs but the tc is still O(n^2)\n    "
                    },
                    {
                        "username": "dhruvpithwa1999",
                        "content": "[@uchihahardik](/uchihahardik) You can refer to my soln, https://leetcode.com/problems/diameter-of-binary-tree/submissions/869730789/\\n\\nI have tried to solve and find path using ArrayList, same approach but different return type\\n\\nmay be this can help you.."
                    },
                    {
                        "username": "uchihahardik",
                        "content": "\"The solution to just find the maximum width is rather simple.\"\\nI am not able to think of an approch any tip?"
                    },
                    {
                        "username": "keJum",
                        "content": "# Example 1\\n![image](https://assets.leetcode.com/users/images/9f86a81d-aef1-4090-a327-14071d450001_1634631307.9913106.png)\\n\\nResult 3, expected 3\\n\\n# Example 100\\n![image](https://assets.leetcode.com/users/images/e671990e-09a1-4deb-b605-5bd4c15419cb_1634631254.7966447.png)\\n\\nResult 7, expected 8.\\n\\nWhy is the result expected to be 8 and not 7?"
                    },
                    {
                        "username": "ishananchit",
                        "content": "because of the path -4, 6, 6, 9, -9, -7, -6, 9, -2"
                    },
                    {
                        "username": "howhowone",
                        "content": "-2 9 -6 -7 -9 9 6 0 -1"
                    },
                    {
                        "username": "Geetanjali_Gupta",
                        "content": "path should be from -1 to -2 then ans would be 8"
                    },
                    {
                        "username": "deeponsubhro",
                        "content": "go from -1 to -2"
                    },
                    {
                        "username": "duchemin01",
                        "content": "[@VigneshwarVG](/VigneshwarVG)  then, expected should be 9"
                    },
                    {
                        "username": "VigneshwarVG",
                        "content": "it isn\\'t a rule that edge must always pass through the root of the tree\\nit might be its left or right or left\\'s (left or right ) or the right\\'s( left or right )and so on \\nhope you get it\\n"
                    },
                    {
                        "username": "RayanYI",
                        "content": "[@mascomen4](/mascomen4)  Thanks, very helpful. Thanks to you I\\'ve solved it :)"
                    },
                    {
                        "username": "Boyka800",
                        "content": "Because you are considering the wrong path, the correct one is from -4 to -2 of lenght 8."
                    },
                    {
                        "username": "mascomen4",
                        "content": "One year later, but may be it'll save some time for the others struggling the problem.\n\nUnfortunately, the assumption that the longest path comes through the root is not right for the unbalanced tree. So, they say `This path may or may not pass through the root`. \n\n*Hint:* try to find the path of 8 edges in the right subtree. "
                    }
                ]
            },
            {
                "id": 1730290,
                "content": [
                    {
                        "username": "SouthernHumor",
                        "content": "How the hek is this problem/program marked easy ? Solutions I\\'m seeing involve 2 recursive functions and this is just not quick or straightforward"
                    },
                    {
                        "username": "gbiems",
                        "content": "This one one of the first tree problems I tried to do on leetcode, since I was looking for \"easy\" tree problems. Oof. Now that I have some more experience, I feel a lot better about how hard I found it when I was starting out. This isn\\'t an easy problem. I come back to it and re-solve it every now and then.\\n\\nI think what makes it difficult is that (in the most common solution I\\'ve seen) you need to return a value from a recursive function (the max length of left or right branch from each node) but you need to set a class variable or other way of tracking the maximum value of the left + right branches.\\n\\nThat\\'s a lot to wrap your head around when you\\'re first looking for recursive tree problems. But hey, if you stick with it, you\\'ll get this, and it\\'s a great problem for tracking variable values in recursive functions. \\n\\nBut having solved a bunch of leetcode problems, I\\'d definitely say this one is medium, not easy. If I didn\\'t know the answer, I think I\\'d still struggle to get this one. "
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "[@eduard92](/eduard92) \"laid off already\" LMFAOOOO \\uD83D\\uDE02\\uD83D\\uDC80"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its easy for those who already know.. maybe they are in uni and already solved in there and they solve it here too.\nSome of us just come here with an empty mind to push forward and is hard if you have no background. I approached this month DP and Trees for the first time in my life, it surely developed a way of thinking of data in terms of a Tree and Recursion in my mind works now as a Stack, isn't something hard to explain anymore, but I still check discuss and other websites for pseudocode.\n\nI know the comment is old, dude probably got at google and laid off already but for future people who feel stuck I think its about pushing into unkown.\n"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I agree. Unless you\\'ve seen the style of this solution somewhere before (it\\'s similar to the divide-and-conquer solution of the Maximum Subarray problem), you\\'ll probably have a tough time when coming into this problem with an empty mind."
                    },
                    {
                        "username": "chidam333",
                        "content": "here you have to just go through every node and find sum of heights of it\\'s left and right node , which is way easier than knowing the exact path... ig lol "
                    },
                    {
                        "username": "alvinato",
                        "content": "[4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]\\n\\n^ the above test case expects an answer of 8.  But I only count 7 edges between every node.  Between which two nodes are there 8 edges?"
                    },
                    {
                        "username": "suraj21209",
                        "content": "https://leetcode.com/problems/diameter-of-binary-tree/submissions/995832822/"
                    },
                    {
                        "username": "chidam333",
                        "content": "Note that the path does not need to pass through the root"
                    },
                    {
                        "username": "toho42",
                        "content": "copy and paste that to the test case to view the binary tree.  The node with a root of -9 has a maxDepth(left) of 4, and a maxDepth(right) of 4.  Thus, the diameter is 8.  This is case where the maxDiameter of a child node exceeds the maxDepth of the parent node\\'s left and right branches.\\n"
                    },
                    {
                        "username": "mascomen4",
                        "content": "see my comment below: https://leetcode.com/problems/diameter-of-binary-tree/discussion/comments/1629510"
                    },
                    {
                        "username": "OBAAT",
                        "content": "Bullshit problem description. \\nBullshit definition for \"diameter\". \\nIs it so difficult to say instead \"longest path\"? \\nProblem writers are morons. "
                    },
                    {
                        "username": "xclusive102",
                        "content": "[@ahmedtsalem9](/ahmedtsalem9) But this is not the world of circles. I agree that using \\'longest path\\' is more appropriate in the world of trees."
                    },
                    {
                        "username": "chumaumenze",
                        "content": "[@ahmedtsalem9](/ahmedtsalem9) The description is not a good one. I could not implement this because I had a problem understanding the question. When they say diameter, it implies the logic of how the diameter of a circle works - the length of the line through the center that touches two points on the edge of the circle. I was calculating the height of the tree from root to leaf."
                    },
                    {
                        "username": "ahmedtsalem9",
                        "content": "Technically, \"Diameter\" is a precise term. In the world of circles, the diameter is the longest line that can ever be drawn within a circle.\\n\\nThe same exact definition applies to trees; it\\'s the longest \"path\" that can ever be drawn within a tree through its nodes."
                    },
                    {
                        "username": "rana_afifi",
                        "content": "Rather tricky. Don\\'t think it is considered easy "
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Me too."
                    },
                    {
                        "username": "myih",
                        "content": "Scrolling down the discussions and most of the solutions are basically the same as the solution for no.124, yet this one is marked as easy and 124 is hard? Is there a easier way for this problem?"
                    },
                    {
                        "username": "suraj21209",
                        "content": "[@dragon1105](/dragon1105) https://leetcode.com/problems/diameter-of-binary-tree/submissions/995832822/"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "This one feels more like a medium to me. But 124 has a waaaay stricter time limit. My solution for 124 is getting TLEd to oblivion even with caching("
                    },
                    {
                        "username": "dragon1105",
                        "content": "Yeah I think this should be labeled as medium. This can only be easy when you\\'ve known the solution of some similar problems like Maximum Subarray (especially the divide-and-conquer one)."
                    },
                    {
                        "username": "WizTheProgrammer",
                        "content": "\"Easy\""
                    },
                    {
                        "username": "Dummyy",
                        "content": "sdcs jhfb wi wiufhw eiu uhweofuwe hfowe fowefowe fhwoe"
                    },
                    {
                        "username": "jonathanferraro75",
                        "content": "banging his head on the keyboard out of frustration"
                    },
                    {
                        "username": "rajat_171",
                        "content": "I agree"
                    },
                    {
                        "username": "techpromulgator",
                        "content": "How is the diameter of the below test case is 8?\\n\\n[4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]\\n\\nWhen I visualize, I see that it\\'s 7 and I\\'m getting 7. But, the expected answer is 8"
                    },
                    {
                        "username": "gauravkumar125",
                        "content": "i got it as 8 "
                    },
                    {
                        "username": "stephanauwerda000",
                        "content": "Because you should calculate max diameter of EVERY node, not just the root.\\nThe node (-9) has a diameter of 8. \\nSo this is the max diameter which the function should return."
                    },
                    {
                        "username": "ande_ka_funda",
                        "content": "The solution to just find the maximum width is rather simple. \\n\\nHowever I was asked to also print the path (and not just find the diameter).\\n\\nTotally fumbled. I have been trying but I am unable to come up with an O(n) solution"
                    },
                    {
                        "username": "JustBored",
                        "content": "Can do a second dfs from the root node with the max diameter. Just memoise which child node leads to the max height for each node  which will tell you which direction to go beforehand. But you have to make sure you go in both directions in the first iteration of the 2nd dfs from the starting node. This will give you the best path in O(n).\n\nThe O(n^2) approach would be to store the maximum height path for each node and combine the child left and right path at the max diameter node to get the optimal path. You can do this in one dfs but the tc is still O(n^2)\n    "
                    },
                    {
                        "username": "dhruvpithwa1999",
                        "content": "[@uchihahardik](/uchihahardik) You can refer to my soln, https://leetcode.com/problems/diameter-of-binary-tree/submissions/869730789/\\n\\nI have tried to solve and find path using ArrayList, same approach but different return type\\n\\nmay be this can help you.."
                    },
                    {
                        "username": "uchihahardik",
                        "content": "\"The solution to just find the maximum width is rather simple.\"\\nI am not able to think of an approch any tip?"
                    },
                    {
                        "username": "keJum",
                        "content": "# Example 1\\n![image](https://assets.leetcode.com/users/images/9f86a81d-aef1-4090-a327-14071d450001_1634631307.9913106.png)\\n\\nResult 3, expected 3\\n\\n# Example 100\\n![image](https://assets.leetcode.com/users/images/e671990e-09a1-4deb-b605-5bd4c15419cb_1634631254.7966447.png)\\n\\nResult 7, expected 8.\\n\\nWhy is the result expected to be 8 and not 7?"
                    },
                    {
                        "username": "ishananchit",
                        "content": "because of the path -4, 6, 6, 9, -9, -7, -6, 9, -2"
                    },
                    {
                        "username": "howhowone",
                        "content": "-2 9 -6 -7 -9 9 6 0 -1"
                    },
                    {
                        "username": "Geetanjali_Gupta",
                        "content": "path should be from -1 to -2 then ans would be 8"
                    },
                    {
                        "username": "deeponsubhro",
                        "content": "go from -1 to -2"
                    },
                    {
                        "username": "duchemin01",
                        "content": "[@VigneshwarVG](/VigneshwarVG)  then, expected should be 9"
                    },
                    {
                        "username": "VigneshwarVG",
                        "content": "it isn\\'t a rule that edge must always pass through the root of the tree\\nit might be its left or right or left\\'s (left or right ) or the right\\'s( left or right )and so on \\nhope you get it\\n"
                    },
                    {
                        "username": "RayanYI",
                        "content": "[@mascomen4](/mascomen4)  Thanks, very helpful. Thanks to you I\\'ve solved it :)"
                    },
                    {
                        "username": "Boyka800",
                        "content": "Because you are considering the wrong path, the correct one is from -4 to -2 of lenght 8."
                    },
                    {
                        "username": "mascomen4",
                        "content": "One year later, but may be it'll save some time for the others struggling the problem.\n\nUnfortunately, the assumption that the longest path comes through the root is not right for the unbalanced tree. So, they say `This path may or may not pass through the root`. \n\n*Hint:* try to find the path of 8 edges in the right subtree. "
                    }
                ]
            },
            {
                "id": 1568066,
                "content": [
                    {
                        "username": "SouthernHumor",
                        "content": "How the hek is this problem/program marked easy ? Solutions I\\'m seeing involve 2 recursive functions and this is just not quick or straightforward"
                    },
                    {
                        "username": "gbiems",
                        "content": "This one one of the first tree problems I tried to do on leetcode, since I was looking for \"easy\" tree problems. Oof. Now that I have some more experience, I feel a lot better about how hard I found it when I was starting out. This isn\\'t an easy problem. I come back to it and re-solve it every now and then.\\n\\nI think what makes it difficult is that (in the most common solution I\\'ve seen) you need to return a value from a recursive function (the max length of left or right branch from each node) but you need to set a class variable or other way of tracking the maximum value of the left + right branches.\\n\\nThat\\'s a lot to wrap your head around when you\\'re first looking for recursive tree problems. But hey, if you stick with it, you\\'ll get this, and it\\'s a great problem for tracking variable values in recursive functions. \\n\\nBut having solved a bunch of leetcode problems, I\\'d definitely say this one is medium, not easy. If I didn\\'t know the answer, I think I\\'d still struggle to get this one. "
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "[@eduard92](/eduard92) \"laid off already\" LMFAOOOO \\uD83D\\uDE02\\uD83D\\uDC80"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its easy for those who already know.. maybe they are in uni and already solved in there and they solve it here too.\nSome of us just come here with an empty mind to push forward and is hard if you have no background. I approached this month DP and Trees for the first time in my life, it surely developed a way of thinking of data in terms of a Tree and Recursion in my mind works now as a Stack, isn't something hard to explain anymore, but I still check discuss and other websites for pseudocode.\n\nI know the comment is old, dude probably got at google and laid off already but for future people who feel stuck I think its about pushing into unkown.\n"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I agree. Unless you\\'ve seen the style of this solution somewhere before (it\\'s similar to the divide-and-conquer solution of the Maximum Subarray problem), you\\'ll probably have a tough time when coming into this problem with an empty mind."
                    },
                    {
                        "username": "chidam333",
                        "content": "here you have to just go through every node and find sum of heights of it\\'s left and right node , which is way easier than knowing the exact path... ig lol "
                    },
                    {
                        "username": "alvinato",
                        "content": "[4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]\\n\\n^ the above test case expects an answer of 8.  But I only count 7 edges between every node.  Between which two nodes are there 8 edges?"
                    },
                    {
                        "username": "suraj21209",
                        "content": "https://leetcode.com/problems/diameter-of-binary-tree/submissions/995832822/"
                    },
                    {
                        "username": "chidam333",
                        "content": "Note that the path does not need to pass through the root"
                    },
                    {
                        "username": "toho42",
                        "content": "copy and paste that to the test case to view the binary tree.  The node with a root of -9 has a maxDepth(left) of 4, and a maxDepth(right) of 4.  Thus, the diameter is 8.  This is case where the maxDiameter of a child node exceeds the maxDepth of the parent node\\'s left and right branches.\\n"
                    },
                    {
                        "username": "mascomen4",
                        "content": "see my comment below: https://leetcode.com/problems/diameter-of-binary-tree/discussion/comments/1629510"
                    },
                    {
                        "username": "OBAAT",
                        "content": "Bullshit problem description. \\nBullshit definition for \"diameter\". \\nIs it so difficult to say instead \"longest path\"? \\nProblem writers are morons. "
                    },
                    {
                        "username": "xclusive102",
                        "content": "[@ahmedtsalem9](/ahmedtsalem9) But this is not the world of circles. I agree that using \\'longest path\\' is more appropriate in the world of trees."
                    },
                    {
                        "username": "chumaumenze",
                        "content": "[@ahmedtsalem9](/ahmedtsalem9) The description is not a good one. I could not implement this because I had a problem understanding the question. When they say diameter, it implies the logic of how the diameter of a circle works - the length of the line through the center that touches two points on the edge of the circle. I was calculating the height of the tree from root to leaf."
                    },
                    {
                        "username": "ahmedtsalem9",
                        "content": "Technically, \"Diameter\" is a precise term. In the world of circles, the diameter is the longest line that can ever be drawn within a circle.\\n\\nThe same exact definition applies to trees; it\\'s the longest \"path\" that can ever be drawn within a tree through its nodes."
                    },
                    {
                        "username": "rana_afifi",
                        "content": "Rather tricky. Don\\'t think it is considered easy "
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Me too."
                    },
                    {
                        "username": "myih",
                        "content": "Scrolling down the discussions and most of the solutions are basically the same as the solution for no.124, yet this one is marked as easy and 124 is hard? Is there a easier way for this problem?"
                    },
                    {
                        "username": "suraj21209",
                        "content": "[@dragon1105](/dragon1105) https://leetcode.com/problems/diameter-of-binary-tree/submissions/995832822/"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "This one feels more like a medium to me. But 124 has a waaaay stricter time limit. My solution for 124 is getting TLEd to oblivion even with caching("
                    },
                    {
                        "username": "dragon1105",
                        "content": "Yeah I think this should be labeled as medium. This can only be easy when you\\'ve known the solution of some similar problems like Maximum Subarray (especially the divide-and-conquer one)."
                    },
                    {
                        "username": "WizTheProgrammer",
                        "content": "\"Easy\""
                    },
                    {
                        "username": "Dummyy",
                        "content": "sdcs jhfb wi wiufhw eiu uhweofuwe hfowe fowefowe fhwoe"
                    },
                    {
                        "username": "jonathanferraro75",
                        "content": "banging his head on the keyboard out of frustration"
                    },
                    {
                        "username": "rajat_171",
                        "content": "I agree"
                    },
                    {
                        "username": "techpromulgator",
                        "content": "How is the diameter of the below test case is 8?\\n\\n[4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]\\n\\nWhen I visualize, I see that it\\'s 7 and I\\'m getting 7. But, the expected answer is 8"
                    },
                    {
                        "username": "gauravkumar125",
                        "content": "i got it as 8 "
                    },
                    {
                        "username": "stephanauwerda000",
                        "content": "Because you should calculate max diameter of EVERY node, not just the root.\\nThe node (-9) has a diameter of 8. \\nSo this is the max diameter which the function should return."
                    },
                    {
                        "username": "ande_ka_funda",
                        "content": "The solution to just find the maximum width is rather simple. \\n\\nHowever I was asked to also print the path (and not just find the diameter).\\n\\nTotally fumbled. I have been trying but I am unable to come up with an O(n) solution"
                    },
                    {
                        "username": "JustBored",
                        "content": "Can do a second dfs from the root node with the max diameter. Just memoise which child node leads to the max height for each node  which will tell you which direction to go beforehand. But you have to make sure you go in both directions in the first iteration of the 2nd dfs from the starting node. This will give you the best path in O(n).\n\nThe O(n^2) approach would be to store the maximum height path for each node and combine the child left and right path at the max diameter node to get the optimal path. You can do this in one dfs but the tc is still O(n^2)\n    "
                    },
                    {
                        "username": "dhruvpithwa1999",
                        "content": "[@uchihahardik](/uchihahardik) You can refer to my soln, https://leetcode.com/problems/diameter-of-binary-tree/submissions/869730789/\\n\\nI have tried to solve and find path using ArrayList, same approach but different return type\\n\\nmay be this can help you.."
                    },
                    {
                        "username": "uchihahardik",
                        "content": "\"The solution to just find the maximum width is rather simple.\"\\nI am not able to think of an approch any tip?"
                    },
                    {
                        "username": "keJum",
                        "content": "# Example 1\\n![image](https://assets.leetcode.com/users/images/9f86a81d-aef1-4090-a327-14071d450001_1634631307.9913106.png)\\n\\nResult 3, expected 3\\n\\n# Example 100\\n![image](https://assets.leetcode.com/users/images/e671990e-09a1-4deb-b605-5bd4c15419cb_1634631254.7966447.png)\\n\\nResult 7, expected 8.\\n\\nWhy is the result expected to be 8 and not 7?"
                    },
                    {
                        "username": "ishananchit",
                        "content": "because of the path -4, 6, 6, 9, -9, -7, -6, 9, -2"
                    },
                    {
                        "username": "howhowone",
                        "content": "-2 9 -6 -7 -9 9 6 0 -1"
                    },
                    {
                        "username": "Geetanjali_Gupta",
                        "content": "path should be from -1 to -2 then ans would be 8"
                    },
                    {
                        "username": "deeponsubhro",
                        "content": "go from -1 to -2"
                    },
                    {
                        "username": "duchemin01",
                        "content": "[@VigneshwarVG](/VigneshwarVG)  then, expected should be 9"
                    },
                    {
                        "username": "VigneshwarVG",
                        "content": "it isn\\'t a rule that edge must always pass through the root of the tree\\nit might be its left or right or left\\'s (left or right ) or the right\\'s( left or right )and so on \\nhope you get it\\n"
                    },
                    {
                        "username": "RayanYI",
                        "content": "[@mascomen4](/mascomen4)  Thanks, very helpful. Thanks to you I\\'ve solved it :)"
                    },
                    {
                        "username": "Boyka800",
                        "content": "Because you are considering the wrong path, the correct one is from -4 to -2 of lenght 8."
                    },
                    {
                        "username": "mascomen4",
                        "content": "One year later, but may be it'll save some time for the others struggling the problem.\n\nUnfortunately, the assumption that the longest path comes through the root is not right for the unbalanced tree. So, they say `This path may or may not pass through the root`. \n\n*Hint:* try to find the path of 8 edges in the right subtree. "
                    }
                ]
            },
            {
                "id": 1752105,
                "content": [
                    {
                        "username": "SouthernHumor",
                        "content": "How the hek is this problem/program marked easy ? Solutions I\\'m seeing involve 2 recursive functions and this is just not quick or straightforward"
                    },
                    {
                        "username": "gbiems",
                        "content": "This one one of the first tree problems I tried to do on leetcode, since I was looking for \"easy\" tree problems. Oof. Now that I have some more experience, I feel a lot better about how hard I found it when I was starting out. This isn\\'t an easy problem. I come back to it and re-solve it every now and then.\\n\\nI think what makes it difficult is that (in the most common solution I\\'ve seen) you need to return a value from a recursive function (the max length of left or right branch from each node) but you need to set a class variable or other way of tracking the maximum value of the left + right branches.\\n\\nThat\\'s a lot to wrap your head around when you\\'re first looking for recursive tree problems. But hey, if you stick with it, you\\'ll get this, and it\\'s a great problem for tracking variable values in recursive functions. \\n\\nBut having solved a bunch of leetcode problems, I\\'d definitely say this one is medium, not easy. If I didn\\'t know the answer, I think I\\'d still struggle to get this one. "
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "[@eduard92](/eduard92) \"laid off already\" LMFAOOOO \\uD83D\\uDE02\\uD83D\\uDC80"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its easy for those who already know.. maybe they are in uni and already solved in there and they solve it here too.\nSome of us just come here with an empty mind to push forward and is hard if you have no background. I approached this month DP and Trees for the first time in my life, it surely developed a way of thinking of data in terms of a Tree and Recursion in my mind works now as a Stack, isn't something hard to explain anymore, but I still check discuss and other websites for pseudocode.\n\nI know the comment is old, dude probably got at google and laid off already but for future people who feel stuck I think its about pushing into unkown.\n"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I agree. Unless you\\'ve seen the style of this solution somewhere before (it\\'s similar to the divide-and-conquer solution of the Maximum Subarray problem), you\\'ll probably have a tough time when coming into this problem with an empty mind."
                    },
                    {
                        "username": "chidam333",
                        "content": "here you have to just go through every node and find sum of heights of it\\'s left and right node , which is way easier than knowing the exact path... ig lol "
                    },
                    {
                        "username": "alvinato",
                        "content": "[4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]\\n\\n^ the above test case expects an answer of 8.  But I only count 7 edges between every node.  Between which two nodes are there 8 edges?"
                    },
                    {
                        "username": "suraj21209",
                        "content": "https://leetcode.com/problems/diameter-of-binary-tree/submissions/995832822/"
                    },
                    {
                        "username": "chidam333",
                        "content": "Note that the path does not need to pass through the root"
                    },
                    {
                        "username": "toho42",
                        "content": "copy and paste that to the test case to view the binary tree.  The node with a root of -9 has a maxDepth(left) of 4, and a maxDepth(right) of 4.  Thus, the diameter is 8.  This is case where the maxDiameter of a child node exceeds the maxDepth of the parent node\\'s left and right branches.\\n"
                    },
                    {
                        "username": "mascomen4",
                        "content": "see my comment below: https://leetcode.com/problems/diameter-of-binary-tree/discussion/comments/1629510"
                    },
                    {
                        "username": "OBAAT",
                        "content": "Bullshit problem description. \\nBullshit definition for \"diameter\". \\nIs it so difficult to say instead \"longest path\"? \\nProblem writers are morons. "
                    },
                    {
                        "username": "xclusive102",
                        "content": "[@ahmedtsalem9](/ahmedtsalem9) But this is not the world of circles. I agree that using \\'longest path\\' is more appropriate in the world of trees."
                    },
                    {
                        "username": "chumaumenze",
                        "content": "[@ahmedtsalem9](/ahmedtsalem9) The description is not a good one. I could not implement this because I had a problem understanding the question. When they say diameter, it implies the logic of how the diameter of a circle works - the length of the line through the center that touches two points on the edge of the circle. I was calculating the height of the tree from root to leaf."
                    },
                    {
                        "username": "ahmedtsalem9",
                        "content": "Technically, \"Diameter\" is a precise term. In the world of circles, the diameter is the longest line that can ever be drawn within a circle.\\n\\nThe same exact definition applies to trees; it\\'s the longest \"path\" that can ever be drawn within a tree through its nodes."
                    },
                    {
                        "username": "rana_afifi",
                        "content": "Rather tricky. Don\\'t think it is considered easy "
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Me too."
                    },
                    {
                        "username": "myih",
                        "content": "Scrolling down the discussions and most of the solutions are basically the same as the solution for no.124, yet this one is marked as easy and 124 is hard? Is there a easier way for this problem?"
                    },
                    {
                        "username": "suraj21209",
                        "content": "[@dragon1105](/dragon1105) https://leetcode.com/problems/diameter-of-binary-tree/submissions/995832822/"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "This one feels more like a medium to me. But 124 has a waaaay stricter time limit. My solution for 124 is getting TLEd to oblivion even with caching("
                    },
                    {
                        "username": "dragon1105",
                        "content": "Yeah I think this should be labeled as medium. This can only be easy when you\\'ve known the solution of some similar problems like Maximum Subarray (especially the divide-and-conquer one)."
                    },
                    {
                        "username": "WizTheProgrammer",
                        "content": "\"Easy\""
                    },
                    {
                        "username": "Dummyy",
                        "content": "sdcs jhfb wi wiufhw eiu uhweofuwe hfowe fowefowe fhwoe"
                    },
                    {
                        "username": "jonathanferraro75",
                        "content": "banging his head on the keyboard out of frustration"
                    },
                    {
                        "username": "rajat_171",
                        "content": "I agree"
                    },
                    {
                        "username": "techpromulgator",
                        "content": "How is the diameter of the below test case is 8?\\n\\n[4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]\\n\\nWhen I visualize, I see that it\\'s 7 and I\\'m getting 7. But, the expected answer is 8"
                    },
                    {
                        "username": "gauravkumar125",
                        "content": "i got it as 8 "
                    },
                    {
                        "username": "stephanauwerda000",
                        "content": "Because you should calculate max diameter of EVERY node, not just the root.\\nThe node (-9) has a diameter of 8. \\nSo this is the max diameter which the function should return."
                    },
                    {
                        "username": "ande_ka_funda",
                        "content": "The solution to just find the maximum width is rather simple. \\n\\nHowever I was asked to also print the path (and not just find the diameter).\\n\\nTotally fumbled. I have been trying but I am unable to come up with an O(n) solution"
                    },
                    {
                        "username": "JustBored",
                        "content": "Can do a second dfs from the root node with the max diameter. Just memoise which child node leads to the max height for each node  which will tell you which direction to go beforehand. But you have to make sure you go in both directions in the first iteration of the 2nd dfs from the starting node. This will give you the best path in O(n).\n\nThe O(n^2) approach would be to store the maximum height path for each node and combine the child left and right path at the max diameter node to get the optimal path. You can do this in one dfs but the tc is still O(n^2)\n    "
                    },
                    {
                        "username": "dhruvpithwa1999",
                        "content": "[@uchihahardik](/uchihahardik) You can refer to my soln, https://leetcode.com/problems/diameter-of-binary-tree/submissions/869730789/\\n\\nI have tried to solve and find path using ArrayList, same approach but different return type\\n\\nmay be this can help you.."
                    },
                    {
                        "username": "uchihahardik",
                        "content": "\"The solution to just find the maximum width is rather simple.\"\\nI am not able to think of an approch any tip?"
                    },
                    {
                        "username": "keJum",
                        "content": "# Example 1\\n![image](https://assets.leetcode.com/users/images/9f86a81d-aef1-4090-a327-14071d450001_1634631307.9913106.png)\\n\\nResult 3, expected 3\\n\\n# Example 100\\n![image](https://assets.leetcode.com/users/images/e671990e-09a1-4deb-b605-5bd4c15419cb_1634631254.7966447.png)\\n\\nResult 7, expected 8.\\n\\nWhy is the result expected to be 8 and not 7?"
                    },
                    {
                        "username": "ishananchit",
                        "content": "because of the path -4, 6, 6, 9, -9, -7, -6, 9, -2"
                    },
                    {
                        "username": "howhowone",
                        "content": "-2 9 -6 -7 -9 9 6 0 -1"
                    },
                    {
                        "username": "Geetanjali_Gupta",
                        "content": "path should be from -1 to -2 then ans would be 8"
                    },
                    {
                        "username": "deeponsubhro",
                        "content": "go from -1 to -2"
                    },
                    {
                        "username": "duchemin01",
                        "content": "[@VigneshwarVG](/VigneshwarVG)  then, expected should be 9"
                    },
                    {
                        "username": "VigneshwarVG",
                        "content": "it isn\\'t a rule that edge must always pass through the root of the tree\\nit might be its left or right or left\\'s (left or right ) or the right\\'s( left or right )and so on \\nhope you get it\\n"
                    },
                    {
                        "username": "RayanYI",
                        "content": "[@mascomen4](/mascomen4)  Thanks, very helpful. Thanks to you I\\'ve solved it :)"
                    },
                    {
                        "username": "Boyka800",
                        "content": "Because you are considering the wrong path, the correct one is from -4 to -2 of lenght 8."
                    },
                    {
                        "username": "mascomen4",
                        "content": "One year later, but may be it'll save some time for the others struggling the problem.\n\nUnfortunately, the assumption that the longest path comes through the root is not right for the unbalanced tree. So, they say `This path may or may not pass through the root`. \n\n*Hint:* try to find the path of 8 edges in the right subtree. "
                    }
                ]
            },
            {
                "id": 1575844,
                "content": [
                    {
                        "username": "SouthernHumor",
                        "content": "How the hek is this problem/program marked easy ? Solutions I\\'m seeing involve 2 recursive functions and this is just not quick or straightforward"
                    },
                    {
                        "username": "gbiems",
                        "content": "This one one of the first tree problems I tried to do on leetcode, since I was looking for \"easy\" tree problems. Oof. Now that I have some more experience, I feel a lot better about how hard I found it when I was starting out. This isn\\'t an easy problem. I come back to it and re-solve it every now and then.\\n\\nI think what makes it difficult is that (in the most common solution I\\'ve seen) you need to return a value from a recursive function (the max length of left or right branch from each node) but you need to set a class variable or other way of tracking the maximum value of the left + right branches.\\n\\nThat\\'s a lot to wrap your head around when you\\'re first looking for recursive tree problems. But hey, if you stick with it, you\\'ll get this, and it\\'s a great problem for tracking variable values in recursive functions. \\n\\nBut having solved a bunch of leetcode problems, I\\'d definitely say this one is medium, not easy. If I didn\\'t know the answer, I think I\\'d still struggle to get this one. "
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "[@eduard92](/eduard92) \"laid off already\" LMFAOOOO \\uD83D\\uDE02\\uD83D\\uDC80"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its easy for those who already know.. maybe they are in uni and already solved in there and they solve it here too.\nSome of us just come here with an empty mind to push forward and is hard if you have no background. I approached this month DP and Trees for the first time in my life, it surely developed a way of thinking of data in terms of a Tree and Recursion in my mind works now as a Stack, isn't something hard to explain anymore, but I still check discuss and other websites for pseudocode.\n\nI know the comment is old, dude probably got at google and laid off already but for future people who feel stuck I think its about pushing into unkown.\n"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I agree. Unless you\\'ve seen the style of this solution somewhere before (it\\'s similar to the divide-and-conquer solution of the Maximum Subarray problem), you\\'ll probably have a tough time when coming into this problem with an empty mind."
                    },
                    {
                        "username": "chidam333",
                        "content": "here you have to just go through every node and find sum of heights of it\\'s left and right node , which is way easier than knowing the exact path... ig lol "
                    },
                    {
                        "username": "alvinato",
                        "content": "[4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]\\n\\n^ the above test case expects an answer of 8.  But I only count 7 edges between every node.  Between which two nodes are there 8 edges?"
                    },
                    {
                        "username": "suraj21209",
                        "content": "https://leetcode.com/problems/diameter-of-binary-tree/submissions/995832822/"
                    },
                    {
                        "username": "chidam333",
                        "content": "Note that the path does not need to pass through the root"
                    },
                    {
                        "username": "toho42",
                        "content": "copy and paste that to the test case to view the binary tree.  The node with a root of -9 has a maxDepth(left) of 4, and a maxDepth(right) of 4.  Thus, the diameter is 8.  This is case where the maxDiameter of a child node exceeds the maxDepth of the parent node\\'s left and right branches.\\n"
                    },
                    {
                        "username": "mascomen4",
                        "content": "see my comment below: https://leetcode.com/problems/diameter-of-binary-tree/discussion/comments/1629510"
                    },
                    {
                        "username": "OBAAT",
                        "content": "Bullshit problem description. \\nBullshit definition for \"diameter\". \\nIs it so difficult to say instead \"longest path\"? \\nProblem writers are morons. "
                    },
                    {
                        "username": "xclusive102",
                        "content": "[@ahmedtsalem9](/ahmedtsalem9) But this is not the world of circles. I agree that using \\'longest path\\' is more appropriate in the world of trees."
                    },
                    {
                        "username": "chumaumenze",
                        "content": "[@ahmedtsalem9](/ahmedtsalem9) The description is not a good one. I could not implement this because I had a problem understanding the question. When they say diameter, it implies the logic of how the diameter of a circle works - the length of the line through the center that touches two points on the edge of the circle. I was calculating the height of the tree from root to leaf."
                    },
                    {
                        "username": "ahmedtsalem9",
                        "content": "Technically, \"Diameter\" is a precise term. In the world of circles, the diameter is the longest line that can ever be drawn within a circle.\\n\\nThe same exact definition applies to trees; it\\'s the longest \"path\" that can ever be drawn within a tree through its nodes."
                    },
                    {
                        "username": "rana_afifi",
                        "content": "Rather tricky. Don\\'t think it is considered easy "
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Me too."
                    },
                    {
                        "username": "myih",
                        "content": "Scrolling down the discussions and most of the solutions are basically the same as the solution for no.124, yet this one is marked as easy and 124 is hard? Is there a easier way for this problem?"
                    },
                    {
                        "username": "suraj21209",
                        "content": "[@dragon1105](/dragon1105) https://leetcode.com/problems/diameter-of-binary-tree/submissions/995832822/"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "This one feels more like a medium to me. But 124 has a waaaay stricter time limit. My solution for 124 is getting TLEd to oblivion even with caching("
                    },
                    {
                        "username": "dragon1105",
                        "content": "Yeah I think this should be labeled as medium. This can only be easy when you\\'ve known the solution of some similar problems like Maximum Subarray (especially the divide-and-conquer one)."
                    },
                    {
                        "username": "WizTheProgrammer",
                        "content": "\"Easy\""
                    },
                    {
                        "username": "Dummyy",
                        "content": "sdcs jhfb wi wiufhw eiu uhweofuwe hfowe fowefowe fhwoe"
                    },
                    {
                        "username": "jonathanferraro75",
                        "content": "banging his head on the keyboard out of frustration"
                    },
                    {
                        "username": "rajat_171",
                        "content": "I agree"
                    },
                    {
                        "username": "techpromulgator",
                        "content": "How is the diameter of the below test case is 8?\\n\\n[4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]\\n\\nWhen I visualize, I see that it\\'s 7 and I\\'m getting 7. But, the expected answer is 8"
                    },
                    {
                        "username": "gauravkumar125",
                        "content": "i got it as 8 "
                    },
                    {
                        "username": "stephanauwerda000",
                        "content": "Because you should calculate max diameter of EVERY node, not just the root.\\nThe node (-9) has a diameter of 8. \\nSo this is the max diameter which the function should return."
                    },
                    {
                        "username": "ande_ka_funda",
                        "content": "The solution to just find the maximum width is rather simple. \\n\\nHowever I was asked to also print the path (and not just find the diameter).\\n\\nTotally fumbled. I have been trying but I am unable to come up with an O(n) solution"
                    },
                    {
                        "username": "JustBored",
                        "content": "Can do a second dfs from the root node with the max diameter. Just memoise which child node leads to the max height for each node  which will tell you which direction to go beforehand. But you have to make sure you go in both directions in the first iteration of the 2nd dfs from the starting node. This will give you the best path in O(n).\n\nThe O(n^2) approach would be to store the maximum height path for each node and combine the child left and right path at the max diameter node to get the optimal path. You can do this in one dfs but the tc is still O(n^2)\n    "
                    },
                    {
                        "username": "dhruvpithwa1999",
                        "content": "[@uchihahardik](/uchihahardik) You can refer to my soln, https://leetcode.com/problems/diameter-of-binary-tree/submissions/869730789/\\n\\nI have tried to solve and find path using ArrayList, same approach but different return type\\n\\nmay be this can help you.."
                    },
                    {
                        "username": "uchihahardik",
                        "content": "\"The solution to just find the maximum width is rather simple.\"\\nI am not able to think of an approch any tip?"
                    },
                    {
                        "username": "keJum",
                        "content": "# Example 1\\n![image](https://assets.leetcode.com/users/images/9f86a81d-aef1-4090-a327-14071d450001_1634631307.9913106.png)\\n\\nResult 3, expected 3\\n\\n# Example 100\\n![image](https://assets.leetcode.com/users/images/e671990e-09a1-4deb-b605-5bd4c15419cb_1634631254.7966447.png)\\n\\nResult 7, expected 8.\\n\\nWhy is the result expected to be 8 and not 7?"
                    },
                    {
                        "username": "ishananchit",
                        "content": "because of the path -4, 6, 6, 9, -9, -7, -6, 9, -2"
                    },
                    {
                        "username": "howhowone",
                        "content": "-2 9 -6 -7 -9 9 6 0 -1"
                    },
                    {
                        "username": "Geetanjali_Gupta",
                        "content": "path should be from -1 to -2 then ans would be 8"
                    },
                    {
                        "username": "deeponsubhro",
                        "content": "go from -1 to -2"
                    },
                    {
                        "username": "duchemin01",
                        "content": "[@VigneshwarVG](/VigneshwarVG)  then, expected should be 9"
                    },
                    {
                        "username": "VigneshwarVG",
                        "content": "it isn\\'t a rule that edge must always pass through the root of the tree\\nit might be its left or right or left\\'s (left or right ) or the right\\'s( left or right )and so on \\nhope you get it\\n"
                    },
                    {
                        "username": "RayanYI",
                        "content": "[@mascomen4](/mascomen4)  Thanks, very helpful. Thanks to you I\\'ve solved it :)"
                    },
                    {
                        "username": "Boyka800",
                        "content": "Because you are considering the wrong path, the correct one is from -4 to -2 of lenght 8."
                    },
                    {
                        "username": "mascomen4",
                        "content": "One year later, but may be it'll save some time for the others struggling the problem.\n\nUnfortunately, the assumption that the longest path comes through the root is not right for the unbalanced tree. So, they say `This path may or may not pass through the root`. \n\n*Hint:* try to find the path of 8 edges in the right subtree. "
                    }
                ]
            },
            {
                "id": 1569834,
                "content": [
                    {
                        "username": "SouthernHumor",
                        "content": "How the hek is this problem/program marked easy ? Solutions I\\'m seeing involve 2 recursive functions and this is just not quick or straightforward"
                    },
                    {
                        "username": "gbiems",
                        "content": "This one one of the first tree problems I tried to do on leetcode, since I was looking for \"easy\" tree problems. Oof. Now that I have some more experience, I feel a lot better about how hard I found it when I was starting out. This isn\\'t an easy problem. I come back to it and re-solve it every now and then.\\n\\nI think what makes it difficult is that (in the most common solution I\\'ve seen) you need to return a value from a recursive function (the max length of left or right branch from each node) but you need to set a class variable or other way of tracking the maximum value of the left + right branches.\\n\\nThat\\'s a lot to wrap your head around when you\\'re first looking for recursive tree problems. But hey, if you stick with it, you\\'ll get this, and it\\'s a great problem for tracking variable values in recursive functions. \\n\\nBut having solved a bunch of leetcode problems, I\\'d definitely say this one is medium, not easy. If I didn\\'t know the answer, I think I\\'d still struggle to get this one. "
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "[@eduard92](/eduard92) \"laid off already\" LMFAOOOO \\uD83D\\uDE02\\uD83D\\uDC80"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its easy for those who already know.. maybe they are in uni and already solved in there and they solve it here too.\nSome of us just come here with an empty mind to push forward and is hard if you have no background. I approached this month DP and Trees for the first time in my life, it surely developed a way of thinking of data in terms of a Tree and Recursion in my mind works now as a Stack, isn't something hard to explain anymore, but I still check discuss and other websites for pseudocode.\n\nI know the comment is old, dude probably got at google and laid off already but for future people who feel stuck I think its about pushing into unkown.\n"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I agree. Unless you\\'ve seen the style of this solution somewhere before (it\\'s similar to the divide-and-conquer solution of the Maximum Subarray problem), you\\'ll probably have a tough time when coming into this problem with an empty mind."
                    },
                    {
                        "username": "chidam333",
                        "content": "here you have to just go through every node and find sum of heights of it\\'s left and right node , which is way easier than knowing the exact path... ig lol "
                    },
                    {
                        "username": "alvinato",
                        "content": "[4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]\\n\\n^ the above test case expects an answer of 8.  But I only count 7 edges between every node.  Between which two nodes are there 8 edges?"
                    },
                    {
                        "username": "suraj21209",
                        "content": "https://leetcode.com/problems/diameter-of-binary-tree/submissions/995832822/"
                    },
                    {
                        "username": "chidam333",
                        "content": "Note that the path does not need to pass through the root"
                    },
                    {
                        "username": "toho42",
                        "content": "copy and paste that to the test case to view the binary tree.  The node with a root of -9 has a maxDepth(left) of 4, and a maxDepth(right) of 4.  Thus, the diameter is 8.  This is case where the maxDiameter of a child node exceeds the maxDepth of the parent node\\'s left and right branches.\\n"
                    },
                    {
                        "username": "mascomen4",
                        "content": "see my comment below: https://leetcode.com/problems/diameter-of-binary-tree/discussion/comments/1629510"
                    },
                    {
                        "username": "OBAAT",
                        "content": "Bullshit problem description. \\nBullshit definition for \"diameter\". \\nIs it so difficult to say instead \"longest path\"? \\nProblem writers are morons. "
                    },
                    {
                        "username": "xclusive102",
                        "content": "[@ahmedtsalem9](/ahmedtsalem9) But this is not the world of circles. I agree that using \\'longest path\\' is more appropriate in the world of trees."
                    },
                    {
                        "username": "chumaumenze",
                        "content": "[@ahmedtsalem9](/ahmedtsalem9) The description is not a good one. I could not implement this because I had a problem understanding the question. When they say diameter, it implies the logic of how the diameter of a circle works - the length of the line through the center that touches two points on the edge of the circle. I was calculating the height of the tree from root to leaf."
                    },
                    {
                        "username": "ahmedtsalem9",
                        "content": "Technically, \"Diameter\" is a precise term. In the world of circles, the diameter is the longest line that can ever be drawn within a circle.\\n\\nThe same exact definition applies to trees; it\\'s the longest \"path\" that can ever be drawn within a tree through its nodes."
                    },
                    {
                        "username": "rana_afifi",
                        "content": "Rather tricky. Don\\'t think it is considered easy "
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Me too."
                    },
                    {
                        "username": "myih",
                        "content": "Scrolling down the discussions and most of the solutions are basically the same as the solution for no.124, yet this one is marked as easy and 124 is hard? Is there a easier way for this problem?"
                    },
                    {
                        "username": "suraj21209",
                        "content": "[@dragon1105](/dragon1105) https://leetcode.com/problems/diameter-of-binary-tree/submissions/995832822/"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "This one feels more like a medium to me. But 124 has a waaaay stricter time limit. My solution for 124 is getting TLEd to oblivion even with caching("
                    },
                    {
                        "username": "dragon1105",
                        "content": "Yeah I think this should be labeled as medium. This can only be easy when you\\'ve known the solution of some similar problems like Maximum Subarray (especially the divide-and-conquer one)."
                    },
                    {
                        "username": "WizTheProgrammer",
                        "content": "\"Easy\""
                    },
                    {
                        "username": "Dummyy",
                        "content": "sdcs jhfb wi wiufhw eiu uhweofuwe hfowe fowefowe fhwoe"
                    },
                    {
                        "username": "jonathanferraro75",
                        "content": "banging his head on the keyboard out of frustration"
                    },
                    {
                        "username": "rajat_171",
                        "content": "I agree"
                    },
                    {
                        "username": "techpromulgator",
                        "content": "How is the diameter of the below test case is 8?\\n\\n[4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]\\n\\nWhen I visualize, I see that it\\'s 7 and I\\'m getting 7. But, the expected answer is 8"
                    },
                    {
                        "username": "gauravkumar125",
                        "content": "i got it as 8 "
                    },
                    {
                        "username": "stephanauwerda000",
                        "content": "Because you should calculate max diameter of EVERY node, not just the root.\\nThe node (-9) has a diameter of 8. \\nSo this is the max diameter which the function should return."
                    },
                    {
                        "username": "ande_ka_funda",
                        "content": "The solution to just find the maximum width is rather simple. \\n\\nHowever I was asked to also print the path (and not just find the diameter).\\n\\nTotally fumbled. I have been trying but I am unable to come up with an O(n) solution"
                    },
                    {
                        "username": "JustBored",
                        "content": "Can do a second dfs from the root node with the max diameter. Just memoise which child node leads to the max height for each node  which will tell you which direction to go beforehand. But you have to make sure you go in both directions in the first iteration of the 2nd dfs from the starting node. This will give you the best path in O(n).\n\nThe O(n^2) approach would be to store the maximum height path for each node and combine the child left and right path at the max diameter node to get the optimal path. You can do this in one dfs but the tc is still O(n^2)\n    "
                    },
                    {
                        "username": "dhruvpithwa1999",
                        "content": "[@uchihahardik](/uchihahardik) You can refer to my soln, https://leetcode.com/problems/diameter-of-binary-tree/submissions/869730789/\\n\\nI have tried to solve and find path using ArrayList, same approach but different return type\\n\\nmay be this can help you.."
                    },
                    {
                        "username": "uchihahardik",
                        "content": "\"The solution to just find the maximum width is rather simple.\"\\nI am not able to think of an approch any tip?"
                    },
                    {
                        "username": "keJum",
                        "content": "# Example 1\\n![image](https://assets.leetcode.com/users/images/9f86a81d-aef1-4090-a327-14071d450001_1634631307.9913106.png)\\n\\nResult 3, expected 3\\n\\n# Example 100\\n![image](https://assets.leetcode.com/users/images/e671990e-09a1-4deb-b605-5bd4c15419cb_1634631254.7966447.png)\\n\\nResult 7, expected 8.\\n\\nWhy is the result expected to be 8 and not 7?"
                    },
                    {
                        "username": "ishananchit",
                        "content": "because of the path -4, 6, 6, 9, -9, -7, -6, 9, -2"
                    },
                    {
                        "username": "howhowone",
                        "content": "-2 9 -6 -7 -9 9 6 0 -1"
                    },
                    {
                        "username": "Geetanjali_Gupta",
                        "content": "path should be from -1 to -2 then ans would be 8"
                    },
                    {
                        "username": "deeponsubhro",
                        "content": "go from -1 to -2"
                    },
                    {
                        "username": "duchemin01",
                        "content": "[@VigneshwarVG](/VigneshwarVG)  then, expected should be 9"
                    },
                    {
                        "username": "VigneshwarVG",
                        "content": "it isn\\'t a rule that edge must always pass through the root of the tree\\nit might be its left or right or left\\'s (left or right ) or the right\\'s( left or right )and so on \\nhope you get it\\n"
                    },
                    {
                        "username": "RayanYI",
                        "content": "[@mascomen4](/mascomen4)  Thanks, very helpful. Thanks to you I\\'ve solved it :)"
                    },
                    {
                        "username": "Boyka800",
                        "content": "Because you are considering the wrong path, the correct one is from -4 to -2 of lenght 8."
                    },
                    {
                        "username": "mascomen4",
                        "content": "One year later, but may be it'll save some time for the others struggling the problem.\n\nUnfortunately, the assumption that the longest path comes through the root is not right for the unbalanced tree. So, they say `This path may or may not pass through the root`. \n\n*Hint:* try to find the path of 8 edges in the right subtree. "
                    }
                ]
            },
            {
                "id": 1567497,
                "content": [
                    {
                        "username": "SouthernHumor",
                        "content": "How the hek is this problem/program marked easy ? Solutions I\\'m seeing involve 2 recursive functions and this is just not quick or straightforward"
                    },
                    {
                        "username": "gbiems",
                        "content": "This one one of the first tree problems I tried to do on leetcode, since I was looking for \"easy\" tree problems. Oof. Now that I have some more experience, I feel a lot better about how hard I found it when I was starting out. This isn\\'t an easy problem. I come back to it and re-solve it every now and then.\\n\\nI think what makes it difficult is that (in the most common solution I\\'ve seen) you need to return a value from a recursive function (the max length of left or right branch from each node) but you need to set a class variable or other way of tracking the maximum value of the left + right branches.\\n\\nThat\\'s a lot to wrap your head around when you\\'re first looking for recursive tree problems. But hey, if you stick with it, you\\'ll get this, and it\\'s a great problem for tracking variable values in recursive functions. \\n\\nBut having solved a bunch of leetcode problems, I\\'d definitely say this one is medium, not easy. If I didn\\'t know the answer, I think I\\'d still struggle to get this one. "
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "[@eduard92](/eduard92) \"laid off already\" LMFAOOOO \\uD83D\\uDE02\\uD83D\\uDC80"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its easy for those who already know.. maybe they are in uni and already solved in there and they solve it here too.\nSome of us just come here with an empty mind to push forward and is hard if you have no background. I approached this month DP and Trees for the first time in my life, it surely developed a way of thinking of data in terms of a Tree and Recursion in my mind works now as a Stack, isn't something hard to explain anymore, but I still check discuss and other websites for pseudocode.\n\nI know the comment is old, dude probably got at google and laid off already but for future people who feel stuck I think its about pushing into unkown.\n"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I agree. Unless you\\'ve seen the style of this solution somewhere before (it\\'s similar to the divide-and-conquer solution of the Maximum Subarray problem), you\\'ll probably have a tough time when coming into this problem with an empty mind."
                    },
                    {
                        "username": "chidam333",
                        "content": "here you have to just go through every node and find sum of heights of it\\'s left and right node , which is way easier than knowing the exact path... ig lol "
                    },
                    {
                        "username": "alvinato",
                        "content": "[4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]\\n\\n^ the above test case expects an answer of 8.  But I only count 7 edges between every node.  Between which two nodes are there 8 edges?"
                    },
                    {
                        "username": "suraj21209",
                        "content": "https://leetcode.com/problems/diameter-of-binary-tree/submissions/995832822/"
                    },
                    {
                        "username": "chidam333",
                        "content": "Note that the path does not need to pass through the root"
                    },
                    {
                        "username": "toho42",
                        "content": "copy and paste that to the test case to view the binary tree.  The node with a root of -9 has a maxDepth(left) of 4, and a maxDepth(right) of 4.  Thus, the diameter is 8.  This is case where the maxDiameter of a child node exceeds the maxDepth of the parent node\\'s left and right branches.\\n"
                    },
                    {
                        "username": "mascomen4",
                        "content": "see my comment below: https://leetcode.com/problems/diameter-of-binary-tree/discussion/comments/1629510"
                    },
                    {
                        "username": "OBAAT",
                        "content": "Bullshit problem description. \\nBullshit definition for \"diameter\". \\nIs it so difficult to say instead \"longest path\"? \\nProblem writers are morons. "
                    },
                    {
                        "username": "xclusive102",
                        "content": "[@ahmedtsalem9](/ahmedtsalem9) But this is not the world of circles. I agree that using \\'longest path\\' is more appropriate in the world of trees."
                    },
                    {
                        "username": "chumaumenze",
                        "content": "[@ahmedtsalem9](/ahmedtsalem9) The description is not a good one. I could not implement this because I had a problem understanding the question. When they say diameter, it implies the logic of how the diameter of a circle works - the length of the line through the center that touches two points on the edge of the circle. I was calculating the height of the tree from root to leaf."
                    },
                    {
                        "username": "ahmedtsalem9",
                        "content": "Technically, \"Diameter\" is a precise term. In the world of circles, the diameter is the longest line that can ever be drawn within a circle.\\n\\nThe same exact definition applies to trees; it\\'s the longest \"path\" that can ever be drawn within a tree through its nodes."
                    },
                    {
                        "username": "rana_afifi",
                        "content": "Rather tricky. Don\\'t think it is considered easy "
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Me too."
                    },
                    {
                        "username": "myih",
                        "content": "Scrolling down the discussions and most of the solutions are basically the same as the solution for no.124, yet this one is marked as easy and 124 is hard? Is there a easier way for this problem?"
                    },
                    {
                        "username": "suraj21209",
                        "content": "[@dragon1105](/dragon1105) https://leetcode.com/problems/diameter-of-binary-tree/submissions/995832822/"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "This one feels more like a medium to me. But 124 has a waaaay stricter time limit. My solution for 124 is getting TLEd to oblivion even with caching("
                    },
                    {
                        "username": "dragon1105",
                        "content": "Yeah I think this should be labeled as medium. This can only be easy when you\\'ve known the solution of some similar problems like Maximum Subarray (especially the divide-and-conquer one)."
                    },
                    {
                        "username": "WizTheProgrammer",
                        "content": "\"Easy\""
                    },
                    {
                        "username": "Dummyy",
                        "content": "sdcs jhfb wi wiufhw eiu uhweofuwe hfowe fowefowe fhwoe"
                    },
                    {
                        "username": "jonathanferraro75",
                        "content": "banging his head on the keyboard out of frustration"
                    },
                    {
                        "username": "rajat_171",
                        "content": "I agree"
                    },
                    {
                        "username": "techpromulgator",
                        "content": "How is the diameter of the below test case is 8?\\n\\n[4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]\\n\\nWhen I visualize, I see that it\\'s 7 and I\\'m getting 7. But, the expected answer is 8"
                    },
                    {
                        "username": "gauravkumar125",
                        "content": "i got it as 8 "
                    },
                    {
                        "username": "stephanauwerda000",
                        "content": "Because you should calculate max diameter of EVERY node, not just the root.\\nThe node (-9) has a diameter of 8. \\nSo this is the max diameter which the function should return."
                    },
                    {
                        "username": "ande_ka_funda",
                        "content": "The solution to just find the maximum width is rather simple. \\n\\nHowever I was asked to also print the path (and not just find the diameter).\\n\\nTotally fumbled. I have been trying but I am unable to come up with an O(n) solution"
                    },
                    {
                        "username": "JustBored",
                        "content": "Can do a second dfs from the root node with the max diameter. Just memoise which child node leads to the max height for each node  which will tell you which direction to go beforehand. But you have to make sure you go in both directions in the first iteration of the 2nd dfs from the starting node. This will give you the best path in O(n).\n\nThe O(n^2) approach would be to store the maximum height path for each node and combine the child left and right path at the max diameter node to get the optimal path. You can do this in one dfs but the tc is still O(n^2)\n    "
                    },
                    {
                        "username": "dhruvpithwa1999",
                        "content": "[@uchihahardik](/uchihahardik) You can refer to my soln, https://leetcode.com/problems/diameter-of-binary-tree/submissions/869730789/\\n\\nI have tried to solve and find path using ArrayList, same approach but different return type\\n\\nmay be this can help you.."
                    },
                    {
                        "username": "uchihahardik",
                        "content": "\"The solution to just find the maximum width is rather simple.\"\\nI am not able to think of an approch any tip?"
                    },
                    {
                        "username": "keJum",
                        "content": "# Example 1\\n![image](https://assets.leetcode.com/users/images/9f86a81d-aef1-4090-a327-14071d450001_1634631307.9913106.png)\\n\\nResult 3, expected 3\\n\\n# Example 100\\n![image](https://assets.leetcode.com/users/images/e671990e-09a1-4deb-b605-5bd4c15419cb_1634631254.7966447.png)\\n\\nResult 7, expected 8.\\n\\nWhy is the result expected to be 8 and not 7?"
                    },
                    {
                        "username": "ishananchit",
                        "content": "because of the path -4, 6, 6, 9, -9, -7, -6, 9, -2"
                    },
                    {
                        "username": "howhowone",
                        "content": "-2 9 -6 -7 -9 9 6 0 -1"
                    },
                    {
                        "username": "Geetanjali_Gupta",
                        "content": "path should be from -1 to -2 then ans would be 8"
                    },
                    {
                        "username": "deeponsubhro",
                        "content": "go from -1 to -2"
                    },
                    {
                        "username": "duchemin01",
                        "content": "[@VigneshwarVG](/VigneshwarVG)  then, expected should be 9"
                    },
                    {
                        "username": "VigneshwarVG",
                        "content": "it isn\\'t a rule that edge must always pass through the root of the tree\\nit might be its left or right or left\\'s (left or right ) or the right\\'s( left or right )and so on \\nhope you get it\\n"
                    },
                    {
                        "username": "RayanYI",
                        "content": "[@mascomen4](/mascomen4)  Thanks, very helpful. Thanks to you I\\'ve solved it :)"
                    },
                    {
                        "username": "Boyka800",
                        "content": "Because you are considering the wrong path, the correct one is from -4 to -2 of lenght 8."
                    },
                    {
                        "username": "mascomen4",
                        "content": "One year later, but may be it'll save some time for the others struggling the problem.\n\nUnfortunately, the assumption that the longest path comes through the root is not right for the unbalanced tree. So, they say `This path may or may not pass through the root`. \n\n*Hint:* try to find the path of 8 edges in the right subtree. "
                    }
                ]
            },
            {
                "id": 1575874,
                "content": [
                    {
                        "username": "SouthernHumor",
                        "content": "How the hek is this problem/program marked easy ? Solutions I\\'m seeing involve 2 recursive functions and this is just not quick or straightforward"
                    },
                    {
                        "username": "gbiems",
                        "content": "This one one of the first tree problems I tried to do on leetcode, since I was looking for \"easy\" tree problems. Oof. Now that I have some more experience, I feel a lot better about how hard I found it when I was starting out. This isn\\'t an easy problem. I come back to it and re-solve it every now and then.\\n\\nI think what makes it difficult is that (in the most common solution I\\'ve seen) you need to return a value from a recursive function (the max length of left or right branch from each node) but you need to set a class variable or other way of tracking the maximum value of the left + right branches.\\n\\nThat\\'s a lot to wrap your head around when you\\'re first looking for recursive tree problems. But hey, if you stick with it, you\\'ll get this, and it\\'s a great problem for tracking variable values in recursive functions. \\n\\nBut having solved a bunch of leetcode problems, I\\'d definitely say this one is medium, not easy. If I didn\\'t know the answer, I think I\\'d still struggle to get this one. "
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "[@eduard92](/eduard92) \"laid off already\" LMFAOOOO \\uD83D\\uDE02\\uD83D\\uDC80"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its easy for those who already know.. maybe they are in uni and already solved in there and they solve it here too.\nSome of us just come here with an empty mind to push forward and is hard if you have no background. I approached this month DP and Trees for the first time in my life, it surely developed a way of thinking of data in terms of a Tree and Recursion in my mind works now as a Stack, isn't something hard to explain anymore, but I still check discuss and other websites for pseudocode.\n\nI know the comment is old, dude probably got at google and laid off already but for future people who feel stuck I think its about pushing into unkown.\n"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I agree. Unless you\\'ve seen the style of this solution somewhere before (it\\'s similar to the divide-and-conquer solution of the Maximum Subarray problem), you\\'ll probably have a tough time when coming into this problem with an empty mind."
                    },
                    {
                        "username": "chidam333",
                        "content": "here you have to just go through every node and find sum of heights of it\\'s left and right node , which is way easier than knowing the exact path... ig lol "
                    },
                    {
                        "username": "alvinato",
                        "content": "[4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]\\n\\n^ the above test case expects an answer of 8.  But I only count 7 edges between every node.  Between which two nodes are there 8 edges?"
                    },
                    {
                        "username": "suraj21209",
                        "content": "https://leetcode.com/problems/diameter-of-binary-tree/submissions/995832822/"
                    },
                    {
                        "username": "chidam333",
                        "content": "Note that the path does not need to pass through the root"
                    },
                    {
                        "username": "toho42",
                        "content": "copy and paste that to the test case to view the binary tree.  The node with a root of -9 has a maxDepth(left) of 4, and a maxDepth(right) of 4.  Thus, the diameter is 8.  This is case where the maxDiameter of a child node exceeds the maxDepth of the parent node\\'s left and right branches.\\n"
                    },
                    {
                        "username": "mascomen4",
                        "content": "see my comment below: https://leetcode.com/problems/diameter-of-binary-tree/discussion/comments/1629510"
                    },
                    {
                        "username": "OBAAT",
                        "content": "Bullshit problem description. \\nBullshit definition for \"diameter\". \\nIs it so difficult to say instead \"longest path\"? \\nProblem writers are morons. "
                    },
                    {
                        "username": "xclusive102",
                        "content": "[@ahmedtsalem9](/ahmedtsalem9) But this is not the world of circles. I agree that using \\'longest path\\' is more appropriate in the world of trees."
                    },
                    {
                        "username": "chumaumenze",
                        "content": "[@ahmedtsalem9](/ahmedtsalem9) The description is not a good one. I could not implement this because I had a problem understanding the question. When they say diameter, it implies the logic of how the diameter of a circle works - the length of the line through the center that touches two points on the edge of the circle. I was calculating the height of the tree from root to leaf."
                    },
                    {
                        "username": "ahmedtsalem9",
                        "content": "Technically, \"Diameter\" is a precise term. In the world of circles, the diameter is the longest line that can ever be drawn within a circle.\\n\\nThe same exact definition applies to trees; it\\'s the longest \"path\" that can ever be drawn within a tree through its nodes."
                    },
                    {
                        "username": "rana_afifi",
                        "content": "Rather tricky. Don\\'t think it is considered easy "
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Me too."
                    },
                    {
                        "username": "myih",
                        "content": "Scrolling down the discussions and most of the solutions are basically the same as the solution for no.124, yet this one is marked as easy and 124 is hard? Is there a easier way for this problem?"
                    },
                    {
                        "username": "suraj21209",
                        "content": "[@dragon1105](/dragon1105) https://leetcode.com/problems/diameter-of-binary-tree/submissions/995832822/"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "This one feels more like a medium to me. But 124 has a waaaay stricter time limit. My solution for 124 is getting TLEd to oblivion even with caching("
                    },
                    {
                        "username": "dragon1105",
                        "content": "Yeah I think this should be labeled as medium. This can only be easy when you\\'ve known the solution of some similar problems like Maximum Subarray (especially the divide-and-conquer one)."
                    },
                    {
                        "username": "WizTheProgrammer",
                        "content": "\"Easy\""
                    },
                    {
                        "username": "Dummyy",
                        "content": "sdcs jhfb wi wiufhw eiu uhweofuwe hfowe fowefowe fhwoe"
                    },
                    {
                        "username": "jonathanferraro75",
                        "content": "banging his head on the keyboard out of frustration"
                    },
                    {
                        "username": "rajat_171",
                        "content": "I agree"
                    },
                    {
                        "username": "techpromulgator",
                        "content": "How is the diameter of the below test case is 8?\\n\\n[4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]\\n\\nWhen I visualize, I see that it\\'s 7 and I\\'m getting 7. But, the expected answer is 8"
                    },
                    {
                        "username": "gauravkumar125",
                        "content": "i got it as 8 "
                    },
                    {
                        "username": "stephanauwerda000",
                        "content": "Because you should calculate max diameter of EVERY node, not just the root.\\nThe node (-9) has a diameter of 8. \\nSo this is the max diameter which the function should return."
                    },
                    {
                        "username": "ande_ka_funda",
                        "content": "The solution to just find the maximum width is rather simple. \\n\\nHowever I was asked to also print the path (and not just find the diameter).\\n\\nTotally fumbled. I have been trying but I am unable to come up with an O(n) solution"
                    },
                    {
                        "username": "JustBored",
                        "content": "Can do a second dfs from the root node with the max diameter. Just memoise which child node leads to the max height for each node  which will tell you which direction to go beforehand. But you have to make sure you go in both directions in the first iteration of the 2nd dfs from the starting node. This will give you the best path in O(n).\n\nThe O(n^2) approach would be to store the maximum height path for each node and combine the child left and right path at the max diameter node to get the optimal path. You can do this in one dfs but the tc is still O(n^2)\n    "
                    },
                    {
                        "username": "dhruvpithwa1999",
                        "content": "[@uchihahardik](/uchihahardik) You can refer to my soln, https://leetcode.com/problems/diameter-of-binary-tree/submissions/869730789/\\n\\nI have tried to solve and find path using ArrayList, same approach but different return type\\n\\nmay be this can help you.."
                    },
                    {
                        "username": "uchihahardik",
                        "content": "\"The solution to just find the maximum width is rather simple.\"\\nI am not able to think of an approch any tip?"
                    },
                    {
                        "username": "keJum",
                        "content": "# Example 1\\n![image](https://assets.leetcode.com/users/images/9f86a81d-aef1-4090-a327-14071d450001_1634631307.9913106.png)\\n\\nResult 3, expected 3\\n\\n# Example 100\\n![image](https://assets.leetcode.com/users/images/e671990e-09a1-4deb-b605-5bd4c15419cb_1634631254.7966447.png)\\n\\nResult 7, expected 8.\\n\\nWhy is the result expected to be 8 and not 7?"
                    },
                    {
                        "username": "ishananchit",
                        "content": "because of the path -4, 6, 6, 9, -9, -7, -6, 9, -2"
                    },
                    {
                        "username": "howhowone",
                        "content": "-2 9 -6 -7 -9 9 6 0 -1"
                    },
                    {
                        "username": "Geetanjali_Gupta",
                        "content": "path should be from -1 to -2 then ans would be 8"
                    },
                    {
                        "username": "deeponsubhro",
                        "content": "go from -1 to -2"
                    },
                    {
                        "username": "duchemin01",
                        "content": "[@VigneshwarVG](/VigneshwarVG)  then, expected should be 9"
                    },
                    {
                        "username": "VigneshwarVG",
                        "content": "it isn\\'t a rule that edge must always pass through the root of the tree\\nit might be its left or right or left\\'s (left or right ) or the right\\'s( left or right )and so on \\nhope you get it\\n"
                    },
                    {
                        "username": "RayanYI",
                        "content": "[@mascomen4](/mascomen4)  Thanks, very helpful. Thanks to you I\\'ve solved it :)"
                    },
                    {
                        "username": "Boyka800",
                        "content": "Because you are considering the wrong path, the correct one is from -4 to -2 of lenght 8."
                    },
                    {
                        "username": "mascomen4",
                        "content": "One year later, but may be it'll save some time for the others struggling the problem.\n\nUnfortunately, the assumption that the longest path comes through the root is not right for the unbalanced tree. So, they say `This path may or may not pass through the root`. \n\n*Hint:* try to find the path of 8 edges in the right subtree. "
                    }
                ]
            },
            {
                "id": 1575770,
                "content": [
                    {
                        "username": "SouthernHumor",
                        "content": "How the hek is this problem/program marked easy ? Solutions I\\'m seeing involve 2 recursive functions and this is just not quick or straightforward"
                    },
                    {
                        "username": "gbiems",
                        "content": "This one one of the first tree problems I tried to do on leetcode, since I was looking for \"easy\" tree problems. Oof. Now that I have some more experience, I feel a lot better about how hard I found it when I was starting out. This isn\\'t an easy problem. I come back to it and re-solve it every now and then.\\n\\nI think what makes it difficult is that (in the most common solution I\\'ve seen) you need to return a value from a recursive function (the max length of left or right branch from each node) but you need to set a class variable or other way of tracking the maximum value of the left + right branches.\\n\\nThat\\'s a lot to wrap your head around when you\\'re first looking for recursive tree problems. But hey, if you stick with it, you\\'ll get this, and it\\'s a great problem for tracking variable values in recursive functions. \\n\\nBut having solved a bunch of leetcode problems, I\\'d definitely say this one is medium, not easy. If I didn\\'t know the answer, I think I\\'d still struggle to get this one. "
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "[@eduard92](/eduard92) \"laid off already\" LMFAOOOO \\uD83D\\uDE02\\uD83D\\uDC80"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its easy for those who already know.. maybe they are in uni and already solved in there and they solve it here too.\nSome of us just come here with an empty mind to push forward and is hard if you have no background. I approached this month DP and Trees for the first time in my life, it surely developed a way of thinking of data in terms of a Tree and Recursion in my mind works now as a Stack, isn't something hard to explain anymore, but I still check discuss and other websites for pseudocode.\n\nI know the comment is old, dude probably got at google and laid off already but for future people who feel stuck I think its about pushing into unkown.\n"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I agree. Unless you\\'ve seen the style of this solution somewhere before (it\\'s similar to the divide-and-conquer solution of the Maximum Subarray problem), you\\'ll probably have a tough time when coming into this problem with an empty mind."
                    },
                    {
                        "username": "chidam333",
                        "content": "here you have to just go through every node and find sum of heights of it\\'s left and right node , which is way easier than knowing the exact path... ig lol "
                    },
                    {
                        "username": "alvinato",
                        "content": "[4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]\\n\\n^ the above test case expects an answer of 8.  But I only count 7 edges between every node.  Between which two nodes are there 8 edges?"
                    },
                    {
                        "username": "suraj21209",
                        "content": "https://leetcode.com/problems/diameter-of-binary-tree/submissions/995832822/"
                    },
                    {
                        "username": "chidam333",
                        "content": "Note that the path does not need to pass through the root"
                    },
                    {
                        "username": "toho42",
                        "content": "copy and paste that to the test case to view the binary tree.  The node with a root of -9 has a maxDepth(left) of 4, and a maxDepth(right) of 4.  Thus, the diameter is 8.  This is case where the maxDiameter of a child node exceeds the maxDepth of the parent node\\'s left and right branches.\\n"
                    },
                    {
                        "username": "mascomen4",
                        "content": "see my comment below: https://leetcode.com/problems/diameter-of-binary-tree/discussion/comments/1629510"
                    },
                    {
                        "username": "OBAAT",
                        "content": "Bullshit problem description. \\nBullshit definition for \"diameter\". \\nIs it so difficult to say instead \"longest path\"? \\nProblem writers are morons. "
                    },
                    {
                        "username": "xclusive102",
                        "content": "[@ahmedtsalem9](/ahmedtsalem9) But this is not the world of circles. I agree that using \\'longest path\\' is more appropriate in the world of trees."
                    },
                    {
                        "username": "chumaumenze",
                        "content": "[@ahmedtsalem9](/ahmedtsalem9) The description is not a good one. I could not implement this because I had a problem understanding the question. When they say diameter, it implies the logic of how the diameter of a circle works - the length of the line through the center that touches two points on the edge of the circle. I was calculating the height of the tree from root to leaf."
                    },
                    {
                        "username": "ahmedtsalem9",
                        "content": "Technically, \"Diameter\" is a precise term. In the world of circles, the diameter is the longest line that can ever be drawn within a circle.\\n\\nThe same exact definition applies to trees; it\\'s the longest \"path\" that can ever be drawn within a tree through its nodes."
                    },
                    {
                        "username": "rana_afifi",
                        "content": "Rather tricky. Don\\'t think it is considered easy "
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Me too."
                    },
                    {
                        "username": "myih",
                        "content": "Scrolling down the discussions and most of the solutions are basically the same as the solution for no.124, yet this one is marked as easy and 124 is hard? Is there a easier way for this problem?"
                    },
                    {
                        "username": "suraj21209",
                        "content": "[@dragon1105](/dragon1105) https://leetcode.com/problems/diameter-of-binary-tree/submissions/995832822/"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "This one feels more like a medium to me. But 124 has a waaaay stricter time limit. My solution for 124 is getting TLEd to oblivion even with caching("
                    },
                    {
                        "username": "dragon1105",
                        "content": "Yeah I think this should be labeled as medium. This can only be easy when you\\'ve known the solution of some similar problems like Maximum Subarray (especially the divide-and-conquer one)."
                    },
                    {
                        "username": "WizTheProgrammer",
                        "content": "\"Easy\""
                    },
                    {
                        "username": "Dummyy",
                        "content": "sdcs jhfb wi wiufhw eiu uhweofuwe hfowe fowefowe fhwoe"
                    },
                    {
                        "username": "jonathanferraro75",
                        "content": "banging his head on the keyboard out of frustration"
                    },
                    {
                        "username": "rajat_171",
                        "content": "I agree"
                    },
                    {
                        "username": "techpromulgator",
                        "content": "How is the diameter of the below test case is 8?\\n\\n[4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]\\n\\nWhen I visualize, I see that it\\'s 7 and I\\'m getting 7. But, the expected answer is 8"
                    },
                    {
                        "username": "gauravkumar125",
                        "content": "i got it as 8 "
                    },
                    {
                        "username": "stephanauwerda000",
                        "content": "Because you should calculate max diameter of EVERY node, not just the root.\\nThe node (-9) has a diameter of 8. \\nSo this is the max diameter which the function should return."
                    },
                    {
                        "username": "ande_ka_funda",
                        "content": "The solution to just find the maximum width is rather simple. \\n\\nHowever I was asked to also print the path (and not just find the diameter).\\n\\nTotally fumbled. I have been trying but I am unable to come up with an O(n) solution"
                    },
                    {
                        "username": "JustBored",
                        "content": "Can do a second dfs from the root node with the max diameter. Just memoise which child node leads to the max height for each node  which will tell you which direction to go beforehand. But you have to make sure you go in both directions in the first iteration of the 2nd dfs from the starting node. This will give you the best path in O(n).\n\nThe O(n^2) approach would be to store the maximum height path for each node and combine the child left and right path at the max diameter node to get the optimal path. You can do this in one dfs but the tc is still O(n^2)\n    "
                    },
                    {
                        "username": "dhruvpithwa1999",
                        "content": "[@uchihahardik](/uchihahardik) You can refer to my soln, https://leetcode.com/problems/diameter-of-binary-tree/submissions/869730789/\\n\\nI have tried to solve and find path using ArrayList, same approach but different return type\\n\\nmay be this can help you.."
                    },
                    {
                        "username": "uchihahardik",
                        "content": "\"The solution to just find the maximum width is rather simple.\"\\nI am not able to think of an approch any tip?"
                    },
                    {
                        "username": "keJum",
                        "content": "# Example 1\\n![image](https://assets.leetcode.com/users/images/9f86a81d-aef1-4090-a327-14071d450001_1634631307.9913106.png)\\n\\nResult 3, expected 3\\n\\n# Example 100\\n![image](https://assets.leetcode.com/users/images/e671990e-09a1-4deb-b605-5bd4c15419cb_1634631254.7966447.png)\\n\\nResult 7, expected 8.\\n\\nWhy is the result expected to be 8 and not 7?"
                    },
                    {
                        "username": "ishananchit",
                        "content": "because of the path -4, 6, 6, 9, -9, -7, -6, 9, -2"
                    },
                    {
                        "username": "howhowone",
                        "content": "-2 9 -6 -7 -9 9 6 0 -1"
                    },
                    {
                        "username": "Geetanjali_Gupta",
                        "content": "path should be from -1 to -2 then ans would be 8"
                    },
                    {
                        "username": "deeponsubhro",
                        "content": "go from -1 to -2"
                    },
                    {
                        "username": "duchemin01",
                        "content": "[@VigneshwarVG](/VigneshwarVG)  then, expected should be 9"
                    },
                    {
                        "username": "VigneshwarVG",
                        "content": "it isn\\'t a rule that edge must always pass through the root of the tree\\nit might be its left or right or left\\'s (left or right ) or the right\\'s( left or right )and so on \\nhope you get it\\n"
                    },
                    {
                        "username": "RayanYI",
                        "content": "[@mascomen4](/mascomen4)  Thanks, very helpful. Thanks to you I\\'ve solved it :)"
                    },
                    {
                        "username": "Boyka800",
                        "content": "Because you are considering the wrong path, the correct one is from -4 to -2 of lenght 8."
                    },
                    {
                        "username": "mascomen4",
                        "content": "One year later, but may be it'll save some time for the others struggling the problem.\n\nUnfortunately, the assumption that the longest path comes through the root is not right for the unbalanced tree. So, they say `This path may or may not pass through the root`. \n\n*Hint:* try to find the path of 8 edges in the right subtree. "
                    }
                ]
            },
            {
                "id": 1566534,
                "content": [
                    {
                        "username": "SouthernHumor",
                        "content": "How the hek is this problem/program marked easy ? Solutions I\\'m seeing involve 2 recursive functions and this is just not quick or straightforward"
                    },
                    {
                        "username": "gbiems",
                        "content": "This one one of the first tree problems I tried to do on leetcode, since I was looking for \"easy\" tree problems. Oof. Now that I have some more experience, I feel a lot better about how hard I found it when I was starting out. This isn\\'t an easy problem. I come back to it and re-solve it every now and then.\\n\\nI think what makes it difficult is that (in the most common solution I\\'ve seen) you need to return a value from a recursive function (the max length of left or right branch from each node) but you need to set a class variable or other way of tracking the maximum value of the left + right branches.\\n\\nThat\\'s a lot to wrap your head around when you\\'re first looking for recursive tree problems. But hey, if you stick with it, you\\'ll get this, and it\\'s a great problem for tracking variable values in recursive functions. \\n\\nBut having solved a bunch of leetcode problems, I\\'d definitely say this one is medium, not easy. If I didn\\'t know the answer, I think I\\'d still struggle to get this one. "
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "[@eduard92](/eduard92) \"laid off already\" LMFAOOOO \\uD83D\\uDE02\\uD83D\\uDC80"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its easy for those who already know.. maybe they are in uni and already solved in there and they solve it here too.\nSome of us just come here with an empty mind to push forward and is hard if you have no background. I approached this month DP and Trees for the first time in my life, it surely developed a way of thinking of data in terms of a Tree and Recursion in my mind works now as a Stack, isn't something hard to explain anymore, but I still check discuss and other websites for pseudocode.\n\nI know the comment is old, dude probably got at google and laid off already but for future people who feel stuck I think its about pushing into unkown.\n"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I agree. Unless you\\'ve seen the style of this solution somewhere before (it\\'s similar to the divide-and-conquer solution of the Maximum Subarray problem), you\\'ll probably have a tough time when coming into this problem with an empty mind."
                    },
                    {
                        "username": "chidam333",
                        "content": "here you have to just go through every node and find sum of heights of it\\'s left and right node , which is way easier than knowing the exact path... ig lol "
                    },
                    {
                        "username": "alvinato",
                        "content": "[4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]\\n\\n^ the above test case expects an answer of 8.  But I only count 7 edges between every node.  Between which two nodes are there 8 edges?"
                    },
                    {
                        "username": "suraj21209",
                        "content": "https://leetcode.com/problems/diameter-of-binary-tree/submissions/995832822/"
                    },
                    {
                        "username": "chidam333",
                        "content": "Note that the path does not need to pass through the root"
                    },
                    {
                        "username": "toho42",
                        "content": "copy and paste that to the test case to view the binary tree.  The node with a root of -9 has a maxDepth(left) of 4, and a maxDepth(right) of 4.  Thus, the diameter is 8.  This is case where the maxDiameter of a child node exceeds the maxDepth of the parent node\\'s left and right branches.\\n"
                    },
                    {
                        "username": "mascomen4",
                        "content": "see my comment below: https://leetcode.com/problems/diameter-of-binary-tree/discussion/comments/1629510"
                    },
                    {
                        "username": "OBAAT",
                        "content": "Bullshit problem description. \\nBullshit definition for \"diameter\". \\nIs it so difficult to say instead \"longest path\"? \\nProblem writers are morons. "
                    },
                    {
                        "username": "xclusive102",
                        "content": "[@ahmedtsalem9](/ahmedtsalem9) But this is not the world of circles. I agree that using \\'longest path\\' is more appropriate in the world of trees."
                    },
                    {
                        "username": "chumaumenze",
                        "content": "[@ahmedtsalem9](/ahmedtsalem9) The description is not a good one. I could not implement this because I had a problem understanding the question. When they say diameter, it implies the logic of how the diameter of a circle works - the length of the line through the center that touches two points on the edge of the circle. I was calculating the height of the tree from root to leaf."
                    },
                    {
                        "username": "ahmedtsalem9",
                        "content": "Technically, \"Diameter\" is a precise term. In the world of circles, the diameter is the longest line that can ever be drawn within a circle.\\n\\nThe same exact definition applies to trees; it\\'s the longest \"path\" that can ever be drawn within a tree through its nodes."
                    },
                    {
                        "username": "rana_afifi",
                        "content": "Rather tricky. Don\\'t think it is considered easy "
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Me too."
                    },
                    {
                        "username": "myih",
                        "content": "Scrolling down the discussions and most of the solutions are basically the same as the solution for no.124, yet this one is marked as easy and 124 is hard? Is there a easier way for this problem?"
                    },
                    {
                        "username": "suraj21209",
                        "content": "[@dragon1105](/dragon1105) https://leetcode.com/problems/diameter-of-binary-tree/submissions/995832822/"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "This one feels more like a medium to me. But 124 has a waaaay stricter time limit. My solution for 124 is getting TLEd to oblivion even with caching("
                    },
                    {
                        "username": "dragon1105",
                        "content": "Yeah I think this should be labeled as medium. This can only be easy when you\\'ve known the solution of some similar problems like Maximum Subarray (especially the divide-and-conquer one)."
                    },
                    {
                        "username": "WizTheProgrammer",
                        "content": "\"Easy\""
                    },
                    {
                        "username": "Dummyy",
                        "content": "sdcs jhfb wi wiufhw eiu uhweofuwe hfowe fowefowe fhwoe"
                    },
                    {
                        "username": "jonathanferraro75",
                        "content": "banging his head on the keyboard out of frustration"
                    },
                    {
                        "username": "rajat_171",
                        "content": "I agree"
                    },
                    {
                        "username": "techpromulgator",
                        "content": "How is the diameter of the below test case is 8?\\n\\n[4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]\\n\\nWhen I visualize, I see that it\\'s 7 and I\\'m getting 7. But, the expected answer is 8"
                    },
                    {
                        "username": "gauravkumar125",
                        "content": "i got it as 8 "
                    },
                    {
                        "username": "stephanauwerda000",
                        "content": "Because you should calculate max diameter of EVERY node, not just the root.\\nThe node (-9) has a diameter of 8. \\nSo this is the max diameter which the function should return."
                    },
                    {
                        "username": "ande_ka_funda",
                        "content": "The solution to just find the maximum width is rather simple. \\n\\nHowever I was asked to also print the path (and not just find the diameter).\\n\\nTotally fumbled. I have been trying but I am unable to come up with an O(n) solution"
                    },
                    {
                        "username": "JustBored",
                        "content": "Can do a second dfs from the root node with the max diameter. Just memoise which child node leads to the max height for each node  which will tell you which direction to go beforehand. But you have to make sure you go in both directions in the first iteration of the 2nd dfs from the starting node. This will give you the best path in O(n).\n\nThe O(n^2) approach would be to store the maximum height path for each node and combine the child left and right path at the max diameter node to get the optimal path. You can do this in one dfs but the tc is still O(n^2)\n    "
                    },
                    {
                        "username": "dhruvpithwa1999",
                        "content": "[@uchihahardik](/uchihahardik) You can refer to my soln, https://leetcode.com/problems/diameter-of-binary-tree/submissions/869730789/\\n\\nI have tried to solve and find path using ArrayList, same approach but different return type\\n\\nmay be this can help you.."
                    },
                    {
                        "username": "uchihahardik",
                        "content": "\"The solution to just find the maximum width is rather simple.\"\\nI am not able to think of an approch any tip?"
                    },
                    {
                        "username": "keJum",
                        "content": "# Example 1\\n![image](https://assets.leetcode.com/users/images/9f86a81d-aef1-4090-a327-14071d450001_1634631307.9913106.png)\\n\\nResult 3, expected 3\\n\\n# Example 100\\n![image](https://assets.leetcode.com/users/images/e671990e-09a1-4deb-b605-5bd4c15419cb_1634631254.7966447.png)\\n\\nResult 7, expected 8.\\n\\nWhy is the result expected to be 8 and not 7?"
                    },
                    {
                        "username": "ishananchit",
                        "content": "because of the path -4, 6, 6, 9, -9, -7, -6, 9, -2"
                    },
                    {
                        "username": "howhowone",
                        "content": "-2 9 -6 -7 -9 9 6 0 -1"
                    },
                    {
                        "username": "Geetanjali_Gupta",
                        "content": "path should be from -1 to -2 then ans would be 8"
                    },
                    {
                        "username": "deeponsubhro",
                        "content": "go from -1 to -2"
                    },
                    {
                        "username": "duchemin01",
                        "content": "[@VigneshwarVG](/VigneshwarVG)  then, expected should be 9"
                    },
                    {
                        "username": "VigneshwarVG",
                        "content": "it isn\\'t a rule that edge must always pass through the root of the tree\\nit might be its left or right or left\\'s (left or right ) or the right\\'s( left or right )and so on \\nhope you get it\\n"
                    },
                    {
                        "username": "RayanYI",
                        "content": "[@mascomen4](/mascomen4)  Thanks, very helpful. Thanks to you I\\'ve solved it :)"
                    },
                    {
                        "username": "Boyka800",
                        "content": "Because you are considering the wrong path, the correct one is from -4 to -2 of lenght 8."
                    },
                    {
                        "username": "mascomen4",
                        "content": "One year later, but may be it'll save some time for the others struggling the problem.\n\nUnfortunately, the assumption that the longest path comes through the root is not right for the unbalanced tree. So, they say `This path may or may not pass through the root`. \n\n*Hint:* try to find the path of 8 edges in the right subtree. "
                    }
                ]
            },
            {
                "id": 1768427,
                "content": [
                    {
                        "username": "SouthernHumor",
                        "content": "How the hek is this problem/program marked easy ? Solutions I\\'m seeing involve 2 recursive functions and this is just not quick or straightforward"
                    },
                    {
                        "username": "gbiems",
                        "content": "This one one of the first tree problems I tried to do on leetcode, since I was looking for \"easy\" tree problems. Oof. Now that I have some more experience, I feel a lot better about how hard I found it when I was starting out. This isn\\'t an easy problem. I come back to it and re-solve it every now and then.\\n\\nI think what makes it difficult is that (in the most common solution I\\'ve seen) you need to return a value from a recursive function (the max length of left or right branch from each node) but you need to set a class variable or other way of tracking the maximum value of the left + right branches.\\n\\nThat\\'s a lot to wrap your head around when you\\'re first looking for recursive tree problems. But hey, if you stick with it, you\\'ll get this, and it\\'s a great problem for tracking variable values in recursive functions. \\n\\nBut having solved a bunch of leetcode problems, I\\'d definitely say this one is medium, not easy. If I didn\\'t know the answer, I think I\\'d still struggle to get this one. "
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "[@eduard92](/eduard92) \"laid off already\" LMFAOOOO \\uD83D\\uDE02\\uD83D\\uDC80"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its easy for those who already know.. maybe they are in uni and already solved in there and they solve it here too.\nSome of us just come here with an empty mind to push forward and is hard if you have no background. I approached this month DP and Trees for the first time in my life, it surely developed a way of thinking of data in terms of a Tree and Recursion in my mind works now as a Stack, isn't something hard to explain anymore, but I still check discuss and other websites for pseudocode.\n\nI know the comment is old, dude probably got at google and laid off already but for future people who feel stuck I think its about pushing into unkown.\n"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I agree. Unless you\\'ve seen the style of this solution somewhere before (it\\'s similar to the divide-and-conquer solution of the Maximum Subarray problem), you\\'ll probably have a tough time when coming into this problem with an empty mind."
                    },
                    {
                        "username": "chidam333",
                        "content": "here you have to just go through every node and find sum of heights of it\\'s left and right node , which is way easier than knowing the exact path... ig lol "
                    },
                    {
                        "username": "alvinato",
                        "content": "[4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]\\n\\n^ the above test case expects an answer of 8.  But I only count 7 edges between every node.  Between which two nodes are there 8 edges?"
                    },
                    {
                        "username": "suraj21209",
                        "content": "https://leetcode.com/problems/diameter-of-binary-tree/submissions/995832822/"
                    },
                    {
                        "username": "chidam333",
                        "content": "Note that the path does not need to pass through the root"
                    },
                    {
                        "username": "toho42",
                        "content": "copy and paste that to the test case to view the binary tree.  The node with a root of -9 has a maxDepth(left) of 4, and a maxDepth(right) of 4.  Thus, the diameter is 8.  This is case where the maxDiameter of a child node exceeds the maxDepth of the parent node\\'s left and right branches.\\n"
                    },
                    {
                        "username": "mascomen4",
                        "content": "see my comment below: https://leetcode.com/problems/diameter-of-binary-tree/discussion/comments/1629510"
                    },
                    {
                        "username": "OBAAT",
                        "content": "Bullshit problem description. \\nBullshit definition for \"diameter\". \\nIs it so difficult to say instead \"longest path\"? \\nProblem writers are morons. "
                    },
                    {
                        "username": "xclusive102",
                        "content": "[@ahmedtsalem9](/ahmedtsalem9) But this is not the world of circles. I agree that using \\'longest path\\' is more appropriate in the world of trees."
                    },
                    {
                        "username": "chumaumenze",
                        "content": "[@ahmedtsalem9](/ahmedtsalem9) The description is not a good one. I could not implement this because I had a problem understanding the question. When they say diameter, it implies the logic of how the diameter of a circle works - the length of the line through the center that touches two points on the edge of the circle. I was calculating the height of the tree from root to leaf."
                    },
                    {
                        "username": "ahmedtsalem9",
                        "content": "Technically, \"Diameter\" is a precise term. In the world of circles, the diameter is the longest line that can ever be drawn within a circle.\\n\\nThe same exact definition applies to trees; it\\'s the longest \"path\" that can ever be drawn within a tree through its nodes."
                    },
                    {
                        "username": "rana_afifi",
                        "content": "Rather tricky. Don\\'t think it is considered easy "
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Me too."
                    },
                    {
                        "username": "myih",
                        "content": "Scrolling down the discussions and most of the solutions are basically the same as the solution for no.124, yet this one is marked as easy and 124 is hard? Is there a easier way for this problem?"
                    },
                    {
                        "username": "suraj21209",
                        "content": "[@dragon1105](/dragon1105) https://leetcode.com/problems/diameter-of-binary-tree/submissions/995832822/"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "This one feels more like a medium to me. But 124 has a waaaay stricter time limit. My solution for 124 is getting TLEd to oblivion even with caching("
                    },
                    {
                        "username": "dragon1105",
                        "content": "Yeah I think this should be labeled as medium. This can only be easy when you\\'ve known the solution of some similar problems like Maximum Subarray (especially the divide-and-conquer one)."
                    },
                    {
                        "username": "WizTheProgrammer",
                        "content": "\"Easy\""
                    },
                    {
                        "username": "Dummyy",
                        "content": "sdcs jhfb wi wiufhw eiu uhweofuwe hfowe fowefowe fhwoe"
                    },
                    {
                        "username": "jonathanferraro75",
                        "content": "banging his head on the keyboard out of frustration"
                    },
                    {
                        "username": "rajat_171",
                        "content": "I agree"
                    },
                    {
                        "username": "techpromulgator",
                        "content": "How is the diameter of the below test case is 8?\\n\\n[4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]\\n\\nWhen I visualize, I see that it\\'s 7 and I\\'m getting 7. But, the expected answer is 8"
                    },
                    {
                        "username": "gauravkumar125",
                        "content": "i got it as 8 "
                    },
                    {
                        "username": "stephanauwerda000",
                        "content": "Because you should calculate max diameter of EVERY node, not just the root.\\nThe node (-9) has a diameter of 8. \\nSo this is the max diameter which the function should return."
                    },
                    {
                        "username": "ande_ka_funda",
                        "content": "The solution to just find the maximum width is rather simple. \\n\\nHowever I was asked to also print the path (and not just find the diameter).\\n\\nTotally fumbled. I have been trying but I am unable to come up with an O(n) solution"
                    },
                    {
                        "username": "JustBored",
                        "content": "Can do a second dfs from the root node with the max diameter. Just memoise which child node leads to the max height for each node  which will tell you which direction to go beforehand. But you have to make sure you go in both directions in the first iteration of the 2nd dfs from the starting node. This will give you the best path in O(n).\n\nThe O(n^2) approach would be to store the maximum height path for each node and combine the child left and right path at the max diameter node to get the optimal path. You can do this in one dfs but the tc is still O(n^2)\n    "
                    },
                    {
                        "username": "dhruvpithwa1999",
                        "content": "[@uchihahardik](/uchihahardik) You can refer to my soln, https://leetcode.com/problems/diameter-of-binary-tree/submissions/869730789/\\n\\nI have tried to solve and find path using ArrayList, same approach but different return type\\n\\nmay be this can help you.."
                    },
                    {
                        "username": "uchihahardik",
                        "content": "\"The solution to just find the maximum width is rather simple.\"\\nI am not able to think of an approch any tip?"
                    },
                    {
                        "username": "keJum",
                        "content": "# Example 1\\n![image](https://assets.leetcode.com/users/images/9f86a81d-aef1-4090-a327-14071d450001_1634631307.9913106.png)\\n\\nResult 3, expected 3\\n\\n# Example 100\\n![image](https://assets.leetcode.com/users/images/e671990e-09a1-4deb-b605-5bd4c15419cb_1634631254.7966447.png)\\n\\nResult 7, expected 8.\\n\\nWhy is the result expected to be 8 and not 7?"
                    },
                    {
                        "username": "ishananchit",
                        "content": "because of the path -4, 6, 6, 9, -9, -7, -6, 9, -2"
                    },
                    {
                        "username": "howhowone",
                        "content": "-2 9 -6 -7 -9 9 6 0 -1"
                    },
                    {
                        "username": "Geetanjali_Gupta",
                        "content": "path should be from -1 to -2 then ans would be 8"
                    },
                    {
                        "username": "deeponsubhro",
                        "content": "go from -1 to -2"
                    },
                    {
                        "username": "duchemin01",
                        "content": "[@VigneshwarVG](/VigneshwarVG)  then, expected should be 9"
                    },
                    {
                        "username": "VigneshwarVG",
                        "content": "it isn\\'t a rule that edge must always pass through the root of the tree\\nit might be its left or right or left\\'s (left or right ) or the right\\'s( left or right )and so on \\nhope you get it\\n"
                    },
                    {
                        "username": "RayanYI",
                        "content": "[@mascomen4](/mascomen4)  Thanks, very helpful. Thanks to you I\\'ve solved it :)"
                    },
                    {
                        "username": "Boyka800",
                        "content": "Because you are considering the wrong path, the correct one is from -4 to -2 of lenght 8."
                    },
                    {
                        "username": "mascomen4",
                        "content": "One year later, but may be it'll save some time for the others struggling the problem.\n\nUnfortunately, the assumption that the longest path comes through the root is not right for the unbalanced tree. So, they say `This path may or may not pass through the root`. \n\n*Hint:* try to find the path of 8 edges in the right subtree. "
                    }
                ]
            },
            {
                "id": 1730290,
                "content": [
                    {
                        "username": "SouthernHumor",
                        "content": "How the hek is this problem/program marked easy ? Solutions I\\'m seeing involve 2 recursive functions and this is just not quick or straightforward"
                    },
                    {
                        "username": "gbiems",
                        "content": "This one one of the first tree problems I tried to do on leetcode, since I was looking for \"easy\" tree problems. Oof. Now that I have some more experience, I feel a lot better about how hard I found it when I was starting out. This isn\\'t an easy problem. I come back to it and re-solve it every now and then.\\n\\nI think what makes it difficult is that (in the most common solution I\\'ve seen) you need to return a value from a recursive function (the max length of left or right branch from each node) but you need to set a class variable or other way of tracking the maximum value of the left + right branches.\\n\\nThat\\'s a lot to wrap your head around when you\\'re first looking for recursive tree problems. But hey, if you stick with it, you\\'ll get this, and it\\'s a great problem for tracking variable values in recursive functions. \\n\\nBut having solved a bunch of leetcode problems, I\\'d definitely say this one is medium, not easy. If I didn\\'t know the answer, I think I\\'d still struggle to get this one. "
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "[@eduard92](/eduard92) \"laid off already\" LMFAOOOO \\uD83D\\uDE02\\uD83D\\uDC80"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its easy for those who already know.. maybe they are in uni and already solved in there and they solve it here too.\nSome of us just come here with an empty mind to push forward and is hard if you have no background. I approached this month DP and Trees for the first time in my life, it surely developed a way of thinking of data in terms of a Tree and Recursion in my mind works now as a Stack, isn't something hard to explain anymore, but I still check discuss and other websites for pseudocode.\n\nI know the comment is old, dude probably got at google and laid off already but for future people who feel stuck I think its about pushing into unkown.\n"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I agree. Unless you\\'ve seen the style of this solution somewhere before (it\\'s similar to the divide-and-conquer solution of the Maximum Subarray problem), you\\'ll probably have a tough time when coming into this problem with an empty mind."
                    },
                    {
                        "username": "chidam333",
                        "content": "here you have to just go through every node and find sum of heights of it\\'s left and right node , which is way easier than knowing the exact path... ig lol "
                    },
                    {
                        "username": "alvinato",
                        "content": "[4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]\\n\\n^ the above test case expects an answer of 8.  But I only count 7 edges between every node.  Between which two nodes are there 8 edges?"
                    },
                    {
                        "username": "suraj21209",
                        "content": "https://leetcode.com/problems/diameter-of-binary-tree/submissions/995832822/"
                    },
                    {
                        "username": "chidam333",
                        "content": "Note that the path does not need to pass through the root"
                    },
                    {
                        "username": "toho42",
                        "content": "copy and paste that to the test case to view the binary tree.  The node with a root of -9 has a maxDepth(left) of 4, and a maxDepth(right) of 4.  Thus, the diameter is 8.  This is case where the maxDiameter of a child node exceeds the maxDepth of the parent node\\'s left and right branches.\\n"
                    },
                    {
                        "username": "mascomen4",
                        "content": "see my comment below: https://leetcode.com/problems/diameter-of-binary-tree/discussion/comments/1629510"
                    },
                    {
                        "username": "OBAAT",
                        "content": "Bullshit problem description. \\nBullshit definition for \"diameter\". \\nIs it so difficult to say instead \"longest path\"? \\nProblem writers are morons. "
                    },
                    {
                        "username": "xclusive102",
                        "content": "[@ahmedtsalem9](/ahmedtsalem9) But this is not the world of circles. I agree that using \\'longest path\\' is more appropriate in the world of trees."
                    },
                    {
                        "username": "chumaumenze",
                        "content": "[@ahmedtsalem9](/ahmedtsalem9) The description is not a good one. I could not implement this because I had a problem understanding the question. When they say diameter, it implies the logic of how the diameter of a circle works - the length of the line through the center that touches two points on the edge of the circle. I was calculating the height of the tree from root to leaf."
                    },
                    {
                        "username": "ahmedtsalem9",
                        "content": "Technically, \"Diameter\" is a precise term. In the world of circles, the diameter is the longest line that can ever be drawn within a circle.\\n\\nThe same exact definition applies to trees; it\\'s the longest \"path\" that can ever be drawn within a tree through its nodes."
                    },
                    {
                        "username": "rana_afifi",
                        "content": "Rather tricky. Don\\'t think it is considered easy "
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Me too."
                    },
                    {
                        "username": "myih",
                        "content": "Scrolling down the discussions and most of the solutions are basically the same as the solution for no.124, yet this one is marked as easy and 124 is hard? Is there a easier way for this problem?"
                    },
                    {
                        "username": "suraj21209",
                        "content": "[@dragon1105](/dragon1105) https://leetcode.com/problems/diameter-of-binary-tree/submissions/995832822/"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "This one feels more like a medium to me. But 124 has a waaaay stricter time limit. My solution for 124 is getting TLEd to oblivion even with caching("
                    },
                    {
                        "username": "dragon1105",
                        "content": "Yeah I think this should be labeled as medium. This can only be easy when you\\'ve known the solution of some similar problems like Maximum Subarray (especially the divide-and-conquer one)."
                    },
                    {
                        "username": "WizTheProgrammer",
                        "content": "\"Easy\""
                    },
                    {
                        "username": "Dummyy",
                        "content": "sdcs jhfb wi wiufhw eiu uhweofuwe hfowe fowefowe fhwoe"
                    },
                    {
                        "username": "jonathanferraro75",
                        "content": "banging his head on the keyboard out of frustration"
                    },
                    {
                        "username": "rajat_171",
                        "content": "I agree"
                    },
                    {
                        "username": "techpromulgator",
                        "content": "How is the diameter of the below test case is 8?\\n\\n[4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]\\n\\nWhen I visualize, I see that it\\'s 7 and I\\'m getting 7. But, the expected answer is 8"
                    },
                    {
                        "username": "gauravkumar125",
                        "content": "i got it as 8 "
                    },
                    {
                        "username": "stephanauwerda000",
                        "content": "Because you should calculate max diameter of EVERY node, not just the root.\\nThe node (-9) has a diameter of 8. \\nSo this is the max diameter which the function should return."
                    },
                    {
                        "username": "ande_ka_funda",
                        "content": "The solution to just find the maximum width is rather simple. \\n\\nHowever I was asked to also print the path (and not just find the diameter).\\n\\nTotally fumbled. I have been trying but I am unable to come up with an O(n) solution"
                    },
                    {
                        "username": "JustBored",
                        "content": "Can do a second dfs from the root node with the max diameter. Just memoise which child node leads to the max height for each node  which will tell you which direction to go beforehand. But you have to make sure you go in both directions in the first iteration of the 2nd dfs from the starting node. This will give you the best path in O(n).\n\nThe O(n^2) approach would be to store the maximum height path for each node and combine the child left and right path at the max diameter node to get the optimal path. You can do this in one dfs but the tc is still O(n^2)\n    "
                    },
                    {
                        "username": "dhruvpithwa1999",
                        "content": "[@uchihahardik](/uchihahardik) You can refer to my soln, https://leetcode.com/problems/diameter-of-binary-tree/submissions/869730789/\\n\\nI have tried to solve and find path using ArrayList, same approach but different return type\\n\\nmay be this can help you.."
                    },
                    {
                        "username": "uchihahardik",
                        "content": "\"The solution to just find the maximum width is rather simple.\"\\nI am not able to think of an approch any tip?"
                    },
                    {
                        "username": "keJum",
                        "content": "# Example 1\\n![image](https://assets.leetcode.com/users/images/9f86a81d-aef1-4090-a327-14071d450001_1634631307.9913106.png)\\n\\nResult 3, expected 3\\n\\n# Example 100\\n![image](https://assets.leetcode.com/users/images/e671990e-09a1-4deb-b605-5bd4c15419cb_1634631254.7966447.png)\\n\\nResult 7, expected 8.\\n\\nWhy is the result expected to be 8 and not 7?"
                    },
                    {
                        "username": "ishananchit",
                        "content": "because of the path -4, 6, 6, 9, -9, -7, -6, 9, -2"
                    },
                    {
                        "username": "howhowone",
                        "content": "-2 9 -6 -7 -9 9 6 0 -1"
                    },
                    {
                        "username": "Geetanjali_Gupta",
                        "content": "path should be from -1 to -2 then ans would be 8"
                    },
                    {
                        "username": "deeponsubhro",
                        "content": "go from -1 to -2"
                    },
                    {
                        "username": "duchemin01",
                        "content": "[@VigneshwarVG](/VigneshwarVG)  then, expected should be 9"
                    },
                    {
                        "username": "VigneshwarVG",
                        "content": "it isn\\'t a rule that edge must always pass through the root of the tree\\nit might be its left or right or left\\'s (left or right ) or the right\\'s( left or right )and so on \\nhope you get it\\n"
                    },
                    {
                        "username": "RayanYI",
                        "content": "[@mascomen4](/mascomen4)  Thanks, very helpful. Thanks to you I\\'ve solved it :)"
                    },
                    {
                        "username": "Boyka800",
                        "content": "Because you are considering the wrong path, the correct one is from -4 to -2 of lenght 8."
                    },
                    {
                        "username": "mascomen4",
                        "content": "One year later, but may be it'll save some time for the others struggling the problem.\n\nUnfortunately, the assumption that the longest path comes through the root is not right for the unbalanced tree. So, they say `This path may or may not pass through the root`. \n\n*Hint:* try to find the path of 8 edges in the right subtree. "
                    }
                ]
            },
            {
                "id": 1568066,
                "content": [
                    {
                        "username": "SouthernHumor",
                        "content": "How the hek is this problem/program marked easy ? Solutions I\\'m seeing involve 2 recursive functions and this is just not quick or straightforward"
                    },
                    {
                        "username": "gbiems",
                        "content": "This one one of the first tree problems I tried to do on leetcode, since I was looking for \"easy\" tree problems. Oof. Now that I have some more experience, I feel a lot better about how hard I found it when I was starting out. This isn\\'t an easy problem. I come back to it and re-solve it every now and then.\\n\\nI think what makes it difficult is that (in the most common solution I\\'ve seen) you need to return a value from a recursive function (the max length of left or right branch from each node) but you need to set a class variable or other way of tracking the maximum value of the left + right branches.\\n\\nThat\\'s a lot to wrap your head around when you\\'re first looking for recursive tree problems. But hey, if you stick with it, you\\'ll get this, and it\\'s a great problem for tracking variable values in recursive functions. \\n\\nBut having solved a bunch of leetcode problems, I\\'d definitely say this one is medium, not easy. If I didn\\'t know the answer, I think I\\'d still struggle to get this one. "
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "[@eduard92](/eduard92) \"laid off already\" LMFAOOOO \\uD83D\\uDE02\\uD83D\\uDC80"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its easy for those who already know.. maybe they are in uni and already solved in there and they solve it here too.\nSome of us just come here with an empty mind to push forward and is hard if you have no background. I approached this month DP and Trees for the first time in my life, it surely developed a way of thinking of data in terms of a Tree and Recursion in my mind works now as a Stack, isn't something hard to explain anymore, but I still check discuss and other websites for pseudocode.\n\nI know the comment is old, dude probably got at google and laid off already but for future people who feel stuck I think its about pushing into unkown.\n"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I agree. Unless you\\'ve seen the style of this solution somewhere before (it\\'s similar to the divide-and-conquer solution of the Maximum Subarray problem), you\\'ll probably have a tough time when coming into this problem with an empty mind."
                    },
                    {
                        "username": "chidam333",
                        "content": "here you have to just go through every node and find sum of heights of it\\'s left and right node , which is way easier than knowing the exact path... ig lol "
                    },
                    {
                        "username": "alvinato",
                        "content": "[4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]\\n\\n^ the above test case expects an answer of 8.  But I only count 7 edges between every node.  Between which two nodes are there 8 edges?"
                    },
                    {
                        "username": "suraj21209",
                        "content": "https://leetcode.com/problems/diameter-of-binary-tree/submissions/995832822/"
                    },
                    {
                        "username": "chidam333",
                        "content": "Note that the path does not need to pass through the root"
                    },
                    {
                        "username": "toho42",
                        "content": "copy and paste that to the test case to view the binary tree.  The node with a root of -9 has a maxDepth(left) of 4, and a maxDepth(right) of 4.  Thus, the diameter is 8.  This is case where the maxDiameter of a child node exceeds the maxDepth of the parent node\\'s left and right branches.\\n"
                    },
                    {
                        "username": "mascomen4",
                        "content": "see my comment below: https://leetcode.com/problems/diameter-of-binary-tree/discussion/comments/1629510"
                    },
                    {
                        "username": "OBAAT",
                        "content": "Bullshit problem description. \\nBullshit definition for \"diameter\". \\nIs it so difficult to say instead \"longest path\"? \\nProblem writers are morons. "
                    },
                    {
                        "username": "xclusive102",
                        "content": "[@ahmedtsalem9](/ahmedtsalem9) But this is not the world of circles. I agree that using \\'longest path\\' is more appropriate in the world of trees."
                    },
                    {
                        "username": "chumaumenze",
                        "content": "[@ahmedtsalem9](/ahmedtsalem9) The description is not a good one. I could not implement this because I had a problem understanding the question. When they say diameter, it implies the logic of how the diameter of a circle works - the length of the line through the center that touches two points on the edge of the circle. I was calculating the height of the tree from root to leaf."
                    },
                    {
                        "username": "ahmedtsalem9",
                        "content": "Technically, \"Diameter\" is a precise term. In the world of circles, the diameter is the longest line that can ever be drawn within a circle.\\n\\nThe same exact definition applies to trees; it\\'s the longest \"path\" that can ever be drawn within a tree through its nodes."
                    },
                    {
                        "username": "rana_afifi",
                        "content": "Rather tricky. Don\\'t think it is considered easy "
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Me too."
                    },
                    {
                        "username": "myih",
                        "content": "Scrolling down the discussions and most of the solutions are basically the same as the solution for no.124, yet this one is marked as easy and 124 is hard? Is there a easier way for this problem?"
                    },
                    {
                        "username": "suraj21209",
                        "content": "[@dragon1105](/dragon1105) https://leetcode.com/problems/diameter-of-binary-tree/submissions/995832822/"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "This one feels more like a medium to me. But 124 has a waaaay stricter time limit. My solution for 124 is getting TLEd to oblivion even with caching("
                    },
                    {
                        "username": "dragon1105",
                        "content": "Yeah I think this should be labeled as medium. This can only be easy when you\\'ve known the solution of some similar problems like Maximum Subarray (especially the divide-and-conquer one)."
                    },
                    {
                        "username": "WizTheProgrammer",
                        "content": "\"Easy\""
                    },
                    {
                        "username": "Dummyy",
                        "content": "sdcs jhfb wi wiufhw eiu uhweofuwe hfowe fowefowe fhwoe"
                    },
                    {
                        "username": "jonathanferraro75",
                        "content": "banging his head on the keyboard out of frustration"
                    },
                    {
                        "username": "rajat_171",
                        "content": "I agree"
                    },
                    {
                        "username": "techpromulgator",
                        "content": "How is the diameter of the below test case is 8?\\n\\n[4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]\\n\\nWhen I visualize, I see that it\\'s 7 and I\\'m getting 7. But, the expected answer is 8"
                    },
                    {
                        "username": "gauravkumar125",
                        "content": "i got it as 8 "
                    },
                    {
                        "username": "stephanauwerda000",
                        "content": "Because you should calculate max diameter of EVERY node, not just the root.\\nThe node (-9) has a diameter of 8. \\nSo this is the max diameter which the function should return."
                    },
                    {
                        "username": "ande_ka_funda",
                        "content": "The solution to just find the maximum width is rather simple. \\n\\nHowever I was asked to also print the path (and not just find the diameter).\\n\\nTotally fumbled. I have been trying but I am unable to come up with an O(n) solution"
                    },
                    {
                        "username": "JustBored",
                        "content": "Can do a second dfs from the root node with the max diameter. Just memoise which child node leads to the max height for each node  which will tell you which direction to go beforehand. But you have to make sure you go in both directions in the first iteration of the 2nd dfs from the starting node. This will give you the best path in O(n).\n\nThe O(n^2) approach would be to store the maximum height path for each node and combine the child left and right path at the max diameter node to get the optimal path. You can do this in one dfs but the tc is still O(n^2)\n    "
                    },
                    {
                        "username": "dhruvpithwa1999",
                        "content": "[@uchihahardik](/uchihahardik) You can refer to my soln, https://leetcode.com/problems/diameter-of-binary-tree/submissions/869730789/\\n\\nI have tried to solve and find path using ArrayList, same approach but different return type\\n\\nmay be this can help you.."
                    },
                    {
                        "username": "uchihahardik",
                        "content": "\"The solution to just find the maximum width is rather simple.\"\\nI am not able to think of an approch any tip?"
                    },
                    {
                        "username": "keJum",
                        "content": "# Example 1\\n![image](https://assets.leetcode.com/users/images/9f86a81d-aef1-4090-a327-14071d450001_1634631307.9913106.png)\\n\\nResult 3, expected 3\\n\\n# Example 100\\n![image](https://assets.leetcode.com/users/images/e671990e-09a1-4deb-b605-5bd4c15419cb_1634631254.7966447.png)\\n\\nResult 7, expected 8.\\n\\nWhy is the result expected to be 8 and not 7?"
                    },
                    {
                        "username": "ishananchit",
                        "content": "because of the path -4, 6, 6, 9, -9, -7, -6, 9, -2"
                    },
                    {
                        "username": "howhowone",
                        "content": "-2 9 -6 -7 -9 9 6 0 -1"
                    },
                    {
                        "username": "Geetanjali_Gupta",
                        "content": "path should be from -1 to -2 then ans would be 8"
                    },
                    {
                        "username": "deeponsubhro",
                        "content": "go from -1 to -2"
                    },
                    {
                        "username": "duchemin01",
                        "content": "[@VigneshwarVG](/VigneshwarVG)  then, expected should be 9"
                    },
                    {
                        "username": "VigneshwarVG",
                        "content": "it isn\\'t a rule that edge must always pass through the root of the tree\\nit might be its left or right or left\\'s (left or right ) or the right\\'s( left or right )and so on \\nhope you get it\\n"
                    },
                    {
                        "username": "RayanYI",
                        "content": "[@mascomen4](/mascomen4)  Thanks, very helpful. Thanks to you I\\'ve solved it :)"
                    },
                    {
                        "username": "Boyka800",
                        "content": "Because you are considering the wrong path, the correct one is from -4 to -2 of lenght 8."
                    },
                    {
                        "username": "mascomen4",
                        "content": "One year later, but may be it'll save some time for the others struggling the problem.\n\nUnfortunately, the assumption that the longest path comes through the root is not right for the unbalanced tree. So, they say `This path may or may not pass through the root`. \n\n*Hint:* try to find the path of 8 edges in the right subtree. "
                    }
                ]
            },
            {
                "id": 1752105,
                "content": [
                    {
                        "username": "SouthernHumor",
                        "content": "How the hek is this problem/program marked easy ? Solutions I\\'m seeing involve 2 recursive functions and this is just not quick or straightforward"
                    },
                    {
                        "username": "gbiems",
                        "content": "This one one of the first tree problems I tried to do on leetcode, since I was looking for \"easy\" tree problems. Oof. Now that I have some more experience, I feel a lot better about how hard I found it when I was starting out. This isn\\'t an easy problem. I come back to it and re-solve it every now and then.\\n\\nI think what makes it difficult is that (in the most common solution I\\'ve seen) you need to return a value from a recursive function (the max length of left or right branch from each node) but you need to set a class variable or other way of tracking the maximum value of the left + right branches.\\n\\nThat\\'s a lot to wrap your head around when you\\'re first looking for recursive tree problems. But hey, if you stick with it, you\\'ll get this, and it\\'s a great problem for tracking variable values in recursive functions. \\n\\nBut having solved a bunch of leetcode problems, I\\'d definitely say this one is medium, not easy. If I didn\\'t know the answer, I think I\\'d still struggle to get this one. "
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "[@eduard92](/eduard92) \"laid off already\" LMFAOOOO \\uD83D\\uDE02\\uD83D\\uDC80"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its easy for those who already know.. maybe they are in uni and already solved in there and they solve it here too.\nSome of us just come here with an empty mind to push forward and is hard if you have no background. I approached this month DP and Trees for the first time in my life, it surely developed a way of thinking of data in terms of a Tree and Recursion in my mind works now as a Stack, isn't something hard to explain anymore, but I still check discuss and other websites for pseudocode.\n\nI know the comment is old, dude probably got at google and laid off already but for future people who feel stuck I think its about pushing into unkown.\n"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I agree. Unless you\\'ve seen the style of this solution somewhere before (it\\'s similar to the divide-and-conquer solution of the Maximum Subarray problem), you\\'ll probably have a tough time when coming into this problem with an empty mind."
                    },
                    {
                        "username": "chidam333",
                        "content": "here you have to just go through every node and find sum of heights of it\\'s left and right node , which is way easier than knowing the exact path... ig lol "
                    },
                    {
                        "username": "alvinato",
                        "content": "[4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]\\n\\n^ the above test case expects an answer of 8.  But I only count 7 edges between every node.  Between which two nodes are there 8 edges?"
                    },
                    {
                        "username": "suraj21209",
                        "content": "https://leetcode.com/problems/diameter-of-binary-tree/submissions/995832822/"
                    },
                    {
                        "username": "chidam333",
                        "content": "Note that the path does not need to pass through the root"
                    },
                    {
                        "username": "toho42",
                        "content": "copy and paste that to the test case to view the binary tree.  The node with a root of -9 has a maxDepth(left) of 4, and a maxDepth(right) of 4.  Thus, the diameter is 8.  This is case where the maxDiameter of a child node exceeds the maxDepth of the parent node\\'s left and right branches.\\n"
                    },
                    {
                        "username": "mascomen4",
                        "content": "see my comment below: https://leetcode.com/problems/diameter-of-binary-tree/discussion/comments/1629510"
                    },
                    {
                        "username": "OBAAT",
                        "content": "Bullshit problem description. \\nBullshit definition for \"diameter\". \\nIs it so difficult to say instead \"longest path\"? \\nProblem writers are morons. "
                    },
                    {
                        "username": "xclusive102",
                        "content": "[@ahmedtsalem9](/ahmedtsalem9) But this is not the world of circles. I agree that using \\'longest path\\' is more appropriate in the world of trees."
                    },
                    {
                        "username": "chumaumenze",
                        "content": "[@ahmedtsalem9](/ahmedtsalem9) The description is not a good one. I could not implement this because I had a problem understanding the question. When they say diameter, it implies the logic of how the diameter of a circle works - the length of the line through the center that touches two points on the edge of the circle. I was calculating the height of the tree from root to leaf."
                    },
                    {
                        "username": "ahmedtsalem9",
                        "content": "Technically, \"Diameter\" is a precise term. In the world of circles, the diameter is the longest line that can ever be drawn within a circle.\\n\\nThe same exact definition applies to trees; it\\'s the longest \"path\" that can ever be drawn within a tree through its nodes."
                    },
                    {
                        "username": "rana_afifi",
                        "content": "Rather tricky. Don\\'t think it is considered easy "
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Me too."
                    },
                    {
                        "username": "myih",
                        "content": "Scrolling down the discussions and most of the solutions are basically the same as the solution for no.124, yet this one is marked as easy and 124 is hard? Is there a easier way for this problem?"
                    },
                    {
                        "username": "suraj21209",
                        "content": "[@dragon1105](/dragon1105) https://leetcode.com/problems/diameter-of-binary-tree/submissions/995832822/"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "This one feels more like a medium to me. But 124 has a waaaay stricter time limit. My solution for 124 is getting TLEd to oblivion even with caching("
                    },
                    {
                        "username": "dragon1105",
                        "content": "Yeah I think this should be labeled as medium. This can only be easy when you\\'ve known the solution of some similar problems like Maximum Subarray (especially the divide-and-conquer one)."
                    },
                    {
                        "username": "WizTheProgrammer",
                        "content": "\"Easy\""
                    },
                    {
                        "username": "Dummyy",
                        "content": "sdcs jhfb wi wiufhw eiu uhweofuwe hfowe fowefowe fhwoe"
                    },
                    {
                        "username": "jonathanferraro75",
                        "content": "banging his head on the keyboard out of frustration"
                    },
                    {
                        "username": "rajat_171",
                        "content": "I agree"
                    },
                    {
                        "username": "techpromulgator",
                        "content": "How is the diameter of the below test case is 8?\\n\\n[4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]\\n\\nWhen I visualize, I see that it\\'s 7 and I\\'m getting 7. But, the expected answer is 8"
                    },
                    {
                        "username": "gauravkumar125",
                        "content": "i got it as 8 "
                    },
                    {
                        "username": "stephanauwerda000",
                        "content": "Because you should calculate max diameter of EVERY node, not just the root.\\nThe node (-9) has a diameter of 8. \\nSo this is the max diameter which the function should return."
                    },
                    {
                        "username": "ande_ka_funda",
                        "content": "The solution to just find the maximum width is rather simple. \\n\\nHowever I was asked to also print the path (and not just find the diameter).\\n\\nTotally fumbled. I have been trying but I am unable to come up with an O(n) solution"
                    },
                    {
                        "username": "JustBored",
                        "content": "Can do a second dfs from the root node with the max diameter. Just memoise which child node leads to the max height for each node  which will tell you which direction to go beforehand. But you have to make sure you go in both directions in the first iteration of the 2nd dfs from the starting node. This will give you the best path in O(n).\n\nThe O(n^2) approach would be to store the maximum height path for each node and combine the child left and right path at the max diameter node to get the optimal path. You can do this in one dfs but the tc is still O(n^2)\n    "
                    },
                    {
                        "username": "dhruvpithwa1999",
                        "content": "[@uchihahardik](/uchihahardik) You can refer to my soln, https://leetcode.com/problems/diameter-of-binary-tree/submissions/869730789/\\n\\nI have tried to solve and find path using ArrayList, same approach but different return type\\n\\nmay be this can help you.."
                    },
                    {
                        "username": "uchihahardik",
                        "content": "\"The solution to just find the maximum width is rather simple.\"\\nI am not able to think of an approch any tip?"
                    },
                    {
                        "username": "keJum",
                        "content": "# Example 1\\n![image](https://assets.leetcode.com/users/images/9f86a81d-aef1-4090-a327-14071d450001_1634631307.9913106.png)\\n\\nResult 3, expected 3\\n\\n# Example 100\\n![image](https://assets.leetcode.com/users/images/e671990e-09a1-4deb-b605-5bd4c15419cb_1634631254.7966447.png)\\n\\nResult 7, expected 8.\\n\\nWhy is the result expected to be 8 and not 7?"
                    },
                    {
                        "username": "ishananchit",
                        "content": "because of the path -4, 6, 6, 9, -9, -7, -6, 9, -2"
                    },
                    {
                        "username": "howhowone",
                        "content": "-2 9 -6 -7 -9 9 6 0 -1"
                    },
                    {
                        "username": "Geetanjali_Gupta",
                        "content": "path should be from -1 to -2 then ans would be 8"
                    },
                    {
                        "username": "deeponsubhro",
                        "content": "go from -1 to -2"
                    },
                    {
                        "username": "duchemin01",
                        "content": "[@VigneshwarVG](/VigneshwarVG)  then, expected should be 9"
                    },
                    {
                        "username": "VigneshwarVG",
                        "content": "it isn\\'t a rule that edge must always pass through the root of the tree\\nit might be its left or right or left\\'s (left or right ) or the right\\'s( left or right )and so on \\nhope you get it\\n"
                    },
                    {
                        "username": "RayanYI",
                        "content": "[@mascomen4](/mascomen4)  Thanks, very helpful. Thanks to you I\\'ve solved it :)"
                    },
                    {
                        "username": "Boyka800",
                        "content": "Because you are considering the wrong path, the correct one is from -4 to -2 of lenght 8."
                    },
                    {
                        "username": "mascomen4",
                        "content": "One year later, but may be it'll save some time for the others struggling the problem.\n\nUnfortunately, the assumption that the longest path comes through the root is not right for the unbalanced tree. So, they say `This path may or may not pass through the root`. \n\n*Hint:* try to find the path of 8 edges in the right subtree. "
                    }
                ]
            },
            {
                "id": 1575844,
                "content": [
                    {
                        "username": "SouthernHumor",
                        "content": "How the hek is this problem/program marked easy ? Solutions I\\'m seeing involve 2 recursive functions and this is just not quick or straightforward"
                    },
                    {
                        "username": "gbiems",
                        "content": "This one one of the first tree problems I tried to do on leetcode, since I was looking for \"easy\" tree problems. Oof. Now that I have some more experience, I feel a lot better about how hard I found it when I was starting out. This isn\\'t an easy problem. I come back to it and re-solve it every now and then.\\n\\nI think what makes it difficult is that (in the most common solution I\\'ve seen) you need to return a value from a recursive function (the max length of left or right branch from each node) but you need to set a class variable or other way of tracking the maximum value of the left + right branches.\\n\\nThat\\'s a lot to wrap your head around when you\\'re first looking for recursive tree problems. But hey, if you stick with it, you\\'ll get this, and it\\'s a great problem for tracking variable values in recursive functions. \\n\\nBut having solved a bunch of leetcode problems, I\\'d definitely say this one is medium, not easy. If I didn\\'t know the answer, I think I\\'d still struggle to get this one. "
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "[@eduard92](/eduard92) \"laid off already\" LMFAOOOO \\uD83D\\uDE02\\uD83D\\uDC80"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its easy for those who already know.. maybe they are in uni and already solved in there and they solve it here too.\nSome of us just come here with an empty mind to push forward and is hard if you have no background. I approached this month DP and Trees for the first time in my life, it surely developed a way of thinking of data in terms of a Tree and Recursion in my mind works now as a Stack, isn't something hard to explain anymore, but I still check discuss and other websites for pseudocode.\n\nI know the comment is old, dude probably got at google and laid off already but for future people who feel stuck I think its about pushing into unkown.\n"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I agree. Unless you\\'ve seen the style of this solution somewhere before (it\\'s similar to the divide-and-conquer solution of the Maximum Subarray problem), you\\'ll probably have a tough time when coming into this problem with an empty mind."
                    },
                    {
                        "username": "chidam333",
                        "content": "here you have to just go through every node and find sum of heights of it\\'s left and right node , which is way easier than knowing the exact path... ig lol "
                    },
                    {
                        "username": "alvinato",
                        "content": "[4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]\\n\\n^ the above test case expects an answer of 8.  But I only count 7 edges between every node.  Between which two nodes are there 8 edges?"
                    },
                    {
                        "username": "suraj21209",
                        "content": "https://leetcode.com/problems/diameter-of-binary-tree/submissions/995832822/"
                    },
                    {
                        "username": "chidam333",
                        "content": "Note that the path does not need to pass through the root"
                    },
                    {
                        "username": "toho42",
                        "content": "copy and paste that to the test case to view the binary tree.  The node with a root of -9 has a maxDepth(left) of 4, and a maxDepth(right) of 4.  Thus, the diameter is 8.  This is case where the maxDiameter of a child node exceeds the maxDepth of the parent node\\'s left and right branches.\\n"
                    },
                    {
                        "username": "mascomen4",
                        "content": "see my comment below: https://leetcode.com/problems/diameter-of-binary-tree/discussion/comments/1629510"
                    },
                    {
                        "username": "OBAAT",
                        "content": "Bullshit problem description. \\nBullshit definition for \"diameter\". \\nIs it so difficult to say instead \"longest path\"? \\nProblem writers are morons. "
                    },
                    {
                        "username": "xclusive102",
                        "content": "[@ahmedtsalem9](/ahmedtsalem9) But this is not the world of circles. I agree that using \\'longest path\\' is more appropriate in the world of trees."
                    },
                    {
                        "username": "chumaumenze",
                        "content": "[@ahmedtsalem9](/ahmedtsalem9) The description is not a good one. I could not implement this because I had a problem understanding the question. When they say diameter, it implies the logic of how the diameter of a circle works - the length of the line through the center that touches two points on the edge of the circle. I was calculating the height of the tree from root to leaf."
                    },
                    {
                        "username": "ahmedtsalem9",
                        "content": "Technically, \"Diameter\" is a precise term. In the world of circles, the diameter is the longest line that can ever be drawn within a circle.\\n\\nThe same exact definition applies to trees; it\\'s the longest \"path\" that can ever be drawn within a tree through its nodes."
                    },
                    {
                        "username": "rana_afifi",
                        "content": "Rather tricky. Don\\'t think it is considered easy "
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Me too."
                    },
                    {
                        "username": "myih",
                        "content": "Scrolling down the discussions and most of the solutions are basically the same as the solution for no.124, yet this one is marked as easy and 124 is hard? Is there a easier way for this problem?"
                    },
                    {
                        "username": "suraj21209",
                        "content": "[@dragon1105](/dragon1105) https://leetcode.com/problems/diameter-of-binary-tree/submissions/995832822/"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "This one feels more like a medium to me. But 124 has a waaaay stricter time limit. My solution for 124 is getting TLEd to oblivion even with caching("
                    },
                    {
                        "username": "dragon1105",
                        "content": "Yeah I think this should be labeled as medium. This can only be easy when you\\'ve known the solution of some similar problems like Maximum Subarray (especially the divide-and-conquer one)."
                    },
                    {
                        "username": "WizTheProgrammer",
                        "content": "\"Easy\""
                    },
                    {
                        "username": "Dummyy",
                        "content": "sdcs jhfb wi wiufhw eiu uhweofuwe hfowe fowefowe fhwoe"
                    },
                    {
                        "username": "jonathanferraro75",
                        "content": "banging his head on the keyboard out of frustration"
                    },
                    {
                        "username": "rajat_171",
                        "content": "I agree"
                    },
                    {
                        "username": "techpromulgator",
                        "content": "How is the diameter of the below test case is 8?\\n\\n[4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]\\n\\nWhen I visualize, I see that it\\'s 7 and I\\'m getting 7. But, the expected answer is 8"
                    },
                    {
                        "username": "gauravkumar125",
                        "content": "i got it as 8 "
                    },
                    {
                        "username": "stephanauwerda000",
                        "content": "Because you should calculate max diameter of EVERY node, not just the root.\\nThe node (-9) has a diameter of 8. \\nSo this is the max diameter which the function should return."
                    },
                    {
                        "username": "ande_ka_funda",
                        "content": "The solution to just find the maximum width is rather simple. \\n\\nHowever I was asked to also print the path (and not just find the diameter).\\n\\nTotally fumbled. I have been trying but I am unable to come up with an O(n) solution"
                    },
                    {
                        "username": "JustBored",
                        "content": "Can do a second dfs from the root node with the max diameter. Just memoise which child node leads to the max height for each node  which will tell you which direction to go beforehand. But you have to make sure you go in both directions in the first iteration of the 2nd dfs from the starting node. This will give you the best path in O(n).\n\nThe O(n^2) approach would be to store the maximum height path for each node and combine the child left and right path at the max diameter node to get the optimal path. You can do this in one dfs but the tc is still O(n^2)\n    "
                    },
                    {
                        "username": "dhruvpithwa1999",
                        "content": "[@uchihahardik](/uchihahardik) You can refer to my soln, https://leetcode.com/problems/diameter-of-binary-tree/submissions/869730789/\\n\\nI have tried to solve and find path using ArrayList, same approach but different return type\\n\\nmay be this can help you.."
                    },
                    {
                        "username": "uchihahardik",
                        "content": "\"The solution to just find the maximum width is rather simple.\"\\nI am not able to think of an approch any tip?"
                    },
                    {
                        "username": "keJum",
                        "content": "# Example 1\\n![image](https://assets.leetcode.com/users/images/9f86a81d-aef1-4090-a327-14071d450001_1634631307.9913106.png)\\n\\nResult 3, expected 3\\n\\n# Example 100\\n![image](https://assets.leetcode.com/users/images/e671990e-09a1-4deb-b605-5bd4c15419cb_1634631254.7966447.png)\\n\\nResult 7, expected 8.\\n\\nWhy is the result expected to be 8 and not 7?"
                    },
                    {
                        "username": "ishananchit",
                        "content": "because of the path -4, 6, 6, 9, -9, -7, -6, 9, -2"
                    },
                    {
                        "username": "howhowone",
                        "content": "-2 9 -6 -7 -9 9 6 0 -1"
                    },
                    {
                        "username": "Geetanjali_Gupta",
                        "content": "path should be from -1 to -2 then ans would be 8"
                    },
                    {
                        "username": "deeponsubhro",
                        "content": "go from -1 to -2"
                    },
                    {
                        "username": "duchemin01",
                        "content": "[@VigneshwarVG](/VigneshwarVG)  then, expected should be 9"
                    },
                    {
                        "username": "VigneshwarVG",
                        "content": "it isn\\'t a rule that edge must always pass through the root of the tree\\nit might be its left or right or left\\'s (left or right ) or the right\\'s( left or right )and so on \\nhope you get it\\n"
                    },
                    {
                        "username": "RayanYI",
                        "content": "[@mascomen4](/mascomen4)  Thanks, very helpful. Thanks to you I\\'ve solved it :)"
                    },
                    {
                        "username": "Boyka800",
                        "content": "Because you are considering the wrong path, the correct one is from -4 to -2 of lenght 8."
                    },
                    {
                        "username": "mascomen4",
                        "content": "One year later, but may be it'll save some time for the others struggling the problem.\n\nUnfortunately, the assumption that the longest path comes through the root is not right for the unbalanced tree. So, they say `This path may or may not pass through the root`. \n\n*Hint:* try to find the path of 8 edges in the right subtree. "
                    }
                ]
            },
            {
                "id": 1569834,
                "content": [
                    {
                        "username": "SouthernHumor",
                        "content": "How the hek is this problem/program marked easy ? Solutions I\\'m seeing involve 2 recursive functions and this is just not quick or straightforward"
                    },
                    {
                        "username": "gbiems",
                        "content": "This one one of the first tree problems I tried to do on leetcode, since I was looking for \"easy\" tree problems. Oof. Now that I have some more experience, I feel a lot better about how hard I found it when I was starting out. This isn\\'t an easy problem. I come back to it and re-solve it every now and then.\\n\\nI think what makes it difficult is that (in the most common solution I\\'ve seen) you need to return a value from a recursive function (the max length of left or right branch from each node) but you need to set a class variable or other way of tracking the maximum value of the left + right branches.\\n\\nThat\\'s a lot to wrap your head around when you\\'re first looking for recursive tree problems. But hey, if you stick with it, you\\'ll get this, and it\\'s a great problem for tracking variable values in recursive functions. \\n\\nBut having solved a bunch of leetcode problems, I\\'d definitely say this one is medium, not easy. If I didn\\'t know the answer, I think I\\'d still struggle to get this one. "
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "[@eduard92](/eduard92) \"laid off already\" LMFAOOOO \\uD83D\\uDE02\\uD83D\\uDC80"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its easy for those who already know.. maybe they are in uni and already solved in there and they solve it here too.\nSome of us just come here with an empty mind to push forward and is hard if you have no background. I approached this month DP and Trees for the first time in my life, it surely developed a way of thinking of data in terms of a Tree and Recursion in my mind works now as a Stack, isn't something hard to explain anymore, but I still check discuss and other websites for pseudocode.\n\nI know the comment is old, dude probably got at google and laid off already but for future people who feel stuck I think its about pushing into unkown.\n"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I agree. Unless you\\'ve seen the style of this solution somewhere before (it\\'s similar to the divide-and-conquer solution of the Maximum Subarray problem), you\\'ll probably have a tough time when coming into this problem with an empty mind."
                    },
                    {
                        "username": "chidam333",
                        "content": "here you have to just go through every node and find sum of heights of it\\'s left and right node , which is way easier than knowing the exact path... ig lol "
                    },
                    {
                        "username": "alvinato",
                        "content": "[4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]\\n\\n^ the above test case expects an answer of 8.  But I only count 7 edges between every node.  Between which two nodes are there 8 edges?"
                    },
                    {
                        "username": "suraj21209",
                        "content": "https://leetcode.com/problems/diameter-of-binary-tree/submissions/995832822/"
                    },
                    {
                        "username": "chidam333",
                        "content": "Note that the path does not need to pass through the root"
                    },
                    {
                        "username": "toho42",
                        "content": "copy and paste that to the test case to view the binary tree.  The node with a root of -9 has a maxDepth(left) of 4, and a maxDepth(right) of 4.  Thus, the diameter is 8.  This is case where the maxDiameter of a child node exceeds the maxDepth of the parent node\\'s left and right branches.\\n"
                    },
                    {
                        "username": "mascomen4",
                        "content": "see my comment below: https://leetcode.com/problems/diameter-of-binary-tree/discussion/comments/1629510"
                    },
                    {
                        "username": "OBAAT",
                        "content": "Bullshit problem description. \\nBullshit definition for \"diameter\". \\nIs it so difficult to say instead \"longest path\"? \\nProblem writers are morons. "
                    },
                    {
                        "username": "xclusive102",
                        "content": "[@ahmedtsalem9](/ahmedtsalem9) But this is not the world of circles. I agree that using \\'longest path\\' is more appropriate in the world of trees."
                    },
                    {
                        "username": "chumaumenze",
                        "content": "[@ahmedtsalem9](/ahmedtsalem9) The description is not a good one. I could not implement this because I had a problem understanding the question. When they say diameter, it implies the logic of how the diameter of a circle works - the length of the line through the center that touches two points on the edge of the circle. I was calculating the height of the tree from root to leaf."
                    },
                    {
                        "username": "ahmedtsalem9",
                        "content": "Technically, \"Diameter\" is a precise term. In the world of circles, the diameter is the longest line that can ever be drawn within a circle.\\n\\nThe same exact definition applies to trees; it\\'s the longest \"path\" that can ever be drawn within a tree through its nodes."
                    },
                    {
                        "username": "rana_afifi",
                        "content": "Rather tricky. Don\\'t think it is considered easy "
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Me too."
                    },
                    {
                        "username": "myih",
                        "content": "Scrolling down the discussions and most of the solutions are basically the same as the solution for no.124, yet this one is marked as easy and 124 is hard? Is there a easier way for this problem?"
                    },
                    {
                        "username": "suraj21209",
                        "content": "[@dragon1105](/dragon1105) https://leetcode.com/problems/diameter-of-binary-tree/submissions/995832822/"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "This one feels more like a medium to me. But 124 has a waaaay stricter time limit. My solution for 124 is getting TLEd to oblivion even with caching("
                    },
                    {
                        "username": "dragon1105",
                        "content": "Yeah I think this should be labeled as medium. This can only be easy when you\\'ve known the solution of some similar problems like Maximum Subarray (especially the divide-and-conquer one)."
                    },
                    {
                        "username": "WizTheProgrammer",
                        "content": "\"Easy\""
                    },
                    {
                        "username": "Dummyy",
                        "content": "sdcs jhfb wi wiufhw eiu uhweofuwe hfowe fowefowe fhwoe"
                    },
                    {
                        "username": "jonathanferraro75",
                        "content": "banging his head on the keyboard out of frustration"
                    },
                    {
                        "username": "rajat_171",
                        "content": "I agree"
                    },
                    {
                        "username": "techpromulgator",
                        "content": "How is the diameter of the below test case is 8?\\n\\n[4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]\\n\\nWhen I visualize, I see that it\\'s 7 and I\\'m getting 7. But, the expected answer is 8"
                    },
                    {
                        "username": "gauravkumar125",
                        "content": "i got it as 8 "
                    },
                    {
                        "username": "stephanauwerda000",
                        "content": "Because you should calculate max diameter of EVERY node, not just the root.\\nThe node (-9) has a diameter of 8. \\nSo this is the max diameter which the function should return."
                    },
                    {
                        "username": "ande_ka_funda",
                        "content": "The solution to just find the maximum width is rather simple. \\n\\nHowever I was asked to also print the path (and not just find the diameter).\\n\\nTotally fumbled. I have been trying but I am unable to come up with an O(n) solution"
                    },
                    {
                        "username": "JustBored",
                        "content": "Can do a second dfs from the root node with the max diameter. Just memoise which child node leads to the max height for each node  which will tell you which direction to go beforehand. But you have to make sure you go in both directions in the first iteration of the 2nd dfs from the starting node. This will give you the best path in O(n).\n\nThe O(n^2) approach would be to store the maximum height path for each node and combine the child left and right path at the max diameter node to get the optimal path. You can do this in one dfs but the tc is still O(n^2)\n    "
                    },
                    {
                        "username": "dhruvpithwa1999",
                        "content": "[@uchihahardik](/uchihahardik) You can refer to my soln, https://leetcode.com/problems/diameter-of-binary-tree/submissions/869730789/\\n\\nI have tried to solve and find path using ArrayList, same approach but different return type\\n\\nmay be this can help you.."
                    },
                    {
                        "username": "uchihahardik",
                        "content": "\"The solution to just find the maximum width is rather simple.\"\\nI am not able to think of an approch any tip?"
                    },
                    {
                        "username": "keJum",
                        "content": "# Example 1\\n![image](https://assets.leetcode.com/users/images/9f86a81d-aef1-4090-a327-14071d450001_1634631307.9913106.png)\\n\\nResult 3, expected 3\\n\\n# Example 100\\n![image](https://assets.leetcode.com/users/images/e671990e-09a1-4deb-b605-5bd4c15419cb_1634631254.7966447.png)\\n\\nResult 7, expected 8.\\n\\nWhy is the result expected to be 8 and not 7?"
                    },
                    {
                        "username": "ishananchit",
                        "content": "because of the path -4, 6, 6, 9, -9, -7, -6, 9, -2"
                    },
                    {
                        "username": "howhowone",
                        "content": "-2 9 -6 -7 -9 9 6 0 -1"
                    },
                    {
                        "username": "Geetanjali_Gupta",
                        "content": "path should be from -1 to -2 then ans would be 8"
                    },
                    {
                        "username": "deeponsubhro",
                        "content": "go from -1 to -2"
                    },
                    {
                        "username": "duchemin01",
                        "content": "[@VigneshwarVG](/VigneshwarVG)  then, expected should be 9"
                    },
                    {
                        "username": "VigneshwarVG",
                        "content": "it isn\\'t a rule that edge must always pass through the root of the tree\\nit might be its left or right or left\\'s (left or right ) or the right\\'s( left or right )and so on \\nhope you get it\\n"
                    },
                    {
                        "username": "RayanYI",
                        "content": "[@mascomen4](/mascomen4)  Thanks, very helpful. Thanks to you I\\'ve solved it :)"
                    },
                    {
                        "username": "Boyka800",
                        "content": "Because you are considering the wrong path, the correct one is from -4 to -2 of lenght 8."
                    },
                    {
                        "username": "mascomen4",
                        "content": "One year later, but may be it'll save some time for the others struggling the problem.\n\nUnfortunately, the assumption that the longest path comes through the root is not right for the unbalanced tree. So, they say `This path may or may not pass through the root`. \n\n*Hint:* try to find the path of 8 edges in the right subtree. "
                    }
                ]
            },
            {
                "id": 1567497,
                "content": [
                    {
                        "username": "SouthernHumor",
                        "content": "How the hek is this problem/program marked easy ? Solutions I\\'m seeing involve 2 recursive functions and this is just not quick or straightforward"
                    },
                    {
                        "username": "gbiems",
                        "content": "This one one of the first tree problems I tried to do on leetcode, since I was looking for \"easy\" tree problems. Oof. Now that I have some more experience, I feel a lot better about how hard I found it when I was starting out. This isn\\'t an easy problem. I come back to it and re-solve it every now and then.\\n\\nI think what makes it difficult is that (in the most common solution I\\'ve seen) you need to return a value from a recursive function (the max length of left or right branch from each node) but you need to set a class variable or other way of tracking the maximum value of the left + right branches.\\n\\nThat\\'s a lot to wrap your head around when you\\'re first looking for recursive tree problems. But hey, if you stick with it, you\\'ll get this, and it\\'s a great problem for tracking variable values in recursive functions. \\n\\nBut having solved a bunch of leetcode problems, I\\'d definitely say this one is medium, not easy. If I didn\\'t know the answer, I think I\\'d still struggle to get this one. "
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "[@eduard92](/eduard92) \"laid off already\" LMFAOOOO \\uD83D\\uDE02\\uD83D\\uDC80"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its easy for those who already know.. maybe they are in uni and already solved in there and they solve it here too.\nSome of us just come here with an empty mind to push forward and is hard if you have no background. I approached this month DP and Trees for the first time in my life, it surely developed a way of thinking of data in terms of a Tree and Recursion in my mind works now as a Stack, isn't something hard to explain anymore, but I still check discuss and other websites for pseudocode.\n\nI know the comment is old, dude probably got at google and laid off already but for future people who feel stuck I think its about pushing into unkown.\n"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I agree. Unless you\\'ve seen the style of this solution somewhere before (it\\'s similar to the divide-and-conquer solution of the Maximum Subarray problem), you\\'ll probably have a tough time when coming into this problem with an empty mind."
                    },
                    {
                        "username": "chidam333",
                        "content": "here you have to just go through every node and find sum of heights of it\\'s left and right node , which is way easier than knowing the exact path... ig lol "
                    },
                    {
                        "username": "alvinato",
                        "content": "[4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]\\n\\n^ the above test case expects an answer of 8.  But I only count 7 edges between every node.  Between which two nodes are there 8 edges?"
                    },
                    {
                        "username": "suraj21209",
                        "content": "https://leetcode.com/problems/diameter-of-binary-tree/submissions/995832822/"
                    },
                    {
                        "username": "chidam333",
                        "content": "Note that the path does not need to pass through the root"
                    },
                    {
                        "username": "toho42",
                        "content": "copy and paste that to the test case to view the binary tree.  The node with a root of -9 has a maxDepth(left) of 4, and a maxDepth(right) of 4.  Thus, the diameter is 8.  This is case where the maxDiameter of a child node exceeds the maxDepth of the parent node\\'s left and right branches.\\n"
                    },
                    {
                        "username": "mascomen4",
                        "content": "see my comment below: https://leetcode.com/problems/diameter-of-binary-tree/discussion/comments/1629510"
                    },
                    {
                        "username": "OBAAT",
                        "content": "Bullshit problem description. \\nBullshit definition for \"diameter\". \\nIs it so difficult to say instead \"longest path\"? \\nProblem writers are morons. "
                    },
                    {
                        "username": "xclusive102",
                        "content": "[@ahmedtsalem9](/ahmedtsalem9) But this is not the world of circles. I agree that using \\'longest path\\' is more appropriate in the world of trees."
                    },
                    {
                        "username": "chumaumenze",
                        "content": "[@ahmedtsalem9](/ahmedtsalem9) The description is not a good one. I could not implement this because I had a problem understanding the question. When they say diameter, it implies the logic of how the diameter of a circle works - the length of the line through the center that touches two points on the edge of the circle. I was calculating the height of the tree from root to leaf."
                    },
                    {
                        "username": "ahmedtsalem9",
                        "content": "Technically, \"Diameter\" is a precise term. In the world of circles, the diameter is the longest line that can ever be drawn within a circle.\\n\\nThe same exact definition applies to trees; it\\'s the longest \"path\" that can ever be drawn within a tree through its nodes."
                    },
                    {
                        "username": "rana_afifi",
                        "content": "Rather tricky. Don\\'t think it is considered easy "
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Me too."
                    },
                    {
                        "username": "myih",
                        "content": "Scrolling down the discussions and most of the solutions are basically the same as the solution for no.124, yet this one is marked as easy and 124 is hard? Is there a easier way for this problem?"
                    },
                    {
                        "username": "suraj21209",
                        "content": "[@dragon1105](/dragon1105) https://leetcode.com/problems/diameter-of-binary-tree/submissions/995832822/"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "This one feels more like a medium to me. But 124 has a waaaay stricter time limit. My solution for 124 is getting TLEd to oblivion even with caching("
                    },
                    {
                        "username": "dragon1105",
                        "content": "Yeah I think this should be labeled as medium. This can only be easy when you\\'ve known the solution of some similar problems like Maximum Subarray (especially the divide-and-conquer one)."
                    },
                    {
                        "username": "WizTheProgrammer",
                        "content": "\"Easy\""
                    },
                    {
                        "username": "Dummyy",
                        "content": "sdcs jhfb wi wiufhw eiu uhweofuwe hfowe fowefowe fhwoe"
                    },
                    {
                        "username": "jonathanferraro75",
                        "content": "banging his head on the keyboard out of frustration"
                    },
                    {
                        "username": "rajat_171",
                        "content": "I agree"
                    },
                    {
                        "username": "techpromulgator",
                        "content": "How is the diameter of the below test case is 8?\\n\\n[4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]\\n\\nWhen I visualize, I see that it\\'s 7 and I\\'m getting 7. But, the expected answer is 8"
                    },
                    {
                        "username": "gauravkumar125",
                        "content": "i got it as 8 "
                    },
                    {
                        "username": "stephanauwerda000",
                        "content": "Because you should calculate max diameter of EVERY node, not just the root.\\nThe node (-9) has a diameter of 8. \\nSo this is the max diameter which the function should return."
                    },
                    {
                        "username": "ande_ka_funda",
                        "content": "The solution to just find the maximum width is rather simple. \\n\\nHowever I was asked to also print the path (and not just find the diameter).\\n\\nTotally fumbled. I have been trying but I am unable to come up with an O(n) solution"
                    },
                    {
                        "username": "JustBored",
                        "content": "Can do a second dfs from the root node with the max diameter. Just memoise which child node leads to the max height for each node  which will tell you which direction to go beforehand. But you have to make sure you go in both directions in the first iteration of the 2nd dfs from the starting node. This will give you the best path in O(n).\n\nThe O(n^2) approach would be to store the maximum height path for each node and combine the child left and right path at the max diameter node to get the optimal path. You can do this in one dfs but the tc is still O(n^2)\n    "
                    },
                    {
                        "username": "dhruvpithwa1999",
                        "content": "[@uchihahardik](/uchihahardik) You can refer to my soln, https://leetcode.com/problems/diameter-of-binary-tree/submissions/869730789/\\n\\nI have tried to solve and find path using ArrayList, same approach but different return type\\n\\nmay be this can help you.."
                    },
                    {
                        "username": "uchihahardik",
                        "content": "\"The solution to just find the maximum width is rather simple.\"\\nI am not able to think of an approch any tip?"
                    },
                    {
                        "username": "keJum",
                        "content": "# Example 1\\n![image](https://assets.leetcode.com/users/images/9f86a81d-aef1-4090-a327-14071d450001_1634631307.9913106.png)\\n\\nResult 3, expected 3\\n\\n# Example 100\\n![image](https://assets.leetcode.com/users/images/e671990e-09a1-4deb-b605-5bd4c15419cb_1634631254.7966447.png)\\n\\nResult 7, expected 8.\\n\\nWhy is the result expected to be 8 and not 7?"
                    },
                    {
                        "username": "ishananchit",
                        "content": "because of the path -4, 6, 6, 9, -9, -7, -6, 9, -2"
                    },
                    {
                        "username": "howhowone",
                        "content": "-2 9 -6 -7 -9 9 6 0 -1"
                    },
                    {
                        "username": "Geetanjali_Gupta",
                        "content": "path should be from -1 to -2 then ans would be 8"
                    },
                    {
                        "username": "deeponsubhro",
                        "content": "go from -1 to -2"
                    },
                    {
                        "username": "duchemin01",
                        "content": "[@VigneshwarVG](/VigneshwarVG)  then, expected should be 9"
                    },
                    {
                        "username": "VigneshwarVG",
                        "content": "it isn\\'t a rule that edge must always pass through the root of the tree\\nit might be its left or right or left\\'s (left or right ) or the right\\'s( left or right )and so on \\nhope you get it\\n"
                    },
                    {
                        "username": "RayanYI",
                        "content": "[@mascomen4](/mascomen4)  Thanks, very helpful. Thanks to you I\\'ve solved it :)"
                    },
                    {
                        "username": "Boyka800",
                        "content": "Because you are considering the wrong path, the correct one is from -4 to -2 of lenght 8."
                    },
                    {
                        "username": "mascomen4",
                        "content": "One year later, but may be it'll save some time for the others struggling the problem.\n\nUnfortunately, the assumption that the longest path comes through the root is not right for the unbalanced tree. So, they say `This path may or may not pass through the root`. \n\n*Hint:* try to find the path of 8 edges in the right subtree. "
                    }
                ]
            },
            {
                "id": 1575874,
                "content": [
                    {
                        "username": "SouthernHumor",
                        "content": "How the hek is this problem/program marked easy ? Solutions I\\'m seeing involve 2 recursive functions and this is just not quick or straightforward"
                    },
                    {
                        "username": "gbiems",
                        "content": "This one one of the first tree problems I tried to do on leetcode, since I was looking for \"easy\" tree problems. Oof. Now that I have some more experience, I feel a lot better about how hard I found it when I was starting out. This isn\\'t an easy problem. I come back to it and re-solve it every now and then.\\n\\nI think what makes it difficult is that (in the most common solution I\\'ve seen) you need to return a value from a recursive function (the max length of left or right branch from each node) but you need to set a class variable or other way of tracking the maximum value of the left + right branches.\\n\\nThat\\'s a lot to wrap your head around when you\\'re first looking for recursive tree problems. But hey, if you stick with it, you\\'ll get this, and it\\'s a great problem for tracking variable values in recursive functions. \\n\\nBut having solved a bunch of leetcode problems, I\\'d definitely say this one is medium, not easy. If I didn\\'t know the answer, I think I\\'d still struggle to get this one. "
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "[@eduard92](/eduard92) \"laid off already\" LMFAOOOO \\uD83D\\uDE02\\uD83D\\uDC80"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its easy for those who already know.. maybe they are in uni and already solved in there and they solve it here too.\nSome of us just come here with an empty mind to push forward and is hard if you have no background. I approached this month DP and Trees for the first time in my life, it surely developed a way of thinking of data in terms of a Tree and Recursion in my mind works now as a Stack, isn't something hard to explain anymore, but I still check discuss and other websites for pseudocode.\n\nI know the comment is old, dude probably got at google and laid off already but for future people who feel stuck I think its about pushing into unkown.\n"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I agree. Unless you\\'ve seen the style of this solution somewhere before (it\\'s similar to the divide-and-conquer solution of the Maximum Subarray problem), you\\'ll probably have a tough time when coming into this problem with an empty mind."
                    },
                    {
                        "username": "chidam333",
                        "content": "here you have to just go through every node and find sum of heights of it\\'s left and right node , which is way easier than knowing the exact path... ig lol "
                    },
                    {
                        "username": "alvinato",
                        "content": "[4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]\\n\\n^ the above test case expects an answer of 8.  But I only count 7 edges between every node.  Between which two nodes are there 8 edges?"
                    },
                    {
                        "username": "suraj21209",
                        "content": "https://leetcode.com/problems/diameter-of-binary-tree/submissions/995832822/"
                    },
                    {
                        "username": "chidam333",
                        "content": "Note that the path does not need to pass through the root"
                    },
                    {
                        "username": "toho42",
                        "content": "copy and paste that to the test case to view the binary tree.  The node with a root of -9 has a maxDepth(left) of 4, and a maxDepth(right) of 4.  Thus, the diameter is 8.  This is case where the maxDiameter of a child node exceeds the maxDepth of the parent node\\'s left and right branches.\\n"
                    },
                    {
                        "username": "mascomen4",
                        "content": "see my comment below: https://leetcode.com/problems/diameter-of-binary-tree/discussion/comments/1629510"
                    },
                    {
                        "username": "OBAAT",
                        "content": "Bullshit problem description. \\nBullshit definition for \"diameter\". \\nIs it so difficult to say instead \"longest path\"? \\nProblem writers are morons. "
                    },
                    {
                        "username": "xclusive102",
                        "content": "[@ahmedtsalem9](/ahmedtsalem9) But this is not the world of circles. I agree that using \\'longest path\\' is more appropriate in the world of trees."
                    },
                    {
                        "username": "chumaumenze",
                        "content": "[@ahmedtsalem9](/ahmedtsalem9) The description is not a good one. I could not implement this because I had a problem understanding the question. When they say diameter, it implies the logic of how the diameter of a circle works - the length of the line through the center that touches two points on the edge of the circle. I was calculating the height of the tree from root to leaf."
                    },
                    {
                        "username": "ahmedtsalem9",
                        "content": "Technically, \"Diameter\" is a precise term. In the world of circles, the diameter is the longest line that can ever be drawn within a circle.\\n\\nThe same exact definition applies to trees; it\\'s the longest \"path\" that can ever be drawn within a tree through its nodes."
                    },
                    {
                        "username": "rana_afifi",
                        "content": "Rather tricky. Don\\'t think it is considered easy "
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Me too."
                    },
                    {
                        "username": "myih",
                        "content": "Scrolling down the discussions and most of the solutions are basically the same as the solution for no.124, yet this one is marked as easy and 124 is hard? Is there a easier way for this problem?"
                    },
                    {
                        "username": "suraj21209",
                        "content": "[@dragon1105](/dragon1105) https://leetcode.com/problems/diameter-of-binary-tree/submissions/995832822/"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "This one feels more like a medium to me. But 124 has a waaaay stricter time limit. My solution for 124 is getting TLEd to oblivion even with caching("
                    },
                    {
                        "username": "dragon1105",
                        "content": "Yeah I think this should be labeled as medium. This can only be easy when you\\'ve known the solution of some similar problems like Maximum Subarray (especially the divide-and-conquer one)."
                    },
                    {
                        "username": "WizTheProgrammer",
                        "content": "\"Easy\""
                    },
                    {
                        "username": "Dummyy",
                        "content": "sdcs jhfb wi wiufhw eiu uhweofuwe hfowe fowefowe fhwoe"
                    },
                    {
                        "username": "jonathanferraro75",
                        "content": "banging his head on the keyboard out of frustration"
                    },
                    {
                        "username": "rajat_171",
                        "content": "I agree"
                    },
                    {
                        "username": "techpromulgator",
                        "content": "How is the diameter of the below test case is 8?\\n\\n[4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]\\n\\nWhen I visualize, I see that it\\'s 7 and I\\'m getting 7. But, the expected answer is 8"
                    },
                    {
                        "username": "gauravkumar125",
                        "content": "i got it as 8 "
                    },
                    {
                        "username": "stephanauwerda000",
                        "content": "Because you should calculate max diameter of EVERY node, not just the root.\\nThe node (-9) has a diameter of 8. \\nSo this is the max diameter which the function should return."
                    },
                    {
                        "username": "ande_ka_funda",
                        "content": "The solution to just find the maximum width is rather simple. \\n\\nHowever I was asked to also print the path (and not just find the diameter).\\n\\nTotally fumbled. I have been trying but I am unable to come up with an O(n) solution"
                    },
                    {
                        "username": "JustBored",
                        "content": "Can do a second dfs from the root node with the max diameter. Just memoise which child node leads to the max height for each node  which will tell you which direction to go beforehand. But you have to make sure you go in both directions in the first iteration of the 2nd dfs from the starting node. This will give you the best path in O(n).\n\nThe O(n^2) approach would be to store the maximum height path for each node and combine the child left and right path at the max diameter node to get the optimal path. You can do this in one dfs but the tc is still O(n^2)\n    "
                    },
                    {
                        "username": "dhruvpithwa1999",
                        "content": "[@uchihahardik](/uchihahardik) You can refer to my soln, https://leetcode.com/problems/diameter-of-binary-tree/submissions/869730789/\\n\\nI have tried to solve and find path using ArrayList, same approach but different return type\\n\\nmay be this can help you.."
                    },
                    {
                        "username": "uchihahardik",
                        "content": "\"The solution to just find the maximum width is rather simple.\"\\nI am not able to think of an approch any tip?"
                    },
                    {
                        "username": "keJum",
                        "content": "# Example 1\\n![image](https://assets.leetcode.com/users/images/9f86a81d-aef1-4090-a327-14071d450001_1634631307.9913106.png)\\n\\nResult 3, expected 3\\n\\n# Example 100\\n![image](https://assets.leetcode.com/users/images/e671990e-09a1-4deb-b605-5bd4c15419cb_1634631254.7966447.png)\\n\\nResult 7, expected 8.\\n\\nWhy is the result expected to be 8 and not 7?"
                    },
                    {
                        "username": "ishananchit",
                        "content": "because of the path -4, 6, 6, 9, -9, -7, -6, 9, -2"
                    },
                    {
                        "username": "howhowone",
                        "content": "-2 9 -6 -7 -9 9 6 0 -1"
                    },
                    {
                        "username": "Geetanjali_Gupta",
                        "content": "path should be from -1 to -2 then ans would be 8"
                    },
                    {
                        "username": "deeponsubhro",
                        "content": "go from -1 to -2"
                    },
                    {
                        "username": "duchemin01",
                        "content": "[@VigneshwarVG](/VigneshwarVG)  then, expected should be 9"
                    },
                    {
                        "username": "VigneshwarVG",
                        "content": "it isn\\'t a rule that edge must always pass through the root of the tree\\nit might be its left or right or left\\'s (left or right ) or the right\\'s( left or right )and so on \\nhope you get it\\n"
                    },
                    {
                        "username": "RayanYI",
                        "content": "[@mascomen4](/mascomen4)  Thanks, very helpful. Thanks to you I\\'ve solved it :)"
                    },
                    {
                        "username": "Boyka800",
                        "content": "Because you are considering the wrong path, the correct one is from -4 to -2 of lenght 8."
                    },
                    {
                        "username": "mascomen4",
                        "content": "One year later, but may be it'll save some time for the others struggling the problem.\n\nUnfortunately, the assumption that the longest path comes through the root is not right for the unbalanced tree. So, they say `This path may or may not pass through the root`. \n\n*Hint:* try to find the path of 8 edges in the right subtree. "
                    }
                ]
            },
            {
                "id": 1793451,
                "content": [
                    {
                        "username": "jd2050",
                        "content": "It\\'s not \"easy\", should be \"medium\""
                    },
                    {
                        "username": "larrywang2014",
                        "content": "\"Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].\"\\n\\nIsn't the length of path supposed to be 4?"
                    },
                    {
                        "username": "sidrocks817",
                        "content": "4->2, 2->1,1->3, length = 3"
                    },
                    {
                        "username": "fadista",
                        "content": "The length is the number of edges, not the number of nodes."
                    },
                    {
                        "username": "upol94",
                        "content": "For input [4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2] why the output is 8?\\nFrom my drawing, left subtree is 1 and right subtree is 6, so it should 7."
                    },
                    {
                        "username": "goku58",
                        "content": "Try -1 to -2"
                    },
                    {
                        "username": "davorrr",
                        "content": "This is a hard problem comrade."
                    },
                    {
                        "username": "sliks",
                        "content": "Two different concepts:\\n - diameter = height of left tree + height of right tree\\n - height = 1 + max(height of left tree, height of right tree)\\n\\nKeep track of the height and calculate its diameter for each node all the way to the root."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "HINT: The diameter can be computed as the sum,\nmax(left side) + max(right side)\n\nso for [1,2,3,4,5] -> return max(1,3) + max(1, 5) -> return 1 + 2 = 3\n\nalso for [1,null,2,3,4] -> return max(1, null) + max(1,3) -> return 0 + 2 = 2"
                    },
                    {
                        "username": "elenaoat",
                        "content": "So I see that one of the inputs is:\\n[4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]\\nhowever, I cannot figure out how would the tree look like. \\nI thought the idea was root, root.left, root.right, root.left.left, root.left.right, etc.\\nhowever, already from the first 3 nodes you can see this doesn\\'t work, because in a binary tree the right node has to be of higher value, but in this case it\\'s lower than root (4 > -3).\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "This would be easy if the \"diameter\" had to pass through the root. But that\\'s not required, it can pass or not pass through whatever it wants. This is definitely not intuitive."
                    },
                    {
                        "username": "rajat_171",
                        "content": "This question is of medium level, There\\'s no doubt about it. I request leetcode to please mark this problem as medium.\\nThank you \\uD83D\\uDE0C"
                    },
                    {
                        "username": "KiritiAryal",
                        "content": "Can somebody please explain this self.diameter = 0 and how it is working. I get the basic concept of an instance variable but this is not making any sense to me. Why do we get error while create diameter = 0 globally? "
                    },
                    {
                        "username": "Boyka800",
                        "content": "[@KiritiAryal](/KiritiAryal)  No, I am doing in C++, sorry can't help in it."
                    },
                    {
                        "username": "KiritiAryal",
                        "content": "[@Boyka800](/Boyka800) Are you doing this is python? I am new to python and just want to understand how the instance variable gets updated in every iteration. "
                    },
                    {
                        "username": "Boyka800",
                        "content": "I have done the same thing, created a global variable for diameter and It\\'s not giving any error, working fine."
                    }
                ]
            },
            {
                "id": 1567987,
                "content": [
                    {
                        "username": "jd2050",
                        "content": "It\\'s not \"easy\", should be \"medium\""
                    },
                    {
                        "username": "larrywang2014",
                        "content": "\"Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].\"\\n\\nIsn't the length of path supposed to be 4?"
                    },
                    {
                        "username": "sidrocks817",
                        "content": "4->2, 2->1,1->3, length = 3"
                    },
                    {
                        "username": "fadista",
                        "content": "The length is the number of edges, not the number of nodes."
                    },
                    {
                        "username": "upol94",
                        "content": "For input [4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2] why the output is 8?\\nFrom my drawing, left subtree is 1 and right subtree is 6, so it should 7."
                    },
                    {
                        "username": "goku58",
                        "content": "Try -1 to -2"
                    },
                    {
                        "username": "davorrr",
                        "content": "This is a hard problem comrade."
                    },
                    {
                        "username": "sliks",
                        "content": "Two different concepts:\\n - diameter = height of left tree + height of right tree\\n - height = 1 + max(height of left tree, height of right tree)\\n\\nKeep track of the height and calculate its diameter for each node all the way to the root."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "HINT: The diameter can be computed as the sum,\nmax(left side) + max(right side)\n\nso for [1,2,3,4,5] -> return max(1,3) + max(1, 5) -> return 1 + 2 = 3\n\nalso for [1,null,2,3,4] -> return max(1, null) + max(1,3) -> return 0 + 2 = 2"
                    },
                    {
                        "username": "elenaoat",
                        "content": "So I see that one of the inputs is:\\n[4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]\\nhowever, I cannot figure out how would the tree look like. \\nI thought the idea was root, root.left, root.right, root.left.left, root.left.right, etc.\\nhowever, already from the first 3 nodes you can see this doesn\\'t work, because in a binary tree the right node has to be of higher value, but in this case it\\'s lower than root (4 > -3).\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "This would be easy if the \"diameter\" had to pass through the root. But that\\'s not required, it can pass or not pass through whatever it wants. This is definitely not intuitive."
                    },
                    {
                        "username": "rajat_171",
                        "content": "This question is of medium level, There\\'s no doubt about it. I request leetcode to please mark this problem as medium.\\nThank you \\uD83D\\uDE0C"
                    },
                    {
                        "username": "KiritiAryal",
                        "content": "Can somebody please explain this self.diameter = 0 and how it is working. I get the basic concept of an instance variable but this is not making any sense to me. Why do we get error while create diameter = 0 globally? "
                    },
                    {
                        "username": "Boyka800",
                        "content": "[@KiritiAryal](/KiritiAryal)  No, I am doing in C++, sorry can't help in it."
                    },
                    {
                        "username": "KiritiAryal",
                        "content": "[@Boyka800](/Boyka800) Are you doing this is python? I am new to python and just want to understand how the instance variable gets updated in every iteration. "
                    },
                    {
                        "username": "Boyka800",
                        "content": "I have done the same thing, created a global variable for diameter and It\\'s not giving any error, working fine."
                    }
                ]
            },
            {
                "id": 1576084,
                "content": [
                    {
                        "username": "jd2050",
                        "content": "It\\'s not \"easy\", should be \"medium\""
                    },
                    {
                        "username": "larrywang2014",
                        "content": "\"Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].\"\\n\\nIsn't the length of path supposed to be 4?"
                    },
                    {
                        "username": "sidrocks817",
                        "content": "4->2, 2->1,1->3, length = 3"
                    },
                    {
                        "username": "fadista",
                        "content": "The length is the number of edges, not the number of nodes."
                    },
                    {
                        "username": "upol94",
                        "content": "For input [4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2] why the output is 8?\\nFrom my drawing, left subtree is 1 and right subtree is 6, so it should 7."
                    },
                    {
                        "username": "goku58",
                        "content": "Try -1 to -2"
                    },
                    {
                        "username": "davorrr",
                        "content": "This is a hard problem comrade."
                    },
                    {
                        "username": "sliks",
                        "content": "Two different concepts:\\n - diameter = height of left tree + height of right tree\\n - height = 1 + max(height of left tree, height of right tree)\\n\\nKeep track of the height and calculate its diameter for each node all the way to the root."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "HINT: The diameter can be computed as the sum,\nmax(left side) + max(right side)\n\nso for [1,2,3,4,5] -> return max(1,3) + max(1, 5) -> return 1 + 2 = 3\n\nalso for [1,null,2,3,4] -> return max(1, null) + max(1,3) -> return 0 + 2 = 2"
                    },
                    {
                        "username": "elenaoat",
                        "content": "So I see that one of the inputs is:\\n[4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]\\nhowever, I cannot figure out how would the tree look like. \\nI thought the idea was root, root.left, root.right, root.left.left, root.left.right, etc.\\nhowever, already from the first 3 nodes you can see this doesn\\'t work, because in a binary tree the right node has to be of higher value, but in this case it\\'s lower than root (4 > -3).\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "This would be easy if the \"diameter\" had to pass through the root. But that\\'s not required, it can pass or not pass through whatever it wants. This is definitely not intuitive."
                    },
                    {
                        "username": "rajat_171",
                        "content": "This question is of medium level, There\\'s no doubt about it. I request leetcode to please mark this problem as medium.\\nThank you \\uD83D\\uDE0C"
                    },
                    {
                        "username": "KiritiAryal",
                        "content": "Can somebody please explain this self.diameter = 0 and how it is working. I get the basic concept of an instance variable but this is not making any sense to me. Why do we get error while create diameter = 0 globally? "
                    },
                    {
                        "username": "Boyka800",
                        "content": "[@KiritiAryal](/KiritiAryal)  No, I am doing in C++, sorry can't help in it."
                    },
                    {
                        "username": "KiritiAryal",
                        "content": "[@Boyka800](/Boyka800) Are you doing this is python? I am new to python and just want to understand how the instance variable gets updated in every iteration. "
                    },
                    {
                        "username": "Boyka800",
                        "content": "I have done the same thing, created a global variable for diameter and It\\'s not giving any error, working fine."
                    }
                ]
            },
            {
                "id": 1929009,
                "content": [
                    {
                        "username": "jd2050",
                        "content": "It\\'s not \"easy\", should be \"medium\""
                    },
                    {
                        "username": "larrywang2014",
                        "content": "\"Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].\"\\n\\nIsn't the length of path supposed to be 4?"
                    },
                    {
                        "username": "sidrocks817",
                        "content": "4->2, 2->1,1->3, length = 3"
                    },
                    {
                        "username": "fadista",
                        "content": "The length is the number of edges, not the number of nodes."
                    },
                    {
                        "username": "upol94",
                        "content": "For input [4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2] why the output is 8?\\nFrom my drawing, left subtree is 1 and right subtree is 6, so it should 7."
                    },
                    {
                        "username": "goku58",
                        "content": "Try -1 to -2"
                    },
                    {
                        "username": "davorrr",
                        "content": "This is a hard problem comrade."
                    },
                    {
                        "username": "sliks",
                        "content": "Two different concepts:\\n - diameter = height of left tree + height of right tree\\n - height = 1 + max(height of left tree, height of right tree)\\n\\nKeep track of the height and calculate its diameter for each node all the way to the root."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "HINT: The diameter can be computed as the sum,\nmax(left side) + max(right side)\n\nso for [1,2,3,4,5] -> return max(1,3) + max(1, 5) -> return 1 + 2 = 3\n\nalso for [1,null,2,3,4] -> return max(1, null) + max(1,3) -> return 0 + 2 = 2"
                    },
                    {
                        "username": "elenaoat",
                        "content": "So I see that one of the inputs is:\\n[4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]\\nhowever, I cannot figure out how would the tree look like. \\nI thought the idea was root, root.left, root.right, root.left.left, root.left.right, etc.\\nhowever, already from the first 3 nodes you can see this doesn\\'t work, because in a binary tree the right node has to be of higher value, but in this case it\\'s lower than root (4 > -3).\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "This would be easy if the \"diameter\" had to pass through the root. But that\\'s not required, it can pass or not pass through whatever it wants. This is definitely not intuitive."
                    },
                    {
                        "username": "rajat_171",
                        "content": "This question is of medium level, There\\'s no doubt about it. I request leetcode to please mark this problem as medium.\\nThank you \\uD83D\\uDE0C"
                    },
                    {
                        "username": "KiritiAryal",
                        "content": "Can somebody please explain this self.diameter = 0 and how it is working. I get the basic concept of an instance variable but this is not making any sense to me. Why do we get error while create diameter = 0 globally? "
                    },
                    {
                        "username": "Boyka800",
                        "content": "[@KiritiAryal](/KiritiAryal)  No, I am doing in C++, sorry can't help in it."
                    },
                    {
                        "username": "KiritiAryal",
                        "content": "[@Boyka800](/Boyka800) Are you doing this is python? I am new to python and just want to understand how the instance variable gets updated in every iteration. "
                    },
                    {
                        "username": "Boyka800",
                        "content": "I have done the same thing, created a global variable for diameter and It\\'s not giving any error, working fine."
                    }
                ]
            },
            {
                "id": 1915789,
                "content": [
                    {
                        "username": "jd2050",
                        "content": "It\\'s not \"easy\", should be \"medium\""
                    },
                    {
                        "username": "larrywang2014",
                        "content": "\"Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].\"\\n\\nIsn't the length of path supposed to be 4?"
                    },
                    {
                        "username": "sidrocks817",
                        "content": "4->2, 2->1,1->3, length = 3"
                    },
                    {
                        "username": "fadista",
                        "content": "The length is the number of edges, not the number of nodes."
                    },
                    {
                        "username": "upol94",
                        "content": "For input [4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2] why the output is 8?\\nFrom my drawing, left subtree is 1 and right subtree is 6, so it should 7."
                    },
                    {
                        "username": "goku58",
                        "content": "Try -1 to -2"
                    },
                    {
                        "username": "davorrr",
                        "content": "This is a hard problem comrade."
                    },
                    {
                        "username": "sliks",
                        "content": "Two different concepts:\\n - diameter = height of left tree + height of right tree\\n - height = 1 + max(height of left tree, height of right tree)\\n\\nKeep track of the height and calculate its diameter for each node all the way to the root."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "HINT: The diameter can be computed as the sum,\nmax(left side) + max(right side)\n\nso for [1,2,3,4,5] -> return max(1,3) + max(1, 5) -> return 1 + 2 = 3\n\nalso for [1,null,2,3,4] -> return max(1, null) + max(1,3) -> return 0 + 2 = 2"
                    },
                    {
                        "username": "elenaoat",
                        "content": "So I see that one of the inputs is:\\n[4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]\\nhowever, I cannot figure out how would the tree look like. \\nI thought the idea was root, root.left, root.right, root.left.left, root.left.right, etc.\\nhowever, already from the first 3 nodes you can see this doesn\\'t work, because in a binary tree the right node has to be of higher value, but in this case it\\'s lower than root (4 > -3).\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "This would be easy if the \"diameter\" had to pass through the root. But that\\'s not required, it can pass or not pass through whatever it wants. This is definitely not intuitive."
                    },
                    {
                        "username": "rajat_171",
                        "content": "This question is of medium level, There\\'s no doubt about it. I request leetcode to please mark this problem as medium.\\nThank you \\uD83D\\uDE0C"
                    },
                    {
                        "username": "KiritiAryal",
                        "content": "Can somebody please explain this self.diameter = 0 and how it is working. I get the basic concept of an instance variable but this is not making any sense to me. Why do we get error while create diameter = 0 globally? "
                    },
                    {
                        "username": "Boyka800",
                        "content": "[@KiritiAryal](/KiritiAryal)  No, I am doing in C++, sorry can't help in it."
                    },
                    {
                        "username": "KiritiAryal",
                        "content": "[@Boyka800](/Boyka800) Are you doing this is python? I am new to python and just want to understand how the instance variable gets updated in every iteration. "
                    },
                    {
                        "username": "Boyka800",
                        "content": "I have done the same thing, created a global variable for diameter and It\\'s not giving any error, working fine."
                    }
                ]
            },
            {
                "id": 1971138,
                "content": [
                    {
                        "username": "jd2050",
                        "content": "It\\'s not \"easy\", should be \"medium\""
                    },
                    {
                        "username": "larrywang2014",
                        "content": "\"Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].\"\\n\\nIsn't the length of path supposed to be 4?"
                    },
                    {
                        "username": "sidrocks817",
                        "content": "4->2, 2->1,1->3, length = 3"
                    },
                    {
                        "username": "fadista",
                        "content": "The length is the number of edges, not the number of nodes."
                    },
                    {
                        "username": "upol94",
                        "content": "For input [4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2] why the output is 8?\\nFrom my drawing, left subtree is 1 and right subtree is 6, so it should 7."
                    },
                    {
                        "username": "goku58",
                        "content": "Try -1 to -2"
                    },
                    {
                        "username": "davorrr",
                        "content": "This is a hard problem comrade."
                    },
                    {
                        "username": "sliks",
                        "content": "Two different concepts:\\n - diameter = height of left tree + height of right tree\\n - height = 1 + max(height of left tree, height of right tree)\\n\\nKeep track of the height and calculate its diameter for each node all the way to the root."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "HINT: The diameter can be computed as the sum,\nmax(left side) + max(right side)\n\nso for [1,2,3,4,5] -> return max(1,3) + max(1, 5) -> return 1 + 2 = 3\n\nalso for [1,null,2,3,4] -> return max(1, null) + max(1,3) -> return 0 + 2 = 2"
                    },
                    {
                        "username": "elenaoat",
                        "content": "So I see that one of the inputs is:\\n[4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]\\nhowever, I cannot figure out how would the tree look like. \\nI thought the idea was root, root.left, root.right, root.left.left, root.left.right, etc.\\nhowever, already from the first 3 nodes you can see this doesn\\'t work, because in a binary tree the right node has to be of higher value, but in this case it\\'s lower than root (4 > -3).\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "This would be easy if the \"diameter\" had to pass through the root. But that\\'s not required, it can pass or not pass through whatever it wants. This is definitely not intuitive."
                    },
                    {
                        "username": "rajat_171",
                        "content": "This question is of medium level, There\\'s no doubt about it. I request leetcode to please mark this problem as medium.\\nThank you \\uD83D\\uDE0C"
                    },
                    {
                        "username": "KiritiAryal",
                        "content": "Can somebody please explain this self.diameter = 0 and how it is working. I get the basic concept of an instance variable but this is not making any sense to me. Why do we get error while create diameter = 0 globally? "
                    },
                    {
                        "username": "Boyka800",
                        "content": "[@KiritiAryal](/KiritiAryal)  No, I am doing in C++, sorry can't help in it."
                    },
                    {
                        "username": "KiritiAryal",
                        "content": "[@Boyka800](/Boyka800) Are you doing this is python? I am new to python and just want to understand how the instance variable gets updated in every iteration. "
                    },
                    {
                        "username": "Boyka800",
                        "content": "I have done the same thing, created a global variable for diameter and It\\'s not giving any error, working fine."
                    }
                ]
            },
            {
                "id": 1569584,
                "content": [
                    {
                        "username": "jd2050",
                        "content": "It\\'s not \"easy\", should be \"medium\""
                    },
                    {
                        "username": "larrywang2014",
                        "content": "\"Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].\"\\n\\nIsn't the length of path supposed to be 4?"
                    },
                    {
                        "username": "sidrocks817",
                        "content": "4->2, 2->1,1->3, length = 3"
                    },
                    {
                        "username": "fadista",
                        "content": "The length is the number of edges, not the number of nodes."
                    },
                    {
                        "username": "upol94",
                        "content": "For input [4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2] why the output is 8?\\nFrom my drawing, left subtree is 1 and right subtree is 6, so it should 7."
                    },
                    {
                        "username": "goku58",
                        "content": "Try -1 to -2"
                    },
                    {
                        "username": "davorrr",
                        "content": "This is a hard problem comrade."
                    },
                    {
                        "username": "sliks",
                        "content": "Two different concepts:\\n - diameter = height of left tree + height of right tree\\n - height = 1 + max(height of left tree, height of right tree)\\n\\nKeep track of the height and calculate its diameter for each node all the way to the root."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "HINT: The diameter can be computed as the sum,\nmax(left side) + max(right side)\n\nso for [1,2,3,4,5] -> return max(1,3) + max(1, 5) -> return 1 + 2 = 3\n\nalso for [1,null,2,3,4] -> return max(1, null) + max(1,3) -> return 0 + 2 = 2"
                    },
                    {
                        "username": "elenaoat",
                        "content": "So I see that one of the inputs is:\\n[4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]\\nhowever, I cannot figure out how would the tree look like. \\nI thought the idea was root, root.left, root.right, root.left.left, root.left.right, etc.\\nhowever, already from the first 3 nodes you can see this doesn\\'t work, because in a binary tree the right node has to be of higher value, but in this case it\\'s lower than root (4 > -3).\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "This would be easy if the \"diameter\" had to pass through the root. But that\\'s not required, it can pass or not pass through whatever it wants. This is definitely not intuitive."
                    },
                    {
                        "username": "rajat_171",
                        "content": "This question is of medium level, There\\'s no doubt about it. I request leetcode to please mark this problem as medium.\\nThank you \\uD83D\\uDE0C"
                    },
                    {
                        "username": "KiritiAryal",
                        "content": "Can somebody please explain this self.diameter = 0 and how it is working. I get the basic concept of an instance variable but this is not making any sense to me. Why do we get error while create diameter = 0 globally? "
                    },
                    {
                        "username": "Boyka800",
                        "content": "[@KiritiAryal](/KiritiAryal)  No, I am doing in C++, sorry can't help in it."
                    },
                    {
                        "username": "KiritiAryal",
                        "content": "[@Boyka800](/Boyka800) Are you doing this is python? I am new to python and just want to understand how the instance variable gets updated in every iteration. "
                    },
                    {
                        "username": "Boyka800",
                        "content": "I have done the same thing, created a global variable for diameter and It\\'s not giving any error, working fine."
                    }
                ]
            },
            {
                "id": 1947130,
                "content": [
                    {
                        "username": "jd2050",
                        "content": "It\\'s not \"easy\", should be \"medium\""
                    },
                    {
                        "username": "larrywang2014",
                        "content": "\"Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].\"\\n\\nIsn't the length of path supposed to be 4?"
                    },
                    {
                        "username": "sidrocks817",
                        "content": "4->2, 2->1,1->3, length = 3"
                    },
                    {
                        "username": "fadista",
                        "content": "The length is the number of edges, not the number of nodes."
                    },
                    {
                        "username": "upol94",
                        "content": "For input [4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2] why the output is 8?\\nFrom my drawing, left subtree is 1 and right subtree is 6, so it should 7."
                    },
                    {
                        "username": "goku58",
                        "content": "Try -1 to -2"
                    },
                    {
                        "username": "davorrr",
                        "content": "This is a hard problem comrade."
                    },
                    {
                        "username": "sliks",
                        "content": "Two different concepts:\\n - diameter = height of left tree + height of right tree\\n - height = 1 + max(height of left tree, height of right tree)\\n\\nKeep track of the height and calculate its diameter for each node all the way to the root."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "HINT: The diameter can be computed as the sum,\nmax(left side) + max(right side)\n\nso for [1,2,3,4,5] -> return max(1,3) + max(1, 5) -> return 1 + 2 = 3\n\nalso for [1,null,2,3,4] -> return max(1, null) + max(1,3) -> return 0 + 2 = 2"
                    },
                    {
                        "username": "elenaoat",
                        "content": "So I see that one of the inputs is:\\n[4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]\\nhowever, I cannot figure out how would the tree look like. \\nI thought the idea was root, root.left, root.right, root.left.left, root.left.right, etc.\\nhowever, already from the first 3 nodes you can see this doesn\\'t work, because in a binary tree the right node has to be of higher value, but in this case it\\'s lower than root (4 > -3).\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "This would be easy if the \"diameter\" had to pass through the root. But that\\'s not required, it can pass or not pass through whatever it wants. This is definitely not intuitive."
                    },
                    {
                        "username": "rajat_171",
                        "content": "This question is of medium level, There\\'s no doubt about it. I request leetcode to please mark this problem as medium.\\nThank you \\uD83D\\uDE0C"
                    },
                    {
                        "username": "KiritiAryal",
                        "content": "Can somebody please explain this self.diameter = 0 and how it is working. I get the basic concept of an instance variable but this is not making any sense to me. Why do we get error while create diameter = 0 globally? "
                    },
                    {
                        "username": "Boyka800",
                        "content": "[@KiritiAryal](/KiritiAryal)  No, I am doing in C++, sorry can't help in it."
                    },
                    {
                        "username": "KiritiAryal",
                        "content": "[@Boyka800](/Boyka800) Are you doing this is python? I am new to python and just want to understand how the instance variable gets updated in every iteration. "
                    },
                    {
                        "username": "Boyka800",
                        "content": "I have done the same thing, created a global variable for diameter and It\\'s not giving any error, working fine."
                    }
                ]
            },
            {
                "id": 1815173,
                "content": [
                    {
                        "username": "jd2050",
                        "content": "It\\'s not \"easy\", should be \"medium\""
                    },
                    {
                        "username": "larrywang2014",
                        "content": "\"Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].\"\\n\\nIsn't the length of path supposed to be 4?"
                    },
                    {
                        "username": "sidrocks817",
                        "content": "4->2, 2->1,1->3, length = 3"
                    },
                    {
                        "username": "fadista",
                        "content": "The length is the number of edges, not the number of nodes."
                    },
                    {
                        "username": "upol94",
                        "content": "For input [4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2] why the output is 8?\\nFrom my drawing, left subtree is 1 and right subtree is 6, so it should 7."
                    },
                    {
                        "username": "goku58",
                        "content": "Try -1 to -2"
                    },
                    {
                        "username": "davorrr",
                        "content": "This is a hard problem comrade."
                    },
                    {
                        "username": "sliks",
                        "content": "Two different concepts:\\n - diameter = height of left tree + height of right tree\\n - height = 1 + max(height of left tree, height of right tree)\\n\\nKeep track of the height and calculate its diameter for each node all the way to the root."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "HINT: The diameter can be computed as the sum,\nmax(left side) + max(right side)\n\nso for [1,2,3,4,5] -> return max(1,3) + max(1, 5) -> return 1 + 2 = 3\n\nalso for [1,null,2,3,4] -> return max(1, null) + max(1,3) -> return 0 + 2 = 2"
                    },
                    {
                        "username": "elenaoat",
                        "content": "So I see that one of the inputs is:\\n[4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]\\nhowever, I cannot figure out how would the tree look like. \\nI thought the idea was root, root.left, root.right, root.left.left, root.left.right, etc.\\nhowever, already from the first 3 nodes you can see this doesn\\'t work, because in a binary tree the right node has to be of higher value, but in this case it\\'s lower than root (4 > -3).\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "This would be easy if the \"diameter\" had to pass through the root. But that\\'s not required, it can pass or not pass through whatever it wants. This is definitely not intuitive."
                    },
                    {
                        "username": "rajat_171",
                        "content": "This question is of medium level, There\\'s no doubt about it. I request leetcode to please mark this problem as medium.\\nThank you \\uD83D\\uDE0C"
                    },
                    {
                        "username": "KiritiAryal",
                        "content": "Can somebody please explain this self.diameter = 0 and how it is working. I get the basic concept of an instance variable but this is not making any sense to me. Why do we get error while create diameter = 0 globally? "
                    },
                    {
                        "username": "Boyka800",
                        "content": "[@KiritiAryal](/KiritiAryal)  No, I am doing in C++, sorry can't help in it."
                    },
                    {
                        "username": "KiritiAryal",
                        "content": "[@Boyka800](/Boyka800) Are you doing this is python? I am new to python and just want to understand how the instance variable gets updated in every iteration. "
                    },
                    {
                        "username": "Boyka800",
                        "content": "I have done the same thing, created a global variable for diameter and It\\'s not giving any error, working fine."
                    }
                ]
            },
            {
                "id": 1676838,
                "content": [
                    {
                        "username": "jd2050",
                        "content": "It\\'s not \"easy\", should be \"medium\""
                    },
                    {
                        "username": "larrywang2014",
                        "content": "\"Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].\"\\n\\nIsn't the length of path supposed to be 4?"
                    },
                    {
                        "username": "sidrocks817",
                        "content": "4->2, 2->1,1->3, length = 3"
                    },
                    {
                        "username": "fadista",
                        "content": "The length is the number of edges, not the number of nodes."
                    },
                    {
                        "username": "upol94",
                        "content": "For input [4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2] why the output is 8?\\nFrom my drawing, left subtree is 1 and right subtree is 6, so it should 7."
                    },
                    {
                        "username": "goku58",
                        "content": "Try -1 to -2"
                    },
                    {
                        "username": "davorrr",
                        "content": "This is a hard problem comrade."
                    },
                    {
                        "username": "sliks",
                        "content": "Two different concepts:\\n - diameter = height of left tree + height of right tree\\n - height = 1 + max(height of left tree, height of right tree)\\n\\nKeep track of the height and calculate its diameter for each node all the way to the root."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "HINT: The diameter can be computed as the sum,\nmax(left side) + max(right side)\n\nso for [1,2,3,4,5] -> return max(1,3) + max(1, 5) -> return 1 + 2 = 3\n\nalso for [1,null,2,3,4] -> return max(1, null) + max(1,3) -> return 0 + 2 = 2"
                    },
                    {
                        "username": "elenaoat",
                        "content": "So I see that one of the inputs is:\\n[4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]\\nhowever, I cannot figure out how would the tree look like. \\nI thought the idea was root, root.left, root.right, root.left.left, root.left.right, etc.\\nhowever, already from the first 3 nodes you can see this doesn\\'t work, because in a binary tree the right node has to be of higher value, but in this case it\\'s lower than root (4 > -3).\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "This would be easy if the \"diameter\" had to pass through the root. But that\\'s not required, it can pass or not pass through whatever it wants. This is definitely not intuitive."
                    },
                    {
                        "username": "rajat_171",
                        "content": "This question is of medium level, There\\'s no doubt about it. I request leetcode to please mark this problem as medium.\\nThank you \\uD83D\\uDE0C"
                    },
                    {
                        "username": "KiritiAryal",
                        "content": "Can somebody please explain this self.diameter = 0 and how it is working. I get the basic concept of an instance variable but this is not making any sense to me. Why do we get error while create diameter = 0 globally? "
                    },
                    {
                        "username": "Boyka800",
                        "content": "[@KiritiAryal](/KiritiAryal)  No, I am doing in C++, sorry can't help in it."
                    },
                    {
                        "username": "KiritiAryal",
                        "content": "[@Boyka800](/Boyka800) Are you doing this is python? I am new to python and just want to understand how the instance variable gets updated in every iteration. "
                    },
                    {
                        "username": "Boyka800",
                        "content": "I have done the same thing, created a global variable for diameter and It\\'s not giving any error, working fine."
                    }
                ]
            },
            {
                "id": 1574330,
                "content": [
                    {
                        "username": "gustring",
                        "content": "Is this actually possible?"
                    },
                    {
                        "username": "nilesmac",
                        "content": "This is one of the harder tree problems I\\'ve come across. There are tree problems marked hard that I find easier."
                    },
                    {
                        "username": "aftabmk",
                        "content": "Best part of this question is that if we add root->val instead of 1 in each recursion then we can solve maxPath sum which is marked as hard. maybe they should mark this as \"hardly\" easy."
                    },
                    {
                        "username": "Dxmaptin",
                        "content": "I think it is better to first try max depth of binary tree before coming on this problem"
                    },
                    {
                        "username": "Dipankar0007",
                        "content": "how this is easy?\\uD83E\\uDD28"
                    },
                    {
                        "username": "michaelscheinfeild",
                        "content": "i have [2,3,null,1]  , how i treat null python dont know this"
                    },
                    {
                        "username": "itmevic",
                        "content": "I do no see how the answer is length 8 for this case, the longest path(# of edges) between 2 nodes that I can find is only 7,\ncan please anyone tell me whats wrong with my code with this case: [4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]\n\n\nMY CODE: \n\n var diameterOfBinaryTree = function(root) {\n    \n   if(root.left === null & root.right === null)\n   return 0\n         \n   let pointer = root \n   return dfs(root,pointer)\n}\n\n\nfunction dfs(pointer,root){\n\n    if(!pointer)\n     return 0\n     \n    if(!pointer.left && !pointer.right) \n      return 1\n\n    if(pointer.left === null && pointer !== root)\n     return dfs(pointer.right)+1\n    if(pointer.right === null && pointer !== root )\n     return dfs(pointer.left)+1\n  \n  if(pointer === root)\n return dfs(pointer.left) + dfs(pointer.right)\n  else  \n   return Math.max(dfs(pointer.left),dfs(pointer.right))+1   \n\n}\n"
                    },
                    {
                        "username": "jchoubankai",
                        "content": "This question\\'s implementation strategy is literally equivalent to \"Binary Tree Maximum Path Sum\", which is a hard level question lmao"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "This ques made me realize the importance of pointers and references because my dumbass wasnt referencing to the global result var\\uD83D\\uDC80"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "The goal of this challenge is to determine the ``maximum diameter`` of a binary tree. The Max-Diameter can travel through the ``root`` node or be wholly within the ``left`` or ``right`` subtree.  Discoverthe Maximum diameter of the entire binary tree and returns it as a result by computing the height and diameter for each subtree.\n\n``Here is the Recursive Implementation ( O(n) ) with Detailed explanation :``\nhttps://leetcode.com/problems/diameter-of-binary-tree/solutions/3859558/recursion-o-n-beats-99-91-runtimes-with-detailed-explanation/"
                    }
                ]
            },
            {
                "id": 2073736,
                "content": [
                    {
                        "username": "gustring",
                        "content": "Is this actually possible?"
                    },
                    {
                        "username": "nilesmac",
                        "content": "This is one of the harder tree problems I\\'ve come across. There are tree problems marked hard that I find easier."
                    },
                    {
                        "username": "aftabmk",
                        "content": "Best part of this question is that if we add root->val instead of 1 in each recursion then we can solve maxPath sum which is marked as hard. maybe they should mark this as \"hardly\" easy."
                    },
                    {
                        "username": "Dxmaptin",
                        "content": "I think it is better to first try max depth of binary tree before coming on this problem"
                    },
                    {
                        "username": "Dipankar0007",
                        "content": "how this is easy?\\uD83E\\uDD28"
                    },
                    {
                        "username": "michaelscheinfeild",
                        "content": "i have [2,3,null,1]  , how i treat null python dont know this"
                    },
                    {
                        "username": "itmevic",
                        "content": "I do no see how the answer is length 8 for this case, the longest path(# of edges) between 2 nodes that I can find is only 7,\ncan please anyone tell me whats wrong with my code with this case: [4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]\n\n\nMY CODE: \n\n var diameterOfBinaryTree = function(root) {\n    \n   if(root.left === null & root.right === null)\n   return 0\n         \n   let pointer = root \n   return dfs(root,pointer)\n}\n\n\nfunction dfs(pointer,root){\n\n    if(!pointer)\n     return 0\n     \n    if(!pointer.left && !pointer.right) \n      return 1\n\n    if(pointer.left === null && pointer !== root)\n     return dfs(pointer.right)+1\n    if(pointer.right === null && pointer !== root )\n     return dfs(pointer.left)+1\n  \n  if(pointer === root)\n return dfs(pointer.left) + dfs(pointer.right)\n  else  \n   return Math.max(dfs(pointer.left),dfs(pointer.right))+1   \n\n}\n"
                    },
                    {
                        "username": "jchoubankai",
                        "content": "This question\\'s implementation strategy is literally equivalent to \"Binary Tree Maximum Path Sum\", which is a hard level question lmao"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "This ques made me realize the importance of pointers and references because my dumbass wasnt referencing to the global result var\\uD83D\\uDC80"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "The goal of this challenge is to determine the ``maximum diameter`` of a binary tree. The Max-Diameter can travel through the ``root`` node or be wholly within the ``left`` or ``right`` subtree.  Discoverthe Maximum diameter of the entire binary tree and returns it as a result by computing the height and diameter for each subtree.\n\n``Here is the Recursive Implementation ( O(n) ) with Detailed explanation :``\nhttps://leetcode.com/problems/diameter-of-binary-tree/solutions/3859558/recursion-o-n-beats-99-91-runtimes-with-detailed-explanation/"
                    }
                ]
            },
            {
                "id": 2064763,
                "content": [
                    {
                        "username": "gustring",
                        "content": "Is this actually possible?"
                    },
                    {
                        "username": "nilesmac",
                        "content": "This is one of the harder tree problems I\\'ve come across. There are tree problems marked hard that I find easier."
                    },
                    {
                        "username": "aftabmk",
                        "content": "Best part of this question is that if we add root->val instead of 1 in each recursion then we can solve maxPath sum which is marked as hard. maybe they should mark this as \"hardly\" easy."
                    },
                    {
                        "username": "Dxmaptin",
                        "content": "I think it is better to first try max depth of binary tree before coming on this problem"
                    },
                    {
                        "username": "Dipankar0007",
                        "content": "how this is easy?\\uD83E\\uDD28"
                    },
                    {
                        "username": "michaelscheinfeild",
                        "content": "i have [2,3,null,1]  , how i treat null python dont know this"
                    },
                    {
                        "username": "itmevic",
                        "content": "I do no see how the answer is length 8 for this case, the longest path(# of edges) between 2 nodes that I can find is only 7,\ncan please anyone tell me whats wrong with my code with this case: [4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]\n\n\nMY CODE: \n\n var diameterOfBinaryTree = function(root) {\n    \n   if(root.left === null & root.right === null)\n   return 0\n         \n   let pointer = root \n   return dfs(root,pointer)\n}\n\n\nfunction dfs(pointer,root){\n\n    if(!pointer)\n     return 0\n     \n    if(!pointer.left && !pointer.right) \n      return 1\n\n    if(pointer.left === null && pointer !== root)\n     return dfs(pointer.right)+1\n    if(pointer.right === null && pointer !== root )\n     return dfs(pointer.left)+1\n  \n  if(pointer === root)\n return dfs(pointer.left) + dfs(pointer.right)\n  else  \n   return Math.max(dfs(pointer.left),dfs(pointer.right))+1   \n\n}\n"
                    },
                    {
                        "username": "jchoubankai",
                        "content": "This question\\'s implementation strategy is literally equivalent to \"Binary Tree Maximum Path Sum\", which is a hard level question lmao"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "This ques made me realize the importance of pointers and references because my dumbass wasnt referencing to the global result var\\uD83D\\uDC80"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "The goal of this challenge is to determine the ``maximum diameter`` of a binary tree. The Max-Diameter can travel through the ``root`` node or be wholly within the ``left`` or ``right`` subtree.  Discoverthe Maximum diameter of the entire binary tree and returns it as a result by computing the height and diameter for each subtree.\n\n``Here is the Recursive Implementation ( O(n) ) with Detailed explanation :``\nhttps://leetcode.com/problems/diameter-of-binary-tree/solutions/3859558/recursion-o-n-beats-99-91-runtimes-with-detailed-explanation/"
                    }
                ]
            },
            {
                "id": 2058593,
                "content": [
                    {
                        "username": "gustring",
                        "content": "Is this actually possible?"
                    },
                    {
                        "username": "nilesmac",
                        "content": "This is one of the harder tree problems I\\'ve come across. There are tree problems marked hard that I find easier."
                    },
                    {
                        "username": "aftabmk",
                        "content": "Best part of this question is that if we add root->val instead of 1 in each recursion then we can solve maxPath sum which is marked as hard. maybe they should mark this as \"hardly\" easy."
                    },
                    {
                        "username": "Dxmaptin",
                        "content": "I think it is better to first try max depth of binary tree before coming on this problem"
                    },
                    {
                        "username": "Dipankar0007",
                        "content": "how this is easy?\\uD83E\\uDD28"
                    },
                    {
                        "username": "michaelscheinfeild",
                        "content": "i have [2,3,null,1]  , how i treat null python dont know this"
                    },
                    {
                        "username": "itmevic",
                        "content": "I do no see how the answer is length 8 for this case, the longest path(# of edges) between 2 nodes that I can find is only 7,\ncan please anyone tell me whats wrong with my code with this case: [4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]\n\n\nMY CODE: \n\n var diameterOfBinaryTree = function(root) {\n    \n   if(root.left === null & root.right === null)\n   return 0\n         \n   let pointer = root \n   return dfs(root,pointer)\n}\n\n\nfunction dfs(pointer,root){\n\n    if(!pointer)\n     return 0\n     \n    if(!pointer.left && !pointer.right) \n      return 1\n\n    if(pointer.left === null && pointer !== root)\n     return dfs(pointer.right)+1\n    if(pointer.right === null && pointer !== root )\n     return dfs(pointer.left)+1\n  \n  if(pointer === root)\n return dfs(pointer.left) + dfs(pointer.right)\n  else  \n   return Math.max(dfs(pointer.left),dfs(pointer.right))+1   \n\n}\n"
                    },
                    {
                        "username": "jchoubankai",
                        "content": "This question\\'s implementation strategy is literally equivalent to \"Binary Tree Maximum Path Sum\", which is a hard level question lmao"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "This ques made me realize the importance of pointers and references because my dumbass wasnt referencing to the global result var\\uD83D\\uDC80"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "The goal of this challenge is to determine the ``maximum diameter`` of a binary tree. The Max-Diameter can travel through the ``root`` node or be wholly within the ``left`` or ``right`` subtree.  Discoverthe Maximum diameter of the entire binary tree and returns it as a result by computing the height and diameter for each subtree.\n\n``Here is the Recursive Implementation ( O(n) ) with Detailed explanation :``\nhttps://leetcode.com/problems/diameter-of-binary-tree/solutions/3859558/recursion-o-n-beats-99-91-runtimes-with-detailed-explanation/"
                    }
                ]
            },
            {
                "id": 2057684,
                "content": [
                    {
                        "username": "gustring",
                        "content": "Is this actually possible?"
                    },
                    {
                        "username": "nilesmac",
                        "content": "This is one of the harder tree problems I\\'ve come across. There are tree problems marked hard that I find easier."
                    },
                    {
                        "username": "aftabmk",
                        "content": "Best part of this question is that if we add root->val instead of 1 in each recursion then we can solve maxPath sum which is marked as hard. maybe they should mark this as \"hardly\" easy."
                    },
                    {
                        "username": "Dxmaptin",
                        "content": "I think it is better to first try max depth of binary tree before coming on this problem"
                    },
                    {
                        "username": "Dipankar0007",
                        "content": "how this is easy?\\uD83E\\uDD28"
                    },
                    {
                        "username": "michaelscheinfeild",
                        "content": "i have [2,3,null,1]  , how i treat null python dont know this"
                    },
                    {
                        "username": "itmevic",
                        "content": "I do no see how the answer is length 8 for this case, the longest path(# of edges) between 2 nodes that I can find is only 7,\ncan please anyone tell me whats wrong with my code with this case: [4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]\n\n\nMY CODE: \n\n var diameterOfBinaryTree = function(root) {\n    \n   if(root.left === null & root.right === null)\n   return 0\n         \n   let pointer = root \n   return dfs(root,pointer)\n}\n\n\nfunction dfs(pointer,root){\n\n    if(!pointer)\n     return 0\n     \n    if(!pointer.left && !pointer.right) \n      return 1\n\n    if(pointer.left === null && pointer !== root)\n     return dfs(pointer.right)+1\n    if(pointer.right === null && pointer !== root )\n     return dfs(pointer.left)+1\n  \n  if(pointer === root)\n return dfs(pointer.left) + dfs(pointer.right)\n  else  \n   return Math.max(dfs(pointer.left),dfs(pointer.right))+1   \n\n}\n"
                    },
                    {
                        "username": "jchoubankai",
                        "content": "This question\\'s implementation strategy is literally equivalent to \"Binary Tree Maximum Path Sum\", which is a hard level question lmao"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "This ques made me realize the importance of pointers and references because my dumbass wasnt referencing to the global result var\\uD83D\\uDC80"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "The goal of this challenge is to determine the ``maximum diameter`` of a binary tree. The Max-Diameter can travel through the ``root`` node or be wholly within the ``left`` or ``right`` subtree.  Discoverthe Maximum diameter of the entire binary tree and returns it as a result by computing the height and diameter for each subtree.\n\n``Here is the Recursive Implementation ( O(n) ) with Detailed explanation :``\nhttps://leetcode.com/problems/diameter-of-binary-tree/solutions/3859558/recursion-o-n-beats-99-91-runtimes-with-detailed-explanation/"
                    }
                ]
            },
            {
                "id": 2049412,
                "content": [
                    {
                        "username": "gustring",
                        "content": "Is this actually possible?"
                    },
                    {
                        "username": "nilesmac",
                        "content": "This is one of the harder tree problems I\\'ve come across. There are tree problems marked hard that I find easier."
                    },
                    {
                        "username": "aftabmk",
                        "content": "Best part of this question is that if we add root->val instead of 1 in each recursion then we can solve maxPath sum which is marked as hard. maybe they should mark this as \"hardly\" easy."
                    },
                    {
                        "username": "Dxmaptin",
                        "content": "I think it is better to first try max depth of binary tree before coming on this problem"
                    },
                    {
                        "username": "Dipankar0007",
                        "content": "how this is easy?\\uD83E\\uDD28"
                    },
                    {
                        "username": "michaelscheinfeild",
                        "content": "i have [2,3,null,1]  , how i treat null python dont know this"
                    },
                    {
                        "username": "itmevic",
                        "content": "I do no see how the answer is length 8 for this case, the longest path(# of edges) between 2 nodes that I can find is only 7,\ncan please anyone tell me whats wrong with my code with this case: [4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]\n\n\nMY CODE: \n\n var diameterOfBinaryTree = function(root) {\n    \n   if(root.left === null & root.right === null)\n   return 0\n         \n   let pointer = root \n   return dfs(root,pointer)\n}\n\n\nfunction dfs(pointer,root){\n\n    if(!pointer)\n     return 0\n     \n    if(!pointer.left && !pointer.right) \n      return 1\n\n    if(pointer.left === null && pointer !== root)\n     return dfs(pointer.right)+1\n    if(pointer.right === null && pointer !== root )\n     return dfs(pointer.left)+1\n  \n  if(pointer === root)\n return dfs(pointer.left) + dfs(pointer.right)\n  else  \n   return Math.max(dfs(pointer.left),dfs(pointer.right))+1   \n\n}\n"
                    },
                    {
                        "username": "jchoubankai",
                        "content": "This question\\'s implementation strategy is literally equivalent to \"Binary Tree Maximum Path Sum\", which is a hard level question lmao"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "This ques made me realize the importance of pointers and references because my dumbass wasnt referencing to the global result var\\uD83D\\uDC80"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "The goal of this challenge is to determine the ``maximum diameter`` of a binary tree. The Max-Diameter can travel through the ``root`` node or be wholly within the ``left`` or ``right`` subtree.  Discoverthe Maximum diameter of the entire binary tree and returns it as a result by computing the height and diameter for each subtree.\n\n``Here is the Recursive Implementation ( O(n) ) with Detailed explanation :``\nhttps://leetcode.com/problems/diameter-of-binary-tree/solutions/3859558/recursion-o-n-beats-99-91-runtimes-with-detailed-explanation/"
                    }
                ]
            },
            {
                "id": 2026329,
                "content": [
                    {
                        "username": "gustring",
                        "content": "Is this actually possible?"
                    },
                    {
                        "username": "nilesmac",
                        "content": "This is one of the harder tree problems I\\'ve come across. There are tree problems marked hard that I find easier."
                    },
                    {
                        "username": "aftabmk",
                        "content": "Best part of this question is that if we add root->val instead of 1 in each recursion then we can solve maxPath sum which is marked as hard. maybe they should mark this as \"hardly\" easy."
                    },
                    {
                        "username": "Dxmaptin",
                        "content": "I think it is better to first try max depth of binary tree before coming on this problem"
                    },
                    {
                        "username": "Dipankar0007",
                        "content": "how this is easy?\\uD83E\\uDD28"
                    },
                    {
                        "username": "michaelscheinfeild",
                        "content": "i have [2,3,null,1]  , how i treat null python dont know this"
                    },
                    {
                        "username": "itmevic",
                        "content": "I do no see how the answer is length 8 for this case, the longest path(# of edges) between 2 nodes that I can find is only 7,\ncan please anyone tell me whats wrong with my code with this case: [4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]\n\n\nMY CODE: \n\n var diameterOfBinaryTree = function(root) {\n    \n   if(root.left === null & root.right === null)\n   return 0\n         \n   let pointer = root \n   return dfs(root,pointer)\n}\n\n\nfunction dfs(pointer,root){\n\n    if(!pointer)\n     return 0\n     \n    if(!pointer.left && !pointer.right) \n      return 1\n\n    if(pointer.left === null && pointer !== root)\n     return dfs(pointer.right)+1\n    if(pointer.right === null && pointer !== root )\n     return dfs(pointer.left)+1\n  \n  if(pointer === root)\n return dfs(pointer.left) + dfs(pointer.right)\n  else  \n   return Math.max(dfs(pointer.left),dfs(pointer.right))+1   \n\n}\n"
                    },
                    {
                        "username": "jchoubankai",
                        "content": "This question\\'s implementation strategy is literally equivalent to \"Binary Tree Maximum Path Sum\", which is a hard level question lmao"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "This ques made me realize the importance of pointers and references because my dumbass wasnt referencing to the global result var\\uD83D\\uDC80"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "The goal of this challenge is to determine the ``maximum diameter`` of a binary tree. The Max-Diameter can travel through the ``root`` node or be wholly within the ``left`` or ``right`` subtree.  Discoverthe Maximum diameter of the entire binary tree and returns it as a result by computing the height and diameter for each subtree.\n\n``Here is the Recursive Implementation ( O(n) ) with Detailed explanation :``\nhttps://leetcode.com/problems/diameter-of-binary-tree/solutions/3859558/recursion-o-n-beats-99-91-runtimes-with-detailed-explanation/"
                    }
                ]
            },
            {
                "id": 2014497,
                "content": [
                    {
                        "username": "gustring",
                        "content": "Is this actually possible?"
                    },
                    {
                        "username": "nilesmac",
                        "content": "This is one of the harder tree problems I\\'ve come across. There are tree problems marked hard that I find easier."
                    },
                    {
                        "username": "aftabmk",
                        "content": "Best part of this question is that if we add root->val instead of 1 in each recursion then we can solve maxPath sum which is marked as hard. maybe they should mark this as \"hardly\" easy."
                    },
                    {
                        "username": "Dxmaptin",
                        "content": "I think it is better to first try max depth of binary tree before coming on this problem"
                    },
                    {
                        "username": "Dipankar0007",
                        "content": "how this is easy?\\uD83E\\uDD28"
                    },
                    {
                        "username": "michaelscheinfeild",
                        "content": "i have [2,3,null,1]  , how i treat null python dont know this"
                    },
                    {
                        "username": "itmevic",
                        "content": "I do no see how the answer is length 8 for this case, the longest path(# of edges) between 2 nodes that I can find is only 7,\ncan please anyone tell me whats wrong with my code with this case: [4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]\n\n\nMY CODE: \n\n var diameterOfBinaryTree = function(root) {\n    \n   if(root.left === null & root.right === null)\n   return 0\n         \n   let pointer = root \n   return dfs(root,pointer)\n}\n\n\nfunction dfs(pointer,root){\n\n    if(!pointer)\n     return 0\n     \n    if(!pointer.left && !pointer.right) \n      return 1\n\n    if(pointer.left === null && pointer !== root)\n     return dfs(pointer.right)+1\n    if(pointer.right === null && pointer !== root )\n     return dfs(pointer.left)+1\n  \n  if(pointer === root)\n return dfs(pointer.left) + dfs(pointer.right)\n  else  \n   return Math.max(dfs(pointer.left),dfs(pointer.right))+1   \n\n}\n"
                    },
                    {
                        "username": "jchoubankai",
                        "content": "This question\\'s implementation strategy is literally equivalent to \"Binary Tree Maximum Path Sum\", which is a hard level question lmao"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "This ques made me realize the importance of pointers and references because my dumbass wasnt referencing to the global result var\\uD83D\\uDC80"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "The goal of this challenge is to determine the ``maximum diameter`` of a binary tree. The Max-Diameter can travel through the ``root`` node or be wholly within the ``left`` or ``right`` subtree.  Discoverthe Maximum diameter of the entire binary tree and returns it as a result by computing the height and diameter for each subtree.\n\n``Here is the Recursive Implementation ( O(n) ) with Detailed explanation :``\nhttps://leetcode.com/problems/diameter-of-binary-tree/solutions/3859558/recursion-o-n-beats-99-91-runtimes-with-detailed-explanation/"
                    }
                ]
            },
            {
                "id": 2012096,
                "content": [
                    {
                        "username": "gustring",
                        "content": "Is this actually possible?"
                    },
                    {
                        "username": "nilesmac",
                        "content": "This is one of the harder tree problems I\\'ve come across. There are tree problems marked hard that I find easier."
                    },
                    {
                        "username": "aftabmk",
                        "content": "Best part of this question is that if we add root->val instead of 1 in each recursion then we can solve maxPath sum which is marked as hard. maybe they should mark this as \"hardly\" easy."
                    },
                    {
                        "username": "Dxmaptin",
                        "content": "I think it is better to first try max depth of binary tree before coming on this problem"
                    },
                    {
                        "username": "Dipankar0007",
                        "content": "how this is easy?\\uD83E\\uDD28"
                    },
                    {
                        "username": "michaelscheinfeild",
                        "content": "i have [2,3,null,1]  , how i treat null python dont know this"
                    },
                    {
                        "username": "itmevic",
                        "content": "I do no see how the answer is length 8 for this case, the longest path(# of edges) between 2 nodes that I can find is only 7,\ncan please anyone tell me whats wrong with my code with this case: [4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]\n\n\nMY CODE: \n\n var diameterOfBinaryTree = function(root) {\n    \n   if(root.left === null & root.right === null)\n   return 0\n         \n   let pointer = root \n   return dfs(root,pointer)\n}\n\n\nfunction dfs(pointer,root){\n\n    if(!pointer)\n     return 0\n     \n    if(!pointer.left && !pointer.right) \n      return 1\n\n    if(pointer.left === null && pointer !== root)\n     return dfs(pointer.right)+1\n    if(pointer.right === null && pointer !== root )\n     return dfs(pointer.left)+1\n  \n  if(pointer === root)\n return dfs(pointer.left) + dfs(pointer.right)\n  else  \n   return Math.max(dfs(pointer.left),dfs(pointer.right))+1   \n\n}\n"
                    },
                    {
                        "username": "jchoubankai",
                        "content": "This question\\'s implementation strategy is literally equivalent to \"Binary Tree Maximum Path Sum\", which is a hard level question lmao"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "This ques made me realize the importance of pointers and references because my dumbass wasnt referencing to the global result var\\uD83D\\uDC80"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "The goal of this challenge is to determine the ``maximum diameter`` of a binary tree. The Max-Diameter can travel through the ``root`` node or be wholly within the ``left`` or ``right`` subtree.  Discoverthe Maximum diameter of the entire binary tree and returns it as a result by computing the height and diameter for each subtree.\n\n``Here is the Recursive Implementation ( O(n) ) with Detailed explanation :``\nhttps://leetcode.com/problems/diameter-of-binary-tree/solutions/3859558/recursion-o-n-beats-99-91-runtimes-with-detailed-explanation/"
                    }
                ]
            },
            {
                "id": 1998893,
                "content": [
                    {
                        "username": "gustring",
                        "content": "Is this actually possible?"
                    },
                    {
                        "username": "nilesmac",
                        "content": "This is one of the harder tree problems I\\'ve come across. There are tree problems marked hard that I find easier."
                    },
                    {
                        "username": "aftabmk",
                        "content": "Best part of this question is that if we add root->val instead of 1 in each recursion then we can solve maxPath sum which is marked as hard. maybe they should mark this as \"hardly\" easy."
                    },
                    {
                        "username": "Dxmaptin",
                        "content": "I think it is better to first try max depth of binary tree before coming on this problem"
                    },
                    {
                        "username": "Dipankar0007",
                        "content": "how this is easy?\\uD83E\\uDD28"
                    },
                    {
                        "username": "michaelscheinfeild",
                        "content": "i have [2,3,null,1]  , how i treat null python dont know this"
                    },
                    {
                        "username": "itmevic",
                        "content": "I do no see how the answer is length 8 for this case, the longest path(# of edges) between 2 nodes that I can find is only 7,\ncan please anyone tell me whats wrong with my code with this case: [4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]\n\n\nMY CODE: \n\n var diameterOfBinaryTree = function(root) {\n    \n   if(root.left === null & root.right === null)\n   return 0\n         \n   let pointer = root \n   return dfs(root,pointer)\n}\n\n\nfunction dfs(pointer,root){\n\n    if(!pointer)\n     return 0\n     \n    if(!pointer.left && !pointer.right) \n      return 1\n\n    if(pointer.left === null && pointer !== root)\n     return dfs(pointer.right)+1\n    if(pointer.right === null && pointer !== root )\n     return dfs(pointer.left)+1\n  \n  if(pointer === root)\n return dfs(pointer.left) + dfs(pointer.right)\n  else  \n   return Math.max(dfs(pointer.left),dfs(pointer.right))+1   \n\n}\n"
                    },
                    {
                        "username": "jchoubankai",
                        "content": "This question\\'s implementation strategy is literally equivalent to \"Binary Tree Maximum Path Sum\", which is a hard level question lmao"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "This ques made me realize the importance of pointers and references because my dumbass wasnt referencing to the global result var\\uD83D\\uDC80"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "The goal of this challenge is to determine the ``maximum diameter`` of a binary tree. The Max-Diameter can travel through the ``root`` node or be wholly within the ``left`` or ``right`` subtree.  Discoverthe Maximum diameter of the entire binary tree and returns it as a result by computing the height and diameter for each subtree.\n\n``Here is the Recursive Implementation ( O(n) ) with Detailed explanation :``\nhttps://leetcode.com/problems/diameter-of-binary-tree/solutions/3859558/recursion-o-n-beats-99-91-runtimes-with-detailed-explanation/"
                    }
                ]
            },
            {
                "id": 1986255,
                "content": [
                    {
                        "username": "chris_1101",
                        "content": "Who in their right mind tagged this easy."
                    },
                    {
                        "username": "nekoaoi",
                        "content": "you have to be really high to mark this as easy."
                    },
                    {
                        "username": "suraj21209",
                        "content": "It\\'s easy to maintain another variable and update it at each node. It might help you - https://leetcode.com/problems/diameter-of-binary-tree/submissions/995832822/"
                    },
                    {
                        "username": "oops_moment",
                        "content": "CHANGE THE DIFFICULTY PLEASE. IT\\'S NOT EASY."
                    },
                    {
                        "username": "trinesh14kumar",
                        "content": "what if the value in root is single then what we should \\n return?"
                    },
                    {
                        "username": "DKarneckij",
                        "content": "Medium for sure"
                    },
                    {
                        "username": "yuxiaohu",
                        "content": "Attention: Test case #91 contains several nodes with the same value 3, which may not be expected in some solutions, if they use node value to identify different nodes. (see Node #12 and #17 below, and there are more node=3 if you continue)\\nroot =\\n[-64,12,18,-4,-53,null,76,null,-51,null,null,-93,3,null,-31,47,null,3,53,-81,33,4,null,-51,-44,-60,11,null,null,null,null,78,null,-35,-64,26,-81,-31,27,60,74,null,null,8,-38,47,12,-24,null,-59,-49,-11,-51,67,null,null,null,null,null,null,null,-67,null,-37,-19,10,-55,72,null,null,null,-70,17,-4,null,null,null,null,null,null,null,3,80,44,-88,-91,null,48,-90,-30,null,null,90,-34,37,null,null,73,-38,-31,-85,-31,-96,null,null,-18,67,34,72,null,-17,-77,null,56,-65,-88,-53,null,null,null,-33,86,null,81,-42,null,null,98,-40,70,-26,24,null,null,null,null,92,72,-27,null,null,null,null,null,null,-67,null,null,null,null,null,null,null,-54,-66,-36,null,-72,null,null,43,null,null,null,-92,-1,-98,null,null,null,null,null,null,null,39,-84,null,null,null,null,null,null,null,null,null,null,null,null,null,-93,null,null,null,98] "
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Hint:\\nAt every subtree find the sum of deepest left & deepest right path from root node of subtree. \\nMaximum of above would be the answer."
                    },
                    {
                        "username": "jpecoraro342",
                        "content": "Hint: You can calculate/return both the diameter, and depth at the same time"
                    },
                    {
                        "username": "arf01",
                        "content": "class Solution {\\npublic:\\n\\n \\n\\n     int maxDepth(TreeNode* root) {\\n        if (root==NULL) return 0; \\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int depth=0;\\n        \\n        while (!q.empty()) {\\n            ++depth;\\n            int s=q.size();\\n            for (int i=0; i<s; i++) {\\n                TreeNode* front=q.front();\\n                q.pop();\\n                \\n                if (front->left) q.push(front->left);\\n                if (front->right) q.push(front->right);\\n            }\\n        }\\n    return depth;\\n    }\\n\\n\\n       void dfs(TreeNode*root, vector<TreeNode*>&v)\\n       {\\n             if(root==nullptr) return;\\n\\n             v.push_back(root);\\n             dfs(root->left,v);\\n             dfs(root->right,v);\\n       }\\n  \\n    int diameterOfBinaryTree(TreeNode* root) {\\n        int ans =0;\\n        vector<TreeNode *>v;\\n        dfs(root,v);\\n\\n\\n          for(auto it:v)\\n          {\\n             int k= maxDepth(it);\\n             ans=max(ans,k);\\n          }\\n          return ans;\\n    }\\n\\n\\n};    whats wrong in this solution"
                    },
                    {
                        "username": "mauro23",
                        "content": "This problem is only easy if you already know how to do it"
                    }
                ]
            },
            {
                "id": 1985633,
                "content": [
                    {
                        "username": "chris_1101",
                        "content": "Who in their right mind tagged this easy."
                    },
                    {
                        "username": "nekoaoi",
                        "content": "you have to be really high to mark this as easy."
                    },
                    {
                        "username": "suraj21209",
                        "content": "It\\'s easy to maintain another variable and update it at each node. It might help you - https://leetcode.com/problems/diameter-of-binary-tree/submissions/995832822/"
                    },
                    {
                        "username": "oops_moment",
                        "content": "CHANGE THE DIFFICULTY PLEASE. IT\\'S NOT EASY."
                    },
                    {
                        "username": "trinesh14kumar",
                        "content": "what if the value in root is single then what we should \\n return?"
                    },
                    {
                        "username": "DKarneckij",
                        "content": "Medium for sure"
                    },
                    {
                        "username": "yuxiaohu",
                        "content": "Attention: Test case #91 contains several nodes with the same value 3, which may not be expected in some solutions, if they use node value to identify different nodes. (see Node #12 and #17 below, and there are more node=3 if you continue)\\nroot =\\n[-64,12,18,-4,-53,null,76,null,-51,null,null,-93,3,null,-31,47,null,3,53,-81,33,4,null,-51,-44,-60,11,null,null,null,null,78,null,-35,-64,26,-81,-31,27,60,74,null,null,8,-38,47,12,-24,null,-59,-49,-11,-51,67,null,null,null,null,null,null,null,-67,null,-37,-19,10,-55,72,null,null,null,-70,17,-4,null,null,null,null,null,null,null,3,80,44,-88,-91,null,48,-90,-30,null,null,90,-34,37,null,null,73,-38,-31,-85,-31,-96,null,null,-18,67,34,72,null,-17,-77,null,56,-65,-88,-53,null,null,null,-33,86,null,81,-42,null,null,98,-40,70,-26,24,null,null,null,null,92,72,-27,null,null,null,null,null,null,-67,null,null,null,null,null,null,null,-54,-66,-36,null,-72,null,null,43,null,null,null,-92,-1,-98,null,null,null,null,null,null,null,39,-84,null,null,null,null,null,null,null,null,null,null,null,null,null,-93,null,null,null,98] "
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Hint:\\nAt every subtree find the sum of deepest left & deepest right path from root node of subtree. \\nMaximum of above would be the answer."
                    },
                    {
                        "username": "jpecoraro342",
                        "content": "Hint: You can calculate/return both the diameter, and depth at the same time"
                    },
                    {
                        "username": "arf01",
                        "content": "class Solution {\\npublic:\\n\\n \\n\\n     int maxDepth(TreeNode* root) {\\n        if (root==NULL) return 0; \\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int depth=0;\\n        \\n        while (!q.empty()) {\\n            ++depth;\\n            int s=q.size();\\n            for (int i=0; i<s; i++) {\\n                TreeNode* front=q.front();\\n                q.pop();\\n                \\n                if (front->left) q.push(front->left);\\n                if (front->right) q.push(front->right);\\n            }\\n        }\\n    return depth;\\n    }\\n\\n\\n       void dfs(TreeNode*root, vector<TreeNode*>&v)\\n       {\\n             if(root==nullptr) return;\\n\\n             v.push_back(root);\\n             dfs(root->left,v);\\n             dfs(root->right,v);\\n       }\\n  \\n    int diameterOfBinaryTree(TreeNode* root) {\\n        int ans =0;\\n        vector<TreeNode *>v;\\n        dfs(root,v);\\n\\n\\n          for(auto it:v)\\n          {\\n             int k= maxDepth(it);\\n             ans=max(ans,k);\\n          }\\n          return ans;\\n    }\\n\\n\\n};    whats wrong in this solution"
                    },
                    {
                        "username": "mauro23",
                        "content": "This problem is only easy if you already know how to do it"
                    }
                ]
            },
            {
                "id": 1980733,
                "content": [
                    {
                        "username": "chris_1101",
                        "content": "Who in their right mind tagged this easy."
                    },
                    {
                        "username": "nekoaoi",
                        "content": "you have to be really high to mark this as easy."
                    },
                    {
                        "username": "suraj21209",
                        "content": "It\\'s easy to maintain another variable and update it at each node. It might help you - https://leetcode.com/problems/diameter-of-binary-tree/submissions/995832822/"
                    },
                    {
                        "username": "oops_moment",
                        "content": "CHANGE THE DIFFICULTY PLEASE. IT\\'S NOT EASY."
                    },
                    {
                        "username": "trinesh14kumar",
                        "content": "what if the value in root is single then what we should \\n return?"
                    },
                    {
                        "username": "DKarneckij",
                        "content": "Medium for sure"
                    },
                    {
                        "username": "yuxiaohu",
                        "content": "Attention: Test case #91 contains several nodes with the same value 3, which may not be expected in some solutions, if they use node value to identify different nodes. (see Node #12 and #17 below, and there are more node=3 if you continue)\\nroot =\\n[-64,12,18,-4,-53,null,76,null,-51,null,null,-93,3,null,-31,47,null,3,53,-81,33,4,null,-51,-44,-60,11,null,null,null,null,78,null,-35,-64,26,-81,-31,27,60,74,null,null,8,-38,47,12,-24,null,-59,-49,-11,-51,67,null,null,null,null,null,null,null,-67,null,-37,-19,10,-55,72,null,null,null,-70,17,-4,null,null,null,null,null,null,null,3,80,44,-88,-91,null,48,-90,-30,null,null,90,-34,37,null,null,73,-38,-31,-85,-31,-96,null,null,-18,67,34,72,null,-17,-77,null,56,-65,-88,-53,null,null,null,-33,86,null,81,-42,null,null,98,-40,70,-26,24,null,null,null,null,92,72,-27,null,null,null,null,null,null,-67,null,null,null,null,null,null,null,-54,-66,-36,null,-72,null,null,43,null,null,null,-92,-1,-98,null,null,null,null,null,null,null,39,-84,null,null,null,null,null,null,null,null,null,null,null,null,null,-93,null,null,null,98] "
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Hint:\\nAt every subtree find the sum of deepest left & deepest right path from root node of subtree. \\nMaximum of above would be the answer."
                    },
                    {
                        "username": "jpecoraro342",
                        "content": "Hint: You can calculate/return both the diameter, and depth at the same time"
                    },
                    {
                        "username": "arf01",
                        "content": "class Solution {\\npublic:\\n\\n \\n\\n     int maxDepth(TreeNode* root) {\\n        if (root==NULL) return 0; \\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int depth=0;\\n        \\n        while (!q.empty()) {\\n            ++depth;\\n            int s=q.size();\\n            for (int i=0; i<s; i++) {\\n                TreeNode* front=q.front();\\n                q.pop();\\n                \\n                if (front->left) q.push(front->left);\\n                if (front->right) q.push(front->right);\\n            }\\n        }\\n    return depth;\\n    }\\n\\n\\n       void dfs(TreeNode*root, vector<TreeNode*>&v)\\n       {\\n             if(root==nullptr) return;\\n\\n             v.push_back(root);\\n             dfs(root->left,v);\\n             dfs(root->right,v);\\n       }\\n  \\n    int diameterOfBinaryTree(TreeNode* root) {\\n        int ans =0;\\n        vector<TreeNode *>v;\\n        dfs(root,v);\\n\\n\\n          for(auto it:v)\\n          {\\n             int k= maxDepth(it);\\n             ans=max(ans,k);\\n          }\\n          return ans;\\n    }\\n\\n\\n};    whats wrong in this solution"
                    },
                    {
                        "username": "mauro23",
                        "content": "This problem is only easy if you already know how to do it"
                    }
                ]
            },
            {
                "id": 1976713,
                "content": [
                    {
                        "username": "chris_1101",
                        "content": "Who in their right mind tagged this easy."
                    },
                    {
                        "username": "nekoaoi",
                        "content": "you have to be really high to mark this as easy."
                    },
                    {
                        "username": "suraj21209",
                        "content": "It\\'s easy to maintain another variable and update it at each node. It might help you - https://leetcode.com/problems/diameter-of-binary-tree/submissions/995832822/"
                    },
                    {
                        "username": "oops_moment",
                        "content": "CHANGE THE DIFFICULTY PLEASE. IT\\'S NOT EASY."
                    },
                    {
                        "username": "trinesh14kumar",
                        "content": "what if the value in root is single then what we should \\n return?"
                    },
                    {
                        "username": "DKarneckij",
                        "content": "Medium for sure"
                    },
                    {
                        "username": "yuxiaohu",
                        "content": "Attention: Test case #91 contains several nodes with the same value 3, which may not be expected in some solutions, if they use node value to identify different nodes. (see Node #12 and #17 below, and there are more node=3 if you continue)\\nroot =\\n[-64,12,18,-4,-53,null,76,null,-51,null,null,-93,3,null,-31,47,null,3,53,-81,33,4,null,-51,-44,-60,11,null,null,null,null,78,null,-35,-64,26,-81,-31,27,60,74,null,null,8,-38,47,12,-24,null,-59,-49,-11,-51,67,null,null,null,null,null,null,null,-67,null,-37,-19,10,-55,72,null,null,null,-70,17,-4,null,null,null,null,null,null,null,3,80,44,-88,-91,null,48,-90,-30,null,null,90,-34,37,null,null,73,-38,-31,-85,-31,-96,null,null,-18,67,34,72,null,-17,-77,null,56,-65,-88,-53,null,null,null,-33,86,null,81,-42,null,null,98,-40,70,-26,24,null,null,null,null,92,72,-27,null,null,null,null,null,null,-67,null,null,null,null,null,null,null,-54,-66,-36,null,-72,null,null,43,null,null,null,-92,-1,-98,null,null,null,null,null,null,null,39,-84,null,null,null,null,null,null,null,null,null,null,null,null,null,-93,null,null,null,98] "
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Hint:\\nAt every subtree find the sum of deepest left & deepest right path from root node of subtree. \\nMaximum of above would be the answer."
                    },
                    {
                        "username": "jpecoraro342",
                        "content": "Hint: You can calculate/return both the diameter, and depth at the same time"
                    },
                    {
                        "username": "arf01",
                        "content": "class Solution {\\npublic:\\n\\n \\n\\n     int maxDepth(TreeNode* root) {\\n        if (root==NULL) return 0; \\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int depth=0;\\n        \\n        while (!q.empty()) {\\n            ++depth;\\n            int s=q.size();\\n            for (int i=0; i<s; i++) {\\n                TreeNode* front=q.front();\\n                q.pop();\\n                \\n                if (front->left) q.push(front->left);\\n                if (front->right) q.push(front->right);\\n            }\\n        }\\n    return depth;\\n    }\\n\\n\\n       void dfs(TreeNode*root, vector<TreeNode*>&v)\\n       {\\n             if(root==nullptr) return;\\n\\n             v.push_back(root);\\n             dfs(root->left,v);\\n             dfs(root->right,v);\\n       }\\n  \\n    int diameterOfBinaryTree(TreeNode* root) {\\n        int ans =0;\\n        vector<TreeNode *>v;\\n        dfs(root,v);\\n\\n\\n          for(auto it:v)\\n          {\\n             int k= maxDepth(it);\\n             ans=max(ans,k);\\n          }\\n          return ans;\\n    }\\n\\n\\n};    whats wrong in this solution"
                    },
                    {
                        "username": "mauro23",
                        "content": "This problem is only easy if you already know how to do it"
                    }
                ]
            },
            {
                "id": 1971829,
                "content": [
                    {
                        "username": "chris_1101",
                        "content": "Who in their right mind tagged this easy."
                    },
                    {
                        "username": "nekoaoi",
                        "content": "you have to be really high to mark this as easy."
                    },
                    {
                        "username": "suraj21209",
                        "content": "It\\'s easy to maintain another variable and update it at each node. It might help you - https://leetcode.com/problems/diameter-of-binary-tree/submissions/995832822/"
                    },
                    {
                        "username": "oops_moment",
                        "content": "CHANGE THE DIFFICULTY PLEASE. IT\\'S NOT EASY."
                    },
                    {
                        "username": "trinesh14kumar",
                        "content": "what if the value in root is single then what we should \\n return?"
                    },
                    {
                        "username": "DKarneckij",
                        "content": "Medium for sure"
                    },
                    {
                        "username": "yuxiaohu",
                        "content": "Attention: Test case #91 contains several nodes with the same value 3, which may not be expected in some solutions, if they use node value to identify different nodes. (see Node #12 and #17 below, and there are more node=3 if you continue)\\nroot =\\n[-64,12,18,-4,-53,null,76,null,-51,null,null,-93,3,null,-31,47,null,3,53,-81,33,4,null,-51,-44,-60,11,null,null,null,null,78,null,-35,-64,26,-81,-31,27,60,74,null,null,8,-38,47,12,-24,null,-59,-49,-11,-51,67,null,null,null,null,null,null,null,-67,null,-37,-19,10,-55,72,null,null,null,-70,17,-4,null,null,null,null,null,null,null,3,80,44,-88,-91,null,48,-90,-30,null,null,90,-34,37,null,null,73,-38,-31,-85,-31,-96,null,null,-18,67,34,72,null,-17,-77,null,56,-65,-88,-53,null,null,null,-33,86,null,81,-42,null,null,98,-40,70,-26,24,null,null,null,null,92,72,-27,null,null,null,null,null,null,-67,null,null,null,null,null,null,null,-54,-66,-36,null,-72,null,null,43,null,null,null,-92,-1,-98,null,null,null,null,null,null,null,39,-84,null,null,null,null,null,null,null,null,null,null,null,null,null,-93,null,null,null,98] "
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Hint:\\nAt every subtree find the sum of deepest left & deepest right path from root node of subtree. \\nMaximum of above would be the answer."
                    },
                    {
                        "username": "jpecoraro342",
                        "content": "Hint: You can calculate/return both the diameter, and depth at the same time"
                    },
                    {
                        "username": "arf01",
                        "content": "class Solution {\\npublic:\\n\\n \\n\\n     int maxDepth(TreeNode* root) {\\n        if (root==NULL) return 0; \\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int depth=0;\\n        \\n        while (!q.empty()) {\\n            ++depth;\\n            int s=q.size();\\n            for (int i=0; i<s; i++) {\\n                TreeNode* front=q.front();\\n                q.pop();\\n                \\n                if (front->left) q.push(front->left);\\n                if (front->right) q.push(front->right);\\n            }\\n        }\\n    return depth;\\n    }\\n\\n\\n       void dfs(TreeNode*root, vector<TreeNode*>&v)\\n       {\\n             if(root==nullptr) return;\\n\\n             v.push_back(root);\\n             dfs(root->left,v);\\n             dfs(root->right,v);\\n       }\\n  \\n    int diameterOfBinaryTree(TreeNode* root) {\\n        int ans =0;\\n        vector<TreeNode *>v;\\n        dfs(root,v);\\n\\n\\n          for(auto it:v)\\n          {\\n             int k= maxDepth(it);\\n             ans=max(ans,k);\\n          }\\n          return ans;\\n    }\\n\\n\\n};    whats wrong in this solution"
                    },
                    {
                        "username": "mauro23",
                        "content": "This problem is only easy if you already know how to do it"
                    }
                ]
            },
            {
                "id": 1928988,
                "content": [
                    {
                        "username": "chris_1101",
                        "content": "Who in their right mind tagged this easy."
                    },
                    {
                        "username": "nekoaoi",
                        "content": "you have to be really high to mark this as easy."
                    },
                    {
                        "username": "suraj21209",
                        "content": "It\\'s easy to maintain another variable and update it at each node. It might help you - https://leetcode.com/problems/diameter-of-binary-tree/submissions/995832822/"
                    },
                    {
                        "username": "oops_moment",
                        "content": "CHANGE THE DIFFICULTY PLEASE. IT\\'S NOT EASY."
                    },
                    {
                        "username": "trinesh14kumar",
                        "content": "what if the value in root is single then what we should \\n return?"
                    },
                    {
                        "username": "DKarneckij",
                        "content": "Medium for sure"
                    },
                    {
                        "username": "yuxiaohu",
                        "content": "Attention: Test case #91 contains several nodes with the same value 3, which may not be expected in some solutions, if they use node value to identify different nodes. (see Node #12 and #17 below, and there are more node=3 if you continue)\\nroot =\\n[-64,12,18,-4,-53,null,76,null,-51,null,null,-93,3,null,-31,47,null,3,53,-81,33,4,null,-51,-44,-60,11,null,null,null,null,78,null,-35,-64,26,-81,-31,27,60,74,null,null,8,-38,47,12,-24,null,-59,-49,-11,-51,67,null,null,null,null,null,null,null,-67,null,-37,-19,10,-55,72,null,null,null,-70,17,-4,null,null,null,null,null,null,null,3,80,44,-88,-91,null,48,-90,-30,null,null,90,-34,37,null,null,73,-38,-31,-85,-31,-96,null,null,-18,67,34,72,null,-17,-77,null,56,-65,-88,-53,null,null,null,-33,86,null,81,-42,null,null,98,-40,70,-26,24,null,null,null,null,92,72,-27,null,null,null,null,null,null,-67,null,null,null,null,null,null,null,-54,-66,-36,null,-72,null,null,43,null,null,null,-92,-1,-98,null,null,null,null,null,null,null,39,-84,null,null,null,null,null,null,null,null,null,null,null,null,null,-93,null,null,null,98] "
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Hint:\\nAt every subtree find the sum of deepest left & deepest right path from root node of subtree. \\nMaximum of above would be the answer."
                    },
                    {
                        "username": "jpecoraro342",
                        "content": "Hint: You can calculate/return both the diameter, and depth at the same time"
                    },
                    {
                        "username": "arf01",
                        "content": "class Solution {\\npublic:\\n\\n \\n\\n     int maxDepth(TreeNode* root) {\\n        if (root==NULL) return 0; \\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int depth=0;\\n        \\n        while (!q.empty()) {\\n            ++depth;\\n            int s=q.size();\\n            for (int i=0; i<s; i++) {\\n                TreeNode* front=q.front();\\n                q.pop();\\n                \\n                if (front->left) q.push(front->left);\\n                if (front->right) q.push(front->right);\\n            }\\n        }\\n    return depth;\\n    }\\n\\n\\n       void dfs(TreeNode*root, vector<TreeNode*>&v)\\n       {\\n             if(root==nullptr) return;\\n\\n             v.push_back(root);\\n             dfs(root->left,v);\\n             dfs(root->right,v);\\n       }\\n  \\n    int diameterOfBinaryTree(TreeNode* root) {\\n        int ans =0;\\n        vector<TreeNode *>v;\\n        dfs(root,v);\\n\\n\\n          for(auto it:v)\\n          {\\n             int k= maxDepth(it);\\n             ans=max(ans,k);\\n          }\\n          return ans;\\n    }\\n\\n\\n};    whats wrong in this solution"
                    },
                    {
                        "username": "mauro23",
                        "content": "This problem is only easy if you already know how to do it"
                    }
                ]
            },
            {
                "id": 1923453,
                "content": [
                    {
                        "username": "chris_1101",
                        "content": "Who in their right mind tagged this easy."
                    },
                    {
                        "username": "nekoaoi",
                        "content": "you have to be really high to mark this as easy."
                    },
                    {
                        "username": "suraj21209",
                        "content": "It\\'s easy to maintain another variable and update it at each node. It might help you - https://leetcode.com/problems/diameter-of-binary-tree/submissions/995832822/"
                    },
                    {
                        "username": "oops_moment",
                        "content": "CHANGE THE DIFFICULTY PLEASE. IT\\'S NOT EASY."
                    },
                    {
                        "username": "trinesh14kumar",
                        "content": "what if the value in root is single then what we should \\n return?"
                    },
                    {
                        "username": "DKarneckij",
                        "content": "Medium for sure"
                    },
                    {
                        "username": "yuxiaohu",
                        "content": "Attention: Test case #91 contains several nodes with the same value 3, which may not be expected in some solutions, if they use node value to identify different nodes. (see Node #12 and #17 below, and there are more node=3 if you continue)\\nroot =\\n[-64,12,18,-4,-53,null,76,null,-51,null,null,-93,3,null,-31,47,null,3,53,-81,33,4,null,-51,-44,-60,11,null,null,null,null,78,null,-35,-64,26,-81,-31,27,60,74,null,null,8,-38,47,12,-24,null,-59,-49,-11,-51,67,null,null,null,null,null,null,null,-67,null,-37,-19,10,-55,72,null,null,null,-70,17,-4,null,null,null,null,null,null,null,3,80,44,-88,-91,null,48,-90,-30,null,null,90,-34,37,null,null,73,-38,-31,-85,-31,-96,null,null,-18,67,34,72,null,-17,-77,null,56,-65,-88,-53,null,null,null,-33,86,null,81,-42,null,null,98,-40,70,-26,24,null,null,null,null,92,72,-27,null,null,null,null,null,null,-67,null,null,null,null,null,null,null,-54,-66,-36,null,-72,null,null,43,null,null,null,-92,-1,-98,null,null,null,null,null,null,null,39,-84,null,null,null,null,null,null,null,null,null,null,null,null,null,-93,null,null,null,98] "
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Hint:\\nAt every subtree find the sum of deepest left & deepest right path from root node of subtree. \\nMaximum of above would be the answer."
                    },
                    {
                        "username": "jpecoraro342",
                        "content": "Hint: You can calculate/return both the diameter, and depth at the same time"
                    },
                    {
                        "username": "arf01",
                        "content": "class Solution {\\npublic:\\n\\n \\n\\n     int maxDepth(TreeNode* root) {\\n        if (root==NULL) return 0; \\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int depth=0;\\n        \\n        while (!q.empty()) {\\n            ++depth;\\n            int s=q.size();\\n            for (int i=0; i<s; i++) {\\n                TreeNode* front=q.front();\\n                q.pop();\\n                \\n                if (front->left) q.push(front->left);\\n                if (front->right) q.push(front->right);\\n            }\\n        }\\n    return depth;\\n    }\\n\\n\\n       void dfs(TreeNode*root, vector<TreeNode*>&v)\\n       {\\n             if(root==nullptr) return;\\n\\n             v.push_back(root);\\n             dfs(root->left,v);\\n             dfs(root->right,v);\\n       }\\n  \\n    int diameterOfBinaryTree(TreeNode* root) {\\n        int ans =0;\\n        vector<TreeNode *>v;\\n        dfs(root,v);\\n\\n\\n          for(auto it:v)\\n          {\\n             int k= maxDepth(it);\\n             ans=max(ans,k);\\n          }\\n          return ans;\\n    }\\n\\n\\n};    whats wrong in this solution"
                    },
                    {
                        "username": "mauro23",
                        "content": "This problem is only easy if you already know how to do it"
                    }
                ]
            },
            {
                "id": 1910139,
                "content": [
                    {
                        "username": "chris_1101",
                        "content": "Who in their right mind tagged this easy."
                    },
                    {
                        "username": "nekoaoi",
                        "content": "you have to be really high to mark this as easy."
                    },
                    {
                        "username": "suraj21209",
                        "content": "It\\'s easy to maintain another variable and update it at each node. It might help you - https://leetcode.com/problems/diameter-of-binary-tree/submissions/995832822/"
                    },
                    {
                        "username": "oops_moment",
                        "content": "CHANGE THE DIFFICULTY PLEASE. IT\\'S NOT EASY."
                    },
                    {
                        "username": "trinesh14kumar",
                        "content": "what if the value in root is single then what we should \\n return?"
                    },
                    {
                        "username": "DKarneckij",
                        "content": "Medium for sure"
                    },
                    {
                        "username": "yuxiaohu",
                        "content": "Attention: Test case #91 contains several nodes with the same value 3, which may not be expected in some solutions, if they use node value to identify different nodes. (see Node #12 and #17 below, and there are more node=3 if you continue)\\nroot =\\n[-64,12,18,-4,-53,null,76,null,-51,null,null,-93,3,null,-31,47,null,3,53,-81,33,4,null,-51,-44,-60,11,null,null,null,null,78,null,-35,-64,26,-81,-31,27,60,74,null,null,8,-38,47,12,-24,null,-59,-49,-11,-51,67,null,null,null,null,null,null,null,-67,null,-37,-19,10,-55,72,null,null,null,-70,17,-4,null,null,null,null,null,null,null,3,80,44,-88,-91,null,48,-90,-30,null,null,90,-34,37,null,null,73,-38,-31,-85,-31,-96,null,null,-18,67,34,72,null,-17,-77,null,56,-65,-88,-53,null,null,null,-33,86,null,81,-42,null,null,98,-40,70,-26,24,null,null,null,null,92,72,-27,null,null,null,null,null,null,-67,null,null,null,null,null,null,null,-54,-66,-36,null,-72,null,null,43,null,null,null,-92,-1,-98,null,null,null,null,null,null,null,39,-84,null,null,null,null,null,null,null,null,null,null,null,null,null,-93,null,null,null,98] "
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Hint:\\nAt every subtree find the sum of deepest left & deepest right path from root node of subtree. \\nMaximum of above would be the answer."
                    },
                    {
                        "username": "jpecoraro342",
                        "content": "Hint: You can calculate/return both the diameter, and depth at the same time"
                    },
                    {
                        "username": "arf01",
                        "content": "class Solution {\\npublic:\\n\\n \\n\\n     int maxDepth(TreeNode* root) {\\n        if (root==NULL) return 0; \\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int depth=0;\\n        \\n        while (!q.empty()) {\\n            ++depth;\\n            int s=q.size();\\n            for (int i=0; i<s; i++) {\\n                TreeNode* front=q.front();\\n                q.pop();\\n                \\n                if (front->left) q.push(front->left);\\n                if (front->right) q.push(front->right);\\n            }\\n        }\\n    return depth;\\n    }\\n\\n\\n       void dfs(TreeNode*root, vector<TreeNode*>&v)\\n       {\\n             if(root==nullptr) return;\\n\\n             v.push_back(root);\\n             dfs(root->left,v);\\n             dfs(root->right,v);\\n       }\\n  \\n    int diameterOfBinaryTree(TreeNode* root) {\\n        int ans =0;\\n        vector<TreeNode *>v;\\n        dfs(root,v);\\n\\n\\n          for(auto it:v)\\n          {\\n             int k= maxDepth(it);\\n             ans=max(ans,k);\\n          }\\n          return ans;\\n    }\\n\\n\\n};    whats wrong in this solution"
                    },
                    {
                        "username": "mauro23",
                        "content": "This problem is only easy if you already know how to do it"
                    }
                ]
            },
            {
                "id": 1909221,
                "content": [
                    {
                        "username": "chris_1101",
                        "content": "Who in their right mind tagged this easy."
                    },
                    {
                        "username": "nekoaoi",
                        "content": "you have to be really high to mark this as easy."
                    },
                    {
                        "username": "suraj21209",
                        "content": "It\\'s easy to maintain another variable and update it at each node. It might help you - https://leetcode.com/problems/diameter-of-binary-tree/submissions/995832822/"
                    },
                    {
                        "username": "oops_moment",
                        "content": "CHANGE THE DIFFICULTY PLEASE. IT\\'S NOT EASY."
                    },
                    {
                        "username": "trinesh14kumar",
                        "content": "what if the value in root is single then what we should \\n return?"
                    },
                    {
                        "username": "DKarneckij",
                        "content": "Medium for sure"
                    },
                    {
                        "username": "yuxiaohu",
                        "content": "Attention: Test case #91 contains several nodes with the same value 3, which may not be expected in some solutions, if they use node value to identify different nodes. (see Node #12 and #17 below, and there are more node=3 if you continue)\\nroot =\\n[-64,12,18,-4,-53,null,76,null,-51,null,null,-93,3,null,-31,47,null,3,53,-81,33,4,null,-51,-44,-60,11,null,null,null,null,78,null,-35,-64,26,-81,-31,27,60,74,null,null,8,-38,47,12,-24,null,-59,-49,-11,-51,67,null,null,null,null,null,null,null,-67,null,-37,-19,10,-55,72,null,null,null,-70,17,-4,null,null,null,null,null,null,null,3,80,44,-88,-91,null,48,-90,-30,null,null,90,-34,37,null,null,73,-38,-31,-85,-31,-96,null,null,-18,67,34,72,null,-17,-77,null,56,-65,-88,-53,null,null,null,-33,86,null,81,-42,null,null,98,-40,70,-26,24,null,null,null,null,92,72,-27,null,null,null,null,null,null,-67,null,null,null,null,null,null,null,-54,-66,-36,null,-72,null,null,43,null,null,null,-92,-1,-98,null,null,null,null,null,null,null,39,-84,null,null,null,null,null,null,null,null,null,null,null,null,null,-93,null,null,null,98] "
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Hint:\\nAt every subtree find the sum of deepest left & deepest right path from root node of subtree. \\nMaximum of above would be the answer."
                    },
                    {
                        "username": "jpecoraro342",
                        "content": "Hint: You can calculate/return both the diameter, and depth at the same time"
                    },
                    {
                        "username": "arf01",
                        "content": "class Solution {\\npublic:\\n\\n \\n\\n     int maxDepth(TreeNode* root) {\\n        if (root==NULL) return 0; \\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int depth=0;\\n        \\n        while (!q.empty()) {\\n            ++depth;\\n            int s=q.size();\\n            for (int i=0; i<s; i++) {\\n                TreeNode* front=q.front();\\n                q.pop();\\n                \\n                if (front->left) q.push(front->left);\\n                if (front->right) q.push(front->right);\\n            }\\n        }\\n    return depth;\\n    }\\n\\n\\n       void dfs(TreeNode*root, vector<TreeNode*>&v)\\n       {\\n             if(root==nullptr) return;\\n\\n             v.push_back(root);\\n             dfs(root->left,v);\\n             dfs(root->right,v);\\n       }\\n  \\n    int diameterOfBinaryTree(TreeNode* root) {\\n        int ans =0;\\n        vector<TreeNode *>v;\\n        dfs(root,v);\\n\\n\\n          for(auto it:v)\\n          {\\n             int k= maxDepth(it);\\n             ans=max(ans,k);\\n          }\\n          return ans;\\n    }\\n\\n\\n};    whats wrong in this solution"
                    },
                    {
                        "username": "mauro23",
                        "content": "This problem is only easy if you already know how to do it"
                    }
                ]
            },
            {
                "id": 1886144,
                "content": [
                    {
                        "username": "chris_1101",
                        "content": "Who in their right mind tagged this easy."
                    },
                    {
                        "username": "nekoaoi",
                        "content": "you have to be really high to mark this as easy."
                    },
                    {
                        "username": "suraj21209",
                        "content": "It\\'s easy to maintain another variable and update it at each node. It might help you - https://leetcode.com/problems/diameter-of-binary-tree/submissions/995832822/"
                    },
                    {
                        "username": "oops_moment",
                        "content": "CHANGE THE DIFFICULTY PLEASE. IT\\'S NOT EASY."
                    },
                    {
                        "username": "trinesh14kumar",
                        "content": "what if the value in root is single then what we should \\n return?"
                    },
                    {
                        "username": "DKarneckij",
                        "content": "Medium for sure"
                    },
                    {
                        "username": "yuxiaohu",
                        "content": "Attention: Test case #91 contains several nodes with the same value 3, which may not be expected in some solutions, if they use node value to identify different nodes. (see Node #12 and #17 below, and there are more node=3 if you continue)\\nroot =\\n[-64,12,18,-4,-53,null,76,null,-51,null,null,-93,3,null,-31,47,null,3,53,-81,33,4,null,-51,-44,-60,11,null,null,null,null,78,null,-35,-64,26,-81,-31,27,60,74,null,null,8,-38,47,12,-24,null,-59,-49,-11,-51,67,null,null,null,null,null,null,null,-67,null,-37,-19,10,-55,72,null,null,null,-70,17,-4,null,null,null,null,null,null,null,3,80,44,-88,-91,null,48,-90,-30,null,null,90,-34,37,null,null,73,-38,-31,-85,-31,-96,null,null,-18,67,34,72,null,-17,-77,null,56,-65,-88,-53,null,null,null,-33,86,null,81,-42,null,null,98,-40,70,-26,24,null,null,null,null,92,72,-27,null,null,null,null,null,null,-67,null,null,null,null,null,null,null,-54,-66,-36,null,-72,null,null,43,null,null,null,-92,-1,-98,null,null,null,null,null,null,null,39,-84,null,null,null,null,null,null,null,null,null,null,null,null,null,-93,null,null,null,98] "
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Hint:\\nAt every subtree find the sum of deepest left & deepest right path from root node of subtree. \\nMaximum of above would be the answer."
                    },
                    {
                        "username": "jpecoraro342",
                        "content": "Hint: You can calculate/return both the diameter, and depth at the same time"
                    },
                    {
                        "username": "arf01",
                        "content": "class Solution {\\npublic:\\n\\n \\n\\n     int maxDepth(TreeNode* root) {\\n        if (root==NULL) return 0; \\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int depth=0;\\n        \\n        while (!q.empty()) {\\n            ++depth;\\n            int s=q.size();\\n            for (int i=0; i<s; i++) {\\n                TreeNode* front=q.front();\\n                q.pop();\\n                \\n                if (front->left) q.push(front->left);\\n                if (front->right) q.push(front->right);\\n            }\\n        }\\n    return depth;\\n    }\\n\\n\\n       void dfs(TreeNode*root, vector<TreeNode*>&v)\\n       {\\n             if(root==nullptr) return;\\n\\n             v.push_back(root);\\n             dfs(root->left,v);\\n             dfs(root->right,v);\\n       }\\n  \\n    int diameterOfBinaryTree(TreeNode* root) {\\n        int ans =0;\\n        vector<TreeNode *>v;\\n        dfs(root,v);\\n\\n\\n          for(auto it:v)\\n          {\\n             int k= maxDepth(it);\\n             ans=max(ans,k);\\n          }\\n          return ans;\\n    }\\n\\n\\n};    whats wrong in this solution"
                    },
                    {
                        "username": "mauro23",
                        "content": "This problem is only easy if you already know how to do it"
                    }
                ]
            },
            {
                "id": 1868439,
                "content": [
                    {
                        "username": "vaibhav_bilwal",
                        "content": "class Solution {\\npublic:\\n    int height( TreeNode *root) {\\n        if(root==NULL)\\n          return 0;\\n\\n          return  max(height(root->left) , height(root->right)) + 1;\\n    }\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        int lh = height(root->left);\\n        int rh = height(root->right);\\n\\n        return lh+rh;\\n        \\n    }\\n};\\nWHAT IS THE WRONG WITH THIS CODE \\nIT DOES PASSED TEST CASE 100 "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "just find the maximum length/ Path in Binary tree?\n"
                    },
                    {
                        "username": "shreyaskaup",
                        "content": "Good problem, but should be marked as Medium difficulty without a doubt"
                    },
                    {
                        "username": "dhananjayyadav",
                        "content": "Why i have to use diameter array of size 1 and not just a variavle diameter in this problem?\\n\\npublic int diameterOfBinaryTree(TreeNode root) {\\n        int[] diameter = new int[1];\\n        height(root, diameter);\\n        return diameter[0];        \\n    }\\n\\n    private int height(TreeNode node, int[] diameter) {\\n        if (node == null) {\\n            return 0;\\n        }\\n        int lh = height(node.left, diameter);\\n        int rh = height(node.right, diameter);\\n        diameter[0] = Math.max(diameter[0], lh + rh);\\n        return 1 + Math.max(lh, rh);\\n    }"
                    },
                    {
                        "username": "jpecoraro342",
                        "content": "Diameter needs to be passed by reference in order to be modified."
                    },
                    {
                        "username": "mohak0",
                        "content": "Nah, come on, this is not an easy problem "
                    },
                    {
                        "username": "djslim",
                        "content": "in many ways similar, main difference is that n-ary tree, but good followup: https://leetcode.com/problems/longest-path-with-different-adjacent-characters/"
                    },
                    {
                        "username": "Ryomen5ukuna",
                        "content": "How is this problem easy.\n\nIf this problem is easy then i am Sukuna ."
                    },
                    {
                        "username": "muthuthevar1320",
                        "content": "# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n\\n    def heightOfTree(self,root,ans):\\n        if root == None:\\n            return 0\\n        \\n        lh=self.heightOfTree(root.left,ans)\\n        rh=self.heightOfTree(root.right,ans)\\n        ans=max(lh+rh,ans)\\n\\n        return max(lh,rh)+1\\n\\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        ans=0\\n        self.heightOfTree(root,ans)\\n        return ans\\n        \\n\\nI don\\'t know where Am I making mistake please help me here"
                    },
                    {
                        "username": "withrvr",
                        "content": "# solve this before this question\\n\\n- https://leetcode.com/problems/maximum-depth-of-binary-tree/\\n-\\n- because\\n- its same as `104. Maximum Depth of Binary Tree`\\n- but here in this question one extra condition is added\\n"
                    },
                    {
                        "username": "withrvr",
                        "content": "# NOTE: ans will be `10` not `8`\\n- for input\\n- `[1,2,3,4,5,null,null,null,null,2,3,null,3,3,null,3,3,3,33,2,null,null,3,null,3,null,3,3,1,null,null,null,6]`\\n\\n\\n## see ans from node `5` is more than any other"
                    }
                ]
            },
            {
                "id": 1856565,
                "content": [
                    {
                        "username": "vaibhav_bilwal",
                        "content": "class Solution {\\npublic:\\n    int height( TreeNode *root) {\\n        if(root==NULL)\\n          return 0;\\n\\n          return  max(height(root->left) , height(root->right)) + 1;\\n    }\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        int lh = height(root->left);\\n        int rh = height(root->right);\\n\\n        return lh+rh;\\n        \\n    }\\n};\\nWHAT IS THE WRONG WITH THIS CODE \\nIT DOES PASSED TEST CASE 100 "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "just find the maximum length/ Path in Binary tree?\n"
                    },
                    {
                        "username": "shreyaskaup",
                        "content": "Good problem, but should be marked as Medium difficulty without a doubt"
                    },
                    {
                        "username": "dhananjayyadav",
                        "content": "Why i have to use diameter array of size 1 and not just a variavle diameter in this problem?\\n\\npublic int diameterOfBinaryTree(TreeNode root) {\\n        int[] diameter = new int[1];\\n        height(root, diameter);\\n        return diameter[0];        \\n    }\\n\\n    private int height(TreeNode node, int[] diameter) {\\n        if (node == null) {\\n            return 0;\\n        }\\n        int lh = height(node.left, diameter);\\n        int rh = height(node.right, diameter);\\n        diameter[0] = Math.max(diameter[0], lh + rh);\\n        return 1 + Math.max(lh, rh);\\n    }"
                    },
                    {
                        "username": "jpecoraro342",
                        "content": "Diameter needs to be passed by reference in order to be modified."
                    },
                    {
                        "username": "mohak0",
                        "content": "Nah, come on, this is not an easy problem "
                    },
                    {
                        "username": "djslim",
                        "content": "in many ways similar, main difference is that n-ary tree, but good followup: https://leetcode.com/problems/longest-path-with-different-adjacent-characters/"
                    },
                    {
                        "username": "Ryomen5ukuna",
                        "content": "How is this problem easy.\n\nIf this problem is easy then i am Sukuna ."
                    },
                    {
                        "username": "muthuthevar1320",
                        "content": "# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n\\n    def heightOfTree(self,root,ans):\\n        if root == None:\\n            return 0\\n        \\n        lh=self.heightOfTree(root.left,ans)\\n        rh=self.heightOfTree(root.right,ans)\\n        ans=max(lh+rh,ans)\\n\\n        return max(lh,rh)+1\\n\\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        ans=0\\n        self.heightOfTree(root,ans)\\n        return ans\\n        \\n\\nI don\\'t know where Am I making mistake please help me here"
                    },
                    {
                        "username": "withrvr",
                        "content": "# solve this before this question\\n\\n- https://leetcode.com/problems/maximum-depth-of-binary-tree/\\n-\\n- because\\n- its same as `104. Maximum Depth of Binary Tree`\\n- but here in this question one extra condition is added\\n"
                    },
                    {
                        "username": "withrvr",
                        "content": "# NOTE: ans will be `10` not `8`\\n- for input\\n- `[1,2,3,4,5,null,null,null,null,2,3,null,3,3,null,3,3,3,33,2,null,null,3,null,3,null,3,3,1,null,null,null,6]`\\n\\n\\n## see ans from node `5` is more than any other"
                    }
                ]
            },
            {
                "id": 1853837,
                "content": [
                    {
                        "username": "vaibhav_bilwal",
                        "content": "class Solution {\\npublic:\\n    int height( TreeNode *root) {\\n        if(root==NULL)\\n          return 0;\\n\\n          return  max(height(root->left) , height(root->right)) + 1;\\n    }\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        int lh = height(root->left);\\n        int rh = height(root->right);\\n\\n        return lh+rh;\\n        \\n    }\\n};\\nWHAT IS THE WRONG WITH THIS CODE \\nIT DOES PASSED TEST CASE 100 "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "just find the maximum length/ Path in Binary tree?\n"
                    },
                    {
                        "username": "shreyaskaup",
                        "content": "Good problem, but should be marked as Medium difficulty without a doubt"
                    },
                    {
                        "username": "dhananjayyadav",
                        "content": "Why i have to use diameter array of size 1 and not just a variavle diameter in this problem?\\n\\npublic int diameterOfBinaryTree(TreeNode root) {\\n        int[] diameter = new int[1];\\n        height(root, diameter);\\n        return diameter[0];        \\n    }\\n\\n    private int height(TreeNode node, int[] diameter) {\\n        if (node == null) {\\n            return 0;\\n        }\\n        int lh = height(node.left, diameter);\\n        int rh = height(node.right, diameter);\\n        diameter[0] = Math.max(diameter[0], lh + rh);\\n        return 1 + Math.max(lh, rh);\\n    }"
                    },
                    {
                        "username": "jpecoraro342",
                        "content": "Diameter needs to be passed by reference in order to be modified."
                    },
                    {
                        "username": "mohak0",
                        "content": "Nah, come on, this is not an easy problem "
                    },
                    {
                        "username": "djslim",
                        "content": "in many ways similar, main difference is that n-ary tree, but good followup: https://leetcode.com/problems/longest-path-with-different-adjacent-characters/"
                    },
                    {
                        "username": "Ryomen5ukuna",
                        "content": "How is this problem easy.\n\nIf this problem is easy then i am Sukuna ."
                    },
                    {
                        "username": "muthuthevar1320",
                        "content": "# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n\\n    def heightOfTree(self,root,ans):\\n        if root == None:\\n            return 0\\n        \\n        lh=self.heightOfTree(root.left,ans)\\n        rh=self.heightOfTree(root.right,ans)\\n        ans=max(lh+rh,ans)\\n\\n        return max(lh,rh)+1\\n\\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        ans=0\\n        self.heightOfTree(root,ans)\\n        return ans\\n        \\n\\nI don\\'t know where Am I making mistake please help me here"
                    },
                    {
                        "username": "withrvr",
                        "content": "# solve this before this question\\n\\n- https://leetcode.com/problems/maximum-depth-of-binary-tree/\\n-\\n- because\\n- its same as `104. Maximum Depth of Binary Tree`\\n- but here in this question one extra condition is added\\n"
                    },
                    {
                        "username": "withrvr",
                        "content": "# NOTE: ans will be `10` not `8`\\n- for input\\n- `[1,2,3,4,5,null,null,null,null,2,3,null,3,3,null,3,3,3,33,2,null,null,3,null,3,null,3,3,1,null,null,null,6]`\\n\\n\\n## see ans from node `5` is more than any other"
                    }
                ]
            },
            {
                "id": 1851311,
                "content": [
                    {
                        "username": "vaibhav_bilwal",
                        "content": "class Solution {\\npublic:\\n    int height( TreeNode *root) {\\n        if(root==NULL)\\n          return 0;\\n\\n          return  max(height(root->left) , height(root->right)) + 1;\\n    }\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        int lh = height(root->left);\\n        int rh = height(root->right);\\n\\n        return lh+rh;\\n        \\n    }\\n};\\nWHAT IS THE WRONG WITH THIS CODE \\nIT DOES PASSED TEST CASE 100 "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "just find the maximum length/ Path in Binary tree?\n"
                    },
                    {
                        "username": "shreyaskaup",
                        "content": "Good problem, but should be marked as Medium difficulty without a doubt"
                    },
                    {
                        "username": "dhananjayyadav",
                        "content": "Why i have to use diameter array of size 1 and not just a variavle diameter in this problem?\\n\\npublic int diameterOfBinaryTree(TreeNode root) {\\n        int[] diameter = new int[1];\\n        height(root, diameter);\\n        return diameter[0];        \\n    }\\n\\n    private int height(TreeNode node, int[] diameter) {\\n        if (node == null) {\\n            return 0;\\n        }\\n        int lh = height(node.left, diameter);\\n        int rh = height(node.right, diameter);\\n        diameter[0] = Math.max(diameter[0], lh + rh);\\n        return 1 + Math.max(lh, rh);\\n    }"
                    },
                    {
                        "username": "jpecoraro342",
                        "content": "Diameter needs to be passed by reference in order to be modified."
                    },
                    {
                        "username": "mohak0",
                        "content": "Nah, come on, this is not an easy problem "
                    },
                    {
                        "username": "djslim",
                        "content": "in many ways similar, main difference is that n-ary tree, but good followup: https://leetcode.com/problems/longest-path-with-different-adjacent-characters/"
                    },
                    {
                        "username": "Ryomen5ukuna",
                        "content": "How is this problem easy.\n\nIf this problem is easy then i am Sukuna ."
                    },
                    {
                        "username": "muthuthevar1320",
                        "content": "# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n\\n    def heightOfTree(self,root,ans):\\n        if root == None:\\n            return 0\\n        \\n        lh=self.heightOfTree(root.left,ans)\\n        rh=self.heightOfTree(root.right,ans)\\n        ans=max(lh+rh,ans)\\n\\n        return max(lh,rh)+1\\n\\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        ans=0\\n        self.heightOfTree(root,ans)\\n        return ans\\n        \\n\\nI don\\'t know where Am I making mistake please help me here"
                    },
                    {
                        "username": "withrvr",
                        "content": "# solve this before this question\\n\\n- https://leetcode.com/problems/maximum-depth-of-binary-tree/\\n-\\n- because\\n- its same as `104. Maximum Depth of Binary Tree`\\n- but here in this question one extra condition is added\\n"
                    },
                    {
                        "username": "withrvr",
                        "content": "# NOTE: ans will be `10` not `8`\\n- for input\\n- `[1,2,3,4,5,null,null,null,null,2,3,null,3,3,null,3,3,3,33,2,null,null,3,null,3,null,3,3,1,null,null,null,6]`\\n\\n\\n## see ans from node `5` is more than any other"
                    }
                ]
            },
            {
                "id": 1837531,
                "content": [
                    {
                        "username": "vaibhav_bilwal",
                        "content": "class Solution {\\npublic:\\n    int height( TreeNode *root) {\\n        if(root==NULL)\\n          return 0;\\n\\n          return  max(height(root->left) , height(root->right)) + 1;\\n    }\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        int lh = height(root->left);\\n        int rh = height(root->right);\\n\\n        return lh+rh;\\n        \\n    }\\n};\\nWHAT IS THE WRONG WITH THIS CODE \\nIT DOES PASSED TEST CASE 100 "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "just find the maximum length/ Path in Binary tree?\n"
                    },
                    {
                        "username": "shreyaskaup",
                        "content": "Good problem, but should be marked as Medium difficulty without a doubt"
                    },
                    {
                        "username": "dhananjayyadav",
                        "content": "Why i have to use diameter array of size 1 and not just a variavle diameter in this problem?\\n\\npublic int diameterOfBinaryTree(TreeNode root) {\\n        int[] diameter = new int[1];\\n        height(root, diameter);\\n        return diameter[0];        \\n    }\\n\\n    private int height(TreeNode node, int[] diameter) {\\n        if (node == null) {\\n            return 0;\\n        }\\n        int lh = height(node.left, diameter);\\n        int rh = height(node.right, diameter);\\n        diameter[0] = Math.max(diameter[0], lh + rh);\\n        return 1 + Math.max(lh, rh);\\n    }"
                    },
                    {
                        "username": "jpecoraro342",
                        "content": "Diameter needs to be passed by reference in order to be modified."
                    },
                    {
                        "username": "mohak0",
                        "content": "Nah, come on, this is not an easy problem "
                    },
                    {
                        "username": "djslim",
                        "content": "in many ways similar, main difference is that n-ary tree, but good followup: https://leetcode.com/problems/longest-path-with-different-adjacent-characters/"
                    },
                    {
                        "username": "Ryomen5ukuna",
                        "content": "How is this problem easy.\n\nIf this problem is easy then i am Sukuna ."
                    },
                    {
                        "username": "muthuthevar1320",
                        "content": "# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n\\n    def heightOfTree(self,root,ans):\\n        if root == None:\\n            return 0\\n        \\n        lh=self.heightOfTree(root.left,ans)\\n        rh=self.heightOfTree(root.right,ans)\\n        ans=max(lh+rh,ans)\\n\\n        return max(lh,rh)+1\\n\\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        ans=0\\n        self.heightOfTree(root,ans)\\n        return ans\\n        \\n\\nI don\\'t know where Am I making mistake please help me here"
                    },
                    {
                        "username": "withrvr",
                        "content": "# solve this before this question\\n\\n- https://leetcode.com/problems/maximum-depth-of-binary-tree/\\n-\\n- because\\n- its same as `104. Maximum Depth of Binary Tree`\\n- but here in this question one extra condition is added\\n"
                    },
                    {
                        "username": "withrvr",
                        "content": "# NOTE: ans will be `10` not `8`\\n- for input\\n- `[1,2,3,4,5,null,null,null,null,2,3,null,3,3,null,3,3,3,33,2,null,null,3,null,3,null,3,3,1,null,null,null,6]`\\n\\n\\n## see ans from node `5` is more than any other"
                    }
                ]
            },
            {
                "id": 1835052,
                "content": [
                    {
                        "username": "vaibhav_bilwal",
                        "content": "class Solution {\\npublic:\\n    int height( TreeNode *root) {\\n        if(root==NULL)\\n          return 0;\\n\\n          return  max(height(root->left) , height(root->right)) + 1;\\n    }\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        int lh = height(root->left);\\n        int rh = height(root->right);\\n\\n        return lh+rh;\\n        \\n    }\\n};\\nWHAT IS THE WRONG WITH THIS CODE \\nIT DOES PASSED TEST CASE 100 "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "just find the maximum length/ Path in Binary tree?\n"
                    },
                    {
                        "username": "shreyaskaup",
                        "content": "Good problem, but should be marked as Medium difficulty without a doubt"
                    },
                    {
                        "username": "dhananjayyadav",
                        "content": "Why i have to use diameter array of size 1 and not just a variavle diameter in this problem?\\n\\npublic int diameterOfBinaryTree(TreeNode root) {\\n        int[] diameter = new int[1];\\n        height(root, diameter);\\n        return diameter[0];        \\n    }\\n\\n    private int height(TreeNode node, int[] diameter) {\\n        if (node == null) {\\n            return 0;\\n        }\\n        int lh = height(node.left, diameter);\\n        int rh = height(node.right, diameter);\\n        diameter[0] = Math.max(diameter[0], lh + rh);\\n        return 1 + Math.max(lh, rh);\\n    }"
                    },
                    {
                        "username": "jpecoraro342",
                        "content": "Diameter needs to be passed by reference in order to be modified."
                    },
                    {
                        "username": "mohak0",
                        "content": "Nah, come on, this is not an easy problem "
                    },
                    {
                        "username": "djslim",
                        "content": "in many ways similar, main difference is that n-ary tree, but good followup: https://leetcode.com/problems/longest-path-with-different-adjacent-characters/"
                    },
                    {
                        "username": "Ryomen5ukuna",
                        "content": "How is this problem easy.\n\nIf this problem is easy then i am Sukuna ."
                    },
                    {
                        "username": "muthuthevar1320",
                        "content": "# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n\\n    def heightOfTree(self,root,ans):\\n        if root == None:\\n            return 0\\n        \\n        lh=self.heightOfTree(root.left,ans)\\n        rh=self.heightOfTree(root.right,ans)\\n        ans=max(lh+rh,ans)\\n\\n        return max(lh,rh)+1\\n\\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        ans=0\\n        self.heightOfTree(root,ans)\\n        return ans\\n        \\n\\nI don\\'t know where Am I making mistake please help me here"
                    },
                    {
                        "username": "withrvr",
                        "content": "# solve this before this question\\n\\n- https://leetcode.com/problems/maximum-depth-of-binary-tree/\\n-\\n- because\\n- its same as `104. Maximum Depth of Binary Tree`\\n- but here in this question one extra condition is added\\n"
                    },
                    {
                        "username": "withrvr",
                        "content": "# NOTE: ans will be `10` not `8`\\n- for input\\n- `[1,2,3,4,5,null,null,null,null,2,3,null,3,3,null,3,3,3,33,2,null,null,3,null,3,null,3,3,1,null,null,null,6]`\\n\\n\\n## see ans from node `5` is more than any other"
                    }
                ]
            },
            {
                "id": 1831812,
                "content": [
                    {
                        "username": "vaibhav_bilwal",
                        "content": "class Solution {\\npublic:\\n    int height( TreeNode *root) {\\n        if(root==NULL)\\n          return 0;\\n\\n          return  max(height(root->left) , height(root->right)) + 1;\\n    }\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        int lh = height(root->left);\\n        int rh = height(root->right);\\n\\n        return lh+rh;\\n        \\n    }\\n};\\nWHAT IS THE WRONG WITH THIS CODE \\nIT DOES PASSED TEST CASE 100 "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "just find the maximum length/ Path in Binary tree?\n"
                    },
                    {
                        "username": "shreyaskaup",
                        "content": "Good problem, but should be marked as Medium difficulty without a doubt"
                    },
                    {
                        "username": "dhananjayyadav",
                        "content": "Why i have to use diameter array of size 1 and not just a variavle diameter in this problem?\\n\\npublic int diameterOfBinaryTree(TreeNode root) {\\n        int[] diameter = new int[1];\\n        height(root, diameter);\\n        return diameter[0];        \\n    }\\n\\n    private int height(TreeNode node, int[] diameter) {\\n        if (node == null) {\\n            return 0;\\n        }\\n        int lh = height(node.left, diameter);\\n        int rh = height(node.right, diameter);\\n        diameter[0] = Math.max(diameter[0], lh + rh);\\n        return 1 + Math.max(lh, rh);\\n    }"
                    },
                    {
                        "username": "jpecoraro342",
                        "content": "Diameter needs to be passed by reference in order to be modified."
                    },
                    {
                        "username": "mohak0",
                        "content": "Nah, come on, this is not an easy problem "
                    },
                    {
                        "username": "djslim",
                        "content": "in many ways similar, main difference is that n-ary tree, but good followup: https://leetcode.com/problems/longest-path-with-different-adjacent-characters/"
                    },
                    {
                        "username": "Ryomen5ukuna",
                        "content": "How is this problem easy.\n\nIf this problem is easy then i am Sukuna ."
                    },
                    {
                        "username": "muthuthevar1320",
                        "content": "# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n\\n    def heightOfTree(self,root,ans):\\n        if root == None:\\n            return 0\\n        \\n        lh=self.heightOfTree(root.left,ans)\\n        rh=self.heightOfTree(root.right,ans)\\n        ans=max(lh+rh,ans)\\n\\n        return max(lh,rh)+1\\n\\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        ans=0\\n        self.heightOfTree(root,ans)\\n        return ans\\n        \\n\\nI don\\'t know where Am I making mistake please help me here"
                    },
                    {
                        "username": "withrvr",
                        "content": "# solve this before this question\\n\\n- https://leetcode.com/problems/maximum-depth-of-binary-tree/\\n-\\n- because\\n- its same as `104. Maximum Depth of Binary Tree`\\n- but here in this question one extra condition is added\\n"
                    },
                    {
                        "username": "withrvr",
                        "content": "# NOTE: ans will be `10` not `8`\\n- for input\\n- `[1,2,3,4,5,null,null,null,null,2,3,null,3,3,null,3,3,3,33,2,null,null,3,null,3,null,3,3,1,null,null,null,6]`\\n\\n\\n## see ans from node `5` is more than any other"
                    }
                ]
            },
            {
                "id": 1809420,
                "content": [
                    {
                        "username": "vaibhav_bilwal",
                        "content": "class Solution {\\npublic:\\n    int height( TreeNode *root) {\\n        if(root==NULL)\\n          return 0;\\n\\n          return  max(height(root->left) , height(root->right)) + 1;\\n    }\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        int lh = height(root->left);\\n        int rh = height(root->right);\\n\\n        return lh+rh;\\n        \\n    }\\n};\\nWHAT IS THE WRONG WITH THIS CODE \\nIT DOES PASSED TEST CASE 100 "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "just find the maximum length/ Path in Binary tree?\n"
                    },
                    {
                        "username": "shreyaskaup",
                        "content": "Good problem, but should be marked as Medium difficulty without a doubt"
                    },
                    {
                        "username": "dhananjayyadav",
                        "content": "Why i have to use diameter array of size 1 and not just a variavle diameter in this problem?\\n\\npublic int diameterOfBinaryTree(TreeNode root) {\\n        int[] diameter = new int[1];\\n        height(root, diameter);\\n        return diameter[0];        \\n    }\\n\\n    private int height(TreeNode node, int[] diameter) {\\n        if (node == null) {\\n            return 0;\\n        }\\n        int lh = height(node.left, diameter);\\n        int rh = height(node.right, diameter);\\n        diameter[0] = Math.max(diameter[0], lh + rh);\\n        return 1 + Math.max(lh, rh);\\n    }"
                    },
                    {
                        "username": "jpecoraro342",
                        "content": "Diameter needs to be passed by reference in order to be modified."
                    },
                    {
                        "username": "mohak0",
                        "content": "Nah, come on, this is not an easy problem "
                    },
                    {
                        "username": "djslim",
                        "content": "in many ways similar, main difference is that n-ary tree, but good followup: https://leetcode.com/problems/longest-path-with-different-adjacent-characters/"
                    },
                    {
                        "username": "Ryomen5ukuna",
                        "content": "How is this problem easy.\n\nIf this problem is easy then i am Sukuna ."
                    },
                    {
                        "username": "muthuthevar1320",
                        "content": "# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n\\n    def heightOfTree(self,root,ans):\\n        if root == None:\\n            return 0\\n        \\n        lh=self.heightOfTree(root.left,ans)\\n        rh=self.heightOfTree(root.right,ans)\\n        ans=max(lh+rh,ans)\\n\\n        return max(lh,rh)+1\\n\\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        ans=0\\n        self.heightOfTree(root,ans)\\n        return ans\\n        \\n\\nI don\\'t know where Am I making mistake please help me here"
                    },
                    {
                        "username": "withrvr",
                        "content": "# solve this before this question\\n\\n- https://leetcode.com/problems/maximum-depth-of-binary-tree/\\n-\\n- because\\n- its same as `104. Maximum Depth of Binary Tree`\\n- but here in this question one extra condition is added\\n"
                    },
                    {
                        "username": "withrvr",
                        "content": "# NOTE: ans will be `10` not `8`\\n- for input\\n- `[1,2,3,4,5,null,null,null,null,2,3,null,3,3,null,3,3,3,33,2,null,null,3,null,3,null,3,3,1,null,null,null,6]`\\n\\n\\n## see ans from node `5` is more than any other"
                    }
                ]
            },
            {
                "id": 1807506,
                "content": [
                    {
                        "username": "vaibhav_bilwal",
                        "content": "class Solution {\\npublic:\\n    int height( TreeNode *root) {\\n        if(root==NULL)\\n          return 0;\\n\\n          return  max(height(root->left) , height(root->right)) + 1;\\n    }\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        int lh = height(root->left);\\n        int rh = height(root->right);\\n\\n        return lh+rh;\\n        \\n    }\\n};\\nWHAT IS THE WRONG WITH THIS CODE \\nIT DOES PASSED TEST CASE 100 "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "just find the maximum length/ Path in Binary tree?\n"
                    },
                    {
                        "username": "shreyaskaup",
                        "content": "Good problem, but should be marked as Medium difficulty without a doubt"
                    },
                    {
                        "username": "dhananjayyadav",
                        "content": "Why i have to use diameter array of size 1 and not just a variavle diameter in this problem?\\n\\npublic int diameterOfBinaryTree(TreeNode root) {\\n        int[] diameter = new int[1];\\n        height(root, diameter);\\n        return diameter[0];        \\n    }\\n\\n    private int height(TreeNode node, int[] diameter) {\\n        if (node == null) {\\n            return 0;\\n        }\\n        int lh = height(node.left, diameter);\\n        int rh = height(node.right, diameter);\\n        diameter[0] = Math.max(diameter[0], lh + rh);\\n        return 1 + Math.max(lh, rh);\\n    }"
                    },
                    {
                        "username": "jpecoraro342",
                        "content": "Diameter needs to be passed by reference in order to be modified."
                    },
                    {
                        "username": "mohak0",
                        "content": "Nah, come on, this is not an easy problem "
                    },
                    {
                        "username": "djslim",
                        "content": "in many ways similar, main difference is that n-ary tree, but good followup: https://leetcode.com/problems/longest-path-with-different-adjacent-characters/"
                    },
                    {
                        "username": "Ryomen5ukuna",
                        "content": "How is this problem easy.\n\nIf this problem is easy then i am Sukuna ."
                    },
                    {
                        "username": "muthuthevar1320",
                        "content": "# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n\\n    def heightOfTree(self,root,ans):\\n        if root == None:\\n            return 0\\n        \\n        lh=self.heightOfTree(root.left,ans)\\n        rh=self.heightOfTree(root.right,ans)\\n        ans=max(lh+rh,ans)\\n\\n        return max(lh,rh)+1\\n\\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        ans=0\\n        self.heightOfTree(root,ans)\\n        return ans\\n        \\n\\nI don\\'t know where Am I making mistake please help me here"
                    },
                    {
                        "username": "withrvr",
                        "content": "# solve this before this question\\n\\n- https://leetcode.com/problems/maximum-depth-of-binary-tree/\\n-\\n- because\\n- its same as `104. Maximum Depth of Binary Tree`\\n- but here in this question one extra condition is added\\n"
                    },
                    {
                        "username": "withrvr",
                        "content": "# NOTE: ans will be `10` not `8`\\n- for input\\n- `[1,2,3,4,5,null,null,null,null,2,3,null,3,3,null,3,3,3,33,2,null,null,3,null,3,null,3,3,1,null,null,null,6]`\\n\\n\\n## see ans from node `5` is more than any other"
                    }
                ]
            },
            {
                "id": 1807498,
                "content": [
                    {
                        "username": "vaibhav_bilwal",
                        "content": "class Solution {\\npublic:\\n    int height( TreeNode *root) {\\n        if(root==NULL)\\n          return 0;\\n\\n          return  max(height(root->left) , height(root->right)) + 1;\\n    }\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        int lh = height(root->left);\\n        int rh = height(root->right);\\n\\n        return lh+rh;\\n        \\n    }\\n};\\nWHAT IS THE WRONG WITH THIS CODE \\nIT DOES PASSED TEST CASE 100 "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "just find the maximum length/ Path in Binary tree?\n"
                    },
                    {
                        "username": "shreyaskaup",
                        "content": "Good problem, but should be marked as Medium difficulty without a doubt"
                    },
                    {
                        "username": "dhananjayyadav",
                        "content": "Why i have to use diameter array of size 1 and not just a variavle diameter in this problem?\\n\\npublic int diameterOfBinaryTree(TreeNode root) {\\n        int[] diameter = new int[1];\\n        height(root, diameter);\\n        return diameter[0];        \\n    }\\n\\n    private int height(TreeNode node, int[] diameter) {\\n        if (node == null) {\\n            return 0;\\n        }\\n        int lh = height(node.left, diameter);\\n        int rh = height(node.right, diameter);\\n        diameter[0] = Math.max(diameter[0], lh + rh);\\n        return 1 + Math.max(lh, rh);\\n    }"
                    },
                    {
                        "username": "jpecoraro342",
                        "content": "Diameter needs to be passed by reference in order to be modified."
                    },
                    {
                        "username": "mohak0",
                        "content": "Nah, come on, this is not an easy problem "
                    },
                    {
                        "username": "djslim",
                        "content": "in many ways similar, main difference is that n-ary tree, but good followup: https://leetcode.com/problems/longest-path-with-different-adjacent-characters/"
                    },
                    {
                        "username": "Ryomen5ukuna",
                        "content": "How is this problem easy.\n\nIf this problem is easy then i am Sukuna ."
                    },
                    {
                        "username": "muthuthevar1320",
                        "content": "# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n\\n    def heightOfTree(self,root,ans):\\n        if root == None:\\n            return 0\\n        \\n        lh=self.heightOfTree(root.left,ans)\\n        rh=self.heightOfTree(root.right,ans)\\n        ans=max(lh+rh,ans)\\n\\n        return max(lh,rh)+1\\n\\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\\n        ans=0\\n        self.heightOfTree(root,ans)\\n        return ans\\n        \\n\\nI don\\'t know where Am I making mistake please help me here"
                    },
                    {
                        "username": "withrvr",
                        "content": "# solve this before this question\\n\\n- https://leetcode.com/problems/maximum-depth-of-binary-tree/\\n-\\n- because\\n- its same as `104. Maximum Depth of Binary Tree`\\n- but here in this question one extra condition is added\\n"
                    },
                    {
                        "username": "withrvr",
                        "content": "# NOTE: ans will be `10` not `8`\\n- for input\\n- `[1,2,3,4,5,null,null,null,null,2,3,null,3,3,null,3,3,3,33,2,null,null,3,null,3,null,3,3,1,null,null,null,6]`\\n\\n\\n## see ans from node `5` is more than any other"
                    }
                ]
            },
            {
                "id": 1795460,
                "content": [
                    {
                        "username": "bryanba",
                        "content": " def get_height(root):\\n\\n            if(root is None):\\n                return -1\\n\\n            return 1 + max(get_height(root.left),get_height(root.right))\\n\\n        def get_height_min(root):\\n            \\n            if(root is None):\\n                return -1\\n\\n            return 1 + min(get_height(root.left),get_height(root.right))\\n\\n        def diameter(root):\\n\\n            if(root is None):\\n                return 0\\n\\n            return get_height(root) + get_height_min(root)\\n\\n\\n        return diameter(root)\\n\\n\\nWHY IS IT NOT WORKING 100/104"
                    },
                    {
                        "username": "acoa",
                        "content": "Why does i keep getting errors despite trying mutiple code?\\nLine 7: error: cannot find symbol [in __Driver__.java]\\n      int ret = new Solution().diameterOfBinaryTree(param_1);"
                    },
                    {
                        "username": "leetcontee",
                        "content": "proof\\n"
                    },
                    {
                        "username": "rboLC",
                        "content": "\n\n\n\n\n public int findHeight(TreeNode node)\n {\n\n//Official solution was a bit hard for me to follow so I have simplified it, Hope it helps someone. Basically at every node we are calculating distance of that node from its leaf... where each leaf node has distance =1 and null node has distance = 0 so \n\n        if(node == null) return 0;\n        if(node.left == null && node.right == null) return 1;\n\n//For every node, we find distance of left node and right node. And distance of parent node becomes max(leftnode, rightnode) + 1.\n\n        int leftPathLength=findHeight(node.left);\n        int rightPathLength=findHeight(node.right);\n        int distance = Math.max(leftPathLength,rightPathLength)+1;\n\n//At this time, we also have opportunity to recalculate diameter as well so \n\n        diameter = Math.max(diameter, leftPathLength+rightPathLength);\n        return distance;\n }\n\n\n \n\nand Call this distance method from  diameterOfBinaryTree on root node.\n public int diameterOfBinaryTree(TreeNode root) {\n        \n        findHeight(root);\n        return diameter;\n        \n    }\n"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        int diameter=0;\\n        height(root,diameter);\\n        return diameter;\\n    }\\n    int height(TreeNode* node,int& diameter){\\n        if(!node){\\n            return 0;\\n        }\\n        int lh=height(node->left,diameter);\\n        int rh=height(node->right,diameter);\\n        diameter=max(diameter,lh+rh);\\n        return 1+ max(lh,rh);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "the6ix",
                        "content": "What does the 1 + max(left, right) do ? can anyone please please tell me how the tracing works i would really appreciate it!!!!!"
                    },
                    {
                        "username": "22mca036",
                        "content": "first we find the left height so go to deep left and till root is null when root is null return 0 again now go to right that is also nulll so return 0 and now 1 + max(left,right) means left is = 0, right is = 0 so max 0 and add a 1 so return 1 and again back to up check for the right subtree like wise it was happend \\n"
                    },
                    {
                        "username": "animagus_",
                        "content": "Lecture 63: Love Babbar"
                    },
                    {
                        "username": "ashbelraj_99",
                        "content": "Well, you will face an issue in 104th Test case. Because in the question itself it is mentioned that the diameter is not only the longest path of any two nodes that pass through the root node.. the node could be anywhere but  path should  be longest in all possible paths in the tree"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Boyka800",
                        "content": "For this problem we can modify the code of height of the binary tree(max depth of binary tree) by adding a global variable and then update that variable to max of variable and 1+ height of left node + height of right node on every node recursively to achieve the required solution in O(n) time and without any extra space(except for recursive calls)."
                    },
                    {
                        "username": "SystemStack",
                        "content": "# Comedy Gold"
                    }
                ]
            },
            {
                "id": 1790243,
                "content": [
                    {
                        "username": "bryanba",
                        "content": " def get_height(root):\\n\\n            if(root is None):\\n                return -1\\n\\n            return 1 + max(get_height(root.left),get_height(root.right))\\n\\n        def get_height_min(root):\\n            \\n            if(root is None):\\n                return -1\\n\\n            return 1 + min(get_height(root.left),get_height(root.right))\\n\\n        def diameter(root):\\n\\n            if(root is None):\\n                return 0\\n\\n            return get_height(root) + get_height_min(root)\\n\\n\\n        return diameter(root)\\n\\n\\nWHY IS IT NOT WORKING 100/104"
                    },
                    {
                        "username": "acoa",
                        "content": "Why does i keep getting errors despite trying mutiple code?\\nLine 7: error: cannot find symbol [in __Driver__.java]\\n      int ret = new Solution().diameterOfBinaryTree(param_1);"
                    },
                    {
                        "username": "leetcontee",
                        "content": "proof\\n"
                    },
                    {
                        "username": "rboLC",
                        "content": "\n\n\n\n\n public int findHeight(TreeNode node)\n {\n\n//Official solution was a bit hard for me to follow so I have simplified it, Hope it helps someone. Basically at every node we are calculating distance of that node from its leaf... where each leaf node has distance =1 and null node has distance = 0 so \n\n        if(node == null) return 0;\n        if(node.left == null && node.right == null) return 1;\n\n//For every node, we find distance of left node and right node. And distance of parent node becomes max(leftnode, rightnode) + 1.\n\n        int leftPathLength=findHeight(node.left);\n        int rightPathLength=findHeight(node.right);\n        int distance = Math.max(leftPathLength,rightPathLength)+1;\n\n//At this time, we also have opportunity to recalculate diameter as well so \n\n        diameter = Math.max(diameter, leftPathLength+rightPathLength);\n        return distance;\n }\n\n\n \n\nand Call this distance method from  diameterOfBinaryTree on root node.\n public int diameterOfBinaryTree(TreeNode root) {\n        \n        findHeight(root);\n        return diameter;\n        \n    }\n"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        int diameter=0;\\n        height(root,diameter);\\n        return diameter;\\n    }\\n    int height(TreeNode* node,int& diameter){\\n        if(!node){\\n            return 0;\\n        }\\n        int lh=height(node->left,diameter);\\n        int rh=height(node->right,diameter);\\n        diameter=max(diameter,lh+rh);\\n        return 1+ max(lh,rh);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "the6ix",
                        "content": "What does the 1 + max(left, right) do ? can anyone please please tell me how the tracing works i would really appreciate it!!!!!"
                    },
                    {
                        "username": "22mca036",
                        "content": "first we find the left height so go to deep left and till root is null when root is null return 0 again now go to right that is also nulll so return 0 and now 1 + max(left,right) means left is = 0, right is = 0 so max 0 and add a 1 so return 1 and again back to up check for the right subtree like wise it was happend \\n"
                    },
                    {
                        "username": "animagus_",
                        "content": "Lecture 63: Love Babbar"
                    },
                    {
                        "username": "ashbelraj_99",
                        "content": "Well, you will face an issue in 104th Test case. Because in the question itself it is mentioned that the diameter is not only the longest path of any two nodes that pass through the root node.. the node could be anywhere but  path should  be longest in all possible paths in the tree"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Boyka800",
                        "content": "For this problem we can modify the code of height of the binary tree(max depth of binary tree) by adding a global variable and then update that variable to max of variable and 1+ height of left node + height of right node on every node recursively to achieve the required solution in O(n) time and without any extra space(except for recursive calls)."
                    },
                    {
                        "username": "SystemStack",
                        "content": "# Comedy Gold"
                    }
                ]
            },
            {
                "id": 1786349,
                "content": [
                    {
                        "username": "bryanba",
                        "content": " def get_height(root):\\n\\n            if(root is None):\\n                return -1\\n\\n            return 1 + max(get_height(root.left),get_height(root.right))\\n\\n        def get_height_min(root):\\n            \\n            if(root is None):\\n                return -1\\n\\n            return 1 + min(get_height(root.left),get_height(root.right))\\n\\n        def diameter(root):\\n\\n            if(root is None):\\n                return 0\\n\\n            return get_height(root) + get_height_min(root)\\n\\n\\n        return diameter(root)\\n\\n\\nWHY IS IT NOT WORKING 100/104"
                    },
                    {
                        "username": "acoa",
                        "content": "Why does i keep getting errors despite trying mutiple code?\\nLine 7: error: cannot find symbol [in __Driver__.java]\\n      int ret = new Solution().diameterOfBinaryTree(param_1);"
                    },
                    {
                        "username": "leetcontee",
                        "content": "proof\\n"
                    },
                    {
                        "username": "rboLC",
                        "content": "\n\n\n\n\n public int findHeight(TreeNode node)\n {\n\n//Official solution was a bit hard for me to follow so I have simplified it, Hope it helps someone. Basically at every node we are calculating distance of that node from its leaf... where each leaf node has distance =1 and null node has distance = 0 so \n\n        if(node == null) return 0;\n        if(node.left == null && node.right == null) return 1;\n\n//For every node, we find distance of left node and right node. And distance of parent node becomes max(leftnode, rightnode) + 1.\n\n        int leftPathLength=findHeight(node.left);\n        int rightPathLength=findHeight(node.right);\n        int distance = Math.max(leftPathLength,rightPathLength)+1;\n\n//At this time, we also have opportunity to recalculate diameter as well so \n\n        diameter = Math.max(diameter, leftPathLength+rightPathLength);\n        return distance;\n }\n\n\n \n\nand Call this distance method from  diameterOfBinaryTree on root node.\n public int diameterOfBinaryTree(TreeNode root) {\n        \n        findHeight(root);\n        return diameter;\n        \n    }\n"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        int diameter=0;\\n        height(root,diameter);\\n        return diameter;\\n    }\\n    int height(TreeNode* node,int& diameter){\\n        if(!node){\\n            return 0;\\n        }\\n        int lh=height(node->left,diameter);\\n        int rh=height(node->right,diameter);\\n        diameter=max(diameter,lh+rh);\\n        return 1+ max(lh,rh);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "the6ix",
                        "content": "What does the 1 + max(left, right) do ? can anyone please please tell me how the tracing works i would really appreciate it!!!!!"
                    },
                    {
                        "username": "22mca036",
                        "content": "first we find the left height so go to deep left and till root is null when root is null return 0 again now go to right that is also nulll so return 0 and now 1 + max(left,right) means left is = 0, right is = 0 so max 0 and add a 1 so return 1 and again back to up check for the right subtree like wise it was happend \\n"
                    },
                    {
                        "username": "animagus_",
                        "content": "Lecture 63: Love Babbar"
                    },
                    {
                        "username": "ashbelraj_99",
                        "content": "Well, you will face an issue in 104th Test case. Because in the question itself it is mentioned that the diameter is not only the longest path of any two nodes that pass through the root node.. the node could be anywhere but  path should  be longest in all possible paths in the tree"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Boyka800",
                        "content": "For this problem we can modify the code of height of the binary tree(max depth of binary tree) by adding a global variable and then update that variable to max of variable and 1+ height of left node + height of right node on every node recursively to achieve the required solution in O(n) time and without any extra space(except for recursive calls)."
                    },
                    {
                        "username": "SystemStack",
                        "content": "# Comedy Gold"
                    }
                ]
            },
            {
                "id": 1764060,
                "content": [
                    {
                        "username": "bryanba",
                        "content": " def get_height(root):\\n\\n            if(root is None):\\n                return -1\\n\\n            return 1 + max(get_height(root.left),get_height(root.right))\\n\\n        def get_height_min(root):\\n            \\n            if(root is None):\\n                return -1\\n\\n            return 1 + min(get_height(root.left),get_height(root.right))\\n\\n        def diameter(root):\\n\\n            if(root is None):\\n                return 0\\n\\n            return get_height(root) + get_height_min(root)\\n\\n\\n        return diameter(root)\\n\\n\\nWHY IS IT NOT WORKING 100/104"
                    },
                    {
                        "username": "acoa",
                        "content": "Why does i keep getting errors despite trying mutiple code?\\nLine 7: error: cannot find symbol [in __Driver__.java]\\n      int ret = new Solution().diameterOfBinaryTree(param_1);"
                    },
                    {
                        "username": "leetcontee",
                        "content": "proof\\n"
                    },
                    {
                        "username": "rboLC",
                        "content": "\n\n\n\n\n public int findHeight(TreeNode node)\n {\n\n//Official solution was a bit hard for me to follow so I have simplified it, Hope it helps someone. Basically at every node we are calculating distance of that node from its leaf... where each leaf node has distance =1 and null node has distance = 0 so \n\n        if(node == null) return 0;\n        if(node.left == null && node.right == null) return 1;\n\n//For every node, we find distance of left node and right node. And distance of parent node becomes max(leftnode, rightnode) + 1.\n\n        int leftPathLength=findHeight(node.left);\n        int rightPathLength=findHeight(node.right);\n        int distance = Math.max(leftPathLength,rightPathLength)+1;\n\n//At this time, we also have opportunity to recalculate diameter as well so \n\n        diameter = Math.max(diameter, leftPathLength+rightPathLength);\n        return distance;\n }\n\n\n \n\nand Call this distance method from  diameterOfBinaryTree on root node.\n public int diameterOfBinaryTree(TreeNode root) {\n        \n        findHeight(root);\n        return diameter;\n        \n    }\n"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        int diameter=0;\\n        height(root,diameter);\\n        return diameter;\\n    }\\n    int height(TreeNode* node,int& diameter){\\n        if(!node){\\n            return 0;\\n        }\\n        int lh=height(node->left,diameter);\\n        int rh=height(node->right,diameter);\\n        diameter=max(diameter,lh+rh);\\n        return 1+ max(lh,rh);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "the6ix",
                        "content": "What does the 1 + max(left, right) do ? can anyone please please tell me how the tracing works i would really appreciate it!!!!!"
                    },
                    {
                        "username": "22mca036",
                        "content": "first we find the left height so go to deep left and till root is null when root is null return 0 again now go to right that is also nulll so return 0 and now 1 + max(left,right) means left is = 0, right is = 0 so max 0 and add a 1 so return 1 and again back to up check for the right subtree like wise it was happend \\n"
                    },
                    {
                        "username": "animagus_",
                        "content": "Lecture 63: Love Babbar"
                    },
                    {
                        "username": "ashbelraj_99",
                        "content": "Well, you will face an issue in 104th Test case. Because in the question itself it is mentioned that the diameter is not only the longest path of any two nodes that pass through the root node.. the node could be anywhere but  path should  be longest in all possible paths in the tree"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Boyka800",
                        "content": "For this problem we can modify the code of height of the binary tree(max depth of binary tree) by adding a global variable and then update that variable to max of variable and 1+ height of left node + height of right node on every node recursively to achieve the required solution in O(n) time and without any extra space(except for recursive calls)."
                    },
                    {
                        "username": "SystemStack",
                        "content": "# Comedy Gold"
                    }
                ]
            },
            {
                "id": 1740554,
                "content": [
                    {
                        "username": "bryanba",
                        "content": " def get_height(root):\\n\\n            if(root is None):\\n                return -1\\n\\n            return 1 + max(get_height(root.left),get_height(root.right))\\n\\n        def get_height_min(root):\\n            \\n            if(root is None):\\n                return -1\\n\\n            return 1 + min(get_height(root.left),get_height(root.right))\\n\\n        def diameter(root):\\n\\n            if(root is None):\\n                return 0\\n\\n            return get_height(root) + get_height_min(root)\\n\\n\\n        return diameter(root)\\n\\n\\nWHY IS IT NOT WORKING 100/104"
                    },
                    {
                        "username": "acoa",
                        "content": "Why does i keep getting errors despite trying mutiple code?\\nLine 7: error: cannot find symbol [in __Driver__.java]\\n      int ret = new Solution().diameterOfBinaryTree(param_1);"
                    },
                    {
                        "username": "leetcontee",
                        "content": "proof\\n"
                    },
                    {
                        "username": "rboLC",
                        "content": "\n\n\n\n\n public int findHeight(TreeNode node)\n {\n\n//Official solution was a bit hard for me to follow so I have simplified it, Hope it helps someone. Basically at every node we are calculating distance of that node from its leaf... where each leaf node has distance =1 and null node has distance = 0 so \n\n        if(node == null) return 0;\n        if(node.left == null && node.right == null) return 1;\n\n//For every node, we find distance of left node and right node. And distance of parent node becomes max(leftnode, rightnode) + 1.\n\n        int leftPathLength=findHeight(node.left);\n        int rightPathLength=findHeight(node.right);\n        int distance = Math.max(leftPathLength,rightPathLength)+1;\n\n//At this time, we also have opportunity to recalculate diameter as well so \n\n        diameter = Math.max(diameter, leftPathLength+rightPathLength);\n        return distance;\n }\n\n\n \n\nand Call this distance method from  diameterOfBinaryTree on root node.\n public int diameterOfBinaryTree(TreeNode root) {\n        \n        findHeight(root);\n        return diameter;\n        \n    }\n"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        int diameter=0;\\n        height(root,diameter);\\n        return diameter;\\n    }\\n    int height(TreeNode* node,int& diameter){\\n        if(!node){\\n            return 0;\\n        }\\n        int lh=height(node->left,diameter);\\n        int rh=height(node->right,diameter);\\n        diameter=max(diameter,lh+rh);\\n        return 1+ max(lh,rh);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "the6ix",
                        "content": "What does the 1 + max(left, right) do ? can anyone please please tell me how the tracing works i would really appreciate it!!!!!"
                    },
                    {
                        "username": "22mca036",
                        "content": "first we find the left height so go to deep left and till root is null when root is null return 0 again now go to right that is also nulll so return 0 and now 1 + max(left,right) means left is = 0, right is = 0 so max 0 and add a 1 so return 1 and again back to up check for the right subtree like wise it was happend \\n"
                    },
                    {
                        "username": "animagus_",
                        "content": "Lecture 63: Love Babbar"
                    },
                    {
                        "username": "ashbelraj_99",
                        "content": "Well, you will face an issue in 104th Test case. Because in the question itself it is mentioned that the diameter is not only the longest path of any two nodes that pass through the root node.. the node could be anywhere but  path should  be longest in all possible paths in the tree"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Boyka800",
                        "content": "For this problem we can modify the code of height of the binary tree(max depth of binary tree) by adding a global variable and then update that variable to max of variable and 1+ height of left node + height of right node on every node recursively to achieve the required solution in O(n) time and without any extra space(except for recursive calls)."
                    },
                    {
                        "username": "SystemStack",
                        "content": "# Comedy Gold"
                    }
                ]
            },
            {
                "id": 1733586,
                "content": [
                    {
                        "username": "bryanba",
                        "content": " def get_height(root):\\n\\n            if(root is None):\\n                return -1\\n\\n            return 1 + max(get_height(root.left),get_height(root.right))\\n\\n        def get_height_min(root):\\n            \\n            if(root is None):\\n                return -1\\n\\n            return 1 + min(get_height(root.left),get_height(root.right))\\n\\n        def diameter(root):\\n\\n            if(root is None):\\n                return 0\\n\\n            return get_height(root) + get_height_min(root)\\n\\n\\n        return diameter(root)\\n\\n\\nWHY IS IT NOT WORKING 100/104"
                    },
                    {
                        "username": "acoa",
                        "content": "Why does i keep getting errors despite trying mutiple code?\\nLine 7: error: cannot find symbol [in __Driver__.java]\\n      int ret = new Solution().diameterOfBinaryTree(param_1);"
                    },
                    {
                        "username": "leetcontee",
                        "content": "proof\\n"
                    },
                    {
                        "username": "rboLC",
                        "content": "\n\n\n\n\n public int findHeight(TreeNode node)\n {\n\n//Official solution was a bit hard for me to follow so I have simplified it, Hope it helps someone. Basically at every node we are calculating distance of that node from its leaf... where each leaf node has distance =1 and null node has distance = 0 so \n\n        if(node == null) return 0;\n        if(node.left == null && node.right == null) return 1;\n\n//For every node, we find distance of left node and right node. And distance of parent node becomes max(leftnode, rightnode) + 1.\n\n        int leftPathLength=findHeight(node.left);\n        int rightPathLength=findHeight(node.right);\n        int distance = Math.max(leftPathLength,rightPathLength)+1;\n\n//At this time, we also have opportunity to recalculate diameter as well so \n\n        diameter = Math.max(diameter, leftPathLength+rightPathLength);\n        return distance;\n }\n\n\n \n\nand Call this distance method from  diameterOfBinaryTree on root node.\n public int diameterOfBinaryTree(TreeNode root) {\n        \n        findHeight(root);\n        return diameter;\n        \n    }\n"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        int diameter=0;\\n        height(root,diameter);\\n        return diameter;\\n    }\\n    int height(TreeNode* node,int& diameter){\\n        if(!node){\\n            return 0;\\n        }\\n        int lh=height(node->left,diameter);\\n        int rh=height(node->right,diameter);\\n        diameter=max(diameter,lh+rh);\\n        return 1+ max(lh,rh);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "the6ix",
                        "content": "What does the 1 + max(left, right) do ? can anyone please please tell me how the tracing works i would really appreciate it!!!!!"
                    },
                    {
                        "username": "22mca036",
                        "content": "first we find the left height so go to deep left and till root is null when root is null return 0 again now go to right that is also nulll so return 0 and now 1 + max(left,right) means left is = 0, right is = 0 so max 0 and add a 1 so return 1 and again back to up check for the right subtree like wise it was happend \\n"
                    },
                    {
                        "username": "animagus_",
                        "content": "Lecture 63: Love Babbar"
                    },
                    {
                        "username": "ashbelraj_99",
                        "content": "Well, you will face an issue in 104th Test case. Because in the question itself it is mentioned that the diameter is not only the longest path of any two nodes that pass through the root node.. the node could be anywhere but  path should  be longest in all possible paths in the tree"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Boyka800",
                        "content": "For this problem we can modify the code of height of the binary tree(max depth of binary tree) by adding a global variable and then update that variable to max of variable and 1+ height of left node + height of right node on every node recursively to achieve the required solution in O(n) time and without any extra space(except for recursive calls)."
                    },
                    {
                        "username": "SystemStack",
                        "content": "# Comedy Gold"
                    }
                ]
            },
            {
                "id": 1728723,
                "content": [
                    {
                        "username": "bryanba",
                        "content": " def get_height(root):\\n\\n            if(root is None):\\n                return -1\\n\\n            return 1 + max(get_height(root.left),get_height(root.right))\\n\\n        def get_height_min(root):\\n            \\n            if(root is None):\\n                return -1\\n\\n            return 1 + min(get_height(root.left),get_height(root.right))\\n\\n        def diameter(root):\\n\\n            if(root is None):\\n                return 0\\n\\n            return get_height(root) + get_height_min(root)\\n\\n\\n        return diameter(root)\\n\\n\\nWHY IS IT NOT WORKING 100/104"
                    },
                    {
                        "username": "acoa",
                        "content": "Why does i keep getting errors despite trying mutiple code?\\nLine 7: error: cannot find symbol [in __Driver__.java]\\n      int ret = new Solution().diameterOfBinaryTree(param_1);"
                    },
                    {
                        "username": "leetcontee",
                        "content": "proof\\n"
                    },
                    {
                        "username": "rboLC",
                        "content": "\n\n\n\n\n public int findHeight(TreeNode node)\n {\n\n//Official solution was a bit hard for me to follow so I have simplified it, Hope it helps someone. Basically at every node we are calculating distance of that node from its leaf... where each leaf node has distance =1 and null node has distance = 0 so \n\n        if(node == null) return 0;\n        if(node.left == null && node.right == null) return 1;\n\n//For every node, we find distance of left node and right node. And distance of parent node becomes max(leftnode, rightnode) + 1.\n\n        int leftPathLength=findHeight(node.left);\n        int rightPathLength=findHeight(node.right);\n        int distance = Math.max(leftPathLength,rightPathLength)+1;\n\n//At this time, we also have opportunity to recalculate diameter as well so \n\n        diameter = Math.max(diameter, leftPathLength+rightPathLength);\n        return distance;\n }\n\n\n \n\nand Call this distance method from  diameterOfBinaryTree on root node.\n public int diameterOfBinaryTree(TreeNode root) {\n        \n        findHeight(root);\n        return diameter;\n        \n    }\n"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        int diameter=0;\\n        height(root,diameter);\\n        return diameter;\\n    }\\n    int height(TreeNode* node,int& diameter){\\n        if(!node){\\n            return 0;\\n        }\\n        int lh=height(node->left,diameter);\\n        int rh=height(node->right,diameter);\\n        diameter=max(diameter,lh+rh);\\n        return 1+ max(lh,rh);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "the6ix",
                        "content": "What does the 1 + max(left, right) do ? can anyone please please tell me how the tracing works i would really appreciate it!!!!!"
                    },
                    {
                        "username": "22mca036",
                        "content": "first we find the left height so go to deep left and till root is null when root is null return 0 again now go to right that is also nulll so return 0 and now 1 + max(left,right) means left is = 0, right is = 0 so max 0 and add a 1 so return 1 and again back to up check for the right subtree like wise it was happend \\n"
                    },
                    {
                        "username": "animagus_",
                        "content": "Lecture 63: Love Babbar"
                    },
                    {
                        "username": "ashbelraj_99",
                        "content": "Well, you will face an issue in 104th Test case. Because in the question itself it is mentioned that the diameter is not only the longest path of any two nodes that pass through the root node.. the node could be anywhere but  path should  be longest in all possible paths in the tree"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Boyka800",
                        "content": "For this problem we can modify the code of height of the binary tree(max depth of binary tree) by adding a global variable and then update that variable to max of variable and 1+ height of left node + height of right node on every node recursively to achieve the required solution in O(n) time and without any extra space(except for recursive calls)."
                    },
                    {
                        "username": "SystemStack",
                        "content": "# Comedy Gold"
                    }
                ]
            },
            {
                "id": 1728225,
                "content": [
                    {
                        "username": "bryanba",
                        "content": " def get_height(root):\\n\\n            if(root is None):\\n                return -1\\n\\n            return 1 + max(get_height(root.left),get_height(root.right))\\n\\n        def get_height_min(root):\\n            \\n            if(root is None):\\n                return -1\\n\\n            return 1 + min(get_height(root.left),get_height(root.right))\\n\\n        def diameter(root):\\n\\n            if(root is None):\\n                return 0\\n\\n            return get_height(root) + get_height_min(root)\\n\\n\\n        return diameter(root)\\n\\n\\nWHY IS IT NOT WORKING 100/104"
                    },
                    {
                        "username": "acoa",
                        "content": "Why does i keep getting errors despite trying mutiple code?\\nLine 7: error: cannot find symbol [in __Driver__.java]\\n      int ret = new Solution().diameterOfBinaryTree(param_1);"
                    },
                    {
                        "username": "leetcontee",
                        "content": "proof\\n"
                    },
                    {
                        "username": "rboLC",
                        "content": "\n\n\n\n\n public int findHeight(TreeNode node)\n {\n\n//Official solution was a bit hard for me to follow so I have simplified it, Hope it helps someone. Basically at every node we are calculating distance of that node from its leaf... where each leaf node has distance =1 and null node has distance = 0 so \n\n        if(node == null) return 0;\n        if(node.left == null && node.right == null) return 1;\n\n//For every node, we find distance of left node and right node. And distance of parent node becomes max(leftnode, rightnode) + 1.\n\n        int leftPathLength=findHeight(node.left);\n        int rightPathLength=findHeight(node.right);\n        int distance = Math.max(leftPathLength,rightPathLength)+1;\n\n//At this time, we also have opportunity to recalculate diameter as well so \n\n        diameter = Math.max(diameter, leftPathLength+rightPathLength);\n        return distance;\n }\n\n\n \n\nand Call this distance method from  diameterOfBinaryTree on root node.\n public int diameterOfBinaryTree(TreeNode root) {\n        \n        findHeight(root);\n        return diameter;\n        \n    }\n"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        int diameter=0;\\n        height(root,diameter);\\n        return diameter;\\n    }\\n    int height(TreeNode* node,int& diameter){\\n        if(!node){\\n            return 0;\\n        }\\n        int lh=height(node->left,diameter);\\n        int rh=height(node->right,diameter);\\n        diameter=max(diameter,lh+rh);\\n        return 1+ max(lh,rh);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "the6ix",
                        "content": "What does the 1 + max(left, right) do ? can anyone please please tell me how the tracing works i would really appreciate it!!!!!"
                    },
                    {
                        "username": "22mca036",
                        "content": "first we find the left height so go to deep left and till root is null when root is null return 0 again now go to right that is also nulll so return 0 and now 1 + max(left,right) means left is = 0, right is = 0 so max 0 and add a 1 so return 1 and again back to up check for the right subtree like wise it was happend \\n"
                    },
                    {
                        "username": "animagus_",
                        "content": "Lecture 63: Love Babbar"
                    },
                    {
                        "username": "ashbelraj_99",
                        "content": "Well, you will face an issue in 104th Test case. Because in the question itself it is mentioned that the diameter is not only the longest path of any two nodes that pass through the root node.. the node could be anywhere but  path should  be longest in all possible paths in the tree"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Boyka800",
                        "content": "For this problem we can modify the code of height of the binary tree(max depth of binary tree) by adding a global variable and then update that variable to max of variable and 1+ height of left node + height of right node on every node recursively to achieve the required solution in O(n) time and without any extra space(except for recursive calls)."
                    },
                    {
                        "username": "SystemStack",
                        "content": "# Comedy Gold"
                    }
                ]
            },
            {
                "id": 1677662,
                "content": [
                    {
                        "username": "bryanba",
                        "content": " def get_height(root):\\n\\n            if(root is None):\\n                return -1\\n\\n            return 1 + max(get_height(root.left),get_height(root.right))\\n\\n        def get_height_min(root):\\n            \\n            if(root is None):\\n                return -1\\n\\n            return 1 + min(get_height(root.left),get_height(root.right))\\n\\n        def diameter(root):\\n\\n            if(root is None):\\n                return 0\\n\\n            return get_height(root) + get_height_min(root)\\n\\n\\n        return diameter(root)\\n\\n\\nWHY IS IT NOT WORKING 100/104"
                    },
                    {
                        "username": "acoa",
                        "content": "Why does i keep getting errors despite trying mutiple code?\\nLine 7: error: cannot find symbol [in __Driver__.java]\\n      int ret = new Solution().diameterOfBinaryTree(param_1);"
                    },
                    {
                        "username": "leetcontee",
                        "content": "proof\\n"
                    },
                    {
                        "username": "rboLC",
                        "content": "\n\n\n\n\n public int findHeight(TreeNode node)\n {\n\n//Official solution was a bit hard for me to follow so I have simplified it, Hope it helps someone. Basically at every node we are calculating distance of that node from its leaf... where each leaf node has distance =1 and null node has distance = 0 so \n\n        if(node == null) return 0;\n        if(node.left == null && node.right == null) return 1;\n\n//For every node, we find distance of left node and right node. And distance of parent node becomes max(leftnode, rightnode) + 1.\n\n        int leftPathLength=findHeight(node.left);\n        int rightPathLength=findHeight(node.right);\n        int distance = Math.max(leftPathLength,rightPathLength)+1;\n\n//At this time, we also have opportunity to recalculate diameter as well so \n\n        diameter = Math.max(diameter, leftPathLength+rightPathLength);\n        return distance;\n }\n\n\n \n\nand Call this distance method from  diameterOfBinaryTree on root node.\n public int diameterOfBinaryTree(TreeNode root) {\n        \n        findHeight(root);\n        return diameter;\n        \n    }\n"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        int diameter=0;\\n        height(root,diameter);\\n        return diameter;\\n    }\\n    int height(TreeNode* node,int& diameter){\\n        if(!node){\\n            return 0;\\n        }\\n        int lh=height(node->left,diameter);\\n        int rh=height(node->right,diameter);\\n        diameter=max(diameter,lh+rh);\\n        return 1+ max(lh,rh);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "the6ix",
                        "content": "What does the 1 + max(left, right) do ? can anyone please please tell me how the tracing works i would really appreciate it!!!!!"
                    },
                    {
                        "username": "22mca036",
                        "content": "first we find the left height so go to deep left and till root is null when root is null return 0 again now go to right that is also nulll so return 0 and now 1 + max(left,right) means left is = 0, right is = 0 so max 0 and add a 1 so return 1 and again back to up check for the right subtree like wise it was happend \\n"
                    },
                    {
                        "username": "animagus_",
                        "content": "Lecture 63: Love Babbar"
                    },
                    {
                        "username": "ashbelraj_99",
                        "content": "Well, you will face an issue in 104th Test case. Because in the question itself it is mentioned that the diameter is not only the longest path of any two nodes that pass through the root node.. the node could be anywhere but  path should  be longest in all possible paths in the tree"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Boyka800",
                        "content": "For this problem we can modify the code of height of the binary tree(max depth of binary tree) by adding a global variable and then update that variable to max of variable and 1+ height of left node + height of right node on every node recursively to achieve the required solution in O(n) time and without any extra space(except for recursive calls)."
                    },
                    {
                        "username": "SystemStack",
                        "content": "# Comedy Gold"
                    }
                ]
            },
            {
                "id": 1673342,
                "content": [
                    {
                        "username": "bryanba",
                        "content": " def get_height(root):\\n\\n            if(root is None):\\n                return -1\\n\\n            return 1 + max(get_height(root.left),get_height(root.right))\\n\\n        def get_height_min(root):\\n            \\n            if(root is None):\\n                return -1\\n\\n            return 1 + min(get_height(root.left),get_height(root.right))\\n\\n        def diameter(root):\\n\\n            if(root is None):\\n                return 0\\n\\n            return get_height(root) + get_height_min(root)\\n\\n\\n        return diameter(root)\\n\\n\\nWHY IS IT NOT WORKING 100/104"
                    },
                    {
                        "username": "acoa",
                        "content": "Why does i keep getting errors despite trying mutiple code?\\nLine 7: error: cannot find symbol [in __Driver__.java]\\n      int ret = new Solution().diameterOfBinaryTree(param_1);"
                    },
                    {
                        "username": "leetcontee",
                        "content": "proof\\n"
                    },
                    {
                        "username": "rboLC",
                        "content": "\n\n\n\n\n public int findHeight(TreeNode node)\n {\n\n//Official solution was a bit hard for me to follow so I have simplified it, Hope it helps someone. Basically at every node we are calculating distance of that node from its leaf... where each leaf node has distance =1 and null node has distance = 0 so \n\n        if(node == null) return 0;\n        if(node.left == null && node.right == null) return 1;\n\n//For every node, we find distance of left node and right node. And distance of parent node becomes max(leftnode, rightnode) + 1.\n\n        int leftPathLength=findHeight(node.left);\n        int rightPathLength=findHeight(node.right);\n        int distance = Math.max(leftPathLength,rightPathLength)+1;\n\n//At this time, we also have opportunity to recalculate diameter as well so \n\n        diameter = Math.max(diameter, leftPathLength+rightPathLength);\n        return distance;\n }\n\n\n \n\nand Call this distance method from  diameterOfBinaryTree on root node.\n public int diameterOfBinaryTree(TreeNode root) {\n        \n        findHeight(root);\n        return diameter;\n        \n    }\n"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        int diameter=0;\\n        height(root,diameter);\\n        return diameter;\\n    }\\n    int height(TreeNode* node,int& diameter){\\n        if(!node){\\n            return 0;\\n        }\\n        int lh=height(node->left,diameter);\\n        int rh=height(node->right,diameter);\\n        diameter=max(diameter,lh+rh);\\n        return 1+ max(lh,rh);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "the6ix",
                        "content": "What does the 1 + max(left, right) do ? can anyone please please tell me how the tracing works i would really appreciate it!!!!!"
                    },
                    {
                        "username": "22mca036",
                        "content": "first we find the left height so go to deep left and till root is null when root is null return 0 again now go to right that is also nulll so return 0 and now 1 + max(left,right) means left is = 0, right is = 0 so max 0 and add a 1 so return 1 and again back to up check for the right subtree like wise it was happend \\n"
                    },
                    {
                        "username": "animagus_",
                        "content": "Lecture 63: Love Babbar"
                    },
                    {
                        "username": "ashbelraj_99",
                        "content": "Well, you will face an issue in 104th Test case. Because in the question itself it is mentioned that the diameter is not only the longest path of any two nodes that pass through the root node.. the node could be anywhere but  path should  be longest in all possible paths in the tree"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Boyka800",
                        "content": "For this problem we can modify the code of height of the binary tree(max depth of binary tree) by adding a global variable and then update that variable to max of variable and 1+ height of left node + height of right node on every node recursively to achieve the required solution in O(n) time and without any extra space(except for recursive calls)."
                    },
                    {
                        "username": "SystemStack",
                        "content": "# Comedy Gold"
                    }
                ]
            }
        ]
    }
]