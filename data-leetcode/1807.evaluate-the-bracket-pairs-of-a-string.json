[
    {
        "title": "Broken Calculator",
        "question_content": "There is a broken calculator that has the integer startValue on its display initially. In one operation, you can:\n\n\tmultiply the number on display by 2, or\n\tsubtract 1 from the number on display.\n\nGiven two integers startValue and target, return the minimum number of operations needed to display target on the calculator.\n&nbsp;\nExample 1:\n\nInput: startValue = 2, target = 3\nOutput: 2\nExplanation: Use double operation and then decrement operation {2 -> 4 -> 3}.\n\nExample 2:\n\nInput: startValue = 5, target = 8\nOutput: 2\nExplanation: Use decrement and then double {5 -> 4 -> 8}.\n\nExample 3:\n\nInput: startValue = 3, target = 10\nOutput: 3\nExplanation: Use double, decrement and double {3 -> 6 -> 5 -> 10}.\n\n&nbsp;\nConstraints:\n\n\t1 <= startValue, target <= 109",
        "solutions": [
            {
                "id": 1874851,
                "title": "c-easy-approach-proper-explanation",
                "content": "### First Approach\\n```\\nAfter reading the problem first approach which would come in my mind is based on the operation which is given.\\nThat is multiplying and subtracting for reaching from \\'startValue\\' to \\'target\\' value.\\nThere would be possibly three cases in this...\\n1. If startValue == target then it will be zero.\\n2. If startValue > target then we only subtract by 1 till we get startValue == target.\\n3. If startValue < target then we only multiply it by till we get startValue equal to target or startValue > target. If startValue get greater than target then we only perform decrementing it.\\n \\n But this approach fails in second case \\'\\uD83D\\uDE05\\'  \\n\\tI/P startValue = 5 target = 8\\n\\tAcc to my approach \\n\\tFirst we go from 5->10 ( X 2 )\\n\\tSecond we subtract 10 -> 9 -> 8 \\n\\tTotal steps is 3.\\n\\tBut the answer is 2;\\n\\tHOW ?? by just decreasing by 1 and then multiplying by 2 i.e 5 -> 4 -> 8.\\n```\\n### Second Approach\\n```\\nInstead of going from startValue to target value we go for opposite i.e target value to startValue.\\nBy reversing the operation i.e instead of multiplying we go for dividing and instead of subtarcting we go for adding.\\nThere would be also possibly three cases in this...\\n1. If target == startValue then it will be zero.\\n2. If  target > startValue then we only divide it by 2 till we get startValue == target or startValue get greater than target. \\n\\tIN STEP SECOND WE HAVE ONE MORE SUB CASES.\\n\\tWe only go for division if target is even else we only increase target by 1.\\n3. If target < startValue then we only increment it by 1.\\n\\nExample \\n\\tI/P  startValue = 5   target = 8\\n\\tStep - 1 target > startValue then divide target by 2 , it becomes 4.\\n\\tStep - 2 target < startValue then we only add by 1 till we get target == startValue. We can only find it by subtracting startValue - target value as startValue is > than target in this case.\\n\\tTherfore total no of steps taken is divide->add i.e \\'2\\' which is the answer.\\n```\\nALGORITHM\\n```\\nStep-1 Declare step counter with initial value 0.\\nStep-2 Start Iterating with condition check whether target value is greater than startValue or not.\\nStep-3 If target > startValue increment step counter by 1. And check whether target value is even or odd.\\nStep-4 If target value is even then divide it by 2 else if it is odd add target value by 1.\\nStep-5 Loop continues till target become small or equal to startValue.\\nStep-6 If target <  startValue then we only add target by 1 till it become equal. So total number of add required can be found by \\'startValue - target\\'. Because currently startValue is > targetValue.\\nStep-7 Return step+startValue - target ;\\n```\\nIF there is some typing mistake then for that i apologize. Thanks for reviewing my idea.\\n\\n### IMPORTANT POINTS\\n```\\nThanks to \\xA0brent7890\\uD83D\\uDE01\\nThe reason why we increment then immediately divide by 2, rather than incrementing more than once and dividing by 2, is simply because, well, better explained in an example:\\n\\nsay our target is 201. Then, say input is 10, or whatever, something smaller.\\n\\nIf, somehow, we think, maybe\\n102*2 = 204 then 204 - 1 - 1 - 1 = 201, in total this is 4 operations.\\n\\ninstead, if we consider\\n102 - 1 = 101 then 101 * 2 = 202 then 202 - 1 = 201, in total is only 3 operations.\\n\\nBut, to put it in reverse, starting from the target, the way to think about this intuitively is, if we start from a target (prior to dividing by 2) and increment to a larger number, how every many times we increment, we\\'re incrementing by a factor of 2 more than if we simply divide by 2 first, then increment on the smaller number.\\n\\nThat\\'s why this process is optimal.\\n```\\n### CODE\\n``` \\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int result=0;\\n        while(target>startValue)\\n        {\\n            result++;\\n            if(target%2==0)\\n                target=target/2;\\n            else\\n                target+=1;\\n        }\\n        result=result+(startValue-target);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nAfter reading the problem first approach which would come in my mind is based on the operation which is given.\\nThat is multiplying and subtracting for reaching from \\'startValue\\' to \\'target\\' value.\\nThere would be possibly three cases in this...\\n1. If startValue == target then it will be zero.\\n2. If startValue > target then we only subtract by 1 till we get startValue == target.\\n3. If startValue < target then we only multiply it by till we get startValue equal to target or startValue > target. If startValue get greater than target then we only perform decrementing it.\\n \\n But this approach fails in second case \\'\\uD83D\\uDE05\\'  \\n\\tI/P startValue = 5 target = 8\\n\\tAcc to my approach \\n\\tFirst we go from 5->10 ( X 2 )\\n\\tSecond we subtract 10 -> 9 -> 8 \\n\\tTotal steps is 3.\\n\\tBut the answer is 2;\\n\\tHOW ?? by just decreasing by 1 and then multiplying by 2 i.e 5 -> 4 -> 8.\\n```\n```\\nInstead of going from startValue to target value we go for opposite i.e target value to startValue.\\nBy reversing the operation i.e instead of multiplying we go for dividing and instead of subtarcting we go for adding.\\nThere would be also possibly three cases in this...\\n1. If target == startValue then it will be zero.\\n2. If  target > startValue then we only divide it by 2 till we get startValue == target or startValue get greater than target. \\n\\tIN STEP SECOND WE HAVE ONE MORE SUB CASES.\\n\\tWe only go for division if target is even else we only increase target by 1.\\n3. If target < startValue then we only increment it by 1.\\n\\nExample \\n\\tI/P  startValue = 5   target = 8\\n\\tStep - 1 target > startValue then divide target by 2 , it becomes 4.\\n\\tStep - 2 target < startValue then we only add by 1 till we get target == startValue. We can only find it by subtracting startValue - target value as startValue is > than target in this case.\\n\\tTherfore total no of steps taken is divide->add i.e \\'2\\' which is the answer.\\n```\n```\\nStep-1 Declare step counter with initial value 0.\\nStep-2 Start Iterating with condition check whether target value is greater than startValue or not.\\nStep-3 If target > startValue increment step counter by 1. And check whether target value is even or odd.\\nStep-4 If target value is even then divide it by 2 else if it is odd add target value by 1.\\nStep-5 Loop continues till target become small or equal to startValue.\\nStep-6 If target <  startValue then we only add target by 1 till it become equal. So total number of add required can be found by \\'startValue - target\\'. Because currently startValue is > targetValue.\\nStep-7 Return step+startValue - target ;\\n```\n```\\nThanks to \\xA0brent7890\\uD83D\\uDE01\\nThe reason why we increment then immediately divide by 2, rather than incrementing more than once and dividing by 2, is simply because, well, better explained in an example:\\n\\nsay our target is 201. Then, say input is 10, or whatever, something smaller.\\n\\nIf, somehow, we think, maybe\\n102*2 = 204 then 204 - 1 - 1 - 1 = 201, in total this is 4 operations.\\n\\ninstead, if we consider\\n102 - 1 = 101 then 101 * 2 = 202 then 202 - 1 = 201, in total is only 3 operations.\\n\\nBut, to put it in reverse, starting from the target, the way to think about this intuitively is, if we start from a target (prior to dividing by 2) and increment to a larger number, how every many times we increment, we\\'re incrementing by a factor of 2 more than if we simply divide by 2 first, then increment on the smaller number.\\n\\nThat\\'s why this process is optimal.\\n```\n``` \\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int result=0;\\n        while(target>startValue)\\n        {\\n            result++;\\n            if(target%2==0)\\n                target=target/2;\\n            else\\n                target+=1;\\n        }\\n        result=result+(startValue-target);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1874813,
                "title": "java-c-recursive-iterative-solution",
                "content": "How\\'s going Ladies - n - Gentlemen, today we are going to solve another coolest problem i.e. **Broken Calculator**\\n\\nSo, what the question is saying is :-\\n```\\n=>Given Two Number\\'s startValue & target\\n=>find Minimum number of operation\\'s to convert startValue to target\\n```\\nNow what operation\\'s question is saying to perform:\\n```\\n=>multiply the number on display by 2, or\\n=>subtract 1 from the number on display.\\n```\\n\\nBut we\\'ll modify the operation\\'s inorder to get our result! We are going to solve our problem in 2 way\\'s **Recursive** &  **Iterative**\\n\\n```\\nRecursive Approach\\n```\\nif `startValue >= target`, then we have to **subtract by 1**\\nOtherwise,\\nif it is `even`, then the only way is to **divide it by 2**\\nIf it is `odd`, then there\\'s no way other than to **add 1 to change to even**\\n\\n**Java**\\n```\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        if(startValue >= target) return startValue - target;\\n        if(target % 2 == 0){\\n            return 1 + brokenCalc(startValue, target / 2);\\n        }\\n        return 1 + brokenCalc(startValue, target + 1);\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        if(startValue >= target) return startValue - target;\\n        if(target % 2 == 0){\\n            return 1 + brokenCalc(startValue, target / 2);\\n        }\\n        return 1 + brokenCalc(startValue, target + 1);\\n    }\\n};\\n```\\nANALYSIS :-\\n* **Time Complexity :-** BigO(logN)\\n\\n* **Space Complexity :-** BigO(1)\\n\\n```\\nIterative Approach\\n```\\nSimilar to recursive,\\nRun the loop until `target` becomes **>** `startValue`\\nWhat you have to perform:-\\nif it is `even`, then the only way is to **divide it by 2**\\nIf it is `odd`, then there\\'s no way other than to **add 1 to change to even**\\n\\n**Let\\'s understand a way more deeper:**\\n\\nWe\\'re only allowed to do \"Double\" and \"Decrement\" operation to startValue,\\nIn the case of change startValue to target, considering target = startValue*(2^n) + 1, where n can be any given number.\\nWe can double startValue for n + 1 times, then, do decrement for startValue*(2^n) - 1 times, which make startValue = target.\\nWhen n get bigger, which means we perform more double operations, the number of required decrement operation would increase exponentially in this case.\\n\\nOn the other hand, if we change target to startValue,\\nwe can do operations to target which are exactly opposite to what we can do to startValue.\\nThat is:\\n\\nDivision: Divide by 2\\nIncrement: Add by 1\\nIn the same case of target = startValue*(2^n) + 1\\nmore division operations we perform, the number of increment operation would decrease exponentially.\\nTherefore, do as many division operations as we can which would lead to minumum number of operation needed to change target to startValue.\\n\\n\\n**Java**\\n```\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        int result = 0;\\n        while(target > startValue){\\n            if(target % 2 == 0){\\n                target /= 2;\\n            }\\n            else{\\n                target++;\\n            }\\n            result++;\\n        }\\n        return result + (startValue - target);\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int result = 0;\\n        while(target > startValue){\\n            if(target % 2 == 0){\\n                target /= 2;\\n            }\\n            else{\\n                target++;\\n            }\\n            result++;\\n        }\\n        return result + (startValue - target);\\n    }\\n};\\n```\\n\\nANALYSIS :-\\n* **Time Complexity :-** BigO(logN)\\n\\n* **Space Complexity :-** BigO(1)\\n",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\n=>Given Two Number\\'s startValue & target\\n=>find Minimum number of operation\\'s to convert startValue to target\\n```\n```\\n=>multiply the number on display by 2, or\\n=>subtract 1 from the number on display.\\n```\n```\\nRecursive Approach\\n```\n```\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        if(startValue >= target) return startValue - target;\\n        if(target % 2 == 0){\\n            return 1 + brokenCalc(startValue, target / 2);\\n        }\\n        return 1 + brokenCalc(startValue, target + 1);\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        if(startValue >= target) return startValue - target;\\n        if(target % 2 == 0){\\n            return 1 + brokenCalc(startValue, target / 2);\\n        }\\n        return 1 + brokenCalc(startValue, target + 1);\\n    }\\n};\\n```\n```\\nIterative Approach\\n```\n```\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        int result = 0;\\n        while(target > startValue){\\n            if(target % 2 == 0){\\n                target /= 2;\\n            }\\n            else{\\n                target++;\\n            }\\n            result++;\\n        }\\n        return result + (startValue - target);\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int result = 0;\\n        while(target > startValue){\\n            if(target % 2 == 0){\\n                target /= 2;\\n            }\\n            else{\\n                target++;\\n            }\\n            result++;\\n        }\\n        return result + (startValue - target);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875138,
                "title": "c-iterative-100-faster-o-1-space",
                "content": "*Upvote if helpful*\\n\\n**Approach**\\n```\\n1. reduce target value as much as possible  because this question can be done by greedy\\n2. if divisible by 2 divide by 2  \\n3. else increase by 1\\n4. if target becomes less than startValue then only option left is to increasse\\n```\\n\\n\\n\\n**CODE**\\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        long long ans = 0;\\n        long long tar = target;\\n        while(startValue != tar){\\n            if(tar%2 == 0 and startValue < tar){\\n                tar /= 2;\\n            }\\n            else if(tar > startValue){\\n                tar +=1;\\n            }\\n            else{\\n                ans += abs(tar-startValue)-1;\\n                tar = startValue;\\n            }\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n1. reduce target value as much as possible  because this question can be done by greedy\\n2. if divisible by 2 divide by 2  \\n3. else increase by 1\\n4. if target becomes less than startValue then only option left is to increasse\\n```\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        long long ans = 0;\\n        long long tar = target;\\n        while(startValue != tar){\\n            if(tar%2 == 0 and startValue < tar){\\n                tar /= 2;\\n            }\\n            else if(tar > startValue){\\n                tar +=1;\\n            }\\n            else{\\n                ans += abs(tar-startValue)-1;\\n                tar = startValue;\\n            }\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 234484,
                "title": "java-c-python-change-y-to-x-in-1-line",
                "content": "## **Intuition**:\\n\\nConsidering how to change `Y` to `X`\\nOperation 1: `Y = Y / 2` if `Y` is even\\nOperation 2: `Y = Y + 1`\\n<br>\\n\\n## **Explanation**:\\n\\nObviously,\\nIf `Y <= X`, we won\\'t do `Y / 2` anymore.\\nWe will increase `Y` until it equals to `X`\\n\\nSo before that, while `Y > X`, we\\'ll keep reducing `Y`, until it\\'s smaller than `X`.\\nIf `Y` is odd, we can do only `Y = Y + 1`\\nIf `Y` is even, if we plus 1 to `Y`, then `Y` is odd, we need to plus another 1.\\nAnd because `(Y + 1 + 1) / 2 = (Y / 2) + 1`, 3 operations are more than 2.\\nWe always choose `Y / 2` if `Y` is even. \\n<br>\\n\\n## **Why it\\'s right**\\nActually, what we do is:\\nIf `Y` is even, `Y = Y / 2`\\nIf `Y` is odd, `Y = (Y + 1) / 2`\\n\\nWe reduce `Y` with least possible operations, until it\\'s smaller than `X`.\\n\\nAnd we know that, we won\\'t do `Y + 1` twice in a row.\\nBecasue we will always end with an operation `Y / 2`.\\n\\n2N times `Y + 1` and once `Y / 2` needs 2N + 1 operations.\\nOnce `Y / 2` first and N times `Y + 1` will end up with same result, but needs only N + 1 operations.\\n<br>\\n\\n## **Time complexity**\\nWe do `Y/2` all the way until it\\'s smaller than `X`,\\ntime complexity is `O(log(Y/X))`.\\n<br>\\n\\n**Java/C++**\\n```\\n        int res = 0;\\n        while (Y > X) {\\n            Y = Y % 2 > 0 ? Y + 1 : Y / 2;\\n            res++;\\n        }\\n        return res + X - Y;\\n```\\n\\n**Python:**\\n```\\n    def brokenCalc(self, X, Y):\\n        res = 0\\n        while X < Y:\\n            res += Y % 2 + 1\\n            Y = (Y + 1) / 2\\n        return res + X - Y\\n```\\n\\n<br>\\n\\n## **1 line Recursive Solution**\\n**Java/C++**\\n```\\n        return X >= Y ? X - Y : 1 + Y % 2 + brokenCalc(X, (Y + 1) / 2);\\n```\\n\\n**Python:**\\n```\\n        return X - Y if X >= Y else 1 + Y % 2 + self.brokenCalc(X, (Y + 1) / 2)\\n```\\n\\n<br>\\n\\n## **FAQ, Updated on 2019-02-11**\\n\\n**Q: Can we try to change X to Y?**\\n**A:** Yes we can.\\n\\n**Java**\\n```\\n    public int brokenCalc(int X, int Y) {\\n        int multiple = 1, res = 0;\\n        while (X * multiple < Y) {\\n            multiple <<= 1;\\n            res++;\\n        }\\n        int diff = X * multiple - Y;\\n        while (diff > 0) {  \\n            res += diff / multiple;\\n            diff -= diff / multiple * multiple;\\n            multiple >>= 1;\\n        }\\n        return res;\\n    }\\n```\\n**C++**\\n```\\n    int brokenCalc(int X, int Y) {\\n        int multiple = 1, res = 0;\\n        while (X * multiple < Y)\\n            multiple <<= 1, res++;\\n        int diff = X * multiple - Y;\\n        while (diff > 0) {  \\n            res += diff / multiple;\\n            diff -= diff / multiple * multiple;\\n            multiple >>= 1;\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python:**\\n```\\n    def brokenCalc(self, X, Y):\\n        multiple = 1\\n        res = 0\\n        while X * multiple < Y:\\n            multiple *= 2\\n            res += 1\\n        diff = X * multiple - Y\\n        while diff:\\n            res += diff / multiple\\n            diff -= diff / multiple * multiple\\n            multiple /= 2\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n        int res = 0;\\n        while (Y > X) {\\n            Y = Y % 2 > 0 ? Y + 1 : Y / 2;\\n            res++;\\n        }\\n        return res + X - Y;\\n```\n```\\n    def brokenCalc(self, X, Y):\\n        res = 0\\n        while X < Y:\\n            res += Y % 2 + 1\\n            Y = (Y + 1) / 2\\n        return res + X - Y\\n```\n```\\n        return X >= Y ? X - Y : 1 + Y % 2 + brokenCalc(X, (Y + 1) / 2);\\n```\n```\\n        return X - Y if X >= Y else 1 + Y % 2 + self.brokenCalc(X, (Y + 1) / 2)\\n```\n```\\n    public int brokenCalc(int X, int Y) {\\n        int multiple = 1, res = 0;\\n        while (X * multiple < Y) {\\n            multiple <<= 1;\\n            res++;\\n        }\\n        int diff = X * multiple - Y;\\n        while (diff > 0) {  \\n            res += diff / multiple;\\n            diff -= diff / multiple * multiple;\\n            multiple >>= 1;\\n        }\\n        return res;\\n    }\\n```\n```\\n    int brokenCalc(int X, int Y) {\\n        int multiple = 1, res = 0;\\n        while (X * multiple < Y)\\n            multiple <<= 1, res++;\\n        int diff = X * multiple - Y;\\n        while (diff > 0) {  \\n            res += diff / multiple;\\n            diff -= diff / multiple * multiple;\\n            multiple >>= 1;\\n        }\\n        return res;\\n    }\\n```\n```\\n    def brokenCalc(self, X, Y):\\n        multiple = 1\\n        res = 0\\n        while X * multiple < Y:\\n            multiple *= 2\\n            res += 1\\n        diff = X * multiple - Y\\n        while diff:\\n            res += diff / multiple\\n            diff -= diff / multiple * multiple\\n            multiple /= 2\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 236565,
                "title": "detailed-proof-of-correctness-greedy-algorithm",
                "content": "**Credits** -- Motivation to convert `y` to `x` inspired by [lee215\\'s Solution](https://leetcode.com/problems/broken-calculator/discuss/234484/JavaC%2B%2BPython-Change-Y-to-X-in-1-Line)\\n\\n\\nFirst, Let use see if the solution exists or not.\\nClearly, we can keep doubling ` x ` till it goes beyond ` y`. Then we can keep decrementing `x` till it reaches `y`. Since the number of operations  is not limited, so we conclude that a solution exists.\\n\\nSo now, consider an optimal solution (any solution with the minimal number of steps). \\nThe path is nothing but a sequence of numbers that start at `x` and end at `y`. \\n\\n`Assume (x<=y)`. The other case is trivial\\n\\n# Case 1) ***Y is odd***\\n\\nNow, consider the last second element of the sequence (optimal path). Recall that we can only move in the sequence via the allowed moves (in the forward direction, we multiply by 2 or decrement by 1). Let us backtrack and see which move did we actually use to get to `y`. (obviously it has to be one of the two moves).\\n\\nNow, the move could not have been multiplication by 2, or else `y` would have been a multiple of 2, which violates our assumption. So the only possible move is the decrement move. It means that the last second term of the sequence is indeed `y+1` if `y` is odd. (And there is no other possibility).\\n\\nSo now we just need to compute the optimal length to reach `y+1`, and then add 1 to our answer to get the optimal path length for `y`. (Why? It happens because `y+1` lies in an optimal path and any subpath of the optimal path must be optimal or else it would violate our assumptions).\\n\\n\\n# Case 2)***Y is even. Say, y=2m***\\n\\nFirst, let us study the worst case analysis of what is the maximum number that you would touch if you play optimally.\\n\\nClearly it is `2*(y-1)`, since in the worst case, you may end up starting at `y-1` and jumping to `2*(y-1)` and then coming back. In all other cases, the jump will lead you to a number less than `2*(y-1)` and you can easily come back to `y` one step at a time.\\n\\nLet us denote `2*(y-1)` as `jump_max`.\\n\\n\\nNow, If `y` is even, we cannot say anything about the last second term of the sequence. (The move could be either multiplication or decrement).\\n\\nHowever, let us see what happens if the last move was multiplication by 2. \\n\\nClearly , the last second element in this case is `y/2` = `m`\\n\\nSo we need to compute the optimal path length to reach `m` and then we can add 1 to our answer. (But this is valid only if we know that the last move was indeed multiplication.)\\n\\n***What if the last move was decrement?***\\n\\nIn that case, the last second element becomes `2m+1`, (odd number) , and by the 1st lemma, we conclude that the last third number is `2m+2`. \\n\\nNow `2m+2` is an even number so either a jump happens or it\\'s descendant is `2m+4`. So we keep going to the right untill we find a`k` such that `2m+2k` is obtained by jumping from `m+k`. Clearly such a number exists as the largest number we can encounter is `jump_max`.\\n\\nSo, now the path looks like \\n\\n`x` .......  `(m+k)` -> `2(m+k)`  -> `(2m+2k-1)` -> `(2m+2k-2) -> ....... `y`\\n\\nBut, if you observe carefully, after we reach `(m+k)` we can decrement `k` times to reach `m` and then double to get `y`. This would cost us `(k+1)` operations `+` the cost to reach `(m+k)`. However, the current cost is `(1 + 2(m+k) - 2m)` = `(2k+1)` operations `+` the cost to reach `(m+k)`. Since the new cost is lower, this violates our assumption that the original sequence was an optimal path. Therefore we have a contradiction and we conclude that the last move could not have been decrement.\\n\\n# **Conclusion**\\n\\nIf `y` is odd, we know that the last number to be reached before `y` is `(y+1)` (in the optimal path)\\n\\nIf `y` is even, we know that the last number to be reached before `y` is `y/2` (in the optimal path).\\n\\nSo finally we have our recursive relation.\\n\\n`if`(x>=y)\\n`cost`(x,y) = x-y\\n\\n\\n`if`(x< y)\\n`cost` (x,y) = 1 + `cost`(x,y+1) if `y` is odd\\n`cost` (x,y) = 1 + `cost`(x,y/2) if `y` is even \\n\\nHere\\'s the iterative implementation\\n\\n```\\nint brokenCalc(int x, int y)\\n{\\n    int count=0;\\n    while(y!=x)\\n    {\\n        if(x>=y) return ((x-y) + count);\\n        \\n        /* If y is even, the last move was multiplication, else decrement */\\n        if(y%2==0) y=y/2 ;\\n        else y++;\\n        \\n        // One operation used\\n        count ++;\\n    }\\n    \\n    return count;\\n}\\n```\\n\\nSorry, It got too long but I hope you get the gist.\\n\\n.",
                "solutionTags": [],
                "code": "```\\nint brokenCalc(int x, int y)\\n{\\n    int count=0;\\n    while(y!=x)\\n    {\\n        if(x>=y) return ((x-y) + count);\\n        \\n        /* If y is even, the last move was multiplication, else decrement */\\n        if(y%2==0) y=y/2 ;\\n        else y++;\\n        \\n        // One operation used\\n        count ++;\\n    }\\n    \\n    return count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1076046,
                "title": "python-greedy-solution-explained",
                "content": "Let us consider several cases and understand, what will be the best choise in each of them. Let us go in opposite direction and divide `Y` by `2` or add `1`, to it until we get `X`.\\n\\n1. If `X > Y`, we do not have a lot of choice, we can just decrease `X` by one until it becomes equal to `Y`, so answer will be `X - Y`.\\n2. If `X == Y`, then we already happy and we return `0`.\\n3. If `Y % 2 == 1`, then let us think, what can be the last step? It can not be multilication by `2`, so the only choice is subtraction of `1` and on previous step we have configuration `(X, Y + 1)`, for which we run our function recursively.\\n4. If `Y % 2 == 0`, let us prove that we always need to divide by `2` in this case. \\n\\nImagine, that we have sequence of operations, like: `[+1, +1, /2, /2, /2, +1, /2, ...]`. Then, if we have `+1, +1, /2` sequence inside, we can always replace it with `/2, +1`, so we can make it shorter. So, there will be no `+1, +1` subsequence, except for the very end and in general all sequence looks like: `[+1, /2, .., /2, +1, /2, ..., /2, ..., +1, ..., +1]`. Note, that the last part correspondes to case `1`. Also we will never have two `+1` in the middle and it means, that if we have even number, we **must** divide it by `2`: if we add `1` to it, then we have no choice to add `1` again (case 3) and then we have `+1, +1, /2` pattern.\\n\\n**Complexity**: time complexity is `O(log Y)`, because every two iteration number decreased at least twice. Space complexity here is also `O(log Y)`, because we use recursion. It can be made `O(1)` if we do it iteratively.\\n\\n```\\nclass Solution:\\n    def brokenCalc(self, X, Y):\\n        if X > Y: return X - Y\\n        if X == Y: return 0\\n        if Y % 2 == 0:\\n            return self.brokenCalc(X, Y//2) + 1\\n        else:\\n            return self.brokenCalc(X, Y + 1) + 1\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [
                    "Greedy",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def brokenCalc(self, X, Y):\\n        if X > Y: return X - Y\\n        if X == Y: return 0\\n        if Y % 2 == 0:\\n            return self.brokenCalc(X, Y//2) + 1\\n        else:\\n            return self.brokenCalc(X, Y + 1) + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1874839,
                "title": "c-2-approaches-easy-simple-short-algorithm",
                "content": "# 991. Broken Calculator\\n**KNOCKCAT**\\n\\n```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Inituton is to convert target value to startvalue by dividing & addition.\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t//\\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09\\n```\\n\\n[LeetCode](http://github.com/knockcat/Leetcode) **LINK TO LEETCODE REPOSITORY**\\n\\nPlease upvote my comment so that i get to win the 2022 giveaway and motivate to make such discussion post.\\n**Happy new Year 2023 to all of you**\\n**keep solving keep improving**\\nLink To comment\\n[Leetcode Give away comment](https://leetcode.com/discuss/general-discussion/2946993/2022-Annual-Badge-and-the-Giveaway/1734919)\\n\\n**ALGORITHM**\\n* The **idea is to bring target equal to startvalue** & **counting the number of operations.**\\n* We will do opposite **insitead of turning startvalue to target.**\\n* **we are turning target to startvalue by 2 steps.**\\n\\t* if **target value is odd** , we will **make it even by adding one to it.**\\n\\t* **If target is even** we will **divide by 2;**\\n\\t* and **doing these 2  operations** we will **count min operations** **till targetvalue is greater than startvalue.**\\n\\nANALYSIS:-\\n* **TIME CONPLEXITY** :- O(logn)\\n* **SPACE COMPLEXITY** :- O(1)\\n``` ``` \\n\\n* **ITERATIVE APPROACH**\\n```\\n\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        \\n\\t\\t// res for counting number of operation\\n        int res = 0;\\n        \\n        while(target > startValue)\\n        {\\n\\t\\t\\t// if target is odd we will make it even\\n            if(target % 2)\\n                ++target;\\n\\t\\t\\t// if target is even divide by 2\\n            else\\n                target /= 2;\\n            \\n            ++res;\\n        }\\n        return res  + startValue - target;\\n    }\\n\\t// for github repository link go to my profile.\\n};\\n\\n```\\n* **RECURSIVE APPROACH**\\n```\\n\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        if(startValue >= target)\\n            return startValue - target;\\n        \\n        if(target & 1)// if odd\\n            return 1 + brokenCalc(startValue, target  + 1);\\n        \\n        // if even\\n        return 1 + brokenCalc(startValue, target / 2);\\n    }\\n\\t// for github repository link go to my profile.\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Inituton is to convert target value to startvalue by dividing & addition.\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t//\\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09\\n```\n``` ```\n```\\n\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        \\n\\t\\t// res for counting number of operation\\n        int res = 0;\\n        \\n        while(target > startValue)\\n        {\\n\\t\\t\\t// if target is odd we will make it even\\n            if(target % 2)\\n                ++target;\\n\\t\\t\\t// if target is even divide by 2\\n            else\\n                target /= 2;\\n            \\n            ++res;\\n        }\\n        return res  + startValue - target;\\n    }\\n\\t// for github repository link go to my profile.\\n};\\n\\n```\n```\\n\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        if(startValue >= target)\\n            return startValue - target;\\n        \\n        if(target & 1)// if odd\\n            return 1 + brokenCalc(startValue, target  + 1);\\n        \\n        // if even\\n        return 1 + brokenCalc(startValue, target / 2);\\n    }\\n\\t// for github repository link go to my profile.\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1076061,
                "title": "broken-calculator-js-python-java-c-simple-solution-w-detailed-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations ([**index**](https://dev.to/seanpgallivan/leetcode-solutions-index-57fl)). If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThe first thing we should be able to understand is that one of the operations increases **X** while the other one decreases it. So the natural tendency is to think about the solution in terms of applying these operations in order. That is, multiply as many times as you need to before subtracting as many times as you need to.\\n\\nWe see that that\\'s not a viable solution, however, once we recognize that one of the operations is quite obviously multiplicative rather than additive, meaning that a subtraction done *before* a multiplication has twice the impact, for example.\\n\\nSo the trick here is to think of the problem backwards: moving from **Y** to **X** instead of from **X** to **Y**. If **Y** is odd, we\\'re forced to do the additive operation (reversed from the subtractive operation) as we can\\'t divide an odd number by **2** and be able to reach **X**. If **Y** is even, we can prioritize the division operation instead. At each step we can increment our **ans**.\\n\\nOnce **Y** drops below **X**, the remaining difference must be made via the additive operation, so we can just **return** that difference plus **ans**.\\n\\n**To illustrate why the backwards order leads to the correct solution**, let\\'s take a look at an example: **X = 3, Y = 13**. Under the naive approach discussed at the very beginning of this section, we could apply the multiplication operation **3** times to achieve **24**, then apply the subtraction operation **11** times to bring **Y** back down to **13**.\\n\\nAs we observed before, that **11** is not very efficient, considering that some/all of those subtraction operations could have been done before some/all of the multiplication operations with greater impact.\\n\\nSo what if we had applied as many of those operations as necessary just *before* the last of the three multiplications? Then we would only have needed **5** operations to effect **10** subtraction, plus the leftover **1** to get to **11** at the end.\\n\\nIf we go back one more step before the second of three multiplications, we could have instead done **2** operations then which would have the effect of **8** substraction, plus an extra operation after the second multiplication (adding another **2** subtraction), plus the final operation after all multiplications to reach **11**.\\n\\nThis quickly begins to represent a binary representation of our target difference of **11**:\\n```js\\n     Total multiplications:                                 In binary: (11 = 1011)\\n        3    2    1    0\\n                      11   =   11 in 11 operations                   1011   =   11\\n                  5    1   =   11 in 6 operations                 101 + 1   =   6\\n             2    1    1   =   11 in 4 operations              10 + 1 + 1   =   4\\n        1    0    1    1   =   11 in 3 operations           1 + 0 + 1 + 1   =   3\\n```\\nWe can already see that this is starting to look like our backwards approach. At each additional multiplication operation available, we\\'re forced to perform a subtraction operation if the difference is still odd, otherwise, we can divide the remainder by **2** and push it back one multiplication earlier.\\n\\nBasically, for each multiplication we need to take **X** over **Y**, we take the remaining difference, count the first bit, then shift the difference to the right. And that should sound *exactly* like our backwards approach, because the first bit is a **0** if even and **1** if odd, and shifting to the right is the same as dividing by **2**.\\n\\n**So why can\\'t we go forwards with X instead of backwards with Y?** As mentioned before, the multiplication operation is, quite obviously, multiplicative, and will have an enhancing effect on any subtraction operations performed before it. Therefore, *we cannot possibly know* how much impact any given subtraction operation will have on the difference between **X** and **Y** until we find out how many multiplication operations we will need after it.\\n\\nSo any solution involving moving **X** to **Y** would at least require \"peeking\" ahead at part of the solution before progressing with the subtraction operations.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nThis solution is almost identical in all four languages.\\n\\nPython will convert our integer into a float if we simply divide by 2, so we can use the floor division operator instead to maintain the integer.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **68ms / 38.2MB** (beats 100% / 90%).\\n```javascript\\nvar brokenCalc = function(X, Y) {\\n    let ans = 0\\n    while (X < Y) {\\n        ans++\\n        if (Y % 2) Y++\\n        else Y /= 2\\n    }\\n    return X - Y + ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **20ms / 14.1MB** (beats 99% / 90%).\\n```python\\nclass Solution:\\n    def brokenCalc(self, X: int, Y: int) -> int:\\n        ans = 0\\n        while X < Y:\\n            ans += 1\\n            if Y % 2: Y += 1\\n            else: Y //= 2\\n        return X - Y + ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **0ms / 35.4MB** (beats 100% / 98%).\\n```java\\nclass Solution {\\n    public int brokenCalc(int X, int Y) {\\n        int ans = 0;\\n        while (X < Y) {\\n            ans++;\\n            if (Y % 2 > 0) Y++;\\n            else Y /= 2;\\n        }\\n        return X - Y + ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 5.8MB** (beats 100% / 81%).\\n```c++\\nclass Solution {\\npublic:\\n    int brokenCalc(int X, int Y) {\\n        int ans = 0;\\n        while (X < Y) {\\n            ans++;\\n            if (Y % 2) Y++;\\n            else Y /= 2;\\n        }\\n        return X - Y + ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\n     Total multiplications:                                 In binary: (11 = 1011)\\n        3    2    1    0\\n                      11   =   11 in 11 operations                   1011   =   11\\n                  5    1   =   11 in 6 operations                 101 + 1   =   6\\n             2    1    1   =   11 in 4 operations              10 + 1 + 1   =   4\\n        1    0    1    1   =   11 in 3 operations           1 + 0 + 1 + 1   =   3\\n```\n```javascript\\nvar brokenCalc = function(X, Y) {\\n    let ans = 0\\n    while (X < Y) {\\n        ans++\\n        if (Y % 2) Y++\\n        else Y /= 2\\n    }\\n    return X - Y + ans\\n};\\n```\n```python\\nclass Solution:\\n    def brokenCalc(self, X: int, Y: int) -> int:\\n        ans = 0\\n        while X < Y:\\n            ans += 1\\n            if Y % 2: Y += 1\\n            else: Y //= 2\\n        return X - Y + ans\\n```\n```java\\nclass Solution {\\n    public int brokenCalc(int X, int Y) {\\n        int ans = 0;\\n        while (X < Y) {\\n            ans++;\\n            if (Y % 2 > 0) Y++;\\n            else Y /= 2;\\n        }\\n        return X - Y + ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int brokenCalc(int X, int Y) {\\n        int ans = 0;\\n        while (X < Y) {\\n            ans++;\\n            if (Y % 2) Y++;\\n            else Y /= 2;\\n        }\\n        return X - Y + ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1076042,
                "title": "python-c-explanation-with-illustration-why-we-should-work-with-y-not-x",
                "content": "Most obvious algorithm would be to count `steps` and do `X *= 2` when `X < Y` and `X -= 1` when `X > Y`, and return `steps` when `X == Y`.\\nEvery time when `X < Y` and we want to double `X`  we need to think, would it be better to subtract one, so when we will get `X > Y`, the difference will be smaller. Here is illustration with `X = 4, Y = 17`:\\nBlue \\u2013 primitive way\\nRed \\u2013 smart way\\n\\n![image](https://assets.leetcode.com/users/images/cf8686ad-3101-4a6c-8309-fac122186e9c_1613898000.5730617.png)\\n\\nHere we see that smart logic for working with `X` not clear, we will need to calculate something ahead to decide should we actually `X -= 1` or `X *= 2` even if `X < Y`, **but** from `Y` perspective everything is quite simple:\\nWe **always** divide `Y` by 2, if `Y > X` **and** `Y % 2 == 0` (can be divided by `2`), \\nand simply add `1` if `Y < X` or if `Y > X` **but** `Y % 2 == 1`. \\n\\nPython Code:\\n```\\nclass Solution:\\n  def brokenCalc(self, x: int, y: int) -> int:\\n    steps = 0\\n    while y > x:\\n      steps += 1 + y % 2 # if y not divisible do 1 extra step (add one to y)\\n      y += y % 2 # if y not divisible add one to y\\n      y //= 2\\n        \\n    return steps + (x - y)\\n```\\n\\nC++ Code:\\n```\\nclass Solution {\\n  public:\\n    int brokenCalc(int x, int y) {\\n      int steps = 0;\\n      while (y > x) {\\n        steps += 1 + y % 2; // if y not divisible do 1 extra step (add one to y)\\n        y += y % 2; // if y not divisible add one to y\\n        y /= 2;\\n      }\\n      return steps + (x - y);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n  def brokenCalc(self, x: int, y: int) -> int:\\n    steps = 0\\n    while y > x:\\n      steps += 1 + y % 2 # if y not divisible do 1 extra step (add one to y)\\n      y += y % 2 # if y not divisible add one to y\\n      y //= 2\\n        \\n    return steps + (x - y)\\n```\n```\\nclass Solution {\\n  public:\\n    int brokenCalc(int x, int y) {\\n      int steps = 0;\\n      while (y > x) {\\n        steps += 1 + y % 2; // if y not divisible do 1 extra step (add one to y)\\n        y += y % 2; // if y not divisible add one to y\\n        y /= 2;\\n      }\\n      return steps + (x - y);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 234791,
                "title": "c-solution-o-n-time-and-o-1-space-using-greedy-algorithm-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int X, int Y) {\\n        if(X > Y){ return X - Y; }\\n        \\n        int num_ops = 0;\\n        int mult = 1;\\n        while(X < Y){\\n            X *= 2;\\n            mult *= 2;\\n            num_ops++;\\n        }\\n        \\n        int diff = X - Y;\\n        while(diff != 0){\\n            if(diff - mult < 0){\\n                mult /= 2;\\n            }\\n            else{\\n                diff -= mult;\\n                num_ops++;\\n            }\\n        }\\n        return num_ops;\\n    }\\n};\\n```\\n\\n**The underlying concept of this solution is based on the following observations**:\\n\\n1. The only way to increment a X towards Y is to double\\n2. The fastest way to decrement X towards Y is to decrement by 1 before doubling some number of times.\\n\\nFor example, if given `X = 7` and `Y = 19`,\\n\\n```\\n7 * 2 * 2 = 28 >= 19\\n```\\n\\nWe intuitively see that at least 2 doublings are required to get `X > Y`. At this point, a possible solution could be to decrement 9 times, however it would be **faster if we could decrement before doubling**.\\n\\nConsider these two cases:\\n```\\nA. (7 - 1) * 2 * 2 = 24\\nB. (7 * 2 - 1) * 2 = 26\\n```\\n\\nNotice that in case `A`, we **save** 2 decrements, but in case `B` we save 4 decrements. **This can be seen by comparing the differences**. The amount we **save** is equal to `2^(number of doublings that occured since decrementing)`.\\n\\nSince we are required to double until `X > Y`, the **minimum number of operations results from decrementing as much as possible, as early as possible**.\\n\\nThe steps are summarized as follows:\\n\\n1. Double X until it is greater than Y and take the difference (`diff`) between X and Y, while keeping track of how many times you doubled (`mult = 2^(number of doublings until X > Y)`)\\n\\n\\n2. Subtract `mult` from `diff` until it `diff - mult < 0`, then divide `mult` by 2 and repeat this process. This will continue until `diff = 0` (We are calculating the minimum number of decrements needed).\\n\\n\\n3. Return `(number of doublings) + (number of times mult is subtracted from diff)`\\n\\n\\n**Example**: `X = 7, Y = 19`\\n```\\n1. We need to double 2 times\\n7 * 2 * 2 > 19 \\ndiff = 28 - 19 = 9\\nmult = 2 * 2 (2 doublings necessary for X > Y)\\n\\n2. We need to decrement 3 times (mult is subtracted from diff 3 times)\\n9 - 4 - 4 - 1 = 0\\n\\n3. We return 2 + 3 = 5\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int X, int Y) {\\n        if(X > Y){ return X - Y; }\\n        \\n        int num_ops = 0;\\n        int mult = 1;\\n        while(X < Y){\\n            X *= 2;\\n            mult *= 2;\\n            num_ops++;\\n        }\\n        \\n        int diff = X - Y;\\n        while(diff != 0){\\n            if(diff - mult < 0){\\n                mult /= 2;\\n            }\\n            else{\\n                diff -= mult;\\n                num_ops++;\\n            }\\n        }\\n        return num_ops;\\n    }\\n};\\n```\n```\\n7 * 2 * 2 = 28 >= 19\\n```\n```\\nA. (7 - 1) * 2 * 2 = 24\\nB. (7 * 2 - 1) * 2 = 26\\n```\n```\\n1. We need to double 2 times\\n7 * 2 * 2 > 19 \\ndiff = 28 - 19 = 9\\nmult = 2 * 2 (2 doublings necessary for X > Y)\\n\\n2. We need to decrement 3 times (mult is subtracted from diff 3 times)\\n9 - 4 - 4 - 1 = 0\\n\\n3. We return 2 + 3 = 5\\n```",
                "codeTag": "Java"
            },
            {
                "id": 234526,
                "title": "simple-recursive-solution-considering-only-last-bit-and-proof-why-it-s-guranteed-shortest-path",
                "content": "```\\npublic int brokenCalc(int X, int Y) {\\n        if (X>=Y) return X-Y;\\n        return (Y&1)==0? 1+brokenCalc(X, Y/2):1+brokenCalc(X, Y+1);\\n        \\n}\\n```\\n\\nSo we check only the last bit of Y, since doubling and -1 can only alter (directly) one bit.\\n\\nif last bit of Y is 0, the last operation must be doubling, we trace back to Y/2\\nif last bit of Y is 1, the last operation must be decrement, we trace back to Y+1\\n\\nTrying to prove that the **if last bit of Y is 0, the last operation must be doubling**:\\n\\n **hypothesis**: there can be one or more decrement from Y+1 to Y in the shortest path, where last bit of Y is 0\\n- since last bit of Y+1 is 1, it must be decrement from Y+2(doubling can never make an 1 on last bit)\\n- two options at Y+2.\\n1. decrement from Y+3, it\\'s the same as the starting point Y+1 and Y;\\n2. doubling from (Y+2)/2, three moves used from (Y+2)/2 to Y: double to Y+2, decrement to Y+1, decrement to Y, while there is a shorter path: decrement to Y/2, double to Y\\n\\n- there we get a contradiction to the hypothesis\\n- so the hypothesis is false\\nhence, **there can be none decrement move(s) from Y+1 to Y in the shortest path if last bit of Y is 0**",
                "solutionTags": [],
                "code": "```\\npublic int brokenCalc(int X, int Y) {\\n        if (X>=Y) return X-Y;\\n        return (Y&1)==0? 1+brokenCalc(X, Y/2):1+brokenCalc(X, Y+1);\\n        \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1076063,
                "title": "js-python-java-c-simple-solution-w-detailed-explanation-beats-100",
                "content": "*(Note: This is part of a series of Leetcode solution explanations ([**index**](https://dev.to/seanpgallivan/leetcode-solutions-index-57fl)). If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThe first thing we should be able to understand is that one of the operations increases **X** while the other one decreases it. So the natural tendency is to think about the solution in terms of applying these operations in order. That is, multiply as many times as you need to before subtracting as many times as you need to.\\n\\nWe see that that\\'s not a viable solution, however, once we recognize that one of the operations is quite obviously multiplicative rather than additive, meaning that a subtraction done *before* a multiplication has twice the impact, for example.\\n\\nSo the trick here is to think of the problem backwards: moving from **Y** to **X** instead of from **X** to **Y**. If **Y** is odd, we\\'re forced to do the additive operation (reversed from the subtractive operation) as we can\\'t divide an odd number by **2** and be able to reach **X**. If **Y** is even, we can prioritize the division operation instead. At each step we can increment our **ans**.\\n\\nOnce **Y** drops below **X**, the remaining difference must be made via the additive operation, so we can just **return** that difference plus **ans**.\\n\\n**To illustrate why the backwards order leads to the correct solution**, let\\'s take a look at an example: **X = 3, Y = 13**. Under the naive approach discussed at the very beginning of this section, we could apply the multiplication operation **3** times to achieve **24**, then apply the subtraction operation **11** times to bring **Y** back down to **13**.\\n\\nAs we observed before, that **11** is not very efficient, considering that some/all of those subtraction operations could have been done before some/all of the multiplication operations with greater impact.\\n\\nSo what if we had applied as many of those operations as necessary just *before* the last of the three multiplications? Then we would only have needed **5** operations to effect **10** subtraction, plus the leftover **1** to get to **11** at the end.\\n\\nIf we go back one more step before the second of three multiplications, we could have instead done **2** operations then which would have the effect of **8** substraction, plus an extra operation after the second multiplication (adding another **2** subtraction), plus the final operation after all multiplications to reach **11**.\\n\\nThis quickly begins to represent a binary representation of our target difference of **11**:\\n```js\\n     Total multiplications:                                 In binary: (11 = 1011)\\n        3    2    1    0\\n                      11   =   11 in 11 operations                   1011   =   11\\n                  5    1   =   11 in 6 operations                 101 + 1   =   6\\n             2    1    1   =   11 in 4 operations              10 + 1 + 1   =   4\\n        1    0    1    1   =   11 in 3 operations           1 + 0 + 1 + 1   =   3\\n```\\nWe can already see that this is starting to look like our backwards approach. At each additional multiplication operation available, we\\'re forced to perform a subtraction operation if the difference is still odd, otherwise, we can divide the remainder by **2** and push it back one multiplication earlier.\\n\\nBasically, for each multiplication we need to take **X** over **Y**, we take the remaining difference, count the first bit, then shift the difference to the right. And that should sound *exactly* like our backwards approach, because the first bit is a **0** if even and **1** if odd, and shifting to the right is the same as dividing by **2**.\\n\\n**So why can\\'t we go forwards with X instead of backwards with Y?** As mentioned before, the multiplication operation is, quite obviously, multiplicative, and will have an enhancing effect on any subtraction operations performed before it. Therefore, *we cannot possibly know* how much impact any given subtraction operation will have on the difference between **X** and **Y** until we find out how many multiplication operations we will need after it.\\n\\nSo any solution involving moving **X** to **Y** would at least require \"peeking\" ahead at part of the solution before progressing with the subtraction operations.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nThis solution is almost identical in all four languages.\\n\\nPython will convert our integer into a float if we simply divide by 2, so we can use the floor division operator instead to maintain the integer.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **68ms / 38.2MB** (beats 100% / 90%).\\n```javascript\\nvar brokenCalc = function(X, Y) {\\n    let ans = 0\\n    while (X < Y) {\\n        ans++\\n        if (Y % 2) Y++\\n        else Y /= 2\\n    }\\n    return X - Y + ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **20ms / 14.1MB** (beats 99% / 90%).\\n```python\\nclass Solution:\\n    def brokenCalc(self, X: int, Y: int) -> int:\\n        ans = 0\\n        while X < Y:\\n            ans += 1\\n            if Y % 2: Y += 1\\n            else: Y //= 2\\n        return X - Y + ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **0ms / 35.4MB** (beats 100% / 98%).\\n```java\\nclass Solution {\\n    public int brokenCalc(int X, int Y) {\\n        int ans = 0;\\n        while (X < Y) {\\n            ans++;\\n            if (Y % 2 > 0) Y++;\\n            else Y /= 2;\\n        }\\n        return X - Y + ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 5.8MB** (beats 100% / 81%).\\n```c++\\nclass Solution {\\npublic:\\n    int brokenCalc(int X, int Y) {\\n        int ans = 0;\\n        while (X < Y) {\\n            ans++;\\n            if (Y % 2) Y++;\\n            else Y /= 2;\\n        }\\n        return X - Y + ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```js\\n     Total multiplications:                                 In binary: (11 = 1011)\\n        3    2    1    0\\n                      11   =   11 in 11 operations                   1011   =   11\\n                  5    1   =   11 in 6 operations                 101 + 1   =   6\\n             2    1    1   =   11 in 4 operations              10 + 1 + 1   =   4\\n        1    0    1    1   =   11 in 3 operations           1 + 0 + 1 + 1   =   3\\n```\n```javascript\\nvar brokenCalc = function(X, Y) {\\n    let ans = 0\\n    while (X < Y) {\\n        ans++\\n        if (Y % 2) Y++\\n        else Y /= 2\\n    }\\n    return X - Y + ans\\n};\\n```\n```python\\nclass Solution:\\n    def brokenCalc(self, X: int, Y: int) -> int:\\n        ans = 0\\n        while X < Y:\\n            ans += 1\\n            if Y % 2: Y += 1\\n            else: Y //= 2\\n        return X - Y + ans\\n```\n```java\\nclass Solution {\\n    public int brokenCalc(int X, int Y) {\\n        int ans = 0;\\n        while (X < Y) {\\n            ans++;\\n            if (Y % 2 > 0) Y++;\\n            else Y /= 2;\\n        }\\n        return X - Y + ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int brokenCalc(int X, int Y) {\\n        int ans = 0;\\n        while (X < Y) {\\n            ans++;\\n            if (Y % 2) Y++;\\n            else Y /= 2;\\n        }\\n        return X - Y + ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1075986,
                "title": "c-simple-short-solution-o-logn-time-o-1-space-0-ms-faster-than-100",
                "content": "We are doing the opposite - instead of turning X into Y by multiplying/subtracting, we are turning Y into X by doing the opposite operations - adding/dividing.\\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int X, int Y) {\\n        int res = 0;\\n        while (Y > X) {\\n            \\n            if (Y % 2) \\n                Y++;\\n            \\n            else \\n                Y /= 2;\\n            \\n            res++;\\n        }\\n        return res + X - Y;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int X, int Y) {\\n        int res = 0;\\n        while (Y > X) {\\n            \\n            if (Y % 2) \\n                Y++;\\n            \\n            else \\n                Y /= 2;\\n            \\n            res++;\\n        }\\n        return res + X - Y;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 234476,
                "title": "simple-java-why-to-go-towards-x",
                "content": "To get minimal steps, we can think of covering distance by taking maximum jumps towards Y and then come back. But this doesn\\u2019t give minimum steps to us.\\nAs we keep jumping towards right, our jump size keeps doubling. We can end up jumping very far away from Y in last jump  and we can loose minimal steps.\\n\\nBut if we go back, from Y to X, then \\n(1.) we would have utilised our biggest jump i.e. last jump to reach Y. And \\n(2.) our jump size also keeps decreasing, so even if we land very far way to left of X, then also it would give us minimal steps when we move forward to Y.\\n\\n**Recursive**\\n```\\n    public int brokenCalc(int X, int Y) {\\n        if(Y <= X) return X-Y;\\n        return 1 + (Y % 2 == 0 ? brokenCalc(X, Y/2) : brokenCalc(X, Y + 1));\\n    }\\n```\\n**Iterative**\\n```\\n    public int brokenCalc(int X, int Y) {\\n        int ans = 0;\\n        for(; Y > X ;  Y = Y % 2 > 0 ? Y + 1 : Y / 2, ans++);\\n        return (ans + X - Y);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int brokenCalc(int X, int Y) {\\n        if(Y <= X) return X-Y;\\n        return 1 + (Y % 2 == 0 ? brokenCalc(X, Y/2) : brokenCalc(X, Y + 1));\\n    }\\n```\n```\\n    public int brokenCalc(int X, int Y) {\\n        int ans = 0;\\n        for(; Y > X ;  Y = Y % 2 > 0 ? Y + 1 : Y / 2, ans++);\\n        return (ans + X - Y);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1874898,
                "title": "rust-o-1-space-and-o-1-time-explained",
                "content": "```rust\\nimpl Solution {\\n    pub fn broken_calc(start_value: i32, target: i32) -> i32 {\\n        // Find the smallest number of doubling needed to get start_value > target.\\n        // * `(target - 1) / start_value` is the largest multiple of target that is less than start_value\\n        // * `31 - (...).leading_zeros()` is the flooring log2 of the value.\\n        // This gives the largest number of doubling possible before start_value > target.\\n        // Plus 1 to get the smallest number of doubling needed.\\n        let m = 32 - ((target - 1) / start_value).leading_zeros() as i32;\\n        // This is the \"overshoot\" by doubling, which we need to subtract away\\n        let diff = (start_value << m) - target;\\n        // Now we look at bits.\\n        // * If bit i is 1, then we can do a subtraction before the i-th doubling (counting from back)\\n        // * E.g. if bit 0 is 1, then we do a subtraction after all doublings\\n        // * If bit 1 is 1, then we do a subtraction before the last doubling\\n        // * If bit 2 is 1, then we do a subtraction before the last two doublings\\n        // * ...\\n        // * If bit m is 1, then we do a subtraction before the first doubling.\\n        // However if bit m+1 or higher is 1, then we can\\'t go back further, so we need to subtract them from the start.\\n        // The `diff >> m` part accounts for this, and this is the doublings we need to do before doublings.\\n        // The `(diff & ((1 << m) - 1)).count_ones()` just counts the number of subtractions that we do in between or after all doublings.\\n        // Finally, add `m` which is the number of doubling operation, we get the final answer\\n        (diff >> m) + (diff & ((1 << m) - 1)).count_ones() as i32 + m\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn broken_calc(start_value: i32, target: i32) -> i32 {\\n        // Find the smallest number of doubling needed to get start_value > target.\\n        // * `(target - 1) / start_value` is the largest multiple of target that is less than start_value\\n        // * `31 - (...).leading_zeros()` is the flooring log2 of the value.\\n        // This gives the largest number of doubling possible before start_value > target.\\n        // Plus 1 to get the smallest number of doubling needed.\\n        let m = 32 - ((target - 1) / start_value).leading_zeros() as i32;\\n        // This is the \"overshoot\" by doubling, which we need to subtract away\\n        let diff = (start_value << m) - target;\\n        // Now we look at bits.\\n        // * If bit i is 1, then we can do a subtraction before the i-th doubling (counting from back)\\n        // * E.g. if bit 0 is 1, then we do a subtraction after all doublings\\n        // * If bit 1 is 1, then we do a subtraction before the last doubling\\n        // * If bit 2 is 1, then we do a subtraction before the last two doublings\\n        // * ...\\n        // * If bit m is 1, then we do a subtraction before the first doubling.\\n        // However if bit m+1 or higher is 1, then we can\\'t go back further, so we need to subtract them from the start.\\n        // The `diff >> m` part accounts for this, and this is the doublings we need to do before doublings.\\n        // The `(diff & ((1 << m) - 1)).count_ones()` just counts the number of subtractions that we do in between or after all doublings.\\n        // Finally, add `m` which is the number of doubling operation, we get the final answer\\n        (diff >> m) + (diff & ((1 << m) - 1)).count_ones() as i32 + m\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1076045,
                "title": "c-recursive-iterative-o-min-operations-0ms-beats-100-explanation",
                "content": "**EXPLANATION**\\nFor finding the **minimum operations** needed to change `X` to `Y`, we need to look at the question in an *opposite perspective*. Here, we will be modifying `Y` not `X` so we need to do operations in `Y` exactly opposite to those which we are supposed to do in `X`. Let us consider some *facts*:\\n1. Doing `X*2` is the opposite of doing `Y/2`. Similarly, `X-1` is opposite of `Y+1`.\\n2. If `X>Y`, then the only way to change `X` to `Y` is by **subtraction**, so we need to do exactly `X-Y` subtraction for achieving that.\\n3.  If `X<Y`, then we need to consider two cases:\\n\\t\\t- If `Y` is **odd** then we need to use the **subtraction** operation in X, that is `X-1` whose opposite operation is `Y+1` (Using 1).\\n\\t\\t- If `Y` is **even** then we need to use the **multiplication** operation in X, that is `X*2` whose opposite operation is `Y/2` (Using 1).\\n\\nNow, considering all the above facts we will solve the problem using **recursive** and **iterative** approaches as shown below.\\n\\n\\n**RECURSIVE APPROACH**\\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int X, int Y) {\\n        if(X==Y) return 0; // no operation required as X and Y are already same\\n        \\n        if(X>Y) return X-Y; // only way to change X to Y is by subtraction\\n        \\n        if(Y % 2){ // Y is odd\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0// do (opposite operation to X-1) or Y+1\\n            return 1 + brokenCalc(X, Y+1); \\n        }\\n        else{ // Y is even\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0// do (opposite operarion of X*2) or Y/2\\n            return 1 + brokenCalc(X, Y>>1); // Y/2 same as Y>>1\\n        }\\n    }\\n};\\n```\\n\\nConsidering, **n=minimum operations needed to change `X` to `Y`**\\n**TIME COMPLEXITY**\\n**O(n)**\\n\\n**SPACE COMPLEXITY**\\n**O(n)**\\n\\n\\n**ITERATIVE APPROACH (No extra space)**\\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int X, int Y) {\\n        int ans=0;\\n        while(X<Y){\\n            if(Y % 2){ // Y is odd\\n                // do (opposite operation to X-1) or Y+1\\n                ++Y;\\n                ++ans;\\n            }\\n            else{ // Y is even\\n                // do (opposite operarion of X*2) or Y/2\\n                Y=Y>>1; // Y/2 same as Y>>1\\n                ++ans;\\n            }    \\n        }\\n        return ans+X-Y; // if X>Y then the only way to change X to Y is by subtraction\\n    }\\n};\\n```\\n\\nConsidering, **n=minimum operations needed to change `X` to `Y`**\\n**TIME COMPLEXITY**\\n**O(n)**\\n\\n**SPACE COMPLEXITY**\\n**O(1)**",
                "solutionTags": [
                    "C",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int X, int Y) {\\n        if(X==Y) return 0; // no operation required as X and Y are already same\\n        \\n        if(X>Y) return X-Y; // only way to change X to Y is by subtraction\\n        \\n        if(Y % 2){ // Y is odd\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0// do (opposite operation to X-1) or Y+1\\n            return 1 + brokenCalc(X, Y+1); \\n        }\\n        else{ // Y is even\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0// do (opposite operarion of X*2) or Y/2\\n            return 1 + brokenCalc(X, Y>>1); // Y/2 same as Y>>1\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int X, int Y) {\\n        int ans=0;\\n        while(X<Y){\\n            if(Y % 2){ // Y is odd\\n                // do (opposite operation to X-1) or Y+1\\n                ++Y;\\n                ++ans;\\n            }\\n            else{ // Y is even\\n                // do (opposite operarion of X*2) or Y/2\\n                Y=Y>>1; // Y/2 same as Y>>1\\n                ++ans;\\n            }    \\n        }\\n        return ans+X-Y; // if X>Y then the only way to change X to Y is by subtraction\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875839,
                "title": "c-6-line-simple-code-easy-to-understand-tc-o-log-n-sc-o-1",
                "content": "#### *Please Upvote if it helps\\u2B06\\uFE0F*\\n```\\nint brokenCalc(int startValue, int target) {\\n        int ans=0;\\n        while(target!=startValue){\\n            if(target<startValue || target%2) target++;\\n            else target/=2;\\n            ans++;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "#### *Please Upvote if it helps\\u2B06\\uFE0F*\\n```\\nint brokenCalc(int startValue, int target) {\\n        int ans=0;\\n        while(target!=startValue){\\n            if(target<startValue || target%2) target++;\\n            else target/=2;\\n            ans++;\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1875304,
                "title": "java-easy-to-understand-beginner-friendly-with-explanation",
                "content": "try doing this for many inputs, u will find a pattern :-\\nwhen target is even then we can reduce steps by making it target/2;\\nwhen target is odd we have to find the even number which is close to target, in which we can perform our operation ie target-1.\\nwhen target is less than start then we simply return start - target \\nExample:- start= 3, target = 2\\nwe can simply perform start -1 to reach target.\\n```\\nclass Solution {\\n    public int brokenCalc(int start, int target) { \\n        if(target < start)\\n            return start-target;\\n        if(start == target)\\n            return 0;\\n        int ans =0;\\n        if(target > 0 && target%2 == 0)\\n            ans = 1+brokenCalc(start,target/2);\\n        else    ans = 1+ brokenCalc(start,target+1);\\n        return ans;\\n    }\\n}\\n```\\nPlease upvote if u find my code easy to understand",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int brokenCalc(int start, int target) { \\n        if(target < start)\\n            return start-target;\\n        if(start == target)\\n            return 0;\\n        int ans =0;\\n        if(target > 0 && target%2 == 0)\\n            ans = 1+brokenCalc(start,target/2);\\n        else    ans = 1+ brokenCalc(start,target+1);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1874888,
                "title": "notagenius-recursive-3-line-solution-iterative-that-uses-less-memory-multilanguage",
                "content": "Hi everyone! I hope you are enjoying coding every day.\\n\\nQuick post today, the non-genius approach as always!\\n\\n- We can model this as BSF or DSF, at every step the game branches by subtracting 1 or multiplying by 2. Of course this is exponential. We also need to take care of loops. It\\'s a path forward, but given that the problem restriction marks target being as high as 1_000_000_000, we are encouraged to find something faster.\\n- My first realization is that if we work backwards from the result we can cut some branches, as you cannot always divide by 2 and keep the current value an integer. Wrking backwards means dividing the target by 2 or adding 1 to the target, rather than multiplying the start by 2, or subtracting 1 from start.\\n- There are no restrictions on startValue or target being greater or lower than the other one. When startValue is greater than target though, you can only get there by subtracting (working forward, or adding working backward). In that case, the result is just adding/subtracting n times, or put another way, startValue-target.\\n- Since we are trying to make target as close as possible as startValue, when we can, we will always divide, as adding 1 will make them further apart.\\n- Sometimes though we need to add 1 as it\\'s the only way to make progress.\\n- So we get to the algorithm:\\n\\t- If startValue >= target, we just return startValue-target\\n\\t- Else when we can, we divide the target by 2 and try again\\n\\t- If we cannot divide by 2, we can just add 1 to target and try again\\n\\nAnd here is the code:\\n\\n```java\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        if (startValue >= target) return startValue-target;\\n        if (target % 2 == 0) return 1 + brokenCalc(startValue, target/2);\\n        else return 1 + brokenCalc(startValue, target + 1);\\n    }\\n}\\n```\\n\\n**Runtime: 0 ms, faster than 100.00% of Java online submissions for Broken Calculator.**\\n\\nThis is O(logn) time and O(logn) memory. From here you can go to iterative if you want to save memory.\\n\\n```java\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        int result = 0;\\n        while (true) {\\n            if (startValue >= target) return result+startValue-target;\\n            if (target % 2 == 0) {\\n                result++; \\n                target /= 2;\\n            }\\n            else {\\n                result++;\\n                target++;\\n            }\\n        }\\n    }\\n}\\n```\\n\\nOr the more concise\\n\\n```java\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        int result = 0;\\n        while (true) {\\n            if (startValue >= target) return result+startValue-target;\\n            result++;\\n            if (target % 2 == 0) target /= 2;\\n            else target++;\\n        }\\n    }\\n}\\n```\\n\\n\\nOr if you are afraid of `while(true)`\\n\\n```java\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        int result = 0;\\n        while (startValue < target) {\\n            result++;\\n            if (target % 2 == 0) target /= 2;\\n            else target++;\\n        }\\n        return result+startValue-target;\\n    }\\n}\\n```\\n\\n**Runtime: 0 ms, faster than 100.00% of Java online submissions for Broken Calculator.**\\n\\nThis is O(logn) time and O(1) memory.\\n\\nBonus track:\\n\\nC++:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int result = 0;\\n        while (startValue < target) {\\n            result++;\\n            if (target % 2 == 0) target /= 2;\\n            else target++;\\n        }\\n        return result+startValue-target;\\n    }\\n};\\n```\\n\\nPython:\\n\\n```py\\nclass Solution(object):\\n    def brokenCalc(self, startValue, target):\\n        result = 0;\\n        while (startValue < target) :\\n            result+=1;\\n            if target % 2 == 0: target = target/2;\\n            else: target+=1;\\n        return result+startValue-target;\\n```\\n\\nRuby:\\n\\n```ruby\\ndef broken_calc(start_value, target)\\n    result = 0;\\n    while start_value < target\\n        result+=1;\\n        if target % 2 == 0 then target = target/2;\\n        else target+=1;\\n        end\\n    end\\n    return result+start_value-target\\nend\\n```\\n\\nGo:\\n\\n```go\\nfunc brokenCalc(startValue int, target int) int {\\n    var result = 0;\\n    for startValue < target {\\n        result++;\\n        if target % 2 == 0 {\\n            target /= 2\\n        } else {\\n            target++\\n        }\\n    }\\n    return result+startValue-target;\\n}\\n```\\n\\nHave fun!!",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Ruby",
                    "Go"
                ],
                "code": "```java\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        if (startValue >= target) return startValue-target;\\n        if (target % 2 == 0) return 1 + brokenCalc(startValue, target/2);\\n        else return 1 + brokenCalc(startValue, target + 1);\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        int result = 0;\\n        while (true) {\\n            if (startValue >= target) return result+startValue-target;\\n            if (target % 2 == 0) {\\n                result++; \\n                target /= 2;\\n            }\\n            else {\\n                result++;\\n                target++;\\n            }\\n        }\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        int result = 0;\\n        while (true) {\\n            if (startValue >= target) return result+startValue-target;\\n            result++;\\n            if (target % 2 == 0) target /= 2;\\n            else target++;\\n        }\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        int result = 0;\\n        while (startValue < target) {\\n            result++;\\n            if (target % 2 == 0) target /= 2;\\n            else target++;\\n        }\\n        return result+startValue-target;\\n    }\\n}\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int result = 0;\\n        while (startValue < target) {\\n            result++;\\n            if (target % 2 == 0) target /= 2;\\n            else target++;\\n        }\\n        return result+startValue-target;\\n    }\\n};\\n```\n```py\\nclass Solution(object):\\n    def brokenCalc(self, startValue, target):\\n        result = 0;\\n        while (startValue < target) :\\n            result+=1;\\n            if target % 2 == 0: target = target/2;\\n            else: target+=1;\\n        return result+startValue-target;\\n```\n```ruby\\ndef broken_calc(start_value, target)\\n    result = 0;\\n    while start_value < target\\n        result+=1;\\n        if target % 2 == 0 then target = target/2;\\n        else target+=1;\\n        end\\n    end\\n    return result+start_value-target\\nend\\n```\n```go\\nfunc brokenCalc(startValue int, target int) int {\\n    var result = 0;\\n    for startValue < target {\\n        result++;\\n        if target % 2 == 0 {\\n            target /= 2\\n        } else {\\n            target++\\n        }\\n    }\\n    return result+startValue-target;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875316,
                "title": "c-recursive-approach-easy-to-understand-with-explanation",
                "content": "**PLEASE UPVOTE IF IT HELPS YOU**\\n``` \\n **APPROACH**\\n \\n1. instead of going towards the target we will make target to move toward start value ie we will do just opposite of what said in question.\\n2. we will check if the target value is even than we will divide it by two\\n3. else we will increment it by 1.\\n4. this process continues untill the target than startvalue \\n5. if startvalue became greater than target than we will just increment target value by 1 untill it became equals to 1.\\n```\\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int start, int target) {\\n        \\n        \\n        if(start >= target)\\n            return start-target;\\n\\t\\t\\n        return 1 + (target%2 == 0 ? brokenCalc(start, target/2) : brokenCalc(start, target+1));\\n    \\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Recursion"
                ],
                "code": "``` \\n **APPROACH**\\n \\n1. instead of going towards the target we will make target to move toward start value ie we will do just opposite of what said in question.\\n2. we will check if the target value is even than we will divide it by two\\n3. else we will increment it by 1.\\n4. this process continues untill the target than startvalue \\n5. if startvalue became greater than target than we will just increment target value by 1 untill it became equals to 1.\\n```\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int start, int target) {\\n        \\n        \\n        if(start >= target)\\n            return start-target;\\n\\t\\t\\n        return 1 + (target%2 == 0 ? brokenCalc(start, target/2) : brokenCalc(start, target+1));\\n    \\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875310,
                "title": "c-faster-solution-iterative-and-recursive-way-o-logn",
                "content": "**Iterative Code**\\n\\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        // In this approach, instead of thinking how\\n        // to approach from start to target, let\\'s think \\n        // how to go from target to start\\n        \\n        /*\\n        ONE CRUX:\\n        \\n            1. If our target is lesser than start then\\n               ans will always be the differece\\n            eg. startValue = 20, target = 5.\\n            In this example multiplying will not do anything\\n            so, ans = (startValue - target) = 20 - 5 = 15;\\n            \\n            2. Otherwise, we\\'ll check if target is odd/even\\n            \\n                -> for even numbers, we can directly divide by 2\\n                -> for odd numbers, we\\'ll increase the target by 1\\n                   just to divide by 2 in the next step\\n        \\n        */\\n        int cnt = 0;\\n        \\n        while(target > startValue)\\n        {\\n            if(target&1)\\n                target++;\\n            else\\n                target/=2;\\n            \\n            cnt++;\\n        }\\n        \\n        return cnt + startValue - target;\\n    }\\n};\\n```\\n\\n**Time - O(logN)\\nSpace - O(1)**\\n\\n**Recursive Code**\\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        \\n        if(startValue >= target) return startValue - target;\\n        \\n        return (target%2==0) ? 1 + brokenCalc(startValue, target/2) : 1 + brokenCalc(startValue, target+1);\\n    }\\n};\\n```\\n\\n**Time - O(logN)\\nSpace - O(logN)**\\n\\n***NB: If you liked the approached please upvote the solution as well as don\\'t hesitate to ask questions in the comments, I\\'ll be more than happy to help***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        // In this approach, instead of thinking how\\n        // to approach from start to target, let\\'s think \\n        // how to go from target to start\\n        \\n        /*\\n        ONE CRUX:\\n        \\n            1. If our target is lesser than start then\\n               ans will always be the differece\\n            eg. startValue = 20, target = 5.\\n            In this example multiplying will not do anything\\n            so, ans = (startValue - target) = 20 - 5 = 15;\\n            \\n            2. Otherwise, we\\'ll check if target is odd/even\\n            \\n                -> for even numbers, we can directly divide by 2\\n                -> for odd numbers, we\\'ll increase the target by 1\\n                   just to divide by 2 in the next step\\n        \\n        */\\n        int cnt = 0;\\n        \\n        while(target > startValue)\\n        {\\n            if(target&1)\\n                target++;\\n            else\\n                target/=2;\\n            \\n            cnt++;\\n        }\\n        \\n        return cnt + startValue - target;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        \\n        if(startValue >= target) return startValue - target;\\n        \\n        return (target%2==0) ? 1 + brokenCalc(startValue, target/2) : 1 + brokenCalc(startValue, target+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 997373,
                "title": "greedy-method-explanation-visual-python",
                "content": "***TL;DR***  (explantion + visual below). This problem is a ***minimization*** problem; thus a greedy method is appropriate. At every stage we take the operation that results in the minimum cost (operation that brings us closest to our target). if we invert our operations ( ```decrement -> increment, double -> half``` ) and work backwards from ```Y``` to ```X``` we arrive at an more elegant and readable solution. \\n\\n```python\\ndef brokenCalc(self, X: int, Y: int) -> int:\\n\\t\\toperations = 0\\n        while Y > X:\\n            Y = Y + 1 if Y % 2 == 1 else Y//2\\n            operations += 1\\n        return operations + X - Y\\n```\\n * * * \\n### Problem Overview \\n* * * \\nRecall the problem requires us to find the ***minimum number of operations*** needed to transfrom ```X``` to ```Y``` where we are confined to a restricted set of operations ```double(X)``` and ```decrement(X)```. To fully understand this problem it is instructive to see why there are many ways to transfrom ```X``` to ```Y```.\\n\\nThere many ways to transfrom ```X``` into ```Y```. Trying different operations in different orderings can lead to different solutions.  We try some number of operations in some order to transform ```X```  to ```Y```.\\n\\n***To demonstrate a few***\\n\\n![image](https://assets.leetcode.com/users/images/86014117-da98-4ee9-8594-c8da5d440331_1609537797.2625136.png)\\n\\n![image](https://assets.leetcode.com/users/images/0ce50c43-41c6-4c61-920c-8c43691f137a_1609537297.903984.png)\\n\\nThese are all feasible solutions, as they result in ```X``` being transformed into ```Y```.\\n\\nNow suppose we restict the set of operations to ```double(X)``` and ```decrement(X)``` \\n![image](https://assets.leetcode.com/users/images/02cf1351-837a-4756-8057-190000510a79_1609537935.8319757.png)\\n\\n![image](https://assets.leetcode.com/users/images/0e363371-0980-44fc-b470-9f196577af8b_1609538174.062282.png)\\n\\nThere are still many ways with this restricted set of operations to transfrom ```X``` to ```Y```, this list is by no means exhaustive.\\n* * * \\n### Greedy Method \\n * * * \\nRecall the problem statement asks us to find the ***minimum*** number of operations.\\n\\nAs shown above there are many valid ways to transform ```X``` to ```Y``` , even with our restricted set of operations. However we only interested in valid transfromations that produce the ***minimum number of operations***. we will follow one of these transfromations that leads to the minimum number of operations and count its operations. \\n * * * \\nThis is a ***minimization*** problem because out of a set of possible solutions we select the minimum. A ***minimization*** problem is type of ***optimization*** problem. Since this is an ***optimization*** problem a ***Greedy*** approach is applicable.\\n\\n* * * \\nThe ***Greedy Method*** is an approach to solve an optimization problem by breaking the problem down into a ***series of stages*** where at each stage we invoke ***the same procedure*** (some selection procedure we define) always making the ***best*** choice for the given stage. At each stage we  end up with some result that ***always meets the constraint of the problem***.\\n\\n* * * \\n\\n### Selection Procedure \\n\\n* * * \\n\\nThe heart of a ***Greedy*** approach is the selection procedure. We repeatedly select a result at each stage. a ***Greedy*** selection procedure always selects the ***best*** possible result at each stage. \\n\\n***In this problem we are selecting an operation at each stage.***\\n\\n#### How do we select the ***best*** operation? \\n\\nFirst we define what ***best*** means to us in this problem. The best operation is the operation at each stage that will lead us to the ***minimum number*** of overall operations to transfrom ```X``` to ```Y```. if we always choose the ***best*** operation at each stage surely we will reach ```Y``` in the ***minimum number of operations***, because at no point did we ever pick an operation that was ***not the best***, so surely our solution is the ***best*** we can do; that is, our solution must have find the minimum number of operations.\\n\\nRecall for our selection procedure to be valid, at each stage we  must end up with some result that ***always meets the constraint of the problem***.  Thus to define a good and valid selection procedure we must be well aware of our ***problem constraints***. \\n\\n* * * \\n### Problem Constraints\\n* * * \\nour ***constraints*** for this problem is we can only use two operations. ```double(X)``` or ```decrement(X)```, thus our result at each stage should always produce a number can be formed by appyling some number of ```decrement(X)```  and/or ```double(X)``` operations to ```X``` where we are free to chose the order of these operations   \\n * * * \\n![image](https://assets.leetcode.com/users/images/d2505c8f-4df7-4fbe-b32e-dd835d2aab2a_1609540533.6298044.png)\\n\\n* * * \\n### Tying It All Togther \\n * * * \\nWe decided it is best to take a ***Greedy*** approach to solving this problem. To implement a Greedy approach we must.\\n\\n1. Define a ***valid*** selection procedure that always selects the ***best*** choice at each stage\\n2. To define a ***valid*** selection procedure we must design the selection procedure in such a way that it always produces a result that ***falls within the constraints of the problem.***\\n\\n * * * \\n***Defining The Selection Procedure*** \\n* * * \\nWhile this problem can be solved by starting from ```X``` and working our way to ```Y```. It is much easier to define our  ***Greedy*** selection procedure. if we work ***backwards*** from ```Y``` to ```X```.\\n\\nTo work backwards from ```X``` to ```Y``` we must invert our ```decrement(X)``` or ```double(X)```  operations.  (this will not affect our count because if we can make a transformation in ```N``` stages we can also undo that transformation in ```N``` stages) \\n\\n![image](https://assets.leetcode.com/users/images/0e4a2066-83e4-4713-9509-d94e7fee9933_1609545282.8591826.png)\\n\\nOur selection procedure must choose the ***best*** operation for each stage,  ***best*** meaning the operation that will lead us to the ***minimum*** number of operations. \\nHowever this is still rather vague. let us be more formal.\\n\\nThe ***best*** operation to select at a given stage when we go from ```Y``` to ```X``` is the operation that brings us ***closest***  to ```Y```. Surely if we ***always*** chose the operation out of our set of choices (```half(X)``` or ```increment(X)```)  that  brings us closest to ```Y```, we will ***always*** reach ```Y``` in the ***minimum possible number*** of operations. \\n\\nAdditionally our slection procedure will have to handle two cases ```X < Y``` and ```X > Y```. first let us address ```X < Y``` as the other case is trivial. \\n\\n![image](https://assets.leetcode.com/users/images/87483da5-7287-4196-840e-0502ed4c918c_1609547090.541625.png)\\n\\nfrom the example above where ```X < Y``` it may seem like there is ***no choice to  be made at all***, because  ***increasing the number*** always pulls us further away from our target ```X```` so why would we ever choose to ````increment(X)```? \\n\\n* recall that a ***valid*** selection procedure always produces a result that ***falls within the constraints of the problem.*** \\n\\n* recall the ***problem constraint*** states we  are only allowed to use the operations```decrement(X)``` and ```double(X)```.\\n\\n* thus at each of our selection procedure the result should be a number that could be formed by some number of ```decrement(X)``` and/or ```double(X)``` ***These operations always produce some integer value.***\\n\\n* * * \\nRecall we ***inverted*** our operations inorder to work backwards. We are able to ***invert*** because the count will remain unaffected as mentioned previously.\\n\\nHowever does our current selection procedure  always produce  a number that could be formed by some number of ```decrement(X)``` and/or ```double(X)```?  observe\\n\\n![image](https://assets.leetcode.com/users/images/2887f1a7-a6da-4086-aeba-047b1ed07655_1609549498.5807447.png)\\n\\nas you can see the result is a decimal and as stated above the result at each stage must be an integer because integer addition and integer muliplication operations are closed under the set of intergers (always results in an integer), thus the selection procedure at stage 2 failed to produce a result meets the problem constraints. thus this will not lead to correct solution\\n\\nthe correct solution is \\n![image](https://assets.leetcode.com/users/images/336cde3c-3fa1-4f7b-968f-bb6ae6eadf24_1609550050.9692233.png)\\n * * * \\nYou may be wondering to counteract this issue by simply using integer floor division. then no decimals would ever occur. \\n* * * \\n![image](https://assets.leetcode.com/users/images/a1eca010-d612-48b5-93e8-470fec979bd0_1609551576.4902742.png)\\n\\n\\nHere we get the correct result. ***but are we guaranteed a correct result for all inputs?*** the answer is no, this is because we inverted our operations. If we make a transformation ```Y``` to ```X``` in series of stages we should visit the exact same stages going to ```X``` to ```Y```  only in reverse order . \\n\\nif we attempt to verify an example this will become clear. \\n![image](https://assets.leetcode.com/users/images/5ef8adb4-4108-485b-a1a9-f8758f7bdf8f_1609553122.5619931.png)\\n\\ngoing from ```X``` to ```Y``` we get 4, and 4 is the correct answer \\n\\n![image](https://assets.leetcode.com/users/images/d251fb15-1d91-47fb-9ffa-f94a7889cff0_1609553372.8630252.png)\\n\\nnotice the stages for the two correct solutions are exactly the same except they are in reverse.\\n\\nAs seen from the example the real check that should be made is whether or not the number at the current stage is divisble by 2. this is because ```double(X)``` always produces a number that is dvisible by 2 and in this way we avoid decimals or incorrect counting caused by integer floor division. \\n\\nthus we truely meet the ***constraitnts for the problem*** it is as if we used ```double(x)``` and ```decrement(x)``` because all stages are exactly the same as if  we did not invert the operations the only difference is we look at them backwards and this does not affect the count. \\n* * * \\n### The Trivial Case \\n* * * \\nlastly let us address the case where ```X >  Y``` \\n\\n* We can only increment from ```Y``` to get to ```X```. In that case the number of operations to get to from ```Y``` to ```X```\\nis ```X - Y```.\\n\\n* It could also be the case that oru selection procedure ends on a number that is less than ```X``` and there are still some operations to be counted. thus we once have the case ```X > Y``` so the only operation that can be formed is ```increment(X)``` thus we can apply the same stategy of ```X - Y``` and add it to our current count of operations. \\n\\nthus we arrive out our final solution. \\nin the worst case we repeatedly half the input, with a few intermediate increment operations. thus we get a runtime of ```O(Log N)``` and space complexity of ```O(1)```\\n\\n```python \\ndef brokenCalc(self, X: int, Y: int) -> int:\\n     operations = 0\\n        while Y > X:\\n            Y = Y + 1 if Y % 2 == 1 else Y//2\\n            operations += 1\\n        return operations + X - Y\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```decrement -> increment, double -> half```\n```Y```\n```X```\n```python\\ndef brokenCalc(self, X: int, Y: int) -> int:\\n\\t\\toperations = 0\\n        while Y > X:\\n            Y = Y + 1 if Y % 2 == 1 else Y//2\\n            operations += 1\\n        return operations + X - Y\\n```\n```X```\n```Y```\n```double(X)```\n```decrement(X)```\n```X```\n```Y```\n```X```\n```Y```\n```X```\n```Y```\n```X```\n```Y```\n```double(X)```\n```decrement(X)```\n```X```\n```Y```\n```X```\n```Y```\n```X```\n```Y```\n```Y```\n```double(X)```\n```decrement(X)```\n```decrement(X)```\n```double(X)```\n```X```\n```X```\n```Y```\n```Y```\n```X```\n```X```\n```Y```\n```decrement(X)```\n```double(X)```\n```N```\n```N```\n```Y```\n```X```\n```Y```\n```half(X)```\n```increment(X)```\n```Y```\n```Y```\n```X < Y```\n```X > Y```\n```X < Y```\n```X < Y```\n```X```\n````increment(X)```\n```decrement(X)```\n```double(X)```\n```decrement(X)```\n```double(X)```\n```decrement(X)```\n```double(X)```\n```Y```\n```X```\n```X```\n```Y```\n```X```\n```Y```\n```double(X)```\n```double(x)```\n```decrement(x)```\n```X >  Y```\n```Y```\n```X```\n```Y```\n```X```\n```X - Y```\n```X```\n```X > Y```\n```increment(X)```\n```X - Y```\n```O(Log N)```\n```O(1)```\n```python \\ndef brokenCalc(self, X: int, Y: int) -> int:\\n     operations = 0\\n        while Y > X:\\n            Y = Y + 1 if Y % 2 == 1 else Y//2\\n            operations += 1\\n        return operations + X - Y\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 308539,
                "title": "thinking-forward",
                "content": "Instead of thinking backward by incrementing and dividing ```Y```, we can think this problem forwardly. \\n\\nIntuition: We want to **first decrement** ```X``` to some extent, **then start to multiply** it until it gets close to ```Y```. \\nThis process equals to decrementing from a number ```X*(2^N)``` to ```Y```, where ```X*(2^N) >= Y```, and the number we are decrementing is **no longer** 1, instead, it is ```2^N```\\n\\nTherefore, we can be greedy. \\nStep1: **Find the smallest N**, for which ```X*(2^N) >= Y```\\nStep2: Start counting the number of decrements we need to do, where we are using ```2^N``` to decrement, until we cannot get any closer to Y.\\nStep3: Then, use ```2^(N-1)``` to decrement until we cannot get any closer to Y. \\nStep4: Use ```2^(N-2)``` to decrement, and do this recursively until we are using```2^0```, which is ```1``` to decrement. \\nFinally, return the number of decrements we have made, remember to plus ```N```, which is the number of multiplication.\\n\\n```\\nclass Solution(object):\\n    def brokenCalc(self, X, Y):\\n        \"\"\"\\n        :type X: int\\n        :type Y: int\\n        :rtype: int\\n        \"\"\"\\n        if Y <= X:\\n            return X-Y\\n        \\n        count = 0\\n        N = 1\\n        while X*2**N < Y:\\n            N += 1\\n        remain = (X*2**N)-Y\\n        count += N\\n        while N >= 0:\\n            count += remain//(2**N)\\n            remain %= (2**N)\\n            N -= 1\\n        \\n        return count\\n\\t\\t",
                "solutionTags": [
                    "Python"
                ],
                "code": "```Y```\n```X```\n```Y```\n```X*(2^N)```\n```Y```\n```X*(2^N) >= Y```\n```2^N```\n```X*(2^N) >= Y```\n```2^N```\n```2^(N-1)```\n```2^(N-2)```\n```2^0```\n```1```\n```N```",
                "codeTag": "Unknown"
            },
            {
                "id": 1876653,
                "title": "python-go-c-greedy-recursive-and-iterative-solutions",
                "content": "**\\uD83D\\uDC46Please UPVOTE it if you find my soulutions are useful \\uD83D\\uDC46 Feel free to ask any question**\\n# [Python/GO/C++] \\uD83C\\uDF1F Greedy Recursive and Iterative Solutions and Explanations \\uD83D\\uDC95\\n## 1\\uFE0F\\u20E3 Recursive Approach:\\nSimply backtrack target to startValue\\n1. If target is even, divide by 2 (for startValue multiply the number on display by 2)\\n2. If target is odd, add 1 (subtract 1 from the number on display.)\\n\\n**Edge Case**\\nOnce target is less or equal to startValue, means we can obtain the number only by subtract 1 from startValue to target\\n=> Return startValue - target, to find steps\\n## Complexity Analysis\\n* Time: O(logN): Let N be target\\'s number.\\n* Space: O(logN): Recurrsive call stack.\\n\\n## Code\\n\\n**Python**\\n```python\\n# Recursive\\nclass Solution:\\n    def brokenCalc(self, startValue: int, target: int) -> int:\\n        # Once target <= startValue, we only do subtract 1 to fit the target\\n        if target <= startValue:\\n            return startValue - target\\n        # Base Greedy Condition\\n        if target % 2 == 0:\\n            return 1 + self.brokenCalc(startValue, target // 2)\\n        else:\\n            return 1 + self.brokenCalc(startValue, target + 1)\\n```\\n**Go**\\n```go\\n// Recursive\\nfunc brokenCalc(startValue int, target int) int {\\n    // Once target <= startValue, we only do subtract 1 to fit the target\\n    if target <= startValue{\\n        return startValue - target\\n    }\\n    // Base Condition\\n    if target % 2 == 0{\\n        return 1 + brokenCalc(startValue, target / 2)\\n    } else{\\n        return 1 + brokenCalc(startValue, target + 1)\\n    }\\n}\\n```\\n**C++**\\n```cpp\\n// Recursive\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        // Once target <= startValue, we only do subtract 1 to fit the target\\n        if (target <= startValue){\\n            return startValue - target;\\n        }\\n        // Base Condition\\n        if (target % 2 == 0){\\n            return 1 + brokenCalc(startValue, target / 2);\\n        } else{\\n            return 1 + brokenCalc(startValue, target + 1);\\n        }\\n    }\\n};\\n```\\n\\n## 2\\uFE0F\\u20E3 Iterative Approach:\\nSame apporach to recurrsive but less space memory. Because we don\\'t use recursive stack.\\n\\n## Complexity Analysis\\n* Time: O(logN): Let N be target\\'s number.\\n* Space: O(1)\\n\\n## Code\\n\\n**Python**\\n```python\\n# Iterative\\nclass Solution:\\n    def brokenCalc(self, startValue: int, target: int) -> int:\\n        steps = 0\\n        while target > startValue:\\n            steps += 1\\n            # Base Greedy Condition\\n            if target % 2 == 0:\\n                target //= 2\\n            else:\\n                target += 1\\n        # Once target <= startValue, we only do subtract 1 to fit the target\\n        return steps + startValue - target\\n```\\n**Go**\\n```go\\n// Iterative\\nfunc brokenCalc(startValue int, target int) int {\\n    steps := 0\\n    for target > startValue{\\n        steps++\\n        // Base Condition\\n        if target % 2 == 0{\\n            target /= 2 \\n        } else{\\n            target += 1\\n        }\\n    }\\n    // Once target <= startValue, we only do subtract 1 to fit the target\\n    return steps + startValue - target\\n}\\n```\\n**C++**\\n```cpp\\n// Iterative\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int steps = 0;\\n        // Base Condition\\n        while (target > startValue){\\n            steps++;\\n            if (target % 2 == 0){\\n                target /= 2;\\n            } else{\\n                target++;\\n            }\\n        }\\n        // Once target <= startValue, we only do subtract 1 to fit the target\\n        return steps + startValue - target;\\n    }\\n};\\n```\\n* See more 2022 Daily Challenge Solution : [GitHub](https://github.com/gcobs0834/2022-Daily-LeetCoding-Challenge-python3-)",
                "solutionTags": [],
                "code": "```python\\n# Recursive\\nclass Solution:\\n    def brokenCalc(self, startValue: int, target: int) -> int:\\n        # Once target <= startValue, we only do subtract 1 to fit the target\\n        if target <= startValue:\\n            return startValue - target\\n        # Base Greedy Condition\\n        if target % 2 == 0:\\n            return 1 + self.brokenCalc(startValue, target // 2)\\n        else:\\n            return 1 + self.brokenCalc(startValue, target + 1)\\n```\n```go\\n// Recursive\\nfunc brokenCalc(startValue int, target int) int {\\n    // Once target <= startValue, we only do subtract 1 to fit the target\\n    if target <= startValue{\\n        return startValue - target\\n    }\\n    // Base Condition\\n    if target % 2 == 0{\\n        return 1 + brokenCalc(startValue, target / 2)\\n    } else{\\n        return 1 + brokenCalc(startValue, target + 1)\\n    }\\n}\\n```\n```cpp\\n// Recursive\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        // Once target <= startValue, we only do subtract 1 to fit the target\\n        if (target <= startValue){\\n            return startValue - target;\\n        }\\n        // Base Condition\\n        if (target % 2 == 0){\\n            return 1 + brokenCalc(startValue, target / 2);\\n        } else{\\n            return 1 + brokenCalc(startValue, target + 1);\\n        }\\n    }\\n};\\n```\n```python\\n# Iterative\\nclass Solution:\\n    def brokenCalc(self, startValue: int, target: int) -> int:\\n        steps = 0\\n        while target > startValue:\\n            steps += 1\\n            # Base Greedy Condition\\n            if target % 2 == 0:\\n                target //= 2\\n            else:\\n                target += 1\\n        # Once target <= startValue, we only do subtract 1 to fit the target\\n        return steps + startValue - target\\n```\n```go\\n// Iterative\\nfunc brokenCalc(startValue int, target int) int {\\n    steps := 0\\n    for target > startValue{\\n        steps++\\n        // Base Condition\\n        if target % 2 == 0{\\n            target /= 2 \\n        } else{\\n            target += 1\\n        }\\n    }\\n    // Once target <= startValue, we only do subtract 1 to fit the target\\n    return steps + startValue - target\\n}\\n```\n```cpp\\n// Iterative\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int steps = 0;\\n        // Base Condition\\n        while (target > startValue){\\n            steps++;\\n            if (target % 2 == 0){\\n                target /= 2;\\n            } else{\\n                target++;\\n            }\\n        }\\n        // Once target <= startValue, we only do subtract 1 to fit the target\\n        return steps + startValue - target;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875785,
                "title": "java-python-recursive",
                "content": "While `target > startValue`, we\\'ll keep reducing `target`, until it\\'s smaller or equals `startValue`.\\nIf `target` is even, if we plus 1 to `target`, then `target` is odd, we can do only plus 1 more,\\nbut` (target + 1 + 1) / 2  = (target / 2) + 1` and  it makes no sense to do an extra operation \\n\\n =>\\n \\n **`target = target / 2` if `target` is even\\n `target = target + 1` if` target` is odd**\\n \\n Using recursion, we can do this check until the `target value` becomes the `start value`\\n\\n### Java\\n\\n```\\npublic int brokenCalc(int startValue, int target) {\\n        if (startValue > target)\\n            return startValue - target;\\n        if (startValue == target)\\n            return 0;\\n\\n        if (target % 2 == 0)\\n            return 1 + brokenCalc(startValue, target / 2);\\n        else\\n            return 1 + brokenCalc(startValue, target + 1);\\n    }\\n```\\n\\n### Python\\n\\n```\\ndef brokenCalc(self, startValue: int, target: int) -> int:\\n        if (startValue > target) : \\n            return startValue - target\\n        if (startValue == target) : \\n            return 0\\n        if (target % 2 == 0): \\n            return 1 + self.brokenCalc(startValue, target // 2)\\n        else : \\n            return 1 + self.brokenCalc(startValue, target + 1)\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Recursion"
                ],
                "code": "```\\npublic int brokenCalc(int startValue, int target) {\\n        if (startValue > target)\\n            return startValue - target;\\n        if (startValue == target)\\n            return 0;\\n\\n        if (target % 2 == 0)\\n            return 1 + brokenCalc(startValue, target / 2);\\n        else\\n            return 1 + brokenCalc(startValue, target + 1);\\n    }\\n```\n```\\ndef brokenCalc(self, startValue: int, target: int) -> int:\\n        if (startValue > target) : \\n            return startValue - target\\n        if (startValue == target) : \\n            return 0\\n        if (target % 2 == 0): \\n            return 1 + self.brokenCalc(startValue, target // 2)\\n        else : \\n            return 1 + self.brokenCalc(startValue, target + 1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1874943,
                "title": "python-solution-easy-to-understand",
                "content": "```\\n# if target value is smaller than startValue we can only subtract from the number\\nif startValue>target:\\n    return startValue-target\\n\\n# we will iterate backwards to reach the startValue (greedy approach)\\ntotal_steps=0\\nwhile target!=startValue:\\n\\tif target<startValue:\\n\\t\\ttotal_steps+=startValue-target\\n\\t\\ttarget=startValue\\n\\telif target%2==1:\\n\\t\\ttotal_steps+=1\\n\\t\\ttarget+=1\\n\\telse:\\n\\t\\ttarget//=2\\n\\t\\ttotal_steps+=1\\nreturn total_steps\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\n# if target value is smaller than startValue we can only subtract from the number\\nif startValue>target:\\n    return startValue-target\\n\\n# we will iterate backwards to reach the startValue (greedy approach)\\ntotal_steps=0\\nwhile target!=startValue:\\n\\tif target<startValue:\\n\\t\\ttotal_steps+=startValue-target\\n\\t\\ttarget=startValue\\n\\telif target%2==1:\\n\\t\\ttotal_steps+=1\\n\\t\\ttarget+=1\\n\\telse:\\n\\t\\ttarget//=2\\n\\t\\ttotal_steps+=1\\nreturn total_steps\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1076754,
                "title": "java-100-recursion",
                "content": "if you like it pls upvote\\n\\nJava\\n```\\nclass Solution {\\n    public int brokenCalc(int X, int Y) {\\n        if(X==Y)\\n        {\\n            return 0;\\n        }\\n        if(X>Y)\\n        {\\n            return X-Y;\\n        }\\n        else\\n        {\\n            if(Y%2==1)\\n            {\\n                return 1+brokenCalc(X,Y+1);\\n            }\\n            else\\n            {\\n                return 1+brokenCalc(X,Y/2);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int brokenCalc(int X, int Y) {\\n        if(X==Y)\\n        {\\n            return 0;\\n        }\\n        if(X>Y)\\n        {\\n            return X-Y;\\n        }\\n        else\\n        {\\n            if(Y%2==1)\\n            {\\n                return 1+brokenCalc(X,Y+1);\\n            }\\n            else\\n            {\\n                return 1+brokenCalc(X,Y/2);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1876481,
                "title": "calculator-reverse-technique-simple-loop-java-100-faster",
                "content": "Hi,\\n\\nI tried this problem straight forward, that time I was not able to pass more than few test cases, so I thought of trying in reverse.\\n\\nHere is my approach :\\n  1. We have to iterate till the target value becomes start value.\\n  2. If the target value is odd then dividing we can increment the count by 2 else 1, this is because if its odd then we can add a value to the target and then divide it by 2\\n  3. Reduce the target by half till the target is less than start value.\\n  4. Once start value is greater than target then add the difference between target and source.\\n\\nHope this is easy to understand.. Upvote if it helps.\\n\\n```\\n    private int brokenCalc(int startValue, int target) {\\n\\t\\tint i=0;\\n\\t\\twhile(target!=startValue){\\n\\t\\t\\tif(target<startValue){\\n\\t\\t\\t\\treturn i+(startValue-target);\\n\\t\\t\\t}\\n\\t\\t\\tif(target%2==1){\\n\\t\\t\\t\\ttarget++;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\ttarget = target/2;\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\treturn i;\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "Hi,\\n\\nI tried this problem straight forward, that time I was not able to pass more than few test cases, so I thought of trying in reverse.\\n\\nHere is my approach :\\n  1. We have to iterate till the target value becomes start value.\\n  2. If the target value is odd then dividing we can increment the count by 2 else 1, this is because if its odd then we can add a value to the target and then divide it by 2\\n  3. Reduce the target by half till the target is less than start value.\\n  4. Once start value is greater than target then add the difference between target and source.\\n\\nHope this is easy to understand.. Upvote if it helps.\\n\\n```\\n    private int brokenCalc(int startValue, int target) {\\n\\t\\tint i=0;\\n\\t\\twhile(target!=startValue){\\n\\t\\t\\tif(target<startValue){\\n\\t\\t\\t\\treturn i+(startValue-target);\\n\\t\\t\\t}\\n\\t\\t\\tif(target%2==1){\\n\\t\\t\\t\\ttarget++;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\ttarget = target/2;\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\treturn i;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1875082,
                "title": "faster-than-100-c-simple-greedy-approach-o-log-n-time-o-1-space-complexity",
                "content": "Approach:\\n\\t1. instead of making startValue equal to target by * and - We can use / and - operation to reduce target to startValue and count steps;\\n\\t2. If current target value is odd than add 1 to target else target is even divide it by 2. at each step increase count of count variable.\\n\\t3. at the end if target ==0 then count is answer but if target become less than startValue then in that case to match target to start we have to perform + operation (startValue-target) times.\\n\\t4. In general count+(startValue-target) will give correct answer;\\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int answer=0;\\n        while(target>startValue){\\n            if(target&1)\\n                target++;\\n            else\\n                target/=2;\\n            answer++;\\n        }\\n        return answer+(startValue-target);\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int answer=0;\\n        while(target>startValue){\\n            if(target&1)\\n                target++;\\n            else\\n                target/=2;\\n            answer++;\\n        }\\n        return answer+(startValue-target);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1846206,
                "title": "javascript-991-broken-calculator",
                "content": "---\\n\\n- This looks similar to a question from Amazon sponsered contest, a month or so ago\\n  - **Brute force** solution\\n  - **Slightly optimized** solution\\n\\n---\\n\\nHope it is simple to understand.\\n\\n---\\n\\n**Brute force** solution\\n\\n```\\nvar brokenCalc = function (startValue, target) {\\n    let count = 0;\\n\\n    // go down\\n    while (target > startValue) {\\n        if (target % 2 === 0) target /= 2;\\n        else target += 1;\\n        count++;\\n    }\\n\\n    // go up\\n    while (startValue != target) {\\n        target += 1;\\n        count++;\\n    }\\n\\n    return count;\\n};\\n```\\n\\n---\\n\\n**Slightly optimized** solution\\n\\n```\\nvar brokenCalc = function (startValue, target) {\\n    let count = 0;\\n\\n    // go down\\n    while (target > startValue) {\\n        if (target % 2 === 0) target /= 2;\\n        else target += 1;\\n        count++;\\n    }\\n\\n    // go up\\n    count += startValue - target;\\n\\n    return count;\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/03bcf34e-ddc0-4cae-bade-1e2669437665_1647182984.236964.png)\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar brokenCalc = function (startValue, target) {\\n    let count = 0;\\n\\n    // go down\\n    while (target > startValue) {\\n        if (target % 2 === 0) target /= 2;\\n        else target += 1;\\n        count++;\\n    }\\n\\n    // go up\\n    while (startValue != target) {\\n        target += 1;\\n        count++;\\n    }\\n\\n    return count;\\n};\\n```\n```\\nvar brokenCalc = function (startValue, target) {\\n    let count = 0;\\n\\n    // go down\\n    while (target > startValue) {\\n        if (target % 2 === 0) target /= 2;\\n        else target += 1;\\n        count++;\\n    }\\n\\n    // go up\\n    count += startValue - target;\\n\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 293970,
                "title": "easy-readable-faster-than-100-c-recursive-solution",
                "content": "```\\n public static int BrokenCalc(int X, int Y)\\n        {\\n            if (Y <= X)\\n                return X - Y;\\n\\n            if (Y % 2 == 1)\\n                return BrokenCalc(X, Y + 1) + 1;\\n            else return BrokenCalc(X, Y / 2) + 1;\\n        }\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\n public static int BrokenCalc(int X, int Y)\\n        {\\n            if (Y <= X)\\n                return X - Y;\\n\\n            if (Y % 2 == 1)\\n                return BrokenCalc(X, Y + 1) + 1;\\n            else return BrokenCalc(X, Y / 2) + 1;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2416694,
                "title": "python-95-67-faster-simplest-solution-with-explanation-beg-to-adv-greedy",
                "content": "```python\\nclass Solution:\\n    def brokenCalc(self, startValue: int, target: int) -> int:\\n        res = 0 # taking a counter. \\n        while target > startValue: # checking if target value is greater then startValue. \\n            res += 1 # as if target is greater implies we`ll be having atleast one operation. \\n            if target%2==0:\\n                target //=2 # in case number is even. \\n            else:\\n                target += 1 # in case number odd. \\n        return res + startValue - target# startValue - target is for (target<=staetValue). \\n```\\n***Found helpful, Do upvote!!***\\n![image](https://assets.leetcode.com/users/images/07f07521-5e18-4da7-8506-d198d0eeeb72_1660327775.915633.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```python\\nclass Solution:\\n    def brokenCalc(self, startValue: int, target: int) -> int:\\n        res = 0 # taking a counter. \\n        while target > startValue: # checking if target value is greater then startValue. \\n            res += 1 # as if target is greater implies we`ll be having atleast one operation. \\n            if target%2==0:\\n                target //=2 # in case number is even. \\n            else:\\n                target += 1 # in case number odd. \\n        return res + startValue - target# startValue - target is for (target<=staetValue). \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1876846,
                "title": "c-how-to-prove-the-o-logn-solution-will-always-work",
                "content": "I refer solution and write in C++. \\n```C++\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int ans = 0; \\n        while(target >startValue) {\\n            ans++;\\n            if (target %2==1){\\n                target++;\\n            } else {\\n                target/=2;\\n            }\\n        }\\n        return ans + startValue - target;\\n    }\\n};\\n```\\nBut the only question is that how to prove this algorithm \\ncan be correct for this problem. \\n\\nAfter thinking sometimes, I still have no answer. \\n\\nCan anyone help me ? \\n\\nThanks a lot \\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int ans = 0; \\n        while(target >startValue) {\\n            ans++;\\n            if (target %2==1){\\n                target++;\\n            } else {\\n                target/=2;\\n            }\\n        }\\n        return ans + startValue - target;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875734,
                "title": "991-c-easy-o-logn-solution-with-explanation",
                "content": "**Please upvote if you find this solution helpful**\\n**Approach:**\\n* Here, we do opposite operations we reduce targetvalue until it is lesser than startvalue\\n* For this we apply just 2 opposite operations....\\ni) If target is odd, add 1 to it\\nii) If target is even, divide it by 2\\n* increment count by 1 for each operation and return it.\\n* **TC-O(LogN), SC- O(1)**\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) \\n    {\\n        //variable for counting no. of operations\\n        int cnt=0;\\n        \\n        while(startValue < target)\\n        {\\n            if(target%2) // odd (t%2==1 for odd)\\n            {\\n                target++;\\n            }\\n            \\n            else //even (t%2==0 for even)\\n            {\\n                target /= 2;\\n            }\\n            \\n            //increment count\\n            cnt++;\\n        }\\n        return cnt + (startValue - target);\\n        \\n    }\\n};\\n```\\n\\n**Please upvote if you find this solution helpful**",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) \\n    {\\n        //variable for counting no. of operations\\n        int cnt=0;\\n        \\n        while(startValue < target)\\n        {\\n            if(target%2) // odd (t%2==1 for odd)\\n            {\\n                target++;\\n            }\\n            \\n            else //even (t%2==0 for even)\\n            {\\n                target /= 2;\\n            }\\n            \\n            //increment count\\n            cnt++;\\n        }\\n        return cnt + (startValue - target);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875432,
                "title": "javascript-intutive-solution",
                "content": "```\\n/**\\n * @param {number} startValue\\n * @param {number} target\\n * @return {number}\\n */\\nvar brokenCalc = function(startValue, target) {\\n    let steps = 0;\\n    \\n    while(target !== startValue){\\n\\n        if(startValue > target){\\n            return steps  + startValue - target;\\n        }\\n        if(target %2 === 0){\\n            target /= 2;\\n        }else {\\n            target += 1;\\n            \\n        }\\n        steps++;\\n    }\\n    return steps\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```\\n/**\\n * @param {number} startValue\\n * @param {number} target\\n * @return {number}\\n */\\nvar brokenCalc = function(startValue, target) {\\n    let steps = 0;\\n    \\n    while(target !== startValue){\\n\\n        if(startValue > target){\\n            return steps  + startValue - target;\\n        }\\n        if(target %2 === 0){\\n            target /= 2;\\n        }else {\\n            target += 1;\\n            \\n        }\\n        steps++;\\n    }\\n    return steps\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1875206,
                "title": "java-100-faster-with-greedy",
                "content": "class Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        \\n        int ans=0;\\n        while(true)\\n        {\\n            if(startValue==target)\\n                return ans;\\n            if(startValue>target)\\n                return ans+startValue-target;\\n            if(target%2==0)\\n            {\\n                target/=2;\\n            }\\n            else\\n            {\\n               target=(target+1)/2;\\n               ans++; \\n            }\\n            ans++;\\n        \\n        }\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "class Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        \\n        int ans=0;\\n        while(true)\\n        {\\n            if(startValue==target)\\n                return ans;\\n            if(startValue>target)\\n                return ans+startValue-target;\\n            if(target%2==0)\\n            {\\n                target/=2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1874880,
                "title": "javascript-greedy-one-liner-recursive-bfs-and-arithmetic-iterative-solutions-100",
                "content": "![image](https://assets.leetcode.com/users/images/a4ae1016-da0f-4e3a-86ae-f0f5840560b8_1647998543.907309.png)\\n\\nHere\\'s the one liner first because I was bored. \\n```\\nconst brokenCalc=(s,e,o=0)=>e<=s?o+s-e:!(e%2)?brokenCalc(s,e/2,o+1):brokenCalc(s,e+1,o+1)\\n```\\n\\nMuch more readable version that works exactly the same:\\n```\\nconst brokenCalc = (start, end, ops = 0) => {\\n  if (end <= start) return ops + start - end;\\n  if (!(end % 2)) return brokenCalc(start, end / 2, ops + 1)\\n  else return brokenCalc(start, end + 1, ops + 1)\\n}\\n```\\n\\nBest / most optimal solution here.  Though if we\\'re being honest, they all have the same complexity / do the same operations, the others just take up a bit more space on the callstack or in the queue.:\\n```\\nconst brokenCalc = (start, end, ops = 0) => {\\n  for (;end > start; ops++) {\\n    !(end % 2) ? end /= 2 : end += 1\\n  }\\n  return ops + start - end\\n}\\n```\\n\\nCompletely unnecessary BFS Version which only ever puts one option in the queue at a time...  Sooo, no branching.  Once again, completely pointless.  But to reiterate - I was bored, and also anytime I see buzzwords like \\'Minimum Operations to\\' or \\'Shortest Distance\\' or \\'Least Time\\' the BFS monster in my brain charges through the wall like Kool-Aid...  So, this is - admittedly - where I started until I wrote it out and realized it was pointless. \\uD83E\\uDD37\\u200D\\u2642\\uFE0F\\n```\\nvar brokenCalc = function(startValue, target, operations = 0) {\\n  const queue = new Queue([target]);\\n  while (!queue.isEmpty()) {\\n    const curend = queue.dequeue();\\n    if (curend <= startValue) return  operations + startValue - curend\\n    if (!(curend % 2)) queue.enqueue(curend / 2)\\n    else queue.enqueue(curend + 1)\\n    operations++\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\nconst brokenCalc=(s,e,o=0)=>e<=s?o+s-e:!(e%2)?brokenCalc(s,e/2,o+1):brokenCalc(s,e+1,o+1)\\n```\n```\\nconst brokenCalc = (start, end, ops = 0) => {\\n  if (end <= start) return ops + start - end;\\n  if (!(end % 2)) return brokenCalc(start, end / 2, ops + 1)\\n  else return brokenCalc(start, end + 1, ops + 1)\\n}\\n```\n```\\nconst brokenCalc = (start, end, ops = 0) => {\\n  for (;end > start; ops++) {\\n    !(end % 2) ? end /= 2 : end += 1\\n  }\\n  return ops + start - end\\n}\\n```\n```\\nvar brokenCalc = function(startValue, target, operations = 0) {\\n  const queue = new Queue([target]);\\n  while (!queue.isEmpty()) {\\n    const curend = queue.dequeue();\\n    if (curend <= startValue) return  operations + startValue - curend\\n    if (!(curend % 2)) queue.enqueue(curend / 2)\\n    else queue.enqueue(curend + 1)\\n    operations++\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1697185,
                "title": "python-o-logn-solution-starting-from-startvalue-with-detailed-explanation",
                "content": "## 991 Broken Calculator\\n\\n[https://leetcode.com/problems/broken-calculator/](https://leetcode.com/problems/broken-calculator/)\\n\\nInstead of doing the smart thing and thinking about the problem from the target backwards as explained [here](https://leetcode.com/problems/broken-calculator/discuss/1076042/Python-C%2B%2B-Explanation-with-illustration-why-we-should-work-with-Y-not-X), I chose to tackle the problem from the startValue upwards.\\n\\nThe general idea is double the startValue until it is greater than target, and it\\'s important to note that the optimal solution **always** requires this many doublings.\\n\\nNow our task is to figure out when to decrease the value so that it minimizes our number of steps.\\n\\n**Case 1:**\\n\\n![case1](https://i.imgur.com/t1ZwSZF.png)\\n\\nIn this example, the difference from the number we get after only doubling and the target is 12. We can see that using the decrease operation at differnce times affects the results differently. The effect of reduction on the final number doubles after every doubling. Decreasing 14 to 13 decreases the final result by 8, since there are 3 doublings after the decrease. This corresponds to 2^3, and so the effects of decreases can be calculated by 2 to the power of the number of doublings remaining. Similarly, there are 2 doublings after the deduction from 26 to 25, and that decreases the final result by 2^2.\\n\\nTherefore, any difference between the number we get from doubling to the target can be broken down into powers of 2, and those powers of 2 then tells us when and how many times to decrease. In this case, the difference of 12 (112-100) can be broken down into 2^3 + 2^2, telling us that we should decrease once with 3 doublings left and once with 2 doublings left.\\n\\nThe final result would be the number of doubles + the number of decreases.\\n\\n**Case 2:**\\n\\n![case2](https://i.imgur.com/laZO199.png)\\n\\nIn this case we have to decrease before we double. The difference of 12 (28-16) can be made up of 2^3 + 2^2. However we can\\'t decrease 3 doublings before the end, since we don\\'t double 3 times. In this case, the earlier we can decrease only affects the final result by 4 (2^2) every time. Therefore the difference can still be broken down into powers of 2, but any powers greater than 2^(max doubles) must be broken down into powers no greater than 2^(max doubles). Here we break the difference down into 3*2^2, meaning we decrease 3 times at 2 doublings before the end.\\n\\n**Case 3:**\\n\\nThis is the case where the start is greater than the target. In this case the result is simply target - start.\\n\\ne.g. \\nstart = 20, target = 5\\nresult = 15 (20-5)\\n\\n**Implementation:**\\n\\nBreaking down the difference into powers of 2 is simply converting the int to binary.\\n\\n```python\\ndef brokenCalc(self, startValue: int, target: int) -> int:\\n```\\nCase 3\\n```python\\n    if startValue>target:\\n        return startValue - target\\n```\\n\\nCalculate doublings and difference\\nx is the value we get if we only apply doubling\\n\\n```python\\n    doublings = 0\\n    x = startValue\\n    while x < target:\\n        x *= 2\\n        doublings += 1\\n    diff = bin(x-target)[2:] #saves difference as binary representation\\n```\\n\\nFinal result res is the number of doublings and the number of decreases\\n```python\\n    res = doublings\\n    #Adds decreases that happen **before** doubling\\n    if diff[:-doublings]:\\n        res += int(diff[:-doublings],2)\\n    #Adds decreases that happen **after** first doubling\\n    if diff[-doublings:]:\\n        res += sum(int(i) for i in diff[-doublings:])\\n    return res\\n```\\n\\nTime: O(logn)\\n\\nSpace: O(1)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\ndef brokenCalc(self, startValue: int, target: int) -> int:\\n```\n```python\\n    if startValue>target:\\n        return startValue - target\\n```\n```python\\n    doublings = 0\\n    x = startValue\\n    while x < target:\\n        x *= 2\\n        doublings += 1\\n    diff = bin(x-target)[2:] #saves difference as binary representation\\n```\n```python\\n    res = doublings\\n    #Adds decreases that happen **before** doubling\\n    if diff[:-doublings]:\\n        res += int(diff[:-doublings],2)\\n    #Adds decreases that happen **after** first doubling\\n    if diff[-doublings:]:\\n        res += sum(int(i) for i in diff[-doublings:])\\n    return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1077278,
                "title": "c-greedy-solution-linear-time",
                "content": "This problem is best solved when reframing the solution around `Y` -- the number we are trying to reach -- and using it as a starting point to reach `X`, which is our original number. This working backwards approach is best exemplified by breaking down the problem using casework:\\n- Clearly, without reframing the problem, we can see that based on the given operations, if `X >= Y`, then the problem is trivial. Since the only way we have to reduce the number is to decrement the number, it is guaranteed to perform the reduction in the fewest number of operations. Therefore, the answer is just `X - Y`.\\n- Otherwise, we can proceed by starting at `Y` and working backwards to get to `X`. The reason why this approach is optimal is because if we were to go in the opposite direction, we don\\'t know the order to best choose our decrement and multiply operations. However, if we work backwards, the path is clear. First of all, let us make clear that the minimum number of operations to get from `X` to `Y` is the minimum number of operations to get from `Y` to `X`. This is apparent by just reversing the order of the operations and applying their inverses, which will ensure minimality. Now, let\\'s look at getting from `Y` to `X`. Clearly, to invert the operations, we must now either divide by two or increment by one, since we are moving in the opposite direction. \\n\\nBased on the setup of this \"working backwards\" process described before, we are left with two cases: \\n- If `Y` is even and more than `X`, we want to divide by 2. This gets us the most \"bang for our buck\" in terms of getting closest to `X`, since we are decreasing by the furthest amount. Furthermore, as an operation, we want to be dividing as much as possible, since there is each division operation can encapsulate up to `Y / 2` subtraction operations.\\n- Otherwise, if we are an odd number, then we just increment. This puts us back into even territory so we can continue decrementing.\\n\\nWe know for certain that dividing at a given point is the best choice we can take, because if we do not divide at that point and instead increment, we are guaranteed to have to increment twice in order to reach the number that would have only one increment had we divided and then incremented, as opposed to incrementing and then dividing (e.g. `10 -> 5 -> 6` vs `10 -> 11 -> 12 -> 6`).\\n\\nAnalyzing this, we see that the time complexity is linear in the number of operations required, since we are merely counting the operations, and requires constant space, since we are only declaring set variables.\\n\\n```\\nint brokenCalc(int X, int Y) {\\n\\tif (X >= Y) {\\n\\t\\treturn X - Y;\\n\\t} else {\\n\\t\\tint count = 0;\\n\\t\\twhile (Y != X) {\\n\\t\\t\\tif (!(Y % 2) && Y > X) {\\n\\t\\t\\t\\tY /= 2;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tY++;\\n\\t\\t\\t}\\n\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint brokenCalc(int X, int Y) {\\n\\tif (X >= Y) {\\n\\t\\treturn X - Y;\\n\\t} else {\\n\\t\\tint count = 0;\\n\\t\\twhile (Y != X) {\\n\\t\\t\\tif (!(Y % 2) && Y > X) {\\n\\t\\t\\t\\tY /= 2;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tY++;\\n\\t\\t\\t}\\n\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1076128,
                "title": "recursive-and-iterative-y-x-1-liner-recursive",
                "content": "\\n\\n\\n**Recursive**\\n\\n```\\nclass Solution {\\n    public int brokenCalc(int X, int Y) {\\n        return (X >= Y) ? X - Y : (Y % 2 == 0) ? 1 + brokenCalc(X, Y / 2) : 1 + brokenCalc(X, Y + 1);\\n\\t\\t// return (X >= Y) ? X - Y : 1 + (Y % 2 == 0 ? brokenCalc(X, Y / 2) : brokenCalc(X, Y + 1));\\n    }\\n}\\n```\\n\\n************\\n**Iterative**\\n\\n```\\nclass Solution {\\n    public int brokenCalc(int X, int Y) {\\n        int operations = 0;\\n        while(Y > X) {\\n            Y = (Y % 2 == 0) ? Y / 2 : Y + 1;\\n            operations++;\\n        }\\n        \\n        return operations + X - Y;\\n    }\\n}\\n```\\n\\n**TC - O(logY)**\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int brokenCalc(int X, int Y) {\\n        return (X >= Y) ? X - Y : (Y % 2 == 0) ? 1 + brokenCalc(X, Y / 2) : 1 + brokenCalc(X, Y + 1);\\n\\t\\t// return (X >= Y) ? X - Y : 1 + (Y % 2 == 0 ? brokenCalc(X, Y / 2) : brokenCalc(X, Y + 1));\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int brokenCalc(int X, int Y) {\\n        int operations = 0;\\n        while(Y > X) {\\n            Y = (Y % 2 == 0) ? Y / 2 : Y + 1;\\n            operations++;\\n        }\\n        \\n        return operations + X - Y;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 705591,
                "title": "short-proof-of-correctness",
                "content": "```\\n    public int brokenCalc(int X, int Y) {\\n        int step = 0;\\n        while (X < Y) {\\n            if (Y % 2 == 0) {\\n                Y /= 2;\\n            } else {\\n                Y++;\\n            }\\n            step++;\\n        }\\n        return step + X - Y;\\n    }\\n```\\n\\nMany persons uses above implementation.\\nLet me proof its correctness.\\n\\nWhen `X >= Y`, we have one path, it is always decrementing `X` to `Y`\\nWhen `X < Y`, let\\'s find out what\\'s last operation\\n* `Y` is odd, last operation must be decrement.  Because we can\\'t multiply 2 to an odd number.\\n* `Y` is even, last operaton must be multiply.  Let\\'s assume `X < Y` and `2 * X >= Y`, that is `X >= Y / 2`, how `X` can reach `Y`\\n\\t* option 1, multiply 2 first, then decrements, operations is `2 * X - Y + 1`\\n\\t* option 2, decrement 1s first, then multiply 2, operations is `X - Y / 2 + 1`\\n\\t* as `(2 *X - Y + 1) - (X - Y / 2 + 1) = X - Y/ 2 >= 0`, so we should choose option2, so the last operation is multiply.\\n\\nWait, I just consider the situation `X >= Y / 2`, but what if `X < Y/ 2`? For `X < Y/ 2`, it must have a step `X_m` where  `Y/2 <= X_m < Y` before it reaches `Y`.\\n",
                "solutionTags": [],
                "code": "```\\n    public int brokenCalc(int X, int Y) {\\n        int step = 0;\\n        while (X < Y) {\\n            if (Y % 2 == 0) {\\n                Y /= 2;\\n            } else {\\n                Y++;\\n            }\\n            step++;\\n        }\\n        return step + X - Y;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 323276,
                "title": "recursive-method-to-solve-problem",
                "content": "## we should analyze the relation of X and Y\\n## case 1: X == Y \\n- the result is  0,these is no need to make any change.\\n\\n## case 2: X  > Y \\n- we can only decrease one by one step. The result will be ```X - Y ```\\n\\n## case 3 : X < Y\\n- case 3.1: if Y is ```odd```, Y must be formed by ```Y + 1 ```which is ```even```, so we can form Y by forming (Y + 1) \\uFF0Cwhich can be formed by some number using ```double ops```\\n- case 3.2: if Y is ```even```, Y must be formed by some number using ```double ops```\\n\\n## code is here,easily understand\\n\\n```cpp\\nint brokenCalc(int X, int Y) {\\n        if( X  == Y ) // case 1\\n            return 0;\\n        if( X > Y ) //  case 2\\n            return X - Y;\\n        if(Y  & 0x01 ) { //case 3.1\\n            return brokenCalc( X, Y + 1 ) + 1 ;\\n        }else {//case 3.2\\n            return brokenCalc( X, Y  /  2 ) + 1;\\n        }\\n        return 0;//end.\\n    }\\n```\\n- Time complexity is $O(log(n))$,space complexity:$O(log(n))$",
                "solutionTags": [],
                "code": "```X - Y ```\n```odd```\n```Y + 1 ```\n```even```\n```double ops```\n```even```\n```double ops```\n```cpp\\nint brokenCalc(int X, int Y) {\\n        if( X  == Y ) // case 1\\n            return 0;\\n        if( X > Y ) //  case 2\\n            return X - Y;\\n        if(Y  & 0x01 ) { //case 3.1\\n            return brokenCalc( X, Y + 1 ) + 1 ;\\n        }else {//case 3.2\\n            return brokenCalc( X, Y  /  2 ) + 1;\\n        }\\n        return 0;//end.\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 241770,
                "title": "c-super-easy-and-short-3-line-solution-can-be-implemented-in-1min-and-beats-100",
                "content": "```\\n    int brokenCalc(int X, int Y) {\\n        if(Y<=X) return X-Y;\\n        if(Y%2==0) return brokenCalc(X, Y/2)+1;\\n        else return brokenCalc(X, Y+1)+1;\\n    }",
                "solutionTags": [],
                "code": "```\\n    int brokenCalc(int X, int Y) {\\n        if(Y<=X) return X-Y;\\n        if(Y%2==0) return brokenCalc(X, Y/2)+1;\\n        else return brokenCalc(X, Y+1)+1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 234478,
                "title": "java-o-logn-solution-with-detailed-explanation",
                "content": "```\\n/* Initially, I am thinking about using BFS.. but the solution will easily get TLE...\\n * Later, after analyze the problem in detail, \\n * I found:\\n * (1) when X > Y... multiple by 2 will only bring us far away from target...\\n *     so each step, we can only subtract 1 from X to get the target value...\\n *     thus we just need to return X - Y;\\n * (2) when Y > X... we can think reversely...\\n *     we can achieve Y from the previous number by either of two cases \\n *     (a) pre - 1 = Y;\\n *     (b) pre * 2 = Y...\\n *     which step to take is dependent on if Y is even or odd...\\n *     if (Y is even), pre = Y / 2;\\n *     if (Y is odd), pre = Y + 1...\\n *     then we reset Y as pre...\\n *     do the same thing, until Y <= X... which is the first case...\\n *         \\n */\\n\\nclass Solution {\\n    public int brokenCalc(int X, int Y) {\\n        int cnt = 0;\\n        while (Y > X) {\\n            if ((Y & 1) == 1) {\\n                Y += 1;\\n                cnt++;\\n            } \\n            Y >>= 1;\\n            cnt++;\\n        }\\n        return cnt + (X - Y);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int brokenCalc(int X, int Y) {\\n        int cnt = 0;\\n        while (Y > X) {\\n            if ((Y & 1) == 1) {\\n                Y += 1;\\n                cnt++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3585777,
                "title": "easy-clear-solution-python-3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def brokenCalc(self, x: int, y: int) -> int:\\n        if y<=x:\\n            return x-y\\n        else:\\n            res=0\\n            while x<y:\\n                if y%2==1:\\n                    y+=1\\n                else:\\n                    y=y//2\\n                res+=1\\n            res+=(x-y)\\n            return res\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def brokenCalc(self, x: int, y: int) -> int:\\n        if y<=x:\\n            return x-y\\n        else:\\n            res=0\\n            while x<y:\\n                if y%2==1:\\n                    y+=1\\n                else:\\n                    y=y//2\\n                res+=1\\n            res+=(x-y)\\n            return res\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345846,
                "title": "best-easiest-to-understand-in-5-lines",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nPlsssss Up Vote! -> \\uD83D\\uDE2D\\n# Code\\n```\\nclass Solution {\\n    public int brokenCalc(int s, int t) {\\n        int ans = 0; \\n        while(t>s){\\n            ans++;\\n            if(t%2==1) t++;        \\n            else t/=2;\\n        }\\n        return ans+s-t;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int brokenCalc(int s, int t) {\\n        int ans = 0; \\n        while(t>s){\\n            ans++;\\n            if(t%2==1) t++;        \\n            else t/=2;\\n        }\\n        return ans+s-t;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3308094,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target)\\n     {\\n        if(startValue >= target)\\n        {\\n            return startValue - target;\\n            }\\n        if(target & 1)\\n        {\\n            return 1 + brokenCalc(startValue, target  + 1);\\n            }\\n        return 1 + brokenCalc(startValue, target / 2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target)\\n     {\\n        if(startValue >= target)\\n        {\\n            return startValue - target;\\n            }\\n        if(target & 1)\\n        {\\n            return 1 + brokenCalc(startValue, target  + 1);\\n            }\\n        return 1 + brokenCalc(startValue, target / 2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256622,
                "title": "c-easy-iterative-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int ans = 0 ;\\n\\n        while(target > startValue)\\n        {\\n            if(target % 2 == 0)\\n            {\\n                target /= 2 ;\\n            }\\n            else\\n            {\\n                target += 1 ;\\n            }\\n            ans ++ ; \\n        }\\n\\n        ans = ans + (startValue - target) ;\\n        return ans ;\\n    }\\n};\\n```\\n![815a317f-9cdf-46e2-a397-af8869dafa2e_1673498197.3721023.png](https://assets.leetcode.com/users/images/9cc6c47d-bdd8-40d7-9737-a2158e0af022_1677948352.6102405.png)\\n",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Greedy"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int ans = 0 ;\\n\\n        while(target > startValue)\\n        {\\n            if(target % 2 == 0)\\n            {\\n                target /= 2 ;\\n            }\\n            else\\n            {\\n                target += 1 ;\\n            }\\n            ans ++ ; \\n        }\\n\\n        ans = ans + (startValue - target) ;\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2907857,
                "title": "java-0ms-100-iterative-recursive",
                "content": "# Please Upvote :D\\n---\\n##### 1. Iterative approach:\\n![image.png](https://assets.leetcode.com/users/images/674497ab-11e0-4658-9ad9-92d5576bf913_1670943311.2295694.png)\\n \\n``` java []\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        int result = 0;\\n\\n        while (target > startValue) {\\n            result++;\\n            if (target % 2 == 0) target /=2;\\n            else target++;\\n        }\\n\\n        return result + (startValue - target);\\n    }\\n}\\n\\n// TC: O(log(target)), SC: O(1)\\n```\\n---\\n##### 2. Recursive approach:\\n![image.png](https://assets.leetcode.com/users/images/e9b351bd-4084-4a34-8a50-65b41eeaecd8_1670943356.5838752.png)\\n\\n``` java []\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        if (startValue >= target) {\\n            return startValue - target;\\n        }\\n\\n        if (target % 2 == 0) {\\n            return 1 + brokenCalc(startValue, target / 2);\\n        }\\n\\n        return 1 + brokenCalc(startValue, target + 1);\\n    }\\n}\\n\\n// TC: O(log(target)), SC: O(1)\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Recursion"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        int result = 0;\\n\\n        while (target > startValue) {\\n            result++;\\n            if (target % 2 == 0) target /=2;\\n            else target++;\\n        }\\n\\n        return result + (startValue - target);\\n    }\\n}\\n\\n// TC: O(log(target)), SC: O(1)\\n```\n``` java []\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        if (startValue >= target) {\\n            return startValue - target;\\n        }\\n\\n        if (target % 2 == 0) {\\n            return 1 + brokenCalc(startValue, target / 2);\\n        }\\n\\n        return 1 + brokenCalc(startValue, target + 1);\\n    }\\n}\\n\\n// TC: O(log(target)), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1876658,
                "title": "simple-java-solution",
                "content": "class Solution {\\n\\n    public int brokenCalc(int s, int t) {\\n        int c=0;\\n        while(t>s)\\n        {\\n            if(t%2==0)\\n            {\\n                c++;\\n                t/=2;\\n            }\\n            else\\n            {\\n                t++;\\n                c++;\\n            }\\n        }\\n        return c+(s-t);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "class Solution {\\n\\n    public int brokenCalc(int s, int t) {\\n        int c=0;\\n        while(t>s)\\n        {\\n            if(t%2==0)\\n            {\\n                c++;\\n                t/=2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1876625,
                "title": "c-broken-calculator-going-backwards",
                "content": "--> Little Intuition : \\n\\n1. instead of going from P to Q think of going Q to P by doing /2 or +1 operations. \\n\\n1. While going backwards, if we encounter an odd number we must think how we must have reached here while going forward (Obviously by doing -1), so we must do a vice verse operation here. for encountering and even number we must have did x*2 while going forward. so we need to do x/2. \\n2. Once we have our startValue>target that means we can no longer do x/2 operations which would reduce it further. so do the remaining +1 operations which is (startValue-target) ops.\\n\\n```\\n  int brokenCalc(int startValue, int target) { \\n        int steps=0;\\n        while(target>startValue){\\n            steps++;\\n           if(target&1)\\n               target++;\\n           else\\n                target/=2;\\n        }\\n        \\n        return steps+(startValue-target);\\n    }\\n```",
                "solutionTags": [
                    "Math",
                    "Greedy"
                ],
                "code": "```\\n  int brokenCalc(int startValue, int target) { \\n        int steps=0;\\n        while(target>startValue){\\n            steps++;\\n           if(target&1)\\n               target++;\\n           else\\n                target/=2;\\n        }\\n        \\n        return steps+(startValue-target);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1875892,
                "title": "c-o-logn-solution-daily-leetcoding-challenge-march-day-23",
                "content": "Intuition: We are sure when we are starting from target to startValue that if number is even that means it would be divided by 2 at some point, if number is odd that means 1 would be substracted from it.\\nSo we are reversing the logic:\\n**1) if target == even, divide it by 2\\n2) if taget == odd, add 1 in it**\\n\\nEdge case: if start value is greater than target then we can just substract 1 every time to reach target. Hence (startValue - target) been done in the last.\\n\\nExample:\\nstartValue = 5\\ntarget = 25\\nwhile(target > startValue)\\n25 -> 26 -> 13 -> 14 -> 7 -> 8 -> 4\\no/p: 6 (operations) + (5-4) = 7\\n\\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        \\n        int count = 0;\\n        while(target> startValue){\\n            if(target%2==0) \\n                target /= 2;\\n            else \\n                target += 1;\\n            \\n            count++;\\n        }\\n        \\n        return count+(startValue-target);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        \\n        int count = 0;\\n        while(target> startValue){\\n            if(target%2==0) \\n                target /= 2;\\n            else \\n                target += 1;\\n            \\n            count++;\\n        }\\n        \\n        return count+(startValue-target);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875775,
                "title": "easy-100-faster-recursive-o-1-space-o-logn-time-100-faster",
                "content": "**Approach**\\nIn this problem, I can\\'t decide which step should i do from the given two (multiply & subtract). But if i do the opposite thing, i can divide and increment the target to get the start value. \\n* Set ans as 0\\n* Start a loop with condition startValue < target & increase by one for every step\\n\\t* If target is even divide target\\n\\t* else increment target by one.\\n*  return ans + (target - startValue)\\n\\n**Code**\\n***Iterative Approach***\\n```\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        int ans = 0;\\n        while(startValue != target && target > startValue){\\n            if(target%2 == 0 )\\n                target /= 2;\\n            else \\n                target++;\\n            ans++;\\n            \\n        }\\n        if(target < startValue)\\n            ans +=  startValue - target;\\n        return ans;\\n    }\\n}\\n```\\n\\n***Recursive Approach***\\n```\\nclass Solution {\\n    private int getStep(int startValue, int target){\\n        if(target <= startValue)\\n            return startValue - target;\\n        if(target%2 == 0){\\n            return 1 + getStep(startValue, target/2);\\n        }else {\\n            return 1 + getStep(startValue, target+1);\\n        }\\n    }\\n    \\n    public int brokenCalc(int startValue, int target) {\\n        return getStep(startValue, target);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        int ans = 0;\\n        while(startValue != target && target > startValue){\\n            if(target%2 == 0 )\\n                target /= 2;\\n            else \\n                target++;\\n            ans++;\\n            \\n        }\\n        if(target < startValue)\\n            ans +=  startValue - target;\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private int getStep(int startValue, int target){\\n        if(target <= startValue)\\n            return startValue - target;\\n        if(target%2 == 0){\\n            return 1 + getStep(startValue, target/2);\\n        }else {\\n            return 1 + getStep(startValue, target+1);\\n        }\\n    }\\n    \\n    public int brokenCalc(int startValue, int target) {\\n        return getStep(startValue, target);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875609,
                "title": "java-solution-with-comments-and-explaination",
                "content": "To Make x to y. we dont know at every step which of the operation might lead to min operation. i.e. for every step we can either do -1 or double it. there is no fix pattern.\\nSo what if we try to reverse think it. i.e. make y to x. in such case x-1 will be replaced by y+1 and x * 2 will be replaced by y / 2.\\nWe know to get min operation we must use more divide by 2 operations.\\n1. loop till y>x\\n2. If y is even. divide it by 2 and if y is odd. add 1 to make it y even again.\\n3. increment counter in each iteration to count no of operations done so far.\\n4. when loop finishes either x==y, in such case counter is the answer else we need to add 1 x-y times to y to make it same as x.\\n\\nexample ->\\nx=3, y=14\\niterations->\\ny,counter\\n14/2,1 (divide)\\n7+1,2(add)\\n8/2,3(divide)\\n4/2,4(divide)\\n\\nreturn 4+(3-2) [add 1 1 times here)\\nin forward direction just reverse the operation order. \\nit is 3 - 1 = 2 * 2 = 4 * 2 = 8 -1 = 7 * 2 =14.\\n\\n```\\npublic int brokenCalc(int start, int target) {\\n\\t\\t// hold no of operations\\n\\t\\tint ans = 0;\\n\\t\\t// till target is greater then start\\n\\t\\twhile (start < target) {\\n\\t\\t\\t// if target is odd. make it even as we can then perform divide operation. which\\n\\t\\t\\t// indeed make no of operation min\\n\\t\\t\\tif (target % 2 == 1) {\\n\\t\\t\\t\\ttarget++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// if target is even. divide by 2.\\n\\t\\t\\t\\ttarget = target / 2;\\n\\t\\t\\t}\\n\\t\\t\\t// increment operation\\n\\t\\t\\tans++;\\n\\t\\t}\\n\\t\\t// either start reaches target. in such case return ans. else then add 1 start -\\n\\t\\t// target no of times more to the target to make it equal to start.\\n\\t\\treturn ans + start - target;\\n\\t}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\npublic int brokenCalc(int start, int target) {\\n\\t\\t// hold no of operations\\n\\t\\tint ans = 0;\\n\\t\\t// till target is greater then start\\n\\t\\twhile (start < target) {\\n\\t\\t\\t// if target is odd. make it even as we can then perform divide operation. which\\n\\t\\t\\t// indeed make no of operation min\\n\\t\\t\\tif (target % 2 == 1) {\\n\\t\\t\\t\\ttarget++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// if target is even. divide by 2.\\n\\t\\t\\t\\ttarget = target / 2;\\n\\t\\t\\t}\\n\\t\\t\\t// increment operation\\n\\t\\t\\tans++;\\n\\t\\t}\\n\\t\\t// either start reaches target. in such case return ans. else then add 1 start -\\n\\t\\t// target no of times more to the target to make it equal to start.\\n\\t\\treturn ans + start - target;\\n\\t}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1875531,
                "title": "easy-c-solution-using-recursion",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    int brokenCalc(int start, int target) {\\n        if(start==target) return 0;\\n        else if(start>target)  return start-target;\\n        else{\\n            if(target%2==1) return 1+brokenCalc(start,target+1);\\n            else return 1+brokenCalc(start,target/2);\\n        }\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    int brokenCalc(int start, int target) {\\n        if(start==target) return 0;\\n        else if(start>target)  return start-target;\\n        else{\\n            if(target%2==1) return 1+brokenCalc(start,target+1);\\n            else return 1+brokenCalc(start,target/2);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1875305,
                "title": "1-line-solution-c-100-faster",
                "content": "**If our start value is greater than target**,\\nthen we have no choice but to decrement it till we reach the target, that gives us *start - target* operations.\\n**If our target is odd**\\nthen we have to add 1 to make it even so as to make it a number that was possibly obtained by doubling the startValue.\\n**If our target is even**\\nthen we can divide this target by 2 \\n**Start - Target will become 0 after finite steps. Hence we get the answer.**\\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int S, int T) {\\n        return S >= T ? S - T : (T & 1 ? 1 + brokenCalc(S,T + 1) : 1 + brokenCalc(S,T/2));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int S, int T) {\\n        return S >= T ? S - T : (T & 1 ? 1 + brokenCalc(S,T + 1) : 1 + brokenCalc(S,T/2));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875097,
                "title": "c-simple-math",
                "content": "As we are given only two operations multiply by 2 and substract 1.\\nIf number is even then the only way to reach it is by multiplying by 2 otherwise add one.\\n\\n```\\npublic class Solution {\\n    public int BrokenCalc(int startValue, int target) {\\n        int count=0;\\n        while(startValue<target)\\n        {\\n            if(target%2==0)\\n                target /=2;\\n            else\\n                target++;\\n            \\n            count++;\\n        }\\n        return count + (startValue-target);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int BrokenCalc(int startValue, int target) {\\n        int count=0;\\n        while(startValue<target)\\n        {\\n            if(target%2==0)\\n                target /=2;\\n            else\\n                target++;\\n            \\n            count++;\\n        }\\n        return count + (startValue-target);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875070,
                "title": "python-99-90-faster-o-n",
                "content": "```\\nclass Solution:\\n    def brokenCalc(self, startValue: int, target: int) -> int:\\n        if target <= startValue:\\n            return startValue - target\\n        else:\\n            steps = 0\\n            while target > startValue:\\n                if target % 2 != 0:\\n                    target += 1\\n                else:\\n                    target = target//2\\n                steps += 1\\n            steps += (startValue - target)\\n            return steps\\n                \\n                \\n```\\n\\n*If you think my solution helped you, please upvote :))*\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def brokenCalc(self, startValue: int, target: int) -> int:\\n        if target <= startValue:\\n            return startValue - target\\n        else:\\n            steps = 0\\n            while target > startValue:\\n                if target % 2 != 0:\\n                    target += 1\\n                else:\\n                    target = target//2\\n                steps += 1\\n            steps += (startValue - target)\\n            return steps\\n                \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875055,
                "title": "javascript-o-n",
                "content": "```\\nvar brokenCalc = function(startValue, target) {\\n    let count = 0;\\n    while(target > startValue) {\\n        target%2 ? target++ : target /= 2;\\n        count++;\\n    }\\n    return count + (startValue - target)\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar brokenCalc = function(startValue, target) {\\n    let count = 0;\\n    while(target > startValue) {\\n        target%2 ? target++ : target /= 2;\\n        count++;\\n    }\\n    return count + (startValue - target)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1874956,
                "title": "c-recursive-100-faster-easy-to-understand-simple-and-sort-o-log-n",
                "content": "**//Please upvote if you find this code is helplful**\\n\\n*Time Complexity : O(log n)\\nSpace Complexity: O(1)*\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n\\t\\n        if(startValue >= target){\\n            return startValue-target;\\n        }\\n        if(target%2 ==0){\\n            return 1 + brokenCalc(startValue, target/2);\\n        }\\n        return 1 + brokenCalc(startValue, target+1);\\n\\t\\t\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n\\t\\n        if(startValue >= target){\\n            return startValue-target;\\n        }\\n        if(target%2 ==0){\\n            return 1 + brokenCalc(startValue, target/2);\\n        }\\n        return 1 + brokenCalc(startValue, target+1);\\n\\t\\t\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1874901,
                "title": "c-approach-from-start-to-target-explaination",
                "content": "Here is a approach that works from start to end.\\n**Working:**\\n1. Keep on multiplying start with 2 until start >= target, meanwhile also calculate the steps.\\n2. Now we have to remove the difference we have between start and target, from the examples you already know reducing at the end wont work.\\n**Here is the logic part:**\\nTo reduce the difference , if we had reduced 1 in any previous step, it would have got multiplied with power of 2s till now. SO using the step count , we can reduced the biggest possible 2\\'s power from difference\\nLets see with example \\n**start = 3 , end = 18\\n 3 -> 6 -> 12 -> 24   steps=4;**\\n difference = 24-18 = 6\\n Now we have to reduce this 6 to 0.\\n \\n If we reduced -1 when x=3 , it would have become -8 till which we cant subtract from 6.\\n If we reduced -1 when x=6 , it would have become -4 , which we can include. SO now diff = 6-4=2;\\n Now we need to reduce 2, when x is in 3phase i.e 12 (although it doesnt mean value would be 12 as we have modifed values in previous iterations) -1 will be become -2 in end and diff=0;\\n \\n```\\nclass Solution {\\npublic:\\n int brokenCalc(int startValue, int target) {\\n     if(startValue >= target)\\n         return startValue-target;\\n\\tlong long  x = startValue;\\n\\tint steps = 0;\\n\\twhile (x < target)\\n\\t\\tx *= 2, steps++;\\n\\tlong long diff =  x - target;\\n\\tif (diff==0) return steps;\\n\\tint i = steps;\\n\\twhile ( diff != 0) {\\n\\t\\tif (diff - (1<<i) >= 0) {\\n\\t\\t\\tdiff -= (1<<i);\\n\\t\\t\\tsteps++;\\n\\t\\t}\\n        else\\n\\t\\ti--;\\n\\t}\\n\\treturn steps;\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n int brokenCalc(int startValue, int target) {\\n     if(startValue >= target)\\n         return startValue-target;\\n\\tlong long  x = startValue;\\n\\tint steps = 0;\\n\\twhile (x < target)\\n\\t\\tx *= 2, steps++;\\n\\tlong long diff =  x - target;\\n\\tif (diff==0) return steps;\\n\\tint i = steps;\\n\\twhile ( diff != 0) {\\n\\t\\tif (diff - (1<<i) >= 0) {\\n\\t\\t\\tdiff -= (1<<i);\\n\\t\\t\\tsteps++;\\n\\t\\t}\\n        else\\n\\t\\ti--;\\n\\t}\\n\\treturn steps;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1077265,
                "title": "python-broken-calculator-simple-solution",
                "content": "```\\ndef brokenCalc(self, X: int, Y: int) -> int:\\n        \\n        ops = 0\\n        \\n        while Y>X:      #reducing Y till it becomes less than X, calculating in reverse way\\n            if Y%2==1:  #if Y is odd, eg: 9 i.e 10-1\\n                Y+=1    \\n            else:\\n                Y=Y//2  #if Y is even \\n            ops+=1\\n        \\n        ops+=(X-Y)      #if X is greater than Y, we can only subtract\\n        \\n        return ops\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef brokenCalc(self, X: int, Y: int) -> int:\\n        \\n        ops = 0\\n        \\n        while Y>X:      #reducing Y till it becomes less than X, calculating in reverse way\\n            if Y%2==1:  #if Y is odd, eg: 9 i.e 10-1\\n                Y+=1    \\n            else:\\n                Y=Y//2  #if Y is even \\n            ops+=1\\n        \\n        ops+=(X-Y)      #if X is greater than Y, we can only subtract\\n        \\n        return ops\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1076711,
                "title": "broken-calculator-c-beats-100-submissions-a-novel-solution-explanation-from-x-to-y",
                "content": "## An simple idea about bits operation\\n\\n* As the X = 3, and you add 1 to 3=> (3 + 1)\\\\\\nHowever, once double operator one time on X, the effect of the \"1\" would also double.\\n* Following the above example,\\n    * 3, add one => 4.\\xA0 \\xA0| 1\\n    * 4, double => 8.\\xA0 \\xA0 \\xA0| 0\\n    * 8, add one => 9.\\xA0 \\xA0| 1\\n    * 9, add one => 10\\xA0 | 1\\n    * 10, double => 20\\xA0 | 0\\n* As the times of double operation more, \"1\" would be effective more anywhere.\\\\\\nTherefore, we treat it as the operation of a bit.\\xA0\\xA0\\n\\n---\\n* e.g, `X=2`, `Y=24`\\n   > * And you would operate (2 -> 3 -> 6 -> 12 -> 24).\\nIf you add 1 to the first \"2\" => (2+1) * 2 * 2 * 2 ...\\nthe \"1\" become 1 * 2 * 2 * 2 ... * (n times)\\n   > * I thought that the \"2\" times 2 continuous until the number greater than \"24\" (Y).\\n=> 2 * 2 * 2 * 2 * 2 = 32. (n = 5)\\nand the different between 24 and 32 is eight.\\n\"8\", in other word, => (1000) on 2 based\\n\\nAs X forces four operations to Y, adding 1 to X, it becomes\\xA0subtracts \"4\".\\\\\\nFinally, the answer is n\\xA0+ (1000)_2 (how many 1\\'s in the number base on 2?)\\\\\\n=> 9\\xA0+ 1 = 10\\n\\n---\\n\\nHowever, cautions for a case...\\\\\\nIs your \"different\" over the n bits can represent, and then the n bits be regarded as \"largest\"?\\n\\ne.g. `X=68`, `Y=71`=> 68 * 2 = 136 > 71. (n = 2)\\n\\n* Different: 136-71 = 6565 => (1000001), \\nit takes seven bits to represent it......n = 2, \\nonly to subtract \"(0)1\"\\ntherefore, shifts 1 bit right => 100000 (32)\\xA0\\n\\n* finally, you should do 32\\xA0+ 1 times subtracting and one double operation to get Y.\\n68 -> 36 -> 72 -> 71(32 time + 1 times + 1 times => 34 times)\\n\\n---\\n\\nIt\\'s **C++ code**:\\n\\n```\\nclass Solution {\\npublic:\\n    typedef struct{\\n        int32_t x;\\n        int32_t pow;\\n    }s_pair;\\n    \\n    int32_t pow(int32_t X, int32_t Y, int32_t &ans){\\n        ans = 0;\\n        while (X < Y){\\n            ans += 1;\\n            X *= 2;\\n        }\\n        return X;\\n    }\\n    \\n    int brokenCalc(int X, int Y) {\\n        int32_t ans = 0;\\n        \\n        int32_t temp = pow(X, Y, ans);\\n        int32_t tp = temp - Y;\\n        if (X > Y)\\n            ans = X - Y;\\n        else{\\n            int32_t anst = ans;\\n            int32_t i = 0;\\n            while (tp > 0 && anst > i){\\n                ans += (tp & 1 > 0);\\n                tp >>= 1;\\n                i += 1;\\n            }\\n            ans += tp;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef struct{\\n        int32_t x;\\n        int32_t pow;\\n    }s_pair;\\n    \\n    int32_t pow(int32_t X, int32_t Y, int32_t &ans){\\n        ans = 0;\\n        while (X < Y){\\n            ans += 1;\\n            X *= 2;\\n        }\\n        return X;\\n    }\\n    \\n    int brokenCalc(int X, int Y) {\\n        int32_t ans = 0;\\n        \\n        int32_t temp = pow(X, Y, ans);\\n        int32_t tp = temp - Y;\\n        if (X > Y)\\n            ans = X - Y;\\n        else{\\n            int32_t anst = ans;\\n            int32_t i = 0;\\n            while (tp > 0 && anst > i){\\n                ans += (tp & 1 > 0);\\n                tp >>= 1;\\n                i += 1;\\n            }\\n            ans += tp;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1076471,
                "title": "c-two-approaches-one-bfs-and-the-other-greedy",
                "content": "My first approach was to use DFS . \\n You will get TLE on this .\\n ```\\n class Solution {\\npublic:\\n    struct node{\\n        int val;\\n        int level;\\n    };\\n    int brokenCalc(int X, int Y) {\\n        \\n \\n         set<int> visit;\\n    if(X==Y)\\n        return 0;\\n    if(X>Y)\\n        return X-Y;\\n   \\n    queue<node> q;\\n    node n = {X, 0};\\n    q.push(n);\\n \\n \\n    while (!q.empty())\\n    {\\n        \\n        node t = q.front();\\n        q.pop();\\n \\n        \\n        if (t.val == Y)\\n            return t.level;\\n \\n        \\n        visit.insert(t.val);\\n \\n        \\n        if (t.val*2 == Y || t.val-1 == Y)\\n            return t.level+1;\\n \\n       \\n        if (visit.find(t.val*2) == visit.end())\\n        {\\n            n.val = t.val*2;\\n            n.level = t.level+1;\\n            q.push(n);\\n        }\\n        if (t.val-1>=0 && visit.find(t.val-1) == visit.end())\\n        {\\n            n.val = t.val-1;\\n            n.level = t.level+1;\\n            q.push(n);\\n        }\\n    }\\n        return 0;\\n    }\\n    \\n};\\n```\\n2nd Approach : Greedy Approach from Backward . p.s : Everyone Shared this .\\n``` \\nclass Solution {\\npublic:\\n    int brokenCalc(int X, int Y) {\\n     \\n        if(X==Y)\\n            return 0;\\n        \\n        int ans=0;\\n        while(Y>X){\\n            ans++;\\n            if(Y%2)\\n                Y++;\\n            else\\n                Y=Y/2;\\n        }\\n        return ans+(X-Y);\\n    }\\n}; \\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Breadth-First Search"
                ],
                "code": "```\\n class Solution {\\npublic:\\n    struct node{\\n        int val;\\n        int level;\\n    };\\n    int brokenCalc(int X, int Y) {\\n        \\n \\n         set<int> visit;\\n    if(X==Y)\\n        return 0;\\n    if(X>Y)\\n        return X-Y;\\n   \\n    queue<node> q;\\n    node n = {X, 0};\\n    q.push(n);\\n \\n \\n    while (!q.empty())\\n    {\\n        \\n        node t = q.front();\\n        q.pop();\\n \\n        \\n        if (t.val == Y)\\n            return t.level;\\n \\n        \\n        visit.insert(t.val);\\n \\n        \\n        if (t.val*2 == Y || t.val-1 == Y)\\n            return t.level+1;\\n \\n       \\n        if (visit.find(t.val*2) == visit.end())\\n        {\\n            n.val = t.val*2;\\n            n.level = t.level+1;\\n            q.push(n);\\n        }\\n        if (t.val-1>=0 && visit.find(t.val-1) == visit.end())\\n        {\\n            n.val = t.val-1;\\n            n.level = t.level+1;\\n            q.push(n);\\n        }\\n    }\\n        return 0;\\n    }\\n    \\n};\\n```\n``` \\nclass Solution {\\npublic:\\n    int brokenCalc(int X, int Y) {\\n     \\n        if(X==Y)\\n            return 0;\\n        \\n        int ans=0;\\n        while(Y>X){\\n            ans++;\\n            if(Y%2)\\n                Y++;\\n            else\\n                Y=Y/2;\\n        }\\n        return ans+(X-Y);\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1076114,
                "title": "0-ms-100-best-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int X, int Y) {\\n        if(X==Y)\\n        {\\n            return 0;\\n        }\\n        if(X>Y)\\n        {\\n            return X-Y;\\n        }\\n        else\\n        {\\n            if(Y%2==1)\\n            {\\n                return 1+brokenCalc(X,Y+1);\\n            }\\n            else\\n            {\\n                return 1+brokenCalc(X,Y/2);\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int X, int Y) {\\n        if(X==Y)\\n        {\\n            return 0;\\n        }\\n        if(X>Y)\\n        {\\n            return X-Y;\\n        }\\n        else\\n        {\\n            if(Y%2==1)\\n            {\\n                return 1+brokenCalc(X,Y+1);\\n            }\\n            else\\n            {\\n                return 1+brokenCalc(X,Y/2);\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1076110,
                "title": "broken-calculator-c-beats-100-submissions-easy-explanation-simple-maths",
                "content": "According to the question, we can perform two types of operations:\\n1] X=X*2;\\n2]X=X-1;\\n\\nIt can be easily observed that when  X>Y  ito reach Y in minimum number of steps, we should \\nonly use the second operation.But  when Y>X  we don\\'t get any clear idea as such about how to proceed.(And as   1<=X,Y<=1e9  brute force approach would lead to TLE.)\\n\\nIf you observe both the give operations are in terms of X;\\nNow if consider equivalent operations in terms of Y(and try to X from Y), it would as follows:\\n1] Y=Y/2;\\n2]Y=Y+1;\\n\\nWe can say that this set of Operations (i.e the one w.r.t Y)  are more convinient as,\\nthe 1st operation can only be applied if Y is even.Similarly if Y is odd operation 1 cannot be performed hence only allowed operation remain operation 2.\\n\\nSo From this we can say that-->\\nif(Y is odd) Y=Y+1;\\nelse Y=Y/2;\\n\\nAnd we repeat the above until Y becomes X.\\n\\n## CODE-->\\n```\\nclass Solution {\\npublic:\\n   \\n    int getAns(int x, int y) \\n    { \\n        if (x>=y)return x-y; \\n        if (y % 2 == 1)return (1 + getAns(x, y + 1)); \\n        else return (1 + getAns(x, y / 2)); \\n        \\n    } \\n    int brokenCalc(int X, int Y){\\n       \\n      return getAns(X,Y);\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    int getAns(int x, int y) \\n    { \\n        if (x>=y)return x-y; \\n        if (y % 2 == 1)return (1 + getAns(x, y + 1)); \\n        else return (1 + getAns(x, y / 2)); \\n        \\n    } \\n    int brokenCalc(int X, int Y){\\n       \\n      return getAns(X,Y);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1075990,
                "title": "java-recursive-2-lines-of-code",
                "content": "```\\n\\tpublic int brokenCalc(int X, int Y) {\\n        if(X >= Y) return X - Y;\\n        return 1 + brokenCalc(X, (Y % 2 == 0) ? Y / 2 : Y + 1);\\n    }",
                "solutionTags": [],
                "code": "```\\n\\tpublic int brokenCalc(int X, int Y) {\\n        if(X >= Y) return X - Y;\\n        return 1 + brokenCalc(X, (Y % 2 == 0) ? Y / 2 : Y + 1);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1033822,
                "title": "easy-clear-solution-python-3",
                "content": "```\\nclass Solution:\\n    def brokenCalc(self, x: int, y: int) -> int:\\n        if y<=x:\\n            return x-y\\n        else:\\n            res=0\\n            while x<y:\\n                if y%2==1:\\n                    y+=1\\n                else:\\n                    y=y//2\\n                res+=1\\n            res+=(x-y)\\n            return res\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def brokenCalc(self, x: int, y: int) -> int:\\n        if y<=x:\\n            return x-y\\n        else:\\n            res=0\\n            while x<y:\\n                if y%2==1:\\n                    y+=1\\n                else:\\n                    y=y//2\\n                res+=1\\n            res+=(x-y)\\n            return res\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 788047,
                "title": "simple-java-backward-solution",
                "content": "```\\nclass Solution {\\n    public int brokenCalc(int X, int Y) {\\n        int res = 0;\\n        while (X != Y) {\\n            if (Y % 2 == 1) {\\n                Y++;\\n                res++;\\n            } else {\\n                if (Y < X) {\\n                    res += X - Y;\\n                    Y = X;\\n                } else {\\n                    Y /= 2;\\n                    res++;\\n                }\\n            }        \\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int brokenCalc(int X, int Y) {\\n        int res = 0;\\n        while (X != Y) {\\n            if (Y % 2 == 1) {\\n                Y++;\\n                res++;\\n            } else {\\n                if (Y < X) {\\n                    res += X - Y;\\n                    Y = X;\\n                } else {\\n                    Y /= 2;\\n                    res++;\\n                }\\n            }        \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 748006,
                "title": "python-explained-high-speed-reversed-approach",
                "content": "**Python Explained | High Speed | Reversed Approach**\\n\\nThe code below presents a Python solution with the notes I used to work out the problem. I hope they are helpful. Cheers,\\n\\n```\\n# Explanation: Let\\'s think the other way around for a second:\\n#           3 -> 10 = 3,6,5,10 (multiply or subtract) ( << 1 , -1)\\n#       This is the same as:\\n#           10 -> 3 = 10,5,6,3 (divide   or sum     ) ( >> 1 , +1) \\n#\\n# Since Bit destruction is somewhat easier:\\n#     - Pop everything, until we reach the required bit length  (adding before reaching len(X) is inefficient (or equal at best))\\n#         - Notice that we can\\'t pop if we don\\'t have a zero at the last bit (we might need to sum one before)\\n#     - Then add the difference between X, and Y:\\n#         - If Y was already higher, divide it by 2 before (but ensure there is a zero at last bit)\\n#\\n# By looking at the algorithm, we need actually to:\\n#     - Pop everything while Y>X\\n#     - Add the difference between [X,Y]\\n#\\nclass Solution:\\n   def brokenCalc(self, X, Y):\\n       # Easy Edge Case, X is higher (or equal since X-Y = 0)\\n       if Y<=X:\\n           return X-Y # We can do nothing but subtract\\n       #\\n       # Y is bigger, now let\\'s think the other way around\\n       n  = 0\\n       while Y>X:\\n           if Y&1:\\n               Y += 1\\n               n += 1\\n           Y >>= 1\\n           n  += 1\\n       n += X-Y # sum to Y until we reach X\\n       return n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Explanation: Let\\'s think the other way around for a second:\\n#           3 -> 10 = 3,6,5,10 (multiply or subtract) ( << 1 , -1)\\n#       This is the same as:\\n#           10 -> 3 = 10,5,6,3 (divide   or sum     ) ( >> 1 , +1) \\n#\\n# Since Bit destruction is somewhat easier:\\n#     - Pop everything, until we reach the required bit length  (adding before reaching len(X) is inefficient (or equal at best))\\n#         - Notice that we can\\'t pop if we don\\'t have a zero at the last bit (we might need to sum one before)\\n#     - Then add the difference between X, and Y:\\n#         - If Y was already higher, divide it by 2 before (but ensure there is a zero at last bit)\\n#\\n# By looking at the algorithm, we need actually to:\\n#     - Pop everything while Y>X\\n#     - Add the difference between [X,Y]\\n#\\nclass Solution:\\n   def brokenCalc(self, X, Y):\\n       # Easy Edge Case, X is higher (or equal since X-Y = 0)\\n       if Y<=X:\\n           return X-Y # We can do nothing but subtract\\n       #\\n       # Y is bigger, now let\\'s think the other way around\\n       n  = 0\\n       while Y>X:\\n           if Y&1:\\n               Y += 1\\n               n += 1\\n           Y >>= 1\\n           n  += 1\\n       n += X-Y # sum to Y until we reach X\\n       return n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 647400,
                "title": "c-2-lines-intuition",
                "content": "**Intuition:**\\nIf (X > Y) only way possible to keep decrementing till Y.\\nIf Y is even, then Y can be reached by reaching Y/2 and adding then 1 step of multiplying by 2.\\nIf Y is odd, then Y can be reached by reaching Y+1, and then 1 step of subtracting 1.\\n\\n**Solution:**\\n\\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int X, int Y) {\\n        \\n        if (X >= Y) return X-Y;\\n        return Y%2 == 0 ? 1 + brokenCalc(X, Y/2) : 1 + brokenCalc(X, Y+1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int X, int Y) {\\n        \\n        if (X >= Y) return X-Y;\\n        return Y%2 == 0 ? 1 + brokenCalc(X, Y/2) : 1 + brokenCalc(X, Y+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 496189,
                "title": "100-javascript-solution-thoroughly-explained-algorithm",
                "content": "First I will paste the code then explain.\\n\\n```\\nconst brokenCalc = function(X, Y) {\\n    if (Y <= X) return X - Y;\\n    let count = 0;\\n    let acc = Y;\\n    \\n    while (acc > X) {\\n        if (acc%2 !== 0) {\\n            acc++;\\n            count++;\\n        }\\n        acc /= 2;\\n        count ++;\\n    }\\n    return count + X - acc;\\n};\\n```\\n\\nFirst, we must split the case into two scenarios. The first case is if Y (second parameter) is less than X. The last example given by the problem matches this: Y=1, X=1024. Because multiplying by 2 will not bring X closer to Y, the only way is to substract 1. Hence, the answer is simply however many times you would subtract 1, and the easiest way to do that is to return the difference between Y and X, hence the first line in the function `if (Y <= X) return X - Y`.\\n\\nThe second scenario is more complicated, because it requires you to combine both multiplication and subtraction operation, and you must find the combination which would have the lowest number of total operations.\\n\\nThe way I did this was by working backwards. I started with Y, and the operations I was counting were instead:\\n1. divide by 2\\n2. add 1\\nTo avoid confusion in this explanation, I will call these operations WBO (working backwards operations). The others, the ones provided by the problem statement, we will call them WFO (working forwards operations).\\n\\nAfter we go through the entire solution, you\\'ll see why I did it in reverse.\\n\\nSay we start with example Y=75, and X=14.\\nThinking in terms WFO, the only way for X to get closer to Y (assuming Y is bigger) is using the \"multiply by 2\" operation. \"subtract 1\" is still important to help us reduce the total number of operations.\\n\\na \"multiply by 2\" operation will always return an even number. If we want to somehow arrive at an odd number, we must use subtract to get there.\\n\\nusing our example, Y=75 which is an odd number. This means that we must use subtract at some point. in WBO terms, we must add 1, and that is one operation. Since we are starting with operations, let\\'s define two variables.\\n\\n`acc` short for \"accumulator\", and it is the intermediary number that we will perform operations on to get to our answer.\\n`count` is the number of operations we have so far performed.\\n\\nafter we add 1 to 75, this means acc=76 and count is 1 because we performed one operation. Now that we have an even number, we know we can get to this number through multiplication in WFO terms. in WBO terms, we divide by two.\\n\\n```\\nacc = 76 / 2 = 38\\ncount = 2\\n```\\n\\nnow we have 38. So we repeat the process. First, we check, can we arrive to this number by multiplying by 2 in WFO terms? In other words, is this number even? if it is, we proceed with dividing by 2 in WBO terms. If it is not, we make it so by adding 1 in WBO terms.\\n\\nIt is even, so we can divide by 2 in WBO.\\n\\n```\\nacc  = 38/2 = 19\\ncount = 3\\n```\\n\\nWe do it again. Is 19 even or odd? it is odd. This means we must add in WBO, because otherwise, we cannot get there by multiplying by two.\\n\\n```\\nacc = 19+1 = 20\\ncount = 4\\n```\\n\\nNow we can divide by two in WBO. However, before we do this, we should note a pattern. In every step, we do the following:\\n1. check if even or odd. If even, skip to step 3. Otherwise, proceed to step 2.\\n2. add 1 (only if it is odd)\\n3. divide by 2\\n\\nThis explains this portion of the code:\\n```\\nif (acc%2 !== 0) {\\n\\tacc++;\\n\\tcount++;\\n}\\nacc /= 2;\\ncount ++;\\n```\\n\\nWhat\\'s the check in while loop for? we\\'re about to find out. Let\\'s proceed.\\n\\n```\\nacc = 20 / 2 = 10\\ncount = 5\\n```\\n\\nso, then we proceed with the usual ... or should we? no we should not. The reason why is that `acc` is now less than `X`. If we divide by 2 (WBO), we will move even farther from X, which is 14, because are no longer at a value greater than `X`. This explains the while loop check.\\n\\nSo, what do we do? Well, since `acc` is less than `X`, this is the same as the first scenario we discussed, where `Y` is smaller `X`. This means that the number of steps left is `X - acc` because they are merely a series of additions in WBO. The final answer must equal that number + `count` that we have already been tallying. This explains the last line in the function.\\n\\nThis technically means that we would not have really need the first if statement at the beginning, because it is redundant. But it was valuable to explain the algorithm.\\n\\nThe reason why we worked backwards is that we would not be able to find the point where, after we subtract several times, we start multiplying by 2 (WFO). In other words, starting with `X=14`, you would not know that you must subtract 1 until you reach 10. Why not 9? or 12? or 7?\\n\\nBONUS:\\n\\nHere is an even shorter way of writing this, using recursion, (nested) ternaries, and arrow functions:\\n\\n```\\nconst brokenCalc = (X, Y) => (Y <= X) ? X - Y : (Y % 2 === 0) ? brokenCalc(X, Y / 2) + 1 : brokenCalc(X, Y+1) + 1;\\n```",
                "solutionTags": [],
                "code": "```\\nconst brokenCalc = function(X, Y) {\\n    if (Y <= X) return X - Y;\\n    let count = 0;\\n    let acc = Y;\\n    \\n    while (acc > X) {\\n        if (acc%2 !== 0) {\\n            acc++;\\n            count++;\\n        }\\n        acc /= 2;\\n        count ++;\\n    }\\n    return count + X - acc;\\n};\\n```\n```\\nacc = 76 / 2 = 38\\ncount = 2\\n```\n```\\nacc  = 38/2 = 19\\ncount = 3\\n```\n```\\nacc = 19+1 = 20\\ncount = 4\\n```\n```\\nif (acc%2 !== 0) {\\n\\tacc++;\\n\\tcount++;\\n}\\nacc /= 2;\\ncount ++;\\n```\n```\\nacc = 20 / 2 = 10\\ncount = 5\\n```\n```\\nconst brokenCalc = (X, Y) => (Y <= X) ? X - Y : (Y % 2 === 0) ? brokenCalc(X, Y / 2) + 1 : brokenCalc(X, Y+1) + 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 481824,
                "title": "two-lines-c-0ms",
                "content": "Y only can be even or odd. If Y is even, can be arrived through x * 2, i.e, x should arrive Y/2 first. We need {brokenCalc(X, Y/2) + 1} steps;\\nIf Y is odd, only can be achieved this  -1 operation, i.e., x should arrive (Y+1) first. We need {brokenCalc(X, Y + 1) + 1} steps;\\n\\t\\n\\tint brokenCalc(int X, int Y) {\\n        if (Y <= X) return X - Y;\\n        return (Y % 2 == 0)? brokenCalc(X, Y / 2) + 1 : brokenCalc(X, Y + 1) + 1;\\n    }\\n\\t\\n\\t",
                "solutionTags": [],
                "code": "Y only can be even or odd. If Y is even, can be arrived through x * 2, i.e, x should arrive Y/2 first. We need {brokenCalc(X, Y/2) + 1} steps;\\nIf Y is odd, only can be achieved this  -1 operation, i.e., x should arrive (Y+1) first. We need {brokenCalc(X, Y + 1) + 1} steps;\\n\\t\\n\\tint brokenCalc(int X, int Y) {\\n        if (Y <= X) return X - Y;\\n        return (Y % 2 == 0)? brokenCalc(X, Y / 2) + 1 : brokenCalc(X, Y + 1) + 1;\\n    }\\n\\t\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 352258,
                "title": "c-solution",
                "content": "```\\npublic class Solution \\n{\\n    public int BrokenCalc(int x, int y) \\n    {\\n        if(x >= y) return x - y;\\n        if(y % 2 == 0) return 1 + BrokenCalc(x, y / 2);\\n        return 1 + BrokenCalc(x, y + 1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public int BrokenCalc(int x, int y) \\n    {\\n        if(x >= y) return x - y;\\n        if(y % 2 == 0) return 1 + BrokenCalc(x, y / 2);\\n        return 1 + BrokenCalc(x, y + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3643922,
                "title": "simple-c-solution-best-for-beginners",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int X, int Y) {\\n        int res = 0;\\n        while (Y > X) {\\n            Y = Y % 2 > 0 ? Y + 1 : Y / 2;\\n            res++;\\n        }\\n        return res + X - Y;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int X, int Y) {\\n        int res = 0;\\n        while (Y > X) {\\n            Y = Y % 2 > 0 ? Y + 1 : Y / 2;\\n            res++;\\n        }\\n        return res + X - Y;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3536528,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\n public:\\n  int brokenCalc(int X, int Y) {\\n    int ops = 0;\\n\\n    while (X < Y) {\\n      if (Y % 2 == 0)\\n        Y /= 2;\\n      else\\n        Y += 1;\\n      ++ops;\\n    }\\n    return ops + X - Y;\\n  }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def brokenCalc(self, startValue: int, target: int) -> int:\\n        ans = 0 \\n        while target > startValue:\\n            if not target % 2:\\n                target /= 2\\n            else:\\n                target += 1\\n\\n            ans += 1\\n\\n        return ans + int(startValue - target)\\n```\\n\\n```Java []\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        if(startValue >= target) return startValue - target;\\n        if(target % 2 == 0){\\n            return 1 + brokenCalc(startValue, target / 2);\\n        }\\n        return 1 + brokenCalc(startValue, target + 1);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\n public:\\n  int brokenCalc(int X, int Y) {\\n    int ops = 0;\\n\\n    while (X < Y) {\\n      if (Y % 2 == 0)\\n        Y /= 2;\\n      else\\n        Y += 1;\\n      ++ops;\\n    }\\n    return ops + X - Y;\\n  }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def brokenCalc(self, startValue: int, target: int) -> int:\\n        ans = 0 \\n        while target > startValue:\\n            if not target % 2:\\n                target /= 2\\n            else:\\n                target += 1\\n\\n            ans += 1\\n\\n        return ans + int(startValue - target)\\n```\n```Java []\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        if(startValue >= target) return startValue - target;\\n        if(target % 2 == 0){\\n            return 1 + brokenCalc(startValue, target / 2);\\n        }\\n        return 1 + brokenCalc(startValue, target + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2809393,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\n\\t\\t\\t\\t\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        if(startValue >= target)\\n            return startValue - target;\\n        \\n        if(target & 1)\\n            return 1 + brokenCalc(startValue, target  + 1);\\n        \\n        return 1 + brokenCalc(startValue, target / 2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\t\\t\\t\\t\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        if(startValue >= target)\\n            return startValue - target;\\n        \\n        if(target & 1)\\n            return 1 + brokenCalc(startValue, target  + 1);\\n        \\n        return 1 + brokenCalc(startValue, target / 2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2645546,
                "title": "100-faster-c-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int i, int j) {\\n        if(i>=j){\\n            return (i-j);\\n        }\\n        if(j%2){\\n            return 1+brokenCalc(i,j+1);\\n        }\\n        else{\\n            return 1+brokenCalc(i,(j>>1));\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Greedy",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int i, int j) {\\n        if(i>=j){\\n            return (i-j);\\n        }\\n        if(j%2){\\n            return 1+brokenCalc(i,j+1);\\n        }\\n        else{\\n            return 1+brokenCalc(i,(j>>1));\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2501378,
                "title": "o-log-n-time-o-1-space-clear-explanation-change-2-1-to-2-1",
                "content": "![image](https://assets.leetcode.com/users/images/046804c6-93fc-460b-a0ca-26266e4d25cb_1661796524.3940682.png)\\n\\n    def brokenCalc(self, startValue: int, target: int) -> int:\\n        \"\"\" O(log N)TS \"\"\"\\n        if startValue >= target:\\n            return startValue - target\\n        return 1 + self.brokenCalc(startValue, target // 2 if target % 2 == 0 else target + 1)\\n\\n    def brokenCalc(self, startValue: int, target: int, ans=0) -> int:\\n        \"\"\" O(log N)T O(1)S \"\"\"\\n\\n        while startValue < target:\\n            target = target // 2 if target % 2 == 0 else target + 1\\n            ans += 1\\n\\n        return ans + startValue - target",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/046804c6-93fc-460b-a0ca-26266e4d25cb_1661796524.3940682.png)\\n\\n    def brokenCalc(self, startValue: int, target: int) -> int:\\n        \"\"\" O(log N)TS \"\"\"\\n        if startValue >= target:\\n            return startValue - target\\n        return 1 + self.brokenCalc(startValue, target // 2 if target % 2 == 0 else target + 1)\\n\\n    def brokenCalc(self, startValue: int, target: int, ans=0) -> int:\\n        \"\"\" O(log N)T O(1)S \"\"\"\\n\\n        while startValue < target:\\n            target = target // 2 if target % 2 == 0 else target + 1\\n            ans += 1\\n\\n        return ans + startValue - target",
                "codeTag": "Python3"
            },
            {
                "id": 2465756,
                "title": "c-solution-time-o-log-target-memory-o-1-beats-100-easy-to-understand-greedy",
                "content": "```C#\\npublic class Solution {\\n    public int BrokenCalc(int startValue, int target) {\\n        int ans = 0;\\n        while (startValue < target) {\\n            if (target % 2 == 1) target++;\\n            else target /= 2;\\n            ans++;\\n        }\\n        \\n        if (startValue == target) return ans;\\n        return ans + startValue - target;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```C#\\npublic class Solution {\\n    public int BrokenCalc(int startValue, int target) {\\n        int ans = 0;\\n        while (startValue < target) {\\n            if (target % 2 == 1) target++;\\n            else target /= 2;\\n            ans++;\\n        }\\n        \\n        if (startValue == target) return ans;\\n        return ans + startValue - target;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2460180,
                "title": "c-2-line-solution-iterative-solution-easy-observation",
                "content": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int start, int target) {\\n        int ct=0;\\n        while(target!=start){\\n            if(target%2==0 and start<=target) target/=2;\\n            else target++;\\n              ct++; }\\n        return ct;\\n    }\\n};\\n**If You Like It Please Upvote.**\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int start, int target) {\\n        int ct=0;\\n        while(target!=start){\\n            if(target%2==0 and start<=target) target/=2;\\n            else target++;\\n              ct++; }\\n        return ct;\\n    }\\n};\\n**If You Like It Please Upvote.**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2336431,
                "title": "greedy-with-basic-maths-100-fast-and-100-memory-efficient",
                "content": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int start, int target) {\\n        int ans = 0;\\n        while(target>start){\\n            if(target%2){\\n                target++;\\n                ans++;\\n            }\\n            target /= 2;\\n            ans++;\\n        }\\n        return ans + start - target;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int start, int target) {\\n        int ans = 0;\\n        while(target>start){\\n            if(target%2){\\n                target++;\\n                ans++;\\n            }\\n            target /= 2;\\n            ans++;\\n        }\\n        return ans + start - target;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111139,
                "title": "c-100-faster-tc-log-n-detailed-logic",
                "content": "```\\n// 1- Here we have been given (either multiply by 2 or decrement 1) to startValue, So we can have three possible condition-\\n// 1a- startValue become equal to target\\n// 1b- startValue become greater than target\\n// 1c - startValue is less than target\\n// 2- You  might think that we will multiply by 2 until startValue<=target and then substract if startValue become greater. But 2nd test case will not pass though this logic.\\n// 3- So instead of making startValue to target ,we will do just opposite. We will devide until target is greater than startValue and finally add if target become less than startValue\\nclass Solution {\\npublic:\\n    int brokenCalc(int startVal, int target) {\\n        if(startVal>=target) return startVal-target;\\n        int cnt=0;\\n        while(target>startVal)\\n        {\\n            if(target%2==0)\\n            target/=2;\\n            else target+=1;\\n            cnt++;\\n        }\\n        if(startVal>target) cnt+=(startVal-target);\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\n// 1- Here we have been given (either multiply by 2 or decrement 1) to startValue, So we can have three possible condition-\\n// 1a- startValue become equal to target\\n// 1b- startValue become greater than target\\n// 1c - startValue is less than target\\n// 2- You  might think that we will multiply by 2 until startValue<=target and then substract if startValue become greater. But 2nd test case will not pass though this logic.\\n// 3- So instead of making startValue to target ,we will do just opposite. We will devide until target is greater than startValue and finally add if target become less than startValue\\nclass Solution {\\npublic:\\n    int brokenCalc(int startVal, int target) {\\n        if(startVal>=target) return startVal-target;\\n        int cnt=0;\\n        while(target>startVal)\\n        {\\n            if(target%2==0)\\n            target/=2;\\n            else target+=1;\\n            cnt++;\\n        }\\n        if(startVal>target) cnt+=(startVal-target);\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1899262,
                "title": "broken-calculator-o-n-logic",
                "content": "class Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        int count=0;\\n        while(startValue!=target)\\n        { if(target>startValue)\\n            if(target%2==0&&(startValue-target)!=1 )\\n            {\\n                target=target/2;\\n                count++;\\n            }\\n             else{\\n                target = target+1;\\n                count++;\\n            }\\n             else{\\n                startValue=startValue-1;\\n                    count++;\\n}}\\n        return count;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        int count=0;\\n        while(startValue!=target)\\n        { if(target>startValue)\\n            if(target%2==0&&(startValue-target)!=1 )\\n            {\\n                target=target/2;\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1885472,
                "title": "beats-100-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int start, int target) {\\n        int ans=0;\\n        while(start!=target){\\n            if(target > start and target%2==0)\\n                target/=2;\\n            else if(target > start)\\n                ++target;\\n            else{\\n                ans+=abs(target-start)-1;\\n                target=start;\\n            }\\n            ++ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int start, int target) {\\n        int ans=0;\\n        while(start!=target){\\n            if(target > start and target%2==0)\\n                target/=2;\\n            else if(target > start)\\n                ++target;\\n            else{\\n                ans+=abs(target-start)-1;\\n                target=start;\\n            }\\n            ++ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1882451,
                "title": "python3-simple-solution",
                "content": "```\\ndef brokenCalc(self, start: int, target: int) -> int:\\n        \\n        count = 0\\n        while target > start:\\n            if target%2 != 0:\\n                target += 1\\n            else:\\n                target//=2\\n                \\n            count += 1\\n            \\n        count += start - target\\n            \\n            \\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\ndef brokenCalc(self, start: int, target: int) -> int:\\n        \\n        count = 0\\n        while target > start:\\n            if target%2 != 0:\\n                target += 1\\n            else:\\n                target//=2\\n                \\n            count += 1\\n            \\n        count += start - target\\n            \\n            \\n        return count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1877523,
                "title": "c-100-faster-solution-0ms-easy-approach",
                "content": "**C++ Solution**\\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n    int count=0; \\n        while (startValue < target) \\n        {   count++;\\n            if (target % 2) target++;\\n            else target /= 2;\\n        }\\n    return startValue-target+count;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n    int count=0; \\n        while (startValue < target) \\n        {   count++;\\n            if (target % 2) target++;\\n            else target /= 2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1877499,
                "title": "c-easy-approach-leetcode-challenge",
                "content": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int count=0;\\n        while(startValue<target)\\n        {\\n            if(target%2==0)\\n            {\\n              target/=2;\\n              count++;\\n            }\\n            else\\n            {\\n                target+=1;\\n                count++;\\n            }\\n        }\\n        return count+startValue-target;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int count=0;\\n        while(startValue<target)\\n        {\\n            if(target%2==0)\\n            {\\n              target/=2;\\n              count++;\\n            }\\n            else\\n            {\\n                target+=1;\\n                count++;\\n            }\\n        }\\n        return count+startValue-target;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1877421,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        \\n        int ans=0;\\n        //Check if target is even or odd\\n        while(startValue<target)\\n        {\\n\\t\\t   //If even, divide the target by 2 and increment the ans by 1\\n            if(target%2==0)\\n            {\\n                target/=2;\\n                ans++;\\n            }\\n            else{\\n\\t\\t\\t   //If odd, add 1 to target and increment the ans by 1\\n                target++;\\n                ans++;\\n            }\\n        }\\n        \\n        \\n        return ans+startValue-target;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        \\n        int ans=0;\\n        //Check if target is even or odd\\n        while(startValue<target)\\n        {\\n\\t\\t   //If even, divide the target by 2 and increment the ans by 1\\n            if(target%2==0)\\n            {\\n                target/=2;\\n                ans++;\\n            }\\n            else{\\n\\t\\t\\t   //If odd, add 1 to target and increment the ans by 1\\n                target++;\\n                ans++;\\n            }\\n        }\\n        \\n        \\n        return ans+startValue-target;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1877249,
                "title": "forward-solution-python",
                "content": "Let\\'s assume that the shortest path consists of k steps where each step consists of one or two actions:\\n1. (optional) decrease by one\\n2. multiply by 2\\n\\nThen\\n\\ntarget = 2 ** k start - a_k 2 ** k - a_(k - 1) 2 ** (k - 1) - ... - a_0\\n\\nLike in the official solution, we can show that a_i is either 0 or 1 for i = 0, 1, ..., k - 1. (Note that a_k may be greater than 1.) Then\\n\\n2 ** k start - target = a_k 2 ** k + a_(k - 1) 2 ** (k - 1) + ... + a_0\\n\\nwhich means that the total cost is k + popcount((k + 1 least significant bits of 2 ** k start - target) - (binary number a_k a_(k-1) ... a_0)). Note that we need to know k to evaluate this expression.\\n\\nFinally, we can show that this number of steps in the shortest path, k, is the minimum number of left shifts that, when applied to startValue, would evaluate greater or equal to target.\\n\\n\\n```\\nclass Solution:\\n    def brokenCalc(self, startValue: int, target: int) -> int:\\n        if target <= startValue:\\n            return startValue - target\\n        cost = 0\\n        val = startValue\\n        mask = 2\\n        sh = 0\\n        while val < target:\\n            cost += 1\\n            val <<= 1\\n            mask <<= 1\\n            sh += 1\\n        mask -= 1\\n        cost += ((val - target) & mask).bit_count()\\n        val -= ((val - target) & mask)\\n        cost += (val - target) >> sh\\n        return cost\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def brokenCalc(self, startValue: int, target: int) -> int:\\n        if target <= startValue:\\n            return startValue - target\\n        cost = 0\\n        val = startValue\\n        mask = 2\\n        sh = 0\\n        while val < target:\\n            cost += 1\\n            val <<= 1\\n            mask <<= 1\\n            sh += 1\\n        mask -= 1\\n        cost += ((val - target) & mask).bit_count()\\n        val -= ((val - target) & mask)\\n        cost += (val - target) >> sh\\n        return cost\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1877088,
                "title": "100-faster-c-easiest-approach",
                "content": "by targeting the target.\\n\\n```\\nint brokenCalc(int startValue, int target) {\\n        int count=0;\\n        while(target>startValue)\\n        {\\n            count++;\\n            if(target&1)\\n                target+=1;\\n                \\n            else\\n                target=target/2;\\n                \\n        }\\n        count=count+(startValue-target);\\n        \\n        return count;\\n        \\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "by targeting the target.\\n\\n```\\nint brokenCalc(int startValue, int target) {\\n        int count=0;\\n        while(target>startValue)\\n        {\\n            count++;\\n            if(target&1)\\n                target+=1;\\n                \\n            else\\n                target=target/2;\\n                \\n        }\\n        count=count+(startValue-target);\\n        \\n        return count;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1877070,
                "title": "java-solution-100-faster",
                "content": "\\tclass Solution \\n\\t{   \\n\\t\\tpublic int brokenCalc(int startValue, int target) \\n\\t\\t{\\n\\t\\t\\tint res = 0;\\n\\n\\t\\t\\twhile(target>startValue)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(target%2 == 1)\\n\\t\\t\\t\\t\\ttarget++;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\ttarget /= 2;\\n\\t\\t\\t\\tres++;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn res - target + startValue;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "class Solution \\n\\t{   \\n\\t\\tpublic int brokenCalc(int startValue, int target) \\n\\t\\t{\\n\\t\\t\\tint res = 0;\\n\\n\\t\\t\\twhile(target>startValue)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(target%2 == 1)\\n\\t\\t\\t\\t\\ttarget++;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\ttarget /= 2;\\n\\t\\t\\t\\tres++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1876929,
                "title": "c-0ms-100-faster-target-to-startvalue",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint brokenCalc(int startValue, int target) {\\n\\t\\t\\t int ans=0;\\n\\t\\t\\t while(target>startValue){\\n\\t\\t\\t\\t  if(target%2==0){\\n\\t\\t\\t\\t\\t  target/=2;\\n\\t\\t\\t\\t  }\\n\\t\\t\\t\\t else{\\n\\t\\t\\t\\t\\t target+=1;\\n\\t\\t\\t\\t }\\n\\t\\t\\t\\t ans++;\\n\\t\\t\\t }\\n\\t\\t\\treturn ans+abs(target-startValue);\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint brokenCalc(int startValue, int target) {\\n\\t\\t\\t int ans=0;\\n\\t\\t\\t while(target>startValue){\\n\\t\\t\\t\\t  if(target%2==0){\\n\\t\\t\\t\\t\\t  target/=2;\\n\\t\\t\\t\\t  }",
                "codeTag": "Java"
            },
            {
                "id": 1876815,
                "title": "c-best-100",
                "content": "Here is the code for this question.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int count=0;\\n        while (target>startValue) {\\n            if (target%2 ==0) target/=2;\\n            else target+=1;\\n            count++;\\n        }\\n        return count+abs(startValue-target);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int count=0;\\n        while (target>startValue) {\\n            if (target%2 ==0) target/=2;\\n            else target+=1;\\n            count++;\\n        }\\n        return count+abs(startValue-target);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1876645,
                "title": "python-simple-solution-with-base-case-explanation",
                "content": "```\\nclass Solution:\\n    def brokenCalc(self, startValue: int, target: int) -> int:\\n        #For this you can simply think for a situation where in start you are at peak and you have to come down from peak and there is only one possibility for that which move down and that\\'s why we do this\\n        if startValue >= target:\\n            return startValue - target\\n        if target % 2== 0:\\n            return 1 + self.brokenCalc(startValue , target // 2)\\n        else:\\n            return 1 + self.brokenCalc(startValue , target + 1)\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def brokenCalc(self, startValue: int, target: int) -> int:\\n        #For this you can simply think for a situation where in start you are at peak and you have to come down from peak and there is only one possibility for that which move down and that\\'s why we do this\\n        if startValue >= target:\\n            return startValue - target\\n        if target % 2== 0:\\n            return 1 + self.brokenCalc(startValue , target // 2)\\n        else:\\n            return 1 + self.brokenCalc(startValue , target + 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1876465,
                "title": "java-simple-clean-solution-with-easy-explanation-of-thought-process",
                "content": "\\n**Idea**\\nIt is simple to think of the problem in the opposite direction. It just feels more natural that as we can clearly see that dividing by 2 is the fastest way to decrease the src towards our target. So if we think of it like - decreasing target to reach startVal using `+1` and `/2`(reversed the operations) operations, it becomes simpler. The solution is simple to comprehend once you understand the below points -\\n\\n1. if `startValue>target`, there is no option other than keeping on adding 1 till we reach the startVal;\\n2. if possible to `divide by 2`, that is the fastest way to decrease target. Hence we do that if possible. \\n3. if not possible(target is odd), we can `add 1` to target using one operation and then again continue the fastest way available to us i.e. point 2.\\n\\nRefer to the code now.\\n\\n```java\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        int ops=0;\\n        while(true){\\n            if(startValue==target)\\n                return ops;\\n            if(startValue>target)  // point 1.\\n                return ops+startValue-target;\\n            \\n            if(target%2==0)target/=2; // point 2.\\n            else{\\n               target=(target+1)/2;   // point 3.\\n               ops++; \\n            }\\n            ops++;\\n        }\\n    }\\n}\\n```\\n\\n**TC is O(logn) and SC is O(1)**\\n",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```java\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        int ops=0;\\n        while(true){\\n            if(startValue==target)\\n                return ops;\\n            if(startValue>target)  // point 1.\\n                return ops+startValue-target;\\n            \\n            if(target%2==0)target/=2; // point 2.\\n            else{\\n               target=(target+1)/2;   // point 3.\\n               ops++; \\n            }\\n            ops++;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1876456,
                "title": "c-5-lines-faster-than-100-takes-memory-less-than-73-18",
                "content": "```c++\\nint res = 0;\\nwhile (target > startValue) {\\n\\tres++;\\n\\ttarget = target % 2 == 0 ? target / 2 : target + 1;\\n}\\nreturn res + (startValue - target);\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```c++\\nint res = 0;\\nwhile (target > startValue) {\\n\\tres++;\\n\\ttarget = target % 2 == 0 ? target / 2 : target + 1;\\n}\\nreturn res + (startValue - target);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1876427,
                "title": "c-easy-iterative-solution-100-faster",
                "content": "Easy iterative solution if target is even then we will divide by 2 and if it is odd then we will add one and divide by 2. If it reaches less than startvalue we will increment till it reaches startvalue\\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int start, int target) {\\n        int ans=0;\\n        while(target>=start)\\n        {\\n            if(target==start)\\n                return ans;\\n            else if(target%2!=0)\\n                ans+=2;\\n            else\\n                ans+=1;\\n            target=(target+1)/2;\\n        }\\n        if(target<start)\\n            ans+=start-target;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int start, int target) {\\n        int ans=0;\\n        while(target>=start)\\n        {\\n            if(target==start)\\n                return ans;\\n            else if(target%2!=0)\\n                ans+=2;\\n            else\\n                ans+=1;\\n            target=(target+1)/2;\\n        }\\n        if(target<start)\\n            ans+=start-target;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1876361,
                "title": "c-straight-forward-recursive-solution-beats-100-solutions",
                "content": "```\\nclass Solution {\\nprivate:\\n    int dfs(int startValue,int target){\\n        if(startValue == target) return 0;\\n        \\n        if(target > startValue){\\n            if((target & 1) == 0) return 1 + dfs(startValue, target / 2);\\n            else return 1 + dfs(startValue, target + 1);\\n        }\\n        else{\\n            return (startValue - target);\\n        }\\n    }\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        return dfs(startValue,target);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int dfs(int startValue,int target){\\n        if(startValue == target) return 0;\\n        \\n        if(target > startValue){\\n            if((target & 1) == 0) return 1 + dfs(startValue, target / 2);\\n            else return 1 + dfs(startValue, target + 1);\\n        }\\n        else{\\n            return (startValue - target);\\n        }\\n    }\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        return dfs(startValue,target);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1876358,
                "title": "easy-understanding-solution",
                "content": "```\\n//PLEASE UPVOTE, IF U LIKE MY SOLUTION  :)\\nint brokenCalc(int start, int target) {\\n        if(start == target) return 0;\\n        if(target < start) return start - target;\\n        int ans = 0;\\n        while(start<target){\\n            ans++;\\n            if(target % 2 == 0){ //even\\n                target /= 2;\\n            }else{\\n                target += 1;\\n                if(target < start) break;\\n            }\\n        }\\n        return ans + start-target;\\n    }\\n//PLEASE UPVOTE, IF U LIKE MY SOLUTION  :)\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Math",
                    "Greedy",
                    "Recursion"
                ],
                "code": "```\\n//PLEASE UPVOTE, IF U LIKE MY SOLUTION  :)\\nint brokenCalc(int start, int target) {\\n        if(start == target) return 0;\\n        if(target < start) return start - target;\\n        int ans = 0;\\n        while(start<target){\\n            ans++;\\n            if(target % 2 == 0){ //even\\n                target /= 2;\\n            }else{\\n                target += 1;\\n                if(target < start) break;\\n            }\\n        }\\n        return ans + start-target;\\n    }\\n//PLEASE UPVOTE, IF U LIKE MY SOLUTION  :)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1876340,
                "title": "c-easy-solution-100-faster",
                "content": "\\n\\tint brokenCalc(int startValue, int target) {\\n\\t\\t\\t\\t   int count=0;\\n\\t\\t\\t\\t   while(target > startValue )\\n\\t\\t\\t\\t   {\\n\\t\\t\\t\\t\\t   if(target%2==1) target++;\\n\\t\\t\\t\\t\\t   else target =  target/2;\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t   }\\n\\t\\t\\t\\treturn count + startValue - target ;",
                "solutionTags": [
                    "C"
                ],
                "code": "\\n\\tint brokenCalc(int startValue, int target) {\\n\\t\\t\\t\\t   int count=0;\\n\\t\\t\\t\\t   while(target > startValue )\\n\\t\\t\\t\\t   {\\n\\t\\t\\t\\t\\t   if(target%2==1) target++;\\n\\t\\t\\t\\t\\t   else target =  target/2;\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t   }\\n\\t\\t\\t\\treturn count + startValue - target ;",
                "codeTag": "Unknown"
            },
            {
                "id": 1876333,
                "title": "3-lines-code-recursion-based-solution-mathematical-approach",
                "content": "```\\nRecursion Solution\\n public int brokenCalc(int startValue, int target) {\\n        if(startValue>=target) return startValue-target;  // base case\\n        if(target %2 == 1) return 1+brokenCalc(startValue,target+1);\\n        return 1+brokenCalc(startValue,target/2);\\n\\t}\\n\\t\\nMathematical Solution\\npublic int brokenCalc(int startValue, int target) {\\n        int count = 0;\\n        if(startValue>target) return startValue-target;\\n        while(startValue<target){\\n            count++;\\n            if(target%2 == 1) target+=1;\\n            else target/=2;\\n        }\\n        if(startValue== target) return count;\\n        \\n        while(startValue>target){\\n            count+= startValue-target;\\n            break;\\n        }\\n        \\n        return count;\\n\\t\\t}\\n\\t\\t",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Recursion"
                ],
                "code": "```\\nRecursion Solution\\n public int brokenCalc(int startValue, int target) {\\n        if(startValue>=target) return startValue-target;  // base case\\n        if(target %2 == 1) return 1+brokenCalc(startValue,target+1);\\n        return 1+brokenCalc(startValue,target/2);\\n\\t}\\n\\t\\nMathematical Solution\\npublic int brokenCalc(int startValue, int target) {\\n        int count = 0;\\n        if(startValue>target) return startValue-target;\\n        while(startValue<target){\\n            count++;\\n            if(target%2 == 1) target+=1;\\n            else target/=2;\\n        }\\n        if(startValue== target) return count;\\n        \\n        while(startValue>target){\\n            count+= startValue-target;\\n            break;\\n        }\\n        \\n        return count;\\n\\t\\t}\\n\\t\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1876274,
                "title": "c-o-log-n-o-1-solution-faster-than-100",
                "content": "class Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int cnt=0;\\n        // bringing the target closest to startValue\\n        while(target>startValue){\\n            if(target%2){\\n                target++; //opposite of subtract operation in startValue\\n                cnt++;\\n            }\\n            else{\\n                target/=2;\\n                cnt++;\\n            }}\\n        return cnt+startValue-target; //when target becomes smaller than startValue, we have to perform (startValue-target) subtract operations.        \\n         }};",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int cnt=0;\\n        // bringing the target closest to startValue\\n        while(target>startValue){\\n            if(target%2){\\n                target++; //opposite of subtract operation in startValue\\n                cnt++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1876228,
                "title": "100-faster-easy-to-understand-hashmap-dp-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        if(target <= startValue ){\\n            return startValue - target;\\n        }\\n        unordered_map<int,int> mp;\\n        int k = startValue;\\n        int steps = 0;\\n        while(startValue < target){\\n            mp[startValue]  = steps;\\n            startValue *=2;\\n            steps++;\\n        }\\n        mp[startValue]  = steps;\\n        int ans = steps + (startValue - target);\\n        steps = 0;\\n        while(target > k ){\\n            if(mp.find(target) != mp.end()){\\n                ans = min(ans , mp[target]  + steps );\\n            }\\n            if(target & 1){\\n                target += 1;\\n            }\\n            else{\\n                target/=2;\\n            }\\n            steps++;\\n        }\\n        \\n        ans = min(ans ,steps + (k - target));\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        if(target <= startValue ){\\n            return startValue - target;\\n        }\\n        unordered_map<int,int> mp;\\n        int k = startValue;\\n        int steps = 0;\\n        while(startValue < target){\\n            mp[startValue]  = steps;\\n            startValue *=2;\\n            steps++;\\n        }\\n        mp[startValue]  = steps;\\n        int ans = steps + (startValue - target);\\n        steps = 0;\\n        while(target > k ){\\n            if(mp.find(target) != mp.end()){\\n                ans = min(ans , mp[target]  + steps );\\n            }\\n            if(target & 1){\\n                target += 1;\\n            }\\n            else{\\n                target/=2;\\n            }\\n            steps++;\\n        }\\n        \\n        ans = min(ans ,steps + (k - target));\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1876081,
                "title": "c-easy-to-understand-daily-leetcoding-challenge-march-day-23",
                "content": "**Please upvote if it helps**\\n\\n* we are going to start from **target to start value** instaed of **startvalue to target**\\n\\n* for our final result we will also **oppose the operations** \\n* if **target == even**, divide it by 2 (**instead of multiplication**)\\n* if t**aget  == odd**, add 1 in it     (**instead of subtraction**)\\n* till our **target gets lesser than the startvalue**\\n* and at the last return **(ans + startValue - target)**\\n\\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) \\n    {\\n        int ans = 0;\\n        \\n        while(startValue < target)\\n        {\\n            // if target is odd\\n            // make it even\\n            if(target % 2 != 0)\\n                target++;\\n            \\n            // else divide it by 2\\n            else\\n                target /= 2;\\n            \\n            ans++;\\n        }\\n        \\n        return ans + startValue - target;\\n    }\\n};\\n```\\n\\nDry Run \\n\\nst = 6, t = 26\\n    \\n    initially, ans = 0;\\n    6<26\\n        t = 26/2 = 13\\n        ans = 0 + 1 = 1\\n        \\n    6<13\\n        t = 13+1 = 14\\n        ans = 1 + 1 = 2\\n        \\n    6<14\\n        t = 14/2 = 7\\n        ans = 2 + 1 = 3\\n        \\n    6<7\\n        t = 7+1 = 8\\n        ans = 3 + 1 = 4\\n        \\n    6<8\\n        t = 8/2 = 4\\n        ans = 4 + 1 = 5\\n        \\n    6<4\\n        break\\n        \\n\\nreturn (5 + 6 - 4)=(7)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) \\n    {\\n        int ans = 0;\\n        \\n        while(startValue < target)\\n        {\\n            // if target is odd\\n            // make it even\\n            if(target % 2 != 0)\\n                target++;\\n            \\n            // else divide it by 2\\n            else\\n                target /= 2;\\n            \\n            ans++;\\n        }\\n        \\n        return ans + startValue - target;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1876045,
                "title": "simple-java-solution-greedy",
                "content": "we will start from target and will try to reach the startValue instead of Multiplication and subtraction we will use division and addition.\\nBase case:If startValue > target the ans will be startValue-target because at that time we have only one option that is subtraction.\\n```\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        if(startValue>target) return startValue-target;\\n        int count=0;\\n        while(startValue!=target){\\n            if(target%2==0 && target>=startValue) target=target/2;\\n            else target++;\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        if(startValue>target) return startValue-target;\\n        int count=0;\\n        while(startValue!=target){\\n            if(target%2==0 && target>=startValue) target=target/2;\\n            else target++;\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875968,
                "title": "991-broken-calculator-0ms-41-1mb-java",
                "content": "```\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        int operation = 0;\\n        while(startValue < target)\\n        {\\n            if(target % 2 == 0)\\n            {\\n                target = target / 2;\\n            }\\n            else{\\n                target = target + 1;\\n            }\\n            operation++;\\n        }\\n        return operation + (startValue - target);\\n    }\\n}\\n```\\nIf my solution helped you please **UPVOTE**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        int operation = 0;\\n        while(startValue < target)\\n        {\\n            if(target % 2 == 0)\\n            {\\n                target = target / 2;\\n            }\\n            else{\\n                target = target + 1;\\n            }\\n            operation++;\\n        }\\n        return operation + (startValue - target);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875955,
                "title": "js",
                "content": "```\\n\\nvar brokenCalc = function(startValue, target) {\\n    \\n    let count = 0;\\n    while(target > startValue){\\n        if(target % 2)\\n            target++;\\n        else\\n          target /= 2;\\n        count++\\n    }\\n    return count + startValue - target;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar brokenCalc = function(startValue, target) {\\n    \\n    let count = 0;\\n    while(target > startValue){\\n        if(target % 2)\\n            target++;\\n        else\\n          target /= 2;\\n        count++\\n    }\\n    return count + startValue - target;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1875899,
                "title": "easiest-c-solution-beginner-friendly-algorithm-backward-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int ans=0;\\n        while (startValue < target) {\\n            if (target%2==0)\\n                target /= 2;\\n            else\\n                target += 1;\\n            ans++;\\n        }\\n        return ans + startValue - target;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int ans=0;\\n        while (startValue < target) {\\n            if (target%2==0)\\n                target /= 2;\\n            else\\n                target += 1;\\n            ans++;\\n        }\\n        return ans + startValue - target;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875826,
                "title": "easy-c-sol-o-log-target-greedy",
                "content": "```\\nclass Solution {   // Time: O(log(target)) :: Aux_Space: O(1);\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        \\n        int res = 0;\\n        \\n        while(target > startValue){\\n            \\n            if(target%2 == 0){\\n                 target = target/2;\\n                res++;\\n            }else{\\n                target++;\\n                res++;\\n            }\\n        }\\n        \\n        return res+startValue-target;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "class Solution {   // Time: O(log(target)) :: Aux_Space: O(1);\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        \\n        int res = 0;\\n        \\n        while(target > startValue){\\n            \\n            if(target%2 == 0){\\n                 target = target/2;\\n                res++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1875812,
                "title": "c-0ms-code-clean-and-simple-solution",
                "content": "TIP : Don\\'t try to change startValue . Instead of that , make target equal to startValue\\nTry solving the problem once again now and then come back and see the code \\n\\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int ans=0;\\n        while(startValue!=target)\\n        {\\n            ans++;\\n            if(target>startValue)\\n            {\\n                if(target%2)  target++;    \\n                else target=target/2;\\n            }\\n            else\\n            {\\n                 ans+=(startValue-target-1); // -1 because we already increased ans by 1 in beginning \\n                target=startValue;   \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int ans=0;\\n        while(startValue!=target)\\n        {\\n            ans++;\\n            if(target>startValue)\\n            {\\n                if(target%2)  target++;    \\n                else target=target/2;\\n            }\\n            else\\n            {\\n                 ans+=(startValue-target-1); // -1 because we already increased ans by 1 in beginning \\n                target=startValue;   \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875791,
                "title": "broken-calculator-recursive-and-iterative-approach",
                "content": "Recursive\\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        if(startValue>=target)\\n            return startValue-target;\\n        if(target%2==0){\\n            return 1+brokenCalc(startValue,target/2);\\n        }\\n        return 1+brokenCalc(startValue,target+1);\\n    }\\n};\\n//Time Complexity: O(log target)\\n//Space Complexity: O(1)\\n```\\nIterative\\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int res=0;\\n        while(target>startValue){\\n            res++;\\n            if(target%2==0){\\n                target/=2;\\n            }else{\\n                target++;\\n            }\\n        }\\n        return res+(startValue-target);\\n    }\\n};\\n//Time Complexity: O(log target)\\n//Space Complexity: O(1)\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        if(startValue>=target)\\n            return startValue-target;\\n        if(target%2==0){\\n            return 1+brokenCalc(startValue,target/2);\\n        }\\n        return 1+brokenCalc(startValue,target+1);\\n    }\\n};\\n//Time Complexity: O(log target)\\n//Space Complexity: O(1)\\n```\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int res=0;\\n        while(target>startValue){\\n            res++;\\n            if(target%2==0){\\n                target/=2;\\n            }else{\\n                target++;\\n            }\\n        }\\n        return res+(startValue-target);\\n    }\\n};\\n//Time Complexity: O(log target)\\n//Space Complexity: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875768,
                "title": "c-easy-understand",
                "content": "```\\n int brokenCalc(int startValue, int target) {\\n        if(startValue >= target)\\n            return startValue - target;\\n        if(target%2==0)\\n            return 1+ brokenCalc(startValue,target/2);\\n        else\\n            return 1+ brokenCalc(startValue,target+1);\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n int brokenCalc(int startValue, int target) {\\n        if(startValue >= target)\\n            return startValue - target;\\n        if(target%2==0)\\n            return 1+ brokenCalc(startValue,target/2);\\n        else\\n            return 1+ brokenCalc(startValue,target+1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1875664,
                "title": "c-o-1-time-and-o-1-space-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        /*\\n        target = multiplySum - minusSum\\n\\t\\t\\n\\t\\tmultiplySum = 2^n * startValue\\n\\t\\t2^(n - 1) < target/startValue <= 2^n\\n        => the count of multiply = n\\n        \\n        minusSum = 2^n * t0 + 2^(n-1) * t1 + .... + 2^0 * tn\\n        ti is the count of minus after i times of multiply\\n        ti = 1 or 0 (i > 0)\\n        t0 >= 0, because the maximum multiplier is n\\n        => count of minus = t0 + (t1 + ... + tn)\\n                    t0 = minusSum / 2^n\\n         t1 + ... + tn = bit1count(minusSum & bitmask)\\n        */\\n        \\n        // Get multiply count\\n        int multCnt = max(ceil(log2((double)target / startValue)), 0.0);\\n        // Get sum of minus\\n        int minusSum = pow(2, multCnt) * startValue - target;\\n        // Get mask for counting 1-bit\\n        int bitmask = (1 << multCnt) - 1;\\n        return multCnt + (minusSum >> multCnt) + __builtin_popcount(minusSum & bitmask);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        /*\\n        target = multiplySum - minusSum\\n\\t\\t\\n\\t\\tmultiplySum = 2^n * startValue\\n\\t\\t2^(n - 1) < target/startValue <= 2^n\\n        => the count of multiply = n\\n        \\n        minusSum = 2^n * t0 + 2^(n-1) * t1 + .... + 2^0 * tn\\n        ti is the count of minus after i times of multiply\\n        ti = 1 or 0 (i > 0)\\n        t0 >= 0, because the maximum multiplier is n\\n        => count of minus = t0 + (t1 + ... + tn)\\n                    t0 = minusSum / 2^n\\n         t1 + ... + tn = bit1count(minusSum & bitmask)\\n        */\\n        \\n        // Get multiply count\\n        int multCnt = max(ceil(log2((double)target / startValue)), 0.0);\\n        // Get sum of minus\\n        int minusSum = pow(2, multCnt) * startValue - target;\\n        // Get mask for counting 1-bit\\n        int bitmask = (1 << multCnt) - 1;\\n        return multCnt + (minusSum >> multCnt) + __builtin_popcount(minusSum & bitmask);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875619,
                "title": "c-easy-solution-0ms-100-faster",
                "content": "Here\\'s what approach I used -\\n* Let\\'s start to reach from target to startValue since it\\'ll also take same steps to reach startValue from target.\\n* The operations will change here. for **startValue = startValue*2 -> target = target/2** and for **startValue = startValue - 1 -> target = target + 1.**\\n* The first case is when starting value is equal to target, then there is no step involved here to change values, so simply return 0.\\n* Then we started our steps from 0 and Performed these operations until our target is greater than startValue -\\n  1. The first case is when my **target value is even**, then one operation can be performed -> **target = target/2** ( so for startValue, it\\'ll be startValue = startValue*2 that is allowed Operation by the calculator.)\\n  2. If **my target is odd**, then we can only perform **target = (target + 1**) operation since doing target = target/2 operation will give us float value that isn\\'t allowed here. ( For the startValue, This operation will be startValue = startValue - 1 )\\n* Now loop will only break in 2 conditons, either my target is less than startValue or target is equal to startValue.\\n* If target is less than startValue, then doing operations target = target/2 isn\\'t going to help. so the only Beneficial operation here is target = target + 1.\\n* We\\'ll do this target = target+1 operation to fill the difference between target and startValue so for **(startValue - target)** times. \\n* In the case when target is equal to startValue, this difference (startValue - target) will be zero.\\n* so we\\'ll simply add these extra steps required to our steps variable.\\n* Now steps variable contains minimum steps needed to reach from startValue to target.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n\\t/* Since startValue = target, no step required to change value */\\n        if(startValue == target) return 0;\\n\\t\\t\\n\\t\\t/* starting value of steps = 0 */\\n        int steps = 0;\\n        while(target>startValue){\\n\\t\\t/* If target value is even, we can only do this operation */\\n            if( target%2==0){\\n                target=target/2;\\n            }\\n\\t\\t\\t/* In case of odd value */\\n            else target+=1;\\n\\t\\t\\t\\n\\t\\t\\t/* steps will increase in both cases */\\n            steps++;\\n        }\\n\\t\\t\\n\\t\\t/* our target might have become less than startValue by target = target/2 operation so add the difference here\\n\\t\\t that shows the number of times we will perform target = target+1 */\\n        steps+=(startValue-target);\\n\\t\\t\\n\\t\\t/* Final minimum steps required */\\n        return steps;\\n    }\\n};\\n```\\n\\nPlease upvote if it helps. Also provide your suggestions to improve the code.",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n\\t/* Since startValue = target, no step required to change value */\\n        if(startValue == target) return 0;\\n\\t\\t\\n\\t\\t/* starting value of steps = 0 */\\n        int steps = 0;\\n        while(target>startValue){\\n\\t\\t/* If target value is even, we can only do this operation */\\n            if( target%2==0){\\n                target=target/2;\\n            }\\n\\t\\t\\t/* In case of odd value */\\n            else target+=1;\\n\\t\\t\\t\\n\\t\\t\\t/* steps will increase in both cases */\\n            steps++;\\n        }\\n\\t\\t\\n\\t\\t/* our target might have become less than startValue by target = target/2 operation so add the difference here\\n\\t\\t that shows the number of times we will perform target = target+1 */\\n        steps+=(startValue-target);\\n\\t\\t\\n\\t\\t/* Final minimum steps required */\\n        return steps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875557,
                "title": "recursive-c-100-fast-greedy",
                "content": "x is initial number, y is target we want to achieve\\n\\n1 step -> x-1 to x\\n         -> 2x to x\\n(x,y) can be (even,odd)  ,(even,even)  ,(odd,odd)  ,(odd,even)\\n\\neg-> x=4  and y=7\\n4->8->7 in 2 step or 7->8->4 in 2 steps\\n\\neg->x=4 and y=8\\n4->8 in 1 steps or 8->4 in 1 steps\\n\\neg-> x=3 to y=11\\n\\n3->6->12->11 or 11->12->6.-> in 3 steps\\neg-> x=3 to y=13\\n\\n3->2->4->8->7->14->13   or 13->14->7->8->4->**2->3**\\n\\nhere 2->3 is the case where we can decrement from 3 to 2 in reality but from backward we are add 1 to gain 3\\nx is bigger than only decrement can happen, x-y is answer\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int x, int y) {\\n        \\n        if(x>=y){\\n            return x-y;     \\n        } \\n\\t\\t\\n        if(y%2) return 1+brokenCalc(x,y+1);   // if i am on odd state we add 1 to make even, \\n        \\n        return 1+brokenCalc(x,y/2);              // if y is even just divide by 2 greedily\\n        \\n        \\n    }\\n};\\n```\\n\\nIF YOU DID\\'T GET ASK ANY LINE ASK IN COMMENT\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int x, int y) {\\n        \\n        if(x>=y){\\n            return x-y;     \\n        } \\n\\t\\t\\n        if(y%2) return 1+brokenCalc(x,y+1);   // if i am on odd state we add 1 to make even, \\n        \\n        return 1+brokenCalc(x,y/2);              // if y is even just divide by 2 greedily\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875554,
                "title": "c-intuition-from-other-s-answer",
                "content": "```\\npublic class Solution \\n{\\n    public int BrokenCalc(int x, int y) \\n    {\\n        int op = 0;\\n        while (y > x) \\n        {\\n            y = y % 2 == 0 ? y / 2 : y + 1;\\n            op++;\\n        }\\n        \\n        //since we are coming from target to source\\n        return op + x - y;\\n    }\\n}\\n\\n/*\\nExplanation with example\\n\\nLet\\'s say we have X = 2 and Y = 9\\nIf we move from X to Y, our approach would be to multiply X while it\\'s less than Y\\n& then decrement it.\\nIt would be something like\\n(2 * 2 * 2 * 2) - 1 - 1 - 1 - 1 - 1 - 1 - 1 which is 3 multiplication and 7 subtraction (Total 10 operations)\\nbut optimal solution would be somthing like\\n(((((2 * 2) - 1) * 2) - 1) * 2) - 1 which is 3 multiplication and 3 subtraction (Total 6 operations)\\n\\nBut for optimal solution, how do decide when to multiply or subtract?\\nLet\\'s try to see the equation:\\nOur optimal solution gives us Y, so it will be something like\\n(((((2 * 2) - 1) * 2) - 1) * 2) - 1 = Y\\n(((((2 * 2) - 1) * 2) - 1) * 2) - 1 = 9\\n(((((2 * 2) - 1) * 2) - 1) * 2) = 9 + 1 = 10\\n((((2 * 2) - 1) * 2) - 1) = 10 / 2 = 5\\n(((2 * 2) - 1) * 2) = 5 + 1 = 6\\n((2 * 2) - 1) = 6 / 2 = 3\\n2 * 2 = 3 + 1 = 4\\n2 = 4 / 2 = 2 (equals X)\\n\\nWhen we see this, we see that for Y, we are adding one when it\\'s odd\\nand dividing by 2 when it\\'s even.\\nthis takes Y close to Y and hence to our answer\\n*/\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public int BrokenCalc(int x, int y) \\n    {\\n        int op = 0;\\n        while (y > x) \\n        {\\n            y = y % 2 == 0 ? y / 2 : y + 1;\\n            op++;\\n        }\\n        \\n        //since we are coming from target to source\\n        return op + x - y;\\n    }\\n}\\n\\n/*\\nExplanation with example\\n\\nLet\\'s say we have X = 2 and Y = 9\\nIf we move from X to Y, our approach would be to multiply X while it\\'s less than Y\\n& then decrement it.\\nIt would be something like\\n(2 * 2 * 2 * 2) - 1 - 1 - 1 - 1 - 1 - 1 - 1 which is 3 multiplication and 7 subtraction (Total 10 operations)\\nbut optimal solution would be somthing like\\n(((((2 * 2) - 1) * 2) - 1) * 2) - 1 which is 3 multiplication and 3 subtraction (Total 6 operations)\\n\\nBut for optimal solution, how do decide when to multiply or subtract?\\nLet\\'s try to see the equation:\\nOur optimal solution gives us Y, so it will be something like\\n(((((2 * 2) - 1) * 2) - 1) * 2) - 1 = Y\\n(((((2 * 2) - 1) * 2) - 1) * 2) - 1 = 9\\n(((((2 * 2) - 1) * 2) - 1) * 2) = 9 + 1 = 10\\n((((2 * 2) - 1) * 2) - 1) = 10 / 2 = 5\\n(((2 * 2) - 1) * 2) = 5 + 1 = 6\\n((2 * 2) - 1) = 6 / 2 = 3\\n2 * 2 = 3 + 1 = 4\\n2 = 4 / 2 = 2 (equals X)\\n\\nWhen we see this, we see that for Y, we are adding one when it\\'s odd\\nand dividing by 2 when it\\'s even.\\nthis takes Y close to Y and hence to our answer\\n*/\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875544,
                "title": "c-sort-ans-simply-to-understand",
                "content": "class Solution {\\npublic:\\n    int brokenCalc(int start, int target) {\\n        \\n        /*\\n            our approach is that Rather than updating startval to reach target ,,we update target to reach start\\n            \\n            \\n        */\\n        \\n        if(start==target)return 0;//base case\\n        \\n        if(start>target)\\n        {\\n          return  start-target;\\n        }\\n        else if(target%2==0)\\n        {\\n           return  1+brokenCalc(start,target/2);\\n        }\\n        else\\n        {\\n            return 1+brokenCalc(start,target+1);\\n        }\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int brokenCalc(int start, int target) {\\n        \\n        /*\\n            our approach is that Rather than updating startval to reach target ,,we update target to reach start\\n            \\n            \\n        */\\n        \\n        if(start==target)return 0;//base case\\n        \\n        if(start>target)\\n        {\\n          return  start-target;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1875517,
                "title": "c-java-greedy-o-logn-time-o-1-space-change-target-to-startvalue",
                "content": "**C++ Code -**\\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int ans = 0;\\n        while(startValue < target){\\n            if(target%2!=0) target += 1;\\n            else target = target >> 1;  \\n            ans++;\\n        }\\n        return ans + (startValue - target);\\n    }\\n};\\n```\\n**Java Code -**\\n```\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        int ans = 0;\\n        while(startValue < target){\\n            if(target%2!=0) target += 1;\\n            else target = target >> 1;  \\n            ans++;\\n        }\\n        return ans + (startValue - target);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int ans = 0;\\n        while(startValue < target){\\n            if(target%2!=0) target += 1;\\n            else target = target >> 1;  \\n            ans++;\\n        }\\n        return ans + (startValue - target);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        int ans = 0;\\n        while(startValue < target){\\n            if(target%2!=0) target += 1;\\n            else target = target >> 1;  \\n            ans++;\\n        }\\n        return ans + (startValue - target);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875437,
                "title": "0ms-3-line-solution-recursion-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int start, int target) \\n    {\\n        if(start>=target) return start-target;\\n        \\n        if(target%2==0) return 1+brokenCalc(start, target/2);\\n\\t\\t\\n        return 1+brokenCalc(start, target+1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int start, int target) \\n    {\\n        if(start>=target) return start-target;\\n        \\n        if(target%2==0) return 1+brokenCalc(start, target/2);\\n\\t\\t\\n        return 1+brokenCalc(start, target+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875420,
                "title": "c-0ms-runtime-easy-solution",
                "content": "class Solution {\\npublic:\\n\\n    int brokenCalc(int startValue, int target) {\\n        int count=0;\\n        while(target>startValue)\\n        {\\n            count++;\\n            if(target%2==0)\\n                target/=2;\\n            else\\n                target++;\\n        }\\n        return count+(startValue-target);\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    int brokenCalc(int startValue, int target) {\\n        int count=0;\\n        while(target>startValue)\\n        {\\n            count++;\\n            if(target%2==0)\\n                target/=2;\\n            else\\n                target++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1875403,
                "title": "c-short-and-simple-solution-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int brokenCalc(int x, int y) {\\n        \\n        if(x >= y)\\n            return x - y;\\n        \\n        int ans = 0;\\n        \\n        while(y > x){\\n            \\n            if(y % 2 == 0)\\n                y = y / 2;\\n            \\n            else\\n                y++;\\n            \\n            ans++;\\n        }\\n        \\n        ans += x - y;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int brokenCalc(int x, int y) {\\n        \\n        if(x >= y)\\n            return x - y;\\n        \\n        int ans = 0;\\n        \\n        while(y > x){\\n            \\n            if(y % 2 == 0)\\n                y = y / 2;\\n            \\n            else\\n                y++;\\n            \\n            ans++;\\n        }\\n        \\n        ans += x - y;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875399,
                "title": "java-100-faster-0ms",
                "content": "```\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        \\n\\t\\t//edge case\\n        if(startValue >= target){\\n            return startValue - target;\\n        }\\n        \\n        int count = 0;\\n        \\n        while( startValue < target){\\n            if(target % 2 == 0){\\n                target /= 2;\\n            }else{\\n                target += 1;\\n            }\\n            \\n            count++;\\n        }\\n        \\n        if(startValue > target){\\n            count += Math.abs(startValue - target);\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        \\n\\t\\t//edge case\\n        if(startValue >= target){\\n            return startValue - target;\\n        }\\n        \\n        int count = 0;\\n        \\n        while( startValue < target){\\n            if(target % 2 == 0){\\n                target /= 2;\\n            }else{\\n                target += 1;\\n            }\\n            \\n            count++;\\n        }\\n        \\n        if(startValue > target){\\n            count += Math.abs(startValue - target);\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875344,
                "title": "c-0-ms-faster-than-100-00-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int ans=0;\\n        while(target>startValue){\\n            ans++;\\n            if(target%2==0){\\n                target/=2;\\n            }\\n            else\\n                target++;\\n        }\\n        return ans+(startValue-target);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int ans=0;\\n        while(target>startValue){\\n            ans++;\\n            if(target%2==0){\\n                target/=2;\\n            }\\n            else\\n                target++;\\n        }\\n        return ans+(startValue-target);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875269,
                "title": "broken-calculator-c-100-o-n-greedy-solution-with-explanation-easy-simple-solution",
                "content": "Try to think Greedily in Opposite Direction i.e start from target Value to reach upto Start Value.\\n\\ni) if targetValue is greater than startValue divide target value by 2 ( as we can multiply start value by 2)\\nif it is not completely divisible then add 1 after division.\\n\\nii) if targetValue is less than startValue add 1 in target Value upto which it reaches to start value ( since we can substract 1 each time from start Value).\\n          \\nPlease Upvote if this is helpful\\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int temp=target;\\n        int count=0;\\n        while(temp>startValue){\\n           \\n               if(temp%2==0){\\n                   temp/=2;\\n                   count++;\\n               }else{\\n                   temp=temp/2 + 1;\\n                   count+=2;\\n               }\\n          \\n        }\\n        if(temp<startValue){\\n            count+=startValue-temp;\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\nPlease Go through my Other Solutions ans Upvote if it is Helpful  :\\nhttps://leetcode.com/problems/partition-labels/discuss/1868704/partition-labels-on-solution-c-greedy-simple-solution\\nhttps://leetcode.com/problems/power-of-four/discuss/1799832/power-of-four-c100bit-manipualtion-easy-solution\\nhttps://leetcode.com/problems/partition-labels/discuss/1868704/partition-labels-on-solution-c-greedy-simple-solution\\nhttps://leetcode.com/problems/binary-tree-level-order-traversal/discuss/1862025/binary-tree-level-order-traversal-queue-binary-tree-easy-solution\\nhttps://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/discuss/1850726/minimum-remove-to-make-valid-parentheses-c-on-simple-logic-easy-solution\\nhttps://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/discuss/1849453/maximum-number-of-vowels-in-a-substring-of-given-length-csliding-window\\nhttps://leetcode.com/problems/reverse-prefix-of-word/discuss/1840375/reverse-prefix-of-word-100-c\\nhttps://leetcode.com/problems/find-n-unique-integers-sum-up-to-zero/discuss/1826246/find-n-unique-integers-sum-up-to-zero-100-simple-solution\\nhttps://leetcode.com/problems/find-minimum-in-rotated-sorted-array/discuss/1814346/find-minimum-in-rotated-sorted-array-binary-search-100-ceasy-solution\\nhttps://leetcode.com/problems/is-subsequence/discuss/1811098/is-subsequence-100-c-easy-solution\\nhttps://leetcode.com/problems/search-in-rotated-sorted-array/discuss/1808021/search-in-rotated-sorted-array-ologn-solution-simple-solution-binary-search\\nhttps://leetcode.com/problems/check-if-number-is-a-sum-of-powers-of-three/discuss/1799853/check-if-number-is-a-sum-of-powers-of-three-100-easy-solution\\nhttps://leetcode.com/problems/sequential-digits/discuss/1751815/sequential-digits-c-100-easy-solution\\nhttps://leetcode.com/problems/binary-gap/discuss/1749101/binary-gap-100-c-simple-solution\\nhttps://leetcode.com/problems/kth-largest-element-in-an-array/discuss/1730888/kth-largest-element-in-an-array-c-sorting-simple-solution\\nhttps://leetcode.com/problems/queries-on-number-of-points-inside-a-circle/discuss/1726527/queries-on-number-of-points-inside-a-circle-c-simple-mathematics\\nhttps://leetcode.com/problems/integer-to-roman/discuss/1726042/integer-to-roman-c-easy-to-understand\\nhttps://leetcode.com/problems/rings-and-rods/discuss/1724149/rings-and-rods-100-c-using-hashmap\\nhttps://leetcode.com/problems/number-complement/discuss/1722669/number-compliment\\nhttps://leetcode.com/problems/find-the-duplicate-number/discuss/1809351/find-the-duplicate-number-o1-space-binary-search-easy-solution\\nhttps://leetcode.com/problems/smallest-string-with-a-given-numeric-value/discuss/1872424/Smallest-String-With-A-Given-Numeric-Value-oror-C%2B%2B-O(n)-oror-Simple-Solution-with-Explaination",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int temp=target;\\n        int count=0;\\n        while(temp>startValue){\\n           \\n               if(temp%2==0){\\n                   temp/=2;\\n                   count++;\\n               }else{\\n                   temp=temp/2 + 1;\\n                   count+=2;\\n               }\\n          \\n        }\\n        if(temp<startValue){\\n            count+=startValue-temp;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875251,
                "title": "easy-greedy-o-log-target-0ms",
                "content": "Easy greedy \\n```\\n    int brokenCalc(int start, int target) {\\n        int c=0;\\n        while(start!=target){\\n            if(target>start){\\n            if(target%2==0){\\n                target/=2;\\n            }else\\n                target++;\\n            }\\n            else\\n                break;\\n            c++;\\n        }\\n        c+=(start-target);\\n        return c;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\n    int brokenCalc(int start, int target) {\\n        int c=0;\\n        while(start!=target){\\n            if(target>start){\\n            if(target%2==0){\\n                target/=2;\\n            }else\\n                target++;\\n            }\\n            else\\n                break;\\n            c++;\\n        }\\n        c+=(start-target);\\n        return c;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1875239,
                "title": "java-100-faster-code",
                "content": "\\'\\'\\'\\n\\n\\nclass Solution {\\npublic int brokenCalc(int startValue, int target) {\\n    if(target < startValue)\\n    {\\n        return startValue - target;\\n    }\\n    \\n    int ops = 0;\\n    while(target > startValue)\\n    {\\n        if(target%2 == 1)\\n        {\\n            target += 1;\\n            ops++;\\n        }\\n        \\n        target = target/2;\\n        ops++;\\n    }\\n    \\n    ops += (startValue-target);\\n    return ops;\\n}\\n}",
                "solutionTags": [],
                "code": "class Solution {\\npublic int brokenCalc(int startValue, int target) {\\n    if(target < startValue)\\n    {\\n        return startValue - target;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1875234,
                "title": "c-100-fast-with-explanation",
                "content": "**Approach :**\\n\\n\\t\\t\\t1.we will go in reverse manner so, think how to go from  target --> start\\n\\t\\t\\t2.  we can do two operation to reach startValue\\n\\t\\t\\t\\t1.   target ++  if target is odd \\n\\t\\t\\t\\t2.   target/=2   if target is even\\n\\t\\t\\t\\t3.   increase the cnt\\n\\t\\t    3. we will do step 2 until target > startValue\\t\\n\\t\\t    4. add startValue- target to cnt and return it\\t\\n\\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        \\n        int cnt=0;\\n        while(target>startValue){\\n            if(target%2)\\n              target++;\\n            else\\n               target/=2;\\n            cnt++;\\n        }\\n        return cnt+startValue-target;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        \\n        int cnt=0;\\n        while(target>startValue){\\n            if(target%2)\\n              target++;\\n            else\\n               target/=2;\\n            cnt++;\\n        }\\n        return cnt+startValue-target;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875164,
                "title": "simple-c-ggreedy-solution-100-faster",
                "content": "time and space - O(log(y/x)) and O(1)\\n\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n\\t\\n        int x= startValue;\\n        int y = target;\\n        \\n        int cnt =0;\\n        \\n        // instead of going from x to y, we r going from y to x\\n        // so our new operations become:\\n        // 1. divide y by 2 (ofc it has to be even , so add +1 to make it even ist )\\n        // 2. add +1 to y\\n        while( x<y){\\n            \\n            // if y is odd, make it even ist\\n            if( y%2)\\n                y++;\\n            \\n            // if its even, keep on dividing by 2, unless y becomes less than x\\n            else\\n                y/=2;\\n            \\n            cnt++;\\n\\n        }\\n        // y goes below x, so the only option left is to keep on addiing 1 to y\\n        // until we reach x\\n        cnt+= (x-y);\\n        \\n        return cnt;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n\\t\\n        int x= startValue;\\n        int y = target;\\n        \\n        int cnt =0;\\n        \\n        // instead of going from x to y, we r going from y to x\\n        // so our new operations become:\\n        // 1. divide y by 2 (ofc it has to be even , so add +1 to make it even ist )\\n        // 2. add +1 to y\\n        while( x<y){\\n            \\n            // if y is odd, make it even ist\\n            if( y%2)\\n                y++;\\n            \\n            // if its even, keep on dividing by 2, unless y becomes less than x\\n            else\\n                y/=2;\\n            \\n            cnt++;\\n\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1875147,
                "title": "c-recursion-easy-simple-algorithms-reverse",
                "content": "Approach: If you try to convert target to startValue then this problem is looks very easy recursion solution.\\n\\nStep 1: if target is odd then we have to add substract cost along with division cost.\\nStep 2: Base case when target is less than startValue then simply add the difference in the ans.\\n\\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {        \\n        //Base case\\n        if(startValue>=target)\\n            return startValue - target;        \\n\\t\\t\\t\\n\\t\\t// division cost\\n        int ans = 1;\\n\\t\\t\\n        if(target%2!=0) {\\n            target++;\\n\\t\\t\\t// subtraction cost\\n            ans++;\\n        }                    \\n\\t\\t\\n        ans += brokenCalc(startValue,target/2);        \\n        return ans;\\n    }\\n};\\n```\\n\\nOptimized Code:\\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {        \\n        \\n        if(startValue >= target)\\n            return startValue - target;        \\n\\t\\t\\t\\n        if(target%2 != 0)\\n            return 2 + brokenCalc(startValue, (target+1)/2);        \\n\\t\\t       \\n        return 1 + brokenCalc(startValue, target/2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {        \\n        //Base case\\n        if(startValue>=target)\\n            return startValue - target;        \\n\\t\\t\\t\\n\\t\\t// division cost\\n        int ans = 1;\\n\\t\\t\\n        if(target%2!=0) {\\n            target++;\\n\\t\\t\\t// subtraction cost\\n            ans++;\\n        }                    \\n\\t\\t\\n        ans += brokenCalc(startValue,target/2);        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {        \\n        \\n        if(startValue >= target)\\n            return startValue - target;        \\n\\t\\t\\t\\n        if(target%2 != 0)\\n            return 2 + brokenCalc(startValue, (target+1)/2);        \\n\\t\\t       \\n        return 1 + brokenCalc(startValue, target/2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875115,
                "title": "simple-iterative-java-solution",
                "content": "\\n\\nclass Solution {\\n\\n    public int brokenCalc(int startValue, int target) {\\n        int ans = 0;\\n        while(target > startValue){\\n            if(target % 2 == 0) target /= 2;\\n            else  target++; \\n            ans++;\\n        } return ans + (startValue - target);\\n}\\n\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public int brokenCalc(int startValue, int target) {\\n        int ans = 0;\\n        while(target > startValue){\\n            if(target % 2 == 0) target /= 2;\\n            else  target++; \\n            ans++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1875066,
                "title": "clean-and-documented-greedy-solution",
                "content": "```\\nclass Solution:\\n    def brokenCalc(self, X: int, Y: int) -> int:\\n        \"\"\"\\n        We have gotten a \"finite\" path S: X -> X[1] -> X[2] -> ... X[n] -> Y and assume X < Y.\\n\\n        Statement: if Y is even then last operation to reach Y must be of multiplication.\\n        Proof: Suppose that is not the case.\\n               Then X[n] = Y + 1.\\n\\n               Now X[n] is odd, so the last operation to reach X[n] can not be multiplication\\n               by 2, it has to be a subtraction by 1.\\n\\n               Now X[n-1] is even. Also that X[n-1] = Y + 2. Applying the statement that\\n               last operation must be of subtraction if number to reach is even, we find\\n               that we are moving away and away from Y.\\n\\n               Hence the length of path S can not be finite. And this is a contraction.\\n\\n               Hence we conclude that last operation must be of multiplication by 2 if\\n               Y is even.\\n        Done\\n\\n        Also note that if Y is odd then last operation can not be of multiplication by 2,\\n        which mean last operation must be of type subtraction.\\n\\n        In the following implementation, we trace back from Y to X, so operation of multiplication\\n        becomes that of division and operation of subtraction becomes that of addition.\\n\\n        Also @see https://leetcode.com/problems/broken-calculator/discuss/234484/JavaC%2B%2BPython-Change-Y-to-X-in-1-Line\\n        :param X:\\n        :param Y:\\n        :return:\\n        \"\"\"\\n        output = 0\\n\\n        while X < Y:\\n            if Y % 2 == 0:\\n                Y //= 2\\n            else:\\n                Y += 1\\n\\n            output += 1\\n\\n        return output + (X - Y)\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def brokenCalc(self, X: int, Y: int) -> int:\\n        \"\"\"\\n        We have gotten a \"finite\" path S: X -> X[1] -> X[2] -> ... X[n] -> Y and assume X < Y.\\n\\n        Statement: if Y is even then last operation to reach Y must be of multiplication.\\n        Proof: Suppose that is not the case.\\n               Then X[n] = Y + 1.\\n\\n               Now X[n] is odd, so the last operation to reach X[n] can not be multiplication\\n               by 2, it has to be a subtraction by 1.\\n\\n               Now X[n-1] is even. Also that X[n-1] = Y + 2. Applying the statement that\\n               last operation must be of subtraction if number to reach is even, we find\\n               that we are moving away and away from Y.\\n\\n               Hence the length of path S can not be finite. And this is a contraction.\\n\\n               Hence we conclude that last operation must be of multiplication by 2 if\\n               Y is even.\\n        Done\\n\\n        Also note that if Y is odd then last operation can not be of multiplication by 2,\\n        which mean last operation must be of type subtraction.\\n\\n        In the following implementation, we trace back from Y to X, so operation of multiplication\\n        becomes that of division and operation of subtraction becomes that of addition.\\n\\n        Also @see https://leetcode.com/problems/broken-calculator/discuss/234484/JavaC%2B%2BPython-Change-Y-to-X-in-1-Line\\n        :param X:\\n        :param Y:\\n        :return:\\n        \"\"\"\\n        output = 0\\n\\n        while X < Y:\\n            if Y % 2 == 0:\\n                Y //= 2\\n            else:\\n                Y += 1\\n\\n            output += 1\\n\\n        return output + (X - Y)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1874974,
                "title": "c-100-faster-iterative-approach-easy-to-understand-o-log-n",
                "content": "**// Please upvote if it is helpful**\\n\\n*Time complexity: O(log n)\\nSpace complexity: O(1)*\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int result =0;\\n        while(target> startValue){\\n            result++;\\n            if(target%2 ==0 ){\\n                target/=2;\\n            }\\n            else{\\n                target++;\\n            }\\n        }\\n        return result+(startValue - target);\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int result =0;\\n        while(target> startValue){\\n            result++;\\n            if(target%2 ==0 ){\\n                target/=2;\\n            }\\n            else{\\n                target++;\\n            }\\n        }\\n        return result+(startValue - target);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1874944,
                "title": "will-a-heuristic-search-algorithm-solve-the-problem",
                "content": "BFS gives a TLE here. What about some heuristic search algorithms, such as A star?\\n\\nMy python code that implements A star.\\nMemory limit exceeded on the case 5/84\\uFF0C where the input is (1, 1000000000)\\n\\n```python\\nclass Solution:\\n    def heuristic(self, start, end):\\n        if start > end:\\n            return start - end\\n        else:\\n            steps = 0\\n            while start <= end:\\n                start *= 2\\n                steps += 1\\n            steps += (start - end)\\n            return steps\\n        \\n    def neighbor(self, start):\\n        return [start * 2, start - 1]\\n    \\n    def brokenCalc(self, startValue: int, target: int) -> int:\\n        # A* finds a path from start to goal.\\n        # h is the heuristic function. h(n) estimates the cost to reach goal from node n.\\n\\n        # The set of discovered nodes that may need to be (re-)expanded.\\n        # Initially, only the start node is known.\\n        # This is usually implemented as a min-heap or priority queue rather than a hash-set.\\n        start = startValue\\n        openSetNodes = set([start])\\n        openSet = [(0, start)] \\n        heapq.heapify(openSet)\\n            \\n        # For node n, cameFrom[n] is the node immediately preceding it on the cheapest path from start to n currently known.\\n        cameFrom = {}\\n        # For node n, gScore[n] is the cost of the cheapest path from start to n currently known.\\n        gScore  = {start: 0}\\n        # For node n, fScore[n] := gScore[n] + h(n). fScore[n] represents our current best guess as to how short a path from start to finish can be if it goes through n.\\n        fScore = {start: 0}\\n        while openSet:\\n        # This operation can occur in O(Log(N)) time if openSet is a min-heap or a priority queue\\n            # print(openSet)\\n            fscore,  current = heapq.heappop(openSet)\\n            openSetNodes.remove(current)\\n            if current == target:\\n                count = 0\\n                while current != start:\\n                    count += 1\\n                    current = cameFrom[current]\\n                return count\\n\\n            for neighbor in self.neighbor(current):\\n                # d(current,neighbor) is the weight of the edge from current to neighbor\\n                # tentative_gScore is the distance from start to the neighbor through current\\n                if neighbor <= 0:\\n                    continue\\n                tentative_gScore = gScore.get(current, 1000000000) + 1\\n                if tentative_gScore < gScore.get(neighbor, 1000000000):\\n                    # This path to neighbor is better than any previous one. Record it!\\n                    cameFrom[neighbor] = current\\n                    gScore[neighbor] = tentative_gScore\\n                    fScore[neighbor] = tentative_gScore + self.heuristic(neighbor, target)\\n                    if neighbor not in openSetNodes:\\n                        openSetNodes.add(neighbor)\\n                        heapq.heappush(openSet, (fScore[neighbor], neighbor))\\n```\\n\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def heuristic(self, start, end):\\n        if start > end:\\n            return start - end\\n        else:\\n            steps = 0\\n            while start <= end:\\n                start *= 2\\n                steps += 1\\n            steps += (start - end)\\n            return steps\\n        \\n    def neighbor(self, start):\\n        return [start * 2, start - 1]\\n    \\n    def brokenCalc(self, startValue: int, target: int) -> int:\\n        # A* finds a path from start to goal.\\n        # h is the heuristic function. h(n) estimates the cost to reach goal from node n.\\n\\n        # The set of discovered nodes that may need to be (re-)expanded.\\n        # Initially, only the start node is known.\\n        # This is usually implemented as a min-heap or priority queue rather than a hash-set.\\n        start = startValue\\n        openSetNodes = set([start])\\n        openSet = [(0, start)] \\n        heapq.heapify(openSet)\\n            \\n        # For node n, cameFrom[n] is the node immediately preceding it on the cheapest path from start to n currently known.\\n        cameFrom = {}\\n        # For node n, gScore[n] is the cost of the cheapest path from start to n currently known.\\n        gScore  = {start: 0}\\n        # For node n, fScore[n] := gScore[n] + h(n). fScore[n] represents our current best guess as to how short a path from start to finish can be if it goes through n.\\n        fScore = {start: 0}\\n        while openSet:\\n        # This operation can occur in O(Log(N)) time if openSet is a min-heap or a priority queue\\n            # print(openSet)\\n            fscore,  current = heapq.heappop(openSet)\\n            openSetNodes.remove(current)\\n            if current == target:\\n                count = 0\\n                while current != start:\\n                    count += 1\\n                    current = cameFrom[current]\\n                return count\\n\\n            for neighbor in self.neighbor(current):\\n                # d(current,neighbor) is the weight of the edge from current to neighbor\\n                # tentative_gScore is the distance from start to the neighbor through current\\n                if neighbor <= 0:\\n                    continue\\n                tentative_gScore = gScore.get(current, 1000000000) + 1\\n                if tentative_gScore < gScore.get(neighbor, 1000000000):\\n                    # This path to neighbor is better than any previous one. Record it!\\n                    cameFrom[neighbor] = current\\n                    gScore[neighbor] = tentative_gScore\\n                    fScore[neighbor] = tentative_gScore + self.heuristic(neighbor, target)\\n                    if neighbor not in openSetNodes:\\n                        openSetNodes.add(neighbor)\\n                        heapq.heappush(openSet, (fScore[neighbor], neighbor))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1874924,
                "title": "python-recursion-thinking-backwards",
                "content": "```\\nclass Solution:\\n    def brokenCalc(self, startValue: int, target: int) -> int:\\n        if target<=startValue:\\n            return (startValue-target)\\n        elif target%2==1:\\n            return 1+Solution.brokenCalc(self,startValue,target+1)\\n        else:\\n            return 1+Solution.brokenCalc(self,startValue,target//2)\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def brokenCalc(self, startValue: int, target: int) -> int:\\n        if target<=startValue:\\n            return (startValue-target)\\n        elif target%2==1:\\n            return 1+Solution.brokenCalc(self,startValue,target+1)\\n        else:\\n            return 1+Solution.brokenCalc(self,startValue,target//2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1874899,
                "title": "java-simple-and-efficient",
                "content": "The idea is  to reach from \"target\" to \"startValue\" instead of the opposite (Which is most of us try on the first think)\\n```\\n\\t\\tint counter = 0;\\n        while (startValue<target){\\n            if (target%2 == 0){\\n                target = target /2;\\n            }else {\\n                target = target + 1;\\n            }\\n            counter++;\\n        }\\n\\n        counter += startValue - target;\\n        return counter;\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\t\\tint counter = 0;\\n        while (startValue<target){\\n            if (target%2 == 0){\\n                target = target /2;\\n            }else {\\n                target = target + 1;\\n            }\\n            counter++;\\n        }\\n\\n        counter += startValue - target;\\n        return counter;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1874823,
                "title": "easy-java-solution-target-to-startvalue",
                "content": "class Solution {\\n    public int brokenCalc(int startValue, int target) {\\n     \\n       int result = 0;\\n\\n        while(startValue != target) {\\n            if (startValue > target) {\\n                result += startValue - target;\\n                break;\\n            }\\n            if(target % 2 == 1) {\\n                target++;\\n            }else{\\n                target = target / 2;\\n            }\\n            result++;\\n        }\\n\\n        return result;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int brokenCalc(int startValue, int target) {\\n     \\n       int result = 0;\\n\\n        while(startValue != target) {\\n            if (startValue > target) {\\n                result += startValue - target;\\n                break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1874789,
                "title": "c-java-solution-o-n-time-and-o-1-space",
                "content": "The intuition is to make the target equal to the startValue.\\n1. If target is even we divide it by 2\\n2. If target is odd we add 1 to it\\n\\nTry to dry run with some cases it will become clear.\\n\\n**C++:**\\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int ans = 0;\\n        while (startValue < target) {\\n            ++ans;\\n            if (target & 1) ++target;\\n            else target /= 2;\\n        }\\n        return ans + startValue - target;\\n    }\\n};\\n```\\n\\n**Java:**\\n```\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        int ans = 0;\\n        while (startValue < target) {\\n            ++ans;\\n            if ((target & 1) == 1) ++target;\\n            else target /= 2;\\n        }\\n        return ans + startValue - target;\\n    }\\n}\\n```\\n\\n**Time complexity:** O(N)\\n**Space complexity:** O(1)",
                "solutionTags": [
                    "Java",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int ans = 0;\\n        while (startValue < target) {\\n            ++ans;\\n            if (target & 1) ++target;\\n            else target /= 2;\\n        }\\n        return ans + startValue - target;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        int ans = 0;\\n        while (startValue < target) {\\n            ++ans;\\n            if ((target & 1) == 1) ++target;\\n            else target /= 2;\\n        }\\n        return ans + startValue - target;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1399699,
                "title": "simple-java-solution",
                "content": "class Solution {\\n\\n    public int brokenCalc(int s, int t) {\\n        int c=0;\\n        while(t>s)\\n        {\\n            c++;\\n            if(t%2==0)\\n                t/=2;\\n            else\\n                t++;\\n        }\\n        return c+(s-t);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int brokenCalc(int s, int t) {\\n        int c=0;\\n        while(t>s)\\n        {\\n            c++;\\n            if(t%2==0)\\n                t/=2;\\n            else\\n                t++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1355780,
                "title": "kotlin",
                "content": "Keep dividing y until you get to an odd number or a value less than or equal to x. Since if after doubling you\\'d be off by more than 2, it\\'s always better to decrement before doubling (i.e. `4->8->7->6` is worse than `4->3->6`) we\\'ll continue halving until we\\'re at or below the starting value, then we\\'d decrement to get there.\\n\\nWalking through, let\\'s say your starting x is 6 and y is 100, here are the loop steps.\\n\\n0) 100 -> too big, divisible by 2\\n1) 50 -> too big, divisible by 2\\n2) 25 -> too big, but not divisible by 2. We can only be off by 1 since otherwise you\\'d decrement before doubling.\\n3) 26 -> too big, divisible by 2\\n4) 13 -> too big, not divisible, add 1\\n5) 14 -> too big, divisible\\n6) 7 -> too big, not divisible, add 1\\n7) 8 -> too big, divisible\\n8) 4 -> too small\\n\\nSince we start with 6 and need to get to 4 to get into the sequence, we return those 8 steps plus the difference 6 - 4 = 2. So 10 total steps.\\n\\n```\\nclass Solution {\\n    fun brokenCalc(x: Int, y: Int): Int {\\n        var steps = 0\\n        var target = y\\n        while (target > x) {\\n            if (target % 2 == 0)\\n                target /= 2\\n            else\\n                target++\\n            steps++\\n        }\\n\\n        return steps + (x - target)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun brokenCalc(x: Int, y: Int): Int {\\n        var steps = 0\\n        var target = y\\n        while (target > x) {\\n            if (target % 2 == 0)\\n                target /= 2\\n            else\\n                target++\\n            steps++\\n        }\\n\\n        return steps + (x - target)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206172,
                "title": "java-easy-solution-with-explanation",
                "content": "# Basic Idea\\n\\n1. I am Y, and I want to become X.\\n    - Question arises why not start from X and go to Y? Well,  if you start from X, you can\\'t say for sure that is X*2 more optimal or X-1 will give a better solution. Why so? Because there is no criteria for you to judge.  This will become more clear, when you read below.\\n\\n2. If I am divisible by 2, I can simply reduce myself to half my number in one step.\\n    - Question arises why did I not increment myself by 1, how is dividing by 2  an optimal step? Well, listen. I want to reach X in the least possible steps,\\n\\n        My Goal : Y \\u2192 X \\n\\n        Case 1 : Y \\u2192 Y/2 \\u2014\\u2014\\u2014\\u2014\\u2192 X . Say steps taken are C_1\\n        Case 2 : Y \\u2192 Y+1 \\u2192 Y+1 \\u2192 Y/2 \\u2014\\u2014\\u2192 X. Steps taken will be C_1 + 2\\n        { If a number is  not divisible by  2 you can\\'t divide it by 2, that is against the rules of the question | \\n\\n        *To sum up every time you increment by 1, you will take 2 more steps to reach X. So Y/2 is surely the optimal solution.*\\n\\n3. If I am not divisible by 2, the only option I have is to increment myself by 1.\\n\\n\\n![image](https://assets.leetcode.com/users/images/ba17bfa7-3e89-4fbe-8609-de837464eea1_1620905451.088948.png)\\n\\n# Code\\n\\n\\tpublic int brokenCalc(int X, int Y) {\\n        int res = 0;\\n        while (Y > X) {\\n            Y = Y % 2 == 0 ? Y/2 : Y+1;\\n            res++;\\n        }\\n        return res + X - Y;\\n    }\\n",
                "solutionTags": [],
                "code": "# Basic Idea\\n\\n1. I am Y, and I want to become X.\\n    - Question arises why not start from X and go to Y? Well,  if you start from X, you can\\'t say for sure that is X*2 more optimal or X-1 will give a better solution. Why so? Because there is no criteria for you to judge.  This will become more clear, when you read below.\\n\\n2. If I am divisible by 2, I can simply reduce myself to half my number in one step.\\n    - Question arises why did I not increment myself by 1, how is dividing by 2  an optimal step? Well, listen. I want to reach X in the least possible steps,\\n\\n        My Goal : Y \\u2192 X \\n\\n        Case 1 : Y \\u2192 Y/2 \\u2014\\u2014\\u2014\\u2014\\u2192 X . Say steps taken are C_1\\n        Case 2 : Y \\u2192 Y+1 \\u2192 Y+1 \\u2192 Y/2 \\u2014\\u2014\\u2192 X. Steps taken will be C_1 + 2\\n        { If a number is  not divisible by  2 you can\\'t divide it by 2, that is against the rules of the question | \\n\\n        *To sum up every time you increment by 1, you will take 2 more steps to reach X. So Y/2 is surely the optimal solution.*\\n\\n3. If I am not divisible by 2, the only option I have is to increment myself by 1.\\n\\n\\n![image](https://assets.leetcode.com/users/images/ba17bfa7-3e89-4fbe-8609-de837464eea1_1620905451.088948.png)\\n\\n# Code\\n\\n\\tpublic int brokenCalc(int X, int Y) {\\n        int res = 0;\\n        while (Y > X) {\\n            Y = Y % 2 == 0 ? Y/2 : Y+1;\\n            res++;\\n        }\\n        return res + X - Y;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1122770,
                "title": "c-short-recursion-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int X, int Y) {\\n        // There are 3 scenarios:\\n        // 1) if X >= Y, we can only subtract 1 from X to get Y, so the result == X - Y.\\n        // 2) if X < Y && Y is odd, we need to reach Y + 1 first and then subtract 1 to get Y,\\n        //    so the result will be brokenCalc(X, Y + 1) + 1 (recursion).\\n        // 3) if X < Y && Y is even, we need to reach Y / 2 first and then multiply 2 to get Y,\\n        //    so the result is brokenCalc(X, Y / 2) + 1. \\n        // To prove our conclusion in 3), assume X >= Y / 2, to get Y we either multiple and then subtract, \\n        // aka 1 + 2 * X - Y #, or reach Y / 2 and then Y, aka 1 + X - Y / 2 <= 1 + 2 * X - Y.\\n        // Therefore to reach Y (even) we always need to get Y / 2 first.\\n        if (X >= Y)\\n        {\\n            return X - Y;\\n        }\\n        \\n        if (Y % 2 == 1)\\n        {\\n            return 1 + brokenCalc(X, Y + 1);\\n        }\\n        \\n        return 1 + brokenCalc(X, Y / 2);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int X, int Y) {\\n        // There are 3 scenarios:\\n        // 1) if X >= Y, we can only subtract 1 from X to get Y, so the result == X - Y.\\n        // 2) if X < Y && Y is odd, we need to reach Y + 1 first and then subtract 1 to get Y,\\n        //    so the result will be brokenCalc(X, Y + 1) + 1 (recursion).\\n        // 3) if X < Y && Y is even, we need to reach Y / 2 first and then multiply 2 to get Y,\\n        //    so the result is brokenCalc(X, Y / 2) + 1. \\n        // To prove our conclusion in 3), assume X >= Y / 2, to get Y we either multiple and then subtract, \\n        // aka 1 + 2 * X - Y #, or reach Y / 2 and then Y, aka 1 + X - Y / 2 <= 1 + 2 * X - Y.\\n        // Therefore to reach Y (even) we always need to get Y / 2 first.\\n        if (X >= Y)\\n        {\\n            return X - Y;\\n        }\\n        \\n        if (Y % 2 == 1)\\n        {\\n            return 1 + brokenCalc(X, Y + 1);\\n        }\\n        \\n        return 1 + brokenCalc(X, Y / 2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1077501,
                "title": "cpp-fast-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int X, int Y) {\\n        int c=0;\\n        while(X!=Y)\\n        {\\n            if(Y>X&&Y%2!=0)\\n            {\\n                Y+=1;\\n                c++;\\n            }\\n          else if(Y>X)\\n            {\\n                Y/=2;\\n                c++;\\n            }\\n            else\\n            {\\n                c+=(X-Y);\\n                break;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int X, int Y) {\\n        int c=0;\\n        while(X!=Y)\\n        {\\n            if(Y>X&&Y%2!=0)\\n            {\\n                Y+=1;\\n                c++;\\n            }\\n          else if(Y>X)\\n            {\\n                Y/=2;\\n                c++;\\n            }\\n            else\\n            {\\n                c+=(X-Y);\\n                break;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1076951,
                "title": "python-3-bit-manipulation-o-log-log-n",
                "content": "# Greedy approach\\n- if Y <= X then we can only decrement X `X-Y` times.\\n- Else we should double X `mul = ceil(log2(Y/X))` times in any case. To get Y we should decrement doublings by `difference = X*2**mul - Y`.  And our goal is to optimize it.\\n- Every two decrements after doubling can be replaced by one decrement before doubling. So every doubling can be with zero or one decrement, but for big differences we need several decrements before doublings. It is easy to implement this parity checking in reverse order: half and increment Y.\\n- Time complexity is `O(log Y/X)`. Space complexity is `O(1)`.\\n```\\nclass Solution:\\n    def brokenCalc(self, X: int, Y: int) -> int:\\n        count = 0\\n        while Y > X:\\n            if Y&1:\\n                Y += 1\\n                count += 1\\n            Y >>= 1\\n            count += 1\\n            \\n        return count + X-Y\\n```\\n\\n# Bit manipulation approach\\n- As you can see in the Greedy approach result consists of three terms.\\n- First term is `mul = ceil(log2(Y/X))`.\\n- Second term is a number of decrements with doublings, or set bit count of `mul` least significant bits of `difference = X*2**mul - Y`.\\n- Third term is a number of decrements before doublings `difference / 2**mul`\\n- Time complexity is `O(log log n)`. For 32-bit integers `log log n = 5`. Space complexity is `O(1)`.\\n\\n```\\nclass Solution:\\n    def brokenCalc(self, X: int, Y: int) -> int:\\n        d = (Y-1)//X; mul = bool(d)\\n        if d & 0xffff0000: d >>=16; mul +=16\\n        if d &     0xff00: d >>= 8; mul += 8\\n        if d &       0xf0: d >>= 4; mul += 4\\n        if d &        0xc: d >>= 2; mul += 2\\n        if d &          2: d >>= 1; mul += 1\\n        \\n        dec = (X << mul)-Y & (1 << mul)-1\\n        dec = (dec >> 1 & 0x55555555) + (dec & 0x55555555)\\n        dec = (dec >> 2 & 0x33333333) + (dec & 0x33333333)\\n        dec = (dec >> 4 & 0x0f0f0f0f) + (dec & 0x0f0f0f0f)\\n        dec = (dec >> 8 & 0x00ff00ff) + (dec & 0x00ff00ff)\\n        dec = (dec >>16 & 0x0000ffff) + (dec & 0x0000ffff)\\n        \\n        return mul + dec + ((X << mul)-Y >> mul)\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def brokenCalc(self, X: int, Y: int) -> int:\\n        count = 0\\n        while Y > X:\\n            if Y&1:\\n                Y += 1\\n                count += 1\\n            Y >>= 1\\n            count += 1\\n            \\n        return count + X-Y\\n```\n```\\nclass Solution:\\n    def brokenCalc(self, X: int, Y: int) -> int:\\n        d = (Y-1)//X; mul = bool(d)\\n        if d & 0xffff0000: d >>=16; mul +=16\\n        if d &     0xff00: d >>= 8; mul += 8\\n        if d &       0xf0: d >>= 4; mul += 4\\n        if d &        0xc: d >>= 2; mul += 2\\n        if d &          2: d >>= 1; mul += 1\\n        \\n        dec = (X << mul)-Y & (1 << mul)-1\\n        dec = (dec >> 1 & 0x55555555) + (dec & 0x55555555)\\n        dec = (dec >> 2 & 0x33333333) + (dec & 0x33333333)\\n        dec = (dec >> 4 & 0x0f0f0f0f) + (dec & 0x0f0f0f0f)\\n        dec = (dec >> 8 & 0x00ff00ff) + (dec & 0x00ff00ff)\\n        dec = (dec >>16 & 0x0000ffff) + (dec & 0x0000ffff)\\n        \\n        return mul + dec + ((X << mul)-Y >> mul)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1076585,
                "title": "java-one-liner-with-recursion-faster-than-100",
                "content": "Clearly, if X >= Y, subtraction is fastest.  Doubling will not improve the answer.\\nOtherwise, we want to end with multiplication by 2 (and if Y is odd, subtract 1).\\nTo solve recursively, we set an initial target value of Y, and successively calculate new targets equal to the previous target divided by 2 and rounded up (i.e. target = (target + 1) / 2, with integer division).\\nRepeat until X >= target, and then add the difference X - target, to cover the necessary subtractions.\\nFor example, suppose X = 3 and Y = 10.\\nStep 1: (X = 3, Y = 10)\\n     Y is even, so we want to end with multiplication by 2 (one operation).\\nStep 2: (X = 3, Y = (10+1) / 2 = 5)\\n     Y is odd, so we want to end with multiplication by 2 and then subtraction (two operations).\\nStep 3: (X = 3, Y = (5+1) / 2 = 3)\\n     X = Y, so we do not need any more operations.\\nSolution is 1 + 2 + 0 = 3 operations.\\n```\\nclass Solution {\\n    public int brokenCalc(int X, int Y) {\\n        if (X >= Y) return X - Y; else return 1 + (Y % 2) + brokenCalc(X, (Y + 1) / 2);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int brokenCalc(int X, int Y) {\\n        if (X >= Y) return X - Y; else return 1 + (Y % 2) + brokenCalc(X, (Y + 1) / 2);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1076371,
                "title": "python-backwards",
                "content": "There\\'s another problem on leetcode where you have to do the reverse (go back from Y to X) and it is actually the way to go, because deciding whether to subtract one from X or double its value is much harder. I couldn\\'t come up with a proper solution it in reasonable time, but check Lee\\'s answer he has provided one.\\n```\\ndef brokenCalc(self, X: int, Y: int) -> int:\\n\\tops = 0\\n\\twhile Y > X:\\n\\t\\tif Y & 1: Y += 1\\n\\t\\telse: Y //= 2\\n\\t\\tops += 1\\n\\treturn ops + X - Y\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef brokenCalc(self, X: int, Y: int) -> int:\\n\\tops = 0\\n\\twhile Y > X:\\n\\t\\tif Y & 1: Y += 1\\n\\t\\telse: Y //= 2\\n\\t\\tops += 1\\n\\treturn ops + X - Y\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1076232,
                "title": "python-24ms-beats-96-68",
                "content": "```\\nclass Solution:\\n    def brokenCalc(self, X: int, Y: int) -> int:\\n        if Y<X:\\n            return X-Y\\n        elif Y==X:\\n            return 0\\n        elif Y%2==0:\\n            Y//=2\\n        else:\\n            Y+=1\\n        return 1 + self.brokenCalc(X, Y)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def brokenCalc(self, X: int, Y: int) -> int:\\n        if Y<X:\\n            return X-Y\\n        elif Y==X:\\n            return 0\\n        elif Y%2==0:\\n            Y//=2\\n        else:\\n            Y+=1\\n        return 1 + self.brokenCalc(X, Y)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1076194,
                "title": "broken-calculator-c-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int X, int Y) {\\n        int steps = 0;\\n        while (Y > X) {\\n            Y = Y%2 ? Y+1 : Y/2;\\n            steps++;\\n        }\\n        steps += X - Y;\\n        return steps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int X, int Y) {\\n        int steps = 0;\\n        while (Y > X) {\\n            Y = Y%2 ? Y+1 : Y/2;\\n            steps++;\\n        }\\n        steps += X - Y;\\n        return steps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1076180,
                "title": "python-forward-solution-toss-and-divide",
                "content": "Thanks to https://leetcode.com/problems/broken-calculator/discuss/308539/Thinking-Forward\\n\\n```\\n    def brokenCalc(self, X, Y):\\n        \"\"\"\\n        :type X: int\\n        :type Y: int\\n        :rtype: int\\n        \"\"\"\\n        if X >= Y:\\n            return X - Y\\n\\n        count = 0\\n        # multiply 2 until X is greater than Y\\n        while X < Y:\\n            X *= 2\\n            count += 1\\n        # Currently, the result is count+left, which might not be optimal\\n        # Calculate when should we decrement 1 to save cost using toss and divide\\n        left = X - Y\\n        power = count\\n        while left > 0:\\n            # if left // 2 ** power > 0, this means we should minus left//2**power before multiply 2 at that level\\n            count += left // 2 ** power\\n            left %= 2 ** power\\n            power -= 1\\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def brokenCalc(self, X, Y):\\n        \"\"\"\\n        :type X: int\\n        :type Y: int\\n        :rtype: int\\n        \"\"\"\\n        if X >= Y:\\n            return X - Y\\n\\n        count = 0\\n        # multiply 2 until X is greater than Y\\n        while X < Y:\\n            X *= 2\\n            count += 1\\n        # Currently, the result is count+left, which might not be optimal\\n        # Calculate when should we decrement 1 to save cost using toss and divide\\n        left = X - Y\\n        power = count\\n        while left > 0:\\n            # if left // 2 ** power > 0, this means we should minus left//2**power before multiply 2 at that level\\n            count += left // 2 ** power\\n            left %= 2 ** power\\n            power -= 1\\n        return count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1076101,
                "title": "broken-calculator-greedy-python3",
                "content": "\\n```\\n\\t\\tif X == Y: return 0\\n        if X > Y: return X - Y\\n        ans = 0\\n        # Divide Y by 2 until it smaller than double of X\\n        while Y > X * 2:\\n            ans += Y % 2 + 1\\n            Y = Y / 2 if Y % 2 == 0 else (Y + 1) / 2 \\n        \\n        # Subtract 1 from X until X * 2 - Y == 0 or X * 2 - Y == 1\\n        if X * 2 - Y > 1:\\n            ans += (X * 2 - Y) // 2\\n            X -= (X * 2 - Y) // 2\\n            \\n        # Until now there are only 2 cases:\\n        # X * 2 - Y == 0: ==> Only 1 steps left: X *= 2\\n        # X * 2 - Y == 1: ==> Only 2 steps left: X *= 2 then X -= 1\\n        ans += int((X * 2) % Y + 1)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\n\\t\\tif X == Y: return 0\\n        if X > Y: return X - Y\\n        ans = 0\\n        # Divide Y by 2 until it smaller than double of X\\n        while Y > X * 2:\\n            ans += Y % 2 + 1\\n            Y = Y / 2 if Y % 2 == 0 else (Y + 1) / 2 \\n        \\n        # Subtract 1 from X until X * 2 - Y == 0 or X * 2 - Y == 1\\n        if X * 2 - Y > 1:\\n            ans += (X * 2 - Y) // 2\\n            X -= (X * 2 - Y) // 2\\n            \\n        # Until now there are only 2 cases:\\n        # X * 2 - Y == 0: ==> Only 1 steps left: X *= 2\\n        # X * 2 - Y == 1: ==> Only 2 steps left: X *= 2 then X -= 1\\n        ans += int((X * 2) % Y + 1)\\n        return ans\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1565214,
                "content": [
                    {
                        "username": "fabregas2messi",
                        "content": "Hi guys,\\n\\nMy first intution for solving this problem was converting from X to Y, I ended up getting TLE or wrong answers. Most of the answers here I see have converting from Y to X. I dont understand how everyone got same intuition but me. Is there a chance that everyone is supermans here or you guys read top voted answers before designing your solution?"
                    },
                    {
                        "username": "RomaFed",
                        "content": "same question.. and if am not wrong, task says we should mutate start value, not target"
                    },
                    {
                        "username": "betaminc",
                        "content": "HAHAHHAHA"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/broken-calculator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Work Backwards\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghya",
                        "content": "My initial intitution was to update value of X to bring it closer to Y. \\n\\nI don\\'t understand what made you guys think of the \"work backward\" solution. What was the intituion behind modifying Y?\\nI am not asking for the solution here. Thanks"
                    },
                    {
                        "username": "krishnachanduakula",
                        "content": "I thought this is a DP question  and  i spanned two trees one with X-1 and other with X*2 \\nand return the minimum of both ,which reached Y fast. When  But i failed to understand its \\na greedy. How to decide if it is a greedy or DP?"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1 <= startValue, target <= 10^9 constraint screams it is not DP. But I\\'ve seen a problem that had such a constraint and had to be solved using DP with some trick."
                    },
                    {
                        "username": "Khwaja_Abdul_Samad",
                        "content": "in the DP approach when it will go with case -1 , it will create endless loop of only substracting one from itself as it will be moving away from target so DP is not a good option"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "I tried BFS approach starting from root, picked element from queue, performed multiply and subtract, push new value to queue.\\nRepeated the process till we reach target value, While pushing new element to queue keep updating steps count.\\n\\nBut ended up with TLE for worst case startValue=1, target=10000000\\n\\nSo BFS won\\'t work here.. Though its actually to find out shortest route from source to target."
                    },
                    {
                        "username": "glock17",
                        "content": "A lot of people are having trouble getting their heads around why are we moving from target to startValue.\nSo here I try to tell you the way I got to the solution.\n\n1. Multiplication is an independent operation irrespective of whether a number is even or odd, so it is a possibility that multiplication by 2 would overshoot our target by a large value and then to tone it down we would have to apply a large number of subtraction operations(as for this case only subtraction would be possible) to reach the target, which is an overkill.\n2. So the greedy approach aims at dividing the number by 2 only when it is possible, which was not the case with multiplication as we could have multiplied at any instance of time. As the target becomes less than the startValue then we simply do addition operations to reach the target value.\n\nHope it makes things clearer.\n\nMy python3 Solution:\nhttps://leetcode.com/problems/broken-calculator/solutions/3096648/python3-intuition-best-explanation-on-leetcode/"
                    },
                    {
                        "username": "crabbyD",
                        "content": "everyone in the discussion is having the same code in which they are changing the value of target and not the value of start.\\ncan anyone explain why everyone is doing so..."
                    },
                    {
                        "username": "Mars_Congressional_Republic",
                        "content": "I started off in that way and got stuck for a while. I guess the realization that made me switch is that you can only divide by 2 for even numbers, but multiplying by 2, you can do that for even or odd numbers so going backward seems more restricted than going forward."
                    },
                    {
                        "username": "livelearn",
                        "content": "Did other languages face the same time restrictions, felt like this was really tight."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.com/2019/02/10/Leetcode-991-Broken-Calculator/\\nHope helpful!"
                    },
                    {
                        "username": "phalkey89",
                        "content": "Question no \"991\"  is itself a series of calc being sold world wide.\\nlol !!"
                    }
                ]
            },
            {
                "id": 1567112,
                "content": [
                    {
                        "username": "fabregas2messi",
                        "content": "Hi guys,\\n\\nMy first intution for solving this problem was converting from X to Y, I ended up getting TLE or wrong answers. Most of the answers here I see have converting from Y to X. I dont understand how everyone got same intuition but me. Is there a chance that everyone is supermans here or you guys read top voted answers before designing your solution?"
                    },
                    {
                        "username": "RomaFed",
                        "content": "same question.. and if am not wrong, task says we should mutate start value, not target"
                    },
                    {
                        "username": "betaminc",
                        "content": "HAHAHHAHA"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/broken-calculator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Work Backwards\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghya",
                        "content": "My initial intitution was to update value of X to bring it closer to Y. \\n\\nI don\\'t understand what made you guys think of the \"work backward\" solution. What was the intituion behind modifying Y?\\nI am not asking for the solution here. Thanks"
                    },
                    {
                        "username": "krishnachanduakula",
                        "content": "I thought this is a DP question  and  i spanned two trees one with X-1 and other with X*2 \\nand return the minimum of both ,which reached Y fast. When  But i failed to understand its \\na greedy. How to decide if it is a greedy or DP?"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1 <= startValue, target <= 10^9 constraint screams it is not DP. But I\\'ve seen a problem that had such a constraint and had to be solved using DP with some trick."
                    },
                    {
                        "username": "Khwaja_Abdul_Samad",
                        "content": "in the DP approach when it will go with case -1 , it will create endless loop of only substracting one from itself as it will be moving away from target so DP is not a good option"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "I tried BFS approach starting from root, picked element from queue, performed multiply and subtract, push new value to queue.\\nRepeated the process till we reach target value, While pushing new element to queue keep updating steps count.\\n\\nBut ended up with TLE for worst case startValue=1, target=10000000\\n\\nSo BFS won\\'t work here.. Though its actually to find out shortest route from source to target."
                    },
                    {
                        "username": "glock17",
                        "content": "A lot of people are having trouble getting their heads around why are we moving from target to startValue.\nSo here I try to tell you the way I got to the solution.\n\n1. Multiplication is an independent operation irrespective of whether a number is even or odd, so it is a possibility that multiplication by 2 would overshoot our target by a large value and then to tone it down we would have to apply a large number of subtraction operations(as for this case only subtraction would be possible) to reach the target, which is an overkill.\n2. So the greedy approach aims at dividing the number by 2 only when it is possible, which was not the case with multiplication as we could have multiplied at any instance of time. As the target becomes less than the startValue then we simply do addition operations to reach the target value.\n\nHope it makes things clearer.\n\nMy python3 Solution:\nhttps://leetcode.com/problems/broken-calculator/solutions/3096648/python3-intuition-best-explanation-on-leetcode/"
                    },
                    {
                        "username": "crabbyD",
                        "content": "everyone in the discussion is having the same code in which they are changing the value of target and not the value of start.\\ncan anyone explain why everyone is doing so..."
                    },
                    {
                        "username": "Mars_Congressional_Republic",
                        "content": "I started off in that way and got stuck for a while. I guess the realization that made me switch is that you can only divide by 2 for even numbers, but multiplying by 2, you can do that for even or odd numbers so going backward seems more restricted than going forward."
                    },
                    {
                        "username": "livelearn",
                        "content": "Did other languages face the same time restrictions, felt like this was really tight."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.com/2019/02/10/Leetcode-991-Broken-Calculator/\\nHope helpful!"
                    },
                    {
                        "username": "phalkey89",
                        "content": "Question no \"991\"  is itself a series of calc being sold world wide.\\nlol !!"
                    }
                ]
            },
            {
                "id": 1565985,
                "content": [
                    {
                        "username": "fabregas2messi",
                        "content": "Hi guys,\\n\\nMy first intution for solving this problem was converting from X to Y, I ended up getting TLE or wrong answers. Most of the answers here I see have converting from Y to X. I dont understand how everyone got same intuition but me. Is there a chance that everyone is supermans here or you guys read top voted answers before designing your solution?"
                    },
                    {
                        "username": "RomaFed",
                        "content": "same question.. and if am not wrong, task says we should mutate start value, not target"
                    },
                    {
                        "username": "betaminc",
                        "content": "HAHAHHAHA"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/broken-calculator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Work Backwards\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghya",
                        "content": "My initial intitution was to update value of X to bring it closer to Y. \\n\\nI don\\'t understand what made you guys think of the \"work backward\" solution. What was the intituion behind modifying Y?\\nI am not asking for the solution here. Thanks"
                    },
                    {
                        "username": "krishnachanduakula",
                        "content": "I thought this is a DP question  and  i spanned two trees one with X-1 and other with X*2 \\nand return the minimum of both ,which reached Y fast. When  But i failed to understand its \\na greedy. How to decide if it is a greedy or DP?"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1 <= startValue, target <= 10^9 constraint screams it is not DP. But I\\'ve seen a problem that had such a constraint and had to be solved using DP with some trick."
                    },
                    {
                        "username": "Khwaja_Abdul_Samad",
                        "content": "in the DP approach when it will go with case -1 , it will create endless loop of only substracting one from itself as it will be moving away from target so DP is not a good option"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "I tried BFS approach starting from root, picked element from queue, performed multiply and subtract, push new value to queue.\\nRepeated the process till we reach target value, While pushing new element to queue keep updating steps count.\\n\\nBut ended up with TLE for worst case startValue=1, target=10000000\\n\\nSo BFS won\\'t work here.. Though its actually to find out shortest route from source to target."
                    },
                    {
                        "username": "glock17",
                        "content": "A lot of people are having trouble getting their heads around why are we moving from target to startValue.\nSo here I try to tell you the way I got to the solution.\n\n1. Multiplication is an independent operation irrespective of whether a number is even or odd, so it is a possibility that multiplication by 2 would overshoot our target by a large value and then to tone it down we would have to apply a large number of subtraction operations(as for this case only subtraction would be possible) to reach the target, which is an overkill.\n2. So the greedy approach aims at dividing the number by 2 only when it is possible, which was not the case with multiplication as we could have multiplied at any instance of time. As the target becomes less than the startValue then we simply do addition operations to reach the target value.\n\nHope it makes things clearer.\n\nMy python3 Solution:\nhttps://leetcode.com/problems/broken-calculator/solutions/3096648/python3-intuition-best-explanation-on-leetcode/"
                    },
                    {
                        "username": "crabbyD",
                        "content": "everyone in the discussion is having the same code in which they are changing the value of target and not the value of start.\\ncan anyone explain why everyone is doing so..."
                    },
                    {
                        "username": "Mars_Congressional_Republic",
                        "content": "I started off in that way and got stuck for a while. I guess the realization that made me switch is that you can only divide by 2 for even numbers, but multiplying by 2, you can do that for even or odd numbers so going backward seems more restricted than going forward."
                    },
                    {
                        "username": "livelearn",
                        "content": "Did other languages face the same time restrictions, felt like this was really tight."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.com/2019/02/10/Leetcode-991-Broken-Calculator/\\nHope helpful!"
                    },
                    {
                        "username": "phalkey89",
                        "content": "Question no \"991\"  is itself a series of calc being sold world wide.\\nlol !!"
                    }
                ]
            },
            {
                "id": 1567438,
                "content": [
                    {
                        "username": "fabregas2messi",
                        "content": "Hi guys,\\n\\nMy first intution for solving this problem was converting from X to Y, I ended up getting TLE or wrong answers. Most of the answers here I see have converting from Y to X. I dont understand how everyone got same intuition but me. Is there a chance that everyone is supermans here or you guys read top voted answers before designing your solution?"
                    },
                    {
                        "username": "RomaFed",
                        "content": "same question.. and if am not wrong, task says we should mutate start value, not target"
                    },
                    {
                        "username": "betaminc",
                        "content": "HAHAHHAHA"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/broken-calculator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Work Backwards\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghya",
                        "content": "My initial intitution was to update value of X to bring it closer to Y. \\n\\nI don\\'t understand what made you guys think of the \"work backward\" solution. What was the intituion behind modifying Y?\\nI am not asking for the solution here. Thanks"
                    },
                    {
                        "username": "krishnachanduakula",
                        "content": "I thought this is a DP question  and  i spanned two trees one with X-1 and other with X*2 \\nand return the minimum of both ,which reached Y fast. When  But i failed to understand its \\na greedy. How to decide if it is a greedy or DP?"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1 <= startValue, target <= 10^9 constraint screams it is not DP. But I\\'ve seen a problem that had such a constraint and had to be solved using DP with some trick."
                    },
                    {
                        "username": "Khwaja_Abdul_Samad",
                        "content": "in the DP approach when it will go with case -1 , it will create endless loop of only substracting one from itself as it will be moving away from target so DP is not a good option"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "I tried BFS approach starting from root, picked element from queue, performed multiply and subtract, push new value to queue.\\nRepeated the process till we reach target value, While pushing new element to queue keep updating steps count.\\n\\nBut ended up with TLE for worst case startValue=1, target=10000000\\n\\nSo BFS won\\'t work here.. Though its actually to find out shortest route from source to target."
                    },
                    {
                        "username": "glock17",
                        "content": "A lot of people are having trouble getting their heads around why are we moving from target to startValue.\nSo here I try to tell you the way I got to the solution.\n\n1. Multiplication is an independent operation irrespective of whether a number is even or odd, so it is a possibility that multiplication by 2 would overshoot our target by a large value and then to tone it down we would have to apply a large number of subtraction operations(as for this case only subtraction would be possible) to reach the target, which is an overkill.\n2. So the greedy approach aims at dividing the number by 2 only when it is possible, which was not the case with multiplication as we could have multiplied at any instance of time. As the target becomes less than the startValue then we simply do addition operations to reach the target value.\n\nHope it makes things clearer.\n\nMy python3 Solution:\nhttps://leetcode.com/problems/broken-calculator/solutions/3096648/python3-intuition-best-explanation-on-leetcode/"
                    },
                    {
                        "username": "crabbyD",
                        "content": "everyone in the discussion is having the same code in which they are changing the value of target and not the value of start.\\ncan anyone explain why everyone is doing so..."
                    },
                    {
                        "username": "Mars_Congressional_Republic",
                        "content": "I started off in that way and got stuck for a while. I guess the realization that made me switch is that you can only divide by 2 for even numbers, but multiplying by 2, you can do that for even or odd numbers so going backward seems more restricted than going forward."
                    },
                    {
                        "username": "livelearn",
                        "content": "Did other languages face the same time restrictions, felt like this was really tight."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.com/2019/02/10/Leetcode-991-Broken-Calculator/\\nHope helpful!"
                    },
                    {
                        "username": "phalkey89",
                        "content": "Question no \"991\"  is itself a series of calc being sold world wide.\\nlol !!"
                    }
                ]
            },
            {
                "id": 1828165,
                "content": [
                    {
                        "username": "fabregas2messi",
                        "content": "Hi guys,\\n\\nMy first intution for solving this problem was converting from X to Y, I ended up getting TLE or wrong answers. Most of the answers here I see have converting from Y to X. I dont understand how everyone got same intuition but me. Is there a chance that everyone is supermans here or you guys read top voted answers before designing your solution?"
                    },
                    {
                        "username": "RomaFed",
                        "content": "same question.. and if am not wrong, task says we should mutate start value, not target"
                    },
                    {
                        "username": "betaminc",
                        "content": "HAHAHHAHA"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/broken-calculator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Work Backwards\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghya",
                        "content": "My initial intitution was to update value of X to bring it closer to Y. \\n\\nI don\\'t understand what made you guys think of the \"work backward\" solution. What was the intituion behind modifying Y?\\nI am not asking for the solution here. Thanks"
                    },
                    {
                        "username": "krishnachanduakula",
                        "content": "I thought this is a DP question  and  i spanned two trees one with X-1 and other with X*2 \\nand return the minimum of both ,which reached Y fast. When  But i failed to understand its \\na greedy. How to decide if it is a greedy or DP?"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1 <= startValue, target <= 10^9 constraint screams it is not DP. But I\\'ve seen a problem that had such a constraint and had to be solved using DP with some trick."
                    },
                    {
                        "username": "Khwaja_Abdul_Samad",
                        "content": "in the DP approach when it will go with case -1 , it will create endless loop of only substracting one from itself as it will be moving away from target so DP is not a good option"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "I tried BFS approach starting from root, picked element from queue, performed multiply and subtract, push new value to queue.\\nRepeated the process till we reach target value, While pushing new element to queue keep updating steps count.\\n\\nBut ended up with TLE for worst case startValue=1, target=10000000\\n\\nSo BFS won\\'t work here.. Though its actually to find out shortest route from source to target."
                    },
                    {
                        "username": "glock17",
                        "content": "A lot of people are having trouble getting their heads around why are we moving from target to startValue.\nSo here I try to tell you the way I got to the solution.\n\n1. Multiplication is an independent operation irrespective of whether a number is even or odd, so it is a possibility that multiplication by 2 would overshoot our target by a large value and then to tone it down we would have to apply a large number of subtraction operations(as for this case only subtraction would be possible) to reach the target, which is an overkill.\n2. So the greedy approach aims at dividing the number by 2 only when it is possible, which was not the case with multiplication as we could have multiplied at any instance of time. As the target becomes less than the startValue then we simply do addition operations to reach the target value.\n\nHope it makes things clearer.\n\nMy python3 Solution:\nhttps://leetcode.com/problems/broken-calculator/solutions/3096648/python3-intuition-best-explanation-on-leetcode/"
                    },
                    {
                        "username": "crabbyD",
                        "content": "everyone in the discussion is having the same code in which they are changing the value of target and not the value of start.\\ncan anyone explain why everyone is doing so..."
                    },
                    {
                        "username": "Mars_Congressional_Republic",
                        "content": "I started off in that way and got stuck for a while. I guess the realization that made me switch is that you can only divide by 2 for even numbers, but multiplying by 2, you can do that for even or odd numbers so going backward seems more restricted than going forward."
                    },
                    {
                        "username": "livelearn",
                        "content": "Did other languages face the same time restrictions, felt like this was really tight."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.com/2019/02/10/Leetcode-991-Broken-Calculator/\\nHope helpful!"
                    },
                    {
                        "username": "phalkey89",
                        "content": "Question no \"991\"  is itself a series of calc being sold world wide.\\nlol !!"
                    }
                ]
            },
            {
                "id": 1773654,
                "content": [
                    {
                        "username": "fabregas2messi",
                        "content": "Hi guys,\\n\\nMy first intution for solving this problem was converting from X to Y, I ended up getting TLE or wrong answers. Most of the answers here I see have converting from Y to X. I dont understand how everyone got same intuition but me. Is there a chance that everyone is supermans here or you guys read top voted answers before designing your solution?"
                    },
                    {
                        "username": "RomaFed",
                        "content": "same question.. and if am not wrong, task says we should mutate start value, not target"
                    },
                    {
                        "username": "betaminc",
                        "content": "HAHAHHAHA"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/broken-calculator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Work Backwards\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghya",
                        "content": "My initial intitution was to update value of X to bring it closer to Y. \\n\\nI don\\'t understand what made you guys think of the \"work backward\" solution. What was the intituion behind modifying Y?\\nI am not asking for the solution here. Thanks"
                    },
                    {
                        "username": "krishnachanduakula",
                        "content": "I thought this is a DP question  and  i spanned two trees one with X-1 and other with X*2 \\nand return the minimum of both ,which reached Y fast. When  But i failed to understand its \\na greedy. How to decide if it is a greedy or DP?"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1 <= startValue, target <= 10^9 constraint screams it is not DP. But I\\'ve seen a problem that had such a constraint and had to be solved using DP with some trick."
                    },
                    {
                        "username": "Khwaja_Abdul_Samad",
                        "content": "in the DP approach when it will go with case -1 , it will create endless loop of only substracting one from itself as it will be moving away from target so DP is not a good option"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "I tried BFS approach starting from root, picked element from queue, performed multiply and subtract, push new value to queue.\\nRepeated the process till we reach target value, While pushing new element to queue keep updating steps count.\\n\\nBut ended up with TLE for worst case startValue=1, target=10000000\\n\\nSo BFS won\\'t work here.. Though its actually to find out shortest route from source to target."
                    },
                    {
                        "username": "glock17",
                        "content": "A lot of people are having trouble getting their heads around why are we moving from target to startValue.\nSo here I try to tell you the way I got to the solution.\n\n1. Multiplication is an independent operation irrespective of whether a number is even or odd, so it is a possibility that multiplication by 2 would overshoot our target by a large value and then to tone it down we would have to apply a large number of subtraction operations(as for this case only subtraction would be possible) to reach the target, which is an overkill.\n2. So the greedy approach aims at dividing the number by 2 only when it is possible, which was not the case with multiplication as we could have multiplied at any instance of time. As the target becomes less than the startValue then we simply do addition operations to reach the target value.\n\nHope it makes things clearer.\n\nMy python3 Solution:\nhttps://leetcode.com/problems/broken-calculator/solutions/3096648/python3-intuition-best-explanation-on-leetcode/"
                    },
                    {
                        "username": "crabbyD",
                        "content": "everyone in the discussion is having the same code in which they are changing the value of target and not the value of start.\\ncan anyone explain why everyone is doing so..."
                    },
                    {
                        "username": "Mars_Congressional_Republic",
                        "content": "I started off in that way and got stuck for a while. I guess the realization that made me switch is that you can only divide by 2 for even numbers, but multiplying by 2, you can do that for even or odd numbers so going backward seems more restricted than going forward."
                    },
                    {
                        "username": "livelearn",
                        "content": "Did other languages face the same time restrictions, felt like this was really tight."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.com/2019/02/10/Leetcode-991-Broken-Calculator/\\nHope helpful!"
                    },
                    {
                        "username": "phalkey89",
                        "content": "Question no \"991\"  is itself a series of calc being sold world wide.\\nlol !!"
                    }
                ]
            },
            {
                "id": 1570826,
                "content": [
                    {
                        "username": "fabregas2messi",
                        "content": "Hi guys,\\n\\nMy first intution for solving this problem was converting from X to Y, I ended up getting TLE or wrong answers. Most of the answers here I see have converting from Y to X. I dont understand how everyone got same intuition but me. Is there a chance that everyone is supermans here or you guys read top voted answers before designing your solution?"
                    },
                    {
                        "username": "RomaFed",
                        "content": "same question.. and if am not wrong, task says we should mutate start value, not target"
                    },
                    {
                        "username": "betaminc",
                        "content": "HAHAHHAHA"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/broken-calculator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Work Backwards\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghya",
                        "content": "My initial intitution was to update value of X to bring it closer to Y. \\n\\nI don\\'t understand what made you guys think of the \"work backward\" solution. What was the intituion behind modifying Y?\\nI am not asking for the solution here. Thanks"
                    },
                    {
                        "username": "krishnachanduakula",
                        "content": "I thought this is a DP question  and  i spanned two trees one with X-1 and other with X*2 \\nand return the minimum of both ,which reached Y fast. When  But i failed to understand its \\na greedy. How to decide if it is a greedy or DP?"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1 <= startValue, target <= 10^9 constraint screams it is not DP. But I\\'ve seen a problem that had such a constraint and had to be solved using DP with some trick."
                    },
                    {
                        "username": "Khwaja_Abdul_Samad",
                        "content": "in the DP approach when it will go with case -1 , it will create endless loop of only substracting one from itself as it will be moving away from target so DP is not a good option"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "I tried BFS approach starting from root, picked element from queue, performed multiply and subtract, push new value to queue.\\nRepeated the process till we reach target value, While pushing new element to queue keep updating steps count.\\n\\nBut ended up with TLE for worst case startValue=1, target=10000000\\n\\nSo BFS won\\'t work here.. Though its actually to find out shortest route from source to target."
                    },
                    {
                        "username": "glock17",
                        "content": "A lot of people are having trouble getting their heads around why are we moving from target to startValue.\nSo here I try to tell you the way I got to the solution.\n\n1. Multiplication is an independent operation irrespective of whether a number is even or odd, so it is a possibility that multiplication by 2 would overshoot our target by a large value and then to tone it down we would have to apply a large number of subtraction operations(as for this case only subtraction would be possible) to reach the target, which is an overkill.\n2. So the greedy approach aims at dividing the number by 2 only when it is possible, which was not the case with multiplication as we could have multiplied at any instance of time. As the target becomes less than the startValue then we simply do addition operations to reach the target value.\n\nHope it makes things clearer.\n\nMy python3 Solution:\nhttps://leetcode.com/problems/broken-calculator/solutions/3096648/python3-intuition-best-explanation-on-leetcode/"
                    },
                    {
                        "username": "crabbyD",
                        "content": "everyone in the discussion is having the same code in which they are changing the value of target and not the value of start.\\ncan anyone explain why everyone is doing so..."
                    },
                    {
                        "username": "Mars_Congressional_Republic",
                        "content": "I started off in that way and got stuck for a while. I guess the realization that made me switch is that you can only divide by 2 for even numbers, but multiplying by 2, you can do that for even or odd numbers so going backward seems more restricted than going forward."
                    },
                    {
                        "username": "livelearn",
                        "content": "Did other languages face the same time restrictions, felt like this was really tight."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.com/2019/02/10/Leetcode-991-Broken-Calculator/\\nHope helpful!"
                    },
                    {
                        "username": "phalkey89",
                        "content": "Question no \"991\"  is itself a series of calc being sold world wide.\\nlol !!"
                    }
                ]
            },
            {
                "id": 1567364,
                "content": [
                    {
                        "username": "fabregas2messi",
                        "content": "Hi guys,\\n\\nMy first intution for solving this problem was converting from X to Y, I ended up getting TLE or wrong answers. Most of the answers here I see have converting from Y to X. I dont understand how everyone got same intuition but me. Is there a chance that everyone is supermans here or you guys read top voted answers before designing your solution?"
                    },
                    {
                        "username": "RomaFed",
                        "content": "same question.. and if am not wrong, task says we should mutate start value, not target"
                    },
                    {
                        "username": "betaminc",
                        "content": "HAHAHHAHA"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/broken-calculator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Work Backwards\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghya",
                        "content": "My initial intitution was to update value of X to bring it closer to Y. \\n\\nI don\\'t understand what made you guys think of the \"work backward\" solution. What was the intituion behind modifying Y?\\nI am not asking for the solution here. Thanks"
                    },
                    {
                        "username": "krishnachanduakula",
                        "content": "I thought this is a DP question  and  i spanned two trees one with X-1 and other with X*2 \\nand return the minimum of both ,which reached Y fast. When  But i failed to understand its \\na greedy. How to decide if it is a greedy or DP?"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1 <= startValue, target <= 10^9 constraint screams it is not DP. But I\\'ve seen a problem that had such a constraint and had to be solved using DP with some trick."
                    },
                    {
                        "username": "Khwaja_Abdul_Samad",
                        "content": "in the DP approach when it will go with case -1 , it will create endless loop of only substracting one from itself as it will be moving away from target so DP is not a good option"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "I tried BFS approach starting from root, picked element from queue, performed multiply and subtract, push new value to queue.\\nRepeated the process till we reach target value, While pushing new element to queue keep updating steps count.\\n\\nBut ended up with TLE for worst case startValue=1, target=10000000\\n\\nSo BFS won\\'t work here.. Though its actually to find out shortest route from source to target."
                    },
                    {
                        "username": "glock17",
                        "content": "A lot of people are having trouble getting their heads around why are we moving from target to startValue.\nSo here I try to tell you the way I got to the solution.\n\n1. Multiplication is an independent operation irrespective of whether a number is even or odd, so it is a possibility that multiplication by 2 would overshoot our target by a large value and then to tone it down we would have to apply a large number of subtraction operations(as for this case only subtraction would be possible) to reach the target, which is an overkill.\n2. So the greedy approach aims at dividing the number by 2 only when it is possible, which was not the case with multiplication as we could have multiplied at any instance of time. As the target becomes less than the startValue then we simply do addition operations to reach the target value.\n\nHope it makes things clearer.\n\nMy python3 Solution:\nhttps://leetcode.com/problems/broken-calculator/solutions/3096648/python3-intuition-best-explanation-on-leetcode/"
                    },
                    {
                        "username": "crabbyD",
                        "content": "everyone in the discussion is having the same code in which they are changing the value of target and not the value of start.\\ncan anyone explain why everyone is doing so..."
                    },
                    {
                        "username": "Mars_Congressional_Republic",
                        "content": "I started off in that way and got stuck for a while. I guess the realization that made me switch is that you can only divide by 2 for even numbers, but multiplying by 2, you can do that for even or odd numbers so going backward seems more restricted than going forward."
                    },
                    {
                        "username": "livelearn",
                        "content": "Did other languages face the same time restrictions, felt like this was really tight."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.com/2019/02/10/Leetcode-991-Broken-Calculator/\\nHope helpful!"
                    },
                    {
                        "username": "phalkey89",
                        "content": "Question no \"991\"  is itself a series of calc being sold world wide.\\nlol !!"
                    }
                ]
            },
            {
                "id": 1566853,
                "content": [
                    {
                        "username": "fabregas2messi",
                        "content": "Hi guys,\\n\\nMy first intution for solving this problem was converting from X to Y, I ended up getting TLE or wrong answers. Most of the answers here I see have converting from Y to X. I dont understand how everyone got same intuition but me. Is there a chance that everyone is supermans here or you guys read top voted answers before designing your solution?"
                    },
                    {
                        "username": "RomaFed",
                        "content": "same question.. and if am not wrong, task says we should mutate start value, not target"
                    },
                    {
                        "username": "betaminc",
                        "content": "HAHAHHAHA"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/broken-calculator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Work Backwards\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghya",
                        "content": "My initial intitution was to update value of X to bring it closer to Y. \\n\\nI don\\'t understand what made you guys think of the \"work backward\" solution. What was the intituion behind modifying Y?\\nI am not asking for the solution here. Thanks"
                    },
                    {
                        "username": "krishnachanduakula",
                        "content": "I thought this is a DP question  and  i spanned two trees one with X-1 and other with X*2 \\nand return the minimum of both ,which reached Y fast. When  But i failed to understand its \\na greedy. How to decide if it is a greedy or DP?"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1 <= startValue, target <= 10^9 constraint screams it is not DP. But I\\'ve seen a problem that had such a constraint and had to be solved using DP with some trick."
                    },
                    {
                        "username": "Khwaja_Abdul_Samad",
                        "content": "in the DP approach when it will go with case -1 , it will create endless loop of only substracting one from itself as it will be moving away from target so DP is not a good option"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "I tried BFS approach starting from root, picked element from queue, performed multiply and subtract, push new value to queue.\\nRepeated the process till we reach target value, While pushing new element to queue keep updating steps count.\\n\\nBut ended up with TLE for worst case startValue=1, target=10000000\\n\\nSo BFS won\\'t work here.. Though its actually to find out shortest route from source to target."
                    },
                    {
                        "username": "glock17",
                        "content": "A lot of people are having trouble getting their heads around why are we moving from target to startValue.\nSo here I try to tell you the way I got to the solution.\n\n1. Multiplication is an independent operation irrespective of whether a number is even or odd, so it is a possibility that multiplication by 2 would overshoot our target by a large value and then to tone it down we would have to apply a large number of subtraction operations(as for this case only subtraction would be possible) to reach the target, which is an overkill.\n2. So the greedy approach aims at dividing the number by 2 only when it is possible, which was not the case with multiplication as we could have multiplied at any instance of time. As the target becomes less than the startValue then we simply do addition operations to reach the target value.\n\nHope it makes things clearer.\n\nMy python3 Solution:\nhttps://leetcode.com/problems/broken-calculator/solutions/3096648/python3-intuition-best-explanation-on-leetcode/"
                    },
                    {
                        "username": "crabbyD",
                        "content": "everyone in the discussion is having the same code in which they are changing the value of target and not the value of start.\\ncan anyone explain why everyone is doing so..."
                    },
                    {
                        "username": "Mars_Congressional_Republic",
                        "content": "I started off in that way and got stuck for a while. I guess the realization that made me switch is that you can only divide by 2 for even numbers, but multiplying by 2, you can do that for even or odd numbers so going backward seems more restricted than going forward."
                    },
                    {
                        "username": "livelearn",
                        "content": "Did other languages face the same time restrictions, felt like this was really tight."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.com/2019/02/10/Leetcode-991-Broken-Calculator/\\nHope helpful!"
                    },
                    {
                        "username": "phalkey89",
                        "content": "Question no \"991\"  is itself a series of calc being sold world wide.\\nlol !!"
                    }
                ]
            },
            {
                "id": 1983290,
                "content": [
                    {
                        "username": "fabregas2messi",
                        "content": "Hi guys,\\n\\nMy first intution for solving this problem was converting from X to Y, I ended up getting TLE or wrong answers. Most of the answers here I see have converting from Y to X. I dont understand how everyone got same intuition but me. Is there a chance that everyone is supermans here or you guys read top voted answers before designing your solution?"
                    },
                    {
                        "username": "RomaFed",
                        "content": "same question.. and if am not wrong, task says we should mutate start value, not target"
                    },
                    {
                        "username": "betaminc",
                        "content": "HAHAHHAHA"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/broken-calculator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Work Backwards\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghya",
                        "content": "My initial intitution was to update value of X to bring it closer to Y. \\n\\nI don\\'t understand what made you guys think of the \"work backward\" solution. What was the intituion behind modifying Y?\\nI am not asking for the solution here. Thanks"
                    },
                    {
                        "username": "krishnachanduakula",
                        "content": "I thought this is a DP question  and  i spanned two trees one with X-1 and other with X*2 \\nand return the minimum of both ,which reached Y fast. When  But i failed to understand its \\na greedy. How to decide if it is a greedy or DP?"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1 <= startValue, target <= 10^9 constraint screams it is not DP. But I\\'ve seen a problem that had such a constraint and had to be solved using DP with some trick."
                    },
                    {
                        "username": "Khwaja_Abdul_Samad",
                        "content": "in the DP approach when it will go with case -1 , it will create endless loop of only substracting one from itself as it will be moving away from target so DP is not a good option"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "I tried BFS approach starting from root, picked element from queue, performed multiply and subtract, push new value to queue.\\nRepeated the process till we reach target value, While pushing new element to queue keep updating steps count.\\n\\nBut ended up with TLE for worst case startValue=1, target=10000000\\n\\nSo BFS won\\'t work here.. Though its actually to find out shortest route from source to target."
                    },
                    {
                        "username": "glock17",
                        "content": "A lot of people are having trouble getting their heads around why are we moving from target to startValue.\nSo here I try to tell you the way I got to the solution.\n\n1. Multiplication is an independent operation irrespective of whether a number is even or odd, so it is a possibility that multiplication by 2 would overshoot our target by a large value and then to tone it down we would have to apply a large number of subtraction operations(as for this case only subtraction would be possible) to reach the target, which is an overkill.\n2. So the greedy approach aims at dividing the number by 2 only when it is possible, which was not the case with multiplication as we could have multiplied at any instance of time. As the target becomes less than the startValue then we simply do addition operations to reach the target value.\n\nHope it makes things clearer.\n\nMy python3 Solution:\nhttps://leetcode.com/problems/broken-calculator/solutions/3096648/python3-intuition-best-explanation-on-leetcode/"
                    },
                    {
                        "username": "crabbyD",
                        "content": "everyone in the discussion is having the same code in which they are changing the value of target and not the value of start.\\ncan anyone explain why everyone is doing so..."
                    },
                    {
                        "username": "Mars_Congressional_Republic",
                        "content": "I started off in that way and got stuck for a while. I guess the realization that made me switch is that you can only divide by 2 for even numbers, but multiplying by 2, you can do that for even or odd numbers so going backward seems more restricted than going forward."
                    },
                    {
                        "username": "livelearn",
                        "content": "Did other languages face the same time restrictions, felt like this was really tight."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.com/2019/02/10/Leetcode-991-Broken-Calculator/\\nHope helpful!"
                    },
                    {
                        "username": "phalkey89",
                        "content": "Question no \"991\"  is itself a series of calc being sold world wide.\\nlol !!"
                    }
                ]
            },
            {
                "id": 1565214,
                "content": [
                    {
                        "username": "fabregas2messi",
                        "content": "Hi guys,\\n\\nMy first intution for solving this problem was converting from X to Y, I ended up getting TLE or wrong answers. Most of the answers here I see have converting from Y to X. I dont understand how everyone got same intuition but me. Is there a chance that everyone is supermans here or you guys read top voted answers before designing your solution?"
                    },
                    {
                        "username": "RomaFed",
                        "content": "same question.. and if am not wrong, task says we should mutate start value, not target"
                    },
                    {
                        "username": "betaminc",
                        "content": "HAHAHHAHA"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/broken-calculator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Work Backwards\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghya",
                        "content": "My initial intitution was to update value of X to bring it closer to Y. \\n\\nI don\\'t understand what made you guys think of the \"work backward\" solution. What was the intituion behind modifying Y?\\nI am not asking for the solution here. Thanks"
                    },
                    {
                        "username": "krishnachanduakula",
                        "content": "I thought this is a DP question  and  i spanned two trees one with X-1 and other with X*2 \\nand return the minimum of both ,which reached Y fast. When  But i failed to understand its \\na greedy. How to decide if it is a greedy or DP?"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1 <= startValue, target <= 10^9 constraint screams it is not DP. But I\\'ve seen a problem that had such a constraint and had to be solved using DP with some trick."
                    },
                    {
                        "username": "Khwaja_Abdul_Samad",
                        "content": "in the DP approach when it will go with case -1 , it will create endless loop of only substracting one from itself as it will be moving away from target so DP is not a good option"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "I tried BFS approach starting from root, picked element from queue, performed multiply and subtract, push new value to queue.\\nRepeated the process till we reach target value, While pushing new element to queue keep updating steps count.\\n\\nBut ended up with TLE for worst case startValue=1, target=10000000\\n\\nSo BFS won\\'t work here.. Though its actually to find out shortest route from source to target."
                    },
                    {
                        "username": "glock17",
                        "content": "A lot of people are having trouble getting their heads around why are we moving from target to startValue.\nSo here I try to tell you the way I got to the solution.\n\n1. Multiplication is an independent operation irrespective of whether a number is even or odd, so it is a possibility that multiplication by 2 would overshoot our target by a large value and then to tone it down we would have to apply a large number of subtraction operations(as for this case only subtraction would be possible) to reach the target, which is an overkill.\n2. So the greedy approach aims at dividing the number by 2 only when it is possible, which was not the case with multiplication as we could have multiplied at any instance of time. As the target becomes less than the startValue then we simply do addition operations to reach the target value.\n\nHope it makes things clearer.\n\nMy python3 Solution:\nhttps://leetcode.com/problems/broken-calculator/solutions/3096648/python3-intuition-best-explanation-on-leetcode/"
                    },
                    {
                        "username": "crabbyD",
                        "content": "everyone in the discussion is having the same code in which they are changing the value of target and not the value of start.\\ncan anyone explain why everyone is doing so..."
                    },
                    {
                        "username": "Mars_Congressional_Republic",
                        "content": "I started off in that way and got stuck for a while. I guess the realization that made me switch is that you can only divide by 2 for even numbers, but multiplying by 2, you can do that for even or odd numbers so going backward seems more restricted than going forward."
                    },
                    {
                        "username": "livelearn",
                        "content": "Did other languages face the same time restrictions, felt like this was really tight."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.com/2019/02/10/Leetcode-991-Broken-Calculator/\\nHope helpful!"
                    },
                    {
                        "username": "phalkey89",
                        "content": "Question no \"991\"  is itself a series of calc being sold world wide.\\nlol !!"
                    }
                ]
            },
            {
                "id": 1567112,
                "content": [
                    {
                        "username": "fabregas2messi",
                        "content": "Hi guys,\\n\\nMy first intution for solving this problem was converting from X to Y, I ended up getting TLE or wrong answers. Most of the answers here I see have converting from Y to X. I dont understand how everyone got same intuition but me. Is there a chance that everyone is supermans here or you guys read top voted answers before designing your solution?"
                    },
                    {
                        "username": "RomaFed",
                        "content": "same question.. and if am not wrong, task says we should mutate start value, not target"
                    },
                    {
                        "username": "betaminc",
                        "content": "HAHAHHAHA"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/broken-calculator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Work Backwards\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghya",
                        "content": "My initial intitution was to update value of X to bring it closer to Y. \\n\\nI don\\'t understand what made you guys think of the \"work backward\" solution. What was the intituion behind modifying Y?\\nI am not asking for the solution here. Thanks"
                    },
                    {
                        "username": "krishnachanduakula",
                        "content": "I thought this is a DP question  and  i spanned two trees one with X-1 and other with X*2 \\nand return the minimum of both ,which reached Y fast. When  But i failed to understand its \\na greedy. How to decide if it is a greedy or DP?"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1 <= startValue, target <= 10^9 constraint screams it is not DP. But I\\'ve seen a problem that had such a constraint and had to be solved using DP with some trick."
                    },
                    {
                        "username": "Khwaja_Abdul_Samad",
                        "content": "in the DP approach when it will go with case -1 , it will create endless loop of only substracting one from itself as it will be moving away from target so DP is not a good option"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "I tried BFS approach starting from root, picked element from queue, performed multiply and subtract, push new value to queue.\\nRepeated the process till we reach target value, While pushing new element to queue keep updating steps count.\\n\\nBut ended up with TLE for worst case startValue=1, target=10000000\\n\\nSo BFS won\\'t work here.. Though its actually to find out shortest route from source to target."
                    },
                    {
                        "username": "glock17",
                        "content": "A lot of people are having trouble getting their heads around why are we moving from target to startValue.\nSo here I try to tell you the way I got to the solution.\n\n1. Multiplication is an independent operation irrespective of whether a number is even or odd, so it is a possibility that multiplication by 2 would overshoot our target by a large value and then to tone it down we would have to apply a large number of subtraction operations(as for this case only subtraction would be possible) to reach the target, which is an overkill.\n2. So the greedy approach aims at dividing the number by 2 only when it is possible, which was not the case with multiplication as we could have multiplied at any instance of time. As the target becomes less than the startValue then we simply do addition operations to reach the target value.\n\nHope it makes things clearer.\n\nMy python3 Solution:\nhttps://leetcode.com/problems/broken-calculator/solutions/3096648/python3-intuition-best-explanation-on-leetcode/"
                    },
                    {
                        "username": "crabbyD",
                        "content": "everyone in the discussion is having the same code in which they are changing the value of target and not the value of start.\\ncan anyone explain why everyone is doing so..."
                    },
                    {
                        "username": "Mars_Congressional_Republic",
                        "content": "I started off in that way and got stuck for a while. I guess the realization that made me switch is that you can only divide by 2 for even numbers, but multiplying by 2, you can do that for even or odd numbers so going backward seems more restricted than going forward."
                    },
                    {
                        "username": "livelearn",
                        "content": "Did other languages face the same time restrictions, felt like this was really tight."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.com/2019/02/10/Leetcode-991-Broken-Calculator/\\nHope helpful!"
                    },
                    {
                        "username": "phalkey89",
                        "content": "Question no \"991\"  is itself a series of calc being sold world wide.\\nlol !!"
                    }
                ]
            },
            {
                "id": 1565985,
                "content": [
                    {
                        "username": "fabregas2messi",
                        "content": "Hi guys,\\n\\nMy first intution for solving this problem was converting from X to Y, I ended up getting TLE or wrong answers. Most of the answers here I see have converting from Y to X. I dont understand how everyone got same intuition but me. Is there a chance that everyone is supermans here or you guys read top voted answers before designing your solution?"
                    },
                    {
                        "username": "RomaFed",
                        "content": "same question.. and if am not wrong, task says we should mutate start value, not target"
                    },
                    {
                        "username": "betaminc",
                        "content": "HAHAHHAHA"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/broken-calculator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Work Backwards\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghya",
                        "content": "My initial intitution was to update value of X to bring it closer to Y. \\n\\nI don\\'t understand what made you guys think of the \"work backward\" solution. What was the intituion behind modifying Y?\\nI am not asking for the solution here. Thanks"
                    },
                    {
                        "username": "krishnachanduakula",
                        "content": "I thought this is a DP question  and  i spanned two trees one with X-1 and other with X*2 \\nand return the minimum of both ,which reached Y fast. When  But i failed to understand its \\na greedy. How to decide if it is a greedy or DP?"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1 <= startValue, target <= 10^9 constraint screams it is not DP. But I\\'ve seen a problem that had such a constraint and had to be solved using DP with some trick."
                    },
                    {
                        "username": "Khwaja_Abdul_Samad",
                        "content": "in the DP approach when it will go with case -1 , it will create endless loop of only substracting one from itself as it will be moving away from target so DP is not a good option"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "I tried BFS approach starting from root, picked element from queue, performed multiply and subtract, push new value to queue.\\nRepeated the process till we reach target value, While pushing new element to queue keep updating steps count.\\n\\nBut ended up with TLE for worst case startValue=1, target=10000000\\n\\nSo BFS won\\'t work here.. Though its actually to find out shortest route from source to target."
                    },
                    {
                        "username": "glock17",
                        "content": "A lot of people are having trouble getting their heads around why are we moving from target to startValue.\nSo here I try to tell you the way I got to the solution.\n\n1. Multiplication is an independent operation irrespective of whether a number is even or odd, so it is a possibility that multiplication by 2 would overshoot our target by a large value and then to tone it down we would have to apply a large number of subtraction operations(as for this case only subtraction would be possible) to reach the target, which is an overkill.\n2. So the greedy approach aims at dividing the number by 2 only when it is possible, which was not the case with multiplication as we could have multiplied at any instance of time. As the target becomes less than the startValue then we simply do addition operations to reach the target value.\n\nHope it makes things clearer.\n\nMy python3 Solution:\nhttps://leetcode.com/problems/broken-calculator/solutions/3096648/python3-intuition-best-explanation-on-leetcode/"
                    },
                    {
                        "username": "crabbyD",
                        "content": "everyone in the discussion is having the same code in which they are changing the value of target and not the value of start.\\ncan anyone explain why everyone is doing so..."
                    },
                    {
                        "username": "Mars_Congressional_Republic",
                        "content": "I started off in that way and got stuck for a while. I guess the realization that made me switch is that you can only divide by 2 for even numbers, but multiplying by 2, you can do that for even or odd numbers so going backward seems more restricted than going forward."
                    },
                    {
                        "username": "livelearn",
                        "content": "Did other languages face the same time restrictions, felt like this was really tight."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.com/2019/02/10/Leetcode-991-Broken-Calculator/\\nHope helpful!"
                    },
                    {
                        "username": "phalkey89",
                        "content": "Question no \"991\"  is itself a series of calc being sold world wide.\\nlol !!"
                    }
                ]
            },
            {
                "id": 1567438,
                "content": [
                    {
                        "username": "fabregas2messi",
                        "content": "Hi guys,\\n\\nMy first intution for solving this problem was converting from X to Y, I ended up getting TLE or wrong answers. Most of the answers here I see have converting from Y to X. I dont understand how everyone got same intuition but me. Is there a chance that everyone is supermans here or you guys read top voted answers before designing your solution?"
                    },
                    {
                        "username": "RomaFed",
                        "content": "same question.. and if am not wrong, task says we should mutate start value, not target"
                    },
                    {
                        "username": "betaminc",
                        "content": "HAHAHHAHA"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/broken-calculator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Work Backwards\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghya",
                        "content": "My initial intitution was to update value of X to bring it closer to Y. \\n\\nI don\\'t understand what made you guys think of the \"work backward\" solution. What was the intituion behind modifying Y?\\nI am not asking for the solution here. Thanks"
                    },
                    {
                        "username": "krishnachanduakula",
                        "content": "I thought this is a DP question  and  i spanned two trees one with X-1 and other with X*2 \\nand return the minimum of both ,which reached Y fast. When  But i failed to understand its \\na greedy. How to decide if it is a greedy or DP?"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1 <= startValue, target <= 10^9 constraint screams it is not DP. But I\\'ve seen a problem that had such a constraint and had to be solved using DP with some trick."
                    },
                    {
                        "username": "Khwaja_Abdul_Samad",
                        "content": "in the DP approach when it will go with case -1 , it will create endless loop of only substracting one from itself as it will be moving away from target so DP is not a good option"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "I tried BFS approach starting from root, picked element from queue, performed multiply and subtract, push new value to queue.\\nRepeated the process till we reach target value, While pushing new element to queue keep updating steps count.\\n\\nBut ended up with TLE for worst case startValue=1, target=10000000\\n\\nSo BFS won\\'t work here.. Though its actually to find out shortest route from source to target."
                    },
                    {
                        "username": "glock17",
                        "content": "A lot of people are having trouble getting their heads around why are we moving from target to startValue.\nSo here I try to tell you the way I got to the solution.\n\n1. Multiplication is an independent operation irrespective of whether a number is even or odd, so it is a possibility that multiplication by 2 would overshoot our target by a large value and then to tone it down we would have to apply a large number of subtraction operations(as for this case only subtraction would be possible) to reach the target, which is an overkill.\n2. So the greedy approach aims at dividing the number by 2 only when it is possible, which was not the case with multiplication as we could have multiplied at any instance of time. As the target becomes less than the startValue then we simply do addition operations to reach the target value.\n\nHope it makes things clearer.\n\nMy python3 Solution:\nhttps://leetcode.com/problems/broken-calculator/solutions/3096648/python3-intuition-best-explanation-on-leetcode/"
                    },
                    {
                        "username": "crabbyD",
                        "content": "everyone in the discussion is having the same code in which they are changing the value of target and not the value of start.\\ncan anyone explain why everyone is doing so..."
                    },
                    {
                        "username": "Mars_Congressional_Republic",
                        "content": "I started off in that way and got stuck for a while. I guess the realization that made me switch is that you can only divide by 2 for even numbers, but multiplying by 2, you can do that for even or odd numbers so going backward seems more restricted than going forward."
                    },
                    {
                        "username": "livelearn",
                        "content": "Did other languages face the same time restrictions, felt like this was really tight."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.com/2019/02/10/Leetcode-991-Broken-Calculator/\\nHope helpful!"
                    },
                    {
                        "username": "phalkey89",
                        "content": "Question no \"991\"  is itself a series of calc being sold world wide.\\nlol !!"
                    }
                ]
            },
            {
                "id": 1828165,
                "content": [
                    {
                        "username": "fabregas2messi",
                        "content": "Hi guys,\\n\\nMy first intution for solving this problem was converting from X to Y, I ended up getting TLE or wrong answers. Most of the answers here I see have converting from Y to X. I dont understand how everyone got same intuition but me. Is there a chance that everyone is supermans here or you guys read top voted answers before designing your solution?"
                    },
                    {
                        "username": "RomaFed",
                        "content": "same question.. and if am not wrong, task says we should mutate start value, not target"
                    },
                    {
                        "username": "betaminc",
                        "content": "HAHAHHAHA"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/broken-calculator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Work Backwards\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghya",
                        "content": "My initial intitution was to update value of X to bring it closer to Y. \\n\\nI don\\'t understand what made you guys think of the \"work backward\" solution. What was the intituion behind modifying Y?\\nI am not asking for the solution here. Thanks"
                    },
                    {
                        "username": "krishnachanduakula",
                        "content": "I thought this is a DP question  and  i spanned two trees one with X-1 and other with X*2 \\nand return the minimum of both ,which reached Y fast. When  But i failed to understand its \\na greedy. How to decide if it is a greedy or DP?"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1 <= startValue, target <= 10^9 constraint screams it is not DP. But I\\'ve seen a problem that had such a constraint and had to be solved using DP with some trick."
                    },
                    {
                        "username": "Khwaja_Abdul_Samad",
                        "content": "in the DP approach when it will go with case -1 , it will create endless loop of only substracting one from itself as it will be moving away from target so DP is not a good option"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "I tried BFS approach starting from root, picked element from queue, performed multiply and subtract, push new value to queue.\\nRepeated the process till we reach target value, While pushing new element to queue keep updating steps count.\\n\\nBut ended up with TLE for worst case startValue=1, target=10000000\\n\\nSo BFS won\\'t work here.. Though its actually to find out shortest route from source to target."
                    },
                    {
                        "username": "glock17",
                        "content": "A lot of people are having trouble getting their heads around why are we moving from target to startValue.\nSo here I try to tell you the way I got to the solution.\n\n1. Multiplication is an independent operation irrespective of whether a number is even or odd, so it is a possibility that multiplication by 2 would overshoot our target by a large value and then to tone it down we would have to apply a large number of subtraction operations(as for this case only subtraction would be possible) to reach the target, which is an overkill.\n2. So the greedy approach aims at dividing the number by 2 only when it is possible, which was not the case with multiplication as we could have multiplied at any instance of time. As the target becomes less than the startValue then we simply do addition operations to reach the target value.\n\nHope it makes things clearer.\n\nMy python3 Solution:\nhttps://leetcode.com/problems/broken-calculator/solutions/3096648/python3-intuition-best-explanation-on-leetcode/"
                    },
                    {
                        "username": "crabbyD",
                        "content": "everyone in the discussion is having the same code in which they are changing the value of target and not the value of start.\\ncan anyone explain why everyone is doing so..."
                    },
                    {
                        "username": "Mars_Congressional_Republic",
                        "content": "I started off in that way and got stuck for a while. I guess the realization that made me switch is that you can only divide by 2 for even numbers, but multiplying by 2, you can do that for even or odd numbers so going backward seems more restricted than going forward."
                    },
                    {
                        "username": "livelearn",
                        "content": "Did other languages face the same time restrictions, felt like this was really tight."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.com/2019/02/10/Leetcode-991-Broken-Calculator/\\nHope helpful!"
                    },
                    {
                        "username": "phalkey89",
                        "content": "Question no \"991\"  is itself a series of calc being sold world wide.\\nlol !!"
                    }
                ]
            },
            {
                "id": 1773654,
                "content": [
                    {
                        "username": "fabregas2messi",
                        "content": "Hi guys,\\n\\nMy first intution for solving this problem was converting from X to Y, I ended up getting TLE or wrong answers. Most of the answers here I see have converting from Y to X. I dont understand how everyone got same intuition but me. Is there a chance that everyone is supermans here or you guys read top voted answers before designing your solution?"
                    },
                    {
                        "username": "RomaFed",
                        "content": "same question.. and if am not wrong, task says we should mutate start value, not target"
                    },
                    {
                        "username": "betaminc",
                        "content": "HAHAHHAHA"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/broken-calculator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Work Backwards\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghya",
                        "content": "My initial intitution was to update value of X to bring it closer to Y. \\n\\nI don\\'t understand what made you guys think of the \"work backward\" solution. What was the intituion behind modifying Y?\\nI am not asking for the solution here. Thanks"
                    },
                    {
                        "username": "krishnachanduakula",
                        "content": "I thought this is a DP question  and  i spanned two trees one with X-1 and other with X*2 \\nand return the minimum of both ,which reached Y fast. When  But i failed to understand its \\na greedy. How to decide if it is a greedy or DP?"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1 <= startValue, target <= 10^9 constraint screams it is not DP. But I\\'ve seen a problem that had such a constraint and had to be solved using DP with some trick."
                    },
                    {
                        "username": "Khwaja_Abdul_Samad",
                        "content": "in the DP approach when it will go with case -1 , it will create endless loop of only substracting one from itself as it will be moving away from target so DP is not a good option"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "I tried BFS approach starting from root, picked element from queue, performed multiply and subtract, push new value to queue.\\nRepeated the process till we reach target value, While pushing new element to queue keep updating steps count.\\n\\nBut ended up with TLE for worst case startValue=1, target=10000000\\n\\nSo BFS won\\'t work here.. Though its actually to find out shortest route from source to target."
                    },
                    {
                        "username": "glock17",
                        "content": "A lot of people are having trouble getting their heads around why are we moving from target to startValue.\nSo here I try to tell you the way I got to the solution.\n\n1. Multiplication is an independent operation irrespective of whether a number is even or odd, so it is a possibility that multiplication by 2 would overshoot our target by a large value and then to tone it down we would have to apply a large number of subtraction operations(as for this case only subtraction would be possible) to reach the target, which is an overkill.\n2. So the greedy approach aims at dividing the number by 2 only when it is possible, which was not the case with multiplication as we could have multiplied at any instance of time. As the target becomes less than the startValue then we simply do addition operations to reach the target value.\n\nHope it makes things clearer.\n\nMy python3 Solution:\nhttps://leetcode.com/problems/broken-calculator/solutions/3096648/python3-intuition-best-explanation-on-leetcode/"
                    },
                    {
                        "username": "crabbyD",
                        "content": "everyone in the discussion is having the same code in which they are changing the value of target and not the value of start.\\ncan anyone explain why everyone is doing so..."
                    },
                    {
                        "username": "Mars_Congressional_Republic",
                        "content": "I started off in that way and got stuck for a while. I guess the realization that made me switch is that you can only divide by 2 for even numbers, but multiplying by 2, you can do that for even or odd numbers so going backward seems more restricted than going forward."
                    },
                    {
                        "username": "livelearn",
                        "content": "Did other languages face the same time restrictions, felt like this was really tight."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.com/2019/02/10/Leetcode-991-Broken-Calculator/\\nHope helpful!"
                    },
                    {
                        "username": "phalkey89",
                        "content": "Question no \"991\"  is itself a series of calc being sold world wide.\\nlol !!"
                    }
                ]
            },
            {
                "id": 1570826,
                "content": [
                    {
                        "username": "fabregas2messi",
                        "content": "Hi guys,\\n\\nMy first intution for solving this problem was converting from X to Y, I ended up getting TLE or wrong answers. Most of the answers here I see have converting from Y to X. I dont understand how everyone got same intuition but me. Is there a chance that everyone is supermans here or you guys read top voted answers before designing your solution?"
                    },
                    {
                        "username": "RomaFed",
                        "content": "same question.. and if am not wrong, task says we should mutate start value, not target"
                    },
                    {
                        "username": "betaminc",
                        "content": "HAHAHHAHA"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/broken-calculator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Work Backwards\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghya",
                        "content": "My initial intitution was to update value of X to bring it closer to Y. \\n\\nI don\\'t understand what made you guys think of the \"work backward\" solution. What was the intituion behind modifying Y?\\nI am not asking for the solution here. Thanks"
                    },
                    {
                        "username": "krishnachanduakula",
                        "content": "I thought this is a DP question  and  i spanned two trees one with X-1 and other with X*2 \\nand return the minimum of both ,which reached Y fast. When  But i failed to understand its \\na greedy. How to decide if it is a greedy or DP?"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1 <= startValue, target <= 10^9 constraint screams it is not DP. But I\\'ve seen a problem that had such a constraint and had to be solved using DP with some trick."
                    },
                    {
                        "username": "Khwaja_Abdul_Samad",
                        "content": "in the DP approach when it will go with case -1 , it will create endless loop of only substracting one from itself as it will be moving away from target so DP is not a good option"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "I tried BFS approach starting from root, picked element from queue, performed multiply and subtract, push new value to queue.\\nRepeated the process till we reach target value, While pushing new element to queue keep updating steps count.\\n\\nBut ended up with TLE for worst case startValue=1, target=10000000\\n\\nSo BFS won\\'t work here.. Though its actually to find out shortest route from source to target."
                    },
                    {
                        "username": "glock17",
                        "content": "A lot of people are having trouble getting their heads around why are we moving from target to startValue.\nSo here I try to tell you the way I got to the solution.\n\n1. Multiplication is an independent operation irrespective of whether a number is even or odd, so it is a possibility that multiplication by 2 would overshoot our target by a large value and then to tone it down we would have to apply a large number of subtraction operations(as for this case only subtraction would be possible) to reach the target, which is an overkill.\n2. So the greedy approach aims at dividing the number by 2 only when it is possible, which was not the case with multiplication as we could have multiplied at any instance of time. As the target becomes less than the startValue then we simply do addition operations to reach the target value.\n\nHope it makes things clearer.\n\nMy python3 Solution:\nhttps://leetcode.com/problems/broken-calculator/solutions/3096648/python3-intuition-best-explanation-on-leetcode/"
                    },
                    {
                        "username": "crabbyD",
                        "content": "everyone in the discussion is having the same code in which they are changing the value of target and not the value of start.\\ncan anyone explain why everyone is doing so..."
                    },
                    {
                        "username": "Mars_Congressional_Republic",
                        "content": "I started off in that way and got stuck for a while. I guess the realization that made me switch is that you can only divide by 2 for even numbers, but multiplying by 2, you can do that for even or odd numbers so going backward seems more restricted than going forward."
                    },
                    {
                        "username": "livelearn",
                        "content": "Did other languages face the same time restrictions, felt like this was really tight."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.com/2019/02/10/Leetcode-991-Broken-Calculator/\\nHope helpful!"
                    },
                    {
                        "username": "phalkey89",
                        "content": "Question no \"991\"  is itself a series of calc being sold world wide.\\nlol !!"
                    }
                ]
            },
            {
                "id": 1567364,
                "content": [
                    {
                        "username": "fabregas2messi",
                        "content": "Hi guys,\\n\\nMy first intution for solving this problem was converting from X to Y, I ended up getting TLE or wrong answers. Most of the answers here I see have converting from Y to X. I dont understand how everyone got same intuition but me. Is there a chance that everyone is supermans here or you guys read top voted answers before designing your solution?"
                    },
                    {
                        "username": "RomaFed",
                        "content": "same question.. and if am not wrong, task says we should mutate start value, not target"
                    },
                    {
                        "username": "betaminc",
                        "content": "HAHAHHAHA"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/broken-calculator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Work Backwards\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghya",
                        "content": "My initial intitution was to update value of X to bring it closer to Y. \\n\\nI don\\'t understand what made you guys think of the \"work backward\" solution. What was the intituion behind modifying Y?\\nI am not asking for the solution here. Thanks"
                    },
                    {
                        "username": "krishnachanduakula",
                        "content": "I thought this is a DP question  and  i spanned two trees one with X-1 and other with X*2 \\nand return the minimum of both ,which reached Y fast. When  But i failed to understand its \\na greedy. How to decide if it is a greedy or DP?"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1 <= startValue, target <= 10^9 constraint screams it is not DP. But I\\'ve seen a problem that had such a constraint and had to be solved using DP with some trick."
                    },
                    {
                        "username": "Khwaja_Abdul_Samad",
                        "content": "in the DP approach when it will go with case -1 , it will create endless loop of only substracting one from itself as it will be moving away from target so DP is not a good option"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "I tried BFS approach starting from root, picked element from queue, performed multiply and subtract, push new value to queue.\\nRepeated the process till we reach target value, While pushing new element to queue keep updating steps count.\\n\\nBut ended up with TLE for worst case startValue=1, target=10000000\\n\\nSo BFS won\\'t work here.. Though its actually to find out shortest route from source to target."
                    },
                    {
                        "username": "glock17",
                        "content": "A lot of people are having trouble getting their heads around why are we moving from target to startValue.\nSo here I try to tell you the way I got to the solution.\n\n1. Multiplication is an independent operation irrespective of whether a number is even or odd, so it is a possibility that multiplication by 2 would overshoot our target by a large value and then to tone it down we would have to apply a large number of subtraction operations(as for this case only subtraction would be possible) to reach the target, which is an overkill.\n2. So the greedy approach aims at dividing the number by 2 only when it is possible, which was not the case with multiplication as we could have multiplied at any instance of time. As the target becomes less than the startValue then we simply do addition operations to reach the target value.\n\nHope it makes things clearer.\n\nMy python3 Solution:\nhttps://leetcode.com/problems/broken-calculator/solutions/3096648/python3-intuition-best-explanation-on-leetcode/"
                    },
                    {
                        "username": "crabbyD",
                        "content": "everyone in the discussion is having the same code in which they are changing the value of target and not the value of start.\\ncan anyone explain why everyone is doing so..."
                    },
                    {
                        "username": "Mars_Congressional_Republic",
                        "content": "I started off in that way and got stuck for a while. I guess the realization that made me switch is that you can only divide by 2 for even numbers, but multiplying by 2, you can do that for even or odd numbers so going backward seems more restricted than going forward."
                    },
                    {
                        "username": "livelearn",
                        "content": "Did other languages face the same time restrictions, felt like this was really tight."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.com/2019/02/10/Leetcode-991-Broken-Calculator/\\nHope helpful!"
                    },
                    {
                        "username": "phalkey89",
                        "content": "Question no \"991\"  is itself a series of calc being sold world wide.\\nlol !!"
                    }
                ]
            },
            {
                "id": 1566853,
                "content": [
                    {
                        "username": "fabregas2messi",
                        "content": "Hi guys,\\n\\nMy first intution for solving this problem was converting from X to Y, I ended up getting TLE or wrong answers. Most of the answers here I see have converting from Y to X. I dont understand how everyone got same intuition but me. Is there a chance that everyone is supermans here or you guys read top voted answers before designing your solution?"
                    },
                    {
                        "username": "RomaFed",
                        "content": "same question.. and if am not wrong, task says we should mutate start value, not target"
                    },
                    {
                        "username": "betaminc",
                        "content": "HAHAHHAHA"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/broken-calculator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Work Backwards\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghya",
                        "content": "My initial intitution was to update value of X to bring it closer to Y. \\n\\nI don\\'t understand what made you guys think of the \"work backward\" solution. What was the intituion behind modifying Y?\\nI am not asking for the solution here. Thanks"
                    },
                    {
                        "username": "krishnachanduakula",
                        "content": "I thought this is a DP question  and  i spanned two trees one with X-1 and other with X*2 \\nand return the minimum of both ,which reached Y fast. When  But i failed to understand its \\na greedy. How to decide if it is a greedy or DP?"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1 <= startValue, target <= 10^9 constraint screams it is not DP. But I\\'ve seen a problem that had such a constraint and had to be solved using DP with some trick."
                    },
                    {
                        "username": "Khwaja_Abdul_Samad",
                        "content": "in the DP approach when it will go with case -1 , it will create endless loop of only substracting one from itself as it will be moving away from target so DP is not a good option"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "I tried BFS approach starting from root, picked element from queue, performed multiply and subtract, push new value to queue.\\nRepeated the process till we reach target value, While pushing new element to queue keep updating steps count.\\n\\nBut ended up with TLE for worst case startValue=1, target=10000000\\n\\nSo BFS won\\'t work here.. Though its actually to find out shortest route from source to target."
                    },
                    {
                        "username": "glock17",
                        "content": "A lot of people are having trouble getting their heads around why are we moving from target to startValue.\nSo here I try to tell you the way I got to the solution.\n\n1. Multiplication is an independent operation irrespective of whether a number is even or odd, so it is a possibility that multiplication by 2 would overshoot our target by a large value and then to tone it down we would have to apply a large number of subtraction operations(as for this case only subtraction would be possible) to reach the target, which is an overkill.\n2. So the greedy approach aims at dividing the number by 2 only when it is possible, which was not the case with multiplication as we could have multiplied at any instance of time. As the target becomes less than the startValue then we simply do addition operations to reach the target value.\n\nHope it makes things clearer.\n\nMy python3 Solution:\nhttps://leetcode.com/problems/broken-calculator/solutions/3096648/python3-intuition-best-explanation-on-leetcode/"
                    },
                    {
                        "username": "crabbyD",
                        "content": "everyone in the discussion is having the same code in which they are changing the value of target and not the value of start.\\ncan anyone explain why everyone is doing so..."
                    },
                    {
                        "username": "Mars_Congressional_Republic",
                        "content": "I started off in that way and got stuck for a while. I guess the realization that made me switch is that you can only divide by 2 for even numbers, but multiplying by 2, you can do that for even or odd numbers so going backward seems more restricted than going forward."
                    },
                    {
                        "username": "livelearn",
                        "content": "Did other languages face the same time restrictions, felt like this was really tight."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.com/2019/02/10/Leetcode-991-Broken-Calculator/\\nHope helpful!"
                    },
                    {
                        "username": "phalkey89",
                        "content": "Question no \"991\"  is itself a series of calc being sold world wide.\\nlol !!"
                    }
                ]
            },
            {
                "id": 1983290,
                "content": [
                    {
                        "username": "fabregas2messi",
                        "content": "Hi guys,\\n\\nMy first intution for solving this problem was converting from X to Y, I ended up getting TLE or wrong answers. Most of the answers here I see have converting from Y to X. I dont understand how everyone got same intuition but me. Is there a chance that everyone is supermans here or you guys read top voted answers before designing your solution?"
                    },
                    {
                        "username": "RomaFed",
                        "content": "same question.. and if am not wrong, task says we should mutate start value, not target"
                    },
                    {
                        "username": "betaminc",
                        "content": "HAHAHHAHA"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/broken-calculator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Work Backwards\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghya",
                        "content": "My initial intitution was to update value of X to bring it closer to Y. \\n\\nI don\\'t understand what made you guys think of the \"work backward\" solution. What was the intituion behind modifying Y?\\nI am not asking for the solution here. Thanks"
                    },
                    {
                        "username": "krishnachanduakula",
                        "content": "I thought this is a DP question  and  i spanned two trees one with X-1 and other with X*2 \\nand return the minimum of both ,which reached Y fast. When  But i failed to understand its \\na greedy. How to decide if it is a greedy or DP?"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1 <= startValue, target <= 10^9 constraint screams it is not DP. But I\\'ve seen a problem that had such a constraint and had to be solved using DP with some trick."
                    },
                    {
                        "username": "Khwaja_Abdul_Samad",
                        "content": "in the DP approach when it will go with case -1 , it will create endless loop of only substracting one from itself as it will be moving away from target so DP is not a good option"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "I tried BFS approach starting from root, picked element from queue, performed multiply and subtract, push new value to queue.\\nRepeated the process till we reach target value, While pushing new element to queue keep updating steps count.\\n\\nBut ended up with TLE for worst case startValue=1, target=10000000\\n\\nSo BFS won\\'t work here.. Though its actually to find out shortest route from source to target."
                    },
                    {
                        "username": "glock17",
                        "content": "A lot of people are having trouble getting their heads around why are we moving from target to startValue.\nSo here I try to tell you the way I got to the solution.\n\n1. Multiplication is an independent operation irrespective of whether a number is even or odd, so it is a possibility that multiplication by 2 would overshoot our target by a large value and then to tone it down we would have to apply a large number of subtraction operations(as for this case only subtraction would be possible) to reach the target, which is an overkill.\n2. So the greedy approach aims at dividing the number by 2 only when it is possible, which was not the case with multiplication as we could have multiplied at any instance of time. As the target becomes less than the startValue then we simply do addition operations to reach the target value.\n\nHope it makes things clearer.\n\nMy python3 Solution:\nhttps://leetcode.com/problems/broken-calculator/solutions/3096648/python3-intuition-best-explanation-on-leetcode/"
                    },
                    {
                        "username": "crabbyD",
                        "content": "everyone in the discussion is having the same code in which they are changing the value of target and not the value of start.\\ncan anyone explain why everyone is doing so..."
                    },
                    {
                        "username": "Mars_Congressional_Republic",
                        "content": "I started off in that way and got stuck for a while. I guess the realization that made me switch is that you can only divide by 2 for even numbers, but multiplying by 2, you can do that for even or odd numbers so going backward seems more restricted than going forward."
                    },
                    {
                        "username": "livelearn",
                        "content": "Did other languages face the same time restrictions, felt like this was really tight."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.com/2019/02/10/Leetcode-991-Broken-Calculator/\\nHope helpful!"
                    },
                    {
                        "username": "phalkey89",
                        "content": "Question no \"991\"  is itself a series of calc being sold world wide.\\nlol !!"
                    }
                ]
            }
        ]
    },
    {
        "title": "Build an Array With Stack Operations",
        "question_content": "<p>You are given an integer array <code>target</code> and an integer <code>n</code>.</p>\n\n<p>You have an empty stack with the two following operations:</p>\n\n<ul>\n\t<li><strong><code>&quot;Push&quot;</code></strong>: pushes an integer to the top of the stack.</li>\n\t<li><strong><code>&quot;Pop&quot;</code></strong>: removes the integer on the top of the stack.</li>\n</ul>\n\n<p>You also have a stream of the integers in the range <code>[1, n]</code>.</p>\n\n<p>Use the two stack operations to make the numbers in the stack (from the bottom to the top) equal to <code>target</code>. You should follow the following rules:</p>\n\n<ul>\n\t<li>If the stream of the integers is not empty, pick the next integer from the stream and push it to the top of the stack.</li>\n\t<li>If the stack is not empty, pop the integer at the top of the stack.</li>\n\t<li>If, at any moment, the elements in the stack (from the bottom to the top) are equal to <code>target</code>, do not read new integers from the stream and do not do more operations on the stack.</li>\n</ul>\n\n<p>Return <em>the stack operations needed to build </em><code>target</code> following the mentioned rules. If there are multiple valid answers, return <strong>any of them</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> target = [1,3], n = 3\n<strong>Output:</strong> [&quot;Push&quot;,&quot;Push&quot;,&quot;Pop&quot;,&quot;Push&quot;]\n<strong>Explanation:</strong> Initially the stack s is empty. The last element is the top of the stack.\nRead 1 from the stream and push it to the stack. s = [1].\nRead 2 from the stream and push it to the stack. s = [1,2].\nPop the integer on the top of the stack. s = [1].\nRead 3 from the stream and push it to the stack. s = [1,3].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> target = [1,2,3], n = 3\n<strong>Output:</strong> [&quot;Push&quot;,&quot;Push&quot;,&quot;Push&quot;]\n<strong>Explanation:</strong> Initially the stack s is empty. The last element is the top of the stack.\nRead 1 from the stream and push it to the stack. s = [1].\nRead 2 from the stream and push it to the stack. s = [1,2].\nRead 3 from the stream and push it to the stack. s = [1,2,3].\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> target = [1,2], n = 4\n<strong>Output:</strong> [&quot;Push&quot;,&quot;Push&quot;]\n<strong>Explanation:</strong> Initially the stack s is empty. The last element is the top of the stack.\nRead 1 from the stream and push it to the stack. s = [1].\nRead 2 from the stream and push it to the stack. s = [1,2].\nSince the stack (from the bottom to the top) is equal to target, we stop the stack operations.\nThe answers that read integer 3 from the stream are not accepted.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= target.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= target[i] &lt;= n</code></li>\n\t<li><code>target</code> is strictly increasing.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 626959,
                "title": "python-simple-faster-than-99",
                "content": "<b>Time Complexity:</b> O(N)\\n<b>Runtime:</b> Faster than 99% <i>(as of May 11th, 2020)</i>\\n<b>Memory Usage:</b> Less than 100% \\n<b>Explanation:</b>\\nStep 1: Create an empty list ```res``` to store the result.\\nStep 2: Add the elements of the input array ```target``` to a set to improve lookup performance. \\nStep 3: Iterate through the integers of ```target``` and add \"Push\" to the ```res``` list for each integer ```in range(1, target[-1] + 1)```. Then, add \"Pop\" if the integer is <b>not</b> in the set.\\nStep 4: Return the result.\\n\\n<i>* Note: The ```n``` parameter is not used in this approach.</i> \\n```\\ndef solution(target, n):\\n    res = []\\n\\ts = set(target)\\n    for i in range(1, target[-1] + 1):\\n        res.append(\"Push\")\\n        if i not in s:\\n            res.append(\"Pop\")\\n    return res\\n```\\nIf you like my solution and/or find it useful, please upvote :) Thank you.",
                "solutionTags": [],
                "code": "```res```\n```target```\n```target```\n```res```\n```in range(1, target[-1] + 1)```\n```n```\n```\\ndef solution(target, n):\\n    res = []\\n\\ts = set(target)\\n    for i in range(1, target[-1] + 1):\\n        res.append(\"Push\")\\n        if i not in s:\\n            res.append(\"Pop\")\\n    return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 624278,
                "title": "java-simple-check",
                "content": "```\\npublic List<String> buildArray(int[] target, int n) {\\n        List<String> result = new ArrayList<>();\\n        int j=0;\\n        for (int i=1;i<=n && j<target.length;i++) {\\n            result.add(\"Push\");\\n            if(target[j]==i) {\\n                j++;\\n            } else {\\n                result.add(\"Pop\");\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<String> buildArray(int[] target, int n) {\\n        List<String> result = new ArrayList<>();\\n        int j=0;\\n        for (int i=1;i<=n && j<target.length;i++) {\\n            result.add(\"Push\");\\n            if(target[j]==i) {\\n                j++;\\n            } else {\\n                result.add(\"Pop\");\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 627077,
                "title": "c-easy-to-understand-4ms-solution-o-n-well-commented",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string> ans;\\n        int currElem=1; //Current Element tells the element to be added in the stack, first element added will be 1\\n        for(int i=0;i<target.size();i++){\\n            while(currElem!=target[i]){ //While we do not make current element equal to corresponding element in target array \\n                ans.push_back(\"Push\");  //We will simply push and pop those elements which are not in final target array\\n                ans.push_back(\"Pop\");\\n                currElem++;\\n            }\\n            ans.push_back(\"Push\"); //Pushing the target element in stack \\n            currElem++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string> ans;\\n        int currElem=1; //Current Element tells the element to be added in the stack, first element added will be 1\\n        for(int i=0;i<target.size();i++){\\n            while(currElem!=target[i]){ //While we do not make current element equal to corresponding element in target array \\n                ans.push_back(\"Push\");  //We will simply push and pop those elements which are not in final target array\\n                ans.push_back(\"Pop\");\\n                currElem++;\\n            }\\n            ans.push_back(\"Push\"); //Pushing the target element in stack \\n            currElem++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1264243,
                "title": "c-using-loops-easy-solution-0ms-beats-100-00-clean-code",
                "content": "**Explaination**\\n\\nStart with `num=1`\\nIgnore value of n and build target array.\\nFor every value that is not present : insert \"Push\" & insert \"Pop\" once for each\\nAfter you get the matching value : insert \"Push\" for once\\n\\n\\n**Complexity**\\n\\nTime `O(n)`\\nSpace `O(n)`\\n\\n**C++ Code**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string> res;\\n        string ph = \"Push\";\\n        string pp = \"Pop\";\\n        int num = 1;\\n        for(int i=0; i<target.size(); i++) {\\n            while(num!=target[i]) {\\n                num++;\\n                res.push_back(\"Push\");\\n                res.push_back(\"Pop\");\\n            }\\n            res.push_back(\"Push\");\\n            num++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string> res;\\n        string ph = \"Push\";\\n        string pp = \"Pop\";\\n        int num = 1;\\n        for(int i=0; i<target.size(); i++) {\\n            while(num!=target[i]) {\\n                num++;\\n                res.push_back(\"Push\");\\n                res.push_back(\"Pop\");\\n            }\\n            res.push_back(\"Push\");\\n            num++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 631337,
                "title": "javascript-easy-to-understand-o-n-time",
                "content": "According to the description, we should build the array from `target` with stack operation. So, for every element, we must do `Push` first. And at last, if it\\'s not in the `target` array, we should do `Pop`.\\n\\nBut if we search value in `target` array, it will cost O(logn) via binary search. Or we could use extra O(n) space to make it to be O(1). Could we don\\'t do the search to make the whole strategy O(n) time and O(1) space?\\n\\nYep, sure. We could use 2 variables - one for traversal `target` array, another one for current increasing value. Then we just need to maintain them and push the `Pop` via compare if they are equal.\\n\\n```js\\nconst buildArray = (target, n) => {\\n  const ret = [];\\n  for (let i = 0, j = 1; i < target.length; ++i, ++j) {\\n    ret.push(\\'Push\\');\\n    target[i] !== j && ret.push(\\'Pop\\') && --i;\\n  }\\n  return ret;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst buildArray = (target, n) => {\\n  const ret = [];\\n  for (let i = 0, j = 1; i < target.length; ++i, ++j) {\\n    ret.push(\\'Push\\');\\n    target[i] !== j && ret.push(\\'Pop\\') && --i;\\n  }\\n  return ret;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 625224,
                "title": "python-24ms-100-faster",
                "content": "```\\nclass Solution:\\n    def buildArray(self, target: List[int], n: int) -> List[str]:\\n        initialValue = 1\\n        output = []\\n        for number in target:\\n            output.extend([\"Push\",\"Pop\"]*(number - initialValue) + [\"Push\"])\\n            initialValue = number + 1\\n        return output\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def buildArray(self, target: List[int], n: int) -> List[str]:\\n        initialValue = 1\\n        output = []\\n        for number in target:\\n            output.extend([\"Push\",\"Pop\"]*(number - initialValue) + [\"Push\"])\\n            initialValue = number + 1\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 623833,
                "title": "java-1ms-100-faster-clean-and-simple-code",
                "content": "Idea is just try to check array element and compare with first N number until array or N.\\nIf number exit in array that means no `Pop` operation on that number else `Push` and `Pop` both operation on that number.\\n\\nTC - O(N)\\n\\n```\\nclass Solution {\\n    public List<String> buildArray(int[] target, int n) {\\n        List<String> list = new ArrayList();\\n        int i = 0;\\n        int j = 0;\\n        while(i++ <= n && j < target.length) {\\n            list.add(\"Push\");\\n            if(target[j] == i) j++;\\n            else list.add(\"Pop\");\\n        }\\n        \\n        return list;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> buildArray(int[] target, int n) {\\n        List<String> list = new ArrayList();\\n        int i = 0;\\n        int j = 0;\\n        while(i++ <= n && j < target.length) {\\n            list.add(\"Push\");\\n            if(target[j] == i) j++;\\n            else list.add(\"Pop\");\\n        }\\n        \\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 623737,
                "title": "clean-python-3-generator",
                "content": "Just a two pointers approach with generator.\\nTime: `O(N)`\\nSpace: `O(N)` for output\\n```\\nclass Solution:\\n    def buildArray(self, target: List[int], n: int) -> List[str]:\\n        def build():\\n            curr = 1\\n            for num in target:\\n                yield \\'Push\\'\\n                while curr < num:\\n                    yield from (\\'Pop\\', \\'Push\\')\\n                    curr += 1\\n                curr += 1\\n        return list(build())\\n```\\n--\\nUpdate: only `for` version\\n```\\nclass Solution:\\n    def buildArray(self, target: List[int], n: int) -> List[str]:\\n        curr, result = 1, []\\n        for num in target:\\n            result += [\\'Push\\'] + [\\'Pop\\', \\'Push\\'] * (num - curr)\\n            curr = num + 1\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def buildArray(self, target: List[int], n: int) -> List[str]:\\n        def build():\\n            curr = 1\\n            for num in target:\\n                yield \\'Push\\'\\n                while curr < num:\\n                    yield from (\\'Pop\\', \\'Push\\')\\n                    curr += 1\\n                curr += 1\\n        return list(build())\\n```\n```\\nclass Solution:\\n    def buildArray(self, target: List[int], n: int) -> List[str]:\\n        curr, result = 1, []\\n        for num in target:\\n            result += [\\'Push\\'] + [\\'Pop\\', \\'Push\\'] * (num - curr)\\n            curr = num + 1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1501381,
                "title": "c-0ms-beginner-friendly-easy-highly-readable",
                "content": "![image](https://assets.leetcode.com/users/images/f5c5a56c-3414-4ba1-b896-76ef9e2d9615_1633275657.0826395.png)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        \\n        vector<string> ans;\\n        \\n        int idx = 1, pos = 0;\\n        while( pos < target.size()){\\n            ans.push_back(\"Push\");\\n            \\n            if(target[pos] == idx)\\n                pos++;\\n            else \\n                ans.push_back(\"Pop\");\\n            \\n            idx++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n\\nHope you liked it , kindly upvote !!\\n\\nHappy Coding \\uD83E\\uDD17",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        \\n        vector<string> ans;\\n        \\n        int idx = 1, pos = 0;\\n        while( pos < target.size()){\\n            ans.push_back(\"Push\");\\n            \\n            if(target[pos] == idx)\\n                pos++;\\n            else \\n                ans.push_back(\"Pop\");\\n            \\n            idx++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1726787,
                "title": "c-one-pass-solution-o-n-100-fast",
                "content": "\\n```\\n vector<string>a;int t=0;\\n        for(int i =0;i<target.size();)\\n        {   a.push_back(\"Push\");\\n            if(target[i]!=++t)a.push_back(\"Pop\");\\n            else i++;\\n        }\\n        return a;\\n```",
                "solutionTags": [],
                "code": "```\\n vector<string>a;int t=0;\\n        for(int i =0;i<target.size();)\\n        {   a.push_back(\"Push\");\\n            if(target[i]!=++t)a.push_back(\"Pop\");\\n            else i++;\\n        }\\n        return a;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1291707,
                "title": "easy-python-solution-96-97",
                "content": "Runtime: 24 ms, faster than 96.97% of Python3 online submissions for Build an Array With Stack Operations.\\nMemory Usage: 14.3 MB, less than 47.78% of Python3 online submissions for Build an Array With Stack Operations.\\n```\\nclass Solution:\\n    def buildArray(self, target: List[int], n: int) -> List[str]:\\n        stack=[]\\n        for i in range(1,n+1):\\n            if(i in target):\\n                stack.append(\"Push\")\\n            else:\\n                stack.append(\"Push\")\\n                stack.append(\"Pop\")\\n            if(i==(target[-1])):\\n                break\\n        return stack",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Runtime: 24 ms, faster than 96.97% of Python3 online submissions for Build an Array With Stack Operations.\\nMemory Usage: 14.3 MB, less than 47.78% of Python3 online submissions for Build an Array With Stack Operations.\\n```\\nclass Solution:\\n    def buildArray(self, target: List[int], n: int) -> List[str]:\\n        stack=[]\\n        for i in range(1,n+1):\\n            if(i in target):\\n                stack.append(\"Push\")\\n            else:\\n                stack.append(\"Push\")\\n                stack.append(\"Pop\")\\n            if(i==(target[-1])):\\n                break\\n        return stack",
                "codeTag": "Java"
            },
            {
                "id": 2667448,
                "title": "c-easy-to-understand-faster-than-100",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n            vector<string> x;\\n            int ind = 0;\\n            for(int i = 1; i<=n;i++){\\n                    x.push_back(\"Push\");\\n                    if(i == target[ind])\\n                       ind++;\\n                       \\n                       else\\n                       x.push_back(\"Pop\");\\n                       \\n                       if(ind == target.size())\\n                       break;\\n            }\\n                       return x;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Array",
                    "Stack",
                    "Binary Tree"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2607302,
                "title": "c-greedy-with-comments-fast-0ms",
                "content": "### Solution 1: greedy\\n\\nSee inline comments for how this works.\\n\\n```\\n    static vector<string> buildArray(const vector<int>& target, const int n) {\\n        vector<string> ans;\\n        // If target is only [n], we need to push/pop all other numbers.\\n        ans.reserve(2 * n);  \\n        \\n        // The |curr|ent number from the stream {1 .. n}.\\n        int curr = 1;\\n        for (const int num : target) {\\n            // If the next number in the target |num| is bigger than the |curr|ent \\n            // number from the stream we need to push and pop it.\\n            while (num > curr) {\\n                ans.emplace_back(\"Push\");\\n                ans.emplace_back(\"Pop\");\\n                ++curr;\\n            }\\n            // |curr| is equal to the next number |num| in |target|. Push it.\\n            // assert(num == curr);\\n            ans.emplace_back(\"Push\");\\n            ++curr;\\n        }\\n        \\n        return ans;\\n    }\\n```\\n\\n**Complexity Analsis**\\n * Time Complexity: O(n)\\n  * Space Complexity: O(n)\\n\\n### Further Comments\\n\\n#### header\\n\\nIn all my submission I am using a header like the following to speed up IO:\\n```\\n// https://leetcode.com/problems/build-an-array-with-stack-operations/\\n// problem: 1441\\nstatic int fast_io = []() { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); return 0; }();\\n```\\n\\n#### static\\n\\nYou may wonder why I am making the method ```static```. It\\'s not using any member variables and I\\'d like to make this explit. This also means no implict ```this``` pointer is passed around.\\n\\n#### const\\n\\nI like making things ```const``` to make it explict that I don\\'t intend to modify this variable. The compiler can be a better partner to spot bugs in your code with that.\\n\\n_As always: Feedback, comments, and questions are welcome. Please upvote if you like the post._\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/Nqm4jJcyBf)!**\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\n    static vector<string> buildArray(const vector<int>& target, const int n) {\\n        vector<string> ans;\\n        // If target is only [n], we need to push/pop all other numbers.\\n        ans.reserve(2 * n);  \\n        \\n        // The |curr|ent number from the stream {1 .. n}.\\n        int curr = 1;\\n        for (const int num : target) {\\n            // If the next number in the target |num| is bigger than the |curr|ent \\n            // number from the stream we need to push and pop it.\\n            while (num > curr) {\\n                ans.emplace_back(\"Push\");\\n                ans.emplace_back(\"Pop\");\\n                ++curr;\\n            }\\n            // |curr| is equal to the next number |num| in |target|. Push it.\\n            // assert(num == curr);\\n            ans.emplace_back(\"Push\");\\n            ++curr;\\n        }\\n        \\n        return ans;\\n    }\\n```\n```\\n// https://leetcode.com/problems/build-an-array-with-stack-operations/\\n// problem: 1441\\nstatic int fast_io = []() { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); return 0; }();\\n```\n```static```\n```this```\n```const```",
                "codeTag": "C++"
            },
            {
                "id": 1672780,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def buildArray(self, target: List[int], n: int) -> List[str]:\\n        a = []\\n        for i in range(1,max(target)+1):\\n            if i in target:\\n                a.append(\"Push\")\\n            else:\\n                a.append(\"Push\")\\n                a.append(\"Pop\")\\n        return a\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def buildArray(self, target: List[int], n: int) -> List[str]:\\n        a = []\\n        for i in range(1,max(target)+1):\\n            if i in target:\\n                a.append(\"Push\")\\n            else:\\n                a.append(\"Push\")\\n                a.append(\"Pop\")\\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1575698,
                "title": "c-faster-than-100",
                "content": "Points\\n* n is useless\\n```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& t, int n) {\\n        std::ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        \\n        int c=0;\\n        vector<string> ans;\\n        for(int i=0; i<t.size(); i++){\\n            if(t[i] == c+1){\\n                ans.push_back(\"Push\");\\n                c++;\\n                continue;\\n            }\\n            while(c+1 != t[i]){\\n                c++;\\n                ans.push_back(\"Push\");\\n                ans.push_back(\"Pop\");\\n            }\\n            ans.push_back(\"Push\");\\n            c++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& t, int n) {\\n        std::ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        \\n        int c=0;\\n        vector<string> ans;\\n        for(int i=0; i<t.size(); i++){\\n            if(t[i] == c+1){\\n                ans.push_back(\"Push\");\\n                c++;\\n                continue;\\n            }\\n            while(c+1 != t[i]){\\n                c++;\\n                ans.push_back(\"Push\");\\n                ans.push_back(\"Pop\");\\n            }\\n            ans.push_back(\"Push\");\\n            c++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1046576,
                "title": "java-100-faster",
                "content": "```\\nclass Solution {\\n    public List<String> buildArray(int[] target, int n) {\\n        List<String> stackOperations = new ArrayList<>();\\n       int i = 0;\\n       int index = 0;\\n       while (i<n && index < target.length) {\\n           if(target[index] == i+1){{\\n               stackOperations.add(\"Push\");\\n               index++;\\n               \\n           }\\n           }else{\\n               stackOperations.add(\"Push\");\\n               stackOperations.add(\"Pop\");\\n           }\\n \\n           i++;\\n           }\\n       return stackOperations;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<String> buildArray(int[] target, int n) {\\n        List<String> stackOperations = new ArrayList<>();\\n       int i = 0;\\n       int index = 0;\\n       while (i<n && index < target.length) {\\n           if(target[index] == i+1){{\\n               stackOperations.add(\"Push\");\\n               index++;\\n               \\n           }",
                "codeTag": "Java"
            },
            {
                "id": 974550,
                "title": "c-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string> res;\\n        \\n        int i=1,j=0;// i for numbers and j for size of target array\\n        \\n        while(i<=n) \\n        {\\n            if(j == target.size())\\n                break;\\n            if(i==target[j])\\n            {\\n                res.push_back(\"Push\");\\n                i++;j++;\\n            }\\n            else\\n            {\\n                res.push_back(\"Push\");\\n                res.push_back(\"Pop\");\\n                i++;\\n            }\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string> res;\\n        \\n        int i=1,j=0;// i for numbers and j for size of target array\\n        \\n        while(i<=n) \\n        {\\n            if(j == target.size())\\n                break;\\n            if(i==target[j])\\n            {\\n                res.push_back(\"Push\");\\n                i++;j++;\\n            }\\n            else\\n            {\\n                res.push_back(\"Push\");\\n                res.push_back(\"Pop\");\\n                i++;\\n            }\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 623820,
                "title": "python-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def buildArray(self, target: List[int], n: int) -> List[str]:\\n        ans = []\\n        for i in range(1,target[-1]+1):\\n            if i in target:\\n                ans.append(\"Push\")\\n            else:\\n                ans.append(\"Push\")\\n                ans.append(\"Pop\")\\n        return ans\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def buildArray(self, target: List[int], n: int) -> List[str]:\\n        ans = []\\n        for i in range(1,target[-1]+1):\\n            if i in target:\\n                ans.append(\"Push\")\\n            else:\\n                ans.append(\"Push\")\\n                ans.append(\"Pop\")\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3137040,
                "title": "simple-sorting-application-based-implementation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI saw that we have to do two operations if we are moving 1 to n and we are not getting equal elements and one operation if they match.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Point a variable j to the start of array target.\\n2. Iterate from 1 to n and check if i == target[j];\\n3. if they match means we have to do \"push\" operation\\n4. else we have to do two operations \"push\" and \"pop\"\\n5. we dont have to handle rest cases as we haev to go till last element present in the array.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N) where N=target.size()\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N) vector to return answer that means O(1) Space Complexity\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string> ans;\\n        int j=0;\\n        for(int i=1; i<=n; i++){\\n            if(j==target.size()){\\n                break;\\n            }\\n            if(target[j]==i){\\n                ans.push_back(\"Push\");\\n                j++;\\n            }\\n            else {\\n                ans.push_back(\"Push\");\\n                ans.push_back(\"Pop\");\\n            }\\n        }\\n    \\xA0\\xA0\\xA0\\xA0return\\xA0ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string> ans;\\n        int j=0;\\n        for(int i=1; i<=n; i++){\\n            if(j==target.size()){\\n                break;\\n            }\\n            if(target[j]==i){\\n                ans.push_back(\"Push\");\\n                j++;\\n            }\\n            else {\\n                ans.push_back(\"Push\");\\n                ans.push_back(\"Pop\");\\n            }\\n        }\\n    \\xA0\\xA0\\xA0\\xA0return\\xA0ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 923627,
                "title": "clean-javascript-solution",
                "content": "```\\n// time O(n) space O(n)\\nvar buildArray = function(target, n) {\\n    let result = []\\n    \\n    for(let i=0, j=1; i<target.length; i++, j++) {\\n        if(target[i] === j) {\\n            result.push(\\'Push\\')\\n        } else {\\n            result.push(\\'Push\\', \\'Pop\\')\\n            i--\\n        }\\n    }\\n    \\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// time O(n) space O(n)\\nvar buildArray = function(target, n) {\\n    let result = []\\n    \\n    for(let i=0, j=1; i<target.length; i++, j++) {\\n        if(target[i] === j) {\\n            result.push(\\'Push\\')\\n        } else {\\n            result.push(\\'Push\\', \\'Pop\\')\\n            i--\\n        }\\n    }\\n    \\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 639944,
                "title": "java-0ms-beats-100-in-both-speed-and-time",
                "content": "```\\nclass Solution {\\n    public List<String> buildArray(int[] target, int n) {\\n        List<String> ans=new ArrayList<>();\\n        int num=1;\\n        for(int x:target){\\n            while(num<x){\\n                num++;\\n                ans.add(\"Push\");\\n                ans.add(\"Pop\");\\n            }\\n            ans.add(\"Push\");\\n            num++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> buildArray(int[] target, int n) {\\n        List<String> ans=new ArrayList<>();\\n        int num=1;\\n        for(int x:target){\\n            while(num<x){\\n                num++;\\n                ans.add(\"Push\");\\n                ans.add(\"Pop\");\\n            }\\n            ans.add(\"Push\");\\n            num++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502246,
                "title": "100-faster-solution-in-c-simple-approach",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach is to first get the maximum value of the array which stays at the last index, as the array is strictly increasing(given in the question). Then start a loop from 1 to the maximum value of the array, and enter the \"Push\" statement into the resulting array. [As for all the cases, we will first Push the value in the stack, and the \"Pop\" it if necessary].\\n\\nThen we\\'re checking if have any number missing in the target array:-\\n-- If \"yes\", then we\\'re entering \"Pop\" statement into the resulting array.\\n-- Else check the next value from target array\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(maximum number in the array)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        int value=1, maxi=target[target.size()-1], i=0;\\n        vector<string> res;\\n        while(value<=maxi){\\n            res.push_back(\"Push\");\\n            if(target[i]==value){\\n                i++;        \\n            }else res.push_back(\"Pop\");\\n            value++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        int value=1, maxi=target[target.size()-1], i=0;\\n        vector<string> res;\\n        while(value<=maxi){\\n            res.push_back(\"Push\");\\n            if(target[i]==value){\\n                i++;        \\n            }else res.push_back(\"Pop\");\\n            value++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2449495,
                "title": "c-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string> ans;\\n        int i = 0;\\n        for(int j = 1; j <= n; j++){\\n            if(target[i] == j){\\n                ans.push_back(\"Push\");\\n                i++;\\n                if(i == target.size())\\n                    break;\\n            }\\n            else{\\n                ans.push_back(\"Push\");\\n                ans.push_back(\"Pop\");\\n            } \\n        }\\n        return ans;\\n   \\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string> ans;\\n        int i = 0;\\n        for(int j = 1; j <= n; j++){\\n            if(target[i] == j){\\n                ans.push_back(\"Push\");\\n                i++;\\n                if(i == target.size())\\n                    break;\\n            }\\n            else{\\n                ans.push_back(\"Push\");\\n                ans.push_back(\"Pop\");\\n            } \\n        }\\n        return ans;\\n   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2008197,
                "title": "c-100-t-c-95-s-c-self-explanatory",
                "content": "**Upvote Or Wot :-)**\\n```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string> v;\\n        int num=1;\\n        for(int i=0;i<target.size();i++){\\n            while(num!=target[i]){\\n                num++;\\n                v.push_back(\"Push\");\\n                v.push_back(\"Pop\");\\n            }\\n            num++;\\n            v.push_back(\"Push\");\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string> v;\\n        int num=1;\\n        for(int i=0;i<target.size();i++){\\n            while(num!=target[i]){\\n                num++;\\n                v.push_back(\"Push\");\\n                v.push_back(\"Pop\");\\n            }\\n            num++;\\n            v.push_back(\"Push\");\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1941504,
                "title": "easy-python-code",
                "content": "```\\nclass Solution:\\n    def buildArray(self, target: List[int], n: int) -> List[str]:\\n        output = []\\n        new_target = []\\n        l = [i for i in range(1,n+1)]\\n        for i in l:\\n            if new_target == target:\\n                return output\\n            output.append(\"Push\")\\n            new_target.append(i)\\n            if i not in target:\\n                output.append(\"Pop\")\\n                new_target.pop()\\n        return output\\n```\\nif this helped, plz **upvote**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def buildArray(self, target: List[int], n: int) -> List[str]:\\n        output = []\\n        new_target = []\\n        l = [i for i in range(1,n+1)]\\n        for i in l:\\n            if new_target == target:\\n                return output\\n            output.append(\"Push\")\\n            new_target.append(i)\\n            if i not in target:\\n                output.append(\"Pop\")\\n                new_target.pop()\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1781039,
                "title": "100-faster-simplest-and-fastest-solution-c",
                "content": "**AN UPVOTE WOULD BE HIGHLY APPERICIATED**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string> ans;\\n      \\n        for(int i=1,j=0;i<=n;i++){\\n            if(target[j]==i && j<target.size()){\\n                ans.push_back(\"Push\");\\n                j++;\\n                if(j==target.size()){\\n                    break;\\n                }\\n            }else{\\n                ans.push_back(\"Push\");\\n                ans.push_back(\"Pop\");\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string> ans;\\n      \\n        for(int i=1,j=0;i<=n;i++){\\n            if(target[j]==i && j<target.size()){\\n                ans.push_back(\"Push\");\\n                j++;\\n                if(j==target.size()){\\n                    break;\\n                }\\n            }else{\\n                ans.push_back(\"Push\");\\n                ans.push_back(\"Pop\");\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1752556,
                "title": "easy-c-solution-runtime-faster-than-100-of-submissions-0-ms-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string> ans;\\n        int i=0,j=1;\\n        while(i<=target.size()-1)\\n        {\\n            if(j==target[i])\\n            {\\n                ans.push_back(\"Push\"); i++; j++;\\n            }\\n            else\\n            {\\n                j++;\\n                ans.push_back(\"Push\");\\n                ans.push_back(\"Pop\");\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string> ans;\\n        int i=0,j=1;\\n        while(i<=target.size()-1)\\n        {\\n            if(j==target[i])\\n            {\\n                ans.push_back(\"Push\"); i++; j++;\\n            }\\n            else\\n            {\\n                j++;\\n                ans.push_back(\"Push\");\\n                ans.push_back(\"Pop\");\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1422974,
                "title": "c-very-easy-o-n-time-and-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        int count=1;\\n        vector<string>ans;\\n        for(int i=0;i<target.size();i++)\\n        {\\n            while(target[i]!=count)\\n            {\\n                ans.push_back(\"Push\");\\n                ans.push_back(\"Pop\");\\n                count++;\\n            }\\n            ans.push_back(\"Push\");\\n            count++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        int count=1;\\n        vector<string>ans;\\n        for(int i=0;i<target.size();i++)\\n        {\\n            while(target[i]!=count)\\n            {\\n                ans.push_back(\"Push\");\\n                ans.push_back(\"Pop\");\\n                count++;\\n            }\\n            ans.push_back(\"Push\");\\n            count++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1410706,
                "title": "c-simple-loop",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string> result;\\n        \\n        int i = 1, j = 0;\\n        while(i <= n && j < target.size()) {\\n            if(target[j] == i) {\\n                result.push_back(\"Push\");\\n                j++;\\n            } else {\\n                result.push_back(\"Push\");\\n                result.push_back(\"Pop\");\\n            }\\n            i++;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string> result;\\n        \\n        int i = 1, j = 0;\\n        while(i <= n && j < target.size()) {\\n            if(target[j] == i) {\\n                result.push_back(\"Push\");\\n                j++;\\n            } else {\\n                result.push_back(\"Push\");\\n                result.push_back(\"Pop\");\\n            }\\n            i++;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 962169,
                "title": "c-clean-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string> res;\\n        for(int i=1;i<=target.back();i++)\\n        {\\n            res.push_back(\"Push\");\\n            if(!count(target.begin(),target.end(),i))\\n                res.push_back(\"Pop\");\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string> res;\\n        for(int i=1;i<=target.back();i++)\\n        {\\n            res.push_back(\"Push\");\\n            if(!count(target.begin(),target.end(),i))\\n                res.push_back(\"Pop\");\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 958799,
                "title": "isn-t-this-test-case-wrong",
                "content": "testcase 49/50\\n```\\ninput\\n\\t[1,2]\\n\\t1\\nOutput\\n\\t[\"Push\"]\\nExpected\\n\\t[\"Push\",\"Push\"]\\n```\\nIf n is 1, why can we build an array [1,2] ??",
                "solutionTags": [],
                "code": "```\\ninput\\n\\t[1,2]\\n\\t1\\nOutput\\n\\t[\"Push\"]\\nExpected\\n\\t[\"Push\",\"Push\"]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 682453,
                "title": "c-3-lines-o-n-time-o-1-space-no-built-in-ds-etc-simple-n-short",
                "content": "```\\nchar ** buildArray(int* target, int targetSize, int n, int* returnSize){\\n    char **a = malloc(sizeof(char *[n * 2])), j = 0; // Question needs this\\n    for (int i = 0, k = 1 ; i < targetSize ; a[j++] = \"Push\", k++ != target[i] ? a[j++] = \"Pop\" : i++);\\n    return *returnSize = j, a;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nchar ** buildArray(int* target, int targetSize, int n, int* returnSize){\\n    char **a = malloc(sizeof(char *[n * 2])), j = 0; // Question needs this\\n    for (int i = 0, k = 1 ; i < targetSize ; a[j++] = \"Push\", k++ != target[i] ? a[j++] = \"Pop\" : i++);\\n    return *returnSize = j, a;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 626812,
                "title": "python3-simulate",
                "content": "```\\n\\nclass Solution:\\n    def buildArray(self, target, n):\\n        result=[]\\n        prev=0\\n        for current in target:\\n            result+=[\\'Push\\',\\'Pop\\']*(current-prev-1)+[\\'Push\\']\\n            prev=current\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution:\\n    def buildArray(self, target, n):\\n        result=[]\\n        prev=0\\n        for current in target:\\n            result+=[\\'Push\\',\\'Pop\\']*(current-prev-1)+[\\'Push\\']\\n            prev=current\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 623681,
                "title": "simple-python",
                "content": "```\\nclass Solution:\\n    def buildArray(self, target: List[int], n: int) -> List[str]:\\n        i = 0\\n        res = []\\n        for j in range(1, n + 1):\\n            if i >= len(target):\\n                return res\\n            if j == target[i]:\\n                res.append(\"Push\")\\n                i += 1\\n            elif j < target[i]:\\n                res.append(\"Push\")\\n                res.append(\"Pop\")\\n        return res\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def buildArray(self, target: List[int], n: int) -> List[str]:\\n        i = 0\\n        res = []\\n        for j in range(1, n + 1):\\n            if i >= len(target):\\n                return res\\n            if j == target[i]:\\n                res.append(\"Push\")\\n                i += 1\\n            elif j < target[i]:\\n                res.append(\"Push\")\\n                res.append(\"Pop\")\\n        return res\\n",
                "codeTag": "Java"
            },
            {
                "id": 3877966,
                "title": "2-c-solutions-with-and-without-stack-beats-100",
                "content": "\\n# Code\\n```\\n// Solution 1 - With stack\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        int i = 1, j = 0;\\n        vector<string> ans;\\n        stack<int> s;\\n        while(i<=n && j<target.size()){\\n            s.push(i++);\\n            ans.push_back(\"Push\");\\n            if(target[j] == s.top()){\\n                j++;\\n            }\\n            else{\\n                s.pop();\\n                ans.push_back(\"Pop\");\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n// Solution 2 - Without stack\\n\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string> ans;\\n        int num = 1; \\n        for(int i=0; i<target.size(); i++){\\n            while(num != target[i]){ \\n                ans.push_back(\"Push\");  \\n                ans.push_back(\"Pop\");\\n                num++;\\n            }\\n            ans.push_back(\"Push\");\\n            num++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Stack",
                    "Simulation"
                ],
                "code": "```\\n// Solution 1 - With stack\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        int i = 1, j = 0;\\n        vector<string> ans;\\n        stack<int> s;\\n        while(i<=n && j<target.size()){\\n            s.push(i++);\\n            ans.push_back(\"Push\");\\n            if(target[j] == s.top()){\\n                j++;\\n            }\\n            else{\\n                s.pop();\\n                ans.push_back(\"Pop\");\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n// Solution 2 - Without stack\\n\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string> ans;\\n        int num = 1; \\n        for(int i=0; i<target.size(); i++){\\n            while(num != target[i]){ \\n                ans.push_back(\"Push\");  \\n                ans.push_back(\"Pop\");\\n                num++;\\n            }\\n            ans.push_back(\"Push\");\\n            num++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3761013,
                "title": "java-0ms-100-faster-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) auxilary space \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> buildArray(int[] target, int n) {\\n       List<String> res = new ArrayList<>();\\n    int curr = 1;     \\n    for(int i = 0; i < target.length; i ++) {\\n        res.add(\"Push\");  //have to push every time\\n        if(target[i] != curr) {  //means we have to pop\\n            res.add(\"Pop\");\\n            i --;  //also don\\'t move to next element in the array\\n        }\\n        curr ++;\\n    }\\n    return res; \\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Stack",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> buildArray(int[] target, int n) {\\n       List<String> res = new ArrayList<>();\\n    int curr = 1;     \\n    for(int i = 0; i < target.length; i ++) {\\n        res.add(\"Push\");  //have to push every time\\n        if(target[i] != curr) {  //means we have to pop\\n            res.add(\"Pop\");\\n            i --;  //also don\\'t move to next element in the array\\n        }\\n        curr ++;\\n    }\\n    return res; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525640,
                "title": "o-n-build-an-array-with-stack-operations-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        int i, j=0;\\n        vector<string> ans;\\n        for(i=1 ; i<=n ; i++)\\n        {\\n            if(target[j]==i)\\n            {\\n                ans.push_back(\"Push\");\\n                j++;\\n                if(j==target.size())\\n                    break;\\n            }\\n            else\\n            {\\n                ans.push_back(\"Push\");\\n                ans.push_back(\"Pop\");\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/d645a635-3401-4c5c-87e4-43347b0873b2_1684124938.600446.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        int i, j=0;\\n        vector<string> ans;\\n        for(i=1 ; i<=n ; i++)\\n        {\\n            if(target[j]==i)\\n            {\\n                ans.push_back(\"Push\");\\n                j++;\\n                if(j==target.size())\\n                    break;\\n            }\\n            else\\n            {\\n                ans.push_back(\"Push\");\\n                ans.push_back(\"Pop\");\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3238977,
                "title": "top-1-rare-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![image.png](https://assets.leetcode.com/users/images/769b0b61-6e62-444b-b984-9df51cf70450_1677566922.1910813.png)\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> buildArray(int[] target, int n) {\\n        List<String> ans = new ArrayList<>();\\n          int input =1;\\n         for(int i:target){\\n            while(input<i){\\n                ans.add(\"Push\");\\n                ans.add(\"Pop\");\\n                input++;\\n            }\\n            ans.add(\"Push\");\\n            input++;\\n         }\\n         return ans;\\n\\n    }\\n}\\n```\\n## Please Upvote ^\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> buildArray(int[] target, int n) {\\n        List<String> ans = new ArrayList<>();\\n          int input =1;\\n         for(int i:target){\\n            while(input<i){\\n                ans.add(\"Push\");\\n                ans.add(\"Pop\");\\n                input++;\\n            }\\n            ans.add(\"Push\");\\n            input++;\\n         }\\n         return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3133094,
                "title": "very-simple-and-easy-beats-100-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string> res;\\n        int curr = 0;\\n        for(int i = 1;i<=target[target.size()-1];i++)\\n        {\\n            res.push_back(\"Push\");\\n            if(i==target[curr])\\n            {\\n                curr++;\\n            }\\n            else\\n            {\\n                res.push_back(\"Pop\");\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string> res;\\n        int curr = 0;\\n        for(int i = 1;i<=target[target.size()-1];i++)\\n        {\\n            res.push_back(\"Push\");\\n            if(i==target[curr])\\n            {\\n                curr++;\\n            }\\n            else\\n            {\\n                res.push_back(\"Pop\");\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3124039,
                "title": "easy-approach-with-runtime-0ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTarget elements are increasing.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing two pointers approach.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n         \\n       vector <string> ans;\\n       int i=1, j=0;\\n     \\n      while(i<=n && j< target.size()){\\n           \\n           if(i==target[j]){\\n               ans.push_back(\"Push\");\\n               i++;\\n               j++;\\n           }\\n           else{\\n               while(i!= target[j])\\n               {\\n                   ans.push_back(\"Push\");\\n                   ans.push_back(\"Pop\");\\n                   i++;\\n               }\\n           }\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n         \\n       vector <string> ans;\\n       int i=1, j=0;\\n     \\n      while(i<=n && j< target.size()){\\n           \\n           if(i==target[j]){\\n               ans.push_back(\"Push\");\\n               i++;\\n               j++;\\n           }\\n           else{\\n               while(i!= target[j])\\n               {\\n                   ans.push_back(\"Push\");\\n                   ans.push_back(\"Pop\");\\n                   i++;\\n               }\\n           }\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3067605,
                "title": "c-easy-solution-100-faster-0ms-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere we have to consider that if a element is not in target then we have simply push and afterwards pop it because it is given the target array is strictly increasing. so for non-target element (\"push\",\"pop\").And for target elements we have to just push it (\"push\").\\n\\n\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe have to run the loop from 1 to n and extra index variable to track the index of the target array and break the loop if index > target array size, increase the index only if you find a matching value (i == target[ind]);\\n\\nHere we don\\'t need to use the stack.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string> ans;\\n        string push = \"Push\", pop = \"Pop\";\\n        int ind = 0;\\n        for(int i = 1; i <= n; i++)\\n        {\\n          if(ind == target.size()) break;\\n          if(i == target[ind])\\n          {\\n            ind++;\\n            ans.push_back(push);\\n          }\\n          else\\n          {\\n            ans.push_back(push);\\n            ans.push_back(pop);\\n          }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string> ans;\\n        string push = \"Push\", pop = \"Pop\";\\n        int ind = 0;\\n        for(int i = 1; i <= n; i++)\\n        {\\n          if(ind == target.size()) break;\\n          if(i == target[ind])\\n          {\\n            ind++;\\n            ans.push_back(push);\\n          }\\n          else\\n          {\\n            ans.push_back(push);\\n            ans.push_back(pop);\\n          }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053984,
                "title": "c-easy-to-understand-beat-100-c-solution",
                "content": "> #### **If you helped, Please Upvote !!!**\\n\\n### Proof\\n![Screenshot 2023-01-15 at 3.06.21 PM.png](https://assets.leetcode.com/users/images/58fa38d9-ab3c-4409-aa4f-0c55058ef872_1673775556.6874478.png)\\n\\n### Intuition\\n- Just think reverse !!!\\n\\n### Approach\\n- Frist make a stack with elements `[1, 2, 3, 4, .... ,target[target.size() -1]]`\\n- After than check one by one element in `target` from end in stack, pop element in the stack still we not get target element.\\n- So, we add `[\"Pop\", \"Push\", \"Push\"]` to the `answer`;\\n- Last remaining element in the stack poping and add `[\"Pop\", \"Push\"]`\\n\\n### Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n### Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> answer;  \\n    void handler(bool isBoth, stack<int> &st) {\\n        if(isBoth) answer.push_back(\"Pop\");\\n        answer.push_back(\"Push\");\\n        st.pop();\\n    }\\n\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        int lastEl = target[target.size() - 1];\\n\\n        stack<int> st;\\n        for(int i = 1; i <= lastEl; i++) st.push(i);\\n        \\n        for(int i = target.size() - 1; i >= 0; i--) {\\n            while(!st.empty() && st.top() > target[i]) handler(true, st);\\n            handler(false, st);\\n        }\\n\\n        while(!st.empty()) handler(true, st);\\n\\n        reverse(answer.begin(), answer.end());\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> answer;  \\n    void handler(bool isBoth, stack<int> &st) {\\n        if(isBoth) answer.push_back(\"Pop\");\\n        answer.push_back(\"Push\");\\n        st.pop();\\n    }\\n\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        int lastEl = target[target.size() - 1];\\n\\n        stack<int> st;\\n        for(int i = 1; i <= lastEl; i++) st.push(i);\\n        \\n        for(int i = target.size() - 1; i >= 0; i--) {\\n            while(!st.empty() && st.top() > target[i]) handler(true, st);\\n            handler(false, st);\\n        }\\n\\n        while(!st.empty()) handler(true, st);\\n\\n        reverse(answer.begin(), answer.end());\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2913767,
                "title": "java-simple-0ms-100-faster-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<String> buildArray(int[] target, int n) {\\n        List<String> list = new ArrayList<>();\\n        int count = 0;\\n        for (int i = 1; i <= n; i++) {\\n            if (count == target.length) {\\n                break;\\n            }\\n            list.add(\"Push\");\\n            if (target[count++] != i) {\\n                list.add(\"Pop\");\\n                count--;\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> buildArray(int[] target, int n) {\\n        List<String> list = new ArrayList<>();\\n        int count = 0;\\n        for (int i = 1; i <= n; i++) {\\n            if (count == target.length) {\\n                break;\\n            }\\n            list.add(\"Push\");\\n            if (target[count++] != i) {\\n                list.add(\"Pop\");\\n                count--;\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2821211,
                "title": "c-0ms-faster-100-solution-brute-force-clean-code",
                "content": "\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n\\n    vector<string> buildArray(vector<int>& target, int n) {\\n\\n       vector<string>ans;\\n\\n       for(int i = 1; i <= target[target.size() -1 ]; ++i)\\n       {\\n          \\n        if(binary_search(target.begin(),target.end(),i))  ans.push_back(\"Push\");\\n             \\n        else\\n        {\\n           ans.push_back(\"Push\");\\n           ans.push_back(\"Pop\");\\n        } \\n\\n       } \\n\\n       return ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n\\n    vector<string> buildArray(vector<int>& target, int n) {\\n\\n       vector<string>ans;\\n\\n       for(int i = 1; i <= target[target.size() -1 ]; ++i)\\n       {\\n          \\n        if(binary_search(target.begin(),target.end(),i))  ans.push_back(\"Push\");\\n             \\n        else\\n        {\\n           ans.push_back(\"Push\");\\n           ans.push_back(\"Pop\");\\n        } \\n\\n       } \\n\\n       return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2770257,
                "title": "1ms-fast-java-solution",
                "content": "# class Solution {\\n    public List<String> buildArray(int[] target, int n) {\\n        ArrayList<String> a=new ArrayList<>();\\n        int j=0;\\n        for(int i=1;i<=n && j<target.length;i++)\\n        {\\n                a.add(\"Push\");\\n                 if(target[j]==i)\\n                 {\\n                     j++;\\n                 }else{\\n                     a.add(\"Pop\");\\n                 }\\n            }\\n        return a;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<String> buildArray(int[] target, int n) {\\n        ArrayList<String> a=new ArrayList<>();\\n        int j=0;\\n        for(int i=1;i<=n && j<target.length;i++)\\n        {\\n                a.add(\"Push\");\\n                 if(target[j]==i)\\n                 {\\n                     j++;\\n                 }",
                "codeTag": "Java"
            },
            {
                "id": 2542769,
                "title": "0ms-using-loop-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        \\n        vector<string> ans;\\n        int atIndex=0;\\n        for(int i=1; i<=n; i++){\\n            if(target[atIndex]==i) {\\n                ans.push_back(\"Push\");\\n                \\n                atIndex++;\\n                if(atIndex>=target.size()) break;\\n            }\\n            else {\\n                ans.push_back(\"Push\");\\n                ans.push_back(\"Pop\");\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        \\n        vector<string> ans;\\n        int atIndex=0;\\n        for(int i=1; i<=n; i++){\\n            if(target[atIndex]==i) {\\n                ans.push_back(\"Push\");\\n                \\n                atIndex++;\\n                if(atIndex>=target.size()) break;\\n            }\\n            else {\\n                ans.push_back(\"Push\");\\n                ans.push_back(\"Pop\");\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2332719,
                "title": "c-solution-100-faster",
                "content": "class Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n       vector<string> ans;\\n        int k = 0,i = 0;\\n        for(i=1;i<=n && k<target.size();i++)\\n        {\\n            ans.push_back(\"Push\");\\n            if(i != target[k])\\n                ans.push_back(\"Pop\");\\n            else\\n                k++;\\n        }/*\\n        while(i != n)\\n        {\\n            ans.push_back(\"push\");\\n            ans.push_back(\"pop\");\\n            i++;\\n        }*/\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n       vector<string> ans;\\n        int k = 0,i = 0;\\n        for(i=1;i<=n && k<target.size();i++)\\n        {\\n            ans.push_back(\"Push\");\\n            if(i != target[k])\\n                ans.push_back(\"Pop\");\\n            else\\n                k++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2242579,
                "title": "java-solution-faster-than-100",
                "content": "```\\nclass Solution {\\n\\n    public List<String> buildArray(int[] target, int n) {\\n        List<String> res = new ArrayList<>();\\n        int j = 0;\\n        for (int i = 1; i <= n && j < target.length; i++) {\\n            res.add(\"Push\");\\n            if (target[j] == i) j++; else res.add(\"Pop\");\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public List<String> buildArray(int[] target, int n) {\\n        List<String> res = new ArrayList<>();\\n        int j = 0;\\n        for (int i = 1; i <= n && j < target.length; i++) {\\n            res.add(\"Push\");\\n            if (target[j] == i) j++; else res.add(\"Pop\");\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2119213,
                "title": "simple-c-o-n-without-while-loop",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n       vector<string> res;\\n        for(int p1=0,p2=1;p1<target.size() && p2<=n; p2++){\\n            res.push_back(\"Push\");\\n            if(target[p1]==p2)                \\n                p1++;\\n            else\\n                res.push_back(\"Pop\");\\n        }\\n        return res;\\n    }\\n};\\n```\\nLogic is traverse over target array , if number is present in that array \"push\" else \"push\" and \"pop\".\\nUPVOTE if Helpful\\nConstructive critiscm most welcome.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n       vector<string> res;\\n        for(int p1=0,p2=1;p1<target.size() && p2<=n; p2++){\\n            res.push_back(\"Push\");\\n            if(target[p1]==p2)                \\n                p1++;\\n            else\\n                res.push_back(\"Pop\");\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2066236,
                "title": "java-one-loop",
                "content": "class Solution {\\n\\n    public List<String> buildArray(int[] target, int n) {\\n        List<String> list = new ArrayList<>();\\n        \\n        for (int j = 0, i = 1; j < target.length;){\\n            if (i == target[j]){\\n                list.add(\"Push\");\\n                j++;\\n            }\\n            else {\\n                list.add(\"Push\");\\n                list.add(\"Pop\");\\n            }\\n            i++;\\n        }\\n        return list;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public List<String> buildArray(int[] target, int n) {\\n        List<String> list = new ArrayList<>();\\n        \\n        for (int j = 0, i = 1; j < target.length;){\\n            if (i == target[j]){\\n                list.add(\"Push\");\\n                j++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2066214,
                "title": "java-solution-0ms-100",
                "content": "class Solution {\\n    public List<String> buildArray(int[] target, int n) {\\n        \\n        int[] nums = new int[n];\\n        List<String> list = new ArrayList<>();\\n        \\n        for (int i = 1; i <= n; i++){\\n            nums[i-1] = i; \\n        }\\n        int a = 0;\\n        for (int i = 0; i < n; i++){  \\n            if (target[a] == nums[i]){\\n                list.add(\"Push\");\\n                a++;\\n            }else {\\n                list.add(\"Push\");\\n                list.add(\"Pop\");\\n            }\\n            \\n            if (a >= target.length) break;\\n\\n        }\\n        return list;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<String> buildArray(int[] target, int n) {\\n        \\n        int[] nums = new int[n];\\n        List<String> list = new ArrayList<>();\\n        \\n        for (int i = 1; i <= n; i++){\\n            nums[i-1] = i; \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1852181,
                "title": "c-cleaenest-and-shortest-code-for-quick-understanding",
                "content": "```\\n    vector<string> buildArray(vector<int>& target, int n)   {\\n        int num = 1, i = 0                                  ;\\n        vector<string> ans                                  ;\\n        while(i < target.size())                            {\\n            if(target[i]==num)                              {\\n                ans.push_back(\"Push\")                       ;\\n                num++; i++                                  ;}\\n            else                                            {\\n                ans.push_back(\"Push\")                       ;\\n                ans.push_back(\"Pop\")                        ;\\n                num++                                       ;}}\\n        return ans                                          ;}\\n\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Stack"
                ],
                "code": "```\\n    vector<string> buildArray(vector<int>& target, int n)   {\\n        int num = 1, i = 0                                  ;\\n        vector<string> ans                                  ;\\n        while(i < target.size())                            {\\n            if(target[i]==num)                              {\\n                ans.push_back(\"Push\")                       ;\\n                num++; i++                                  ;}\\n            else                                            {\\n                ans.push_back(\"Push\")                       ;\\n                ans.push_back(\"Pop\")                        ;\\n                num++                                       ;}}\\n        return ans                                          ;}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1763758,
                "title": "c-easy-faster-than-100-of-submissions",
                "content": "```\\n// Please Upvote if you found it helpful\\n\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string>ans;\\n        int i=0,j=1;\\n        while(i<=target.size()-1)\\n        {\\n            if(target[i]==j)\\n            {\\n                ans.push_back(\"Push\");\\n                i++;\\n                j++;\\n            }\\n            else\\n            {\\n                j++;\\n                ans.push_back(\"Push\");\\n                ans.push_back(\"Pop\");\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string>ans;\\n        int i=0,j=1;\\n        while(i<=target.size()-1)\\n        {\\n            if(target[i]==j)\\n            {\\n                ans.push_back(\"Push\");\\n                i++;\\n                j++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1721904,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public List<String> buildArray(int[] target, int n) {\\n        int start = 1;\\n        List<String> result  = new ArrayList<>();\\n        for(int i = 0; i < target.length; ) {\\n            if(target[i] == start)\\n            {\\n                result.add(\"Push\");\\n                start++;\\n                i++;\\n            } else  {\\n                result.add(\"Push\");\\n                result.add(\"Pop\");\\n                start++;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\\nGuy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE.\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> buildArray(int[] target, int n) {\\n        int start = 1;\\n        List<String> result  = new ArrayList<>();\\n        for(int i = 0; i < target.length; ) {\\n            if(target[i] == start)\\n            {\\n                result.add(\"Push\");\\n                start++;\\n                i++;\\n            } else  {\\n                result.add(\"Push\");\\n                result.add(\"Pop\");\\n                start++;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1620573,
                "title": "0ms-stack-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        int m = target.size();\\n        int p1=0;\\n        vector<int> res;\\n        for(int i=1;i<=n;i++)res.push_back(i);\\n        int p2=0;\\n        vector<string> ans;\\n        while(p1<m)\\n        {\\n            if(target[p1] == res[p2]) \\n            {\\n                ans.push_back(\"Push\");p1++;p2++;\\n            }\\n            else if(target[p1] != res[p2])\\n            {\\n                ans.push_back(\"Push\");\\n                ans.push_back(\"Pop\");\\n                p2++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```\\nKindly Upvote the solution if you found it useful.......d\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        int m = target.size();\\n        int p1=0;\\n        vector<int> res;\\n        for(int i=1;i<=n;i++)res.push_back(i);\\n        int p2=0;\\n        vector<string> ans;\\n        while(p1<m)\\n        {\\n            if(target[p1] == res[p2]) \\n            {\\n                ans.push_back(\"Push\");p1++;p2++;\\n            }\\n            else if(target[p1] != res[p2])\\n            {\\n                ans.push_back(\"Push\");\\n                ans.push_back(\"Pop\");\\n                p2++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nKindly Upvote the solution if you found it useful.......d\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1591646,
                "title": "java-faster-than-100-00-two-versions-over-list-over-target",
                "content": "Using list (from 1 to n numbers):\\n```\\npublic List<String> buildArray(int[] target, int n) {\\n\\tList<String> result = new ArrayList<>();\\n\\t\\n\\tint targetIndex = 0;\\n\\tfor(int i = 1; i <= n; i++) {\\n\\t\\tif(targetIndex == target.length) break;             //early exit, numbers in target is out\\n\\t\\tresult.add(\"Push\");                             //add \"Push\"\\n\\t\\tif(i == target[targetIndex]) targetIndex++;       //if value from list is not equals target than \"Pop\" it\\n\\t\\telse result.add(\"Pop\");\\n\\t}\\n\\n\\treturn result;\\n}\\n```\\n\\nUsing target array:\\n```\\npublic List<String> buildArray(int[] target, int n) {\\n\\tList<String> result = new ArrayList<>();\\n\\t\\n\\tint listIndex = 1;\\n\\tfor(int num : target) {\\n\\t\\twhile(listIndex++ < num) {      // Push + Pop for each value from list while < num\\n\\t\\t\\tresult.add(\"Push\");\\n\\t\\t\\tresult.add(\"Pop\");\\n\\t\\t}\\n\\t\\tresult.add(\"Push\");          //Push current target value\\n\\t}\\n\\n\\treturn result;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic List<String> buildArray(int[] target, int n) {\\n\\tList<String> result = new ArrayList<>();\\n\\t\\n\\tint targetIndex = 0;\\n\\tfor(int i = 1; i <= n; i++) {\\n\\t\\tif(targetIndex == target.length) break;             //early exit, numbers in target is out\\n\\t\\tresult.add(\"Push\");                             //add \"Push\"\\n\\t\\tif(i == target[targetIndex]) targetIndex++;       //if value from list is not equals target than \"Pop\" it\\n\\t\\telse result.add(\"Pop\");\\n\\t}\\n\\n\\treturn result;\\n}\\n```\n```\\npublic List<String> buildArray(int[] target, int n) {\\n\\tList<String> result = new ArrayList<>();\\n\\t\\n\\tint listIndex = 1;\\n\\tfor(int num : target) {\\n\\t\\twhile(listIndex++ < num) {      // Push + Pop for each value from list while < num\\n\\t\\t\\tresult.add(\"Push\");\\n\\t\\t\\tresult.add(\"Pop\");\\n\\t\\t}\\n\\t\\tresult.add(\"Push\");          //Push current target value\\n\\t}\\n\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1552938,
                "title": "c-100-time-space-no-hashtable",
                "content": "```\\nconst char *push_str = \"Push\";\\nconst char *pop_str = \"Pop\";\\n\\nchar ** buildArray(int* target, int targetSize, int n, int* returnSize){\\n    \\n    char **res  = (char**)malloc(sizeof(char*)*(n*2));\\n    int ind = 0;\\n    \\n    int target_array_index = 0;\\n    int target_last_ele = target[targetSize-1];\\n    \\n    for(int i=1;i<=target_last_ele;i++){\\n        \\n        if(i==target[target_array_index]){\\n            target_array_index++;\\n            char *temp = (char*)malloc(sizeof(char*));\\n            temp = push_str;\\n            res[ind++] = temp;\\n        }\\n        else{\\n            char *temp1 = (char*)malloc(sizeof(char*));\\n            char *temp2 = (char*)malloc(sizeof(char*));\\n            temp1 = push_str;\\n            temp2 = pop_str;\\n            res[ind++] = temp1;\\n            res[ind++] = temp2;\\n        }\\n    }    \\n    \\n    *returnSize = ind;\\n    return res;\\n}\\n\\n```\\nApproach : \\n1.Create an array of char pointers of size 2 times \\'n\\' that is going to be returned.\\n2.Keep a variable to keep track of target array elements named as **target_array_index** and assign it to zero .\\n3.From 1 till the last element in target array keep incrementing \\'i\\' and check if the **target_array_index** corresponding value and **i **are equal. \\n4.If equal add \"Push\" to the result array and **increment target_array_index**  , else add \"Push\" and \"Pop\" **without incrementing the target_array_index**.\\n5.Return the array of char pointers.\\n\\nThe main idea is just to add \"Push\" if element is present else add \"Push\" then \"Pop\".\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nconst char *push_str = \"Push\";\\nconst char *pop_str = \"Pop\";\\n\\nchar ** buildArray(int* target, int targetSize, int n, int* returnSize){\\n    \\n    char **res  = (char**)malloc(sizeof(char*)*(n*2));\\n    int ind = 0;\\n    \\n    int target_array_index = 0;\\n    int target_last_ele = target[targetSize-1];\\n    \\n    for(int i=1;i<=target_last_ele;i++){\\n        \\n        if(i==target[target_array_index]){\\n            target_array_index++;\\n            char *temp = (char*)malloc(sizeof(char*));\\n            temp = push_str;\\n            res[ind++] = temp;\\n        }\\n        else{\\n            char *temp1 = (char*)malloc(sizeof(char*));\\n            char *temp2 = (char*)malloc(sizeof(char*));\\n            temp1 = push_str;\\n            temp2 = pop_str;\\n            res[ind++] = temp1;\\n            res[ind++] = temp2;\\n        }\\n    }    \\n    \\n    *returnSize = ind;\\n    return res;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1381669,
                "title": "c-tc-o-n-sc-o-n",
                "content": "# Feel free to post your doubts in comment\\n```\\nvector<string> buildArray(vector<int>& target, int n) {\\n\\tstring pu = \"Push\";\\n\\tstring po = \"Pop\";\\n\\tvector<string> ans;\\n\\tint current = 1;\\n\\tfor( auto i : target ){\\n\\t\\tif(i!=current){\\n\\t\\t\\twhile(current!=i){\\n\\t\\t\\t\\tans.push_back(pu);\\n\\t\\t\\t\\tans.push_back(po);\\n\\t\\t\\t\\tcurrent++;\\n\\t\\t\\t}\\n\\t\\t\\tans.push_back(pu);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tans.push_back({pu});\\n\\n\\t\\tcurrent++;\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<string> buildArray(vector<int>& target, int n) {\\n\\tstring pu = \"Push\";\\n\\tstring po = \"Pop\";\\n\\tvector<string> ans;\\n\\tint current = 1;\\n\\tfor( auto i : target ){\\n\\t\\tif(i!=current){\\n\\t\\t\\twhile(current!=i){\\n\\t\\t\\t\\tans.push_back(pu);\\n\\t\\t\\t\\tans.push_back(po);\\n\\t\\t\\t\\tcurrent++;\\n\\t\\t\\t}\\n\\t\\t\\tans.push_back(pu);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tans.push_back({pu});\\n\\n\\t\\tcurrent++;\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1315003,
                "title": "c-fast-and-understandable-solution-o-n-time-complexity-and-o-1-space-complexity",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<string> buildArray(vector<int>& target, int n) {\\n\\n\\t\\t\\tvector<string> res;\\n\\n\\t\\t\\tint ind = 0;\\n\\n\\t\\t\\tfor(int i=1 ; i<=n && ind<target.size() ; i++){\\n\\n\\t\\t\\t\\tres.push_back(\"Push\");\\n\\t\\t\\t\\tif(target[ind] == i)\\n\\t\\t\\t\\t\\tind++;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tres.push_back(\"Pop\");\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<string> buildArray(vector<int>& target, int n) {\\n\\n\\t\\t\\tvector<string> res;\\n\\n\\t\\t\\tint ind = 0;\\n\\n\\t\\t\\tfor(int i=1 ; i<=n && ind<target.size() ; i++){\\n\\n\\t\\t\\t\\tres.push_back(\"Push\");\\n\\t\\t\\t\\tif(target[ind] == i)\\n\\t\\t\\t\\t\\tind++;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tres.push_back(\"Pop\");\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1262183,
                "title": "easy-c-approach",
                "content": "class Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string> ans;\\n        int j=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            ans.push_back(\"Push\");\\n            \\n            if(target[j]==i)\\n               j++;\\n            else\\n                ans.push_back(\"Pop\");\\n            if(j==target.size())\\n                break;\\n        }\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string> ans;\\n        int j=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            ans.push_back(\"Push\");\\n            \\n            if(target[j]==i)\\n               j++;\\n            else\\n                ans.push_back(\"Pop\");\\n            if(j==target.size())\\n                break;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1207860,
                "title": "cpp-solution-100-faster-with-comments",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Build an Array With Stack Operations.\\nMemory Usage: 7.8 MB, less than 43.89% of C++ online submissions for Build an Array With Stack Operations.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        \\n        vector<string> ans;\\n        int curr= 0;\\n        \\n        for(int i=0; i<target.size(); i++)\\n        {\\n\\t\\t//let\\'s say our target array is [1,3] and we are inserting \"Push\" and \"Pop\"\\n\\t\\t//in the ans array, so here we are assuming that we have a array [1,2,3] \\n\\t\\t//and we are trying to get the array [1,3] and for that we have used curr \\n\\t\\t//variable\\n\\t\\t\\n\\t\\t// here curr= 0 and list starts with 1 so we are incrementing the curr \\n\\t\\t//who tells us that which value should be in the target array if we assume\\n\\t\\t//that it is increasing only? answer is current tells us...\\n\\t\\t\\n            curr++;\\n            if(curr == target[i])\\n                ans.push_back(\"Push\");\\n            else \\n            {\\n                int diff= target[i] - curr;\\n                \\n                while(diff--)\\n                {\\n                    ans.push_back(\"Push\");\\n                    ans.push_back(\"Pop\");\\n                }\\n                curr= target[i];\\n                ans.push_back(\"Push\");\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**please upvote :-)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        \\n        vector<string> ans;\\n        int curr= 0;\\n        \\n        for(int i=0; i<target.size(); i++)\\n        {\\n\\t\\t//let\\'s say our target array is [1,3] and we are inserting \"Push\" and \"Pop\"\\n\\t\\t//in the ans array, so here we are assuming that we have a array [1,2,3] \\n\\t\\t//and we are trying to get the array [1,3] and for that we have used curr \\n\\t\\t//variable\\n\\t\\t\\n\\t\\t// here curr= 0 and list starts with 1 so we are incrementing the curr \\n\\t\\t//who tells us that which value should be in the target array if we assume\\n\\t\\t//that it is increasing only? answer is current tells us...\\n\\t\\t\\n            curr++;\\n            if(curr == target[i])\\n                ans.push_back(\"Push\");\\n            else \\n            {\\n                int diff= target[i] - curr;\\n                \\n                while(diff--)\\n                {\\n                    ans.push_back(\"Push\");\\n                    ans.push_back(\"Pop\");\\n                }\\n                curr= target[i];\\n                ans.push_back(\"Push\");\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1158149,
                "title": "python-solution-faster-than-90-50",
                "content": "```\\nclass Solution:\\n    def buildArray(self, target: List[int], n: int) -> List[str]:\\n        arr = []\\n        response_list = []\\n        i = 1\\n        while(arr!=target and i<=n):\\n            if i in target:\\n                arr.append(i)\\n                response_list.append(\"Push\")\\n            else:\\n                response_list.append(\"Push\")\\n                response_list.append(\"Pop\")\\n            i += 1\\n        return response_list\\n   ```",
                "solutionTags": [
                    "Python",
                    "Array",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def buildArray(self, target: List[int], n: int) -> List[str]:\\n        arr = []\\n        response_list = []\\n        i = 1\\n        while(arr!=target and i<=n):\\n            if i in target:\\n                arr.append(i)\\n                response_list.append(\"Push\")\\n            else:\\n                response_list.append(\"Push\")\\n                response_list.append(\"Pop\")\\n            i += 1\\n        return response_list\\n   ```",
                "codeTag": "Java"
            },
            {
                "id": 1056266,
                "title": "0ms-beats-100-easy-to-understand-added-comments",
                "content": "\\n```\\npublic List<String> buildArray(int[] target, int n) {\\n\\t\\tList<String> answer = new ArrayList<String>();\\n\\t\\tint start=1;\\n\\t\\tfor(int i=0;i<target.length;){\\n\\t\\t\\tif(target[i]==start){ //scanning the elements and expecting a sequential insertion \\n\\t\\t\\t\\tanswer.add(\"Push\");\\n\\t\\t\\t\\ti++; //Key here is we move on to check the next element on in case of sequential insertion\\n\\t\\t\\t}\\n\\t\\t\\telse{ // adding the combination of Push-Pop when sequential insertion isn\\'t encountered\\n\\t\\t\\t\\tanswer.add(\"Push\");\\n\\t\\t\\t\\tanswer.add(\"Pop\");\\n\\t\\t\\t}\\n\\t\\t\\tstart++;\\n\\t\\t}\\n\\t\\treturn answer;   \\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic List<String> buildArray(int[] target, int n) {\\n\\t\\tList<String> answer = new ArrayList<String>();\\n\\t\\tint start=1;\\n\\t\\tfor(int i=0;i<target.length;){\\n\\t\\t\\tif(target[i]==start){ //scanning the elements and expecting a sequential insertion \\n\\t\\t\\t\\tanswer.add(\"Push\");\\n\\t\\t\\t\\ti++; //Key here is we move on to check the next element on in case of sequential insertion\\n\\t\\t\\t}\\n\\t\\t\\telse{ // adding the combination of Push-Pop when sequential insertion isn\\'t encountered\\n\\t\\t\\t\\tanswer.add(\"Push\");\\n\\t\\t\\t\\tanswer.add(\"Pop\");\\n\\t\\t\\t}\\n\\t\\t\\tstart++;\\n\\t\\t}\\n\\t\\treturn answer;   \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1010620,
                "title": "python3-solution",
                "content": "```\\nclass Solution:\\n    def buildArray(self, target: List[int], n: int) -> List[str]:\\n        n = [x for x in range(1,target[-1]+1)]\\n        res = []\\n        for i in n:\\n            res.append(\"Push\")\\n            if i not in target:\\n                res.append(\"Pop\")\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def buildArray(self, target: List[int], n: int) -> List[str]:\\n        n = [x for x in range(1,target[-1]+1)]\\n        res = []\\n        for i in n:\\n            res.append(\"Push\")\\n            if i not in target:\\n                res.append(\"Pop\")\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1008657,
                "title": "c-sol-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        \\n        vector<string> ans;\\n        int i=0, j=1;\\n        while(i<target.size())\\n        {\\n            if(i==target.size()) break;\\n            \\n            if(j==target[i]) \\n            {\\n                ans.push_back(\"Push\");\\n                j++;\\n                i++;\\n            }\\n            else{\\n                ans.push_back(\"Push\");\\n                ans.push_back(\"Pop\");\\n                j++;\\n            }\\n            \\n            \\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\ndo give a upvote if it helped you :)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        \\n        vector<string> ans;\\n        int i=0, j=1;\\n        while(i<target.size())\\n        {\\n            if(i==target.size()) break;\\n            \\n            if(j==target[i]) \\n            {\\n                ans.push_back(\"Push\");\\n                j++;\\n                i++;\\n            }\\n            else{\\n                ans.push_back(\"Push\");\\n                ans.push_back(\"Pop\");\\n                j++;\\n            }\\n            \\n            \\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 972004,
                "title": "python-o-n",
                "content": "```\\n    def buildArray(self, target: List[int], n: int) -> List[str]:\\n        res = []\\n        cur = 0\\n        for val in range(1, n+1):\\n            if cur == len(target) or val > target[cur]:\\n                break\\n            elif val == target[cur]:\\n                res.append(\\'Push\\')\\n                cur += 1\\n            else:\\n                res.extend([\\'Push\\', \\'Pop\\'])                \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    def buildArray(self, target: List[int], n: int) -> List[str]:\\n        res = []\\n        cur = 0\\n        for val in range(1, n+1):\\n            if cur == len(target) or val > target[cur]:\\n                break\\n            elif val == target[cur]:\\n                res.append(\\'Push\\')\\n                cur += 1\\n            else:\\n                res.extend([\\'Push\\', \\'Pop\\'])                \\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 667379,
                "title": "simple-java-solution-using-hashset-runtime-faster-than-100-and-space-lesser-than-100",
                "content": "class Solution {\\n    public List<String> buildArray(int[] target, int n) {\\n        List<String>  list = new ArrayList<>();\\n        int length= target.length;\\n        Set<Integer> set = new HashSet<Integer> ();\\n        \\n        for(int i=0; i< target.length; i++){\\n            set.add(target[i]);\\n        }\\n        for(int i=1; i<=n; i++){\\n            \\n            if(set.contains(i)){\\n                list.add(\"Push\");\\n                length--;\\n                if(length==0) break;\\n            }\\n            else{\\n                list.add(\"Push\");\\n                list.add(\"Pop\");\\n            }\\n        }\\n        return list;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<String> buildArray(int[] target, int n) {\\n        List<String>  list = new ArrayList<>();\\n        int length= target.length;\\n        Set<Integer> set = new HashSet<Integer> ();\\n        \\n        for(int i=0; i< target.length; i++){\\n            set.add(target[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 663666,
                "title": "java-pop-iff-not-in-the-list",
                "content": "```\\n    public List<String> buildArray(int[] target, int n) {\\n        List<String> res = new ArrayList<>();\\n        for (int j = 0, i = 0; i < target.length; i++) {\\n            while (++j < target[i]) {\\n                res.add(\"Push\");\\n                res.add(\"Pop\");\\n            }\\n            res.add(\"Push\");\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<String> buildArray(int[] target, int n) {\\n        List<String> res = new ArrayList<>();\\n        for (int j = 0, i = 0; i < target.length; i++) {\\n            while (++j < target[i]) {\\n                res.add(\"Push\");\\n                res.add(\"Pop\");\\n            }\\n            res.add(\"Push\");\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 634440,
                "title": "find-out-missing-number-c-beat-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string> ans;\\n        // the following algorithm will find out missing numbers\\n        \\n        for(int i = 1,j = 1; i <= n; i++){\\n            if(i == target[j - 1]){\\n                ans.push_back(\"Push\");\\n                j++;\\n            }\\n            else{\\n                //missing numbers should take a push and pop\\n                ans.push_back(\"Push\");\\n                ans.push_back(\"Pop\");\\n            }\\n            if(j - 1 >= target.size()){\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string> ans;\\n        // the following algorithm will find out missing numbers\\n        \\n        for(int i = 1,j = 1; i <= n; i++){\\n            if(i == target[j - 1]){\\n                ans.push_back(\"Push\");\\n                j++;\\n            }\\n            else{\\n                //missing numbers should take a push and pop\\n                ans.push_back(\"Push\");\\n                ans.push_back(\"Pop\");\\n            }\\n            if(j - 1 >= target.size()){\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 625179,
                "title": "python-simple-solution-in-5-lines",
                "content": "\\n    def buildArray(self, target: List[int], n: int) -> List[str]:\\n        prev, res = 0, []\\n        for t in target:\\n            res += [\\'Push\\', \\'Pop\\'] * (t - prev - 1) + [\\'Push\\']\\n            prev = t\\n        return res",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\n    def buildArray(self, target: List[int], n: int) -> List[str]:\\n        prev, res = 0, []\\n        for t in target:\\n            res += [\\'Push\\', \\'Pop\\'] * (t - prev - 1) + [\\'Push\\']\\n            prev = t\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 623905,
                "title": "rust-simple-answer-0ms",
                "content": "```Rust\\nimpl Solution {\\n    pub fn build_array(target: Vec<i32>, n: i32) -> Vec<String> {\\n        let cc: HashSet<i32> = HashSet::from_iter(target);\\n        let m = min(n, *cc.iter().max().unwrap());\\n        let mut res: Vec<String> = vec![];\\n        for i in 1..1 + m {\\n            res.push(\"Push\".to_string());\\n            if !cc.contains(&i) {\\n                res.push(\"Pop\".to_string())\\n            };\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Rust\\nimpl Solution {\\n    pub fn build_array(target: Vec<i32>, n: i32) -> Vec<String> {\\n        let cc: HashSet<i32> = HashSet::from_iter(target);\\n        let m = min(n, *cc.iter().max().unwrap());\\n        let mut res: Vec<String> = vec![];\\n        for i in 1..1 + m {\\n            res.push(\"Push\".to_string());\\n            if !cc.contains(&i) {\\n                res.push(\"Pop\".to_string())\\n            };\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 623850,
                "title": "java-find-the-discontinuity-of-the-array",
                "content": "The key idea here is to find a the missing number(s) of the given array: \\n* \\tIf its missing numbers are smaller than the ending number of the `target` array, then we need to do `Push` and `Pop` operations for each missing number. \\n* \\tIf its missing numbers larger than the ending number of the `target` array, we do nothing.\\n\\n```\\n    public List<String> buildArray(int[] target, int n) {\\n        List<String> res = new ArrayList<>();\\n        int k = 1;  // k is a tracker that track the number that start from 1 to n.\\n        for(int i=0; i<target.length; i++) {\\n            if (target[i] == k) { // there is no missing number for current value of k. Then we just do a \\'Push\\' operation.\\n                res.add(\"Push\");\\n            } else { // if there is a missing number, we need to keep i unmoved until we handle all the missing numbers!\\n                i--;\\n                res.add(\"Push\");\\n                res.add(\"Pop\");\\n            }\\n            k++;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<String> buildArray(int[] target, int n) {\\n        List<String> res = new ArrayList<>();\\n        int k = 1;  // k is a tracker that track the number that start from 1 to n.\\n        for(int i=0; i<target.length; i++) {\\n            if (target[i] == k) { // there is no missing number for current value of k. Then we just do a \\'Push\\' operation.\\n                res.add(\"Push\");\\n            } else { // if there is a missing number, we need to keep i unmoved until we handle all the missing numbers!\\n                i--;\\n                res.add(\"Push\");\\n                res.add(\"Pop\");\\n            }\\n            k++;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 623690,
                "title": "c-simulation",
                "content": "Given the final states of a stack, return the operations to build the stack.\\n\\n# Explanation\\n\\nJust push in the needed elements and pop out the elemens that are not needed.\\n\\nTime Complexity: `O(n)`\\n\\n# C++ Solution\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        int i = 1;\\n        vector<string> ans;\\n        for (int j = 0; j < target.size(); j++) {\\n            while (i <= n && i != target[j]) {\\n                ans.push_back(\"Push\");\\n                ans.push_back(\"Pop\");\\n                i++;\\n            }\\n            ans.push_back(\"Push\");\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        int i = 1;\\n        vector<string> ans;\\n        for (int j = 0; j < target.size(); j++) {\\n            while (i <= n && i != target[j]) {\\n                ans.push_back(\"Push\");\\n                ans.push_back(\"Pop\");\\n                i++;\\n            }\\n            ans.push_back(\"Push\");\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3992081,
                "title": "beginner-friendly-simple-solution-with-using-stack-ds-in-python3",
                "content": "# Intuition\\nIf you follow the description, you\\'ll find, that it\\'s strongly requires to use the [Stack DS](https://en.wikipedia.org/wiki/Stack_(abstract_data_type)).\\n# Approach\\n1. initialize `i`, that will point to the particular index of `target`\\n2. initialize `ans` variable\\n3. initialize `cur`, that will store **a top number** in stack (for this case we\\'ll **simulate the stack itself** via using this constant)\\n4. iterate from `1` to `target[-1] + 1` to fit the bounds of this list\\n5. any time you\\'ve found, that current elem in `target` equals to **the current element**, check if the **simulated stack** isn\\'t **FIT** the condition `cur and cur - 1 != target[i - 1]`\\n6. handle the appropriate operation with `Pop` and `Push` and increment `cur`\\n7. after the iteration return `ans`\\n\\n\\n# Complexity\\n- Time complexity: **O(n)**, because of iterating upon `last element in target` in worst-case scenario\\n\\n- Space complexity: **O(k)**, because of storing operations `k` times inside `ans`\\n\\n# Code\\n```\\nclass Solution:\\n    def buildArray(self, target: List[int], n: int) -> List[str]:\\n        i = 0\\n        ans = []\\n        cur = 0\\n\\n        for j in range(1, target[-1] + 1):            \\n            if target[i] == j:\\n                while cur and cur - 1 != target[i - 1]:\\n                    cur -= 1\\n                    ans.append(\\'Pop\\')\\n\\n                i += 1\\n                cur = j\\n\\n            ans.append(\\'Push\\')\\n            cur += 1\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def buildArray(self, target: List[int], n: int) -> List[str]:\\n        i = 0\\n        ans = []\\n        cur = 0\\n\\n        for j in range(1, target[-1] + 1):            \\n            if target[i] == j:\\n                while cur and cur - 1 != target[i - 1]:\\n                    cur -= 1\\n                    ans.append(\\'Pop\\')\\n\\n                i += 1\\n                cur = j\\n\\n            ans.append(\\'Push\\')\\n            cur += 1\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3693974,
                "title": "c-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string>s;\\n        int j=0;\\n        for(int i=1; i<=n; i++){\\n            if(target[j] == i){\\n                j++;\\n                s.push_back(\"Push\");\\n\\n                if(j==target.size()){\\n                    break;\\n                }\\n            }\\n\\n            else{\\n                s.push_back(\"Push\");\\n                s.push_back(\"Pop\");\\n            }\\n        }\\n\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string>s;\\n        int j=0;\\n        for(int i=1; i<=n; i++){\\n            if(target[j] == i){\\n                j++;\\n                s.push_back(\"Push\");\\n\\n                if(j==target.size()){\\n                    break;\\n                }\\n            }\\n\\n            else{\\n                s.push_back(\"Push\");\\n                s.push_back(\"Pop\");\\n            }\\n        }\\n\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3628387,
                "title": "easy-c-solution-beat-100",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n         vector<string> s;\\n         int j=0;\\n         for(int i=0;i<n;i++){\\n            if(target[j]==i+1){\\n                j++;\\n                s.push_back(\"Push\");\\n                if(j==target.size())\\n                    return s;\\n            }\\n            else{\\n                s.push_back(\"Push\");\\n                s.push_back(\"Pop\");\\n            }\\n              \\n         }\\n         return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n         vector<string> s;\\n         int j=0;\\n         for(int i=0;i<n;i++){\\n            if(target[j]==i+1){\\n                j++;\\n                s.push_back(\"Push\");\\n                if(j==target.size())\\n                    return s;\\n            }\\n            else{\\n                s.push_back(\"Push\");\\n                s.push_back(\"Pop\");\\n            }\\n              \\n         }\\n         return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622052,
                "title": "simple-python-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def buildArray(self, target: List[int], n: int) -> List[str]:\\n        a = []\\n        for i in range(1, max(target)+1):\\n            if i in target:\\n                a.append(\"Push\")\\n            else:\\n                a.append(\"Push\")\\n                a.append(\"Pop\")\\n        return a\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def buildArray(self, target: List[int], n: int) -> List[str]:\\n        a = []\\n        for i in range(1, max(target)+1):\\n            if i in target:\\n                a.append(\"Push\")\\n            else:\\n                a.append(\"Push\")\\n                a.append(\"Pop\")\\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3431585,
                "title": "beats-100-solutions-in-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCompare target and number of iteration of the loop\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string> v;\\n        int j=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(target[j]==i+1)\\n            {\\n                j++;\\n                v.push_back(\"Push\");\\n                if(j==target.size())\\n                {\\n                    return v;\\n                }\\n            }\\n            else\\n            {\\n                v.push_back(\"Push\");\\n                v.push_back(\"Pop\");\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string> v;\\n        int j=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(target[j]==i+1)\\n            {\\n                j++;\\n                v.push_back(\"Push\");\\n                if(j==target.size())\\n                {\\n                    return v;\\n                }\\n            }\\n            else\\n            {\\n                v.push_back(\"Push\");\\n                v.push_back(\"Pop\");\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349287,
                "title": "c-100-faster-3-lines-only-o-n-1-pass",
                "content": "**Intuition**\\n- While traversing through the stream of the integers in the range `[1, n]`\\n- We `push` for each one of  integer in stream until target is available\\n- If `target[j]` has that integer from stream then we increment to get next target `j + 1`\\n- otherwise, we push `pop`\\n\\n**Code**\\n```c++\\n vector<string> buildArray(vector<int>& target, int n, vector<string> res = {}) {\\n        auto len = target.size();\\n        for (int i = 1, j = 0; i <= n && j < len; i++) {\\n            res.push_back(\"Push\");\\n            if (target[j] == i) j++; else res.push_back(\"Pop\");\\n        }\\n        return res;\\n}\\n```\\n\\n**Complexity**\\nTime: `O(n)`\\nSpace:  `O(n)`\\n\\n**For more solutions, check out this \\uD83C\\uDFC6  [GITHUB REPOSITORY](https://github.com/MuhtasimTanmoy/playground) with over 1500+ solutions.**",
                "solutionTags": [],
                "code": "```c++\\n vector<string> buildArray(vector<int>& target, int n, vector<string> res = {}) {\\n        auto len = target.size();\\n        for (int i = 1, j = 0; i <= n && j < len; i++) {\\n            res.push_back(\"Push\");\\n            if (target[j] == i) j++; else res.push_back(\"Pop\");\\n        }\\n        return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3344525,
                "title": "very-easy-solution-with-space-complexity-o-1",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n\\n        vector<string>v; int p=0; int s=target.size();\\n        int a=target[s-1];\\n        for(int i=1;i<=a;i++)\\n        {   \\n            if(p<s && i==target[p] )\\n            {v.push_back(\"Push\");\\n             p++;\\n             \\n            } \\n           else \\n             {\\n               v.push_back(\"Push\");\\n               v.push_back(\"Pop\");\\n             } \\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n\\n        vector<string>v; int p=0; int s=target.size();\\n        int a=target[s-1];\\n        for(int i=1;i<=a;i++)\\n        {   \\n            if(p<s && i==target[p] )\\n            {v.push_back(\"Push\");\\n             p++;\\n             \\n            } \\n           else \\n             {\\n               v.push_back(\"Push\");\\n               v.push_back(\"Pop\");\\n             } \\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146692,
                "title": "o-n-time-o-1-space-0ms-runtime-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string>res;\\n        int val=target[target.size()-1];\\n        int it=0;\\n        for(int i=1;i<=val && it<target.size();i++){\\n            if(i==target[it]){\\n                res.push_back(\"Push\");\\n                it++;\\n            }else{\\n                res.push_back(\"Push\");\\n                res.push_back(\"Pop\");\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string>res;\\n        int val=target[target.size()-1];\\n        int it=0;\\n        for(int i=1;i<=val && it<target.size();i++){\\n            if(i==target[it]){\\n                res.push_back(\"Push\");\\n                it++;\\n            }else{\\n                res.push_back(\"Push\");\\n                res.push_back(\"Pop\");\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3106656,
                "title": "best-easy-approach-100-acceptance-python-3",
                "content": "# Intuition\\n# ***Please Upvote My Solution***\\n\\n# Approach\\nSimple Iteration\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def buildArray(self, target: List[int], n: int) -> List[str]:\\n        lst=[]\\n        for i in range(1,n+1):\\n            if i in target:\\n                lst.append(\"Push\")\\n            else:\\n                lst.append(\"Push\")\\n                lst.append(\"Pop\")\\n            if i==target[-1]:\\n                break\\n        return lst\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def buildArray(self, target: List[int], n: int) -> List[str]:\\n        lst=[]\\n        for i in range(1,n+1):\\n            if i in target:\\n                lst.append(\"Push\")\\n            else:\\n                lst.append(\"Push\")\\n                lst.append(\"Pop\")\\n            if i==target[-1]:\\n                break\\n        return lst\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2943084,
                "title": "simple-solution-using-for-loop-in-c-must-see",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string>ans;\\n        int j=0;\\n        for(int i=1; i<=n ;i++){\\n            if(j==target.size()){\\n                break;\\n            }\\n            if(target[j]==i){\\n                ans.push_back(\"Push\");\\n                j++;\\n            }\\n            else{\\n                 ans.push_back(\"Push\");\\n                 ans.push_back(\"Pop\");\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string>ans;\\n        int j=0;\\n        for(int i=1; i<=n ;i++){\\n            if(j==target.size()){\\n                break;\\n            }\\n            if(target[j]==i){\\n                ans.push_back(\"Push\");\\n                j++;\\n            }\\n            else{\\n                 ans.push_back(\"Push\");\\n                 ans.push_back(\"Pop\");\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2917420,
                "title": "c-solution-beats-100-runtime",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public IList<string> BuildArray(int[] target, int n) {\\n        var operations = new List<string>();\\n\\n        var targetIndex = 0;\\n\\n        for (var i = 1; i <= n && targetIndex < target.Length; i++)\\n        {\\n            if(i == target[targetIndex])\\n            {\\n                operations.Add(\"Push\");\\n                targetIndex++;\\n            }\\n            else\\n            {\\n                operations.Add(\"Push\");\\n                operations.Add(\"Pop\");\\n            }\\n        }\\n\\n        return operations;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<string> BuildArray(int[] target, int n) {\\n        var operations = new List<string>();\\n\\n        var targetIndex = 0;\\n\\n        for (var i = 1; i <= n && targetIndex < target.Length; i++)\\n        {\\n            if(i == target[targetIndex])\\n            {\\n                operations.Add(\"Push\");\\n                targetIndex++;\\n            }\\n            else\\n            {\\n                operations.Add(\"Push\");\\n                operations.Add(\"Pop\");\\n            }\\n        }\\n\\n        return operations;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2800649,
                "title": "easy-and-fast-c-sol",
                "content": "# Intuition\\nArray is sorted and we need to perform two operation push and pop.so we can use binary serach.\\n\\n# Approach\\n for all 1 to n we have two cases element is present or not in target arrray.so to cehck i use binaray seach.if it is present i simply push that element in array otherwise i will do push and pop.also check whether is last element or not if it is then just break the loop.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string>ans;\\n        int maxi=target[target.size()-1];\\n        for(int i=1;i<=n;i++)\\n        {\\n             if(i>maxi)\\n              break;\\n              if(binary_search(target.begin(),target.end(),i))\\n              {\\n                  ans.push_back(\"Push\");\\n                 \\n              }\\n              else \\n               ans.push_back(\"Push\"), ans.push_back(\"Pop\");\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string>ans;\\n        int maxi=target[target.size()-1];\\n        for(int i=1;i<=n;i++)\\n        {\\n             if(i>maxi)\\n              break;\\n              if(binary_search(target.begin(),target.end(),i))\\n              {\\n                  ans.push_back(\"Push\");\\n                 \\n              }\\n              else \\n               ans.push_back(\"Push\"), ans.push_back(\"Pop\");\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2769533,
                "title": "c-easy-solution-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        stack<int> st;\\n        int j=0;\\n        vector<string> ans;\\n        for(int i=1;i<=n && j<target.size();i++)\\n        {\\n            st.push(i);\\n            ans.push_back(\"Push\");\\n            if(st.top()!=target[j])\\n            {\\n                st.pop();\\n                ans.push_back(\"Pop\");\\n            }\\n            else j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        stack<int> st;\\n        int j=0;\\n        vector<string> ans;\\n        for(int i=1;i<=n && j<target.size();i++)\\n        {\\n            st.push(i);\\n            ans.push_back(\"Push\");\\n            if(st.top()!=target[j])\\n            {\\n                st.pop();\\n                ans.push_back(\"Pop\");\\n            }\\n            else j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2728707,
                "title": "c-100-fast",
                "content": "\\'\\'\\'\\n\\n\\nclass Solution {\\npublic:\\n\\n\\n    vector<string> buildArray(vector<int>& num, int n) {\\n        int curr=1;\\n        vector<string> res;\\n        for(int i=0;i<num.size();i++){\\n            if(curr==num[i]){\\n                res.push_back(\"Push\");\\n                curr++;\\n            }\\n            \\n            \\n            else{\\n                while(curr!=num[i] && curr<=n){\\n                res.push_back(\"Push\");\\n                res.push_back(\"Pop\");\\n                \\n                curr++;\\n                }\\n            \\n            if(curr<=n && curr==num[i]){\\n                res.push_back(\"Push\");\\n                curr++;\\n               }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n\\'\\'\\'",
                "solutionTags": [
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n\\n\\n    vector<string> buildArray(vector<int>& num, int n) {\\n        int curr=1;\\n        vector<string> res;\\n        for(int i=0;i<num.size();i++){\\n            if(curr==num[i]){\\n                res.push_back(\"Push\");\\n                curr++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2717833,
                "title": "c-solution-100-faster-than-others",
                "content": "class Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n       int c=1,i=0;\\n       vector <string> result;\\n       while (c<=n && i<target.size()){\\n           if (c==target[i]){\\n              result.emplace_back(\"Push\");\\n              i++;  \\n           }\\n           else{\\n               result.emplace_back(\"Push\");\\n               result.emplace_back(\"Pop\");\\n           }\\n           c++;\\n       }\\n       return result; \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n       int c=1,i=0;\\n       vector <string> result;\\n       while (c<=n && i<target.size()){\\n           if (c==target[i]){\\n              result.emplace_back(\"Push\");\\n              i++;  \\n           }",
                "codeTag": "Java"
            },
            {
                "id": 2642764,
                "title": "c-easy-to-understand-100-by-time-and-97-by-space",
                "content": "```\\nvector<string> buildArray(vector<int>& target, int n) {\\n        vector<string> v;\\n        int i = 0, m = target.size(); int c = 1;\\n        while(i<m){\\n            while(c!=target[i]){\\n\\t\\t\\t// Just do this operation till the no. doesn\\'t match\\n                v.push_back(\"Push\"); v.push_back(\"Pop\"); c++;\\n            }\\n\\t\\t\\t// Or else go with the normal flow\\n            v.push_back(\"Push\"); \\n            c++; i++;\\n        }\\n        return v;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<string> buildArray(vector<int>& target, int n) {\\n        vector<string> v;\\n        int i = 0, m = target.size(); int c = 1;\\n        while(i<m){\\n            while(c!=target[i]){\\n\\t\\t\\t// Just do this operation till the no. doesn\\'t match\\n                v.push_back(\"Push\"); v.push_back(\"Pop\"); c++;\\n            }\\n\\t\\t\\t// Or else go with the normal flow\\n            v.push_back(\"Push\"); \\n            c++; i++;\\n        }\\n        return v;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2640406,
                "title": "python-2-pointers-time-o-n-space-o-1",
                "content": "Idea: 2 pointers to track target and stream separately, using the fact that target elements are increasing\\nTime; O(n)\\nSpace: O(1)\\n\\n\\n\\'\\'\\'\\n\\n    def buildArray(self, target: List[int], n: int) -> List[str]:\\n        res = []\\n        cur = 0 # cur to track target list index\\n        for i in range(1, target[-1]+1): # i to scan over stream element (not index, thus starting from 1)          \\n            if target[cur] == i:\\n                res.append(\\'Push\\')\\n                cur += 1\\n            else: # target[cur] > stream element i, then i is missing in target list\\n                res.append(\\'Push\\')\\n                res.append(\\'Pop\\')\\n        return res\\n\\'\\'\\'",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "Idea: 2 pointers to track target and stream separately, using the fact that target elements are increasing\\nTime; O(n)\\nSpace: O(1)\\n\\n\\n\\'\\'\\'\\n\\n    def buildArray(self, target: List[int], n: int) -> List[str]:\\n        res = []\\n        cur = 0 # cur to track target list index\\n        for i in range(1, target[-1]+1): # i to scan over stream element (not index, thus starting from 1)          \\n            if target[cur] == i:\\n                res.append(\\'Push\\')\\n                cur += 1\\n            else: # target[cur] > stream element i, then i is missing in target list\\n                res.append(\\'Push\\')\\n                res.append(\\'Pop\\')\\n        return res\\n\\'\\'\\'",
                "codeTag": "Python3"
            },
            {
                "id": 2468529,
                "title": "c-100-faster-solution-easy-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        unordered_set<int>s;\\n        vector<string>result;\\n        int count=0;\\n        for(int i=0;i<target.size();i++)\\n        {\\n            s.insert(target[i]);\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(s.find(i)!=s.end())\\n            {\\n                result.push_back(\"Push\");\\n                count++;\\n            }\\n            else\\n            {\\n                result.push_back(\"Push\");\\n                                result.push_back(\"Pop\");\\n\\n            }\\n            if(count==target.size())\\n                break;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        unordered_set<int>s;\\n        vector<string>result;\\n        int count=0;\\n        for(int i=0;i<target.size();i++)\\n        {\\n            s.insert(target[i]);\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(s.find(i)!=s.end())\\n            {\\n                result.push_back(\"Push\");\\n                count++;\\n            }\\n            else\\n            {\\n                result.push_back(\"Push\");\\n                                result.push_back(\"Pop\");\\n\\n            }\\n            if(count==target.size())\\n                break;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2465412,
                "title": "easy-intuition-c-greedy",
                "content": "```\\n vector<string> buildArray(vector<int>& target, int n) {\\n        \\n        vector<string> ans;\\n        int num=1;\\n        for(int i=0;i<target.size();i++)\\n        {\\n            while(num<target[i])   // Eg : [3 4 6]  1,2 push pop push pop \\n            {\\n                ans.push_back(\"Push\");\\n                ans.push_back(\"Pop\");\\n                num++;\\n            }\\n            ans.push_back(\"Push\");  // num=3 now sirf push hoga ab\\n            num++;  //num is now 4 agla number 4 check krna hume agli iteration pe\\n        }\\n        return ans;\\n    }\\n",
                "solutionTags": [],
                "code": "```\\n vector<string> buildArray(vector<int>& target, int n) {\\n        \\n        vector<string> ans;\\n        int num=1;\\n        for(int i=0;i<target.size();i++)\\n        {\\n            while(num<target[i])   // Eg : [3 4 6]  1,2 push pop push pop \\n            {\\n                ans.push_back(\"Push\");\\n                ans.push_back(\"Pop\");\\n                num++;\\n            }\\n            ans.push_back(\"Push\");  // num=3 now sirf push hoga ab\\n            num++;  //num is now 4 agla number 4 check krna hume agli iteration pe\\n        }\\n        return ans;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2416347,
                "title": "easy-to-understand-0ms-c",
                "content": "\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<string> buildArray(vector<int>& target, int n) {\\n\\t\\t\\tvector<string>vec;\\n\\t\\t\\tint m = target[target.size()-1];\\n\\t\\t\\tint j=0;\\n\\t\\t\\tfor(int i=1; i<=m; i++){\\n\\t\\t\\t\\tif(i == target[j]){\\n\\t\\t\\t\\t\\tvec.push_back(\"Push\");\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tvec.push_back(\"Push\");\\n\\t\\t\\t\\t\\tvec.push_back(\"Pop\");\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn vec;\\n\\t\\t}\\n\\t};\\n\\'\\'\\'\\n\\nif it is helpful, you are smart enough what to do \\uD83D\\uDC4D   \\nfor any doubt comment below  : )",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<string> buildArray(vector<int>& target, int n) {\\n\\t\\t\\tvector<string>vec;\\n\\t\\t\\tint m = target[target.size()-1];\\n\\t\\t\\tint j=0;\\n\\t\\t\\tfor(int i=1; i<=m; i++){\\n\\t\\t\\t\\tif(i == target[j]){\\n\\t\\t\\t\\t\\tvec.push_back(\"Push\");\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2384079,
                "title": "c-linear-time-stack-based-solution",
                "content": "The question is to mimic a stack operations for given n numbers starting from 1 but the only catch is that the target array will contain the number that has to stay in the stack which means while traversing the n numbers what comes in sequence and it is present in stack the ans will contain push otherwise we have to add and remove that element which will make no difference to the target array.\\nSteps by Step\\n1.Declare an ans vector of string and a variable which starts from 1\\n2.traverse the target array and if the element is equal to target then add Push to the ans\\n3.if the target is not equal then add Push and Pop to ans vector and increment variable until it reaches the next target in the array.\\n4.Continue step three and four until end of target array \\n5.return ans vector\\n\\nCode\\n```\\nvector<string> buildArray(vector<int>& target, int n) {\\n        vector<string> ans;\\n        int num=1;\\n        for(int i=0;i<target.size();)\\n        {\\n            if(target[i]==num)\\n            {\\n                ans.push_back(\"Push\");\\n                num+=1;\\n                i++;\\n            }else{\\n                ans.push_back(\"Push\");\\n                ans.push_back(\"Pop\");\\n                num+=1;\\n            }\\n        }\\n        return ans;\\n    }\\n```\\nWe could do it with while loop inside for loop but we are only moving forward in the array when variable meets target.One can absolutely do it in the either way.",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nvector<string> buildArray(vector<int>& target, int n) {\\n        vector<string> ans;\\n        int num=1;\\n        for(int i=0;i<target.size();)\\n        {\\n            if(target[i]==num)\\n            {\\n                ans.push_back(\"Push\");\\n                num+=1;\\n                i++;\\n            }else{\\n                ans.push_back(\"Push\");\\n                ans.push_back(\"Pop\");\\n                num+=1;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2319984,
                "title": "c-o-n-solution-using-vector",
                "content": "class Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        \\n        vector<string> ans;\\n        int m=target.size();\\n        int i=1,j=0;\\n        \\n        while(i<=n){\\n            if(i==target[j]){\\n                ans.emplace_back(\"Push\");\\n                i++;\\n                j++;\\n            }\\n            else{\\n                ans.emplace_back(\"Push\");\\n                ans.emplace_back(\"Pop\");\\n                i++;   \\n            } \\n            \\n            if(j==m){\\n                break;\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        \\n        vector<string> ans;\\n        int m=target.size();\\n        int i=1,j=0;\\n        \\n        while(i<=n){\\n            if(i==target[j]){\\n                ans.emplace_back(\"Push\");\\n                i++;\\n                j++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2304869,
                "title": "c-solution-build-an-array-with-stack-operations",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string> ans;\\n        \\n        int j = 1;\\n        \\n        for(int i = 0 ; i < target.size() ; ){\\n            if(target[i] == j){\\n                ans.push_back(\"Push\");\\n                i++;\\n            }\\n            else{\\n                ans.push_back(\"Push\");\\n                ans.push_back(\"Pop\");\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string> ans;\\n        \\n        int j = 1;\\n        \\n        for(int i = 0 ; i < target.size() ; ){\\n            if(target[i] == j){\\n                ans.push_back(\"Push\");\\n                i++;\\n            }\\n            else{\\n                ans.push_back(\"Push\");\\n                ans.push_back(\"Pop\");\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2272899,
                "title": "c-very-easy-code-100-faster",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string> res;\\n        int j=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            res.push_back(\"Push\");\\n            if(target[j]==i)\\n                j++;\\n            else\\n               res.push_back(\"Pop\"); \\n            if(j==target.size())\\n                break;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string> res;\\n        int j=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            res.push_back(\"Push\");\\n            if(target[j]==i)\\n                j++;\\n            else\\n               res.push_back(\"Pop\"); \\n            if(j==target.size())\\n                break;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2166637,
                "title": "java-easy-solution-runtime-1ms",
                "content": "class Solution {\\n    public List<String> buildArray(int[] target, int n) {\\n        \\n        int len = target.length;\\n        \\n        List<String> output = new ArrayList<>();\\n        \\n        int counter=1;\\n        \\n        for(int i=0; i<len; i++){\\n            if(target[i]==counter) output.add(\"Push\");\\n            else{\\n                output.add(\"Push\");\\n                output.add(\"Pop\");\\n                i--;\\n            }\\n            counter++;\\n        }\\n        \\n        return output;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<String> buildArray(int[] target, int n) {\\n        \\n        int len = target.length;\\n        \\n        List<String> output = new ArrayList<>();\\n        \\n        int counter=1;\\n        \\n        for(int i=0; i<len; i++){\\n            if(target[i]==counter) output.add(\"Push\");\\n            else{\\n                output.add(\"Push\");\\n                output.add(\"Pop\");\\n                i--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2132539,
                "title": "easiest-ever-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string>ans;\\n        int p=0;\\n        \\n        for(int i=1;i<=n;i++){\\n          if(p==target.size()){\\n              return ans;\\n          }\\n            \\n            if(i==target[p]){\\n              ans.push_back(\"Push\");\\n                p++;\\n            }\\n            else{\\n                ans.push_back(\"Push\");\\n                ans.push_back(\"Pop\");\\n            }\\n            // p++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string>ans;\\n        int p=0;\\n        \\n        for(int i=1;i<=n;i++){\\n          if(p==target.size()){\\n              return ans;\\n          }\\n            \\n            if(i==target[p]){\\n              ans.push_back(\"Push\");\\n                p++;\\n            }\\n            else{\\n                ans.push_back(\"Push\");\\n                ans.push_back(\"Pop\");\\n            }\\n            // p++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2060866,
                "title": "java-solution-100-0-ms",
                "content": "public List<String> buildArray(int[] target, int n) {\\n        List<String> list = new ArrayList<>();\\n        int startNum = 1;\\n\\n        for (int i = 0; i < target.length;  startNum++) {\\n            if (target[i] == startNum) {\\n                list.add(\"Push\");\\n                i++;\\n            } else {\\n                list.add(\"Push\");\\n                list.add(\"Pop\");\\n            }\\n        }\\n\\n        return list;\\n    }",
                "solutionTags": [],
                "code": "public List<String> buildArray(int[] target, int n) {\\n        List<String> list = new ArrayList<>();\\n        int startNum = 1;\\n\\n        for (int i = 0; i < target.length;  startNum++) {\\n            if (target[i] == startNum) {\\n                list.add(\"Push\");\\n                i++;\\n            } else {\\n                list.add(\"Push\");\\n                list.add(\"Pop\");\\n            }\\n        }\\n\\n        return list;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2036828,
                "title": "simple-c-code-100-time-81-96-memory",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string> ans;\\n        int idx = 0, sz = target.size();\\n        int i = 1;\\n        while(i <= n)\\n        {\\n            if(idx < sz)\\n            {\\n                if(target[idx] == i)\\n                {\\n                    ans.push_back(\"Push\");\\n                    idx++;\\n                }\\n                else\\n                {\\n                    ans.push_back(\"Push\");\\n                    ans.push_back(\"Pop\");\\n                }\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string> ans;\\n        int idx = 0, sz = target.size();\\n        int i = 1;\\n        while(i <= n)\\n        {\\n            if(idx < sz)\\n            {\\n                if(target[idx] == i)\\n                {\\n                    ans.push_back(\"Push\");\\n                    idx++;\\n                }\\n                else\\n                {\\n                    ans.push_back(\"Push\");\\n                    ans.push_back(\"Pop\");\\n                }\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1989367,
                "title": "fastest-java-solution-using-stack-0ms",
                "content": "![image](https://assets.leetcode.com/users/images/a915c294-e012-4e6f-998d-bdc540316f9c_1651160234.7964022.jpeg)\\n```\\nclass Solution {\\n    public List<String> buildArray(int[] target, int n) \\n    {\\n        Stack<String> stk = new Stack<>();\\n        int i=1;\\n        int pos=0;\\n        while(pos<target.length)\\n        {\\n            stk.push(\"Push\");\\n            if(i!=target[pos])\\n                stk.push(\"Pop\");\\n            else\\n                pos++;\\n            i++;\\n        }\\n        return stk;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Stack"
                ],
                "code": "class Solution {\\n    public List<String> buildArray(int[] target, int n) \\n    {\\n        Stack<String> stk = new Stack<>();\\n        int i=1;\\n        int pos=0;\\n        while(pos<target.length)\\n        {\\n            stk.push(\"Push\");\\n            if(i!=target[pos])\\n                stk.push(\"Pop\");\\n            else\\n                pos++;\\n            i++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1981598,
                "title": "c-one-pass-solution",
                "content": "**One Pass Solution**\\n\\n```\\nvector<string> buildArray(vector<int>& target, int n) {\\n        int i=0,m = target.size(),j=1;\\n        vector<string>str;\\n        vector<int>list;\\n        while(j<=n && i<m){\\n                list.push_back(j);\\n                j++;\\n                str.push_back(\"Push\");\\n            if(list.size() && target[i] != list.back()){\\n                str.push_back(\"Pop\");\\n            }\\n            if(list.size() && target[i] == list.back())i++;\\n        }\\n        return str;\\n    }\\n```\\n\\n\\n**TC : O(N)**\\n**SC : O(N)**\\n\\n*:) Happy Coding \\uD83C\\uDF88*",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<string> buildArray(vector<int>& target, int n) {\\n        int i=0,m = target.size(),j=1;\\n        vector<string>str;\\n        vector<int>list;\\n        while(j<=n && i<m){\\n                list.push_back(j);\\n                j++;\\n                str.push_back(\"Push\");\\n            if(list.size() && target[i] != list.back()){\\n                str.push_back(\"Pop\");\\n            }\\n            if(list.size() && target[i] == list.back())i++;\\n        }\\n        return str;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1972470,
                "title": "c-easy-solution-using-stack-beats-100-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& t, int n) {\\n        vector<string> s;\\n        stack<int> a;\\n        for(int i=n;i>=1;i--)\\n        {\\n            a.push(i);\\n        }\\n        for(int i=0;i<t.size();)\\n        {\\n            if(t[i]==a.top())\\n            {\\n                s.push_back(\"Push\");\\n                a.pop();\\n                i++;\\n            }\\n            else\\n            {\\n                s.push_back(\"Push\");\\n                s.push_back(\"Pop\");\\n                a.pop();\\n            }\\n            \\n            \\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& t, int n) {\\n        vector<string> s;\\n        stack<int> a;\\n        for(int i=n;i>=1;i--)\\n        {\\n            a.push(i);\\n        }\\n        for(int i=0;i<t.size();)\\n        {\\n            if(t[i]==a.top())\\n            {\\n                s.push_back(\"Push\");\\n                a.pop();\\n                i++;\\n            }\\n            else\\n            {\\n                s.push_back(\"Push\");\\n                s.push_back(\"Pop\");\\n                a.pop();\\n            }\\n            \\n            \\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1879425,
                "title": "beginner-friendly-java-solution",
                "content": "```\\nclass Solution {\\n    public List<String> buildArray(int[] target, int n) {\\n        Set<Integer> set = Arrays.stream(target).boxed().collect(Collectors.toSet());\\n        Stack<String> stack = new Stack<>();\\n        for(int i=1; i<=target[target.length-1]; i++){\\n            stack.push(\"Push\");\\n            if(!set.contains(i))     stack.push(\"Pop\");\\n        }\\n        return stack;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> buildArray(int[] target, int n) {\\n        Set<Integer> set = Arrays.stream(target).boxed().collect(Collectors.toSet());\\n        Stack<String> stack = new Stack<>();\\n        for(int i=1; i<=target[target.length-1]; i++){\\n            stack.push(\"Push\");\\n            if(!set.contains(i))     stack.push(\"Pop\");\\n        }\\n        return stack;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1879410,
                "title": "beginner-friendly-javascript-solution",
                "content": "```\\n/**\\n * @param {number[]} target\\n * @param {number} n\\n * @return {string[]}\\n */\\nvar buildArray = function(target, n) {\\n    let set = new Set(target)\\n    var list = []\\n    for(let i=1; i<=target[target.length-1]; i++){\\n        list.push(\"Push\")\\n        if(!set.has(i))     list.push(\"Pop\")\\n    }\\n    return list\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} target\\n * @param {number} n\\n * @return {string[]}\\n */\\nvar buildArray = function(target, n) {\\n    let set = new Set(target)\\n    var list = []\\n    for(let i=1; i<=target[target.length-1]; i++){\\n        list.push(\"Push\")\\n        if(!set.has(i))     list.push(\"Pop\")\\n    }\\n    return list\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1879404,
                "title": "beginner-friendly-python-solution",
                "content": "```\\nclass Solution(object):\\n    def buildArray(self, target, n):\\n        s = set(target)\\n        list = []\\n        for i in range(1, target[-1]+1):\\n            list.append(\"Push\")\\n            if i not in s:\\n                list.append(\"Pop\")\\n        return list\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def buildArray(self, target, n):\\n        s = set(target)\\n        list = []\\n        for i in range(1, target[-1]+1):\\n            list.append(\"Push\")\\n            if i not in s:\\n                list.append(\"Pop\")\\n        return list\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1869894,
                "title": "c-o-n-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string> v;\\n        int i,j, l=target.size();\\n        for(i=1, j=0; (i<=n)&&(j<l); ++i,++j){\\n            if(i==target[j]){\\n                v.push_back(\"Push\");\\n            }\\n            else{\\n                v.push_back(\"Push\");\\n                v.push_back(\"Pop\");\\n                --j;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string> v;\\n        int i,j, l=target.size();\\n        for(i=1, j=0; (i<=n)&&(j<l); ++i,++j){\\n            if(i==target[j]){\\n                v.push_back(\"Push\");\\n            }\\n            else{\\n                v.push_back(\"Push\");\\n                v.push_back(\"Pop\");\\n                --j;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1792059,
                "title": "python-simply-check-if-the-current-index-reaches-the-last-target-index",
                "content": "```\\nclass Solution:\\n    def buildArray(self, t: List[int], n: int) -> List[str]:\\n        m = {1: \"Push\", 2: \"Pop\"}\\n        r = []\\n        for i in range(1, n + 1):\\n            if i in t:\\n                r.append(m[1])\\n            else:\\n                r.append(m[1])\\n                r.append(m[2])\\n            if i == t[-1]:\\n                break\\n        return r\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def buildArray(self, t: List[int], n: int) -> List[str]:\\n        m = {1: \"Push\", 2: \"Pop\"}\\n        r = []\\n        for i in range(1, n + 1):\\n            if i in t:\\n                r.append(m[1])\\n            else:\\n                r.append(m[1])\\n                r.append(m[2])\\n            if i == t[-1]:\\n                break\\n        return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1718506,
                "title": "logic-ignore-n-0-milliseconds",
                "content": "*simply end the iterations at the last value of target i.e. target[target.length-1]...\\nFor example - if we want [1,5] from n=7, we can ignore n=7 and simply check till 5 whether all values are present or not! if yes then add \"Push\" else add \"Push\" + \"Pop\".*\\n```\\nclass Solution {\\n    public List<String> buildArray(int[] target, int n) {\\n        \\n        List<String> l = new ArrayList<String>();\\n        \\n        int start=1;\\n        int end= target[target.length-1];\\n        int ptr= 0;\\n        \\n        while(start<=end){\\n            if (start==target[ptr]){\\n                l.add(\"Push\");\\n                start++;\\n                ptr++;\\n            }\\n            else{\\n                l.add(\"Push\");\\n                l.add(\"Pop\");\\n                start++;\\n            }\\n        }\\n        \\n        return l;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> buildArray(int[] target, int n) {\\n        \\n        List<String> l = new ArrayList<String>();\\n        \\n        int start=1;\\n        int end= target[target.length-1];\\n        int ptr= 0;\\n        \\n        while(start<=end){\\n            if (start==target[ptr]){\\n                l.add(\"Push\");\\n                start++;\\n                ptr++;\\n            }\\n            else{\\n                l.add(\"Push\");\\n                l.add(\"Pop\");\\n                start++;\\n            }\\n        }\\n        \\n        return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1704349,
                "title": "simple-python-solution-faster-than-95-explanation",
                "content": "### Iterate through till the last element that is n (given). Check for each number if it is present in target. If it is present , append (\"Push\") , else append (\"Push\" and \"Pop\"). \\n### The break condition is there because of the following case. Suppose the given array is this -> [1,3,5,7], and given \\'n\\' is 3. Once we reach 3, we do not want to waste time going any further, hence this line of code here.\\n\\t\\t if(i+1 > max(target)):\\n                break \\n\\n### Incase of any doubt, mention it in the replies, please don\\'t forget to upvote if you understand it :D\\n``` class Solution:\\n    def buildArray(self, target: List[int], n: int) -> List[str]:\\n        \\n        operations = []\\n        \\n        for i in range(n):\\n            if(i+1 > max(target)):\\n                break\\n            if (i+1 in target):\\n                operations.append(\"Push\")\\n            else:\\n                operations.append(\"Push\")\\n                operations.append(\"Pop\")\\n        return operations",
                "solutionTags": [
                    "Python"
                ],
                "code": "### Iterate through till the last element that is n (given). Check for each number if it is present in target. If it is present , append (\"Push\") , else append (\"Push\" and \"Pop\"). \\n### The break condition is there because of the following case. Suppose the given array is this -> [1,3,5,7], and given \\'n\\' is 3. Once we reach 3, we do not want to waste time going any further, hence this line of code here.\\n\\t\\t if(i+1 > max(target)):\\n                break \\n\\n### Incase of any doubt, mention it in the replies, please don\\'t forget to upvote if you understand it :D\\n``` class Solution:\\n    def buildArray(self, target: List[int], n: int) -> List[str]:\\n        \\n        operations = []\\n        \\n        for i in range(n):\\n            if(i+1 > max(target)):\\n                break\\n            if (i+1 in target):\\n                operations.append(\"Push\")\\n            else:\\n                operations.append(\"Push\")\\n                operations.append(\"Pop\")\\n        return operations",
                "codeTag": "Java"
            },
            {
                "id": 1697446,
                "title": "python-solution",
                "content": "## Short\\n```\\nclass Solution:\\n    def buildArray(self, target: List[int], n: int) -> List[str]:\\n        return chain(*[[\\'Push\\'] if i in set(target) else [\\'Push\\', \\'Pop\\'] for i in range(1, max(target) + 1)])\\n```\\n## Long\\n```\\nclass Solution:\\n    def buildArray(self, target: List[int], n: int) -> List[str]:\\n        target = set(target)\\n        max_val = max(target)\\n        res = []\\n      \\n        for i in range(1, n + 1):\\n            res.append(\\'Push\\')\\n            if i == max_val: break\\n            if i not in target:\\n                res.append(\\'Pop\\')\\n                \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def buildArray(self, target: List[int], n: int) -> List[str]:\\n        return chain(*[[\\'Push\\'] if i in set(target) else [\\'Push\\', \\'Pop\\'] for i in range(1, max(target) + 1)])\\n```\n```\\nclass Solution:\\n    def buildArray(self, target: List[int], n: int) -> List[str]:\\n        target = set(target)\\n        max_val = max(target)\\n        res = []\\n      \\n        for i in range(1, n + 1):\\n            res.append(\\'Push\\')\\n            if i == max_val: break\\n            if i not in target:\\n                res.append(\\'Pop\\')\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1692396,
                "title": "c-solution-faster-than-100",
                "content": "class Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string> ans;\\n        int c=1;\\n        for(int i=0;i<target.size();)\\n        {\\n            if(c==target[i])\\n            {\\n                ans.push_back(\"Push\");\\n                i++;\\n            }\\n            else{\\n                ans.push_back(\"Push\");\\n                ans.push_back(\"Pop\");\\n            }\\n            c++;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string> ans;\\n        int c=1;\\n        for(int i=0;i<target.size();)\\n        {\\n            if(c==target[i])\\n            {\\n                ans.push_back(\"Push\");\\n                i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1681566,
                "title": "c-runtime-0-ms-faster-than-100-00-memory-usage-7-7-mb-less-than-95-44",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string> ret;\\n        vector<int> numbers;\\n        numbers.reserve(n);\\n        for(int i=1; i<n+1; i++){\\n           numbers.emplace_back(i); \\n        }\\n        int i=0, j=0;\\n        while(i<target.size()){\\n            if(target[i++]==numbers[j++]){\\n                ret.push_back(\"Push\");\\n            }\\n            else{\\n                ret.push_back(\"Push\");\\n                ret.push_back(\"Pop\");\\n                i--;\\n            }\\n           \\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string> ret;\\n        vector<int> numbers;\\n        numbers.reserve(n);\\n        for(int i=1; i<n+1; i++){\\n           numbers.emplace_back(i); \\n        }\\n        int i=0, j=0;\\n        while(i<target.size()){\\n            if(target[i++]==numbers[j++]){\\n                ret.push_back(\"Push\");\\n            }\\n            else{\\n                ret.push_back(\"Push\");\\n                ret.push_back(\"Pop\");\\n                i--;\\n            }\\n           \\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1674973,
                "title": "easy-c-solution-0ms-runtime",
                "content": "* We\\'re maintaining a variable cnt which is initialised as 1 to maintain the [1,2,3...n] list.\\n* Whenever cnt != target we are adding the statements push and pop.\\n\\n```\\n vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string> ans;\\n        int cnt = 1;\\n        \\n        for(int i=0; i<target.size(); i++ ,cnt++){\\n            if(target[i] == cnt){\\n                ans.push_back(\"Push\");\\n            }else{\\n                ans.push_back(\"Push\");\\n                ans.push_back(\"Pop\");\\n                i--;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```\\n\\nHope this helps!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string> ans;\\n        int cnt = 1;\\n        \\n        for(int i=0; i<target.size(); i++ ,cnt++){\\n            if(target[i] == cnt){\\n                ans.push_back(\"Push\");\\n            }else{\\n                ans.push_back(\"Push\");\\n                ans.push_back(\"Pop\");\\n                i--;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1618550,
                "title": "java-faster-than-100",
                "content": "```\\nclass Solution {\\n    public List<String> buildArray(int[] target, int n) {\\n        List<String> answer = new ArrayList<String>();\\n        int[] temp = new int[n + 1];\\n        for(int i = 1; i <= n; i++) {\\n            temp[i] = i;\\n        }\\n        \\n        int j = 1;\\n        for(int i = 0; i < target.length;) {\\n            if(target[i] == temp[j]) {\\n                answer.add(\"Push\");\\n                j++;\\n                i++;\\n            }\\n            else {\\n                answer.add(\"Push\");\\n                answer.add(\"Pop\");\\n                j++;\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> buildArray(int[] target, int n) {\\n        List<String> answer = new ArrayList<String>();\\n        int[] temp = new int[n + 1];\\n        for(int i = 1; i <= n; i++) {\\n            temp[i] = i;\\n        }\\n        \\n        int j = 1;\\n        for(int i = 0; i < target.length;) {\\n            if(target[i] == temp[j]) {\\n                answer.add(\"Push\");\\n                j++;\\n                i++;\\n            }\\n            else {\\n                answer.add(\"Push\");\\n                answer.add(\"Pop\");\\n                j++;\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1594199,
                "title": "unordered-maps",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        unordered_map<int,bool> m;\\n        for(int i=0;i<target.size();i++){\\n            m[target[i]]=true;\\n        }\\n        vector<string> ans;\\n        for(int i=1;i<=target[target.size()-1];i++){\\n            if(m.find(i)==m.end()){\\n                ans.push_back(\"Push\");\\n                ans.push_back(\"Pop\");\\n            }\\n            if(m.find(i)!=m.end()){\\n                ans.push_back(\"Push\");\\n            } \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        unordered_map<int,bool> m;\\n        for(int i=0;i<target.size();i++){\\n            m[target[i]]=true;\\n        }\\n        vector<string> ans;\\n        for(int i=1;i<=target[target.size()-1];i++){\\n            if(m.find(i)==m.end()){\\n                ans.push_back(\"Push\");\\n                ans.push_back(\"Pop\");\\n            }\\n            if(m.find(i)!=m.end()){\\n                ans.push_back(\"Push\");\\n            } \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1571765,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {number[]} target\\n * @param {number} n\\n * @return {string[]}\\n */\\nvar buildArray = function(target, n) {\\n    let currentTargetIndex = 0\\n    let operations = []\\n    for(let i=1;i<=n && currentTargetIndex < target.length;i++) {\\n        operations.push(\"Push\")\\n        if(target[currentTargetIndex] == i) {\\n            currentTargetIndex++\\n        } else {\\n            operations.push(\"Pop\")\\n        }\\n    }\\n    return operations\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} target\\n * @param {number} n\\n * @return {string[]}\\n */\\nvar buildArray = function(target, n) {\\n    let currentTargetIndex = 0\\n    let operations = []\\n    for(let i=1;i<=n && currentTargetIndex < target.length;i++) {\\n        operations.push(\"Push\")\\n        if(target[currentTargetIndex] == i) {\\n            currentTargetIndex++\\n        } else {\\n            operations.push(\"Pop\")\\n        }\\n    }\\n    return operations\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1565127,
                "title": "java-simple-easy-to-understand-solution-faster-than-100-memory-less-than-69",
                "content": "**Upvote please**\\n```\\nclass Solution {\\n    public List<String> buildArray(int[] target, int n) {\\n        List<String> list = new ArrayList<String>(); \\n        int j = 0;\\n        for(int i = 1; i <= n; i++){\\n            if(j == target.length){\\n                break;\\n            }\\n            if(i == target[j]){\\n                list.add(\"Push\");\\n                j++;\\n            }\\n            else{\\n                list.add(\"Push\");\\n                list.add(\"Pop\");\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> buildArray(int[] target, int n) {\\n        List<String> list = new ArrayList<String>(); \\n        int j = 0;\\n        for(int i = 1; i <= n; i++){\\n            if(j == target.length){\\n                break;\\n            }\\n            if(i == target[j]){\\n                list.add(\"Push\");\\n                j++;\\n            }\\n            else{\\n                list.add(\"Push\");\\n                list.add(\"Pop\");\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1564231,
                "title": "c-o-n-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string>res;\\n        int j=0,i=0;\\n        while( j<target.size()){\\n            if(target[j]==i+1){\\n                res.push_back(\"Push\");\\n                j++;i++;\\n            }else{\\n                res.push_back(\"Push\");\\n                res.push_back(\"Pop\");\\n                i++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string>res;\\n        int j=0,i=0;\\n        while( j<target.size()){\\n            if(target[j]==i+1){\\n                res.push_back(\"Push\");\\n                j++;i++;\\n            }else{\\n                res.push_back(\"Push\");\\n                res.push_back(\"Pop\");\\n                i++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1536977,
                "title": "faster-than-100-soln-simple-cpp-code",
                "content": "If you dont understand the language, plz read Constraints once, It should clear doubts.\\n\\nDont confuse word \\'Set\\' from the set data structure.\\n```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string> ans;\\n        int m = target.size();\\n        int currValIdx = 0; //the target value which you want to generate\\n            \\n        int val = 1; // the value form the set\\n\\t\\t\\n\\t\\t// Basic logic is if the value from the set matches to the target one add \"Push\", increase \\'val\\' since its used , increase index of target since its already added.\\n\\t\\t// If \\'val\\' des not match target, add \"Push\" and \"Pop\",and increase val\\n\\t\\t// Do it until you consume the whole target array\\n        while(currValIdx < m){\\n            if(val != target[currValIdx]){\\n                ans.push_back(\"Push\");\\n                ans.push_back(\"Pop\");\\n                val++;\\n            }\\n            if(val == target[currValIdx]){\\n                ans.push_back(\"Push\");\\n                val++;\\n                currValIdx++;\\n            }\\n        }\\n        \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string> ans;\\n        int m = target.size();\\n        int currValIdx = 0; //the target value which you want to generate\\n            \\n        int val = 1; // the value form the set\\n\\t\\t\\n\\t\\t// Basic logic is if the value from the set matches to the target one add \"Push\", increase \\'val\\' since its used , increase index of target since its already added.\\n\\t\\t// If \\'val\\' des not match target, add \"Push\" and \"Pop\",and increase val\\n\\t\\t// Do it until you consume the whole target array\\n        while(currValIdx < m){\\n            if(val != target[currValIdx]){\\n                ans.push_back(\"Push\");\\n                ans.push_back(\"Pop\");\\n                val++;\\n            }\\n            if(val == target[currValIdx]){\\n                ans.push_back(\"Push\");\\n                val++;\\n                currValIdx++;\\n            }\\n        }\\n        \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1536284,
                "title": "java-solution-runtime-0-ms-faster-than-100-00",
                "content": "```\\nclass Solution {\\n    public List<String> buildArray(int[] target, int n) {\\n\\n        List<String> list = new ArrayList<>();\\n\\n        int sequence = 1;\\n        for (int i = 0; i < target.length; ) {\\n            if (target[i] == sequence) {\\n                list.add(\"Push\");\\n                i++;\\n            } else {\\n                list.add(\"Push\");\\n                list.add(\"Pop\");\\n            }\\n            sequence++;\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> buildArray(int[] target, int n) {\\n\\n        List<String> list = new ArrayList<>();\\n\\n        int sequence = 1;\\n        for (int i = 0; i < target.length; ) {\\n            if (target[i] == sequence) {\\n                list.add(\"Push\");\\n                i++;\\n            } else {\\n                list.add(\"Push\");\\n                list.add(\"Pop\");\\n            }\\n            sequence++;\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1504319,
                "title": "o-n-fast-c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string>ans; \\n        int j = 0;\\n        for(int i=1;i<=target[target.size()-1];i++)\\n        {\\n            // Had target not been sorted\\n            // ans.push_back(\"Push\");\\n            // if(find(target.begin(),target.end(),i)==target.end())\\n            // {\\n            //     ans.push_back(\"Pop\");\\n            // }\\n            while(i<target[j])\\n            {\\n                i++;\\n                ans.push_back(\"Push\");\\n                ans.push_back(\"Pop\");\\n            }\\n            \\n            if(i==target[j++])\\n            {\\n                ans.push_back(\"Push\");\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string>ans; \\n        int j = 0;\\n        for(int i=1;i<=target[target.size()-1];i++)\\n        {\\n            // Had target not been sorted\\n            // ans.push_back(\"Push\");\\n            // if(find(target.begin(),target.end(),i)==target.end())\\n            // {\\n            //     ans.push_back(\"Pop\");\\n            // }\\n            while(i<target[j])\\n            {\\n                i++;\\n                ans.push_back(\"Push\");\\n                ans.push_back(\"Pop\");\\n            }\\n            \\n            if(i==target[j++])\\n            {\\n                ans.push_back(\"Push\");\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1489122,
                "title": "easy-java-solution-100-faster",
                "content": "```\\nclass Solution {\\n    public List<String> buildArray(int[] target, int n) {\\n        List<String> st = new ArrayList<>();\\n        int k = 1;\\n        for(int i = 0; i < target.length; i++){\\n            if(k != target[i]){\\n                while(k != target[i]){\\n                    st.add(\"Push\");\\n                    st.add(\"Pop\");\\n                    k++;\\n                }\\n                st.add(\"Push\");\\n                k++;\\n            }\\n            else{\\n                st.add(\"Push\");\\n                k++;\\n            }\\n        }\\n        return st;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<String> buildArray(int[] target, int n) {\\n        List<String> st = new ArrayList<>();\\n        int k = 1;\\n        for(int i = 0; i < target.length; i++){\\n            if(k != target[i]){\\n                while(k != target[i]){\\n                    st.add(\"Push\");\\n                    st.add(\"Pop\");\\n                    k++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1449372,
                "title": "java-100-faster-code-simple-solution",
                "content": "```\\nclass Solution {\\n      static List<String> buildArray(int[] target, int n) {\\n        List<String> list = new ArrayList<>();\\n        int k=0;\\n\\t\\t\\n        for (int i = 1; i <= n; i++) {\\n            if (k<target.length && i==target[k]) {\\n                list.add(\"Push\");\\n                k++;\\n            }else if (k<target.length && i!=target[k]){\\n                list.add(\"Push\");\\n                list.add(\"Pop\");\\n            }else{\\n                break;\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n      static List<String> buildArray(int[] target, int n) {\\n        List<String> list = new ArrayList<>();\\n        int k=0;\\n\\t\\t\\n        for (int i = 1; i <= n; i++) {\\n            if (k<target.length && i==target[k]) {\\n                list.add(\"Push\");\\n                k++;\\n            }else if (k<target.length && i!=target[k]){\\n                list.add(\"Push\");\\n                list.add(\"Pop\");\\n            }else{\\n                break;\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1408215,
                "title": "python3-o-n-time-o-1-space",
                "content": "\\tclass Solution:\\n\\t\\tdef buildArray(self, target: List[int], n: int) -> List[str]:\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tRuntime: 24 ms, faster than 97.22% of Python3 online submissions for Build an Array With Stack Operations.\\n\\t\\t\\tMemory Usage: 14.2 MB, less than 51.81% of Python3 online submissions for Build an Array With Stack Operations.\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tcurr=0\\n\\t\\t\\tresult=[]\\n\\t\\t\\tl=len(target)\\n\\t\\t\\tfor i in  range(1,n+1):\\n\\t\\t\\t\\tif curr<l and target[curr]==i:\\n\\t\\t\\t\\t\\tresult.append(\"Push\")\\n\\t\\t\\t\\t\\tcurr+=1\\n\\t\\t\\t\\telif curr<l :\\n\\t\\t\\t\\t\\tresult+=[\"Push\",\"Pop\"]\\n\\t\\t\\treturn result",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef buildArray(self, target: List[int], n: int) -> List[str]:\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tRuntime: 24 ms, faster than 97.22% of Python3 online submissions for Build an Array With Stack Operations.\\n\\t\\t\\tMemory Usage: 14.2 MB, less than 51.81% of Python3 online submissions for Build an Array With Stack Operations.\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tcurr=0\\n\\t\\t\\tresult=[]\\n\\t\\t\\tl=len(target)\\n\\t\\t\\tfor i in  range(1,n+1):\\n\\t\\t\\t\\tif curr<l and target[curr]==i:\\n\\t\\t\\t\\t\\tresult.append(\"Push\")\\n\\t\\t\\t\\t\\tcurr+=1\\n\\t\\t\\t\\telif curr<l :\\n\\t\\t\\t\\t\\tresult+=[\"Push\",\"Pop\"]\\n\\t\\t\\treturn result",
                "codeTag": "Java"
            },
            {
                "id": 1391587,
                "title": "c-soln-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string> st;\\n        stack<int> s;\\n        int i=1;\\n        int j=-1;\\n        while(true)\\n        {\\n            j++;\\n            s.push(i);\\n            st.push_back(\"Push\");a\\n            if(s.top()!=target[j])\\n            {\\n                s.pop();\\n                st.push_back(\"Pop\");\\n                j--;\\n            }\\n            else if(s.size()==target.size())\\n                break;\\n            i++; \\n        }\\n        return st;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string> st;\\n        stack<int> s;\\n        int i=1;\\n        int j=-1;\\n        while(true)\\n        {\\n            j++;\\n            s.push(i);\\n            st.push_back(\"Push\");a\\n            if(s.top()!=target[j])\\n            {\\n                s.pop();\\n                st.push_back(\"Pop\");\\n                j--;\\n            }\\n            else if(s.size()==target.size())\\n                break;\\n            i++; \\n        }\\n        return st;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1373778,
                "title": "java-easy-o-n",
                "content": "```\\nclass Solution {\\n    public List<String> buildArray(int[] target, int n) {\\n         int count = 1;\\n         List<String> lst = new ArrayList<>();\\n         int i = 0;\\n         while(i < target.length){\\n            if(count == target[i]){\\n                 lst.add(\"Push\");\\n                 i++;\\n            }\\n            else{\\n                lst.add(\"Push\");\\n                lst.add(\"Pop\");\\n            }\\n           count++;\\n         }\\n      return lst;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> buildArray(int[] target, int n) {\\n         int count = 1;\\n         List<String> lst = new ArrayList<>();\\n         int i = 0;\\n         while(i < target.length){\\n            if(count == target[i]){\\n                 lst.add(\"Push\");\\n                 i++;\\n            }\\n            else{\\n                lst.add(\"Push\");\\n                lst.add(\"Pop\");\\n            }\\n           count++;\\n         }\\n      return lst;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369254,
                "title": "java-easy-solution-o-1-space-and-o-n-time",
                "content": "```\\nclass Solution {\\n    public List<String> buildArray(int[] target, int n) {\\n        List<String> finalList = new ArrayList<String>();\\n        int j=0;\\n        for(int i=1;i<=n;i++){   \\n            if(j==target.length)    break;\\n            finalList.add(\"Push\");          \\n            if(target[j] != i){  \\n                finalList.add(\"Pop\");\\n            }else{\\n                j++;\\n            }\\n        }\\n        return finalList;\\n    }\\n}\\n```\\n\\nNote: Output List is not considered in the space complexity as List has to be returned.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> buildArray(int[] target, int n) {\\n        List<String> finalList = new ArrayList<String>();\\n        int j=0;\\n        for(int i=1;i<=n;i++){   \\n            if(j==target.length)    break;\\n            finalList.add(\"Push\");          \\n            if(target[j] != i){  \\n                finalList.add(\"Pop\");\\n            }else{\\n                j++;\\n            }\\n        }\\n        return finalList;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1315760,
                "title": "easy-to-understand",
                "content": "```\\nclass Solution\\n{\\n    public List<String> buildArray(int[] target, int n) \\n    {\\n        int i , j ;\\n        List<String> result = new ArrayList<>();\\n        for( i = 1 , j = 0 ; j < target.length ; i++ )\\n        {\\n            result.add(\"Push\") ;\\n            if( i != target[j] )\\n            {\\n                result.add(\"Pop\") ;\\n            }\\n            else\\n            {\\n                j++ ;\\n            }\\n        }\\n        return result ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n    public List<String> buildArray(int[] target, int n) \\n    {\\n        int i , j ;\\n        List<String> result = new ArrayList<>();\\n        for( i = 1 , j = 0 ; j < target.length ; i++ )\\n        {\\n            result.add(\"Push\") ;\\n            if( i != target[j] )\\n            {\\n                result.add(\"Pop\") ;\\n            }\\n            else\\n            {\\n                j++ ;\\n            }\\n        }\\n        return result ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1313347,
                "title": "c-clean-correct",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        \\n        vector<string> res;\\n        \\n        int i = 1, ind = 0;\\n        \\n        for(int i=1 ; i<=n && ind<target.size() ; i++){\\n            \\n            res.push_back(\"Push\");\\n            if(target[ind] == i)\\n                ind++;\\n            else\\n                res.push_back(\"Pop\");\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        \\n        vector<string> res;\\n        \\n        int i = 1, ind = 0;\\n        \\n        for(int i=1 ; i<=n && ind<target.size() ; i++){\\n            \\n            res.push_back(\"Push\");\\n            if(target[ind] == i)\\n                ind++;\\n            else\\n                res.push_back(\"Pop\");\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1311971,
                "title": "java-100-faster-and-simple",
                "content": "```\\nclass Solution {\\n    public List<String> buildArray(int[] target, int n) {\\n        \\n        List<String> operations = new ArrayList<String>();\\n        int targetPtr = 0;;\\n        \\n        for(int i = 1; i <= n && targetPtr < target.length ; i++) {\\n            operations.add(\"Push\");\\n            if( target[targetPtr] != i) operations.add(\"Pop\");\\n            if( target[targetPtr] <= i) targetPtr++;\\n        }\\n        return operations;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> buildArray(int[] target, int n) {\\n        \\n        List<String> operations = new ArrayList<String>();\\n        int targetPtr = 0;;\\n        \\n        for(int i = 1; i <= n && targetPtr < target.length ; i++) {\\n            operations.add(\"Push\");\\n            if( target[targetPtr] != i) operations.add(\"Pop\");\\n            if( target[targetPtr] <= i) targetPtr++;\\n        }\\n        return operations;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1300526,
                "title": "python3-simple-o-n-solution",
                "content": "```\\nclass Solution:\\n    def buildArray(self, target: List[int], n: int) -> List[str]:\\n        res=[]\\n        last=0\\n        for x in target:\\n            diff = x-last -1\\n            if diff:\\n                res+=[\"Push\", \"Pop\"]*diff\\n            res+=[\"Push\"]\\n            last=x\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def buildArray(self, target: List[int], n: int) -> List[str]:\\n        res=[]\\n        last=0\\n        for x in target:\\n            diff = x-last -1\\n            if diff:\\n                res+=[\"Push\", \"Pop\"]*diff\\n            res+=[\"Push\"]\\n            last=x\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1274523,
                "title": "98-33-fast-easy-to-follow-javascript-solution",
                "content": "```\\nvar buildArray = function(target, n) {\\n    n = target.slice(-1)[0];\\n    const operations = [];\\n     for(let i=1; i<=n; i++){\\n        if(target.includes(i)) operations.push(\\'Push\\');\\n        else operations.push(\\'Push\\', \\'Pop\\');\\n    }\\n    return operations;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar buildArray = function(target, n) {\\n    n = target.slice(-1)[0];\\n    const operations = [];\\n     for(let i=1; i<=n; i++){\\n        if(target.includes(i)) operations.push(\\'Push\\');\\n        else operations.push(\\'Push\\', \\'Pop\\');\\n    }\\n    return operations;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1266525,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def buildArray(self, target, n):\\n        \"\"\"\\n        :type target: List[int]\\n        :type n: int\\n        :rtype: List[str]\\n        \"\"\"\\n        l = [i for i in range(1, n+1)]\\n        \\n        cmpIndex = 0\\n        ans = list()\\n        for i in range(len(target)):\\n            print(\"cmpIndex is: \", cmpIndex, \" i is: \", i)\\n            if target[i] == l[cmpIndex]:\\n                ans.append(\"Push\")\\n                cmpIndex = cmpIndex + 1\\n                \\n            else:\\n                diff = target[i] - l[cmpIndex]\\n                while (diff > 0):\\n                    ans.append(\"Push\")\\n                    ans.append(\"Pop\")\\n                    cmpIndex = cmpIndex + 1\\n                    diff = diff - 1\\n                ans.append(\"Push\")\\n                cmpIndex = cmpIndex + 1\\n            if(target == ans):\\n                break\\n        \\n        # print(ans)\\n        return ans\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def buildArray(self, target, n):\\n        \"\"\"\\n        :type target: List[int]\\n        :type n: int\\n        :rtype: List[str]\\n        \"\"\"\\n        l = [i for i in range(1, n+1)]\\n        \\n        cmpIndex = 0\\n        ans = list()\\n        for i in range(len(target)):\\n            print(\"cmpIndex is: \", cmpIndex, \" i is: \", i)\\n            if target[i] == l[cmpIndex]:\\n                ans.append(\"Push\")\\n                cmpIndex = cmpIndex + 1\\n                \\n            else:\\n                diff = target[i] - l[cmpIndex]\\n                while (diff > 0):\\n                    ans.append(\"Push\")\\n                    ans.append(\"Pop\")\\n                    cmpIndex = cmpIndex + 1\\n                    diff = diff - 1\\n                ans.append(\"Push\")\\n                cmpIndex = cmpIndex + 1\\n            if(target == ans):\\n                break\\n        \\n        # print(ans)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1258495,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string> result;\\n        int c = 1;\\n        for (int i = 0; i < target.size();){\\n            while(target[i] != c){\\n                result.push_back(\"Push\");\\n                result.push_back(\"Pop\");\\n                c++;\\n            }\\n            result.push_back(\"Push\");\\n            i++;\\n            c++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string> result;\\n        int c = 1;\\n        for (int i = 0; i < target.size();){\\n            while(target[i] != c){\\n                result.push_back(\"Push\");\\n                result.push_back(\"Pop\");\\n                c++;\\n            }\\n            result.push_back(\"Push\");\\n            i++;\\n            c++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1241571,
                "title": "simple-stack-solution-in-c",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& t, int n) {\\n        int i = 1;\\n        vector<string> ans;\\n        stack<int> st;\\n        st.push(i);\\n        for(int j=0;j<t.size();j++){\\n            if(st.top()==t[j]){\\n                ans.push_back(\"Push\");\\n\\n            }\\n            else if(st.top()!=t[j]){\\n               while(st.top()!=t[j] && j<t.size()){\\n                   ans.push_back(\"Push\");\\n                   ans.push_back(\"Pop\");\\n                   i++;\\n                   st.push(i);\\n               }\\n               ans.push_back(\"Push\");\\n            }\\n            i++;\\n            st.push(i);\\n        }\\n        return ans;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& t, int n) {\\n        int i = 1;\\n        vector<string> ans;\\n        stack<int> st;\\n        st.push(i);\\n        for(int j=0;j<t.size();j++){\\n            if(st.top()==t[j]){\\n                ans.push_back(\"Push\");\\n\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1227800,
                "title": "java-easy-to-understand-faster-than-100",
                "content": "class Solution {\\n    public List<String> buildArray(int[] target, int n) {\\n        Stack<Integer> stack=new Stack<Integer>();\\n        List<String> list=new ArrayList<String>();\\n        int t=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            stack.push(i);\\n            list.add(\"Push\");\\n            if(i!=target[t])\\n            {\\n                stack.pop();\\n                list.add(\"Pop\");\\n            }\\n            else\\n            {\\n                if(t!=target.length-1)\\n                {\\n                    t++;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n        }\\n        return list;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<String> buildArray(int[] target, int n) {\\n        Stack<Integer> stack=new Stack<Integer>();\\n        List<String> list=new ArrayList<String>();\\n        int t=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            stack.push(i);\\n            list.add(\"Push\");\\n            if(i!=target[t])\\n            {\\n                stack.pop();\\n                list.add(\"Pop\");\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1227719,
                "title": "python-3-runtime-28-ms-faster-than-88-26-simple",
                "content": "I don\\'t understand what\\u2019s the usage of `n` here, If anyone knows let me know. :-)\\n```\\nclass Solution:\\n    def buildArray(self, target: List[int], n: int) -> List[str]:\\n        ans = []\\n        for i in range(1,target[-1]+1):\\n            if i in target:\\n                ans.append(\"Push\")\\n            else:\\n                ans.append(\"Push\")\\n                ans.append(\"Pop\")\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def buildArray(self, target: List[int], n: int) -> List[str]:\\n        ans = []\\n        for i in range(1,target[-1]+1):\\n            if i in target:\\n                ans.append(\"Push\")\\n            else:\\n                ans.append(\"Push\")\\n                ans.append(\"Pop\")\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1221174,
                "title": "java-100-fast",
                "content": "```\\npublic List<String> buildArray(int[] target, int n) {\\n\\t\\n\\tList<String> output = new ArrayList<>();\\n\\tfor (int i = 1, j = 0; j < target.length; i++) {\\n\\t\\toutput.add(\"Push\");\\n\\t\\tif (i != target[j]) {\\n\\t\\t\\toutput.add(\"Pop\");\\n\\t\\t} else {\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\t}\\n\\treturn output;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic List<String> buildArray(int[] target, int n) {\\n\\t\\n\\tList<String> output = new ArrayList<>();\\n\\tfor (int i = 1, j = 0; j < target.length; i++) {\\n\\t\\toutput.add(\"Push\");\\n\\t\\tif (i != target[j]) {\\n\\t\\t\\toutput.add(\"Pop\");\\n\\t\\t} else {\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\t}\\n\\treturn output;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1212772,
                "title": "best-and-concise-solution-beats-100-submissions-0ms",
                "content": "```\\n vector<string> buildArray(vector<int>& target, int n) {\\n        int curr = 1;\\n        vector<string> ans;\\n        for(int i = 0 ; i < target.size(); i++){\\n            while(curr!= target[i]){\\n                ans.push_back(\"Push\");\\n                ans.push_back(\"Pop\");\\n                curr++;\\n            }\\n            ans.push_back(\"Push\");\\n            curr++;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n vector<string> buildArray(vector<int>& target, int n) {\\n        int curr = 1;\\n        vector<string> ans;\\n        for(int i = 0 ; i < target.size(); i++){\\n            while(curr!= target[i]){\\n                ans.push_back(\"Push\");\\n                ans.push_back(\"Pop\");\\n                curr++;\\n            }\\n            ans.push_back(\"Push\");\\n            curr++;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1208688,
                "title": "python-3-one-line",
                "content": "# Explanation:\\nConsider the example, `[2,3,6]`.\\nWe need to build the array: push, pop, push, push, push, pop, push.\\nTo further break it down:\\n * 1: push, pop\\n * 2: push\\n * 3: push\\n * 4: push, pop\\n * 5: push, pop\\n * 6: push\\n\\nOr breaking it down by adjascent pairs (if we add `0` to the beginning):\\n * `0,2`: push, pop, push\\n * `2,3`: push\\n * `3,6`: push, pop, push, pop, push\\n\\nSo we need to:\\n1. Add `[0]` to the front of the target list\\n2. For each pair `a` and `b`, compute `b - a`\\n    * If it\\'s `1`, just `Push`\\n    * If it\\'s larger, like for example `7`, then we need to `Push` and `Pop` 6 times, followed by a `Push`\\n    * In other words, we want to \"Push\" and \"Pop\" `b - a - 1` times, and then \"Push\" once more\\n\\n# Code:\\n```python\\nclass Solution:\\n  def buildArray(self, A: List[int], n: int) -> List[str]:\\n    return [x for a,b in zip([0] + A, A) for x in [\"Push\", \"Pop\"]*(b-a-1) + [\"Push\"]]\\n```\\n\\n# And because I like true one-liners:\\n```python\\nclass Solution: buildArray = lambda _,A,n: [x for a,b in zip([0] + A, A) for x in [\"Push\", \"Pop\"]*(b-a-1) + [\"Push\"]]\\n```\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n  def buildArray(self, A: List[int], n: int) -> List[str]:\\n    return [x for a,b in zip([0] + A, A) for x in [\"Push\", \"Pop\"]*(b-a-1) + [\"Push\"]]\\n```\n```python\\nclass Solution: buildArray = lambda _,A,n: [x for a,b in zip([0] + A, A) for x in [\"Push\", \"Pop\"]*(b-a-1) + [\"Push\"]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206602,
                "title": "c-solution",
                "content": "```\\nvector<string> buildArray(vector<int>& t, int n) {\\n        vector<string>ans;\\n        string s=\"Push\";\\n        string s1=\"Pop\";\\n        int i=1;\\n        int a=0;\\n        while(i<=n&&a<t.size()){\\n            \\n            if(i!=t[a]){\\n                ans.push_back(s);\\n                ans.push_back(s1);\\n            }\\n            else{\\n                 ans.push_back(s);\\n                a++;\\n            }\\n            i++;\\n        }\\n    \\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<string> buildArray(vector<int>& t, int n) {\\n        vector<string>ans;\\n        string s=\"Push\";\\n        string s1=\"Pop\";\\n        int i=1;\\n        int a=0;\\n        while(i<=n&&a<t.size()){\\n            \\n            if(i!=t[a]){\\n                ans.push_back(s);\\n                ans.push_back(s1);\\n            }\\n            else{\\n                 ans.push_back(s);\\n                a++;\\n            }\\n            i++;\\n        }\\n    \\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1199317,
                "title": "simple-c-code-4ms",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string> stackop;\\n        int k = 1;\\n        int last = min(target[target.size()-1],n);\\n        int i = 0;\\n        while(k<=last){\\n            if( k == target[i]){\\n                stackop.push_back(\"Push\");\\n                i++;\\n                k++;\\n            }\\n            else{\\n                while(k<target[i]){\\n                    stackop.push_back(\"Push\");\\n                    stackop.push_back(\"Pop\");\\n                    k++;\\n                }\\n            }\\n        }\\n        return stackop;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> buildArray(vector<int>& target, int n) {\\n        vector<string> stackop;\\n        int k = 1;\\n        int last = min(target[target.size()-1],n);\\n        int i = 0;\\n        while(k<=last){\\n            if( k == target[i]){\\n                stackop.push_back(\"Push\");\\n                i++;\\n                k++;\\n            }\\n            else{\\n                while(k<target[i]){\\n                    stackop.push_back(\"Push\");\\n                    stackop.push_back(\"Pop\");\\n                    k++;\\n                }\\n            }\\n        }\\n        return stackop;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1180215,
                "title": "pyhton-simple-solution",
                "content": "Time: O(n)\\nSpace: O(n)\\n\\n```\\nclass Solution:\\n    def buildArray(self, target: List[int], n: int) -> List[str]:\\n        output = []\\n        i = 1\\n        for x in target:\\n            while i != x:\\n                output.append(\"Push\")\\n                output.append(\"Pop\")\\n                i += 1\\n            output.append(\"Push\")\\n            i += 1\\n        \\n        return output\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def buildArray(self, target: List[int], n: int) -> List[str]:\\n        output = []\\n        i = 1\\n        for x in target:\\n            while i != x:\\n                output.append(\"Push\")\\n                output.append(\"Pop\")\\n                i += 1\\n            output.append(\"Push\")\\n            i += 1\\n        \\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1179335,
                "title": "python-straightforward-solution-with-detailed-comments",
                "content": "Simple straightforward Python 3 solution with detailed comments. Runtime beats 89% and uses stack properties.\\n```\\nclass Solution:\\n    def buildArray(self, target: List[int], n: int) -> List[str]:\\n        \\n        # create a list to store the results\\n        output = list()\\n        \\n        # iterate through the sequence of numbers\\n        for number in range(1, n + 1):\\n            \\n            # check if the number equals to the first element of target array\\n            if number == target[0]:\\n                \\n                # if yes, add \"push\" to the output\\n                output.extend([\"Push\"])\\n                \\n                # remove the number from the target array\\n                target.pop(0)\\n                \\n            else:\\n                # if no, add [\"push\", \"pop\"] to the output\\n                output.extend([\"Push\", \"Pop\"])\\n                \\n             # increase the number  \\n            number += 1\\n            \\n            # break the loop if the target array is empty\\n            if not target:\\n                break\\n        return output\\n\\t\\t```\\n\\t\\t",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def buildArray(self, target: List[int], n: int) -> List[str]:\\n        \\n        # create a list to store the results\\n        output = list()\\n        \\n        # iterate through the sequence of numbers\\n        for number in range(1, n + 1):\\n            \\n            # check if the number equals to the first element of target array\\n            if number == target[0]:\\n                \\n                # if yes, add \"push\" to the output\\n                output.extend([\"Push\"])\\n                \\n                # remove the number from the target array\\n                target.pop(0)\\n                \\n            else:\\n                # if no, add [\"push\", \"pop\"] to the output\\n                output.extend([\"Push\", \"Pop\"])\\n                \\n             # increase the number  \\n            number += 1\\n            \\n            # break the loop if the target array is empty\\n            if not target:\\n                break\\n        return output\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1178645,
                "title": "python-easy-solution-better-than-97-07-submissions",
                "content": "```\\nclass Solution:\\n    def buildArray(self, target: List[int], n: int) -> List[str]:\\n        res = []\\n        i = 0\\n        num = 1\\n        while(i<len(target)):\\n            if target[i]==num:\\n                res.append(\"Push\")\\n                i+=1\\n            elif target[i]!=num:\\n                res.append(\"Push\")\\n                res.append(\"Pop\") \\n            num+=1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def buildArray(self, target: List[int], n: int) -> List[str]:\\n        res = []\\n        i = 0\\n        num = 1\\n        while(i<len(target)):\\n            if target[i]==num:\\n                res.append(\"Push\")\\n                i+=1\\n            elif target[i]!=num:\\n                res.append(\"Push\")\\n                res.append(\"Pop\") \\n            num+=1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1158107,
                "title": "rust",
                "content": "```\\nimpl Solution {\\n    pub fn build_array(target: Vec<i32>, n: i32) -> Vec<String> {\\n        let mut output: Vec<String> = Vec::new();\\n    for i in 0..target[target.len() - 1] {\\n        output.push(String::from(\"Push\"));\\n        if target.contains(&(i + 1)) {\\n            continue;\\n        };\\n        output.push(String::from(\"Pop\"));\\n    }\\n    output\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn build_array(target: Vec<i32>, n: i32) -> Vec<String> {\\n        let mut output: Vec<String> = Vec::new();\\n    for i in 0..target[target.len() - 1] {\\n        output.push(String::from(\"Push\"));\\n        if target.contains(&(i + 1)) {\\n            continue;\\n        };\\n        output.push(String::from(\"Pop\"));\\n    }\\n    output\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1155567,
                "title": "java-without-stack",
                "content": "class Solution {\\n    public List<String> buildArray(int[] target, int n) {\\n\\t\\n        int start=1;\\n        List<String> ans=new ArrayList<>();\\n        for(int i=0;i<target.length;i++)\\n        {\\n            ans.add(\"Push\");\\n            if(target[i]!=start)\\n                { ans.add(\"Pop\");i--;}\\n            \\n            start++;\\n        }\\n        return ans;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<String> buildArray(int[] target, int n) {\\n\\t\\n        int start=1;\\n        List<String> ans=new ArrayList<>();\\n        for(int i=0;i<target.length;i++)\\n        {\\n            ans.add(\"Push\");\\n            if(target[i]!=start)\\n                { ans.add(\"Pop\");i--;}",
                "codeTag": "Java"
            },
            {
                "id": 1145025,
                "title": "python3-solution-1441-build-an-array-with-stack-operations-32ms-14-4mb",
                "content": "```\\nclass Solution:\\n    def buildArray(self, target: List[int], n: int) -> List[str]:\\n        \\n        step = min(target[-1],n) # by knowing the last number in target, we can calculate the essential steps count\\n        \\n        ans=[]\\n        k = 0 # in order to mvoe the target\\n        for i in range(1,step+1):\\n            if target[k] == i:\\n                ans.append(\"Push\")\\n                k+=1\\n            elif target[k]>i:\\n                ans.extend([\"Push\",\"Pop\"])\\n                \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def buildArray(self, target: List[int], n: int) -> List[str]:\\n        \\n        step = min(target[-1],n) # by knowing the last number in target, we can calculate the essential steps count\\n        \\n        ans=[]\\n        k = 0 # in order to mvoe the target\\n        for i in range(1,step+1):\\n            if target[k] == i:\\n                ans.append(\"Push\")\\n                k+=1\\n            elif target[k]>i:\\n                ans.extend([\"Push\",\"Pop\"])\\n                \\n        return ans\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564750,
                "content": [
                    {
                        "username": "dhtmlkitchen",
                        "content": "I don\\'t understand the question. What do they ask? Can you explain it?"
                    },
                    {
                        "username": "kinshuksharely12",
                        "content": "They just want the total \"push\" and \"pops\" it will take to make a copy of target string in stack"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "I wasn\\'t sure about it.\\nIf input is target = [3,4], n = 4,\\nshould the following answers are all correct?\\n[Push, Push, Pop, Pop, Push, Push]\\n[Push, Pop, Push, Pop, Push, Push]"
                    },
                    {
                        "username": "Rutik5233",
                        "content": "[\"Push\",\"Pop\",\"Push\",\"Pop\",\"Push\",\"Push\"]"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "I don\\'t know if it\\'s just me but I have no idea why do we need this n parameter"
                    },
                    {
                        "username": "cswartzell",
                        "content": "The test cases are limited to accepting only values UP TO 3 for some reason. This problem is odd. "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "yeah, I don\\'t think having the variable n is very necessary"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This is an easy question logically, but hard to get what its trying to say. They made it sound so complicated.\\n\\nHere is the question in simple terms,\\n\\nYou have an increasing array target, you need to replicate that array in a stack,\\n\\nTo replicate it, you will have a stream of number from 1 to n, from where you will take the number one at a time.\\n\\nFor each number you will either Push it and move to next index of target to compare the next number in loop, or if it does not matches, for some reason you need to Push it, but also Pop it afterwards.\\n\\nJust code this simple thing and get AC"
                    },
                    {
                        "username": "user8675309",
                        "content": "## Suggested Rewrite of Question\\n\\nYou are given an integer array `target` sorted in **non-descending** order, and an integer `n` denoting a stream of numbers from `[1,n]`.\\n\\nYour goal is to list the operations needed to recreate `target` using the stream of numbers. (You are guaranteed this will always be possible.)\\n\\nThe array should consist of either `\"Push\"` or `\"Pop\"`.\\n\\n* `\"Push\"`: pushes the next number in the stream to `target`.\\n* `\"Pop\"`: removes top number of `target`.\\n\\nOnce the elements in the stack are equal to `target`, stop reading new integers from the stream and do no more operations on the stack.\\n\\nReturn *the stack operations needed to build* `target`. If there are multiple valid answers, return **any of them**.\\n\\n**Example 4:**\\n\\n    Input: target = [3,6], n = 6\\n    Output:\\n      [\"Push\",\"Pop\",\"Push\",\"Pop\",\"Push\",\"Push\",\"Push\",\"Pop\",\"Pop\",\"Push\",\"Push\",\"Pop\"]\\n      [\"Push\",\"Pop\",\"Push\",\"Pop\",\"Push\",\"Push\",\"Pop\",\"Push\",\"Pop\",\"Push\",\"Push\",\"Pop\"] would also be an acceptable answer."
                    },
                    {
                        "username": "rastogiyash461",
                        "content": "your output is wrong.\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "This is indeed a little more clear. "
                    },
                    {
                        "username": "colias-palaeno",
                        "content": "This is an objectively bad question. why does the n parameter exist? I wrote a solution without mentioning it once LOL"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Giving an extra parameter doesn\\'t make the question \"objectively bad\" lmao, many of the problems have extra information given which you would never use, filtering out information which you would need for the problem from pool of information given is also a problem solving skill."
                    },
                    {
                        "username": "rma81123",
                        "content": "For those who are having a difficult time understanding the question, here is how I saw it.\\nYou have to run the operations from 1 to n, UNLESS n>target [target.size-1] and you have already \"push\" the last element of the target[ ].\\n\\neg: target = [1,3], n = 2\\nin this case run the operation from 1 to n\\nsince n<target [target.size-1], we run from 1 to n ( n=2 ) \\n\\neg: target = [1,3], n = 4\\nin this case run the operation from 1 to 3 ( target [target.size-1] )\\nsince n>target [target.size-1], and once you have already pushed the last element (3), there is no need to continue any further."
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "n is worth it?"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "n is worth it?"
                    }
                ]
            },
            {
                "id": 1565334,
                "content": [
                    {
                        "username": "dhtmlkitchen",
                        "content": "I don\\'t understand the question. What do they ask? Can you explain it?"
                    },
                    {
                        "username": "kinshuksharely12",
                        "content": "They just want the total \"push\" and \"pops\" it will take to make a copy of target string in stack"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "I wasn\\'t sure about it.\\nIf input is target = [3,4], n = 4,\\nshould the following answers are all correct?\\n[Push, Push, Pop, Pop, Push, Push]\\n[Push, Pop, Push, Pop, Push, Push]"
                    },
                    {
                        "username": "Rutik5233",
                        "content": "[\"Push\",\"Pop\",\"Push\",\"Pop\",\"Push\",\"Push\"]"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "I don\\'t know if it\\'s just me but I have no idea why do we need this n parameter"
                    },
                    {
                        "username": "cswartzell",
                        "content": "The test cases are limited to accepting only values UP TO 3 for some reason. This problem is odd. "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "yeah, I don\\'t think having the variable n is very necessary"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This is an easy question logically, but hard to get what its trying to say. They made it sound so complicated.\\n\\nHere is the question in simple terms,\\n\\nYou have an increasing array target, you need to replicate that array in a stack,\\n\\nTo replicate it, you will have a stream of number from 1 to n, from where you will take the number one at a time.\\n\\nFor each number you will either Push it and move to next index of target to compare the next number in loop, or if it does not matches, for some reason you need to Push it, but also Pop it afterwards.\\n\\nJust code this simple thing and get AC"
                    },
                    {
                        "username": "user8675309",
                        "content": "## Suggested Rewrite of Question\\n\\nYou are given an integer array `target` sorted in **non-descending** order, and an integer `n` denoting a stream of numbers from `[1,n]`.\\n\\nYour goal is to list the operations needed to recreate `target` using the stream of numbers. (You are guaranteed this will always be possible.)\\n\\nThe array should consist of either `\"Push\"` or `\"Pop\"`.\\n\\n* `\"Push\"`: pushes the next number in the stream to `target`.\\n* `\"Pop\"`: removes top number of `target`.\\n\\nOnce the elements in the stack are equal to `target`, stop reading new integers from the stream and do no more operations on the stack.\\n\\nReturn *the stack operations needed to build* `target`. If there are multiple valid answers, return **any of them**.\\n\\n**Example 4:**\\n\\n    Input: target = [3,6], n = 6\\n    Output:\\n      [\"Push\",\"Pop\",\"Push\",\"Pop\",\"Push\",\"Push\",\"Push\",\"Pop\",\"Pop\",\"Push\",\"Push\",\"Pop\"]\\n      [\"Push\",\"Pop\",\"Push\",\"Pop\",\"Push\",\"Push\",\"Pop\",\"Push\",\"Pop\",\"Push\",\"Push\",\"Pop\"] would also be an acceptable answer."
                    },
                    {
                        "username": "rastogiyash461",
                        "content": "your output is wrong.\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "This is indeed a little more clear. "
                    },
                    {
                        "username": "colias-palaeno",
                        "content": "This is an objectively bad question. why does the n parameter exist? I wrote a solution without mentioning it once LOL"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Giving an extra parameter doesn\\'t make the question \"objectively bad\" lmao, many of the problems have extra information given which you would never use, filtering out information which you would need for the problem from pool of information given is also a problem solving skill."
                    },
                    {
                        "username": "rma81123",
                        "content": "For those who are having a difficult time understanding the question, here is how I saw it.\\nYou have to run the operations from 1 to n, UNLESS n>target [target.size-1] and you have already \"push\" the last element of the target[ ].\\n\\neg: target = [1,3], n = 2\\nin this case run the operation from 1 to n\\nsince n<target [target.size-1], we run from 1 to n ( n=2 ) \\n\\neg: target = [1,3], n = 4\\nin this case run the operation from 1 to 3 ( target [target.size-1] )\\nsince n>target [target.size-1], and once you have already pushed the last element (3), there is no need to continue any further."
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "n is worth it?"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "n is worth it?"
                    }
                ]
            },
            {
                "id": 1974289,
                "content": [
                    {
                        "username": "dhtmlkitchen",
                        "content": "I don\\'t understand the question. What do they ask? Can you explain it?"
                    },
                    {
                        "username": "kinshuksharely12",
                        "content": "They just want the total \"push\" and \"pops\" it will take to make a copy of target string in stack"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "I wasn\\'t sure about it.\\nIf input is target = [3,4], n = 4,\\nshould the following answers are all correct?\\n[Push, Push, Pop, Pop, Push, Push]\\n[Push, Pop, Push, Pop, Push, Push]"
                    },
                    {
                        "username": "Rutik5233",
                        "content": "[\"Push\",\"Pop\",\"Push\",\"Pop\",\"Push\",\"Push\"]"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "I don\\'t know if it\\'s just me but I have no idea why do we need this n parameter"
                    },
                    {
                        "username": "cswartzell",
                        "content": "The test cases are limited to accepting only values UP TO 3 for some reason. This problem is odd. "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "yeah, I don\\'t think having the variable n is very necessary"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This is an easy question logically, but hard to get what its trying to say. They made it sound so complicated.\\n\\nHere is the question in simple terms,\\n\\nYou have an increasing array target, you need to replicate that array in a stack,\\n\\nTo replicate it, you will have a stream of number from 1 to n, from where you will take the number one at a time.\\n\\nFor each number you will either Push it and move to next index of target to compare the next number in loop, or if it does not matches, for some reason you need to Push it, but also Pop it afterwards.\\n\\nJust code this simple thing and get AC"
                    },
                    {
                        "username": "user8675309",
                        "content": "## Suggested Rewrite of Question\\n\\nYou are given an integer array `target` sorted in **non-descending** order, and an integer `n` denoting a stream of numbers from `[1,n]`.\\n\\nYour goal is to list the operations needed to recreate `target` using the stream of numbers. (You are guaranteed this will always be possible.)\\n\\nThe array should consist of either `\"Push\"` or `\"Pop\"`.\\n\\n* `\"Push\"`: pushes the next number in the stream to `target`.\\n* `\"Pop\"`: removes top number of `target`.\\n\\nOnce the elements in the stack are equal to `target`, stop reading new integers from the stream and do no more operations on the stack.\\n\\nReturn *the stack operations needed to build* `target`. If there are multiple valid answers, return **any of them**.\\n\\n**Example 4:**\\n\\n    Input: target = [3,6], n = 6\\n    Output:\\n      [\"Push\",\"Pop\",\"Push\",\"Pop\",\"Push\",\"Push\",\"Push\",\"Pop\",\"Pop\",\"Push\",\"Push\",\"Pop\"]\\n      [\"Push\",\"Pop\",\"Push\",\"Pop\",\"Push\",\"Push\",\"Pop\",\"Push\",\"Pop\",\"Push\",\"Push\",\"Pop\"] would also be an acceptable answer."
                    },
                    {
                        "username": "rastogiyash461",
                        "content": "your output is wrong.\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "This is indeed a little more clear. "
                    },
                    {
                        "username": "colias-palaeno",
                        "content": "This is an objectively bad question. why does the n parameter exist? I wrote a solution without mentioning it once LOL"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Giving an extra parameter doesn\\'t make the question \"objectively bad\" lmao, many of the problems have extra information given which you would never use, filtering out information which you would need for the problem from pool of information given is also a problem solving skill."
                    },
                    {
                        "username": "rma81123",
                        "content": "For those who are having a difficult time understanding the question, here is how I saw it.\\nYou have to run the operations from 1 to n, UNLESS n>target [target.size-1] and you have already \"push\" the last element of the target[ ].\\n\\neg: target = [1,3], n = 2\\nin this case run the operation from 1 to n\\nsince n<target [target.size-1], we run from 1 to n ( n=2 ) \\n\\neg: target = [1,3], n = 4\\nin this case run the operation from 1 to 3 ( target [target.size-1] )\\nsince n>target [target.size-1], and once you have already pushed the last element (3), there is no need to continue any further."
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "n is worth it?"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "n is worth it?"
                    }
                ]
            },
            {
                "id": 1903356,
                "content": [
                    {
                        "username": "dhtmlkitchen",
                        "content": "I don\\'t understand the question. What do they ask? Can you explain it?"
                    },
                    {
                        "username": "kinshuksharely12",
                        "content": "They just want the total \"push\" and \"pops\" it will take to make a copy of target string in stack"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "I wasn\\'t sure about it.\\nIf input is target = [3,4], n = 4,\\nshould the following answers are all correct?\\n[Push, Push, Pop, Pop, Push, Push]\\n[Push, Pop, Push, Pop, Push, Push]"
                    },
                    {
                        "username": "Rutik5233",
                        "content": "[\"Push\",\"Pop\",\"Push\",\"Pop\",\"Push\",\"Push\"]"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "I don\\'t know if it\\'s just me but I have no idea why do we need this n parameter"
                    },
                    {
                        "username": "cswartzell",
                        "content": "The test cases are limited to accepting only values UP TO 3 for some reason. This problem is odd. "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "yeah, I don\\'t think having the variable n is very necessary"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This is an easy question logically, but hard to get what its trying to say. They made it sound so complicated.\\n\\nHere is the question in simple terms,\\n\\nYou have an increasing array target, you need to replicate that array in a stack,\\n\\nTo replicate it, you will have a stream of number from 1 to n, from where you will take the number one at a time.\\n\\nFor each number you will either Push it and move to next index of target to compare the next number in loop, or if it does not matches, for some reason you need to Push it, but also Pop it afterwards.\\n\\nJust code this simple thing and get AC"
                    },
                    {
                        "username": "user8675309",
                        "content": "## Suggested Rewrite of Question\\n\\nYou are given an integer array `target` sorted in **non-descending** order, and an integer `n` denoting a stream of numbers from `[1,n]`.\\n\\nYour goal is to list the operations needed to recreate `target` using the stream of numbers. (You are guaranteed this will always be possible.)\\n\\nThe array should consist of either `\"Push\"` or `\"Pop\"`.\\n\\n* `\"Push\"`: pushes the next number in the stream to `target`.\\n* `\"Pop\"`: removes top number of `target`.\\n\\nOnce the elements in the stack are equal to `target`, stop reading new integers from the stream and do no more operations on the stack.\\n\\nReturn *the stack operations needed to build* `target`. If there are multiple valid answers, return **any of them**.\\n\\n**Example 4:**\\n\\n    Input: target = [3,6], n = 6\\n    Output:\\n      [\"Push\",\"Pop\",\"Push\",\"Pop\",\"Push\",\"Push\",\"Push\",\"Pop\",\"Pop\",\"Push\",\"Push\",\"Pop\"]\\n      [\"Push\",\"Pop\",\"Push\",\"Pop\",\"Push\",\"Push\",\"Pop\",\"Push\",\"Pop\",\"Push\",\"Push\",\"Pop\"] would also be an acceptable answer."
                    },
                    {
                        "username": "rastogiyash461",
                        "content": "your output is wrong.\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "This is indeed a little more clear. "
                    },
                    {
                        "username": "colias-palaeno",
                        "content": "This is an objectively bad question. why does the n parameter exist? I wrote a solution without mentioning it once LOL"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Giving an extra parameter doesn\\'t make the question \"objectively bad\" lmao, many of the problems have extra information given which you would never use, filtering out information which you would need for the problem from pool of information given is also a problem solving skill."
                    },
                    {
                        "username": "rma81123",
                        "content": "For those who are having a difficult time understanding the question, here is how I saw it.\\nYou have to run the operations from 1 to n, UNLESS n>target [target.size-1] and you have already \"push\" the last element of the target[ ].\\n\\neg: target = [1,3], n = 2\\nin this case run the operation from 1 to n\\nsince n<target [target.size-1], we run from 1 to n ( n=2 ) \\n\\neg: target = [1,3], n = 4\\nin this case run the operation from 1 to 3 ( target [target.size-1] )\\nsince n>target [target.size-1], and once you have already pushed the last element (3), there is no need to continue any further."
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "n is worth it?"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "n is worth it?"
                    }
                ]
            },
            {
                "id": 1868678,
                "content": [
                    {
                        "username": "dhtmlkitchen",
                        "content": "I don\\'t understand the question. What do they ask? Can you explain it?"
                    },
                    {
                        "username": "kinshuksharely12",
                        "content": "They just want the total \"push\" and \"pops\" it will take to make a copy of target string in stack"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "I wasn\\'t sure about it.\\nIf input is target = [3,4], n = 4,\\nshould the following answers are all correct?\\n[Push, Push, Pop, Pop, Push, Push]\\n[Push, Pop, Push, Pop, Push, Push]"
                    },
                    {
                        "username": "Rutik5233",
                        "content": "[\"Push\",\"Pop\",\"Push\",\"Pop\",\"Push\",\"Push\"]"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "I don\\'t know if it\\'s just me but I have no idea why do we need this n parameter"
                    },
                    {
                        "username": "cswartzell",
                        "content": "The test cases are limited to accepting only values UP TO 3 for some reason. This problem is odd. "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "yeah, I don\\'t think having the variable n is very necessary"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This is an easy question logically, but hard to get what its trying to say. They made it sound so complicated.\\n\\nHere is the question in simple terms,\\n\\nYou have an increasing array target, you need to replicate that array in a stack,\\n\\nTo replicate it, you will have a stream of number from 1 to n, from where you will take the number one at a time.\\n\\nFor each number you will either Push it and move to next index of target to compare the next number in loop, or if it does not matches, for some reason you need to Push it, but also Pop it afterwards.\\n\\nJust code this simple thing and get AC"
                    },
                    {
                        "username": "user8675309",
                        "content": "## Suggested Rewrite of Question\\n\\nYou are given an integer array `target` sorted in **non-descending** order, and an integer `n` denoting a stream of numbers from `[1,n]`.\\n\\nYour goal is to list the operations needed to recreate `target` using the stream of numbers. (You are guaranteed this will always be possible.)\\n\\nThe array should consist of either `\"Push\"` or `\"Pop\"`.\\n\\n* `\"Push\"`: pushes the next number in the stream to `target`.\\n* `\"Pop\"`: removes top number of `target`.\\n\\nOnce the elements in the stack are equal to `target`, stop reading new integers from the stream and do no more operations on the stack.\\n\\nReturn *the stack operations needed to build* `target`. If there are multiple valid answers, return **any of them**.\\n\\n**Example 4:**\\n\\n    Input: target = [3,6], n = 6\\n    Output:\\n      [\"Push\",\"Pop\",\"Push\",\"Pop\",\"Push\",\"Push\",\"Push\",\"Pop\",\"Pop\",\"Push\",\"Push\",\"Pop\"]\\n      [\"Push\",\"Pop\",\"Push\",\"Pop\",\"Push\",\"Push\",\"Pop\",\"Push\",\"Pop\",\"Push\",\"Push\",\"Pop\"] would also be an acceptable answer."
                    },
                    {
                        "username": "rastogiyash461",
                        "content": "your output is wrong.\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "This is indeed a little more clear. "
                    },
                    {
                        "username": "colias-palaeno",
                        "content": "This is an objectively bad question. why does the n parameter exist? I wrote a solution without mentioning it once LOL"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Giving an extra parameter doesn\\'t make the question \"objectively bad\" lmao, many of the problems have extra information given which you would never use, filtering out information which you would need for the problem from pool of information given is also a problem solving skill."
                    },
                    {
                        "username": "rma81123",
                        "content": "For those who are having a difficult time understanding the question, here is how I saw it.\\nYou have to run the operations from 1 to n, UNLESS n>target [target.size-1] and you have already \"push\" the last element of the target[ ].\\n\\neg: target = [1,3], n = 2\\nin this case run the operation from 1 to n\\nsince n<target [target.size-1], we run from 1 to n ( n=2 ) \\n\\neg: target = [1,3], n = 4\\nin this case run the operation from 1 to 3 ( target [target.size-1] )\\nsince n>target [target.size-1], and once you have already pushed the last element (3), there is no need to continue any further."
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "n is worth it?"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "n is worth it?"
                    }
                ]
            },
            {
                "id": 1893572,
                "content": [
                    {
                        "username": "dhtmlkitchen",
                        "content": "I don\\'t understand the question. What do they ask? Can you explain it?"
                    },
                    {
                        "username": "kinshuksharely12",
                        "content": "They just want the total \"push\" and \"pops\" it will take to make a copy of target string in stack"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "I wasn\\'t sure about it.\\nIf input is target = [3,4], n = 4,\\nshould the following answers are all correct?\\n[Push, Push, Pop, Pop, Push, Push]\\n[Push, Pop, Push, Pop, Push, Push]"
                    },
                    {
                        "username": "Rutik5233",
                        "content": "[\"Push\",\"Pop\",\"Push\",\"Pop\",\"Push\",\"Push\"]"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "I don\\'t know if it\\'s just me but I have no idea why do we need this n parameter"
                    },
                    {
                        "username": "cswartzell",
                        "content": "The test cases are limited to accepting only values UP TO 3 for some reason. This problem is odd. "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "yeah, I don\\'t think having the variable n is very necessary"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This is an easy question logically, but hard to get what its trying to say. They made it sound so complicated.\\n\\nHere is the question in simple terms,\\n\\nYou have an increasing array target, you need to replicate that array in a stack,\\n\\nTo replicate it, you will have a stream of number from 1 to n, from where you will take the number one at a time.\\n\\nFor each number you will either Push it and move to next index of target to compare the next number in loop, or if it does not matches, for some reason you need to Push it, but also Pop it afterwards.\\n\\nJust code this simple thing and get AC"
                    },
                    {
                        "username": "user8675309",
                        "content": "## Suggested Rewrite of Question\\n\\nYou are given an integer array `target` sorted in **non-descending** order, and an integer `n` denoting a stream of numbers from `[1,n]`.\\n\\nYour goal is to list the operations needed to recreate `target` using the stream of numbers. (You are guaranteed this will always be possible.)\\n\\nThe array should consist of either `\"Push\"` or `\"Pop\"`.\\n\\n* `\"Push\"`: pushes the next number in the stream to `target`.\\n* `\"Pop\"`: removes top number of `target`.\\n\\nOnce the elements in the stack are equal to `target`, stop reading new integers from the stream and do no more operations on the stack.\\n\\nReturn *the stack operations needed to build* `target`. If there are multiple valid answers, return **any of them**.\\n\\n**Example 4:**\\n\\n    Input: target = [3,6], n = 6\\n    Output:\\n      [\"Push\",\"Pop\",\"Push\",\"Pop\",\"Push\",\"Push\",\"Push\",\"Pop\",\"Pop\",\"Push\",\"Push\",\"Pop\"]\\n      [\"Push\",\"Pop\",\"Push\",\"Pop\",\"Push\",\"Push\",\"Pop\",\"Push\",\"Pop\",\"Push\",\"Push\",\"Pop\"] would also be an acceptable answer."
                    },
                    {
                        "username": "rastogiyash461",
                        "content": "your output is wrong.\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "This is indeed a little more clear. "
                    },
                    {
                        "username": "colias-palaeno",
                        "content": "This is an objectively bad question. why does the n parameter exist? I wrote a solution without mentioning it once LOL"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Giving an extra parameter doesn\\'t make the question \"objectively bad\" lmao, many of the problems have extra information given which you would never use, filtering out information which you would need for the problem from pool of information given is also a problem solving skill."
                    },
                    {
                        "username": "rma81123",
                        "content": "For those who are having a difficult time understanding the question, here is how I saw it.\\nYou have to run the operations from 1 to n, UNLESS n>target [target.size-1] and you have already \"push\" the last element of the target[ ].\\n\\neg: target = [1,3], n = 2\\nin this case run the operation from 1 to n\\nsince n<target [target.size-1], we run from 1 to n ( n=2 ) \\n\\neg: target = [1,3], n = 4\\nin this case run the operation from 1 to 3 ( target [target.size-1] )\\nsince n>target [target.size-1], and once you have already pushed the last element (3), there is no need to continue any further."
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "n is worth it?"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "n is worth it?"
                    }
                ]
            },
            {
                "id": 1749545,
                "content": [
                    {
                        "username": "dhtmlkitchen",
                        "content": "I don\\'t understand the question. What do they ask? Can you explain it?"
                    },
                    {
                        "username": "kinshuksharely12",
                        "content": "They just want the total \"push\" and \"pops\" it will take to make a copy of target string in stack"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "I wasn\\'t sure about it.\\nIf input is target = [3,4], n = 4,\\nshould the following answers are all correct?\\n[Push, Push, Pop, Pop, Push, Push]\\n[Push, Pop, Push, Pop, Push, Push]"
                    },
                    {
                        "username": "Rutik5233",
                        "content": "[\"Push\",\"Pop\",\"Push\",\"Pop\",\"Push\",\"Push\"]"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "I don\\'t know if it\\'s just me but I have no idea why do we need this n parameter"
                    },
                    {
                        "username": "cswartzell",
                        "content": "The test cases are limited to accepting only values UP TO 3 for some reason. This problem is odd. "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "yeah, I don\\'t think having the variable n is very necessary"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This is an easy question logically, but hard to get what its trying to say. They made it sound so complicated.\\n\\nHere is the question in simple terms,\\n\\nYou have an increasing array target, you need to replicate that array in a stack,\\n\\nTo replicate it, you will have a stream of number from 1 to n, from where you will take the number one at a time.\\n\\nFor each number you will either Push it and move to next index of target to compare the next number in loop, or if it does not matches, for some reason you need to Push it, but also Pop it afterwards.\\n\\nJust code this simple thing and get AC"
                    },
                    {
                        "username": "user8675309",
                        "content": "## Suggested Rewrite of Question\\n\\nYou are given an integer array `target` sorted in **non-descending** order, and an integer `n` denoting a stream of numbers from `[1,n]`.\\n\\nYour goal is to list the operations needed to recreate `target` using the stream of numbers. (You are guaranteed this will always be possible.)\\n\\nThe array should consist of either `\"Push\"` or `\"Pop\"`.\\n\\n* `\"Push\"`: pushes the next number in the stream to `target`.\\n* `\"Pop\"`: removes top number of `target`.\\n\\nOnce the elements in the stack are equal to `target`, stop reading new integers from the stream and do no more operations on the stack.\\n\\nReturn *the stack operations needed to build* `target`. If there are multiple valid answers, return **any of them**.\\n\\n**Example 4:**\\n\\n    Input: target = [3,6], n = 6\\n    Output:\\n      [\"Push\",\"Pop\",\"Push\",\"Pop\",\"Push\",\"Push\",\"Push\",\"Pop\",\"Pop\",\"Push\",\"Push\",\"Pop\"]\\n      [\"Push\",\"Pop\",\"Push\",\"Pop\",\"Push\",\"Push\",\"Pop\",\"Push\",\"Pop\",\"Push\",\"Push\",\"Pop\"] would also be an acceptable answer."
                    },
                    {
                        "username": "rastogiyash461",
                        "content": "your output is wrong.\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "This is indeed a little more clear. "
                    },
                    {
                        "username": "colias-palaeno",
                        "content": "This is an objectively bad question. why does the n parameter exist? I wrote a solution without mentioning it once LOL"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Giving an extra parameter doesn\\'t make the question \"objectively bad\" lmao, many of the problems have extra information given which you would never use, filtering out information which you would need for the problem from pool of information given is also a problem solving skill."
                    },
                    {
                        "username": "rma81123",
                        "content": "For those who are having a difficult time understanding the question, here is how I saw it.\\nYou have to run the operations from 1 to n, UNLESS n>target [target.size-1] and you have already \"push\" the last element of the target[ ].\\n\\neg: target = [1,3], n = 2\\nin this case run the operation from 1 to n\\nsince n<target [target.size-1], we run from 1 to n ( n=2 ) \\n\\neg: target = [1,3], n = 4\\nin this case run the operation from 1 to 3 ( target [target.size-1] )\\nsince n>target [target.size-1], and once you have already pushed the last element (3), there is no need to continue any further."
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "n is worth it?"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "n is worth it?"
                    }
                ]
            },
            {
                "id": 2008075,
                "content": [
                    {
                        "username": "dhtmlkitchen",
                        "content": "I don\\'t understand the question. What do they ask? Can you explain it?"
                    },
                    {
                        "username": "kinshuksharely12",
                        "content": "They just want the total \"push\" and \"pops\" it will take to make a copy of target string in stack"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "I wasn\\'t sure about it.\\nIf input is target = [3,4], n = 4,\\nshould the following answers are all correct?\\n[Push, Push, Pop, Pop, Push, Push]\\n[Push, Pop, Push, Pop, Push, Push]"
                    },
                    {
                        "username": "Rutik5233",
                        "content": "[\"Push\",\"Pop\",\"Push\",\"Pop\",\"Push\",\"Push\"]"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "I don\\'t know if it\\'s just me but I have no idea why do we need this n parameter"
                    },
                    {
                        "username": "cswartzell",
                        "content": "The test cases are limited to accepting only values UP TO 3 for some reason. This problem is odd. "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "yeah, I don\\'t think having the variable n is very necessary"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This is an easy question logically, but hard to get what its trying to say. They made it sound so complicated.\\n\\nHere is the question in simple terms,\\n\\nYou have an increasing array target, you need to replicate that array in a stack,\\n\\nTo replicate it, you will have a stream of number from 1 to n, from where you will take the number one at a time.\\n\\nFor each number you will either Push it and move to next index of target to compare the next number in loop, or if it does not matches, for some reason you need to Push it, but also Pop it afterwards.\\n\\nJust code this simple thing and get AC"
                    },
                    {
                        "username": "user8675309",
                        "content": "## Suggested Rewrite of Question\\n\\nYou are given an integer array `target` sorted in **non-descending** order, and an integer `n` denoting a stream of numbers from `[1,n]`.\\n\\nYour goal is to list the operations needed to recreate `target` using the stream of numbers. (You are guaranteed this will always be possible.)\\n\\nThe array should consist of either `\"Push\"` or `\"Pop\"`.\\n\\n* `\"Push\"`: pushes the next number in the stream to `target`.\\n* `\"Pop\"`: removes top number of `target`.\\n\\nOnce the elements in the stack are equal to `target`, stop reading new integers from the stream and do no more operations on the stack.\\n\\nReturn *the stack operations needed to build* `target`. If there are multiple valid answers, return **any of them**.\\n\\n**Example 4:**\\n\\n    Input: target = [3,6], n = 6\\n    Output:\\n      [\"Push\",\"Pop\",\"Push\",\"Pop\",\"Push\",\"Push\",\"Push\",\"Pop\",\"Pop\",\"Push\",\"Push\",\"Pop\"]\\n      [\"Push\",\"Pop\",\"Push\",\"Pop\",\"Push\",\"Push\",\"Pop\",\"Push\",\"Pop\",\"Push\",\"Push\",\"Pop\"] would also be an acceptable answer."
                    },
                    {
                        "username": "rastogiyash461",
                        "content": "your output is wrong.\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "This is indeed a little more clear. "
                    },
                    {
                        "username": "colias-palaeno",
                        "content": "This is an objectively bad question. why does the n parameter exist? I wrote a solution without mentioning it once LOL"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Giving an extra parameter doesn\\'t make the question \"objectively bad\" lmao, many of the problems have extra information given which you would never use, filtering out information which you would need for the problem from pool of information given is also a problem solving skill."
                    },
                    {
                        "username": "rma81123",
                        "content": "For those who are having a difficult time understanding the question, here is how I saw it.\\nYou have to run the operations from 1 to n, UNLESS n>target [target.size-1] and you have already \"push\" the last element of the target[ ].\\n\\neg: target = [1,3], n = 2\\nin this case run the operation from 1 to n\\nsince n<target [target.size-1], we run from 1 to n ( n=2 ) \\n\\neg: target = [1,3], n = 4\\nin this case run the operation from 1 to 3 ( target [target.size-1] )\\nsince n>target [target.size-1], and once you have already pushed the last element (3), there is no need to continue any further."
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "n is worth it?"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "n is worth it?"
                    }
                ]
            },
            {
                "id": 2008073,
                "content": [
                    {
                        "username": "dhtmlkitchen",
                        "content": "I don\\'t understand the question. What do they ask? Can you explain it?"
                    },
                    {
                        "username": "kinshuksharely12",
                        "content": "They just want the total \"push\" and \"pops\" it will take to make a copy of target string in stack"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "I wasn\\'t sure about it.\\nIf input is target = [3,4], n = 4,\\nshould the following answers are all correct?\\n[Push, Push, Pop, Pop, Push, Push]\\n[Push, Pop, Push, Pop, Push, Push]"
                    },
                    {
                        "username": "Rutik5233",
                        "content": "[\"Push\",\"Pop\",\"Push\",\"Pop\",\"Push\",\"Push\"]"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "I don\\'t know if it\\'s just me but I have no idea why do we need this n parameter"
                    },
                    {
                        "username": "cswartzell",
                        "content": "The test cases are limited to accepting only values UP TO 3 for some reason. This problem is odd. "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "yeah, I don\\'t think having the variable n is very necessary"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This is an easy question logically, but hard to get what its trying to say. They made it sound so complicated.\\n\\nHere is the question in simple terms,\\n\\nYou have an increasing array target, you need to replicate that array in a stack,\\n\\nTo replicate it, you will have a stream of number from 1 to n, from where you will take the number one at a time.\\n\\nFor each number you will either Push it and move to next index of target to compare the next number in loop, or if it does not matches, for some reason you need to Push it, but also Pop it afterwards.\\n\\nJust code this simple thing and get AC"
                    },
                    {
                        "username": "user8675309",
                        "content": "## Suggested Rewrite of Question\\n\\nYou are given an integer array `target` sorted in **non-descending** order, and an integer `n` denoting a stream of numbers from `[1,n]`.\\n\\nYour goal is to list the operations needed to recreate `target` using the stream of numbers. (You are guaranteed this will always be possible.)\\n\\nThe array should consist of either `\"Push\"` or `\"Pop\"`.\\n\\n* `\"Push\"`: pushes the next number in the stream to `target`.\\n* `\"Pop\"`: removes top number of `target`.\\n\\nOnce the elements in the stack are equal to `target`, stop reading new integers from the stream and do no more operations on the stack.\\n\\nReturn *the stack operations needed to build* `target`. If there are multiple valid answers, return **any of them**.\\n\\n**Example 4:**\\n\\n    Input: target = [3,6], n = 6\\n    Output:\\n      [\"Push\",\"Pop\",\"Push\",\"Pop\",\"Push\",\"Push\",\"Push\",\"Pop\",\"Pop\",\"Push\",\"Push\",\"Pop\"]\\n      [\"Push\",\"Pop\",\"Push\",\"Pop\",\"Push\",\"Push\",\"Pop\",\"Push\",\"Pop\",\"Push\",\"Push\",\"Pop\"] would also be an acceptable answer."
                    },
                    {
                        "username": "rastogiyash461",
                        "content": "your output is wrong.\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "This is indeed a little more clear. "
                    },
                    {
                        "username": "colias-palaeno",
                        "content": "This is an objectively bad question. why does the n parameter exist? I wrote a solution without mentioning it once LOL"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Giving an extra parameter doesn\\'t make the question \"objectively bad\" lmao, many of the problems have extra information given which you would never use, filtering out information which you would need for the problem from pool of information given is also a problem solving skill."
                    },
                    {
                        "username": "rma81123",
                        "content": "For those who are having a difficult time understanding the question, here is how I saw it.\\nYou have to run the operations from 1 to n, UNLESS n>target [target.size-1] and you have already \"push\" the last element of the target[ ].\\n\\neg: target = [1,3], n = 2\\nin this case run the operation from 1 to n\\nsince n<target [target.size-1], we run from 1 to n ( n=2 ) \\n\\neg: target = [1,3], n = 4\\nin this case run the operation from 1 to 3 ( target [target.size-1] )\\nsince n>target [target.size-1], and once you have already pushed the last element (3), there is no need to continue any further."
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "n is worth it?"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "n is worth it?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Evaluate the Bracket Pairs of a String",
        "question_content": "<p>You are given a string <code>s</code> that contains some bracket pairs, with each pair containing a <strong>non-empty</strong> key.</p>\n\n<ul>\n\t<li>For example, in the string <code>&quot;(name)is(age)yearsold&quot;</code>, there are <strong>two</strong> bracket pairs that contain the keys <code>&quot;name&quot;</code> and <code>&quot;age&quot;</code>.</li>\n</ul>\n\n<p>You know the values of a wide range of keys. This is represented by a 2D string array <code>knowledge</code> where each <code>knowledge[i] = [key<sub>i</sub>, value<sub>i</sub>]</code> indicates that key <code>key<sub>i</sub></code> has a value of <code>value<sub>i</sub></code>.</p>\n\n<p>You are tasked to evaluate <strong>all</strong> of the bracket pairs. When you evaluate a bracket pair that contains some key <code>key<sub>i</sub></code>, you will:</p>\n\n<ul>\n\t<li>Replace <code>key<sub>i</sub></code> and the bracket pair with the key&#39;s corresponding <code>value<sub>i</sub></code>.</li>\n\t<li>If you do not know the value of the key, you will replace <code>key<sub>i</sub></code> and the bracket pair with a question mark <code>&quot;?&quot;</code> (without the quotation marks).</li>\n</ul>\n\n<p>Each key will appear at most once in your <code>knowledge</code>. There will not be any nested brackets in <code>s</code>.</p>\n\n<p>Return <em>the resulting string after evaluating <strong>all</strong> of the bracket pairs.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;(name)is(age)yearsold&quot;, knowledge = [[&quot;name&quot;,&quot;bob&quot;],[&quot;age&quot;,&quot;two&quot;]]\n<strong>Output:</strong> &quot;bobistwoyearsold&quot;\n<strong>Explanation:</strong>\nThe key &quot;name&quot; has a value of &quot;bob&quot;, so replace &quot;(name)&quot; with &quot;bob&quot;.\nThe key &quot;age&quot; has a value of &quot;two&quot;, so replace &quot;(age)&quot; with &quot;two&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;hi(name)&quot;, knowledge = [[&quot;a&quot;,&quot;b&quot;]]\n<strong>Output:</strong> &quot;hi?&quot;\n<strong>Explanation:</strong> As you do not know the value of the key &quot;name&quot;, replace &quot;(name)&quot; with &quot;?&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;(a)(a)(a)aaa&quot;, knowledge = [[&quot;a&quot;,&quot;yes&quot;]]\n<strong>Output:</strong> &quot;yesyesyesaaa&quot;\n<strong>Explanation:</strong> The same key can appear multiple times.\nThe key &quot;a&quot; has a value of &quot;yes&quot;, so replace all occurrences of &quot;(a)&quot; with &quot;yes&quot;.\nNotice that the &quot;a&quot;s not in a bracket pair are not evaluated.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= knowledge.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>knowledge[i].length == 2</code></li>\n\t<li><code>1 &lt;= key<sub>i</sub>.length, value<sub>i</sub>.length &lt;= 10</code></li>\n\t<li><code>s</code> consists of lowercase English letters and round brackets <code>&#39;(&#39;</code> and <code>&#39;)&#39;</code>.</li>\n\t<li>Every open bracket <code>&#39;(&#39;</code> in <code>s</code> will have a corresponding close bracket <code>&#39;)&#39;</code>.</li>\n\t<li>The key in each bracket pair of <code>s</code> will be non-empty.</li>\n\t<li>There will not be any nested bracket pairs in <code>s</code>.</li>\n\t<li><code>key<sub>i</sub></code> and <code>value<sub>i</sub></code> consist of lowercase English letters.</li>\n\t<li>Each <code>key<sub>i</sub></code> in <code>knowledge</code> is unique.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1130510,
                "title": "python-short-solution-using-split-explained",
                "content": "Nothing very special about this problem, we need to traverse our string and deal with data inside brackets. Let us do it in the following way:\\n\\n1. Create `d`: dictionary of knowledge\\n2. Split `s` into parts, using `(`. Imagine, that `s = (name)is(age)yearsold`, then splitted list will be `[\\'\\', \\'name)is\\', \\'age)yearsold\\']`. It will look like this: first part will not have closing bracket, and each next part will have closing bracket.\\n3. So, we add `t[0]` to final solution and then for each next part we againg use split, now by \")\" and check if we have first part in `d` or not: and either add `?` to answer or corresponding value. Also we add second part `b`, which goes after brackets.\\n\\n**Complexity**: time complexity is `O(m + n)`, where `m` is the length of `s` and `n` is the total length of all the words in `knowledge`: we created dictionary once and then we do one split with `O(n)` and then for each part we do another split and total length of all parts is `O(n)`. Space complexity is also `O(m+n)`.\\n\\n```\\nclass Solution:\\n    def evaluate(self, s, knowledge):\\n        d = {k:v for k, v in knowledge}\\n        t = s.split(\"(\")\\n        ans = t[0]\\n        for i in range(1, len(t)):\\n            a, b = t[i].split(\")\")\\n            ans += d.get(a, \"?\") + b\\n        return ans\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def evaluate(self, s, knowledge):\\n        d = {k:v for k, v in knowledge}\\n        t = s.split(\"(\")\\n        ans = t[0]\\n        for i in range(1, len(t)):\\n            a, b = t[i].split(\")\")\\n            ans += d.get(a, \"?\") + b\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1130600,
                "title": "python-solution",
                "content": "Time `O(n)`\\nSpace `O(n)`\\n<br>\\n\\n**Python**\\n```py\\n    def evaluate(self, s, A):\\n        d = {k: v for k, v in A}\\n        res = []\\n        cur = \\'\\'\\n        going = False\\n        for c in s:\\n            if c == \\'(\\':\\n                going = True\\n            elif c == \\')\\':\\n                going = False\\n                res.append(d.get(cur, \\'?\\'))\\n                cur = \\'\\'\\n            elif going:\\n                cur += c\\n            else:\\n                res.append(c)\\n        return \\'\\'.join(res)\\n```\\n",
                "solutionTags": [],
                "code": "```py\\n    def evaluate(self, s, A):\\n        d = {k: v for k, v in A}\\n        res = []\\n        cur = \\'\\'\\n        going = False\\n        for c in s:\\n            if c == \\'(\\':\\n                going = True\\n            elif c == \\')\\':\\n                going = False\\n                res.append(d.get(cur, \\'?\\'))\\n                cur = \\'\\'\\n            elif going:\\n                cur += c\\n            else:\\n                res.append(c)\\n        return \\'\\'.join(res)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1130604,
                "title": "simple-solution-using-hashmap-w-explanation-linear-complexity",
                "content": "There isn\\'t much to this problem. We just need to realize that we can simple map each key from `knowledge` with its corresponding value to make the task of finding the *key-value pair* into amortized **`O(1)`** time complexity. \\n\\nAfter this, we just need to iterate over the string `s`, find the bracket pairs and map the word inside it to either its corresponding value (if it exists) or `?`.\\n\\n\\n```\\nstring evaluate(string s, vector<vector<string>>& knowledge) {\\n\\tunordered_map<string, string> mp;   // stores key-val pair from knowledge\\n\\tfor(auto& pair : knowledge) mp[pair[0]] = pair[1];\\n\\tint n = size(s); string ans = \"\";\\n\\tfor(int i = 0; i < n; i++)\\n\\t\\tif(s[i] == \\'(\\'){                \\n\\t\\t\\tstring key = \"\";\\t\\t\\t\\n\\t\\t\\twhile(++i < n && s[i] != \\')\\') key += s[i];   // finding the word inside bracket pair\\n\\t\\t\\tans += (mp.count(key) ? mp[key] : \"?\");      // if key is found, append corresponding value else append ?\\n\\t\\t}\\n\\t\\telse ans += s[i];  // for rest of the string, keep it as it is\\n\\t\\n\\treturn ans;\\n}\\n```\\n\\n***Time Complexity :*** `O(N + M)`, where `N` is the length of string and `M` is the number of pairs in `knowledge`\\n***Space Complexity :*** `O(N + M)`",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstring evaluate(string s, vector<vector<string>>& knowledge) {\\n\\tunordered_map<string, string> mp;   // stores key-val pair from knowledge\\n\\tfor(auto& pair : knowledge) mp[pair[0]] = pair[1];\\n\\tint n = size(s); string ans = \"\";\\n\\tfor(int i = 0; i < n; i++)\\n\\t\\tif(s[i] == \\'(\\'){                \\n\\t\\t\\tstring key = \"\";\\t\\t\\t\\n\\t\\t\\twhile(++i < n && s[i] != \\')\\') key += s[i];   // finding the word inside bracket pair\\n\\t\\t\\tans += (mp.count(key) ? mp[key] : \"?\");      // if key is found, append corresponding value else append ?\\n\\t\\t}\\n\\t\\telse ans += s[i];  // for rest of the string, keep it as it is\\n\\t\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1131122,
                "title": "java-hashmap-indexof-string-fromindex",
                "content": "\\n```\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n        var map = knowledge.stream().collect(Collectors.toMap(k-> \"(\" + k.get(0)+\")\", k-> k.get(1)));\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0; i<s.length(); i++) {\\n            char c = s.charAt(i);\\n            if(c == \\'(\\') {\\n                int j = s.indexOf(\")\", i);\\n                sb.append(map.getOrDefault(s.substring(i, j+1), \"?\"));\\n                i=j;\\n            } else sb.append(c);\\n        }\\n        return sb.toString();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n        var map = knowledge.stream().collect(Collectors.toMap(k-> \"(\" + k.get(0)+\")\", k-> k.get(1)));\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0; i<s.length(); i++) {\\n            char c = s.charAt(i);\\n            if(c == \\'(\\') {\\n                int j = s.indexOf(\")\", i);\\n                sb.append(map.getOrDefault(s.substring(i, j+1), \"?\"));\\n                i=j;\\n            } else sb.append(c);\\n        }\\n        return sb.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1130548,
                "title": "c-easy-solution-simple-straight-forward-code-explained",
                "content": "The idea is pretty simple, first we **store the keys and values given in an unordered_map**. After that we traverse the string whenever we encounter the` \\'(\\'` , we add the key to our `string temp` until we find `\\')\\'` and check whether this key is present in our `map`, \\nif yes, we add the value to our `res`,\\nelse we add `\\'?`\\'\\nFinally we `return res`.\\n\\n**Do upvote** if you find it helpful!!!\\n```\\nstring evaluate(string s, vector<vector<string>>& k) {\\n        unordered_map<string,string>m;\\n        for(vector<string>temp : k)  m[temp[0]]= temp[1];\\n        string res = \"\";\\n        int n = s.length(),i=0;\\n        while(i<n){\\n            if(s[i] != \\'(\\') res += s[i++];\\n            else{\\n                int j = i+1;\\n                string temp = \"\";\\n                while(j<n && s[j] != \\')\\') \\n                    temp+=s[j++];\\n                if(m.find(temp) != m.end()) res += m[temp];\\n                else res += \\'?\\';\\n                i = j+1;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nstring evaluate(string s, vector<vector<string>>& k) {\\n        unordered_map<string,string>m;\\n        for(vector<string>temp : k)  m[temp[0]]= temp[1];\\n        string res = \"\";\\n        int n = s.length(),i=0;\\n        while(i<n){\\n            if(s[i] != \\'(\\') res += s[i++];\\n            else{\\n                int j = i+1;\\n                string temp = \"\";\\n                while(j<n && s[j] != \\')\\') \\n                    temp+=s[j++];\\n                if(m.find(temp) != m.end()) res += m[temp];\\n                else res += \\'?\\';\\n                i = j+1;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1365287,
                "title": "if-you-are-getting-tle-mle-then-have-a-look-here-you-will-definitely-learn-something-new",
                "content": "* ***If you are getting TLE/MLE then Have a look here you will definitely learn something new......***\\n\\nFirst Have a look at this code\\n```\\nclass Solution {\\npublic:\\n    string evaluate(string s, vector<vector<string>>& knowledge) {\\n        \\n        string res;\\n         unordered_map<string, string> m;\\n        for(int i=0; i<knowledge.size(); ++i){\\n            m.insert({knowledge[i][0], knowledge[i][1]}); \\n        }\\n        \\n      for(int i=0; i<s.length(); i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                string key;\\n                i++;\\n                while(s[i]!=\\')\\')\\n                {\\n                    key+=s[i++];\\n                }\\n                 string value;\\n                if(m.find(key)!=m.end())\\n             {     value = m[key];    \\n             \\n                     res=res+value;\\n                    //res+=value;\\n             }\\n                else\\n                   { res+=\"?\";}\\n            }\\n            else\\n                res+=s[i];\\n        }\\n        return res;\\n    }\\n};\\n```\\nWhen I was doing res=res+value ; I was continuosly getting MLE(Memory Limit Exceeded) which resulted in TLE while submitting the code. I tried many things but the MLE was not going.\\nThen I pondered and did something like this-:\\n```\\nclass Solution {\\npublic:\\n    string evaluate(string s, vector<vector<string>>& knowledge) {\\n        \\n        string res;\\n         unorderedmap<string, string> m;\\n        for(int i=0; i<knowledge.size(); ++i){\\n            m.insert({knowledge[i][0], knowledge[i][1]}); // Inserting {key, value} pair\\n        }\\n        \\n      for(int i=0; i<s.length(); i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                string key;\\n                i++;\\n                while(s[i]!=\\')\\')\\n                {\\n                    key+=s[i++];\\n                }\\n                 string value;\\n                if(m.find(key)!=m.end())\\n             {     value = m[key];    \\n             \\n                    // res=res+value;\\n                    res+=value;\\n             }\\n                else\\n                   { res+=\"?\";}\\n            }\\n\\t\\t else\\n                res+=s[i];\\n        }\\n        return res;\\n    }\\n};\\n```\\nI just replaced res=res+value with res+=value and To my amazement The MLE/TLE was gone and it compiled in really fast time.\\n\\n## I tried to find out the reason and what I found was this:\\n\\n\\n**string operator+(string&, string&)** operator copies the arguments into a new string object. You then copy this temporary return value into res - which may also involve copying into a new, larger buffer. Unless C++11 is enabled, in which case move assignment will be used, so the latter potential allocation + copy is avoided.\\n\\n**string& operator+=(const string&)** does not create a new string object. It modifies the existing string buffer in-place - unless a larger buffer is needed, in which case reallocation cannot be avoided.\\n\\nSo, res += value avoids creation of temporary buffers in dynamic memory. If the string is large enough, doubling the number of simultaneously used copies can roughly double the peak memory use of the program. Also, the extra temporary allocations may increase the fragmentation of dynamic memory space, which increases the overhead of dynamic memory management. These two factors may cause the memory limit given for the program to be exceeded.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string evaluate(string s, vector<vector<string>>& knowledge) {\\n        \\n        string res;\\n         unordered_map<string, string> m;\\n        for(int i=0; i<knowledge.size(); ++i){\\n            m.insert({knowledge[i][0], knowledge[i][1]}); \\n        }\\n        \\n      for(int i=0; i<s.length(); i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                string key;\\n                i++;\\n                while(s[i]!=\\')\\')\\n                {\\n                    key+=s[i++];\\n                }\\n                 string value;\\n                if(m.find(key)!=m.end())\\n             {     value = m[key];    \\n             \\n                     res=res+value;\\n                    //res+=value;\\n             }\\n                else\\n                   { res+=\"?\";}\\n            }\\n            else\\n                res+=s[i];\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string evaluate(string s, vector<vector<string>>& knowledge) {\\n        \\n        string res;\\n         unorderedmap<string, string> m;\\n        for(int i=0; i<knowledge.size(); ++i){\\n            m.insert({knowledge[i][0], knowledge[i][1]}); // Inserting {key, value} pair\\n        }\\n        \\n      for(int i=0; i<s.length(); i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                string key;\\n                i++;\\n                while(s[i]!=\\')\\')\\n                {\\n                    key+=s[i++];\\n                }\\n                 string value;\\n                if(m.find(key)!=m.end())\\n             {     value = m[key];    \\n             \\n                    // res=res+value;\\n                    res+=value;\\n             }\\n                else\\n                   { res+=\"?\";}\\n            }\\n\\t\\t else\\n                res+=s[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1328505,
                "title": "swift-evaluate-the-bracket-pairs-of-a-string-test-cases",
                "content": "```swift\\nclass Solution {\\n    func evaluate(_ s: String, _ knowledge: [[String]]) -> String {\\n        let map = knowledge.reduce(into: [String:String](), { $0[$1[0]] = $1[1] })\\n        var key = \"\", isKey = false, result = \"\"\\n        s.forEach{\\n            switch $0 {\\n            case \"(\": isKey = true; key = \"\"\\n            case \")\": isKey = false; result += map[key, default: \"?\"]\\n            default: isKey ? (key += \"\\\\($0)\") : (result += \"\\\\($0)\")\\n            }\\n        }\\n        return result\\n    }\\n}\\n```\\n\\n```swift\\nimport XCTest\\n\\n// Executed 4 tests, with 0 failures (0 unexpected) in 0.038 (0.040) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test0() {\\n        let res = s.evaluate(\"(name)is(age)yearsold\", [[\"name\",\"bob\"],[\"age\",\"two\"]])\\n        XCTAssertEqual(res, \"bobistwoyearsold\")\\n    }\\n    func test1() {\\n        let res = s.evaluate(\"hi(name)\", [[\"a\",\"b\"]])\\n        XCTAssertEqual(res, \"hi?\")\\n    }\\n    func test2() {\\n        let res = s.evaluate(\"(a)(a)(a)aaa\", [[\"a\",\"yes\"]])\\n        XCTAssertEqual(res, \"yesyesyesaaa\")\\n    }\\n    func test3() {\\n        let res = s.evaluate(\"(a)(b)\", [[\"a\",\"b\"],[\"b\",\"a\"]])\\n        XCTAssertEqual(res, \"ba\")\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func evaluate(_ s: String, _ knowledge: [[String]]) -> String {\\n        let map = knowledge.reduce(into: [String:String](), { $0[$1[0]] = $1[1] })\\n        var key = \"\", isKey = false, result = \"\"\\n        s.forEach{\\n            switch $0 {\\n            case \"(\": isKey = true; key = \"\"\\n            case \")\": isKey = false; result += map[key, default: \"?\"]\\n            default: isKey ? (key += \"\\\\($0)\") : (result += \"\\\\($0)\")\\n            }\\n        }\\n        return result\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\n// Executed 4 tests, with 0 failures (0 unexpected) in 0.038 (0.040) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test0() {\\n        let res = s.evaluate(\"(name)is(age)yearsold\", [[\"name\",\"bob\"],[\"age\",\"two\"]])\\n        XCTAssertEqual(res, \"bobistwoyearsold\")\\n    }\\n    func test1() {\\n        let res = s.evaluate(\"hi(name)\", [[\"a\",\"b\"]])\\n        XCTAssertEqual(res, \"hi?\")\\n    }\\n    func test2() {\\n        let res = s.evaluate(\"(a)(a)(a)aaa\", [[\"a\",\"yes\"]])\\n        XCTAssertEqual(res, \"yesyesyesaaa\")\\n    }\\n    func test3() {\\n        let res = s.evaluate(\"(a)(b)\", [[\"a\",\"b\"],[\"b\",\"a\"]])\\n        XCTAssertEqual(res, \"ba\")\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1130718,
                "title": "a-map-and-a-stack",
                "content": "We use a stack to make code shorter, thogh it\\'s not necessary since we do not have nested keys.\\n\\nNot sure why this was a third problem in the contest. The first problem was much trickier.\\n\\n**C++**\\n```cpp\\nstring evaluate(string s, vector<vector<string>>& kb) {\\n    vector<string> st(1);\\n    unordered_map<string, string> m;\\n    for (auto &p : kb)\\n        m[p[0]] = p[1];\\n    for (auto ch: s) {\\n        if (ch == \\')\\') {\\n            auto it = m.find(st.back());\\n            st.pop_back();\\n            st.back() += it != end(m) ? it->second : \"?\";\\n        }\\n        else if(ch == \\'(\\')\\n            st.push_back(\"\");\\n        else\\n            st.back() += ch;\\n    }\\n    return st.front();\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nstring evaluate(string s, vector<vector<string>>& kb) {\\n    vector<string> st(1);\\n    unordered_map<string, string> m;\\n    for (auto &p : kb)\\n        m[p[0]] = p[1];\\n    for (auto ch: s) {\\n        if (ch == \\')\\') {\\n            auto it = m.find(st.back());\\n            st.pop_back();\\n            st.back() += it != end(m) ? it->second : \"?\";\\n        }\\n        else if(ch == \\'(\\')\\n            st.push_back(\"\");\\n        else\\n            st.back() += ch;\\n    }\\n    return st.front();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1130695,
                "title": "java-easy-solution",
                "content": "**Explanation:**\\n* Store all knowledge in HashMap to get words in O(1)\\n* Simple add of characters that are before or after bracket . \\n* (key) found this key and replace through mapped value.\\n\\n**CODE:**\\n```\\n public String evaluate(String s, List<List<String>> knowledge) {\\n        StringBuilder sb=new StringBuilder();\\n        HashMap<String,String> map=new HashMap<>();\\n       \\n        for(List<String> str:knowledge){\\n          map.put(str.get(0),str.get(1));    \\n        }\\n        \\n         int i=0;\\n        while(i<s.length()){\\n            char ch=s.charAt(i);\\n            if(ch==\\'(\\'){\\n                 i++; //we are at \\'(\\' to move to next character\\n                StringBuilder key=new StringBuilder();\\n                // (abcd) -> will cover abcd through this while loop\\n                while(i<s.length() && s.charAt(i)!=\\')\\'){\\n                    key.append(s.charAt(i));\\n                    i++;\\n                }\\n                sb.append(map.containsKey(key.toString())?map.get(key.toString()):\"?\");\\n                i++; // we are at \\')\\' to move to next character\\n                continue;\\n            }\\n            sb.append(ch);    \\n            i++;\\n            \\n        }\\n        return sb.toString();\\n    }\\n```\\n\\n\\n\\nPlease **UPVOTE** if found it helpful and feel free to reach out to me or comment down if you have any doubt.",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\n public String evaluate(String s, List<List<String>> knowledge) {\\n        StringBuilder sb=new StringBuilder();\\n        HashMap<String,String> map=new HashMap<>();\\n       \\n        for(List<String> str:knowledge){\\n          map.put(str.get(0),str.get(1));    \\n        }\\n        \\n         int i=0;\\n        while(i<s.length()){\\n            char ch=s.charAt(i);\\n            if(ch==\\'(\\'){\\n                 i++; //we are at \\'(\\' to move to next character\\n                StringBuilder key=new StringBuilder();\\n                // (abcd) -> will cover abcd through this while loop\\n                while(i<s.length() && s.charAt(i)!=\\')\\'){\\n                    key.append(s.charAt(i));\\n                    i++;\\n                }\\n                sb.append(map.containsKey(key.toString())?map.get(key.toString()):\"?\");\\n                i++; // we are at \\')\\' to move to next character\\n                continue;\\n            }\\n            sb.append(ch);    \\n            i++;\\n            \\n        }\\n        return sb.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1131431,
                "title": "python-solution-using-dictionary",
                "content": "```\\ndef evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        d = dict()\\n        for i, j in knowledge:\\n            d[i]=j\\n        res, i = \\'\\', 0\\n        while i < len(s):\\n            if s[i] ==\\'(\\':\\n                i,t = i+1,i+1\\n                while s[i]!=\\')\\':\\n                    i+=1\\n                if s[t:i] in d:\\n                    res+=d[s[t:i]]\\n                else:\\n                    res += \\'?\\'\\n            else:\\n                res += s[i]\\n            i += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        d = dict()\\n        for i, j in knowledge:\\n            d[i]=j\\n        res, i = \\'\\', 0\\n        while i < len(s):\\n            if s[i] ==\\'(\\':\\n                i,t = i+1,i+1\\n                while s[i]!=\\')\\':\\n                    i+=1\\n                if s[t:i] in d:\\n                    res+=d[s[t:i]]\\n                else:\\n                    res += \\'?\\'\\n            else:\\n                res += s[i]\\n            i += 1\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2464101,
                "title": "c-hash-table-81-35-faster-easy-to-understand",
                "content": "string evaluate(string s, vector<vector<string>>& knowledge) {\\n        unordered_map<string,string>mp;\\n        int n=knowledge.size();\\n        for(int i=0;i<n;i++){\\n            mp.insert({knowledge[i][0],knowledge[i][1]});\\n        }\\n        string  ans;\\n        \\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\'){\\n                i++;\\n                string sas;\\n                while(s[i]!=\\')\\'){\\n                    sas.push_back(s[i]);\\n                    i++;\\n                }\\n                \\n                if(mp.count(sas)){\\n                    ans+=mp[sas];\\n                }\\n                else ans.push_back(\\'?\\');\\n                \\n            }\\n            else {\\n                ans.push_back(s[i]);\\n            }\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table"
                ],
                "code": "string evaluate(string s, vector<vector<string>>& knowledge) {\\n        unordered_map<string,string>mp;\\n        int n=knowledge.size();\\n        for(int i=0;i<n;i++){\\n            mp.insert({knowledge[i][0],knowledge[i][1]});\\n        }\\n        string  ans;\\n        \\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\'){\\n                i++;\\n                string sas;\\n                while(s[i]!=\\')\\'){\\n                    sas.push_back(s[i]);\\n                    i++;\\n                }\\n                \\n                if(mp.count(sas)){\\n                    ans+=mp[sas];\\n                }\\n                else ans.push_back(\\'?\\');\\n                \\n            }\\n            else {\\n                ans.push_back(s[i]);\\n            }\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1133276,
                "title": "javascript-map-regexp-2-lines-of-code",
                "content": "```javascript\\nvar evaluate = function(s, knowledge) {\\n    // key => value hash map can be directly constructed using the Map constructor\\n    const map = new Map(knowledge);\\n    \\n\\t// since bracket pairs can\\'t be nested we can use a RegExp to capture keys and replace using a map constructed in the line above\\n\\treturn s.replace(/\\\\(([a-z]+)\\\\)/g, (_, p1) => map.get(p1) ?? \"?\");\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar evaluate = function(s, knowledge) {\\n    // key => value hash map can be directly constructed using the Map constructor\\n    const map = new Map(knowledge);\\n    \\n\\t// since bracket pairs can\\'t be nested we can use a RegExp to capture keys and replace using a map constructed in the line above\\n\\treturn s.replace(/\\\\(([a-z]+)\\\\)/g, (_, p1) => map.get(p1) ?? \"?\");\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1130508,
                "title": "java-o-n",
                "content": "```\\npublic String evaluate(String s, List<List<String>> knowledge) {\\n\\tMap<String, String> map = new HashMap<>();\\n\\tfor(List<String> k: knowledge) \\n\\t\\tmap.put(k.get(0), k.get(1));\\n\\tStringBuffer result = new StringBuffer(), key = new StringBuffer();\\n\\tboolean isKey =false;\\n\\tfor(int i=0;i<s.length();i++)\\n\\t\\tif(s.charAt(i) == \\')\\' && isKey==true) {\\n\\t\\t\\tisKey = false;\\n\\t\\t\\tif(map.containsKey(key.toString())) result.append(map.get(key.toString()));\\n\\t\\t\\telse result.append(\"?\");\\n\\t\\t\\tkey.setLength(0);\\n\\t\\t} else if(isKey) key.append(s.charAt(i));\\n\\t\\telse if(isKey == false && s.charAt(i) == \\'(\\')  isKey = true;\\n\\t\\telse result.append(s.charAt(i));\\n\\treturn result.toString();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic String evaluate(String s, List<List<String>> knowledge) {\\n\\tMap<String, String> map = new HashMap<>();\\n\\tfor(List<String> k: knowledge) \\n\\t\\tmap.put(k.get(0), k.get(1));\\n\\tStringBuffer result = new StringBuffer(), key = new StringBuffer();\\n\\tboolean isKey =false;\\n\\tfor(int i=0;i<s.length();i++)\\n\\t\\tif(s.charAt(i) == \\')\\' && isKey==true) {\\n\\t\\t\\tisKey = false;\\n\\t\\t\\tif(map.containsKey(key.toString())) result.append(map.get(key.toString()));\\n\\t\\t\\telse result.append(\"?\");\\n\\t\\t\\tkey.setLength(0);\\n\\t\\t} else if(isKey) key.append(s.charAt(i));\\n\\t\\telse if(isKey == false && s.charAt(i) == \\'(\\')  isKey = true;\\n\\t\\telse result.append(s.charAt(i));\\n\\treturn result.toString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1260257,
                "title": "c-comments-added",
                "content": "```\\nclass Solution {\\npublic:\\n    string evaluate(string s, vector<vector<string>>& knowledge) {\\n        string ans; // resultant string\\n        int n = s.size();\\n        if(n < 2) return s; // because () will come in pair so, size should be more than 2\\n        int sz = knowledge.size();\\n        unordered_map<string, string> mp; // To reduce Runtime otherwise it will give TLE\\n        for(int i=0; i<sz; ++i){\\n            mp.insert({knowledge[i][0], knowledge[i][1]}); // Inserting {key, value} pair\\n        }\\n        for(int i=0; i<n; i++){\\n            \\n            if(s[i] == \\'(\\'){  \\n                string key;\\n                i++;\\n                while(s[i] != \\')\\'){ // getting key till we get \\')\\'\\n                    key += s[i++];\\n                }\\n                string value;\\n                if(mp.find(key) != mp.end()){ // If {key, value} pair is present then replace (key) by it\\'s value\\n                    value = mp[key];\\n                    ans += value;\\n                }\\n                else {// otherwise replace (key) by ?\\n                    ans += \"?\";\\n                }\\n            }\\n            else ans += s[i];\\n        }\\n        return ans;\\n    }\\n};\\n\\n**Please do upvote**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string evaluate(string s, vector<vector<string>>& knowledge) {\\n        string ans; // resultant string\\n        int n = s.size();\\n        if(n < 2) return s; // because () will come in pair so, size should be more than 2\\n        int sz = knowledge.size();\\n        unordered_map<string, string> mp; // To reduce Runtime otherwise it will give TLE\\n        for(int i=0; i<sz; ++i){\\n            mp.insert({knowledge[i][0], knowledge[i][1]}",
                "codeTag": "Java"
            },
            {
                "id": 1244209,
                "title": "c-o-n-time-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string evaluate(string s, vector<vector<string>>& knowledge) \\n    {\\n        unordered_map<string, string> mp;\\n        for(int i=0; i<knowledge.size(); i++)\\n            mp[knowledge[i][0]] = knowledge[i][1];\\n        string res=\"\";\\n        for(int i=0; i<s.size(); i++)\\n        {\\n            if(s[i] == \\'(\\')\\n            {\\n                i++;\\n                string key=\"\";\\n                while(s[i] != \\')\\')\\n                {\\n                    key += s[i];                    \\n                    i++;\\n                }\\n                if(mp.find(key) != mp.end())\\n                    res += mp[key];\\n                else\\n                    res += \\'?\\';\\n                continue;\\n            }\\n            res += s[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string evaluate(string s, vector<vector<string>>& knowledge) \\n    {\\n        unordered_map<string, string> mp;\\n        for(int i=0; i<knowledge.size(); i++)\\n            mp[knowledge[i][0]] = knowledge[i][1];\\n        string res=\"\";\\n        for(int i=0; i<s.size(); i++)\\n        {\\n            if(s[i] == \\'(\\')\\n            {\\n                i++;\\n                string key=\"\";\\n                while(s[i] != \\')\\')\\n                {\\n                    key += s[i];                    \\n                    i++;\\n                }\\n                if(mp.find(key) != mp.end())\\n                    res += mp[key];\\n                else\\n                    res += \\'?\\';\\n                continue;\\n            }\\n            res += s[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1130707,
                "title": "straightforward-python-dictionary-solution",
                "content": "```\\nclass Solution:\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        K = { k[0] : k[1] for k in knowledge}\\n        stack = []\\n        for ch in s:\\n            if ch != \\')\\':\\n                stack.append(ch)\\n            else:\\n                word = []\\n                while stack[-1] != \\'(\\':\\n                    word.append(stack.pop())\\n                stack.pop()\\n                stack.append(K.get(\\'\\'.join(word[::-1]), \\'?\\'))\\n                \\n        return \\'\\'.join(stack)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        K = { k[0] : k[1] for k in knowledge}\\n        stack = []\\n        for ch in s:\\n            if ch != \\')\\':\\n                stack.append(ch)\\n            else:\\n                word = []\\n                while stack[-1] != \\'(\\':\\n                    word.append(stack.pop())\\n                stack.pop()\\n                stack.append(K.get(\\'\\'.join(word[::-1]), \\'?\\'))\\n                \\n        return \\'\\'.join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1130532,
                "title": "c-linear-scan",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1.\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-234/problems/evaluate-the-bracket-pairs-of-a-string/\\n// Author: github.com/lzl124631x\\n// Time: O(S + A)\\n// Space: O(S + A)\\nclass Solution {\\npublic:\\n    string evaluate(string s, vector<vector<string>>& A) {\\n        unordered_map<string, string> m;\\n        for (auto &v : A) {\\n            m[v[0]] = v[1];\\n        }\\n        int N = s.size(), start = -1;\\n        string ans;\\n        for (int i = 0; i < N; ++i) {\\n            if (s[i] == \\'(\\') { // log the index of (\\n                start = i;\\n            } else if (s[i] == \\')\\') { // Get the key and try to find the corresponding value\\n                auto key = s.substr(start + 1, i - start - 1);\\n                if (m.count(key)) ans += m[key];\\n                else ans += \"?\";\\n                start = -1;\\n            } else if (start == -1) { // Characters that are not in () are directly appended.\\n                ans += s[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-234/problems/evaluate-the-bracket-pairs-of-a-string/\\n// Author: github.com/lzl124631x\\n// Time: O(S + A)\\n// Space: O(S + A)\\nclass Solution {\\npublic:\\n    string evaluate(string s, vector<vector<string>>& A) {\\n        unordered_map<string, string> m;\\n        for (auto &v : A) {\\n            m[v[0]] = v[1];\\n        }\\n        int N = s.size(), start = -1;\\n        string ans;\\n        for (int i = 0; i < N; ++i) {\\n            if (s[i] == \\'(\\') { // log the index of (\\n                start = i;\\n            } else if (s[i] == \\')\\') { // Get the key and try to find the corresponding value\\n                auto key = s.substr(start + 1, i - start - 1);\\n                if (m.count(key)) ans += m[key];\\n                else ans += \"?\";\\n                start = -1;\\n            } else if (start == -1) { // Characters that are not in () are directly appended.\\n                ans += s[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2835138,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   string evaluate(string s, vector<vector<string>>& k) {\\n        unordered_map<string,string>m;\\n        for(vector<string>temp : k)  m[temp[0]]= temp[1];\\n        string res = \"\";\\n        int n = s.length(),i=0;\\n        while(i<n){\\n            if(s[i] != \\'(\\') res += s[i++];\\n            else{\\n                int j = i+1;\\n                string temp = \"\";\\n                while(j<n && s[j] != \\')\\') \\n                    temp+=s[j++];\\n                if(m.find(temp) != m.end()) res += m[temp];\\n                else res += \\'?\\';\\n                i = j+1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   string evaluate(string s, vector<vector<string>>& k) {\\n        unordered_map<string,string>m;\\n        for(vector<string>temp : k)  m[temp[0]]= temp[1];\\n        string res = \"\";\\n        int n = s.length(),i=0;\\n        while(i<n){\\n            if(s[i] != \\'(\\') res += s[i++];\\n            else{\\n                int j = i+1;\\n                string temp = \"\";\\n                while(j<n && s[j] != \\')\\') \\n                    temp+=s[j++];\\n                if(m.find(temp) != m.end()) res += m[temp];\\n                else res += \\'?\\';\\n                i = j+1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2804522,
                "title": "java-hashmap-easy",
                "content": "### **Please Upvote** :D\\nThe example testcase with output `\"yesyesyesaaa\"` really got me lmao.\\n```\\nclass Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n        Map<String, String> map = new HashMap<>();\\n\\n        for (List<String> list : knowledge) {\\n            map.put(list.get(0), list.get(1));\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) != \\'(\\') {\\n                sb.append(s.charAt(i));\\n            }\\n            else if (s.charAt(i) == \\'(\\') {\\n                int start = i + 1;\\n                while (i < s.length() && s.charAt(i) != \\')\\') {\\n                    i++;\\n                }\\n                sb.append(map.getOrDefault(s.substring(start, i), \"?\"));\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n\\n// TC: O(n ^ 2), SC: (k)\\n// n -> length of string\\n// k -> length of map\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n        Map<String, String> map = new HashMap<>();\\n\\n        for (List<String> list : knowledge) {\\n            map.put(list.get(0), list.get(1));\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) != \\'(\\') {\\n                sb.append(s.charAt(i));\\n            }\\n            else if (s.charAt(i) == \\'(\\') {\\n                int start = i + 1;\\n                while (i < s.length() && s.charAt(i) != \\')\\') {\\n                    i++;\\n                }\\n                sb.append(map.getOrDefault(s.substring(start, i), \"?\"));\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n\\n// TC: O(n ^ 2), SC: (k)\\n// n -> length of string\\n// k -> length of map\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2760130,
                "title": "using-map-very-beginner-friendly-approach-in-c-clean-code-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    string evaluate(string s, vector<vector<string>>& knowledge) {\\n     map<string, string>mp;\\n      for(auto it : knowledge)\\n      {\\n        mp[it[0]] = it[1];\\n      }\\n      string res = \"\";\\n      for(int i = 0 ; i < s.length() ; i++)\\n      {\\n        bool take = false;\\n        int add = -1;\\n       if(s[i] == \\'(\\') \\n       {\\n         string test = \"\";\\n         int temp = i+1;\\n         while(s[temp] != \\')\\')\\n         {\\n           test += s[temp];\\n           temp++;\\n         }\\n         take = true;\\n         add = temp;\\n         if(mp.find(test) != mp.end()) res += mp[test];\\n         else res += \\'?\\';\\n       }\\n        else res += s[i];\\n        if(add != -1) i = add;\\n      }\\n      return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string evaluate(string s, vector<vector<string>>& knowledge) {\\n     map<string, string>mp;\\n      for(auto it : knowledge)\\n      {\\n        mp[it[0]] = it[1];\\n      }\\n      string res = \"\";\\n      for(int i = 0 ; i < s.length() ; i++)\\n      {\\n        bool take = false;\\n        int add = -1;\\n       if(s[i] == \\'(\\') \\n       {\\n         string test = \"\";\\n         int temp = i+1;\\n         while(s[temp] != \\')\\')\\n         {\\n           test += s[temp];\\n           temp++;\\n         }\\n         take = true;\\n         add = temp;\\n         if(mp.find(test) != mp.end()) res += mp[test];\\n         else res += \\'?\\';\\n       }\\n        else res += s[i];\\n        if(add != -1) i = add;\\n      }\\n      return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1713704,
                "title": "python3-dictionary-hash-table-two-pointers-easy-understanding",
                "content": "```\\ndef evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        d = {k: v for k, v in knowledge}\\n        \\n        left = 0\\n        res = []\\n        s += \"(\"\\n        for idx, char in enumerate(s):\\n            if char == \"(\":\\n                res.append(s[left:idx])\\n                left = idx\\n            if char == \")\":\\n                temp = s[left + 1: idx]\\n                res.append(d.get(temp, \\'?\\'))\\n                left = idx + 1\\n        return \\'\\'.join(res)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Two Pointers"
                ],
                "code": "```\\ndef evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        d = {k: v for k, v in knowledge}\\n        \\n        left = 0\\n        res = []\\n        s += \"(\"\\n        for idx, char in enumerate(s):\\n            if char == \"(\":\\n                res.append(s[left:idx])\\n                left = idx\\n            if char == \")\":\\n                temp = s[left + 1: idx]\\n                res.append(d.get(temp, \\'?\\'))\\n                left = idx + 1\\n        return \\'\\'.join(res)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1393591,
                "title": "java-map-stringbuilder-implementation",
                "content": "```\\nclass Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n        Map<String, String> map = new HashMap<>();\\n        for(List<String> ele : knowledge) {\\n            map.put(ele.get(0), ele.get(1));\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        int b_start = -1;\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s.charAt(i) == \\'(\\') {\\n                b_start = i;\\n            } else if(s.charAt(i) == \\')\\') {\\n                String key = s.substring(b_start + 1, i);\\n                sb.append(map.getOrDefault(key, \"?\"));\\n                b_start = -1;\\n            } else {\\n                if(b_start == -1) {\\n                    sb.append(s.charAt(i));\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n````",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n        Map<String, String> map = new HashMap<>();\\n        for(List<String> ele : knowledge) {\\n            map.put(ele.get(0), ele.get(1));\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        int b_start = -1;\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s.charAt(i) == \\'(\\') {\\n                b_start = i;\\n            } else if(s.charAt(i) == \\')\\') {\\n                String key = s.substring(b_start + 1, i);\\n                sb.append(map.getOrDefault(key, \"?\"));\\n                b_start = -1;\\n            } else {\\n                if(b_start == -1) {\\n                    sb.append(s.charAt(i));\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368364,
                "title": "1807-from-left-to-right-copy-chars-if-ignore-lookup-for-val-for-in-between-string",
                "content": "---\\n**Algo**\\n- **Regex solution**\\n  - Add all `(key)` and val to Map. **NOTE**: brackets in key.\\n  - Use regex to find above replace with val, repeatedly / global / g flag\\n- **Non Regex**\\n  - Add all `key` and val to Map. **NOTE**: no brackets in key.\\n  - From left to right read char `c`\\n    - if (, but flag it as `KEY started` by making KEY from null to empty array [] or empty string \\'\\')\\n    - if KEY has stated, append to it, else append to `ans` array\\n    - if ), if KEY is found in map, then append value of the KEY to arr, else append `?`\\n  - return `arr`\\n\\nHope it is simple to understand.\\n\\n---\\n\\n**Regex solution 1 - Too slow**\\n\\n```\\nvar evaluate = function (s, knowledge) {\\n    let map = new Map();\\n\\n    for (let [key, val] of knowledge)\\n\\t\\tmap.set(\"\\\\\\\\(\" + key + \"\\\\\\\\)\", val);\\n\\n    for (let [key, val] of map)\\n\\t\\ts = s.replace(new RegExp(key, \"g\"), val);\\n\\n    return s.replace(new RegExp(\"\\\\\\\\(.*?\\\\\\\\)\", \"g\"), \"?\");\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/89ed516e-05c5-4f3a-9ac1-6d771dd8b594_1627477320.8375618.png)\\n\\n---\\n\\n**Regex solution 2 - Too slow - 2 or 3 liner**\\n\\n```\\nvar evaluate = function (s, knowledge) {\\n    for (let [key, val] of knowledge)\\n        s = s.replace(new RegExp(\"\\\\\\\\(\" + key + \"\\\\\\\\)\", \"g\"), val);\\n    return s.replace(new RegExp(\"\\\\\\\\(.*?\\\\\\\\)\", \"g\"), \"?\");\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/c4bbbab4-3b12-4173-b6cc-3a8d4312fd98_1627477345.4494987.png)\\n\\n---\\n\\n**Non Regex solution 1 - faster - ans & KEY both are arrays**\\n\\n```\\nvar evaluate = function (s, knowledge) {\\n    let ans = [];\\n\\n    let map = new Map();\\n    for (let [key, val] of knowledge) map.set(key, val);\\n\\n    let KEY = null;\\n    for (let c of s) {\\n        switch (c) {\\n            case \"(\":\\n                KEY = [];\\n                break;\\n            case \")\":\\n                if (map.has(KEY.join(\"\"))) ans.push(map.get(KEY.join(\"\")));\\n                else ans.push(\"?\"); // append ? if key not found, else its val\\n\\n                KEY = null;\\n                break;\\n            default:\\n                if (KEY) KEY.push(c);\\n                else ans.push(c); // not a key, so it is ans\\n                break;\\n        }\\n    }\\n\\n    return ans.join(\"\");\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/50534db9-a4a3-4dca-a33c-bcb01c162140_1627477367.1345446.png)\\n\\n---\\n\\n**Non Regex solution 2 - faster - ans is array & KEY is string**\\n\\n```\\nvar evaluate = function (s, knowledge) {\\n    let ans = [];\\n\\n    let map = new Map(knowledge);\\n\\n    let KEY = null;\\n    for (let c of s) {\\n        switch (c) {\\n            case \"(\":\\n                KEY = \"\";\\n                break;\\n            case \")\":\\n                if (map.has(KEY)) ans.push(map.get(KEY));\\n                else ans.push(\"?\"); // append ? if key not found, else its val\\n\\n                KEY = null;\\n                break;\\n            default:\\n                if (KEY !== null) KEY += c;\\n                else ans.push(c); // not a key, so it is ans\\n                break;\\n        }\\n    }\\n\\n    return ans.join(\"\");\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/fa44f8b9-714b-46be-bc17-effc7ea8b182_1627477386.742021.png)\\n\\n---\\n\\n**Non Regex solution 3 - faster - ans & KEY both are strings**\\n\\n```\\nvar evaluate = function (s, knowledge) {\\n    let ans = \"\";\\n\\n    let map = new Map(knowledge);\\n\\n    let KEY = null;\\n    for (let c of s) {\\n        switch (c) {\\n            case \"(\":\\n                KEY = \"\";\\n                break;\\n            case \")\":\\n                if (map.has(KEY)) ans += map.get(KEY);\\n                else ans += \"?\"; // append ? if key not found, else its val\\n\\n                KEY = null;\\n                break;\\n            default:\\n                if (KEY !== null) KEY += c;\\n                else ans += c; // not a key, so it is ans\\n                break;\\n        }\\n    }\\n\\n    return ans;\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/a6cda400-8000-41c5-81aa-64623830b38c_1627477428.328326.png)\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar evaluate = function (s, knowledge) {\\n    let map = new Map();\\n\\n    for (let [key, val] of knowledge)\\n\\t\\tmap.set(\"\\\\\\\\(\" + key + \"\\\\\\\\)\", val);\\n\\n    for (let [key, val] of map)\\n\\t\\ts = s.replace(new RegExp(key, \"g\"), val);\\n\\n    return s.replace(new RegExp(\"\\\\\\\\(.*?\\\\\\\\)\", \"g\"), \"?\");\\n};\\n```\n```\\nvar evaluate = function (s, knowledge) {\\n    for (let [key, val] of knowledge)\\n        s = s.replace(new RegExp(\"\\\\\\\\(\" + key + \"\\\\\\\\)\", \"g\"), val);\\n    return s.replace(new RegExp(\"\\\\\\\\(.*?\\\\\\\\)\", \"g\"), \"?\");\\n};\\n```\n```\\nvar evaluate = function (s, knowledge) {\\n    let ans = [];\\n\\n    let map = new Map();\\n    for (let [key, val] of knowledge) map.set(key, val);\\n\\n    let KEY = null;\\n    for (let c of s) {\\n        switch (c) {\\n            case \"(\":\\n                KEY = [];\\n                break;\\n            case \")\":\\n                if (map.has(KEY.join(\"\"))) ans.push(map.get(KEY.join(\"\")));\\n                else ans.push(\"?\"); // append ? if key not found, else its val\\n\\n                KEY = null;\\n                break;\\n            default:\\n                if (KEY) KEY.push(c);\\n                else ans.push(c); // not a key, so it is ans\\n                break;\\n        }\\n    }\\n\\n    return ans.join(\"\");\\n};\\n```\n```\\nvar evaluate = function (s, knowledge) {\\n    let ans = [];\\n\\n    let map = new Map(knowledge);\\n\\n    let KEY = null;\\n    for (let c of s) {\\n        switch (c) {\\n            case \"(\":\\n                KEY = \"\";\\n                break;\\n            case \")\":\\n                if (map.has(KEY)) ans.push(map.get(KEY));\\n                else ans.push(\"?\"); // append ? if key not found, else its val\\n\\n                KEY = null;\\n                break;\\n            default:\\n                if (KEY !== null) KEY += c;\\n                else ans.push(c); // not a key, so it is ans\\n                break;\\n        }\\n    }\\n\\n    return ans.join(\"\");\\n};\\n```\n```\\nvar evaluate = function (s, knowledge) {\\n    let ans = \"\";\\n\\n    let map = new Map(knowledge);\\n\\n    let KEY = null;\\n    for (let c of s) {\\n        switch (c) {\\n            case \"(\":\\n                KEY = \"\";\\n                break;\\n            case \")\":\\n                if (map.has(KEY)) ans += map.get(KEY);\\n                else ans += \"?\"; // append ? if key not found, else its val\\n\\n                KEY = null;\\n                break;\\n            default:\\n                if (KEY !== null) KEY += c;\\n                else ans += c; // not a key, so it is ans\\n                break;\\n        }\\n    }\\n\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1286887,
                "title": "python-dictionary-simple-solution",
                "content": "```\\nclass Solution:\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        knowledge = dict(knowledge)\\n        answer, start = [], None\\n        for i, char in enumerate(s):\\n            if char == \\'(\\': \\n                start = i + 1\\n            elif char == \\')\\':\\n                answer.append(knowledge.get(s[start:i], \\'?\\'))\\n                start = None\\n            elif start is None: \\n                answer.append(char)\\n        return \\'\\'.join(answer)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        knowledge = dict(knowledge)\\n        answer, start = [], None\\n        for i, char in enumerate(s):\\n            if char == \\'(\\': \\n                start = i + 1\\n            elif char == \\')\\':\\n                answer.append(knowledge.get(s[start:i], \\'?\\'))\\n                start = None\\n            elif start is None: \\n                answer.append(char)\\n        return \\'\\'.join(answer)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1188249,
                "title": "binary-search-c",
                "content": "I first sorted the array according to key. Then for finding the value of a given key, I applied binary search. If key is found, I returned the corresponding value... if not found, I returned ```\"?\"```.\\nThe above part is implemented in the ```search()``` function.\\nRest of the code is pretty much normal and easy to understand.\\n\\n```\\nclass Solution {\\npublic:\\n    string search(string &key, vector<vector<string>> &v){\\n        int l=0,r=v.size()-1;\\n        while(l<=r){\\n            int mid=l+(r-l)/2;\\n            if(v[mid][0]==key){\\n                return v[mid][1];\\n            }else if(v[mid][0]<key){\\n                l=mid+1;\\n            }else{\\n                r=mid-1;\\n            }\\n        }\\n        return \"?\";\\n    }\\n    string evaluate(string s, vector<vector<string>>& knowledge) {\\n        sort(knowledge.begin(),knowledge.end());\\n        int i=0;\\n        string ans;\\n        while(i<s.length()){\\n            if(s[i]==\\'(\\'){\\n                int j=i;\\n                while(s[i]!=\\')\\'){\\n                    i++;\\n                }\\n                int len=i-j-1;\\n                string key=s.substr(j+1,len);\\n                string res=search(key,knowledge);\\n                ans.append(res);\\n                i++;\\n            }else{\\n                ans.push_back(s[i]);\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease let me know in the comments if you could suggest improvements in the above code/approach.",
                "solutionTags": [],
                "code": "```\"?\"```\n```search()```\n```\\nclass Solution {\\npublic:\\n    string search(string &key, vector<vector<string>> &v){\\n        int l=0,r=v.size()-1;\\n        while(l<=r){\\n            int mid=l+(r-l)/2;\\n            if(v[mid][0]==key){\\n                return v[mid][1];\\n            }else if(v[mid][0]<key){\\n                l=mid+1;\\n            }else{\\n                r=mid-1;\\n            }\\n        }\\n        return \"?\";\\n    }\\n    string evaluate(string s, vector<vector<string>>& knowledge) {\\n        sort(knowledge.begin(),knowledge.end());\\n        int i=0;\\n        string ans;\\n        while(i<s.length()){\\n            if(s[i]==\\'(\\'){\\n                int j=i;\\n                while(s[i]!=\\')\\'){\\n                    i++;\\n                }\\n                int len=i-j-1;\\n                string key=s.substr(j+1,len);\\n                string res=search(key,knowledge);\\n                ans.append(res);\\n                i++;\\n            }else{\\n                ans.push_back(s[i]);\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1131716,
                "title": "python-clear-hashmap-solution-with-video-explanation",
                "content": "Video with clear visualization and explanation:\\nhttps://youtu.be/Qb1nX4f3dbA\\n\\n\\n\\nIntuition: Hashmap+Linear Scan\\n \\n\\n**Code**\\nInspired by: https://leetcode.com/problems/evaluate-the-bracket-pairs-of-a-string/discuss/1130600/Python-Solution\\n```\\nclass Solution:\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        m = {k: v for k, v in knowledge}\\n        res = []\\n        cur = \\'\\'\\n        inBracket = False\\n        \\n        for c in s:\\n            if c == \\'(\\':\\n                inBracket = True\\n            elif c == \\')\\':\\n                inBracket = False\\n                res.append(m.get(cur, \\'?\\'))\\n                cur = \\'\\'\\n            elif inBracket:\\n                cur += c\\n            else:\\n                res.append(c)\\n                \\n        return \\'\\'.join(res)\\n```\\n\\n\\nTime / Space: O(n)\\n\\n\\nFeel free to subscribe to my channel. More LeetCoding videos coming up!\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        m = {k: v for k, v in knowledge}\\n        res = []\\n        cur = \\'\\'\\n        inBracket = False\\n        \\n        for c in s:\\n            if c == \\'(\\':\\n                inBracket = True\\n            elif c == \\')\\':\\n                inBracket = False\\n                res.append(m.get(cur, \\'?\\'))\\n                cur = \\'\\'\\n            elif inBracket:\\n                cur += c\\n            else:\\n                res.append(c)\\n                \\n        return \\'\\'.join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1131195,
                "title": "simple-solution-3-lines-re-module-in-python",
                "content": "```\\nclass Solution:\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        import re\\n        k = dict(knowledge)\\n        return re.sub(r\\'\\\\((\\\\w+?)\\\\)\\', lambda mo : k.get(mo.group(1), \\'?\\'), s)\\n```\\n\\nSo the explanation of the code is as follows. First the \\n```\\nk = dict(knowledge)\\n```\\nline is a shorthand for creating a dict from a list of key/value pairs. The re.sub method finds matches of a pattern in a string. When it matches the pattern, in this case a word between a pair of brackets, it calls the supplied lambda with the matched string as argument. In this case this string is a key in the dict \\'k\\' that was just created. A lookup is done using the get method. The value of the dict entry is what the re.sub method uses to replace the matched word with. If the value cannot be found it uses the supplied second argument as the value to replace the matched string with. In this case it is the required \\'?\\' symbol.\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        import re\\n        k = dict(knowledge)\\n        return re.sub(r\\'\\\\((\\\\w+?)\\\\)\\', lambda mo : k.get(mo.group(1), \\'?\\'), s)\\n```\n```\\nk = dict(knowledge)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1130904,
                "title": "java-using-regex-only-tle",
                "content": "```\\nclass Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n        char[] arr = s.toCharArray();\\n        StringBuilder str = new StringBuilder();\\n        HashMap<String,String>  map = new HashMap();\\n\\t\\t\\n        for( List<String> k : knowledge )\\n          map.put( \"(\" +k.get(0)+\")\", k.get(1) ); // storing name->bob, age->two\\n        \\n        for( int end = 0 ; end < arr.length; end++ )\\n        {\\n            char ch = arr[end];\\n            if( ch == \\'(\\')\\n            {\\n                int start = end;\\n                while( arr[end] != \\')\\') end++; //go till matching \\')\\' \\n                if( map.get( s.substring(start,end+1) ) != null ) //  s.substring(j,i+1) = (name) \\n                    str.append( map.get( s.substring(start,end+1) ) );\\n                else\\n                    str.append(\"?\" );\\n            }\\n            else\\n                str.append(ch+\"\");\\n        }\\n    return str.toString();\\n    }\\n}\\n```\\n\\nSolution with Regex gave TLE during contest\\n\\n```\\nclass Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n        for( List<String> k : knowledge )\\n        {\\n            String key = \"\\\\\\\\(\" +k.get(0)+\"\\\\\\\\)\";\\n            String val = k.get(1);\\n            s=s.replaceAll( key, val);\\n        }\\n        String key = \"\\\\\\\\([a-z]*\\\\\\\\)\";\\n        s=s.replaceAll(key,\"?\");\\n     \\n    return s;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n        char[] arr = s.toCharArray();\\n        StringBuilder str = new StringBuilder();\\n        HashMap<String,String>  map = new HashMap();\\n\\t\\t\\n        for( List<String> k : knowledge )\\n          map.put( \"(\" +k.get(0)+\")\", k.get(1) ); // storing name->bob, age->two\\n        \\n        for( int end = 0 ; end < arr.length; end++ )\\n        {\\n            char ch = arr[end];\\n            if( ch == \\'(\\')\\n            {\\n                int start = end;\\n                while( arr[end] != \\')\\') end++; //go till matching \\')\\' \\n                if( map.get( s.substring(start,end+1) ) != null ) //  s.substring(j,i+1) = (name) \\n                    str.append( map.get( s.substring(start,end+1) ) );\\n                else\\n                    str.append(\"?\" );\\n            }\\n            else\\n                str.append(ch+\"\");\\n        }\\n    return str.toString();\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n        for( List<String> k : knowledge )\\n        {\\n            String key = \"\\\\\\\\(\" +k.get(0)+\"\\\\\\\\)\";\\n            String val = k.get(1);\\n            s=s.replaceAll( key, val);\\n        }\\n        String key = \"\\\\\\\\([a-z]*\\\\\\\\)\";\\n        s=s.replaceAll(key,\"?\");\\n     \\n    return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1130806,
                "title": "javascript-for-beginners-230ms",
                "content": "```\\n var evaluate = function(s, knowledge) {\\n    const map = new Map();\\n    \\n    for (const [ky, val] of knowledge) {\\n        map.set(ky, val);\\n    }\\n\\n    let out = \\'\\';\\n    let started = false;\\n    let tmp = \\'\\';\\n    for (const c of s) {\\n        if (started) {\\n            if (c === \\')\\') {\\n                if (map.has(tmp)) {\\n                    out += map.get(tmp);\\n                } else {\\n                    out += \\'?\\';\\n                }\\n                tmp = \\'\\'\\n                started = false;\\n            } else {\\n                tmp += c;\\n            }\\n        } else if (c == \\'(\\') {\\n            started = true;\\n        } else {\\n            out += c;\\n        }\\n    }\\n    return out;\\n};",
                "solutionTags": [],
                "code": "```\\n var evaluate = function(s, knowledge) {\\n    const map = new Map();\\n    \\n    for (const [ky, val] of knowledge) {\\n        map.set(ky, val);\\n    }\\n\\n    let out = \\'\\';\\n    let started = false;\\n    let tmp = \\'\\';\\n    for (const c of s) {\\n        if (started) {\\n            if (c === \\')\\') {\\n                if (map.has(tmp)) {\\n                    out += map.get(tmp);\\n                } else {\\n                    out += \\'?\\';\\n                }\\n                tmp = \\'\\'\\n                started = false;\\n            } else {\\n                tmp += c;\\n            }\\n        } else if (c == \\'(\\') {\\n            started = true;\\n        } else {\\n            out += c;\\n        }\\n    }\\n    return out;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1130570,
                "title": "clean-python-3-hashmap-and-generator",
                "content": "Time: `O(N)`\\nSpace: `O(N)`\\n```\\nclass Solution:\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        def gen(S: str):\\n            i, is_closed = -1, True\\n            for j, c in enumerate(S):\\n                if c == \\'(\\':\\n                    i = j + 1\\n                    is_closed = False\\n                elif c == \\')\\':\\n                    yield lookup.get(s[i:j], \\'?\\')\\n                    is_closed = True\\n                elif is_closed:\\n                    yield c\\n\\n        lookup = {k: v for k, v in knowledge}\\n        return \\'\\'.join(gen(s))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        def gen(S: str):\\n            i, is_closed = -1, True\\n            for j, c in enumerate(S):\\n                if c == \\'(\\':\\n                    i = j + 1\\n                    is_closed = False\\n                elif c == \\')\\':\\n                    yield lookup.get(s[i:j], \\'?\\')\\n                    is_closed = True\\n                elif is_closed:\\n                    yield c\\n\\n        lookup = {k: v for k, v in knowledge}\\n        return \\'\\'.join(gen(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1130549,
                "title": "python-regex-based-solution-memory-100-runtime-100",
                "content": "This is a common transformation task in text processing. Regex is powerful. \\nDocumentation ref: [re.sub](https://docs.python.org/3/library/re.html#re.sub)\\n\\n```\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        k = {}\\n        for e in knowledge:\\n            k[e[0]] = e[1]\\n        \\n        # replace function m-> re.match object\\n        def r(m):\\n            n = m.group(0)[1:-1]\\n            if n in k:\\n                return k[n]\\n            else:\\n                return \"?\"\\n            \\n        return re.sub(\"\\\\((.*?)\\\\)\",r,s)\\n```",
                "solutionTags": [],
                "code": "```\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        k = {}\\n        for e in knowledge:\\n            k[e[0]] = e[1]\\n        \\n        # replace function m-> re.match object\\n        def r(m):\\n            n = m.group(0)[1:-1]\\n            if n in k:\\n                return k[n]\\n            else:\\n                return \"?\"\\n            \\n        return re.sub(\"\\\\((.*?)\\\\)\",r,s)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1130526,
                "title": "python-using-dic-very-easy-solution",
                "content": "```\\nclass Solution:\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        dic ={}\\n        for a,b in knowledge:\\n            dic[a] = b\\n        res, temp  = \\'\\', \\'\\'\\n        isopened = False\\n        for i in range(len(s)):\\n            if s[i] == \\'(\\':\\n                isopened = True\\n            elif s[i] == \\')\\':\\n                key = temp\\n                if key in dic:\\n                    res = res + dic[key]\\n                else:\\n                    res = res + \\'?\\'\\n                temp = \\'\\'\\n                isopened = False\\n            elif  isopened == False:\\n                res = res + s[i]\\n            elif isopened == True:\\n                temp = temp + s[i]\\n        return res\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        dic ={}\\n        for a,b in knowledge:\\n            dic[a] = b\\n        res, temp  = \\'\\', \\'\\'\\n        isopened = False\\n        for i in range(len(s)):\\n            if s[i] == \\'(\\':\\n                isopened = True\\n            elif s[i] == \\')\\':\\n                key = temp\\n                if key in dic:\\n                    res = res + dic[key]\\n                else:\\n                    res = res + \\'?\\'\\n                temp = \\'\\'\\n                isopened = False\\n            elif  isopened == False:\\n                res = res + s[i]\\n            elif isopened == True:\\n                temp = temp + s[i]\\n        return res\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038830,
                "title": "easy-hashmap",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n        HashMap<String, String> map=new HashMap<>();\\n        for(int i=0; i<knowledge.size(); i++){\\n            map.put((knowledge.get(i)).get(0),(knowledge.get(i)).get(1));\\n        }\\n        String ans=\"\";\\n        for(int i=0; i<s.length(); i++){\\n            if(s.charAt(i)==\\'(\\'){\\n                int start=i;\\n                int end=i;\\n                while(s.charAt(i)!=\\')\\'){\\n                    i++;\\n                }\\n                end=i;\\n                String str=map.get(s.substring(start+1,end));\\n                ans += str==null ? \"?\" : str;\\n            }else{\\n                ans+=s.charAt(i);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Function"
                ],
                "code": "```\\nclass Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n        HashMap<String, String> map=new HashMap<>();\\n        for(int i=0; i<knowledge.size(); i++){\\n            map.put((knowledge.get(i)).get(0),(knowledge.get(i)).get(1));\\n        }\\n        String ans=\"\";\\n        for(int i=0; i<s.length(); i++){\\n            if(s.charAt(i)==\\'(\\'){\\n                int start=i;\\n                int end=i;\\n                while(s.charAt(i)!=\\')\\'){\\n                    i++;\\n                }\\n                end=i;\\n                String str=map.get(s.substring(start+1,end));\\n                ans += str==null ? \"?\" : str;\\n            }else{\\n                ans+=s.charAt(i);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687363,
                "title": "python-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        d={}\\n        for i in knowledge:\\n            d[i[0]]=i[1]\\n        temp=\\'\\'\\n        res=\\'\\'\\n        flag=0\\n        for i in s:\\n            if i==\\'(\\':\\n                flag=1\\n            elif i!=\\')\\' and flag==1:\\n                temp=temp+i\\n            elif i==\\')\\':\\n                if temp in d.keys():\\n                    res=res+d[temp]\\n                else:\\n                    res=res+\\'?\\'\\n                temp=\\'\\'\\n                flag=0\\n            else:\\n                res=res+i\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        d={}\\n        for i in knowledge:\\n            d[i[0]]=i[1]\\n        temp=\\'\\'\\n        res=\\'\\'\\n        flag=0\\n        for i in s:\\n            if i==\\'(\\':\\n                flag=1\\n            elif i!=\\')\\' and flag==1:\\n                temp=temp+i\\n            elif i==\\')\\':\\n                if temp in d.keys():\\n                    res=res+d[temp]\\n                else:\\n                    res=res+\\'?\\'\\n                temp=\\'\\'\\n                flag=0\\n            else:\\n                res=res+i\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3299569,
                "title": "a-basic-solution-find-bracket-index-and-make-new-string-accordingly",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string evaluate(string s, vector<vector<string>>& knowledge) {\\n        string ans = \"\";\\n\\n        map<string, string> keyvalue;\\n\\n        for(int i=0;i<knowledge.size();i++){\\n          keyvalue[knowledge[i][0]] = knowledge[i][1];\\n        }\\n          vector<int> index;\\n\\n          for(int i=0;i<s.length();i++)\\n          {\\n            if(s[i] == \\'(\\'){\\n              index.push_back(i);\\n            }else if(s[i] == \\')\\'){\\n              index.push_back(i);\\n            }\\n          }\\n          int k = 0;\\n          bool bopen = false;\\n          for(int i=0;i<s.length();i++){\\n            \\n            if(s[i] == \\'(\\'){\\n              bopen = true;\\n           //   cout<<k<<\" \"<<endl;\\n             string key = s.substr(index[k]+1,index[k+1]-index[k]-1);\\n           //  cout<<key<<\" \"<<endl;\\n             if(keyvalue[key] == \"\"){\\n                ans+=\"?\";\\n             }else{\\n                ans+=keyvalue[key];\\n             }\\n             \\n             k = k+2;\\n            }else if(s[i] == \\')\\'){\\n              bopen = false;\\n            }else{\\n              if(!bopen)\\n              ans+=s[i];\\n            }\\n          }\\n                   \\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string evaluate(string s, vector<vector<string>>& knowledge) {\\n        string ans = \"\";\\n\\n        map<string, string> keyvalue;\\n\\n        for(int i=0;i<knowledge.size();i++){\\n          keyvalue[knowledge[i][0]] = knowledge[i][1];\\n        }\\n          vector<int> index;\\n\\n          for(int i=0;i<s.length();i++)\\n          {\\n            if(s[i] == \\'(\\'){\\n              index.push_back(i);\\n            }else if(s[i] == \\')\\'){\\n              index.push_back(i);\\n            }\\n          }\\n          int k = 0;\\n          bool bopen = false;\\n          for(int i=0;i<s.length();i++){\\n            \\n            if(s[i] == \\'(\\'){\\n              bopen = true;\\n           //   cout<<k<<\" \"<<endl;\\n             string key = s.substr(index[k]+1,index[k+1]-index[k]-1);\\n           //  cout<<key<<\" \"<<endl;\\n             if(keyvalue[key] == \"\"){\\n                ans+=\"?\";\\n             }else{\\n                ans+=keyvalue[key];\\n             }\\n             \\n             k = k+2;\\n            }else if(s[i] == \\')\\'){\\n              bopen = false;\\n            }else{\\n              if(!bopen)\\n              ans+=s[i];\\n            }\\n          }\\n                   \\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3154883,
                "title": "easy-solution-beats-90-simple-hashmap-o-n-time",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string evaluate(string s, vector<vector<string>>& knowledge) {\\n        unordered_map<string,string>mp;\\n        for(int i=0;i<knowledge.size();i++){\\n            mp[knowledge[i][0]]=knowledge[i][1];\\n        }\\n        string res=\"\";\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\'){\\n                string temp=\"\";\\n                i++;\\n                while(i<s.length() && s[i]!=\\')\\'){\\n                    temp+=s[i++];\\n                }\\n                res+=mp.find(temp)!=mp.end()?mp[temp]:\"?\";\\n            }\\n            else{\\n                res+=s[i];\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string evaluate(string s, vector<vector<string>>& knowledge) {\\n        unordered_map<string,string>mp;\\n        for(int i=0;i<knowledge.size();i++){\\n            mp[knowledge[i][0]]=knowledge[i][1];\\n        }\\n        string res=\"\";\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\'){\\n                string temp=\"\";\\n                i++;\\n                while(i<s.length() && s[i]!=\\')\\'){\\n                    temp+=s[i++];\\n                }\\n                res+=mp.find(temp)!=mp.end()?mp[temp]:\"?\";\\n            }\\n            else{\\n                res+=s[i];\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3139848,
                "title": "stack-dictionary-solution",
                "content": "# Code\\n```\\npublic class Solution {\\n    public string Evaluate(string s, IList<IList<string>> knowledge) {\\n        var stack = new Stack<char>();\\n        for(int i=s.Length-1;i>=0;i--){\\n            stack.Push(s[i]);\\n        }\\n\\n        var dic = new Dictionary<string, string>();\\n        foreach(var k in knowledge){\\n            dic.Add(k[0], k[1]);\\n        }\\n\\n        var res = \"\";\\n        while(stack.Count>0){\\n            var c = stack.Pop();\\n            if(c == \\'(\\'){\\n                var curKey = \"\";\\n                while(stack.Peek() != \\')\\'){\\n                    curKey += stack.Pop();\\n                }\\n                stack.Pop();\\n                \\n                if(dic.Keys.Contains(curKey)){\\n                    res += dic[curKey];\\n                }\\n                else{\\n                    res += \\'?\\';\\n                }\\n            }\\n            else{\\n                res += c;\\n            }\\n        }\\n        return res;\\n    }\\n\\n    \\n    //this is first thought coming into my mind. very simple \\n    //but too low efficient and can\\'t pass the time limit\\n    public string Evaluate1(string s, IList<IList<string>> knowledge){\\n        foreach(var k in knowledge){\\n            k[0] = $\"({k[0]})\";\\n            s = s.Replace(k[0], k[1]);\\n        }\\n        var left = s.IndexOf(\"(\");\\n        while(left >=0){\\n            var right = s.IndexOf(\")\");\\n            s = s.Replace(s[left..(right+1)], \"?\");\\n            left = s.IndexOf(\"(\");\\n        }\\n        return s;   \\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public string Evaluate(string s, IList<IList<string>> knowledge) {\\n        var stack = new Stack<char>();\\n        for(int i=s.Length-1;i>=0;i--){\\n            stack.Push(s[i]);\\n        }\\n\\n        var dic = new Dictionary<string, string>();\\n        foreach(var k in knowledge){\\n            dic.Add(k[0], k[1]);\\n        }\\n\\n        var res = \"\";\\n        while(stack.Count>0){\\n            var c = stack.Pop();\\n            if(c == \\'(\\'){\\n                var curKey = \"\";\\n                while(stack.Peek() != \\')\\'){\\n                    curKey += stack.Pop();\\n                }\\n                stack.Pop();\\n                \\n                if(dic.Keys.Contains(curKey)){\\n                    res += dic[curKey];\\n                }\\n                else{\\n                    res += \\'?\\';\\n                }\\n            }\\n            else{\\n                res += c;\\n            }\\n        }\\n        return res;\\n    }\\n\\n    \\n    //this is first thought coming into my mind. very simple \\n    //but too low efficient and can\\'t pass the time limit\\n    public string Evaluate1(string s, IList<IList<string>> knowledge){\\n        foreach(var k in knowledge){\\n            k[0] = $\"({k[0]})\";\\n            s = s.Replace(k[0], k[1]);\\n        }\\n        var left = s.IndexOf(\"(\");\\n        while(left >=0){\\n            var right = s.IndexOf(\")\");\\n            s = s.Replace(s[left..(right+1)], \"?\");\\n            left = s.IndexOf(\"(\");\\n        }\\n        return s;   \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109776,
                "title": "simple-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string evaluate(string s, vector<vector<string>>& knowledge) {\\n        string ans=\"\";\\n        unordered_map<string,string>m;\\n        for(int i=0;i<knowledge.size();i++)\\n        {\\n            m[knowledge[i][0]]=knowledge[i][1];\\n        }\\n        string x=\"\";\\n        for(int i=0;i<s.length();)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                i++;\\n                while(s[i]!=\\')\\')\\n                {\\n                    x+=s[i];\\n                    i++;\\n                }\\n                if(m.find(x)!=m.end())\\n                {\\n                    ans+=m[x];\\n                }\\n                else\\n                {\\n                    ans+=\\'?\\';\\n                }\\n                x=\"\";\\n\\n            }\\n            else{\\n                ans+=s[i];\\n            }\\n            i++;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string evaluate(string s, vector<vector<string>>& knowledge) {\\n        string ans=\"\";\\n        unordered_map<string,string>m;\\n        for(int i=0;i<knowledge.size();i++)\\n        {\\n            m[knowledge[i][0]]=knowledge[i][1];\\n        }\\n        string x=\"\";\\n        for(int i=0;i<s.length();)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                i++;\\n                while(s[i]!=\\')\\')\\n                {\\n                    x+=s[i];\\n                    i++;\\n                }\\n                if(m.find(x)!=m.end())\\n                {\\n                    ans+=m[x];\\n                }\\n                else\\n                {\\n                    ans+=\\'?\\';\\n                }\\n                x=\"\";\\n\\n            }\\n            else{\\n                ans+=s[i];\\n            }\\n            i++;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2867301,
                "title": "c-382ms-faster-than-95-hashing-easy-understanding-clean-code",
                "content": "\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n\\n    string evaluate(string s, vector<vector<string>>& k) {\\n        \\n        unordered_map<string,string>mpp;\\n\\n        for(auto &it : k) mpp[it[0]] = it[1];\\n\\n        string res = \"\";\\n        \\n        string temp;\\n\\n        bool flag = 0;\\n\\n        for(int i = 0; i < s.length(); ++i)\\n        {\\n           \\n           if(s[i] == \\'(\\') flag = 1;\\n           \\n           else if(s[i] == \\')\\')\\n           {\\n\\n               if(mpp[temp] == \"\") res += \"?\";\\n\\n               else res += mpp[temp];\\n\\n               flag = 0; temp = \"\";\\n           }\\n\\n           else if(flag == 1) temp.push_back(s[i]);\\n           \\n           else res.push_back(s[i]);\\n\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n\\n    string evaluate(string s, vector<vector<string>>& k) {\\n        \\n        unordered_map<string,string>mpp;\\n\\n        for(auto &it : k) mpp[it[0]] = it[1];\\n\\n        string res = \"\";\\n        \\n        string temp;\\n\\n        bool flag = 0;\\n\\n        for(int i = 0; i < s.length(); ++i)\\n        {\\n           \\n           if(s[i] == \\'(\\') flag = 1;\\n           \\n           else if(s[i] == \\')\\')\\n           {\\n\\n               if(mpp[temp] == \"\") res += \"?\";\\n\\n               else res += mpp[temp];\\n\\n               flag = 0; temp = \"\";\\n           }\\n\\n           else if(flag == 1) temp.push_back(s[i]);\\n           \\n           else res.push_back(s[i]);\\n\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2825460,
                "title": "python-regular-expression-solution",
                "content": "Runtime: 2292 ms, beats 56.60%\\nMemory: 52.4 MB, beats 94.04%\\n\\n```python\\nimport re\\n\\nclass Solution:\\n    def evaluate(self, s: str, knowledge: list[list[str]]) -> str:\\n\\t    # Transform the list into a dictonary for quick lookups.\\n        knowledge = {k[0]: k[1] for k in knowledge}\\n\\t\\t\\n\\t\\t# Lookup function taking a Match object returning either the\\n\\t\\t# value associated with a matched key or \\'?\\' if no such key exists.\\n        def lookup(match: re.Match) -> str:\\n            return knowledge.get(match.group(0)[1:-1], \\'?\\')\\n\\t\\t\\n\\t\\t# Regular expression substitition - pattern lazily looks for zero\\n\\t\\t# or more characters between parentheses.\\n        return re.sub(r\"\\\\(.*?\\\\)\", lookup, s)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nimport re\\n\\nclass Solution:\\n    def evaluate(self, s: str, knowledge: list[list[str]]) -> str:\\n\\t    # Transform the list into a dictonary for quick lookups.\\n        knowledge = {k[0]: k[1] for k in knowledge}\\n\\t\\t\\n\\t\\t# Lookup function taking a Match object returning either the\\n\\t\\t# value associated with a matched key or \\'?\\' if no such key exists.\\n        def lookup(match: re.Match) -> str:\\n            return knowledge.get(match.group(0)[1:-1], \\'?\\')\\n\\t\\t\\n\\t\\t# Regular expression substitition - pattern lazily looks for zero\\n\\t\\t# or more characters between parentheses.\\n        return re.sub(r\"\\\\(.*?\\\\)\", lookup, s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2802351,
                "title": "c-solution-unordered-map-linear-time",
                "content": "```\\nclass Solution {\\npublic:\\n    string evaluate(string s, vector<vector<string>>& lis) {\\n        unordered_map<string,string>mp;\\n        for(auto a:lis){\\n            mp[a[0]]=a[1];\\n        }\\n        int l=0,r=0;\\n        string ans=\"\";\\n        while(r<size(s)){\\n            if(s[r]==\\'(\\'){\\n                l=r;\\n                while(s[r]!=\\')\\')r++;\\n                string temp=s.substr(l+1,r-l-1);\\n                if(mp.find(temp)==mp.end())ans+=\"?\";\\n                else ans+=mp[temp];\\n                r++;\\n            }\\n            else ans+=s[r++];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string evaluate(string s, vector<vector<string>>& lis) {\\n        unordered_map<string,string>mp;\\n        for(auto a:lis){\\n            mp[a[0]]=a[1];\\n        }\\n        int l=0,r=0;\\n        string ans=\"\";\\n        while(r<size(s)){\\n            if(s[r]==\\'(\\'){\\n                l=r;\\n                while(s[r]!=\\')\\')r++;\\n                string temp=s.substr(l+1,r-l-1);\\n                if(mp.find(temp)==mp.end())ans+=\"?\";\\n                else ans+=mp[temp];\\n                r++;\\n            }\\n            else ans+=s[r++];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2451538,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    string evaluate(string s, vector<vector<string>>& knowledge) {\\n        unordered_map<string,string> m;\\n        for(auto& i : knowledge){\\n            m[i[0]] = i[1];\\n        }\\n        int l = s.length();\\n        string t = \"\";\\n        for(int i=0; i<l; ++i){\\n            string p = \"\";\\n            if(s[i]==\\'(\\'){\\n                ++i;\\n                while(i<l && s[i] != \\')\\'){\\n                    p += s[i];\\n                    ++i;\\n                }\\n                if(m.find(p) != m.end()){\\n                    t += m[p];\\n                }\\n                else{\\n                    t += \"?\";\\n                }\\n            }\\n            else{\\n                t += s[i];\\n            }\\n        }\\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string evaluate(string s, vector<vector<string>>& knowledge) {\\n        unordered_map<string,string> m;\\n        for(auto& i : knowledge){\\n            m[i[0]] = i[1];\\n        }\\n        int l = s.length();\\n        string t = \"\";\\n        for(int i=0; i<l; ++i){\\n            string p = \"\";\\n            if(s[i]==\\'(\\'){\\n                ++i;\\n                while(i<l && s[i] != \\')\\'){\\n                    p += s[i];\\n                    ++i;\\n                }\\n                if(m.find(p) != m.end()){\\n                    t += m[p];\\n                }\\n                else{\\n                    t += \"?\";\\n                }\\n            }\\n            else{\\n                t += s[i];\\n            }\\n        }\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2350359,
                "title": "c-very-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string evaluate(string s, vector<vector<string>>& grid) {\\n        int n=s.length();\\n        bool b=false;\\n        unordered_map<string,string>m;\\n        \\n        for(int i=0;i<grid.size();i++){\\n            m[grid[i][0]]=grid[i][1];\\n        }\\n        string t=\"\";\\n        string st=\"\";\\n        \\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'(\\'){\\n                b=true;\\n                continue;\\n            }\\n            if(s[i]==\\')\\'){\\n                if(m.find(t)!=m.end()){\\n                    string temp=m[t];\\n                    int sz=t.size();\\n                    while(sz--){\\n                        st.pop_back();\\n                    }\\n                    for(int j=0;j<temp.length();j++){\\n                        st.push_back(temp[j]);\\n                    }\\n                }\\n                else{\\n                    int sz=t.size();\\n                    while(sz--){\\n                        st.pop_back();\\n                    }\\n                    st.push_back(\\'?\\');\\n                }\\n                b=false;t=\"\";\\n                continue;\\n            }\\n            \\n            if(b){\\n                t+=s[i];\\n            }\\n            st+=s[i];\\n        }\\n        \\n        return st;\\n \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string evaluate(string s, vector<vector<string>>& grid) {\\n        int n=s.length();\\n        bool b=false;\\n        unordered_map<string,string>m;\\n        \\n        for(int i=0;i<grid.size();i++){\\n            m[grid[i][0]]=grid[i][1];\\n        }\\n        string t=\"\";\\n        string st=\"\";\\n        \\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'(\\'){\\n                b=true;\\n                continue;\\n            }\\n            if(s[i]==\\')\\'){\\n                if(m.find(t)!=m.end()){\\n                    string temp=m[t];\\n                    int sz=t.size();\\n                    while(sz--){\\n                        st.pop_back();\\n                    }\\n                    for(int j=0;j<temp.length();j++){\\n                        st.push_back(temp[j]);\\n                    }\\n                }\\n                else{\\n                    int sz=t.size();\\n                    while(sz--){\\n                        st.pop_back();\\n                    }\\n                    st.push_back(\\'?\\');\\n                }\\n                b=false;t=\"\";\\n                continue;\\n            }\\n            \\n            if(b){\\n                t+=s[i];\\n            }\\n            st+=s[i];\\n        }\\n        \\n        return st;\\n \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2255260,
                "title": "c-100-faster-hash-map",
                "content": "```\\nclass Solution {\\npublic:\\n    string evaluate(string s, vector<vector<string>>& knowledge) {\\n        \\n\\t\\tunordered_map<string, string> mp;\\n        string ans = \"\";\\n        \\n\\t\\t// Convert the given 2D vector to Hash Map\\n        for(int i=0; i<knowledge.size(); i++)\\n            mp[knowledge[i][0]] = knowledge[i][1];\\n        \\n        \\n        int i=0, n=s.size();\\n        while(i<n){            \\n            if(s[i] == \\'(\\'){\\n                i++;\\n                string tp=\"\";\\n                while(i<n && s[i] != \\')\\'){\\n                    tp+=s[i];\\n                    i++;\\n                }\\n                if(mp.find(tp) == mp.end()) ans+=\"?\";\\n                else ans += mp[tp];\\n            }\\n            else ans+=s[i];\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nUpvote if you find it helpful. \\uD83D\\uDE4C",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string evaluate(string s, vector<vector<string>>& knowledge) {\\n        \\n\\t\\tunordered_map<string, string> mp;\\n        string ans = \"\";\\n        \\n\\t\\t// Convert the given 2D vector to Hash Map\\n        for(int i=0; i<knowledge.size(); i++)\\n            mp[knowledge[i][0]] = knowledge[i][1];\\n        \\n        \\n        int i=0, n=s.size();\\n        while(i<n){            \\n            if(s[i] == \\'(\\'){\\n                i++;\\n                string tp=\"\";\\n                while(i<n && s[i] != \\')\\'){\\n                    tp+=s[i];\\n                    i++;\\n                }\\n                if(mp.find(tp) == mp.end()) ans+=\"?\";\\n                else ans += mp[tp];\\n            }\\n            else ans+=s[i];\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2121813,
                "title": "my-simple-java-solution",
                "content": "```\\nclass Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n        Map<String,String> map=new HashMap<>();\\n      String ans=\"\";\\n        for(int i=0;i<knowledge.size();i++){\\n          map.put(knowledge.get(i).get(0),knowledge.get(i).get(1));\\n        }\\n      for(int i=0;i<s.length();i++){\\n        if(s.charAt(i)==\\'(\\'){\\n          int j=s.indexOf(\")\",i);\\n          String temp=map.getOrDefault(s.substring(i+1,j),\"?\");\\n          ans=ans+temp;\\n          i=j;\\n        }\\n        else{\\n          ans=ans+s.charAt(i);\\n        }\\n      }\\n      return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n        Map<String,String> map=new HashMap<>();\\n      String ans=\"\";\\n        for(int i=0;i<knowledge.size();i++){\\n          map.put(knowledge.get(i).get(0),knowledge.get(i).get(1));\\n        }\\n      for(int i=0;i<s.length();i++){\\n        if(s.charAt(i)==\\'(\\'){\\n          int j=s.indexOf(\")\",i);\\n          String temp=map.getOrDefault(s.substring(i+1,j),\"?\");\\n          ans=ans+temp;\\n          i=j;\\n        }\\n        else{\\n          ans=ans+s.charAt(i);\\n        }\\n      }\\n      return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112659,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n        Map<String, String> knowledgeMap = new HashMap<>();\\n        for(List<String> know : knowledge){\\n            knowledgeMap.put(know.get(0),know.get(1));\\n        }\\n        StringBuilder buildResult = new StringBuilder();\\n        StringBuilder temp = new StringBuilder();\\n        boolean inBracket = false;\\n        for(int i = 0; i<s.length(); i++){\\n            char c = s.charAt(i);\\n            if(c == \\'(\\'){\\n                inBracket = true;\\n            }else if(inBracket){\\n                if(c == \\')\\'){\\n                    String key = temp.toString();\\n                    if(knowledgeMap.containsKey(key)){\\n                        buildResult.append(knowledgeMap.get(key));\\n                    }else{\\n                        buildResult.append(\\'?\\');\\n                    }\\n                    inBracket = false;\\n                    temp = new StringBuilder();\\n                }else{\\n                    temp.append(c);\\n                }\\n            }else{\\n                buildResult.append(c);\\n            }\\n        }\\n        return buildResult.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n        Map<String, String> knowledgeMap = new HashMap<>();\\n        for(List<String> know : knowledge){\\n            knowledgeMap.put(know.get(0),know.get(1));\\n        }\\n        StringBuilder buildResult = new StringBuilder();\\n        StringBuilder temp = new StringBuilder();\\n        boolean inBracket = false;\\n        for(int i = 0; i<s.length(); i++){\\n            char c = s.charAt(i);\\n            if(c == \\'(\\'){\\n                inBracket = true;\\n            }else if(inBracket){\\n                if(c == \\')\\'){\\n                    String key = temp.toString();\\n                    if(knowledgeMap.containsKey(key)){\\n                        buildResult.append(knowledgeMap.get(key));\\n                    }else{\\n                        buildResult.append(\\'?\\');\\n                    }\\n                    inBracket = false;\\n                    temp = new StringBuilder();\\n                }else{\\n                    temp.append(c);\\n                }\\n            }else{\\n                buildResult.append(c);\\n            }\\n        }\\n        return buildResult.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2016745,
                "title": "1807-evaluate-the-bracket-pairs-of-a-string-implementation-simple-solution",
                "content": "This actually pretty simple implementation problem.\\n\\nYou can find my implementation below \\n\\n\\n```\\nclass Solution {\\npublic:\\n    //function to check wheather given key is present or not\\n    string check_key(map<string,string> &data, string key)\\n    {\\n        // if jey is not present return ?\\n        if (data.find(key) == data.end())\\n            return \"?\";\\n        \\n        //present return value for that particular key\\n        return data[key] ;\\n    }\\n    \\n    \\n    string evaluate(string s, vector<vector<string>>& knowledge) \\n    {\\n        //declarations for final answer and map to store data in key value format\\n        string answer;\\n        map<string,string>data;\\n        \\n        // stroing the data\\n        for(int index = 0; index < knowledge.size(); index++)\\n        {\\n            data[knowledge[index][0]] = knowledge[index][1];\\n        }\\n        //process\\n        for(int index = 0; index < s.size(); index++)\\n        {\\n            \\n            // if it is opening parenthesis\\n            // till you find the closing parenthesis \\n            // form a string with all character between open and closing parenthsis\\n            // check wheather string is present in the map or not\\n            // if it is in map return value else return ? and add it final answer\\n            // update the index pointer\\n            \\n            if(s[index] == \\'(\\')\\n            {\\n                int ptr;\\n                string temp = \"\";\\n                for(ptr = index + 1; ptr < s.size(); ptr++)\\n                {\\n                    //if closing parenthesis\\n                    //we are done and update the index with the index of closing pointer\\n                    if(s[ptr] == \\')\\')\\n                    {\\n                        index = ptr;\\n                        break;\\n                    }\\n                    else\\n                    {\\n                        //construction of string with charcters between ( and )\\n                        temp += s[ptr];\\n                    }\\n                }\\n               //check and adding result based on result of check_key function\\n               answer += check_key(data,temp);\\n            }\\n            // if not a opening ( add it to final answer\\n            else\\n            {\\n                answer += s[index];\\n            }\\n        }\\n        //returning the final answer\\n        return answer;\\n    }\\n};\\n```\\n\\nIf you find this to be useful Please upvote :)\\n\\nThanks..!!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    //function to check wheather given key is present or not\\n    string check_key(map<string,string> &data, string key)\\n    {\\n        // if jey is not present return ?\\n        if (data.find(key) == data.end())\\n            return \"?\";\\n        \\n        //present return value for that particular key\\n        return data[key] ;\\n    }\\n    \\n    \\n    string evaluate(string s, vector<vector<string>>& knowledge) \\n    {\\n        //declarations for final answer and map to store data in key value format\\n        string answer;\\n        map<string,string>data;\\n        \\n        // stroing the data\\n        for(int index = 0; index < knowledge.size(); index++)\\n        {\\n            data[knowledge[index][0]] = knowledge[index][1];\\n        }\\n        //process\\n        for(int index = 0; index < s.size(); index++)\\n        {\\n            \\n            // if it is opening parenthesis\\n            // till you find the closing parenthesis \\n            // form a string with all character between open and closing parenthsis\\n            // check wheather string is present in the map or not\\n            // if it is in map return value else return ? and add it final answer\\n            // update the index pointer\\n            \\n            if(s[index] == \\'(\\')\\n            {\\n                int ptr;\\n                string temp = \"\";\\n                for(ptr = index + 1; ptr < s.size(); ptr++)\\n                {\\n                    //if closing parenthesis\\n                    //we are done and update the index with the index of closing pointer\\n                    if(s[ptr] == \\')\\')\\n                    {\\n                        index = ptr;\\n                        break;\\n                    }\\n                    else\\n                    {\\n                        //construction of string with charcters between ( and )\\n                        temp += s[ptr];\\n                    }\\n                }\\n               //check and adding result based on result of check_key function\\n               answer += check_key(data,temp);\\n            }\\n            // if not a opening ( add it to final answer\\n            else\\n            {\\n                answer += s[index];\\n            }\\n        }\\n        //returning the final answer\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1840407,
                "title": "faster-than-98-97-easy-to-understand-commented",
                "content": "**PLEASE UPVOTE IF YOU LIKE THE SOLUTION\\nASK IN COMMENTS IF FACING ANY DOUBTS**\\n\\n```\\nstring evaluate(string s, vector<vector<string>>& k) {\\n        unordered_map<string ,string> mp;\\n        for(int i=0;i<k.size();i++)\\n        {\\n            mp[k[i][0]]=k[i][1]; // INITIALIZING ALL VALUES IN MAP I.E\\n        }\\n        string q,p;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'(\\') // IF \\'(\\' IS ENCOUNTERED\\n            {i++;\\n             p=\"\"; \\n                while(s[i]!=\\')\\')\\n                {\\n                   p+=s[i];\\n                    i++;\\n                  \\n                } \\n          \\n            \\n             \\n                if(mp.find(p)!=mp.end()) //CHECKING IF STRING WITHIN BRACKETS EXISTS IN OUR MAP\\n                {\\n                    q+=mp[p]; // IF YES ADDING TO OUR STRING\\n                }\\n             else\\n                 q+=\"?\"; // IF NO ADDING \\'?\\'\\n            }\\n            else\\n               q+=s[i]; // JUST ADDING STRING IF NOT WITHIN BRACKETS\\n        }return q;\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nstring evaluate(string s, vector<vector<string>>& k) {\\n        unordered_map<string ,string> mp;\\n        for(int i=0;i<k.size();i++)\\n        {\\n            mp[k[i][0]]=k[i][1]; // INITIALIZING ALL VALUES IN MAP I.E\\n        }\\n        string q,p;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'(\\') // IF \\'(\\' IS ENCOUNTERED\\n            {i++;\\n             p=\"\"; \\n                while(s[i]!=\\')\\')\\n                {\\n                   p+=s[i];\\n                    i++;\\n                  \\n                } \\n          \\n            \\n             \\n                if(mp.find(p)!=mp.end()) //CHECKING IF STRING WITHIN BRACKETS EXISTS IN OUR MAP\\n                {\\n                    q+=mp[p]; // IF YES ADDING TO OUR STRING\\n                }\\n             else\\n                 q+=\"?\"; // IF NO ADDING \\'?\\'\\n            }\\n            else\\n               q+=s[i]; // JUST ADDING STRING IF NOT WITHIN BRACKETS\\n        }return q;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1742925,
                "title": "c-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    string evaluate(string s, vector<vector<string>>& knowledge) {\\n        \\n        unordered_map<string,string> keys;\\n        \\n        for(int i=0;i<knowledge.size();i++)\\n        {\\n            keys[knowledge[i][0]]=knowledge[i][1];\\n        }\\n        \\n        string newstring=\"\";\\n        string tempstring=\"\";\\n        bool isParanthesisStarted=false;\\n        \\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                isParanthesisStarted=true;\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                isParanthesisStarted=false;\\n                stringstream ss;\\n                if(keys.find(tempstring)==keys.end())\\n                    ss<<\"?\";\\n                else\\n                    ss<<keys[tempstring];\\n                newstring=newstring.append(ss.str());\\n                tempstring=\"\";\\n            }\\n            else if(!isParanthesisStarted)\\n            {\\n                newstring+=s[i];\\n            }\\n            else if(isParanthesisStarted)\\n            {\\n                tempstring+=s[i];\\n            }\\n            \\n        }\\n        \\n        return newstring;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string evaluate(string s, vector<vector<string>>& knowledge) {\\n        \\n        unordered_map<string,string> keys;\\n        \\n        for(int i=0;i<knowledge.size();i++)\\n        {\\n            keys[knowledge[i][0]]=knowledge[i][1];\\n        }\\n        \\n        string newstring=\"\";\\n        string tempstring=\"\";\\n        bool isParanthesisStarted=false;\\n        \\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                isParanthesisStarted=true;\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                isParanthesisStarted=false;\\n                stringstream ss;\\n                if(keys.find(tempstring)==keys.end())\\n                    ss<<\"?\";\\n                else\\n                    ss<<keys[tempstring];\\n                newstring=newstring.append(ss.str());\\n                tempstring=\"\";\\n            }\\n            else if(!isParanthesisStarted)\\n            {\\n                newstring+=s[i];\\n            }\\n            else if(isParanthesisStarted)\\n            {\\n                tempstring+=s[i];\\n            }\\n            \\n        }\\n        \\n        return newstring;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1723281,
                "title": "python3-evaluate-the-bracket-pairs-of-a-string-memory-distribution-less-than-90",
                "content": "Runtime: 7925 ms\\nMemory Usage: 54.3 MB\\n```\\nclass Solution:\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n\\t# create dictionary of bracket Pairs\\n        make_dict = {}\\n        for i in knowledge:\\n            make_dict[i[0]] = i[1]\\n\\t\\t\\t\\n\\t\\t# initialize start and end of the bracket as 0\\n        start = 0\\n        end = 0\\n\\t\\t\\n\\t\\t# iterate over the string until position of brackets are not found \\n        while start != -1 or end != -1:\\n\\t\\t\\n\\t\\t# Note the index of brackets and get the substring within brackets\\n            start = s.find(\\'(\\')\\n            end = s.find(\\')\\')\\n\\t\\t\\t\\n\\t\\t\\t# if no brackets are found return the string\\n            if start == -1 or end == -1:\\n                return s\\n\\t\\t\\t\\n\\t\\t\\t# get the substring\\t\\n            sub_str = s[start+1:end]\\n\\t\\t\\t\\n\\t\\t\\t# if value for the substring is not found in the knowledge dictionary replace the substring by \\'?\\'\\n\\t\\t\\t# else replace the substring by its corresponding value from the knowledge dictionary\\n            if not make_dict.get(sub_str):\\n                s = s.replace(s[start:end+1], \\'?\\')\\n            else:\\n                s = s.replace(s[start:end+1], make_dict[sub_str])\\n        return s\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n\\t# create dictionary of bracket Pairs\\n        make_dict = {}\\n        for i in knowledge:\\n            make_dict[i[0]] = i[1]\\n\\t\\t\\t\\n\\t\\t# initialize start and end of the bracket as 0\\n        start = 0\\n        end = 0\\n\\t\\t\\n\\t\\t# iterate over the string until position of brackets are not found \\n        while start != -1 or end != -1:\\n\\t\\t\\n\\t\\t# Note the index of brackets and get the substring within brackets\\n            start = s.find(\\'(\\')\\n            end = s.find(\\')\\')\\n\\t\\t\\t\\n\\t\\t\\t# if no brackets are found return the string\\n            if start == -1 or end == -1:\\n                return s\\n\\t\\t\\t\\n\\t\\t\\t# get the substring\\t\\n            sub_str = s[start+1:end]\\n\\t\\t\\t\\n\\t\\t\\t# if value for the substring is not found in the knowledge dictionary replace the substring by \\'?\\'\\n\\t\\t\\t# else replace the substring by its corresponding value from the knowledge dictionary\\n            if not make_dict.get(sub_str):\\n                s = s.replace(s[start:end+1], \\'?\\')\\n            else:\\n                s = s.replace(s[start:end+1], make_dict[sub_str])\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1722609,
                "title": "java-easy-and-fast-solution-using-hashmap",
                "content": "I don\\'t know why is this question rated as medium. It\\'s an easy question, and it has a simple solution.\\n\\n```\\nclass Solution\\n{\\n    public String evaluate(String s, List<List<String>> knowledge)\\n    {\\n        int index=0;\\n        StringBuilder result= new StringBuilder();\\n        HashMap<String,String> map= new HashMap<>();\\n        for(List<String> list: knowledge)\\n            map.put(list.get(0), list.get(1));\\n        for (int i = 0; i < s.length(); i++)\\n        {\\n            if (s.charAt(i)==\\'(\\')\\n            {\\n                result.append(s.substring(index, i));\\n                index=i+1;\\n            }\\n            else if (s.charAt(i)==\\')\\')\\n            {\\n                result.append(map.getOrDefault(s.substring(index, i), \"?\"));\\n                index=i+1;\\n            }\\n        }\\n        result.append(s.substring(index));\\n        return result.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n    public String evaluate(String s, List<List<String>> knowledge)\\n    {\\n        int index=0;\\n        StringBuilder result= new StringBuilder();\\n        HashMap<String,String> map= new HashMap<>();\\n        for(List<String> list: knowledge)\\n            map.put(list.get(0), list.get(1));\\n        for (int i = 0; i < s.length(); i++)\\n        {\\n            if (s.charAt(i)==\\'(\\')\\n            {\\n                result.append(s.substring(index, i));\\n                index=i+1;\\n            }\\n            else if (s.charAt(i)==\\')\\')\\n            {\\n                result.append(map.getOrDefault(s.substring(index, i), \"?\"));\\n                index=i+1;\\n            }\\n        }\\n        result.append(s.substring(index));\\n        return result.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1672933,
                "title": "c-easy-approach-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    string evaluate(string s, vector<vector<string>>& knowledge) {\\n        string a=\"\";\\n        unordered_map<string,string> ans;\\n       for( auto a:knowledge){\\n         ans[a[0]]=a[1];\\n            \\n        }\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\'){\\n                i++;\\n                string word;\\n                while(s[i]!=\\')\\'){\\n                    word+=s[i];\\n                    i++;\\n                }\\n                if(ans.find(word)!=ans.end()){\\n                    a+=ans[word];\\n                }\\n                else{\\n                    a+=\\'?\\';\\n                }\\n            }\\n            else{\\n                a+=s[i];\\n            }\\n        }\\n        return a;\\n    }\\n};\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string evaluate(string s, vector<vector<string>>& knowledge) {\\n        string a=\"\";\\n        unordered_map<string,string> ans;\\n       for( auto a:knowledge){\\n         ans[a[0]]=a[1];\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1626990,
                "title": "java-hashmap",
                "content": "```\\nclass Solution {\\n    public String evaluate(String s, List<List<String>> knowledge){\\n        HashMap<String, String> map = new HashMap<>();\\n        for(int i = 0;i<knowledge.size();i++){\\n            map.put(knowledge.get(i).get(0), knowledge.get(i).get(1));\\n        }\\n        StringBuilder res = new StringBuilder();\\n        int i = 0;\\n        while(i<s.length()){\\n            if(s.charAt(i)==\\'(\\'){\\n                int j = i;\\n                while(j<s.length() && s.charAt(j)!=\\')\\')j++;\\n                if(map.containsKey(s.substring(i+1,j))){\\n                    res.append(map.get(s.substring(i+1,j)));\\n                }\\n                else{\\n                    res.append(\"?\");\\n                }\\n                i = j+1;\\n            }\\n            else{\\n                res.append(s.charAt(i));\\n                i++;\\n            }\\n        }\\n        return res.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String evaluate(String s, List<List<String>> knowledge){\\n        HashMap<String, String> map = new HashMap<>();\\n        for(int i = 0;i<knowledge.size();i++){\\n            map.put(knowledge.get(i).get(0), knowledge.get(i).get(1));\\n        }\\n        StringBuilder res = new StringBuilder();\\n        int i = 0;\\n        while(i<s.length()){\\n            if(s.charAt(i)==\\'(\\'){\\n                int j = i;\\n                while(j<s.length() && s.charAt(j)!=\\')\\')j++;\\n                if(map.containsKey(s.substring(i+1,j))){\\n                    res.append(map.get(s.substring(i+1,j)));\\n                }\\n                else{\\n                    res.append(\"?\");\\n                }\\n                i = j+1;\\n            }\\n            else{\\n                res.append(s.charAt(i));\\n                i++;\\n            }\\n        }\\n        return res.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1587314,
                "title": "easy-java-solution-with-hashmap-with-explanation",
                "content": "```\\nclass Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n        StringBuilder sb = new StringBuilder(s);\\n        HashMap<String,String> hm = new HashMap<String ,String>();\\n        for(List<String> ls : knowledge ){                        //putting all values in list in form of key value pair so that they can be easily accesed through hashmap \\n            hm.put(ls.get(0) ,ls.get(1));\\n        }\\n        int pointone = 0;      // taking two pointers so that we can get the string between two parenthesis\\n        int pointwo =0 ;\\n        int index=0;          // this variable will take care of the difference in made in length after replacing a substring from the string ex  if we replaced string name with a string bigger than its length like ashutosh here the difference between the length of name and ashutosh is 4 character so after adding this value theindex of  next paranthesis will shift to 4 more values but we also removed two paranthesis we need to subtract this also.\\n        while(pointwo<s.length()){          //checking if pointwo does not overflow the index\\n            if(s.charAt(pointone)==\\'(\\'){     // if we found a opening paranthesis move pointer two till we found a closing one .\\n                while(s.charAt(pointwo)!=\\')\\'){\\n                    pointwo++;\\n                }\\n            String query = s.substring(pointone+1 ,pointwo);   // storing the string between those paranthesis as query\\n             if(hm.containsKey(query)){\\n                 sb.replace(pointone-index,pointwo+1-index, hm.get(query));  // if it is present in map then replace it\\n                  index = index+query.length()+2-hm.get(query).length();  //     updating the difference created\\n             }\\n            else{\\n                sb.replace(pointone-index,pointwo+1-index, \"?\");    // if not present just replace it with ?\\n                 index =index+query.length()+2-1;\\n            } \\n                pointwo=pointwo+1;          // now move pointer one and two to one position just after pointer two so we can again search for a query\\n                pointone=pointwo;   \\n            }\\n            else{\\n                pointone++; // if its not paranthesis just increment both pointers\\n                pointwo++;\\n            }\\n        }\\n    return sb.toString(); // return string\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n        StringBuilder sb = new StringBuilder(s);\\n        HashMap<String,String> hm = new HashMap<String ,String>();\\n        for(List<String> ls : knowledge ){                        //putting all values in list in form of key value pair so that they can be easily accesed through hashmap \\n            hm.put(ls.get(0) ,ls.get(1));\\n        }\\n        int pointone = 0;      // taking two pointers so that we can get the string between two parenthesis\\n        int pointwo =0 ;\\n        int index=0;          // this variable will take care of the difference in made in length after replacing a substring from the string ex  if we replaced string name with a string bigger than its length like ashutosh here the difference between the length of name and ashutosh is 4 character so after adding this value theindex of  next paranthesis will shift to 4 more values but we also removed two paranthesis we need to subtract this also.\\n        while(pointwo<s.length()){          //checking if pointwo does not overflow the index\\n            if(s.charAt(pointone)==\\'(\\'){     // if we found a opening paranthesis move pointer two till we found a closing one .\\n                while(s.charAt(pointwo)!=\\')\\'){\\n                    pointwo++;\\n                }\\n            String query = s.substring(pointone+1 ,pointwo);   // storing the string between those paranthesis as query\\n             if(hm.containsKey(query)){\\n                 sb.replace(pointone-index,pointwo+1-index, hm.get(query));  // if it is present in map then replace it\\n                  index = index+query.length()+2-hm.get(query).length();  //     updating the difference created\\n             }\\n            else{\\n                sb.replace(pointone-index,pointwo+1-index, \"?\");    // if not present just replace it with ?\\n                 index =index+query.length()+2-1;\\n            } \\n                pointwo=pointwo+1;          // now move pointer one and two to one position just after pointer two so we can again search for a query\\n                pointone=pointwo;   \\n            }\\n            else{\\n                pointone++; // if its not paranthesis just increment both pointers\\n                pointwo++;\\n            }\\n        }\\n    return sb.toString(); // return string\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1552553,
                "title": "simple-java-o-n-solution",
                "content": "```java\\n// AC: Runtime: 45 ms, faster than 57.45% of Java online submissions for Evaluate the Bracket Pairs of a String.\\n// Memory Usage: 85.8 MB, less than 45.04% of Java online submissions for Evaluate the Bracket Pairs of a String.\\n// .\\n// T:O(n), S:O(n)\\n//\\nclass Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n        HashMap<String, String> record = new HashMap<>();\\n        for (List<String> pair: knowledge) {\\n            record.put(pair.get(0), pair.get(1));\\n        }\\n        StringBuilder ret = new StringBuilder();\\n        StringBuilder temp = new StringBuilder();\\n        boolean sign = false;\\n        for (Character c: s.toCharArray()) {\\n            if (c == \\'(\\') {\\n                sign = true;\\n            } else if (c == \\')\\') {\\n                ret.append(record.getOrDefault(temp.toString(), \"?\"));\\n                sign = false;\\n                temp = new StringBuilder();\\n            } else {\\n                if (sign) {\\n                    temp.append(c);\\n                } else {\\n                    ret.append(c);\\n                }\\n            }\\n        }\\n\\n        return ret.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```java\\n// AC: Runtime: 45 ms, faster than 57.45% of Java online submissions for Evaluate the Bracket Pairs of a String.\\n// Memory Usage: 85.8 MB, less than 45.04% of Java online submissions for Evaluate the Bracket Pairs of a String.\\n// .\\n// T:O(n), S:O(n)\\n//\\nclass Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n        HashMap<String, String> record = new HashMap<>();\\n        for (List<String> pair: knowledge) {\\n            record.put(pair.get(0), pair.get(1));\\n        }\\n        StringBuilder ret = new StringBuilder();\\n        StringBuilder temp = new StringBuilder();\\n        boolean sign = false;\\n        for (Character c: s.toCharArray()) {\\n            if (c == \\'(\\') {\\n                sign = true;\\n            } else if (c == \\')\\') {\\n                ret.append(record.getOrDefault(temp.toString(), \"?\"));\\n                sign = false;\\n                temp = new StringBuilder();\\n            } else {\\n                if (sign) {\\n                    temp.append(c);\\n                } else {\\n                    ret.append(c);\\n                }\\n            }\\n        }\\n\\n        return ret.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1547361,
                "title": "python-hashmap-dictionary-faster-than-96",
                "content": "```\\nclass Solution:\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        hashmap = collections.defaultdict(lambda: \\'?\\')\\n        for pair in knowledge:\\n            hashmap[\\'(\\' + pair[0] + \\')\\'] = pair[1]\\n        res = \\'\\'\\n        cur = \\'\\'\\n        flag = False\\n        for c in s:\\n            if flag:\\n                cur += c\\n                if c == \\')\\':\\n                    res += hashmap[cur]\\n                    cur = \\'\\'\\n                    flag = False\\n            else:\\n                if c == \\'(\\':\\n                    flag = True\\n                    cur += c\\n                else:\\n                    res += c\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        hashmap = collections.defaultdict(lambda: \\'?\\')\\n        for pair in knowledge:\\n            hashmap[\\'(\\' + pair[0] + \\')\\'] = pair[1]\\n        res = \\'\\'\\n        cur = \\'\\'\\n        flag = False\\n        for c in s:\\n            if flag:\\n                cur += c\\n                if c == \\')\\':\\n                    res += hashmap[cur]\\n                    cur = \\'\\'\\n                    flag = False\\n            else:\\n                if c == \\'(\\':\\n                    flag = True\\n                    cur += c\\n                else:\\n                    res += c\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1500767,
                "title": "javascript-intutive-solution",
                "content": "**Please upvote if you like this solution**\\n```\\n/**\\n * @param {string} s\\n * @param {string[][]} knowledge\\n * @return {string}\\n */\\nvar evaluate = function(s, arr) {\\n    let obj = {};\\n    arr.forEach(ele => {\\n        let [key, val] = ele;\\n        obj[key] = val\\n    });\\n    let i=0;\\n    let result = \\'\\'\\n    while(i<s.length){\\n        if(s[i] === \\'(\\'){\\n            i++;\\n            let word = \\'\\';\\n            while(s[i] !== \\')\\'){\\n                word += s[i];\\n                i++\\n            }\\n            result += (obj[word] !== undefined) ? obj[word]: \\'?\\'\\n        }else{\\n            result += s[i]\\n        }\\n        i++\\n    }\\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {string[][]} knowledge\\n * @return {string}\\n */\\nvar evaluate = function(s, arr) {\\n    let obj = {};\\n    arr.forEach(ele => {\\n        let [key, val] = ele;\\n        obj[key] = val\\n    });\\n    let i=0;\\n    let result = \\'\\'\\n    while(i<s.length){\\n        if(s[i] === \\'(\\'){\\n            i++;\\n            let word = \\'\\';\\n            while(s[i] !== \\')\\'){\\n                word += s[i];\\n                i++\\n            }\\n            result += (obj[word] !== undefined) ? obj[word]: \\'?\\'\\n        }else{\\n            result += s[i]\\n        }\\n        i++\\n    }\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1496469,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    string evaluate(string s, vector<vector<string>>& k) {\\n        map<string,string>mp;\\n        for(auto i : k)\\n        {\\n            mp[i[0]] = i[1];\\n        }\\n        int n = s.size();\\n        string ans=\"\";\\n        int f=0; \\n        string u ; int a,b;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(f == 1)\\n            {\\n                if(s[i] == \\')\\')\\n                {\\n                    f=0;\\n                 \\n                    if(mp.find(u) != mp.end())\\n                        ans+=mp[u];\\n                    else\\n                        ans+=\"?\";\\n                    continue;\\n                }\\n                else if(s[i]!=\\')\\'){ u+=s[i];\\n                    continue;}\\n            }\\n            if(f == 0 && s[i] != \\'(\\')\\n            {\\n                ans+=s[i];\\n            }\\n            else if(f == 0 && s[i] == \\'(\\')\\n            {\\n                f=1; \\n                u=\"\";\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string evaluate(string s, vector<vector<string>>& k) {\\n        map<string,string>mp;\\n        for(auto i : k)\\n        {\\n            mp[i[0]] = i[1];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1464416,
                "title": "py-eval-bracket-pairs-regex",
                "content": "```\\nclass Solution:\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        K = dict(knowledge)\\n        S = []\\n        i,j,k = 0, 0, len(s)\\n        for m in re.finditer(\\'(\\\\([a-z]+\\\\))\\', s):\\n            j,k = m.start(), m.end()\\n            S.append(s[i:j])\\n            S.append(K.get(s[j+1:k-1], \\'?\\'))\\n            i = k\\n        S.append(s[i:])\\n        return \\'\\'.join(S)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        K = dict(knowledge)\\n        S = []\\n        i,j,k = 0, 0, len(s)\\n        for m in re.finditer(\\'(\\\\([a-z]+\\\\))\\', s):\\n            j,k = m.start(), m.end()\\n            S.append(s[i:j])\\n            S.append(K.get(s[j+1:k-1], \\'?\\'))\\n            i = k\\n        S.append(s[i:])\\n        return \\'\\'.join(S)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1447792,
                "title": "easy-c-solution-using-map",
                "content": "\\n\\t string evaluate(string s, vector<vector<string>>& knowledge) {\\n\\t\\t\\t\\t\\tmap<string,string>mp;\\n\\t\\t\\t\\t\\tint n=knowledge.size();\\n\\t\\t\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t\\t\\t\\tmp.insert({knowledge[i][0],knowledge[i][1]});  //store the every KeyValuePair \\n\\t\\t\\t\\t\\tstring str=\"\";\\n\\t\\t\\t\\t\\tint n1=s.size();\\n\\t\\t\\t\\t\\tfor(int i=0;i<n1;i++)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(s[i] ==\\'(\\')\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tstring t=\"\";\\n\\t\\t\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\t\\t\\twhile(i<n1 && s[i]!=\\')\\')\\n\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tt+=s[i];\\n\\t\\t\\t\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\tauto find1=mp.find(t);  // find the  value of key\\n\\t\\t\\t\\t\\t\\t\\tif(find1!=mp.end()) // if key(bracket string ) present in replace it with corresponding value\\n\\t\\t\\t\\t\\t\\t\\t\\tstr+=find1->second; \\n\\t\\t\\t\\t\\t\\t\\telse                       // if key(bracket string ) not present in map replace value \"?\"\\n\\t\\t\\t\\t\\t\\t\\t\\tstr+=\"?\";\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\tstr+=s[i];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn str;\\n    }",
                "solutionTags": [],
                "code": "\\n\\t string evaluate(string s, vector<vector<string>>& knowledge) {\\n\\t\\t\\t\\t\\tmap<string,string>mp;\\n\\t\\t\\t\\t\\tint n=knowledge.size();\\n\\t\\t\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t\\t\\t\\tmp.insert({knowledge[i][0],knowledge[i][1]});  //store the every KeyValuePair \\n\\t\\t\\t\\t\\tstring str=\"\";\\n\\t\\t\\t\\t\\tint n1=s.size();\\n\\t\\t\\t\\t\\tfor(int i=0;i<n1;i++)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(s[i] ==\\'(\\')\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tstring t=\"\";\\n\\t\\t\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\t\\t\\twhile(i<n1 && s[i]!=\\')\\')\\n\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tt+=s[i];\\n\\t\\t\\t\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\tauto find1=mp.find(t);  // find the  value of key\\n\\t\\t\\t\\t\\t\\t\\tif(find1!=mp.end()) // if key(bracket string ) present in replace it with corresponding value\\n\\t\\t\\t\\t\\t\\t\\t\\tstr+=find1->second; \\n\\t\\t\\t\\t\\t\\t\\telse                       // if key(bracket string ) not present in map replace value \"?\"\\n\\t\\t\\t\\t\\t\\t\\t\\tstr+=\"?\";\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\tstr+=s[i];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn str;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1358243,
                "title": "python-o-n-concise-solution-w-explanation",
                "content": "Logically, this problem is simple: iterate over the input string \\'s\\' and replace all of the (key)s with their associated values in knowledge if the key exists, else replace them with \\'?\\'.\\n\\nThere are many ways to do this, although I personally find this to be the most straight forward logically (and it is faster than 95+%).\\n1. First, convert the knowledge list into a dictionary so we can quickly check if a key exists in O(1).\\n2. Next, use a while loop to iterate over all of the characters in s. Whenever we find an open parantheses character, we use pythons string.find() to find the matching closing parentheses. This gets use the key. Whenever we find a character that is not part of a key, we simply add it to our res variable since it will always be part of the output.\\n3. Lastly, once we have the key, we simply check if it is in the dictionary \\'d\\'. If it is, we add the associated value to our \\'res\\' variable; if not, we add \\'?\\' to res instead. **Note:** we also increment our iterator \\'i\\' based on the length of the key found, since we just scanned the next \\'key length\\' characters with string.find().\\n```\\nclass Solution:\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        res, i, d, n = \"\", 0, dict(knowledge), len(s)\\n        while i < n:\\n            if s[i] == \\'(\\':\\n                key = s[i+1:s.find(\\')\\',i,n)]        # find the closing \\')\\' and parse the key\\n                res += d[key] if key in d else \\'?\\'  # add the value of this key if it exists, else \\'?\\'\\n                i += len(key)+1                     # adjust our iterator \\'i\\' to account for key length\\n            else: res += s[i]     \\n            i += 1 \\n        return res   \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        res, i, d, n = \"\", 0, dict(knowledge), len(s)\\n        while i < n:\\n            if s[i] == \\'(\\':\\n                key = s[i+1:s.find(\\')\\',i,n)]        # find the closing \\')\\' and parse the key\\n                res += d[key] if key in d else \\'?\\'  # add the value of this key if it exists, else \\'?\\'\\n                i += len(key)+1                     # adjust our iterator \\'i\\' to account for key length\\n            else: res += s[i]     \\n            i += 1 \\n        return res   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1309627,
                "title": "solution-using-dict-and-stack",
                "content": "We first convert the knowledge array to a dictionary for O(1) lookup time, instead of O(n) (n=length of knowledge array). \\nWe also initialize a stack and a flag to let us know whether a character will be added to our final output string, or a stack (logic explained below).\\n\\nNow, we simply go through the string. Whenever we encounter a \\'(\\', we know everything up until the next \\')\\' will be a key. So we turn on our flag so that we know whether to add all those characters to our stack. \\n\\nWhen we reach a \\')\\', we just get the string from the stack and look it up in our dictionary, and add the corresponding value to the output. If no key exists, just add a \\'?\\' to the output. Then turn off the flag and empty the stack.\\n\\nIf the flag is not turned on, we add the characters to the output as normal.\\n\\n```\\nclass Solution:\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        \\n        #create dictionary for lookup of values\\n        mapper = {} \\n        for pair in knowledge:\\n            mapper[pair[0]] = pair[1] \\n        \\n        \\n        output = \"\" \\n        stack = [] \\n        use_stack = False\\n        for i in range(len(s)): \\n            if s[i] == \\'(\\': \\n                use_stack = True\\n            elif s[i] == \\')\\': \\n                key = \\'\\'.join(stack) \\n                if key in mapper:\\n                    output += mapper[\\'\\'.join(stack)]\\n                else:\\n                    output += \\'?\\'\\n                stack = [] \\n                use_stack = False\\n            else:\\n                if use_stack:\\n                    stack.append(s[i]) \\n                else:\\n                    output += s[i] \\n        return output \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        \\n        #create dictionary for lookup of values\\n        mapper = {} \\n        for pair in knowledge:\\n            mapper[pair[0]] = pair[1] \\n        \\n        \\n        output = \"\" \\n        stack = [] \\n        use_stack = False\\n        for i in range(len(s)): \\n            if s[i] == \\'(\\': \\n                use_stack = True\\n            elif s[i] == \\')\\': \\n                key = \\'\\'.join(stack) \\n                if key in mapper:\\n                    output += mapper[\\'\\'.join(stack)]\\n                else:\\n                    output += \\'?\\'\\n                stack = [] \\n                use_stack = False\\n            else:\\n                if use_stack:\\n                    stack.append(s[i]) \\n                else:\\n                    output += s[i] \\n        return output \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1279885,
                "title": "java-solution",
                "content": "\\n\\n    private Map<String, String> buildMap(List<List<String>> knowledge) {\\n        Map<String, String> map = new HashMap<>();\\n        for(List<String> item: knowledge) {\\n            map.put(item.get(0), item.get(1));\\n        }\\n        return map;\\n    }\\n\\t\\n\\tpublic String evaluate(String s, List<List<String>> knowledge) {\\n\\t\\t\\tif (s == null || s.isEmpty()) return s;\\n\\t\\t\\tMap<String, String> map = buildMap(knowledge);\\n\\t\\t\\tStringBuilder res = new StringBuilder();\\n\\t\\t\\tStringBuilder temp = new StringBuilder();\\n\\t\\t\\tboolean inFlag = false;\\n\\t\\t\\tfor(char c: s.toCharArray()) {\\n\\t\\t\\t\\tif (c == \\'(\\') {\\n\\t\\t\\t\\t\\tinFlag = true;\\n\\t\\t\\t\\t} else if (c == \\')\\') {\\n\\t\\t\\t\\t\\tinFlag = false;\\n\\t\\t\\t\\t\\tres.append(map.getOrDefault(temp.toString(), \"?\"));\\n\\t\\t\\t\\t\\ttemp.setLength(0);\\n\\t\\t\\t\\t} else if (inFlag) {\\n\\t\\t\\t\\t\\ttemp.append(c);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tres.append(c);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn res.toString();\\n\\t\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n\\n    private Map<String, String> buildMap(List<List<String>> knowledge) {\\n        Map<String, String> map = new HashMap<>();\\n        for(List<String> item: knowledge) {\\n            map.put(item.get(0), item.get(1));\\n        }\\n        return map;\\n    }\\n\\t\\n\\tpublic String evaluate(String s, List<List<String>> knowledge) {\\n\\t\\t\\tif (s == null || s.isEmpty()) return s;\\n\\t\\t\\tMap<String, String> map = buildMap(knowledge);\\n\\t\\t\\tStringBuilder res = new StringBuilder();\\n\\t\\t\\tStringBuilder temp = new StringBuilder();\\n\\t\\t\\tboolean inFlag = false;\\n\\t\\t\\tfor(char c: s.toCharArray()) {\\n\\t\\t\\t\\tif (c == \\'(\\') {\\n\\t\\t\\t\\t\\tinFlag = true;\\n\\t\\t\\t\\t} else if (c == \\')\\') {\\n\\t\\t\\t\\t\\tinFlag = false;\\n\\t\\t\\t\\t\\tres.append(map.getOrDefault(temp.toString(), \"?\"));\\n\\t\\t\\t\\t\\ttemp.setLength(0);\\n\\t\\t\\t\\t} else if (inFlag) {\\n\\t\\t\\t\\t\\ttemp.append(c);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tres.append(c);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn res.toString();\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1254229,
                "title": "simple-java-solution-30ms-98-faster",
                "content": "**Do upvote, incase it helps you!**\\n```\\nclass Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n        HashMap<String,String> hm = new HashMap<>();\\n        \\n        for(List<String> list:knowledge){\\n            hm.put(list.get(0),list.get(1));\\n        }\\n        int j=0;\\n        StringBuilder sb=new StringBuilder();\\n        int n=s.length();\\n        for(int i=0;i<n;i++){\\n            if(s.charAt(i)==\\'(\\'){\\n                j=i+1;\\n                while(s.charAt(i)!=\\')\\'){\\n                    i++;\\n                }\\n                sb.append(hm.getOrDefault(s.substring(j,i),\"?\"));\\n            }\\n            else\\n               sb.append(s.charAt(i));\\n        }\\n        return sb.toString();\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "class Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n        HashMap<String,String> hm = new HashMap<>();\\n        \\n        for(List<String> list:knowledge){\\n            hm.put(list.get(0),list.get(1));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1237179,
                "title": "javascript-easy-to-understand-faster-then-97",
                "content": "```\\n/**\\n * @param {string} s\\n * @param {string[][]} knowledge\\n * @return {string}\\n */\\nconst evaluate = (s, knowledge) => {\\n    const bracketValsMap = new Map(knowledge);\\n    \\n    let res = \\'\\';\\n    for (let i = 0; i < s.length; i++) {        \\n        \\n        if (s[i] === \\'(\\') {\\n            let keyStr = \\'\\';\\n            while (s[i + 1] !== \\')\\' && i < s.length) {\\n                i++;\\n                keyStr += s[i];\\n            }\\n                        \\n            i+= 1; // move pointer to \\')\\'\\n            res += bracketValsMap.get(keyStr) || \\'?\\';\\n            continue; // skip the \\')\\'\\n        }\\n        \\n\\n        res += s[i];\\n    }\\n    \\n    return res;\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {string[][]} knowledge\\n * @return {string}\\n */\\nconst evaluate = (s, knowledge) => {\\n    const bracketValsMap = new Map(knowledge);\\n    \\n    let res = \\'\\';\\n    for (let i = 0; i < s.length; i++) {        \\n        \\n        if (s[i] === \\'(\\') {\\n            let keyStr = \\'\\';\\n            while (s[i + 1] !== \\')\\' && i < s.length) {\\n                i++;\\n                keyStr += s[i];\\n            }\\n                        \\n            i+= 1; // move pointer to \\')\\'\\n            res += bracketValsMap.get(keyStr) || \\'?\\';\\n            continue; // skip the \\')\\'\\n        }\\n        \\n\\n        res += s[i];\\n    }\\n    \\n    return res;\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1234263,
                "title": "c-using-map-and-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    string evaluate(string s, vector<vector<string>>& knowledge) {\\n        string result = \"\";\\n        queue<string>interim;\\n        for(int i = 0;i<s.length();i++)\\n        {\\n            if(s[i] == \\'(\\')\\n            {   \\n                string temp;\\n                i++;\\n                while(s[i] != \\')\\')\\n                {\\n                    temp+=s[i];\\n                    i++;\\n                }\\n                interim.push(temp);\\n            }\\n\\n        }\\n        map<string,string>pq;\\n        for(int i = 0;i<knowledge.size();i++)\\n        {\\n            string one = knowledge[i][0];\\n            string two = knowledge[i][1];\\n            pq[one] = two;\\n        }\\n        int i = 0;\\n        while(i<s.length())\\n        { \\n          if(s[i] == \\'(\\')\\n          {\\n              string one = interim.front();\\n              interim.pop();\\n              if(pq.find(one) != pq.end())\\n                  result+=pq[one];\\n              else\\n                  result+=\\'?\\';\\n               i = i+one.length()+1;\\n          }\\n            else\\n                result+=s[i];\\n           i = i+1; \\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string evaluate(string s, vector<vector<string>>& knowledge) {\\n        string result = \"\";\\n        queue<string>interim;\\n        for(int i = 0;i<s.length();i++)\\n        {\\n            if(s[i] == \\'(\\')\\n            {   \\n                string temp;\\n                i++;\\n                while(s[i] != \\')\\')\\n                {\\n                    temp+=s[i];\\n                    i++;\\n                }\\n                interim.push(temp);\\n            }\\n\\n        }\\n        map<string,string>pq;\\n        for(int i = 0;i<knowledge.size();i++)\\n        {\\n            string one = knowledge[i][0];\\n            string two = knowledge[i][1];\\n            pq[one] = two;\\n        }\\n        int i = 0;\\n        while(i<s.length())\\n        { \\n          if(s[i] == \\'(\\')\\n          {\\n              string one = interim.front();\\n              interim.pop();\\n              if(pq.find(one) != pq.end())\\n                  result+=pq[one];\\n              else\\n                  result+=\\'?\\';\\n               i = i+one.length()+1;\\n          }\\n            else\\n                result+=s[i];\\n           i = i+1; \\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1234234,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string evaluate(string s, vector<vector<string>>& k) \\n    {\\n        string ans;\\n        unordered_map<string, string>M;\\n        \\n        for(auto p : k)\\n            M[p[0]] = p[1];\\n\\n        for(int i=0; i<s.size(); i++)\\n        {   \\n            if(s[i] == \\'(\\')\\n            {\\n                string key;\\n\\t\\t\\t\\ti++;   // move to next char of opening bracket\\n                while(i< s.size() and s[i] != \\')\\')\\n                    key += s[i++];\\n                \\n                if(M.find(key) != M.end())\\n                    ans += M[key];\\n                else\\n                    ans += \\'?\\';\\n            }\\n            else\\n                ans += s[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string evaluate(string s, vector<vector<string>>& k) \\n    {\\n        string ans;\\n        unordered_map<string, string>M;\\n        \\n        for(auto p : k)\\n            M[p[0]] = p[1];\\n\\n        for(int i=0; i<s.size(); i++)\\n        {   \\n            if(s[i] == \\'(\\')\\n            {\\n                string key;\\n\\t\\t\\t\\ti++;   // move to next char of opening bracket\\n                while(i< s.size() and s[i] != \\')\\')\\n                    key += s[i++];\\n                \\n                if(M.find(key) != M.end())\\n                    ans += M[key];\\n                else\\n                    ans += \\'?\\';\\n            }\\n            else\\n                ans += s[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1229294,
                "title": "java-hashmap",
                "content": "````\\nclass Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n     HashMap<String,String> hm = new HashMap<String,String>();\\n        for(int i=0;i<knowledge.size();i++)\\n        {\\n            hm.put(knowledge.get(i).get(0),knowledge.get(i).get(1));\\n        }\\n        \\n        String ans=\"\",temp=\"\";\\n        int count=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i) ==\\'(\\')\\n            {\\n                count=1;\\n                continue;\\n            }\\n            if(s.charAt(i) ==\\')\\')\\n            {\\n                count=0;\\n                if(hm.containsKey(temp))\\n                {\\n                    ans=ans+hm.get(temp);\\n                }\\n                else\\n                    ans=ans+\"?\";\\n                temp=\"\";\\n                continue;\\n            }\\n            if(count==1)\\n            {\\n                temp=temp+s.charAt(i); \\n            }\\n            else\\n                ans=ans+s.charAt(i);\\n        }\\n        \\n        return ans;\\n}\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n     HashMap<String,String> hm = new HashMap<String,String>();\\n        for(int i=0;i<knowledge.size();i++)\\n        {\\n            hm.put(knowledge.get(i).get(0),knowledge.get(i).get(1));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1191676,
                "title": "79-43-python-no-trie-required",
                "content": "This is a pretty straightforward question. People using Python might be at a huge advantage here.\\n\\n```\\nclass Solution:\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        knowledge = dict(knowledge)\\n        res, start = \\'\\', 0\\n        while start < len(s):\\n            if s[start] != \\'(\\':\\n                res += s[start]\\n            else:\\n                start, key = start + 1, \\'\\'\\n                while s[start] != \\')\\':\\n                    key += s[start]\\n                    start += 1\\n                res += knowledge[key] if key in knowledge else \\'?\\'\\n            start += 1\\n        return res\\n                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        knowledge = dict(knowledge)\\n        res, start = \\'\\', 0\\n        while start < len(s):\\n            if s[start] != \\'(\\':\\n                res += s[start]\\n            else:\\n                start, key = start + 1, \\'\\'\\n                while s[start] != \\')\\':\\n                    key += s[start]\\n                    start += 1\\n                res += knowledge[key] if key in knowledge else \\'?\\'\\n            start += 1\\n        return res\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1189716,
                "title": "python3-simple-solution-using-dictionary",
                "content": "```\\nclass Solution:\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        d= {}\\n        for i in knowledge:\\n            d[i[0]] = i[1]\\n        z = \\'\\'\\n        x = \\'\\'\\n        flag = False\\n        for i in s:\\n            if i == \\'(\\':\\n                flag = True\\n            elif i == \\')\\':\\n                flag = False\\n                z += d.get(x,\\'?\\')\\n                x = \\'\\'\\n            elif flag:\\n                x += i\\n            else:\\n                z += i\\n        return z\\n```\\n**If you like this solution, please upvote for this**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        d= {}\\n        for i in knowledge:\\n            d[i[0]] = i[1]\\n        z = \\'\\'\\n        x = \\'\\'\\n        flag = False\\n        for i in s:\\n            if i == \\'(\\':\\n                flag = True\\n            elif i == \\')\\':\\n                flag = False\\n                z += d.get(x,\\'?\\')\\n                x = \\'\\'\\n            elif flag:\\n                x += i\\n            else:\\n                z += i\\n        return z\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1171379,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        dct = {kn[0]: kn[1] for kn in knowledge}\\n        res = []\\n        temp = None\\n        for index, value in enumerate(s):\\n            if value == \\'(\\':\\n                temp = index\\n            elif value == \\')\\':\\n                res.append(dct.get(s[temp+1:index], \\'?\\'))\\n                temp = None\\n            elif temp is None:\\n                res.append(value)\\n        return \\'\\'.join(res)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        dct = {kn[0]: kn[1] for kn in knowledge}\\n        res = []\\n        temp = None\\n        for index, value in enumerate(s):\\n            if value == \\'(\\':\\n                temp = index\\n            elif value == \\')\\':\\n                res.append(dct.get(s[temp+1:index], \\'?\\'))\\n                temp = None\\n            elif temp is None:\\n                res.append(value)\\n        return \\'\\'.join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1169739,
                "title": "java-map-easy-solution",
                "content": "```\\nclass Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n        String ans=\"\";\\n        Map<String,String> mp=new HashMap<>();\\n        for(int i=0;i<knowledge.size();i++){\\n            List<String> keyval=knowledge.get(i);\\n            mp.put(keyval.get(0),keyval.get(1));\\n        }\\n        boolean of=false;  //opening brace found\\n        boolean cf=false;  //closing brace found\\n        String key=\"\";\\n        for(int i=0;i<s.length();i++){\\n          if(s.charAt(i)==\\'(\\') of=true;\\n          if(s.charAt(i)==\\')\\') cf=true;\\n          \\n          if(of){\\n            key=key+((s.charAt(i)==\\'(\\' || s.charAt(i)==\\')\\')  ? \"\" : s.charAt(i));\\n          }\\n          if(of && cf){\\n            String val=mp.get(key)==null ? \"?\" : mp.get(key);\\n            ans=ans+val;\\n            of=false;\\n            cf=false;\\n            key=\"\";\\n          }\\n          \\n          if(of==false && cf==false){\\n            ans=ans+((s.charAt(i)==\\'(\\' || s.charAt(i)==\\')\\')  ? \"\" : s.charAt(i));\\n          }\\n          \\n        }\\n      return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n        String ans=\"\";\\n        Map<String,String> mp=new HashMap<>();\\n        for(int i=0;i<knowledge.size();i++){\\n            List<String> keyval=knowledge.get(i);\\n            mp.put(keyval.get(0),keyval.get(1));\\n        }\\n        boolean of=false;  //opening brace found\\n        boolean cf=false;  //closing brace found\\n        String key=\"\";\\n        for(int i=0;i<s.length();i++){\\n          if(s.charAt(i)==\\'(\\') of=true;\\n          if(s.charAt(i)==\\')\\') cf=true;\\n          \\n          if(of){\\n            key=key+((s.charAt(i)==\\'(\\' || s.charAt(i)==\\')\\')  ? \"\" : s.charAt(i));\\n          }\\n          if(of && cf){\\n            String val=mp.get(key)==null ? \"?\" : mp.get(key);\\n            ans=ans+val;\\n            of=false;\\n            cf=false;\\n            key=\"\";\\n          }\\n          \\n          if(of==false && cf==false){\\n            ans=ans+((s.charAt(i)==\\'(\\' || s.charAt(i)==\\')\\')  ? \"\" : s.charAt(i));\\n          }\\n          \\n        }\\n      return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1163559,
                "title": "java-using-hash-map-and-string-builder-few-comments-included",
                "content": "```\\nclass Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n        \\n        Map<String, String> map = new HashMap();\\n        \\n        for(List<String> pair: knowledge) {\\n            map.put(pair.get(0), pair.get(1));                            //this line will put key and value in the map. For visualization please try printing the map.\\n        }\\n        \\n        // System.out.print(map);\\n        \\n        StringBuilder sb = new StringBuilder();                   //for building a new String\\n        \\n        char[] ch  = s.toCharArray();\\n        for(int i = 0; i<ch.length;) \\n        {\\n            if(ch[i] == \\'(\\')                                     //if  \\'(\\' is encountered simply append all the elements till \\')\\' in res and check wheather res is present as a key in the map. If present append value associated with res in String Builder.\\n            {\\n                String res = \"\";\\n                int j = i+1;\\n                while(ch[j]!=\\')\\') \\n                {\\n                    res += ch[j];\\n                    j++;\\n                }\\n                i = j+1;\\n\\t\\t\\t\\t\\n                if(map.containsKey(res)) \\n                {\\n                    sb.append(map.get(res));\\n                }\\n                else\\n                    sb.append(\\'?\\');\\n            }\\n            else \\n            {\\n                sb.append(ch[i]);\\n                i++;\\n            }\\n        }\\n        \\n        return sb.toString();              //return string representation of the StringBuilder\\n    }\\n}\\n```\\n\\n# Do upvote if you like the solution.\\n# I Am ready to clarify any doubts associated with the question",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n        \\n        Map<String, String> map = new HashMap();\\n        \\n        for(List<String> pair: knowledge) {\\n            map.put(pair.get(0), pair.get(1));                            //this line will put key and value in the map. For visualization please try printing the map.\\n        }\\n        \\n        // System.out.print(map);\\n        \\n        StringBuilder sb = new StringBuilder();                   //for building a new String\\n        \\n        char[] ch  = s.toCharArray();\\n        for(int i = 0; i<ch.length;) \\n        {\\n            if(ch[i] == \\'(\\')                                     //if  \\'(\\' is encountered simply append all the elements till \\')\\' in res and check wheather res is present as a key in the map. If present append value associated with res in String Builder.\\n            {\\n                String res = \"\";\\n                int j = i+1;\\n                while(ch[j]!=\\')\\') \\n                {\\n                    res += ch[j];\\n                    j++;\\n                }\\n                i = j+1;\\n\\t\\t\\t\\t\\n                if(map.containsKey(res)) \\n                {\\n                    sb.append(map.get(res));\\n                }\\n                else\\n                    sb.append(\\'?\\');\\n            }\\n            else \\n            {\\n                sb.append(ch[i]);\\n                i++;\\n            }\\n        }\\n        \\n        return sb.toString();              //return string representation of the StringBuilder\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1155648,
                "title": "java-simple-solution-hashmap-stringbuilder",
                "content": "Use of hashmap, stringbuilder, and substring to complete this problem\\n\\n```\\nclass Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n        \\n        Map<String, String> map = new HashMap<String, String>();\\n        \\n        for (List<String> sub: knowledge) {\\n            map.put(sub.get(0), sub.get(1));\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        int index = 0;\\n        \\n        while (index < s.length()) {\\n            if (s.charAt(index) == \\'(\\') {\\n                \\n                int temp = index;\\n                \\n                while (s.charAt(index) != \\')\\') index++;\\n                \\n                if (map.containsKey(s.substring(temp+1, index))) sb.append(map.get(s.substring(temp+1, index)));\\n                \\n                else sb.append(\\'?\\');\\n            }\\n            \\n            else {\\n                sb.append(s.charAt(index));\\n            }\\n            \\n            index++;\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n        \\n        Map<String, String> map = new HashMap<String, String>();\\n        \\n        for (List<String> sub: knowledge) {\\n            map.put(sub.get(0), sub.get(1));\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        int index = 0;\\n        \\n        while (index < s.length()) {\\n            if (s.charAt(index) == \\'(\\') {\\n                \\n                int temp = index;\\n                \\n                while (s.charAt(index) != \\')\\') index++;\\n                \\n                if (map.containsKey(s.substring(temp+1, index))) sb.append(map.get(s.substring(temp+1, index)));\\n                \\n                else sb.append(\\'?\\');\\n            }\\n            \\n            else {\\n                sb.append(s.charAt(index));\\n            }\\n            \\n            index++;\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1144633,
                "title": "python-use-while-loop",
                "content": "```\\nclass Solution:\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        d = {}\\n        for key, value in knowledge:\\n            d[key] = value\\n            \\n        ans = \\'\\'\\n        n = len(s)\\n        i = 0\\n        while i < n:\\n            word = \\'\\'\\n            if s[i] == \\'(\\':\\n                while i + 1 < n and s[i+1] != \\')\\':\\n                    word += s[i+1]\\n                    i += 1\\n                i += 1\\n                if word in d:\\n                    ans += d[word]\\n                else:\\n                    ans += \\'?\\'\\n            else:\\n                ans += s[i]\\n            i += 1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        d = {}\\n        for key, value in knowledge:\\n            d[key] = value\\n            \\n        ans = \\'\\'\\n        n = len(s)\\n        i = 0\\n        while i < n:\\n            word = \\'\\'\\n            if s[i] == \\'(\\':\\n                while i + 1 < n and s[i+1] != \\')\\':\\n                    word += s[i+1]\\n                    i += 1\\n                i += 1\\n                if word in d:\\n                    ans += d[word]\\n                else:\\n                    ans += \\'?\\'\\n            else:\\n                ans += s[i]\\n            i += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1138917,
                "title": "java-solution-with-map-usage",
                "content": "class Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n        \\n        if(s == null || s.length() == 0 || s.trim().length() == 0)\\n            return \"\";\\n        \\n        \\n        //Prepare a map of all the values \"from\" and \"to\" from knowledge List.\\n        // Have a return StringBuffer and add character untill we encounter (\\n        // if we encounter (, capture string till we get ), use the string between\\n        // () and get the replacement, if present in map, else use ? and add to return StringBuffer\\n        //Run the same  for rest of the string. \\n        \\n        HashMap<String, String> aux = new HashMap<String, String>();\\n        \\n        for ( List<String> know : knowledge )\\n        {\\n            aux.put(know.get(0), know.get(1));\\n        }\\n        \\n        StringBuffer retStr = new StringBuffer();\\n        \\n        char[] strChars = s.toCharArray();\\n        \\n        for ( int i = 0; i < strChars.length; i++ )\\n        {\\n            if ( strChars[i] != \\'(\\')\\n                retStr.append(strChars[i]);\\n            else \\n            {\\n                int start = i;\\n                StringBuffer key = new StringBuffer();\\n                i++;\\n                while ( strChars[i] != \\')\\' )\\n                {\\n                    key.append( strChars[i] );\\n                    i++;\\n                }\\n                \\n                if( aux.containsKey(key.toString()) )\\n                    retStr.append(aux.get(key.toString()));\\n                else\\n                    retStr.append(\\'?\\');\\n             }\\n        }\\n        \\n        return retStr.toString();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n        \\n        if(s == null || s.length() == 0 || s.trim().length() == 0)\\n            return \"\";\\n        \\n        \\n        //Prepare a map of all the values \"from\" and \"to\" from knowledge List.\\n        // Have a return StringBuffer and add character untill we encounter (\\n        // if we encounter (, capture string till we get ), use the string between\\n        // () and get the replacement, if present in map, else use ? and add to return StringBuffer\\n        //Run the same  for rest of the string. \\n        \\n        HashMap<String, String> aux = new HashMap<String, String>();\\n        \\n        for ( List<String> know : knowledge )\\n        {\\n            aux.put(know.get(0), know.get(1));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1138348,
                "title": "python3-regex-2-liner",
                "content": "Regex makes this problem pretty simple to solve.\\n\\t`\\\\(\\\\w+\\\\)` captures any alphanumeric groups (wrapped between two parentheses) that contains more than 1 character. The lambda function allows us to use the value from capture group and substitute it with what we stored in our dictionary.\\n```\\nclass Solution:\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        d = { f\"({key})\": value for key, value in knowledge }\\n        return re.sub(r\\'\\\\(\\\\w+\\\\)\\', lambda x: d.get(x.group(0), \"?\"), s)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        d = { f\"({key})\": value for key, value in knowledge }\\n        return re.sub(r\\'\\\\(\\\\w+\\\\)\\', lambda x: d.get(x.group(0), \"?\"), s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1138159,
                "title": "kotlin-hashmap-based-linear-pass-solution",
                "content": "This is pretty self explanatory. \\n\\n```\\nfun evaluate(s: String, knowledge: List<List<String>>): String {\\n    // knowledge hashmap,\\n    val hashmap = hashMapOf<String, String>()\\n    knowledge.forEach { hashmap[it.first()] = it.last() }\\n\\n    val finalString = StringBuilder()\\n\\n    val currentString = StringBuilder()\\n    var isBracketKeyProcessing = false\\n\\n    for (c in s.toCharArray()) {\\n        if (c == \\'(\\') {\\n            isBracketKeyProcessing = true\\n            continue\\n        } else if (c == \\')\\') {\\n            isBracketKeyProcessing = false\\n            finalString.append(hashmap[currentString.toString()]?:\"?\")\\n            currentString.clear()\\n        } else {\\n            // there are two things that will happen\\n            if (isBracketKeyProcessing) currentString.append(c)\\n            else finalString.append(c)\\n        }\\n    }\\n\\n    return finalString.toString()\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfun evaluate(s: String, knowledge: List<List<String>>): String {\\n    // knowledge hashmap,\\n    val hashmap = hashMapOf<String, String>()\\n    knowledge.forEach { hashmap[it.first()] = it.last() }\\n\\n    val finalString = StringBuilder()\\n\\n    val currentString = StringBuilder()\\n    var isBracketKeyProcessing = false\\n\\n    for (c in s.toCharArray()) {\\n        if (c == \\'(\\') {\\n            isBracketKeyProcessing = true\\n            continue\\n        } else if (c == \\')\\') {\\n            isBracketKeyProcessing = false\\n            finalString.append(hashmap[currentString.toString()]?:\"?\")\\n            currentString.clear()\\n        } else {\\n            // there are two things that will happen\\n            if (isBracketKeyProcessing) currentString.append(c)\\n            else finalString.append(c)\\n        }\\n    }\\n\\n    return finalString.toString()\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1137523,
                "title": "easy-one-pass-o-n-java-solution-using-hashmap-and-stack",
                "content": "Here is my attempt without using two pointers. \\n- Create HashMap to store the key-value pair from knowledge list\\n- Use Stack to keep track of opening & closing brackets\\n- When stack is not empty, append the current character as key\\n- When stack is empty, append the current character as result\\n- Reset the key whenever \\')\\' is encountered \\n```\\n public String evaluate(String s, List<List<String>> knowledge) {\\n        \\n        Map<String, String> map = new HashMap();\\n        ArrayDeque<Character> stack = new ArrayDeque();\\n        \\n        for(List<String> pair : knowledge){\\n            map.put(pair.get(0), pair.get(1));\\n        }\\n\\n        StringBuilder key = new StringBuilder();\\n        StringBuilder result = new StringBuilder();\\n        \\n        for(int i = 0 ; i < s.length(); i++){\\n            \\n            char curr = s.charAt(i);\\n        \\n            if(curr == \\'(\\'){\\n                stack.push(\\'(\\');\\n                key = new StringBuilder();\\n            }\\n            \\n            else if(curr == \\')\\'){\\n                stack.pop();\\n                result.append(map.getOrDefault(key.toString(), \"?\"));\\n            }\\n            \\n            else if(!stack.isEmpty()){\\n                 key.append(curr);    \\n            }\\n            \\n            else{\\n                result.append(curr);\\n            }\\n        }\\n        \\n        return result.toString();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public String evaluate(String s, List<List<String>> knowledge) {\\n        \\n        Map<String, String> map = new HashMap();\\n        ArrayDeque<Character> stack = new ArrayDeque();\\n        \\n        for(List<String> pair : knowledge){\\n            map.put(pair.get(0), pair.get(1));\\n        }\\n\\n        StringBuilder key = new StringBuilder();\\n        StringBuilder result = new StringBuilder();\\n        \\n        for(int i = 0 ; i < s.length(); i++){\\n            \\n            char curr = s.charAt(i);\\n        \\n            if(curr == \\'(\\'){\\n                stack.push(\\'(\\');\\n                key = new StringBuilder();\\n            }\\n            \\n            else if(curr == \\')\\'){\\n                stack.pop();\\n                result.append(map.getOrDefault(key.toString(), \"?\"));\\n            }\\n            \\n            else if(!stack.isEmpty()){\\n                 key.append(curr);    \\n            }\\n            \\n            else{\\n                result.append(curr);\\n            }\\n        }\\n        \\n        return result.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1137125,
                "title": "java-easy-solution-detailed-explanation",
                "content": "```\\nclass Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n         \\n\\t   //Converting List to HashMap to retrieve values in O(1)\\n        HashMap<String, String> map = new HashMap<>();\\n        for(List<String> list : knowledge)\\n            map.put(list.get(0), list.get(1));\\n        \\n\\t\\t//Creating StringBuilder since it is not synchronized hence faster than StringBuffer\\n        StringBuilder sb = new StringBuilder(s);\\n\\t\\t\\n        //Creating startIndex and endIndex and initializing it to -1, to keep track of the index\\'s of \\'(\\' and \\')\\'\\n\\t\\tint startIndex = -1;\\n        int endIndex  = -1;\\n        \\n\\t\\t//Now, Running a loop and updating the startIndex and endIndex by the index of \\'(\\' and \\')\\' repectively, when found\\n        for(int i = 0; i < sb.length(); i++){\\n            if(sb.charAt(i) == \\'(\\')\\n                startIndex = i;     \\n            else if(sb.charAt(i) == \\')\\')\\n                endIndex = i;\\n            \\n\\t\\t\\t//The moment we find that the value of startIndex and endIndex is not -1\\n\\t\\t\\t//we have to replace the string from startIndex(inclusive) to endIndex(inclusive) of the string\\n\\t\\t\\tif(startIndex != -1 && endIndex != -1){\\n                \\n\\t\\t\\t//Storing the toBeReplaced String in key variable : \\n\\t\\t\\t//From startIndex + 1(because the 1st character would be \\'(\\', and from the 2nd index, the actual string would be found) \\n\\t\\t\\t//to endIndex(substring method return lastIndex - 1, hence automatically \\')\\' is excluded)\\n\\t\\t\\t\\tString key = sb.substring(startIndex + 1, endIndex);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//If the key is found in map, simply replace the string\\n                if(map.containsKey(key)){\\n                    String val = map.get(key);\\n                    sb.replace(startIndex, endIndex + 1, val);\\n                    \\n\\t\\t\\t\\t\\t//Now, after replacing note that the string is updated and the index i no longer points to the next desired index \\n\\t\\t\\t\\t\\t//beacuse length of the inserted string might not be the same as of the replaced string\\n\\t\\t\\t\\t\\t//hence we also need to update our i \\n\\t\\t\\t\\t\\ti = Math.abs(startIndex - val.length()) - 1;\\n                }\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//else if the key is not found, replace the string by \"?\", as per the question\\n                else{\\n                    sb.replace(startIndex, endIndex + 1, \"?\");\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t//Here also, replacement is done, hence update i\\n                    i = Math.abs(startIndex - 1) - 1;\\n                }\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//Set both index\\'s to -1 when the replacement is done\\n                startIndex = -1;\\n                endIndex = -1;\\n            }\\n        }\\n\\t\\t\\n\\t\\t//Finally return\\n        return sb.toString();\\n    }\\n}\\n```\\nDo upvote, if you find it Useful :)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n         \\n\\t   //Converting List to HashMap to retrieve values in O(1)\\n        HashMap<String, String> map = new HashMap<>();\\n        for(List<String> list : knowledge)\\n            map.put(list.get(0), list.get(1));\\n        \\n\\t\\t//Creating StringBuilder since it is not synchronized hence faster than StringBuffer\\n        StringBuilder sb = new StringBuilder(s);\\n\\t\\t\\n        //Creating startIndex and endIndex and initializing it to -1, to keep track of the index\\'s of \\'(\\' and \\')\\'\\n\\t\\tint startIndex = -1;\\n        int endIndex  = -1;\\n        \\n\\t\\t//Now, Running a loop and updating the startIndex and endIndex by the index of \\'(\\' and \\')\\' repectively, when found\\n        for(int i = 0; i < sb.length(); i++){\\n            if(sb.charAt(i) == \\'(\\')\\n                startIndex = i;     \\n            else if(sb.charAt(i) == \\')\\')\\n                endIndex = i;\\n            \\n\\t\\t\\t//The moment we find that the value of startIndex and endIndex is not -1\\n\\t\\t\\t//we have to replace the string from startIndex(inclusive) to endIndex(inclusive) of the string\\n\\t\\t\\tif(startIndex != -1 && endIndex != -1){\\n                \\n\\t\\t\\t//Storing the toBeReplaced String in key variable : \\n\\t\\t\\t//From startIndex + 1(because the 1st character would be \\'(\\', and from the 2nd index, the actual string would be found) \\n\\t\\t\\t//to endIndex(substring method return lastIndex - 1, hence automatically \\')\\' is excluded)\\n\\t\\t\\t\\tString key = sb.substring(startIndex + 1, endIndex);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//If the key is found in map, simply replace the string\\n                if(map.containsKey(key)){\\n                    String val = map.get(key);\\n                    sb.replace(startIndex, endIndex + 1, val);\\n                    \\n\\t\\t\\t\\t\\t//Now, after replacing note that the string is updated and the index i no longer points to the next desired index \\n\\t\\t\\t\\t\\t//beacuse length of the inserted string might not be the same as of the replaced string\\n\\t\\t\\t\\t\\t//hence we also need to update our i \\n\\t\\t\\t\\t\\ti = Math.abs(startIndex - val.length()) - 1;\\n                }\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//else if the key is not found, replace the string by \"?\", as per the question\\n                else{\\n                    sb.replace(startIndex, endIndex + 1, \"?\");\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t//Here also, replacement is done, hence update i\\n                    i = Math.abs(startIndex - 1) - 1;\\n                }\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//Set both index\\'s to -1 when the replacement is done\\n                startIndex = -1;\\n                endIndex = -1;\\n            }\\n        }\\n\\t\\t\\n\\t\\t//Finally return\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1132167,
                "title": "python-faster-than-100-and-space-100",
                "content": "\\n```\\nclass Solution:\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        dic = {}\\n        \\n        for key,value in knowledge:\\n            dic[key] = value\\n        \\n        listOfBracketsWithString = re.findall(\\'\\\\(.*?\\\\)\\',s)\\n        \\n        for i in listOfBracketsWithString:\\n            i = i.strip(\"(\").strip(\")\")\\n            if i in dic:\\n                s = s.replace(\"(\"+i+\")\",dic[i])\\n            else:\\n                s = s.replace(\"(\"+i+\")\",\"?\")\\n        \\n        return s",
                "solutionTags": [],
                "code": "class Solution:\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        dic = {}",
                "codeTag": "Java"
            },
            {
                "id": 1132116,
                "title": "rust-two-pointer-hashmap",
                "content": "Fellow Rustecean, please vote up or suggest better code. Thanks!\\n```\\nuse std::collections::HashMap;\\n#[allow(dead_code)]\\nimpl Solution {\\n    pub fn evaluate(ss: String, knowledge: Vec<Vec<String>>) -> String {\\n        let mut map: HashMap<String, String> = HashMap::new();\\n        for row in knowledge {\\n            map.insert(row[0].clone(), row[1].clone());\\n        }\\n        let s: Vec<char> = ss.chars().collect();\\n        let mut res: Vec<String> = vec![];\\n        let mut i = 0;\\n        let n = s.len();\\n        while i < n {\\n            while i < n && s[i] != \\'(\\' {\\n                res.push(s[i].to_string());\\n                i += 1;\\n            }\\n            if i == n {\\n                break;\\n            }\\n            let mut j = i + 1;\\n            while j < n && s[j] != \\')\\' {\\n                j += 1;\\n            }\\n            let key = &ss[i + 1..j];\\n            match map.get(key) {\\n                Some(value) => res.push((*value).clone()),\\n                None => res.push(\"?\".to_string()),\\n            }\\n            i = j + 1\\n        }\\n        res.join(\"\")\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "Fellow Rustecean, please vote up or suggest better code. Thanks!\\n```\\nuse std::collections::HashMap;\\n#[allow(dead_code)]\\nimpl Solution {\\n    pub fn evaluate(ss: String, knowledge: Vec<Vec<String>>) -> String {\\n        let mut map: HashMap<String, String> = HashMap::new();\\n        for row in knowledge {\\n            map.insert(row[0].clone(), row[1].clone());\\n        }\\n        let s: Vec<char> = ss.chars().collect();\\n        let mut res: Vec<String> = vec![];\\n        let mut i = 0;\\n        let n = s.len();\\n        while i < n {\\n            while i < n && s[i] != \\'(\\' {\\n                res.push(s[i].to_string());\\n                i += 1;\\n            }\\n            if i == n {\\n                break;\\n            }\\n            let mut j = i + 1;\\n            while j < n && s[j] != \\')\\' {\\n                j += 1;\\n            }\\n            let key = &ss[i + 1..j];\\n            match map.get(key) {\\n                Some(value) => res.push((*value).clone()),\\n                None => res.push(\"?\".to_string()),\\n            }\\n            i = j + 1\\n        }\\n        res.join(\"\")\\n    }\\n}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1131945,
                "title": "python-one-liner",
                "content": "Here\\'s an **one-liner** solution:\\n\\n```python\\nclass Solution:\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        return s.replace(\\'(\\',\\'{d[\\').replace(\\')\\',\\']}\\').format(d=defaultdict(lambda:\\'?\\',knowledge))\\n```\\n\\nIt\\'s based on the following facts.\\n\\n**Fact 1.** String can be formatted using dictionary:\\n\\n```python\\nd = {\\'name\\': \\'bob\\', \\'age\\': \\'two\\'}\\nres = \\'{d[name]}is{d[age]}yearsold\\'.format(d=d)\\n# res = \"bobistwoyearsold\"\\n```\\n\\n**Fact 2.** Dictionary can be initialized using iterables:\\n\\n```python\\nknowledges = [[\\'name\\', \\'bob\\'], [\\'age\\', \\'two\\']]\\nd = dict(knowledges)\\nres = \\'{d[name]}is{d[age]}yearsold\\'.format(d=d)\\n# res = \"bobistwoyearsold\"\\n```\\n\\n**Fact 3.**  ```collections.defaultdict``` inherits methods from ```dict```:\\n\\n```python\\nknowledges = [[\\'name\\', \\'bob\\'], [\\'age\\', \\'two\\']]\\nd = collections.defaultdict(lambda: \\'?\\', knowledges)\\nres = \\'{d[name]}is{d[age]}years{d[a]}old\\'.format(d=d)\\n# res = \"bobistwoyears?old\"\\n```\\n\\nFor the input string ```\"(name)is(age)yearsold\"```, we just need to replace the parentheses (e.g. ```(name)```) by braces (e.g. ```{d[name]}```) to apply the above facts. This gives the one-liner at the begining.\\n\\nThat\\'s it. Hope you found it interesting.",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        return s.replace(\\'(\\',\\'{d[\\').replace(\\')\\',\\']}\\').format(d=defaultdict(lambda:\\'?\\',knowledge))\\n```\n```python\\nd = {\\'name\\': \\'bob\\', \\'age\\': \\'two\\'}\\nres = \\'{d[name]}is{d[age]}yearsold\\'.format(d=d)\\n# res = \"bobistwoyearsold\"\\n```\n```python\\nknowledges = [[\\'name\\', \\'bob\\'], [\\'age\\', \\'two\\']]\\nd = dict(knowledges)\\nres = \\'{d[name]}is{d[age]}yearsold\\'.format(d=d)\\n# res = \"bobistwoyearsold\"\\n```\n```collections.defaultdict```\n```dict```\n```python\\nknowledges = [[\\'name\\', \\'bob\\'], [\\'age\\', \\'two\\']]\\nd = collections.defaultdict(lambda: \\'?\\', knowledges)\\nres = \\'{d[name]}is{d[age]}years{d[a]}old\\'.format(d=d)\\n# res = \"bobistwoyears?old\"\\n```\n```\"(name)is(age)yearsold\"```\n```(name)```\n```{d[name]}```",
                "codeTag": "Java"
            },
            {
                "id": 1131242,
                "title": "easy-c-solution-using-map-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    string evaluate(string s, vector<vector<string>>& know) {\\n        string ans=\"\";\\n        map<string,string> mp;\\n        for(int i=0; i<know.size(); i++) mp[know[i][0]]=know[i][1];  // store all the keys in map\\n        for(int i=0; i<s.size(); i++) {\\n             if(s[i]==\\'(\\') {         // encountering a start of key \\n                 string key=\"\";\\n                 i++;\\n                 while(i<s.size() && s[i]!=\\')\\') {\\n                     key+=s[i];                    \\n                     i++;\\n                 }\\n                 if(mp.count(key)) ans+=mp[key];   // if key is present in map concat that corresponding value of key to ans\\n                 else ans+=\"?\";    // if key is not present concat \"?\"\\n             }else {\\n                 ans+=s[i];    // if you dont encounter a key just concat the ans\\n             } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string evaluate(string s, vector<vector<string>>& know) {\\n        string ans=\"\";\\n        map<string,string> mp;\\n        for(int i=0; i<know.size(); i++) mp[know[i][0]]=know[i][1];  // store all the keys in map\\n        for(int i=0; i<s.size(); i++) {\\n             if(s[i]==\\'(\\') {         // encountering a start of key \\n                 string key=\"\";\\n                 i++;\\n                 while(i<s.size() && s[i]!=\\')\\') {\\n                     key+=s[i];                    \\n                     i++;\\n                 }\\n                 if(mp.count(key)) ans+=mp[key];   // if key is present in map concat that corresponding value of key to ans\\n                 else ans+=\"?\";    // if key is not present concat \"?\"\\n             }else {\\n                 ans+=s[i];    // if you dont encounter a key just concat the ans\\n             } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1131062,
                "title": "c-simple-and-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string evaluate(string s, vector<vector<string>>& knowledge) {\\n        unordered_map<string,string> um;\\n        for(auto x: knowledge){\\n            um[x[0]]=x[1];\\n        }\\n        string ans;\\n        bool bracket=false;\\n        string curr;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\'){\\n                bracket=true;\\n                curr=\"\";\\n                continue;\\n            }\\n            else if(s[i]==\\')\\'){\\n                bracket=false;  \\n                if(um.find(curr)==um.end())\\n                    ans+=\"?\";\\n                else\\n                    ans+=um[curr];\\n                continue;\\n            }\\n            if(!bracket){\\n                ans.push_back(s[i]);\\n            }\\n            else{\\n                curr.push_back(s[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string evaluate(string s, vector<vector<string>>& knowledge) {\\n        unordered_map<string,string> um;\\n        for(auto x: knowledge){\\n            um[x[0]]=x[1];\\n        }\\n        string ans;\\n        bool bracket=false;\\n        string curr;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\'){\\n                bracket=true;\\n                curr=\"\";\\n                continue;\\n            }\\n            else if(s[i]==\\')\\'){\\n                bracket=false;  \\n                if(um.find(curr)==um.end())\\n                    ans+=\"?\";\\n                else\\n                    ans+=um[curr];\\n                continue;\\n            }\\n            if(!bracket){\\n                ans.push_back(s[i]);\\n            }\\n            else{\\n                curr.push_back(s[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1131059,
                "title": "java-100-faster-using-hash-map",
                "content": "```\\nclass Solution {\\n    public String evaluate(String str, List<List<String>> list) {\\n        HashMap<String, String> map= new HashMap<>();\\n        \\n        for(int i=0; i<list.size() ;i++){\\n            String s1= list.get(i).get(0);\\n            String s2= list.get(i).get(1);\\n            map.put(s1,s2);\\n        }\\n        String ans = \"\";\\n        for(int i=0; i < str.length() ; i++){\\n            if(str.charAt(i) == \\'(\\'){\\n                int j=i+1;\\n                String ts= \"\";\\n                while(j < str.length() && str.charAt(j) != \\')\\'){\\n                    ts+= str.charAt(j);\\n                    j++;\\n                }\\n                i=j;\\n                if(map.containsKey(ts)){\\n                    ans+= map.get(ts);\\n                }else{\\n                    ans+= \"?\";\\n                }\\n                \\n            }else{\\n                ans+= str.charAt(i);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String evaluate(String str, List<List<String>> list) {\\n        HashMap<String, String> map= new HashMap<>();\\n        \\n        for(int i=0; i<list.size() ;i++){\\n            String s1= list.get(i).get(0);\\n            String s2= list.get(i).get(1);\\n            map.put(s1,s2);\\n        }\\n        String ans = \"\";\\n        for(int i=0; i < str.length() ; i++){\\n            if(str.charAt(i) == \\'(\\'){\\n                int j=i+1;\\n                String ts= \"\";\\n                while(j < str.length() && str.charAt(j) != \\')\\'){\\n                    ts+= str.charAt(j);\\n                    j++;\\n                }\\n                i=j;\\n                if(map.containsKey(ts)){\\n                    ans+= map.get(ts);\\n                }else{\\n                    ans+= \"?\";\\n                }\\n                \\n            }else{\\n                ans+= str.charAt(i);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1130951,
                "title": "javascript-solution-with-regex-272-ms",
                "content": "```\\nvar evaluate = function(s, knowledge) {\\n    const map = new Map();\\n    \\n    for (const [key, val] of knowledge) {\\n        map.set(key, val);\\n    }\\n    \\n    return s.replace(/\\\\((\\\\w+)\\\\)/g, function (match, contents) {\\n        return map.get(contents) || \"?\";\\n    });\\n};\\n```\\nWithout regex it can look like this (248 ms):\\n```\\nvar evaluate = function(s, knowledge) {\\n    const map = new Map();\\n    let result = \"\";\\n    \\n    for (const [key, val] of knowledge) {\\n        map.set(key, val);\\n    }\\n    \\n    for (let i = 0; i < s.length; ++i) {\\n        if (s[i] === \"(\") {\\n            for (let j = i + 1; j < s.length; ++j) {\\n                if (s[j] === \")\") {\\n                    result += map.get(s.substring(i + 1, j)) || \"?\";\\n                    i = j;\\n                    break;\\n                }\\n            }\\n        } else result += s[i];\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar evaluate = function(s, knowledge) {\\n    const map = new Map();\\n    \\n    for (const [key, val] of knowledge) {\\n        map.set(key, val);\\n    }\\n    \\n    return s.replace(/\\\\((\\\\w+)\\\\)/g, function (match, contents) {\\n        return map.get(contents) || \"?\";\\n    });\\n};\\n```\n```\\nvar evaluate = function(s, knowledge) {\\n    const map = new Map();\\n    let result = \"\";\\n    \\n    for (const [key, val] of knowledge) {\\n        map.set(key, val);\\n    }\\n    \\n    for (let i = 0; i < s.length; ++i) {\\n        if (s[i] === \"(\") {\\n            for (let j = i + 1; j < s.length; ++j) {\\n                if (s[j] === \")\") {\\n                    result += map.get(s.substring(i + 1, j)) || \"?\";\\n                    i = j;\\n                    break;\\n                }\\n            }\\n        } else result += s[i];\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1130827,
                "title": "javascript-straight-forward-beginner-approach",
                "content": "```\\nvar evaluate = function(s, knowledge) {\\n    \\n    let hash={}\\n    for(let i =0;i<knowledge.length;i++){\\n        let [key,val]=knowledge[i]    \\n           hash[key]=val \\n    }\\n    \\n    let final=\"\"\\n    \\n    for(let i =0;i<s.length;i++){\\n        \\n        if(s[i]==\\'(\\'){\\n            let str=\\'\\'\\n            while(s[i]!==\\')\\'){\\n                i++\\n                if(s[i]==\\')\\'){\\n                    break\\n                }\\n                str+=s[i]\\n                \\n            }\\n            \\n            if(hash[str]){\\n                final+=hash[str]\\n            }\\n            else{\\n                final+=\\'?\\'\\n            }\\n        }\\n        \\n        else{\\n        final+=s[i]\\n            \\n        }\\n    }\\n\\n    return final\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar evaluate = function(s, knowledge) {\\n    \\n    let hash={}\\n    for(let i =0;i<knowledge.length;i++){\\n        let [key,val]=knowledge[i]    \\n           hash[key]=val \\n    }\\n    \\n    let final=\"\"\\n    \\n    for(let i =0;i<s.length;i++){\\n        \\n        if(s[i]==\\'(\\'){\\n            let str=\\'\\'\\n            while(s[i]!==\\')\\'){\\n                i++\\n                if(s[i]==\\')\\'){\\n                    break\\n                }\\n                str+=s[i]\\n                \\n            }\\n            \\n            if(hash[str]){\\n                final+=hash[str]\\n            }\\n            else{\\n                final+=\\'?\\'\\n            }\\n        }\\n        \\n        else{\\n        final+=s[i]\\n            \\n        }\\n    }\\n\\n    return final\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1130768,
                "title": "python3-sweep",
                "content": "\\n```\\nclass Solution:\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        mp = dict(knowledge)\\n        i = 0 \\n        ans = []\\n        while i < len(s): \\n            if s[i] == \"(\": \\n                ii = i \\n                while ii < len(s) and s[ii] != \")\": \\n                    ii += 1\\n                ans.append(mp.get(s[i+1:ii], \"?\"))\\n                i = ii+1\\n            else: \\n                ans.append(s[i])\\n                i += 1\\n        return \"\".join(ans)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        mp = dict(knowledge)\\n        i = 0 \\n        ans = []\\n        while i < len(s): \\n            if s[i] == \"(\": \\n                ii = i \\n                while ii < len(s) and s[ii] != \")\": \\n                    ii += 1\\n                ans.append(mp.get(s[i+1:ii], \"?\"))\\n                i = ii+1\\n            else: \\n                ans.append(s[i])\\n                i += 1\\n        return \"\".join(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1130726,
                "title": "java-o-n-simple-readable-solution-with-comments-beats-100",
                "content": "The solution can be summarized in three steps.\\n1. Until you find an opening bracket, append each character to the output. \\n2. Once you find an opening bracket, find the next closing bracket.\\n3. Determine the value that will replace the substring and append it to the output. \\n\\n```\\nclass Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n        HashMap<String, String> mappings = getMappings(knowledge);\\n        StringBuilder result = new StringBuilder();\\n        int openingBracketIndex = 0, closingBracketIndex = 0;\\n        int i = 0;\\n        while (i < s.length()) {\\n            char current = s.charAt(i);\\n            if (current != \\'(\\') {\\n                result.append(current);\\n            } else {\\n                openingBracketIndex = i;\\n                \\n                // Find the corresponding closing bracket.\\n                while (s.charAt(i) != \\')\\') {\\n                    i++;\\n                }\\n                closingBracketIndex = i;\\n\\n                // Determine the substring between the opening and closing brackets.\\n                String substring = s.substring(openingBracketIndex + 1, closingBracketIndex);\\n                \\n                if (mappings.containsKey(substring)) {\\n                    result.append(mappings.get(substring));\\n                } else {\\n                    result.append(\\'?\\');\\n                }\\n            }\\n            i++;\\n        }\\n        return result.toString();\\n    }\\n    \\n    private static HashMap<String, String> getMappings(List<List<String>> knowledge) {\\n        HashMap<String, String> mappings = new HashMap<>();\\n        for (List<String> input: knowledge) {\\n            String key = input.get(0);\\n            String value = input.get(1);\\n            mappings.put(key, value);\\n        }\\n        return mappings;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n        HashMap<String, String> mappings = getMappings(knowledge);\\n        StringBuilder result = new StringBuilder();\\n        int openingBracketIndex = 0, closingBracketIndex = 0;\\n        int i = 0;\\n        while (i < s.length()) {\\n            char current = s.charAt(i);\\n            if (current != \\'(\\') {\\n                result.append(current);\\n            } else {\\n                openingBracketIndex = i;\\n                \\n                // Find the corresponding closing bracket.\\n                while (s.charAt(i) != \\')\\') {\\n                    i++;\\n                }\\n                closingBracketIndex = i;\\n\\n                // Determine the substring between the opening and closing brackets.\\n                String substring = s.substring(openingBracketIndex + 1, closingBracketIndex);\\n                \\n                if (mappings.containsKey(substring)) {\\n                    result.append(mappings.get(substring));\\n                } else {\\n                    result.append(\\'?\\');\\n                }\\n            }\\n            i++;\\n        }\\n        return result.toString();\\n    }\\n    \\n    private static HashMap<String, String> getMappings(List<List<String>> knowledge) {\\n        HashMap<String, String> mappings = new HashMap<>();\\n        for (List<String> input: knowledge) {\\n            String key = input.get(0);\\n            String value = input.get(1);\\n            mappings.put(key, value);\\n        }\\n        return mappings;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1130664,
                "title": "ruby-regular-expression",
                "content": "Use `gsub` with block to replace all substrings wrapped in parentheses.\\n\\n```ruby\\ndef evaluate(s, knowledge)\\n  knowledge = knowledge.to_h\\n  knowledge.default = \\'?\\'\\n  s.gsub(/\\\\([^)]+\\\\)/) { |k| knowledge[k[1..-2]] }\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef evaluate(s, knowledge)\\n  knowledge = knowledge.to_h\\n  knowledge.default = \\'?\\'\\n  s.gsub(/\\\\([^)]+\\\\)/) { |k| knowledge[k[1..-2]] }\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1130609,
                "title": "java-solution-using-flag-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n        HashMap<String, String> map = new HashMap<>();\\n       StringBuilder result = new StringBuilder();\\n        for(List<String> list : knowledge){\\n            map.put(list.get(0), list.get(1));\\n        }\\n        \\n        int keyA = 0;\\n        StringBuilder key = new StringBuilder();\\n        \\n        for(int i= 0; i<s.length(); i++){\\n            if(keyA == 1 && s.charAt(i) != \\')\\'){\\n                key.append(s.charAt(i));\\n              \\n            }\\n            if(s.charAt(i) == \\'(\\'){\\n                keyA = 1; \\n                continue;\\n            } else if(s.charAt(i) == \\')\\') {\\n                keyA = 0;\\n                  System.out.println(key);\\n\\n                if(map.containsKey(key.toString())){\\n                    result.append(map.get(key.toString()));\\n                }else {\\n                     result.append(\"?\"); \\n                }\\n                \\n                key = new StringBuilder();\\n                \\n                }else if(keyA != 1){\\n                result.append(s.charAt(i)); \\n            }\\n           \\n        }\\n        return result.toString();\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n        HashMap<String, String> map = new HashMap<>();\\n       StringBuilder result = new StringBuilder();\\n        for(List<String> list : knowledge){\\n            map.put(list.get(0), list.get(1));\\n        }\\n        \\n        int keyA = 0;\\n        StringBuilder key = new StringBuilder();\\n        \\n        for(int i= 0; i<s.length(); i++){\\n            if(keyA == 1 && s.charAt(i) != \\')\\'){\\n                key.append(s.charAt(i));\\n              \\n            }\\n            if(s.charAt(i) == \\'(\\'){\\n                keyA = 1; \\n                continue;\\n            } else if(s.charAt(i) == \\')\\') {\\n                keyA = 0;\\n                  System.out.println(key);\\n\\n                if(map.containsKey(key.toString())){\\n                    result.append(map.get(key.toString()));\\n                }else {\\n                     result.append(\"?\"); \\n                }\\n                \\n                key = new StringBuilder();\\n                \\n                }else if(keyA != 1){\\n                result.append(s.charAt(i)); \\n            }\\n           \\n        }\\n        return result.toString();\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1130496,
                "title": "kt-js-py3-cpp-map-solutions",
                "content": "*Kotlin*\\n```\\nclass Solution {\\n    fun evaluate(s: String, A: List<List<String>>): String {\\n        var ans = mutableListOf<String>()\\n        var keyword = false\\n        var word = mutableListOf<Char>()\\n        var m = mutableMapOf<String, String>()\\n        for (pair in A) {\\n            var (key, value) = pair\\n            m[key] = value\\n        }\\n        for (c in s) {\\n            if (c == \\'(\\') {\\n                word.clear()\\n                keyword = true\\n            }\\n            else if (c == \\')\\') {\\n                var key = word.joinToString(\"\")\\n                ans.add(m[key] ?: \"?\")\\n                keyword = false\\n            } else {\\n                if (keyword) word.add(c) else ans.add(c.toString())\\n            }\\n        }\\n        return ans.joinToString(\"\")\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet evaluate = (s, A, m = new Map(), keyword = false, word = [], ans = []) => {\\n    for (let [key, val] of A)\\n        m.set(key, val);\\n    for (let c of s) {\\n        if (c == \\'(\\') word = [], keyword = true;\\n        if (c == \\')\\') ans.push(m.get(word.join(\\'\\')) || \\'?\\'), keyword = false;\\n        if (97 <= c.charCodeAt(0)) {\\n            if (keyword) word.push(c); else ans.push(c);\\n        }\\n    }\\n    return ans.join(\\'\\');\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def evaluate(self, s: str, A: List[List[str]], keyword = False) -> str:\\n        ans = []\\n        m = {}\\n        for key, val in A:\\n            m[key] = val\\n        word = []\\n        for c in s:\\n            if c == \\'(\\': word.clear(); keyword = True\\n            if c == \\')\\': ans.append(m[\\'\\'.join(word)] if \\'\\'.join(word) in m else \\'?\\'); keyword = False\\n            if c.isalpha():\\n                word.append(c) if keyword else ans.append(c)\\n        return \\'\\'.join(ans)\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using Map = unordered_map<string, string>;\\n    using VS = vector<string>;\\n    using VVS = vector<VS>;\\n    string evaluate(string s, VVS& A, bool keyword = false, string word = {}, Map m = {}) {\\n        for (auto& pair: A) {\\n            auto [key, val] = tie(pair[0], pair[1]);\\n            m[key] = val;\\n        }\\n        ostringstream os;\\n        for (auto c: s) {\\n            if (c == \\'(\\') word.clear(), keyword = true;\\n            if (c == \\')\\') os << (m.find(word) != m.end() ? m[word] : \"?\"), keyword = false;\\n            if (isalpha(c)) {\\n                if (keyword) word.push_back(c); else os << c;\\n            }\\n        }\\n        return os.str();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun evaluate(s: String, A: List<List<String>>): String {\\n        var ans = mutableListOf<String>()\\n        var keyword = false\\n        var word = mutableListOf<Char>()\\n        var m = mutableMapOf<String, String>()\\n        for (pair in A) {\\n            var (key, value) = pair\\n            m[key] = value\\n        }\\n        for (c in s) {\\n            if (c == \\'(\\') {\\n                word.clear()\\n                keyword = true\\n            }\\n            else if (c == \\')\\') {\\n                var key = word.joinToString(\"\")\\n                ans.add(m[key] ?: \"?\")\\n                keyword = false\\n            } else {\\n                if (keyword) word.add(c) else ans.add(c.toString())\\n            }\\n        }\\n        return ans.joinToString(\"\")\\n    }\\n}\\n```\n```\\nlet evaluate = (s, A, m = new Map(), keyword = false, word = [], ans = []) => {\\n    for (let [key, val] of A)\\n        m.set(key, val);\\n    for (let c of s) {\\n        if (c == \\'(\\') word = [], keyword = true;\\n        if (c == \\')\\') ans.push(m.get(word.join(\\'\\')) || \\'?\\'), keyword = false;\\n        if (97 <= c.charCodeAt(0)) {\\n            if (keyword) word.push(c); else ans.push(c);\\n        }\\n    }\\n    return ans.join(\\'\\');\\n};\\n```\n```\\nclass Solution:\\n    def evaluate(self, s: str, A: List[List[str]], keyword = False) -> str:\\n        ans = []\\n        m = {}\\n        for key, val in A:\\n            m[key] = val\\n        word = []\\n        for c in s:\\n            if c == \\'(\\': word.clear(); keyword = True\\n            if c == \\')\\': ans.append(m[\\'\\'.join(word)] if \\'\\'.join(word) in m else \\'?\\'); keyword = False\\n            if c.isalpha():\\n                word.append(c) if keyword else ans.append(c)\\n        return \\'\\'.join(ans)\\n```\n```\\nclass Solution {\\npublic:\\n    using Map = unordered_map<string, string>;\\n    using VS = vector<string>;\\n    using VVS = vector<VS>;\\n    string evaluate(string s, VVS& A, bool keyword = false, string word = {}, Map m = {}) {\\n        for (auto& pair: A) {\\n            auto [key, val] = tie(pair[0], pair[1]);\\n            m[key] = val;\\n        }\\n        ostringstream os;\\n        for (auto c: s) {\\n            if (c == \\'(\\') word.clear(), keyword = true;\\n            if (c == \\')\\') os << (m.find(word) != m.end() ? m[word] : \"?\"), keyword = false;\\n            if (isalpha(c)) {\\n                if (keyword) word.push_back(c); else os << c;\\n            }\\n        }\\n        return os.str();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4095236,
                "title": "javascript-stack-hash-table",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nunless we encounter a closing bracket we push chars into the stack and\\nas soon as we encounter a closing bracket we pop the chars untill open bracket to form the key we need to search. If the key value pair is present in knowledge array push the updated value into the stack else push \\'?\\'\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @param {string[][]} knowledge\\n * @return {string}\\n */\\nvar evaluate = function(s, knowledge) {\\n    let stack = [];\\n    let hash = {};\\n    for(let tuple of knowledge){\\n        let [key, value] = tuple;\\n        hash[key] = value;\\n    }\\n    for(let char of s){\\n        if(char === \\')\\'){\\n            let key = \\'\\';\\n            while(stack[stack.length-1] !== \\'(\\'){\\n                key = stack.pop() + key;\\n            }\\n            stack.pop();\\n            stack.push(hash[key] || \\'?\\');\\n        } else {\\n            stack.push(char);\\n        }\\n    }\\n    return stack.join(\\'\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {string[][]} knowledge\\n * @return {string}\\n */\\nvar evaluate = function(s, knowledge) {\\n    let stack = [];\\n    let hash = {};\\n    for(let tuple of knowledge){\\n        let [key, value] = tuple;\\n        hash[key] = value;\\n    }\\n    for(let char of s){\\n        if(char === \\')\\'){\\n            let key = \\'\\';\\n            while(stack[stack.length-1] !== \\'(\\'){\\n                key = stack.pop() + key;\\n            }\\n            stack.pop();\\n            stack.push(hash[key] || \\'?\\');\\n        } else {\\n            stack.push(char);\\n        }\\n    }\\n    return stack.join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4040022,
                "title": "29ms-100-java-hashmap-explainedd",
                "content": "\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Map the knowledge list in a hashmap\\n- Iterate throough s , whenever \\')\\' comes initialise StringBuilder sb to store the next characters until \\')\\' comes\\n- We used String Builder for better complexity, when \\')\\' append mp.get(sb), i.e the value mappend against sb, in ans StringBuilder.\\n- Note that if a key is not present in map put \"?\" instead\\n\\n# Complexity\\n- Time complexity: O(s.length)  -> s.length will be greater than knowledge.length\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n        HashMap<String, String> mp = new HashMap<>();\\n\\n        for(var e : knowledge){\\n            mp.put(e.get(0),e.get(1));\\n        }\\n\\n        StringBuilder ans = new StringBuilder();\\n        StringBuilder sb = new StringBuilder();\\n        boolean brac = false;\\n\\n        for(char c : s.toCharArray()){\\n            if(c==\\'(\\'){\\n                sb = new StringBuilder();\\n                brac = true;\\n            }\\n            else if(c==\\')\\'){\\n                ans.append( mp.getOrDefault(sb.toString() , \"?\") );\\n                brac = false;\\n            }\\n\\n            else if(brac==true) sb.append(c);\\n\\n            else ans.append(c);\\n\\n        }\\n\\n        return ans.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n        HashMap<String, String> mp = new HashMap<>();\\n\\n        for(var e : knowledge){\\n            mp.put(e.get(0),e.get(1));\\n        }\\n\\n        StringBuilder ans = new StringBuilder();\\n        StringBuilder sb = new StringBuilder();\\n        boolean brac = false;\\n\\n        for(char c : s.toCharArray()){\\n            if(c==\\'(\\'){\\n                sb = new StringBuilder();\\n                brac = true;\\n            }\\n            else if(c==\\')\\'){\\n                ans.append( mp.getOrDefault(sb.toString() , \"?\") );\\n                brac = false;\\n            }\\n\\n            else if(brac==true) sb.append(c);\\n\\n            else ans.append(c);\\n\\n        }\\n\\n        return ans.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4034706,
                "title": "simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def evaluate(self, s, knowledge):\\n        \"\"\"\\n        :type s: str\\n        :type knowledge: List[List[str]]\\n        :rtype: str\\n        \"\"\"\\n        start=[]\\n        end=[]\\n        disc={}\\n        for a,b in knowledge:\\n            disc[a]=b\\n        res=\"\"\\n        f=0\\n        for i in range(len(s)):\\n            if s[i]==\"(\":\\n                f=1\\n                start.append(i)\\n            if s[i]==\")\":\\n                indx=start.pop()\\n                wod=s[indx+1:i]\\n                #print(wod)\\n                if wod in disc:\\n                    res+=disc[wod]\\n                else:\\n                    res+=\"?\"\\n                f=0\\n                continue\\n            if f==0:\\n                res+=s[i]\\n        #print(res)\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def evaluate(self, s, knowledge):\\n        \"\"\"\\n        :type s: str\\n        :type knowledge: List[List[str]]\\n        :rtype: str\\n        \"\"\"\\n        start=[]\\n        end=[]\\n        disc={}\\n        for a,b in knowledge:\\n            disc[a]=b\\n        res=\"\"\\n        f=0\\n        for i in range(len(s)):\\n            if s[i]==\"(\":\\n                f=1\\n                start.append(i)\\n            if s[i]==\")\":\\n                indx=start.pop()\\n                wod=s[indx+1:i]\\n                #print(wod)\\n                if wod in disc:\\n                    res+=disc[wod]\\n                else:\\n                    res+=\"?\"\\n                f=0\\n                continue\\n            if f==0:\\n                res+=s[i]\\n        #print(res)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4027951,
                "title": "golang-o-n-fast-and-pretty-simple-code",
                "content": "```\\nimport (\\n  \"strings\"\\n)\\n\\nfunc evaluate(s string, knowledge [][]string) string {\\n  if len(s) == 1 {\\n    return s\\n  }\\n\\n  k := make(map[string]string, len(knowledge))\\n\\n  for i:=0; i<len(knowledge); i++ {\\n    key := knowledge[i][0]\\n    v := knowledge[i][1]\\n    k[key] = v\\n  }\\n\\n  var ans []string\\n\\n  lptr := -1 \\n  rptr := 0\\n\\n  for i:=0; i<len(s); i++ {\\n    if s[i] == \\'(\\' {\\n      if lptr == -1 && i != 0 {\\n        ans = append(ans, s[lptr+1:i])\\n      }\\n      if rptr != 0 {\\n        ans = append(ans, s[rptr+1:i])\\n      }\\n      lptr = i\\n      continue\\n    } else if s[i] == \\')\\' {\\n      rptr = i\\n      key := s[lptr+1:rptr]\\n      val, ok := k[key]; if !ok {\\n        ans = append(ans, \"?\")\\n      } else {\\n        ans = append(ans, val)\\n      }\\n    }\\n    if i == len(s)-1 {\\n      if lptr == -1 {\\n        return s\\n      }\\n      if rptr < i {\\n        ans = append(ans, s[rptr+1:i+1])\\n      }\\n    }\\n  }\\n  return strings.Join(ans, \"\")\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nimport (\\n  \"strings\"\\n)\\n\\nfunc evaluate(s string, knowledge [][]string) string {\\n  if len(s) == 1 {\\n    return s\\n  }\\n\\n  k := make(map[string]string, len(knowledge))\\n\\n  for i:=0; i<len(knowledge); i++ {\\n    key := knowledge[i][0]\\n    v := knowledge[i][1]\\n    k[key] = v\\n  }\\n\\n  var ans []string\\n\\n  lptr := -1 \\n  rptr := 0\\n\\n  for i:=0; i<len(s); i++ {\\n    if s[i] == \\'(\\' {\\n      if lptr == -1 && i != 0 {\\n        ans = append(ans, s[lptr+1:i])\\n      }\\n      if rptr != 0 {\\n        ans = append(ans, s[rptr+1:i])\\n      }\\n      lptr = i\\n      continue\\n    } else if s[i] == \\')\\' {\\n      rptr = i\\n      key := s[lptr+1:rptr]\\n      val, ok := k[key]; if !ok {\\n        ans = append(ans, \"?\")\\n      } else {\\n        ans = append(ans, val)\\n      }\\n    }\\n    if i == len(s)-1 {\\n      if lptr == -1 {\\n        return s\\n      }\\n      if rptr < i {\\n        ans = append(ans, s[rptr+1:i+1])\\n      }\\n    }\\n  }\\n  return strings.Join(ans, \"\")\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4018905,
                "title": "python-simple-logic",
                "content": "# Code\\n```\\nclass Solution:\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        d = {key:sol for key, sol in knowledge}\\n        ans = add = \\'\\'\\n\\n        for char in s:\\n            if char == \\'(\\':\\n                ans += add\\n                add = \\'\\'\\n            elif char == \\')\\':\\n                ans += d[add] if add in d else \\'?\\'\\n                add = \\'\\'\\n            else:\\n                add += char\\n\\n        return ans + add\\n\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        d = {key:sol for key, sol in knowledge}\\n        ans = add = \\'\\'\\n\\n        for char in s:\\n            if char == \\'(\\':\\n                ans += add\\n                add = \\'\\'\\n            elif char == \\')\\':\\n                ans += d[add] if add in d else \\'?\\'\\n                add = \\'\\'\\n            else:\\n                add += char\\n\\n        return ans + add\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3994514,
                "title": "python3-easy-to-understand-solution-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n\\n    def __init__(self):\\n        self.i = 0\\n\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        \\n        hmap = {key: val for key, val in knowledge}\\n\\n        res = \"\"\\n        while self.i < len(s):\\n            \\n            # if the current value at self.i is \"(\"\\n            if s[self.i] == \"(\":\\n                word = self.parseParenthesis(s)\\n                res += hmap.get(word, \"?\")\\n            else: # otherwise, add to the res\\n                res += s[self.i]\\n            self.i += 1\\n        return res\\n\\n    def parseParenthesis(self, s):\\n        \\'\\'\\'\\n        Called when the curent value at the self.i is (\\n        Return the word inside the parenthesis\\n        \\'\\'\\'\\n        self.i += 1\\n        word = \"\"\\n        while s[self.i] != \")\":\\n            word += s[self.i]\\n            self.i += 1\\n        return word\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\n    def __init__(self):\\n        self.i = 0\\n\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        \\n        hmap = {key: val for key, val in knowledge}\\n\\n        res = \"\"\\n        while self.i < len(s):\\n            \\n            # if the current value at self.i is \"(\"\\n            if s[self.i] == \"(\":\\n                word = self.parseParenthesis(s)\\n                res += hmap.get(word, \"?\")\\n            else: # otherwise, add to the res\\n                res += s[self.i]\\n            self.i += 1\\n        return res\\n\\n    def parseParenthesis(self, s):\\n        \\'\\'\\'\\n        Called when the curent value at the self.i is (\\n        Return the word inside the parenthesis\\n        \\'\\'\\'\\n        self.i += 1\\n        word = \"\"\\n        while s[self.i] != \")\":\\n            word += s[self.i]\\n            self.i += 1\\n        return word\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3987872,
                "title": "very-efficient-beats-100-95-solution-without-regexp",
                "content": "```\\nvar evaluate = function(s, knowledge) {\\n    const hash = new Map()\\n    \\n    for (const [key, value] of knowledge) {\\n        hash.set(key, value)\\n    }\\n    \\n    let res = \\'\\'\\n    let isKey = false\\n    let key = \\'\\'\\n    \\n    for (let i = 0; i < s.length; i++) {\\n        if (s[i] === \\'(\\') {\\n            isKey = true\\n            continue\\n        }\\n        \\n        if (s[i] === \\')\\') {\\n            isKey = false\\n            res += (hash.get(key) || \\'?\\')\\n            key = \\'\\'\\n            continue\\n        }\\n        \\n        if (isKey) {\\n            key += s[i]\\n            continue\\n        }\\n        \\n        res += s[i]\\n    }\\n    \\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar evaluate = function(s, knowledge) {\\n    const hash = new Map()\\n    \\n    for (const [key, value] of knowledge) {\\n        hash.set(key, value)\\n    }\\n    \\n    let res = \\'\\'\\n    let isKey = false\\n    let key = \\'\\'\\n    \\n    for (let i = 0; i < s.length; i++) {\\n        if (s[i] === \\'(\\') {\\n            isKey = true\\n            continue\\n        }\\n        \\n        if (s[i] === \\')\\') {\\n            isKey = false\\n            res += (hash.get(key) || \\'?\\')\\n            key = \\'\\'\\n            continue\\n        }\\n        \\n        if (isKey) {\\n            key += s[i]\\n            continue\\n        }\\n        \\n        res += s[i]\\n    }\\n    \\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3984028,
                "title": "evaluate-the-bracket-pairs-of-a-string",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n        String str = new String();\\n        HashMap<String,String> hm = new HashMap<String,String>();\\n        for(int i=0;i<knowledge.size();i++)\\n        {\\n            hm.put(knowledge.get(i).get(0),knowledge.get(i).get(1));\\n        }\\n        int braket = 0;\\n        String str1 = new String();\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'(\\')\\n            braket++;\\n            if(braket>0)\\n            {\\n                if(s.charAt(i)!=\\'(\\'&&s.charAt(i)!=\\')\\')\\n                str1 = str1+s.charAt(i);\\n            } \\n            if(braket==0)\\n            {\\n                str=str+s.charAt(i);\\n            }\\n            if(s.charAt(i)==\\')\\')\\n            {\\n                if(hm.containsKey(str1)==true)\\n                str = str+hm.get(str1);\\n                else\\n                str = str+\"?\";\\n                braket--;\\n                str1=\"\";\\n            } \\n        }\\n        return str;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n        String str = new String();\\n        HashMap<String,String> hm = new HashMap<String,String>();\\n        for(int i=0;i<knowledge.size();i++)\\n        {\\n            hm.put(knowledge.get(i).get(0),knowledge.get(i).get(1));\\n        }\\n        int braket = 0;\\n        String str1 = new String();\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'(\\')\\n            braket++;\\n            if(braket>0)\\n            {\\n                if(s.charAt(i)!=\\'(\\'&&s.charAt(i)!=\\')\\')\\n                str1 = str1+s.charAt(i);\\n            } \\n            if(braket==0)\\n            {\\n                str=str+s.charAt(i);\\n            }\\n            if(s.charAt(i)==\\')\\')\\n            {\\n                if(hm.containsKey(str1)==true)\\n                str = str+hm.get(str1);\\n                else\\n                str = str+\"?\";\\n                braket--;\\n                str1=\"\";\\n            } \\n        }\\n        return str;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3968943,
                "title": "regex-fast-and-simple-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$ \\n\\n- Space complexity:$$O(n)$$ \\n\\n# Code\\n```\\nfunction evaluate(s: string, knowledge: string[][]): string {\\n    const map:Map<string,string>=new Map(knowledge as any)\\n\\n    const functiunToReplace=(word:string):string=>{\\n        if(map.get(word))return map.get(word)\\n        return \"?\"\\n    }\\n\\n    let result = s.replace(/\\\\([A-Za-z0-9]+\\\\)/gi, \\n    (str:string) => functiunToReplace(str.slice(1,str.length-1)));\\n\\n    return result\\n};  \\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction evaluate(s: string, knowledge: string[][]): string {\\n    const map:Map<string,string>=new Map(knowledge as any)\\n\\n    const functiunToReplace=(word:string):string=>{\\n        if(map.get(word))return map.get(word)\\n        return \"?\"\\n    }\\n\\n    let result = s.replace(/\\\\([A-Za-z0-9]+\\\\)/gi, \\n    (str:string) => functiunToReplace(str.slice(1,str.length-1)));\\n\\n    return result\\n};  \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3954942,
                "title": "hashmap-o-n-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        knowledge = {k:v for k,v in knowledge}\\n\\n        answer = []\\n        word = []\\n        to_read = False\\n        for ch in s:\\n            if ch==\\'(\\':\\n                to_read = True\\n            elif ch==\\')\\':\\n                answer.append(knowledge.get(\\'\\'.join(word),\\'?\\'))\\n                word = []\\n                to_read = False\\n            else:\\n                if not to_read:\\n                    answer.append(ch)\\n                else:\\n                    word.append(ch)\\n        return \\'\\'.join(answer)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        knowledge = {k:v for k,v in knowledge}\\n\\n        answer = []\\n        word = []\\n        to_read = False\\n        for ch in s:\\n            if ch==\\'(\\':\\n                to_read = True\\n            elif ch==\\')\\':\\n                answer.append(knowledge.get(\\'\\'.join(word),\\'?\\'))\\n                word = []\\n                to_read = False\\n            else:\\n                if not to_read:\\n                    answer.append(ch)\\n                else:\\n                    word.append(ch)\\n        return \\'\\'.join(answer)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952126,
                "title": "solution-more",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n        Map<String, String> knowledgeMap = new HashMap<>();\\n        for(List<String> Know : knowledge){\\n            knowledgeMap.put(Know.get(0),Know.get(1));\\n        }\\n        StringBuilder buildResult = new StringBuilder();\\n        StringBuilder temp = new StringBuilder();\\n\\n        boolean inBrackeat = false;\\n        for(char c : s.toCharArray()) {\\n            \\n            if(c ==\\'(\\'){\\n                inBrackeat = true;\\n            }else if (inBrackeat) {\\n                if(c == \\')\\'){\\n                    String key = temp.toString();\\n                    if (knowledgeMap.containsKey(key)){\\n                        buildResult.append(knowledgeMap.get(key));\\n                    }else{\\n                        buildResult.append(\\'?\\');\\n                    }\\n                    inBrackeat = false;\\n                    temp = new StringBuilder();\\n                }else{\\n                    temp.append(c);\\n                }\\n            }else{\\n                buildResult.append(c);\\n\\n            }\\n        }\\n        return buildResult.toString();\\n        \\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n        Map<String, String> knowledgeMap = new HashMap<>();\\n        for(List<String> Know : knowledge){\\n            knowledgeMap.put(Know.get(0),Know.get(1));\\n        }\\n        StringBuilder buildResult = new StringBuilder();\\n        StringBuilder temp = new StringBuilder();\\n\\n        boolean inBrackeat = false;\\n        for(char c : s.toCharArray()) {\\n            \\n            if(c ==\\'(\\'){\\n                inBrackeat = true;\\n            }else if (inBrackeat) {\\n                if(c == \\')\\'){\\n                    String key = temp.toString();\\n                    if (knowledgeMap.containsKey(key)){\\n                        buildResult.append(knowledgeMap.get(key));\\n                    }else{\\n                        buildResult.append(\\'?\\');\\n                    }\\n                    inBrackeat = false;\\n                    temp = new StringBuilder();\\n                }else{\\n                    temp.append(c);\\n                }\\n            }else{\\n                buildResult.append(c);\\n\\n            }\\n        }\\n        return buildResult.toString();\\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3949962,
                "title": "c-hash-map-simulation",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string evaluate(string s, vector<vector<string>>& kn) {\\n        int n = s.size();\\n        unordered_map<string,string> m;\\n        for(auto &i:kn)\\n        m[i[0]] = i[1];\\n        string ans = \"\";\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                string tmp = \"\";\\n                i++;\\n                while(i<n && s[i]!=\\')\\')\\n                {\\n                    tmp+=s[i];\\n                    i++;\\n                }\\n                if(m.find(tmp)!=m.end())\\n                ans+=m[tmp];\\n                else\\n                ans+=\\'?\\';\\n            }\\n            else\\n            ans+=s[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string evaluate(string s, vector<vector<string>>& kn) {\\n        int n = s.size();\\n        unordered_map<string,string> m;\\n        for(auto &i:kn)\\n        m[i[0]] = i[1];\\n        string ans = \"\";\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                string tmp = \"\";\\n                i++;\\n                while(i<n && s[i]!=\\')\\')\\n                {\\n                    tmp+=s[i];\\n                    i++;\\n                }\\n                if(m.find(tmp)!=m.end())\\n                ans+=m[tmp];\\n                else\\n                ans+=\\'?\\';\\n            }\\n            else\\n            ans+=s[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3922712,
                "title": "cpp-very-easy-implementation-fastest-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    string evaluate(string s, vector<vector<string>>& knowledge) {\\n        unordered_map<string,string>m;\\n        for(auto & e: knowledge){\\n            m[e[0]]=e[1];\\n        }\\n        string ans=\"\";\\n        for(int i=0;i<s.size();i++){\\n            char c=s[i];\\n            if(c==\\'(\\'){\\n                i++;\\n                string s1=\"\";\\n                while(s[i]!=\\')\\'){\\n                    s1+=s[i];\\n                    i++;\\n                }\\n                auto it=m.find(s1);\\n                if(it==m.end())ans+=\"?\";\\n                else ans+=it->second;\\n            }\\n            else ans+=s[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    string evaluate(string s, vector<vector<string>>& knowledge) {\\n        unordered_map<string,string>m;\\n        for(auto & e: knowledge){\\n            m[e[0]]=e[1];\\n        }\\n        string ans=\"\";\\n        for(int i=0;i<s.size();i++){\\n            char c=s[i];\\n            if(c==\\'(\\'){\\n                i++;\\n                string s1=\"\";\\n                while(s[i]!=\\')\\'){\\n                    s1+=s[i];\\n                    i++;\\n                }\\n                auto it=m.find(s1);\\n                if(it==m.end())ans+=\"?\";\\n                else ans+=it->second;\\n            }\\n            else ans+=s[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3883475,
                "title": "javascript-95-runtime",
                "content": "```javascript\\nconst evaluate = (s, knowledge) => {\\n  const key = new Map(knowledge)\\n\\n  let res = \"\";\\n  while (s.length > 0) {\\n    if (s.indexOf(\"(\") !== -1) {\\n      res += s.substring(0, s.indexOf(\"(\"));\\n      res += key.get(s.substring(s.indexOf(\"(\") + 1, s.indexOf(\")\"))) || \"?\";\\n      s = s.substring(s.indexOf(\")\") + 1);\\n    } else {\\n      res += s;\\n      break;\\n    }\\n  }\\n  return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nconst evaluate = (s, knowledge) => {\\n  const key = new Map(knowledge)\\n\\n  let res = \"\";\\n  while (s.length > 0) {\\n    if (s.indexOf(\"(\") !== -1) {\\n      res += s.substring(0, s.indexOf(\"(\"));\\n      res += key.get(s.substring(s.indexOf(\"(\") + 1, s.indexOf(\")\"))) || \"?\";\\n      s = s.substring(s.indexOf(\")\") + 1);\\n    } else {\\n      res += s;\\n      break;\\n    }\\n  }\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3881380,
                "title": "easy-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n        \\n        HashMap<String, String> map = new HashMap<>();\\n\\n        for (List<String> list : knowledge) {\\n            map.put(list.get(0), list.get(1));\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) != \\'(\\') {\\n                sb.append(s.charAt(i));\\n            }\\n            else if (s.charAt(i) == \\'(\\') {\\n                int start = i + 1;\\n                while (i < s.length() && s.charAt(i) != \\')\\') {\\n                    i++;\\n                }\\n                sb.append(map.getOrDefault(s.substring(start, i), \"?\"));\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n        \\n        HashMap<String, String> map = new HashMap<>();\\n\\n        for (List<String> list : knowledge) {\\n            map.put(list.get(0), list.get(1));\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) != \\'(\\') {\\n                sb.append(s.charAt(i));\\n            }\\n            else if (s.charAt(i) == \\'(\\') {\\n                int start = i + 1;\\n                while (i < s.length() && s.charAt(i) != \\')\\') {\\n                    i++;\\n                }\\n                sb.append(map.getOrDefault(s.substring(start, i), \"?\"));\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3864711,
                "title": "java-single-pass-solution-using-hashmap-beats-99-32",
                "content": "\\n# Approach\\nGiven the problem constraints like , no nested brackets and valid brackets, we scan the string and for every opening bracket, find its corrosponding closing bracket. \\nThe string found inside the brackets is replaced by its value based on \"knowledge\" as defined in problem.\\n\\n# Complexity\\n- Time complexity:\\nEvery index in String array is only operated upon once during a linear scan , Time : O(N)\\n\\n- Space complexity:\\nO(N + M) // N = String length, M = Knowledge length\\n\\n# Code\\n```\\nclass Solution {\\n    Map<String, String> hm = new HashMap();\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n      StringBuilder sb = new StringBuilder();\\n      for(List<String> pair : knowledge) hm.put(pair.get(0), pair.get(1));\\n\\n      int index = 0; int n = s.length();\\n\\n      while(index < n) {\\n          if(s.charAt(index) == \\'(\\') {\\n              int nextIndex = addValueToResult(s, index, n, sb);\\n              index = nextIndex;\\n          }else {\\n              sb.append(\"\" + s.charAt(index));\\n              index++;\\n          }\\n      }\\n\\n      return sb.toString();\\n    }\\n\\n    int addValueToResult(String s, int index, int n, StringBuilder sb) {\\n        int start = index;\\n        while(index < n && s.charAt(index) != \\')\\') {\\n            index++;\\n        }\\n        // index now points to next \\')\\'\\n        if(start + 1 < n && index <= n)\\n            sb.append(hm.getOrDefault(s.substring(start + 1, index), \"?\"));\\n        return index + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    Map<String, String> hm = new HashMap();\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n      StringBuilder sb = new StringBuilder();\\n      for(List<String> pair : knowledge) hm.put(pair.get(0), pair.get(1));\\n\\n      int index = 0; int n = s.length();\\n\\n      while(index < n) {\\n          if(s.charAt(index) == \\'(\\') {\\n              int nextIndex = addValueToResult(s, index, n, sb);\\n              index = nextIndex;\\n          }else {\\n              sb.append(\"\" + s.charAt(index));\\n              index++;\\n          }\\n      }\\n\\n      return sb.toString();\\n    }\\n\\n    int addValueToResult(String s, int index, int n, StringBuilder sb) {\\n        int start = index;\\n        while(index < n && s.charAt(index) != \\')\\') {\\n            index++;\\n        }\\n        // index now points to next \\')\\'\\n        if(start + 1 < n && index <= n)\\n            sb.append(hm.getOrDefault(s.substring(start + 1, index), \"?\"));\\n        return index + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3823755,
                "title": "python3-10-lines-t-s-o-n-o-n-t-100",
                "content": "# Intuition\\n\\nSplit string into substrings that are either (1) in brackets, or (2) not in brackets.\\n\\nUse hashtable for $$O(1)$$ conversion of substrings in group (1).\\n\\n# Complexity\\n- Time complexity: $$O(m + n)$$\\nwhere $$m$$ is the length of $$s$$, and $$n$$ is the length of $$knowledge$$.\\n\\n- Space complexity: $$O(m + n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n\\n        # knowledge has to be stored in hashtable\\n        hm = defaultdict(lambda: \\'?\\')\\n        for k, v in knowledge: \\n            hm[k] = v\\n\\n        # tokenise; e.g. let s = \"(name)is(age)yearsold\"\\n        # t = s.split(\\'(\\')      = [\"\", \"name)is\", \"age)yearsold\"]\\n        # tokens = t.split(\\')\\') = [[\"\"], [\"name\", \"is\"], [\"age\", \"yearsold\"]]\\n        tokens = [c.split(\\')\\') for c in s.split(\\'(\\')]\\n        \\n        # first token is either:\\n        # 1) empty string (i.e. if s starts with open bracket)\\n        # 2) a string before the first open bracket\\n        # 3) s, if no open brackets exist\\n        ans = [tokens[0][0]]\\n\\n        # subsequent tokens are:\\n        # token[0] = word in brackets\\n        # token[1] = word not in brackets\\n        for i in range(1, len(tokens)):\\n            bracketed, not_bracketed = tokens[i]\\n            ans.append(hm[bracketed])\\n            ans.append(not_bracketed)\\n\\n        return \\'\\'.join(ans)\\n\\n```\\n\\nhttps://leetcode.com/problems/evaluate-the-bracket-pairs-of-a-string/submissions/1005310298/",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n\\n        # knowledge has to be stored in hashtable\\n        hm = defaultdict(lambda: \\'?\\')\\n        for k, v in knowledge: \\n            hm[k] = v\\n\\n        # tokenise; e.g. let s = \"(name)is(age)yearsold\"\\n        # t = s.split(\\'(\\')      = [\"\", \"name)is\", \"age)yearsold\"]\\n        # tokens = t.split(\\')\\') = [[\"\"], [\"name\", \"is\"], [\"age\", \"yearsold\"]]\\n        tokens = [c.split(\\')\\') for c in s.split(\\'(\\')]\\n        \\n        # first token is either:\\n        # 1) empty string (i.e. if s starts with open bracket)\\n        # 2) a string before the first open bracket\\n        # 3) s, if no open brackets exist\\n        ans = [tokens[0][0]]\\n\\n        # subsequent tokens are:\\n        # token[0] = word in brackets\\n        # token[1] = word not in brackets\\n        for i in range(1, len(tokens)):\\n            bracketed, not_bracketed = tokens[i]\\n            ans.append(hm[bracketed])\\n            ans.append(not_bracketed)\\n\\n        return \\'\\'.join(ans)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3777133,
                "title": "best-c-solution-using-stack-and-map-easy-to-understand",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\n#include <bits/stdc++.h>\\r\\nusing namespace std;\\r\\nclass Solution\\r\\n{\\r\\npublic:\\r\\n    string evaluate(string s, vector<vector<string>> &knowledge)\\r\\n    {\\r\\n        stack<char> st;\\r\\n        string ans;\\r\\n        string temp;\\r\\n        map<string, string> m;\\r\\n        for (auto &&i : knowledge)\\r\\n        {\\r\\n            m[i[0]] = i[1];\\r\\n        }\\r\\n        for (int i = 0; i < s.size(); i++)\\r\\n        {\\r\\n            if (s[i] == \\'(\\')\\r\\n            {\\r\\n                st.push(s[i]);\\r\\n            }\\r\\n            else if (!st.empty() && st.top() == \\'(\\' && s[i] == \\')\\')\\r\\n            {\\r\\n                auto it = m.find(temp);\\r\\n                if (it == m.end())\\r\\n                {\\r\\n                    ans += \\'?\\';\\r\\n                }\\r\\n                else\\r\\n                {\\r\\n                    ans += m[temp];\\r\\n                }\\r\\n                temp.clear();\\r\\n                st.pop();\\r\\n            }\\r\\n            else if (!st.empty() && st.top() == \\'(\\' && s[i] != \\')\\')\\r\\n            {\\r\\n                temp += s[i];\\r\\n            }\\r\\n            else\\r\\n            {\\r\\n                ans += s[i];\\r\\n            }\\r\\n        }\\r\\n        return ans;\\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\r\\n#include <bits/stdc++.h>\\r\\nusing namespace std;\\r\\nclass Solution\\r\\n{\\r\\npublic:\\r\\n    string evaluate(string s, vector<vector<string>> &knowledge)\\r\\n    {\\r\\n        stack<char> st;\\r\\n        string ans;\\r\\n        string temp;\\r\\n        map<string, string> m;\\r\\n        for (auto &&i : knowledge)\\r\\n        {\\r\\n            m[i[0]] = i[1];\\r\\n        }\\r\\n        for (int i = 0; i < s.size(); i++)\\r\\n        {\\r\\n            if (s[i] == \\'(\\')\\r\\n            {\\r\\n                st.push(s[i]);\\r\\n            }\\r\\n            else if (!st.empty() && st.top() == \\'(\\' && s[i] == \\')\\')\\r\\n            {\\r\\n                auto it = m.find(temp);\\r\\n                if (it == m.end())\\r\\n                {\\r\\n                    ans += \\'?\\';\\r\\n                }\\r\\n                else\\r\\n                {\\r\\n                    ans += m[temp];\\r\\n                }\\r\\n                temp.clear();\\r\\n                st.pop();\\r\\n            }\\r\\n            else if (!st.empty() && st.top() == \\'(\\' && s[i] != \\')\\')\\r\\n            {\\r\\n                temp += s[i];\\r\\n            }\\r\\n            else\\r\\n            {\\r\\n                ans += s[i];\\r\\n            }\\r\\n        }\\r\\n        return ans;\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3724049,
                "title": "lets-goooooo-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nThe problem involves evaluating bracket pairs in a given string using a knowledge base.\\nWe need to find keys within parentheses and replace them with their corresponding values, handling cases where keys are not present.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1\\uFE0F\\u20E3 Create an unordered map to store key-value pairs from the knowledge base, using the first element of each pair as the key and the second element as the value.\\n2\\uFE0F\\u20E3 Iterate through the knowledge vector and populate the unordered map with key-value pairs.\\n3\\uFE0F\\u20E3 Traverse the input string, identifying bracket pairs.\\n4\\uFE0F\\u20E3 If a key is found, check if it exists in the map using find().\\n- If found, append the corresponding value to the output string.\\n- If not found, append \\'?\\' to the output string.\\n5\\uFE0F\\u20E3 For characters outside brackets, add them to the output string unchanged.\\n6\\uFE0F\\u20E3 Return the final output string. The solution efficiently replaces keys within brackets with their values using the unordered map.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <unordered_map>\\nclass Solution {\\npublic:\\n    string evaluate(string s, vector<vector<string>>& knowledge) {\\n        unordered_map<string,string> MyMap;\\n        unordered_set<string> Keys;\\n\\n        for(vector<string> k : knowledge){\\n            MyMap[k[0]] = k[1];\\n            Keys.insert(k[0]);\\n        }\\n\\n        string OutputString = \"\";\\n        int index = 0;\\n        \\n        while(index < s.size()){\\n            // if its key time\\n            if(s[index] == \\'(\\'){\\n                string key = \"\";\\n                index++;\\n                while(s[index] != \\')\\'){\\n                    key += s[index];\\n                    index++;\\n                }\\n\\n                // if the key wasn\\'t present in knowledge\\n                if(Keys.find(key) == Keys.end()){\\n                    OutputString += \\'?\\';\\n                }\\n                // if the key was present in knowledge\\n                else{\\n                    OutputString += MyMap[key];\\n                }\\n            }\\n            // general cases\\n            else{\\n                OutputString += s[index];\\n            }\\n\\n            index++;\\n        }\\n\\n        return OutputString;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\n#include <unordered_map>\\nclass Solution {\\npublic:\\n    string evaluate(string s, vector<vector<string>>& knowledge) {\\n        unordered_map<string,string> MyMap;\\n        unordered_set<string> Keys;\\n\\n        for(vector<string> k : knowledge){\\n            MyMap[k[0]] = k[1];\\n            Keys.insert(k[0]);\\n        }\\n\\n        string OutputString = \"\";\\n        int index = 0;\\n        \\n        while(index < s.size()){\\n            // if its key time\\n            if(s[index] == \\'(\\'){\\n                string key = \"\";\\n                index++;\\n                while(s[index] != \\')\\'){\\n                    key += s[index];\\n                    index++;\\n                }\\n\\n                // if the key wasn\\'t present in knowledge\\n                if(Keys.find(key) == Keys.end()){\\n                    OutputString += \\'?\\';\\n                }\\n                // if the key was present in knowledge\\n                else{\\n                    OutputString += MyMap[key];\\n                }\\n            }\\n            // general cases\\n            else{\\n                OutputString += s[index];\\n            }\\n\\n            index++;\\n        }\\n\\n        return OutputString;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3706655,
                "title": "simple-kotlin-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    fun evaluate(s: String, knowledge: List<List<String>>): String {\\n        val knowledgeMap: MutableMap<String, String?> = HashMap()\\n        knowledge.forEach { list -> knowledgeMap[list[0]] = list[1] }\\n\\n        var retStr = \"\"\\n        var waitingForClose = false\\n        var currentKey = \"\"\\n\\n        for (char in s) {\\n            if (char == \\'(\\') {\\n                waitingForClose = true\\n                currentKey = \"\"\\n            } else if (char == \\')\\') {\\n                waitingForClose = false\\n                retStr += knowledgeMap[currentKey] ?: \"?\"\\n            } else {\\n                if (waitingForClose) {\\n                    currentKey += char\\n                } else {\\n                    retStr += char\\n                }\\n            }\\n        }\\n\\n        return retStr\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun evaluate(s: String, knowledge: List<List<String>>): String {\\n        val knowledgeMap: MutableMap<String, String?> = HashMap()\\n        knowledge.forEach { list -> knowledgeMap[list[0]] = list[1] }\\n\\n        var retStr = \"\"\\n        var waitingForClose = false\\n        var currentKey = \"\"\\n\\n        for (char in s) {\\n            if (char == \\'(\\') {\\n                waitingForClose = true\\n                currentKey = \"\"\\n            } else if (char == \\')\\') {\\n                waitingForClose = false\\n                retStr += knowledgeMap[currentKey] ?: \"?\"\\n            } else {\\n                if (waitingForClose) {\\n                    currentKey += char\\n                } else {\\n                    retStr += char\\n                }\\n            }\\n        }\\n\\n        return retStr\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3692810,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n\\n    string evaluate(string s, vector<vector<string>>& knowledge) {\\n      string g=\"\",t=\"\";\\n        int i,j,b=0;\\n        map<string,string>res;\\n        for(auto kk:knowledge)\\n        {\\n            res[kk[0]]=kk[1];\\n        }\\n       \\n      for(i=0;i<s.size();i++)\\n      {\\n          if(s[i]==\\'(\\')\\n            {\\n                \\n                b=1;\\n                t=\"\";\\n            }\\n             else if(s[i]==\\')\\')\\n           {\\n               if(res[t]!=\"\")\\n                    g+=res[t];\\n                else    \\n                    g+=\"?\";\\n              \\n                t=\"\";\\n                b=0;\\n           }\\n            else if(b==1)\\n                t+=s[i];\\n            else\\n                g+=s[i];\\n       \\n      }\\n        return g;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n\\n    string evaluate(string s, vector<vector<string>>& knowledge) {\\n      string g=\"\",t=\"\";\\n        int i,j,b=0;\\n        map<string,string>res;\\n        for(auto kk:knowledge)\\n        {\\n            res[kk[0]]=kk[1];\\n        }\\n       \\n      for(i=0;i<s.size();i++)\\n      {\\n          if(s[i]==\\'(\\')\\n            {\\n                \\n                b=1;\\n                t=\"\";\\n            }\\n             else if(s[i]==\\')\\')\\n           {\\n               if(res[t]!=\"\")\\n                    g+=res[t];\\n                else    \\n                    g+=\"?\";\\n              \\n                t=\"\";\\n                b=0;\\n           }\\n            else if(b==1)\\n                t+=s[i];\\n            else\\n                g+=s[i];\\n       \\n      }\\n        return g;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650091,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n        HashMap<String,String> map=new HashMap<>();\\n        for(int i=0;i<knowledge.size();i++)\\n        {\\n            map.put(knowledge.get(i).get(0),knowledge.get(i).get(1));\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        int i=0;\\n        int n=s.length();\\n        while(i<n)\\n        {\\n            if(s.charAt(i)==\\'(\\')\\n            {\\n                int j=i+1;\\n                while(j<n && s.charAt(j)!=\\')\\')j++;\\n                \\n                sb.append(map.getOrDefault(s.substring(i+1,j),\"?\"));\\n                i=j;\\n            }\\n            else sb.append(s.charAt(i));\\n            i++;\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n        HashMap<String,String> map=new HashMap<>();\\n        for(int i=0;i<knowledge.size();i++)\\n        {\\n            map.put(knowledge.get(i).get(0),knowledge.get(i).get(1));\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        int i=0;\\n        int n=s.length();\\n        while(i<n)\\n        {\\n            if(s.charAt(i)==\\'(\\')\\n            {\\n                int j=i+1;\\n                while(j<n && s.charAt(j)!=\\')\\')j++;\\n                \\n                sb.append(map.getOrDefault(s.substring(i+1,j),\"?\"));\\n                i=j;\\n            }\\n            else sb.append(s.charAt(i));\\n            i++;\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623444,
                "title": "prem-s-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nIterate through the string and when the you see the beginning (, work your way up to get the entire string and update\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n) where the n is the size of the string\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(k) where k is the size of the knowledge \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n        HashMap<String,String> map = new HashMap<>();\\n        for(List<String> list : knowledge) map.put(list.get(0),list.get(1));\\n\\n        StringBuilder sb = new StringBuilder();\\n\\n        for(int i = 0 ; i< s.length() ; i++){\\n            char c = s.charAt(i);\\n            if(c!=\\'(\\'){\\n                sb.append(c);\\n                continue;\\n            }\\n            StringBuilder curr = new StringBuilder();\\n            while(s.charAt(++i)!=\\')\\') curr.append(s.charAt(i));\\n            sb.append(map.getOrDefault(curr.toString(),\"?\"));\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n        HashMap<String,String> map = new HashMap<>();\\n        for(List<String> list : knowledge) map.put(list.get(0),list.get(1));\\n\\n        StringBuilder sb = new StringBuilder();\\n\\n        for(int i = 0 ; i< s.length() ; i++){\\n            char c = s.charAt(i);\\n            if(c!=\\'(\\'){\\n                sb.append(c);\\n                continue;\\n            }\\n            StringBuilder curr = new StringBuilder();\\n            while(s.charAt(++i)!=\\')\\') curr.append(s.charAt(i));\\n            sb.append(map.getOrDefault(curr.toString(),\"?\"));\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3620082,
                "title": "python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        d=dict()\\n        for i in knowledge:\\n            d[i[0]]=i[1]\\n        res=\"\"\\n        f=0\\n        sb=\"\"\\n        for i in s:\\n            if(f==0):\\n                if(i==\\'(\\'):\\n                    f=1\\n                else:\\n                    res+=i\\n            else:\\n                if(i==\\')\\'):\\n                    f=0\\n                    if(sb in d.keys()):\\n                        res+=d.get(sb)\\n                    else:\\n                        res+=\"?\"\\n                    sb=\"\"\\n                else:\\n                    sb+=i\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        d=dict()\\n        for i in knowledge:\\n            d[i[0]]=i[1]\\n        res=\"\"\\n        f=0\\n        sb=\"\"\\n        for i in s:\\n            if(f==0):\\n                if(i==\\'(\\'):\\n                    f=1\\n                else:\\n                    res+=i\\n            else:\\n                if(i==\\')\\'):\\n                    f=0\\n                    if(sb in d.keys()):\\n                        res+=d.get(sb)\\n                    else:\\n                        res+=\"?\"\\n                    sb=\"\"\\n                else:\\n                    sb+=i\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3530841,
                "title": "python-easy-intuative-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        ms={}\\n        for i in knowledge:\\n            if i[0] in ms:\\n                ms[i[0]]=i[1]\\n            else:\\n                ms[i[0]]=i[1]\\n        res=\"\"\\n        temp=\"\"\\n        i=0\\n        while i!=len(s):\\n            if s[i]==\"(\":\\n                stack = []\\n                i+=1\\n                while s[i]!=\")\":\\n                    stack.append(s[i])\\n                    i+=1    \\n                while len(stack)!=0:\\n                    myString=stack.pop()\\n                    temp+=myString\\n                checkinmap=temp[::-1]\\n                if checkinmap in ms:\\n                    res+=ms[checkinmap]\\n                else:\\n                    res+=\"?\" \\n                i+=1          \\n                temp=\"\"\\n\\n            else:\\n                res+=s[i]\\n                i+=1        \\n        return res\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution:\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        ms={}\\n        for i in knowledge:\\n            if i[0] in ms:\\n                ms[i[0]]=i[1]\\n            else:\\n                ms[i[0]]=i[1]\\n        res=\"\"\\n        temp=\"\"\\n        i=0\\n        while i!=len(s):\\n            if s[i]==\"(\":\\n                stack = []\\n                i+=1\\n                while s[i]!=\")\":\\n                    stack.append(s[i])\\n                    i+=1    \\n                while len(stack)!=0:\\n                    myString=stack.pop()\\n                    temp+=myString\\n                checkinmap=temp[::-1]\\n                if checkinmap in ms:\\n                    res+=ms[checkinmap]\\n                else:\\n                    res+=\"?\" \\n                i+=1          \\n                temp=\"\"\\n\\n            else:\\n                res+=s[i]\\n                i+=1        \\n        return res\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529266,
                "title": "1807-python-solution-without-using-built-in-functions",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        t=0\\n        new=\\'\\'\\n        knowledge = {x:y for x,y in knowledge}\\n        for x in s:\\n            if x==\\'(\\':\\n                cur=\\'\\'\\n                t=1\\n                continue\\n            elif x==\\')\\':\\n                if cur in knowledge:\\n                    new += knowledge[cur]\\n                else:\\n                    new += \\'?\\'\\n                t=0\\n                continue\\n            if t: cur += x\\n            else: new+=x\\n        return new\\n\\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        t=0\\n        new=\\'\\'\\n        knowledge = {x:y for x,y in knowledge}\\n        for x in s:\\n            if x==\\'(\\':\\n                cur=\\'\\'\\n                t=1\\n                continue\\n            elif x==\\')\\':\\n                if cur in knowledge:\\n                    new += knowledge[cur]\\n                else:\\n                    new += \\'?\\'\\n                t=0\\n                continue\\n            if t: cur += x\\n            else: new+=x\\n        return new\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3489944,
                "title": "evaluate-the-bracket-pairs-of-a-string",
                "content": "------------------ Easy C++ Solution ------------------\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string evaluate(string s, vector<vector<string>>& knowledge) {\\n    string ans;\\n    unordered_map<string, string> map;\\n\\n    for (vector<string>& list : knowledge)\\n      map[\"(\" + list[0] + \")\"] = list[1];\\n\\n    for (int i = 0; i < s.length(); ++i) {\\n      char c = s[i];\\n      if (c == \\'(\\') {\\n        int j = s.find_first_of(\\')\\', i);\\n         string key = s.substr(i, j - i + 1);\\n        ans += map.count(key) ? map[key] : \"?\";\\n        i = j;\\n      } else {\\n        ans += c;\\n      }\\n    }\\n     return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string evaluate(string s, vector<vector<string>>& knowledge) {\\n    string ans;\\n    unordered_map<string, string> map;\\n\\n    for (vector<string>& list : knowledge)\\n      map[\"(\" + list[0] + \")\"] = list[1];\\n\\n    for (int i = 0; i < s.length(); ++i) {\\n      char c = s[i];\\n      if (c == \\'(\\') {\\n        int j = s.find_first_of(\\')\\', i);\\n         string key = s.substr(i, j - i + 1);\\n        ans += map.count(key) ? map[key] : \"?\";\\n        i = j;\\n      } else {\\n        ans += c;\\n      }\\n    }\\n     return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3477163,
                "title": "c-map",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string evaluate(string s, vector<vector<string>>& knowledge) {\\n        unordered_map<string, string> Map;\\n        for(vector<string> k: knowledge) {\\n            Map[k[0]] = k[1];\\n        }\\n        string ans = \"\", word = \"\"; \\n        bool bracket = false;\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s[i] == \\'(\\') {\\n                bracket = true;\\n                continue;\\n            }\\n            if(s[i] == \\')\\'){\\n                ans += (Map[word] == \"\")? \"?\": Map[word];\\n                bracket = false;\\n                word = \"\";\\n                continue;\\n            }\\n            if(!bracket) ans += s[i];\\n            else word += s[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string evaluate(string s, vector<vector<string>>& knowledge) {\\n        unordered_map<string, string> Map;\\n        for(vector<string> k: knowledge) {\\n            Map[k[0]] = k[1];\\n        }\\n        string ans = \"\", word = \"\"; \\n        bool bracket = false;\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s[i] == \\'(\\') {\\n                bracket = true;\\n                continue;\\n            }\\n            if(s[i] == \\')\\'){\\n                ans += (Map[word] == \"\")? \"?\": Map[word];\\n                bracket = false;\\n                word = \"\";\\n                continue;\\n            }\\n            if(!bracket) ans += s[i];\\n            else word += s[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471272,
                "title": "evaluate-the-bracket-pairs-of-a-string",
                "content": "# Code\\n```\\nclass Solution:\\n    def evaluate(self, s: str, k: List[List[str]]) -> str:\\n        dic = {}\\n        for i in k:\\n            dic[i[0]] = i[1]\\n        g = \"\"\\n        for i in range(len(s)):\\n            g+= s[i]\\n            if s[i]==\"(\":\\n                a = i\\n            elif s[i]==\")\":\\n                b = i\\n                if s[a+1:b] in dic:\\n                    print(dic[s[a+1:b]])\\n                    g = g.replace(s[a:b+1],dic[s[a+1:b]])\\n                else:\\n                    g = g.replace(s[a:b+1],\"?\")\\n        return g\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def evaluate(self, s: str, k: List[List[str]]) -> str:\\n        dic = {}\\n        for i in k:\\n            dic[i[0]] = i[1]\\n        g = \"\"\\n        for i in range(len(s)):\\n            g+= s[i]\\n            if s[i]==\"(\":\\n                a = i\\n            elif s[i]==\")\":\\n                b = i\\n                if s[a+1:b] in dic:\\n                    print(dic[s[a+1:b]])\\n                    g = g.replace(s[a:b+1],dic[s[a+1:b]])\\n                else:\\n                    g = g.replace(s[a:b+1],\"?\")\\n        return g\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464725,
                "title": "using-regular-expression-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @param {string[][]} knowledge\\n * @return {string}\\n */\\nvar evaluate = function(s, knowledge) {\\n    let obj={}\\n    for(var i=0;i<knowledge.length;i++){\\n        obj[knowledge[i][0]]=knowledge[i][1]\\n    }\\n    const keyArray=Object.keys(obj)\\n    keyArray.forEach(key=>{\\n        let regex = new RegExp(`\\\\\\\\(${key}\\\\\\\\)`, \"g\");\\n        s=s.replace(regex,obj[key])\\n    })\\n   if( s.indexOf(\\'(\\')<0){\\n       return s\\n   }\\n   s=s.replace(/\\\\(.*?\\\\)/g,\"?\")\\n   return s\\n\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {string[][]} knowledge\\n * @return {string}\\n */\\nvar evaluate = function(s, knowledge) {\\n    let obj={}\\n    for(var i=0;i<knowledge.length;i++){\\n        obj[knowledge[i][0]]=knowledge[i][1]\\n    }\\n    const keyArray=Object.keys(obj)\\n    keyArray.forEach(key=>{\\n        let regex = new RegExp(`\\\\\\\\(${key}\\\\\\\\)`, \"g\");\\n        s=s.replace(regex,obj[key])\\n    })\\n   if( s.indexOf(\\'(\\')<0){\\n       return s\\n   }\\n   s=s.replace(/\\\\(.*?\\\\)/g,\"?\")\\n   return s\\n\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3441912,
                "title": "python-solution-using-hash-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem requires replacing certain characters in a given string with their corresponding values from a knowledge base. One possible approach is to create a dictionary from the knowledge base, where each key in the dictionary corresponds to a character that needs to be replaced, and its corresponding value is the replacement string. We can then iterate through the input string and replace each key with its corresponding value from the dictionary.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe first create a dictionary hash_m from the knowledge base, where each key in the dictionary corresponds to a character that needs to be replaced, and its corresponding value is the replacement string. We then initialize an empty string ans to store the final output. We also set a flag flag to True to keep track of whether we are currently processing a key or a value in the input string.\\n\\nWe then iterate through each character in the input string s. If the flag is set to True, we check if the current character is an opening parenthesis. If it is, we set the key variable to an empty string and set the flag to False. Otherwise, we append the current character to the ans string.\\n\\nIf the flag is set to False, we check if the current character is a closing parenthesis. If it is, we check if the key is present in the hash_m dictionary. If it is, we append the corresponding value to the ans string. Otherwise, we append a question mark \\'?\\' to the ans string to indicate that the key is not present in the knowledge base. We then set the flag to True. If the current character is not a closing parenthesis, we append the current character to the key string.\\n\\nFinally, we return the ans string as the final output.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n), where n is the length of the input string s. We need to iterate through each character in the input string once.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(k), where k is the number of keys in the knowledge base. We need to create a dictionary to store the key-value pairs from the knowledge base.\\n\\n# Code\\n```\\nclass Solution:\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        hash_m = {}\\n        for item in knowledge:\\n            hash_m[item[0]]= item[1]\\n\\n        ans = \"\"\\n        flag=True\\n        # print(hash_m)\\n        for ind,char in enumerate(s):\\n            if flag == True:\\n                if char==\"(\":\\n                    key=\"\"\\n                    flag=False\\n                else:\\n                    ans+=char\\n\\n            else:\\n                if char==\")\":\\n                    if key not in hash_m:\\n                        ans+=\"?\"\\n                    else:\\n                        ans+=hash_m[key]\\n                    flag=True\\n                else:\\n                    key+=char\\n        return ans\\n            \\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        hash_m = {}\\n        for item in knowledge:\\n            hash_m[item[0]]= item[1]\\n\\n        ans = \"\"\\n        flag=True\\n        # print(hash_m)\\n        for ind,char in enumerate(s):\\n            if flag == True:\\n                if char==\"(\":\\n                    key=\"\"\\n                    flag=False\\n                else:\\n                    ans+=char\\n\\n            else:\\n                if char==\")\":\\n                    if key not in hash_m:\\n                        ans+=\"?\"\\n                    else:\\n                        ans+=hash_m[key]\\n                    flag=True\\n                else:\\n                    key+=char\\n        return ans\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434986,
                "title": "python3-dictionary",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def evaluate(self, s: str, k: List[List[str]]) -> str:\\n        var={}\\n        flag=False\\n        res=\\'\\'\\n        strr=\\'\\'\\n\\n        for i in range(len(k)):\\n            var[k[i][0]]=k[i][1]\\n\\n        for i in range(len(s)):\\n            if flag and s[i]!=\\')\\':\\n                strr+=s[i]\\n\\n            elif s[i]==\\'(\\':\\n                flag=True\\n\\n            elif s[i]==\\')\\':\\n                flag=False\\n                if strr in var:\\n                    res+=var[strr]\\n\\n                else:\\n                    res+=\\'?\\'\\n\\n                strr=\\'\\'\\n\\n            else:\\n                res+=s[i]\\n\\n        return res\\n\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def evaluate(self, s: str, k: List[List[str]]) -> str:\\n        var={}\\n        flag=False\\n        res=\\'\\'\\n        strr=\\'\\'\\n\\n        for i in range(len(k)):\\n            var[k[i][0]]=k[i][1]\\n\\n        for i in range(len(s)):\\n            if flag and s[i]!=\\')\\':\\n                strr+=s[i]\\n\\n            elif s[i]==\\'(\\':\\n                flag=True\\n\\n            elif s[i]==\\')\\':\\n                flag=False\\n                if strr in var:\\n                    res+=var[strr]\\n\\n                else:\\n                    res+=\\'?\\'\\n\\n                strr=\\'\\'\\n\\n            else:\\n                res+=s[i]\\n\\n        return res\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3429162,
                "title": "java-o-n-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n        Map<String, String> map = new HashMap<>();\\n        for (List<String> pair : knowledge) map.put(pair.get(0), pair.get(1));\\n        StringBuilder sb = new StringBuilder(), sbMain = new StringBuilder();\\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (c == \\'(\\') {\\n                while (s.charAt(++i) != \\')\\') sb.append(s.charAt(i));\\n                String v = map.get(sb.toString());\\n                sbMain.append(v == null ? \"?\" : v);\\n                sb.setLength(0);\\n                continue;\\n            }\\n            if (c != \\')\\') sbMain.append(c);\\n        }\\n        return sbMain.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n        Map<String, String> map = new HashMap<>();\\n        for (List<String> pair : knowledge) map.put(pair.get(0), pair.get(1));\\n        StringBuilder sb = new StringBuilder(), sbMain = new StringBuilder();\\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (c == \\'(\\') {\\n                while (s.charAt(++i) != \\')\\') sb.append(s.charAt(i));\\n                String v = map.get(sb.toString());\\n                sbMain.append(v == null ? \"?\" : v);\\n                sb.setLength(0);\\n                continue;\\n            }\\n            if (c != \\')\\') sbMain.append(c);\\n        }\\n        return sbMain.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3402475,
                "title": "java-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n        \\n         HashMap<String,String> map=new HashMap<>();\\n\\t\\t \\n        // add the all key or value in hashmap\\n\\t\\t\\n         for(int i=0;i<knowledge.size();i++){\\n             List<String> list=knowledge.get(i);\\n             map.put(list.get(0),list.get(1));\\n         }\\n        // it is for prepare ansewer\\n        String ans=\"\";\\n\\t\\t\\n        // it is used to find key in the given string\\n        String str=\"\";\\n        \\n        Stack<Character> st=new Stack<>();\\n\\t\\t\\n        for(int i=0;i<s.length();i++){\\n            char ch=s.charAt(i);\\n            // it is check the all possible combination\\n            if(ch==\\'(\\'){\\n                st.push(ch);\\n            }\\n            else if(st.size()>0 && ch!=\\')\\'){\\n                str +=ch;\\n            }\\n            else if(ch==\\')\\'){\\n                 if(map.containsKey(str)){\\n                     ans +=map.get(str);\\n                 }\\n                else{\\n                   ans +=\\'?\\'; \\n                }\\n                str=\"\";\\n                st.pop();\\n            }\\n            else{\\n                ans +=ch;\\n            }\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n        \\n         HashMap<String,String> map=new HashMap<>();\\n\\t\\t \\n        // add the all key or value in hashmap\\n\\t\\t\\n         for(int i=0;i<knowledge.size();i++){\\n             List<String> list=knowledge.get(i);\\n             map.put(list.get(0),list.get(1));\\n         }\\n        // it is for prepare ansewer\\n        String ans=\"\";\\n\\t\\t\\n        // it is used to find key in the given string\\n        String str=\"\";\\n        \\n        Stack<Character> st=new Stack<>();\\n\\t\\t\\n        for(int i=0;i<s.length();i++){\\n            char ch=s.charAt(i);\\n            // it is check the all possible combination\\n            if(ch==\\'(\\'){\\n                st.push(ch);\\n            }\\n            else if(st.size()>0 && ch!=\\')\\'){\\n                str +=ch;\\n            }\\n            else if(ch==\\')\\'){\\n                 if(map.containsKey(str)){\\n                     ans +=map.get(str);\\n                 }\\n                else{\\n                   ans +=\\'?\\'; \\n                }\\n                str=\"\";\\n                st.pop();\\n            }\\n            else{\\n                ans +=ch;\\n            }\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3401048,
                "title": "simple-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string evaluate(string s, vector<vector<string>>& knowledge) {\\n        map<string , string> mp;\\n\\n        for(int i=0 ; i<knowledge.size() ; i++) mp[knowledge[i][0]] = knowledge[i][1];\\n\\n        bool on = false;\\n        string curr = \"\";\\n\\n        string ans = \"\";\\n\\n        for(int i= 0 ; i<s.size() ; i++){\\n            if(s[i]==\\'(\\'){\\n                on = true;\\n            }\\n            else if(on and s[i]!=\\')\\'){\\n                curr += s[i];\\n            }\\n            else if(s[i]==\\')\\'){\\n                string temp = \"?\";\\n                if(mp.find(curr)!=mp.end()){\\n                    temp = mp[curr];\\n                }\\n                ans += temp;\\n                on = false;\\n                curr = \"\";\\n            }\\n            else{\\n                ans += s[i];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string evaluate(string s, vector<vector<string>>& knowledge) {\\n        map<string , string> mp;\\n\\n        for(int i=0 ; i<knowledge.size() ; i++) mp[knowledge[i][0]] = knowledge[i][1];\\n\\n        bool on = false;\\n        string curr = \"\";\\n\\n        string ans = \"\";\\n\\n        for(int i= 0 ; i<s.size() ; i++){\\n            if(s[i]==\\'(\\'){\\n                on = true;\\n            }\\n            else if(on and s[i]!=\\')\\'){\\n                curr += s[i];\\n            }\\n            else if(s[i]==\\')\\'){\\n                string temp = \"?\";\\n                if(mp.find(curr)!=mp.end()){\\n                    temp = mp[curr];\\n                }\\n                ans += temp;\\n                on = false;\\n                curr = \"\";\\n            }\\n            else{\\n                ans += s[i];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351048,
                "title": "using-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n        HashMap<String,String> hm = new HashMap<>();\\n        \\n        for(int i=0; i<knowledge.size(); i++){\\n            hm.put(knowledge.get(i).get(0),knowledge.get(i).get(1));\\n        }\\n\\n        int start = -1;\\n        int end = -1;\\n\\n        StringBuilder sb = new StringBuilder();\\n\\n        for(int i=0; i<s.length(); i++){\\n            if(s.charAt(i)==\\'(\\'){\\n                start=i;\\n            }\\n\\n            if(start == -1){\\n                sb.append(s.charAt(i));\\n            }\\n\\n            if(s.charAt(i)==\\')\\'){\\n                end=i;\\n                sb.append(hm.getOrDefault(s.substring(start+1,end),\"?\"));\\n                start=-1;\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n        HashMap<String,String> hm = new HashMap<>();\\n        \\n        for(int i=0; i<knowledge.size(); i++){\\n            hm.put(knowledge.get(i).get(0),knowledge.get(i).get(1));\\n        }\\n\\n        int start = -1;\\n        int end = -1;\\n\\n        StringBuilder sb = new StringBuilder();\\n\\n        for(int i=0; i<s.length(); i++){\\n            if(s.charAt(i)==\\'(\\'){\\n                start=i;\\n            }\\n\\n            if(start == -1){\\n                sb.append(s.charAt(i));\\n            }\\n\\n            if(s.charAt(i)==\\')\\'){\\n                end=i;\\n                sb.append(hm.getOrDefault(s.substring(start+1,end),\"?\"));\\n                start=-1;\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349114,
                "title": "cpp-using-stack-and-hashtable",
                "content": "![UPvote.jpg](https://assets.leetcode.com/users/images/7801fca5-75f8-4644-89b2-865a76aaba91_1679944159.0523555.jpeg)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string evaluate(string s, vector<vector<string>>& knowledge) {\\n        unordered_map<string,string>m;\\n        for(int i=0;i<knowledge.size();i++){\\n            m[knowledge[i][0]] = knowledge[i][1];\\n        }\\n        string str;\\n        stack<char>st;\\n        string demo;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\'){\\n                st.push(s[i]);\\n            }\\n            else if(!st.empty() && st.top()==\\'(\\' && s[i]==\\')\\'){\\n                auto it = m.find(demo);\\n                if(it==m.end()) str += \\'?\\';\\n                else str += m[demo];\\n                demo.clear();\\n                st.pop();\\n            }\\n            else if(!st.empty() && st.top() == \\'(\\' && s[i]!=\\')\\'){\\n                demo += s[i];\\n            }\\n            else{\\n                str += s[i];\\n            }\\n        }\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string evaluate(string s, vector<vector<string>>& knowledge) {\\n        unordered_map<string,string>m;\\n        for(int i=0;i<knowledge.size();i++){\\n            m[knowledge[i][0]] = knowledge[i][1];\\n        }\\n        string str;\\n        stack<char>st;\\n        string demo;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\'){\\n                st.push(s[i]);\\n            }\\n            else if(!st.empty() && st.top()==\\'(\\' && s[i]==\\')\\'){\\n                auto it = m.find(demo);\\n                if(it==m.end()) str += \\'?\\';\\n                else str += m[demo];\\n                demo.clear();\\n                st.pop();\\n            }\\n            else if(!st.empty() && st.top() == \\'(\\' && s[i]!=\\')\\'){\\n                demo += s[i];\\n            }\\n            else{\\n                str += s[i];\\n            }\\n        }\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345880,
                "title": "java-soln-hashmap",
                "content": "```\\nclass Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n        Map<String, String> knowledgeMap = new HashMap<>();\\n        for(List<String> pair : knowledge) {\\n            knowledgeMap.put(pair.get(0), pair.get(1));\\n        }\\n        \\n        int n = s.length();\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < n; i++) {\\n            while(s.charAt(i) == \\'(\\') {\\n                int j = i;\\n                while(s.charAt(j) != \\')\\') {\\n                    j++;\\n                }\\n                String key = s.substring(i+1, j);\\n                sb.append(knowledgeMap.getOrDefault(key, \\'?\\'));\\n                i = j + 1;\\n                if(i >= n) break;\\n            }\\n            if(i >= n) break;\\n            sb.append(s.charAt(i));\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n        Map<String, String> knowledgeMap = new HashMap<>();\\n        for(List<String> pair : knowledge) {\\n            knowledgeMap.put(pair.get(0), pair.get(1));\\n        }\\n        \\n        int n = s.length();\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < n; i++) {\\n            while(s.charAt(i) == \\'(\\') {\\n                int j = i;\\n                while(s.charAt(j) != \\')\\') {\\n                    j++;\\n                }\\n                String key = s.substring(i+1, j);\\n                sb.append(knowledgeMap.getOrDefault(key, \\'?\\'));\\n                i = j + 1;\\n                if(i >= n) break;\\n            }\\n            if(i >= n) break;\\n            sb.append(s.charAt(i));\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341752,
                "title": "python-solution-87-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        hash_map = {l[0]: l[1] for l in knowledge}\\n        result = []\\n        i = 0\\n        while i < len(s):\\n            if s[i] == \"(\":\\n                j = s.find(\")\", i)\\n                if j == -1:\\n                    # if the closing bracket is not found, append the remaining substring and exit\\n                    result.append(s[i:])\\n                    break\\n                result.append(s[i:j + 1])  # append the substring between brackets including the brackets\\n                i = j + 1\\n            else:\\n                j = s.find(\"(\", i)\\n                if j == -1:\\n                    result.append(s[i:])  # append the remaining substring and exit\\n                    break\\n                result.append(s[i:j])  # append the substring outside brackets\\n                i = j\\n\\n        for idx, char in enumerate(result):\\n            if char[0] == \"(\":\\n                result[idx] = hash_map.get(char[1:-1], \"?\")\\n        return \"\".join(result)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        hash_map = {l[0]: l[1] for l in knowledge}\\n        result = []\\n        i = 0\\n        while i < len(s):\\n            if s[i] == \"(\":\\n                j = s.find(\")\", i)\\n                if j == -1:\\n                    # if the closing bracket is not found, append the remaining substring and exit\\n                    result.append(s[i:])\\n                    break\\n                result.append(s[i:j + 1])  # append the substring between brackets including the brackets\\n                i = j + 1\\n            else:\\n                j = s.find(\"(\", i)\\n                if j == -1:\\n                    result.append(s[i:])  # append the remaining substring and exit\\n                    break\\n                result.append(s[i:j])  # append the substring outside brackets\\n                i = j\\n\\n        for idx, char in enumerate(result):\\n            if char[0] == \"(\":\\n                result[idx] = hash_map.get(char[1:-1], \"?\")\\n        return \"\".join(result)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3338586,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    string evaluate(string s, vector<vector<string>>& knowledge) {\\n        unordered_map<string, string>Change ;\\n        for(auto& k : knowledge)\\n            Change[k[0]] = k[1] ;\\n        string ret ;\\n        int i = 0 ;\\n        int n = s.size() ;\\n        while( i < n ){\\n            if(s[i] >= \\'a\\' && s[i] <= \\'z\\'){\\n                ret.push_back(s[i]) ;\\n                i++ ;\\n                continue ;\\n            }\\n            if(s[i] == \\'(\\'){\\n                int j ;\\n                for(j = i+1; j < n; j++){\\n                    if(s[j] == \\')\\')\\n                        break ;\\n                }\\n                string str = s.substr(i+1, j-i-1) ;\\n                if(Change.find(str) == Change.end())\\n                    ret += \"?\" ;\\n                else\\n                    ret += Change[str] ;\\n                i = j+1 ;\\n            }\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string evaluate(string s, vector<vector<string>>& knowledge) {\\n        unordered_map<string, string>Change ;\\n        for(auto& k : knowledge)\\n            Change[k[0]] = k[1] ;\\n        string ret ;\\n        int i = 0 ;\\n        int n = s.size() ;\\n        while( i < n ){\\n            if(s[i] >= \\'a\\' && s[i] <= \\'z\\'){\\n                ret.push_back(s[i]) ;\\n                i++ ;\\n                continue ;\\n            }\\n            if(s[i] == \\'(\\'){\\n                int j ;\\n                for(j = i+1; j < n; j++){\\n                    if(s[j] == \\')\\')\\n                        break ;\\n                }\\n                string str = s.substr(i+1, j-i-1) ;\\n                if(Change.find(str) == Change.end())\\n                    ret += \"?\" ;\\n                else\\n                    ret += Change[str] ;\\n                i = j+1 ;\\n            }\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3297778,
                "title": "python3-beats-98-29",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        dic={}\\n        for i in knowledge:\\n            dic[i[0]]=i[1]\\n        go=False\\n        check=\"\"\\n        res=\"\"\\n        for i in s:\\n            if i==\")\":\\n                go=False\\n                if check in dic:\\n                    res+=dic[check]\\n                else:\\n                    res+=\"?\"\\n                check=\"\"\\n                continue\\n            elif i==\"(\":\\n                go=True\\n                continue\\n            if go:\\n                check+=i\\n            else:\\n                res+=i\\n        return res\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        dic={}\\n        for i in knowledge:\\n            dic[i[0]]=i[1]\\n        go=False\\n        check=\"\"\\n        res=\"\"\\n        for i in s:\\n            if i==\")\":\\n                go=False\\n                if check in dic:\\n                    res+=dic[check]\\n                else:\\n                    res+=\"?\"\\n                check=\"\"\\n                continue\\n            elif i==\"(\":\\n                go=True\\n                continue\\n            if go:\\n                check+=i\\n            else:\\n                res+=i\\n        return res\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3289133,
                "title": "golang-100-fastest-139ms",
                "content": "![image.png](https://assets.leetcode.com/users/images/5a134f48-c792-4726-b08b-6aace672de3b_1678640296.501876.png)\\n\\n```\\nfunc evaluate(s string, knowledge [][]string) string {\\n var sb,key strings.Builder    \\n set := map[string]string{}\\n for _,v := range knowledge {\\n     set[v[0]] = v[1]\\n }\\n \\n for i := 0; i < len(s); i++ {\\n     if s[i] == \\'(\\'  {  \\n         for i++ ; s[i] != \\')\\'; i++ {\\n            key.WriteByte(s[i])\\n         }\\n         if _, ok := set[key.String()]; !ok {\\n                set[key.String()] = \"?\"\\n            }\\n            sb.WriteString(set[key.String()]); \\n            key.Reset()\\n            continue\\n    }\\n    sb.WriteByte(s[i])\\n\\n}\\n         \\nreturn sb.String()\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc evaluate(s string, knowledge [][]string) string {\\n var sb,key strings.Builder    \\n set := map[string]string{}\\n for _,v := range knowledge {\\n     set[v[0]] = v[1]\\n }\\n \\n for i := 0; i < len(s); i++ {\\n     if s[i] == \\'(\\'  {  \\n         for i++ ; s[i] != \\')\\'; i++ {\\n            key.WriteByte(s[i])\\n         }\\n         if _, ok := set[key.String()]; !ok {\\n                set[key.String()] = \"?\"\\n            }\\n            sb.WriteString(set[key.String()]); \\n            key.Reset()\\n            continue\\n    }\\n    sb.WriteByte(s[i])\\n\\n}\\n         \\nreturn sb.String()\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3281868,
                "title": "python3-good-enough",
                "content": "``` Python3 []\\nclass Solution:\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        mapping = {x:y for x,y in knowledge}\\n        final = []\\n\\n        current = None\\n        for i in range(len(s)):\\n            if not current:\\n                if s[i] == \\'(\\':\\n                    current = s[i]\\n                else:\\n                    final.append(s[i])\\n            else:\\n                if s[i] == \\')\\':\\n                    final.append(mapping.get(current[1:], \\'?\\'))\\n                    current = None\\n                else:\\n                    current += s[i]\\n        \\n        return \\'\\'.join(final)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "``` Python3 []\\nclass Solution:\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        mapping = {x:y for x,y in knowledge}\\n        final = []\\n\\n        current = None\\n        for i in range(len(s)):\\n            if not current:\\n                if s[i] == \\'(\\':\\n                    current = s[i]\\n                else:\\n                    final.append(s[i])\\n            else:\\n                if s[i] == \\')\\':\\n                    final.append(mapping.get(current[1:], \\'?\\'))\\n                    current = None\\n                else:\\n                    current += s[i]\\n        \\n        return \\'\\'.join(final)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3278866,
                "title": "java-brute-force-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n        StringBuilder sb=new StringBuilder();\\n       \\n        Map<String, String> map = new HashMap<>();\\n        knowledge.forEach(kv -> map.put(kv.get(0), kv.get(1)));\\n        for(int i=0;i<s.length();i++){\\n            \\n            \\n        if(s.charAt(i)==\\'(\\'){\\n             StringBuilder key=new StringBuilder();\\n                while(++i<s.length()&&s.charAt(i)!=\\')\\'){\\n                   key.append(s.charAt(i)); \\n                    \\n                }\\n                 sb.append(map.getOrDefault(key.toString(),\"?\"));\\n                \\n        }        \\n        else{\\n            sb.append(s.charAt(i));\\n        }\\n\\n\\n\\n\\n\\n\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n        StringBuilder sb=new StringBuilder();\\n       \\n        Map<String, String> map = new HashMap<>();\\n        knowledge.forEach(kv -> map.put(kv.get(0), kv.get(1)));\\n        for(int i=0;i<s.length();i++){\\n            \\n            \\n        if(s.charAt(i)==\\'(\\'){\\n             StringBuilder key=new StringBuilder();\\n                while(++i<s.length()&&s.charAt(i)!=\\')\\'){\\n                   key.append(s.charAt(i)); \\n                    \\n                }\\n                 sb.append(map.getOrDefault(key.toString(),\"?\"));\\n                \\n        }        \\n        else{\\n            sb.append(s.charAt(i));\\n        }\\n\\n\\n\\n\\n\\n\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3273841,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func evaluate(_ s: String, _ k: [[String]]) -> String {\\n\\n        let keys = k.reduce(into: [String: String]()) { $0[$1[0]] = $1[1] }\\n\\n        var words = s\\n            .components(separatedBy: \"(\")\\n            .flatMap { $0.components(separatedBy: \")\") }\\n        \\n        for i in stride(from: 1, to: words.count, by: 2) {\\n            words[i] = keys[words[i]] ?? \"?\"\\n        }\\n\\n        return words.joined()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func evaluate(_ s: String, _ k: [[String]]) -> String {\\n\\n        let keys = k.reduce(into: [String: String]()) { $0[$1[0]] = $1[1] }\\n\\n        var words = s\\n            .components(separatedBy: \"(\")\\n            .flatMap { $0.components(separatedBy: \")\") }\\n        \\n        for i in stride(from: 1, to: words.count, by: 2) {\\n            words[i] = keys[words[i]] ?? \"?\"\\n        }\\n\\n        return words.joined()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259307,
                "title": "java-hashmap",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n        HashMap<String,String> map = new HashMap();\\n\\n        for(List<String> list: knowledge){\\n            map.put(list.get(0),list.get(1));\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)!=\\'(\\'){\\n                sb.append(s.charAt(i));\\n            }else if(s.charAt(i)==\\'(\\'){\\n                int start=i+1;\\n                while(i<s.length() && s.charAt(i)!=\\')\\'){\\n                    i++;\\n                }\\n                sb.append(map.getOrDefault(s.substring(start,i),\"?\"));\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n\\n/*\\n\\n*/\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n        HashMap<String,String> map = new HashMap();\\n\\n        for(List<String> list: knowledge){\\n            map.put(list.get(0),list.get(1));\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)!=\\'(\\'){\\n                sb.append(s.charAt(i));\\n            }else if(s.charAt(i)==\\'(\\'){\\n                int start=i+1;\\n                while(i<s.length() && s.charAt(i)!=\\')\\'){\\n                    i++;\\n                }\\n                sb.append(map.getOrDefault(s.substring(start,i),\"?\"));\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n\\n/*\\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3237953,
                "title": "javascript-logic",
                "content": "# Code\\n```\\n// O(n)\\nvar evaluate = function(s, knowledge) {\\n    const arr = s.split(\\'\\');\\n    const map = {};\\n    for (let [a, b] of knowledge) {\\n        map[a] = b;\\n    }\\n    let str = \\'\\';\\n    let l = -1;\\n    let key = \\'\\';\\n    for (let i = 0; i < arr.length; i++) {\\n        if (arr[i] === \\'(\\') {\\n            l = i;\\n            continue;\\n        }\\n        if (arr[i] === \\')\\') {\\n            str += map[key] || \\'?\\'\\n            l = -1;\\n            key = \\'\\';\\n            continue;\\n        }\\n        if (l === -1) str += arr[i];\\n        else key += arr[i];\\n    }\\n    return str;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// O(n)\\nvar evaluate = function(s, knowledge) {\\n    const arr = s.split(\\'\\');\\n    const map = {};\\n    for (let [a, b] of knowledge) {\\n        map[a] = b;\\n    }\\n    let str = \\'\\';\\n    let l = -1;\\n    let key = \\'\\';\\n    for (let i = 0; i < arr.length; i++) {\\n        if (arr[i] === \\'(\\') {\\n            l = i;\\n            continue;\\n        }\\n        if (arr[i] === \\')\\') {\\n            str += map[key] || \\'?\\'\\n            l = -1;\\n            key = \\'\\';\\n            continue;\\n        }\\n        if (l === -1) str += arr[i];\\n        else key += arr[i];\\n    }\\n    return str;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3230528,
                "title": "very-easy-solution-with-comments-beats-99-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- go through string, if we see \\'(\\', record the key until \\')\\'; look for corresponding value of this keyto insert into res\\n- otherwise if we see regular characters, they are not in the bracket, so just insert current character into res\\n# Approach for O(n)\\n<!-- Describe your approach to solving the problem. -->\\nbuild a hash table for knowledge, for fast key val lookup.\\n\\n# Complexity\\n- Time complexity: O(n) for traversing twice\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) for hash table\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string evaluate(string s, vector<vector<string>>& knowledge) {\\n        // build a hash table for knowledge. \\n        unordered_map<string, string> lookup;\\n        for(const auto& pair : knowledge){\\n            lookup[pair[0]]=pair[1];\\n        }\\n        string res=\"\";\\n        // go through s, if see \\'(\\', record the key until \\')\\', look for corresponding value to insert into res\\n        // otherwise just insert current character into res\\n        for(int i=0; i<s.size(); i++){\\n            // see (\\n            if(s[i]==\\'(\\'){\\n                i++;\\n                string key=\"\";\\n                while(s[i]!=\\')\\'){ // see \\'(\\', record the key until \\')\\'\\n                    key+=s[i];\\n                    i++;\\n                }\\n                if(lookup.count(key)){ //look for corresponding value to insert into res\\n                    res+=lookup[key];\\n                }else{\\n                    res+=\"?\";\\n                }\\n            }\\n            \\n            // normal character\\n            else{\\n                res+=s[i];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string evaluate(string s, vector<vector<string>>& knowledge) {\\n        // build a hash table for knowledge. \\n        unordered_map<string, string> lookup;\\n        for(const auto& pair : knowledge){\\n            lookup[pair[0]]=pair[1];\\n        }\\n        string res=\"\";\\n        // go through s, if see \\'(\\', record the key until \\')\\', look for corresponding value to insert into res\\n        // otherwise just insert current character into res\\n        for(int i=0; i<s.size(); i++){\\n            // see (\\n            if(s[i]==\\'(\\'){\\n                i++;\\n                string key=\"\";\\n                while(s[i]!=\\')\\'){ // see \\'(\\', record the key until \\')\\'\\n                    key+=s[i];\\n                    i++;\\n                }\\n                if(lookup.count(key)){ //look for corresponding value to insert into res\\n                    res+=lookup[key];\\n                }else{\\n                    res+=\"?\";\\n                }\\n            }\\n            \\n            // normal character\\n            else{\\n                res+=s[i];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3213642,
                "title": "short-implementation",
                "content": "# Intuition\\nI tried to solve it with regular expression and with a `Map`. I used a `Map`, because it is much more performant than an `object` (`Record` also is an `object`)\\n\\n# Approach\\nI used the Map, even though it probably is not more performant in this example than an object (or Record). The regex is put into groups, to easily filter out the brackets.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction evaluate(s: string, knowledge: string[][]): string {\\n  const knowledgeMap = new Map<string, string>(Object.entries(Object.fromEntries(knowledge)));\\n\\n  const regex = /(\\\\()(.*?)(\\\\))/g;\\n  const matches = s.matchAll(regex);\\n\\n  for (const match of [...matches]) s = s.replace(match[0], knowledgeMap.get(match[2]) ?? \\'?\\')\\n\\n  return s;\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction evaluate(s: string, knowledge: string[][]): string {\\n  const knowledgeMap = new Map<string, string>(Object.entries(Object.fromEntries(knowledge)));\\n\\n  const regex = /(\\\\()(.*?)(\\\\))/g;\\n  const matches = s.matchAll(regex);\\n\\n  for (const match of [...matches]) s = s.replace(match[0], knowledgeMap.get(match[2]) ?? \\'?\\')\\n\\n  return s;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3207317,
                "title": "c-map",
                "content": "```\\nclass Solution {\\npublic:\\n    string evaluate(string s, vector<vector<string>>& knowledge) {\\n        unordered_map<string,string> m;\\n        for (auto& v : knowledge) m[v[0]] = v[1];\\n        string ans = \"\";\\n        for (int i = 0; i < s.size(); ++i){\\n            if (s[i] == \\'(\\'){\\n                string cur = \"\";\\n                while (s[++i] != \\')\\') cur += s[i];\\n                if (m.find(cur) != m.end()) ans += m[cur];\\n                else ans += \\'?\\';\\n            }\\n            else ans += s[i];\\n        }\\n            return ans;\\n        }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string evaluate(string s, vector<vector<string>>& knowledge) {\\n        unordered_map<string,string> m;\\n        for (auto& v : knowledge) m[v[0]] = v[1];\\n        string ans = \"\";\\n        for (int i = 0; i < s.size(); ++i){\\n            if (s[i] == \\'(\\'){\\n                string cur = \"\";\\n                while (s[++i] != \\')\\') cur += s[i];\\n                if (m.find(cur) != m.end()) ans += m[cur];\\n                else ans += \\'?\\';\\n            }\\n            else ans += s[i];\\n        }\\n            return ans;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3196606,
                "title": "dict-string-easy",
                "content": "# Code\\n```\\nclass Solution:\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        #make dictionary of the given list\\n        knowledge = dict(knowledge)\\n        #res is list to store index values  \\n        res=[]\\n        #starting index \\n        idx = None\\n        #enumerate given string s\\n        # if char of s is \"(\" then increase the index \\n        # if char of s is \")\" then we have found the key\\n        # replace the key with value \\n        # if value is not present then replace the key with \"?\"\\n        for i, char in enumerate(s):\\n            if char == \\'(\\': \\n                idx = i + 1\\n            elif char == \\')\\':\\n                res.append(knowledge.get(s[idx:i], \\'?\\'))\\n                idx = None\\n            elif idx is None: \\n                res.append(char)\\n        #return the answer in the form of string\\n        return \\'\\'.join(res)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        #make dictionary of the given list\\n        knowledge = dict(knowledge)\\n        #res is list to store index values  \\n        res=[]\\n        #starting index \\n        idx = None\\n        #enumerate given string s\\n        # if char of s is \"(\" then increase the index \\n        # if char of s is \")\" then we have found the key\\n        # replace the key with value \\n        # if value is not present then replace the key with \"?\"\\n        for i, char in enumerate(s):\\n            if char == \\'(\\': \\n                idx = i + 1\\n            elif char == \\')\\':\\n                res.append(knowledge.get(s[idx:i], \\'?\\'))\\n                idx = None\\n            elif idx is None: \\n                res.append(char)\\n        #return the answer in the form of string\\n        return \\'\\'.join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174409,
                "title": "simple-java-solution-using-hashmap",
                "content": "# Complexity\\n- Time complexity:\\nO(M + N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n        Map<String, String> map = new HashMap<>();\\n        for (List<String> list : knowledge) {\\n            map.put(list.get(0), list.get(1));\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < s.length(); ) {\\n            if (s.charAt(i) == \\'(\\') {\\n                int end = s.indexOf(\\')\\', i);\\n                String key = s.substring(i + 1, end);\\n                if (map.containsKey(key)) {\\n                    sb.append(map.get(key));\\n                } else {\\n                    sb.append(\\'?\\');\\n                }\\n                i = end + 1;\\n            } else {\\n                sb.append(s.charAt(i));\\n                i++;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n        Map<String, String> map = new HashMap<>();\\n        for (List<String> list : knowledge) {\\n            map.put(list.get(0), list.get(1));\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < s.length(); ) {\\n            if (s.charAt(i) == \\'(\\') {\\n                int end = s.indexOf(\\')\\', i);\\n                String key = s.substring(i + 1, end);\\n                if (map.containsKey(key)) {\\n                    sb.append(map.get(key));\\n                } else {\\n                    sb.append(\\'?\\');\\n                }\\n                i = end + 1;\\n            } else {\\n                sb.append(s.charAt(i));\\n                i++;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3168358,
                "title": "simple-case-handling",
                "content": "\\n# Code\\n```\\nstring evaluate(string s, vector<vector<string>>& knowledge) {\\n    unordered_map<string, string> mp;\\n    \\n    for (vector<string> vec : knowledge) {\\n        mp[vec[0]] = vec[1];\\n    }\\n\\n    string ans = \"\";\\n\\n    for (int i = 0; i < s.size();) {\\n        string temp = \"\";\\n        if (s[i] == \\'(\\') {\\n            i++;\\n            while (s[i] != \\')\\') {\\n                temp += s[i];\\n                i++;\\n            }\\n            i++;\\n            mp.count(temp) ? ans += mp[temp] : ans += \"?\";\\n            continue;\\n        }\\n        ans += s[i++];\\n    }\\n\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstring evaluate(string s, vector<vector<string>>& knowledge) {\\n    unordered_map<string, string> mp;\\n    \\n    for (vector<string> vec : knowledge) {\\n        mp[vec[0]] = vec[1];\\n    }\\n\\n    string ans = \"\";\\n\\n    for (int i = 0; i < s.size();) {\\n        string temp = \"\";\\n        if (s[i] == \\'(\\') {\\n            i++;\\n            while (s[i] != \\')\\') {\\n                temp += s[i];\\n                i++;\\n            }\\n            i++;\\n            mp.count(temp) ? ans += mp[temp] : ans += \"?\";\\n            continue;\\n        }\\n        ans += s[i++];\\n    }\\n\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3153601,
                "title": "easy-c-solution-using-hashing",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n\\n    string evaluate(string s, vector<vector<string>>& k) {\\n        \\n        unordered_map<string,string>mpp;\\n\\n        for(auto &it : k) mpp[it[0]] = it[1];\\n\\n        string res = \"\";\\n        \\n        string temp;\\n\\n        bool flag = 0;\\n\\n        for(int i = 0; i < s.length(); ++i)\\n        {\\n           \\n           if(s[i] == \\'(\\') flag = 1;\\n           \\n           else if(s[i] == \\')\\')\\n           {\\n\\n               if(mpp[temp] == \"\") res += \"?\";\\n\\n               else res += mpp[temp];\\n\\n               flag = 0; temp = \"\";\\n           }\\n\\n           else if(flag == 1) temp.push_back(s[i]);\\n           \\n           else res.push_back(s[i]);\\n\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n\\n    string evaluate(string s, vector<vector<string>>& k) {\\n        \\n        unordered_map<string,string>mpp;\\n\\n        for(auto &it : k) mpp[it[0]] = it[1];\\n\\n        string res = \"\";\\n        \\n        string temp;\\n\\n        bool flag = 0;\\n\\n        for(int i = 0; i < s.length(); ++i)\\n        {\\n           \\n           if(s[i] == \\'(\\') flag = 1;\\n           \\n           else if(s[i] == \\')\\')\\n           {\\n\\n               if(mpp[temp] == \"\") res += \"?\";\\n\\n               else res += mpp[temp];\\n\\n               flag = 0; temp = \"\";\\n           }\\n\\n           else if(flag == 1) temp.push_back(s[i]);\\n           \\n           else res.push_back(s[i]);\\n\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3140867,
                "title": "python-super-simple",
                "content": "# Intuition\\nConvert knowledge array to dictionary for faster query.\\nUse brackets as delimiter to split string. \\nSplit everything with closing bracket, this will result in sections that consist of 2 parts one before and after opening bracket. Then just add up to result. If first part has anything add it up to result, second part use as query to dictionary and add up that to result too.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        known = defaultdict(lambda : \\'?\\')\\n        for k,v in knowledge: known[k] = v\\n        result, parts = \\'\\', s.split(\\')\\')\\n        for part in parts:\\n            if \\'(\\' not in part: result += part\\n            else:\\n                p1, p2 = part.split(\\'(\\')\\n                if p1: result += p1\\n                result += known[p2]\\n        return result\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\\n        known = defaultdict(lambda : \\'?\\')\\n        for k,v in knowledge: known[k] = v\\n        result, parts = \\'\\', s.split(\\')\\')\\n        for part in parts:\\n            if \\'(\\' not in part: result += part\\n            else:\\n                p1, p2 = part.split(\\'(\\')\\n                if p1: result += p1\\n                result += known[p2]\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3139109,
                "title": "java-easy-solution-using-hashmap-and-stringbuilder",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n        StringBuilder sb=new StringBuilder();\\n        HashMap<String,String> map=new HashMap<>();\\n        for(List<String> l:knowledge){\\n          String key=l.get(0);\\n         String value=l.get(1);\\n         map.put(key,value);\\n  }\\nfor(int i=0;i<s.length();i++){\\n    char ch=s.charAt(i);\\n  if(ch==\\'(\\'){\\n      int j=s.indexOf(\\')\\',i);\\n      System.out.println(j);\\n      sb.append(map.getOrDefault(s.substring(i+1,j),\"?\"));\\n        System.out.println(s.substring(i+1,j));\\n        i=j;\\n  }else{\\n      sb.append(s.charAt(i));\\n  }}\\nreturn sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String evaluate(String s, List<List<String>> knowledge) {\\n        StringBuilder sb=new StringBuilder();\\n        HashMap<String,String> map=new HashMap<>();\\n        for(List<String> l:knowledge){\\n          String key=l.get(0);\\n         String value=l.get(1);\\n         map.put(key,value);\\n  }\\nfor(int i=0;i<s.length();i++){\\n    char ch=s.charAt(i);\\n  if(ch==\\'(\\'){\\n      int j=s.indexOf(\\')\\',i);\\n      System.out.println(j);\\n      sb.append(map.getOrDefault(s.substring(i+1,j),\"?\"));\\n        System.out.println(s.substring(i+1,j));\\n        i=j;\\n  }else{\\n      sb.append(s.charAt(i));\\n  }}\\nreturn sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3093106,
                "title": "easy-understandable-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string evaluate(string s, vector<vector<string>>& knowledge) {\\n        unordered_map<string,string> mp;\\n        for(auto v: knowledge){\\n            mp[v[0]] = v[1];\\n        }\\n        string ans =\"\";\\n        for(int i=0;i<s.length();i++){\\n            if(s[i] == \\'(\\'){\\n                string key =\"\";\\n                i++;\\n                while(i < s.length() && s[i] != \\')\\'){\\n                    key.push_back(s[i]);\\n                    i++;\\n                }\\n                // cout << key << endl;\\n                if(mp.find(key) == mp.end()){\\n                    ans.push_back(\\'?\\');\\n                }\\n                else{\\n                    ans += mp[key];\\n                }\\n                continue;\\n            }\\n            ans.push_back(s[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string evaluate(string s, vector<vector<string>>& knowledge) {\\n        unordered_map<string,string> mp;\\n        for(auto v: knowledge){\\n            mp[v[0]] = v[1];\\n        }\\n        string ans =\"\";\\n        for(int i=0;i<s.length();i++){\\n            if(s[i] == \\'(\\'){\\n                string key =\"\";\\n                i++;\\n                while(i < s.length() && s[i] != \\')\\'){\\n                    key.push_back(s[i]);\\n                    i++;\\n                }\\n                // cout << key << endl;\\n                if(mp.find(key) == mp.end()){\\n                    ans.push_back(\\'?\\');\\n                }\\n                else{\\n                    ans += mp[key];\\n                }\\n                continue;\\n            }\\n            ans.push_back(s[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            }
        ],
        "discussions": [
            {
                "id": 1960725,
                "content": [
                    {
                        "username": "Jason-Law",
                        "content": "IMO, this should be easy."
                    },
                    {
                        "username": "summerblam",
                        "content": "Find it strange that the dictionary is not sorted in Map but a 2D array. "
                    },
                    {
                        "username": "kennyhml",
                        "content": "It encourages you to parse it into a dict yourself such as `data = {k: v for k, v in knowledge}`, because otherwise you will keep having to to $$O(n)$$ lookups rather than $$O(1)$$ (in return for extra space)\n\nEDIT: Before some smartass mentions that you can just do `data = dict(knowledge)` because it can just parse the lists structure itself, I know. I just prefer it to be more verbose + theyre the same in terms of efficiency."
                    },
                    {
                        "username": "longluo",
                        "content": "May be it\\'s the **Easiest** problem among the **Medium** problems."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Not the easiest but it\\'s not even challenging just straight forward approach"
                    }
                ]
            },
            {
                "id": 1818303,
                "content": [
                    {
                        "username": "Jason-Law",
                        "content": "IMO, this should be easy."
                    },
                    {
                        "username": "summerblam",
                        "content": "Find it strange that the dictionary is not sorted in Map but a 2D array. "
                    },
                    {
                        "username": "kennyhml",
                        "content": "It encourages you to parse it into a dict yourself such as `data = {k: v for k, v in knowledge}`, because otherwise you will keep having to to $$O(n)$$ lookups rather than $$O(1)$$ (in return for extra space)\n\nEDIT: Before some smartass mentions that you can just do `data = dict(knowledge)` because it can just parse the lists structure itself, I know. I just prefer it to be more verbose + theyre the same in terms of efficiency."
                    },
                    {
                        "username": "longluo",
                        "content": "May be it\\'s the **Easiest** problem among the **Medium** problems."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Not the easiest but it\\'s not even challenging just straight forward approach"
                    }
                ]
            },
            {
                "id": 1753744,
                "content": [
                    {
                        "username": "Jason-Law",
                        "content": "IMO, this should be easy."
                    },
                    {
                        "username": "summerblam",
                        "content": "Find it strange that the dictionary is not sorted in Map but a 2D array. "
                    },
                    {
                        "username": "kennyhml",
                        "content": "It encourages you to parse it into a dict yourself such as `data = {k: v for k, v in knowledge}`, because otherwise you will keep having to to $$O(n)$$ lookups rather than $$O(1)$$ (in return for extra space)\n\nEDIT: Before some smartass mentions that you can just do `data = dict(knowledge)` because it can just parse the lists structure itself, I know. I just prefer it to be more verbose + theyre the same in terms of efficiency."
                    },
                    {
                        "username": "longluo",
                        "content": "May be it\\'s the **Easiest** problem among the **Medium** problems."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Not the easiest but it\\'s not even challenging just straight forward approach"
                    }
                ]
            }
        ]
    }
]