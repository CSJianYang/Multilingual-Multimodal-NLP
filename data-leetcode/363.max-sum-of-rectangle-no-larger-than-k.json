[
    {
        "title": "Max Sum of Rectangle No Larger Than K",
        "question_content": "Given an m x n matrix matrix and an integer k, return the max sum of a rectangle in the matrix such that its sum is no larger than k.\nIt is guaranteed that there will be a rectangle with a sum no larger than k.\n&nbsp;\nExample 1:\n\nInput: matrix = [[1,0,1],[0,-2,3]], k = 2\nOutput: 2\nExplanation: Because the sum of the blue rectangle [[0, 1], [-2, 3]] is 2, and 2 is the max number no larger than k (k = 2).\n\nExample 2:\n\nInput: matrix = [[2,2,-1]], k = 3\nOutput: 3\n\n&nbsp;\nConstraints:\n\n\tm == matrix.length\n\tn == matrix[i].length\n\t1 <= m, n <= 100\n\t-100 <= matrix[i][j] <= 100\n\t-105 <= k <= 105\n\n&nbsp;\nFollow up: What if the number of rows is much larger than the number of columns?",
        "solutions": [
            {
                "id": 83599,
                "title": "accepted-c-codes-with-explanation-and-references",
                "content": "The naive solution is brute-force, which is O((mn)^2). In order to be more efficient, I tried something similar to Kadane's algorithm. The only difference is that here we have upper bound restriction K. Here's the easily understanding video link for the problem \"find the max sum rectangle in 2D array\": [Maximum Sum Rectangular Submatrix in Matrix dynamic programming/2D kadane][1] (Trust me, it's really easy and straightforward). \\n\\nOnce you are clear how to solve the above problem, the next step is to find the max sum no more than K in an array. This can be done within O(nlogn), and you can refer to this article: [max subarray sum no more than k][2].\\n\\nFor the solution below, I assume that the number of rows is larger than the number of columns. Thus in general time complexity is O[min(m,n)^2 * max(m,n) * log(max(m,n))], space O(max(m, n)).\\n\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        if (matrix.empty()) return 0;\\n        int row = matrix.size(), col = matrix[0].size(), res = INT_MIN;\\n        for (int l = 0; l < col; ++l) {\\n            vector<int> sums(row, 0);\\n            for (int r = l; r < col; ++r) {\\n                for (int i = 0; i < row; ++i) {\\n                    sums[i] += matrix[i][r];\\n                }\\n                \\n                // Find the max subarray no more than K \\n                set<int> accuSet;\\n                accuSet.insert(0);\\n                int curSum = 0, curMax = INT_MIN;\\n                for (int sum : sums) {\\n                    curSum += sum;\\n                    set<int>::iterator it = accuSet.lower_bound(curSum - k);\\n                    if (it != accuSet.end()) curMax = std::max(curMax, curSum - *it);\\n                    accuSet.insert(curSum);\\n                }\\n                res = std::max(res, curMax);\\n            }\\n        }\\n        return res;\\n    }\\n\\n  [1]: https://www.youtube.com/watch?v=yCQN096CwWM\\n  [2]: https://www.quora.com/Given-an-array-of-integers-A-and-an-integer-k-find-a-subarray-that-contains-the-largest-sum-subject-to-a-constraint-that-the-sum-is-less-than-k",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "The naive solution is brute-force, which is O((mn)^2). In order to be more efficient, I tried something similar to Kadane's algorithm. The only difference is that here we have upper bound restriction K. Here's the easily understanding video link for the problem \"find the max sum rectangle in 2D array\": [Maximum Sum Rectangular Submatrix in Matrix dynamic programming/2D kadane][1] (Trust me, it's really easy and straightforward). \\n\\nOnce you are clear how to solve the above problem, the next step is to find the max sum no more than K in an array. This can be done within O(nlogn), and you can refer to this article: [max subarray sum no more than k][2].\\n\\nFor the solution below, I assume that the number of rows is larger than the number of columns. Thus in general time complexity is O[min(m,n)^2 * max(m,n) * log(max(m,n))], space O(max(m, n)).\\n\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        if (matrix.empty()) return 0;\\n        int row = matrix.size(), col = matrix[0].size(), res = INT_MIN;\\n        for (int l = 0; l < col; ++l) {\\n            vector<int> sums(row, 0);\\n            for (int r = l; r < col; ++r) {\\n                for (int i = 0; i < row; ++i) {\\n                    sums[i] += matrix[i][r];\\n                }\\n                \\n                // Find the max subarray no more than K \\n                set<int> accuSet;\\n                accuSet.insert(0);\\n                int curSum = 0, curMax = INT_MIN;\\n                for (int sum : sums) {\\n                    curSum += sum;\\n                    set<int>::iterator it = accuSet.lower_bound(curSum - k);\\n                    if (it != accuSet.end()) curMax = std::max(curMax, curSum - *it);\\n                    accuSet.insert(curSum);\\n                }\\n                res = std::max(res, curMax);\\n            }\\n        }\\n        return res;\\n    }\\n\\n  [1]: https://www.youtube.com/watch?v=yCQN096CwWM\\n  [2]: https://www.quora.com/Given-an-array-of-integers-A-and-an-integer-k-find-a-subarray-that-contains-the-largest-sum-subject-to-a-constraint-that-the-sum-is-less-than-k",
                "codeTag": "Unknown"
            },
            {
                "id": 1313721,
                "title": "java-python-sub-problem-max-sum-of-subarray-no-larger-than-k-clean-concise",
                "content": "**Idea**\\n- Firstly, let solve this sub problem **Max Sum of Subarray No Larger Than K**, which is \"Given an array of N integers, find the maximum sum of subarray which is no larger than K\".\\n\\t- Iterating index `i` from left to right.\\n\\t- Calculate prefixSum so far, let name it `right`\\n\\t- Try to find the `left` prefixSum so that `right - left <= k` => `left >= right - k`.\\n\\t- We can use `TreeSet` (implemented as BST), and use `ceiling(x)` to find the least key greater than or equal to the given `x`. So `left = bst.ceiling(right-k)`.\\n\\t- If we found a valid `left`, then we update the answer by `ans = max(ans, right - left)`.\\n- Then we try all possible pairs of `(r1, r2)` of rows in the matrix, where `0 <= r1 <= r2 < m`. Make an array of `n` integer, where `arr[c] = sum(matrix[r1][c]...matrix[r2][c])`, then solve that sub problem.\\n\\n![image](https://assets.leetcode.com/users/images/c9e51580-0e29-4125-a4d2-2c921c72aea8_1625336085.6260538.png)\\n\\n**Similar problems**\\n- [1. Two Sum](https://leetcode.com/problems/two-sum/) -> Check HashMap solution, which uses idea of calculate `right` prefixSum so far and looking for `left` prefixSum in the HashMap.\\n- [85. Maximal Rectangle](https://leetcode.com/problems/maximal-rectangle/) -> Solve sub-matrix problems by solving sub-array problems.\\n\\n**Implementation**\\n<iframe src=\"https://leetcode.com/playground/FawcNpny/shared\" frameBorder=\"0\" width=\"100%\" height=\"600\"></iframe>\\n\\n**Complexity**\\n- Time: `O(M^2 * N * logN)`, where `M <= 100` is number of rows, `N <= 100` is number of columns in the matrix.\\n- Space: `O(N)`\\n\\nIf you think this post is useful, I\\'m happy if you **give a vote**. Any questions or discussions in this post are welcome! Thanks.",
                "solutionTags": [],
                "code": "**Idea**\\n- Firstly, let solve this sub problem **Max Sum of Subarray No Larger Than K**, which is \"Given an array of N integers, find the maximum sum of subarray which is no larger than K\".\\n\\t- Iterating index `i` from left to right.\\n\\t- Calculate prefixSum so far, let name it `right`\\n\\t- Try to find the `left` prefixSum so that `right - left <= k` => `left >= right - k`.\\n\\t- We can use `TreeSet` (implemented as BST), and use `ceiling(x)` to find the least key greater than or equal to the given `x`. So `left = bst.ceiling(right-k)`.\\n\\t- If we found a valid `left`, then we update the answer by `ans = max(ans, right - left)`.\\n- Then we try all possible pairs of `(r1, r2)` of rows in the matrix, where `0 <= r1 <= r2 < m`. Make an array of `n` integer, where `arr[c] = sum(matrix[r1][c]...matrix[r2][c])`, then solve that sub problem.\\n\\n![image](https://assets.leetcode.com/users/images/c9e51580-0e29-4125-a4d2-2c921c72aea8_1625336085.6260538.png)\\n\\n**Similar problems**\\n- [1. Two Sum](https://leetcode.com/problems/two-sum/) -> Check HashMap solution, which uses idea of calculate `right` prefixSum so far and looking for `left` prefixSum in the HashMap.\\n- [85. Maximal Rectangle](https://leetcode.com/problems/maximal-rectangle/) -> Solve sub-matrix problems by solving sub-array problems.\\n\\n**Implementation**\\n<iframe src=\"https://leetcode.com/playground/FawcNpny/shared\" frameBorder=\"0\" width=\"100%\" height=\"600\"></iframe>\\n\\n**Complexity**\\n- Time: `O(M^2 * N * logN)`, where `M <= 100` is number of rows, `N <= 100` is number of columns in the matrix.\\n- Space: `O(N)`\\n\\nIf you think this post is useful, I\\'m happy if you **give a vote**. Any questions or discussions in this post are welcome! Thanks.",
                "codeTag": "Unknown"
            },
            {
                "id": 851448,
                "title": "c-from-800-ms-to-50-ms",
                "content": "#### Intuition\\nPersonal observation: we spend all this time learning advanced data structures and algorithm. But the hardest problems seem to revolve around simple arrays and strings.\\n\\nThis is an interesting question that combines two (hard) subproblems:\\n1. Maximum Sum Rectangle, similar problems:\\n\\t- [85. Maximal Rectangle](https://leetcode.com/problems/maximal-rectangle/)\\n2. Max Subarray Sum Equals K; similar problems:\\n\\t- [560. Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/)\\n\\t- [862. Shortest Subarray with Sum at Least K](https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/)\\n\\nFor the first subproblem, the solution is to accumulate the sum of each row between columns `l` and `r`. Then, we can use the Kadane\\'s algorithm to find the maximum sum subarray for all those columns. Search for the Maximum Sum Rectangle problem on Youtube for video explanations.\\n\\nNow, we are not looking for just the maximum sum, but maximum sum less than `k`. You may be tempted to try a sliding window technique here, but the problem is that we can have negative numbers. For problem #560, we used a hash set to find a sum that equals to `k`. Here, we can use an ordered set and binary-search for a complement value. \\n\\n#### Base Solution\\nThis is the shortest solution, and it\\'s accepted with 800 ms runtime. \\n```cpp\\nint maxSumSubmatrix(vector<vector<int>>& m, int k) {\\n    int res = INT_MIN, rows = m.size(), cols = m[0].size();\\n    for (int l = 0; l < cols; ++l) {\\n        vector<int> sums(rows);\\n        for (int r = l; r < cols; ++r) {\\n            for (int i = 0; i < rows; ++i) \\n                sums[i] += m[i][r];\\n            set<int> s = {0};\\n            int run_sum = 0;\\n            for (int sum : sums) {\\n                run_sum += sum;\\n                auto it = s.lower_bound(run_sum - k);\\n                if (it != end(s))\\n                    res = max(res, run_sum - *it);\\n                s.insert(run_sum);\\n            }\\n        }\\n    }\\n    return res;\\n}\\n```\\n#### Optimization: Add Kadane\\nWe could add few optimizations: e.g. exit early if we found a sum that is equals to `k`. We could also check whether number of rows is less than number of columns, and flip the dimensions. In addition, we can precompute the prefix sum in the matrix, instead of creating and populating the `sums` array.\\n\\nHowever, the most noticeable optimization is to go back to the Kadane\\'s algorithm! We can compute the maximum rectangle sum in O(n). If the maximum sum rectangle sum is less or equal than `k`, we can skip the binary search phase completely. This improves the runtime from 800 ms to 50 ms.\\n\\n```cpp\\nint maxSumSubmatrix(vector<vector<int>>& m, int k) {\\n    int res = INT_MIN, rows = m.size(), cols = m[0].size();\\n    for (int l = 0; l < cols; ++l) {\\n        vector<int> sums(rows);\\n        for (int r = l; r < cols; ++r) {\\n            int kadane = 0, max_kadane = INT_MIN;\\n            for (int i = 0; i < rows; ++i) {\\n                sums[i] += m[i][r];\\n                kadane = max(kadane + sums[i], sums[i]);\\n                max_kadane = max(max_kadane, kadane);\\n            }\\n            if (max_kadane <= k) {\\n                res = max(res, max_kadane);\\n                continue;\\n            }\\n            set<int> s = {0};\\n            int run_sum = 0;\\n            for (int sum : sums) {\\n                run_sum += sum;\\n                auto it = s.lower_bound(run_sum - k);\\n                if (it != end(s))\\n                    res = max(res, run_sum - *it);\\n                s.insert(run_sum);\\n            }\\n        }\\n    }\\n    return res;\\n}  \\n```",
                "solutionTags": [],
                "code": "```cpp\\nint maxSumSubmatrix(vector<vector<int>>& m, int k) {\\n    int res = INT_MIN, rows = m.size(), cols = m[0].size();\\n    for (int l = 0; l < cols; ++l) {\\n        vector<int> sums(rows);\\n        for (int r = l; r < cols; ++r) {\\n            for (int i = 0; i < rows; ++i) \\n                sums[i] += m[i][r];\\n            set<int> s = {0};\\n            int run_sum = 0;\\n            for (int sum : sums) {\\n                run_sum += sum;\\n                auto it = s.lower_bound(run_sum - k);\\n                if (it != end(s))\\n                    res = max(res, run_sum - *it);\\n                s.insert(run_sum);\\n            }\\n        }\\n    }\\n    return res;\\n}\\n```\n```cpp\\nint maxSumSubmatrix(vector<vector<int>>& m, int k) {\\n    int res = INT_MIN, rows = m.size(), cols = m[0].size();\\n    for (int l = 0; l < cols; ++l) {\\n        vector<int> sums(rows);\\n        for (int r = l; r < cols; ++r) {\\n            int kadane = 0, max_kadane = INT_MIN;\\n            for (int i = 0; i < rows; ++i) {\\n                sums[i] += m[i][r];\\n                kadane = max(kadane + sums[i], sums[i]);\\n                max_kadane = max(max_kadane, kadane);\\n            }\\n            if (max_kadane <= k) {\\n                res = max(res, max_kadane);\\n                continue;\\n            }\\n            set<int> s = {0};\\n            int run_sum = 0;\\n            for (int sum : sums) {\\n                run_sum += sum;\\n                auto it = s.lower_bound(run_sum - k);\\n                if (it != end(s))\\n                    res = max(res, run_sum - *it);\\n                s.insert(run_sum);\\n            }\\n        }\\n    }\\n    return res;\\n}  \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 83597,
                "title": "java-binary-search-solution-time-complexity-min-m-n-2-max-m-n-log-max-m-n",
                "content": "\\n    /* first  consider the situation matrix is 1D\\n        we can save every sum of 0~i(0<=i<len) and binary search previous sum to find \\n        possible result for every index, time complexity is O(NlogN).\\n        so in 2D matrix, we can sum up all values from row i to row j and create a 1D array \\n        to use 1D array solution.\\n        If col number is less than row number, we can sum up all values from col i to col j \\n        then use 1D array solution.\\n    */\\n    public int maxSumSubmatrix(int[][] matrix, int target) {\\n        int row = matrix.length;\\n        if(row==0)return 0;\\n        int col = matrix[0].length;\\n        int m = Math.min(row,col);\\n        int n = Math.max(row,col);\\n        //indicating sum up in every row or every column\\n        boolean colIsBig = col>row;\\n        int res = Integer.MIN_VALUE;\\n        for(int i = 0;i<m;i++){\\n            int[] array = new int[n];\\n            // sum from row j to row i\\n            for(int j = i;j>=0;j--){\\n                int val = 0;\\n                TreeSet<Integer> set = new TreeSet<Integer>();\\n                set.add(0);\\n                //traverse every column/row and sum up\\n                for(int k = 0;k<n;k++){\\n                    array[k]=array[k]+(colIsBig?matrix[j][k]:matrix[k][j]);\\n                    val = val + array[k];\\n                    //use  TreeMap to binary search previous sum to get possible result \\n                    Integer subres = set.ceiling(val-target);\\n                    if(null!=subres){\\n                        res=Math.max(res,val-subres);\\n                    }\\n                    set.add(val);\\n                }\\n            }\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "\\n    /* first  consider the situation matrix is 1D\\n        we can save every sum of 0~i(0<=i<len) and binary search previous sum to find \\n        possible result for every index, time complexity is O(NlogN).\\n        so in 2D matrix, we can sum up all values from row i to row j and create a 1D array \\n        to use 1D array solution.\\n        If col number is less than row number, we can sum up all values from col i to col j \\n        then use 1D array solution.\\n    */\\n    public int maxSumSubmatrix(int[][] matrix, int target) {\\n        int row = matrix.length;\\n        if(row==0)return 0;\\n        int col = matrix[0].length;\\n        int m = Math.min(row,col);\\n        int n = Math.max(row,col);\\n        //indicating sum up in every row or every column\\n        boolean colIsBig = col>row;\\n        int res = Integer.MIN_VALUE;\\n        for(int i = 0;i<m;i++){\\n            int[] array = new int[n];\\n            // sum from row j to row i\\n            for(int j = i;j>=0;j--){\\n                int val = 0;\\n                TreeSet<Integer> set = new TreeSet<Integer>();\\n                set.add(0);\\n                //traverse every column/row and sum up\\n                for(int k = 0;k<n;k++){\\n                    array[k]=array[k]+(colIsBig?matrix[j][k]:matrix[k][j]);\\n                    val = val + array[k];\\n                    //use  TreeMap to binary search previous sum to get possible result \\n                    Integer subres = set.ceiling(val-target);\\n                    if(null!=subres){\\n                        res=Math.max(res,val-subres);\\n                    }\\n                    set.add(val);\\n                }\\n            }\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 445540,
                "title": "python-bisect-solution-960ms-beat-71-25",
                "content": "Please see and vote for my solution for these similar problems.\\n[560. Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/discuss/344431/Simple-Python-DP-solution)\\n[974. Subarray Sums Divisible by K](https://leetcode.com/problems/subarray-sums-divisible-by-k/discuss/344436/Simple-Python-DP-solution)\\n[325. Maximum Size Subarray Sum Equals k](https://leetcode.com/problems/maximum-size-subarray-sum-equals-k/discuss/344432/Simple-Python-DP-solution)\\n[1074. Number of Submatrices That Sum to Target](https://leetcode.com/problems/number-of-submatrices-that-sum-to-target/discuss/344440/Simple-Python-DP-solution)\\n[363. Max Sum of Rectangle No Larger Than K](https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/discuss/445540/Python-bisect-solution-(960ms-beat-71.25))\\n\\nFor each row, calculate the prefix sum. For each pair of columns, calculate the sum of rows.\\nNow this problem is changed to a 1D problem: max subarray sum no more than k.\\n```\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        def maxSumSubarray(arr):\\n            sub_s_max = float(\\'-inf\\')\\n            s_curr = 0\\n            prefix_sums = [float(\\'inf\\')]\\n            for x in arr:\\n                bisect.insort(prefix_sums, s_curr)\\n                s_curr += x\\n                i = bisect.bisect_left(prefix_sums, s_curr - k)\\n                sub_s_max = max(sub_s_max, s_curr - prefix_sums[i])\\n            return sub_s_max\\n        \\n        m, n = len(matrix), len(matrix[0])\\n        for x in range(m):\\n            for y in range(n - 1):\\n                matrix[x][y+1] += matrix[x][y]\\n        res = float(\\'-inf\\')\\n        for y1 in range(n):\\n            for y2 in range(y1, n):\\n                arr = [matrix[x][y2] - (matrix[x][y1-1] if y1 > 0 else 0) for x in range(m)]\\n                res = max(res, maxSumSubarray(arr))\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        def maxSumSubarray(arr):\\n            sub_s_max = float(\\'-inf\\')\\n            s_curr = 0\\n            prefix_sums = [float(\\'inf\\')]\\n            for x in arr:\\n                bisect.insort(prefix_sums, s_curr)\\n                s_curr += x\\n                i = bisect.bisect_left(prefix_sums, s_curr - k)\\n                sub_s_max = max(sub_s_max, s_curr - prefix_sums[i])\\n            return sub_s_max\\n        \\n        m, n = len(matrix), len(matrix[0])\\n        for x in range(m):\\n            for y in range(n - 1):\\n                matrix[x][y+1] += matrix[x][y]\\n        res = float(\\'-inf\\')\\n        for y1 in range(n):\\n            for y2 in range(y1, n):\\n                arr = [matrix[x][y2] - (matrix[x][y1-1] if y1 > 0 else 0) for x in range(m)]\\n                res = max(res, maxSumSubarray(arr))\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 469544,
                "title": "simple-c-prefix-sum-solution-w-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    // The Core Idea Behind This Problem:\\n    // Let\\'s first consider the 1 dimensional case, and then we can extrapolate to the 2-dimensional case of the problem\\n    // Let\\'s say we have an array [-3, 6, -2], and we need to find the greatest contiguous subsequence sum <= k=2\\n    // One approach which may immediately jump to mind is Kadane\\'s algorithm.\\n    // However, this cannot work for the simple reason that we cannot find the next greatest subsequence sum <= k=2 simply from the previous result.\\n    // This is best illustrated looking at [-3, 6, -2]. \\n    // Firstly, maxSum = -3\\n    // However, when we reach 6, what do we do? We can choose to take 6 on its own, however this exceeds k=2.\\n    // We can also take -3+6, however, this is less than 6 on its own (does not guarantee a maximum), and it also exceeds k. There is no reasonable course\\n\\t// of action to take in a case like this to guarantee that the maximum BOUNDED \\n\\t// contiguous subarray sum can be found simply by looking at the previous result.\\n    // So, we do the next best thing. We compute prefix sums\\n    //\\n    // Arr:      [-3, 6, -2].\\n    // Pref: [0,  -3, 3,  1].\\n    //\\n    // For those who do not know, a prefix sum essentially is the sum of all of the array elements up to and including index i from 0.\\n    // Using this prefix sum array, at each index r (standing for right side of contiguous sequence) we find index l \\n\\t// previous such that pref[r] - pref[l] <= k & pref[r] - pref[l] > currMax.\\n    // This naive algorithm has a time complexity of O(n^2). But can we do better?\\n    \\n    // Yes we can! Introducing, the balanced binary search tree.\\n    // Looking at the above algorithm, we are essentially trying to find pref[l] such at it is\\n\\t// maximised, however when added with pref[r] it does not exceed k.\\n    // This can be done through a binary search in a binary search tree, looking for the \\n\\t// previously encountered prefix sum such that it is >= currPrefixSum - k.\\n    \\n    // In the C++ STL, the underlying implementation of the ordered set is a\\n\\t// balanced binary search tree (Red-Black tree). We can use this, as well as the in-built\\n\\t// function lower_bound to perform this storage and search.\\n    \\n    // We store previously encountered prefix sums in our BST (Binary search tree), \\n\\t// and then for every new one we perform this search to try and maximise our sum whilst not exceeding k.\\n    \\n    // Insertion and searching a BST are both O(log n) operations. \\n\\t// We perform this insertion and search n times in a loop through our array. This leads to O(n log n) complexity.\\n    \\n    // Transitioning to two dimensions:\\n    // Moving to 2 dimensions is actually surprisingly easy once you have developed this core insight.\\n    // View each element in your 1 dimensional array as simply the contiguous array sum between two column boundaries, lCol and rCol.\\n    // Illustrated:\\n    // For 2D array              Corresponding 1D with lCol = 0, rCol = 0\\n    // [[1,  0, 1],              [1, 0]\\n    //  [0, -2, 3]]              Corresponding 1D with lCol = 0, rCol = 1\\n    //                           [1 + 0, 0 + -2] = [1, -2].\\n    //                           Corresponding 1D with lCol = 1, rCol = 2\\n    //                           [0 + 1, -2 + 3] = [1, 1].\\n    \\n    // We can efficiently compute these 1D arrays through using prefix sums AGAIN! Phew, that\\'s a lot of prefix sums.\\n    // Essentially, for each row of the 2D array we compute the prefix sums of the elements\\n    \\n    // So for the previous 2D array, the prefix sums look as follows.\\n    // [[1, 1, 2],\\n    //  [0, -2, 1]]\\n    //\\n    // Now, to find index 0 (row 0) of our 1D array, for lCol = 1 & rCol = 2\\n    // we take the pref[row = 0][rCol = 2] and subtract away pref[row = 0][lCol - 1 = 0] to remove any sums\\n    // which do not correspond to our inclusive range.\\n    \\n    // Each 1D array is found through iterating through all of the possible lCol, rCol combinations where lCol <= rCol.\\n    // Then, we perform the same algorithm with the BST (Binary Search Tree) on the current 1D array as outlined above.\\n    // Maximum is replaced if we find a larger rectangle sum.\\n    \\n    \\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        // Precompute column prefix sums\\n        for (int row = 0; row < matrix.size(); ++row) {\\n            int currSum = 0;\\n            for (int col = 0; col < matrix[row].size(); ++col) {\\n                currSum += matrix[row][col];\\n                matrix[row][col] = currSum;\\n            }\\n        }\\n        \\n        int maxSum = INT_MIN;\\n        for (int lCol = 0; lCol < matrix[0].size(); ++lCol) {\\n            for (int rCol = lCol; rCol < matrix[0].size(); ++rCol) {\\n                \\n                set<int> bst; // RB tree\\n                bst.insert(0);\\n                \\n                int rowPrefSum = 0;\\n                for (int row = 0; row < matrix.size(); ++row) {\\n                    int currSum = matrix[row][rCol] - (lCol == 0 ? 0 : matrix[row][lCol-1]);\\n                    rowPrefSum += currSum;\\n                    \\n                    auto searchRes = bst.lower_bound(rowPrefSum - k);\\n                    \\n                    if (searchRes != bst.end()) {      \\n                        maxSum = max(maxSum, rowPrefSum - *searchRes);\\n                    }\\n                    \\n                    bst.insert(rowPrefSum);\\n                }\\n                \\n                \\n            }\\n        }\\n        \\n        return maxSum;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // The Core Idea Behind This Problem:\\n    // Let\\'s first consider the 1 dimensional case, and then we can extrapolate to the 2-dimensional case of the problem\\n    // Let\\'s say we have an array [-3, 6, -2], and we need to find the greatest contiguous subsequence sum <= k=2\\n    // One approach which may immediately jump to mind is Kadane\\'s algorithm.\\n    // However, this cannot work for the simple reason that we cannot find the next greatest subsequence sum <= k=2 simply from the previous result.\\n    // This is best illustrated looking at [-3, 6, -2]. \\n    // Firstly, maxSum = -3\\n    // However, when we reach 6, what do we do? We can choose to take 6 on its own, however this exceeds k=2.\\n    // We can also take -3+6, however, this is less than 6 on its own (does not guarantee a maximum), and it also exceeds k. There is no reasonable course\\n\\t// of action to take in a case like this to guarantee that the maximum BOUNDED \\n\\t// contiguous subarray sum can be found simply by looking at the previous result.\\n    // So, we do the next best thing. We compute prefix sums\\n    //\\n    // Arr:      [-3, 6, -2].\\n    // Pref: [0,  -3, 3,  1].\\n    //\\n    // For those who do not know, a prefix sum essentially is the sum of all of the array elements up to and including index i from 0.\\n    // Using this prefix sum array, at each index r (standing for right side of contiguous sequence) we find index l \\n\\t// previous such that pref[r] - pref[l] <= k & pref[r] - pref[l] > currMax.\\n    // This naive algorithm has a time complexity of O(n^2). But can we do better?\\n    \\n    // Yes we can! Introducing, the balanced binary search tree.\\n    // Looking at the above algorithm, we are essentially trying to find pref[l] such at it is\\n\\t// maximised, however when added with pref[r] it does not exceed k.\\n    // This can be done through a binary search in a binary search tree, looking for the \\n\\t// previously encountered prefix sum such that it is >= currPrefixSum - k.\\n    \\n    // In the C++ STL, the underlying implementation of the ordered set is a\\n\\t// balanced binary search tree (Red-Black tree). We can use this, as well as the in-built\\n\\t// function lower_bound to perform this storage and search.\\n    \\n    // We store previously encountered prefix sums in our BST (Binary search tree), \\n\\t// and then for every new one we perform this search to try and maximise our sum whilst not exceeding k.\\n    \\n    // Insertion and searching a BST are both O(log n) operations. \\n\\t// We perform this insertion and search n times in a loop through our array. This leads to O(n log n) complexity.\\n    \\n    // Transitioning to two dimensions:\\n    // Moving to 2 dimensions is actually surprisingly easy once you have developed this core insight.\\n    // View each element in your 1 dimensional array as simply the contiguous array sum between two column boundaries, lCol and rCol.\\n    // Illustrated:\\n    // For 2D array              Corresponding 1D with lCol = 0, rCol = 0\\n    // [[1,  0, 1],              [1, 0]\\n    //  [0, -2, 3]]              Corresponding 1D with lCol = 0, rCol = 1\\n    //                           [1 + 0, 0 + -2] = [1, -2].\\n    //                           Corresponding 1D with lCol = 1, rCol = 2\\n    //                           [0 + 1, -2 + 3] = [1, 1].\\n    \\n    // We can efficiently compute these 1D arrays through using prefix sums AGAIN! Phew, that\\'s a lot of prefix sums.\\n    // Essentially, for each row of the 2D array we compute the prefix sums of the elements\\n    \\n    // So for the previous 2D array, the prefix sums look as follows.\\n    // [[1, 1, 2],\\n    //  [0, -2, 1]]\\n    //\\n    // Now, to find index 0 (row 0) of our 1D array, for lCol = 1 & rCol = 2\\n    // we take the pref[row = 0][rCol = 2] and subtract away pref[row = 0][lCol - 1 = 0] to remove any sums\\n    // which do not correspond to our inclusive range.\\n    \\n    // Each 1D array is found through iterating through all of the possible lCol, rCol combinations where lCol <= rCol.\\n    // Then, we perform the same algorithm with the BST (Binary Search Tree) on the current 1D array as outlined above.\\n    // Maximum is replaced if we find a larger rectangle sum.\\n    \\n    \\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        // Precompute column prefix sums\\n        for (int row = 0; row < matrix.size(); ++row) {\\n            int currSum = 0;\\n            for (int col = 0; col < matrix[row].size(); ++col) {\\n                currSum += matrix[row][col];\\n                matrix[row][col] = currSum;\\n            }\\n        }\\n        \\n        int maxSum = INT_MIN;\\n        for (int lCol = 0; lCol < matrix[0].size(); ++lCol) {\\n            for (int rCol = lCol; rCol < matrix[0].size(); ++rCol) {\\n                \\n                set<int> bst; // RB tree\\n                bst.insert(0);\\n                \\n                int rowPrefSum = 0;\\n                for (int row = 0; row < matrix.size(); ++row) {\\n                    int currSum = matrix[row][rCol] - (lCol == 0 ? 0 : matrix[row][lCol-1]);\\n                    rowPrefSum += currSum;\\n                    \\n                    auto searchRes = bst.lower_bound(rowPrefSum - k);\\n                    \\n                    if (searchRes != bst.end()) {      \\n                        maxSum = max(maxSum, rowPrefSum - *searchRes);\\n                    }\\n                    \\n                    bst.insert(rowPrefSum);\\n                }\\n                \\n                \\n            }\\n        }\\n        \\n        return maxSum;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 83618,
                "title": "2-accepted-java-solution",
                "content": "Decide to post because I was actually asked this question during my interview!\\nThere is a simple version of O(n^4).\\nThe idea is to calculate every rectangle [[r1,c1], [r2,c2]], and simply pick the max area <= k.\\nAn improved version takes O(n^3logn). It borrows the idea to find max subarray with sum <= k in 1D array, and apply here: we find all rectangles bounded between r1 & r2, with columns from 0 to end. Pick a pair from tree.\\nI remember the interviewer said there could be an even better solution, but I haven't figured that out...\\n\\nSolution I, O(n^4):\\n\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0)\\n            return 0;\\n        int rows = matrix.length, cols = matrix[0].length;\\n        int[][] areas = new int[rows][cols];\\n        for (int r = 0; r < rows; r++) {\\n            for (int c = 0; c < cols; c++) {\\n                int area = matrix[r][c];\\n                if (r-1 >= 0)\\n                    area += areas[r-1][c];\\n                if (c-1 >= 0)\\n                    area += areas[r][c-1];\\n                if (r-1 >= 0 && c-1 >= 0)\\n                    area -= areas[r-1][c-1];\\n                areas[r][c] = area;\\n            }\\n        }\\n        int max = Integer.MIN_VALUE;\\n        for (int r1 = 0; r1 < rows; r1++) {\\n            for (int c1 = 0; c1 < cols; c1++) {\\n                for (int r2 = r1; r2 < rows; r2++) {\\n                    for (int c2 = c1; c2 < cols; c2++) {\\n                        int area = areas[r2][c2];\\n                        if (r1-1 >= 0)\\n                            area -= areas[r1-1][c2];\\n                        if (c1-1 >= 0)\\n                            area -= areas[r2][c1-1];\\n                        if (r1-1 >= 0 && c1 -1 >= 0)\\n                            area += areas[r1-1][c1-1];\\n                        if (area <= k)\\n                            max = Math.max(max, area);\\n                    }\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n\\nSolution II (O(n^3logn)\\n\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0)\\n            return 0;\\n        int rows = matrix.length, cols = matrix[0].length;\\n        int[][] areas = new int[rows][cols];\\n        for (int r = 0; r < rows; r++) {\\n            for (int c = 0; c < cols; c++) {\\n                int area = matrix[r][c];\\n                if (r-1 >= 0)\\n                    area += areas[r-1][c];\\n                if (c-1 >= 0)\\n                    area += areas[r][c-1];\\n                if (r-1 >= 0 && c-1 >= 0)\\n                    area -= areas[r-1][c-1];\\n                areas[r][c] = area;\\n            }\\n        }\\n        int max = Integer.MIN_VALUE;\\n        for (int r1 = 0; r1 < rows; r1++) {\\n            for (int r2 = r1; r2 < rows; r2++) {\\n                TreeSet<Integer> tree = new TreeSet<>();\\n                tree.add(0);    // padding\\n                for (int c = 0; c < cols; c++) {\\n                    int area = areas[r2][c];\\n                    if (r1-1 >= 0)\\n                        area -= areas[r1-1][c];\\n                    Integer ceiling = tree.ceiling(area - k);\\n                    if (ceiling != null)\\n                        max = Math.max(max, area - ceiling);\\n                    tree.add(area);\\n                }\\n            }\\n        }\\n        return max;\\n    }",
                "solutionTags": [],
                "code": "Decide to post because I was actually asked this question during my interview!\\nThere is a simple version of O(n^4).\\nThe idea is to calculate every rectangle [[r1,c1], [r2,c2]], and simply pick the max area <= k.\\nAn improved version takes O(n^3logn). It borrows the idea to find max subarray with sum <= k in 1D array, and apply here: we find all rectangles bounded between r1 & r2, with columns from 0 to end. Pick a pair from tree.\\nI remember the interviewer said there could be an even better solution, but I haven't figured that out...\\n\\nSolution I, O(n^4):\\n\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0)\\n            return 0;\\n        int rows = matrix.length, cols = matrix[0].length;\\n        int[][] areas = new int[rows][cols];\\n        for (int r = 0; r < rows; r++) {\\n            for (int c = 0; c < cols; c++) {\\n                int area = matrix[r][c];\\n                if (r-1 >= 0)\\n                    area += areas[r-1][c];\\n                if (c-1 >= 0)\\n                    area += areas[r][c-1];\\n                if (r-1 >= 0 && c-1 >= 0)\\n                    area -= areas[r-1][c-1];\\n                areas[r][c] = area;\\n            }\\n        }\\n        int max = Integer.MIN_VALUE;\\n        for (int r1 = 0; r1 < rows; r1++) {\\n            for (int c1 = 0; c1 < cols; c1++) {\\n                for (int r2 = r1; r2 < rows; r2++) {\\n                    for (int c2 = c1; c2 < cols; c2++) {\\n                        int area = areas[r2][c2];\\n                        if (r1-1 >= 0)\\n                            area -= areas[r1-1][c2];\\n                        if (c1-1 >= 0)\\n                            area -= areas[r2][c1-1];\\n                        if (r1-1 >= 0 && c1 -1 >= 0)\\n                            area += areas[r1-1][c1-1];\\n                        if (area <= k)\\n                            max = Math.max(max, area);\\n                    }\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n\\nSolution II (O(n^3logn)\\n\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0)\\n            return 0;\\n        int rows = matrix.length, cols = matrix[0].length;\\n        int[][] areas = new int[rows][cols];\\n        for (int r = 0; r < rows; r++) {\\n            for (int c = 0; c < cols; c++) {\\n                int area = matrix[r][c];\\n                if (r-1 >= 0)\\n                    area += areas[r-1][c];\\n                if (c-1 >= 0)\\n                    area += areas[r][c-1];\\n                if (r-1 >= 0 && c-1 >= 0)\\n                    area -= areas[r-1][c-1];\\n                areas[r][c] = area;\\n            }\\n        }\\n        int max = Integer.MIN_VALUE;\\n        for (int r1 = 0; r1 < rows; r1++) {\\n            for (int r2 = r1; r2 < rows; r2++) {\\n                TreeSet<Integer> tree = new TreeSet<>();\\n                tree.add(0);    // padding\\n                for (int c = 0; c < cols; c++) {\\n                    int area = areas[r2][c];\\n                    if (r1-1 >= 0)\\n                        area -= areas[r1-1][c];\\n                    Integer ceiling = tree.ceiling(area - k);\\n                    if (ceiling != null)\\n                        max = Math.max(max, area - ceiling);\\n                    tree.add(area);\\n                }\\n            }\\n        }\\n        return max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1312722,
                "title": "python-two-solutions-explained",
                "content": "#### Solution 1\\nFirst of all, let us understand how to solve 1d problem: that is given list `nums` and number `U` we need to find the maximum sum of adjacent several elements such that its sum is no more than `U`. Note, that it is very similar to problem **327. Count of Range Sum**, but there the goal was to find not the biggest sum, but number of such sums. However we can use the similar idea: let us add cumulative sums one by one, that is if we have `nums = [3, 1, 4, 1, 5, 9, 2, 6]`, then we add elements `[3, 4, 8, 9, 14, 23, 25, 31]`. Each time before we add element we do binary search of element `s - U`: the closest element bigger than `s - U`. If `ind != len(SList)`, then we update our answer.\\n\\nWhen we found how to solve 1-d problem, it is time to work with 2-d problem. Actually we need to solve `O(m^2)` 1-d problems, to choose numbers i,j such that `1 <= i <=j <= m`. What we can do is to calculate cumulative sums for each column and then for each pair create list of differences and apply our `countRangeSum` function.\\n\\n#### Complexity\\nTime complexity of 1-d problem is `O(n log n)`, so time complexity of all algorithm is `O(m^2*n log n)`. It can be make `O(n^2 * m log m)` if we rotate our matrix, but in practice it works similar for me. Space complexity is `O(mn)`.\\n\\n#### Code\\n```python\\nfrom sortedcontainers import SortedList\\n    \\nclass Solution:\\n    def maxSumSubmatrix(self, M, k):\\n        def countRangeSum(nums, U):\\n            SList, ans = SortedList([0]), -float(\"inf\")\\n            for s in accumulate(nums):\\n                idx = SList.bisect_left(s - U) \\n                if idx < len(SList): ans = max(ans, s - SList[idx])        \\n                SList.add(s)\\n            return ans\\n        \\n        m, n, ans = len(M), len(M[0]), -float(\"inf\")\\n        \\n        for i, j in product(range(1, m), range(n)):\\n            M[i][j] += M[i-1][j]\\n                \\n        M = [[0]*n] + M\\n        \\n        for r1, r2 in combinations(range(m + 1), 2):\\n            row = [j - i for i, j in zip(M[r1], M[r2])]\\n            ans = max(ans, countRangeSum(row, k))\\n            \\n        return ans\\n```\\n\\n#### Solution 2:\\n\\nWe can use slightly different function `countRangeSum`, where instead of SortedList we use usual list and `insort` function. Complexity is `O(n^2)`, however because `n` is not very big, it works even faster than previous method, like 2-3 times!\\n\\n#### Complexity\\nTime complexity is `O(n^2*m^2)`, but with very small constant. Space complexity is `O(mn)`.\\n\\n#### Code\\n```python\\ndef countRangeSum(nums, U):\\n\\t\\tSList, ans = [0], -float(\"inf\")\\n\\t\\tfor s in accumulate(nums):\\n\\t\\t\\tidx = bisect_left(SList, s - U) \\n\\t\\t\\tif idx < len(SList): ans = max(ans, s - SList[idx])        \\n\\t\\t\\tbisect.insort(SList, s)\\n\\t\\treturn ans\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```python\\nfrom sortedcontainers import SortedList\\n    \\nclass Solution:\\n    def maxSumSubmatrix(self, M, k):\\n        def countRangeSum(nums, U):\\n            SList, ans = SortedList([0]), -float(\"inf\")\\n            for s in accumulate(nums):\\n                idx = SList.bisect_left(s - U) \\n                if idx < len(SList): ans = max(ans, s - SList[idx])        \\n                SList.add(s)\\n            return ans\\n        \\n        m, n, ans = len(M), len(M[0]), -float(\"inf\")\\n        \\n        for i, j in product(range(1, m), range(n)):\\n            M[i][j] += M[i-1][j]\\n                \\n        M = [[0]*n] + M\\n        \\n        for r1, r2 in combinations(range(m + 1), 2):\\n            row = [j - i for i, j in zip(M[r1], M[r2])]\\n            ans = max(ans, countRangeSum(row, k))\\n            \\n        return ans\\n```\n```python\\ndef countRangeSum(nums, U):\\n\\t\\tSList, ans = [0], -float(\"inf\")\\n\\t\\tfor s in accumulate(nums):\\n\\t\\t\\tidx = bisect_left(SList, s - U) \\n\\t\\t\\tif idx < len(SList): ans = max(ans, s - SList[idx])        \\n\\t\\t\\tbisect.insort(SList, s)\\n\\t\\treturn ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 83595,
                "title": "java-117ms-beat-99-81-merge-sort",
                "content": "```\\n/*\\n * If # of columns is smaller, process one set of columns [i..j) at a time, for each different i<j.\\n * For one set of colums [i..j), do it like \"Count of Range Sum\".\\n * O(n) = n^2 * mlogm.\\n * Assume we have such result.\\n */\\npublic class Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int m = matrix.length, n = matrix[0].length, ans = Integer.MIN_VALUE;\\n        long[] sum = new long[m+1]; // stores sum of rect[0..p][i..j]\\n        for (int i = 0; i < n; ++i) {\\n            long[] sumInRow = new long[m];\\n            for (int j = i; j < n; ++j) { // for each rect[*][i..j]\\n                for (int p = 0; p < m; ++p) {\\n                    sumInRow[p] += matrix[p][j];\\n                    sum[p+1] = sum[p] + sumInRow[p];\\n                }\\n                ans = Math.max(ans, mergeSort(sum, 0, m+1, k));\\n                if (ans == k) return k;\\n            }\\n        }\\n        return ans;\\n    }\\n    int mergeSort(long[] sum, int start, int end, int k) {\\n        if (end == start+1) return Integer.MIN_VALUE; // need at least 2 to proceed\\n        int mid = start + (end - start)/2, cnt = 0;\\n        int ans = mergeSort(sum, start, mid, k);\\n        if (ans == k) return k;\\n        ans = Math.max(ans, mergeSort(sum, mid, end, k));\\n        if (ans == k) return k;\\n        long[] cache = new long[end-start];\\n        for (int i = start, j = mid, p = mid; i < mid; ++i) {\\n            while (j < end && sum[j] - sum[i] <= k) ++j;\\n            if (j-1 >= mid) {\\n                ans = Math.max(ans, (int)(sum[j-1] - sum[i]));\\n                if (ans == k) return k;\\n            }\\n            while (p < end && sum[p] < sum[i]) cache[cnt++] = sum[p++];\\n            cache[cnt++] = sum[i];\\n        }\\n        System.arraycopy(cache, 0, sum, start, cnt);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n * If # of columns is smaller, process one set of columns [i..j) at a time, for each different i<j.\\n * For one set of colums [i..j), do it like \"Count of Range Sum\".\\n * O(n) = n^2 * mlogm.\\n * Assume we have such result.\\n */\\npublic class Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int m = matrix.length, n = matrix[0].length, ans = Integer.MIN_VALUE;\\n        long[] sum = new long[m+1]; // stores sum of rect[0..p][i..j]\\n        for (int i = 0; i < n; ++i) {\\n            long[] sumInRow = new long[m];\\n            for (int j = i; j < n; ++j) { // for each rect[*][i..j]\\n                for (int p = 0; p < m; ++p) {\\n                    sumInRow[p] += matrix[p][j];\\n                    sum[p+1] = sum[p] + sumInRow[p];\\n                }\\n                ans = Math.max(ans, mergeSort(sum, 0, m+1, k));\\n                if (ans == k) return k;\\n            }\\n        }\\n        return ans;\\n    }\\n    int mergeSort(long[] sum, int start, int end, int k) {\\n        if (end == start+1) return Integer.MIN_VALUE; // need at least 2 to proceed\\n        int mid = start + (end - start)/2, cnt = 0;\\n        int ans = mergeSort(sum, start, mid, k);\\n        if (ans == k) return k;\\n        ans = Math.max(ans, mergeSort(sum, mid, end, k));\\n        if (ans == k) return k;\\n        long[] cache = new long[end-start];\\n        for (int i = start, j = mid, p = mid; i < mid; ++i) {\\n            while (j < end && sum[j] - sum[i] <= k) ++j;\\n            if (j-1 >= mid) {\\n                ans = Math.max(ans, (int)(sum[j-1] - sum[i]));\\n                if (ans == k) return k;\\n            }\\n            while (p < end && sum[p] < sum[i]) cache[cnt++] = sum[p++];\\n            cache[cnt++] = sum[i];\\n        }\\n        System.arraycopy(cache, 0, sum, start, cnt);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 83614,
                "title": "accepted-java-solution",
                "content": "The idea of this solution is to convert the problem into \"find the maximum sum of sub-array no larger than K\". \\n\\nThe time complexity will be O(r^2clogc) where r is the number of rows and c is the number of columns. If r is much larger than c, the complexity can be O(c^2rlogr) by creating a row-sum array instead of column-sum array\\n\\n```\\n\\npublic class Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        int max = Integer.MIN_VALUE;\\n        for (int i = 0; i < row; i ++) {\\n            int[] colSum = new int[col];\\n            for (int j = i; j < row; j ++) {\\n                for (int c = 0; c < col; c ++) {\\n                    colSum[c] += matrix[j][c];\\n                }\\n                max = Math.max(max, findMax(colSum, k));\\n            }\\n        }\\n        return max;\\n    }\\n    \\n    private int findMax(int[] nums, int k) {\\n        int max = Integer.MIN_VALUE;\\n        int sum = 0;\\n        TreeSet<Integer> s = new TreeSet();\\n        s.add(0);\\n    \\n        for(int i = 0;i < nums.length; i ++){\\n            int t = sum + nums[i];\\n            sum = t;\\n            Integer gap = s.ceiling(sum - k);\\n            if(gap != null) max = Math.max(max, sum - gap);\\n            s.add(t);\\n        }\\n    \\n        return max;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\npublic class Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        int max = Integer.MIN_VALUE;\\n        for (int i = 0; i < row; i ++) {\\n            int[] colSum = new int[col];\\n            for (int j = i; j < row; j ++) {\\n                for (int c = 0; c < col; c ++) {\\n                    colSum[c] += matrix[j][c];\\n                }\\n                max = Math.max(max, findMax(colSum, k));\\n            }\\n        }\\n        return max;\\n    }\\n    \\n    private int findMax(int[] nums, int k) {\\n        int max = Integer.MIN_VALUE;\\n        int sum = 0;\\n        TreeSet<Integer> s = new TreeSet();\\n        s.add(0);\\n    \\n        for(int i = 0;i < nums.length; i ++){\\n            int t = sum + nums[i];\\n            sum = t;\\n            Integer gap = s.ceiling(sum - k);\\n            if(gap != null) max = Math.max(max, sum - gap);\\n            s.add(t);\\n        }\\n    \\n        return max;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2491014,
                "title": "python-99-2-using-kadane-s-algorithm-bisect",
                "content": "```\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        m, n = len(matrix), len(matrix[0])\\n        res = -inf\\n        \\n        for l in range(n):\\n            rowSums = [0] * m\\n            for r in range(l, n):\\n                colSums = [0]\\n                colSum = 0\\n                for i in range(m):\\n                    rowSums[i] += matrix[i][r]\\n                    colSum += rowSums[i]\\n                    diff = colSum - k\\n                    idx = bisect_left(colSums, diff)\\n                    if idx < len(colSums):\\n                        if colSums[idx] == diff:\\n                            return k\\n                        else:\\n                            res = max(res, colSum - colSums[idx])\\n                    insort(colSums, colSum)\\n        return res\\n```\\n![image](https://assets.leetcode.com/users/images/29dd3558-a351-4e70-b9b5-af0e03ab8425_1661617035.1357048.png)\\n\\n**Please UPVOTE if you LIKE!!**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        m, n = len(matrix), len(matrix[0])\\n        res = -inf\\n        \\n        for l in range(n):\\n            rowSums = [0] * m\\n            for r in range(l, n):\\n                colSums = [0]\\n                colSum = 0\\n                for i in range(m):\\n                    rowSums[i] += matrix[i][r]\\n                    colSum += rowSums[i]\\n                    diff = colSum - k\\n                    idx = bisect_left(colSums, diff)\\n                    if idx < len(colSums):\\n                        if colSums[idx] == diff:\\n                            return k\\n                        else:\\n                            res = max(res, colSum - colSums[idx])\\n                    insort(colSums, colSum)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2488551,
                "title": "c-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int r = matrix.size(), c = matrix[0].size();\\n        \\n        int prefix[r+1][c+1];\\n        memset(prefix,0,sizeof(prefix));\\n        \\n        for(int i=1; i<=r; ++i) prefix[i][1] = prefix[i-1][1] + matrix[i-1][0];\\n        for(int i=1; i<=c; ++i) prefix[1][i] = prefix[1][i-1] + matrix[0][i-1];\\n        \\n        for(int i=2; i<=r; ++i){\\n            for(int j=2; j<=c; ++j){\\n                prefix[i][j] = prefix[i-1][j] + prefix[i][j-1] - prefix[i-1][j-1] + matrix[i-1][j-1];\\n            }\\n        }\\n        \\n        \\n        int ans = INT_MIN;\\n        for (int x1 = 1; x1 <= r; ++x1) {\\n\\t\\t\\tfor (int y1 = 1; y1 <= c; ++y1) {\\n\\t\\t\\t\\tfor (int x2 = x1; x2 <= r; ++x2) {\\n\\t\\t\\t\\t\\tfor (int y2 = y1; y2 <= c; ++y2) {\\n\\t\\t\\t\\t\\t\\tint sum = prefix[x2][y2] - prefix[x1-1][y2] - prefix[x2][y1-1] + prefix[x1-1][y1-1];\\n\\t\\t\\t\\t\\t\\tif (sum <= k) {\\n\\t\\t\\t\\t\\t\\t\\tans = max(ans, sum);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n        return ans;\\n    }\\n};\\n```\\nplease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int r = matrix.size(), c = matrix[0].size();\\n        \\n        int prefix[r+1][c+1];\\n        memset(prefix,0,sizeof(prefix));\\n        \\n        for(int i=1; i<=r; ++i) prefix[i][1] = prefix[i-1][1] + matrix[i-1][0];\\n        for(int i=1; i<=c; ++i) prefix[1][i] = prefix[1][i-1] + matrix[0][i-1];\\n        \\n        for(int i=2; i<=r; ++i){\\n            for(int j=2; j<=c; ++j){\\n                prefix[i][j] = prefix[i-1][j] + prefix[i][j-1] - prefix[i-1][j-1] + matrix[i-1][j-1];\\n            }\\n        }\\n        \\n        \\n        int ans = INT_MIN;\\n        for (int x1 = 1; x1 <= r; ++x1) {\\n\\t\\t\\tfor (int y1 = 1; y1 <= c; ++y1) {\\n\\t\\t\\t\\tfor (int x2 = x1; x2 <= r; ++x2) {\\n\\t\\t\\t\\t\\tfor (int y2 = y1; y2 <= c; ++y2) {\\n\\t\\t\\t\\t\\t\\tint sum = prefix[x2][y2] - prefix[x1-1][y2] - prefix[x2][y1-1] + prefix[x1-1][y1-1];\\n\\t\\t\\t\\t\\t\\tif (sum <= k) {\\n\\t\\t\\t\\t\\t\\t\\tans = max(ans, sum);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 83596,
                "title": "any-accepted-python-solution",
                "content": "I got a TLE for the Python code below, because the time cost of bisect.insort is O(n) for a built-in list.\\n\\nThe code was rejudged as accepted just now, but very slow... 1800ms+\\n\\n    class Solution(object):\\n        def maxSumSubmatrix(self, matrix, k):\\n            \"\"\"\\n            :type matrix: List[List[int]]\\n            :type k: int\\n            :rtype: int\\n            \"\"\"\\n            m = len(matrix)\\n            n = len(matrix[0]) if m else 0\\n            \\n            M = max(m, n)\\n            N = min(m, n)\\n            ans = None\\n            for x in range(N):\\n                sums = [0] * M\\n                for y in range(x, N):\\n                    slist, num = [], 0\\n                    for z in range(M):\\n                        sums[z] += matrix[z][y] if m > n else matrix[y][z]\\n                        num += sums[z]\\n                        if num <= k: ans = max(ans, num)\\n                        i = bisect.bisect_left(slist, num - k)\\n                        if i != len(slist): ans = max(ans, num - slist[i])\\n                        bisect.insort(slist, num)\\n            return ans or 0\\n\\nCould anybody share a more efficient Python solution? Thank you :D",
                "solutionTags": [
                    "Python"
                ],
                "code": "I got a TLE for the Python code below, because the time cost of bisect.insort is O(n) for a built-in list.\\n\\nThe code was rejudged as accepted just now, but very slow... 1800ms+\\n\\n    class Solution(object):\\n        def maxSumSubmatrix(self, matrix, k):\\n            \"\"\"\\n            :type matrix: List[List[int]]\\n            :type k: int\\n            :rtype: int\\n            \"\"\"\\n            m = len(matrix)\\n            n = len(matrix[0]) if m else 0\\n            \\n            M = max(m, n)\\n            N = min(m, n)\\n            ans = None\\n            for x in range(N):\\n                sums = [0] * M\\n                for y in range(x, N):\\n                    slist, num = [], 0\\n                    for z in range(M):\\n                        sums[z] += matrix[z][y] if m > n else matrix[y][z]\\n                        num += sums[z]\\n                        if num <= k: ans = max(ans, num)\\n                        i = bisect.bisect_left(slist, num - k)\\n                        if i != len(slist): ans = max(ans, num - slist[i])\\n                        bisect.insort(slist, num)\\n            return ans or 0\\n\\nCould anybody share a more efficient Python solution? Thank you :D",
                "codeTag": "Java"
            },
            {
                "id": 2488222,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Prefix Sum && Binary Search***\\n\\n* ***Time Complexity :- O(N * N * N * logN)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // function for finding maximum subarray having sum less than k\\n    \\n    int find_max(vector<int>& arr, int k)\\n    {\\n        int n = arr.size();\\n        \\n        int maxi = INT_MIN;\\n        \\n        // curr_sum will store cumulative sum\\n        \\n        int curr_sum = 0;\\n        \\n        // set will store the prefix sum of array\\n        \\n        set<int> s;\\n        \\n        // put 0 into set, if curr_sum == k, (curr_sum - k) will be zero \\n        \\n        s.insert(0);\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            // calculate cumulative sum\\n            \\n            curr_sum += arr[i];\\n            \\n            // find the prefix sum in set having sum == curr_sum - k\\n            \\n            auto it = s.lower_bound(curr_sum - k);\\n            \\n            // if prefix sum is present, update the maxi\\n            \\n            if(it != s.end())\\n            {\\n                maxi = max(maxi, curr_sum - *it);\\n            }\\n            \\n            // insert prefix sum into set\\n            \\n            s.insert(curr_sum);\\n        }\\n        \\n        return maxi;\\n    }\\n    \\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        \\n        int n = matrix.size();\\n        \\n        int m = matrix[0].size();\\n        \\n        int maxi = INT_MIN;\\n        \\n        // fix the position of two rows and take cumulative sum of columns between two fixed rows\\n        \\n        for(int start_row = 0; start_row < n; start_row++)\\n        {\\n            vector<int> col_array(m, 0);\\n            \\n            for(int end_row = start_row; end_row < n; end_row++)\\n            {\\n                // take cumulative sum of columns between two fixed rows\\n                \\n                for(int col = 0; col < m; col++)\\n                {\\n                    col_array[col] += matrix[end_row][col];\\n                }\\n                \\n                // find maximum subarray having sum less than equal to k\\n                \\n                int curr_max = find_max(col_array, k);\\n                \\n                // update the maximum sum\\n                \\n                maxi = max(maxi, curr_max);\\n            }\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // function for finding maximum subarray having sum less than k\\n    \\n    int find_max(vector<int>& arr, int k)\\n    {\\n        int n = arr.size();\\n        \\n        int maxi = INT_MIN;\\n        \\n        // curr_sum will store cumulative sum\\n        \\n        int curr_sum = 0;\\n        \\n        // set will store the prefix sum of array\\n        \\n        set<int> s;\\n        \\n        // put 0 into set, if curr_sum == k, (curr_sum - k) will be zero \\n        \\n        s.insert(0);\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            // calculate cumulative sum\\n            \\n            curr_sum += arr[i];\\n            \\n            // find the prefix sum in set having sum == curr_sum - k\\n            \\n            auto it = s.lower_bound(curr_sum - k);\\n            \\n            // if prefix sum is present, update the maxi\\n            \\n            if(it != s.end())\\n            {\\n                maxi = max(maxi, curr_sum - *it);\\n            }\\n            \\n            // insert prefix sum into set\\n            \\n            s.insert(curr_sum);\\n        }\\n        \\n        return maxi;\\n    }\\n    \\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        \\n        int n = matrix.size();\\n        \\n        int m = matrix[0].size();\\n        \\n        int maxi = INT_MIN;\\n        \\n        // fix the position of two rows and take cumulative sum of columns between two fixed rows\\n        \\n        for(int start_row = 0; start_row < n; start_row++)\\n        {\\n            vector<int> col_array(m, 0);\\n            \\n            for(int end_row = start_row; end_row < n; end_row++)\\n            {\\n                // take cumulative sum of columns between two fixed rows\\n                \\n                for(int col = 0; col < m; col++)\\n                {\\n                    col_array[col] += matrix[end_row][col];\\n                }\\n                \\n                // find maximum subarray having sum less than equal to k\\n                \\n                int curr_max = find_max(col_array, k);\\n                \\n                // update the maximum sum\\n                \\n                maxi = max(maxi, curr_max);\\n            }\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2489079,
                "title": "python-prefix-sums-and-binary-search",
                "content": "This is an implementation of a solution provided [here](https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/discuss/851448/C%2B%2B-from-800-ms-to-50-ms).\\n\\n**Solution**:\\nUse two pointers to generate prefix sums of each rows. Left pointer will go from 0 to n and right pointer will go from left to n. By calculating prefix sums for each row, we reduce all rectangle from 2d to 1d where each rectangle is represented by 1d array of rows prefix sum.\\n\\nFor each row prefix sum, we will calculate column prefix sum and use binary search to find maximum area lesser than k. Start by initialize a list to store previously calculated column prefix sum. Iterate through all values in the row prefix sum. At each iteration, calculate the column prefix sum and check if there exists a previous column prefix sum that is larger than the different between the current column sum and k but the smallest among all previous prefix sums that are greater than the different. Use binary search to find such values. If there is, update the result.\\n\\n    Ex: Given matrix = [[1,0,1],[0,-2,3]], k = 2\\n    l   r   rowSums     colSums     area        res        \\n    0   0   [1, 0]      [1, 1]      [1,  1]     1\\n    0   1   [1, -2]     [1, -1]     [1, -1]     1\\n    0   2   [2, 1]      [2, 3]      [2, None]   2\\n    1   1   [0, -2]     [0, -2]     [0, -2]     2\\n    1   2   [1, 1]      [1, 2]      [1, 2]      2\\n    2   2   [1, 3]      [1, 4]      [1, None]   2\\n\\n\\nP.S. Kadane Algorithm: Given a list of numbers. You can calculate the maximum area ended at each number by taking the maximum between the current number vs the maximum area of previous number plus the current number. \\n\\n        area(i) = max(area(i-1) + nums[i], nums[i])\\n\\n**Complexity**:\\n    Time: O(m\\\\**2 n\\\\**2)\\n    Space:  O(m)\\n\\t\\n```\\nfrom bisect import bisect_right, insort\\nfrom math import inf\\n\\n\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: list[list[int]], k: int) -> int:\\n\\n        # Get the length of rows and colums\\n        m, n = len(matrix), len(matrix[0])\\n\\n        # Initialize the result\\n        res = -inf\\n\\n        # Iterate the left pointer from 0 to n\\n        for l in range(n):\\n\\n            # Initialize the row prefix sum\\n            rowSums = [0] * m\\n\\n            # Iterate the right pointer from left to n\\n            for r in range(l, n):\\n\\n                # Calculate the row prefix sum from left to right\\n                for i in range(m):\\n                    rowSums[i] += matrix[i][r]\\n\\n                # Calculate the column prefix sums\\n                # Initialize a list to store previous column prefix sum\\n                colSums = [0]\\n\\n                # Intialize the column prefix sum\\n                colSum = 0\\n\\n                # Iterate through all row prefix sums\\n                for rowSum in rowSums:\\n\\n                    # Add the current row prefix sum to the column prefix sum\\n                    colSum += rowSum\\n\\n                    # Calculate the different between the column prefix sum and k\\n                    diff = colSum - k\\n\\n                    # Perform a binary search to find an index of a value is larger but cloest to the different among previously calculated column prefix sums\\n                    idx = bisect_right(colSums, diff)\\n\\n                    # Check if the different exists among the previously calculated column prefix sums\\n                    if idx - 1 >= 0 and colSums[idx - 1] == diff:\\n\\n                        # If yes, update the result\\n                        res = max(res, colSum - colSums[idx - 1])\\n\\n                        # End the search because we found the largest possible result\\n                        return k\\n\\n                    # Else, if the different does not exist among the previously calculated column prefix sums, check if there is a previously calculated column prefix sum larger than the different\\n                    elif idx != len(colSums):\\n\\n                        # If yes, update the result with the new area if it is larger than previous result\\n                        res = max(res, colSum - colSums[idx])\\n\\n                    # Insert the current column prefix sum into the list while maintaining the sorted order\\n                    insort(colSums, colSum)\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom bisect import bisect_right, insort\\nfrom math import inf\\n\\n\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: list[list[int]], k: int) -> int:\\n\\n        # Get the length of rows and colums\\n        m, n = len(matrix), len(matrix[0])\\n\\n        # Initialize the result\\n        res = -inf\\n\\n        # Iterate the left pointer from 0 to n\\n        for l in range(n):\\n\\n            # Initialize the row prefix sum\\n            rowSums = [0] * m\\n\\n            # Iterate the right pointer from left to n\\n            for r in range(l, n):\\n\\n                # Calculate the row prefix sum from left to right\\n                for i in range(m):\\n                    rowSums[i] += matrix[i][r]\\n\\n                # Calculate the column prefix sums\\n                # Initialize a list to store previous column prefix sum\\n                colSums = [0]\\n\\n                # Intialize the column prefix sum\\n                colSum = 0\\n\\n                # Iterate through all row prefix sums\\n                for rowSum in rowSums:\\n\\n                    # Add the current row prefix sum to the column prefix sum\\n                    colSum += rowSum\\n\\n                    # Calculate the different between the column prefix sum and k\\n                    diff = colSum - k\\n\\n                    # Perform a binary search to find an index of a value is larger but cloest to the different among previously calculated column prefix sums\\n                    idx = bisect_right(colSums, diff)\\n\\n                    # Check if the different exists among the previously calculated column prefix sums\\n                    if idx - 1 >= 0 and colSums[idx - 1] == diff:\\n\\n                        # If yes, update the result\\n                        res = max(res, colSum - colSums[idx - 1])\\n\\n                        # End the search because we found the largest possible result\\n                        return k\\n\\n                    # Else, if the different does not exist among the previously calculated column prefix sums, check if there is a previously calculated column prefix sum larger than the different\\n                    elif idx != len(colSums):\\n\\n                        # If yes, update the result with the new area if it is larger than previous result\\n                        res = max(res, colSum - colSums[idx])\\n\\n                    # Insert the current column prefix sum into the list while maintaining the sorted order\\n                    insort(colSums, colSum)\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2488336,
                "title": "c-easy-solution-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int tar) {\\n        int m=matrix.size(),n=matrix[0].size();\\n        vector<vector<int>>dp(m+1,vector<int>(n,0));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                dp[i+1][j]=dp[i][j]+matrix[i][j];\\n            }\\n        }\\n        int ans=INT_MIN;\\n        for(int i=0;i<m;i++){\\n            for(int l=i+1;l<=m;l++){\\n                for(int j=0;j<n;j++){\\n                    int val=0;\\n                    for(int k=j;k<n;k++){\\n                        val+=dp[l][k]-dp[i][k];\\n                        \\n                        if(val<tar){\\n                            ans=max(ans,val);\\n                        }\\n                        else if(val==tar){\\n                            return tar;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# **Please share and Upvote it Motivates me**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int tar) {\\n        int m=matrix.size(),n=matrix[0].size();\\n        vector<vector<int>>dp(m+1,vector<int>(n,0));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                dp[i+1][j]=dp[i][j]+matrix[i][j];\\n            }\\n        }\\n        int ans=INT_MIN;\\n        for(int i=0;i<m;i++){\\n            for(int l=i+1;l<=m;l++){\\n                for(int j=0;j<n;j++){\\n                    int val=0;\\n                    for(int k=j;k<n;k++){\\n                        val+=dp[l][k]-dp[i][k];\\n                        \\n                        if(val<tar){\\n                            ans=max(ans,val);\\n                        }\\n                        else if(val==tar){\\n                            return tar;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2488344,
                "title": "java-easy-and-simple-solution-90-faster-code",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] arr, int k) {\\n        int rows = arr.length;\\n        int cols = arr[0].length;\\n        int maxK = Integer.MIN_VALUE;\\n        for(int i = 0; i < cols; i++){\\n            int dp[] = new int[rows];\\n            for(int j = i; j < cols; j++){\\n                for(int l = 0; l < rows; l++){\\n                    dp[l] += arr[l][j];\\n                }\\n                int currSum = maxSubArray(dp, k);\\n                maxK = Math.max(maxK, currSum);                 \\n                if(maxK == k)\\n                    return k;\\n            }\\n        }\\n        return maxK;\\n    }\\n    public int maxSubArray(int[] arr, int k) {\\n        int max = Integer.MIN_VALUE;\\n        int currSum = 0;\\n        TreeSet<Integer> set = new TreeSet<>();\\n        set.add(0);\\n        for (int i = 0; i < arr.length; i++) {\\n            currSum += arr[i];\\n            Integer ceilValue = set.ceiling(currSum - k);\\n            if(ceilValue != null) {\\n                max = Math.max(max, currSum - ceilValue);\\n            }\\n            set.add(currSum);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] arr, int k) {\\n        int rows = arr.length;\\n        int cols = arr[0].length;\\n        int maxK = Integer.MIN_VALUE;\\n        for(int i = 0; i < cols; i++){\\n            int dp[] = new int[rows];\\n            for(int j = i; j < cols; j++){\\n                for(int l = 0; l < rows; l++){\\n                    dp[l] += arr[l][j];\\n                }\\n                int currSum = maxSubArray(dp, k);\\n                maxK = Math.max(maxK, currSum);                 \\n                if(maxK == k)\\n                    return k;\\n            }\\n        }\\n        return maxK;\\n    }\\n    public int maxSubArray(int[] arr, int k) {\\n        int max = Integer.MIN_VALUE;\\n        int currSum = 0;\\n        TreeSet<Integer> set = new TreeSet<>();\\n        set.add(0);\\n        for (int i = 0; i < arr.length; i++) {\\n            currSum += arr[i];\\n            Integer ceilValue = set.ceiling(currSum - k);\\n            if(ceilValue != null) {\\n                max = Math.max(max, currSum - ceilValue);\\n            }\\n            set.add(currSum);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 83631,
                "title": "using-cumulative-sum-and-treeset",
                "content": "To find the max sum of an array, we can do as follows:\\n\\n* compute the cumulative sum of the array\\n* find a pair of i and j, constrained to i<j, and **cum[j]-cum[i]<=k**\\n* do some trick, the inequation above is actually **cum[j]-k<=cum[i]**, we need to find the minimum value of **cum[i]** in order to maximize **cum[j]-cum[i]**, that is, find **TreeSet.ceiling(cum[j]-k)**\\n* if founded in the treeset, the value is actually **cum[i]**, by subtract **cum[i]** from **cum[j]**, we update the result\\nThe Max sum of rectangle on larger than k can be transformed into the problem of finding the max sum of an array no larger than k by slicing  the matrix:\\n```\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int result = Integer.MIN_VALUE;\\n        for (int begin = 0; begin < n; begin++) {\\n            for (int end = begin + 1; end <= n; end++) {\\n                int[] arr = new int[m];\\n                for (int i = 0; i < m; i++) {\\n                    for (int j = begin; j < end; j++) {\\n                        arr[i] += matrix[i][j];\\n                    }\\n                }\\n                TreeSet<Integer> treeSet = new TreeSet<>();\\n                treeSet.add(0);\\n                int cumulative = 0;\\n                for (int i : arr) {\\n                    cumulative += i;\\n                    Integer ceiling = treeSet.ceiling(cumulative - k);\\n                    if (ceiling != null) {\\n                        result = Math.max(result, cumulative - ceiling);\\n                    }\\n                    treeSet.add(cumulative);\\n                }\\n            }\\n        }\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "To find the max sum of an array, we can do as follows:\\n\\n* compute the cumulative sum of the array\\n* find a pair of i and j, constrained to i<j, and **cum[j]-cum[i]<=k**\\n* do some trick, the inequation above is actually **cum[j]-k<=cum[i]**, we need to find the minimum value of **cum[i]** in order to maximize **cum[j]-cum[i]**, that is, find **TreeSet.ceiling(cum[j]-k)**\\n* if founded in the treeset, the value is actually **cum[i]**, by subtract **cum[i]** from **cum[j]**, we update the result\\nThe Max sum of rectangle on larger than k can be transformed into the problem of finding the max sum of an array no larger than k by slicing  the matrix:\\n```\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int result = Integer.MIN_VALUE;\\n        for (int begin = 0; begin < n; begin++) {\\n            for (int end = begin + 1; end <= n; end++) {\\n                int[] arr = new int[m];\\n                for (int i = 0; i < m; i++) {\\n                    for (int j = begin; j < end; j++) {\\n                        arr[i] += matrix[i][j];\\n                    }\\n                }\\n                TreeSet<Integer> treeSet = new TreeSet<>();\\n                treeSet.add(0);\\n                int cumulative = 0;\\n                for (int i : arr) {\\n                    cumulative += i;\\n                    Integer ceiling = treeSet.ceiling(cumulative - k);\\n                    if (ceiling != null) {\\n                        result = Math.max(result, cumulative - ceiling);\\n                    }\\n                    treeSet.add(cumulative);\\n                }\\n            }\\n        }\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 147759,
                "title": "clean-java-code-with-treeset-beat-99-99",
                "content": "Same idea: use the same rule to get the all the submatrix prefixsum. The lgn is **not** because the binary search. The reason lgN is here we use balanced bst here. (In java, TreeSet or TreeMap)\\n\\n    //Time: O(n * n * (m) * lgm) n means the col size and m row size\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        int result = Integer.MIN_VALUE;\\n        \\n        for(int j = 0; j < col; j++) {\\n            int[] sum = new int[row];\\n            \\n            for(int current = j; current < col; current++) {\\n                for(int i = 0; i < row; i++) {\\n                    sum[i] += matrix[i][current];\\n                }\\n                \\n                int temp = find(sum, k);\\n                \\n                result = Math.max(temp, result);\\n                \\n            }\\n            \\n        }\\n        return result;\\n    }\\n    //O(lgM) find the maxium gap\\n    private int find(int[] sum, int k) {\\n        int result = Integer.MIN_VALUE;\\n        TreeSet<Integer> set = new TreeSet<>();\\n        set.add(0);\\n        int current = 0;\\n        for(int i = 0; i < sum.length; i++) {\\n            current += sum[i];\\n            \\n            Integer target = set.ceiling(current - k); \\n                \\n            if(target != null) {\\n                result = Math.max(result, current - target);\\n            }\\n            set.add(current);\\n        }\\n        \\n        return result;\\n    }\\n",
                "solutionTags": [],
                "code": "Same idea: use the same rule to get the all the submatrix prefixsum. The lgn is **not** because the binary search. The reason lgN is here we use balanced bst here. (In java, TreeSet or TreeMap)\\n\\n    //Time: O(n * n * (m) * lgm) n means the col size and m row size\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        int result = Integer.MIN_VALUE;\\n        \\n        for(int j = 0; j < col; j++) {\\n            int[] sum = new int[row];\\n            \\n            for(int current = j; current < col; current++) {\\n                for(int i = 0; i < row; i++) {\\n                    sum[i] += matrix[i][current];\\n                }\\n                \\n                int temp = find(sum, k);\\n                \\n                result = Math.max(temp, result);\\n                \\n            }\\n            \\n        }\\n        return result;\\n    }\\n    //O(lgM) find the maxium gap\\n    private int find(int[] sum, int k) {\\n        int result = Integer.MIN_VALUE;\\n        TreeSet<Integer> set = new TreeSet<>();\\n        set.add(0);\\n        int current = 0;\\n        for(int i = 0; i < sum.length; i++) {\\n            current += sum[i];\\n            \\n            Integer target = set.ceiling(current - k); \\n                \\n            if(target != null) {\\n                result = Math.max(result, current - target);\\n            }\\n            set.add(current);\\n        }\\n        \\n        return result;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2491089,
                "title": "brute-force-binary-search-on-prefix-sum-explained",
                "content": "Note; \\nI\\'ve attached a link at the bottom to a post I\\'ve made explaining all the details like prefix matrix and rectangles in super great detail.\\n\\nThis post touches them briefly.\\n<hr />\\n\\nI\\'ve used few tricks for the solution.\\n\\n* Prefix matrix (extension of prefix sums) - `matrix_prefix[row][col]` is the sum of the matrix from `0, 0` (origin) to `row, col` (in code there is a buffer of +1 to every dimension to handle boundaries easier)\\n\\nThe prefix matrix is used to calculate the sum of a rectange in O(1) time.\\n\\n* Rectangle - A rectangle can be represented as a pair of cartesian coordinates `(x1, y1), (x2, y2)`\\n\\n\\n# Brute force\\nUnderstanding the previous ideas, one could generate all possible rectangle pairs and calculate the sum using the prefix matrix. That will cost `O(n^2*m^2)` or `O(n^4)` assume n=m\\n\\n```\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        ans = float(\\'-inf\\')\\n        \\n        matrix_prefix = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\\n        \\n        for row in range(1, m + 1):\\n            for col in range(1, n + 1):\\n                matrix_prefix[row][col] = matrix[row - 1][col - 1] + matrix_prefix[row-1][col] + matrix_prefix[row][col-1] - matrix_prefix[row-1][col-1]\\n        \\n        for y1 in range(m):\\n            for x1 in range(n):\\n                for y2 in range(y1, m):\\n                    for x2 in range(x1, n):\\n                        SUM = matrix_prefix[y2 + 1][x2 + 1] - matrix_prefix[y1][x2+1] - matrix_prefix[y2+1][x1] + matrix_prefix[y1][x1]\\n                        if SUM <= k:\\n                            ans = max(ans, SUM)\\n        return ans\\n```\\n\\n# Binary search\\nAn optimization is to fix 2 vertical points. (y1, y2) and iterate the whole horizontal space, x.\\n\\nThis turns the problem into a \"subarray sum equal k\" problem. We have a running sum and also we remember the prefixes of the sums we\\'ve seen.\\n\\nWhenever we subtract a prefix sum from the current sum we can find the \"middle sum\".\\n\\nNow image `k=10` and our current window sum is 8, we we have -2 as a prefix then we could subtract it and get to window sum = 10.\\n\\nSo we need to subtract a value with AT MOST -2. -2 is our `complement`.\\n\\nTo find the best matching prefix (to -2 in the former example) we will use a binary search.\\n\\n```\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        ans = float(\\'-inf\\')\\n        \\n        matrix_prefix = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\\n        \\n        for row in range(1, m + 1):\\n            for col in range(1, n + 1):\\n                matrix_prefix[row][col] = matrix[row - 1][col - 1] + matrix_prefix[row-1][col] + matrix_prefix[row][col-1] - matrix_prefix[row-1][col-1]\\n        \\n        for y1 in range(m):\\n            for y2 in range(y1, m):\\n                x_sums = []\\n                for x in range(n):\\n                    rec_sum = matrix_prefix[y2 + 1][x + 1] - matrix_prefix[y1][x+1] - matrix_prefix[y2+1][0] + matrix_prefix[y1][0]\\n                    comp = rec_sum - k\\n                    \\n                    if rec_sum <= k:\\n                        ans = max(ans, rec_sum)\\n                        \\n                    i = bisect.bisect_left(x_sums, comp)    \\n                    if x_sums and i < len(x_sums):\\n                        if rec_sum - x_sums[i] <= k:\\n                            ans = max(ans, rec_sum - x_sums[i])\\n                    \\n                    bisect.insort(x_sums, rec_sum)\\n                    \\n        return ans\\n```\\n\\n\\n# Note\\n* I\\'ve went over most technical concepts in a brief, like prefix matrix and turning the problem into \"subarray sum equal k\". I\\'ve made an in depth discussion to a similar question, please check it out if you are interested in more details\\n\\nhttps://leetcode.com/problems/number-of-submatrices-that-sum-to-target/discuss/2298642/fully-explained-intuition-4-solutions-must-read-with-image",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        ans = float(\\'-inf\\')\\n        \\n        matrix_prefix = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\\n        \\n        for row in range(1, m + 1):\\n            for col in range(1, n + 1):\\n                matrix_prefix[row][col] = matrix[row - 1][col - 1] + matrix_prefix[row-1][col] + matrix_prefix[row][col-1] - matrix_prefix[row-1][col-1]\\n        \\n        for y1 in range(m):\\n            for x1 in range(n):\\n                for y2 in range(y1, m):\\n                    for x2 in range(x1, n):\\n                        SUM = matrix_prefix[y2 + 1][x2 + 1] - matrix_prefix[y1][x2+1] - matrix_prefix[y2+1][x1] + matrix_prefix[y1][x1]\\n                        if SUM <= k:\\n                            ans = max(ans, SUM)\\n        return ans\\n```\n```\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        ans = float(\\'-inf\\')\\n        \\n        matrix_prefix = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\\n        \\n        for row in range(1, m + 1):\\n            for col in range(1, n + 1):\\n                matrix_prefix[row][col] = matrix[row - 1][col - 1] + matrix_prefix[row-1][col] + matrix_prefix[row][col-1] - matrix_prefix[row-1][col-1]\\n        \\n        for y1 in range(m):\\n            for y2 in range(y1, m):\\n                x_sums = []\\n                for x in range(n):\\n                    rec_sum = matrix_prefix[y2 + 1][x + 1] - matrix_prefix[y1][x+1] - matrix_prefix[y2+1][0] + matrix_prefix[y1][0]\\n                    comp = rec_sum - k\\n                    \\n                    if rec_sum <= k:\\n                        ans = max(ans, rec_sum)\\n                        \\n                    i = bisect.bisect_left(x_sums, comp)    \\n                    if x_sums and i < len(x_sums):\\n                        if rec_sum - x_sums[i] <= k:\\n                            ans = max(ans, rec_sum - x_sums[i])\\n                    \\n                    bisect.insort(x_sums, rec_sum)\\n                    \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 83632,
                "title": "easy-understand-python-ac-solution-with-clear-comments",
                "content": "The idea comes from the C++ or Java solution posted on discuss, I just rewrite the idea with python.\\n* using two pointers to scan the column, Space is O(col)\\n* `left` and `right` both start from the 0, and move `right` first when it reaches the end then move `left`\\n* record the sum of the value and find the max sum less than k \\n* the following code can also be used to solve `Max Sum of Sub-Matrix `, only need to replace the `maxSubArraylessK` with `Kadane's algorithm`\\n\\n```\\n def maxSubArraylessK(self,nums,k):\\n        \"\"\"\\n        we need to find the sum[right]-sum[left]<=k\\n        since the bitsect return the index of the sorted value\\n        we can't directly pop the nums[idx] \\n        we should use insort from the bisect\\n        \"\"\"\\n        # python set() doesn't support indexing, using list instead\\n        # similar as the c++ or java set()\\n        \\n        cumset=[]\\n        cumset.append(0)\\n        maxsum=-1<<32\\n        cursum=0\\n        for i in xrange(len(nums)):\\n            cursum+=nums[i]\\n            # find the lower bound of the index\\n            idx=bisect.bisect_left(cumset,cursum-k)\\n            # find max in sum[right]-sum[left]<=k\\n            if 0<=idx<len(cumset):\\n                maxsum=max(maxsum,cursum-cumset[idx])\\n            # using insort instead of append since bisect_left reason\\n            bisect.insort(cumset,cursum)\\n        return maxsum\\n    \\n    \\n    def maxSumSubmatrix(self, matrix, k):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        \"\"\"\\n        The python solution hasn't a good time performance,\\n        since lack some of the datatype to do \\n        I am trying to imitate the way solved in c++ or Java\\n        Ther related quesiton might be:\\n        1. #53. Maximum Subarray \\n        2. Maximum Subarray sum less or equal than K\\n        3. maximun sum of rectangle \\n        \"\"\"\\n        if not matrix or not matrix[0]:\\n            return 0\\n        row,col=len(matrix),len(matrix[0])\\n        res=-(1<<32)\\n        # using two pointer to record the scan position\\n        for left in xrange(col):\\n            # reset mem to store the row data\\n            cursums=[0 for _ in xrange(row)]\\n            # since the rectange has area>0 \\n            right=left\\n            while right<col:\\n                # count one row\\n                for i in xrange(row):\\n                    cursums[i]+=matrix[i][right]\\n                # find the max in this row\\n                curarrmax=self.maxSubArraylessK(cursums,k)\\n                res=max(res,curarrmax)\\n                right+=1\\n                \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n def maxSubArraylessK(self,nums,k):\\n        \"\"\"\\n        we need to find the sum[right]-sum[left]<=k\\n        since the bitsect return the index of the sorted value\\n        we can't directly pop the nums[idx] \\n        we should use insort from the bisect\\n        \"\"\"\\n        # python set() doesn't support indexing, using list instead\\n        # similar as the c++ or java set()\\n        \\n        cumset=[]\\n        cumset.append(0)\\n        maxsum=-1<<32\\n        cursum=0\\n        for i in xrange(len(nums)):\\n            cursum+=nums[i]\\n            # find the lower bound of the index\\n            idx=bisect.bisect_left(cumset,cursum-k)\\n            # find max in sum[right]-sum[left]<=k\\n            if 0<=idx<len(cumset):\\n                maxsum=max(maxsum,cursum-cumset[idx])\\n            # using insort instead of append since bisect_left reason\\n            bisect.insort(cumset,cursum)\\n        return maxsum\\n    \\n    \\n    def maxSumSubmatrix(self, matrix, k):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        \"\"\"\\n        The python solution hasn't a good time performance,\\n        since lack some of the datatype to do \\n        I am trying to imitate the way solved in c++ or Java\\n        Ther related quesiton might be:\\n        1. #53. Maximum Subarray \\n        2. Maximum Subarray sum less or equal than K\\n        3. maximun sum of rectangle \\n        \"\"\"\\n        if not matrix or not matrix[0]:\\n            return 0\\n        row,col=len(matrix),len(matrix[0])\\n        res=-(1<<32)\\n        # using two pointer to record the scan position\\n        for left in xrange(col):\\n            # reset mem to store the row data\\n            cursums=[0 for _ in xrange(row)]\\n            # since the rectange has area>0 \\n            right=left\\n            while right<col:\\n                # count one row\\n                for i in xrange(row):\\n                    cursums[i]+=matrix[i][right]\\n                # find the max in this row\\n                curarrmax=self.maxSubArraylessK(cursums,k)\\n                res=max(res,curarrmax)\\n                right+=1\\n                \\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2488882,
                "title": "solution-in-python",
                "content": "The bisect_left() method is provided by the bisect module, which returns the left-most index to insert the given element, while maintaining the sorted order.\\nThe insort function is the second step that does the real insertion process. The function returns the list after the element has been inserted in the rightmost index without altering the sorted order.\\n\\n```\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        ans = float(\"-inf\")\\n        m, n = len(matrix), len(matrix[0])\\n        for i in range(n):\\n            lstSum = [0] * m\\n            for j in range(i, n):\\n                currSum = 0\\n                curlstSum = [0]\\n                for t in range(m):\\n                    lstSum[t] += matrix[t][j]\\n                    currSum += lstSum[t]\\n                    pos = bisect_left(curlstSum, currSum - k)\\n                    if pos < len(curlstSum):\\n                        if curlstSum[pos] == currSum - k:\\n                            return k\\n                        else:\\n                            ans = max(ans, currSum - curlstSum[pos])\\n                    insort(curlstSum, currSum)\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        ans = float(\"-inf\")\\n        m, n = len(matrix), len(matrix[0])\\n        for i in range(n):\\n            lstSum = [0] * m\\n            for j in range(i, n):\\n                currSum = 0\\n                curlstSum = [0]\\n                for t in range(m):\\n                    lstSum[t] += matrix[t][j]\\n                    currSum += lstSum[t]\\n                    pos = bisect_left(curlstSum, currSum - k)\\n                    if pos < len(curlstSum):\\n                        if curlstSum[pos] == currSum - k:\\n                            return k\\n                        else:\\n                            ans = max(ans, currSum - curlstSum[pos])\\n                    insort(curlstSum, currSum)\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 741420,
                "title": "java-3ms-beats-100-no-binary-search-no-treeset",
                "content": "The basic idea is to use one 1-d array to record all possible area values every time we go through the matrix for every possible rectangle, and try to find the value we want. Every time we find a value which equals to k, we can just return it.\\n\\nWe do the outer loop column by column, and the inner loop row by row to find all possible rectangle.\\n\\nLet\\'s say we have a matrix as below:\\n\\n1  2  3\\n4  5  6\\n7  8  9\\n\\nWe start from column 0  and we are at column 1 now (the bold part). sum[i] means the accumulative area value for the i + 1 row.\\n**1**  **2**  3   ... sum[0] = 1 + 2 = 3\\n**4**  **5**  6   ... sum[1] = 4 + 5 = 9\\n**7**  **8**  9   ... sum[2] = 7 + 8 = 15\\n\\nThen we can try to find the result in the sum array by checking its subarray starting from sum[0]. It would give us the potential possible largest result. \\n\\n```\\nint curr = 0;\\nint max = sum[0];\\nfor (int n : sum) {\\n      curr = Math.max(n, curr + n);\\n      max = Math.max(curr, max);\\n      if (max == k) return max;\\n}\\n```\\n\\nIf max is smaller than k, the result would be the larger one between max and res. (we can prove that the current max is the largest possible result for the current rectangle we are at now (the bold part), there is no need to check it row by row). \\n\\nIf max is lager than k, it means we have to check the rectangle (the bold part as below) row by row.  (Actually we can just do this part to find the result directly but if we check the largest possible value from sum[0] first we can save like 50% time.)\\n\\n**1**  **2**   ... row 0\\n**4**  **5**   ... row 1\\n**7**  **8**   ... row 2\\n\\nCheck row0, row0 + row1, row0 + row1 + row2, row1, row1 + row2, row2. \\n\\nHope it could help.\\n\\n```\\npublic int maxSumSubmatrix(int[][] matrix, int k) {\\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0)\\n            return 0;\\n        \\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n     \\n        int res = Integer.MIN_VALUE;\\n        for (int i = 0; i < col; i++) {\\n            int[] sum = new int[row];\\n            for (int j = i; j < col; j++) {\\n                for (int r = 0; r < row; r++) {\\n                    sum[r] += matrix[r][j];\\n                }\\n                int curr = 0;\\n                int max = sum[0];\\n                for (int n : sum) {\\n                    curr = Math.max(n, curr + n);\\n                    max = Math.max(curr, max);\\n                    if (max == k) return max;\\n                }\\n                if (max < k) {\\n                    res = Math.max(max, res);\\n                } else {\\n                    for (int a = 0; a < row; a++) {\\n                        int currSum = 0;\\n                        for (int b = a; b < row; b++) {\\n                            currSum += sum[b];\\n                            if (currSum <= k) res = Math.max(currSum, res);\\n                        }\\n                    }\\n                    if (res == k) return res;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n",
                "solutionTags": [],
                "code": "```\\nint curr = 0;\\nint max = sum[0];\\nfor (int n : sum) {\\n      curr = Math.max(n, curr + n);\\n      max = Math.max(curr, max);\\n      if (max == k) return max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 739739,
                "title": "javascript-clean-dp-solution",
                "content": "Time Complexity: where `R` - num of Rows, `C` - num of Cols\\n* Average: `O(R^2 * C)` when kadane\\'s `max` <= `k`\\n* Worst: `O(R^2 * C^2)` when kadane\\'s `max` >`k`\\n\\n```javascript\\nvar maxSumSubmatrix = function(matrix, k) {\\n    const R_NUM = matrix.length, C_NUM = matrix[0].length;\\n    let maxSum = -Infinity;\\n    \\n    for(let l = 0; l < R_NUM; l++) {\\n        const dp = Array(C_NUM).fill(0);\\n        \\n        for(let r = l; r < R_NUM; r++) {\\n            let sum = 0, max = -Infinity;\\n            \\n            for(let c = 0; c < C_NUM; c++) {\\n                // build running dp array\\n                dp[c] += matrix[r][c];\\n                \\n                // implement kadane\\'s algorithm\\n                if(sum < 0) sum = 0;\\n                sum += dp[c];\\n                max = Math.max(max, sum);\\n            }\\n            \\n            // if max <= k take kadane\\'s algorithm\\n            if(max <= k) maxSum = Math.max(max, maxSum);\\n            else {\\n                // if max > k find the max subarray sum no larger than k\\n                max = -Infinity;\\n\\n                for(let c = 0; c < C_NUM; c++) {\\n                    sum = 0;\\n\\n                    for(let d = c; d < C_NUM; d++) {\\n                        sum += dp[d];\\n                        if(sum <= k) max = Math.max(sum, max);\\n                    }\\n                }\\n                maxSum = Math.max(max, maxSum);\\n            }\\n            if(maxSum === k) return k; // short circuit\\n        }\\n    }\\n    return maxSum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```javascript\\nvar maxSumSubmatrix = function(matrix, k) {\\n    const R_NUM = matrix.length, C_NUM = matrix[0].length;\\n    let maxSum = -Infinity;\\n    \\n    for(let l = 0; l < R_NUM; l++) {\\n        const dp = Array(C_NUM).fill(0);\\n        \\n        for(let r = l; r < R_NUM; r++) {\\n            let sum = 0, max = -Infinity;\\n            \\n            for(let c = 0; c < C_NUM; c++) {\\n                // build running dp array\\n                dp[c] += matrix[r][c];\\n                \\n                // implement kadane\\'s algorithm\\n                if(sum < 0) sum = 0;\\n                sum += dp[c];\\n                max = Math.max(max, sum);\\n            }\\n            \\n            // if max <= k take kadane\\'s algorithm\\n            if(max <= k) maxSum = Math.max(max, maxSum);\\n            else {\\n                // if max > k find the max subarray sum no larger than k\\n                max = -Infinity;\\n\\n                for(let c = 0; c < C_NUM; c++) {\\n                    sum = 0;\\n\\n                    for(let d = c; d < C_NUM; d++) {\\n                        sum += dp[d];\\n                        if(sum <= k) max = Math.max(sum, max);\\n                    }\\n                }\\n                maxSum = Math.max(max, maxSum);\\n            }\\n            if(maxSum === k) return k; // short circuit\\n        }\\n    }\\n    return maxSum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2298524,
                "title": "c-simple-c-code",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 1; j < m; j++)\\n            {\\n                matrix[i][j] += matrix[i][j-1];\\n            }\\n        }\\n        int ans = INT_MIN;\\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = i; j < m; j++)\\n            {\\n                int rowsum = 0;\\n                set<int> tmp = {0};\\n                for(int f = 0; f < n; f++)\\n                {\\n                    rowsum += matrix[f][j];\\n                    if(i > 0)\\n                        rowsum -= matrix[f][i-1];\\n                    auto lb = tmp.lower_bound(rowsum-k);\\n                    if(lb != tmp.end())\\n                        ans = max(ans, rowsum-*lb);\\n                    tmp.insert(rowsum);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 1; j < m; j++)\\n            {\\n                matrix[i][j] += matrix[i][j-1];\\n            }\\n        }\\n        int ans = INT_MIN;\\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = i; j < m; j++)\\n            {\\n                int rowsum = 0;\\n                set<int> tmp = {0};\\n                for(int f = 0; f < n; f++)\\n                {\\n                    rowsum += matrix[f][j];\\n                    if(i > 0)\\n                        rowsum -= matrix[f][i-1];\\n                    auto lb = tmp.lower_bound(rowsum-k);\\n                    if(lb != tmp.end())\\n                        ans = max(ans, rowsum-*lb);\\n                    tmp.insert(rowsum);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 665160,
                "title": "java-treeset-solution-with-m-m-nlog-n-time",
                "content": "First, let us simplify the problem, imagine this is a single - row matrix, which is equivalent to 1D array. How do we find the max subarray such that its sum is no larger than k? If all elements are non-negative, the problem can be much easier, \\u201Csliding window\\u201D could be a good start. However, there are negative elements as well. Accordingly, there is no fixed window or fixed amount we could refer to. When we do not know how to approach a problem, we can always start from a brute force solution.\\ncheck out my youtube link right here: https://youtu.be/gD4dzeQ6YH0\\n\\nBrute force :\\n\\tget all possible subarrays, and sum each respectively to find the closest sum to k.\\n\\tO(n^3)\\nMore optimized:\\n\\tTo avoid sum up subarrays multiple times, we can use prefixSum.\\n\\tO(n^2)\\nFurther optimized:\\n\\tprefixSum - x <= k\\n\\tx >= prefixSum - k\\nwe are looking for a previous prefixSum that is smallest larger or equal to \\u201CprefixSum - k\\u201D\\nTreeSet can help us with the implementation.\\nO(nlog(n)\\n\\t\\nNow, let\\'s come back to a 2D matrix. To convert it to a 1D array, we use a double for loop to get all possible consecutive-rows combinations and add them up. The rest is just the same as what we did for 1D array. If \\u201Cm\\u201D represents total rows, \\u201Cn\\u201D represents total cols, the time complexity is O(m * m * nlog(n)).\\n\\n```\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int m = matrix.length, n = matrix[0].length;\\n        \\n        int max = Integer.MIN_VALUE;\\n        // step 1\\n        for (int i = 0; i < m; i++) {\\n            int[] add = new int[n];\\n            for (int j = i; j < m; j++) {\\n                sum(add, matrix[j]);\\n                \\n                TreeSet<Integer> treeset = new TreeSet<>();\\n                max = Math.max(max, helper(add, treeset, k));\\n                if (max == k) {\\n                    return max;\\n                }\\n            }\\n        }\\n        return max == Integer.MIN_VALUE ? -1 : max;\\n    }\\n    private int helper(int[] add, TreeSet<Integer> treeset, int k) {\\n        treeset.add(0);\\n        int prefixSum = 0;\\n        int curMax = Integer.MIN_VALUE;\\n        for (int ele : add) {\\n            prefixSum += ele;\\n            Integer ceil = treeset.ceiling(prefixSum - k);\\n            if (ceil != null) {\\n                if (prefixSum - ceil == k) {\\n                    return k;\\n                } else {\\n                    curMax = Math.max(curMax, prefixSum - ceil);\\n                }\\n            }\\n            treeset.add(prefixSum);\\n        }\\n        return curMax;\\n    }\\n    private void sum(int[] add, int[] cols) {\\n        for (int i = 0; i < cols.length; i++){\\n            add[i] += cols[i];\\n        }\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int m = matrix.length, n = matrix[0].length;\\n        \\n        int max = Integer.MIN_VALUE;\\n        // step 1\\n        for (int i = 0; i < m; i++) {\\n            int[] add = new int[n];\\n            for (int j = i; j < m; j++) {\\n                sum(add, matrix[j]);\\n                \\n                TreeSet<Integer> treeset = new TreeSet<>();\\n                max = Math.max(max, helper(add, treeset, k));\\n                if (max == k) {\\n                    return max;\\n                }\\n            }\\n        }\\n        return max == Integer.MIN_VALUE ? -1 : max;\\n    }\\n    private int helper(int[] add, TreeSet<Integer> treeset, int k) {\\n        treeset.add(0);\\n        int prefixSum = 0;\\n        int curMax = Integer.MIN_VALUE;\\n        for (int ele : add) {\\n            prefixSum += ele;\\n            Integer ceil = treeset.ceiling(prefixSum - k);\\n            if (ceil != null) {\\n                if (prefixSum - ceil == k) {\\n                    return k;\\n                } else {\\n                    curMax = Math.max(curMax, prefixSum - ceil);\\n                }\\n            }\\n            treeset.add(prefixSum);\\n        }\\n        return curMax;\\n    }\\n    private void sum(int[] add, int[] cols) {\\n        for (int i = 0; i < cols.length; i++){\\n            add[i] += cols[i];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2488679,
                "title": "explanation-and-example-for-the-binary-search-part",
                "content": "This problem can be solved by combining (1) Kadane\\'s algorithm, and (2) binary search.\\n\\nMany have talked about (1) the Kadane\\'s part.\\n\\nFor people who stumbled on the (2) binary search part below, here is some explanation and example.\\n\\nI am going to explain\\n\\n```c++\\n// vector<int> sums is the vector for the sums of each rows\\n// int res is our desired result\\n\\nset<int> s{0};\\nint cumsum = 0;\\nfor (int x : sums) {\\n\\tcumsum += x;\\n\\tconst auto it = s.lower_bound(cumsum - k);\\n\\tif (it != s.cend()) {\\n\\t\\tres = std::max(res, cumsum - *it);\\n\\t}\\n\\ts.insert(cumsum);\\n}\\n```\\n\\nGiven `k = 6` and\\n\\n```\\n   index    0    1    2    3\\n    sums    5    8   -6    4\\n```\\n\\nour goal is to update `res` with the max subarray sum in `[ 5 8 -6 4 ]` whose value is no greater than `k=6`.\\n\\nNote that we can\\'t directly apply Kadane\\'s algorithm here, because we have a constraint.\\n\\nThe above algorithm works out the `cumsum` one by one, and each time adds one cumsum to a set.\\n\\n```\\n   index    0    1    2    3\\n    sums    5    8   -6    4\\n cumsums    5    13   7   11\\n```\\n\\nNote that\\n\\n```\\nsubarray_sum in (a, b] = cumsums[b] - cumsums[a]\\n```\\n\\nGiven `b` and `k`, we would like to find the largest `subarray_sum in (a,b]`  such that\\n\\n```\\nsubarray_sum in (a,b] <= k\\n```\\n\\nor\\n\\n```\\ncumsums[b] - cumsums[a] <= k\\n```\\n\\nwhich is to find a smallest `cumsums[a]` such that\\n\\n```\\ncumsums[a] >= cumsums[b] - k\\n```\\n\\nand this is to find the smallest previous cumsum that is greater than or equal to `cumsums[b] - k`, which is the lower bound.\\n\\n```\\n   index    0    1    2    3\\n    sums    5    8   -6    4\\n cumsums    5    13   7   11\\n```\\n\\nFor example, when we are at index `3`, our set is `{0, 5, 13, 7}`, and we want to find the smallest item in this set that greater than or equal to `cumsums[b] - k = 11 - 6 = 5`. So we got `cumsums[a] = 5` from our set. So we can update `res` with max subarray sum `cumsums[b] - cumsums[a] = 11 - 5 = 6`.\\n\\n",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```c++\\n// vector<int> sums is the vector for the sums of each rows\\n// int res is our desired result\\n\\nset<int> s{0};\\nint cumsum = 0;\\nfor (int x : sums) {\\n\\tcumsum += x;\\n\\tconst auto it = s.lower_bound(cumsum - k);\\n\\tif (it != s.cend()) {\\n\\t\\tres = std::max(res, cumsum - *it);\\n\\t}\\n\\ts.insert(cumsum);\\n}\\n```\n```\\n   index    0    1    2    3\\n    sums    5    8   -6    4\\n```\n```\\n   index    0    1    2    3\\n    sums    5    8   -6    4\\n cumsums    5    13   7   11\\n```\n```\\nsubarray_sum in (a, b] = cumsums[b] - cumsums[a]\\n```\n```\\nsubarray_sum in (a,b] <= k\\n```\n```\\ncumsums[b] - cumsums[a] <= k\\n```\n```\\ncumsums[a] >= cumsums[b] - k\\n```\n```\\n   index    0    1    2    3\\n    sums    5    8   -6    4\\n cumsums    5    13   7   11\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2088522,
                "title": "java-prefix-sum-bottom-right-rectangles-with-explanation-and-comments",
                "content": "**Intuition**: There are probably too many rectangles (and thus too many cells to add) to brute force this.  But if we can speed up the computation of the sum of a given rectangle, then can we expect to reach an answer without TLE?  We can get a sense of this from the limits.  The max width and height of the matrix are both 100.  Let\\'s take these maxima as the worst case.  So we have 100 choices of starting row and thus 100x101/2 choices of starting row and height.  Similarly, we have 100x101/2 choices for starting column and width.  So we have 25502500 total rectangles to compute in the worst case.  This is about 2.5x10^7.  If we can keep the computation of each rectangle O[1] then we\\'ll have O\\\\[m^2 n^2\\\\] for our overall runtime.  What if we track the bottom right sums of the complete rectangles (ending at height-1, width-1, inclusive) at a given (r0, c0)?  (This is actually more of a suffix sum than a prefix sum, but let\\'s see where it goes.)  Then, we have a way to compute the sum of a rectangle (r0, c0, rf, cf).  (Here, `r0` means initial (top) row, `rf` = final (bottom) row, `c0` = initial (left) column and `cf` = final (right) column).  We can visualize this to see it:\\n\\n```\\n     (r0, c0)                  (r0, cf+1)          (r0, width)\\n\\t          +--------------------------+--------------------+\\n\\t\\t\\t  |                          |                    |\\n\\t\\t\\t  |           (A)            |        (B)         |\\n\\t\\t\\t  |     target rectangle     |  right rectangle   |\\n\\t\\t\\t  |                          |                    |\\n  (rf+1, c0)  |             (rf+1, cf+1) |      (rf+1, width) |\\n\\t          +--------------------------+--------------------+\\n\\t\\t\\t  |                          |                    |\\n\\t\\t\\t  |           (C)            |        (D)         |\\n\\t\\t\\t  |     lower rectangle      |  lower-right rect. |\\n\\t\\t\\t  |                          |                    |\\n (height, c0) |           (height, cf+1) |    (height, width) |\\n\\t\\t\\t  +--------------------------+--------------------+\\n```\\n\\nThe entire rectangle (r0, c0, height, width) is comprised of four inner rectangles.  And if we precompute the entire rectangles (\\\\*, \\\\*, height, width) then we can say that:\\n\\ntarget rectangle = (r0, c0, height, width) - (r0, cf+1, height, width) - (rf+1, c0, height, width) + (rf+1, cf+1, height, width)\\n\\nNote that we are adding in the lower-right rectangle again because we have subtracted it away twice, so we add it back in to ensure our sum is correct.\\n\\nSo, we can see, if we precompute the sum for every rectangle (\\\\*, \\\\*, height, width), we can compute the sum of every rectangle (\\\\*, \\\\*, \\\\*, \\\\*) with two subtractions and an addition.  This keeps us under 10^8 operations and might be fast enough to complete within the time limit.\\n\\n**Buillding up the  bottom-right sums**:  We take advantage of the same identity, building the sum up from m, n right-to-left and bottom-to-top.  We\\'ll use a sum matrix of size \\\\[m+1\\\\]\\\\[n+1\\\\] in order to have zeros at the extremes and not worry about range checking in our sums matrix.  If our matrix name for sums is `brsum` for \"bottom-right sum\", and if we notice that our new sum at (r, c) is the value at (r, c) plus the sum to the right, plus the sum below, minus the sum below-and-right (we have to subtract it because it got added twice), we have\\n```\\n    brsum[r][c] = matrix[r][c] + brsum[r][c + 1] + brsum[r + 1][c] - brsum[r + 1][c + 1];\\n```\\n\\n**Optimizations**: First, if we encounter the value k in the matrix at (r, c), then we have a 1x1 rectangle with sum k - this means our answer is k and we can simply return early.  Second, as we are computing all sums for all possible rectangles, if we encounter k as a rectangle sum, we can also return early, as there is no way to improve upon this.\\n\\n**Code**: O\\\\[m\\\\*n\\\\] space, O\\\\[m^2\\\\*n^2\\\\] time.  Runtimes around ~230ms plus or minus 20ms, faster than about 75 or 80% as of May 2022.  Not the most optimal algorithm, but completes well within the time limit.\\n\\n```\\nclass Solution {\\n\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        final int m = matrix.length;\\n        if (m < 1) {\\n            throw new IllegalArgumentException(\"empty matrix - no rows\");\\n        }\\n        final int n = matrix[0].length;\\n        if (n < 1) {\\n            throw new IllegalArgumentException(\"empty matrix - no columns\");\\n        }\\n        // Let\\'s make our bottom-right sum matrix wider and higher by 1 each, so we don\\'t go out of range.\\n        // All of the values r >= m and c >= n should be 0 (and will default to 0 during array construction).\\n        final int[][] brsum = new int[m + 1][n + 1];\\n        // Build up from bottom right, bottom to top and right to left.\\n        for (int r = (m - 1); r >= 0; --r) {\\n            for (int c = (n - 1); c >= 0; --c) {\\n                final int val = matrix[r][c];\\n                // did we happen to find a 1x1 rectangle at (r, c) which sums to k?\\n                if (val == k) {\\n                    return val;\\n                }\\n                // Extend the sum: value + right + down - rightAndDown (because rightAndDown was added twice)\\n                brsum[r][c] = matrix[r][c] + brsum[r][c + 1] + brsum[r + 1][c] - brsum[r + 1][c + 1];\\n            }\\n        }\\n        // Now, we search.\\n        int maxSum = Integer.MIN_VALUE;\\n        for (int r0 = 0; r0 < m; ++r0) {\\n            for (int rf = r0; rf < m; ++rf) {\\n                final int rfp1 = rf + 1; // Let\\'s avoid computing rf + 1 many times.\\n                for (int c0 = 0; c0 < n; ++c0) {\\n                    for (int cf = c0; cf < n; ++cf) {\\n                        final int cfp1 = cf + 1; // Let\\'s avoid computing cf + 1 multiple times.\\n\\t\\t\\t\\t\\t\\t// Compute the sum for this rectangle: complete - right - lower + lower_right.\\n                        final int sum = brsum[r0][c0] + brsum[rfp1][cfp1] - brsum[r0][cfp1] - brsum[rfp1][c0];\\n\\t\\t\\t\\t\\t\\t// Did we happen to find a sum adding to k?  If not, did we find a larger sum less than k?\\n                        if (sum == k) {\\n                            return sum;\\n                        } else if (sum < k && sum > maxSum) {\\n                            maxSum = sum;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return maxSum;\\n    }\\n\\n}\\n```\\n\\n**Note**: Could we go faster with other approaches?  Yes, we could, if the effort is worth the runtime reduction.  But my goal for this solution was to find something we could be expected to remember (or develop easily from first principles) and implement quickly and accurately, which handles the constraints we are given, including time.  As someone who hires engineers and engineering managers, I would be quite satisfied with this approach combined with a mention that Kadane\\'s algorithm could probably be used to go faster, but some research and experimentation would be necessary.  In the information age, I don\\'t think we need to memorize everything.  Knowing things exist and being able to assimilate new information is often more than sufficient.  And sometimes understanding when perfect is the enemy of good is a useful skill.\\n\\n**Standard Plea**: If this solution and explanation were helpful or at least didn\\'t waste your time, I\\'d **appreciate your upvote**.  If not, or if you disagree with my point of view (regarding good vs perfect or memorizing things), I would **welcome your comments and/or constructive criticism**.\\n\\nThanks for reading, and happy coding!\\n",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\n     (r0, c0)                  (r0, cf+1)          (r0, width)\\n\\t          +--------------------------+--------------------+\\n\\t\\t\\t  |                          |                    |\\n\\t\\t\\t  |           (A)            |        (B)         |\\n\\t\\t\\t  |     target rectangle     |  right rectangle   |\\n\\t\\t\\t  |                          |                    |\\n  (rf+1, c0)  |             (rf+1, cf+1) |      (rf+1, width) |\\n\\t          +--------------------------+--------------------+\\n\\t\\t\\t  |                          |                    |\\n\\t\\t\\t  |           (C)            |        (D)         |\\n\\t\\t\\t  |     lower rectangle      |  lower-right rect. |\\n\\t\\t\\t  |                          |                    |\\n (height, c0) |           (height, cf+1) |    (height, width) |\\n\\t\\t\\t  +--------------------------+--------------------+\\n```\n```\\n    brsum[r][c] = matrix[r][c] + brsum[r][c + 1] + brsum[r + 1][c] - brsum[r + 1][c + 1];\\n```\n```\\nclass Solution {\\n\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        final int m = matrix.length;\\n        if (m < 1) {\\n            throw new IllegalArgumentException(\"empty matrix - no rows\");\\n        }\\n        final int n = matrix[0].length;\\n        if (n < 1) {\\n            throw new IllegalArgumentException(\"empty matrix - no columns\");\\n        }\\n        // Let\\'s make our bottom-right sum matrix wider and higher by 1 each, so we don\\'t go out of range.\\n        // All of the values r >= m and c >= n should be 0 (and will default to 0 during array construction).\\n        final int[][] brsum = new int[m + 1][n + 1];\\n        // Build up from bottom right, bottom to top and right to left.\\n        for (int r = (m - 1); r >= 0; --r) {\\n            for (int c = (n - 1); c >= 0; --c) {\\n                final int val = matrix[r][c];\\n                // did we happen to find a 1x1 rectangle at (r, c) which sums to k?\\n                if (val == k) {\\n                    return val;\\n                }\\n                // Extend the sum: value + right + down - rightAndDown (because rightAndDown was added twice)\\n                brsum[r][c] = matrix[r][c] + brsum[r][c + 1] + brsum[r + 1][c] - brsum[r + 1][c + 1];\\n            }\\n        }\\n        // Now, we search.\\n        int maxSum = Integer.MIN_VALUE;\\n        for (int r0 = 0; r0 < m; ++r0) {\\n            for (int rf = r0; rf < m; ++rf) {\\n                final int rfp1 = rf + 1; // Let\\'s avoid computing rf + 1 many times.\\n                for (int c0 = 0; c0 < n; ++c0) {\\n                    for (int cf = c0; cf < n; ++cf) {\\n                        final int cfp1 = cf + 1; // Let\\'s avoid computing cf + 1 multiple times.\\n\\t\\t\\t\\t\\t\\t// Compute the sum for this rectangle: complete - right - lower + lower_right.\\n                        final int sum = brsum[r0][c0] + brsum[rfp1][cfp1] - brsum[r0][cfp1] - brsum[rfp1][c0];\\n\\t\\t\\t\\t\\t\\t// Did we happen to find a sum adding to k?  If not, did we find a larger sum less than k?\\n                        if (sum == k) {\\n                            return sum;\\n                        } else if (sum < k && sum > maxSum) {\\n                            maxSum = sum;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return maxSum;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314266,
                "title": "c-yet-another-kadane-algorithm-solution",
                "content": "As many have pointed out, consider each pair of left column `l` and right `r`.\\nTry to compute a cumulative sum across rows.\\nIf there is no the `k` contraint, a plain Kadane algorithm would suffice.\\nSince the result needs to be no larger than `k`, a binary search is needed for the most general case.\\nHowever, Kadane algorithm can still be used to bypass the binary search in some cases.\\n\\nAs of 7/3/2021, this soultion runs for ~500ms. It looks like new test cases have been added.\\nTime complexity `O(n^2 * m * log(m))`\\nSpace comlexity `O(m)`\\n```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int m = matrix.size(), n = matrix[0].size();\\n        int res = INT_MIN;\\n        vector<int> row_sum(m, 0);\\n        for (int l = 0; l < n; ++l)\\n        {\\n            fill(row_sum.begin(), row_sum.end(), 0);\\n            for (int r = l; r < n; ++r)\\n            {\\n                // Kadane algorithm for a possible shortcut to next iteration or even an early return\\n                int cur_sum = 0, best_sum = INT_MIN;\\n                for (int i = 0; i < m; ++i)\\n                {\\n                    row_sum[i] += matrix[i][r];\\n                    if (cur_sum < 0)\\n                        cur_sum = row_sum[i];\\n                    else\\n                        cur_sum += row_sum[i];\\n                    best_sum = max(best_sum, cur_sum);\\n                }\\n                if (best_sum == k)\\n                    return k;\\n                else if (best_sum < k)\\n                {\\n                    res = max(res, best_sum);\\n                    continue;\\n                }\\n                // Otherwise, try binary search of running sums\\n                cur_sum = 0;\\n                set<int> s{0};\\n                for (auto& sum: row_sum)\\n                {\\n                    cur_sum += sum;\\n                    auto it = s.lower_bound(cur_sum - k);\\n                    if (it != s.end())\\n                        res = max(res, cur_sum - *it);\\n                    if (res == k)\\n                        return k;\\n                    s.insert(cur_sum);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int m = matrix.size(), n = matrix[0].size();\\n        int res = INT_MIN;\\n        vector<int> row_sum(m, 0);\\n        for (int l = 0; l < n; ++l)\\n        {\\n            fill(row_sum.begin(), row_sum.end(), 0);\\n            for (int r = l; r < n; ++r)\\n            {\\n                // Kadane algorithm for a possible shortcut to next iteration or even an early return\\n                int cur_sum = 0, best_sum = INT_MIN;\\n                for (int i = 0; i < m; ++i)\\n                {\\n                    row_sum[i] += matrix[i][r];\\n                    if (cur_sum < 0)\\n                        cur_sum = row_sum[i];\\n                    else\\n                        cur_sum += row_sum[i];\\n                    best_sum = max(best_sum, cur_sum);\\n                }\\n                if (best_sum == k)\\n                    return k;\\n                else if (best_sum < k)\\n                {\\n                    res = max(res, best_sum);\\n                    continue;\\n                }\\n                // Otherwise, try binary search of running sums\\n                cur_sum = 0;\\n                set<int> s{0};\\n                for (auto& sum: row_sum)\\n                {\\n                    cur_sum += sum;\\n                    auto it = s.lower_bound(cur_sum - k);\\n                    if (it != s.end())\\n                        res = max(res, cur_sum - *it);\\n                    if (res == k)\\n                        return k;\\n                    s.insert(cur_sum);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 521118,
                "title": "swift",
                "content": "```\\nclass Solution {\\n    func maxSumSubmatrix(_ matrix: [[Int]], _ k: Int) -> Int {\\n        var res = Int.min\\n        let m = matrix.count\\n        let n = matrix[0].count\\n        \\n        \\n        for left in 0..<n {\\n            var rowsSum = [Int](repeating: 0, count: m)\\n            for right in left..<n {\\n                \\n                for row in 0..<m {\\n                    rowsSum[row] += matrix[row][right]\\n                }\\n                res = max(countSubarraysSmallerThenK(rowsSum, k), res)\\n            }\\n        }\\n        \\n        return res\\n    }\\n    \\n    func countSubarraysSmallerThenK(_ arr: [Int], _ k: Int) -> Int {\\n        var res = Int.min\\n        \\n        for i in 0..<arr.count {\\n            var sum = 0\\n            for j in i..<arr.count {\\n                sum += arr[j]\\n                if sum > res && sum <= k {\\n                    res = sum\\n                }\\n            }\\n        }\\n        \\n        return res\\n    }\\n}\\n```\\n\\nSpace complexity is O(m)\\nTime complexity is 0(m*n\\u02C63)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func maxSumSubmatrix(_ matrix: [[Int]], _ k: Int) -> Int {\\n        var res = Int.min\\n        let m = matrix.count\\n        let n = matrix[0].count\\n        \\n        \\n        for left in 0..<n {\\n            var rowsSum = [Int](repeating: 0, count: m)\\n            for right in left..<n {\\n                \\n                for row in 0..<m {\\n                    rowsSum[row] += matrix[row][right]\\n                }\\n                res = max(countSubarraysSmallerThenK(rowsSum, k), res)\\n            }\\n        }\\n        \\n        return res\\n    }\\n    \\n    func countSubarraysSmallerThenK(_ arr: [Int], _ k: Int) -> Int {\\n        var res = Int.min\\n        \\n        for i in 0..<arr.count {\\n            var sum = 0\\n            for j in i..<arr.count {\\n                sum += arr[j]\\n                if sum > res && sum <= k {\\n                    res = sum\\n                }\\n            }\\n        }\\n        \\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 487685,
                "title": "simple-python-solution",
                "content": "```\\nimport bisect\\nimport sys\\n\\n\\nclass Solution:\\n    \\n    # Overall complexity O(n^4)\\n    def maxSumSubmatrix(self, matrix, k):\\n\\n        # Validation for corner case.\\n        if not matrix:\\n            return 0\\n\\n        # Traditional kadane algorithm does not work \\n        # here, as that algorithm always finds max sum\\n        # in a sub array and disregards intermediate sums\\n        # which needs to be considered for evaluating <=k criteria. \\n        #\\n        # Below function stores prefix sum values\\n        # in a sorted list and performs binary \\n        # search on this list to get the closest\\n        # element whose difference with current element\\n        # does not exceed k. \\n        # Complexity for this algorithm is O(n^2)\\n        def max_sum_array_no_larger_than_k(l, k):\\n            prefix_sums = [0]\\n            prefix_sum, max_sum = 0, -sys.maxsize\\n            for item in l:\\n                prefix_sum += item\\n                \\n                left = bisect.bisect_left(prefix_sums, prefix_sum - k)\\n                if left < len(prefix_sums):\\n                    max_sum = max(max_sum, prefix_sum - prefix_sums[left])\\n                   \\n               # This has a worst case complexity of O(n) \\n                bisect.insort(prefix_sums, prefix_sum)\\n            return max_sum\\n\\n        row_len = len(matrix)\\n        col_len = len(matrix[0])\\n        max_sum = -sys.maxsize\\n        \\n        # Below loops basically fold 2-d array into \\n        # a single dimensional array, so that above \\n        # function can be applied to it.\\n        # Here we iterate through all possible 2-d\\n        # arrays possible for every column. \\n        for from_col in range(col_len):\\n            col_values = [0 for _ in range(row_len)]\\n            for to_col in range(from_col, col_len):\\n                for row in range(row_len):\\n                    col_values[row] = col_values[row] + matrix[row][to_col]\\n                curr_sum = max_sum_array_no_larger_than_k(col_values, k)\\n                max_sum = max(curr_sum, max_sum)\\n        return max_sum\\n```",
                "solutionTags": [],
                "code": "```\\nimport bisect\\nimport sys\\n\\n\\nclass Solution:\\n    \\n    # Overall complexity O(n^4)\\n    def maxSumSubmatrix(self, matrix, k):\\n\\n        # Validation for corner case.\\n        if not matrix:\\n            return 0\\n\\n        # Traditional kadane algorithm does not work \\n        # here, as that algorithm always finds max sum\\n        # in a sub array and disregards intermediate sums\\n        # which needs to be considered for evaluating <=k criteria. \\n        #\\n        # Below function stores prefix sum values\\n        # in a sorted list and performs binary \\n        # search on this list to get the closest\\n        # element whose difference with current element\\n        # does not exceed k. \\n        # Complexity for this algorithm is O(n^2)\\n        def max_sum_array_no_larger_than_k(l, k):\\n            prefix_sums = [0]\\n            prefix_sum, max_sum = 0, -sys.maxsize\\n            for item in l:\\n                prefix_sum += item\\n                \\n                left = bisect.bisect_left(prefix_sums, prefix_sum - k)\\n                if left < len(prefix_sums):\\n                    max_sum = max(max_sum, prefix_sum - prefix_sums[left])\\n                   \\n               # This has a worst case complexity of O(n) \\n                bisect.insort(prefix_sums, prefix_sum)\\n            return max_sum\\n\\n        row_len = len(matrix)\\n        col_len = len(matrix[0])\\n        max_sum = -sys.maxsize\\n        \\n        # Below loops basically fold 2-d array into \\n        # a single dimensional array, so that above \\n        # function can be applied to it.\\n        # Here we iterate through all possible 2-d\\n        # arrays possible for every column. \\n        for from_col in range(col_len):\\n            col_values = [0 for _ in range(row_len)]\\n            for to_col in range(from_col, col_len):\\n                for row in range(row_len):\\n                    col_values[row] = col_values[row] + matrix[row][to_col]\\n                curr_sum = max_sum_array_no_larger_than_k(col_values, k)\\n                max_sum = max(curr_sum, max_sum)\\n        return max_sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2492107,
                "title": "easy-dp-beginner-level-easy-solution",
                "content": "```\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int tar) {\\n        int n=matrix.length,m=matrix[0].length,i,j,k,l,dp[][] = new int[n][m],val,max=Integer.MIN_VALUE,target=tar;\\n        for(i=0;i<n;i++){\\n            for(j=0;j<m;j++){\\n                dp[i][j]=matrix[i][j];\\n                if(j>0) dp[i][j]+=dp[i][j-1];\\n            }\\n        }\\n        for(i=0;i<n;i++){\\n            for(j=0;j<m;j++){\\n                if(i>0) dp[i][j]+=dp[i-1][j];\\n            }\\n        }\\n        for(i=0;i<n;i++){\\n            for(j=0;j<m;j++){\\n                for(k=i;k<n;k++){\\n                    for(l=j;l<m;l++){\\n                        val=dp[k][l];\\n                        if((i-1)>=0 && (j-1)>=0) val += dp[i-1][j-1];\\n                        if((i-1)>=0) val=val-dp[i-1][l];\\n                        if((j-1)>=0) val=val-dp[k][j-1];\\n                        if(val>max && val<=target) max=val;\\n                    }\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int tar) {\\n        int n=matrix.length,m=matrix[0].length,i,j,k,l,dp[][] = new int[n][m],val,max=Integer.MIN_VALUE,target=tar;\\n        for(i=0;i<n;i++){\\n            for(j=0;j<m;j++){\\n                dp[i][j]=matrix[i][j];\\n                if(j>0) dp[i][j]+=dp[i][j-1];\\n            }\\n        }\\n        for(i=0;i<n;i++){\\n            for(j=0;j<m;j++){\\n                if(i>0) dp[i][j]+=dp[i-1][j];\\n            }\\n        }\\n        for(i=0;i<n;i++){\\n            for(j=0;j<m;j++){\\n                for(k=i;k<n;k++){\\n                    for(l=j;l<m;l++){\\n                        val=dp[k][l];\\n                        if((i-1)>=0 && (j-1)>=0) val += dp[i-1][j-1];\\n                        if((i-1)>=0) val=val-dp[i-1][l];\\n                        if((j-1)>=0) val=val-dp[k][j-1];\\n                        if(val>max && val<=target) max=val;\\n                    }\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2488527,
                "title": "java-beats-100-32ms-kadane-s-algorithm-and-faster-approach-w-video-explanation",
                "content": "*Please **Upvote** if you find this explanation helpful*\\n\\n**Video Explanation**\\n[Max Sum of Rectangle No Larger Than K | YouTube](https://www.youtube.com/watch?v=rztZyG5kpvM&feature=youtu.be)\\n\\n**Java Solution**\\n\\n```\\n//Kadane\\'s Algorithm Approach\\n//600ms+  explained in video\\n\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int result = Integer.MIN_VALUE;\\n        \\n        for(int left =0 ;left<matrix[0].length; left++){\\n            \\n            int[] rSum = new int[matrix.length];\\n            \\n            for(int right = left;right<matrix[0].length;right++){\\n                for(int row=0; row < matrix.length; row++)\\n                    rSum[row] += matrix[row][right];\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t//explanation of these 3 loops starts from 02:00 in Video\\n                \\n                TreeSet<Integer> set = new TreeSet<>();\\n                \\n                set.add(0);\\n                int cs = 0;\\n                \\n                for(int a: rSum){\\n                    cs += a;\\n\\t\\t\\t\\t\\t\\n                    //if you don\\'t understand what exactly is going on here\\n\\t\\t\\t\\t\\t// then watch the video from 12:27\\n\\t\\t\\t\\t\\t\\n                    Integer target = set.ceiling(cs-k);\\n                    \\n                    if(target !=null)\\n                        result = Math.max(result,cs-target);\\n                    set.add(cs);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\n**Faster Approach**\\n```\\n//32ms - faster than 100%\\n\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[0].length; j++) {\\n                if (i > 0) {\\n                    matrix[i][j] += matrix[i - 1][j];\\n                }\\n                if (j > 0) {\\n                    matrix[i][j] += matrix[i][j - 1];\\n                }\\n                if (i > 0 && j > 0) {\\n                    matrix[i][j] -= matrix[i - 1][j - 1];\\n                }\\n            }\\n        }\\n        int result = Integer.MIN_VALUE;\\n        \\n        int[][] dpHigh = new int[matrix.length][matrix.length + 1];\\n        int[][] dpLow = new int[matrix.length][matrix.length + 1];\\n        \\n        for (int i = matrix.length - 1; i >= 0; i--) {\\n            for (int h = 1; h <= matrix.length - i; h++) {\\n                int theValue = getSum(matrix, i, matrix[0].length - 1, h, 1);\\n                dpLow[i][h] = theValue;\\n                dpHigh[i][h] = theValue;\\n                if (theValue == k) {\\n                    return theValue;\\n                }\\n                if (theValue < k) {\\n                    result = Math.max(result, theValue);\\n                }\\n            }\\n        }\\n        \\n        for (int i = matrix.length - 1; i >= 0; i--) {\\n            for (int j = matrix[0].length - 2; j >= 0; j--) {\\n                for (int h = 1; h <= matrix.length - i; h++) {\\n                    int newSum = getSum(matrix, i, j, h, 1);\\n                    if (dpLow[i][h] > 0) {\\n                        dpHigh[i][h] += newSum;\\n                        dpLow[i][h] = newSum;\\n                    } else if (dpHigh[i][h] < 0) {\\n                        dpLow[i][h] += newSum;\\n                        dpHigh[i][h] = newSum;\\n                    } else {\\n                        dpHigh[i][h] += newSum;\\n                        dpLow[i][h] += newSum;\\n                    }\\n                    if (dpHigh[i][h] >= result && dpLow[i][h] <= k) {\\n                        for (int w = 1; w <= matrix[0].length - j; w++) {\\n                            int sum = getSum(matrix, i, j, h, w);\\n                            if (sum == k) {\\n                                return sum;\\n                            } else if (sum < k) {\\n                                result = Math.max(result, sum);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private int getSum(int[][] matrix, int i, int j, int h, int w) {\\n        int sum = matrix[i + h - 1][j + w - 1];\\n        if (i > 0) {\\n            sum -= matrix[i - 1][j + w - 1];\\n        }\\n        if (j > 0) {\\n            sum -= matrix[i + h - 1][j - 1];\\n        }\\n        if (i > 0 && j > 0) {\\n            sum += matrix[i - 1][j - 1];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Tree",
                    "Prefix Sum",
                    "Ordered Set"
                ],
                "code": "```\\n//Kadane\\'s Algorithm Approach\\n//600ms+  explained in video\\n\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int result = Integer.MIN_VALUE;\\n        \\n        for(int left =0 ;left<matrix[0].length; left++){\\n            \\n            int[] rSum = new int[matrix.length];\\n            \\n            for(int right = left;right<matrix[0].length;right++){\\n                for(int row=0; row < matrix.length; row++)\\n                    rSum[row] += matrix[row][right];\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t//explanation of these 3 loops starts from 02:00 in Video\\n                \\n                TreeSet<Integer> set = new TreeSet<>();\\n                \\n                set.add(0);\\n                int cs = 0;\\n                \\n                for(int a: rSum){\\n                    cs += a;\\n\\t\\t\\t\\t\\t\\n                    //if you don\\'t understand what exactly is going on here\\n\\t\\t\\t\\t\\t// then watch the video from 12:27\\n\\t\\t\\t\\t\\t\\n                    Integer target = set.ceiling(cs-k);\\n                    \\n                    if(target !=null)\\n                        result = Math.max(result,cs-target);\\n                    set.add(cs);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\n```\\n//32ms - faster than 100%\\n\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[0].length; j++) {\\n                if (i > 0) {\\n                    matrix[i][j] += matrix[i - 1][j];\\n                }\\n                if (j > 0) {\\n                    matrix[i][j] += matrix[i][j - 1];\\n                }\\n                if (i > 0 && j > 0) {\\n                    matrix[i][j] -= matrix[i - 1][j - 1];\\n                }\\n            }\\n        }\\n        int result = Integer.MIN_VALUE;\\n        \\n        int[][] dpHigh = new int[matrix.length][matrix.length + 1];\\n        int[][] dpLow = new int[matrix.length][matrix.length + 1];\\n        \\n        for (int i = matrix.length - 1; i >= 0; i--) {\\n            for (int h = 1; h <= matrix.length - i; h++) {\\n                int theValue = getSum(matrix, i, matrix[0].length - 1, h, 1);\\n                dpLow[i][h] = theValue;\\n                dpHigh[i][h] = theValue;\\n                if (theValue == k) {\\n                    return theValue;\\n                }\\n                if (theValue < k) {\\n                    result = Math.max(result, theValue);\\n                }\\n            }\\n        }\\n        \\n        for (int i = matrix.length - 1; i >= 0; i--) {\\n            for (int j = matrix[0].length - 2; j >= 0; j--) {\\n                for (int h = 1; h <= matrix.length - i; h++) {\\n                    int newSum = getSum(matrix, i, j, h, 1);\\n                    if (dpLow[i][h] > 0) {\\n                        dpHigh[i][h] += newSum;\\n                        dpLow[i][h] = newSum;\\n                    } else if (dpHigh[i][h] < 0) {\\n                        dpLow[i][h] += newSum;\\n                        dpHigh[i][h] = newSum;\\n                    } else {\\n                        dpHigh[i][h] += newSum;\\n                        dpLow[i][h] += newSum;\\n                    }\\n                    if (dpHigh[i][h] >= result && dpLow[i][h] <= k) {\\n                        for (int w = 1; w <= matrix[0].length - j; w++) {\\n                            int sum = getSum(matrix, i, j, h, w);\\n                            if (sum == k) {\\n                                return sum;\\n                            } else if (sum < k) {\\n                                result = Math.max(result, sum);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private int getSum(int[][] matrix, int i, int j, int h, int w) {\\n        int sum = matrix[i + h - 1][j + w - 1];\\n        if (i > 0) {\\n            sum -= matrix[i - 1][j + w - 1];\\n        }\\n        if (j > 0) {\\n            sum -= matrix[i + h - 1][j - 1];\\n        }\\n        if (i > 0 && j > 0) {\\n            sum += matrix[i - 1][j - 1];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2488423,
                "title": "daily-leetcode-solution",
                "content": "![image](https://assets.leetcode.com/users/images/c74f2cc5-9780-4996-b6e1-3ab612bef7ce_1661572978.4759052.png)\\n",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/c74f2cc5-9780-4996-b6e1-3ab612bef7ce_1661572978.4759052.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2488215,
                "title": "c-easy-solution-faster-than-99-5-less-memory-than-95",
                "content": "* **Runtime: 284 ms, faster than 99.74% of C++ online submissions for Max Sum of Rectangle No Larger Than K.**\\n* **Memory Usage: 10.5 MB, less than 94.90% of C++ online submissions for Max Sum of Rectangle No Larger Than K.**\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int max_sum = INT_MIN, m=matrix.size(), n=matrix[0].size(), subarr[m];\\n        for(int l=0; l<n; l++) {\\n            memset(subarr,0,sizeof(subarr));\\n            for(int r=l; r<n; r++) {\\n                for(int i=0; i<m; i++) subarr[i] += matrix[i][r];\\n                for(int i=0; i<m; i++) {\\n                    int sum = 0;\\n                    for(int j=i; j<m; j++) {\\n                        sum += subarr[j];\\n                        if(sum > max_sum && sum <=k) max_sum = sum;\\n                    }\\n                }\\n            }\\n        }\\n        return max_sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int max_sum = INT_MIN, m=matrix.size(), n=matrix[0].size(), subarr[m];\\n        for(int l=0; l<n; l++) {\\n            memset(subarr,0,sizeof(subarr));\\n            for(int r=l; r<n; r++) {\\n                for(int i=0; i<m; i++) subarr[i] += matrix[i][r];\\n                for(int i=0; i<m; i++) {\\n                    int sum = 0;\\n                    for(int j=i; j<m; j++) {\\n                        sum += subarr[j];\\n                        if(sum > max_sum && sum <=k) max_sum = sum;\\n                    }\\n                }\\n            }\\n        }\\n        return max_sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 645868,
                "title": "max-sum-of-rectangle-no-larger-than-k-java-solution-explained",
                "content": "```java\\n/**\\n* Idea: \\n*  We scan all columns and for each group of columns we calculate the row sum of till that columns  \\n*  Say we have 3 columns, so we will have group of column such that [0]. [0,1], [0,1,2], [1], [1,2], [2]\\n*  then we calculate corresponding row sum this is where we use rolling sum to reduce complexity\\n* \\n*  Then we use the row sum array to get the maximum contiguous sub array sum which is under k\\n*  For this we can use kadane\\'s algorithm \\n*   Say we have [1, 3, -1, 2]\\n*   Good explanation of Kadane\\'s Algorithm https://www.youtube.com/watch?v=2MmGzdiKR9Y\\n*\\n*   Kadane\\'s algorith states that we can figure out maximum contiguas subarray sum with only one scan of the array\\n*   The basic idea is every element can be the max or the max can come from elements previous to that element\\n*\\n*   In the above example take the first element (1), the max subarray sum is 1 till that point\\n*   For second element, the choice is between use the element 3 or (3 and previous subarray sum) in this case max(3, 4) = 4\\n*   For third element (-1), the choice is -1 or previous 4 -> (4 + -1) = 3 the output is  3\\n*   For fourth element (2), the choice is 2 or previous 3 -> (3 + 2) = 5, the output is 5 \\n*   Looks like the maximum subarray sum here is the summation of the complete array. Otherwise we would\\'ve take max of all above \\n*   values MAX(1, 4, 3, 5 ) => 5\\n*   \\n*   This is a bit special case where we need to find the sum does not exceed k value , say k is 2\\n*   The trick is to maintain a sorted order of the sums found at each step, so the array will look like \\n*   [We add a 0 for convinience with negative value, meaning our value should not go negative]\\n*   (0) the first element is having sum 1, then (1 - 2) = -1, the closest ceiling value is 0, we can subtract 0 to not exceed max value 2, and the closest value we can get to 2 is (1 - 0) = 1\\n*   (0, 1) THe second sum is 4, the closest larger value of 4 - 2 = 2 is not found, so we just add it, meaning till now we can\\'t subtract anything from 4 which will make sure it won\\'t exceed 2\\n*   (0, 1, 4) the third sum is 3, the closest larger value of 3 - 2 = 1, thus we know we can go till (3 - 1) = 2, this is the closest of 2 we go. This can be inferred as if we take (3, -1) that is the closest sum of 2. \\n*  (0, 1, 3, 4) the next value is 5, thus (5 - 2) = 3, closest to 3 is 3, thus we again know we can go till (5 - 3) = 2, the corresponding subarray will be same one as above.\\n*   Time Complexity => if n is no of cols and m is no of rows, then O(n^2 * mlogm)\\n*   Space Complexity => O(m) (originally 2m)\\n*/\\n\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        \\n        int maxSum = Integer.MIN_VALUE;\\n        int rows = matrix.length;\\n        int cols = matrix[0].length;\\n        for (int i = 0; i < cols; i++) {\\n            \\n            // Starting at each column we incrementally go till end\\n            // [0], [0,1], [0,1,2]\\n            // [1], [1,2]\\n            // [2]\\n            \\n            int[] rowSum = new int[rows];\\n            for (int col = i; col < cols; col++) {\\n                for (int row = 0; row < rows; row++) {\\n                    rowSum[row] += matrix[row][col];\\n                }\\n                \\n                // We have calculated the row sum till the current column\\n                // Now it is time to mind the max subarray sum we can achieve lesser than k\\n                int maxSumUnderK = maxSubarrayLessThanK(rowSum, k);\\n                maxSum = Math.max(maxSum, maxSumUnderK);\\n                \\n                // This will prune the computations a bit, if we achieve k, we know \\n                // we don\\'t need to go futher this the max we can go, return now, don\\'t waste time computing more\\n                if (maxSum == k) return k;\\n            }\\n        }\\n        return maxSum;\\n    }\\n    \\n    // This is Kadane\\'s algorithm .. a bit modified\\n    private int maxSubarrayLessThanK(int[] array, int k) {\\n        int maxSumUnderK = Integer.MIN_VALUE;\\n        \\n        // Best possible data structure to keep stuff in sorted order and get back in log n time\\n        TreeSet<Integer> sortedPreviousSums = new TreeSet<>();\\n        sortedPreviousSums.add(0);\\n        \\n        int incrementalSum = 0;\\n        for (int i = 0; i < array.length; i++) {\\n            incrementalSum += array[i];\\n            \\n            // Now we try to find if our sorted sum list is having\\n            // any thing just larger than (sum - k), say that is previousSum\\n            // If there is an element we know we can go close to k as much as (sum - previousSum)\\n            Integer previousSum = sortedPreviousSums.ceiling(incrementalSum - k);\\n            if (previousSum != null) {\\n                maxSumUnderK = Math.max(maxSumUnderK, incrementalSum - previousSum);\\n            }\\n            \\n            sortedPreviousSums.add(incrementalSum);\\n        }\\n        \\n        return maxSumUnderK;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```java\\n/**\\n* Idea: \\n*  We scan all columns and for each group of columns we calculate the row sum of till that columns  \\n*  Say we have 3 columns, so we will have group of column such that [0]. [0,1], [0,1,2], [1], [1,2], [2]\\n*  then we calculate corresponding row sum this is where we use rolling sum to reduce complexity\\n* \\n*  Then we use the row sum array to get the maximum contiguous sub array sum which is under k\\n*  For this we can use kadane\\'s algorithm \\n*   Say we have [1, 3, -1, 2]\\n*   Good explanation of Kadane\\'s Algorithm https://www.youtube.com/watch?v=2MmGzdiKR9Y\\n*\\n*   Kadane\\'s algorith states that we can figure out maximum contiguas subarray sum with only one scan of the array\\n*   The basic idea is every element can be the max or the max can come from elements previous to that element\\n*\\n*   In the above example take the first element (1), the max subarray sum is 1 till that point\\n*   For second element, the choice is between use the element 3 or (3 and previous subarray sum) in this case max(3, 4) = 4\\n*   For third element (-1), the choice is -1 or previous 4 -> (4 + -1) = 3 the output is  3\\n*   For fourth element (2), the choice is 2 or previous 3 -> (3 + 2) = 5, the output is 5 \\n*   Looks like the maximum subarray sum here is the summation of the complete array. Otherwise we would\\'ve take max of all above \\n*   values MAX(1, 4, 3, 5 ) => 5\\n*   \\n*   This is a bit special case where we need to find the sum does not exceed k value , say k is 2\\n*   The trick is to maintain a sorted order of the sums found at each step, so the array will look like \\n*   [We add a 0 for convinience with negative value, meaning our value should not go negative]\\n*   (0) the first element is having sum 1, then (1 - 2) = -1, the closest ceiling value is 0, we can subtract 0 to not exceed max value 2, and the closest value we can get to 2 is (1 - 0) = 1\\n*   (0, 1) THe second sum is 4, the closest larger value of 4 - 2 = 2 is not found, so we just add it, meaning till now we can\\'t subtract anything from 4 which will make sure it won\\'t exceed 2\\n*   (0, 1, 4) the third sum is 3, the closest larger value of 3 - 2 = 1, thus we know we can go till (3 - 1) = 2, this is the closest of 2 we go. This can be inferred as if we take (3, -1) that is the closest sum of 2. \\n*  (0, 1, 3, 4) the next value is 5, thus (5 - 2) = 3, closest to 3 is 3, thus we again know we can go till (5 - 3) = 2, the corresponding subarray will be same one as above.\\n*   Time Complexity => if n is no of cols and m is no of rows, then O(n^2 * mlogm)\\n*   Space Complexity => O(m) (originally 2m)\\n*/\\n\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        \\n        int maxSum = Integer.MIN_VALUE;\\n        int rows = matrix.length;\\n        int cols = matrix[0].length;\\n        for (int i = 0; i < cols; i++) {\\n            \\n            // Starting at each column we incrementally go till end\\n            // [0], [0,1], [0,1,2]\\n            // [1], [1,2]\\n            // [2]\\n            \\n            int[] rowSum = new int[rows];\\n            for (int col = i; col < cols; col++) {\\n                for (int row = 0; row < rows; row++) {\\n                    rowSum[row] += matrix[row][col];\\n                }\\n                \\n                // We have calculated the row sum till the current column\\n                // Now it is time to mind the max subarray sum we can achieve lesser than k\\n                int maxSumUnderK = maxSubarrayLessThanK(rowSum, k);\\n                maxSum = Math.max(maxSum, maxSumUnderK);\\n                \\n                // This will prune the computations a bit, if we achieve k, we know \\n                // we don\\'t need to go futher this the max we can go, return now, don\\'t waste time computing more\\n                if (maxSum == k) return k;\\n            }\\n        }\\n        return maxSum;\\n    }\\n    \\n    // This is Kadane\\'s algorithm .. a bit modified\\n    private int maxSubarrayLessThanK(int[] array, int k) {\\n        int maxSumUnderK = Integer.MIN_VALUE;\\n        \\n        // Best possible data structure to keep stuff in sorted order and get back in log n time\\n        TreeSet<Integer> sortedPreviousSums = new TreeSet<>();\\n        sortedPreviousSums.add(0);\\n        \\n        int incrementalSum = 0;\\n        for (int i = 0; i < array.length; i++) {\\n            incrementalSum += array[i];\\n            \\n            // Now we try to find if our sorted sum list is having\\n            // any thing just larger than (sum - k), say that is previousSum\\n            // If there is an element we know we can go close to k as much as (sum - previousSum)\\n            Integer previousSum = sortedPreviousSums.ceiling(incrementalSum - k);\\n            if (previousSum != null) {\\n                maxSumUnderK = Math.max(maxSumUnderK, incrementalSum - previousSum);\\n            }\\n            \\n            sortedPreviousSums.add(incrementalSum);\\n        }\\n        \\n        return maxSumUnderK;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 83621,
                "title": "no-real-dp-technique-actually-used-c-critically-commented",
                "content": "The last section of the solution can be tricky, but read it carefully and I believe you can get it done! \\n\\n**Good luck!**\\n\\n    class Solution {\\n    public:\\n        int maxSumSubmatrix(vector<vector<int>>& matrix, int k) \\n        {\\n            if(matrix.empty()) return 0;\\n            int rowSize = matrix.size(), colSize = matrix[0].size();\\n            int ret = INT_MIN;\\n            for(int l = 0; l < colSize; ++l) //starting leftmost column;\\n            {\\n                vector<int> sums(rowSize, 0); //store the row pre-sums;\\n                for(int c = l; c < colSize; ++c) //try different ending columns;\\n                {\\n                    for(int r = 0; r < rowSize; ++r) //sum them up in rows;\\n                        sums[r] += matrix[r][c];\\n                    set<int> sums_set; //store the sums from the starting top-left;\\n                    sums_set.insert(0); //as a sentinel;\\n                    int maxSum = INT_MIN, sum = 0;\\n                    for(int i = 0; i < rowSize; ++i)\\n                    {\\n                        sum += sums[i]; //the sum from the starting top-left to current position;\\n                        auto iter = sums_set.lower_bound(sum-k); //check the possible sum candidates;\\n                        if(iter != sums_set.end()) maxSum = max(maxSum, sum-*iter); //found one, check it;\\n                        sums_set.insert(sum);\\n                    }\\n                    ret = max(ret, maxSum);\\n                }\\n            }\\n            return ret;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int maxSumSubmatrix(vector<vector<int>>& matrix, int k) \\n        {\\n            if(matrix.empty()) return 0;\\n            int rowSize = matrix.size(), colSize = matrix[0].size();\\n            int ret = INT_MIN;\\n            for(int l = 0; l < colSize; ++l) //starting leftmost column;\\n            {\\n                vector<int> sums(rowSize, 0); //store the row pre-sums;\\n                for(int c = l; c < colSize; ++c) //try different ending columns;\\n                {\\n                    for(int r = 0; r < rowSize; ++r) //sum them up in rows;\\n                        sums[r] += matrix[r][c];\\n                    set<int> sums_set; //store the sums from the starting top-left;\\n                    sums_set.insert(0); //as a sentinel;\\n                    int maxSum = INT_MIN, sum = 0;\\n                    for(int i = 0; i < rowSize; ++i)\\n                    {\\n                        sum += sums[i]; //the sum from the starting top-left to current position;\\n                        auto iter = sums_set.lower_bound(sum-k); //check the possible sum candidates;\\n                        if(iter != sums_set.end()) maxSum = max(maxSum, sum-*iter); //found one, check it;\\n                        sums_set.insert(sum);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 2459253,
                "title": "c-solution-time-o-m-2-n-2-memory-o-m-n-easy-to-understand-2d-prefix-sum",
                "content": "```C#\\npublic class Solution {\\n    public int MaxSumSubmatrix(int[][] matrix, int k) {\\n        int rows = matrix.Length, cols = matrix[0].Length;\\n        \\n        int[][] sums = new int[rows + 1][];\\n        for (int i = 0; i <= rows; i++) sums[i] = new int[cols + 1];\\n        \\n        int ans = int.MinValue;\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                sums[i + 1][j + 1] = sums[i + 1][j] + sums[i][j + 1] - sums[i][j] + matrix[i][j];\\n                \\n                for (int rectangleHeight = 0; rectangleHeight <= i; rectangleHeight++) {\\n                    for (int rectangleWidth = 0; rectangleWidth <= j; rectangleWidth++) {\\n                        int rectangleSum = sums[i + 1][j + 1] - sums[i + 1][j - rectangleWidth] - sums[i - rectangleHeight][j + 1] + sums[i - rectangleHeight][j - rectangleWidth];\\n                        if (rectangleSum == k) return rectangleSum;\\n                        if (rectangleSum < k) ans = Math.Max(ans, rectangleSum);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```C#\\npublic class Solution {\\n    public int MaxSumSubmatrix(int[][] matrix, int k) {\\n        int rows = matrix.Length, cols = matrix[0].Length;\\n        \\n        int[][] sums = new int[rows + 1][];\\n        for (int i = 0; i <= rows; i++) sums[i] = new int[cols + 1];\\n        \\n        int ans = int.MinValue;\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                sums[i + 1][j + 1] = sums[i + 1][j] + sums[i][j + 1] - sums[i][j] + matrix[i][j];\\n                \\n                for (int rectangleHeight = 0; rectangleHeight <= i; rectangleHeight++) {\\n                    for (int rectangleWidth = 0; rectangleWidth <= j; rectangleWidth++) {\\n                        int rectangleSum = sums[i + 1][j + 1] - sums[i + 1][j - rectangleWidth] - sums[i - rectangleHeight][j + 1] + sums[i - rectangleHeight][j - rectangleWidth];\\n                        if (rectangleSum == k) return rectangleSum;\\n                        if (rectangleSum < k) ans = Math.Max(ans, rectangleSum);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1318887,
                "title": "java-kadane-s-algorithm-explanation",
                "content": "scan cols from left to right. for every fixed left & right column, store sum of rows in temp array. find max contiguous sum from this temp array using Kadane\\'s algorithm which is described below:\\n```\\n\\tx\\n<--->\\n\\t\\t\\ty\\n<----------->\\n\\n\\t\\ty-x=k\\n\\t <------>\\n```\\n\\n```\\npublic int maxSumSubmatrix(int[][] matrix, int k) {\\n        int res = Integer.MIN_VALUE;\\n        for(int leftCol = 0; leftCol < matrix[0].length; leftCol++) {\\n            int[] tempRowsSum = new int[matrix.length];\\n            for(int rightCol = leftCol; rightCol < matrix[0].length; rightCol++) {\\n                for(int row = 0; row < matrix.length; row++) {\\n                    tempRowsSum[row] += matrix[row][rightCol];\\n                }\\n                TreeSet<Integer> set = new TreeSet<>();\\n                set.add(0);\\n                int cSum = 0;\\n                for(int a : tempRowsSum) {\\n                    cSum += a;\\n                    //cSum is y & target is x here. cSum-k = y-k = x+k-k = x. \\n                    Integer target = set.ceiling(cSum - k);\\n                    //cSum-target = y-x = k\\n                    if(target != null) res = Math.max(res, cSum - target);\\n                    set.add(cSum);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\nTC: O(col * col * row * (log row))\\nSC: O(row)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\tx\\n<--->\\n\\t\\t\\ty\\n<----------->\\n\\n\\t\\ty-x=k\\n\\t <------>\\n```\n```\\npublic int maxSumSubmatrix(int[][] matrix, int k) {\\n        int res = Integer.MIN_VALUE;\\n        for(int leftCol = 0; leftCol < matrix[0].length; leftCol++) {\\n            int[] tempRowsSum = new int[matrix.length];\\n            for(int rightCol = leftCol; rightCol < matrix[0].length; rightCol++) {\\n                for(int row = 0; row < matrix.length; row++) {\\n                    tempRowsSum[row] += matrix[row][rightCol];\\n                }\\n                TreeSet<Integer> set = new TreeSet<>();\\n                set.add(0);\\n                int cSum = 0;\\n                for(int a : tempRowsSum) {\\n                    cSum += a;\\n                    //cSum is y & target is x here. cSum-k = y-k = x+k-k = x. \\n                    Integer target = set.ceiling(cSum - k);\\n                    //cSum-target = y-x = k\\n                    if(target != null) res = Math.max(res, cSum - target);\\n                    set.add(cSum);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1313574,
                "title": "rust-translated-prefix-sum-on-1d-array-using-sorted-container",
                "content": "```rust\\nuse std::collections::BTreeSet;\\n\\nimpl Solution {\\n    pub fn max_sum_submatrix(matrix: Vec<Vec<i32>>, k: i32) -> i32 {\\n        let (row, col) = (matrix.len(), matrix[0].len());\\n        let mut answer = std::i32::MIN;\\n        for i in 0..row {\\n            let mut rowsum = vec![0; col];\\n            for r in matrix.iter().skip(i) {\\n                rowsum.iter_mut().zip(r).for_each(|(sum, val)| *sum += val);\\n                let mut sum = 0;\\n                let mut bts = BTreeSet::new();\\n                bts.insert(0);\\n                for val in &rowsum {\\n                    sum += val;\\n                    if let Some(x) = bts.range(sum - k..).next() {\\n                        answer = answer.max(sum - x);\\n                        if answer == k {\\n                            return k;\\n                        }\\n                    };\\n                    bts.insert(sum);\\n                }\\n            }\\n        }\\n        answer\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::collections::BTreeSet;\\n\\nimpl Solution {\\n    pub fn max_sum_submatrix(matrix: Vec<Vec<i32>>, k: i32) -> i32 {\\n        let (row, col) = (matrix.len(), matrix[0].len());\\n        let mut answer = std::i32::MIN;\\n        for i in 0..row {\\n            let mut rowsum = vec![0; col];\\n            for r in matrix.iter().skip(i) {\\n                rowsum.iter_mut().zip(r).for_each(|(sum, val)| *sum += val);\\n                let mut sum = 0;\\n                let mut bts = BTreeSet::new();\\n                bts.insert(0);\\n                for val in &rowsum {\\n                    sum += val;\\n                    if let Some(x) = bts.range(sum - k..).next() {\\n                        answer = answer.max(sum - x);\\n                        if answer == k {\\n                            return k;\\n                        }\\n                    };\\n                    bts.insert(sum);\\n                }\\n            }\\n        }\\n        answer\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1287117,
                "title": "c-prefix-sum-solution",
                "content": "```\\npublic class Solution {\\n    public int MaxSumSubmatrix(int[][] matrix, int k) {\\n        \\n        if(matrix == null || matrix.Length == 0)\\n            return -1;\\n        \\n        int m = matrix.Length, n = matrix[0].Length;\\n        int[,] prefixSum = new int[m + 1, n + 1];\\n        for(int i = 1; i <= m; i++)\\n        {\\n            for(int j = 1; j <= n; j++)      \\n            {\\n                // prefixSum[i,j] denotes the sum of elements between matrix[0][0] ~ matrix[i-1][j-1]\\n                prefixSum[i,j] = prefixSum[i-1,j] + prefixSum[i,j-1] - prefixSum[i-1,j-1] + matrix[i-1][j-1];\\n            }\\n        }\\n        \\n        int max = Int32.MinValue;\\n        HashSet<int> set = new HashSet<int>();\\n        for(int r1 = 1; r1 <= m; r1++)\\n        {\\n            for(int r2 = r1; r2 <= m; r2++)\\n            {              \\n                set.Clear();\\n                set.Add(0);\\n                \\n                for(int col = 1; col <= n; col++)\\n                {\\n                    int rangeSum = prefixSum[r2,col] - prefixSum[r1-1,col];\\n                    \\n                    foreach(var num in set)\\n                    {\\n                        int sum = rangeSum - num;\\n                        if(sum <= k)\\n                            max = Math.Max(max, sum);\\n                    }\\n                    \\n                    set.Add(rangeSum);\\n                }\\n            }\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MaxSumSubmatrix(int[][] matrix, int k) {\\n        \\n        if(matrix == null || matrix.Length == 0)\\n            return -1;\\n        \\n        int m = matrix.Length, n = matrix[0].Length;\\n        int[,] prefixSum = new int[m + 1, n + 1];\\n        for(int i = 1; i <= m; i++)\\n        {\\n            for(int j = 1; j <= n; j++)      \\n            {\\n                // prefixSum[i,j] denotes the sum of elements between matrix[0][0] ~ matrix[i-1][j-1]\\n                prefixSum[i,j] = prefixSum[i-1,j] + prefixSum[i,j-1] - prefixSum[i-1,j-1] + matrix[i-1][j-1];\\n            }\\n        }\\n        \\n        int max = Int32.MinValue;\\n        HashSet<int> set = new HashSet<int>();\\n        for(int r1 = 1; r1 <= m; r1++)\\n        {\\n            for(int r2 = r1; r2 <= m; r2++)\\n            {              \\n                set.Clear();\\n                set.Add(0);\\n                \\n                for(int col = 1; col <= n; col++)\\n                {\\n                    int rangeSum = prefixSum[r2,col] - prefixSum[r1-1,col];\\n                    \\n                    foreach(var num in set)\\n                    {\\n                        int sum = rangeSum - num;\\n                        if(sum <= k)\\n                            max = Math.Max(max, sum);\\n                    }\\n                    \\n                    set.Add(rangeSum);\\n                }\\n            }\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 963923,
                "title": "java-2-approaches-o-n-2-m-log-m-group-row-column-and-merge-sort",
                "content": "**Approach 1:**\\n1. Iterate over all row ranges and add those rows together.\\n2. Solve the problem of **maximum sum of subarray less than or equal to k** on this array.\\n\\nFor example:\\nrow 0 -> [ a\\u2003\\u2003b\\u2003\\u2003c\\u2003\\u2003d ]\\nrow 1 -> [ e\\u2003\\u2003f\\u2003\\u2003g\\u2003\\u2003h ]\\nrow 2 -> [ i\\u2003\\u2003j\\u2003\\u2003k\\u2003\\u2003l ]\\n\\nStep 1 means:\\nrows [0..0] -> [ a\\u2003\\u2003\\u2003\\u2003b\\u2003\\u2003\\u2003\\u2003c\\u2003\\u2003\\u2003\\u2003d ]\\nrows [0..1] -> [ a+e\\u2003\\u2003\\u2003b+f\\u2003\\u2003c+g\\u2003\\u2003d+h ]\\nrows [0..2] -> [ a+e+i\\u2003b+f+j\\u2003c+g+k\\u2003d+h+l ]\\nrows [1..1] -> [ e\\u2003\\u2003\\u2003f\\u2003\\u2003\\u2003g\\u2003\\u2003\\u2003h ]\\nrows [1..2] -> [ e+i\\u2003\\u2003f+j\\u2003\\u2003g+k\\u2003\\u2003h+l ]\\nrows [2..2] -> [ i\\u2003\\u2003\\u2003j\\u2003\\u2003\\u2003k\\u2003\\u2003\\u2003l ]\\n\\nStep 2 means solving the problem on all of these row range sums.\\nHow to solve **maximum sum of subarray less than or equal to k** efficiently?\\nLet\\'s say we have an array ```A```. We want to find out maximum value of ```sum[i..j] = A[i] + A[i+1] + ... A[j] <= k```\\n```sum[i..j]``` can be redefined in terms of ```prefix``` sum as ```sum[i..j] = prefix[j] - prefix[i-1]```\\nSo a solution could be to traverse over the array and calculate the best valid subarray ending at that index and take the maximum of all these subarray values.\\nSuppose we\\'re at an index ```j```, what is the best start index ```i (i < j)``` that we\\'re looking for?\\n\\n-> Maximize LHS (Left Hand Side) such that ```sum[i..j] <= k```\\n-> Maximize LHS such that ```prefix[j] - prefix[i-1] <= k```\\n-> **Minimize** ```prefix[i-1]``` (there is minus sign in front of ```prefix[i-1]``` so minimizing ```prefix[i-1]``` increases LHS) such that ```prefix[j] - prefix[i-1] <= k```\\n-> Minimize ```prefix[i-1]``` such that ```prefix[i-1] >= prefix[j] - k```\\nSo essentially we\\'re trying to **find an old prefix sum which is just greater than or equal to current prefix sum - k**. This can be efficiently solved using a sorted list like TreeSet on ```prefix``` sum values.\\n\\n**Follow up:** What if the number of rows is much larger than the number of columns?\\nIterate over column ranges instead of rows and solve the problem on array formed by column range sums.\\nSince whichever dimension we iterate the ranges on adds a quadratic time wherever the other dimension only contributes linear-logarithmic time, we\\'d like to do the grouping on whichever dimension is smaller.\\n\\n**Optimization:**\\nWe can use Kadane\\'s algorithm to find the maximum subarray sum in an array and use it directly if it is ```<= k```. That can help us avoid the more costly TreeSet based computation in some cases.\\n\\n```\\n// 12 ms. 94.57%\\nclass Solution {\\n    private int maxSumSubarray(int[] A) {\\n        int min = 0, res = Integer.MIN_VALUE;\\n        for(int sum: A) {\\n            res = Math.max(res, sum - min);\\n            min = Math.min(min, sum);\\n        }\\n        return res;\\n    }\\n    private int maxSumSubarray(int[] A, int k) {\\n        int res = maxSumSubarray(A);\\n        if(res <= k) return res;\\n        res = Integer.MIN_VALUE;\\n        TreeSet<Integer> set = new TreeSet<>();\\n        set.add(0);\\n        for(int sum: A) {\\n            Integer old = set.ceiling(sum - k);\\n            if(old != null) {\\n                if(sum - old > res) {\\n                    res = sum - old;\\n                    if(res == k) return res;\\n                }\\n            }\\n            set.add(sum);\\n        }\\n        return res;\\n    }\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int m = matrix.length, n = m == 0 ? 0 : matrix[0].length, res = Integer.MIN_VALUE;\\n        boolean groupingRows = true;\\n        if(m > n) {\\n            int temp = m; m = n; n = temp;\\n            groupingRows = false;\\n        }\\n        int[] sum = new int[n];\\n        for(int i = 0; i < m; i++) {\\n            Arrays.fill(sum, 0);\\n            for(int j = i; j < m; j++) {\\n                int pre = 0;\\n                if(groupingRows) {\\n                    for(int t = 0; t < n; t++) sum[t] += pre += matrix[j][t];\\n                } else {\\n                    for(int t = 0; t < n; t++) sum[t] += pre += matrix[t][j];\\n                }\\n                res = Math.max(res, maxSumSubarray(sum, k));\\n                if(res == k) return res;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n**Approach 2:**\\nBasic idea is the same as previous approach but we solve the problem in Step 2 differently.\\nHere we leverage divide and conquer technique. Basically we perform merge sort on ```prefix``` sum values and calculate result during merge step.\\nOne might remember the idea of using merge sort to count inversions in an array. This is very similar.\\n\\nSo how exactly do we compute result during merge step?\\nSuppose we are merging left ```prefix``` subarray and right ```prefix``` subarray.\\nRemember from previous approach, for each index we\\'re trying to **find an old prefix sum which is just greater than or equal to current prefix sum - k**. So we can iterate over right subarray and for each index ```j```, keep incrementing the pointer in left array ```i``` (initialized to start index) till that situation is false (or basically ```prefix[i] < prefix[j] - k```). This way, we can compute the result for all cross subarrays (i.e. ```i``` in left subarray and ```j``` in right subarray) in linear time.\\nAfter this, we do the standard merging part of merge sort.\\n\\n```\\n// 7 ms. 95.80%\\nclass Solution {\\n    private int[] M;\\n    private int merge(int[] A, int l, int m, int r, int k) {\\n        int res = Integer.MIN_VALUE;\\n        for(int j = m+1, i = l; j <= r; j++) {\\n            while(i <= m && A[j] - A[i] > k) i++;\\n            if(i > m) break;\\n            res = Math.max(res, A[j] - A[i]);\\n            if(res == k) return res;\\n        }\\n        int i = l, j = m+1, t = 0;\\n        while(i <= m && j <= r) M[t++] = A[i] <= A[j] ? A[i++] : A[j++];\\n        while(i <= m) M[t++] = A[i++];\\n        while(j <= r) M[t++] = A[j++];\\n        for(i = l; i <= r; i++) A[i] = M[i-l];\\n        return res;\\n    }\\n    private int mergeSort(int[] A, int l, int r, int k) {\\n        if(l == r) return A[l] <= k ? A[l] : Integer.MIN_VALUE;\\n        int m = l + ((r-l) >> 1);\\n        int res = mergeSort(A, l, m, k);\\n        if(res == k) return res;\\n        res = Math.max(res, mergeSort(A, m+1, r, k));\\n        if(res == k) return res;\\n        return Math.max(res, merge(A, l, m, r, k));\\n    }\\n    private int maxSumSubarray(int[] A) {\\n        int min = 0, res = Integer.MIN_VALUE;\\n        for(int sum: A) {\\n            res = Math.max(res, sum - min);\\n            min = Math.min(min, sum);\\n        }\\n        return res;\\n    }\\n    private int maxSumSubarray(int[] A, int k) {\\n        int res = maxSumSubarray(A);\\n        if(res <= k) return res;\\n        return mergeSort(A.clone(), 0, A.length-1, k);\\n    }\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int m = matrix.length, n = m == 0 ? 0 : matrix[0].length, res = Integer.MIN_VALUE;\\n        boolean groupingRows = true;\\n        if(m > n) {\\n            int temp = m; m = n; n = temp;\\n            groupingRows = false;\\n        }\\n        int[] sum = new int[n];\\n        this.M = new int[n];\\n        for(int i = 0; i < m; i++) {\\n            Arrays.fill(sum, 0);\\n            for(int j = i; j < m; j++) {\\n                int pre = 0;\\n                if(groupingRows) {\\n                    for(int t = 0; t < n; t++) sum[t] += pre += matrix[j][t];\\n                } else {\\n                    for(int t = 0; t < n; t++) sum[t] += pre += matrix[t][j];\\n                }\\n                res = Math.max(res, maxSumSubarray(sum, k));\\n                if(res == k) return res;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Merge Sort",
                    "Ordered Set"
                ],
                "code": "```A```\n```sum[i..j] = A[i] + A[i+1] + ... A[j] <= k```\n```sum[i..j]```\n```prefix```\n```sum[i..j] = prefix[j] - prefix[i-1]```\n```j```\n```i (i < j)```\n```sum[i..j] <= k```\n```prefix[j] - prefix[i-1] <= k```\n```prefix[i-1]```\n```prefix[i-1]```\n```prefix[i-1]```\n```prefix[j] - prefix[i-1] <= k```\n```prefix[i-1]```\n```prefix[i-1] >= prefix[j] - k```\n```prefix```\n```<= k```\n```\\n// 12 ms. 94.57%\\nclass Solution {\\n    private int maxSumSubarray(int[] A) {\\n        int min = 0, res = Integer.MIN_VALUE;\\n        for(int sum: A) {\\n            res = Math.max(res, sum - min);\\n            min = Math.min(min, sum);\\n        }\\n        return res;\\n    }\\n    private int maxSumSubarray(int[] A, int k) {\\n        int res = maxSumSubarray(A);\\n        if(res <= k) return res;\\n        res = Integer.MIN_VALUE;\\n        TreeSet<Integer> set = new TreeSet<>();\\n        set.add(0);\\n        for(int sum: A) {\\n            Integer old = set.ceiling(sum - k);\\n            if(old != null) {\\n                if(sum - old > res) {\\n                    res = sum - old;\\n                    if(res == k) return res;\\n                }\\n            }\\n            set.add(sum);\\n        }\\n        return res;\\n    }\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int m = matrix.length, n = m == 0 ? 0 : matrix[0].length, res = Integer.MIN_VALUE;\\n        boolean groupingRows = true;\\n        if(m > n) {\\n            int temp = m; m = n; n = temp;\\n            groupingRows = false;\\n        }\\n        int[] sum = new int[n];\\n        for(int i = 0; i < m; i++) {\\n            Arrays.fill(sum, 0);\\n            for(int j = i; j < m; j++) {\\n                int pre = 0;\\n                if(groupingRows) {\\n                    for(int t = 0; t < n; t++) sum[t] += pre += matrix[j][t];\\n                } else {\\n                    for(int t = 0; t < n; t++) sum[t] += pre += matrix[t][j];\\n                }\\n                res = Math.max(res, maxSumSubarray(sum, k));\\n                if(res == k) return res;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\n```prefix```\n```prefix```\n```prefix```\n```j```\n```i```\n```prefix[i] < prefix[j] - k```\n```i```\n```j```\n```\\n// 7 ms. 95.80%\\nclass Solution {\\n    private int[] M;\\n    private int merge(int[] A, int l, int m, int r, int k) {\\n        int res = Integer.MIN_VALUE;\\n        for(int j = m+1, i = l; j <= r; j++) {\\n            while(i <= m && A[j] - A[i] > k) i++;\\n            if(i > m) break;\\n            res = Math.max(res, A[j] - A[i]);\\n            if(res == k) return res;\\n        }\\n        int i = l, j = m+1, t = 0;\\n        while(i <= m && j <= r) M[t++] = A[i] <= A[j] ? A[i++] : A[j++];\\n        while(i <= m) M[t++] = A[i++];\\n        while(j <= r) M[t++] = A[j++];\\n        for(i = l; i <= r; i++) A[i] = M[i-l];\\n        return res;\\n    }\\n    private int mergeSort(int[] A, int l, int r, int k) {\\n        if(l == r) return A[l] <= k ? A[l] : Integer.MIN_VALUE;\\n        int m = l + ((r-l) >> 1);\\n        int res = mergeSort(A, l, m, k);\\n        if(res == k) return res;\\n        res = Math.max(res, mergeSort(A, m+1, r, k));\\n        if(res == k) return res;\\n        return Math.max(res, merge(A, l, m, r, k));\\n    }\\n    private int maxSumSubarray(int[] A) {\\n        int min = 0, res = Integer.MIN_VALUE;\\n        for(int sum: A) {\\n            res = Math.max(res, sum - min);\\n            min = Math.min(min, sum);\\n        }\\n        return res;\\n    }\\n    private int maxSumSubarray(int[] A, int k) {\\n        int res = maxSumSubarray(A);\\n        if(res <= k) return res;\\n        return mergeSort(A.clone(), 0, A.length-1, k);\\n    }\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int m = matrix.length, n = m == 0 ? 0 : matrix[0].length, res = Integer.MIN_VALUE;\\n        boolean groupingRows = true;\\n        if(m > n) {\\n            int temp = m; m = n; n = temp;\\n            groupingRows = false;\\n        }\\n        int[] sum = new int[n];\\n        this.M = new int[n];\\n        for(int i = 0; i < m; i++) {\\n            Arrays.fill(sum, 0);\\n            for(int j = i; j < m; j++) {\\n                int pre = 0;\\n                if(groupingRows) {\\n                    for(int t = 0; t < n; t++) sum[t] += pre += matrix[j][t];\\n                } else {\\n                    for(int t = 0; t < n; t++) sum[t] += pre += matrix[t][j];\\n                }\\n                res = Math.max(res, maxSumSubarray(sum, k));\\n                if(res == k) return res;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 799232,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int kadane(vector<int> vt,int k){\\n        set<int> st;\\n        int sum=0;\\n        int result=INT_MIN;\\n        st.insert(0);\\n        for(int i=0;i<vt.size();i++){\\n            sum+=vt[i];\\n            auto it=st.lower_bound(sum-k);\\n            \\n            if(it!=st.end()){\\n                result=max(result,sum-(*it));\\n            }\\n            \\n            st.insert(sum);\\n        }\\n        \\n        return result;\\n    }\\n    \\n    \\n    \\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        int result=INT_MIN;\\n        \\n        for(int l=0;l<m;l++){\\n            vector<int> sum(n,0);\\n            for(int r=l;r<m;r++){\\n                \\n                for(int i=0;i<n;i++){\\n                    sum[i]+=matrix[i][r];\\n                }\\n                \\n                result=max(result,kadane(sum,k));\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int kadane(vector<int> vt,int k){\\n        set<int> st;\\n        int sum=0;\\n        int result=INT_MIN;\\n        st.insert(0);\\n        for(int i=0;i<vt.size();i++){\\n            sum+=vt[i];\\n            auto it=st.lower_bound(sum-k);\\n            \\n            if(it!=st.end()){\\n                result=max(result,sum-(*it));\\n            }\\n            \\n            st.insert(sum);\\n        }\\n        \\n        return result;\\n    }\\n    \\n    \\n    \\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        int result=INT_MIN;\\n        \\n        for(int l=0;l<m;l++){\\n            vector<int> sum(n,0);\\n            for(int r=l;r<m;r++){\\n                \\n                for(int i=0;i<n;i++){\\n                    sum[i]+=matrix[i][r];\\n                }\\n                \\n                result=max(result,kadane(sum,k));\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 568746,
                "title": "python3-solution-with-bst",
                "content": "The idea comes from https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/discuss/83596/Any-Accepted-Python-Solution/300996 and Thanks to @sfcapital999\\n for sharing his solution. I have rewritten the implementation to make it more clear and hopefully it could help the other people who are stuck on this question for quite a while:)\\n \\n ```\\n class TreeNode:\\n    def __init__(self, val: int):\\n        self.val = val\\n        self.left = None\\n        self.right = None\\n\\n\\nclass BST:\\n    def __init__(self, root: TreeNode):\\n        self.root = root\\n\\n    def insert(self, newNode: TreeNode) -> None:\\n        \"\"\"\\n        Insert a new node to the BST.\\n        \"\"\"\\n        currNode = self.root\\n        while currNode:\\n            if currNode.val > newNode.val:\\n                if currNode.left:\\n                    currNode = currNode.left\\n                else:\\n                    currNode.left = newNode\\n                    break\\n            else:\\n                if currNode.right:\\n                    currNode = currNode.right\\n                else:\\n                    currNode.right = newNode\\n                    break\\n\\n    def ceiling(self, val: int) -> int:\\n        \"\"\"\\n        Try to find a node in BST whose value is the minimum value that is\\n        not less than the input value, then return the node\\'s value.\\n        \"\"\"\\n        currNode = self.root\\n        rslt = float(\\'inf\\')\\n        while currNode:\\n            if currNode.val < val:\\n                currNode = currNode.right\\n            else:\\n                rslt = min(rslt, currNode.val)\\n                currNode = currNode.left\\n\\n        return rslt\\n\\n\\nclass Solution:\\n    def _get_limit_max_sub_sum(self, nums: List[int], k: int) -> int:\\n        \"\"\"\\n        Try to find a contiguous sub list from nums whose summary <= k.\\n        The search process is accelarated by storing the pre calculated\\n        sub summaries to each node of a BST.\\n        \"\"\"\\n        currSum, currMax = 0, float(\\'-inf\\')\\n        bst = BST(TreeNode(currSum))\\n        for num in nums:\\n            currSum += num\\n            preSum = bst.ceiling(currSum - k)\\n            currMax = max(currMax, currSum - preSum)\\n            bst.insert(TreeNode(currSum))\\n\\n        return currMax\\n\\n    def _get_no_limit_max_sub_sum(self, nums: List[int]) -> int:\\n        \"\"\"\\n        Get the maximum summary of any contiguous sub list from the input list.\\n        \"\"\"\\n        currMax, currSum = float(\\'-inf\\'), 0\\n        for num in nums:\\n            currSum = max(num, currSum + num)\\n            currMax = max(currMax, currSum)\\n\\n        return currMax\\n\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        \"\"\"\\n        Presumptions:\\n        1. matrix is not empty.\\n        2. matrix has more rows than columns.\\n        \"\"\"\\n        R, C = len(matrix), len(matrix[0])\\n        currMax = float(\\'-inf\\')\\n        for c1 in range(C):\\n            rowSums = [0] * R\\n            for c2 in range(c1, C):\\n                # First calculate sum between column c1 to c2 of each row.\\n                for r in range(R):\\n                    rowSums[r] += matrix[r][c2]\\n\\n                # Then the sum of rectangles between column c1 and c2\\n                # could be formed by any contiguous sub list from rowSums.\\n                # So firstly we try to get the maximum sub sum from rowSums.\\n                noLimitSubMax = self._get_no_limit_max_sub_sum(rowSums)\\n                if noLimitSubMax <= k:\\n                    currMax = max(currMax, noLimitSubMax)\\n                else:\\n                    currMax = max(\\n                        currMax, self._get_limit_max_sub_sum(rowSums, k))\\n\\n                # Found the maximum possible sub sum.\\n                if currMax == k:\\n                    return k\\n\\n        return currMax\\n ```",
                "solutionTags": [
                    "Python3",
                    "Binary Search Tree"
                ],
                "code": "```\\n class TreeNode:\\n    def __init__(self, val: int):\\n        self.val = val\\n        self.left = None\\n        self.right = None\\n\\n\\nclass BST:\\n    def __init__(self, root: TreeNode):\\n        self.root = root\\n\\n    def insert(self, newNode: TreeNode) -> None:\\n        \"\"\"\\n        Insert a new node to the BST.\\n        \"\"\"\\n        currNode = self.root\\n        while currNode:\\n            if currNode.val > newNode.val:\\n                if currNode.left:\\n                    currNode = currNode.left\\n                else:\\n                    currNode.left = newNode\\n                    break\\n            else:\\n                if currNode.right:\\n                    currNode = currNode.right\\n                else:\\n                    currNode.right = newNode\\n                    break\\n\\n    def ceiling(self, val: int) -> int:\\n        \"\"\"\\n        Try to find a node in BST whose value is the minimum value that is\\n        not less than the input value, then return the node\\'s value.\\n        \"\"\"\\n        currNode = self.root\\n        rslt = float(\\'inf\\')\\n        while currNode:\\n            if currNode.val < val:\\n                currNode = currNode.right\\n            else:\\n                rslt = min(rslt, currNode.val)\\n                currNode = currNode.left\\n\\n        return rslt\\n\\n\\nclass Solution:\\n    def _get_limit_max_sub_sum(self, nums: List[int], k: int) -> int:\\n        \"\"\"\\n        Try to find a contiguous sub list from nums whose summary <= k.\\n        The search process is accelarated by storing the pre calculated\\n        sub summaries to each node of a BST.\\n        \"\"\"\\n        currSum, currMax = 0, float(\\'-inf\\')\\n        bst = BST(TreeNode(currSum))\\n        for num in nums:\\n            currSum += num\\n            preSum = bst.ceiling(currSum - k)\\n            currMax = max(currMax, currSum - preSum)\\n            bst.insert(TreeNode(currSum))\\n\\n        return currMax\\n\\n    def _get_no_limit_max_sub_sum(self, nums: List[int]) -> int:\\n        \"\"\"\\n        Get the maximum summary of any contiguous sub list from the input list.\\n        \"\"\"\\n        currMax, currSum = float(\\'-inf\\'), 0\\n        for num in nums:\\n            currSum = max(num, currSum + num)\\n            currMax = max(currMax, currSum)\\n\\n        return currMax\\n\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        \"\"\"\\n        Presumptions:\\n        1. matrix is not empty.\\n        2. matrix has more rows than columns.\\n        \"\"\"\\n        R, C = len(matrix), len(matrix[0])\\n        currMax = float(\\'-inf\\')\\n        for c1 in range(C):\\n            rowSums = [0] * R\\n            for c2 in range(c1, C):\\n                # First calculate sum between column c1 to c2 of each row.\\n                for r in range(R):\\n                    rowSums[r] += matrix[r][c2]\\n\\n                # Then the sum of rectangles between column c1 and c2\\n                # could be formed by any contiguous sub list from rowSums.\\n                # So firstly we try to get the maximum sub sum from rowSums.\\n                noLimitSubMax = self._get_no_limit_max_sub_sum(rowSums)\\n                if noLimitSubMax <= k:\\n                    currMax = max(currMax, noLimitSubMax)\\n                else:\\n                    currMax = max(\\n                        currMax, self._get_limit_max_sub_sum(rowSums, k))\\n\\n                # Found the maximum possible sub sum.\\n                if currMax == k:\\n                    return k\\n\\n        return currMax\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 485276,
                "title": "java-prefix-sum-solution-o-n-4",
                "content": "```\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int target) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int[][] dp = new int[m + 1][n + 1];\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0; i <m; ++i) {\\n            for(int j = 0; j < n; ++j) {\\n                dp[i + 1][j + 1] = dp[i][j + 1] + dp[i + 1][j] - dp[i][j] + matrix[i][j];\\n                if(dp[i + 1][j + 1] <= target) max = Math.max(max, dp[i + 1][j + 1]);\\n            }\\n        }\\n\\n        int sum = 0;\\n        for(int i = 1; i <= m; ++i) {\\n            for(int j = 1; j <= n; ++j) {\\n                for(int k = 1; i - k >= 0; ++k) {\\n                    for(int l = 1; j - l >= 0; ++l) {\\n                        sum = dp[i][j] - dp[i - k][j] - dp[i][j - l] + dp[i - k][j - l];\\n                        if(sum <= target) max = Math.max(max, sum);\\n                    }\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int target) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int[][] dp = new int[m + 1][n + 1];\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0; i <m; ++i) {\\n            for(int j = 0; j < n; ++j) {\\n                dp[i + 1][j + 1] = dp[i][j + 1] + dp[i + 1][j] - dp[i][j] + matrix[i][j];\\n                if(dp[i + 1][j + 1] <= target) max = Math.max(max, dp[i + 1][j + 1]);\\n            }\\n        }\\n\\n        int sum = 0;\\n        for(int i = 1; i <= m; ++i) {\\n            for(int j = 1; j <= n; ++j) {\\n                for(int k = 1; i - k >= 0; ++k) {\\n                    for(int l = 1; j - l >= 0; ++l) {\\n                        sum = dp[i][j] - dp[i - k][j] - dp[i][j - l] + dp[i - k][j - l];\\n                        if(sum <= target) max = Math.max(max, sum);\\n                    }\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 363968,
                "title": "c-20-ms-99-solution",
                "content": "This is pretty much the same as finding maximum rectangle sum, but with more work if the maximum sum exceeds the constraint. To handle the constraint, we can use a set with cumulative sums and look for a ```sum(i)``` that is as close to ```sum(j)-k``` as possible, and we can get the best sum as ```sum(j) - best sum(i)```. We can find `best sum(i)` by calling ```set::lower_bound```. \\n\\nBecause we need extra work only if the maximum sum exceeds the constraint, we can keep Kadane\\'s Algorithm for finding maximum sum, and only resort to using set and finding lower bound when the maximum sum does exceed constraint. \\n\\n```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int maxS) {\\n        int maxA = INT32_MIN, r = matrix.size(), c = matrix[0].size();\\n        for(int i = 0; i < c; ++i) {\\n            vector<int> sum(r, 0);\\n            if(maxA == maxS) return maxA; // Stop if we can reach maxS\\n            for(int j = i; j < c; ++j) {\\n                for(int k = 0; k < r; ++k) sum[k] += matrix[k][j];\\n                \\n                //First try Kadane\\'s Algo and see if maxSum is less than maxS. \\n                int curMax = INT32_MIN, curSum = 0;\\n                for(int k = 0; k < r; ++k) {\\n                    curSum += sum[k];\\n                    curMax = max(curMax, curSum);\\n                    if(curSum < 0) curSum = 0;\\n                }\\n                if(curMax <= maxS) {maxA = max(maxA, curMax); continue;}\\n                \\n                // Only apply slow method when there maxSum that is greater than maxS.\\n                int csum = 0;\\n                set<int> s({csum});\\n                for(int k = 0; k < r; ++k) {\\n                    csum += sum[k];\\n                    auto it = s.lower_bound(csum - maxS);\\n                    if(it != s.end()) maxA = max(maxA, csum - *it);\\n                    s.insert(csum);\\n                }\\n            }\\n        }\\n        return maxA;\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "solutionTags": [],
                "code": "```sum(i)```\n```sum(j)-k```\n```sum(j) - best sum(i)```\n```set::lower_bound```\n```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int maxS) {\\n        int maxA = INT32_MIN, r = matrix.size(), c = matrix[0].size();\\n        for(int i = 0; i < c; ++i) {\\n            vector<int> sum(r, 0);\\n            if(maxA == maxS) return maxA; // Stop if we can reach maxS\\n            for(int j = i; j < c; ++j) {\\n                for(int k = 0; k < r; ++k) sum[k] += matrix[k][j];\\n                \\n                //First try Kadane\\'s Algo and see if maxSum is less than maxS. \\n                int curMax = INT32_MIN, curSum = 0;\\n                for(int k = 0; k < r; ++k) {\\n                    curSum += sum[k];\\n                    curMax = max(curMax, curSum);\\n                    if(curSum < 0) curSum = 0;\\n                }\\n                if(curMax <= maxS) {maxA = max(maxA, curMax); continue;}\\n                \\n                // Only apply slow method when there maxSum that is greater than maxS.\\n                int csum = 0;\\n                set<int> s({csum});\\n                for(int k = 0; k < r; ++k) {\\n                    csum += sum[k];\\n                    auto it = s.lower_bound(csum - maxS);\\n                    if(it != s.end()) maxA = max(maxA, csum - *it);\\n                    s.insert(csum);\\n                }\\n            }\\n        }\\n        return maxA;\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "codeTag": "C++"
            },
            {
                "id": 339848,
                "title": "true-o-min-m-n-2-min-m-n-log-min-m-n-solution-in-python-not-using-bisort",
                "content": "Didn\\'t see anyone post a solution in Python in O(m^2 * nlogn). As treemap is not available, most O(m^2 * nlogn) solutions in Java/C++ don\\'t apply. \\nPosting one, inspired by Prob. 975\\n\\n```\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        R, C = len(matrix), len(matrix[0])\\n        if R > C:\\n            n_matrix = [[matrix[r][c] for r in range(R)] for c in range(C)]\\n            R, C = C, R\\n            matrix = n_matrix\\n        \\n        ps = [[0] * (C + 1) for _ in range(R + 1)]\\n        \\n        for r in range(R):\\n            for c in range(C):\\n                ps[r+1][c+1] = ps[r+1][c] + matrix[r][c]\\n        for c in range(C):\\n            for r in range(R):\\n                ps[r+1][c+1] = ps[r][c+1] + ps[r+1][c+1]\\n        \\n        res = -sys.maxsize\\n        for r1 in range(R):\\n            for r2 in range(r1, R):                \\n                vals = []\\n                maxx = -sys.maxsize\\n                flag = False\\n                for i in range(C + 1): # get the horizontal partial sums\\n                    val = ps[r2+1][i] - ps[r1][i]\\n                    if val - maxx <= k:\\n                        flag = True\\n                    maxx = max(maxx, val)\\n                    vals.append(val)\\n                                \\n                pairs = sorted([(v, i) for i, v in enumerate(vals)], reverse = True)\\n                stack = []\\n                i = 0\\n                for j in range(len(pairs)):\\n                    # elements with the value <= pairs[j][0] - k should be enstacked\\n                    while i < len(pairs) and pairs[i][0] >= pairs[j][0] - k:\\n                        while stack and stack[-1] >= pairs[i][1]:\\n                            stack.pop()\\n                        stack.append(pairs[i][1])\\n                        i += 1\\n    \\n                    pos = bisect.bisect_left(stack, pairs[j][1])\\n                    if pos > 0:\\n                        res = max(res, pairs[j][0] - vals[stack[pos-1]])\\n        return res\\n```\\n\\nNOT using bisort, only used bisect in the innermost loop, thus O(nlogn) for each combinations of r1, r2",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        R, C = len(matrix), len(matrix[0])\\n        if R > C:\\n            n_matrix = [[matrix[r][c] for r in range(R)] for c in range(C)]\\n            R, C = C, R\\n            matrix = n_matrix\\n        \\n        ps = [[0] * (C + 1) for _ in range(R + 1)]\\n        \\n        for r in range(R):\\n            for c in range(C):\\n                ps[r+1][c+1] = ps[r+1][c] + matrix[r][c]\\n        for c in range(C):\\n            for r in range(R):\\n                ps[r+1][c+1] = ps[r][c+1] + ps[r+1][c+1]\\n        \\n        res = -sys.maxsize\\n        for r1 in range(R):\\n            for r2 in range(r1, R):                \\n                vals = []\\n                maxx = -sys.maxsize\\n                flag = False\\n                for i in range(C + 1): # get the horizontal partial sums\\n                    val = ps[r2+1][i] - ps[r1][i]\\n                    if val - maxx <= k:\\n                        flag = True\\n                    maxx = max(maxx, val)\\n                    vals.append(val)\\n                                \\n                pairs = sorted([(v, i) for i, v in enumerate(vals)], reverse = True)\\n                stack = []\\n                i = 0\\n                for j in range(len(pairs)):\\n                    # elements with the value <= pairs[j][0] - k should be enstacked\\n                    while i < len(pairs) and pairs[i][0] >= pairs[j][0] - k:\\n                        while stack and stack[-1] >= pairs[i][1]:\\n                            stack.pop()\\n                        stack.append(pairs[i][1])\\n                        i += 1\\n    \\n                    pos = bisect.bisect_left(stack, pairs[j][1])\\n                    if pos > 0:\\n                        res = max(res, pairs[j][0] - vals[stack[pos-1]])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 111842,
                "title": "python-1200ms-binary-search-using-bisect",
                "content": "```\\nclass Solution(object):\\n    def maxSumSubmatrix(self, matrix, target):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        if not matrix or not matrix[0]:\\n            return 0\\n        m, n = len(matrix), len(matrix[0])\\n        if m > n:\\n            return self.maxSumSubmatrix(map(list,zip(*matrix)), target)\\n        res = -sys.maxint\\n        for r1 in range(m):\\n            sumArr = [0] * n\\n            for r2 in range(r1, m):\\n                # update sumArr: add matrix[r2]\\n                for j in range(n):\\n                    sumArr[j] += matrix[r2][j]\\n                \\n                curSum, tmpArr = 0, [0, sys.maxint]\\n                for k in range(n):\\n                    curSum += sumArr[k]\\n                    ind = bisect.bisect_left(tmpArr, curSum - target)\\n                    res = max(res, curSum - tmpArr[ind])\\n                    bisect.insort(tmpArr, curSum)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxSumSubmatrix(self, matrix, target):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        if not matrix or not matrix[0]:\\n            return 0\\n        m, n = len(matrix), len(matrix[0])\\n        if m > n:\\n            return self.maxSumSubmatrix(map(list,zip(*matrix)), target)\\n        res = -sys.maxint\\n        for r1 in range(m):\\n            sumArr = [0] * n\\n            for r2 in range(r1, m):\\n                # update sumArr: add matrix[r2]\\n                for j in range(n):\\n                    sumArr[j] += matrix[r2][j]\\n                \\n                curSum, tmpArr = 0, [0, sys.maxint]\\n                for k in range(n):\\n                    curSum += sumArr[k]\\n                    ind = bisect.bisect_left(tmpArr, curSum - target)\\n                    res = max(res, curSum - tmpArr[ind])\\n                    bisect.insort(tmpArr, curSum)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 83601,
                "title": "c-46ms-solution-beats-99-78",
                "content": "class Solution {\\npublic:\\n     \\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int m=matrix.size();\\n        if(m==0) return 0;\\n        int n=matrix[0].size();\\n        int res=INT_MIN;\\n        for(int i=0;i<n;i++) {  // the number of columns is smaller\\n            vector<int> sums(m,0);\\n            for(int j=i;j<n;j++) {\\n                for(int row=0;row<m;row++) {\\n                    sums[row]+=matrix[row][j];\\n                }\\n                int ms = maxSumArray(sums, k);\\n                if (ms == k) return ms;\\n                if (ms < k && ms > res) res = ms;\\n          \\n            }\\n        }\\n        return res;\\n    }\\n     \\n    int maxSumArray(vector<int> & arr, int k) {\\n        int sum = 0, maxS = INT_MIN;\\n        for (int i = 0; i < arr.size(); i++) {  //it's a trick. Maybe O(n) to solve this problem\\n            sum += arr[i];\\n            maxS = max(sum, maxS);\\n            if (sum == k ) return sum;\\n            if (sum < 0) sum = 0;\\n        }\\n        if (maxS <= k) return maxS;\\n        maxS= INT_MIN;\\n        set<int>sums;\\n        sum = 0;\\n        sums.insert(0);\\n        for (int i = 0; i < arr.size(); i++) {\\n            sum += arr[i];\\n            auto it = sums.lower_bound(sum - k);\\n            if (it != sums.end()) maxS = max(sum - *it, maxS);\\n            sums.insert(sum);\\n        }\\n        return maxS;\\n    }  \\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n     \\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int m=matrix.size();\\n        if(m==0) return 0;\\n        int n=matrix[0].size();\\n        int res=INT_MIN;\\n        for(int i=0;i<n;i++) {  // the number of columns is smaller\\n            vector<int> sums(m,0);\\n            for(int j=i;j<n;j++) {\\n                for(int row=0;row<m;row++) {\\n                    sums[row]+=matrix[row][j];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2491340,
                "title": "java-93-faster-clean-prefix-sum",
                "content": "```\\nclass Solution {\\n\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        final int rows = matrix.length;\\n        final int cols = matrix[0].length;\\n        final int[][] prefixSum = new int[rows + 1][cols + 1];\\n\\n        for (int r = 0; r < rows; r++) {\\n            for (int c = 0; c < cols; c++) {\\n                prefixSum[r + 1][c + 1] = prefixSum[r][c + 1] + prefixSum[r + 1][c] - prefixSum[r][c] + matrix[r][c];\\n            }\\n        }\\n\\n        int max = Integer.MIN_VALUE;\\n\\n        for (int rowSize = 0; rowSize < rows; rowSize++) {\\n            for (int colSize = 0; colSize < cols; colSize++) {\\n                for (int rStart = 0; rStart + rowSize < rows; rStart++) {\\n                    for (int cStart = 0; cStart + colSize < cols; cStart++) {\\n                        final int r1 = rStart;\\n                        final int c1 = cStart;\\n                        final int r2 = rStart + rowSize;\\n                        final int c2 = cStart + colSize;\\n                        final int sum = prefixSum[r2 + 1][c2 + 1] + prefixSum[r1][c1] - prefixSum[r1][c2 + 1] - prefixSum[r2 + 1][c1];\\n\\n                        if (sum == k) return k;\\n                        else if (sum < k) max = Math.max(max, sum);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return max;\\n    }\\n}\\n/**\\n\\nComplexity Analysis: \\n\\nM : No of rows\\nN : No of cols\\n\\nTime Complexity : \\n\\nTo Build prefix Sum : O(M*N)\\nTo Calculate Size of all rectangles : O(M^2*N^2)\\n\\n\\nSpace Complexity : \\n\\nTo Build prefix Sum : O(M*N)\\n\\n*/\\n",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\n\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        final int rows = matrix.length;\\n        final int cols = matrix[0].length;\\n        final int[][] prefixSum = new int[rows + 1][cols + 1];\\n\\n        for (int r = 0; r < rows; r++) {\\n            for (int c = 0; c < cols; c++) {\\n                prefixSum[r + 1][c + 1] = prefixSum[r][c + 1] + prefixSum[r + 1][c] - prefixSum[r][c] + matrix[r][c];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2490694,
                "title": "simple-prefix-sum-rust-solution-100-faster",
                "content": "```rust\\nimpl Solution {\\n    pub fn max_sum_submatrix(matrix: Vec<Vec<i32>>, k: i32) -> i32 {\\n        let n = matrix.len();\\n        let m = matrix[0].len();\\n        let mut ans = std::i32::MIN;\\n        let mut p = vec![vec![0; m + 1]; n + 1];\\n        \\n        for j in 1..=m {\\n            p[1][j] = p[1][j-1] + matrix[0][j-1];\\n        }\\n        \\n        for i in 1..=n {\\n            p[i][1] = p[i-1][1] + matrix[i-1][0];\\n        }\\n        \\n        for i in 2..=n {\\n            for j in 2..=m {\\n                p[i][j] = p[i-1][j] + p[i][j-1] - p[i-1][j-1] + matrix[i-1][j-1];\\n            }\\n        }\\n        \\n        for i in 0..n {\\n            for j in 0..m {\\n                for si in 1..=n-i {\\n                    for sj in 1..=m-j {\\n                        let cur_sum = p[i+si][j+sj] - p[i][j+sj] - p[i+si][j] + p[i][j];\\n                        if cur_sum <= k && cur_sum > ans {\\n                            ans = cur_sum;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Prefix Sum"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn max_sum_submatrix(matrix: Vec<Vec<i32>>, k: i32) -> i32 {\\n        let n = matrix.len();\\n        let m = matrix[0].len();\\n        let mut ans = std::i32::MIN;\\n        let mut p = vec![vec![0; m + 1]; n + 1];\\n        \\n        for j in 1..=m {\\n            p[1][j] = p[1][j-1] + matrix[0][j-1];\\n        }\\n        \\n        for i in 1..=n {\\n            p[i][1] = p[i-1][1] + matrix[i-1][0];\\n        }\\n        \\n        for i in 2..=n {\\n            for j in 2..=m {\\n                p[i][j] = p[i-1][j] + p[i][j-1] - p[i-1][j-1] + matrix[i-1][j-1];\\n            }\\n        }\\n        \\n        for i in 0..n {\\n            for j in 0..m {\\n                for si in 1..=n-i {\\n                    for sj in 1..=m-j {\\n                        let cur_sum = p[i+si][j+sj] - p[i][j+sj] - p[i+si][j] + p[i][j];\\n                        if cur_sum <= k && cur_sum > ans {\\n                            ans = cur_sum;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2490149,
                "title": "c-binary-search-prefix-sum-set-lower-bound-accepted",
                "content": "**Prefix Sum, Binary Search, Set Approach !!**\\n\\n**Time Complexity:- O(n^3*logn)**\\n  \\n\\n```\\nclass Solution {\\npublic:\\n   \\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int final_res=INT_MIN;\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                // Prefix Sum Calculated\\n                matrix[i][j]+=matrix[i][j-1];\\n            }\\n        }\\n        \\n        // Maintaining the window l-->start and r-->end\\n        for(int l=0;l<m;l++){\\n            for(int r=l;r<m;r++){\\n                set<int> st={0};\\n                //st.insert(0);\\n                \\n                // Prefix sum variable\\n                int p_sum1=0;\\n                \\n                // loop for considering the current width of the rectangle\\n                for(int i=0;i<n;i++){\\n                    int sum2=matrix[i][r];\\n                    if(l>0){\\n                        sum2=sum2-matrix[i][l-1];\\n                    }\\n                    \\n                    p_sum1=p_sum1 + sum2;\\n                    \\n                    int var = p_sum1-k;\\n                    \\n\\t\\t\\t\\t\\t// Lower Bound Calculated\\n                    auto it = st.lower_bound(var);\\n                    \\n                    if(it!=st.end()){\\n                        int tmp=p_sum1-(*it);\\n                    // updating the final res if it is maximum than the previous one\\n                        final_res = max(final_res,tmp);\\n                    }\\n                    \\n                    st.insert(p_sum1);\\n                }\\n            }\\n        }\\n        \\n        return final_res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree",
                    "Prefix Sum",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int final_res=INT_MIN;\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                // Prefix Sum Calculated\\n                matrix[i][j]+=matrix[i][j-1];\\n            }\\n        }\\n        \\n        // Maintaining the window l-->start and r-->end\\n        for(int l=0;l<m;l++){\\n            for(int r=l;r<m;r++){\\n                set<int> st={0};\\n                //st.insert(0);\\n                \\n                // Prefix sum variable\\n                int p_sum1=0;\\n                \\n                // loop for considering the current width of the rectangle\\n                for(int i=0;i<n;i++){\\n                    int sum2=matrix[i][r];\\n                    if(l>0){\\n                        sum2=sum2-matrix[i][l-1];\\n                    }\\n                    \\n                    p_sum1=p_sum1 + sum2;\\n                    \\n                    int var = p_sum1-k;\\n                    \\n\\t\\t\\t\\t\\t// Lower Bound Calculated\\n                    auto it = st.lower_bound(var);\\n                    \\n                    if(it!=st.end()){\\n                        int tmp=p_sum1-(*it);\\n                    // updating the final res if it is maximum than the previous one\\n                        final_res = max(final_res,tmp);\\n                    }\\n                    \\n                    st.insert(p_sum1);\\n                }\\n            }\\n        }\\n        \\n        return final_res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2489584,
                "title": "fastest-python-working-99-faster-91-more-memory-efficient-solution-multiple-approach",
                "content": "# DON\\'T FORGET TO UPVOTE!!\\n# 1. 99% Fast and 91% memory efficient best solution:\\n\\n\\n\\tclass Solution:\\n\\t\\tdef maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n\\t\\t\\tdef find(nums: List[int]):\\n\\t\\t\\t\\tprefixsums_encountered = [0]\\n\\t\\t\\t\\tn = 1\\n\\t\\t\\t\\tres = -inf\\n\\t\\t\\t\\tfor prefixsum in accumulate(nums):\\n\\t\\t\\t\\t\\tprev_sum = prefixsum - k\\n\\t\\t\\t\\t\\tpos = bisect_left(prefixsums_encountered, prev_sum)\\n\\t\\t\\t\\t\\tif pos < n:\\n\\t\\t\\t\\t\\t\\tres = max(res, prefixsum - prefixsums_encountered[pos])\\n\\t\\t\\t\\t\\t\\tif res == k:\\n\\t\\t\\t\\t\\t\\t\\treturn k\\n\\t\\t\\t\\t\\tinsort(prefixsums_encountered, prefixsum)\\n\\t\\t\\t\\t\\tn += 1\\n\\t\\t\\t\\treturn res\\n\\n\\t\\t\\theight, width = len(matrix), len(matrix[0])\\n\\t\\t\\tres = -inf\\n\\t\\t\\tfor rownum in range(height):\\n\\t\\t\\t\\ttotals = [0] * width\\n\\t\\t\\t\\tfor bottom_row in range(rownum, height):\\n\\t\\t\\t\\t\\tfor colnum in range(width):\\n\\t\\t\\t\\t\\t\\ttotals[colnum] += matrix[bottom_row][colnum]\\n\\n\\t\\t\\t\\t\\tres = max(res, find(totals))\\n\\t\\t\\t\\t\\tif res == k:\\n\\t\\t\\t\\t\\t\\treturn k\\n\\t\\t\\treturn res\\n\\n\\n# 2. 91% fast and 90% memory efficient solution:\\n\\n\\t\\tclass Solution:\\n\\t\\t\\tdef maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n\\t\\t\\t\\tif not matrix:  return 0\\n\\n\\t\\t\\t\\tres = float(\\'-inf\\')\\n\\t\\t\\t\\tM, N = len(matrix), len(matrix[0])\\n\\n\\n\\t\\t\\t\\tfor i in range(N):\\n\\t\\t\\t\\t\\tsums = [0 for _ in range(M)]\\n\\t\\t\\t\\t\\tfor j in range(i, N):\\n\\t\\t\\t\\t\\t\\tfor r in range(M):\\n\\t\\t\\t\\t\\t\\t\\tsums[r] += matrix[r][j]\\n\\n\\t\\t\\t\\t\\t\\t# find the largest sum of a subarray which is no more than K\\n\\t\\t\\t\\t\\t\\timport bisect\\n\\t\\t\\t\\t\\t\\tcum_sum = [0]\\n\\t\\t\\t\\t\\t\\tcum, max_sum = 0, float(\\'-inf\\')\\n\\t\\t\\t\\t\\t\\tfor item in sums:\\n\\t\\t\\t\\t\\t\\t\\tcum += item\\n\\t\\t\\t\\t\\t\\t\\t# current accum - prev accum <= k, try to find the target in the list of accum values\\n\\t\\t\\t\\t\\t\\t\\ttarget = cum - k \\n\\t\\t\\t\\t\\t\\t\\tleft = bisect.bisect_left(cum_sum, target)\\n\\t\\t\\t\\t\\t\\t\\tif left < len(cum_sum):\\n\\t\\t\\t\\t\\t\\t\\t\\tmax_sum = max(max_sum, cum - cum_sum[left])\\n\\t\\t\\t\\t\\t\\t\\tbisect.insort(cum_sum, cum)\\n\\n\\t\\t\\t\\t\\t\\tres = max(res, max_sum)\\n\\n\\t\\t\\t\\treturn res\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n# 3.  81% FAST slightly differtent solution:\\n\\n\\n\\tclass Solution:\\n\\t\\tdef maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n\\t\\t\\tm = len(matrix)\\n\\t\\t\\tn = len(matrix[0])\\n\\n\\t\\t\\tfor i in range(1, m):\\n\\t\\t\\t\\tfor j in range(n):\\n\\t\\t\\t\\t\\tmatrix[i][j] += matrix[i - 1][j]\\n\\n\\t\\t\\tmax_sum = -float(\\'inf\\')\\n\\t\\t\\tfor i in range(m):\\n\\t\\t\\t\\tfor j in range(i, m):\\n\\t\\t\\t\\t\\tcol_prefix_sums = [0 for _ in range(n)]\\n\\t\\t\\t\\t\\tcol_prefix_sums[0] = matrix[j][0] - (0 if i - 1 < 0 else matrix[i - 1][0])\\n\\t\\t\\t\\t\\tfor l in range(1, n):\\n\\t\\t\\t\\t\\t\\tcol_prefix_sums[l] += (col_prefix_sums[l - 1] + matrix[j][l] - (0 if i - 1 < 0 else matrix[i - 1][l]))\\n\\t\\t\\t\\t\\tmax_sum = max(max_sum, self.process_col_prefix_sums(col_prefix_sums, k))\\n\\n\\t\\t\\treturn max_sum\\n\\n\\t\\tdef process_col_prefix_sums(self, col_prefix_sums, k):\\n\\t\\t\\tmax_sum = -float(\\'inf\\')\\n\\t\\t\\tordered_list = []\\n\\t\\t\\tordered_list.append(0)\\n\\t\\t\\tfor prefix_sum in col_prefix_sums:\\n\\t\\t\\t\\ttarget = prefix_sum - k\\n\\t\\t\\t\\tidx = bisect_left(ordered_list, target)\\n\\t\\t\\t\\tif idx < len(ordered_list):\\n\\t\\t\\t\\t\\tmax_sum = max(max_sum, prefix_sum - ordered_list[idx])\\n\\t\\t\\t\\tinsert_idx = bisect_left(ordered_list, prefix_sum)\\n\\t\\t\\t\\tordered_list.insert(insert_idx, prefix_sum)\\n\\t\\t\\treturn max_sum",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "# DON\\'T FORGET TO UPVOTE!!\\n# 1. 99% Fast and 91% memory efficient best solution:\\n\\n\\n\\tclass Solution:\\n\\t\\tdef maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n\\t\\t\\tdef find(nums: List[int]):\\n\\t\\t\\t\\tprefixsums_encountered = [0]\\n\\t\\t\\t\\tn = 1\\n\\t\\t\\t\\tres = -inf\\n\\t\\t\\t\\tfor prefixsum in accumulate(nums):\\n\\t\\t\\t\\t\\tprev_sum = prefixsum - k\\n\\t\\t\\t\\t\\tpos = bisect_left(prefixsums_encountered, prev_sum)\\n\\t\\t\\t\\t\\tif pos < n:\\n\\t\\t\\t\\t\\t\\tres = max(res, prefixsum - prefixsums_encountered[pos])\\n\\t\\t\\t\\t\\t\\tif res == k:\\n\\t\\t\\t\\t\\t\\t\\treturn k\\n\\t\\t\\t\\t\\tinsort(prefixsums_encountered, prefixsum)\\n\\t\\t\\t\\t\\tn += 1\\n\\t\\t\\t\\treturn res\\n\\n\\t\\t\\theight, width = len(matrix), len(matrix[0])\\n\\t\\t\\tres = -inf\\n\\t\\t\\tfor rownum in range(height):\\n\\t\\t\\t\\ttotals = [0] * width\\n\\t\\t\\t\\tfor bottom_row in range(rownum, height):\\n\\t\\t\\t\\t\\tfor colnum in range(width):\\n\\t\\t\\t\\t\\t\\ttotals[colnum] += matrix[bottom_row][colnum]\\n\\n\\t\\t\\t\\t\\tres = max(res, find(totals))\\n\\t\\t\\t\\t\\tif res == k:\\n\\t\\t\\t\\t\\t\\treturn k\\n\\t\\t\\treturn res\\n\\n\\n# 2. 91% fast and 90% memory efficient solution:\\n\\n\\t\\tclass Solution:\\n\\t\\t\\tdef maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n\\t\\t\\t\\tif not matrix:  return 0\\n\\n\\t\\t\\t\\tres = float(\\'-inf\\')\\n\\t\\t\\t\\tM, N = len(matrix), len(matrix[0])\\n\\n\\n\\t\\t\\t\\tfor i in range(N):\\n\\t\\t\\t\\t\\tsums = [0 for _ in range(M)]\\n\\t\\t\\t\\t\\tfor j in range(i, N):\\n\\t\\t\\t\\t\\t\\tfor r in range(M):\\n\\t\\t\\t\\t\\t\\t\\tsums[r] += matrix[r][j]\\n\\n\\t\\t\\t\\t\\t\\t# find the largest sum of a subarray which is no more than K\\n\\t\\t\\t\\t\\t\\timport bisect\\n\\t\\t\\t\\t\\t\\tcum_sum = [0]\\n\\t\\t\\t\\t\\t\\tcum, max_sum = 0, float(\\'-inf\\')\\n\\t\\t\\t\\t\\t\\tfor item in sums:\\n\\t\\t\\t\\t\\t\\t\\tcum += item\\n\\t\\t\\t\\t\\t\\t\\t# current accum - prev accum <= k, try to find the target in the list of accum values\\n\\t\\t\\t\\t\\t\\t\\ttarget = cum - k \\n\\t\\t\\t\\t\\t\\t\\tleft = bisect.bisect_left(cum_sum, target)\\n\\t\\t\\t\\t\\t\\t\\tif left < len(cum_sum):\\n\\t\\t\\t\\t\\t\\t\\t\\tmax_sum = max(max_sum, cum - cum_sum[left])\\n\\t\\t\\t\\t\\t\\t\\tbisect.insort(cum_sum, cum)\\n\\n\\t\\t\\t\\t\\t\\tres = max(res, max_sum)\\n\\n\\t\\t\\t\\treturn res\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n# 3.  81% FAST slightly differtent solution:\\n\\n\\n\\tclass Solution:\\n\\t\\tdef maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n\\t\\t\\tm = len(matrix)\\n\\t\\t\\tn = len(matrix[0])\\n\\n\\t\\t\\tfor i in range(1, m):\\n\\t\\t\\t\\tfor j in range(n):\\n\\t\\t\\t\\t\\tmatrix[i][j] += matrix[i - 1][j]\\n\\n\\t\\t\\tmax_sum = -float(\\'inf\\')\\n\\t\\t\\tfor i in range(m):\\n\\t\\t\\t\\tfor j in range(i, m):\\n\\t\\t\\t\\t\\tcol_prefix_sums = [0 for _ in range(n)]\\n\\t\\t\\t\\t\\tcol_prefix_sums[0] = matrix[j][0] - (0 if i - 1 < 0 else matrix[i - 1][0])\\n\\t\\t\\t\\t\\tfor l in range(1, n):\\n\\t\\t\\t\\t\\t\\tcol_prefix_sums[l] += (col_prefix_sums[l - 1] + matrix[j][l] - (0 if i - 1 < 0 else matrix[i - 1][l]))\\n\\t\\t\\t\\t\\tmax_sum = max(max_sum, self.process_col_prefix_sums(col_prefix_sums, k))\\n\\n\\t\\t\\treturn max_sum\\n\\n\\t\\tdef process_col_prefix_sums(self, col_prefix_sums, k):\\n\\t\\t\\tmax_sum = -float(\\'inf\\')\\n\\t\\t\\tordered_list = []\\n\\t\\t\\tordered_list.append(0)\\n\\t\\t\\tfor prefix_sum in col_prefix_sums:\\n\\t\\t\\t\\ttarget = prefix_sum - k\\n\\t\\t\\t\\tidx = bisect_left(ordered_list, target)\\n\\t\\t\\t\\tif idx < len(ordered_list):\\n\\t\\t\\t\\t\\tmax_sum = max(max_sum, prefix_sum - ordered_list[idx])\\n\\t\\t\\t\\tinsert_idx = bisect_left(ordered_list, prefix_sum)\\n\\t\\t\\t\\tordered_list.insert(insert_idx, prefix_sum)\\n\\t\\t\\treturn max_sum",
                "codeTag": "Java"
            },
            {
                "id": 2489164,
                "title": "using-kadane-algorithm-c-solution-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int row = matrix.size(), col = matrix[0].size(), res = INT_MIN;\\n        for(int left = 0 ; left < col ; left++){\\n            vector<int> sum(row, 0);\\n            for(int right = left ; right < col ; right++){\\n                for(int r=0 ; r<row; r++){\\n                    sum[r] += matrix[r][right];\\n                }\\n                set<int> mySet;\\n                mySet.insert(0);\\n                int currSum = 0, currMax = INT_MIN;\\n                for(int r=0 ; r<row; r++){\\n                    currSum+=sum[r];\\n                    auto  it = mySet.lower_bound(currSum-k);\\n                    if(it!=mySet.end()) currMax = max(currMax, currSum - (*it));\\n                    mySet.insert(currSum);\\n                }\\n                res = max (res, currMax);\\n            }\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int row = matrix.size(), col = matrix[0].size(), res = INT_MIN;\\n        for(int left = 0 ; left < col ; left++){\\n            vector<int> sum(row, 0);\\n            for(int right = left ; right < col ; right++){\\n                for(int r=0 ; r<row; r++){\\n                    sum[r] += matrix[r][right];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2488730,
                "title": "135-ms-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n\\t// TIME COMPLEXITY:- O(M^2 NLOG(N))\\n\\t// SPACE COMPLEXITY:- O(N)\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n    //     int n = matrix.size();\\n    //     int m = matrix[0].size();\\n    //     int ans = INT_MIN;\\n    //     // prefix sum of every row\\n    //     for(int i=0;i<n;i++){\\n    //         for(int j=1;j<m;j++)\\n    //             matrix[i][j]+=matrix[i][j-1];\\n    //     }\\n    //     // try every possible width of subarray\\n    //     for(int start=0;start<m;start++){\\n    //         for(int end=start;end<m;end++){\\n    //             set<int> s = {0};\\n    //             int pref_sum = 0;\\n    //             // for current width of rectangle\\n    //             for(int i=0;i<n;i++){\\n    //                 int sum = matrix[i][end];\\n    //                 if(start>0)\\n    //                     sum-=matrix[i][start-1];\\n    //                 pref_sum+=sum;\\n    //                 auto itr = s.lower_bound(pref_sum-k);\\n    //                 if(itr!=s.end())\\n    //                     ans = max(ans,pref_sum-(*itr));\\n    //                 s.insert(pref_sum);\\n    //             }\\n    //         }\\n    //     }\\n    //     return ans;\\n    \\n        int ans = INT_MIN;\\n        \\n        int R = matrix.size();\\n        int C = matrix[0].size();\\n        int arr[R];\\n        \\n        for(int l = 0; l < C; ++l) {\\n            memset(arr, 0, sizeof(arr));\\n            \\n            for(int r = l; r < C; ++r) \\n            {\\n                for(int up = 0; up < R; ++up)\\n                {\\n                    arr[up] += matrix[up][r]; \\n                }\\n                int sum = 0, g = INT_MIN;\\n                for(int up = 0; up < R; ++up) \\n                {\\n                    sum = max(sum + arr[up], arr[up]);\\n                    g = max(g, sum);\\n                    if(g == k) \\n                        return k;\\n                }\\n                if(g < k) \\n                {\\n                    ans = max(ans, g);\\n                } \\n                else \\n                {\\n                    for(int up1 = 0; up1 < R; ++up1) \\n                    {\\n                        sum = 0;\\n                        for(int up2 = up1; up2 < R; ++up2) \\n                        {\\n                            sum += arr[up2];\\n                            if(sum <= k) \\n                                ans = max(ans, sum);\\n                        }\\n                        \\n                        if(ans == k) return k;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\t// TIME COMPLEXITY:- O(M^2 NLOG(N))\\n\\t// SPACE COMPLEXITY:- O(N)\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n    //     int n = matrix.size();\\n    //     int m = matrix[0].size();\\n    //     int ans = INT_MIN;\\n    //     // prefix sum of every row\\n    //     for(int i=0;i<n;i++){\\n    //         for(int j=1;j<m;j++)\\n    //             matrix[i][j]+=matrix[i][j-1];\\n    //     }\\n    //     // try every possible width of subarray\\n    //     for(int start=0;start<m;start++){\\n    //         for(int end=start;end<m;end++){\\n    //             set<int> s = {0};\\n    //             int pref_sum = 0;\\n    //             // for current width of rectangle\\n    //             for(int i=0;i<n;i++){\\n    //                 int sum = matrix[i][end];\\n    //                 if(start>0)\\n    //                     sum-=matrix[i][start-1];\\n    //                 pref_sum+=sum;\\n    //                 auto itr = s.lower_bound(pref_sum-k);\\n    //                 if(itr!=s.end())\\n    //                     ans = max(ans,pref_sum-(*itr));\\n    //                 s.insert(pref_sum);\\n    //             }\\n    //         }\\n    //     }\\n    //     return ans;\\n    \\n        int ans = INT_MIN;\\n        \\n        int R = matrix.size();\\n        int C = matrix[0].size();\\n        int arr[R];\\n        \\n        for(int l = 0; l < C; ++l) {\\n            memset(arr, 0, sizeof(arr));\\n            \\n            for(int r = l; r < C; ++r) \\n            {\\n                for(int up = 0; up < R; ++up)\\n                {\\n                    arr[up] += matrix[up][r]; \\n                }\\n                int sum = 0, g = INT_MIN;\\n                for(int up = 0; up < R; ++up) \\n                {\\n                    sum = max(sum + arr[up], arr[up]);\\n                    g = max(g, sum);\\n                    if(g == k) \\n                        return k;\\n                }\\n                if(g < k) \\n                {\\n                    ans = max(ans, g);\\n                } \\n                else \\n                {\\n                    for(int up1 = 0; up1 < R; ++up1) \\n                    {\\n                        sum = 0;\\n                        for(int up2 = up1; up2 < R; ++up2) \\n                        {\\n                            sum += arr[up2];\\n                            if(sum <= k) \\n                                ans = max(ans, sum);\\n                        }\\n                        \\n                        if(ans == k) return k;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2488502,
                "title": "java-easy-solution-updated",
                "content": "```\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] grid, int k) \\n    {\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        int max=Integer.MIN_VALUE;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int a[]=new int[m];\\n            for(int j=i;j<n;j++)\\n            {\\n                for(int x=0;x<m;x++)\\n                a[x]+=grid[j][x];\\n                \\n                int sum=helper(a,k);\\n                max=Math.max(max,sum);\\n            }\\n        }\\n        \\n        return max;\\n    }\\n    \\n    public int helper(int a[],int k)\\n    {\\n        int ans=Integer.MIN_VALUE;\\n        \\n        for(int i=0;i<a.length;i++)\\n        {\\n            int s=0;\\n            for(int j=i;j<a.length;j++)\\n            {\\n                s+=a[j];\\n                if(s<=k)\\n                ans=Math.max(ans,s);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] grid, int k) \\n    {\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        int max=Integer.MIN_VALUE;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int a[]=new int[m];\\n            for(int j=i;j<n;j++)\\n            {\\n                for(int x=0;x<m;x++)\\n                a[x]+=grid[j][x];\\n                \\n                int sum=helper(a,k);\\n                max=Math.max(max,sum);\\n            }\\n        }\\n        \\n        return max;\\n    }\\n    \\n    public int helper(int a[],int k)\\n    {\\n        int ans=Integer.MIN_VALUE;\\n        \\n        for(int i=0;i<a.length;i++)\\n        {\\n            int s=0;\\n            for(int j=i;j<a.length;j++)\\n            {\\n                s+=a[j];\\n                if(s<=k)\\n                ans=Math.max(ans,s);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2329481,
                "title": "c-well-commented-concise",
                "content": "```\\nclass Solution {\\npublic:\\n    int process(vector<int> &v,int k){\\n        \\n        set<int> s;\\n        s.insert(0);\\n\\t\\t// horizontal prefix sum to find actual sum of matrix \\n        for(int i = 1;i<v.size();i++){\\n            v[i] += v[i-1];\\n        }\\n        int ans = INT_MIN;\\n\\t\\t// since we want sum to be less than k so for some pre[i] a j must exist such that pre[i] - pre[j] <= k\\n\\t\\t// this gives pre[j] >= pre[i] - k and can be easily found using lower_bound\\n        for(int i = 0;i<v.size();i++){\\n            int p = v[i];\\n            auto it = s.lower_bound(p-k);\\n            if(it != s.end()){\\n                ans = max(ans,p - *it);\\n            }\\n            s.insert(v[i]);\\n        }\\n        return ans;\\n    }\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int sum) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n\\t\\t// vertical prefix sum for each matrix i.e. for each column\\n        for(int i = 0;i<m;i++){\\n            for(int j = 1;j<n;j++){\\n                matrix[j][i] += matrix[j-1][i];\\n            }\\n        }\\n        int ans = INT_MIN;\\n        for(int i = 0;i<n;i++){\\n            for(int j = i;j<n;j++){\\n\\t\\t\\t// fixing the height of matrix by setting starting row to i and ending row to j\\n                vector<int> temp;\\n\\t\\t\\t\\t// generating vertical prefix sum for i to j \\n                for(int k = 0;k<m;k++){\\n                    int val = matrix[j][k] - ((i-1>=0)?matrix[i-1][k]:0);\\n                    temp.push_back(val);\\n                }\\n                ans = max(ans,process(temp,sum));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int process(vector<int> &v,int k){\\n        \\n        set<int> s;\\n        s.insert(0);\\n\\t\\t// horizontal prefix sum to find actual sum of matrix \\n        for(int i = 1;i<v.size();i++){\\n            v[i] += v[i-1];\\n        }\\n        int ans = INT_MIN;\\n\\t\\t// since we want sum to be less than k so for some pre[i] a j must exist such that pre[i] - pre[j] <= k\\n\\t\\t// this gives pre[j] >= pre[i] - k and can be easily found using lower_bound\\n        for(int i = 0;i<v.size();i++){\\n            int p = v[i];\\n            auto it = s.lower_bound(p-k);\\n            if(it != s.end()){\\n                ans = max(ans,p - *it);\\n            }\\n            s.insert(v[i]);\\n        }\\n        return ans;\\n    }\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int sum) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n\\t\\t// vertical prefix sum for each matrix i.e. for each column\\n        for(int i = 0;i<m;i++){\\n            for(int j = 1;j<n;j++){\\n                matrix[j][i] += matrix[j-1][i];\\n            }\\n        }\\n        int ans = INT_MIN;\\n        for(int i = 0;i<n;i++){\\n            for(int j = i;j<n;j++){\\n\\t\\t\\t// fixing the height of matrix by setting starting row to i and ending row to j\\n                vector<int> temp;\\n\\t\\t\\t\\t// generating vertical prefix sum for i to j \\n                for(int k = 0;k<m;k++){\\n                    int val = matrix[j][k] - ((i-1>=0)?matrix[i-1][k]:0);\\n                    temp.push_back(val);\\n                }\\n                ans = max(ans,process(temp,sum));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1557124,
                "title": "simple-extended-kadane-s-algorithm-o-r-r-c-log-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int kadane(vector<int> a,int k){\\n        int ans=INT_MIN,cs=0,p=0;\\n        set<int> st;\\n        st.insert(0);\\n        for(int i=0;i<a.size();i++){\\n            cs+=a[i];\\n            if((cs-p)<=k)\\n                ans=max(ans,cs-p);\\n            else{\\n                auto it=st.lower_bound(cs-k);\\n                if(it!=st.end())\\n                    ans=max(ans,cs-*it);\\n            }\\n            st.insert(cs);\\n            p=min(p,cs);\\n        }\\n        return ans;\\n    }\\n    \\n    int maxSumSubmatrix(vector<vector<int>>& a, int k) {\\n        int ans=INT_MIN;\\n        for(int i=0;i<a.size();i++){\\n            vector<int> v(a[0].size(),0);\\n            for(int j=i;j<a.size();j++){\\n                for(int k=0;k<a[0].size();k++)\\n                    v[k]+=a[j][k];\\n                ans=max(ans,kadane(v,k));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Binary Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kadane(vector<int> a,int k){\\n        int ans=INT_MIN,cs=0,p=0;\\n        set<int> st;\\n        st.insert(0);\\n        for(int i=0;i<a.size();i++){\\n            cs+=a[i];\\n            if((cs-p)<=k)\\n                ans=max(ans,cs-p);\\n            else{\\n                auto it=st.lower_bound(cs-k);\\n                if(it!=st.end())\\n                    ans=max(ans,cs-*it);\\n            }\\n            st.insert(cs);\\n            p=min(p,cs);\\n        }\\n        return ans;\\n    }\\n    \\n    int maxSumSubmatrix(vector<vector<int>>& a, int k) {\\n        int ans=INT_MIN;\\n        for(int i=0;i<a.size();i++){\\n            vector<int> v(a[0].size(),0);\\n            for(int j=i;j<a.size();j++){\\n                for(int k=0;k<a[0].size();k++)\\n                    v[k]+=a[j][k];\\n                ans=max(ans,kadane(v,k));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1412192,
                "title": "clean-python-solution-offical-solution-with-other-similar-problems",
                "content": "```python\\n\"\"\"\\nTime: O(min(M,N)^2 * max(M,N) * Log(max(M,N)))\\nSpace: O(MN), can reduce to O(max(M,N)) by not using a new 2D array \"matrixRotated\".\\nJust change the iteration in `maxSumSubmatrix()`.\\n\\nThis is the implementation of the offical solution 1 and 2.\\n\"\"\"\\nfrom sortedcontainers import SortedSet\\n\\nclass Solution(object):\\n    def maxSumSubmatrix(self, matrix, k):\\n        if len(matrix)>len(matrix[0]): matrix = self.rotate(matrix)\\n        \\n        ans = float(\\'-inf\\')\\n        M = len(matrix)\\n        N = len(matrix[0])\\n        \\n        for start in xrange(M):\\n            rowSum = [0]*N #row sum of rows from matrix[start] to row\\n            for row in matrix[start:]:\\n                for i, n in enumerate(row): rowSum[i] += n\\n                ans = max(ans, self.maxSumRow(rowSum, k))\\n                if ans==k: return ans\\n        return ans\\n    \\n    def maxSumRow(self, row, k):\\n        ans = float(\\'-inf\\')\\n        total = 0\\n        \\n        ss = SortedSet()\\n        ss.add(0)\\n        \\n        for n in row:\\n            total += n\\n            i = ss.bisect_left(total-k)\\n            if i<len(ss):\\n                x = ss[i]\\n                ans = max(ans, total-x)\\n            ss.add(total)\\n        return ans\\n            \\n    def rotate(self, matrix):\\n        M = len(matrix)\\n        N = len(matrix[0])\\n        matrixRotated = [[0]*M for _ in xrange(N)]\\n        \\n        for i in xrange(M):\\n            for j in xrange(N):\\n                matrixRotated[j][i] = matrix[i][j]\\n        return matrixRotated\\n            \\n\"\"\"\\nRelated Heap Problems:\\nContains Duplicate: I, II, III\\nMax Sum of Rectangle No Larger Than K\\nMaximum Sum Of Subarray Close To K\\nK Empty Slots\\n\\nFor more other topics similar problems, check out my GitHub.\\nIt took me a lots of time to make the solution. Becuase I want to help others like me.\\nPlease give me a star if you like it. Means a lot to me.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```",
                "solutionTags": [],
                "code": "```python\\n\"\"\"\\nTime: O(min(M,N)^2 * max(M,N) * Log(max(M,N)))\\nSpace: O(MN), can reduce to O(max(M,N)) by not using a new 2D array \"matrixRotated\".\\nJust change the iteration in `maxSumSubmatrix()`.\\n\\nThis is the implementation of the offical solution 1 and 2.\\n\"\"\"\\nfrom sortedcontainers import SortedSet\\n\\nclass Solution(object):\\n    def maxSumSubmatrix(self, matrix, k):\\n        if len(matrix)>len(matrix[0]): matrix = self.rotate(matrix)\\n        \\n        ans = float(\\'-inf\\')\\n        M = len(matrix)\\n        N = len(matrix[0])\\n        \\n        for start in xrange(M):\\n            rowSum = [0]*N #row sum of rows from matrix[start] to row\\n            for row in matrix[start:]:\\n                for i, n in enumerate(row): rowSum[i] += n\\n                ans = max(ans, self.maxSumRow(rowSum, k))\\n                if ans==k: return ans\\n        return ans\\n    \\n    def maxSumRow(self, row, k):\\n        ans = float(\\'-inf\\')\\n        total = 0\\n        \\n        ss = SortedSet()\\n        ss.add(0)\\n        \\n        for n in row:\\n            total += n\\n            i = ss.bisect_left(total-k)\\n            if i<len(ss):\\n                x = ss[i]\\n                ans = max(ans, total-x)\\n            ss.add(total)\\n        return ans\\n            \\n    def rotate(self, matrix):\\n        M = len(matrix)\\n        N = len(matrix[0])\\n        matrixRotated = [[0]*M for _ in xrange(N)]\\n        \\n        for i in xrange(M):\\n            for j in xrange(N):\\n                matrixRotated[j][i] = matrix[i][j]\\n        return matrixRotated\\n            \\n\"\"\"\\nRelated Heap Problems:\\nContains Duplicate: I, II, III\\nMax Sum of Rectangle No Larger Than K\\nMaximum Sum Of Subarray Close To K\\nK Empty Slots\\n\\nFor more other topics similar problems, check out my GitHub.\\nIt took me a lots of time to make the solution. Becuase I want to help others like me.\\nPlease give me a star if you like it. Means a lot to me.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314118,
                "title": "max-sum-of-rectangle-no-larger-than-k-solution-python",
                "content": "Please  Upvote if you like the solution. \\n``` \\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n\\n        # For corner cases\\n        if not matrix:\\n            return 0\\n        \\n        def max_sumk(l, k):\\n            sums = [0]\\n            presum, ans = 0, -sys.maxsize\\n            for item in l:\\n                presum += item\\n                \\n                left = bisect.bisect_left(sums, presum - k)\\n                if left < len(sums):\\n                    ans = max(ans, presum - sums[left])\\n                    \\n                bisect.insort(sums, presum)\\n            return ans\\n\\n        \\n        \\n        rows = len(matrix)\\n        cols = len(matrix[0])\\n        ans = -sys.maxsize\\n       \\n        # iterating through all  2D arrays possible for every column. \\n        for i in range(cols):\\n            Cvalues = [0 for _ in range(rows)]\\n            \\n            for j in range(i, cols):\\n                \\n                for row in range(rows):\\n                    Cvalues[row] = Cvalues[row] + matrix[row][j]\\n                \\n                curr_sum = max_sumk(Cvalues, k)\\n                ans = max(curr_sum, ans)\\n        \\n        return ans\\n        \\n```",
                "solutionTags": [],
                "code": "``` \\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n\\n        # For corner cases\\n        if not matrix:\\n            return 0\\n        \\n        def max_sumk(l, k):\\n            sums = [0]\\n            presum, ans = 0, -sys.maxsize\\n            for item in l:\\n                presum += item\\n                \\n                left = bisect.bisect_left(sums, presum - k)\\n                if left < len(sums):\\n                    ans = max(ans, presum - sums[left])\\n                    \\n                bisect.insort(sums, presum)\\n            return ans\\n\\n        \\n        \\n        rows = len(matrix)\\n        cols = len(matrix[0])\\n        ans = -sys.maxsize\\n       \\n        # iterating through all  2D arrays possible for every column. \\n        for i in range(cols):\\n            Cvalues = [0 for _ in range(rows)]\\n            \\n            for j in range(i, cols):\\n                \\n                for row in range(rows):\\n                    Cvalues[row] = Cvalues[row] + matrix[row][j]\\n                \\n                curr_sum = max_sumk(Cvalues, k)\\n                ans = max(curr_sum, ans)\\n        \\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1313678,
                "title": "numpy-approach-with-o-n-2-m-2-648ms-beats-95-24",
                "content": "```\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        import numpy as np\\n        \\n        matrix = np.array(matrix, dtype=np.int32)\\n        \\n        M,N = matrix.shape\\n        \\n        ret = float(\"-inf\")\\n        \\n        CUM = np.zeros((M,N), dtype=np.int32)\\n        for shift_r in range(M):\\n            CUM[:M-shift_r] += matrix[shift_r:]\\n            \\n            _CUM = np.zeros((M-shift_r,N), dtype=np.int32)\\n            for shift_c in range(N):\\n                _CUM[:, :N-shift_c] += CUM[:M-shift_r,shift_c:]\\n                tmp = _CUM[(_CUM<=k) & (_CUM>ret)]\\n                if tmp.size:\\n                    ret = tmp.max()\\n            if ret == k:\\n                return ret\\n        \\n        return ret\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        import numpy as np\\n        \\n        matrix = np.array(matrix, dtype=np.int32)\\n        \\n        M,N = matrix.shape\\n        \\n        ret = float(\"-inf\")\\n        \\n        CUM = np.zeros((M,N), dtype=np.int32)\\n        for shift_r in range(M):\\n            CUM[:M-shift_r] += matrix[shift_r:]\\n            \\n            _CUM = np.zeros((M-shift_r,N), dtype=np.int32)\\n            for shift_c in range(N):\\n                _CUM[:, :N-shift_c] += CUM[:M-shift_r,shift_c:]\\n                tmp = _CUM[(_CUM<=k) & (_CUM>ret)]\\n                if tmp.size:\\n                    ret = tmp.max()\\n            if ret == k:\\n                return ret\\n        \\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1313484,
                "title": "go-optimal-solution-o-n-2-m-log-m-100-time-260ms-100-space-7-2mb",
                "content": "```\\nfunc maxSumSubmatrix(matrix [][]int, k int) int {\\n    m, n := len(matrix), len(matrix[0])\\n    maxSum := math.MinInt32\\n\\n    for i:=0; i<m; i++ {\\n        for j:=1;j<n; j++{\\n            matrix[i][j] += matrix[i][j-1]\\n        }\\n    }\\n    for l:=0; l<n; l++ {\\n        for r:=l; r < n; r++ {\\n            prefixSum, set := 0, Set{0}\\n            for i:=0; i< m; i++ {\\n                sum := matrix[i][r]\\n                if l > 0 {\\n                    sum -= matrix[i][l-1]\\n                }\\n                prefixSum += sum\\n                idx := sort.SearchInts(set, prefixSum-k)\\n                if idx != len(set) {\\n                    maxSum = max(maxSum, prefixSum-set[idx])\\n                }\\n                set.Insert(prefixSum)\\n            }\\n        }\\n    }\\n    \\n    return maxSum\\n}\\n\\ntype Set []int\\n\\nfunc (s *Set) Insert(x int) {\\n\\ti := sort.SearchInts(*s, x)\\n\\tif i == len(*s) {\\n\\t\\t*s = append(*s, x)\\n\\t} else if (*s)[i] != x {\\n\\t\\t*s = append(*s, 0)\\n\\t\\tcopy((*s)[i+1:], (*s)[i:])\\n\\t\\t(*s)[i] = x\\n\\t}\\n}\\n\\nfunc max(a, b int) int {\\n    if a < b {\\n        return b\\n    }\\n    return a\\n}",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```\\nfunc maxSumSubmatrix(matrix [][]int, k int) int {\\n    m, n := len(matrix), len(matrix[0])\\n    maxSum := math.MinInt32\\n\\n    for i:=0; i<m; i++ {\\n        for j:=1;j<n; j++{\\n            matrix[i][j] += matrix[i][j-1]\\n        }\\n    }\\n    for l:=0; l<n; l++ {\\n        for r:=l; r < n; r++ {\\n            prefixSum, set := 0, Set{0}\\n            for i:=0; i< m; i++ {\\n                sum := matrix[i][r]\\n                if l > 0 {\\n                    sum -= matrix[i][l-1]\\n                }\\n                prefixSum += sum\\n                idx := sort.SearchInts(set, prefixSum-k)\\n                if idx != len(set) {\\n                    maxSum = max(maxSum, prefixSum-set[idx])\\n                }\\n                set.Insert(prefixSum)\\n            }\\n        }\\n    }\\n    \\n    return maxSum\\n}\\n\\ntype Set []int\\n\\nfunc (s *Set) Insert(x int) {\\n\\ti := sort.SearchInts(*s, x)\\n\\tif i == len(*s) {\\n\\t\\t*s = append(*s, x)\\n\\t} else if (*s)[i] != x {\\n\\t\\t*s = append(*s, 0)\\n\\t\\tcopy((*s)[i+1:], (*s)[i:])\\n\\t\\t(*s)[i] = x\\n\\t}\\n}\\n\\nfunc max(a, b int) int {\\n    if a < b {\\n        return b\\n    }\\n    return a\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1313021,
                "title": "python3-sortedlist-time-is-o-m-2-n-log-n-accepted",
                "content": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        M = len(matrix)\\n        N = len(matrix[0])\\n        CSr = [ None for _ in matrix]\\n        for i,row in enumerate(matrix):\\n            CSr[i] = list(accumulate(row, initial=0))\\n        \\n        best = float(\\'-inf\\')\\n        \\n        for r1 in range(M):\\n            Srow = [0]*(N+1)\\n            for r2 in range(r1+1,M+1):\\n                Srow = [a+b for a,b in zip(Srow,CSr[r2-1])]\\n                SL = SortedList(Srow)\\n                for c in range(N):\\n                    target = k + Srow[c]\\n                    SL.remove(Srow[c])\\n                    j = SL.bisect(target)-1\\n                    if j<0:\\n                        continue\\n                    best = max(best, SL[j]-Srow[c])\\n        \\n        return best\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        M = len(matrix)\\n        N = len(matrix[0])\\n        CSr = [ None for _ in matrix]\\n        for i,row in enumerate(matrix):\\n            CSr[i] = list(accumulate(row, initial=0))\\n        \\n        best = float(\\'-inf\\')\\n        \\n        for r1 in range(M):\\n            Srow = [0]*(N+1)\\n            for r2 in range(r1+1,M+1):\\n                Srow = [a+b for a,b in zip(Srow,CSr[r2-1])]\\n                SL = SortedList(Srow)\\n                for c in range(N):\\n                    target = k + Srow[c]\\n                    SL.remove(Srow[c])\\n                    j = SL.bisect(target)-1\\n                    if j<0:\\n                        continue\\n                    best = max(best, SL[j]-Srow[c])\\n        \\n        return best\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1312803,
                "title": "max-sum-of-rectangle-c-explained",
                "content": "At first glance, you may feel that it is very big, but believe me it is as simple as you read it.\\n**Part 1**\\nIdea is simple, suppose you are doing the same problem with 1D array then what should we do ?\\nFor 1D array just iterate the array and store the prefix sum in a set (for binary search), every time find the lower bound of the required value\\n(**as we stored prefix sum so for a sub array, form i to j, sum[i, j] = sum[j] - sum[i-1], let X = sum[j] - sum[i-1], then we find value of X such that runningSum - X <= k)**\\nWe can do this by lower_bound function in C++ and bisect_left in python;\\n\\n**Part 2**\\nNow think Matrix =>\\n1. iterate in every row ,from curr row to last row add numbers in every col store in a 1D array ( ofCourse size will be no. of columns)\\n2. Now apply the above algo in this 1D array and update the result\\n3. we will do this for every row as in step 1 and final result returned\\n\\nThis looks good but we can furthure optimize it =>\\ntime complexity of part 1 => O(nlog(n))\\ntime complexity of part 2 => O(m*m)\\n So we can take m as smaller dimension and n as bigger dimension \\n so if columns > row , then squeez rows\\n else squeez columns\\n \\n This will give => O(min(m,n)2*max(m,n)*log(max(m,n))\\n\\nsee comment for working example\\n```\\nstatic auto ______ = [](){\\n    std::ios_base::sync_with_stdio(0);\\n    cin.tie(0);\\n    return 0;\\n}();\\n\\nclass Solution {\\npublic:\\n    int m, n, K, result = INT_MIN;\\n    \\n\\t// you an skip this part\\n\\t// basically kadane\\'s algo is for fast look up max sum, so if we get the value less tha k, we don\\'t need to check part 1\\n    /* int kadaneAlgo(vector<int> nums){\\n        int maxSum=INT_MIN, currMaxSum = 0;\\n        for(int num : nums){\\n            currMaxSum = max(currMaxSum+num, num);\\n            maxSum = max(maxSum, currMaxSum);\\n        } \\n        return maxSum;\\n    }\\n    */\\n    void updateResult(vector<int> nums){\\n       //  int kadaneSum = kadaneAlgo(nums);\\n       // if(kadaneSum <= K) {\\n          //  result = max(result, kadaneSum);\\n           // return;\\n       // }\\n        int sum=0;\\n        set<int> s;\\n        s.insert(sum);\\n        for(int num : nums){\\n            sum+=num;\\n            auto tmp = s.lower_bound(sum-K);\\n            if(tmp != s.end()) result = max(result, sum- *tmp);\\n            s.insert(sum);\\n        }\\n    }\\n    \\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        K=k, m=matrix.size(), n=matrix[0].size();\\n        if(n > m){   // columns greater than rows \\n            vector<int> rowSum(n);   // sqeeze rows into a single array\\n            for(int i=0; i<m; i++){\\n                fill(rowSum.begin(), rowSum.end(), 0);\\n                for(int row=i; row<m; row++){    // convert from ith row till last row into a single 1D array\\n                    for(int col=0; col<n; col++){\\n                        rowSum[col] += matrix[row][col];\\n                    }\\n                    updateResult(rowSum);\\n                }\\n            }\\n            if(result == k)return result;\\n        }\\n        else{ // squeez columns into a single array\\n            vector<int> colSum(m);\\n            for(int i=0; i<n; i++){\\n                fill(colSum.begin(), colSum.end(), 0);\\n                for(int col=i; col<n; col++){\\n                    for(int row=0; row < m; row++)\\n                        colSum[row] += matrix[row][col];\\n                    updateResult(colSum);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n**if you find it helpful, plz upvote**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstatic auto ______ = [](){\\n    std::ios_base::sync_with_stdio(0);\\n    cin.tie(0);\\n    return 0;\\n}();\\n\\nclass Solution {\\npublic:\\n    int m, n, K, result = INT_MIN;\\n    \\n\\t// you an skip this part\\n\\t// basically kadane\\'s algo is for fast look up max sum, so if we get the value less tha k, we don\\'t need to check part 1\\n    /* int kadaneAlgo(vector<int> nums){\\n        int maxSum=INT_MIN, currMaxSum = 0;\\n        for(int num : nums){\\n            currMaxSum = max(currMaxSum+num, num);\\n            maxSum = max(maxSum, currMaxSum);\\n        } \\n        return maxSum;\\n    }\\n    */\\n    void updateResult(vector<int> nums){\\n       //  int kadaneSum = kadaneAlgo(nums);\\n       // if(kadaneSum <= K) {\\n          //  result = max(result, kadaneSum);\\n           // return;\\n       // }\\n        int sum=0;\\n        set<int> s;\\n        s.insert(sum);\\n        for(int num : nums){\\n            sum+=num;\\n            auto tmp = s.lower_bound(sum-K);\\n            if(tmp != s.end()) result = max(result, sum- *tmp);\\n            s.insert(sum);\\n        }\\n    }\\n    \\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        K=k, m=matrix.size(), n=matrix[0].size();\\n        if(n > m){   // columns greater than rows \\n            vector<int> rowSum(n);   // sqeeze rows into a single array\\n            for(int i=0; i<m; i++){\\n                fill(rowSum.begin(), rowSum.end(), 0);\\n                for(int row=i; row<m; row++){    // convert from ith row till last row into a single 1D array\\n                    for(int col=0; col<n; col++){\\n                        rowSum[col] += matrix[row][col];\\n                    }\\n                    updateResult(rowSum);\\n                }\\n            }\\n            if(result == k)return result;\\n        }\\n        else{ // squeez columns into a single array\\n            vector<int> colSum(m);\\n            for(int i=0; i<n; i++){\\n                fill(colSum.begin(), colSum.end(), 0);\\n                for(int col=i; col<n; col++){\\n                    for(int row=0; row < m; row++)\\n                        colSum[row] += matrix[row][col];\\n                    updateResult(colSum);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1143118,
                "title": "java-dynamic-programming-treeset-binary-search-beats-91-o-col-col-row-log-row",
                "content": "\\n    // O(col*col*row*log(row))\\n\\tpublic static int maxSumSubmatrix(int[][] matrix, int k) {\\n\\n\\t\\tint row = matrix.length, col = matrix[0].length, max = Integer.MIN_VALUE;\\n\\t\\tfor (int left = 0; left < col; left++) {\\n\\t\\t\\tint[] temp = new int[row];\\n\\t\\t\\tfor (int right = left; right < col; right++) {\\n\\t\\t\\t\\tfor (int i = 0; i < row; i++)\\n\\t\\t\\t\\t\\ttemp[i] += matrix[i][right];\\n\\t\\t\\t\\tint sum = maxSubArrayK(temp, k);\\n\\t\\t\\t\\tif (sum > max)\\n\\t\\t\\t\\t\\tmax = sum;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn max;\\n\\t}\\n\\n\\t// O(nlogn)\\n\\tpublic static int maxSubArrayK(int[] temp, int k) {\\n\\n\\t\\tint sum = kadanes(temp);\\n\\t\\tif (sum <= k)\\n\\t\\t\\treturn sum;\\n\\t\\tTreeSet<Integer> set = new TreeSet<>();\\n\\t\\tset.add(0);\\n\\t\\tint csum = 0, len = temp.length, max = Integer.MIN_VALUE;\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tcsum += temp[i];\\n\\t\\t\\tInteger set2 = set.ceiling(csum - k);\\n\\t\\t\\tif (set2 != null) {\\n\\t\\t\\t\\tif (csum - set2 > max)\\n\\t\\t\\t\\t\\tmax = csum - set2;\\n\\t\\t\\t}\\n\\t\\t\\tset.add(csum);\\n\\t\\t}\\n\\t\\treturn max;\\n\\t}\\n\\n\\t// Kadanes\\n\\t// O(n)\\n\\tpublic static int kadanes(int[] temp) {\\n\\t\\tint omax = temp[0], cmax = temp[0], len = temp.length;\\n\\t\\tfor (int i = 1; i < len; i++) {\\n\\t\\t\\tcmax += temp[i];\\n\\t\\t\\tif (temp[i] > cmax)\\n\\t\\t\\t\\tcmax = temp[i];\\n\\t\\t\\tif (cmax > omax)\\n\\t\\t\\t\\tomax = cmax;\\n\\t\\t}\\n\\t\\treturn omax;\\n\\t}\\n",
                "solutionTags": [],
                "code": "\\n    // O(col*col*row*log(row))\\n\\tpublic static int maxSumSubmatrix(int[][] matrix, int k) {\\n\\n\\t\\tint row = matrix.length, col = matrix[0].length, max = Integer.MIN_VALUE;\\n\\t\\tfor (int left = 0; left < col; left++) {\\n\\t\\t\\tint[] temp = new int[row];\\n\\t\\t\\tfor (int right = left; right < col; right++) {\\n\\t\\t\\t\\tfor (int i = 0; i < row; i++)\\n\\t\\t\\t\\t\\ttemp[i] += matrix[i][right];\\n\\t\\t\\t\\tint sum = maxSubArrayK(temp, k);\\n\\t\\t\\t\\tif (sum > max)\\n\\t\\t\\t\\t\\tmax = sum;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn max;\\n\\t}\\n\\n\\t// O(nlogn)\\n\\tpublic static int maxSubArrayK(int[] temp, int k) {\\n\\n\\t\\tint sum = kadanes(temp);\\n\\t\\tif (sum <= k)\\n\\t\\t\\treturn sum;\\n\\t\\tTreeSet<Integer> set = new TreeSet<>();\\n\\t\\tset.add(0);\\n\\t\\tint csum = 0, len = temp.length, max = Integer.MIN_VALUE;\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tcsum += temp[i];\\n\\t\\t\\tInteger set2 = set.ceiling(csum - k);\\n\\t\\t\\tif (set2 != null) {\\n\\t\\t\\t\\tif (csum - set2 > max)\\n\\t\\t\\t\\t\\tmax = csum - set2;\\n\\t\\t\\t}\\n\\t\\t\\tset.add(csum);\\n\\t\\t}\\n\\t\\treturn max;\\n\\t}\\n\\n\\t// Kadanes\\n\\t// O(n)\\n\\tpublic static int kadanes(int[] temp) {\\n\\t\\tint omax = temp[0], cmax = temp[0], len = temp.length;\\n\\t\\tfor (int i = 1; i < len; i++) {\\n\\t\\t\\tcmax += temp[i];\\n\\t\\t\\tif (temp[i] > cmax)\\n\\t\\t\\t\\tcmax = temp[i];\\n\\t\\t\\tif (cmax > omax)\\n\\t\\t\\t\\tomax = cmax;\\n\\t\\t}\\n\\t\\treturn omax;\\n\\t}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 579734,
                "title": "java-easy-clean-code",
                "content": "```\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] arr, int k) {\\n        int rows = arr.length;\\n        int cols = arr[0].length;\\n        int maxK = Integer.MIN_VALUE;\\n        for(int i = 0; i < cols; i++){\\n            int dp[] = new int[rows];\\n            for(int j = i; j < cols; j++){\\n                for(int l = 0; l < rows; l++){\\n                    dp[l] += arr[l][j];\\n                }\\n                int currSum = maxSubArray(dp, k);\\n                maxK = Math.max(maxK, currSum);                 \\n                if(maxK == k)\\n                    return k;\\n            }\\n        }\\n        return maxK;\\n    }\\n    public int maxSubArray(int[] arr, int k) {\\n        int max = Integer.MIN_VALUE;\\n        int currSum = 0;\\n        TreeSet<Integer> set = new TreeSet<>();\\n        set.add(0);\\n        for (int i = 0; i < arr.length; i++) {\\n            currSum += arr[i];\\n            Integer ceilValue = set.ceiling(currSum - k);\\n            if(ceilValue != null) {\\n                max = Math.max(max, currSum - ceilValue);\\n            }\\n            set.add(currSum);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] arr, int k) {\\n        int rows = arr.length;\\n        int cols = arr[0].length;\\n        int maxK = Integer.MIN_VALUE;\\n        for(int i = 0; i < cols; i++){\\n            int dp[] = new int[rows];\\n            for(int j = i; j < cols; j++){\\n                for(int l = 0; l < rows; l++){\\n                    dp[l] += arr[l][j];\\n                }\\n                int currSum = maxSubArray(dp, k);\\n                maxK = Math.max(maxK, currSum);                 \\n                if(maxK == k)\\n                    return k;\\n            }\\n        }\\n        return maxK;\\n    }\\n    public int maxSubArray(int[] arr, int k) {\\n        int max = Integer.MIN_VALUE;\\n        int currSum = 0;\\n        TreeSet<Integer> set = new TreeSet<>();\\n        set.add(0);\\n        for (int i = 0; i < arr.length; i++) {\\n            currSum += arr[i];\\n            Integer ceilValue = set.ceiling(currSum - k);\\n            if(ceilValue != null) {\\n                max = Math.max(max, currSum - ceilValue);\\n            }\\n            set.add(currSum);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 461411,
                "title": "easy-to-understand",
                "content": "Updated a little bit based on this solution: [JavaScript-Solution-Kadane\\'s\\n](https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/discuss/407822/JavaScript-Solution-Kadane\\'s)\\n\\n#### Idea:\\n1. Basically brute-force.\\n2. Iterate from every column to the last column,\\n3. Calculate running sum for each row,\\n4. Calculate rectangle sum for each possibility on the way\\n5. Update the target max.\\n\\n```javascript\\nconst maxSumSubmatrix = function(matrix, k) {\\n  let max = -Infinity;\\n  const R = matrix.length, C = matrix[0].length;\\n  const sums = Array(R);\\n  // Try starting from column 0 to the rightmost column\\n  for (let c1 = 0; c1 < C; c1 += 1) {\\n    // Because we start with a new column, we should clear sums\\n    sums.fill(0);\\n    // Scan through the rest of the columns\\n    for (let c2 = c1; c2 < C; c2 += 1) {\\n      // Update current sums for each row, sums[r] = sum(matrix[r][c1:c2]) \\n      for (let row = 0; row < R; row += 1) {\\n        sums[row] += matrix[row][c2];\\n      }\\n      // console.log(sums) to see values of sums\\n      for (let r1 = 0; r1 < R; r1 += 1) {\\n        let sum = 0;\\n        for (let r2 = r1; r2 < R; r2 += 1) {\\n          // Calculate sum for current rectangle: sum(matrix[r1:r2, c1:c2])\\n          sum += sums[r2];\\n          // Update target max sum\\n          if (sum > max && sum <= k) {\\n            max = sum;\\n          }\\n        }\\n      }\\n    }\\n  }\\n  return max;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nconst maxSumSubmatrix = function(matrix, k) {\\n  let max = -Infinity;\\n  const R = matrix.length, C = matrix[0].length;\\n  const sums = Array(R);\\n  // Try starting from column 0 to the rightmost column\\n  for (let c1 = 0; c1 < C; c1 += 1) {\\n    // Because we start with a new column, we should clear sums\\n    sums.fill(0);\\n    // Scan through the rest of the columns\\n    for (let c2 = c1; c2 < C; c2 += 1) {\\n      // Update current sums for each row, sums[r] = sum(matrix[r][c1:c2]) \\n      for (let row = 0; row < R; row += 1) {\\n        sums[row] += matrix[row][c2];\\n      }\\n      // console.log(sums) to see values of sums\\n      for (let r1 = 0; r1 < R; r1 += 1) {\\n        let sum = 0;\\n        for (let r2 = r1; r2 < R; r2 += 1) {\\n          // Calculate sum for current rectangle: sum(matrix[r1:r2, c1:c2])\\n          sum += sums[r2];\\n          // Update target max sum\\n          if (sum > max && sum <= k) {\\n            max = sum;\\n          }\\n        }\\n      }\\n    }\\n  }\\n  return max;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 453435,
                "title": "python-3-o-n-m-2-log-min-n-m-prefix-sum-with-dp-sliding-window-rb-tree",
                "content": "1. First just create a prefix sum of each row\\n2. Next we are going to do sliding window by starting off with rectangles of col length 1, then 2, then 3, then 4, and sliding those to every single possible spot. We just take each x1 and x2 and move them around all possible y spots.\\n3. This is probably the most difficult to understand part. There\\'s a special technique to drop the complexity from n^2 to nlogn. We can run an accumulator, and remember the past sums we found in a balanced tree, and every time we are on the next step, we can subtract from our current accumulated sum any old accumulated sum to get the true sum of a particular sub-rectangle. This lets us avoid manually checking each rectangle formed when sliding down the rows, and just let\\'s us do a linear sweep, and with each operation, doing a log(n) search to find the closest fitting element within our RB tree. Each time we find a possible solution, just check if the maximum is greater than the current.\\n\\nJust as a side note, Kadane\\'s algorithm fails in this problem because it only works without a given bound; this problem isn\\'t as deterministic, you need to actually take a look at what you got so far every time, rather than just the best previous.\\n\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        maxSum = -sys.maxsize\\n\\n        #prefix sum\\n        for i in range(m):\\n            for j in range(1,n):\\n                    matrix[i][j] += matrix[i][j-1]\\n        \\n        for x1 in range(n):\\n            for x2 in range(x1 , n):\\n                rectAcc = 0\\n                seen = SortedList()\\n                seen.add(0)\\n                for y in range(m):\\n                    rectAcc += matrix[y][x2] - (matrix[y][x1 - 1] if x1 > 0 else 0)\\n                    currTargetLoc = seen.bisect_left(rectAcc - k)\\n                    \\n                    if(currTargetLoc < len(seen)):\\n                        maxSum = max(maxSum, rectAcc - seen[currTargetLoc])\\n                        \\n                    seen.add(rectAcc)\\n                    \\n        return maxSum\\n```",
                "solutionTags": [],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        maxSum = -sys.maxsize\\n\\n        #prefix sum\\n        for i in range(m):\\n            for j in range(1,n):\\n                    matrix[i][j] += matrix[i][j-1]\\n        \\n        for x1 in range(n):\\n            for x2 in range(x1 , n):\\n                rectAcc = 0\\n                seen = SortedList()\\n                seen.add(0)\\n                for y in range(m):\\n                    rectAcc += matrix[y][x2] - (matrix[y][x1 - 1] if x1 > 0 else 0)\\n                    currTargetLoc = seen.bisect_left(rectAcc - k)\\n                    \\n                    if(currTargetLoc < len(seen)):\\n                        maxSum = max(maxSum, rectAcc - seen[currTargetLoc])\\n                        \\n                    seen.add(rectAcc)\\n                    \\n        return maxSum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 252043,
                "title": "javascript",
                "content": "Solution mirrors the exact steps in this video: https://www.youtube.com/watch?v=yCQN096CwWM\\n   ```\\n    function maxSumSubmatrix(matrix, k) {\\n        const row = matrix.length, col = matrix[0].length;\\n        let result = -Infinity;\\n        for (let i = 0; i < col; i++) {\\n            let rowSum = Array(row).fill(0);\\n            for (let j = i; j < col; j++) {\\n                let sum = 0, max = -Infinity;\\n                for (let r = 0; r < row; r++) {\\n                    rowSum[r] += matrix[r][j];\\n                    if (sum < 0) sum = 0;\\n                    sum += rowSum[r];\\n                    max = Math.max(max, sum)\\n                }\\n                if (max <= k) result = Math.max(result, max)\\n                else {\\n                    max = -Infinity;\\n                    for (let m = 0; m < row; m++) {\\n                        sum = 0;\\n                        for (let n = m; n < row; n++) {\\n                            sum += rowSum[n];\\n                            if (sum <= k) max = Math.max(max, sum)\\n                        }\\n                    }\\n                    result = Math.max(result, max)\\n                }\\n                if (result === k) return k;\\n            }\\n        }\\n        return result;\\n    }\\n\\t\\n```",
                "solutionTags": [],
                "code": "```\\n    function maxSumSubmatrix(matrix, k) {\\n        const row = matrix.length, col = matrix[0].length;\\n        let result = -Infinity;\\n        for (let i = 0; i < col; i++) {\\n            let rowSum = Array(row).fill(0);\\n            for (let j = i; j < col; j++) {\\n                let sum = 0, max = -Infinity;\\n                for (let r = 0; r < row; r++) {\\n                    rowSum[r] += matrix[r][j];\\n                    if (sum < 0) sum = 0;\\n                    sum += rowSum[r];\\n                    max = Math.max(max, sum)\\n                }\\n                if (max <= k) result = Math.max(result, max)\\n                else {\\n                    max = -Infinity;\\n                    for (let m = 0; m < row; m++) {\\n                        sum = 0;\\n                        for (let n = m; n < row; n++) {\\n                            sum += rowSum[n];\\n                            if (sum <= k) max = Math.max(max, sum)\\n                        }\\n                    }\\n                    result = Math.max(result, max)\\n                }\\n                if (result === k) return k;\\n            }\\n        }\\n        return result;\\n    }\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 83610,
                "title": "python-o-n-4-solution",
                "content": "Convert the problem to 1-D and them find max subarray no larger than K.\\n\\n    class Solution(object):\\n        def maxSumSubmatrix(self, matrix, k):\\n            maxSum = -9999999\\n            horizontalSum = [[0 for j in xrange(0, len(matrix[0]) + 1)] for i in xrange(0, len(matrix))]\\n            for i in xrange(0, len(matrix)):\\n                for j in xrange(0, len(matrix[0])):\\n                    horizontalSum[i][j] = horizontalSum[i][j - 1] + matrix[i][j]\\n            for cola in xrange(0, len(matrix[0])):\\n                for colb in xrange(cola, len(matrix[0])):\\n                    bilist, vsum = [0], 0\\n                    for i in xrange(0, len(matrix)):\\n                        vsumj = horizontalSum[i][colb] - horizontalSum[i][cola - 1]\\n                        vsum += vsumj\\n                        i = bisect.bisect_left(bilist, vsum - k)\\n                        if i < len(bilist):\\n                            maxSum = max(maxSum, vsum - bilist[i])\\n                        bisect.insort(bilist, vsum)\\n            return maxSum",
                "solutionTags": [],
                "code": "Convert the problem to 1-D and them find max subarray no larger than K.\\n\\n    class Solution(object):\\n        def maxSumSubmatrix(self, matrix, k):\\n            maxSum = -9999999\\n            horizontalSum = [[0 for j in xrange(0, len(matrix[0]) + 1)] for i in xrange(0, len(matrix))]\\n            for i in xrange(0, len(matrix)):\\n                for j in xrange(0, len(matrix[0])):\\n                    horizontalSum[i][j] = horizontalSum[i][j - 1] + matrix[i][j]\\n            for cola in xrange(0, len(matrix[0])):\\n                for colb in xrange(cola, len(matrix[0])):\\n                    bilist, vsum = [0], 0\\n                    for i in xrange(0, len(matrix)):\\n                        vsumj = horizontalSum[i][colb] - horizontalSum[i][cola - 1]\\n                        vsum += vsumj\\n                        i = bisect.bisect_left(bilist, vsum - k)\\n                        if i < len(bilist):\\n                            maxSum = max(maxSum, vsum - bilist[i])\\n                        bisect.insort(bilist, vsum)\\n            return maxSum",
                "codeTag": "Java"
            },
            {
                "id": 83636,
                "title": "java-244ms-applying",
                "content": "Refer to [This solution][1]\\n\\n\\n    public class Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        //Assuming that rows is larger than the number of cols\\n\\n        int row=matrix.length, col=matrix[0].length;\\n        int minDf=Integer.MAX_VALUE;\\n        for(int left=0;left<col;left++){\\n            int[] tmp=new int[row];\\n            for(int right=left;right<col;right++){\\n                TreeSet<Integer> set=new TreeSet<>();\\n                int cursum=0;\\n                for(int i=0;i<row;i++){\\n                    tmp[i]+=matrix[i][right];\\n                    cursum+=tmp[i];\\n                    if(cursum==k) return k;\\n                    if(cursum<k) minDf=Math.min(minDf,k-cursum);\\n                    Integer x=set.ceiling(cursum-k);\\n                    if(x!=null && cursum-x<=k) minDf=Math.min(minDf,k-cursum+x);\\n                    if(minDf==0) return k;\\n                    set.add(cursum);\\n                }\\n            }\\n        }\\n        return k-minDf;\\n    }\\n}\\n\\n\\n  [1]: https://leetcode.com/discuss/109749/accepted-c-codes-with-explanation-and-references",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        //Assuming that rows is larger than the number of cols\\n\\n        int row=matrix.length, col=matrix[0].length;\\n        int minDf=Integer.MAX_VALUE;\\n        for(int left=0;left<col;left++){\\n            int[] tmp=new int[row];\\n            for(int right=left;right<col;right++){\\n                TreeSet<Integer> set=new TreeSet<>();\\n                int cursum=0;\\n                for(int i=0;i<row;i++){\\n                    tmp[i]+=matrix[i][right];\\n                    cursum+=tmp[i];\\n                    if(cursum==k) return k;\\n                    if(cursum<k) minDf=Math.min(minDf,k-cursum);\\n                    Integer x=set.ceiling(cursum-k);\\n                    if(x!=null && cursum-x<=k) minDf=Math.min(minDf,k-cursum+x);\\n                    if(minDf==0) return k;\\n                    set.add(cursum);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3250225,
                "title": "363-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Firstly, iterate over all the columns starting from 0 to n. For each iteration, the sum of the values in the current column and all the previous columns will be stored in the list temp.\\n2. Using the Kadane\\'s algorithm, find the maximum sum of a subarray with a sum less than or equal to k in the list temp.\\n3. Update the maximum sum of a subarray found so far.\\n4. Return the maximum sum of a subarray found so far.\\n\\n\\nThe problem asks us to find the maximum sum of a subrectangle in a given matrix matrix such that the sum is no larger than a given integer k.\\n\\nThe solution uses a nested loop to iterate over all the possible subrectangles in the matrix. The outer loop iterates over the left column index left, and the inner loop iterates over the right column index right that is to the right of left. This ensures that we are considering all possible subrectangles that start from column left and end at column right.\\n\\nFor each subrectangle, the solution calculates the sum of each row in the subrectangle by iterating over the rows of the matrix. The row sums are stored in the list temp.\\n\\nThe problem now reduces to finding the maximum sum of a subarray in temp such that the sum is no larger than k. The solution uses Kadane\\'s algorithm to solve this subproblem. Kadane\\'s algorithm is a dynamic programming algorithm that can be used to find the maximum subarray sum in a given array.\\n\\nThe solution maintains a list cum_sum_set that stores the cumulative sum of the elements in temp. For each cumulative sum cum_sum, the solution finds the largest cumulative sum cum_sum_prev in cum_sum_set such that cum_sum - cum_sum_prev is no larger than k. This is done using the bisect_left function from the bisect module.\\n\\nIf such a cum_sum_prev is found, the solution updates the maximum sum found so far as cum_sum - cum_sum_prev.\\n\\nFinally, the solution returns the maximum sum found over all subrectangles.\\n# Complexity\\n- Time complexity:\\n75.76%\\n\\n- Space complexity:\\n67.10%\\n\\n# Code\\n```\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        \\n        # Getting the dimensions of the matrix\\n        m, n = len(matrix), len(matrix[0])\\n        \\n        # Initializing the maximum sum\\n        max_sum = -float(\\'inf\\')\\n        \\n        # Iterating over all the columns\\n        for left in range(n):\\n            \\n            # Initializing the temporary sum list\\n            temp = [0] * m\\n            \\n            # Iterating over all the columns to the right of left\\n            for right in range(left, n):\\n                \\n                # Adding the values of the current column to temp\\n                for i in range(m):\\n                    temp[i] += matrix[i][right]\\n                \\n                # Kadane\\'s algorithm to find the maximum sum of a subarray with sum less than or equal to k\\n                cum_sum = 0\\n                cum_sum_set = sorted([0])\\n                \\n                for t in temp:\\n                    cum_sum += t\\n                    it = bisect_left(cum_sum_set, cum_sum - k)\\n                    if it != len(cum_sum_set):\\n                        max_sum = max(max_sum, cum_sum - cum_sum_set[it])\\n                    bisect.insort(cum_sum_set, cum_sum)\\n        \\n        # Returning the maximum sum found\\n        return max_sum\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Binary Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        \\n        # Getting the dimensions of the matrix\\n        m, n = len(matrix), len(matrix[0])\\n        \\n        # Initializing the maximum sum\\n        max_sum = -float(\\'inf\\')\\n        \\n        # Iterating over all the columns\\n        for left in range(n):\\n            \\n            # Initializing the temporary sum list\\n            temp = [0] * m\\n            \\n            # Iterating over all the columns to the right of left\\n            for right in range(left, n):\\n                \\n                # Adding the values of the current column to temp\\n                for i in range(m):\\n                    temp[i] += matrix[i][right]\\n                \\n                # Kadane\\'s algorithm to find the maximum sum of a subarray with sum less than or equal to k\\n                cum_sum = 0\\n                cum_sum_set = sorted([0])\\n                \\n                for t in temp:\\n                    cum_sum += t\\n                    it = bisect_left(cum_sum_set, cum_sum - k)\\n                    if it != len(cum_sum_set):\\n                        max_sum = max(max_sum, cum_sum - cum_sum_set[it])\\n                    bisect.insort(cum_sum_set, cum_sum)\\n        \\n        # Returning the maximum sum found\\n        return max_sum\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2497906,
                "title": "python-prefix-sum-w-sorted-list-commented-and-explained",
                "content": "**Intuition**\\n\\nThis question is 2 Hard problems disguised as one:\\n\\n*Problem 1 - Sum of rectangle that satisfies some condition*\\n\\n- Brute-force way of solving this requires enumerating all possible rectangles in `O(m^2 * n^2)`\\n- But while brute-forcing, we will notice that we redo a lot of calculations when building up rectangles (afterall... many sub-rectangles have overlaps with each other).\\n- We can improve our brute-force by using prefix-sums. For a single column, we will create a prefix-sum for each cell. Then we add up all values for the next column, and the next... This prefix-sum array represents a 2D rectangle collapsing into a 1D array. From the 1D array, we can determine which sub-array (and therefore rectangle) satisfies our condition.\\n- Now we just need to figure out what we do with this 1D array, and can we do better than `O(n^2)`?\\n\\n*Problem 2 - Max Sum of sub-array less than k*\\n\\n- It is tempting to just throw Kadane\\'s algorithm. Which would be correct if we simply needed a max sum. However, we need max sum *less than k*, which implies we need some sorting.\\n- One observation/trick we have to realize is that we need to keep track of prefix-sums here as well! And we need to quick way of *extracting* a subarray from the array.\\n- If we keep a `running sum`, and a list of `prefix_sums` we have seen so far, we can extract out a subarray by simply subtracting any `prefix_sum` from `running sum`. This is the main motivation behind keeping a sorted list. It drops the runtime from `O(n^2)` to `O(n*log(n))`\\n- Next is deciding which `prefix_sum` we need from our list. We look at the formula `running_sum - k`. So we apply `bisect_left` to get index of the largest element that satisfies <= `running_sum - k`\\n\\nCombining the two problems above will give us the solution to tackle our main problem. To improve our performance, we make sure # of cols is always less than # of rows. Otherwise, we transpose our matrix.\\n\\n**Solution**\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        res = -math.inf\\n        \\n        m, n = len(matrix), len(matrix[0])\\n\\n        # ensure that cols < rows, otherwise transpose the matrix\\n        if m < n:\\n            matrix = list(zip(*matrix))\\n            m, n = n, m\\n        \\n        # for each column\\n        for col in range(n):\\n            \\n            prefix_sums = [0] * m\\n\\n            for j in range(col, n):\\n                # add current column into the prefix sum array\\n                for i in range(m):\\n                    prefix_sums[i] += matrix[i][j]\\n                \\n                res = max(res, self.maxSumSubarray(prefix_sums, k))\\n                if res == k:\\n                    return res\\n        \\n        return res\\n        \\n        \\n    def maxSumSubarray(self, nums: List[int], k: int) -> int:\\n        # create a sorted list of all prefix sums.\\n        # this allows us to look up desired prefixes\\n        # in O(log(n)) instead of O(n)\\n        prefix = SortedList([0])\\n                \\n        res = -math.inf\\n        \\n        # we keep a running sum of every element we\\'ve seen.\\n        # this allows us to extract a sub-array by simply\\n        # subtracting a previously recorded prefix from the running sum\\n        #\\n        #         [A,   B,     C,       D]\\n        # prefix  [A, A+B, A+B+C, A+B+C+D]\\n        #\\n        # If we want [C,D] and our running sum is (A+B+C+D)\\n        # Then we should subtract (A+B) from running sum to get (C+D).\\n        curr_sum = 0\\n        \\n        for num in nums:\\n            curr_sum += num\\n            \\n            # find the largest prefix that satisfies (curr_sum - k)\\n            i = prefix.bisect_left(curr_sum - k)\\n            if i < len(prefix):\\n                res = max(res, curr_sum - prefix[i])\\n                \\n            # add curr_sum to prefix_sum\\n            prefix.add(curr_sum)\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        res = -math.inf\\n        \\n        m, n = len(matrix), len(matrix[0])\\n\\n        # ensure that cols < rows, otherwise transpose the matrix\\n        if m < n:\\n            matrix = list(zip(*matrix))\\n            m, n = n, m\\n        \\n        # for each column\\n        for col in range(n):\\n            \\n            prefix_sums = [0] * m\\n\\n            for j in range(col, n):\\n                # add current column into the prefix sum array\\n                for i in range(m):\\n                    prefix_sums[i] += matrix[i][j]\\n                \\n                res = max(res, self.maxSumSubarray(prefix_sums, k))\\n                if res == k:\\n                    return res\\n        \\n        return res\\n        \\n        \\n    def maxSumSubarray(self, nums: List[int], k: int) -> int:\\n        # create a sorted list of all prefix sums.\\n        # this allows us to look up desired prefixes\\n        # in O(log(n)) instead of O(n)\\n        prefix = SortedList([0])\\n                \\n        res = -math.inf\\n        \\n        # we keep a running sum of every element we\\'ve seen.\\n        # this allows us to extract a sub-array by simply\\n        # subtracting a previously recorded prefix from the running sum\\n        #\\n        #         [A,   B,     C,       D]\\n        # prefix  [A, A+B, A+B+C, A+B+C+D]\\n        #\\n        # If we want [C,D] and our running sum is (A+B+C+D)\\n        # Then we should subtract (A+B) from running sum to get (C+D).\\n        curr_sum = 0\\n        \\n        for num in nums:\\n            curr_sum += num\\n            \\n            # find the largest prefix that satisfies (curr_sum - k)\\n            i = prefix.bisect_left(curr_sum - k)\\n            if i < len(prefix):\\n                res = max(res, curr_sum - prefix[i])\\n                \\n            # add curr_sum to prefix_sum\\n            prefix.add(curr_sum)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2490852,
                "title": "c-83-48-faster-medium",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        uint8_t m = matrix.size();\\n        uint8_t n = matrix[0].size();\\n        \\n        int psa[m][n];\\n        psa[0][0] = matrix[0][0];\\n        \\n        for(uint8_t i = 1; i < m; i++)\\n            psa[i][0] = psa[i-1][0] + matrix[i][0];\\n        for(uint8_t i = 1; i < n; i++)\\n            psa[0][i] = psa[0][i-1] + matrix[0][i];\\n        for (uint8_t i = 1; i < m; i++)\\n            for (uint8_t j = 1; j < n; j++)\\n                psa[i][j] = psa[i - 1][j] + psa[i][j - 1] - psa[i - 1][j - 1] + matrix[i][j];\\n        \\n        int maxSum = INT_MIN;\\n        for(uint8_t i = 0; i < m; i++)\\n            for(uint8_t j = 0; j < n; j++)\\n                for(uint8_t p = i; p < m; p++)\\n                    for(uint8_t q = j; q < n; q++)\\n                    {\\n                        int x = psa[p][q] + \\n                            (i > 0 ? -psa[i-1][q] : 0) +\\n                            (j > 0 ? -psa[p][j-1] : 0) +\\n                            (i > 0 && j > 0 ? psa[i-1][j-1] : 0);\\n                        if(x <= k)\\n                            maxSum = max(maxSum, x);\\n                    }\\n        \\n        return maxSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        uint8_t m = matrix.size();\\n        uint8_t n = matrix[0].size();\\n        \\n        int psa[m][n];\\n        psa[0][0] = matrix[0][0];\\n        \\n        for(uint8_t i = 1; i < m; i++)\\n            psa[i][0] = psa[i-1][0] + matrix[i][0];\\n        for(uint8_t i = 1; i < n; i++)\\n            psa[0][i] = psa[0][i-1] + matrix[0][i];\\n        for (uint8_t i = 1; i < m; i++)\\n            for (uint8_t j = 1; j < n; j++)\\n                psa[i][j] = psa[i - 1][j] + psa[i][j - 1] - psa[i - 1][j - 1] + matrix[i][j];\\n        \\n        int maxSum = INT_MIN;\\n        for(uint8_t i = 0; i < m; i++)\\n            for(uint8_t j = 0; j < n; j++)\\n                for(uint8_t p = i; p < m; p++)\\n                    for(uint8_t q = j; q < n; q++)\\n                    {\\n                        int x = psa[p][q] + \\n                            (i > 0 ? -psa[i-1][q] : 0) +\\n                            (j > 0 ? -psa[p][j-1] : 0) +\\n                            (i > 0 && j > 0 ? psa[i-1][j-1] : 0);\\n                        if(x <= k)\\n                            maxSum = max(maxSum, x);\\n                    }\\n        \\n        return maxSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2490775,
                "title": "c-computing-back-sum-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int maxSum = INT_MIN;\\n        \\n        for(int l = 0; l < n; l++) {\\n            vector<int> sumArr(m, 0);\\n            for(int r = l; r < n; r++) {\\n                for(int i = 0; i < m; i++) sumArr[i] += matrix[i][r];\\n                for(int i = 0; i < m; i++) {\\n                    int sum = 0;\\n                    for(int j = i; j < m; j++) {\\n                        sum += sumArr[j];\\n                        if(sum > maxSum && sum <= k) maxSum = sum;\\n                    }\\n                }\\n            }\\n        }\\n        return maxSum;\\n    }\\n};\\n```\\n**PLEASE UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Memoization",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int maxSum = INT_MIN;\\n        \\n        for(int l = 0; l < n; l++) {\\n            vector<int> sumArr(m, 0);\\n            for(int r = l; r < n; r++) {\\n                for(int i = 0; i < m; i++) sumArr[i] += matrix[i][r];\\n                for(int i = 0; i < m; i++) {\\n                    int sum = 0;\\n                    for(int j = i; j < m; j++) {\\n                        sum += sumArr[j];\\n                        if(sum > maxSum && sum <= k) maxSum = sum;\\n                    }\\n                }\\n            }\\n        }\\n        return maxSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2490503,
                "title": "c-prefix-sum-easy-solution",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>> &matrix, int tar)\\n    {\\n        int m = matrix.size(), n = matrix[0].size();\\n        int ans = INT_MIN;\\n        vector<vector<int>> dp(m + 1, vector<int>(n, 0));\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                dp[i + 1][j] = dp[i][j] + matrix[i][j];\\n            }\\n        }\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int l = i + 1; l <= m; l++)\\n            {\\n                for (int j = 0; j < n; j++)\\n                {\\n                    int val = 0;\\n                    for (int k = j; k < n; k++)\\n                    {\\n                        val += dp[l][k] - dp[i][k];\\n\\n                        if (val < tar)\\n                        {\\n                            ans = max(ans, val);\\n                        }\\n                        else if (val == tar)\\n                        {\\n                            return tar;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>> &matrix, int tar)\\n    {\\n        int m = matrix.size(), n = matrix[0].size();\\n        int ans = INT_MIN;\\n        vector<vector<int>> dp(m + 1, vector<int>(n, 0));\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                dp[i + 1][j] = dp[i][j] + matrix[i][j];\\n            }\\n        }\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int l = i + 1; l <= m; l++)\\n            {\\n                for (int j = 0; j < n; j++)\\n                {\\n                    int val = 0;\\n                    for (int k = j; k < n; k++)\\n                    {\\n                        val += dp[l][k] - dp[i][k];\\n\\n                        if (val < tar)\\n                        {\\n                            ans = max(ans, val);\\n                        }\\n                        else if (val == tar)\\n                        {\\n                            return tar;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2490332,
                "title": "c-code-for-beginners-easy-code",
                "content": "You can precompute a 2D prefix array, and then use a 2D sliding window to get the largest rectangle with sum<=k\\n\\nBut, I am using the other approach using the binary search and Kadanes\\n```\\nclass Solution {\\npublic:\\n    int BinarySearch(vector<int> &arr, int k){\\n        int res=INT_MIN;\\n        int sum=0;\\n        set<int> s;\\n        s.insert(0);\\n        for(int i=0;i<arr.size();i++){\\n            sum+=arr[i];\\n            auto it=s.lower_bound(sum-k);\\n//the reason why we take lower bound is--> let\\'s say, at any general index idx, the prefix sum is cur. We take lower bound of (cur- k). This will give me a value greater than or equal to (cur-k) , lets say we got cur-k + lambda, where lambda>=0. So the sum of the segment that we get is cur - (cur - k + lambda) = k-lambda. So we can clearly see, we got a value less than or equal to k, as lambda>=0.\\n            if(it!=s.end()){\\n                res=max(res,sum-*it);\\n            }\\n            if(res==k){\\n                return k;\\n            }\\n            s.insert(sum);\\n        }  \\n        return res;\\n    }\\n    \\n    int KadaneAlgo(vector<int> &arr, int k){\\n        int sum=0;\\n        int maxSum=INT_MIN;\\n        for(int i=0;i<arr.size();i++){\\n            sum+=arr[i];\\n            maxSum=max(maxSum,sum);\\n            if(sum<0){\\n                sum=0;\\n            }\\n        }\\n        maxSum=max(maxSum,*max_element(arr.begin(),arr.end()));\\n        return maxSum;\\n    }\\n    \\n    int maxSumSubmatrix(vector<vector<int>>& M, int k) {\\n        int res=INT_MIN;\\n        int R=M.size();       \\n        int C=M[0].size();\\n        for(int i=0;i<C;i++){\\n            vector<int> arr(R,0);\\n            for(int j=i;j<C;j++){\\n                for(int k=0;k<R;k++){\\n                    arr[k]+=M[k][j];\\n                }\\n                int tempSum=KadaneAlgo(arr,k);\\n                if(tempSum==k){\\n                    return k;\\n                }\\n                else if(tempSum<k){\\n                    res=max(res,tempSum);\\n                }\\n                else{\\n                    tempSum=BinarySearch(arr,k);\\n                    res=max(res,tempSum);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int BinarySearch(vector<int> &arr, int k){\\n        int res=INT_MIN;\\n        int sum=0;\\n        set<int> s;\\n        s.insert(0);\\n        for(int i=0;i<arr.size();i++){\\n            sum+=arr[i];\\n            auto it=s.lower_bound(sum-k);\\n//the reason why we take lower bound is--> let\\'s say, at any general index idx, the prefix sum is cur. We take lower bound of (cur- k). This will give me a value greater than or equal to (cur-k) , lets say we got cur-k + lambda, where lambda>=0. So the sum of the segment that we get is cur - (cur - k + lambda) = k-lambda. So we can clearly see, we got a value less than or equal to k, as lambda>=0.\\n            if(it!=s.end()){\\n                res=max(res,sum-*it);\\n            }\\n            if(res==k){\\n                return k;\\n            }\\n            s.insert(sum);\\n        }  \\n        return res;\\n    }\\n    \\n    int KadaneAlgo(vector<int> &arr, int k){\\n        int sum=0;\\n        int maxSum=INT_MIN;\\n        for(int i=0;i<arr.size();i++){\\n            sum+=arr[i];\\n            maxSum=max(maxSum,sum);\\n            if(sum<0){\\n                sum=0;\\n            }\\n        }\\n        maxSum=max(maxSum,*max_element(arr.begin(),arr.end()));\\n        return maxSum;\\n    }\\n    \\n    int maxSumSubmatrix(vector<vector<int>>& M, int k) {\\n        int res=INT_MIN;\\n        int R=M.size();       \\n        int C=M[0].size();\\n        for(int i=0;i<C;i++){\\n            vector<int> arr(R,0);\\n            for(int j=i;j<C;j++){\\n                for(int k=0;k<R;k++){\\n                    arr[k]+=M[k][j];\\n                }\\n                int tempSum=KadaneAlgo(arr,k);\\n                if(tempSum==k){\\n                    return k;\\n                }\\n                else if(tempSum<k){\\n                    res=max(res,tempSum);\\n                }\\n                else{\\n                    tempSum=BinarySearch(arr,k);\\n                    res=max(res,tempSum);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2489199,
                "title": "c-prefix-sum-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int tar) {\\n        int m=matrix.size(),n=matrix[0].size();\\n        vector<vector<int>>dp(m+1,vector<int>(n,0));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                dp[i+1][j]=dp[i][j]+matrix[i][j];\\n            }\\n        }\\n        int ans=INT_MIN;\\n        for(int i=0;i<m;i++){\\n            for(int l=i+1;l<=m;l++){\\n                for(int j=0;j<n;j++){\\n                    int val=0;\\n                    for(int k=j;k<n;k++){\\n                        val+=dp[l][k]-dp[i][k];\\n                        \\n                        if(val<tar){\\n                            ans=max(ans,val);\\n                        }\\n                        else if(val==tar){\\n                            return tar;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int tar) {\\n        int m=matrix.size(),n=matrix[0].size();\\n        vector<vector<int>>dp(m+1,vector<int>(n,0));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                dp[i+1][j]=dp[i][j]+matrix[i][j];\\n            }\\n        }\\n        int ans=INT_MIN;\\n        for(int i=0;i<m;i++){\\n            for(int l=i+1;l<=m;l++){\\n                for(int j=0;j<n;j++){\\n                    int val=0;\\n                    for(int k=j;k<n;k++){\\n                        val+=dp[l][k]-dp[i][k];\\n                        \\n                        if(val<tar){\\n                            ans=max(ans,val);\\n                        }\\n                        else if(val==tar){\\n                            return tar;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2488864,
                "title": "c-easy-solution-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int res = INT_MIN;\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n        \\n        for(int l = 0;l < cols;++l){\\n            vector<int> sums(rows);\\n            for(int r = l;r < cols;++r){\\n                for(int i=0;i<rows;++i){\\n                    sums[i] += matrix[i][r];\\n                }\\n                set<int> s = {0};\\n                int run_sum = 0;\\n                for(int sum : sums){\\n                    run_sum += sum;\\n                    auto it = s.lower_bound(run_sum - k);\\n                    if(it != end(s)){\\n                        res = max(res,run_sum - *it);\\n                    }\\n                    s.insert(run_sum);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int res = INT_MIN;\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n        \\n        for(int l = 0;l < cols;++l){\\n            vector<int> sums(rows);\\n            for(int r = l;r < cols;++r){\\n                for(int i=0;i<rows;++i){\\n                    sums[i] += matrix[i][r];\\n                }\\n                set<int> s = {0};\\n                int run_sum = 0;\\n                for(int sum : sums){\\n                    run_sum += sum;\\n                    auto it = s.lower_bound(run_sum - k);\\n                    if(it != end(s)){\\n                        res = max(res,run_sum - *it);\\n                    }\\n                    s.insert(run_sum);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2488861,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        \\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        int[] sum = new int[n];\\n        int maxSum = Integer.MIN_VALUE;\\n        \\n        for(int i = 0; i<m; i++){\\n            Arrays.fill(sum,0);\\n            \\n            for(int j = i; j<m; j++){\\n                \\n                for(int r = 0; r<n; r++){\\n                    sum[r] += matrix[r][j];\\n                }\\n                \\n                int currMax = findMaxSubarraySum(sum,k);\\n                maxSum = Math.max(currMax, maxSum);\\n            }\\n        }\\n        \\n        return maxSum;\\n    }\\n    \\n    \\n    public int findMaxSubarraySum(int a[], int k) {\\n        \\n        int max = Integer.MIN_VALUE;\\n        \\n        for (int i = 0; i < a.length; i++) {\\n            int tsum = 0;\\n            for (int j = i; j < a.length; j++) {\\n                tsum += a[j];\\n                if (tsum <= k)\\n                    max = Math.max(max, tsum);\\n            }\\n        }\\n        return max;\\n    }\\n\\n}\\n\\n\\n\\n//     public static int kadane(int[] arr, int k){\\n//         int n = arr.length;\\n//         int max = Integer.MIN_VALUE;\\n//         int sum = 0;\\n//         for(int i = 0; i<n; i++){\\n//             sum = sum+arr[i];\\n            \\n//             if(sum<0){\\n//                 sum = 0;\\n//             }\\n//             if(sum>max){\\n//                 max = sum;\\n//             }\\n//         }\\n//         return max;\\n//     }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        \\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        int[] sum = new int[n];\\n        int maxSum = Integer.MIN_VALUE;\\n        \\n        for(int i = 0; i<m; i++){\\n            Arrays.fill(sum,0);\\n            \\n            for(int j = i; j<m; j++){\\n                \\n                for(int r = 0; r<n; r++){\\n                    sum[r] += matrix[r][j];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2488688,
                "title": "c-rust-2d-prefix-sum-100-faster",
                "content": "![image](https://assets.leetcode.com/users/images/8ad79f0a-27ea-42b0-a2b6-27e731a047d7_1661577986.1099648.png)\\n# Rust Code\\n\\n\\timpl Solution {\\n\\t\\tpub fn max_sum_submatrix(matrix: Vec<Vec<i32>>, k: i32) -> i32 {\\n\\t\\t\\tlet m: usize = matrix.len();        \\n\\t\\t\\tlet n: usize = matrix[0].len();\\n\\t\\t\\tlet mut pre_sum = vec![vec![0;n+1];m+1];\\n\\t\\t\\tfor i in 1..=m {\\n\\t\\t\\t\\tfor j in 1..=n {\\n\\t\\t\\t\\t\\tpre_sum[i][j]=-pre_sum[i-1][j-1]+pre_sum[i-1][j]+pre_sum[i][j-1]+matrix[i-1][j-1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// println!(\"{:?}\", pre_sum);\\n\\n\\t\\t\\tlet mut ans: i32 = -12222;\\n\\t\\t\\tfor sr in 1..=m {\\n\\t\\t\\t\\tfor sc in 1..=n {\\n\\t\\t\\t\\t\\tfor er in sr..=m {\\n\\t\\t\\t\\t\\t\\tfor ec in sc..=n {\\n\\t\\t\\t\\t\\t\\t\\tlet area = pre_sum[er][ec]-pre_sum[er][sc-1]-pre_sum[sr-1][ec]+pre_sum[sr-1][sc-1];\\n\\t\\t\\t\\t\\t\\t\\tif area <= k {ans = ans.max(area);}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tans\\n\\t\\t}\\n\\t}\\n\\n# C# Code\\n\\tpublic class Solution {\\n\\t\\tpublic int MaxSumSubmatrix(int[][] matrix, int k) {\\n\\t\\t\\tvar m = matrix.Length;        \\n\\t\\t\\tvar n = matrix[0].Length;\\n\\t\\t\\tvar preSum = new int[m+1, n+1];\\n\\n\\t\\t\\tfor(int i=1; i<=m; ++i)\\n\\t\\t\\t\\tfor(int j=1; j<=n; ++j)\\n\\t\\t\\t\\t\\tpreSum[i, j] += preSum[i-1, j] + preSum[i, j-1] - preSum[i-1, j-1] + matrix[i-1][j-1];\\n\\n\\t\\t\\tvar ans = -111111;\\n\\n\\t\\t\\tfor(int sr=1; sr<=m; ++sr)\\n\\t\\t\\t\\tfor(int sc=1; sc<=n; ++sc)\\n\\t\\t\\t\\t\\tfor(int er=sr; er<=m; ++er)\\n\\t\\t\\t\\t\\t\\tfor(int ec=sc; ec<=n; ++ec){\\n\\t\\t\\t\\t\\t\\t\\tvar area = preSum[er, ec] - preSum[sr-1, ec] - preSum[er, sc-1] + preSum[sr-1, sc-1];\\n\\t\\t\\t\\t\\t\\t\\tif(area <= k)\\n\\t\\t\\t\\t\\t\\t\\t\\tans = Math.Max(ans, area);\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Rust"
                ],
                "code": "class Solution {\\n\\t\\tpublic int MaxSumSubmatrix(int[][] matrix, int k) {\\n\\t\\t\\tvar m = matrix.Length;        \\n\\t\\t\\tvar n = matrix[0].Length;\\n\\t\\t\\tvar preSum = new int[m+1, n+1];\\n\\n\\t\\t\\tfor(int i=1; i<=m; ++i)\\n\\t\\t\\t\\tfor(int j=1; j<=n; ++j)\\n\\t\\t\\t\\t\\tpreSum[i, j] += preSum[i-1, j] + preSum[i, j-1] - preSum[i-1, j-1] + matrix[i-1][j-1];\\n\\n\\t\\t\\tvar ans = -111111;\\n\\n\\t\\t\\tfor(int sr=1; sr<=m; ++sr)\\n\\t\\t\\t\\tfor(int sc=1; sc<=n; ++sc)\\n\\t\\t\\t\\t\\tfor(int er=sr; er<=m; ++er)\\n\\t\\t\\t\\t\\t\\tfor(int ec=sc; ec<=n; ++ec){\\n\\t\\t\\t\\t\\t\\t\\tvar area = preSum[er, ec] - preSum[sr-1, ec] - preSum[er, sc-1] + preSum[sr-1, sc-1];\\n\\t\\t\\t\\t\\t\\t\\tif(area <= k)\\n\\t\\t\\t\\t\\t\\t\\t\\tans = Math.Max(ans, area);\\n\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2488290,
                "title": "java-solution-using-prefix-sum-binary-search-o-nlogn-time-complexity",
                "content": "# Java\\n```\\npublic class Solution {\\n  //Time: O(r2 * clogc)\\n  // SC : O(c)\\n  public int maxSumSubmatrix(int[][] matrix, int k) {\\n    int row = matrix.length;\\n    int col = matrix[0].length;\\n    int max = Integer.MIN_VALUE;\\n    for (int i = 0; i < row; i ++) {\\n      int[] colSum = new int[col];\\n      for (int j = i; j < row; j ++) {\\n        for (int c = 0; c < col; c ++) {\\n          colSum[c] += matrix[j][c];\\n          //System.out.print(colSum[c] + \" \");\\n        }\\n        //System.out.println();\\n        max = Math.max(max, find(colSum, k));\\n      }\\n    }\\n    return max;\\n  }\\n\\n  private int find(int[] sum, int k) {\\n    int result = Integer.MIN_VALUE;\\n    TreeSet<Integer> set = new TreeSet<>();\\n    set.add(0);\\n    int prefixSum = 0;\\n    for(int i = 0; i < sum.length; i++) {\\n      prefixSum += sum[i];\\n\\n      Integer target = set.ceiling(prefixSum - k);\\n\\n      if(target != null) {\\n        result = Math.max(result, prefixSum - target);\\n      }\\n      set.add(prefixSum);\\n    }\\n\\n    return result;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\npublic class Solution {\\n  //Time: O(r2 * clogc)\\n  // SC : O(c)\\n  public int maxSumSubmatrix(int[][] matrix, int k) {\\n    int row = matrix.length;\\n    int col = matrix[0].length;\\n    int max = Integer.MIN_VALUE;\\n    for (int i = 0; i < row; i ++) {\\n      int[] colSum = new int[col];\\n      for (int j = i; j < row; j ++) {\\n        for (int c = 0; c < col; c ++) {\\n          colSum[c] += matrix[j][c];\\n          //System.out.print(colSum[c] + \" \");\\n        }\\n        //System.out.println();\\n        max = Math.max(max, find(colSum, k));\\n      }\\n    }\\n    return max;\\n  }\\n\\n  private int find(int[] sum, int k) {\\n    int result = Integer.MIN_VALUE;\\n    TreeSet<Integer> set = new TreeSet<>();\\n    set.add(0);\\n    int prefixSum = 0;\\n    for(int i = 0; i < sum.length; i++) {\\n      prefixSum += sum[i];\\n\\n      Integer target = set.ceiling(prefixSum - k);\\n\\n      if(target != null) {\\n        result = Math.max(result, prefixSum - target);\\n      }\\n      set.add(prefixSum);\\n    }\\n\\n    return result;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2485717,
                "title": "simple-java-solution-with-explanation-prefix-sum-with-brute-force-check",
                "content": "### Explanation:\\nAssume the following input:\\n```\\nMatrix:\\nthe input matrix\\n1    0    1\\n0  -2    3\\n2    2  -1\\n\\nk = 3\\n```\\n\\nGrid Sum: any index (i,j) below, is the sum of all numbers in the grid between (0,0) -> (i,j), padded with 0s on left and top for ease of computation\\n```\\n0\\t0\\t0\\t0\\t\\n0\\t1\\t1\\t2\\t\\n0\\t1\\t-1\\t3\\t\\n0\\t3\\t3\\t6\\t\\n```\\n\\nNested loop to check grid sum between two points (i,j) and (a,b):\\n- Just like in a 1D array where we need 2 nested loops to compare any combination of index i and index j in the loop where 0 <= i <= j < n\\n- Here, since it\\'s a 2D array, we will need 4 nested loops:\\n  -  The first 2 respresenting the row,col for the start of the grid (i,j)\\n  -  The last 2 representing the row,col for the end of the grid (a,b)\\n- Now, we can use the grid sum/ prefix sum to compute the sum of any rectangle formed between (i,j) and (a,b)\\n- How to calculate grid sum?\\n```\\nLet\\'s break down this statement:\\nint curr_sum = sum[a+1][b+1] - sum[i][b+1] - sum[a+1][j] + sum[i][j];\\n\\nLet\\'s say you want the sum of this grid:\\n- - - - - - - - -\\n- - - - - - - - -\\n- - - - - - - - -\\n- - - ? ? ? ? - -\\n- - - ? ? ? ? - -\\n- - - ? ? ? ? - -\\n- - - - - - - - -\\n\\nStep 1: Forget about the elements to it\\'s right and bottom, hence you can focus on below grid and we know the sum from (0,0) till [?] -> sum[a+1][b+1]\\n- - - - - - - \\n- - - - - - - \\n- - - - - - - \\n- - - ? ? ? ?\\n- - - ? ? ? ?\\n- - - ? ? ? [?]\\n\\nStep 2: You need to eliminate the indices marked by \\'-\\' above, eliminate the top area (grid sum at [*]) -> sum[i][b+1]\\n* * * * * * *\\n* * * * * * * \\n* * * * * * [*] \\n- - - ? ? ? ?\\n- - - ? ? ? ?\\n- - - ? ? ? ?\\n\\nStep 3: You need to eliminate the indices marked by \\'-\\' above, eliminate the left area (grid sum at [*]) -> sum[a+1][j] \\n* * * - - - - \\n* * * - - - - \\n* * * - - - - \\n* * * ? ? ? ?\\n* * * ? ? ? ?\\n* * [*] ? ? ? ?\\n\\nStep 4: The area marked by \\'*\\' below was eliminated twice, hence add the grid sum at [*] -> sum[i][j]\\n* * * - - - - \\n* * * - - - - \\n* * [*] - - - - \\n- - - ? ? ? ?\\n- - - ? ? ? ?\\n- - - ? ? ? ?\\n```\\n\\n### Dry Run:\\n```\\nGrid Sum between (i,j) and (a,b):\\n0,0 -> 0,0 : 1\\n0,0 -> 0,1 : 1\\n0,0 -> 0,2 : 2\\n0,0 -> 1,0 : 1\\n0,0 -> 1,1 : -1\\n...\\n0,1 -> 2,2 : 3\\n0,2 -> 0,2 : 1\\n0,2 -> 1,2 : 4\\n0,2 -> 2,2 : 3\\n...\\n1,2 -> 2,2 : 2\\n2,0 -> 2,0 : 2\\n2,0 -> 2,1 : 4\\n2,0 -> 2,2 : 3\\n...\\n```\\n\\n### Why this works:\\n- The max grid size for this question is 100 x 100 (n = 100)\\n- The solution below runs in O(n4) ~ 10^8 operations < 10^9 operations, hence within runtime limits \\n\\n### Solution:\\n```\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        // find prefix sum of grid\\n        int[][] sum = new int[matrix.length + 1][matrix[0].length + 1];\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[0].length; j++) {\\n                sum[i+1][j+1] = sum[i+1][j] + sum[i][j+1] - sum[i][j] + matrix[i][j];\\n            }\\n        }\\n        int ans = Integer.MIN_VALUE;\\n        // brute force check sum of grid between (i,j) and (a,b)\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[0].length; j++) {\\n                for (int a = i; a < matrix.length; a++) {\\n                    for (int b = j; b < matrix[0].length; b++) {\\n                        int curr_sum = sum[a+1][b+1] - sum[i][b+1] - sum[a+1][j] + sum[i][j];\\n                        if (curr_sum <= k && curr_sum > ans) {\\n                            ans = curr_sum;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nMatrix:\\nthe input matrix\\n1    0    1\\n0  -2    3\\n2    2  -1\\n\\nk = 3\\n```\n```\\n0\\t0\\t0\\t0\\t\\n0\\t1\\t1\\t2\\t\\n0\\t1\\t-1\\t3\\t\\n0\\t3\\t3\\t6\\t\\n```\n```\\nLet\\'s break down this statement:\\nint curr_sum = sum[a+1][b+1] - sum[i][b+1] - sum[a+1][j] + sum[i][j];\\n\\nLet\\'s say you want the sum of this grid:\\n- - - - - - - - -\\n- - - - - - - - -\\n- - - - - - - - -\\n- - - ? ? ? ? - -\\n- - - ? ? ? ? - -\\n- - - ? ? ? ? - -\\n- - - - - - - - -\\n\\nStep 1: Forget about the elements to it\\'s right and bottom, hence you can focus on below grid and we know the sum from (0,0) till [?] -> sum[a+1][b+1]\\n- - - - - - - \\n- - - - - - - \\n- - - - - - - \\n- - - ? ? ? ?\\n- - - ? ? ? ?\\n- - - ? ? ? [?]\\n\\nStep 2: You need to eliminate the indices marked by \\'-\\' above, eliminate the top area (grid sum at [*]) -> sum[i][b+1]\\n* * * * * * *\\n* * * * * * * \\n* * * * * * [*] \\n- - - ? ? ? ?\\n- - - ? ? ? ?\\n- - - ? ? ? ?\\n\\nStep 3: You need to eliminate the indices marked by \\'-\\' above, eliminate the left area (grid sum at [*]) -> sum[a+1][j] \\n* * * - - - - \\n* * * - - - - \\n* * * - - - - \\n* * * ? ? ? ?\\n* * * ? ? ? ?\\n* * [*] ? ? ? ?\\n\\nStep 4: The area marked by \\'*\\' below was eliminated twice, hence add the grid sum at [*] -> sum[i][j]\\n* * * - - - - \\n* * * - - - - \\n* * [*] - - - - \\n- - - ? ? ? ?\\n- - - ? ? ? ?\\n- - - ? ? ? ?\\n```\n```\\nGrid Sum between (i,j) and (a,b):\\n0,0 -> 0,0 : 1\\n0,0 -> 0,1 : 1\\n0,0 -> 0,2 : 2\\n0,0 -> 1,0 : 1\\n0,0 -> 1,1 : -1\\n...\\n0,1 -> 2,2 : 3\\n0,2 -> 0,2 : 1\\n0,2 -> 1,2 : 4\\n0,2 -> 2,2 : 3\\n...\\n1,2 -> 2,2 : 2\\n2,0 -> 2,0 : 2\\n2,0 -> 2,1 : 4\\n2,0 -> 2,2 : 3\\n...\\n```\n```\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        // find prefix sum of grid\\n        int[][] sum = new int[matrix.length + 1][matrix[0].length + 1];\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[0].length; j++) {\\n                sum[i+1][j+1] = sum[i+1][j] + sum[i][j+1] - sum[i][j] + matrix[i][j];\\n            }\\n        }\\n        int ans = Integer.MIN_VALUE;\\n        // brute force check sum of grid between (i,j) and (a,b)\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[0].length; j++) {\\n                for (int a = i; a < matrix.length; a++) {\\n                    for (int b = j; b < matrix[0].length; b++) {\\n                        int curr_sum = sum[a+1][b+1] - sum[i][b+1] - sum[a+1][j] + sum[i][j];\\n                        if (curr_sum <= k && curr_sum > ans) {\\n                            ans = curr_sum;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2485706,
                "title": "c-clean-code-similar-to-2d-kadane-approach",
                "content": "**Code** : \\n```\\nclass Solution {\\npublic:\\n    \\n    int sumNoLargerThanK_1D_array(vector<int> &v,int k){\\n        set<int> prefSet;\\n        prefSet.insert(0);\\n        int curSum = 0, curMax = INT_MIN;\\n        for (int sum : v) {\\n            curSum += sum;\\n            auto it = prefSet.lower_bound(curSum - k);\\n            if (it != prefSet.end()) curMax = max(curMax, curSum - *it);\\n            prefSet.insert(curSum);\\n        }\\n        return curMax;\\n    }\\n    \\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        if (matrix.empty()) return 0;\\n        int m = matrix.size(), n = matrix[0].size(), res = -1e8;\\n        for (int l = 0; l < n; ++l) {\\n            vector<int> v(m, 0);\\n            for (int r = l; r < n; ++r) {\\n                for (int i = 0; i < m; ++i) {\\n                    v[i] += matrix[i][r];\\n                }\\n                res=max(res,sumNoLargerThanK_1D_array(v,k));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nTime Complexity : **O[min(m,n)^2 * max(m,n) * log(max(m,n))]**\\nSpace Complexity :  **O(max(m, n))**\\n\\nHope this helps :)",
                "solutionTags": [
                    "C",
                    "Matrix",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int sumNoLargerThanK_1D_array(vector<int> &v,int k){\\n        set<int> prefSet;\\n        prefSet.insert(0);\\n        int curSum = 0, curMax = INT_MIN;\\n        for (int sum : v) {\\n            curSum += sum;\\n            auto it = prefSet.lower_bound(curSum - k);\\n            if (it != prefSet.end()) curMax = max(curMax, curSum - *it);\\n            prefSet.insert(curSum);\\n        }\\n        return curMax;\\n    }\\n    \\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        if (matrix.empty()) return 0;\\n        int m = matrix.size(), n = matrix[0].size(), res = -1e8;\\n        for (int l = 0; l < n; ++l) {\\n            vector<int> v(m, 0);\\n            for (int r = l; r < n; ++r) {\\n                for (int i = 0; i < m; ++i) {\\n                    v[i] += matrix[i][r];\\n                }\\n                res=max(res,sumNoLargerThanK_1D_array(v,k));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2485659,
                "title": "100-fastest-98-less-space-easy-to-understand-c",
                "content": "![image](https://assets.leetcode.com/users/images/e77d693f-89b5-4f62-a77f-a601dac0f1cb_1661561205.8769515.png)\\n\\n\\nclass Solution {\\npublic:\\n\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int ans = INT_MIN;\\n        \\n        int R = matrix.size();\\n        int C = matrix[0].size();\\n        int arr[R];\\n        \\n        for(int l = 0; l < C; ++l) {\\n            memset(arr, 0, sizeof(arr));\\n            \\n            for(int r = l; r < C; ++r) \\n            {\\n                for(int up = 0; up < R; ++up)\\n                {\\n                    arr[up] += matrix[up][r]; \\n                }\\n                int sum = 0, g = INT_MIN;\\n                for(int up = 0; up < R; ++up) \\n                {\\n                    sum = max(sum + arr[up], arr[up]);\\n                    g = max(g, sum);\\n                    if(g == k) \\n                        return k;\\n                }\\n                if(g < k) \\n                {\\n                    ans = max(ans, g);\\n                } \\n                else \\n                {\\n                    for(int up1 = 0; up1 < R; ++up1) \\n                    {\\n                        sum = 0;\\n                        for(int up2 = up1; up2 < R; ++up2) \\n                        {\\n                            sum += arr[up2];\\n                            if(sum <= k) \\n                                ans = max(ans, sum);\\n                        }\\n                        \\n                        if(ans == k) return k;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int ans = INT_MIN;\\n        \\n        int R = matrix.size();\\n        int C = matrix[0].size();\\n        int arr[R];\\n        \\n        for(int l = 0; l < C; ++l) {\\n            memset(arr, 0, sizeof(arr));\\n            \\n            for(int r = l; r < C; ++r) \\n            {\\n                for(int up = 0; up < R; ++up)\\n                {\\n                    arr[up] += matrix[up][r]; \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2485637,
                "title": "c-90-faster-small-solution",
                "content": "```\\nint maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n    const int m = matrix.size();\\n    const int n = matrix[0].size();\\n    int ans = INT_MIN;\\n\\n    for (int baseCol = 0; baseCol < n; ++baseCol) {\\n      // sums[i] := sum(matrix[i][baseCol..j])\\n      vector<int> sums(m, 0);\\n      for (int j = baseCol; j < n; ++j) {\\n        for (int i = 0; i < m; ++i)\\n          sums[i] += matrix[i][j];\\n        // find the max subarray no more than k\\n        set<int> accumulate{0};\\n        int prefix = 0;\\n        for (const int sum : sums) {\\n          prefix += sum;\\n          const auto it = accumulate.lower_bound(prefix - k);\\n          if (it != cend(accumulate))\\n            ans = max(ans, prefix - *it);\\n          accumulate.insert(prefix);\\n        }\\n      }\\n    }\\n\\n    return ans;\\n  }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n    const int m = matrix.size();\\n    const int n = matrix[0].size();\\n    int ans = INT_MIN;\\n\\n    for (int baseCol = 0; baseCol < n; ++baseCol) {\\n      // sums[i] := sum(matrix[i][baseCol..j])\\n      vector<int> sums(m, 0);\\n      for (int j = baseCol; j < n; ++j) {\\n        for (int i = 0; i < m; ++i)\\n          sums[i] += matrix[i][j];\\n        // find the max subarray no more than k\\n        set<int> accumulate{0};\\n        int prefix = 0;\\n        for (const int sum : sums) {\\n          prefix += sum;\\n          const auto it = accumulate.lower_bound(prefix - k);\\n          if (it != cend(accumulate))\\n            ans = max(ans, prefix - *it);\\n          accumulate.insert(prefix);\\n        }\\n      }\\n    }\\n\\n    return ans;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2485605,
                "title": "daily-leetcoding-challenge-august-day-27",
                "content": "This problem is the Daily LeetCoding Challenge for August, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Prefix Sum on 1D Array using Sorted Container\n\n  \n**Approach 2:** Follow-up - Larger Number of Rows than Columns\n\n  \n**Approach 3:** Combining it with Kadane's Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2459775,
                "title": "c-solution-time-o-n-3-logn-memory-o-m-n-easy-to-understand-subarray-sum-less-than-k",
                "content": "```\\nclass Solution {\\npublic:\\n    //2D into 1D compression than binary search\\n    int SubarrSumlessthanK(vector<int>&arr,int k){\\n        int n=arr.size();\\n        int ans=-1e9;\\n        set<int>st;\\n        st.insert(0);\\n        int csum=0;\\n        for(auto x:arr){\\n            csum+=x;\\n            auto it=st.lower_bound(csum-k);\\n            if(it!=st.end()){\\n                ans=max(ans,csum-*it);\\n            }\\n            st.insert(csum);\\n        }\\n        return ans;\\n    }\\n    int maxSumSubmatrix(vector<vector<int>>& mat, int k) {\\n        //Binary search ;\\n        //Hmare Saath Shri Ragunath To Kis Baat Ki Chinta -> \"Jai Shri Ram\"\\n        int ans=-int(1e9);\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        for(int c1=0;c1<n;c1++){\\n            vector<int>arr(m,0);\\n            for(int c2=c1;c2<n;c2++){\\n                for(int r=0;r<m;r++){\\n                    arr[r]+=mat[r][c2];\\n                }\\n                ans=max(ans,SubarrSumlessthanK(arr,k));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //2D into 1D compression than binary search\\n    int SubarrSumlessthanK(vector<int>&arr,int k){\\n        int n=arr.size();\\n        int ans=-1e9;\\n        set<int>st;\\n        st.insert(0);\\n        int csum=0;\\n        for(auto x:arr){\\n            csum+=x;\\n            auto it=st.lower_bound(csum-k);\\n            if(it!=st.end()){\\n                ans=max(ans,csum-*it);\\n            }\\n            st.insert(csum);\\n        }\\n        return ans;\\n    }\\n    int maxSumSubmatrix(vector<vector<int>>& mat, int k) {\\n        //Binary search ;\\n        //Hmare Saath Shri Ragunath To Kis Baat Ki Chinta -> \"Jai Shri Ram\"\\n        int ans=-int(1e9);\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        for(int c1=0;c1<n;c1++){\\n            vector<int>arr(m,0);\\n            for(int c2=c1;c2<n;c2++){\\n                for(int r=0;r<m;r++){\\n                    arr[r]+=mat[r][c2];\\n                }\\n                ans=max(ans,SubarrSumlessthanK(arr,k));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2368438,
                "title": "faster-than-98-18-pyrhon-numpy",
                "content": "![image](https://assets.leetcode.com/users/images/6f27779a-667c-443f-9c77-01e2aabafe8f_1659428934.3194134.png)\\n```\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        import numpy as np\\n        \\n        matrix = np.array(matrix, dtype=np.int32)\\n        \\n        M,N = matrix.shape\\n        \\n        ret = float(\"-inf\")\\n        \\n        CUM = np.zeros((M,N), dtype=np.int32)\\n        for shift_r in range(M):\\n            CUM[:M-shift_r] += matrix[shift_r:]\\n            \\n            _CUM = np.zeros((M-shift_r,N), dtype=np.int32)\\n            for shift_c in range(N):\\n                _CUM[:, :N-shift_c] += CUM[:M-shift_r,shift_c:]\\n                tmp = _CUM[(_CUM<=k) & (_CUM>ret)]\\n                if tmp.size:\\n                    ret = tmp.max()\\n            if ret == k:\\n                return ret\\n        \\n        return ret\\n\\n\\'\\'\\'\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/6f27779a-667c-443f-9c77-01e2aabafe8f_1659428934.3194134.png)\\n```\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        import numpy as np\\n        \\n        matrix = np.array(matrix, dtype=np.int32)\\n        \\n        M,N = matrix.shape\\n        \\n        ret = float(\"-inf\")\\n        \\n        CUM = np.zeros((M,N), dtype=np.int32)\\n        for shift_r in range(M):\\n            CUM[:M-shift_r] += matrix[shift_r:]\\n            \\n            _CUM = np.zeros((M-shift_r,N), dtype=np.int32)\\n            for shift_c in range(N):\\n                _CUM[:, :N-shift_c] += CUM[:M-shift_r,shift_c:]\\n                tmp = _CUM[(_CUM<=k) & (_CUM>ret)]\\n                if tmp.size:\\n                    ret = tmp.max()\\n            if ret == k:\\n                return ret\\n        \\n        return ret\\n\\n\\'\\'\\'\\n",
                "codeTag": "Java"
            },
            {
                "id": 1959343,
                "title": "java-beats-100-00-memory-speed-0ms-april-2022",
                "content": "\\n    class Solution {\\n\\n    private int maxSumSubarray(int[] A) {\\n        int min = 0, res = Integer.MIN_VALUE;\\n        for(int sum: A) {\\n            res = Math.max(res, sum - min);\\n            min = Math.min(min, sum);\\n        }\\n        return res;\\n    }\\n    private int maxSumSubarray(int[] A, int k) {\\n        int res = maxSumSubarray(A);\\n        if(res <= k) return res;\\n        res = Integer.MIN_VALUE;\\n        TreeSet<Integer> set = new TreeSet<>();\\n        set.add(0);\\n        for(int sum: A) {\\n            Integer old = set.ceiling(sum - k);\\n            if(old != null) {\\n                if(sum - old > res) {\\n                    res = sum - old;\\n                    if(res == k) return res;\\n                }\\n            }\\n            set.add(sum);\\n        }\\n        return res;\\n    }\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int m = matrix.length, n = m == 0 ? 0 : matrix[0].length, res = Integer.MIN_VALUE;\\n        boolean groupingRows = true;\\n        if(m > n) {\\n            int temp = m; m = n; n = temp;\\n            groupingRows = false;\\n        }\\n        int[] sum = new int[n];\\n        for(int i = 0; i < m; i++) {\\n            Arrays.fill(sum, 0);\\n            for(int j = i; j < m; j++) {\\n                int pre = 0;\\n                if(groupingRows) {\\n                    for(int t = 0; t < n; t++) sum[t] += pre += matrix[j][t];\\n                } else {\\n                    for(int t = 0; t < n; t++) sum[t] += pre += matrix[t][j];\\n                }\\n                res = Math.max(res, maxSumSubarray(sum, k));\\n                if(res == k) return res;\\n            }\\n        }\\n        return res;\\n    }\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    private int maxSumSubarray(int[] A) {\\n        int min = 0, res = Integer.MIN_VALUE;\\n        for(int sum: A) {\\n            res = Math.max(res, sum - min);\\n            min = Math.min(min, sum);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1778025,
                "title": "java-binarysearch",
                "content": "**Intuition**\\n\\n    1. Explore all possible rectangle\\n    2. Consider matrix with only one col. We get row*row no of rectangles. We have\\n\\t\\tto choose max sum(rectangle) where sum(rectangle) <= k\\n    3. We can make use of prefix array where prefix[i] is sum of val in row i.\\n    4. Make use of TreeSet && prefix sum to find all rectangles with sum less \\n\\t\\tthan k.\\n    5. Extend the above method to two dimensions\\n\\n```\\npublic int maxSumSubmatrix(int[][] matrix, int k) {\\n        \\n        int rows = matrix.length;\\n        int cols = matrix[0].length;\\n        \\n        int ans = Integer.MIN_VALUE;\\n        \\n        // l - left end of rectangle\\n        // r - right end of rectangle\\n        // loop for width expansion\\n        for(int l = 0; l < cols; l++){\\n            int[] prefix = new int[rows];\\n            for(int r = l; r < cols; r++){\\n                // step 3\\n                for(int row = 0; row < rows; row++){\\n                    prefix[row] += matrix[row][r];\\n                }\\n                //System.out.println(l+\" \"+r+\" \"+Arrays.toString(prefix));\\n                // step 4\\n                //cummulative[j] - cummulative[i] <=k  -> cummulative[j] - k <= cummulative[i];\\n                //we use ceil function to find cummulative sum which is store in our treeset\\n                int cj = 0;\\n                TreeSet<Integer> cummulative = new TreeSet<>();\\n                cummulative.add(0);\\n                for(int i = 0; i < rows; i++){\\n                    cj += prefix[i];\\n                    Integer ci = cummulative.ceiling(cj - k);\\n                    // ci found, sum between i & j is cj - ci;    \\n                    if(ci!=null){\\n                        ans = Math.max(ans, cj-ci);\\n                    }\\n                    cummulative.add(cj);\\n                }\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int maxSumSubmatrix(int[][] matrix, int k) {\\n        \\n        int rows = matrix.length;\\n        int cols = matrix[0].length;\\n        \\n        int ans = Integer.MIN_VALUE;\\n        \\n        // l - left end of rectangle\\n        // r - right end of rectangle\\n        // loop for width expansion\\n        for(int l = 0; l < cols; l++){\\n            int[] prefix = new int[rows];\\n            for(int r = l; r < cols; r++){\\n                // step 3\\n                for(int row = 0; row < rows; row++){\\n                    prefix[row] += matrix[row][r];\\n                }\\n                //System.out.println(l+\" \"+r+\" \"+Arrays.toString(prefix));\\n                // step 4\\n                //cummulative[j] - cummulative[i] <=k  -> cummulative[j] - k <= cummulative[i];\\n                //we use ceil function to find cummulative sum which is store in our treeset\\n                int cj = 0;\\n                TreeSet<Integer> cummulative = new TreeSet<>();\\n                cummulative.add(0);\\n                for(int i = 0; i < rows; i++){\\n                    cj += prefix[i];\\n                    Integer ci = cummulative.ceiling(cj - k);\\n                    // ci found, sum between i & j is cj - ci;    \\n                    if(ci!=null){\\n                        ans = Math.max(ans, cj-ci);\\n                    }\\n                    cummulative.add(cj);\\n                }\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1621975,
                "title": "python-sortedset-similar-to-java-official-solution",
                "content": "The answer in another discussion page made by otoc is still faster, however here\\'s an answer that matches the Java solution format wise.\\n\\n```\\nimport sortedcontainers\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        def updateResult(nums, k):\\n            nonlocal result\\n            \\n            summ = 0\\n            sortedSum = sortedcontainers.SortedSet()\\n            sortedSum.add(0)\\n            \\n            for num in nums:\\n                summ += num\\n                x = sortedSum.bisect_left(summ - k)\\n                if x < len(sortedSum):\\n                    result = max(result, summ - sortedSum[x])\\n                    \\n                sortedSum.add(summ)\\n                    \\n        result = -math.inf\\n                    \\n        for i in range(len(matrix)):\\n            rowSum = [0] * len(matrix[0])\\n            \\n            for row in range(i, len(matrix)):\\n                for col in range(len(matrix[row])):\\n                    rowSum[col] += matrix[row][col]\\n                    \\n                updateResult(rowSum, k)\\n                \\n                if result == k:\\n                    return result\\n                \\n        return result if result != -math.inf else -1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport sortedcontainers\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        def updateResult(nums, k):\\n            nonlocal result\\n            \\n            summ = 0\\n            sortedSum = sortedcontainers.SortedSet()\\n            sortedSum.add(0)\\n            \\n            for num in nums:\\n                summ += num\\n                x = sortedSum.bisect_left(summ - k)\\n                if x < len(sortedSum):\\n                    result = max(result, summ - sortedSum[x])\\n                    \\n                sortedSum.add(summ)\\n                    \\n        result = -math.inf\\n                    \\n        for i in range(len(matrix)):\\n            rowSum = [0] * len(matrix[0])\\n            \\n            for row in range(i, len(matrix)):\\n                for col in range(len(matrix[row])):\\n                    rowSum[col] += matrix[row][col]\\n                    \\n                updateResult(rowSum, k)\\n                \\n                if result == k:\\n                    return result\\n                \\n        return result if result != -math.inf else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1430051,
                "title": "c-implementation",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int solve(vector<int>&v,int k){\\n        int maxi = INT_MIN;\\n       for(int i=0;i<v.size();i++){\\n           int sum = 0;\\n           for(int j = i;j<v.size();j++){\\n               sum+=v[j];\\n               if(sum<=k && sum>maxi) maxi = sum;\\n           }\\n       }\\n        return maxi;\\n    }\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int _k) {\\n      \\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        int ans = INT_MIN;\\n        for(int i=0;i<row;i++){\\n            vector<int>v(col);\\n            for(int j=i;j<row;j++){\\n                for(int k=0;k<col;k++){\\n                    v[k] = v[k] + matrix[j][k];\\n                }\\n                 ans = max(ans,solve(v,_k));   \\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int solve(vector<int>&v,int k){\\n        int maxi = INT_MIN;\\n       for(int i=0;i<v.size();i++){\\n           int sum = 0;\\n           for(int j = i;j<v.size();j++){\\n               sum+=v[j];\\n               if(sum<=k && sum>maxi) maxi = sum;\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 1313898,
                "title": "c-using-concept-of-2-d-kadane-s-algorithm",
                "content": "You should first understand 2-D kadane\\'s and then come here.\\nAfter that, this question will be child\\'s play.\\n2-D Kadane\\'s  Link :  \\n\\thttps://github.com/MAZHARMIK/Interview_DS_Algo/blob/master/DP/Maximum%20Sum%20Rectangular%20Submatrix%20in%20Matrix%20dynamic%20programming(2-D%20kadane).cpp\\n```\\n/*\\n\\tThis problem is solved using the concept of 2-D Kadane\\'s Algorithm\\n\\ti.e. maximum rectangle sum in a 2-D matrix\\n*/\\nclass Solution {\\npublic:\\n    void findMaxLessThanK(vector<int>& nums, int k, int &result) {\\n        int cuSum  = 0;\\n        int maxSum  = INT_MIN;\\n        set<int> st;\\n        st.insert(0);\\n\\n        for(int i = 0; i<nums.size(); i++) {\\n            cuSum += nums[i];\\n            auto it = st.lower_bound(cuSum-k);\\n\\n            if(it != end(st)) {\\n                maxSum = max(maxSum, cuSum-*it);\\n            }\\n            st.insert(cuSum);\\n        }\\n\\n        result = max(result, maxSum);\\n    }\\n    \\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int rows   = matrix.size();\\n        int cols   = matrix[0].size();\\n        int result = INT_MIN;\\n\\n        for(int L = 0; L<cols; L++) {\\n            vector<int> temp(rows, 0);\\n            for(int R = L; R<cols; R++) {\\n\\n                for(int row = 0; row < rows; row++)\\n                    temp[row] += matrix[row][R];\\n\\n                findMaxLessThanK(temp, k, result);            \\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n\\tThis problem is solved using the concept of 2-D Kadane\\'s Algorithm\\n\\ti.e. maximum rectangle sum in a 2-D matrix\\n*/\\nclass Solution {\\npublic:\\n    void findMaxLessThanK(vector<int>& nums, int k, int &result) {\\n        int cuSum  = 0;\\n        int maxSum  = INT_MIN;\\n        set<int> st;\\n        st.insert(0);\\n\\n        for(int i = 0; i<nums.size(); i++) {\\n            cuSum += nums[i];\\n            auto it = st.lower_bound(cuSum-k);\\n\\n            if(it != end(st)) {\\n                maxSum = max(maxSum, cuSum-*it);\\n            }\\n            st.insert(cuSum);\\n        }\\n\\n        result = max(result, maxSum);\\n    }\\n    \\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int rows   = matrix.size();\\n        int cols   = matrix[0].size();\\n        int result = INT_MIN;\\n\\n        for(int L = 0; L<cols; L++) {\\n            vector<int> temp(rows, 0);\\n            for(int R = L; R<cols; R++) {\\n\\n                for(int row = 0; row < rows; row++)\\n                    temp[row] += matrix[row][R];\\n\\n                findMaxLessThanK(temp, k, result);            \\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1313293,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0)\\n            return 0;\\n        int maxSum = Integer.MIN_VALUE;\\n        for(int i = 0; i<matrix[0].length;i++){\\n            int[] sum = new int[matrix.length];\\n            for(int m = i; m<matrix[0].length;m++){\\n                for(int j = 0; j<matrix.length;j++){\\n                    sum[j]+=matrix[j][m];\\n                    if(sum[j]==k)return  k;  \\n                    if(sum[j]<k)maxSum=Math.max(maxSum,sum[j]);\\n                }\\n                for(int j = 0; j<matrix.length;j++){\\n                    int summe=0;    \\n                    for(int n = j; n<matrix.length;n++){\\n                        summe+=sum[n];\\n                        if(summe==k)return k;\\n                        if(summe<k)maxSum=Math.max(maxSum,summe);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return maxSum;\\n \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0)\\n            return 0;\\n        int maxSum = Integer.MIN_VALUE;\\n        for(int i = 0; i<matrix[0].length;i++){\\n            int[] sum = new int[matrix.length];\\n            for(int m = i; m<matrix[0].length;m++){\\n                for(int j = 0; j<matrix.length;j++){\\n                    sum[j]+=matrix[j][m];\\n                    if(sum[j]==k)return  k;  \\n                    if(sum[j]<k)maxSum=Math.max(maxSum,sum[j]);\\n                }\\n                for(int j = 0; j<matrix.length;j++){\\n                    int summe=0;    \\n                    for(int n = j; n<matrix.length;n++){\\n                        summe+=sum[n];\\n                        if(summe==k)return k;\\n                        if(summe<k)maxSum=Math.max(maxSum,summe);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return maxSum;\\n \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1277586,
                "title": "python3-insort-sortedlist",
                "content": "\\n```\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        m, n = len(matrix), len(matrix[0]) # dimensions \\n        \\n        ans = -inf \\n        rsum = [[0]*(n+1) for _ in range(m)] # row prefix sum \\n        for j in range(n): \\n            for i in range(m): rsum[i][j+1] = matrix[i][j] + rsum[i][j]\\n            for jj in range(j+1):\\n                prefix = 0 \\n                vals = [0]\\n                for i in range(m): \\n                    prefix += rsum[i][j+1] - rsum[i][jj]\\n                    x = bisect_left(vals, prefix - k)\\n                    if x < len(vals): ans = max(ans, prefix - vals[x])\\n                    insort(vals, prefix)\\n        return ans\\n```\\n\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        m, n = len(matrix), len(matrix[0]) # dimensions \\n        \\n        ans = -inf \\n        rsum = [[0]*(n+1) for _ in range(m)] # row prefix sum \\n        for j in range(n): \\n            for i in range(m): rsum[i][j+1] = matrix[i][j] + rsum[i][j]\\n            for jj in range(j+1):\\n                prefix = 0 \\n                vals = SortedList()\\n                for i in range(m): \\n                    vals.add(prefix)\\n                    prefix += rsum[i][j+1] - rsum[i][jj]\\n                    x = vals.bisect_left(prefix - k)\\n                    if x < len(vals): ans = max(ans, prefix - vals[x])\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        m, n = len(matrix), len(matrix[0]) # dimensions \\n        \\n        ans = -inf \\n        rsum = [[0]*(n+1) for _ in range(m)] # row prefix sum \\n        for j in range(n): \\n            for i in range(m): rsum[i][j+1] = matrix[i][j] + rsum[i][j]\\n            for jj in range(j+1):\\n                prefix = 0 \\n                vals = [0]\\n                for i in range(m): \\n                    prefix += rsum[i][j+1] - rsum[i][jj]\\n                    x = bisect_left(vals, prefix - k)\\n                    if x < len(vals): ans = max(ans, prefix - vals[x])\\n                    insort(vals, prefix)\\n        return ans\\n```\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        m, n = len(matrix), len(matrix[0]) # dimensions \\n        \\n        ans = -inf \\n        rsum = [[0]*(n+1) for _ in range(m)] # row prefix sum \\n        for j in range(n): \\n            for i in range(m): rsum[i][j+1] = matrix[i][j] + rsum[i][j]\\n            for jj in range(j+1):\\n                prefix = 0 \\n                vals = SortedList()\\n                for i in range(m): \\n                    vals.add(prefix)\\n                    prefix += rsum[i][j+1] - rsum[i][jj]\\n                    x = vals.bisect_left(prefix - k)\\n                    if x < len(vals): ans = max(ans, prefix - vals[x])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 856618,
                "title": "python-solution-prefix-sum-2d-array",
                "content": "```\\nclass Solution:\\n    def maxSumSubmatrix(self, w: List[List[int]], K: int) -> int:\\n        \\n        def get(x1: int, y1: int, x2: int, y2: int) -> int:\\n            return s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]\\n        \\n        n, m = len(w), len(w[0])\\n        \"\"\"\\n        >>> a = [[1,2,3],[4,2,6]]\\n        >>> len(a) \\u884C\\u6570\\n        2\\n        >>> len(a[0]) \\u5217\\u6570\\n        3\\n        \"\"\"\\n        # \\u9884\\u5904\\u7406\\u5F97\\u5230\\u77E9\\u9635\\u524D\\u7F00\\u548C\\n        s = [[0 for i in range(m + 1)] for y in range(n + 1)]\\n        for i in range (1, n + 1):\\n            for j in range (1, m + 1):\\n                s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + w[i - 1][j - 1]\\n        \\n        res = -sys.maxsize\\n        for i in range(1, m + 1):\\n            for j in range(i, m + 1):\\n                L = [0]\\n                for k in range(1, n + 1):\\n                    si = get(1, i, k, j)\\n                    it = bisect.bisect_left(L, si - K)\\n                    if it != len(L):\\n                        res = max(res, si - L[it])\\n                    bisect.insort(L, si)\\n        return res\\n\\t\\t",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSumSubmatrix(self, w: List[List[int]], K: int) -> int:\\n        \\n        def get(x1: int, y1: int, x2: int, y2: int) -> int:\\n            return s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]\\n        \\n        n, m = len(w), len(w[0])\\n        \"\"\"\\n        >>> a = [[1,2,3],[4,2,6]]\\n        >>> len(a) \\u884C\\u6570\\n        2\\n        >>> len(a[0]) \\u5217\\u6570\\n        3\\n        \"\"\"\\n        # \\u9884\\u5904\\u7406\\u5F97\\u5230\\u77E9\\u9635\\u524D\\u7F00\\u548C\\n        s = [[0 for i in range(m + 1)] for y in range(n + 1)]\\n        for i in range (1, n + 1):\\n            for j in range (1, m + 1):\\n                s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + w[i - 1][j - 1]\\n        \\n        res = -sys.maxsize\\n        for i in range(1, m + 1):\\n            for j in range(i, m + 1):\\n                L = [0]\\n                for k in range(1, n + 1):\\n                    si = get(1, i, k, j)\\n                    it = bisect.bisect_left(L, si - K)\\n                    if it != len(L):\\n                        res = max(res, si - L[it])\\n                    bisect.insort(L, si)\\n        return res\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 782703,
                "title": "same-technique-to-solve-lc363-and-lc1074",
                "content": "Inspired by many other people and the discussions under both problems. The key idea follows the three steps below:\\n1. calculate presum for each row, which later help easily get the sum of sub array between col=i and col=j, for any row;\\n2. between any column pair [i, j] (both side inclusive), the problem of LC363 becomes `max sum of sub array no larger than K`, in a one-dimentional array, and the problem of LC1074 becomes `number of sub arrays that sum to target`. The reason is we can reduce the horizontal dimention to a single sum number, using the pre sum calculated from step 1;\\n3. at this point, the problem can very much borrow the idea from LC560. We can iterate vertically from the first row to the last row. Each step we can calculate the current sum so far until the current row. We also need to store the current sum in an O(1)-get data structure, to efficiently access later.\\n\\nFor LC 363, we can use a tree set to store all the current sum already seen, and each step fetch from the set using set.ceiling(curSum-k). I think the snippet pasted below is self-explained.\\n\\n```java\\nclass Solution {\\n  public int maxSumSubmatrix(int[][] matrix, int k) {\\n    if(matrix==null || matrix.length==0 || matrix[0].length==0) {\\n      return 0;\\n    }\\n    int m=matrix.length, n=matrix[0].length;\\n    int[][] sum=new int[m][n+1];\\n    for(int i=0; i<m; i++) {\\n      for(int j=1; j<=n; j++) {\\n        sum[i][j]=sum[i][j-1]+matrix[i][j-1];\\n      }\\n    }\\n    \\n    int res=Integer.MIN_VALUE;\\n    // for each column pair [i, j], where i and j are inclusive.\\n    for(int i=0; i<n; i++) {\\n      for(int j=i; j<n; j++) {\\n        int curSum=0;\\n        TreeSet<Integer> set=new TreeSet<>();\\n        set.add(0);\\n        for(int p=0; p<m; p++) {\\n          curSum=curSum+sum[p][j+1]-sum[p][i];\\n          Integer val=set.ceiling(curSum-k);\\n          if(val!=null) {\\n            res=Math.max(res, curSum-val);\\n          }\\n          set.add(curSum);\\n        }\\n      }\\n    }\\n    return res;\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n  public int maxSumSubmatrix(int[][] matrix, int k) {\\n    if(matrix==null || matrix.length==0 || matrix[0].length==0) {\\n      return 0;\\n    }\\n    int m=matrix.length, n=matrix[0].length;\\n    int[][] sum=new int[m][n+1];\\n    for(int i=0; i<m; i++) {\\n      for(int j=1; j<=n; j++) {\\n        sum[i][j]=sum[i][j-1]+matrix[i][j-1];\\n      }\\n    }\\n    \\n    int res=Integer.MIN_VALUE;\\n    // for each column pair [i, j], where i and j are inclusive.\\n    for(int i=0; i<n; i++) {\\n      for(int j=i; j<n; j++) {\\n        int curSum=0;\\n        TreeSet<Integer> set=new TreeSet<>();\\n        set.add(0);\\n        for(int p=0; p<m; p++) {\\n          curSum=curSum+sum[p][j+1]-sum[p][i];\\n          Integer val=set.ceiling(curSum-k);\\n          if(val!=null) {\\n            res=Math.max(res, curSum-val);\\n          }\\n          set.add(curSum);\\n        }\\n      }\\n    }\\n    return res;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 779649,
                "title": "binary-search-with-bisect-or-your-own-implementation-python",
                "content": "```\\nclass Solution(object):\\n    def maxSumSubmatrix(self, matrix, k):\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        \\n        def bsearch(nums, val):\\n            left = 0\\n            right = len(nums)\\n            while left < right:\\n                mid = left + (right - left)//2\\n                if nums[mid] >= val:\\n                    right = mid\\n                else:\\n                    left = mid + 1\\n            return left\\n        \\n        res = -2**31\\n        \\n        for i in range(n):\\n            sums = [0] * m\\n            for j in range(i, n):\\n                for r in range(m):\\n                    sums[r] += matrix[r][j]\\n                \\n                # suppose we have an array, we need to find its sub array, \\n                # such that sum(subarray) <=k and sum(subarray) is maximum\\n                \\n                presum = 0\\n                cumsum = [0]\\n                for num in sums:\\n                    presum += num\\n                    \\n                    #left = bsearch(cumsum, presum - k) # cumsum[left] >= presum - k, i.e., k>= presum - cumsum[left]\\n                    left = bisect.bisect_left(cumsum, presum - k)\\n                    if left < len(cumsum):\\n                        res = max(res, presum - cumsum[left])\\n                        \\n                    #left2 = bsearch(cumsum, presum)\\n                    #cumsum.insert(left2, presum)\\n                    bisect.insort(cumsum, presum)\\n        return res\\n    \\n    def maxSumSubmatrix(self, matrix, k):\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        \\n        def bsearch(nums, val):\\n            left = 0\\n            right = len(nums)\\n            while left < right:\\n                mid = left + (right - left)//2\\n                if nums[mid] >= val:\\n                    right = mid\\n                else:\\n                    left = mid + 1\\n            return left\\n        \\n        res = -2**31\\n        \\n        for i in range(n):\\n            sums = [0] * m\\n            for j in range(i, n):\\n                for r in range(m):\\n                    sums[r] += matrix[r][j]\\n                \\n                # suppose we have an array, we need to find its sub array, \\n                # such that sum(subarray) <=k and sum(subarray) is maximum\\n                \\n                presum = 0\\n                cumsum = [0]\\n                for num in sums:\\n                    presum += num\\n                    \\n                    left = bsearch(cumsum, presum - k) # cumsum[left] >= presum - k, i.e., k>= presum - cumsum[left]\\n                    #left = bisect.bisect_left(cumsum, presum - k)\\n                    if left < len(cumsum):\\n                        res = max(res, presum - cumsum[left])\\n                        \\n                    left2 = bsearch(cumsum, presum)\\n                    cumsum.insert(left2, presum)\\n                    #bisect.insort(cumsum, presum)\\n        return res\\n```\\n\\nSpecially: \\n```\\n\\t\\tfor i in range(columns): # i \\u626B\\u8FC7\\u6BCF\\u4E00\\u5217\\n            sums = [0 for _ in range(rows)] # sums \\u7684\\u957F\\u5EA6\\uFF0C\\u548C\\u884C\\u6570\\u76F8\\u540C\\n            for j in range(i, columns): # j\\u4E5F\\u662F\\u626B\\u8FC7i\\u540E\\u9762\\u7684\\u5217\\n                for r in range(rows): # r\\u662F\\u6240\\u6709\\u884C\\uFF0C\\n                    sums[r] += matrix[r][j]\\n                print(sums)\\n                #\\u5206\\u522B\\u662F \\u7B2C0\\u5217\\u7684\\u6240\\u6709\\u884C\\n                #       \\u7B2C0\\u5217\\u7684\\u6240\\u6709\\u884C+\\u7B2C1\\u5217\\u7684\\u6240\\u6709\\u884C\\n                #       \\u7B2C0\\u5217\\u7684\\u6240\\u6709\\u884C+\\u7B2C1\\u5217\\u7684\\u6240\\u6709\\u884C+\\u7B2C2\\u5217\\u7684\\u6240\\u6709\\u884C\\n                \\n                #       \\u7B2C1\\u5217\\u7684\\u6240\\u6709\\u884C\\n                #       \\u7B2C1\\u5217\\u7684\\u6240\\u6709\\u884C+\\u7B2C2\\u5217\\u7684\\u6240\\u6709\\u884C\\n                \\n                #       \\u7B2C2\\u5217\\u7684\\u6240\\u6709\\u884C\\n```\\n\\nAnd details regarding finding a subarray, whose sum <= k and the sum is the largest among all subarraies that satisfy sum (x) <=k.\\n\\n```\\ndef bsearch(nums, val):\\n    left = 0\\n    right = len(nums)\\n    while left < right:\\n        mid = left + (right - left)//2\\n        if nums[mid] >= val:\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n\\ndef prefix(nums, k):\\n    import bisect\\n    res = float(\\'-inf\\')\\n    cum_sum = [0]\\n    prefixSum, max_sum = 0, float(\\'-inf\\')\\n    for num in nums:\\n        prefixSum += num # \\u5F53\\u524D\\u4E3A\\u6B62\\u7684\\u524D\\u7F00\\u548C\\n\\n        #cum_sum[left] >= prefixSum - k\\n        #\\u4ECE\\u800C\\u6211\\u4EEC\\u6709 k >= prefixSum - cum_sum[left]\\n        # \\u5F53\\u524D\\u6709\\u4E86\\u4E00\\u4E2AprefixSum\\u7684\\u7ED3\\u679C\\uFF0C\\u90A3\\u6211\\u4EEC\\u7684\\u76EE\\u6807\\u662F\\uFF1A\\u5411\\u5DE6\\uFF0C\\u5BFB\\u627E\\u4E00\\u4E2A\\u5DF2\\u6709\\u7684prefixSum (old) \\uFF0C\\u4F7F\\u5F97prefixSum - prefixSum(old) <= k \\u800C\\u4E14\\u8FD9\\u6837\\u7684\\u503C\\u53EF\\u4EE5\\u6700\\u5927\\u5316\\uFF01\\n\\n        #left = bisect.bisect_left(cum_sum, prefixSum - k) # why prefixSum - k? \\u4E3A\\u4EC0\\u4E48\\u4F7F\\u7528prefixSum-k\\u6765\\u786E\\u5B9Aleft?\\n        left = bsearch(cum_sum, prefixSum - k)\\n        # left\\u662FprefixSum - k\\u88AB\\u63D2\\u5165\\u7684\\u4F4D\\u7F6E\\uFF0C\\u5982\\u679CprefixSum - k\\u6BD4\\u5176\\u4E2D\\u7684\\u6240\\u6709\\u503C\\u90FD\\u5927\\uFF0C\\u5219left=len(cum_sum)\\n\\n        print(\\'cum_sum=\\', cum_sum, \\'prefixSum - k=\\', prefixSum - k, \\', prefixSum=\\', prefixSum, \\', left=\\', left)\\n\\n        if left < len(cum_sum):\\n            max_sum = max(max_sum, prefixSum - cum_sum[left])\\n\\n        #bisect.insort(cum_sum, prefixSum) # insert to sorted array, such as 3 in [2,4,5] -> [2,3,4,5]\\n        left2 = bsearch(cum_sum, prefixSum)\\n        cum_sum.insert(left2, prefixSum)\\n\\n    res = max(res, max_sum)\\n    return res\\n\\nnums = [1, -3, 4, 7, -5, 6]\\nprint(prefix(nums, 5))\\n\\n# \\u76EE\\u7684\\u5C31\\u662F\\u5728nums\\u4E2D\\u5BFB\\u627E\\u4E00\\u4E2A\\u5B50\\u6570\\u7EC4\\uFF0C\\u5E76\\u4E14\\u6EE1\\u8DB3\\uFF1A\\u8BE5\\u5B50\\u6570\\u7EC4\\u7684\\u548C<=k=5\\uFF0C\\u5E76\\u4E14\\u6700\\u63A5\\u8FD1k \\uFF08\\u662F\\u6240\\u6709<=k\\u4E2D\\uFF0C\"\\u548C\"/sum \\u6700\\u5927\\u7684\\uFF09\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxSumSubmatrix(self, matrix, k):\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        \\n        def bsearch(nums, val):\\n            left = 0\\n            right = len(nums)\\n            while left < right:\\n                mid = left + (right - left)//2\\n                if nums[mid] >= val:\\n                    right = mid\\n                else:\\n                    left = mid + 1\\n            return left\\n        \\n        res = -2**31\\n        \\n        for i in range(n):\\n            sums = [0] * m\\n            for j in range(i, n):\\n                for r in range(m):\\n                    sums[r] += matrix[r][j]\\n                \\n                # suppose we have an array, we need to find its sub array, \\n                # such that sum(subarray) <=k and sum(subarray) is maximum\\n                \\n                presum = 0\\n                cumsum = [0]\\n                for num in sums:\\n                    presum += num\\n                    \\n                    #left = bsearch(cumsum, presum - k) # cumsum[left] >= presum - k, i.e., k>= presum - cumsum[left]\\n                    left = bisect.bisect_left(cumsum, presum - k)\\n                    if left < len(cumsum):\\n                        res = max(res, presum - cumsum[left])\\n                        \\n                    #left2 = bsearch(cumsum, presum)\\n                    #cumsum.insert(left2, presum)\\n                    bisect.insort(cumsum, presum)\\n        return res\\n    \\n    def maxSumSubmatrix(self, matrix, k):\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        \\n        def bsearch(nums, val):\\n            left = 0\\n            right = len(nums)\\n            while left < right:\\n                mid = left + (right - left)//2\\n                if nums[mid] >= val:\\n                    right = mid\\n                else:\\n                    left = mid + 1\\n            return left\\n        \\n        res = -2**31\\n        \\n        for i in range(n):\\n            sums = [0] * m\\n            for j in range(i, n):\\n                for r in range(m):\\n                    sums[r] += matrix[r][j]\\n                \\n                # suppose we have an array, we need to find its sub array, \\n                # such that sum(subarray) <=k and sum(subarray) is maximum\\n                \\n                presum = 0\\n                cumsum = [0]\\n                for num in sums:\\n                    presum += num\\n                    \\n                    left = bsearch(cumsum, presum - k) # cumsum[left] >= presum - k, i.e., k>= presum - cumsum[left]\\n                    #left = bisect.bisect_left(cumsum, presum - k)\\n                    if left < len(cumsum):\\n                        res = max(res, presum - cumsum[left])\\n                        \\n                    left2 = bsearch(cumsum, presum)\\n                    cumsum.insert(left2, presum)\\n                    #bisect.insort(cumsum, presum)\\n        return res\\n```\n```\\n\\t\\tfor i in range(columns): # i \\u626B\\u8FC7\\u6BCF\\u4E00\\u5217\\n            sums = [0 for _ in range(rows)] # sums \\u7684\\u957F\\u5EA6\\uFF0C\\u548C\\u884C\\u6570\\u76F8\\u540C\\n            for j in range(i, columns): # j\\u4E5F\\u662F\\u626B\\u8FC7i\\u540E\\u9762\\u7684\\u5217\\n                for r in range(rows): # r\\u662F\\u6240\\u6709\\u884C\\uFF0C\\n                    sums[r] += matrix[r][j]\\n                print(sums)\\n                #\\u5206\\u522B\\u662F \\u7B2C0\\u5217\\u7684\\u6240\\u6709\\u884C\\n                #       \\u7B2C0\\u5217\\u7684\\u6240\\u6709\\u884C+\\u7B2C1\\u5217\\u7684\\u6240\\u6709\\u884C\\n                #       \\u7B2C0\\u5217\\u7684\\u6240\\u6709\\u884C+\\u7B2C1\\u5217\\u7684\\u6240\\u6709\\u884C+\\u7B2C2\\u5217\\u7684\\u6240\\u6709\\u884C\\n                \\n                #       \\u7B2C1\\u5217\\u7684\\u6240\\u6709\\u884C\\n                #       \\u7B2C1\\u5217\\u7684\\u6240\\u6709\\u884C+\\u7B2C2\\u5217\\u7684\\u6240\\u6709\\u884C\\n                \\n                #       \\u7B2C2\\u5217\\u7684\\u6240\\u6709\\u884C\\n```\n```\\ndef bsearch(nums, val):\\n    left = 0\\n    right = len(nums)\\n    while left < right:\\n        mid = left + (right - left)//2\\n        if nums[mid] >= val:\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n\\ndef prefix(nums, k):\\n    import bisect\\n    res = float(\\'-inf\\')\\n    cum_sum = [0]\\n    prefixSum, max_sum = 0, float(\\'-inf\\')\\n    for num in nums:\\n        prefixSum += num # \\u5F53\\u524D\\u4E3A\\u6B62\\u7684\\u524D\\u7F00\\u548C\\n\\n        #cum_sum[left] >= prefixSum - k\\n        #\\u4ECE\\u800C\\u6211\\u4EEC\\u6709 k >= prefixSum - cum_sum[left]\\n        # \\u5F53\\u524D\\u6709\\u4E86\\u4E00\\u4E2AprefixSum\\u7684\\u7ED3\\u679C\\uFF0C\\u90A3\\u6211\\u4EEC\\u7684\\u76EE\\u6807\\u662F\\uFF1A\\u5411\\u5DE6\\uFF0C\\u5BFB\\u627E\\u4E00\\u4E2A\\u5DF2\\u6709\\u7684prefixSum (old) \\uFF0C\\u4F7F\\u5F97prefixSum - prefixSum(old) <= k \\u800C\\u4E14\\u8FD9\\u6837\\u7684\\u503C\\u53EF\\u4EE5\\u6700\\u5927\\u5316\\uFF01\\n\\n        #left = bisect.bisect_left(cum_sum, prefixSum - k) # why prefixSum - k? \\u4E3A\\u4EC0\\u4E48\\u4F7F\\u7528prefixSum-k\\u6765\\u786E\\u5B9Aleft?\\n        left = bsearch(cum_sum, prefixSum - k)\\n        # left\\u662FprefixSum - k\\u88AB\\u63D2\\u5165\\u7684\\u4F4D\\u7F6E\\uFF0C\\u5982\\u679CprefixSum - k\\u6BD4\\u5176\\u4E2D\\u7684\\u6240\\u6709\\u503C\\u90FD\\u5927\\uFF0C\\u5219left=len(cum_sum)\\n\\n        print(\\'cum_sum=\\', cum_sum, \\'prefixSum - k=\\', prefixSum - k, \\', prefixSum=\\', prefixSum, \\', left=\\', left)\\n\\n        if left < len(cum_sum):\\n            max_sum = max(max_sum, prefixSum - cum_sum[left])\\n\\n        #bisect.insort(cum_sum, prefixSum) # insert to sorted array, such as 3 in [2,4,5] -> [2,3,4,5]\\n        left2 = bsearch(cum_sum, prefixSum)\\n        cum_sum.insert(left2, prefixSum)\\n\\n    res = max(res, max_sum)\\n    return res\\n\\nnums = [1, -3, 4, 7, -5, 6]\\nprint(prefix(nums, 5))\\n\\n# \\u76EE\\u7684\\u5C31\\u662F\\u5728nums\\u4E2D\\u5BFB\\u627E\\u4E00\\u4E2A\\u5B50\\u6570\\u7EC4\\uFF0C\\u5E76\\u4E14\\u6EE1\\u8DB3\\uFF1A\\u8BE5\\u5B50\\u6570\\u7EC4\\u7684\\u548C<=k=5\\uFF0C\\u5E76\\u4E14\\u6700\\u63A5\\u8FD1k \\uFF08\\u662F\\u6240\\u6709<=k\\u4E2D\\uFF0C\"\\u548C\"/sum \\u6700\\u5927\\u7684\\uFF09\\n```",
                "codeTag": "Java"
            },
            {
                "id": 540718,
                "title": "java-readable-kadane-s-with-comments",
                "content": "`Runtime: 791 ms, faster than 18.26% of Java online submissions for Max Sum of Rectangle No Larger Than K.\\nMemory Usage: 42 MB, less than 100.00% of Java online submissions for Max Sum of Rectangle No Larger Than K.`\\n\\n\\n```\\npublic class Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int[] sumColumn = new int[matrix[0].length];\\n        int max = Integer.MIN_VALUE;\\n        for (int l = 0; l < matrix.length; l++) {\\n            // Reset sum column every time we move left index\\n            sumColumn = new int[matrix[0].length];\\n            \\n            // Iterate through combinations of left and right boundaries for columns\\n            for (int r = l; r < matrix.length; r++) { \\n                \\n                // Sum all cell values across columns, starting from left moving towards right\\n                for (int i = 0; i < matrix[0].length; i++) {\\n                    sumColumn[i] += matrix[r][i];\\n                }\\n\\n                // Calculate the local maximum using kadane\\'s and take the max between previous max and new value\\n                max = Math.max(max, kadanes(sumColumn, k));                 \\n                if (max == k) { return k; }\\n            }\\n        }\\n        return max;\\n    }\\n    \\n    // Like normal kadane\\'s except we use a TreeSet since we don\\'t want to exceed value k\\n    private int kadanes(int[] arr, int k) {\\n        int max = Integer.MIN_VALUE;\\n        int curr = 0;\\n        \\n        // Create tree set to find local maximum with respect to k\\n        TreeSet<Integer> set = new TreeSet<>();\\n        \\n        // Populate with 0 for the case where curr - k is smaller than 0\\n        set.add(0);\\n        for (int i = 0; i < arr.length; i++) {\\n            curr += arr[i];\\n            \\n            // Use the previous sums to determine the smallest previous sum. that can be subtracted from the \\n            // current sum to stay under the value k, by taking the ceiling value for curr - k\\n            Integer ceil = set.ceiling(curr - k);\\n            if(ceil != null) {\\n                max = Math.max(max, curr - ceil);\\n            }\\n            set.add(curr);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int[] sumColumn = new int[matrix[0].length];\\n        int max = Integer.MIN_VALUE;\\n        for (int l = 0; l < matrix.length; l++) {\\n            // Reset sum column every time we move left index\\n            sumColumn = new int[matrix[0].length];\\n            \\n            // Iterate through combinations of left and right boundaries for columns\\n            for (int r = l; r < matrix.length; r++) { \\n                \\n                // Sum all cell values across columns, starting from left moving towards right\\n                for (int i = 0; i < matrix[0].length; i++) {\\n                    sumColumn[i] += matrix[r][i];\\n                }\\n\\n                // Calculate the local maximum using kadane\\'s and take the max between previous max and new value\\n                max = Math.max(max, kadanes(sumColumn, k));                 \\n                if (max == k) { return k; }\\n            }\\n        }\\n        return max;\\n    }\\n    \\n    // Like normal kadane\\'s except we use a TreeSet since we don\\'t want to exceed value k\\n    private int kadanes(int[] arr, int k) {\\n        int max = Integer.MIN_VALUE;\\n        int curr = 0;\\n        \\n        // Create tree set to find local maximum with respect to k\\n        TreeSet<Integer> set = new TreeSet<>();\\n        \\n        // Populate with 0 for the case where curr - k is smaller than 0\\n        set.add(0);\\n        for (int i = 0; i < arr.length; i++) {\\n            curr += arr[i];\\n            \\n            // Use the previous sums to determine the smallest previous sum. that can be subtracted from the \\n            // current sum to stay under the value k, by taking the ceiling value for curr - k\\n            Integer ceil = set.ceiling(curr - k);\\n            if(ceil != null) {\\n                max = Math.max(max, curr - ceil);\\n            }\\n            set.add(curr);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 463007,
                "title": "accepted-c-solution-376-ms-beats-75-61-time-o-col-2-row-2-memory-o-rows-easy-to-understand",
                "content": "Ported to C# and cleaned unnecessary code from: [JavaScript-Solution-Kadane\\'s](https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/discuss/407822/JavaScript-Solution-Kadane\\'s)\\n```\\npublic class Solution {\\n    \\n    public int MaxSumSubmatrix(int[][] matrix, int k)\\n    {\\n        int max = int.MinValue;\\n        int rows = matrix.Length;\\n        int cols = matrix[0].Length;\\n        int[] sums = new int[rows];\\n        for (int l = 0; l < cols; l++)\\n        {\\n            Array.Clear(sums, 0, rows);            \\n            for (int r = l; r < cols; r++)\\n            {\\n                for (int row = 0; row < rows; row++)\\n                    sums[row] += matrix[row][r];                    \\n                \\n                for (int i = 0; i < rows; i++)\\n                {\\n                    int sum = 0;                             \\n                    for (int j = i; j < rows; j++)\\n                    {\\n                        sum += sums[j];\\n                        if (sum > max && sum <= k)\\n                            max = sum;\\n                    }                    \\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    \\n    public int MaxSumSubmatrix(int[][] matrix, int k)\\n    {\\n        int max = int.MinValue;\\n        int rows = matrix.Length;\\n        int cols = matrix[0].Length;\\n        int[] sums = new int[rows];\\n        for (int l = 0; l < cols; l++)\\n        {\\n            Array.Clear(sums, 0, rows);            \\n            for (int r = l; r < cols; r++)\\n            {\\n                for (int row = 0; row < rows; row++)\\n                    sums[row] += matrix[row][r];                    \\n                \\n                for (int i = 0; i < rows; i++)\\n                {\\n                    int sum = 0;                             \\n                    for (int j = i; j < rows; j++)\\n                    {\\n                        sum += sums[j];\\n                        if (sum > max && sum <= k)\\n                            max = sum;\\n                    }                    \\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 407822,
                "title": "javascript-solution-kadane-s",
                "content": "```javascript\\nvar maxSumSubmatrix = function(m, k) {\\n    let mt=0,mb=0, ml=0,mr=0, max=-Infinity;\\n    let rows = m.length, cols = m[0].length;\\n    let sums=Array(rows);\\n    for (let l = 0; l < cols; l++) {\\n        sums.fill(0);\\n        for (let r=l; l < cols; r++) {\\n            if(r>=cols)break;\\n            for (let row = 0; row < rows; row++) {\\n                sums[row] += m[row][r];\\n            }\\n            for (let i = 0; i < rows; i++) {\\n                let sum = 0;\\n                for (let j = i; j < rows; j++) {\\n                    sum += sums[j];\\n                    if (sum > max && sum <= k) {\\n                        mt = i;\\n                        mb = j;\\n                        ml = l;\\n                        mr = r;\\n                        max = sum;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar maxSumSubmatrix = function(m, k) {\\n    let mt=0,mb=0, ml=0,mr=0, max=-Infinity;\\n    let rows = m.length, cols = m[0].length;\\n    let sums=Array(rows);\\n    for (let l = 0; l < cols; l++) {\\n        sums.fill(0);\\n        for (let r=l; l < cols; r++) {\\n            if(r>=cols)break;\\n            for (let row = 0; row < rows; row++) {\\n                sums[row] += m[row][r];\\n            }\\n            for (let i = 0; i < rows; i++) {\\n                let sum = 0;\\n                for (let j = i; j < rows; j++) {\\n                    sum += sums[j];\\n                    if (sum > max && sum <= k) {\\n                        mt = i;\\n                        mb = j;\\n                        ml = l;\\n                        mr = r;\\n                        max = sum;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 218304,
                "title": "python-dp-kadane-binary-search",
                "content": "* M = # of rows, N= # of cols\\n* M >  N\\n* O(N^2 M^2)\\n\\t* bisect.bisect() takes O(logM) but bisect.insort() takes O(M)\\n```\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix, k):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        n_row, n_col = len(matrix), len(matrix[0])\\n        ans = float(\\'-inf\\')\\n        for l in range(n_col):\\n            sums = [0] * n_row\\n            for r in range(l, n_col):\\n                for i in range(n_row):\\n                    sums[i] += matrix[i][r]\\n                ans = max(ans, self.maxSubArray(sums, k))\\n        return ans\\n                    \\n    def maxSubArray(self, nums, k):\\n        cur_sum, max_sum = 0, float(\\'-inf\\')\\n        sums = [0]\\n        for i, n in enumerate(nums, 1):\\n            cur_sum += n\\n            idx = bisect.bisect_left(sums, cur_sum - k)\\n            if idx != i:\\n                max_sum = max(max_sum, cur_sum - sums[idx])\\n            bisect.insort(sums, cur_sum)\\n        return max_sum\\n\\n        \\n        \\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix, k):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        n_row, n_col = len(matrix), len(matrix[0])\\n        ans = float(\\'-inf\\')\\n        for l in range(n_col):\\n            sums = [0] * n_row\\n            for r in range(l, n_col):\\n                for i in range(n_row):\\n                    sums[i] += matrix[i][r]\\n                ans = max(ans, self.maxSubArray(sums, k))\\n        return ans\\n                    \\n    def maxSubArray(self, nums, k):\\n        cur_sum, max_sum = 0, float(\\'-inf\\')\\n        sums = [0]\\n        for i, n in enumerate(nums, 1):\\n            cur_sum += n\\n            idx = bisect.bisect_left(sums, cur_sum - k)\\n            if idx != i:\\n                max_sum = max(max_sum, cur_sum - sums[idx])\\n            bisect.insort(sums, cur_sum)\\n        return max_sum\\n\\n        \\n        \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 83598,
                "title": "java-81ms-beats-previously-submitted-java-solutions",
                "content": "```\\npublic class Solution {\\n\\n    public static int maxSumSubArrayNoGreaterThanK(int[] s, int k) {\\n        int len     = s.length;\\n        int ans     = Integer.MIN_VALUE;\\n        int nums[] = new int[len];\\n        nums[0] = s[0];\\n        for(int i=1;i<len;i++){\\n            nums[i] = nums[i-1] + s[i];\\n        }\\n\\n        for(int i=0;i<len;i++){\\n            for(int j=i;j<len;j++){\\n                int sum;\\n                if(i==0) sum = nums[j];\\n                else sum = nums[j] - nums[i-1];\\n                if(sum > ans && sum <= k)\\n                    ans = sum;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int cols    = matrix[0].length;\\n        int rows    = matrix.length;\\n        int maxSum  = Integer.MIN_VALUE;\\n\\n        for (int leftCol = 0; leftCol < cols; leftCol++) {\\n            int[] tmp = new int[rows];\\n            for (int rightCol = leftCol; rightCol < cols; rightCol++) {\\n                for (int l = 0; l < rows; l++) {\\n                    tmp[l] += matrix[l][rightCol];\\n                }\\n                int currentResult = maxSumSubArrayNoGreaterThanK(tmp,k);\\n                if (currentResult > maxSum) {\\n                    maxSum = currentResult;\\n                }\\n            }\\n        }\\n        return maxSum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n\\n    public static int maxSumSubArrayNoGreaterThanK(int[] s, int k) {\\n        int len     = s.length;\\n        int ans     = Integer.MIN_VALUE;\\n        int nums[] = new int[len];\\n        nums[0] = s[0];\\n        for(int i=1;i<len;i++){\\n            nums[i] = nums[i-1] + s[i];\\n        }\\n\\n        for(int i=0;i<len;i++){\\n            for(int j=i;j<len;j++){\\n                int sum;\\n                if(i==0) sum = nums[j];\\n                else sum = nums[j] - nums[i-1];\\n                if(sum > ans && sum <= k)\\n                    ans = sum;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int cols    = matrix[0].length;\\n        int rows    = matrix.length;\\n        int maxSum  = Integer.MIN_VALUE;\\n\\n        for (int leftCol = 0; leftCol < cols; leftCol++) {\\n            int[] tmp = new int[rows];\\n            for (int rightCol = leftCol; rightCol < cols; rightCol++) {\\n                for (int l = 0; l < rows; l++) {\\n                    tmp[l] += matrix[l][rightCol];\\n                }\\n                int currentResult = maxSumSubArrayNoGreaterThanK(tmp,k);\\n                if (currentResult > maxSum) {\\n                    maxSum = currentResult;\\n                }\\n            }\\n        }\\n        return maxSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 83611,
                "title": "merge-sort-beat-100-python-submissions",
                "content": "class Solution(object):\\n    def findMaxArea(self, a, l, r, k):\\n        if l >= r: return -2**31\\n        \\n        m = (l+r)/2\\n        res = max(self.findMaxArea(a, l, m, k), self.findMaxArea(a, m+1, r, k))\\n        \\n        i = l\\n        for j in range(m+1, r+1):\\n            while i <= m and a[j] - a[i] > k: i += 1\\n            if i > m: break\\n            if res < a[j] - a[i]: res = a[j] - a[i]\\n            \\n        tmp = [0]*(r-l+1)\\n        i = l\\n        j = m+1\\n        t = 0\\n        \\n        while i <= m and j <= r:\\n            if a[i] <= a[j]:\\n                tmp[t] = a[i]\\n                i += 1\\n                t += 1\\n            else:\\n                tmp[t] = a[j]\\n                t += 1\\n                j += 1\\n        \\n        while i <= m:\\n            tmp[t] = a[i]\\n            t += 1\\n            i += 1\\n            \\n        while j <= r:\\n            tmp[t] = a[j]\\n            t += 1\\n            j += 1\\n            \\n        for i in range(len(tmp)): a[l+i] = tmp[i]\\n        \\n        return res\\n        \\n    def maxSumSubmatrix(self, matrix, k):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        if len(matrix) == 0 or len(matrix[0]) == 0: return 0\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        if m > n:\\n            m, n = n, m\\n            a = [[0]*n for i in range(m)]\\n            \\n            for i in range(m):\\n                for j in range(n):\\n                    a[i][j] = matrix[j][i]\\n        \\n        else:\\n            a = [[0]*n for i in range(m)]\\n            for i in range(m):\\n                for j in range(n):\\n                    a[i][j] = matrix[i][j]\\n                \\n        res = -2**31\\n        for i in range(m):\\n            h = [0] * n\\n            for j in range(i, m):\\n                sum = [0] * (n+1)\\n                \\n                low = 0\\n                maxArea = -2**31\\n                \\n                for t in range(n):\\n                    h[t] += a[j][t]\\n                    sum[t+1] = sum[t] + h[t]\\n                    \\n                    maxArea = max(maxArea, sum[t+1]-low)\\n                    low = min(low, sum[t+1])\\n                    \\n                if maxArea <= res: continue\\n            \\n                if maxArea == k: return k\\n                if maxArea > k: maxArea = self.findMaxArea(sum, 0, n, k)\\n                \\n                res = max(res, maxArea)\\n                \\n        return res",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def findMaxArea(self, a, l, r, k):\\n        if l >= r: return -2**31\\n        \\n        m = (l+r)/2\\n        res = max(self.findMaxArea(a, l, m, k), self.findMaxArea(a, m+1, r, k))\\n        \\n        i = l\\n        for j in range(m+1, r+1):\\n            while i <= m and a[j] - a[i] > k: i += 1\\n            if i > m: break\\n            if res < a[j] - a[i]: res = a[j] - a[i]\\n            \\n        tmp = [0]*(r-l+1)\\n        i = l\\n        j = m+1\\n        t = 0\\n        \\n        while i <= m and j <= r:\\n            if a[i] <= a[j]:\\n                tmp[t] = a[i]\\n                i += 1\\n                t += 1\\n            else:\\n                tmp[t] = a[j]\\n                t += 1\\n                j += 1\\n        \\n        while i <= m:\\n            tmp[t] = a[i]\\n            t += 1\\n            i += 1\\n            \\n        while j <= r:\\n            tmp[t] = a[j]\\n            t += 1\\n            j += 1\\n            \\n        for i in range(len(tmp)): a[l+i] = tmp[i]\\n        \\n        return res\\n        \\n    def maxSumSubmatrix(self, matrix, k):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        if len(matrix) == 0 or len(matrix[0]) == 0: return 0\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        if m > n:\\n            m, n = n, m\\n            a = [[0]*n for i in range(m)]\\n            \\n            for i in range(m):\\n                for j in range(n):\\n                    a[i][j] = matrix[j][i]\\n        \\n        else:\\n            a = [[0]*n for i in range(m)]\\n            for i in range(m):\\n                for j in range(n):\\n                    a[i][j] = matrix[i][j]\\n                \\n        res = -2**31\\n        for i in range(m):\\n            h = [0] * n\\n            for j in range(i, m):\\n                sum = [0] * (n+1)\\n                \\n                low = 0\\n                maxArea = -2**31\\n                \\n                for t in range(n):\\n                    h[t] += a[j][t]\\n                    sum[t+1] = sum[t] + h[t]\\n                    \\n                    maxArea = max(maxArea, sum[t+1]-low)\\n                    low = min(low, sum[t+1])\\n                    \\n                if maxArea <= res: continue\\n            \\n                if maxArea == k: return k\\n                if maxArea > k: maxArea = self.findMaxArea(sum, 0, n, k)\\n                \\n                res = max(res, maxArea)\\n                \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 83620,
                "title": "java-solution-easy-understand",
                "content": "This answer was almost like the solution mentioned in this video:https://www.youtube.com/watch?v=yCQN096CwWM\\n\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n\\n        int[] a = new int[n];\\n        int max = Integer.MIN_VALUE;\\n\\n        for(int l=0;l<m;l++){\\n            for(int i=0;i<n;i++) a[i] = 0;\\n\\n            for(int r=l;r<m;r++){\\n                for(int i=0;i<n;i++) a[i] += matrix[r][i];\\n                int t = maxSumSubArray(a, k);\\n                max = Math.max(t, max);\\n            }\\n        }\\n\\n        return max;\\n    }\\n\\n    private int maxSumSubArray(int[] a , int k){\\n\\n        int max = Integer.MIN_VALUE;\\n        int sumj = 0;\\n        TreeSet<Integer> s = new TreeSet();\\n        s.add(0);\\n\\n        for(int i=0;i<a.length;i++){\\n            int t = sumj + a[i];\\n            sumj = t;\\n            Integer gap = s.ceiling(sumj - k);\\n            if(gap != null) max = Math.max(max, sumj - gap);\\n            s.add(t);\\n        }\\n\\n        return max;\\n    }",
                "solutionTags": [],
                "code": "This answer was almost like the solution mentioned in this video:https://www.youtube.com/watch?v=yCQN096CwWM\\n\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n\\n        int[] a = new int[n];\\n        int max = Integer.MIN_VALUE;\\n\\n        for(int l=0;l<m;l++){\\n            for(int i=0;i<n;i++) a[i] = 0;\\n\\n            for(int r=l;r<m;r++){\\n                for(int i=0;i<n;i++) a[i] += matrix[r][i];\\n                int t = maxSumSubArray(a, k);\\n                max = Math.max(t, max);\\n            }\\n        }\\n\\n        return max;\\n    }\\n\\n    private int maxSumSubArray(int[] a , int k){\\n\\n        int max = Integer.MIN_VALUE;\\n        int sumj = 0;\\n        TreeSet<Integer> s = new TreeSet();\\n        s.add(0);\\n\\n        for(int i=0;i<a.length;i++){\\n            int t = sumj + a[i];\\n            sumj = t;\\n            Integer gap = s.ceiling(sumj - k);\\n            if(gap != null) max = Math.max(max, sumj - gap);\\n            s.add(t);\\n        }\\n\\n        return max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 83633,
                "title": "naive-but-accepted-java-solution",
                "content": "Well, I think that this is the most direct solution for this problem. We just add the numbers in every rectangle and find the sum closest but not larger than k. Since the array is 2-d, we have 4 points to decide the rectangle, the algorithm will be O(n^2).\\n\\n    public class Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        \\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\\n            return 0;\\n        }\\n        \\n        int[][] sums = new int[matrix.length][matrix[0].length];\\n        \\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[0].length; j++) {\\n                if (j == 0) {\\n                    sums[i][j] = matrix[i][j];\\n                } else {\\n                    sums[i][j] = sums[i][j - 1] + matrix[i][j];\\n                }\\n            }\\n        }\\n        \\n        /* O(n^4) loop */\\n        int max = 0;\\n        boolean firstMax = false;\\n        int tmpSum = 0;\\n        for (int i = 0; i < matrix[0].length; i++) {\\n            for (int j = i; j < matrix[0].length; j++) {\\n                for (int m = 0; m < matrix.length; m++) {\\n                    tmpSum = 0;\\n                    for (int n = m; n < matrix.length; n++) {\\n                        if (i == 0) {\\n                            tmpSum += sums[n][j];\\n                        } else {\\n                            tmpSum += sums[n][j] - sums[n][i - 1];\\n                        }\\n                        if (tmpSum > k) {\\n                            continue;\\n                        } else {\\n                            if (firstMax == false) {\\n                                max = tmpSum;\\n                                firstMax = true;\\n                            } else if ((k - tmpSum) < (k - max)) {\\n                                max = tmpSum;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        \\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3561775,
                "title": "363-max-sum-of-rectangle-no-larger-than-k",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n         int ans = INT_MIN, m = size(matrix), n = size(matrix[0]);\\n        for (int l = 0; l < n; l++) {\\n            vector<int>sums(m,0);\\n            for (int r = l; r < n; r++) {\\n                for (int i = 0; i < m; i++) sums[i] += matrix[i][r];\\n                for (int i = 0; i < m; i++) {\\n                    int sum = 0;\\n                    for (int j = i; j < m; j++) {\\n                        sum += sums[j];\\n                        if (sum > ans && sum <= k)                               ans = sum;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n         int ans = INT_MIN, m = size(matrix), n = size(matrix[0]);\\n        for (int l = 0; l < n; l++) {\\n            vector<int>sums(m,0);\\n            for (int r = l; r < n; r++) {\\n                for (int i = 0; i < m; i++) sums[i] += matrix[i][r];\\n                for (int i = 0; i < m; i++) {\\n                    int sum = 0;\\n                    for (int j = i; j < m; j++) {\\n                        sum += sums[j];\\n                        if (sum > ans && sum <= k)                               ans = sum;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2518962,
                "title": "faster-than-87-solutions-not-showing-tle-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        int res = INT_MIN;\\n        for(int left = 0;left<m;left++){\\n           vector<int>sums(n);\\n            for(int col = left;col<m;col++){\\n                for(int row=0;row<n;row++){\\n                   sums[row]+=matrix[row][col];\\n                }\\n                    set<int>st ={0};\\n                    int run_sum = 0;\\n                    for(int sum :sums){\\n                        run_sum+=sum;\\n                        auto it = st.lower_bound(run_sum-k);\\n                        if(it!=end(st)){\\n                            res = max(res,run_sum-*it);\\n                            if(res==k){\\n                                return res; // doing this for handling TLE\\n                            }\\n                        }\\n                        st.insert(run_sum);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};\\n```\\n",
                "solutionTags": [
                    "Array",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        int res = INT_MIN;\\n        for(int left = 0;left<m;left++){\\n           vector<int>sums(n);\\n            for(int col = left;col<m;col++){\\n                for(int row=0;row<n;row++){\\n                   sums[row]+=matrix[row][col];\\n                }\\n                    set<int>st ={0};\\n                    int run_sum = 0;\\n                    for(int sum :sums){\\n                        run_sum+=sum;\\n                        auto it = st.lower_bound(run_sum-k);\\n                        if(it!=end(st)){\\n                            res = max(res,run_sum-*it);\\n                            if(res==k){\\n                                return res; // doing this for handling TLE\\n                            }\\n                        }\\n                        st.insert(run_sum);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2497970,
                "title": "wrong-test-case",
                "content": "For the case (Test cas number 20)\\ninput - [[5,-4,-3,4],[-3,-4,4,5],[5,1,5,-4]] and k =8\\nThe output expected answer is 8 - A lot of people are getting the answer 8 too especially if you are using a prefix sum method. I cannot for the life of me find the actual submatrix where 8 is the sum. Can anyone verify if this is a wrong testcase ?",
                "solutionTags": [],
                "code": "For the case (Test cas number 20)\\ninput - [[5,-4,-3,4],[-3,-4,4,5],[5,1,5,-4]] and k =8\\nThe output expected answer is 8 - A lot of people are getting the answer 8 too especially if you are using a prefix sum method. I cannot for the life of me find the actual submatrix where 8 is the sum. Can anyone verify if this is a wrong testcase ?",
                "codeTag": "Unknown"
            },
            {
                "id": 2495732,
                "title": "bfd-brute-force-deal-full-and-full-brute-force-and-nothing-else-beats-90-28-runtime",
                "content": "```\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int out =-100000-1;\\n        if(matrix.length==1){\\n            int [] arr = new int[matrix[0].length];\\n            for(int i=0;i<arr.length;i++){\\n                arr[i]=matrix[0][i];\\n            }\\n            if(desiredSum(arr,k)>out ){\\n                out = desiredSum(arr,k);\\n            }\\n            return (out);\\n        }\\n        else{\\n        for(int j=0;j<matrix.length;j++){\\n            int [] arr = new int[matrix[0].length];\\n            for(int i=0;i<arr.length;i++){\\n                arr[i]=matrix[j][i];\\n            }\\n            if(desiredSum(arr,k)>out ){\\n                out = desiredSum(arr,k);\\n            }\\n            for(int m=j+1;m<matrix.length;m++){\\n                for(int l=0;l<arr.length;l++){\\n                arr[l]=arr[l]+matrix[m][l];\\n                    }\\n            if(desiredSum(arr,k)>out ){\\n                out = desiredSum(arr,k);\\n            }\\n            }\\n        }\\n        return out;\\n        }\\n    }\\n    static int desiredSum (int[] A,int k){\\n        int out=-100000-1;\\n        \\n        for(int i=0;i<A.length;i++){\\n            int cursum = A[i];\\n            if(cursum>out&&cursum<=k){\\n                    out=cursum;\\n                }\\n            for(int j=i+1;j<A.length;j++){\\n                cursum = cursum+A[j];\\n                if(cursum>out&&cursum<=k){\\n                    out=cursum;\\n                }\\n            }\\n        }\\n        return out;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int out =-100000-1;\\n        if(matrix.length==1){\\n            int [] arr = new int[matrix[0].length];\\n            for(int i=0;i<arr.length;i++){\\n                arr[i]=matrix[0][i];\\n            }\\n            if(desiredSum(arr,k)>out ){\\n                out = desiredSum(arr,k);\\n            }\\n            return (out);\\n        }\\n        else{\\n        for(int j=0;j<matrix.length;j++){\\n            int [] arr = new int[matrix[0].length];\\n            for(int i=0;i<arr.length;i++){\\n                arr[i]=matrix[j][i];\\n            }\\n            if(desiredSum(arr,k)>out ){\\n                out = desiredSum(arr,k);\\n            }\\n            for(int m=j+1;m<matrix.length;m++){\\n                for(int l=0;l<arr.length;l++){\\n                arr[l]=arr[l]+matrix[m][l];\\n                    }\\n            if(desiredSum(arr,k)>out ){\\n                out = desiredSum(arr,k);\\n            }\\n            }\\n        }\\n        return out;\\n        }\\n    }\\n    static int desiredSum (int[] A,int k){\\n        int out=-100000-1;\\n        \\n        for(int i=0;i<A.length;i++){\\n            int cursum = A[i];\\n            if(cursum>out&&cursum<=k){\\n                    out=cursum;\\n                }\\n            for(int j=i+1;j<A.length;j++){\\n                cursum = cursum+A[j];\\n                if(cursum>out&&cursum<=k){\\n                    out=cursum;\\n                }\\n            }\\n        }\\n        return out;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2492688,
                "title": "ruby-o-n-2-m-log2-m-using-binary-search-with-comments",
                "content": "Seems like nobody except me has published a solution for Ruby. Nobody knows about `bsearch` method? Ok, here it is for you: [link](https://ruby-doc.org/core-3.1.2/doc/bsearch_rdoc.html).\\n\\n```ruby\\ndef max_sum_submatrix(matrix, k)\\n    m, n = matrix.length, matrix[0].length\\n    res = -Float::INFINITY\\n    # Lets iterate through start and last columns and then we\\'ll iterate through last rows setting boundaries to our rectangle.\\n    # We won\\'t iterate through start rows since we will find the most efficient start row with a binary search \\n    # that is way faster having complexity only O(log2(last_row)) instead of O(last_row).\\n    for start_col in (0...n)\\n        sum_row = Array.new(m, 0)   # There will be sums of elements in rows that are limited by the start and last columns.\\n        for last_col in (start_col...n)\\n            sum = 0     # Current sum of all sums of rows from 0 to last_row.\\n            accum_sums = [0] # It will be a sorted from min to max array of accumulated sums with size m + 1.\\n            for last_row in (0...m)\\n                sum += ( sum_row[last_row] += matrix[last_row][last_col] )\\n                # Now we want to find a minimum subsum to substract from sum so that (sum - subsub) <= k. Lets name it \\'excess\\'.\\n                excess = accum_sums.bsearch { |x| x >= sum - k }   \\n                unless excess.nil? # If excess == nil then it appeared to be imposible to achieve a condition (sum - subsub) <= k\\n                    res = [res, sum - excess].max\\n                end\\n                # Now we need to find an index to insert sum so that accum_sums array stayed sorted from min to max.\\n                idx = accum_sums.bsearch_index { |x| x >= sum }\\n                accum_sums.insert(idx || (last_row + 1), sum)\\n            end\\n        end\\n    end\\n    res\\nend\\n```\\n",
                "solutionTags": [
                    "Ruby",
                    "Binary Search"
                ],
                "code": "```ruby\\ndef max_sum_submatrix(matrix, k)\\n    m, n = matrix.length, matrix[0].length\\n    res = -Float::INFINITY\\n    # Lets iterate through start and last columns and then we\\'ll iterate through last rows setting boundaries to our rectangle.\\n    # We won\\'t iterate through start rows since we will find the most efficient start row with a binary search \\n    # that is way faster having complexity only O(log2(last_row)) instead of O(last_row).\\n    for start_col in (0...n)\\n        sum_row = Array.new(m, 0)   # There will be sums of elements in rows that are limited by the start and last columns.\\n        for last_col in (start_col...n)\\n            sum = 0     # Current sum of all sums of rows from 0 to last_row.\\n            accum_sums = [0] # It will be a sorted from min to max array of accumulated sums with size m + 1.\\n            for last_row in (0...m)\\n                sum += ( sum_row[last_row] += matrix[last_row][last_col] )\\n                # Now we want to find a minimum subsum to substract from sum so that (sum - subsub) <= k. Lets name it \\'excess\\'.\\n                excess = accum_sums.bsearch { |x| x >= sum - k }   \\n                unless excess.nil? # If excess == nil then it appeared to be imposible to achieve a condition (sum - subsub) <= k\\n                    res = [res, sum - excess].max\\n                end\\n                # Now we need to find an index to insert sum so that accum_sums array stayed sorted from min to max.\\n                idx = accum_sums.bsearch_index { |x| x >= sum }\\n                accum_sums.insert(idx || (last_row + 1), sum)\\n            end\\n        end\\n    end\\n    res\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2492234,
                "title": "ruby-o-n-2-m-2",
                "content": "```ruby\\ndef max_sum_submatrix(matrix, k)\\n    m, n = matrix.length, matrix[0].length\\n    res = -Float::INFINITY\\n    for start_col in (0...n)\\n        sum_row = Array.new(m, 0)\\n        for last_col in (start_col...n)\\n            for row in (0...m)\\n                sum_row[row] += matrix[row][last_col]\\n            end\\n            for start_row in (0...m)\\n                sum = 0\\n                for last_row in (start_row...m)\\n                    sum += sum_row[last_row]\\n                    sum == k ? (return k) : (sum < k && sum > res && res = sum)\\n                end\\n            end\\n        end\\n    end\\n    res\\nend\\n```\\nMy another one ruby solution (more optimized using binary search) you can find here: [link](https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/discuss/2492688/Ruby-or-O(n2-*-m-*-log2(m))-using-binary-search.-With-comments!).",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef max_sum_submatrix(matrix, k)\\n    m, n = matrix.length, matrix[0].length\\n    res = -Float::INFINITY\\n    for start_col in (0...n)\\n        sum_row = Array.new(m, 0)\\n        for last_col in (start_col...n)\\n            for row in (0...m)\\n                sum_row[row] += matrix[row][last_col]\\n            end\\n            for start_row in (0...m)\\n                sum = 0\\n                for last_row in (start_row...m)\\n                    sum += sum_row[last_row]\\n                    sum == k ? (return k) : (sum < k && sum > res && res = sum)\\n                end\\n            end\\n        end\\n    end\\n    res\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2492089,
                "title": "typescript-100-faster-and-100-memory-efficient",
                "content": "```\\nfunction maxSumSubmatrix(matrix: number[][], k: number): number {\\n    // Idea:\\n    // calculate sum of the rectangle from [0,0] to [i,j]\\n    // then calculate sum of rectangles from [x1,y1] to [x2,y2] using the previously calculated sum in O(1)\\n\\n    const m = matrix.length, n = matrix[0].length;\\n    const MIN_VAL = -100 * m * n;\\n\\n    // Calculate row-wise cummilitive sum\\n    const rowCSum: number[][] = []; // O(m*n)\\n    for (let i = 0; i < m; i++) { // O(m*n)\\n        rowCSum[i] = [];\\n        rowCSum[i][0] = matrix[i][0];\\n        for (let j = 1; j < n; j++) {\\n            rowCSum[i][j] = rowCSum[i][j - 1] + matrix[i][j];\\n        }\\n    }\\n\\n    const sums: number[][] = rowCSum.map(row => row.map(col => col)); // O(m*n)\\n\\n    for (let c = 0; c < n; c++) { // O(m*n)\\n        for (let r = 1; r < m; r++) {\\n            sums[r][c] = sums[r - 1][c] + rowCSum[r][c];\\n        }\\n    }\\n\\n    let ans = MIN_VAL;\\n    let reg = {};\\n\\n    // O(m^2*n^2)\\n    for (let x1 = 0; x1 < m; x1++) {\\n        for (let y1 = 0; y1 < n; y1++) {\\n            for (let x2 = x1; x2 < m; x2++) {\\n                for (let y2 = y1; y2 < n; y2++) {\\n                    let t = sums[x2][y2];\\n                    if (x1 > 0) t -= sums[x1 - 1][y2];\\n                    if (y1 > 0) t -= sums[x2][y1 - 1];\\n\\n                    if (x1 > 0 && y1 > 0) t += sums[x1 - 1][y1 - 1];\\n\\n                    if (t === k) return t;\\n                    if (t <= k && ans < t) { ans = t; reg = { x1, y1, x2, y2 } }\\n                }\\n            }\\n        }\\n    }\\n\\n    return ans;\\n};\\n```\\n\\nTime complexity: O(m^2 * n^2)\\nSpace: O(m*n) + O(m*n)",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction maxSumSubmatrix(matrix: number[][], k: number): number {\\n    // Idea:\\n    // calculate sum of the rectangle from [0,0] to [i,j]\\n    // then calculate sum of rectangles from [x1,y1] to [x2,y2] using the previously calculated sum in O(1)\\n\\n    const m = matrix.length, n = matrix[0].length;\\n    const MIN_VAL = -100 * m * n;\\n\\n    // Calculate row-wise cummilitive sum\\n    const rowCSum: number[][] = []; // O(m*n)\\n    for (let i = 0; i < m; i++) { // O(m*n)\\n        rowCSum[i] = [];\\n        rowCSum[i][0] = matrix[i][0];\\n        for (let j = 1; j < n; j++) {\\n            rowCSum[i][j] = rowCSum[i][j - 1] + matrix[i][j];\\n        }\\n    }\\n\\n    const sums: number[][] = rowCSum.map(row => row.map(col => col)); // O(m*n)\\n\\n    for (let c = 0; c < n; c++) { // O(m*n)\\n        for (let r = 1; r < m; r++) {\\n            sums[r][c] = sums[r - 1][c] + rowCSum[r][c];\\n        }\\n    }\\n\\n    let ans = MIN_VAL;\\n    let reg = {};\\n\\n    // O(m^2*n^2)\\n    for (let x1 = 0; x1 < m; x1++) {\\n        for (let y1 = 0; y1 < n; y1++) {\\n            for (let x2 = x1; x2 < m; x2++) {\\n                for (let y2 = y1; y2 < n; y2++) {\\n                    let t = sums[x2][y2];\\n                    if (x1 > 0) t -= sums[x1 - 1][y2];\\n                    if (y1 > 0) t -= sums[x2][y1 - 1];\\n\\n                    if (x1 > 0 && y1 > 0) t += sums[x1 - 1][y1 - 1];\\n\\n                    if (t === k) return t;\\n                    if (t <= k && ans < t) { ans = t; reg = { x1, y1, x2, y2 } }\\n                }\\n            }\\n        }\\n    }\\n\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2492027,
                "title": "max-sum-of-rectangle-no-longer-than-k-upvote-if-you-find-helpfull",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int tar) {\\n        int m=matrix.size(),n=matrix[0].size();\\n        vector<vector<int>>dp(m+1,vector<int>(n,0));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                dp[i+1][j]=dp[i][j]+matrix[i][j];\\n            }\\n        }\\n        int ans=INT_MIN;\\n        for(int i=0;i<m;i++){\\n            for(int l=i+1;l<=m;l++){\\n                for(int j=0;j<n;j++){\\n                    int val=0;\\n                    for(int k=j;k<n;k++){\\n                        val+=dp[l][k]-dp[i][k];\\n                        \\n                        if(val<tar){\\n                            ans=max(ans,val);\\n                        }\\n                        else if(val==tar){\\n                            return tar;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int tar) {\\n        int m=matrix.size(),n=matrix[0].size();\\n        vector<vector<int>>dp(m+1,vector<int>(n,0));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                dp[i+1][j]=dp[i][j]+matrix[i][j];\\n            }\\n        }\\n        int ans=INT_MIN;\\n        for(int i=0;i<m;i++){\\n            for(int l=i+1;l<=m;l++){\\n                for(int j=0;j<n;j++){\\n                    int val=0;\\n                    for(int k=j;k<n;k++){\\n                        val+=dp[l][k]-dp[i][k];\\n                        \\n                        if(val<tar){\\n                            ans=max(ans,val);\\n                        }\\n                        else if(val==tar){\\n                            return tar;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2491727,
                "title": "java-prefixsum",
                "content": "```\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int n = matrix.length, m = matrix[0].length;\\n        int[][] prefix = calculatePrefix(matrix);\\n        int answer = -100_001;\\n        for (int sr = 0; sr < n; sr++) {\\n            for (int er = sr; er < n; er++) {\\n                for (int sc = 0; sc < m; sc++) {\\n                    for (int ec = sc; ec < m; ec++) {\\n                        //  find the sum of the rectangle [sr, sc] and [er, ec] both inclusive\\n                        int sum = prefix[er + 1][ec + 1] - prefix[sr][ec + 1] - prefix[er + 1][sc] + prefix[sr][sc];\\n                        if (sum <= k && sum > answer) {\\n                            answer = sum;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return answer;\\n    }\\n    \\n    public int[][] calculatePrefix(int[][] a) {\\n        int n = a.length, m = a[0].length;\\n        int[][] answer = new int[n+1][m+1];\\n        //  at answer[i][j] -> sum of submatrix starting at (0,0) ending at (i - 1) and (j - 1)\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= m; j++) {\\n                answer[i][j] = answer[i-1][j] + answer[i][j-1] - answer[i-1][j-1] + a[i-1][j-1];\\n            }\\n        }\\n        return answer;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int n = matrix.length, m = matrix[0].length;\\n        int[][] prefix = calculatePrefix(matrix);\\n        int answer = -100_001;\\n        for (int sr = 0; sr < n; sr++) {\\n            for (int er = sr; er < n; er++) {\\n                for (int sc = 0; sc < m; sc++) {\\n                    for (int ec = sc; ec < m; ec++) {\\n                        //  find the sum of the rectangle [sr, sc] and [er, ec] both inclusive\\n                        int sum = prefix[er + 1][ec + 1] - prefix[sr][ec + 1] - prefix[er + 1][sc] + prefix[sr][sc];\\n                        if (sum <= k && sum > answer) {\\n                            answer = sum;\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 2491601,
                "title": "rust-functional-style",
                "content": "```\\nuse std::collections::BTreeSet;\\n\\nimpl Solution {\\n    pub fn max_sum_submatrix(matrix: Vec<Vec<i32>>, k: i32) -> i32 {\\n        let mut set = BTreeSet::<i32>::new();\\n        let (n, m) = (matrix.len(), matrix[0].len());\\n        (0..n).map(|i| {\\n            let mut acc = vec![0; m];\\n            matrix.iter().skip(i).map(|row| {\\n                set.clear();\\n                set.insert(0);\\n                let mut prefix_sum = 0;\\n                acc.iter_mut().zip(row.iter()).map(|(a, r)| {\\n                    *a += r;\\n                    prefix_sum += *a;\\n                    let rez = set.range(prefix_sum - k..).next().map(|s| prefix_sum - *s);\\n                    set.insert(prefix_sum);\\n                    rez\\n                }).max()\\n            }).max()\\n        }).max().unwrap().unwrap().unwrap().unwrap()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::BTreeSet;\\n\\nimpl Solution {\\n    pub fn max_sum_submatrix(matrix: Vec<Vec<i32>>, k: i32) -> i32 {\\n        let mut set = BTreeSet::<i32>::new();\\n        let (n, m) = (matrix.len(), matrix[0].len());\\n        (0..n).map(|i| {\\n            let mut acc = vec![0; m];\\n            matrix.iter().skip(i).map(|row| {\\n                set.clear();\\n                set.insert(0);\\n                let mut prefix_sum = 0;\\n                acc.iter_mut().zip(row.iter()).map(|(a, r)| {\\n                    *a += r;\\n                    prefix_sum += *a;\\n                    let rez = set.range(prefix_sum - k..).next().map(|s| prefix_sum - *s);\\n                    set.insert(prefix_sum);\\n                    rez\\n                }).max()\\n            }).max()\\n        }).max().unwrap().unwrap().unwrap().unwrap()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2491465,
                "title": "dp-vertical-prefix-same-logic-in-c-go-javascript-but-python-give-tle",
                "content": "# C++\\n```cpp\\nclass Solution {\\n\\n#define vvi vector<vector<int>>\\n#define vi vector<int>\\n\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& grid, int k)\\n    {\\n        int     C = grid[0].size();\\n        int     R = grid.size();\\n        int     i, j, ii, jj, tmp, r;\\n        vvi     dp(R + 1, vi(C, 0));\\n\\n        /*  \\n        *   step 1: make a dp grid of (r + 1) x c\\n        *   set to \\'cascading\\' prefix sum\\n        */\\n\\n        i = -1;\\n        while (++i < R)\\n        {\\n            j = -1;\\n            while (++j < C)\\n                dp[i + 1][j] = dp[i][j] + grid[i][j];\\n        }\\n        vvip(dp, R + 1, C); // printer\\n\\n        /*  \\n        *   step 2: traversing/squeezing in from top-left to bottom-right\\n        *   find sum that equals k\\n        *   if not found, let res = max(res, sum)\\n        */\\n\\n        r = -2147483648;\\n        i = -1;\\n        while (++i < R)\\n        {\\n            ii = i;\\n            while (++ii < R + 1)\\n            {\\n                j = -1;\\n                while (++j < C)\\n                {\\n                    tmp = 0;\\n                    jj = j - 1;\\n                    while (++jj < C)\\n                    {\\n                        tmp += dp[ii][jj] - dp[i][jj];\\n                        if (tmp == k)\\n                            return k;\\n                        if (tmp < k && r < tmp)\\n                            r = tmp;\\n                    }\\n                }\\n            }\\n        }\\n        return r;\\n    }\\n\\n    void    vvip(vvi dp, int r, int c)\\n    {\\n        int     i = -1, j;\\n\\n        while (++i < r)\\n        {\\n            j = -1;\\n            while (++j < c)\\n                cout << dp[i][j] << \\' \\';\\n            cout << \\'\\\\n\\';\\n        }\\n        cout << \\'\\\\n\\';\\n    }\\n};\\n\\n/*\\n[[1,0,1],[0,-2,3],[2,6,-6]]\\n2\\n[[1,0,1],[0,-2,3],[-10,-12,-1]]\\n2\\n*/\\n```\\n# Go\\n```cpp\\nfunc maxSumSubmatrix(grid [][]int, k int) int {\\n    r := len(grid)\\n    c := len(grid[0])\\n    dp := make([][] int, r + 1)\\n    for i := range dp {\\n        dp[i] = make([] int, c)\\n    }\\n    // fmt.Print(dp)\\n    for i := 0; i < r; i++ {\\n        for j := 0; j < c; j++ {\\n            dp[i + 1][j] = dp[i][j] + grid[i][j]\\n        }\\n    }\\n    // fmt.Print(dp)\\n    res := -2147483648\\n    for i := 0; i < r; i++ {\\n        for ii := i + 1; ii < r + 1; ii++ {\\n            for j := 0; j < c; j++ {\\n                tmp := 0\\n                for jj := j; jj < c; jj++ {\\n                    tmp += dp[ii][jj] - dp[i][jj] // minus\\n                    if tmp == k {\\n                        return k\\n                    }\\n                    if tmp < k && res < tmp {\\n                        res = tmp\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return res\\n}\\n\\n/*\\n[[1,0,1],[0,-2,3]]\\n2\\n[[2,2,-1]]\\n3\\n[[2,2,-1]]\\n0\\n[[1,0,1],[0,-2,3],[2,6,-6]]\\n2\\n[[1,0,1],[0,-2,3],[-10,-12,-1]]\\n2\\n*/\\n```\\n# Javascript\\n```go\\n/**\\n * @param {number[][]} matrix\\n * @param {number} k\\n * @return {number}\\n */\\nvar maxSumSubmatrix = function(grid, k) {\\n    let c = grid[0].length\\n    let r = grid.length\\n    let i, j\\n    let dp = [...Array(r + 1)].map(e => Array(c).fill(0))\\n    // console.log(dp)\\n    i = -1;\\n    while (++i < r) {\\n        j = -1;\\n        while (++j < c)\\n            dp[i + 1][j] = dp[i][j] + grid[i][j];\\n    }\\n    // console.log(dp)\\n    let res = -2147483648;\\n    i = -1;\\n    while (++i < r) {\\n        let ii = i;\\n        while (++ii < r + 1) {\\n            j = -1;\\n            while (++j < c) {\\n                let tmp = 0;\\n                let jj = j - 1;\\n                while (++jj < c) {\\n                    tmp += dp[ii][jj] - dp[i][jj];\\n                    if (tmp == k)\\n                        return k;\\n                    if (tmp < k && res < tmp)\\n                        res = tmp;\\n                }\\n            }\\n        }\\n    }\\n    return res;\\n};\\n\\n/*\\n[[1,0,1],[0,-2,3]]\\n2\\n[[2,2,-1]]\\n3\\n[[2,2,-1]]\\n0\\n[[1,0,1],[0,-2,3],[2,6,-6]]\\n2\\n[[1,0,1],[0,-2,3],[-10,-12,-1]]\\n2\\n*/\\n```\\n\\n# Python \\n```rust\\nclass Solution:\\n    def maxSumSubmatrix(self, grid: List[List[int]], k: int) -> int:\\n        r = len(grid)\\n        c = len(grid[0])\\n        dp = [[0] * c for _ in range(r + 1)]\\n        for i in range(r):\\n            for j in range(c):\\n                dp[i + 1][j] = dp[i][j] + grid[i][j]\\n        res = -1e9\\n        for i in range(r):\\n            for ii in range(i + 1, r + 1): # 2 vertical idx\\n                for j in range(c):\\n                    val = 0\\n                    for jj in range(j, c):\\n                        val += dp[ii][jj] - dp[i][jj]\\n                        if val == k:\\n                            return k\\n                        if val < k and val > res:\\n                            res = val\\n        return res\\n\\n\\n\"\"\"\\n[[1,0,1],[0,-2,3]]\\n2\\n[[1,0,1],[0,-2,3],[2,6,-6]]\\n2\\n[[1,0,1],[0,-2,3],[-10,-12,-1]]\\n2\\n[[2,2,-1]]\\n0\\n\"\"\"\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "C",
                    "JavaScript",
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nclass Solution {\\n\\n#define vvi vector<vector<int>>\\n#define vi vector<int>\\n\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& grid, int k)\\n    {\\n        int     C = grid[0].size();\\n        int     R = grid.size();\\n        int     i, j, ii, jj, tmp, r;\\n        vvi     dp(R + 1, vi(C, 0));\\n\\n        /*  \\n        *   step 1: make a dp grid of (r + 1) x c\\n        *   set to \\'cascading\\' prefix sum\\n        */\\n\\n        i = -1;\\n        while (++i < R)\\n        {\\n            j = -1;\\n            while (++j < C)\\n                dp[i + 1][j] = dp[i][j] + grid[i][j];\\n        }\\n        vvip(dp, R + 1, C); // printer\\n\\n        /*  \\n        *   step 2: traversing/squeezing in from top-left to bottom-right\\n        *   find sum that equals k\\n        *   if not found, let res = max(res, sum)\\n        */\\n\\n        r = -2147483648;\\n        i = -1;\\n        while (++i < R)\\n        {\\n            ii = i;\\n            while (++ii < R + 1)\\n            {\\n                j = -1;\\n                while (++j < C)\\n                {\\n                    tmp = 0;\\n                    jj = j - 1;\\n                    while (++jj < C)\\n                    {\\n                        tmp += dp[ii][jj] - dp[i][jj];\\n                        if (tmp == k)\\n                            return k;\\n                        if (tmp < k && r < tmp)\\n                            r = tmp;\\n                    }\\n                }\\n            }\\n        }\\n        return r;\\n    }\\n\\n    void    vvip(vvi dp, int r, int c)\\n    {\\n        int     i = -1, j;\\n\\n        while (++i < r)\\n        {\\n            j = -1;\\n            while (++j < c)\\n                cout << dp[i][j] << \\' \\';\\n            cout << \\'\\\\n\\';\\n        }\\n        cout << \\'\\\\n\\';\\n    }\\n};\\n\\n/*\\n[[1,0,1],[0,-2,3],[2,6,-6]]\\n2\\n[[1,0,1],[0,-2,3],[-10,-12,-1]]\\n2\\n*/\\n```\n```cpp\\nfunc maxSumSubmatrix(grid [][]int, k int) int {\\n    r := len(grid)\\n    c := len(grid[0])\\n    dp := make([][] int, r + 1)\\n    for i := range dp {\\n        dp[i] = make([] int, c)\\n    }\\n    // fmt.Print(dp)\\n    for i := 0; i < r; i++ {\\n        for j := 0; j < c; j++ {\\n            dp[i + 1][j] = dp[i][j] + grid[i][j]\\n        }\\n    }\\n    // fmt.Print(dp)\\n    res := -2147483648\\n    for i := 0; i < r; i++ {\\n        for ii := i + 1; ii < r + 1; ii++ {\\n            for j := 0; j < c; j++ {\\n                tmp := 0\\n                for jj := j; jj < c; jj++ {\\n                    tmp += dp[ii][jj] - dp[i][jj] // minus\\n                    if tmp == k {\\n                        return k\\n                    }\\n                    if tmp < k && res < tmp {\\n                        res = tmp\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return res\\n}\\n\\n/*\\n[[1,0,1],[0,-2,3]]\\n2\\n[[2,2,-1]]\\n3\\n[[2,2,-1]]\\n0\\n[[1,0,1],[0,-2,3],[2,6,-6]]\\n2\\n[[1,0,1],[0,-2,3],[-10,-12,-1]]\\n2\\n*/\\n```\n```go\\n/**\\n * @param {number[][]} matrix\\n * @param {number} k\\n * @return {number}\\n */\\nvar maxSumSubmatrix = function(grid, k) {\\n    let c = grid[0].length\\n    let r = grid.length\\n    let i, j\\n    let dp = [...Array(r + 1)].map(e => Array(c).fill(0))\\n    // console.log(dp)\\n    i = -1;\\n    while (++i < r) {\\n        j = -1;\\n        while (++j < c)\\n            dp[i + 1][j] = dp[i][j] + grid[i][j];\\n    }\\n    // console.log(dp)\\n    let res = -2147483648;\\n    i = -1;\\n    while (++i < r) {\\n        let ii = i;\\n        while (++ii < r + 1) {\\n            j = -1;\\n            while (++j < c) {\\n                let tmp = 0;\\n                let jj = j - 1;\\n                while (++jj < c) {\\n                    tmp += dp[ii][jj] - dp[i][jj];\\n                    if (tmp == k)\\n                        return k;\\n                    if (tmp < k && res < tmp)\\n                        res = tmp;\\n                }\\n            }\\n        }\\n    }\\n    return res;\\n};\\n\\n/*\\n[[1,0,1],[0,-2,3]]\\n2\\n[[2,2,-1]]\\n3\\n[[2,2,-1]]\\n0\\n[[1,0,1],[0,-2,3],[2,6,-6]]\\n2\\n[[1,0,1],[0,-2,3],[-10,-12,-1]]\\n2\\n*/\\n```\n```rust\\nclass Solution:\\n    def maxSumSubmatrix(self, grid: List[List[int]], k: int) -> int:\\n        r = len(grid)\\n        c = len(grid[0])\\n        dp = [[0] * c for _ in range(r + 1)]\\n        for i in range(r):\\n            for j in range(c):\\n                dp[i + 1][j] = dp[i][j] + grid[i][j]\\n        res = -1e9\\n        for i in range(r):\\n            for ii in range(i + 1, r + 1): # 2 vertical idx\\n                for j in range(c):\\n                    val = 0\\n                    for jj in range(j, c):\\n                        val += dp[ii][jj] - dp[i][jj]\\n                        if val == k:\\n                            return k\\n                        if val < k and val > res:\\n                            res = val\\n        return res\\n\\n\\n\"\"\"\\n[[1,0,1],[0,-2,3]]\\n2\\n[[1,0,1],[0,-2,3],[2,6,-6]]\\n2\\n[[1,0,1],[0,-2,3],[-10,-12,-1]]\\n2\\n[[2,2,-1]]\\n0\\n\"\"\"\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2491303,
                "title": "c-solution-using-kadanes-algorithm",
                "content": "have used kadanes algorithm to find max sum in every column and to overcome the issue with kadanes algorithm ( when sum<0 case) have used set. \\n```\\n int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        if(matrix.empty())\\n            return 0;\\n        int sol = INT_MIN;\\n        int row= matrix.size(), column = matrix[0].size();\\n        for(int l=0;l<column;l++){\\n            vector<int> temp(row,0);\\n            for(int r=l; r<column;r++){\\n                for(int i=0;i<row;i++){\\n                    temp[i] += matrix[i][r];\\n                }\\n            set<int> accuSet;\\n            accuSet.insert(0);\\n            int sums = 0, max_sum = INT_MIN;\\n            for (int sum : temp) {\\n                sums += sum;\\n                set<int>::iterator it = accuSet.lower_bound(sums - k);\\n                if (it != accuSet.end()) max_sum = max(max_sum, sums - *it);\\n                accuSet.insert(sums);\\n            }\\n            sol = max(sol, max_sum);\\n            }\\n        }\\n        return sol;\\n    }\\n\\t```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\n int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        if(matrix.empty())\\n            return 0;\\n        int sol = INT_MIN;\\n        int row= matrix.size(), column = matrix[0].size();\\n        for(int l=0;l<column;l++){\\n            vector<int> temp(row,0);\\n            for(int r=l; r<column;r++){\\n                for(int i=0;i<row;i++){\\n                    temp[i] += matrix[i][r];\\n                }\\n            set<int> accuSet;\\n            accuSet.insert(0);\\n            int sums = 0, max_sum = INT_MIN;\\n            for (int sum : temp) {\\n                sums += sum;\\n                set<int>::iterator it = accuSet.lower_bound(sums - k);\\n                if (it != accuSet.end()) max_sum = max(max_sum, sums - *it);\\n                accuSet.insert(sums);\\n            }\\n            sol = max(sol, max_sum);\\n            }\\n        }\\n        return sol;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2491043,
                "title": "clean-simple-c-prefix-sum-solution-space-99",
                "content": "```\\nclass Solution {\\npublic:\\n  int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n      \\n    int n=matrix.size(), m = matrix[0].size();\\n    vector<vector<int>> cum(n, vector<int> (m, 0));\\n    //cum[i][j] gives area of rectangle from (0,0) to (i,j)\\n\\n    //Filling the cum matrix\\n    cum[0][0] = matrix[0][0];\\n\\n    //filling 0th row\\n    for(int row=1; row<n; row++){\\n      cum[row][0] = cum[row-1][0] + matrix[row][0];\\n    }\\n    //filling 0th col\\n    for(int col=1; col<m; col++){\\n      cum[0][col] = cum[0][col-1] + matrix[0][col];\\n    }     \\n\\n    for(int row=1; row<n; row++){\\n      for(int col=1; col<m; col++){\\n        cum[row][col] = matrix[row][col] + (cum[row][col-1] + cum[row-1][col] - cum[row-1][col-1]);\\n      }\\n    }\\n    //checking the values in cum matrix\\n    // for(int row=0; row<n; row++){\\n    //   for(int col=0; col<m; col++){\\n    //     cout<<cum[row][col]<<\" \";\\n    //   }cout<<endl;\\n    // }\\n\\n    int max_area = INT_MIN, cur_area;\\n\\n    for(int st_row=0; st_row<n; st_row++){\\n      for(int st_col=0; st_col<m; st_col++){\\n        \\n        for(int en_row=st_row; en_row<n; en_row++){\\n          for(int en_col=st_col; en_col<m; en_col++){\\n            \\n            cur_area = INT_MIN;\\n            \\n            if(en_row==st_row && en_col==st_col){\\n              cur_area = matrix[en_row][en_col]; //single ele max case \\n            }\\n            else{\\n              if(st_row==0 && st_col==0){\\n                cur_area = cum[en_row][en_col];\\n              }\\n              else if(st_row == 0){\\n                cur_area =  cum[en_row][en_col] - cum[en_row][st_col - 1];\\n              }\\n              else if(st_col == 0){\\n                cur_area = cum[en_row][en_col] - cum[st_row - 1][en_col];\\n              }\\n              else{\\n                cur_area = cum[en_row][en_col] - cum[en_row][st_col - 1] - cum[st_row - 1][en_col] + cum[st_row - 1][st_col - 1];\\n              }\\n            }\\n\\n            // cout<<cur_area<<\" \";\\n            if(cur_area <= k){\\n              max_area = max(max_area, cur_area);\\n            }\\n          }\\n        }\\n      }\\n    }\\n    return max_area;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n      \\n    int n=matrix.size(), m = matrix[0].size();\\n    vector<vector<int>> cum(n, vector<int> (m, 0));\\n    //cum[i][j] gives area of rectangle from (0,0) to (i,j)\\n\\n    //Filling the cum matrix\\n    cum[0][0] = matrix[0][0];\\n\\n    //filling 0th row\\n    for(int row=1; row<n; row++){\\n      cum[row][0] = cum[row-1][0] + matrix[row][0];\\n    }\\n    //filling 0th col\\n    for(int col=1; col<m; col++){\\n      cum[0][col] = cum[0][col-1] + matrix[0][col];\\n    }     \\n\\n    for(int row=1; row<n; row++){\\n      for(int col=1; col<m; col++){\\n        cum[row][col] = matrix[row][col] + (cum[row][col-1] + cum[row-1][col] - cum[row-1][col-1]);\\n      }\\n    }\\n    //checking the values in cum matrix\\n    // for(int row=0; row<n; row++){\\n    //   for(int col=0; col<m; col++){\\n    //     cout<<cum[row][col]<<\" \";\\n    //   }cout<<endl;\\n    // }\\n\\n    int max_area = INT_MIN, cur_area;\\n\\n    for(int st_row=0; st_row<n; st_row++){\\n      for(int st_col=0; st_col<m; st_col++){\\n        \\n        for(int en_row=st_row; en_row<n; en_row++){\\n          for(int en_col=st_col; en_col<m; en_col++){\\n            \\n            cur_area = INT_MIN;\\n            \\n            if(en_row==st_row && en_col==st_col){\\n              cur_area = matrix[en_row][en_col]; //single ele max case \\n            }\\n            else{\\n              if(st_row==0 && st_col==0){\\n                cur_area = cum[en_row][en_col];\\n              }\\n              else if(st_row == 0){\\n                cur_area =  cum[en_row][en_col] - cum[en_row][st_col - 1];\\n              }\\n              else if(st_col == 0){\\n                cur_area = cum[en_row][en_col] - cum[st_row - 1][en_col];\\n              }\\n              else{\\n                cur_area = cum[en_row][en_col] - cum[en_row][st_col - 1] - cum[st_row - 1][en_col] + cum[st_row - 1][st_col - 1];\\n              }\\n            }\\n\\n            // cout<<cur_area<<\" \";\\n            if(cur_area <= k){\\n              max_area = max(max_area, cur_area);\\n            }\\n          }\\n        }\\n      }\\n    }\\n    return max_area;\\n  }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2490720,
                "title": "elixir-rust-prefix-sum-solution",
                "content": "Similar as [1074. Number of Submatrices That Sum to Target](https://leetcode.com/problems/number-of-submatrices-that-sum-to-target/)\\n\\n```elixir\\ndefmodule Solution do\\n  @spec max_sum_submatrix(matrix :: [[integer]], k :: integer) :: integer\\n  def max_sum_submatrix(matrix, k) do\\n    m = length(matrix) - 1\\n    n = length(hd(matrix)) - 1\\n\\n    matrix =\\n      matrix\\n      |> Enum.with_index()\\n      |> Enum.reduce(%{}, fn {row, i}, acc ->\\n        row\\n        |> Enum.with_index()\\n        |> Enum.reduce(acc, fn {n, j}, acc ->\\n          if j == 0 do\\n            Map.put(acc, {i, j}, n)\\n          else\\n            Map.put(acc, {i, j}, n + acc[{i, j - 1}])\\n          end\\n        end)\\n      end)\\n\\n    for left <- 0..n, right <- left..n, reduce: -100_000 do\\n      ans ->\\n        for r <- 0..m, reduce: {ans, 0, :gb_sets.from_list([0])} do\\n          {ans, pre_sum, set} ->\\n            pre_sum = pre_sum + matrix[{r, right}] - Map.get(matrix, {r, left - 1}, 0)\\n            iter = :gb_sets.iterator_from(pre_sum - k, set)\\n\\n            ans =\\n              case :gb_sets.next(iter) do\\n                {sum, _} -> max(ans, pre_sum - sum)\\n                _ -> ans\\n              end\\n\\n            set = :gb_sets.add(pre_sum, set)\\n            {ans, pre_sum, set}\\n        end\\n        |> elem(0)\\n    end\\n  end\\nend\\n```\\n\\n```rust\\nuse std::collections::BTreeSet;\\nuse std::ops::Bound::Included;\\n\\nimpl Solution {\\n    pub fn max_sum_submatrix(mut matrix: Vec<Vec<i32>>, k: i32) -> i32 {\\n        for i in 0..matrix.len() {\\n            for j in 1..matrix[i].len() {\\n                matrix[i][j] += matrix[i][j - 1];\\n            }\\n        }\\n\\n        let mut ans = i32::MIN;\\n        for left in 0..matrix[0].len() {\\n            for right in left..matrix[0].len() {\\n                let mut set = BTreeSet::new();\\n                set.insert(0);\\n                let mut pre_sum = 0;\\n                for r in 0..matrix.len() {\\n                    pre_sum += matrix[r][right];\\n                    if left > 0 {\\n                        pre_sum -= matrix[r][left - 1];\\n                    }\\n                    if let Some(sum) = set.range(pre_sum - k..).next() {\\n                        ans = ans.max(pre_sum - sum);\\n                    }\\n\\n                    set.insert(pre_sum);\\n                }\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Elixir",
                    "Prefix Sum"
                ],
                "code": "```elixir\\ndefmodule Solution do\\n  @spec max_sum_submatrix(matrix :: [[integer]], k :: integer) :: integer\\n  def max_sum_submatrix(matrix, k) do\\n    m = length(matrix) - 1\\n    n = length(hd(matrix)) - 1\\n\\n    matrix =\\n      matrix\\n      |> Enum.with_index()\\n      |> Enum.reduce(%{}, fn {row, i}, acc ->\\n        row\\n        |> Enum.with_index()\\n        |> Enum.reduce(acc, fn {n, j}, acc ->\\n          if j == 0 do\\n            Map.put(acc, {i, j}, n)\\n          else\\n            Map.put(acc, {i, j}, n + acc[{i, j - 1}])\\n          end\\n        end)\\n      end)\\n\\n    for left <- 0..n, right <- left..n, reduce: -100_000 do\\n      ans ->\\n        for r <- 0..m, reduce: {ans, 0, :gb_sets.from_list([0])} do\\n          {ans, pre_sum, set} ->\\n            pre_sum = pre_sum + matrix[{r, right}] - Map.get(matrix, {r, left - 1}, 0)\\n            iter = :gb_sets.iterator_from(pre_sum - k, set)\\n\\n            ans =\\n              case :gb_sets.next(iter) do\\n                {sum, _} -> max(ans, pre_sum - sum)\\n                _ -> ans\\n              end\\n\\n            set = :gb_sets.add(pre_sum, set)\\n            {ans, pre_sum, set}\\n        end\\n        |> elem(0)\\n    end\\n  end\\nend\\n```\n```rust\\nuse std::collections::BTreeSet;\\nuse std::ops::Bound::Included;\\n\\nimpl Solution {\\n    pub fn max_sum_submatrix(mut matrix: Vec<Vec<i32>>, k: i32) -> i32 {\\n        for i in 0..matrix.len() {\\n            for j in 1..matrix[i].len() {\\n                matrix[i][j] += matrix[i][j - 1];\\n            }\\n        }\\n\\n        let mut ans = i32::MIN;\\n        for left in 0..matrix[0].len() {\\n            for right in left..matrix[0].len() {\\n                let mut set = BTreeSet::new();\\n                set.insert(0);\\n                let mut pre_sum = 0;\\n                for r in 0..matrix.len() {\\n                    pre_sum += matrix[r][right];\\n                    if left > 0 {\\n                        pre_sum -= matrix[r][left - 1];\\n                    }\\n                    if let Some(sum) = set.range(pre_sum - k..).next() {\\n                        ans = ans.max(pre_sum - sum);\\n                    }\\n\\n                    set.insert(pre_sum);\\n                }\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2490502,
                "title": "clean-python3-w-comments-prefix-sum-bisect-faster-than-97",
                "content": "Please Upvote if it helps! :)\\n```\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        rows, cols = len(matrix), len(matrix[0])\\n        prefix_sum = [[0] * (cols + 1) for _ in range(rows + 1)] #take advantage of -1 indexing\\n        # build prefix sum matrix, keeping track of the sum above and left of each index\\n        for row in range(rows):\\n            sum_left = 0\\n            for col in range(cols):\\n                sum_above = prefix_sum[row - 1][col]\\n                sum_left += matrix[row][col]\\n                prefix_sum[row][col] = sum_above + sum_left\\n                \\n        # fix start and end row, and for each traverse across the columns\\n        max_sum_lk = float(\\'-inf\\')\\n        for row1 in range(rows):\\n            for row2 in range(row1, rows):\\n                left_sums = [0]\\n                # binary search for a sum to the left that is as small as possible (because we are subtracting it),\\n                # such that the cumulative sum across all these columns minus that left sum is <= k\\n                for end_col in range(cols):\\n                    sum_here = prefix_sum[row2][end_col] - prefix_sum[row1 - 1][end_col]\\n                    \\n                    ins = bisect_right(left_sums, sum_here - k)\\n                    if ins > 0 and left_sums[ins - 1] == sum_here - k:\\n                        return k\\n                    elif ins <= end_col:\\n                        max_sum_lk = max(max_sum_lk, sum_here - left_sums[ins])\\n                        \\n                    insort(left_sums, sum_here)\\n\\n        return max_sum_lk",
                "solutionTags": [
                    "Python",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "Please Upvote if it helps! :)\\n```\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        rows, cols = len(matrix), len(matrix[0])\\n        prefix_sum = [[0] * (cols + 1) for _ in range(rows + 1)] #take advantage of -1 indexing\\n        # build prefix sum matrix, keeping track of the sum above and left of each index\\n        for row in range(rows):\\n            sum_left = 0\\n            for col in range(cols):\\n                sum_above = prefix_sum[row - 1][col]\\n                sum_left += matrix[row][col]\\n                prefix_sum[row][col] = sum_above + sum_left\\n                \\n        # fix start and end row, and for each traverse across the columns\\n        max_sum_lk = float(\\'-inf\\')\\n        for row1 in range(rows):\\n            for row2 in range(row1, rows):\\n                left_sums = [0]\\n                # binary search for a sum to the left that is as small as possible (because we are subtracting it),\\n                # such that the cumulative sum across all these columns minus that left sum is <= k\\n                for end_col in range(cols):\\n                    sum_here = prefix_sum[row2][end_col] - prefix_sum[row1 - 1][end_col]\\n                    \\n                    ins = bisect_right(left_sums, sum_here - k)\\n                    if ins > 0 and left_sums[ins - 1] == sum_here - k:\\n                        return k\\n                    elif ins <= end_col:\\n                        max_sum_lk = max(max_sum_lk, sum_here - left_sums[ins])\\n                        \\n                    insort(left_sums, sum_here)\\n\\n        return max_sum_lk",
                "codeTag": "Java"
            },
            {
                "id": 2490476,
                "title": "sliding-window-kadane-faster-than-88-c",
                "content": "Time Complexity: O(m^2 nlog(n))\\nSpace Complexity: O(n)\\n```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int ans = INT_MIN;\\n        for (int left = 0; left<m; left++){\\n            vector<int> col(n, 0);\\n            for(int right = left; right<m; right++){\\n                // Apply Kadane Algorithm\\n                int best = INT_MIN;\\n                int curr = 0;\\n                for(int i=0; i<n; i++){\\n                    col[i] += matrix[right][i];\\n                    curr += col[i];\\n                    if (curr == k){\\n                        return k;\\n                    }\\n                    best = max(best, curr);\\n                    if (curr<0){\\n                        curr = 0;\\n                    }\\n                }\\n                if (best<k){\\n                    ans = max(ans, best);\\n                    continue;\\n                }\\n                // If not find from kadane algorithm i.e. k is less than 0\\n                set<int> s;\\n                s.insert(0);\\n                curr = 0;\\n                for(int i=0; i<n; i++){\\n                    curr += col[i];\\n                    auto it = s.lower_bound(curr - k);\\n                    if (it != s.end()){\\n                        ans = max(ans, curr-*it);\\n                    }\\n                    s.insert(curr);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int ans = INT_MIN;\\n        for (int left = 0; left<m; left++){\\n            vector<int> col(n, 0);\\n            for(int right = left; right<m; right++){\\n                // Apply Kadane Algorithm\\n                int best = INT_MIN;\\n                int curr = 0;\\n                for(int i=0; i<n; i++){\\n                    col[i] += matrix[right][i];\\n                    curr += col[i];\\n                    if (curr == k){\\n                        return k;\\n                    }\\n                    best = max(best, curr);\\n                    if (curr<0){\\n                        curr = 0;\\n                    }\\n                }\\n                if (best<k){\\n                    ans = max(ans, best);\\n                    continue;\\n                }\\n                // If not find from kadane algorithm i.e. k is less than 0\\n                set<int> s;\\n                s.insert(0);\\n                curr = 0;\\n                for(int i=0; i<n; i++){\\n                    curr += col[i];\\n                    auto it = s.lower_bound(curr - k);\\n                    if (it != s.end()){\\n                        ans = max(ans, curr-*it);\\n                    }\\n                    s.insert(curr);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2490017,
                "title": "java-solution-not-that-easy-dry-run-the-code-you-ll-get-it-for-sure-d",
                "content": "### Please Upvote !!!\\n```\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int result = Integer.MIN_VALUE;\\n        int rows = matrix.length, cols = matrix[0].length;\\n\\n        for (int left = 0; left < cols; left++) {\\n            int[] sum = new int[rows];\\n\\n            for (int right = left; right < cols; right++) {\\n                for (int i = 0; i < rows; i++) {\\n                    sum[i] += matrix[i][right];\\n                }\\n                result = Math.max(result, validSum(sum, k));\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    int validSum(int[] arr, int k) {\\n        int max = Integer.MIN_VALUE;\\n\\n        for (int i = 0; i < arr.length; i++) {\\n            int sum = 0;\\n\\n            for (int j = i; j < arr.length; j++) {\\n                sum += arr[j];\\n                if (sum <= k) max = Math.max(max, sum);\\n            }\\n        }\\n\\n        return max;\\n    }\\n}\\n\\n/*\\n\\nTC:\\n\\nm = rows size\\nm = col size\\n\\nInside Helper :\\n-> n + (n-1) + (n-2) + ... + 1 = O(n^2)\\n\\nMain code :\\n-> m + (m-1) + (m-2) + ... + 1 = O(m^2)\\nAnd we are running m times for each loop\\n-> O(m^2 * n)\\n\\nAnd Helper also we are running for all O(n^2) times\\nSo, O(m^2 * n + m^2 * n^2) will be time complexity\\nTherefore, roughly \\'O(m^2 * n^2)\\'\\n\\n\\n\\nSC: O(m)\\nm -> Number of rows\\n\\n*/\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int result = Integer.MIN_VALUE;\\n        int rows = matrix.length, cols = matrix[0].length;\\n\\n        for (int left = 0; left < cols; left++) {\\n            int[] sum = new int[rows];\\n\\n            for (int right = left; right < cols; right++) {\\n                for (int i = 0; i < rows; i++) {\\n                    sum[i] += matrix[i][right];\\n                }\\n                result = Math.max(result, validSum(sum, k));\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    int validSum(int[] arr, int k) {\\n        int max = Integer.MIN_VALUE;\\n\\n        for (int i = 0; i < arr.length; i++) {\\n            int sum = 0;\\n\\n            for (int j = i; j < arr.length; j++) {\\n                sum += arr[j];\\n                if (sum <= k) max = Math.max(max, sum);\\n            }\\n        }\\n\\n        return max;\\n    }\\n}\\n\\n/*\\n\\nTC:\\n\\nm = rows size\\nm = col size\\n\\nInside Helper :\\n-> n + (n-1) + (n-2) + ... + 1 = O(n^2)\\n\\nMain code :\\n-> m + (m-1) + (m-2) + ... + 1 = O(m^2)\\nAnd we are running m times for each loop\\n-> O(m^2 * n)\\n\\nAnd Helper also we are running for all O(n^2) times\\nSo, O(m^2 * n + m^2 * n^2) will be time complexity\\nTherefore, roughly \\'O(m^2 * n^2)\\'\\n\\n\\n\\nSC: O(m)\\nm -> Number of rows\\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2490003,
                "title": "java-code-with-explanation",
                "content": "**Explanation to the solution** Feel free to ask doubts\\n\\nGiven m*n matrix and an integer k\\nso we will start with columns and find the maximum sum of that column taking care that sum<=k(we can do this using Kadane algorithm)\\nand this process will be followed for all the rows i.e for(row=0 to row<row.count) and for each row we will iterate through all the columns ie. for(col=0 to col<col.count)\\nwe will create an array for each row and will store the sum of each column in it one by one i.e., col++\\nand with this array we will find the max sum as long as it is less than equal to k\\nDry run it once for urself\\n**upvote if it helped**\\n\\n----------------------------------code------------------------------------------------------\\nclass Solution {\\npublic int maxSumSubmatrix(int[][] matrix, int k) {\\nint n=matrix.length;\\nint m=matrix[0].length;\\nint max=Integer.MIN_VALUE;\\nfor(int row=0;row<n;row++)\\n{\\nint arr[]=new int[m];\\nfor(int col=row;col<n;col++)\\n{\\nfor(int x=0;x<m;x++)\\narr[x]+=matrix[col][x];\\n\\n            int sum=kadaneHelper(arr,k);\\n            max=Math.max(max,sum);\\n        }\\n    }\\n    return max;\\n}\\n\\npublic int kadaneHelper(int arr[],int k)\\n{\\n    int res=Integer.MIN_VALUE;\\n    \\n    for(int i=0;i<arr.length;i++)\\n    {\\n        int sum=0;\\n        for(int j=i;j<arr.length;j++)\\n        {\\n            sum+=arr[j];\\n            if(sum<=k)\\n            res=Math.max(res,sum);\\n        }\\n    }\\n    return res;\\n}\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\npublic int maxSumSubmatrix(int[][] matrix, int k) {\\nint n=matrix.length;\\nint m=matrix[0].length;\\nint max=Integer.MIN_VALUE;\\nfor(int row=0;row<n;row++)\\n{\\nint arr[]=new int[m];\\nfor(int col=row;col<n;col++)\\n{\\nfor(int x=0;x<m;x++)\\narr[x]+=matrix[col][x];\\n\\n            int sum=kadaneHelper(arr,k);\\n            max=Math.max(max,sum);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2489863,
                "title": "c-naive-faster-than-100-solution",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int m = matrix.size(), n = matrix[0].size();\\n        for(int i = 0;i < m;++i)\\n            for(int j = 1;j < n;++j)\\n                matrix[i][j] += matrix[i][j-1];\\n        int prefix[n+1];\\n        int ans = INT_MIN;\\n        for(int up = 0;up < m;++up){\\n            memset(prefix, 0, sizeof(prefix));\\n            for(int down = up;down < m;++down){\\n                for(int j = 1;j <= n;++j){\\n                    prefix[j] += matrix[down][j-1];\\n                    for(int col = 0;col < j;++col)\\n                        if((prefix[j] - prefix[col]) > ans && (prefix[j] - prefix[col]) <= k)\\n                            ans = prefix[j] - prefix[col];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nTime Complexity : O((mn)^2)\\nSpace Complexity : O(n)",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int m = matrix.size(), n = matrix[0].size();\\n        for(int i = 0;i < m;++i)\\n            for(int j = 1;j < n;++j)\\n                matrix[i][j] += matrix[i][j-1];\\n        int prefix[n+1];\\n        int ans = INT_MIN;\\n        for(int up = 0;up < m;++up){\\n            memset(prefix, 0, sizeof(prefix));\\n            for(int down = up;down < m;++down){\\n                for(int j = 1;j <= n;++j){\\n                    prefix[j] += matrix[down][j-1];\\n                    for(int col = 0;col < j;++col)\\n                        if((prefix[j] - prefix[col]) > ans && (prefix[j] - prefix[col]) <= k)\\n                            ans = prefix[j] - prefix[col];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2489831,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& mat, int k) {\\n        int ans=INT_MIN;    \\n        int n=mat.size();\\n        int m=mat[0].size();\\n        vector<vector<int>> pre=mat;\\n        for(int col=0;col<m;col++){\\n            for(int row=1;row<n;row++){\\n                pre[row][col]+=pre[row-1][col];\\n            }\\n        }\\n        for(int col=0;col<m;col++){\\n            vector<int> temp(n);\\n            for(int c=col;c<m;c++){\\n                set<int> s; s.insert(0);\\n                for(int r=0;r<n;r++){\\n                    if(c==col){\\n                        temp[r]=pre[r][c];\\n                    }\\n                    else{\\n                        temp[r]+=pre[r][c];\\n                    } \\n                    auto itr=s.lower_bound(temp[r]-k);\\n                    if(itr!=s.end()) ans=max(ans,temp[r]-(*itr)); \\n                    s.insert(temp[r]);\\n                }\\n            }            \\n        } \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& mat, int k) {\\n        int ans=INT_MIN;    \\n        int n=mat.size();\\n        int m=mat[0].size();\\n        vector<vector<int>> pre=mat;\\n        for(int col=0;col<m;col++){\\n            for(int row=1;row<n;row++){\\n                pre[row][col]+=pre[row-1][col];\\n            }\\n        }\\n        for(int col=0;col<m;col++){\\n            vector<int> temp(n);\\n            for(int c=col;c<m;c++){\\n                set<int> s; s.insert(0);\\n                for(int r=0;r<n;r++){\\n                    if(c==col){\\n                        temp[r]=pre[r][c];\\n                    }\\n                    else{\\n                        temp[r]+=pre[r][c];\\n                    } \\n                    auto itr=s.lower_bound(temp[r]-k);\\n                    if(itr!=s.end()) ans=max(ans,temp[r]-(*itr)); \\n                    s.insert(temp[r]);\\n                }\\n            }            \\n        } \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2489824,
                "title": "daily-leetcode-challenge-august-27",
                "content": "class Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int t) {\\n       int m=matrix.size(),n=matrix[0].size();\\n        vector<vector<int>>dp(m+1,vector<int>(n,0));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                dp[i+1][j]=dp[i][j]+matrix[i][j];\\n            }\\n        }\\n        int ans=INT_MIN;\\n        for(int i=0;i<m;i++){\\n            for(int l=i+1;l<=m;l++){\\n                for(int j=0;j<n;j++){\\n                    int val=0;\\n                    for(int k=j;k<n;k++){\\n                        val+=dp[l][k]-dp[i][k];\\n                        \\n                        if(val<t){\\n                            ans=max(ans,val);\\n                        }\\n                        else if(val==t){\\n                            return t;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n};\\n ****please upvote if u found this code useful****",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int t) {\\n       int m=matrix.size(),n=matrix[0].size();\\n        vector<vector<int>>dp(m+1,vector<int>(n,0));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                dp[i+1][j]=dp[i][j]+matrix[i][j];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2489544,
                "title": "swift-solution-using-subsums",
                "content": "```\\nclass Solution {\\n    func maxSumSubmatrix(_ matrix: [[Int]], _ k: Int) -> Int {\\n        var subSums: [[Int]] = .init(repeating: .init(repeating: 0, count: matrix[0].count + 1), count: matrix.count + 1)\\n        var res = Int.min\\n        for y in 1...matrix.count {\\n            for x in 1...matrix[0].count {\\n                subSums[y][x] = matrix[y - 1][x - 1]\\n                subSums[y][x] += subSums[y - 1][x]\\n                subSums[y][x] += subSums[y][x - 1]\\n                subSums[y][x] -= subSums[y - 1][x - 1]\\n            }\\n        }\\n        for y in 0...matrix.count {\\n            for x in 0...matrix[0].count {\\n                for g in 0..<y {\\n                    for h in 0..<x {\\n                        let temp = subSums[y][x] - (subSums[y][h] + subSums[g][x] - subSums[g][h])\\n                        if temp <= k {\\n                            res = max(res, temp)\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maxSumSubmatrix(_ matrix: [[Int]], _ k: Int) -> Int {\\n        var subSums: [[Int]] = .init(repeating: .init(repeating: 0, count: matrix[0].count + 1), count: matrix.count + 1)\\n        var res = Int.min\\n        for y in 1...matrix.count {\\n            for x in 1...matrix[0].count {\\n                subSums[y][x] = matrix[y - 1][x - 1]\\n                subSums[y][x] += subSums[y - 1][x]\\n                subSums[y][x] += subSums[y][x - 1]\\n                subSums[y][x] -= subSums[y - 1][x - 1]\\n            }\\n        }\\n        for y in 0...matrix.count {\\n            for x in 0...matrix[0].count {\\n                for g in 0..<y {\\n                    for h in 0..<x {\\n                        let temp = subSums[y][x] - (subSums[y][h] + subSums[g][x] - subSums[g][h])\\n                        if temp <= k {\\n                            res = max(res, temp)\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2488541,
                "title": "python-3-built-in-function-necessary",
                "content": "I took the standard-solution approach. However I found the usage of the built-in `bisect_left` function seem to be necessary to pass the tests. I tried replacing `bisect_left` with a standard binary search implementation (`i` `j` pointers) and it got TLE. Doing it by hand is a lot slower than using built-ins I guess... \\n\\n```\\nfrom sortedcontainers import SortedSet\\n\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        m, n = len(matrix), len(matrix[0])\\n        \\n\\t\\t# Function to find the subarray sum that is closest to U in the given 1-D array \"psr\"\\n        def maxSumSubarray(psr, U: int) -> int:\\n            ss, ans = SortedSet([0]), -999999\\n            for c in range(n):\\n                diff = psr[c] - U\\n                if diff == 0: return U\\n                idx = ss.bisect_left(diff)\\n                if idx < len(ss): ans = max(ans, psr[c]-ss[idx])\\n                ss.add(psr[c])\\n            return ans\\n        \\n        res = -999999\\n        \\n        # construct row-wise prefix sum matrix\\n        ps = [[] for x in range(m)]\\n        for r in range(m):\\n            ps[r].append(matrix[r][0])\\n            for c in range(1, n):\\n                ps[r].append(ps[r][-1]+matrix[r][c])\\n        \\n\\t\\t# Run over merged rows\\n        for router in range(m):\\n            psr = [0 for x in range(n)]\\n            for rinner in range(router, m):\\n                psr = [ x+y for x, y in zip(psr, ps[rinner]) ]  \\n                res = max(maxSumSubarray(psr, k), res)\\n                if res == k: return k\\n                \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nfrom sortedcontainers import SortedSet\\n\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        m, n = len(matrix), len(matrix[0])\\n        \\n\\t\\t# Function to find the subarray sum that is closest to U in the given 1-D array \"psr\"\\n        def maxSumSubarray(psr, U: int) -> int:\\n            ss, ans = SortedSet([0]), -999999\\n            for c in range(n):\\n                diff = psr[c] - U\\n                if diff == 0: return U\\n                idx = ss.bisect_left(diff)\\n                if idx < len(ss): ans = max(ans, psr[c]-ss[idx])\\n                ss.add(psr[c])\\n            return ans\\n        \\n        res = -999999\\n        \\n        # construct row-wise prefix sum matrix\\n        ps = [[] for x in range(m)]\\n        for r in range(m):\\n            ps[r].append(matrix[r][0])\\n            for c in range(1, n):\\n                ps[r].append(ps[r][-1]+matrix[r][c])\\n        \\n\\t\\t# Run over merged rows\\n        for router in range(m):\\n            psr = [0 for x in range(n)]\\n            for rinner in range(router, m):\\n                psr = [ x+y for x, y in zip(psr, ps[rinner]) ]  \\n                res = max(maxSumSubarray(psr, k), res)\\n                if res == k: return k\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2488474,
                "title": "c",
                "content": "```\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int target) {       \\n        int ans = INT_MIN;\\n        \\n        vector<vector<int>> col_prefix(matrix.size() + 1, vector<int>(matrix[0].size(), 0));\\n        for (int i = 0; i < col_prefix[0].size(); ++ i){\\n            for (int j = 1; j < col_prefix.size(); ++ j){\\n                col_prefix[j][i] = col_prefix[j - 1][i] + matrix[j - 1][i];\\n            }\\n        }\\n        for (int i = 0; i < col_prefix.size(); ++ i){\\n            for (int j = i + 1; j < col_prefix.size(); ++ j){\\n                set<int> use;\\n                int accumulate = 0;\\n                use.insert(accumulate);\\n                \\n                for (int k = 0; k < col_prefix[0].size(); ++ k){\\n                    accumulate += col_prefix[j][k] - col_prefix[i][k];\\n                    \\n                    auto get = use.lower_bound(accumulate - target);\\n                    if (get != use.end()){\\n                        ans = max(ans, accumulate - *get);\\n                    }\\n                    \\n                    use.insert(accumulate);\\n                }\\n                \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int target) {       \\n        int ans = INT_MIN;\\n        \\n        vector<vector<int>> col_prefix(matrix.size() + 1, vector<int>(matrix[0].size(), 0));\\n        for (int i = 0; i < col_prefix[0].size(); ++ i){\\n            for (int j = 1; j < col_prefix.size(); ++ j){\\n                col_prefix[j][i] = col_prefix[j - 1][i] + matrix[j - 1][i];\\n            }\\n        }\\n        for (int i = 0; i < col_prefix.size(); ++ i){\\n            for (int j = i + 1; j < col_prefix.size(); ++ j){\\n                set<int> use;\\n                int accumulate = 0;\\n                use.insert(accumulate);\\n                \\n                for (int k = 0; k < col_prefix[0].size(); ++ k){\\n                    accumulate += col_prefix[j][k] - col_prefix[i][k];\\n                    \\n                    auto get = use.lower_bound(accumulate - target);\\n                    if (get != use.end()){\\n                        ans = max(ans, accumulate - *get);\\n                    }\\n                    \\n                    use.insert(accumulate);\\n                }\\n                \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2488372,
                "title": "c-prefix-sum-faster",
                "content": "```\\nclass Solution {\\n   public:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>> dp(n + 1, vector<int>(m + 1));\\n\\n        int ans = INT_MIN;\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= m; j++) {\\n                dp[i][j] = dp[i][j - 1] + matrix[i - 1][j - 1];\\n            }\\n        }\\n\\n        for (int c1 = 1; c1 <= m; c1++) {\\n            for (int c2 = c1; c2 <= m; c2++) {\\n                vector<int> arr(n + 1);\\n                for (int i = 1; i <= n; i++) {\\n                    arr[i] = arr[i - 1] + dp[i][c2] - dp[i][c1 - 1];\\n                }\\n\\n                for (int r1 = 1; r1 <= n; r1++) {\\n                    for (int r2 = r1; r2 <= n; r2++) {\\n                        if (arr[r2] - arr[r1 - 1] <= k) {\\n                            ans = max(ans, arr[r2] - arr[r1 - 1]);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n   public:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>> dp(n + 1, vector<int>(m + 1));\\n\\n        int ans = INT_MIN;\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= m; j++) {\\n                dp[i][j] = dp[i][j - 1] + matrix[i - 1][j - 1];\\n            }\\n        }\\n\\n        for (int c1 = 1; c1 <= m; c1++) {\\n            for (int c2 = c1; c2 <= m; c2++) {\\n                vector<int> arr(n + 1);\\n                for (int i = 1; i <= n; i++) {\\n                    arr[i] = arr[i - 1] + dp[i][c2] - dp[i][c1 - 1];\\n                }\\n\\n                for (int r1 = 1; r1 <= n; r1++) {\\n                    for (int r2 = r1; r2 <= n; r2++) {\\n                        if (arr[r2] - arr[r1 - 1] <= k) {\\n                            ans = max(ans, arr[r2] - arr[r1 - 1]);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2488351,
                "title": "java-solution-faster-than-98",
                "content": "\\n```\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int[][] dp = new int[m + 1][n + 1];\\n\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                dp[i][j] = dp[i][j - 1] + dp[i - 1][j] - dp[i - 1][j - 1] + matrix[i - 1][j - 1];\\n            }\\n        }\\n        int result = Integer.MIN_VALUE;\\n        for (int i = 0; i < m; i++ ) {\\n            for (int j = 0; j < n; j++) {\\n                for (int a = i + 1; a <= m; a++) {\\n                    for (int b = j + 1; b <= n; b++) {\\n                        int tmp = dp[a][b] - dp[a][j] - dp[i][b] + dp[i][j];\\n                        if (tmp <= k) {\\n                            if (tmp == k) {\\n                                return k;\\n                            }\\n                            result = Math.max(result, tmp);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int[][] dp = new int[m + 1][n + 1];\\n\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                dp[i][j] = dp[i][j - 1] + dp[i - 1][j] - dp[i - 1][j - 1] + matrix[i - 1][j - 1];\\n            }\\n        }\\n        int result = Integer.MIN_VALUE;\\n        for (int i = 0; i < m; i++ ) {\\n            for (int j = 0; j < n; j++) {\\n                for (int a = i + 1; a <= m; a++) {\\n                    for (int b = j + 1; b <= n; b++) {\\n                        int tmp = dp[a][b] - dp[a][j] - dp[i][b] + dp[i][j];\\n                        if (tmp <= k) {\\n                            if (tmp == k) {\\n                                return k;\\n                            }\\n                            result = Math.max(result, tmp);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2488332,
                "title": "simple-c-solution-easy-understand-brute-force-enumeration-prefix-sum-binary-search",
                "content": "(brute force enumeration + prefix sum + binary search) O(n^2mlogm)\\nConvert the problem into a one-dimensional problem. The enumeration lo and hi represent the column interval of the currently processed data. For each column interval, it can be regarded as a one-dimensional problem.\\nOne-dimensional problems can be solved in O(mlogm) time using prefix sum with binary search. Maintains an ordered collection with 0 initially placed in the collection. Each time the prefix sum of the current position is obtained, the first number greater than or equal to sum - k is binary searched in the set, and if it can be found, the answer is updated. Then put the prefix sum of the current position into an ordered set.\\ntime complexity\\nThere are n^2 column intervals in total, and the time to solve each one-dimensional problem is O(mlogm).\\nSo the total time complexity is O(n^2mlogm).\\nspace complexity\\nAdditional O(m) space is required to record the sum of each row under the current column interval.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int m = matrix.size(), n = matrix[0].size();\\n        int ans = INT_MIN;\\n\\n        for (int lo = 0; lo < n; lo++) {\\n            vector<int> row(m, 0);\\n            for (int hi = lo; hi < n; hi++) {\\n                set<int> pre;\\n                int sum = 0;\\n\\n                pre.insert(0);\\n                for (int i = 0; i < m; i++) {\\n                    row[i] += matrix[i][hi];\\n                    sum += row[i];\\n                    auto it = pre.lower_bound(sum - k);\\n                    if (it != pre.end())\\n                        ans = max(ans, sum - *it);\\n                    pre.insert(sum);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search",
                    "Enumeration",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int m = matrix.size(), n = matrix[0].size();\\n        int ans = INT_MIN;\\n\\n        for (int lo = 0; lo < n; lo++) {\\n            vector<int> row(m, 0);\\n            for (int hi = lo; hi < n; hi++) {\\n                set<int> pre;\\n                int sum = 0;\\n\\n                pre.insert(0);\\n                for (int i = 0; i < m; i++) {\\n                    row[i] += matrix[i][hi];\\n                    sum += row[i];\\n                    auto it = pre.lower_bound(sum - k);\\n                    if (it != pre.end())\\n                        ans = max(ans, sum - *it);\\n                    pre.insert(sum);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2488296,
                "title": "java-brute-force-o-n-4-prefix-sum-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] grid, int k) \\n    {\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        int max=Integer.MIN_VALUE;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int a[]=new int[m];\\n            for(int j=i;j<n;j++)\\n            {\\n                for(int x=0;x<m;x++)\\n                a[x]+=grid[j][x];\\n                \\n                int sum=helper(a,k);\\n                max=Math.max(max,sum);\\n            }\\n        }\\n        \\n        return max;\\n    }\\n    \\n    public int helper(int a[],int k)\\n    {\\n        int ans=Integer.MIN_VALUE;\\n        \\n        for(int i=0;i<a.length;i++)\\n        {\\n            int s=0;\\n            for(int j=i;j<a.length;j++)\\n            {\\n                s+=a[j];\\n                if(s<=k)\\n                ans=Math.max(ans,s);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] grid, int k) \\n    {\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        int max=Integer.MIN_VALUE;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int a[]=new int[m];\\n            for(int j=i;j<n;j++)\\n            {\\n                for(int x=0;x<m;x++)\\n                a[x]+=grid[j][x];\\n                \\n                int sum=helper(a,k);\\n                max=Math.max(max,sum);\\n            }\\n        }\\n        \\n        return max;\\n    }\\n    \\n    public int helper(int a[],int k)\\n    {\\n        int ans=Integer.MIN_VALUE;\\n        \\n        for(int i=0;i<a.length;i++)\\n        {\\n            int s=0;\\n            for(int j=i;j<a.length;j++)\\n            {\\n                s+=a[j];\\n                if(s<=k)\\n                ans=Math.max(ans,s);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2488291,
                "title": "c-prefix-sum-for-2d-array-simple-solution",
                "content": "```\\ntypedef int ll;\\nclass Solution {\\npublic:\\n    ll dp[105][105];\\n \\n    ll get(ll x1,ll y1,ll x2,ll y2){\\n        return dp[x2+1][y2+1] - dp[x1][y2+1] - dp[x2+1][y1] + dp[x1][y1];\\n    }\\n    int maxSumSubmatrix(vector<vector<int>>& arr, int ch) {\\n        ll n = arr.size(),m = arr[0].size();\\n        for(ll i = 0;i <= n;i++){\\n            for(ll j = 0;j <= m;j++){\\n                dp[i][j] = 0;\\n            }\\n        }\\n        for(ll i = 1;i <= n;i++){\\n            for(ll j = 1;j <= m;j++){\\n                dp[i][j] = arr[i-1][j-1] + dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1];\\n            }\\n        }\\n        ll ans = -INT_MAX;\\n        for(ll i = 0;i < n;i++){\\n            for(ll j = 0;j < m;j++){\\n                for(ll k = i;k < n;k++){\\n                    for(ll l = j;l < m;l++){\\n                        \\n                        ll temp = get(i, j, k, l);\\n                        if(temp > ans && temp <= ch)\\n                            ans = temp;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\ntypedef int ll;\\nclass Solution {\\npublic:\\n    ll dp[105][105];\\n \\n    ll get(ll x1,ll y1,ll x2,ll y2){\\n        return dp[x2+1][y2+1] - dp[x1][y2+1] - dp[x2+1][y1] + dp[x1][y1];\\n    }\\n    int maxSumSubmatrix(vector<vector<int>>& arr, int ch) {\\n        ll n = arr.size(),m = arr[0].size();\\n        for(ll i = 0;i <= n;i++){\\n            for(ll j = 0;j <= m;j++){\\n                dp[i][j] = 0;\\n            }\\n        }\\n        for(ll i = 1;i <= n;i++){\\n            for(ll j = 1;j <= m;j++){\\n                dp[i][j] = arr[i-1][j-1] + dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1];\\n            }\\n        }\\n        ll ans = -INT_MAX;\\n        for(ll i = 0;i < n;i++){\\n            for(ll j = 0;j < m;j++){\\n                for(ll k = i;k < n;k++){\\n                    for(ll l = j;l < m;l++){\\n                        \\n                        ll temp = get(i, j, k, l);\\n                        if(temp > ans && temp <= ch)\\n                            ans = temp;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2485686,
                "title": "c-90-speed-1100-ms-99-space-for-loop",
                "content": "So this problem is an inclusion exclusion principle problem.\\n\\nAs it turns out this problem can be solved in O(n^2 m^2)  time where n is the length and m is the width of your array.\\n\\nFirst you make a DP  of size n x m  where DP[i][j] holds the area of the rectangle starting at coordinate (0,0) and ending at coordinate (i,j)\\n\\nReally this is all the information you need to calculate any rectangle in your matrix\\n\\nSay we wish to find the area of the rectangle with upper left hand coordinate  (x1, y1) and lower right hand coordinate (x2,y2).\\n\\nOf course x1<=x2  and y1<=y2\\n\\nObviously this box is inside DP[x2][y2]  so what we do next is slice off everything that is not inside our box\\n\\nYou can cut Box DP[x2][y2] into four pieces to get your rectangle with corners (x1,y1) , (x2,y2)\\n\\nNamely it is as follows DP[x2][y2] - DP[x1-1][y2] - DP[x2][y1-1] + DP[x1-1][y1-1]\\n\\nWe cut out the rectangles DP[x2][y1-1] and DP[x1-1][y2] BUT we should note we cut out the rectangle \\nDP[x1-1][y1-1] one too many times so we add it back in.\\n\\nSo in effect you can do this trick and run over all quadruplets (x1,y1)  (x2,y2)\\n\\nOf course as was said earlier this is O(n^2 m^2)  time constraints.\\n\\nThe Code is Below:      Thank You!   =]\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& M, int k) {\\n       \\n        \\n        int n=M.size(), m=M[0].size();\\n        int DP[n][m];\\n        memset(DP,0,sizeof(DP));\\n        \\n        DP[0][0]=M[0][0];\\n        \\n        for(int i=1;i<m;i++) DP[0][i]=DP[0][i-1] + M[0][i];\\n        for(int i=1;i<n;i++) DP[i][0]=DP[i-1][0] + M[i][0];\\n        \\n        for(int i=1;i<n;i++)\\n            for(int j=1;j<m;j++)\\n            {\\n                DP[i][j]=DP[i-1][j]+DP[i][j-1]-DP[i-1][j-1] + M[i][j];\\n            }\\n        \\n        int ret=INT_MIN, cur;\\n        \\n        int M1, M2, M3, M4;\\n        \\n        for(int x1=0;x1<n;x1++)\\n            for(int x2=x1;x2<n;x2++)\\n                for(int y1=0;y1<m;y1++)\\n                    for(int y2=y1;y2<m;y2++)\\n                    {\\n                        M1=0; M2=0; M3=0; M4=0;\\n                        \\n                        if(x1>0&&y1>0) M1=DP[x1-1][y1-1];\\n                        if(x1>0) M2=DP[x1-1][y2];\\n                        if(y1>0) M3=DP[x2][y1-1];\\n                        \\n                        M4=DP[x2][y2];\\n                        \\n                         cur=M4-M3-M2+M1;\\n               \\n                         if(cur<=k) ret=max(ret,cur);\\n                        \\n                        \\n                    } \\n        return(ret);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& M, int k) {\\n       \\n        \\n        int n=M.size(), m=M[0].size();\\n        int DP[n][m];\\n        memset(DP,0,sizeof(DP));\\n        \\n        DP[0][0]=M[0][0];\\n        \\n        for(int i=1;i<m;i++) DP[0][i]=DP[0][i-1] + M[0][i];\\n        for(int i=1;i<n;i++) DP[i][0]=DP[i-1][0] + M[i][0];\\n        \\n        for(int i=1;i<n;i++)\\n            for(int j=1;j<m;j++)\\n            {\\n                DP[i][j]=DP[i-1][j]+DP[i][j-1]-DP[i-1][j-1] + M[i][j];\\n            }\\n        \\n        int ret=INT_MIN, cur;\\n        \\n        int M1, M2, M3, M4;\\n        \\n        for(int x1=0;x1<n;x1++)\\n            for(int x2=x1;x2<n;x2++)\\n                for(int y1=0;y1<m;y1++)\\n                    for(int y2=y1;y2<m;y2++)\\n                    {\\n                        M1=0; M2=0; M3=0; M4=0;\\n                        \\n                        if(x1>0&&y1>0) M1=DP[x1-1][y1-1];\\n                        if(x1>0) M2=DP[x1-1][y2];\\n                        if(y1>0) M3=DP[x2][y1-1];\\n                        \\n                        M4=DP[x2][y2];\\n                        \\n                         cur=M4-M3-M2+M1;\\n               \\n                         if(cur<=k) ret=max(ret,cur);\\n                        \\n                        \\n                    } \\n        return(ret);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2379893,
                "title": "python-concise-bisect-solution",
                "content": "```\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        \"\"\"\\n        prefix sum, bisect.\\n        T(n) = O(m^2n), S(n) = O(n).\\n        \"\"\"\\n        m, n = len(matrix), len(matrix[0])\\n        res = - 2**31\\n        for ii in range(m):\\n            sums = [0] * n\\n            for i in range(ii, m):\\n                sorted_ps, ps = [], 0\\n                for j in range(n):\\n                    sums[j] += matrix[i][j]\\n                    ps += sums[j]\\n                    if ps <= k:\\n                        res = max(res, ps)\\n                    index = bisect.bisect_left(sorted_ps, ps - k)\\n                    if index < len(sorted_ps):\\n                        res = max(res, ps - sorted_ps[index])\\n                    bisect.insort(sorted_ps, ps)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        \"\"\"\\n        prefix sum, bisect.\\n        T(n) = O(m^2n), S(n) = O(n).\\n        \"\"\"\\n        m, n = len(matrix), len(matrix[0])\\n        res = - 2**31\\n        for ii in range(m):\\n            sums = [0] * n\\n            for i in range(ii, m):\\n                sorted_ps, ps = [], 0\\n                for j in range(n):\\n                    sums[j] += matrix[i][j]\\n                    ps += sums[j]\\n                    if ps <= k:\\n                        res = max(res, ps)\\n                    index = bisect.bisect_left(sorted_ps, ps - k)\\n                    if index < len(sorted_ps):\\n                        res = max(res, ps - sorted_ps[index])\\n                    bisect.insort(sorted_ps, ps)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2309175,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& mat, int k) {\\n        int m = mat.size(), n = mat[0].size(), res = INT32_MIN;\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 1; j < n; j++) {\\n                mat[i][j] += mat[i][j-1];\\n            }\\n        }\\n        \\n        for(int i = 0; i < n; i++) {\\n            for(int j = i; j < n; j++) {\\n                vector<int> pref(m);\\n                for(int k = 0; k < m; k++) pref[k] = mat[k][j]-(i > 0? mat[k][i-1]:0);\\n                for(int k = 1; k < m; k++) pref[k] += pref[k-1];\\n                set<int> st;\\n                \\n                for(int l = -1; l < m; l++) {\\n                    int curr = l >= 0? pref[l]:0;\\n                    auto it = st.lower_bound(curr-k);\\n                    if(it != st.end()) {\\n                        res = max(res,curr-(*it));\\n                    }\\n                    st.insert(curr);\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& mat, int k) {\\n        int m = mat.size(), n = mat[0].size(), res = INT32_MIN;\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 1; j < n; j++) {\\n                mat[i][j] += mat[i][j-1];\\n            }\\n        }\\n        \\n        for(int i = 0; i < n; i++) {\\n            for(int j = i; j < n; j++) {\\n                vector<int> pref(m);\\n                for(int k = 0; k < m; k++) pref[k] = mat[k][j]-(i > 0? mat[k][i-1]:0);\\n                for(int k = 1; k < m; k++) pref[k] += pref[k-1];\\n                set<int> st;\\n                \\n                for(int l = -1; l < m; l++) {\\n                    int curr = l >= 0? pref[l]:0;\\n                    auto it = st.lower_bound(curr-k);\\n                    if(it != st.end()) {\\n                        res = max(res,curr-(*it));\\n                    }\\n                    st.insert(curr);\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2181397,
                "title": "c-easy-to-understand-intuitive",
                "content": "Key Point : Fix starting and ending columns between which our maximum sum sub-rectangle is present whose sum is less than or equal to k\\n```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int n=matrix.size(),m=matrix[0].size();\\n        int ans=INT_MIN;\\n        for(int c1=0;c1<m;c1++){ \\n            vector<int> v(n,0);\\n            for(int c2=c1;c2<m;c2++){\\n                for(int i=0;i<n;i++){\\n                    v[i]+=matrix[i][c2];   // finding row-wise sum of the current sub-matrix\\n                }\\n                int sum=0;\\n                set<int> st;\\n                st.insert(0);\\n                for(int r=0;r<n;r++){     // finding maximum subarray sum less than k\\n                    sum+=v[r];\\n                    auto it=st.lower_bound(sum-k);\\n                    if(it!=st.end()){\\n                        ans=max(ans,sum-(*it));\\n                    }\\n                    st.insert(sum);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int n=matrix.size(),m=matrix[0].size();\\n        int ans=INT_MIN;\\n        for(int c1=0;c1<m;c1++){ \\n            vector<int> v(n,0);\\n            for(int c2=c1;c2<m;c2++){\\n                for(int i=0;i<n;i++){\\n                    v[i]+=matrix[i][c2];   // finding row-wise sum of the current sub-matrix\\n                }\\n                int sum=0;\\n                set<int> st;\\n                st.insert(0);\\n                for(int r=0;r<n;r++){     // finding maximum subarray sum less than k\\n                    sum+=v[r];\\n                    auto it=st.lower_bound(sum-k);\\n                    if(it!=st.end()){\\n                        ans=max(ans,sum-(*it));\\n                    }\\n                    st.insert(sum);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2126907,
                "title": "multiset-solution-faster-than-70",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int n=matrix.size(),m=matrix[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<m;j++)\\n                matrix[i][j]+=matrix[i][j-1];\\n        }\\n        int ans=INT_MIN;\\n        for(int c1=0;c1<m;c1++){\\n            for(int c2=c1;c2<m;c2++){\\n                multiset<int> me;\\n                int sum=0;\\n                for(int row=0;row<n;row++){\\n                    sum+=matrix[row][c2]-(c1>0?matrix[row][c1-1]:0);\\n                    if(sum<=k) ans=max(sum,ans); \\n                    auto it=me.lower_bound(sum-k);\\n                    if(it!=me.end() and (sum-*it)<=k) ans=max(ans,sum-*it);\\n                    me.insert(sum);\\n                }\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int n=matrix.size(),m=matrix[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<m;j++)\\n                matrix[i][j]+=matrix[i][j-1];\\n        }\\n        int ans=INT_MIN;\\n        for(int c1=0;c1<m;c1++){\\n            for(int c2=c1;c2<m;c2++){\\n                multiset<int> me;\\n                int sum=0;\\n                for(int row=0;row<n;row++){\\n                    sum+=matrix[row][c2]-(c1>0?matrix[row][c1-1]:0);\\n                    if(sum<=k) ans=max(sum,ans); \\n                    auto it=me.lower_bound(sum-k);\\n                    if(it!=me.end() and (sum-*it)<=k) ans=max(ans,sum-*it);\\n                    me.insert(sum);\\n                }\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2070378,
                "title": "c-dp-72-faster-90-less-space",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int arr[101][101];\\n    \\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        \\n        for(int i=1;i<=matrix.size();i++){\\n            for(int j=1;j<=matrix[0].size();j++){\\n                arr[i][j] = arr[i-1][j] + arr[i][j-1] - arr[i-1][j-1] + matrix[i-1][j-1];\\n            }\\n        }\\n        \\n        int lmax = INT_MIN;\\n        for(int a=1;a<=matrix.size();a++){\\n            for(int b=1;b<=matrix[0].size();b++){\\n                for(int c=a;c<=matrix.size();c++){\\n                    for(int d=b;d<=matrix[0].size();d++){\\n                        int val = arr[c][d] - arr[c][b-1] - arr[a-1][d] + arr[a-1][b-1];\\n                        \\n                        if(val <= k){\\n                            \\n                            lmax = max(lmax, val);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return lmax;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int arr[101][101];\\n    \\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        \\n        for(int i=1;i<=matrix.size();i++){\\n            for(int j=1;j<=matrix[0].size();j++){\\n                arr[i][j] = arr[i-1][j] + arr[i][j-1] - arr[i-1][j-1] + matrix[i-1][j-1];\\n            }\\n        }\\n        \\n        int lmax = INT_MIN;\\n        for(int a=1;a<=matrix.size();a++){\\n            for(int b=1;b<=matrix[0].size();b++){\\n                for(int c=a;c<=matrix.size();c++){\\n                    for(int d=b;d<=matrix[0].size();d++){\\n                        int val = arr[c][d] - arr[c][b-1] - arr[a-1][d] + arr[a-1][b-1];\\n                        \\n                        if(val <= k){\\n                            \\n                            lmax = max(lmax, val);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return lmax;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1776725,
                "title": "java-prefixsum-treemap",
                "content": "```\\nclass Solution {\\n    public int find(int sum[][],int p,int j,int k)\\n    {\\n        int max=-10000000,s=0;\\n        TreeMap<Integer,Integer>map=new TreeMap<Integer,Integer>();\\n        map.put(0,-1);\\n        for(int i=0;i<sum.length;i++)\\n        {\\n            s=s+sum[i][p]-sum[i][j+1];\\n            if(map.containsKey(s-k))\\n            {\\n                    return k;\\n            }\\n            if(map.higherKey(s-k)!=null)\\n            {\\n                int y=map.higherKey(s-k);\\n                max=Math.max(max,s-y);\\n            }\\n            map.put(s,i);\\n        }\\n        return max;\\n    }\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int ans=-1000000;\\n        int sum[][]=new int[matrix.length][matrix[0].length+1];\\n        for(int i=0;i<matrix.length;i++)\\n        {\\n            for(int j=matrix[0].length-1;j>=0;j--)\\n            {\\n                sum[i][j]=sum[i][j+1]+matrix[i][j];\\n            }\\n        }\\n        for(int j=matrix[0].length-1;j>=0;j--)\\n        {\\n            for(int p=j;p>=0;p--)\\n            {\\n                ans=Math.max(ans,find(sum,p,j,k));\\n                if(ans==k)\\n                    return k;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int find(int sum[][],int p,int j,int k)\\n    {\\n        int max=-10000000,s=0;\\n        TreeMap<Integer,Integer>map=new TreeMap<Integer,Integer>();\\n        map.put(0,-1);\\n        for(int i=0;i<sum.length;i++)\\n        {\\n            s=s+sum[i][p]-sum[i][j+1];\\n            if(map.containsKey(s-k))\\n            {\\n                    return k;\\n            }\\n            if(map.higherKey(s-k)!=null)\\n            {\\n                int y=map.higherKey(s-k);\\n                max=Math.max(max,s-y);\\n            }\\n            map.put(s,i);\\n        }\\n        return max;\\n    }\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int ans=-1000000;\\n        int sum[][]=new int[matrix.length][matrix[0].length+1];\\n        for(int i=0;i<matrix.length;i++)\\n        {\\n            for(int j=matrix[0].length-1;j>=0;j--)\\n            {\\n                sum[i][j]=sum[i][j+1]+matrix[i][j];\\n            }\\n        }\\n        for(int j=matrix[0].length-1;j>=0;j--)\\n        {\\n            for(int p=j;p>=0;p--)\\n            {\\n                ans=Math.max(ans,find(sum,p,j,k));\\n                if(ans==k)\\n                    return k;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1742951,
                "title": "c-simplified-set-kadane-running-sum-o-rows-log-rows-cols-2",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int K) {\\n        \\n        int num_rows = matrix.size(), num_cols = matrix[0].size();\\n        int ans = INT_MIN;\\n   \\n        for(int l=0;l<num_cols;l++){\\n            vector<int>row_sum(num_rows,0);\\n            for(int r=l;r<num_cols;r++){\\n                for(int k=0;k<num_rows;k++)\\n                    row_sum[k] += matrix[k][r];\\n                int sum = 0;\\n                set<int>s;\\n                s.insert(0);\\n                if(num_rows==1){\\n                    if(row_sum[0]<=K)\\n                        ans = max(ans,row_sum[0]);\\n                    continue;\\n                }\\n                for(int k=0;k<num_rows;k++){\\n                      sum+=row_sum[k];\\n                      auto it = (s.lower_bound((sum-K)));\\n                      if(it!=s.end()){\\n                          int x = *it;\\n                          ans = max(ans, sum-x);\\n                      }\\n                      s.insert(sum);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int K) {\\n        \\n        int num_rows = matrix.size(), num_cols = matrix[0].size();\\n        int ans = INT_MIN;\\n   \\n        for(int l=0;l<num_cols;l++){\\n            vector<int>row_sum(num_rows,0);\\n            for(int r=l;r<num_cols;r++){\\n                for(int k=0;k<num_rows;k++)\\n                    row_sum[k] += matrix[k][r];\\n                int sum = 0;\\n                set<int>s;\\n                s.insert(0);\\n                if(num_rows==1){\\n                    if(row_sum[0]<=K)\\n                        ans = max(ans,row_sum[0]);\\n                    continue;\\n                }\\n                for(int k=0;k<num_rows;k++){\\n                      sum+=row_sum[k];\\n                      auto it = (s.lower_bound((sum-K)));\\n                      if(it!=s.end()){\\n                          int x = *it;\\n                          ans = max(ans, sum-x);\\n                      }\\n                      s.insert(sum);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1687900,
                "title": "python-3-100-time-96-memory-prefix-sum-bisect-left",
                "content": "![image](https://assets.leetcode.com/users/images/44d8fcc1-8a63-4a21-84d3-12b4f99092cf_1642093217.1059096.png)\\n\\nThe problem is quite similar to [1074. Number of Submatrices That Sum to Target](http://https://leetcode.com/problems/number-of-submatrices-that-sum-to-target/). In 1074 we keep a rolling hash counter to look up for whether (cumulative_sum - target) exists in the hash. For this one, for each two columns 0 <= i <= j < n, we maintain a sorted list of cumulative sums from all previous rows 0 to r - 1. Arriving at row r, we calculate the cumulative_sum[r], and binary search for (cumulative_sum[r] - k) in the sorted list to find the best row x for calculating one candidate answer (cumulative_sum[r] - cumulative_sum[x]). (cumulative_sum[r] - cumulative_sum[x]) represents the submatrix sum inclusively from `matrix[x+1][i]` to `matrix[r][j]`.\\n\\n```\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        \\n\\t\\t# prefix sum each row\\n        for row in matrix:\\n            for i in range(1, n):\\n                row[i] = row[i] + row[i-1]\\n            row.insert(0, 0)\\n        \\n        ans = -inf\\n        for i in range(n):\\n            for j in range(i, n):\\n                arr = [0] # init with a 0 in case cur_sum == k at a paricular row\\n                cur_sum = 0\\n                for r in range(m):\\n\\t\\t\\t\\t    cur_sum += matrix[r][j+1] - matrix[r][i] # submatrix sum row 0 to r\\n                    x = bisect_left(arr, cur_sum - k) # search for the best candidate from earlier rows\\n                    if x < len(arr):\\n                        if arr[x] == cur_sum - k:\\n                            return k\\n                        else:\\n                            ans = max(ans, cur_sum - arr[x])\\n                    insort(arr, cur_sum) # update sorted list of cumulative sums\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        \\n\\t\\t# prefix sum each row\\n        for row in matrix:\\n            for i in range(1, n):\\n                row[i] = row[i] + row[i-1]\\n            row.insert(0, 0)\\n        \\n        ans = -inf\\n        for i in range(n):\\n            for j in range(i, n):\\n                arr = [0] # init with a 0 in case cur_sum == k at a paricular row\\n                cur_sum = 0\\n                for r in range(m):\\n\\t\\t\\t\\t    cur_sum += matrix[r][j+1] - matrix[r][i] # submatrix sum row 0 to r\\n                    x = bisect_left(arr, cur_sum - k) # search for the best candidate from earlier rows\\n                    if x < len(arr):\\n                        if arr[x] == cur_sum - k:\\n                            return k\\n                        else:\\n                            ans = max(ans, cur_sum - arr[x])\\n                    insort(arr, cur_sum) # update sorted list of cumulative sums\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1430650,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n   int fun(vector<int> arr, int K)\\n   {\\n        int N=arr.size();\\n        set<int> cum_set;\\n        cum_set.insert(0);\\n\\n        int max_sum = INT_MIN, cSum = 0;\\n\\n        for (int i = 0; i < N; i++) {\\n            cSum += arr[i];\\n            set<int>::iterator sit= cum_set.lower_bound(cSum - K);\\n            if (sit != cum_set.end())\\n                max_sum = max(max_sum, cSum - *sit);\\n            cum_set.insert(cSum);\\n        }\\n        return max_sum;\\n    }\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int r=matrix.size();\\n        int c=matrix[0].size();\\n        \\n        vector<vector<int>> pre(r+1,vector<int>(c+1,0));\\n        \\n       for(int j=1;j<c+1;j++){\\n           for(int i=1;i<r+1;i++){\\n               pre[i][j]+=pre[i-1][j]+matrix[i-1][j-1];\\n           }\\n       }\\n        int ans=INT_MIN;\\n        for(int i=1;i<r+1;i++){\\n            for(int j=1;j<=r+1-i;j++){\\n                int cr=1;\\n                vector<int> v;\\n                while(cr<c+1){\\n                    v.push_back(pre[j+i-1][cr]-pre[j-1][cr]);\\n                   \\n                    cr++;\\n                }\\n                ans=max(ans,fun(v,k));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int fun(vector<int> arr, int K)\\n   {\\n        int N=arr.size();\\n        set<int> cum_set;\\n        cum_set.insert(0);\\n\\n        int max_sum = INT_MIN, cSum = 0;\\n\\n        for (int i = 0; i < N; i++) {\\n            cSum += arr[i];\\n            set<int>::iterator sit= cum_set.lower_bound(cSum - K);\\n            if (sit != cum_set.end())\\n                max_sum = max(max_sum, cSum - *sit);\\n            cum_set.insert(cSum);\\n        }\\n        return max_sum;\\n    }\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int r=matrix.size();\\n        int c=matrix[0].size();\\n        \\n        vector<vector<int>> pre(r+1,vector<int>(c+1,0));\\n        \\n       for(int j=1;j<c+1;j++){\\n           for(int i=1;i<r+1;i++){\\n               pre[i][j]+=pre[i-1][j]+matrix[i-1][j-1];\\n           }\\n       }\\n        int ans=INT_MIN;\\n        for(int i=1;i<r+1;i++){\\n            for(int j=1;j<=r+1-i;j++){\\n                int cr=1;\\n                vector<int> v;\\n                while(cr<c+1){\\n                    v.push_back(pre[j+i-1][cr]-pre[j-1][cr]);\\n                   \\n                    cr++;\\n                }\\n                ans=max(ans,fun(v,k));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1401036,
                "title": "python-solution-using-bisect-module",
                "content": "here is the python solution using bisect module. Bisect module is used whenever we want to find the index (```index = bisect.bisect_left(a,x)```) in an list such that it bisects the list in two halfs, each element in left half is lesser than x and each element in right half is greater than or equal to x.\\n```\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        r,c = len(matrix), len(matrix[0])\\n        ans = -math.inf\\n        for up in range(r):\\n            curr = [0]*c\\n            for down in range(up,r):\\n                curr = [curr[i]+matrix[down][i] for i in range(c)]\\n                seen = [0]\\n                sm = 0\\n                for i in range(c):\\n                    sm += curr[i]\\n                    ind = bisect.bisect_left(seen,sm-k)\\n                    if ind < len(seen) and sm-seen[ind] > ans:\\n                        ans = sm-seen[ind]\\n                    bisect.insort_right(seen,sm)\\n        return ans\\n\\t\\t```",
                "solutionTags": [],
                "code": "```index = bisect.bisect_left(a,x)```\n```\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        r,c = len(matrix), len(matrix[0])\\n        ans = -math.inf\\n        for up in range(r):\\n            curr = [0]*c\\n            for down in range(up,r):\\n                curr = [curr[i]+matrix[down][i] for i in range(c)]\\n                seen = [0]\\n                sm = 0\\n                for i in range(c):\\n                    sm += curr[i]\\n                    ind = bisect.bisect_left(seen,sm-k)\\n                    if ind < len(seen) and sm-seen[ind] > ans:\\n                        ans = sm-seen[ind]\\n                    bisect.insort_right(seen,sm)\\n        return ans\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1365977,
                "title": "accepted-java-solution",
                "content": "```\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int ki) {\\n        int n=matrix.length;\\n        int m=matrix[0].length;\\n        int[][] dp=new int[n+2][m+2];\\n        int ans=Integer.MIN_VALUE;\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                dp[i][j]=dp[i][j-1]+dp[i-1][j]-dp[i-1][j-1]+matrix[i-1][j-1];\\n                if(matrix[i-1][j-1]<=ki)ans=Math.max(ans,matrix[i-1][j-1]);\\n            }\\n        }\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                for(int k=0;k<=n-i;k++){\\n                    for(int l=0;l<=m-j;l++){\\n                        int a=k+i;\\n                        int b=l+j;\\n                        int d=dp[a][b]-dp[a-i][b]-dp[a][b-j]+dp[a-i][b-j];\\n                        if(d<=ki)ans=Math.max(ans,d);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int ki) {\\n        int n=matrix.length;\\n        int m=matrix[0].length;\\n        int[][] dp=new int[n+2][m+2];\\n        int ans=Integer.MIN_VALUE;\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                dp[i][j]=dp[i][j-1]+dp[i-1][j]-dp[i-1][j-1]+matrix[i-1][j-1];\\n                if(matrix[i-1][j-1]<=ki)ans=Math.max(ans,matrix[i-1][j-1]);\\n            }\\n        }\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                for(int k=0;k<=n-i;k++){\\n                    for(int l=0;l<=m-j;l++){\\n                        int a=k+i;\\n                        int b=l+j;\\n                        int d=dp[a][b]-dp[a-i][b]-dp[a][b-j]+dp[a-i][b-j];\\n                        if(d<=ki)ans=Math.max(ans,d);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1343104,
                "title": "2d-kadane-prefix-sum-solution-c",
                "content": "```\\nclass Solution{\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k)\\n    {\\n        int m = matrix.size(), n = matrix[0].size();\\n        int sum[m][n], mx=INT_MIN;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                auto x = matrix[i][j];\\n                if(i>0 && j>0) x=x+sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1];\\n                else if(i>0 && j<=0) x=x+sum[i-1][j];\\n                else if(i<=0 && j>0) x=x+sum[i][j-1];\\n                sum[i][j]=x;\\n                for(int r=0;r<=i;r++)\\n                {\\n                    for(int c=0;c<=j;c++)\\n                    {\\n                        auto chk = sum[i][j];\\n                        if(r>0 && c>0) chk=chk-sum[r-1][j]-sum[i][c-1]+sum[r-1][c-1];\\n                        else if(r>0 && c<=0) chk=chk-sum[r-1][j];\\n                        else if(r<=0 && c>0) chk=chk-sum[i][c-1];\\n                        if(chk<=k) mx=max(mx,chk);\\n                    }\\n                }\\n            }\\n        }\\n        return mx;\\n    }\\n};\\n```\\n```\\nclass Solution{\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k)\\n    {\\n        int m = matrix.size(), n = matrix[0].size();\\n        int sum[m][n], res=INT_MIN;  \\n        vector<int> row(m, 0);\\n        for(int l=0;l<n;l++)\\n        {\\n            fill(row.begin(), row.end(), 0); //refill vector with 0 with every change in pointer \\'l\\'\\n            for(int r=l;r<n;r++)\\n            {\\n                int csum=0, mx=INT_MIN;\\n                for(int i=0;i<m;i++)\\n                {\\n                    row[i]+=matrix[i][r];\\n                    if(csum<0) csum = row[i];\\n                    else csum=csum+row[i];\\n                    mx=max(mx, csum);\\n                }\\n                if(mx<=k)\\n                {\\n                    res=max(res, mx); \\n                    continue;\\n                }\\n                set<int> s; //if maximum sum for a l is greater than k\\n                s.insert(0); \\n                csum=0;\\n                for(auto x: row)\\n                {\\n                    csum+=x;\\n                    auto f = s.lower_bound(csum-k); //find element which is equal to or just greater than difference between current sum and k\\n                    if(f!=s.end()) res=max(res, csum -*f);\\n                    s.insert(csum);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution{\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k)\\n    {\\n        int m = matrix.size(), n = matrix[0].size();\\n        int sum[m][n], mx=INT_MIN;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                auto x = matrix[i][j];\\n                if(i>0 && j>0) x=x+sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1];\\n                else if(i>0 && j<=0) x=x+sum[i-1][j];\\n                else if(i<=0 && j>0) x=x+sum[i][j-1];\\n                sum[i][j]=x;\\n                for(int r=0;r<=i;r++)\\n                {\\n                    for(int c=0;c<=j;c++)\\n                    {\\n                        auto chk = sum[i][j];\\n                        if(r>0 && c>0) chk=chk-sum[r-1][j]-sum[i][c-1]+sum[r-1][c-1];\\n                        else if(r>0 && c<=0) chk=chk-sum[r-1][j];\\n                        else if(r<=0 && c>0) chk=chk-sum[i][c-1];\\n                        if(chk<=k) mx=max(mx,chk);\\n                    }\\n                }\\n            }\\n        }\\n        return mx;\\n    }\\n};\\n```\n```\\nclass Solution{\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k)\\n    {\\n        int m = matrix.size(), n = matrix[0].size();\\n        int sum[m][n], res=INT_MIN;  \\n        vector<int> row(m, 0);\\n        for(int l=0;l<n;l++)\\n        {\\n            fill(row.begin(), row.end(), 0); //refill vector with 0 with every change in pointer \\'l\\'\\n            for(int r=l;r<n;r++)\\n            {\\n                int csum=0, mx=INT_MIN;\\n                for(int i=0;i<m;i++)\\n                {\\n                    row[i]+=matrix[i][r];\\n                    if(csum<0) csum = row[i];\\n                    else csum=csum+row[i];\\n                    mx=max(mx, csum);\\n                }\\n                if(mx<=k)\\n                {\\n                    res=max(res, mx); \\n                    continue;\\n                }\\n                set<int> s; //if maximum sum for a l is greater than k\\n                s.insert(0); \\n                csum=0;\\n                for(auto x: row)\\n                {\\n                    csum+=x;\\n                    auto f = s.lower_bound(csum-k); //find element which is equal to or just greater than difference between current sum and k\\n                    if(f!=s.end()) res=max(res, csum -*f);\\n                    s.insert(csum);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1320556,
                "title": "javascript-2-solutions-dp-binary-search",
                "content": "DP: 944ms\\n```\\nconst maxSumSubmatrix = (g, k) => {\\n    let [n, m, res] = [g.length, g[0].length, Number.MIN_SAFE_INTEGER];\\n    let dp = initialize2DArrayNew(n, m); // save 2D matrix pre sum\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < m; j++) {\\n            let sum = g[i][j];\\n            if (i > 0) sum += dp[i - 1][j];\\n            if (j > 0) sum += dp[i][j - 1];\\n            if (i > 0 && j > 0) sum -= dp[i - 1][j - 1];\\n            dp[i][j] = sum;\\n            for (let r = 0; r <= i; r++) { // subrectangles sum calculation\\n                for (let c = 0; c <= j; c++) {\\n                    let curSum = dp[i][j];\\n                    if (r > 0) curSum -= dp[r - 1][j];\\n                    if (c > 0) curSum -= dp[i][c - 1];\\n                    if (r > 0 && c > 0) curSum += dp[r - 1][c - 1];\\n                    if (curSum <= k) res = Math.max(res, curSum);\\n                }\\n            }\\n        }\\n    }\\n    return res;\\n};\\n\\nconst initialize2DArrayNew = (n, m) => {\\n    let data = [];\\n    for (let i = 0; i < n; i++) {\\n        let tmp = Array(m).fill(0);\\n        data.push(tmp);\\n    }\\n    return data;\\n};\\n```\\nbinary search with Treeset 792ms\\n```\\nfunction Bisect() {\\n    return { insort_right, insort_left, bisect_left, bisect_right }\\n    function insort_right(a, x, lo = 0, hi = null) {\\n        lo = bisect_right(a, x, lo, hi);\\n        a.splice(lo, 0, x);\\n    }\\n    function bisect_right(a, x, lo = 0, hi = null) {\\n        if (lo < 0) throw new Error(\\'lo must be non-negative\\');\\n        if (hi == null) hi = a.length;\\n        while (lo < hi) {\\n            let mid = lo + hi >> 1;\\n            x < a[mid] ? hi = mid : lo = mid + 1;\\n        }\\n        return lo;\\n    }\\n    function insort_left(a, x, lo = 0, hi = null) {\\n        lo = bisect_left(a, x, lo, hi);\\n        a.splice(lo, 0, x);\\n    }\\n    function bisect_left(a, x, lo = 0, hi = null) {\\n        if (lo < 0) throw new Error(\\'lo must be non-negative\\');\\n        if (hi == null) hi = a.length;\\n        while (lo < hi) {\\n            let mid = lo + hi >> 1;\\n            a[mid] < x ? lo = mid + 1 : hi = mid;\\n        }\\n        return lo;\\n    }\\n}\\n\\nfunction TreeSet(elements) {\\n    let ts = [];\\n    let se = new Set();\\n    let bisect = new Bisect();\\n    if (elements) addAll(elements);\\n    return { add, floor, ceiling, lower, remove, contains, size, clear, toArray };\\n    function addAll(elements) {\\n        for (const e of elements) {\\n            if (se.has(e)) continue;\\n            add(e);\\n            se.add(e);\\n        }\\n    }\\n    function add(e) {\\n        if (!se.has(e)) {\\n            bisect.insort_right(ts, e);\\n            se.add(e);\\n        }\\n    }\\n    function ceiling(e) {\\n        let idx = bisect.bisect_right(ts, e);\\n        if (ts[idx - 1] == e) return e;\\n        return ts[bisect.bisect_right(ts, e)];\\n    }\\n    function floor(e) {\\n        let idx = bisect.bisect_left(ts, e);\\n        if (ts[idx] == e) {\\n            return e;\\n        } else {\\n            return ts[bisect.bisect_left(ts, e) - 1];\\n        }\\n    }\\n    function lower(e) {\\n        let idx = bisect.bisect_left(ts, e);\\n        if (ts[idx] < e) {\\n            return ts[idx];\\n        } else {\\n            return ts[bisect.bisect_left(ts, e) - 1];\\n        }\\n    }\\n    function remove(e) {\\n        let res = new Set(ts);\\n        res.delete(e);\\n        ts = [...res];\\n        se.delete(e);\\n    }\\n    function contains(e) {\\n        return se.has(e);\\n    }\\n    function size() {\\n        return ts.length;\\n    }\\n    function clear() {\\n        ts = [];\\n    }\\n    function toArray() {\\n        return ts;\\n    }\\n}\\n\\nconst maxSumSubmatrix = (g, k) => {\\n    let [n, m, res] = [g.length, g[0].length, Number.MIN_SAFE_INTEGER];\\n    for (let i = 0; i < m; i++) {\\n        let sum = Array(n).fill(0);\\n        for (let j = i; j < m; j++) {\\n            for (let k = 0; k < n; k++) {\\n                sum[k] += g[k][j];\\n            }\\n            let curSum = 0;\\n            let ts = new TreeSet([0]);\\n            for (const x of sum) {\\n                curSum += x;\\n                let tmp = ts.ceiling(curSum - k); // java treeset ceiling, c++ set lower_bound\\n                if (tmp != undefined) res = Math.max(res, curSum - tmp);\\n                ts.add(curSum);\\n            }\\n        }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Tree",
                    "Binary Tree",
                    "Ordered Set"
                ],
                "code": "```\\nconst maxSumSubmatrix = (g, k) => {\\n    let [n, m, res] = [g.length, g[0].length, Number.MIN_SAFE_INTEGER];\\n    let dp = initialize2DArrayNew(n, m); // save 2D matrix pre sum\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < m; j++) {\\n            let sum = g[i][j];\\n            if (i > 0) sum += dp[i - 1][j];\\n            if (j > 0) sum += dp[i][j - 1];\\n            if (i > 0 && j > 0) sum -= dp[i - 1][j - 1];\\n            dp[i][j] = sum;\\n            for (let r = 0; r <= i; r++) { // subrectangles sum calculation\\n                for (let c = 0; c <= j; c++) {\\n                    let curSum = dp[i][j];\\n                    if (r > 0) curSum -= dp[r - 1][j];\\n                    if (c > 0) curSum -= dp[i][c - 1];\\n                    if (r > 0 && c > 0) curSum += dp[r - 1][c - 1];\\n                    if (curSum <= k) res = Math.max(res, curSum);\\n                }\\n            }\\n        }\\n    }\\n    return res;\\n};\\n\\nconst initialize2DArrayNew = (n, m) => {\\n    let data = [];\\n    for (let i = 0; i < n; i++) {\\n        let tmp = Array(m).fill(0);\\n        data.push(tmp);\\n    }\\n    return data;\\n};\\n```\n```\\nfunction Bisect() {\\n    return { insort_right, insort_left, bisect_left, bisect_right }\\n    function insort_right(a, x, lo = 0, hi = null) {\\n        lo = bisect_right(a, x, lo, hi);\\n        a.splice(lo, 0, x);\\n    }\\n    function bisect_right(a, x, lo = 0, hi = null) {\\n        if (lo < 0) throw new Error(\\'lo must be non-negative\\');\\n        if (hi == null) hi = a.length;\\n        while (lo < hi) {\\n            let mid = lo + hi >> 1;\\n            x < a[mid] ? hi = mid : lo = mid + 1;\\n        }\\n        return lo;\\n    }\\n    function insort_left(a, x, lo = 0, hi = null) {\\n        lo = bisect_left(a, x, lo, hi);\\n        a.splice(lo, 0, x);\\n    }\\n    function bisect_left(a, x, lo = 0, hi = null) {\\n        if (lo < 0) throw new Error(\\'lo must be non-negative\\');\\n        if (hi == null) hi = a.length;\\n        while (lo < hi) {\\n            let mid = lo + hi >> 1;\\n            a[mid] < x ? lo = mid + 1 : hi = mid;\\n        }\\n        return lo;\\n    }\\n}\\n\\nfunction TreeSet(elements) {\\n    let ts = [];\\n    let se = new Set();\\n    let bisect = new Bisect();\\n    if (elements) addAll(elements);\\n    return { add, floor, ceiling, lower, remove, contains, size, clear, toArray };\\n    function addAll(elements) {\\n        for (const e of elements) {\\n            if (se.has(e)) continue;\\n            add(e);\\n            se.add(e);\\n        }\\n    }\\n    function add(e) {\\n        if (!se.has(e)) {\\n            bisect.insort_right(ts, e);\\n            se.add(e);\\n        }\\n    }\\n    function ceiling(e) {\\n        let idx = bisect.bisect_right(ts, e);\\n        if (ts[idx - 1] == e) return e;\\n        return ts[bisect.bisect_right(ts, e)];\\n    }\\n    function floor(e) {\\n        let idx = bisect.bisect_left(ts, e);\\n        if (ts[idx] == e) {\\n            return e;\\n        } else {\\n            return ts[bisect.bisect_left(ts, e) - 1];\\n        }\\n    }\\n    function lower(e) {\\n        let idx = bisect.bisect_left(ts, e);\\n        if (ts[idx] < e) {\\n            return ts[idx];\\n        } else {\\n            return ts[bisect.bisect_left(ts, e) - 1];\\n        }\\n    }\\n    function remove(e) {\\n        let res = new Set(ts);\\n        res.delete(e);\\n        ts = [...res];\\n        se.delete(e);\\n    }\\n    function contains(e) {\\n        return se.has(e);\\n    }\\n    function size() {\\n        return ts.length;\\n    }\\n    function clear() {\\n        ts = [];\\n    }\\n    function toArray() {\\n        return ts;\\n    }\\n}\\n\\nconst maxSumSubmatrix = (g, k) => {\\n    let [n, m, res] = [g.length, g[0].length, Number.MIN_SAFE_INTEGER];\\n    for (let i = 0; i < m; i++) {\\n        let sum = Array(n).fill(0);\\n        for (let j = i; j < m; j++) {\\n            for (let k = 0; k < n; k++) {\\n                sum[k] += g[k][j];\\n            }\\n            let curSum = 0;\\n            let ts = new TreeSet([0]);\\n            for (const x of sum) {\\n                curSum += x;\\n                let tmp = ts.ceiling(curSum - k); // java treeset ceiling, c++ set lower_bound\\n                if (tmp != undefined) res = Math.max(res, curSum - tmp);\\n                ts.add(curSum);\\n            }\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1567964,
                "content": [
                    {
                        "username": "galster",
                        "content": "I solved this problem  in C++ just like most other people solved it here, except I started iterating over the rows and performing a one-dimensional binary search on sum of columns. I got a TLE. When I switched between the rows and columns the solution was accepted. This should not be the case. Either the algorithm enforces this on both the rows and columns or it doesnt enforce it at all."
                    },
                    {
                        "username": "FatShibaInu",
                        "content": "My submission failed at the following test case:\\nInput:\\n[[2,2,-1]]\\n2\\nOutput:\\n0\\nExpected:\\n2\\n\\nAs I see it, to make a rectangle with an area>0, the rectangle must have at least two rows and two columns, so this test case should return 0, because it's a straight line with area =0.\\n\\nIf a single element [2] means an area =0, which means as long as the rectangle has elements, its area is greater than 0, then what's the point saying \"The rectangle inside the matrix must have an area > 0\"?\\n\\nAm I misunderstanding something?"
                    },
                    {
                        "username": "Fengster",
                        "content": "So I think another condition that needs to be added is that there must exist a number no greater than k.\\nOtherwise, the only solution is empty matrix, however area must > 0.\\nConsider this test case: [[2]] 1\\nIt returns -2147483648 on mine because my max variable is default min value of Integer. It returns -1000000000 as the expected answer. (so problem creator used -1000000000 as default result? : ) )"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "this one is like a sequel to https://leetcode.com/problems/range-sum-query-2d-immutable/"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "since1991sanchit",
                        "content": "# Suggestion for additional tag: Merge Sort "
                    }
                ]
            },
            {
                "id": 1571637,
                "content": [
                    {
                        "username": "galster",
                        "content": "I solved this problem  in C++ just like most other people solved it here, except I started iterating over the rows and performing a one-dimensional binary search on sum of columns. I got a TLE. When I switched between the rows and columns the solution was accepted. This should not be the case. Either the algorithm enforces this on both the rows and columns or it doesnt enforce it at all."
                    },
                    {
                        "username": "FatShibaInu",
                        "content": "My submission failed at the following test case:\\nInput:\\n[[2,2,-1]]\\n2\\nOutput:\\n0\\nExpected:\\n2\\n\\nAs I see it, to make a rectangle with an area>0, the rectangle must have at least two rows and two columns, so this test case should return 0, because it's a straight line with area =0.\\n\\nIf a single element [2] means an area =0, which means as long as the rectangle has elements, its area is greater than 0, then what's the point saying \"The rectangle inside the matrix must have an area > 0\"?\\n\\nAm I misunderstanding something?"
                    },
                    {
                        "username": "Fengster",
                        "content": "So I think another condition that needs to be added is that there must exist a number no greater than k.\\nOtherwise, the only solution is empty matrix, however area must > 0.\\nConsider this test case: [[2]] 1\\nIt returns -2147483648 on mine because my max variable is default min value of Integer. It returns -1000000000 as the expected answer. (so problem creator used -1000000000 as default result? : ) )"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "this one is like a sequel to https://leetcode.com/problems/range-sum-query-2d-immutable/"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "since1991sanchit",
                        "content": "# Suggestion for additional tag: Merge Sort "
                    }
                ]
            },
            {
                "id": 1571636,
                "content": [
                    {
                        "username": "galster",
                        "content": "I solved this problem  in C++ just like most other people solved it here, except I started iterating over the rows and performing a one-dimensional binary search on sum of columns. I got a TLE. When I switched between the rows and columns the solution was accepted. This should not be the case. Either the algorithm enforces this on both the rows and columns or it doesnt enforce it at all."
                    },
                    {
                        "username": "FatShibaInu",
                        "content": "My submission failed at the following test case:\\nInput:\\n[[2,2,-1]]\\n2\\nOutput:\\n0\\nExpected:\\n2\\n\\nAs I see it, to make a rectangle with an area>0, the rectangle must have at least two rows and two columns, so this test case should return 0, because it's a straight line with area =0.\\n\\nIf a single element [2] means an area =0, which means as long as the rectangle has elements, its area is greater than 0, then what's the point saying \"The rectangle inside the matrix must have an area > 0\"?\\n\\nAm I misunderstanding something?"
                    },
                    {
                        "username": "Fengster",
                        "content": "So I think another condition that needs to be added is that there must exist a number no greater than k.\\nOtherwise, the only solution is empty matrix, however area must > 0.\\nConsider this test case: [[2]] 1\\nIt returns -2147483648 on mine because my max variable is default min value of Integer. It returns -1000000000 as the expected answer. (so problem creator used -1000000000 as default result? : ) )"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "this one is like a sequel to https://leetcode.com/problems/range-sum-query-2d-immutable/"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "since1991sanchit",
                        "content": "# Suggestion for additional tag: Merge Sort "
                    }
                ]
            },
            {
                "id": 1861282,
                "content": [
                    {
                        "username": "galster",
                        "content": "I solved this problem  in C++ just like most other people solved it here, except I started iterating over the rows and performing a one-dimensional binary search on sum of columns. I got a TLE. When I switched between the rows and columns the solution was accepted. This should not be the case. Either the algorithm enforces this on both the rows and columns or it doesnt enforce it at all."
                    },
                    {
                        "username": "FatShibaInu",
                        "content": "My submission failed at the following test case:\\nInput:\\n[[2,2,-1]]\\n2\\nOutput:\\n0\\nExpected:\\n2\\n\\nAs I see it, to make a rectangle with an area>0, the rectangle must have at least two rows and two columns, so this test case should return 0, because it's a straight line with area =0.\\n\\nIf a single element [2] means an area =0, which means as long as the rectangle has elements, its area is greater than 0, then what's the point saying \"The rectangle inside the matrix must have an area > 0\"?\\n\\nAm I misunderstanding something?"
                    },
                    {
                        "username": "Fengster",
                        "content": "So I think another condition that needs to be added is that there must exist a number no greater than k.\\nOtherwise, the only solution is empty matrix, however area must > 0.\\nConsider this test case: [[2]] 1\\nIt returns -2147483648 on mine because my max variable is default min value of Integer. It returns -1000000000 as the expected answer. (so problem creator used -1000000000 as default result? : ) )"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "this one is like a sequel to https://leetcode.com/problems/range-sum-query-2d-immutable/"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "since1991sanchit",
                        "content": "# Suggestion for additional tag: Merge Sort "
                    }
                ]
            },
            {
                "id": 1759629,
                "content": [
                    {
                        "username": "galster",
                        "content": "I solved this problem  in C++ just like most other people solved it here, except I started iterating over the rows and performing a one-dimensional binary search on sum of columns. I got a TLE. When I switched between the rows and columns the solution was accepted. This should not be the case. Either the algorithm enforces this on both the rows and columns or it doesnt enforce it at all."
                    },
                    {
                        "username": "FatShibaInu",
                        "content": "My submission failed at the following test case:\\nInput:\\n[[2,2,-1]]\\n2\\nOutput:\\n0\\nExpected:\\n2\\n\\nAs I see it, to make a rectangle with an area>0, the rectangle must have at least two rows and two columns, so this test case should return 0, because it's a straight line with area =0.\\n\\nIf a single element [2] means an area =0, which means as long as the rectangle has elements, its area is greater than 0, then what's the point saying \"The rectangle inside the matrix must have an area > 0\"?\\n\\nAm I misunderstanding something?"
                    },
                    {
                        "username": "Fengster",
                        "content": "So I think another condition that needs to be added is that there must exist a number no greater than k.\\nOtherwise, the only solution is empty matrix, however area must > 0.\\nConsider this test case: [[2]] 1\\nIt returns -2147483648 on mine because my max variable is default min value of Integer. It returns -1000000000 as the expected answer. (so problem creator used -1000000000 as default result? : ) )"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "this one is like a sequel to https://leetcode.com/problems/range-sum-query-2d-immutable/"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "since1991sanchit",
                        "content": "# Suggestion for additional tag: Merge Sort "
                    }
                ]
            },
            {
                "id": 1713297,
                "content": [
                    {
                        "username": "galster",
                        "content": "I solved this problem  in C++ just like most other people solved it here, except I started iterating over the rows and performing a one-dimensional binary search on sum of columns. I got a TLE. When I switched between the rows and columns the solution was accepted. This should not be the case. Either the algorithm enforces this on both the rows and columns or it doesnt enforce it at all."
                    },
                    {
                        "username": "FatShibaInu",
                        "content": "My submission failed at the following test case:\\nInput:\\n[[2,2,-1]]\\n2\\nOutput:\\n0\\nExpected:\\n2\\n\\nAs I see it, to make a rectangle with an area>0, the rectangle must have at least two rows and two columns, so this test case should return 0, because it's a straight line with area =0.\\n\\nIf a single element [2] means an area =0, which means as long as the rectangle has elements, its area is greater than 0, then what's the point saying \"The rectangle inside the matrix must have an area > 0\"?\\n\\nAm I misunderstanding something?"
                    },
                    {
                        "username": "Fengster",
                        "content": "So I think another condition that needs to be added is that there must exist a number no greater than k.\\nOtherwise, the only solution is empty matrix, however area must > 0.\\nConsider this test case: [[2]] 1\\nIt returns -2147483648 on mine because my max variable is default min value of Integer. It returns -1000000000 as the expected answer. (so problem creator used -1000000000 as default result? : ) )"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "this one is like a sequel to https://leetcode.com/problems/range-sum-query-2d-immutable/"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "since1991sanchit",
                        "content": "# Suggestion for additional tag: Merge Sort "
                    }
                ]
            }
        ]
    }
]